{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.0;\r\n\r\ninterface IMultiSigManager {\r\n\tfunction provideAddress(address origin, uint poolIndex) external returns (address payable);\r\n\tfunction passedContract(address) external returns (bool);\r\n\tfunction moderator() external returns(address);\r\n}\r\n\r\ninterface ICustodianToken {\r\n\tfunction emitTransfer(address from, address to, uint value) external returns (bool success);\r\n}\r\n\r\ninterface IWETH {\r\n\tfunction balanceOf(address) external returns (uint);\r\n\tfunction transfer(address to, uint value) external returns (bool success);\r\n\tfunction transferFrom(address from, address to, uint value) external returns (bool success);\r\n\tfunction approve(address spender, uint value) external returns (bool success);\r\n\tfunction allowance(address owner, address spender) external returns (uint);\r\n\tfunction withdraw(uint value) external;\r\n\tfunction deposit() external;\r\n}\r\n\r\ninterface IOracle {\r\n\tfunction getLastPrice() external returns(uint, uint);\r\n\tfunction started() external returns(bool);\r\n}\r\n\r\nlibrary SafeMath {\r\n\tfunction mul(uint a, uint b) internal pure returns (uint) {\r\n\t\tuint c = a * b;\r\n\t\tassert(a == 0 || c / a == b);\r\n\t\treturn c;\r\n\t}\r\n\r\n\tfunction div(uint a, uint b) internal pure returns (uint) {\r\n\t\t// assert(b > 0); // Solidity automatically throws when dividing by 0\r\n\t\tuint c = a / b;\r\n\t\t// assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\t\treturn c;\r\n\t}\r\n\r\n\tfunction sub(uint a, uint b) internal pure returns (uint) {\r\n\t\tassert(b <= a);\r\n\t\treturn a - b;\r\n\t}\r\n\r\n\tfunction add(uint a, uint b) internal pure returns (uint) {\r\n\t\tuint c = a + b;\r\n\t\tassert(c >= a);\r\n\t\treturn c;\r\n\t}\r\n\r\n\tfunction diff(uint a, uint b) internal pure returns (uint) {\r\n\t\treturn a > b ? sub(a, b) : sub(b, a);\r\n\t}\r\n\r\n\tfunction gt(uint a, uint b) internal pure returns(bytes1) {\r\n\t\tbytes1 c;\r\n\t\tc = 0x00;\r\n\t\tif (a > b) {\r\n\t\t\tc = 0x01;\r\n\t\t}\r\n\t\treturn c;\r\n\t}\r\n}\r\n\r\ncontract Managed {\r\n\tIMultiSigManager roleManager;\r\n\taddress public roleManagerAddress;\r\n\taddress public operator;\r\n\tuint public lastOperationTime;\r\n\tuint public operationCoolDown;\r\n\tuint constant BP_DENOMINATOR = 10000;\r\n\r\n\tevent UpdateRoleManager(address newManagerAddress);\r\n\tevent UpdateOperator(address updater, address newOperator);\r\n\r\n\tmodifier only(address addr) {\r\n\t\trequire(msg.sender == addr);\r\n\t\t_;\r\n\t}\r\n\r\n\tmodifier inUpdateWindow() {\r\n\t\tuint currentTime = getNowTimestamp();\r\n\t\trequire(currentTime - lastOperationTime >= operationCoolDown);\r\n\t\t_;\r\n\t\tlastOperationTime = currentTime;\r\n\t}\r\n\r\n\tconstructor(\r\n\t\taddress roleManagerAddr,\r\n\t\taddress opt, \r\n\t\tuint optCoolDown\r\n\t) public {\r\n\t\troleManagerAddress = roleManagerAddr;\r\n\t\troleManager = IMultiSigManager(roleManagerAddr);\r\n\t\toperator = opt;\r\n\t\toperationCoolDown = optCoolDown;\r\n\t}\r\n\r\n\tfunction updateRoleManager(address newManagerAddr) \r\n\t\tinUpdateWindow() \r\n\t\tpublic \r\n\treturns (bool) {\r\n\t\trequire(roleManager.passedContract(newManagerAddr));\r\n\t\troleManagerAddress = newManagerAddr;\r\n\t\troleManager = IMultiSigManager(roleManagerAddress);\r\n\t\trequire(roleManager.moderator() != address(0));\r\n\t\temit UpdateRoleManager(newManagerAddr);\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction updateOperator() public inUpdateWindow() returns (bool) {\t\r\n\t\taddress updater = msg.sender;\t\r\n\t\toperator = roleManager.provideAddress(updater, 0);\r\n\t\temit UpdateOperator(updater, operator);\t\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction getNowTimestamp() internal view returns (uint) {\r\n\t\treturn now;\r\n\t}\r\n}\r\n\r\n/// @title Custodian - every derivative contract should has basic custodian properties\r\n/// @author duo.network\r\ncontract Custodian is Managed {\r\n\tusing SafeMath for uint;\r\n\r\n\t/*\r\n     * Constants\r\n     */\r\n\tuint constant decimals = 18;\r\n\tuint constant WEI_DENOMINATOR = 1000000000000000000;\r\n\tenum State {\r\n\t\tInception,\r\n\t\tTrading,\r\n\t\tPreReset,\r\n\t\tReset,\r\n\t\tMatured\r\n\t}\r\n\r\n\t/*\r\n     * Storage\r\n     */\r\n\tIOracle oracle;\r\n\tICustodianToken aToken;\r\n\tICustodianToken bToken;\r\n\tstring public contractCode;\r\n\taddress payable feeCollector;\r\n\taddress oracleAddress;\r\n\taddress aTokenAddress;\r\n\taddress bTokenAddress;\r\n\tmapping(address => uint)[2] public balanceOf;\r\n\tmapping (address => mapping (address => uint))[2] public allowance;\r\n\taddress[] public users;\r\n\tmapping (address => uint) public existingUsers;\r\n\tState state;\r\n\tuint minBalance = 10000000000000000; // set at constructor\r\n\tuint public totalSupplyA;\r\n\tuint public totalSupplyB;\r\n\tuint ethCollateralInWei;\r\n\tuint navAInWei;\r\n\tuint navBInWei;\r\n\tuint lastPriceInWei;\r\n\tuint lastPriceTimeInSecond;\r\n\tuint resetPriceInWei;\r\n\tuint resetPriceTimeInSecond;\r\n\tuint createCommInBP;\r\n\tuint redeemCommInBP;\r\n\tuint period;\r\n\tuint maturityInSecond; // set to 0 for perpetuals\r\n\tuint preResetWaitingBlocks;\r\n\tuint priceFetchCoolDown;\r\n\t\r\n\t// cycle state variables\r\n\tuint lastPreResetBlockNo = 0;\r\n\tuint nextResetAddrIndex;\r\n\r\n\t/*\r\n     *  Modifiers\r\n     */\r\n\tmodifier inState(State _state) {\r\n\t\trequire(state == _state);\r\n\t\t_;\r\n\t}\r\n\r\n\t/*\r\n     *  Events\r\n     */\r\n\tevent StartTrading(uint navAInWei, uint navBInWei);\r\n\tevent StartPreReset();\r\n\tevent StartReset(uint nextIndex, uint total);\r\n\tevent Matured(uint navAInWei, uint navBInWei);\r\n\tevent AcceptPrice(uint indexed priceInWei, uint indexed timeInSecond, uint navAInWei, uint navBInWei);\r\n\tevent Create(address indexed sender, uint ethAmtInWei, uint tokenAInWei, uint tokenBInWei, uint feeInWei);\r\n\tevent Redeem(address indexed sender, uint ethAmtInWei, uint tokenAInWei, uint tokenBInWei, uint feeInWei);\r\n\tevent TotalSupply(uint totalSupplyAInWei, uint totalSupplyBInWei);\r\n\t// token events\r\n\tevent Transfer(address indexed from, address indexed to, uint value, uint index);\r\n\tevent Approval(address indexed tokenOwner, address indexed spender, uint tokens, uint index);\r\n\t// operation events\r\n\tevent CollectFee(address addr, uint feeInWei, uint feeBalanceInWei);\r\n\tevent UpdateOracle(address newOracleAddress);\r\n\tevent UpdateFeeCollector(address updater, address newFeeCollector);\r\n\r\n\t/*\r\n     *  Constructor\r\n     */\r\n\t/// @dev Contract constructor sets operation cool down and set address pool status.\r\n\t///\t@param code contract name\r\n\t///\t@param maturity marutiry time in second\r\n\t///\t@param roleManagerAddr roleManagerContract Address\r\n\t///\t@param fc feeCollector address\r\n\t///\t@param comm commission rate\r\n\t///\t@param pd period\r\n\t///\t@param preResetWaitBlk pre reset waiting block numbers\r\n\t///\t@param pxFetchCoolDown price fetching cool down\r\n\t///\t@param opt operator\r\n\t///\t@param optCoolDown operation cooldown\r\n\t///\t@param minimumBalance niminum balance required\r\n\tconstructor(\r\n\t\tstring memory code,\r\n\t\tuint maturity,\r\n\t\taddress roleManagerAddr,\r\n\t\taddress payable fc,\r\n\t\tuint comm,\r\n\t\tuint pd,\r\n\t\tuint preResetWaitBlk, \r\n\t\tuint pxFetchCoolDown,\r\n\t\taddress opt,\r\n\t\tuint optCoolDown,\r\n\t\tuint minimumBalance\r\n\t\t) \r\n\t\tpublic\r\n\t\tManaged(roleManagerAddr, opt, optCoolDown) \r\n\t{\r\n\t\tcontractCode = code;\r\n\t\tmaturityInSecond = maturity;\r\n\t\tstate = State.Inception;\r\n\t\tfeeCollector = fc;\r\n\t\tcreateCommInBP = comm;\r\n\t\tredeemCommInBP = comm;\r\n\t\tperiod = pd;\r\n\t\tpreResetWaitingBlocks = preResetWaitBlk;\r\n\t\tpriceFetchCoolDown = pxFetchCoolDown;\r\n\t\tnavAInWei = WEI_DENOMINATOR;\r\n\t\tnavBInWei = WEI_DENOMINATOR;\r\n\t\tminBalance = minimumBalance;\r\n\t}\r\n\r\n\t/*\r\n     * Public functions\r\n     */\r\n\r\n\t/// @dev return totalUsers in the system.\r\n\tfunction totalUsers() public view returns (uint) {\r\n\t\treturn users.length;\r\n\t}\r\n\r\n\tfunction feeBalanceInWei() public view returns(uint) {\r\n\t\treturn address(this).balance.sub(ethCollateralInWei);\r\n\t}\r\n\r\n\t/*\r\n     * ERC token functions\r\n     */\r\n\t/// @dev transferInternal function.\r\n\t/// @param index 0 is classA , 1 is class B\r\n\t/// @param from  from address\r\n\t/// @param to   to address\r\n\t/// @param tokens num of tokens transferred\r\n\tfunction transferInternal(uint index, address from, address to, uint tokens) \r\n\t\tinternal \r\n\t\tinState(State.Trading)\r\n\t\treturns (bool success) \r\n\t{\r\n\t\t// Prevent transfer to 0x0 address. Use burn() instead\r\n\t\trequire(to != address(0));\r\n\t\t// Check if the sender has enough\r\n\t\trequire(balanceOf[index][from] >= tokens);\r\n\r\n\t\t// Save this for an assertion in the future\r\n\t\tuint previousBalances = balanceOf[index][from].add(balanceOf[index][to]);\r\n\t\t// Subtract from the sender\r\n\t\tbalanceOf[index][from] = balanceOf[index][from].sub(tokens);\r\n\t\t// Add the same to the recipient\r\n\t\tbalanceOf[index][to] = balanceOf[index][to].add(tokens);\r\n\t\r\n\t\t// Asserts are used to use static analysis to find bugs in your code. They should never fail\r\n\t\tassert(balanceOf[index][from].add(balanceOf[index][to]) == previousBalances);\r\n\t\temit Transfer(from, to, tokens, index);\r\n\t\tcheckUser(from, balanceOf[index][from], balanceOf[1 - index][from]);\r\n\t\tcheckUser(to, balanceOf[index][to], balanceOf[1 - index][to]);\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction determineAddress(uint index, address from) internal view returns (address) {\r\n\t\treturn index == 0 && msg.sender == aTokenAddress || \r\n\t\t\tindex == 1 && msg.sender == bTokenAddress \r\n\t\t\t? from : msg.sender;\r\n\t}\r\n\r\n\tfunction transfer(uint index, address from, address to, uint tokens)\r\n\t\tpublic\r\n\t\tinState(State.Trading)\r\n\t\treturns (bool success) \r\n\t{\r\n\t\trequire(index == 0 || index == 1);\r\n\t\treturn transferInternal(index, determineAddress(index, from), to, tokens);\r\n\t}\r\n\r\n\tfunction transferFrom(uint index, address spender, address from, address to, uint tokens) \r\n\t\tpublic \r\n\t\tinState(State.Trading)\r\n\t\treturns (bool success) \r\n\t{\r\n\t\trequire(index == 0 || index == 1);\r\n\t\taddress spenderToUse = determineAddress(index, spender);\r\n\t\trequire(tokens <= allowance[index][from][spenderToUse]);\t // Check allowance\r\n\t\tallowance[index][from][spenderToUse] = allowance[index][from][spenderToUse].sub(tokens);\r\n\t\treturn transferInternal(index, from, to, tokens);\r\n\t}\r\n\r\n\tfunction approve(uint index, address sender, address spender, uint tokens) \r\n\t\tpublic \r\n\t\treturns (bool success) \r\n\t{\r\n\t\trequire(index == 0 || index == 1);\r\n\t\taddress senderToUse = determineAddress(index, sender);\r\n\t\tallowance[index][senderToUse][spender] = tokens;\r\n\t\temit Approval(senderToUse, spender, tokens, index);\r\n\t\treturn true;\r\n\t}\r\n\t// end of token functions\r\n\r\n\t/*\r\n     * Internal Functions\r\n     */\r\n\t// start of internal utility functions\r\n\tfunction checkUser(address user, uint256 balanceA, uint256 balanceB) internal {\r\n\t\tuint userIdx = existingUsers[user];\r\n\t\tif ( userIdx > 0) {\r\n\t\t\tif (balanceA < minBalance && balanceB < minBalance) {\r\n\t\t\t\tuint lastIdx = users.length;\r\n\t\t\t\taddress lastUser = users[lastIdx - 1];\r\n\t\t\t\tif (userIdx < lastIdx) {\r\n\t\t\t\t\tusers[userIdx - 1] = lastUser;\r\n\t\t\t\t\texistingUsers[lastUser] = userIdx;\r\n\t\t\t\t}\r\n\t\t\t\tdelete users[lastIdx - 1];\r\n\t\t\t\texistingUsers[user] = 0;\r\n\t\t\t\tusers.length--;\t\t\t\t\t\r\n\t\t\t}\r\n\t\t} else if (balanceA >= minBalance || balanceB >= minBalance) {\r\n\t\t\tusers.push(user);\r\n\t\t\texistingUsers[user] = users.length;\r\n\t\t}\r\n\t}\r\n\t// end of internal utility functions\r\n\r\n\t/*\r\n     * Operation Functions\r\n     */\r\n\tfunction collectFee(uint amountInWei) \r\n\t\tpublic \r\n\t\tonly(feeCollector) \r\n\t\tinState(State.Trading) \r\n\t\treturns (bool success) \r\n\t{\r\n\t\tuint feeBalance = feeBalanceInWei().sub(amountInWei);\r\n\t\tfeeCollector.transfer(amountInWei);\r\n\t\temit CollectFee(feeCollector, amountInWei, feeBalance);\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction updateOracle(address newOracleAddr) \r\n\t\tonly(roleManager.moderator())\r\n\t\tinUpdateWindow() \r\n\t\tpublic \r\n\treturns (bool) {\r\n\t\trequire(roleManager.passedContract(newOracleAddr));\r\n\t\toracleAddress = newOracleAddr;\r\n\t\toracle = IOracle(oracleAddress);\r\n\t\t(uint lastPrice, uint lastPriceTime) = oracle.getLastPrice();\r\n\t\trequire(lastPrice > 0 && lastPriceTime > 0);\r\n\t\temit UpdateOracle(newOracleAddr);\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction updateFeeCollector() \r\n\t\tpublic \r\n\t\tinUpdateWindow() \r\n\treturns (bool) {\r\n\t\taddress updater = msg.sender;\r\n\t\tfeeCollector = roleManager.provideAddress(updater, 0);\r\n\t\temit UpdateFeeCollector(updater, feeCollector);\r\n\t\treturn true;\r\n\t}\r\n}\r\n\r\n/// @title DualClassCustodian - dual class token contract\r\n/// @author duo.network\r\ncontract DualClassCustodian is Custodian {\r\n\t/*\r\n     * Storage\r\n     */\r\n\r\n\tuint alphaInBP;\r\n\tuint betaInWei;\r\n\tuint limitUpperInWei; \r\n\tuint limitLowerInWei;\r\n\tuint iterationGasThreshold;\r\n\tuint periodCouponInWei; \r\n\tuint limitPeriodicInWei; \r\n\r\n\t// reset intermediate values\r\n\tuint newAFromAPerA;\r\n\tuint newAFromBPerB;\r\n\tuint newBFromAPerA;\r\n\tuint newBFromBPerB;\r\n\r\n\tenum ResetState {\r\n\t\tUpwardReset,\r\n\t\tDownwardReset,\r\n\t\tPeriodicReset\r\n\t}\r\n\r\n\tResetState resetState;\r\n\r\n\t/*\r\n     * Events\r\n     */\r\n\tevent SetValue(uint index, uint oldValue, uint newValue);\r\n\r\n\tfunction() external payable {}\r\n\t\r\n\t/*\r\n     * Constructor\r\n     */\r\n\tconstructor(\r\n\t\tstring memory code,\r\n\t\tuint maturity,\r\n\t\taddress roleManagerAddr,\r\n\t\taddress payable fc,\r\n\t\tuint alpha,\r\n\t\tuint r,\r\n\t\tuint hp,\r\n\t\tuint hu,\r\n\t\tuint hd,\r\n\t\tuint comm,\r\n\t\tuint pd,\r\n\t\tuint optCoolDown,\r\n\t\tuint pxFetchCoolDown,\r\n\t\tuint iteGasTh,\r\n\t\tuint preResetWaitBlk,\r\n\t\tuint minimumBalance\r\n\t\t) \r\n\t\tpublic \r\n\t\tCustodian ( \r\n\t\tcode,\r\n\t\tmaturity,\r\n\t\troleManagerAddr,\r\n\t\tfc,\r\n\t\tcomm,\r\n\t\tpd,\r\n\t\tpreResetWaitBlk, \r\n\t\tpxFetchCoolDown,\r\n\t\tmsg.sender,\r\n\t\toptCoolDown,\r\n\t\tminimumBalance\r\n\t\t)\r\n\t{\r\n\t\talphaInBP = alpha;\r\n\t\tbetaInWei = WEI_DENOMINATOR;\r\n\t\tperiodCouponInWei = r;\r\n\t\tlimitPeriodicInWei = hp;\r\n\t\tlimitUpperInWei = hu; \r\n\t\tlimitLowerInWei = hd;\r\n\t\titerationGasThreshold = iteGasTh; // 65000;\r\n\t}\r\n\r\n\r\n\t/*\r\n     * Public Functions\r\n     */\r\n\t/// @dev startCustodian\r\n\t///\t@param aAddr contract address of Class A\r\n\t///\t@param bAddr contract address of Class B\r\n\t///\t@param oracleAddr contract address of Oracle\r\n\tfunction startCustodian(\r\n\t\taddress aAddr,\r\n\t\taddress bAddr,\r\n\t\taddress oracleAddr\r\n\t\t) \r\n\t\tpublic \r\n\t\tinState(State.Inception) \r\n\t\tonly(operator)\r\n\t\treturns (bool success) \r\n\t{\t\r\n\t\taTokenAddress = aAddr;\r\n\t\taToken = ICustodianToken(aTokenAddress);\r\n\t\tbTokenAddress = bAddr;\r\n\t\tbToken = ICustodianToken(bTokenAddress);\r\n\t\toracleAddress = oracleAddr;\r\n\t\toracle = IOracle(oracleAddress);\r\n\t\t(uint priceInWei, uint timeInSecond) = oracle.getLastPrice();\r\n\t\trequire(priceInWei > 0 && timeInSecond > 0);\r\n\t\tlastPriceInWei = priceInWei;\r\n\t\tlastPriceTimeInSecond = timeInSecond;\r\n\t\tresetPriceInWei = priceInWei;\r\n\t\tresetPriceTimeInSecond = timeInSecond;\r\n\t\troleManager = IMultiSigManager(roleManagerAddress);\r\n\t\tstate = State.Trading;\r\n\t\temit AcceptPrice(priceInWei, timeInSecond, WEI_DENOMINATOR, WEI_DENOMINATOR);\r\n\t\temit StartTrading(navAInWei, navBInWei);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/// @dev create with ETH\r\n\tfunction create() \r\n\t\tpublic \r\n\t\tpayable \r\n\t\tinState(State.Trading) \r\n\t\treturns (bool) \r\n\t{\t\r\n\t\treturn createInternal(msg.sender, msg.value);\r\n\t}\r\n\r\n\t/// @dev create with ETH\r\n\t///\t@param amount amount of WETH to create\r\n\t///\t@param wethAddr wrapEth contract address\r\n\tfunction createWithWETH(uint amount, address wethAddr)\r\n\t\tpublic \r\n\t\tinState(State.Trading) \r\n\t\treturns (bool success) \r\n\t{\r\n\t\trequire(amount > 0 && wethAddr != address(0));\r\n\t\tIWETH wethToken = IWETH(wethAddr);\r\n\t\twethToken.transferFrom(msg.sender, address(this), amount);\r\n\t\tuint wethBalance = wethToken.balanceOf(address(this));\r\n\t\trequire(wethBalance >= amount);\r\n\t\tuint beforeEthBalance = address(this).balance;\r\n        wethToken.withdraw(wethBalance);\r\n\t\tuint ethIncrement = address(this).balance.sub(beforeEthBalance);\r\n\t\trequire(ethIncrement >= wethBalance);\r\n\t\treturn createInternal(msg.sender, amount);\r\n\t}\r\n\r\n\tfunction createInternal(address sender, uint ethAmtInWei) \r\n\t\tinternal \r\n\t\treturns(bool)\r\n\t{\r\n\t\trequire(ethAmtInWei > 0);\r\n\t\tuint feeInWei;\r\n\t\t(ethAmtInWei, feeInWei) = deductFee(ethAmtInWei, createCommInBP);\r\n\t\tethCollateralInWei = ethCollateralInWei.add(ethAmtInWei);\r\n\t\tuint numeritor = ethAmtInWei\r\n\t\t\t\t\t\t.mul(resetPriceInWei)\r\n\t\t\t\t\t\t.mul(betaInWei)\r\n\t\t\t\t\t\t.mul(BP_DENOMINATOR\r\n\t\t);\r\n\t\tuint denominator = WEI_DENOMINATOR\r\n\t\t\t\t\t\t.mul(WEI_DENOMINATOR)\r\n\t\t\t\t\t\t.mul(alphaInBP\r\n\t\t\t\t\t\t\t.add(BP_DENOMINATOR)\r\n\t\t);\r\n\t\tuint tokenValueB = numeritor.div(denominator);\r\n\t\tuint tokenValueA = tokenValueB.mul(alphaInBP).div(BP_DENOMINATOR);\r\n\t\tbalanceOf[0][sender] = balanceOf[0][sender].add(tokenValueA);\r\n\t\tbalanceOf[1][sender] = balanceOf[1][sender].add(tokenValueB);\r\n\t\tcheckUser(sender, balanceOf[0][sender], balanceOf[1][sender]);\r\n\t\ttotalSupplyA = totalSupplyA.add(tokenValueA);\r\n\t\ttotalSupplyB = totalSupplyB.add(tokenValueB);\r\n\r\n\t\temit Create(\r\n\t\t\tsender, \r\n\t\t\tethAmtInWei, \r\n\t\t\ttokenValueA, \r\n\t\t\ttokenValueB, \r\n\t\t\tfeeInWei\r\n\t\t\t);\r\n\t\temit TotalSupply(totalSupplyA, totalSupplyB);\r\n\t\taToken.emitTransfer(address(0), sender, tokenValueA);\r\n\t\tbToken.emitTransfer(address(0), sender, tokenValueB);\r\n\t\treturn true;\r\n\r\n\t}\r\n\r\n\tfunction redeem(uint amtInWeiA, uint amtInWeiB) \r\n\t\tpublic \r\n\t\tinState(State.Trading) \r\n\t\treturns (bool success) \r\n\t{\r\n\t\tuint adjAmtInWeiA = amtInWeiA.mul(BP_DENOMINATOR).div(alphaInBP);\r\n\t\tuint deductAmtInWeiB = adjAmtInWeiA < amtInWeiB ? adjAmtInWeiA : amtInWeiB;\r\n\t\tuint deductAmtInWeiA = deductAmtInWeiB.mul(alphaInBP).div(BP_DENOMINATOR);\r\n\t\taddress payable sender = msg.sender;\r\n\t\trequire(balanceOf[0][sender] >= deductAmtInWeiA && balanceOf[1][sender] >= deductAmtInWeiB);\r\n\t\tuint ethAmtInWei = deductAmtInWeiA\r\n\t\t\t.add(deductAmtInWeiB)\r\n\t\t\t.mul(WEI_DENOMINATOR)\r\n\t\t\t.mul(WEI_DENOMINATOR)\r\n\t\t\t.div(resetPriceInWei)\r\n\t\t\t.div(betaInWei);\r\n\t\treturn redeemInternal(sender, ethAmtInWei, deductAmtInWeiA, deductAmtInWeiB);\r\n\t}\r\n\r\n\tfunction redeemAll() public inState(State.Matured) returns (bool success) {\r\n\t\taddress payable sender = msg.sender;\r\n\t\tuint balanceAInWei = balanceOf[0][sender];\r\n\t\tuint balanceBInWei = balanceOf[1][sender];\r\n\t\trequire(balanceAInWei > 0 || balanceBInWei > 0);\r\n\t\tuint ethAmtInWei = balanceAInWei\r\n\t\t\t.mul(navAInWei)\r\n\t\t\t.add(balanceBInWei\r\n\t\t\t\t.mul(navBInWei))\r\n\t\t\t.div(lastPriceInWei);\r\n\t\treturn redeemInternal(sender, ethAmtInWei, balanceAInWei, balanceBInWei);\r\n\t}\r\n\r\n\tfunction redeemInternal(\r\n\t\taddress payable sender, \r\n\t\tuint ethAmtInWei, \r\n\t\tuint deductAmtInWeiA, \r\n\t\tuint deductAmtInWeiB) \r\n\t\tinternal \r\n\t\treturns(bool) \r\n\t{\r\n\t\trequire(ethAmtInWei > 0);\r\n\t\tethCollateralInWei = ethCollateralInWei.sub(ethAmtInWei);\r\n\t\tuint feeInWei;\r\n\t\t(ethAmtInWei,  feeInWei) = deductFee(ethAmtInWei, redeemCommInBP);\r\n\r\n\t\tbalanceOf[0][sender] = balanceOf[0][sender].sub(deductAmtInWeiA);\r\n\t\tbalanceOf[1][sender] = balanceOf[1][sender].sub(deductAmtInWeiB);\r\n\t\tcheckUser(sender, balanceOf[0][sender], balanceOf[1][sender]);\r\n\t\ttotalSupplyA = totalSupplyA.sub(deductAmtInWeiA);\r\n\t\ttotalSupplyB = totalSupplyB.sub(deductAmtInWeiB);\r\n\t\tsender.transfer(ethAmtInWei);\r\n\t\temit Redeem(\r\n\t\t\tsender, \r\n\t\t\tethAmtInWei, \r\n\t\t\tdeductAmtInWeiA, \r\n\t\t\tdeductAmtInWeiB, \r\n\t\t\tfeeInWei\r\n\t\t);\r\n\t\temit TotalSupply(totalSupplyA, totalSupplyB);\r\n\t\taToken.emitTransfer(sender, address(0), deductAmtInWeiA);\r\n\t\tbToken.emitTransfer(sender, address(0), deductAmtInWeiB);\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction deductFee(\r\n\t\tuint ethAmtInWei, \r\n\t\tuint commInBP\r\n\t) \r\n\t\tinternal pure\r\n\t\treturns (\r\n\t\t\tuint ethAmtAfterFeeInWei, \r\n\t\t\tuint feeInWei) \r\n\t{\r\n\t\trequire(ethAmtInWei > 0);\r\n\t\tfeeInWei = ethAmtInWei.mul(commInBP).div(BP_DENOMINATOR);\r\n\t\tethAmtAfterFeeInWei = ethAmtInWei.sub(feeInWei);\r\n\t}\r\n\t// end of conversion\r\n\r\n\r\n\t// start of operator functions\r\n\tfunction setValue(uint idx, uint newValue) public only(operator) inState(State.Trading) inUpdateWindow() returns (bool success) {\r\n\t\tuint oldValue;\r\n\t\tif (idx == 0) {\r\n\t\t\trequire(newValue <= BP_DENOMINATOR);\r\n\t\t\toldValue = createCommInBP;\r\n\t\t\tcreateCommInBP = newValue;\r\n\t\t} else if (idx == 1) {\r\n\t\t\trequire(newValue <= BP_DENOMINATOR);\r\n\t\t\toldValue = redeemCommInBP;\r\n\t\t\tredeemCommInBP = newValue;\r\n\t\t} else if (idx == 2) {\r\n\t\t\toldValue = iterationGasThreshold;\r\n\t\t\titerationGasThreshold = newValue;\r\n\t\t} else if (idx == 3) {\r\n\t\t\toldValue = preResetWaitingBlocks;\r\n\t\t\tpreResetWaitingBlocks = newValue;\r\n\t\t} else {\r\n\t\t\trevert();\r\n\t\t}\r\n\r\n\t\temit SetValue(idx, oldValue, newValue);\r\n\t\treturn true;\r\n\t}\r\n\t// end of operator functions\r\n\r\n\tfunction getStates() public view returns (uint[30] memory) {\r\n\t\treturn [\r\n\t\t\t// managed\r\n\t\t\tlastOperationTime,\r\n\t\t\toperationCoolDown,\r\n\t\t\t// custodian\r\n\t\t\tuint(state),\r\n\t\t\tminBalance,\r\n\t\t\ttotalSupplyA,\r\n\t\t\ttotalSupplyB,\r\n\t\t\tethCollateralInWei,\r\n\t\t\tnavAInWei,\r\n\t\t\tnavBInWei,\r\n\t\t\tlastPriceInWei,\r\n\t\t\tlastPriceTimeInSecond,\r\n\t\t\tresetPriceInWei,\r\n\t\t\tresetPriceTimeInSecond,\r\n\t\t\tcreateCommInBP,\r\n\t\t\tredeemCommInBP,\r\n\t\t\tperiod,\r\n\t\t\tmaturityInSecond,\r\n\t\t\tpreResetWaitingBlocks,\r\n\t\t\tpriceFetchCoolDown,\r\n\t\t\tnextResetAddrIndex,\r\n\t\t\ttotalUsers(),\r\n\t\t\tfeeBalanceInWei(),\r\n\t\t\t// dual class custodian\r\n\t\t\tuint(resetState),\r\n\t\t\talphaInBP,\r\n\t\t\tbetaInWei,\r\n\t\t\tperiodCouponInWei, \r\n\t\t\tlimitPeriodicInWei, \r\n\t\t\tlimitUpperInWei, \r\n\t\t\tlimitLowerInWei,\r\n\t\t\titerationGasThreshold\r\n\t\t];\r\n\t}\r\n\r\n\tfunction getAddresses() public view returns (address[6] memory) {\r\n\t\treturn [\r\n\t\t\troleManagerAddress,\r\n\t\t\toperator,\r\n\t\t\tfeeCollector,\r\n\t\t\toracleAddress,\r\n\t\t\taTokenAddress,\r\n\t\t\tbTokenAddress\r\n\t\t];\r\n\t}\r\n}\r\n\r\n\r\n/// @title Mozart - short & long token contract\r\n/// @author duo.network\r\ncontract Mozart is DualClassCustodian {\r\n\t/*\r\n     * Constructor\r\n     */\r\n\tconstructor(\r\n\t\tstring memory code,\r\n\t\tuint maturity,\r\n\t\taddress roleManagerAddr,\r\n\t\taddress payable fc,\r\n\t\tuint alpha,\r\n\t\tuint hu,\r\n\t\tuint hd,\r\n\t\tuint comm,\r\n\t\tuint pd,\r\n\t\tuint optCoolDown,\r\n\t\tuint pxFetchCoolDown,\r\n\t\tuint iteGasTh,\r\n\t\tuint preResetWaitBlk,\r\n\t\tuint minimumBalance\r\n\t\t) \r\n\t\tpublic \r\n\t\tDualClassCustodian ( \r\n\t\t\tcode,\r\n\t\t\tmaturity,\r\n\t\t\troleManagerAddr,\r\n\t\t\tfc,\r\n\t\t\talpha,\r\n\t\t\t0,\r\n\t\t\t0,\r\n\t\t\thu,\r\n\t\t\thd,\r\n\t\t\tcomm,\r\n\t\t\tpd,\r\n\t\t\toptCoolDown,\r\n\t\t\tpxFetchCoolDown,\r\n\t\t\titeGasTh,\r\n\t\t\tpreResetWaitBlk,\r\n\t\t\tminimumBalance\r\n\t\t)\r\n\t{\r\n\t}\r\n\r\n\t// start of priceFetch funciton\r\n\tfunction fetchPrice() public inState(State.Trading) returns (bool) {\r\n\t\tuint currentTime = getNowTimestamp();\r\n\t\trequire(currentTime > lastPriceTimeInSecond.add(priceFetchCoolDown));\r\n\t\t(uint priceInWei, uint timeInSecond) = oracle.getLastPrice();\r\n\t\trequire(timeInSecond > lastPriceTimeInSecond && timeInSecond <= currentTime && priceInWei > 0);\r\n\t\tlastPriceInWei = priceInWei;\r\n\t\tlastPriceTimeInSecond = timeInSecond;\r\n\t\t(navAInWei, navBInWei) = calculateNav(\r\n\t\t\tpriceInWei, \r\n\t\t\tresetPriceInWei \r\n\t\t\t);\r\n\t\tif (maturityInSecond > 0 && timeInSecond > maturityInSecond) {\r\n\t\t\tstate = State.Matured;\r\n\t\t\temit Matured(navAInWei, navBInWei);\r\n\t\t} else if (navBInWei >= limitUpperInWei || navBInWei <= limitLowerInWei) {\r\n\t\t\tstate = State.PreReset;\r\n\t\t\tlastPreResetBlockNo = block.number;\r\n\t\t\temit StartPreReset();\r\n\t\t} \r\n\t\temit AcceptPrice(priceInWei, timeInSecond, navAInWei, navBInWei);\r\n\t\treturn true;\r\n\t}\r\n\t\r\n\tfunction calculateNav(\r\n\t\tuint priceInWei, \r\n\t\tuint rstPriceInWei\r\n\t\t) \r\n\t\tinternal \r\n\t\tview \r\n\t\treturns (uint, uint) \r\n\t{\r\n\t\tuint navEthInWei = priceInWei.mul(WEI_DENOMINATOR).div(rstPriceInWei);\r\n\t\t\r\n\t\tuint navParentInWei = navEthInWei\r\n\t\t\t.mul(alphaInBP\r\n\t\t\t\t.add(BP_DENOMINATOR))\r\n\t\t\t.div(BP_DENOMINATOR);\r\n\t\t\r\n\t\tif(navEthInWei >= WEI_DENOMINATOR.mul(2)) {\r\n\t\t\treturn (0, navParentInWei);\r\n\t\t}\r\n\r\n\t\tif(navEthInWei <= WEI_DENOMINATOR\r\n\t\t\t.mul(2)\r\n\t\t\t.mul(alphaInBP)\r\n\t\t\t.div(alphaInBP\r\n\t\t\t\t.mul(2)\r\n\t\t\t\t.add(BP_DENOMINATOR)\r\n\t\t\t)\r\n\t\t) {\r\n\t\t\treturn (navParentInWei.mul(BP_DENOMINATOR).div(alphaInBP), 0);\r\n\t\t}\r\n\t\tuint navA = WEI_DENOMINATOR.mul(2).sub(navEthInWei);\r\n\t\tuint navB = navEthInWei\r\n\t\t\t.mul(alphaInBP\r\n\t\t\t\t.mul(2)\r\n\t\t\t\t.add(BP_DENOMINATOR))\r\n\t\t\t.sub(WEI_DENOMINATOR\r\n\t\t\t\t.mul(alphaInBP)\r\n\t\t\t\t.mul(2))\r\n\t\t\t.div(BP_DENOMINATOR);\r\n\t\treturn (navA, navB);\r\n\t}\r\n\t// end of priceFetch function\r\n\r\n\t// start of reset function\r\n\tfunction startPreReset() public inState(State.PreReset) returns (bool success) {\r\n\t\tif (block.number - lastPreResetBlockNo >= preResetWaitingBlocks) {\r\n\t\t\tstate = State.Reset;\r\n\t\t\tif (navBInWei >= limitUpperInWei) {\r\n\t\t\t\tresetState = ResetState.UpwardReset;\r\n\t\t\t\tnewAFromAPerA = 0;\r\n\t\t\t\tnewBFromAPerA = 0;\r\n\t\t\t\tuint excessBInWei = navBInWei.sub(navAInWei);\r\n\t\t\t\tnewBFromBPerB = excessBInWei.mul(BP_DENOMINATOR).div(BP_DENOMINATOR.add(alphaInBP));\r\n\t\t\t\tnewAFromBPerB = newBFromBPerB.mul(alphaInBP).div(BP_DENOMINATOR);\r\n\t\t\t\t// adjust total supply\r\n\t\t\t\ttotalSupplyA = totalSupplyA.mul(navAInWei).div(WEI_DENOMINATOR).add(totalSupplyB.mul(newAFromBPerB).div(WEI_DENOMINATOR));\r\n\t\t\t\ttotalSupplyB = totalSupplyB.mul(navAInWei).div(WEI_DENOMINATOR).add(totalSupplyB.mul(newBFromBPerB).div(WEI_DENOMINATOR));\r\n\t\t\t} else {\r\n\t\t\t\tresetState = ResetState.DownwardReset;\r\n\t\t\t\tnewAFromBPerB = 0;\r\n\t\t\t\tnewBFromBPerB = 0;\r\n\t\t\t\tuint excessAInWei = navAInWei.sub(navBInWei);\r\n\t\t\t\tnewBFromAPerA = excessAInWei.mul(BP_DENOMINATOR).div(BP_DENOMINATOR.add(alphaInBP));\r\n\t\t\t\tnewAFromAPerA = newBFromAPerA.mul(alphaInBP).div(BP_DENOMINATOR);\r\n\t\t\t\ttotalSupplyB = totalSupplyB.mul(navBInWei).div(WEI_DENOMINATOR).add(totalSupplyA.mul(newBFromAPerA).div(WEI_DENOMINATOR));\r\n\t\t\t\ttotalSupplyA = totalSupplyA.mul(navBInWei).div(WEI_DENOMINATOR).add(totalSupplyA.mul(newAFromAPerA).div(WEI_DENOMINATOR));\r\n\t\t\t} \r\n\r\n\t\t\temit TotalSupply(totalSupplyA, totalSupplyB);\r\n\t\t\temit StartReset(nextResetAddrIndex, users.length);\r\n\t\t} else \r\n\t\t\temit StartPreReset();\r\n\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction startReset() public inState(State.Reset) returns (bool success) {\r\n\t\tuint currentBalanceA;\r\n\t\tuint currentBalanceB;\r\n\t\tuint newBalanceA;\r\n\t\tuint newBalanceB;\r\n\t\tuint newAFromA;\r\n\t\tuint newBFromA;\r\n\t\tuint newBFromB;\r\n\t\tuint newAFromB;\r\n\t\taddress currentAddress;\r\n\t\tuint localResetAddrIndex = nextResetAddrIndex;\r\n\t\twhile (localResetAddrIndex < users.length && gasleft() > iterationGasThreshold) {\r\n\t\t\tcurrentAddress = users[localResetAddrIndex];\r\n\t\t\tcurrentBalanceA = balanceOf[0][currentAddress];\r\n\t\t\tcurrentBalanceB = balanceOf[1][currentAddress];\r\n\t\t\tif (resetState == ResetState.DownwardReset) {\r\n\t\t\t\tnewBFromA = currentBalanceA.mul(newBFromAPerA).div(WEI_DENOMINATOR);\r\n\t\t\t\tnewAFromA = newBFromA.mul(alphaInBP).div(BP_DENOMINATOR);\r\n\t\t\t\tnewBalanceA = currentBalanceA.mul(navBInWei).div(WEI_DENOMINATOR).add(newAFromA);\r\n\t\t\t\tnewBalanceB = currentBalanceB.mul(navBInWei).div(WEI_DENOMINATOR).add(newBFromA);\r\n\t\t\t} else {\r\n\t\t\t\tnewBFromB = currentBalanceB.mul(newBFromBPerB).div(WEI_DENOMINATOR);\r\n\t\t\t\tnewAFromB = newBFromB.mul(alphaInBP).div(BP_DENOMINATOR);\r\n\t\t\t\tnewBalanceA = currentBalanceA.mul(navAInWei).div(WEI_DENOMINATOR).add(newAFromB);\r\n\t\t\t\tnewBalanceB = currentBalanceB.mul(navAInWei).div(WEI_DENOMINATOR).add(newBFromB);\r\n\t\t\t}\r\n\r\n\t\t\tbalanceOf[0][currentAddress] = newBalanceA;\r\n\t\t\tbalanceOf[1][currentAddress] = newBalanceB;\r\n\t\t\tlocalResetAddrIndex++;\r\n\t\t}\r\n\r\n\t\tif (localResetAddrIndex >= users.length) {\r\n\t\t\t\r\n\t\t\tresetPriceInWei = lastPriceInWei;\r\n\t\t\tresetPriceTimeInSecond = lastPriceTimeInSecond;\r\n\t\t\tnavAInWei = WEI_DENOMINATOR;\r\n\t\t\tnavBInWei = WEI_DENOMINATOR;\r\n\t\t\tnextResetAddrIndex = 0;\r\n\r\n\t\t\tstate = State.Trading;\r\n\t\t\temit StartTrading(navAInWei, navBInWei);\r\n\t\t\treturn true;\r\n\t\t} else {\r\n\t\t\tnextResetAddrIndex = localResetAddrIndex;\r\n\t\t\temit StartReset(localResetAddrIndex, users.length);\r\n\t\t\treturn false;\r\n\t\t}\r\n\t}\r\n\t// end of reset function\r\n}","ABI":"[{\"constant\":false,\"inputs\":[],\"name\":\"updateFeeCollector\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"index\",\"type\":\"uint256\"},{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newManagerAddr\",\"type\":\"address\"}],\"name\":\"updateRoleManager\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"fetchPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"startPreReset\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupplyB\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastOperationTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOracleAddr\",\"type\":\"address\"}],\"name\":\"updateOracle\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"redeemAll\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"startReset\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"users\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"index\",\"type\":\"uint256\"},{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"operationCoolDown\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"operator\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"contractCode\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupplyA\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"idx\",\"type\":\"uint256\"},{\"name\":\"newValue\",\"type\":\"uint256\"}],\"name\":\"setValue\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amtInWeiA\",\"type\":\"uint256\"},{\"name\":\"amtInWeiB\",\"type\":\"uint256\"}],\"name\":\"redeem\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"feeBalanceInWei\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"wethAddr\",\"type\":\"address\"}],\"name\":\"createWithWETH\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAddresses\",\"outputs\":[{\"name\":\"\",\"type\":\"address[6]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"aAddr\",\"type\":\"address\"},{\"name\":\"bAddr\",\"type\":\"address\"},{\"name\":\"oracleAddr\",\"type\":\"address\"}],\"name\":\"startCustodian\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amountInWei\",\"type\":\"uint256\"}],\"name\":\"collectFee\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"existingUsers\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalUsers\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"roleManagerAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"updateOperator\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getStates\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[30]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"create\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"index\",\"type\":\"uint256\"},{\"name\":\"sender\",\"type\":\"address\"},{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"code\",\"type\":\"string\"},{\"name\":\"maturity\",\"type\":\"uint256\"},{\"name\":\"roleManagerAddr\",\"type\":\"address\"},{\"name\":\"fc\",\"type\":\"address\"},{\"name\":\"alpha\",\"type\":\"uint256\"},{\"name\":\"hu\",\"type\":\"uint256\"},{\"name\":\"hd\",\"type\":\"uint256\"},{\"name\":\"comm\",\"type\":\"uint256\"},{\"name\":\"pd\",\"type\":\"uint256\"},{\"name\":\"optCoolDown\",\"type\":\"uint256\"},{\"name\":\"pxFetchCoolDown\",\"type\":\"uint256\"},{\"name\":\"iteGasTh\",\"type\":\"uint256\"},{\"name\":\"preResetWaitBlk\",\"type\":\"uint256\"},{\"name\":\"minimumBalance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"index\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"oldValue\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"newValue\",\"type\":\"uint256\"}],\"name\":\"SetValue\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"navAInWei\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"navBInWei\",\"type\":\"uint256\"}],\"name\":\"StartTrading\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"StartPreReset\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"nextIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"total\",\"type\":\"uint256\"}],\"name\":\"StartReset\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"navAInWei\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"navBInWei\",\"type\":\"uint256\"}],\"name\":\"Matured\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"priceInWei\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"timeInSecond\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"navAInWei\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"navBInWei\",\"type\":\"uint256\"}],\"name\":\"AcceptPrice\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"ethAmtInWei\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokenAInWei\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokenBInWei\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"feeInWei\",\"type\":\"uint256\"}],\"name\":\"Create\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"ethAmtInWei\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokenAInWei\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokenBInWei\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"feeInWei\",\"type\":\"uint256\"}],\"name\":\"Redeem\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"totalSupplyAInWei\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"totalSupplyBInWei\",\"type\":\"uint256\"}],\"name\":\"TotalSupply\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"tokenOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"feeInWei\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"feeBalanceInWei\",\"type\":\"uint256\"}],\"name\":\"CollectFee\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newOracleAddress\",\"type\":\"address\"}],\"name\":\"UpdateOracle\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"updater\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newFeeCollector\",\"type\":\"address\"}],\"name\":\"UpdateFeeCollector\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newManagerAddress\",\"type\":\"address\"}],\"name\":\"UpdateRoleManager\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"updater\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newOperator\",\"type\":\"address\"}],\"name\":\"UpdateOperator\",\"type\":\"event\"}]","ContractName":"Mozart","CompilerVersion":"v0.5.0+commit.1d4f565a","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"00000000000000000000000000000000000000000000000000000000000001c00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000d728681490d63582047a6cd2fc80b1343c6aba20000000000000000000000000597be94b5491da37f26ab36650971367cdfd2b3c000000000000000000000000000000000000000000000000000000000000138800000000000000000000000000000000000000000000000018493fba64ef000000000000000000000000000000000000000000000000000003782dace9d9000000000000000000000000000000000000000000000000000000000000000000640000000000000000000000000000000000000000000000000000000000000e1000000000000000000000000000000000000000000000000000000000000151800000000000000000000000000000000000000000000000000000000000000bb8000000000000000000000000000000000000000000000000000000000000fde8000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000002386f26fc10000000000000000000000000000000000000000000000000000000000000000000a4d4f5a4152542d50505400000000000000000000000000000000000000000000","Library":"","SwarmSource":"bzzr://80542e1bc53bc4783fc4b3b62e381658822585214710ba9223e0a9df52fb4619"}]}