{"status":"1","message":"OK","result":[{"SourceCode":"// File: ../3rdparty/openzeppelin-solidity/contracts/token/ERC20/IERC20.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://eips.ethereum.org/EIPS/eip-20\r\n */\r\ninterface IERC20 {\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n\r\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address who) external view returns (uint256);\r\n\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: ../3rdparty/openzeppelin-solidity/contracts/ownership/Ownable.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n     * account.\r\n     */\r\n    constructor () internal {\r\n        _owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), _owner);\r\n    }\r\n\r\n    /**\r\n     * @return the address of the owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @return true if `msg.sender` is the owner of the contract.\r\n     */\r\n    function isOwner() public view returns (bool) {\r\n        return msg.sender == _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to relinquish control of the contract.\r\n     * It will not be possible to call the functions with the `onlyOwner`\r\n     * modifier anymore.\r\n     * @notice Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\n// File: ../3rdparty/openzeppelin-solidity/contracts/math/SafeMath.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Unsigned math operations with safety checks that revert on error.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Multiplies two unsigned integers, reverts on overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, \"SafeMath: division by zero\");\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"SafeMath: subtraction overflow\");\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Adds two unsigned integers, reverts on overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\r\n     * reverts when dividing by zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0, \"SafeMath: modulo by zero\");\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: contracts/Whitelist.sol\r\n\r\npragma solidity >=0.4.25 <0.6.0;\r\n\r\n\r\ncontract Whitelist is Ownable{\r\n    mapping (uint256 => uint8) private _partners;\r\n    mapping (address => uint256) private _partner_ids;\r\n    mapping (uint256 => address) private _partner_address;\r\n    uint256 public partners_counter=1;\r\n    mapping (address => uint8) private _whitelist;\r\n    mapping (address => uint256) private _referrals;\r\n    mapping (uint256 => mapping(uint256=>address)) private _partners_referrals;\r\n    mapping (uint256 => uint256) _partners_referrals_counter;\r\n\r\n    uint8 public constant STATE_NEW = 0;\r\n    uint8 public constant STATE_WHITELISTED = 1;\r\n    uint8 public constant STATE_BLACKLISTED = 2;\r\n    uint8 public constant STATE_ONHOLD = 3;\r\n\r\n    event Whitelisted(address indexed partner, address indexed subscriber);\r\n    event AddPartner(address indexed partner, uint256 partner_id);\r\n\r\n    function _add_partner(address partner) private returns (bool){\r\n        _partner_ids[partner] = partners_counter;\r\n        _partner_address[partners_counter] = partner;\r\n        _partners[partners_counter] = STATE_WHITELISTED;\r\n        _whitelist[partner] = STATE_WHITELISTED;\r\n        emit AddPartner(partner, partners_counter);\r\n        partners_counter++;\r\n    }\r\n    \r\n    constructor () public {\r\n        _add_partner(msg.sender);\r\n    }\r\n\r\n    function getPartnerId(address partner) public view returns (uint256){\r\n        return _partner_ids[partner];\r\n    }\r\n\r\n    modifier onlyWhiteisted(){\r\n        require(_whitelist[msg.sender] == STATE_WHITELISTED, \"Ownable: caller is not whitelisted\");\r\n        _;\r\n    }\r\n\r\n    function isPartner() public view returns (bool){\r\n        return _partners[_partner_ids[msg.sender]] == STATE_WHITELISTED;\r\n    }\r\n\r\n    function partnerStatus(address partner) public view returns (uint8){\r\n        return _partners[_partner_ids[partner]];\r\n    }\r\n\r\n\r\n    modifier onlyPartnerOrOwner(){\r\n        require(isOwner() || isPartner(), \"Ownable: caller is not the owner or partner\");\r\n        _;\r\n    }\r\n\r\n    function setPartnerState(address partner, uint8 state) public onlyOwner returns(bool){\r\n        uint256 partner_id = getPartnerId(partner);\r\n        if( partner_id == 0 && state == STATE_WHITELISTED){\r\n            _add_partner(partner);\r\n        }else{\r\n            _partners[partner_id] = state;\r\n        }\r\n        return true;\r\n    }\r\n\r\n\r\n    function addPartner(address partner) public onlyOwner returns(bool){\r\n        _add_partner(partner);\r\n        return true;\r\n    }\r\n\r\n    function whitelist(address referral) public onlyPartnerOrOwner returns (bool){\r\n        require(_whitelist[referral] == STATE_NEW, \"Referral is already whitelisted\");\r\n        uint256 partner_id = getPartnerId(msg.sender);\r\n        require(partner_id != 0, \"Partner not found\");\r\n        _whitelist[referral] = STATE_WHITELISTED;\r\n        _referrals[referral] = partner_id;\r\n        _partners_referrals[partner_id][_partners_referrals_counter[partner_id]] = referral;\r\n        _partners_referrals_counter[partner_id] ++;\r\n        emit Whitelisted(msg.sender, referral);\r\n\r\n    }\r\n\r\n    function setWhitelistState(address referral, uint8 state) public onlyOwner returns (bool){\r\n        require(_whitelist[referral] != STATE_NEW, \"Referral is not in list\");\r\n        _whitelist[referral] = state;\r\n    }\r\n\r\n    function getWhitelistState(address referral) public view returns (uint8){\r\n        return _whitelist[referral];\r\n    }\r\n\r\n    function getPartner(address referral) public view returns (address){\r\n        return _partner_address[_referrals[referral]];\r\n    }\r\n\r\n    function setPartnersAddress(uint256 partner_id, address new_partner) public onlyOwner returns (bool){\r\n        _partner_address[partner_id] = new_partner;\r\n        _partner_ids[new_partner] = partner_id;\r\n        return true;\r\n    }\r\n\r\n    function bulkWhitelist(address[] memory address_list) public returns(bool){\r\n        for(uint256 i = 0; i < address_list.length; i++){\r\n            whitelist(address_list[i]);\r\n        }\r\n        return true;\r\n    }\r\n\r\n}\r\n\r\n// File: contracts/Periods.sol\r\n\r\npragma solidity >=0.4.25 <0.6.0;\r\n\r\n\r\ncontract Periods is Ownable{\r\n    uint16 private _current_period;\r\n    uint16 private _total_periods;\r\n    mapping (uint16=>uint256) _periods;\r\n    bool _adjustable;\r\n\r\n    constructor() public{\r\n        _adjustable = true;\r\n    }\r\n\r\n    function getPeriodsCounter() public view returns(uint16){\r\n        return _total_periods;\r\n    }\r\n\r\n    function getCurrentPeriod() public view returns(uint16){\r\n        return _checkCurrentPeriod();\r\n    }\r\n\r\n    function getCurrentTime() public view returns(uint256){\r\n        return now;\r\n    }\r\n\r\n\r\n    function getCurrentPeriodTimestamp() public view returns(uint256){\r\n        return _periods[_current_period];\r\n    }\r\n\r\n    function getPeriodTimestamp(uint16 period) public view returns(uint256){\r\n        return _periods[period];\r\n    }\r\n\r\n    \r\n    function setCurrentPeriod(uint16 period) public onlyOwner returns (bool){\r\n        require(period < _total_periods, \"Do not have timestamp for that period\");\r\n        _current_period = period;\r\n        return true;\r\n    }\r\n\r\n\r\n    function addPeriodTimestamp(uint256 timestamp) public onlyOwner returns (bool){\r\n//        require(_total_periods - _current_period < 50, \"Cannot add more that 50 periods from now\");\r\n//        require((_current_period == 0) || (timestamp - _periods[_total_periods-1] > 28 days && (timestamp - _periods[_total_periods-1] < 32 days )), \"Incorrect period)\");\r\n        _periods[_total_periods] = timestamp;\r\n        _total_periods++;\r\n        return true;\r\n    }\r\n\r\n    function _checkCurrentPeriod() private view returns (uint16){\r\n        uint16 current_period = _current_period;\r\n        while( current_period < _total_periods-1){\r\n            if( now < _periods[current_period] ){\r\n                break;\r\n            }\r\n            current_period ++;\r\n        }\r\n        return current_period;\r\n    }\r\n\r\n    function adjustCurrentPeriod( ) public returns (uint16){\r\n        if(!_adjustable){\r\n            return _current_period;\r\n        }\r\n        require(_total_periods > 1, \"Periods are not set\");\r\n        require(_current_period < _total_periods, \"Last period reached\");\r\n        //require(_total_periods - _current_period < 50, \"Adjust more that 50 periods from now\");\r\n        uint16 current_period = _checkCurrentPeriod();\r\n        if(current_period > _current_period){\r\n            _current_period = current_period;\r\n        }\r\n        return current_period;\r\n    }\r\n\r\n    function addPeriodTimestamps(uint256[] memory timestamps) public onlyOwner returns(bool){\r\n        //require(timestamps.length < 50, \"Cannot set more than 50 periods\");\r\n        for(uint16 current_timestamp = 0; current_timestamp < timestamps.length; current_timestamp ++){\r\n            addPeriodTimestamp(timestamps[current_timestamp]);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    function setLastPeriod(uint16 period) public onlyOwner returns(bool){\r\n        require(period < _total_periods-1, \"Incorrect period\");\r\n        require(period > _current_period, \"Cannot change passed periods\");\r\n        _total_periods = period;\r\n        return true;\r\n    }\r\n\r\n\r\n}\r\n\r\n// File: contracts/Subscriptions.sol\r\n\r\npragma solidity >=0.4.25 <0.6.0;\r\n\r\n\r\n\r\n\r\ncontract Subscriptions is Ownable, Periods {\r\n    using SafeMath for uint256;\r\n\r\n    uint8 STATE_MISSING = 0;\r\n    uint8 STATE_ACTIVE = 1;\r\n    uint8 STATE_WITHDRAWN = 2;\r\n    uint8 STATE_PAID = 3;\r\n\r\n    uint256 ROUNDING = 1000;\r\n\r\n    struct Subscription{\r\n        uint256 subscriber_id;\r\n        uint256 subscription;\r\n        uint256 certificates;\r\n        uint256 certificate_rate;\r\n        uint256 certificate_partners_rate;\r\n        uint16 period;\r\n        uint16 lockout_period;\r\n        uint16 total_periods;\r\n        uint256 certificates_redeemed;\r\n        uint256 redemption;\r\n        uint256 payout;\r\n        uint256 deposit;\r\n        uint256 commission;\r\n        uint256 paid_to_partner;\r\n        uint256 redeem_requested;\r\n        uint256 redeem_delivered;\r\n    }\r\n\r\n    mapping (address=>uint256) private _subscribers;\r\n    mapping (uint256=>address) private _subscribers_id;\r\n    uint256 private _subscribers_counter=1;\r\n\r\n    mapping (uint256=>Subscription) private _subscriptions;\r\n    mapping (uint256=>mapping(uint256=>uint256)) private _subscribers_subscriptions;\r\n    mapping (uint256=>mapping(uint16=>uint256)) private _subscribers_subscriptions_by_period;\r\n    mapping (uint256=>uint16) private _subscribers_subscriptions_recent;\r\n    uint256 private _subscriptions_counter=1;\r\n    mapping (uint256=>uint256) private _subscribers_subscriptions_counter;\r\n\r\n    uint256 private _commission;\r\n\r\n    uint256 private _total_subscription=0;\r\n    uint16 private _lockout_period;\r\n    uint16 private _max_period;\r\n\r\n    event Subscribe(address subscriber, uint256 subscription, uint256 certs );\r\n    event Topup(address indexed subscriber, uint256 subscription_id, uint256 amount);\r\n    event Payout(address indexed subscriber, uint256 subscription_id, uint256 amount);\r\n    event Redemption(address indexed subscriber, uint256 subscription_id, uint256 amount);\r\n    event RedemptionPartner(address indexed partner, address indexed subscriber, uint256 subscription_id, uint256 amount);\r\n    event AmountCertNickelWireReceived(address indexed subscriber, uint256 subscription_id, uint256 amount);\r\n\r\n    constructor() public{\r\n        _lockout_period = 3;\r\n        _max_period = 24;\r\n        _commission = 1000;\r\n    }\r\n\r\n    function floor(uint a, uint m) internal pure returns (uint256 ) {\r\n        return ((a ) / m) * m;\r\n    }\r\n\r\n    function ceil(uint a, uint m) internal pure returns (uint256 ) {\r\n        return ((a + m + 1) / m) * m;\r\n    }\r\n\r\n\r\n    function get_subscriber_id(address subscriber_address) public view returns (uint256){\r\n        return _subscribers[subscriber_address];\r\n    }\r\n\r\n    function get_subscriber_address(uint256 subscriber_id) public view returns (address){\r\n        return _subscribers_id[subscriber_id];\r\n    }\r\n\r\n    function lockoutPeriod() public view returns(uint16){\r\n        return _lockout_period;\r\n    }\r\n\r\n    function setLockoutPeriod(uint16 period) public returns (bool){\r\n        _lockout_period = period;\r\n        return true;\r\n    }\r\n\r\n    function maxPeriod() public view returns(uint16){\r\n        return _max_period;\r\n    }\r\n\r\n    function setMaxPeriod(uint16 period) public onlyOwner returns(bool){\r\n        _max_period = period;\r\n        return true;\r\n    }\r\n\r\n    function commission() public view returns(uint256){\r\n        return _commission;\r\n    }\r\n\r\n    function setCommission(uint256 value) public onlyOwner returns(bool){\r\n        _commission = value;\r\n        return true;\r\n    }\r\n\r\n\r\n    function _new_subscription(uint256 subscriber_id, uint16 period, uint256 amount, uint256 units, uint256 unit_rate, uint256 partners_rate) private returns(bool){\r\n            Subscription memory subscription = Subscription(\r\n                subscriber_id,\r\n                amount, // subscription\r\n                units, // certificates\r\n                unit_rate, // certificate_rate\r\n                partners_rate, // certificate_partners_rate\r\n                period, // period\r\n                _lockout_period, // lockout_period\r\n                _max_period, // total_periods\r\n                0, // certificates_redeemed\r\n                0, // redemption\r\n                0, // redemption\r\n                0, // deposit\r\n                0, // commission\r\n                0,  // paidtopartner\r\n                0, // redemptiuon requested\r\n                0 // redeemption delivered\r\n                );\r\n\r\n            uint256 subscription_id = _subscriptions_counter;\r\n            _subscriptions[subscription_id] = subscription;\r\n            uint256 subscribers_subscriptions_counter = _subscribers_subscriptions_counter[subscriber_id];\r\n            _subscribers_subscriptions[subscriber_id][subscribers_subscriptions_counter] = subscription_id;\r\n            _subscribers_subscriptions_by_period[subscriber_id][period] = subscription_id;\r\n            if(_subscribers_subscriptions_recent[subscriber_id] < period){\r\n                _subscribers_subscriptions_recent[subscriber_id] = period;\r\n            }\r\n            _subscribers_subscriptions_counter[subscriber_id]++;\r\n            _subscriptions_counter++;\r\n    }\r\n\r\n\r\n    function _subscribe(address subscriber, uint256 amount, uint256 units, uint256 unit_rate, uint256 partners_rate ) private returns(bool){\r\n        uint256 subscriber_id = get_subscriber_id(subscriber);\r\n        uint16 current_period = getCurrentPeriod();\r\n        if( subscriber_id == 0 ){\r\n            subscriber_id = _subscribers_counter;\r\n            _subscribers[subscriber] = subscriber_id;\r\n            _subscribers_id[subscriber_id] = subscriber;\r\n            _subscribers_counter ++;\r\n        }\r\n\r\n        if(_subscribers_subscriptions_counter[subscriber_id] == 0){\r\n            _new_subscription(subscriber_id, current_period, amount, units, unit_rate, partners_rate);\r\n        }else{\r\n            Subscription memory subscription = _subscriptions[_subscribers_subscriptions_by_period[subscriber_id][_subscribers_subscriptions_recent[subscriber_id]]];\r\n            if( subscription.period == current_period){\r\n                subscription.subscription = subscription.subscription.add(amount);\r\n                if(units != 0){\r\n                    subscription.certificate_rate = subscription.certificate_rate.mul(subscription.certificates).add(units.mul(unit_rate)).div(subscription.certificates.add(units));\r\n                    subscription.certificate_partners_rate = subscription.certificate_partners_rate.mul(subscription.certificates).add(units.mul(partners_rate)).div(subscription.certificates.add(units));\r\n                    subscription.certificates = subscription.certificates.add(units);\r\n                }\r\n            }else{\r\n                _new_subscription(subscriber_id, current_period, amount, units, unit_rate, partners_rate);\r\n            }\r\n        }\r\n        emit Subscribe(subscriber, amount, units);\r\n        return true;\r\n    }\r\n\r\n    function _payout(address subscriber, uint256 subscription_id, uint256 amount ) private returns(bool){\r\n        uint subscriber_id = get_subscriber_id(subscriber);\r\n        require(subscriber_id != 0, \"No subscriber id found\");\r\n\r\n        Subscription storage subscription = _subscriptions[_subscribers_subscriptions[subscriber_id][subscription_id]];\r\n        uint256 total_payout = subscription.payout.add(amount);\r\n        require (subscription.subscription >= total_payout, \"Payout exceeds subscription\");\r\n        subscription.payout = total_payout;\r\n        return true;\r\n    }\r\n\r\n    function _return_payout(address subscriber, uint256 subscription_id, uint256 amount ) private returns(bool){\r\n        uint subscriber_id = get_subscriber_id(subscriber);\r\n        require(subscriber_id != 0, \"No subscriber id found\");\r\n        Subscription storage subscription = _subscriptions[_subscribers_subscriptions[subscriber_id][subscription_id]];\r\n        uint256 total_payout = subscription.payout.sub(amount);\r\n        require(total_payout <= subscription.subscription, \"Cannot return more than initial subscription\");\r\n        subscription.payout = total_payout;\r\n        return true;\r\n    }\r\n\r\n\r\n    function _redeem(uint256 subscriber_id, uint256 subscription_id, uint256 amount ) private returns(bool){\r\n        Subscription storage subscription = _subscriptions[_subscribers_subscriptions[subscriber_id][subscription_id]];\r\n        require( subscription.certificates.sub(subscription.certificates_redeemed) >= amount, \"Not enough certificates\");\r\n\r\n        uint256 pay_to_partner_rate = 0;\r\n        if( getCurrentPeriod() >= subscription.period + subscription.lockout_period ){\r\n             pay_to_partner_rate = subscription.certificate_partners_rate.mul( getCurrentPeriod() - subscription.period - subscription.lockout_period).div(subscription.total_periods-subscription.lockout_period);\r\n        }\r\n\r\n        uint256 subscription_required = floor(amount.mul(subscription.certificate_rate.add(pay_to_partner_rate).add(commission())), ROUNDING);\r\n\r\n        uint256 subscription_debit = subscription.subscription.add(subscription.deposit);\r\n        uint256 subscription_credit = subscription.redemption.add(subscription.payout).add(subscription.commission).add(subscription.paid_to_partner);\r\n\r\n        require(subscription_debit > subscription_credit, \"Too much credited\");\r\n        require(subscription_required <= subscription_debit.sub(subscription_credit), \"Not enough funds\");\r\n\r\n        uint256 redemption_total = floor(amount.mul(subscription.certificate_rate), ROUNDING);\r\n\r\n        subscription.certificates_redeemed = subscription.certificates_redeemed.add(amount);\r\n        subscription.redemption = subscription.redemption.add( redemption_total);\r\n        subscription.paid_to_partner = subscription.paid_to_partner.add( _get_partners_payout(subscriber_id, subscription_id, amount) );\r\n        subscription.commission = floor(subscription.commission.add( amount.mul(commission())), ROUNDING);\r\n        return true;\r\n    }\r\n\r\n    function _partners_redeem(uint256 partners_subscriber_id, uint256 subscriber_id, uint256 subscription_id, uint256 amount ) private returns(bool){\r\n\r\n        Subscription memory subscription = _subscriptions[_subscribers_subscriptions[subscriber_id][subscription_id]];\r\n        Subscription storage partners_subscription = _subscriptions[_subscribers_subscriptions_by_period[partners_subscriber_id][subscription.period]]; \r\n\r\n        uint256 redemption_total = amount.mul(subscription.certificate_partners_rate);\r\n        partners_subscription.redemption = partners_subscription.redemption.add( redemption_total);\r\n        partners_subscription.deposit = partners_subscription.deposit.add( _get_partners_payout(subscriber_id, subscription_id, amount ));\r\n        return true;\r\n    }\r\n\r\n    function _get_subscriptions_count(uint256 subscriber_id) private view returns(uint256){\r\n        return _subscribers_subscriptions_counter[subscriber_id];\r\n    }\r\n\r\n\r\n    function getSubscriptionsCountAll() public view returns(uint256) {\r\n        return _subscriptions_counter;\r\n    }\r\n\r\n    function getSubscriptionsCount(address subscriber) public view returns (uint256){\r\n        uint256 subscriber_id = get_subscriber_id(subscriber);\r\n        require(subscriber_id != 0, \"No subscriber id found\");\r\n        return _get_subscriptions_count(subscriber_id);\r\n    }\r\n\r\n    function _getSubscription(uint256 subscriber_id, uint256 subscription_id) private view returns (uint256){\r\n        Subscription memory subscription = _subscriptions[_subscribers_subscriptions[subscriber_id][subscription_id]];\r\n        return subscription.subscription;\r\n\r\n    }\r\n\r\n    function _getPayout(uint256 subscriber_id, uint256 subscription_id) private view returns (uint256){\r\n        Subscription memory subscription = _subscriptions[_subscribers_subscriptions[subscriber_id][subscription_id]];\r\n        return subscription.payout;\r\n\r\n    }\r\n\r\n\r\n    function _getCertificates(uint256 subscriber_id, uint256 subscription_id) private view returns (uint256){\r\n        Subscription memory subscription = _subscriptions[_subscribers_subscriptions[subscriber_id][subscription_id]];\r\n        return subscription.certificates;\r\n\r\n    }\r\n\r\n \r\n\r\n\r\n    function subscribe(address subscriber, uint256 amount, uint256 units, uint256 unit_rate, uint256 partner_rate) internal returns(bool){\r\n        _subscribe(subscriber, amount, units, unit_rate, partner_rate);\r\n        return true;\r\n    }\r\n\r\n    function _getCertificatesAvailable(uint256 subscriber_id, uint256 subscription_id) private view returns (uint256){\r\n        Subscription memory subscription = _subscriptions[_subscribers_subscriptions[subscriber_id][subscription_id]];\r\n        uint256 subscription_debit = subscription.subscription.add(subscription.deposit);\r\n        uint256 subscription_credit = subscription.redemption.add(subscription.payout).add(subscription.commission).add(subscription.paid_to_partner);\r\n        if( subscription_credit >= subscription_debit){\r\n            return 0;\r\n        }\r\n        uint256 pay_to_partner_rate = 0;\r\n        if( getCurrentPeriod() >= subscription.period + subscription.lockout_period ){\r\n             pay_to_partner_rate = subscription.certificate_partners_rate.mul( getCurrentPeriod() - subscription.period - subscription.lockout_period).div(subscription.total_periods-subscription.lockout_period);\r\n        }\r\n        uint256 cert_rate = subscription.certificate_rate.add(pay_to_partner_rate).add(commission());\r\n        return ( subscription_debit.sub(subscription_credit).div( floor(cert_rate, ROUNDING)) );\r\n    }    \r\n\r\n    function _getTopupAmount(uint256 subscriber_id, uint256 subscription_id, uint256 amount) private view returns (uint256){\r\n        Subscription memory subscription = _subscriptions[_subscribers_subscriptions[subscriber_id][subscription_id]];\r\n        require( amount <= subscription.certificates - subscription.certificates_redeemed, \"Cannot calculate for amount greater than available\");\r\n        uint256 calc_amount = amount;\r\n        if( amount == 0){\r\n            calc_amount = subscription.certificates - subscription.certificates_redeemed;\r\n        }\r\n        uint256 subscription_debit = subscription.subscription.add(subscription.deposit);\r\n        uint256 subscription_credit = subscription.redemption.add(subscription.payout).add(subscription.commission).add(subscription.paid_to_partner);\r\n\r\n        uint256 pay_to_partner_rate = 0;\r\n        if( getCurrentPeriod() >= subscription.period + subscription.lockout_period ){\r\n             pay_to_partner_rate = floor(subscription.certificate_partners_rate.\r\n                                    mul( getCurrentPeriod() - subscription.period - subscription.lockout_period).\r\n                                    div(subscription.total_periods-subscription.lockout_period), ROUNDING);\r\n        }\r\n        uint256 cert_rate = subscription.certificate_rate.add(pay_to_partner_rate).add(commission());\r\n        uint256 required_amount = cert_rate.mul(calc_amount);\r\n\r\n        if( required_amount <= subscription_debit.sub(subscription_credit) ) return 0;\r\n\r\n        return ( ceil(required_amount.sub(subscription_debit.sub(subscription_credit)), 1000));\r\n    }\r\n\r\n\r\n    function _get_available_payout(uint256 subscriber_id, uint256 subscription_id) private view returns (uint256){\r\n        Subscription memory subscription = _subscriptions[_subscribers_subscriptions[subscriber_id][subscription_id]];\r\n        uint16 periods_passed = getCurrentPeriod() - subscription.period;\r\n        if( periods_passed <= subscription.lockout_period) {\r\n            return 0;\r\n        }\r\n        if( periods_passed > subscription.total_periods) {\r\n            return subscription.subscription.add(subscription.deposit).sub(subscription.payout).\r\n                sub(subscription.redemption).sub(subscription.commission).sub(subscription.paid_to_partner);\r\n        }\r\n        uint256 debit = subscription.subscription.sub(subscription.redemption).\r\n            div(subscription.total_periods - subscription.lockout_period).mul(periods_passed - subscription.lockout_period).add(subscription.deposit);\r\n        uint256 credit = subscription.paid_to_partner.add(subscription.payout).add(subscription.commission);\r\n        //if (credit >= debit) return 0;\r\n        return floor(debit.sub(credit), 1000);\r\n    }\r\n\r\n    function get_available(address subscriber, uint256 subscription_id) private view returns (uint256){\r\n        uint256 subscriber_id = get_subscriber_id(subscriber);\r\n        require(subscriber_id != 0, \"No subscriber id found\");\r\n        return(_get_available_payout(subscriber_id, subscription_id));\r\n    }\r\n\r\n    function get_available_certs(address subscriber, uint256 subscription_id) private view returns (uint256){\r\n        uint256 subscriber_id = get_subscriber_id(subscriber);\r\n        require(subscriber_id != 0, \"No subscriber id found\");\r\n        return(_get_available_payout(subscriber_id, subscription_id));\r\n    }\r\n    function _get_partners_payout(uint256 subscriber_id, uint256 subscription_id, uint256 amount) private view returns (uint256){\r\n        Subscription memory subscription = _subscriptions[_subscribers_subscriptions[subscriber_id][subscription_id]];\r\n        uint16 periods_passed = getCurrentPeriod() - subscription.period;\r\n        if( periods_passed <= subscription.lockout_period) {\r\n            return 0;\r\n        }\r\n        if( periods_passed > subscription.total_periods) {\r\n            return floor(amount.mul(subscription.certificate_partners_rate), ROUNDING);\r\n        }\r\n        uint256 partners_payout = floor(amount.mul(subscription.certificate_partners_rate).\r\n                                        div(subscription.total_periods - subscription.lockout_period).\r\n                                        mul(periods_passed - subscription.lockout_period), ROUNDING);\r\n        return partners_payout;\r\n    }\r\n\r\n    function get_partners_payout(address subscriber, uint256 subscription_id, uint256 amount) private view returns (uint256){\r\n        uint256 subscriber_id = get_subscriber_id(subscriber);\r\n        require(subscriber_id != 0, \"No subscriber id found\");\r\n        return(_get_partners_payout(subscriber_id, subscription_id, amount));\r\n    }\r\n\r\n    function payout(address subscriber, uint256 subscription_id, uint256 amount) internal returns(bool){\r\n        uint256 available = get_available(subscriber, subscription_id);\r\n        require(available >= amount, \"Not enough funds for withdrawal\");\r\n        _payout(subscriber, subscription_id, amount);\r\n        emit Payout(subscriber, subscription_id, amount);\r\n        return true;\r\n    }\r\n\r\n    function redeem(address subscriber, uint256 subscription_id, uint256 amount) internal returns(bool){\r\n        uint256 subscriber_id = get_subscriber_id(subscriber);\r\n        _redeem(subscriber_id, subscription_id, amount);\r\n        emit Redemption(subscriber, subscription_id, amount);\r\n\r\n    }\r\n\r\n    function partners_redeem(address partner, address subscriber, uint256 subscription_id, uint256 amount) internal returns(bool){\r\n        uint256 subscriber_id = get_subscriber_id(subscriber);\r\n        require(subscriber_id != 0, \"No subscriber id found\");\r\n        uint256 partners_subscriber_id = get_subscriber_id(partner);\r\n        require(partners_subscriber_id != 0, \"No subscriber id found\");\r\n        _partners_redeem(partners_subscriber_id, subscriber_id, subscription_id, amount);\r\n        emit RedemptionPartner(partner, subscriber, subscription_id, amount);\r\n    }\r\n\r\n    function return_payout(address subscriber, uint256 subscription_id, uint256 amount) internal returns(bool){\r\n        _return_payout(subscriber, subscription_id, amount);\r\n        return true;\r\n    }\r\n\r\n    function getAvailable(address subscriber, uint256 subscription_id) public view returns(uint256){\r\n        return get_available(subscriber, subscription_id);\r\n    }\r\n\r\n    function _changeSubscriptionOwner(address old_subscriber_address, address new_subscriber_address) internal returns (bool){\r\n        uint256 subscriber_id = get_subscriber_id(old_subscriber_address);\r\n        require(getSubscriptionsCount(new_subscriber_address) == 0, \"New subscriber has subscriptions\");\r\n        _subscribers[new_subscriber_address] = subscriber_id;\r\n        _subscribers_id[subscriber_id] = new_subscriber_address;\r\n        return true;\r\n    }\r\n\r\n    function _get_subscription(uint256 subscriber_id, uint256 subscription_id) private view returns(Subscription memory){\r\n        return  _subscriptions[_subscribers_subscriptions[subscriber_id][subscription_id]];\r\n    }\r\n\r\n\r\n\r\n    function get_subscription(address subscriber, uint256 subscription_id) internal view returns(Subscription memory){\r\n        uint256 subscriber_id = get_subscriber_id(subscriber);\r\n        require(subscriber_id != 0, \"No subscriber id found\");\r\n        return  _subscriptions[_subscribers_subscriptions[subscriber_id][subscription_id]];\r\n    }\r\n\r\n    function get_global_subscription(uint256 subscription_id) internal view returns(Subscription memory){\r\n        return  _subscriptions[subscription_id];\r\n    }\r\n\r\n\r\n    function _top(uint256 subscriber_id, uint256 subscription_id, uint256 amount) private returns(bool){\r\n        Subscription storage subscription =  _subscriptions[_subscribers_subscriptions[subscriber_id][subscription_id]];\r\n        subscription.deposit = subscription.deposit.add(amount);\r\n        return true;\r\n    }\r\n\r\n\r\n    function top(address subscriber, uint256 subscription_id, uint256 amount) internal returns(bool){\r\n        uint256 subscriber_id = get_subscriber_id(subscriber);\r\n        //require(_getTopupAmount(subscriber_id, subscription_id, 0) >= amount, \"Cannot topup more that available\");\r\n        _top(subscriber_id, subscription_id, amount);\r\n        emit Topup(subscriber,subscription_id,amount);\r\n    }\r\n\r\n\r\n    function getCertSubscriptionStartDate(address subscriber, uint256 subscription_id) public view returns(uint256){\r\n        Subscription memory subscription = get_subscription(subscriber, subscription_id);\r\n        return getPeriodTimestamp(subscription.period);\r\n    }\r\n\r\n    function getNWXgrantedToInvestor(address subscriber, uint256 subscription_id) public view returns(uint256){\r\n        Subscription memory subscription = get_subscription(subscriber, subscription_id);\r\n        return subscription.subscription;\r\n    }\r\n\r\n    function getNWXgrantedToPartner(address subscriber, uint256 subscription_id) public view returns(uint256){\r\n        uint256 subscriber_id = get_subscriber_id(subscriber);\r\n        Subscription memory subscription = get_subscription(subscriber, subscription_id);\r\n        return _get_partners_payout(subscriber_id, subscription_id, subscription.certificates.sub(subscription.certificates_redeemed) ).add(subscription.paid_to_partner);\r\n    }\r\n\r\n    function getNWXpayedToInvestor(address subscriber, uint256 subscription_id) public view returns(uint256){\r\n        Subscription memory subscription = get_subscription(subscriber, subscription_id);\r\n        return subscription.payout;\r\n    }\r\n\r\n    function getNWXpayedToPartner(address subscriber, uint256 subscription_id) public view returns(uint256){\r\n        Subscription memory subscription = get_subscription(subscriber, subscription_id);\r\n        return subscription.paid_to_partner;\r\n    }\r\n\r\n\r\n    function  getAmountCertRedemptionRequested(address subscriber, uint256 subscription_id) public view returns(uint256){\r\n        Subscription memory subscription = get_subscription(subscriber, subscription_id);\r\n        return subscription.certificates_redeemed;\r\n    }\r\n\r\n    function  getAmountCertNickelWireReceived(address subscriber, uint256 subscription_id) public view returns(uint256){\r\n        Subscription memory subscription = get_subscription(subscriber, subscription_id);\r\n        return subscription.redeem_delivered;\r\n    }\r\n\r\n    function  setAmountCertNickelWireReceived(address subscriber, uint256 subscription_id, uint256 amount ) public onlyOwner returns(bool){\r\n        uint256 subscriber_id = get_subscriber_id(subscriber);\r\n        Subscription storage subscription = _subscriptions[_subscribers_subscriptions[subscriber_id][subscription_id]];\r\n        require(subscription.certificates_redeemed>=amount, \"Not enough redeemed certs\");\r\n        subscription.redeem_delivered = amount;\r\n        emit AmountCertNickelWireReceived(subscriber, subscription_id, amount);\r\n        return true;\r\n    }\r\n    /*\r\n    function  setAmountCertRedemptionRequested(address subscriber, uint256 subscription_id, uint256 amount ) public onlyOwner returns(bool){\r\n        uint256 subscriber_id = get_subscriber_id(subscriber);\r\n        Subscription storage subscription = _subscriptions[_subscribers_subscriptions[subscriber_id][subscription_id]];\r\n        require(subscription.certificates_redeemed>=amount, \"Not enough redeemed certs\");\r\n        subscription.redeem_requested = amount;\r\n        return true;\r\n    }\r\n    */\r\n    /*\r\n    function  requestRedemption(uint256 subscription_id, uint256 amount ) public returns(bool){\r\n        uint256 subscriber_id = get_subscriber_id(msg.sender);\r\n        Subscription storage subscription = _subscriptions[_subscribers_subscriptions[subscriber_id][subscription_id]];\r\n        require(subscription.certificates_redeemed>=subscription.redeem_requested.add(amount), \"Not enough redeemed certs\");\r\n        subscription.redeem_requested = subscription.redeem_requested.add(amount);\r\n        return true;\r\n    }\r\n    */\r\n\r\n   function getTopupAmount(address subscriber, uint256 subscription_id, uint256 amount) public view returns (uint256){\r\n        uint256 subscriber_id = get_subscriber_id(subscriber);\r\n        require(subscriber_id != 0, \"No subscriber id found\");\r\n        return _getTopupAmount(subscriber_id, subscription_id, amount);\r\n    }\r\n\r\n\r\n    function getSubscription(address subscriber, uint256 subscription_id) public view returns (uint256){\r\n        uint256 subscriber_id = get_subscriber_id(subscriber);\r\n        require(subscriber_id != 0, \"No subscriber id found\");\r\n        return _getSubscription(subscriber_id, subscription_id);\r\n    }\r\n\r\n    function getPayout(address subscriber, uint256 subscription_id) public view returns (uint256){\r\n        uint256 subscriber_id = get_subscriber_id(subscriber);\r\n        require(subscriber_id != 0, \"No subscriber id found\");\r\n        return _getPayout(subscriber_id, subscription_id);\r\n    }\r\n\r\n\r\n    function getSubscriptionAll(address subscriber) public view returns (uint256){\r\n        uint256 subscriber_id = get_subscriber_id(subscriber);\r\n        require(subscriber_id != 0, \"No subscriber id found\");\r\n        uint256 total_subscription = 0;\r\n        for( uint256 subscription_id = 0; subscription_id < _subscribers_subscriptions_counter[subscriber_id]; subscription_id++){\r\n            total_subscription = total_subscription.add(_getSubscription(subscriber_id, subscription_id));\r\n        }\r\n        return total_subscription;\r\n    }\r\n\r\n\r\n    function getCertificatesRedeemedQty(address subscriber, uint256 subscription_id) public view returns (uint256){\r\n        Subscription memory subscription = get_subscription(subscriber, subscription_id);\r\n        return subscription.certificates_redeemed;\r\n    }\r\n\r\n\r\n    function getCertificatesQty(address subscriber, uint256 subscription_id) public view returns (uint256){\r\n        uint256 subscriber_id = get_subscriber_id(subscriber);\r\n        require(subscriber_id != 0, \"No subscriber id found\");\r\n        return _getCertificates(subscriber_id, subscription_id);\r\n    }\r\n\r\n\r\n    function getCertificatesQtyAll(address subscriber) public view returns (uint256){\r\n        uint256 subscriber_id = get_subscriber_id(subscriber);\r\n        require(subscriber_id != 0, \"No subscriber id found\");\r\n        uint256 total_certificates = 0;\r\n        for( uint256 subscription_id = 0; subscription_id < _subscribers_subscriptions_counter[subscriber_id]; subscription_id++){\r\n            total_certificates = total_certificates.add(_getCertificates(subscriber_id, subscription_id));\r\n        }\r\n        return total_certificates;\r\n    }\r\n\r\n\r\n\r\n    function getCertificatesQtyAvailable(address subscriber, uint256 subscription_id) public view returns (uint256){\r\n        uint256 subscriber_id = get_subscriber_id(subscriber);\r\n        require(subscriber_id != 0, \"No subscriber id found\");\r\n        return _getCertificatesAvailable(subscriber_id, subscription_id);\r\n    }\r\n\r\n    function getCertificatesQtyAvailableAll(address subscriber) public view returns (uint256){\r\n        uint256 subscriber_id = get_subscriber_id(subscriber);\r\n        require(subscriber_id != 0, \"No subscriber id found\");\r\n        uint256 total_certificates = 0;\r\n        for( uint256 subscription_id = 0; subscription_id < _subscribers_subscriptions_counter[subscriber_id]; subscription_id++){\r\n            total_certificates = total_certificates.add(_getCertificatesAvailable(subscriber_id, subscription_id));\r\n        }\r\n        return total_certificates;\r\n    }\r\n\r\n\r\n}\r\n\r\n// File: contracts/INIWIX.sol\r\n\r\npragma solidity >=0.4.25 <0.6.0;\r\n\r\n\r\ninterface INIWIX {\r\n    function tokenFallback( address from, uint256 value ) external returns(bool);\r\n}\r\n\r\n// File: contracts/Cert.sol\r\n\r\npragma solidity >=0.4.25 <0.6.0;\r\npragma experimental ABIEncoderV2;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract Cert is Ownable, Whitelist, Subscriptions{\r\n    using SafeMath for uint256;\r\n\r\n    string private _name;\r\n\r\n    IERC20 _niwix;\r\n    IERC20 _euron;\r\n\r\n    uint256 private _deposit_niwix_rate;\r\n    uint256 private _subscription_niwix_rate;\r\n    uint256 private _subscription_partner_rate;\r\n    uint256 private _subscription_unit_rate;\r\n\r\n    uint public n;\r\n    address public sender;\r\n\r\n    event TokenFallbackCert(address indexed where, address indexed sender, address indexed from, uint256 value);\r\n    event DepositTo(address indexed where, address indexed sender, address indexed to, uint256 value);\r\n    event Redemption(address indexed subscriber, uint256 subscription_id, uint256 amount);\r\n    event ChangeSubscriber(address indexed from, address indexed to);\r\n    event Withdraw(address indexed subscriber, uint256 subscription_id, uint256 amount);\r\n    event Deposit(address indexed subscriber, uint256 amount);\r\n    event SetNIWIXRate(uint256 rate);\r\n    event SetUnitPrice(uint256 rate);\r\n    event SetSubscriptionPartnerRate(uint256 rate);\r\n\r\n    mapping (uint256=>uint256) paper_certificate;\r\n\r\n    function tokenFallback( address from, uint256 value ) public returns(bool){\r\n        if( msg.sender == address(_euron)){\r\n            if( from != address(_niwix) )\r\n            {\r\n                _euron.transfer(address(_niwix), value);\r\n                INIWIX(address(_niwix)).tokenFallback(from, value);\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n\r\n    constructor() public {\r\n        _name = \"NiwixCert\";\r\n        _deposit_niwix_rate = 1000 * 10 ** 8;\r\n        _subscription_niwix_rate = 10000 * 10 ** 8;\r\n        _subscription_unit_rate = 100 * 10 ** 8;\r\n    }\r\n\r\n    function name() public view returns(string memory){\r\n        return _name;\r\n    }\r\n\r\n    function setNiwix(address contract_address) public onlyOwner returns(bool){\r\n        _niwix = IERC20(contract_address);\r\n        return true;\r\n    }\r\n\r\n    function setEURON(address contract_address) public onlyOwner returns(bool){\r\n        _euron = IERC20(contract_address);\r\n        return true;\r\n    }\r\n\r\n    function depositNiwixRate() public view returns(uint256){\r\n        return _deposit_niwix_rate;\r\n    }\r\n\r\n    function setDepositNiwixRate(uint256 value) public onlyOwner returns(uint256){\r\n        _deposit_niwix_rate = value;\r\n    }\r\n\r\n    function setSubscriptionUnitRate(uint256 value) public onlyOwner returns(uint256){\r\n        _subscription_unit_rate = value;\r\n    }\r\n\r\n    function setSubscriptionNiwixRate(uint256 value) public onlyOwner returns(uint256){\r\n        _subscription_niwix_rate = value;\r\n    }\r\n\r\n    function getSubscriptionUnitRate() public view returns(uint256){\r\n        return(_subscription_unit_rate);\r\n    }\r\n\r\n\r\n    function getDepositNiwixValue(uint256 euron_amount) public view returns(uint256){\r\n        return euron_amount.div(_subscription_unit_rate).mul(depositNiwixRate());\r\n    }\r\n\r\n\r\n    function setSubscriptionParnerRate(uint256 value) public onlyOwner returns(uint256){\r\n        _subscription_partner_rate = value;\r\n    }\r\n\r\n    function subscriptionPartnerRate() public view returns(uint256){\r\n        return _subscription_partner_rate;\r\n    }\r\n\r\n    function _get_subscription_units(uint256 value) public view returns (uint256){\r\n        return value.div(_subscription_unit_rate);\r\n    }\r\n\r\n    function _get_subscription_change(uint256 value) public view returns (uint256){\r\n        uint256 units = value.div(_subscription_unit_rate);\r\n        uint256 subscription = units.mul(_subscription_unit_rate);\r\n        return value.sub(subscription);\r\n    }\r\n\r\n    function get_subscription_value(uint256 value) public view returns (uint256, uint256, uint256){\r\n        uint256 units = _get_subscription_units(value);\r\n        uint256 subscription = units.mul(_subscription_unit_rate);\r\n        return (units, subscription, value.sub(subscription));\r\n    }\r\n\r\n\r\n    function _deposit(address euron_address, uint256 euron_amount, address niwix_address ) private returns (uint256 subscription_value){\r\n        _euron.transferFrom(euron_address, address(this), euron_amount);\r\n        uint256 subscription_change;\r\n        uint256 subscription_units;\r\n        (subscription_units, subscription_value, subscription_change) = get_subscription_value(euron_amount);\r\n        uint256 niwix_amount = getDepositNiwixValue(euron_amount);\r\n\r\n        if(niwix_amount>0){\r\n            _niwix.transferFrom(niwix_address, address(this), niwix_amount);\r\n        }\r\n        if(subscription_change > 0 ){\r\n            _euron.transfer(niwix_address, subscription_change);\r\n        }\r\n        address partner = getPartner(niwix_address);\r\n        if (partner != address(0)){\r\n            subscribe(partner, subscription_units.mul(_subscription_partner_rate), 0, 0, 0);\r\n        }\r\n\r\n        subscribe(niwix_address, subscription_units.mul(_subscription_niwix_rate), subscription_units, _subscription_niwix_rate, _subscription_partner_rate );\r\n    }\r\n\r\n    function depositTo(address address_to, uint256 value) public returns (bool){\r\n        require(getWhitelistState(address_to) == Whitelist.STATE_WHITELISTED, \"Address needs to be whitelisted\");\r\n        require(partnerStatus(address_to) == Whitelist.STATE_NEW, \"Cannot deposit to partner\");\r\n        emit DepositTo(address(this), msg.sender, address_to, value);\r\n        _deposit(msg.sender, value, address_to);\r\n        emit Deposit(address_to, value);\r\n        return true;\r\n    }\r\n\r\n    function deposit(uint256 value) public returns (bool){\r\n        require(getWhitelistState(msg.sender) == Whitelist.STATE_WHITELISTED, \"You need to be whitelisted\");\r\n        require(partnerStatus(msg.sender) == Whitelist.STATE_NEW, \"Partner cannot deposit\");\r\n        uint256 amount = value;\r\n        if(value == 0){\r\n            amount = _euron.allowance(msg.sender, address(this));\r\n        }\r\n        _deposit(msg.sender, amount, msg.sender);\r\n        emit Deposit(msg.sender, amount);\r\n    }\r\n\r\n    function withdraw(uint256 subscription_id, uint256 value) public returns (bool){\r\n        uint256 amount = value;\r\n        if(value == 0){\r\n            amount = getAvailable(msg.sender, subscription_id);\r\n        }\r\n        require(amount > 0, \"Wrong value or no funds availabe for withdrawal\");\r\n\r\n        payout(msg.sender, subscription_id, amount);\r\n        _niwix.transfer(msg.sender, amount);\r\n        emit Withdraw(msg.sender, subscription_id, amount);\r\n        return true;\r\n    }\r\n    /*\r\n    function return_withdrawal(uint256 subscription_id, uint256 value ) public returns (bool){\r\n        _niwix.transferFrom(msg.sender, address(this), value);\r\n        return_payout(msg.sender, subscription_id, value);\r\n        emit ReturnRedemption(msg.sender, subscription_id, value);\r\n        return true;\r\n    }\r\n    */\r\n    function change_subscribers_address(address from, address to) public onlyOwner returns (bool){\r\n        require(getWhitelistState(to) == Whitelist.STATE_WHITELISTED, \"To address must be whitelisted\");\r\n\r\n        _changeSubscriptionOwner(from, to);\r\n        emit ChangeSubscriber(from, to);\r\n        return true;\r\n    }\r\n\r\n    function change_address( address to) public returns (bool){\r\n        require(getWhitelistState(to) == Whitelist.STATE_WHITELISTED, \"To address must be whitelisted\");\r\n        _changeSubscriptionOwner(msg.sender, to);\r\n        emit ChangeSubscriber(msg.sender, to);\r\n        return true;\r\n    }\r\n\r\n\r\n    function redemption(uint256 subscription_id, uint256 amount) public  returns (bool){\r\n        address partner = getPartner(msg.sender);\r\n        if (partner != address(0)){\r\n           partners_redeem(partner, msg.sender, subscription_id, amount);\r\n        }\r\n\r\n        redeem(msg.sender, subscription_id, amount);\r\n        return true;\r\n    }\r\n\r\n    function topup(uint256 subscription_id, uint256 amount) public  returns (bool){\r\n        _niwix.transferFrom(msg.sender, address(this), amount);\r\n        top(msg.sender, subscription_id, amount);\r\n        return true;\r\n    }\r\n\r\n    function topupOwner(address to, uint256 subscription_id, uint256 amount) public onlyOwner  returns (bool){\r\n        top(to, subscription_id, amount);\r\n        return true;\r\n    }\r\n\r\n\r\n    function transfer(address to, uint256 subscription_id, uint256 amount) public returns (bool)\r\n    {\r\n//        Subscription memory subscription = get_subscription(msg.sender, subscription_id);\r\n//        uint256 subscription_certificates = subscription.certificates;\r\n        redemption(subscription_id, amount);\r\n        subscribe(to, amount.mul(_subscription_niwix_rate), amount, _subscription_niwix_rate, _subscription_partner_rate );\r\n        address partner = getPartner(to);\r\n        if (partner != address(0)){\r\n            subscribe(partner, amount.mul(_subscription_partner_rate), 0, 0, 0);\r\n        }\r\n\r\n    }\r\n\r\n    function viewSubscription(address subscriber, uint256 subscription_id) public view returns(Subscription memory){\r\n        if( subscriber == address(0) )\r\n        {\r\n            return get_global_subscription( subscription_id );\r\n        }\r\n        return get_subscription(subscriber, subscription_id);\r\n    }\r\n\r\n\r\n    function reclaimEther(address payable _to) external onlyOwner {\r\n        _to.transfer(address(this).balance);\r\n    }\r\n\r\n    function reclaimToken(IERC20 token, address _to) external onlyOwner {\r\n        uint256 balance = token.balanceOf(address(this));\r\n        token.transfer(_to, balance);\r\n    }\r\n\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"subscription_id\",\"type\":\"uint256\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"redemption\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"_get_subscription_units\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getSubscriptionsCountAll\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCurrentPeriod\",\"outputs\":[{\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"subscription_id\",\"type\":\"uint256\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"partner_id\",\"type\":\"uint256\"},{\"name\":\"new_partner\",\"type\":\"address\"}],\"name\":\"setPartnersAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"STATE_BLACKLISTED\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"subscriber\",\"type\":\"address\"},{\"name\":\"subscription_id\",\"type\":\"uint256\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"setAmountCertNickelWireReceived\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"subscriptionPartnerRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"subscription_id\",\"type\":\"uint256\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"topup\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"setDepositNiwixRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"subscription_id\",\"type\":\"uint256\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"topupOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCurrentTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"n\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"setCommission\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"subscriber\",\"type\":\"address\"},{\"name\":\"subscription_id\",\"type\":\"uint256\"}],\"name\":\"getSubscription\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"subscriber\",\"type\":\"address\"},{\"name\":\"subscription_id\",\"type\":\"uint256\"}],\"name\":\"getNWXgrantedToInvestor\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"tokenFallback\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"referral\",\"type\":\"address\"}],\"name\":\"getWhitelistState\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"subscription_id\",\"type\":\"uint256\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxPeriod\",\"outputs\":[{\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"partner\",\"type\":\"address\"}],\"name\":\"partnerStatus\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"timestamps\",\"type\":\"uint256[]\"}],\"name\":\"addPeriodTimestamps\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"adjustCurrentPeriod\",\"outputs\":[{\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"subscriber\",\"type\":\"address\"},{\"name\":\"subscription_id\",\"type\":\"uint256\"}],\"name\":\"getPayout\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"STATE_NEW\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"}],\"name\":\"change_subscribers_address\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"sender\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getSubscriptionUnitRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"subscriber\",\"type\":\"address\"}],\"name\":\"getCertificatesQtyAll\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"partner\",\"type\":\"address\"},{\"name\":\"state\",\"type\":\"uint8\"}],\"name\":\"setPartnerState\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"addPeriodTimestamp\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"subscriber\",\"type\":\"address\"},{\"name\":\"subscription_id\",\"type\":\"uint256\"}],\"name\":\"getAmountCertRedemptionRequested\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isPartner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"STATE_WHITELISTED\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"reclaimToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"period\",\"type\":\"uint16\"}],\"name\":\"setMaxPeriod\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"partner\",\"type\":\"address\"}],\"name\":\"addPartner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"get_subscription_value\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"referral\",\"type\":\"address\"},{\"name\":\"state\",\"type\":\"uint8\"}],\"name\":\"setWhitelistState\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"subscriber\",\"type\":\"address\"},{\"name\":\"subscription_id\",\"type\":\"uint256\"}],\"name\":\"getAvailable\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"reclaimEther\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"referral\",\"type\":\"address\"}],\"name\":\"whitelist\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"subscriber\",\"type\":\"address\"},{\"name\":\"subscription_id\",\"type\":\"uint256\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"getTopupAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"subscriber\",\"type\":\"address\"},{\"name\":\"subscription_id\",\"type\":\"uint256\"}],\"name\":\"getCertificatesQty\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getPeriodsCounter\",\"outputs\":[{\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"subscriber\",\"type\":\"address\"},{\"name\":\"subscription_id\",\"type\":\"uint256\"}],\"name\":\"viewSubscription\",\"outputs\":[{\"components\":[{\"name\":\"subscriber_id\",\"type\":\"uint256\"},{\"name\":\"subscription\",\"type\":\"uint256\"},{\"name\":\"certificates\",\"type\":\"uint256\"},{\"name\":\"certificate_rate\",\"type\":\"uint256\"},{\"name\":\"certificate_partners_rate\",\"type\":\"uint256\"},{\"name\":\"period\",\"type\":\"uint16\"},{\"name\":\"lockout_period\",\"type\":\"uint16\"},{\"name\":\"total_periods\",\"type\":\"uint16\"},{\"name\":\"certificates_redeemed\",\"type\":\"uint256\"},{\"name\":\"redemption\",\"type\":\"uint256\"},{\"name\":\"payout\",\"type\":\"uint256\"},{\"name\":\"deposit\",\"type\":\"uint256\"},{\"name\":\"commission\",\"type\":\"uint256\"},{\"name\":\"paid_to_partner\",\"type\":\"uint256\"},{\"name\":\"redeem_requested\",\"type\":\"uint256\"},{\"name\":\"redeem_delivered\",\"type\":\"uint256\"}],\"name\":\"\",\"type\":\"tuple\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"partner\",\"type\":\"address\"}],\"name\":\"getPartnerId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"period\",\"type\":\"uint16\"}],\"name\":\"setLastPeriod\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"subscriber\",\"type\":\"address\"},{\"name\":\"subscription_id\",\"type\":\"uint256\"}],\"name\":\"getCertificatesQtyAvailable\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"partners_counter\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"depositNiwixRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"STATE_ONHOLD\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"euron_amount\",\"type\":\"uint256\"}],\"name\":\"getDepositNiwixValue\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"period\",\"type\":\"uint16\"}],\"name\":\"getPeriodTimestamp\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"contract_address\",\"type\":\"address\"}],\"name\":\"setNiwix\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"}],\"name\":\"change_address\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"subscriber\",\"type\":\"address\"},{\"name\":\"subscription_id\",\"type\":\"uint256\"}],\"name\":\"getCertSubscriptionStartDate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"subscriber\",\"type\":\"address\"},{\"name\":\"subscription_id\",\"type\":\"uint256\"}],\"name\":\"getNWXpayedToPartner\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"setSubscriptionNiwixRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"contract_address\",\"type\":\"address\"}],\"name\":\"setEURON\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"subscriber\",\"type\":\"address\"}],\"name\":\"getSubscriptionsCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"subscriber\",\"type\":\"address\"},{\"name\":\"subscription_id\",\"type\":\"uint256\"}],\"name\":\"getCertificatesRedeemedQty\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"subscriber_id\",\"type\":\"uint256\"}],\"name\":\"get_subscriber_address\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"period\",\"type\":\"uint16\"}],\"name\":\"setLockoutPeriod\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lockoutPeriod\",\"outputs\":[{\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"referral\",\"type\":\"address\"}],\"name\":\"getPartner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"subscriber\",\"type\":\"address\"}],\"name\":\"getSubscriptionAll\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"subscriber\",\"type\":\"address\"},{\"name\":\"subscription_id\",\"type\":\"uint256\"}],\"name\":\"getNWXgrantedToPartner\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"commission\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"subscriber\",\"type\":\"address\"},{\"name\":\"subscription_id\",\"type\":\"uint256\"}],\"name\":\"getNWXpayedToInvestor\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"period\",\"type\":\"uint16\"}],\"name\":\"setCurrentPeriod\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"subscriber\",\"type\":\"address\"}],\"name\":\"getCertificatesQtyAvailableAll\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"subscriber\",\"type\":\"address\"},{\"name\":\"subscription_id\",\"type\":\"uint256\"}],\"name\":\"getAmountCertNickelWireReceived\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"setSubscriptionParnerRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"setSubscriptionUnitRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"address_list\",\"type\":\"address[]\"}],\"name\":\"bulkWhitelist\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"_get_subscription_change\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"subscriber_address\",\"type\":\"address\"}],\"name\":\"get_subscriber_id\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCurrentPeriodTimestamp\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"address_to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"depositTo\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"where\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"TokenFallbackCert\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"where\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"DepositTo\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"subscriber\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"subscription_id\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Redemption\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"}],\"name\":\"ChangeSubscriber\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"subscriber\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"subscription_id\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"subscriber\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"rate\",\"type\":\"uint256\"}],\"name\":\"SetNIWIXRate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"rate\",\"type\":\"uint256\"}],\"name\":\"SetUnitPrice\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"rate\",\"type\":\"uint256\"}],\"name\":\"SetSubscriptionPartnerRate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"subscriber\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"subscription\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"certs\",\"type\":\"uint256\"}],\"name\":\"Subscribe\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"subscriber\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"subscription_id\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Topup\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"subscriber\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"subscription_id\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Payout\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"partner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"subscriber\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"subscription_id\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"RedemptionPartner\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"subscriber\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"subscription_id\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"AmountCertNickelWireReceived\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"partner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"subscriber\",\"type\":\"address\"}],\"name\":\"Whitelisted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"partner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"partner_id\",\"type\":\"uint256\"}],\"name\":\"AddPartner\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"Cert","CompilerVersion":"v0.5.8+commit.23d335f2","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://b2c86f572325656e27eb9b53f3494ddf5c1b7fc591d9b7b86e3822a9f0d31b47"}]}