{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.0;\r\n\r\ninterface IERC20 {\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n\r\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address who) external view returns (uint256);\r\n\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ncontract TokenDistributionSpecial {\r\n\r\n    mapping (address => Investor) private _investors;\r\n    address[] investorAddresses;\r\n\r\n    struct Investor {\r\n        uint256 total;\r\n        uint256 released;\r\n    }\r\n\r\n    uint256 public initTimestamp;\r\n    uint256 public totalAmount;\r\n    IERC20 token;\r\n\r\n    // fraction of tokens to be distributed every month.\r\n    // we use 140 as denominator of a fraction.\r\n    // if monthlyFraction[0] = 5 this means that 5/140 of total is to be distributed \r\n    // in \"month 1\".\r\n    // note that numbers in this array sum up to 140, which means that after 17 months\r\n    // 140/140 of total will be distributed.\r\n    uint16[17] monthlyFraction = [\r\n        5,   // 1\r\n        15,  // 2\r\n        20,  // 3\r\n        5,   // 4\r\n        5,   // 5\r\n        5,   // 6\r\n        5,   // 7\r\n        5,   // 8\r\n        5,   // 9\r\n        5,   // 10\r\n        5,   // 11\r\n        5,   // 12\r\n        5,   // 13\r\n        5,   // 14\r\n        5,   // 15\r\n        20,  // 16\r\n        20  // 17\r\n    ];\r\n\r\n    constructor(address _token, address[] memory investors, uint256[] memory tokenAmounts) public {\r\n        token = IERC20(_token);\r\n        initTimestamp = block.timestamp;\r\n        require(investors.length == tokenAmounts.length);\r\n    \r\n        for (uint i = 0; i < investors.length; i++) {\r\n            address investor_address = investors[i];\r\n            investorAddresses.push(investor_address);\r\n            require(_investors[investor_address].total == 0); // prevent duplicate addresses\r\n            _investors[investor_address].total = tokenAmounts[i] * 1000000;\r\n            _investors[investor_address].released = 0;\r\n            totalAmount += tokenAmounts[i];\r\n        }\r\n    }\r\n\r\n    function fractionToAmount(uint256 total, uint256 numerator) internal pure returns (uint256) {\r\n        return (total * numerator) / 140;\r\n    }\r\n\r\n    function computeUnlockedAmount(Investor storage inv) internal view returns (uint256) {\r\n        uint256 total = inv.total;\r\n        // first month is immediately unlocked\r\n        uint256 unlocked = fractionToAmount(total, monthlyFraction[0]);\r\n        uint256 daysPassed = getDaysPassed();\r\n        if (daysPassed > 510) {\r\n            return total; // after 17 months we unlock all tokens\r\n        }\r\n\r\n        uint256 monthsPassed = daysPassed / 30;\r\n        if (monthsPassed >= 17) {\r\n            return total;\r\n        }\r\n\r\n        // unlock up until the current month.\r\n        // E.g. monthsPassed == 1 then this loop is not executed\r\n        // if monthsPassed == 2 then this loop is executed once with m=1 and so on.\r\n        for (uint m = 1; m < monthsPassed; m++) {\r\n            unlocked += fractionToAmount(total, monthlyFraction[m]);\r\n        }\r\n    \r\n        // do daily unlock starting from second month\r\n        if (monthsPassed > 0) {\r\n            uint256 daysSinceStartOfAMonth = daysPassed - monthsPassed * 30;\r\n            if (daysSinceStartOfAMonth > 30)\r\n            daysSinceStartOfAMonth = 30;\r\n            uint256 unlockedThisMonths = fractionToAmount(total, monthlyFraction[monthsPassed]);\r\n            unlocked += (unlockedThisMonths * daysSinceStartOfAMonth) / 30;\r\n        }\r\n        \r\n        if (unlocked > total) {\r\n            return total;\r\n        } \r\n        else return unlocked;\r\n    }\r\n\r\n    function distributedTokensFor(address account) public {\r\n        Investor storage inv = _investors[account];\r\n        uint256 unlocked = computeUnlockedAmount(inv);\r\n        if (unlocked > inv.released) {\r\n            uint256 delta = unlocked - inv.released;\r\n            inv.released = unlocked;\r\n            token.transferFrom(0xc311e99365CEBf428088C3430499c04fbc770b17, account, delta);\r\n        }\r\n    }\r\n    \r\n    function distributedTokens() public {\r\n        for (uint i = 0; i < investorAddresses.length; i++) {\r\n            distributedTokensFor(investorAddresses[i]);\r\n        }\r\n    }\r\n\r\n    function amountOfTokensToUnlock(address account) external view returns (uint256) {\r\n        Investor storage inv = _investors[account];\r\n        uint256 unlocked = computeUnlockedAmount(inv);\r\n        return (unlocked - inv.released);\r\n    }\r\n    \r\n    function getDaysPassed() public view returns (uint) {\r\n        return (block.timestamp - initTimestamp) / 86400;\r\n    }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"getDaysPassed\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"distributedTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"initTimestamp\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"amountOfTokensToUnlock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"distributedTokensFor\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"investors\",\"type\":\"address[]\"},{\"name\":\"tokenAmounts\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"}]","ContractName":"TokenDistributionSpecial","CompilerVersion":"v0.5.8+commit.23d335f2","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000915044526758533dfb918eceb6e44bc21632060d000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000c00000000000000000000000000000000000000000000000000000000000000002000000000000000000000000a68836c10696b40ef5828932dd370a61e4159ae2000000000000000000000000ad28be2059e305756124ca716164a76c71d9b93f0000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000036d51300000000000000000000000000000000000000000000000000000000004cf9e5","Library":"","LicenseType":"GNU GPLv3","SwarmSource":"bzzr://3c02551f2e904d642d6175b457f3e50a9760cc8a3adb470111da8601119a54c1"}]}