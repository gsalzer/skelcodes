{"status":"1","message":"OK","result":[{"SourceCode":"/**\r\n * Copyright (c) 2018-present, Leap DAO (leapdao.org)\r\n *\r\n * This source code is licensed under the Mozilla Public License, version 2,\r\n * found in the LICENSE file in the root directory of this source tree.\r\n */\r\n \r\npragma solidity 0.5.2;\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Unsigned math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Multiplies two unsigned integers, reverts on overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Adds two unsigned integers, reverts on overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\r\n     * reverts when dividing by zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n\r\ncontract TransferrableToken {\r\n  function transferFrom(address _from, address _to, uint256 _valueOrTokenId) public;\r\n  function approve(address _to, uint256 _value) public;\r\n}\r\n\r\n/**\r\n * @title PriorityQueue\r\n * @dev A priority queue implementation\r\n */\r\n\r\nlibrary PriorityQueue {\r\n  using SafeMath for uint256;\r\n\r\n  struct Token {\r\n    TransferrableToken addr;\r\n    uint256[] heapList;\r\n    uint256 currentSize;\r\n  }\r\n\r\n  function insert(Token storage self, uint256 k) public {\r\n    self.heapList.push(k);\r\n    self.currentSize = self.currentSize.add(1);\r\n    percUp(self, self.currentSize);\r\n  }\r\n\r\n  function minChild(Token storage self, uint256 i) public view returns (uint256) {\r\n    if (i.mul(2).add(1) > self.currentSize) {\r\n      return i.mul(2);\r\n    } else {\r\n      if (self.heapList[i.mul(2)] < self.heapList[i.mul(2).add(1)]) {\r\n        return i.mul(2);\r\n      } else {\r\n        return i.mul(2).add(1);\r\n      }\r\n    }\r\n  }\r\n\r\n  function getMin(Token storage self) public view returns (uint256) {\r\n    return self.heapList[1];\r\n  }\r\n\r\n  function delMin(Token storage self) public returns (uint256) {\r\n    uint256 retVal = self.heapList[1];\r\n    self.heapList[1] = self.heapList[self.currentSize];\r\n    delete self.heapList[self.currentSize];\r\n    self.currentSize = self.currentSize.sub(1);\r\n    percDown(self, 1);\r\n    self.heapList.length = self.heapList.length.sub(1);\r\n    return retVal;\r\n  }\r\n\r\n  // solium-disable-next-line security/no-assign-params\r\n  function percUp(Token storage self, uint256 i) private {\r\n    uint256 j = i;\r\n    uint256 newVal = self.heapList[i];\r\n    while (newVal < self.heapList[i.div(2)]) {\r\n      self.heapList[i] = self.heapList[i.div(2)];\r\n      i = i.div(2);\r\n    }\r\n    if (i != j) self.heapList[i] = newVal;\r\n  }\r\n\r\n  // solium-disable-next-line security/no-assign-params\r\n  function percDown(Token storage self, uint256 i) private {\r\n    uint256 j = i;\r\n    uint256 newVal = self.heapList[i];\r\n    uint256 mc = minChild(self, i);\r\n    while (mc <= self.currentSize && newVal > self.heapList[mc]) {\r\n      self.heapList[i] = self.heapList[mc];\r\n      i = mc;\r\n      mc = minChild(self, i);\r\n    }\r\n    if (i != j) self.heapList[i] = newVal;\r\n  }\r\n\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"self\",\"type\":\"PriorityQueue.Token storage\"}],\"name\":\"delMin\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"self\",\"type\":\"PriorityQueue.Token storage\"}],\"name\":\"getMin\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"self\",\"type\":\"PriorityQueue.Token storage\"},{\"name\":\"k\",\"type\":\"uint256\"}],\"name\":\"insert\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"self\",\"type\":\"PriorityQueue.Token storage\"},{\"name\":\"i\",\"type\":\"uint256\"}],\"name\":\"minChild\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"PriorityQueue","CompilerVersion":"v0.5.2+commit.1df8f40c","OptimizationUsed":"1","Runs":"2","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://2256f63d0fb9e2656410ac7c55cbc8d83bce59ba28a90b36fb4a8a55091f97ff"}]}