{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.5;\r\n\r\nlibrary SigUtils {\r\n    /**\r\n      @dev Recovers address who signed the message \r\n      @param _hash operation ethereum signed message hash\r\n      @param _signature message `hash` signature  \r\n    */\r\n    function ecrecover2 (\r\n        bytes32 _hash, \r\n        bytes memory _signature\r\n    ) internal pure returns (address) {\r\n        bytes32 r;\r\n        bytes32 s;\r\n        uint8 v;\r\n\r\n        assembly {\r\n            r := mload(add(_signature, 32))\r\n            s := mload(add(_signature, 64))\r\n            v := and(mload(add(_signature, 65)), 255)\r\n        }\r\n\r\n        if (v < 27) {\r\n            v += 27;\r\n        }\r\n\r\n        return ecrecover(\r\n            _hash,\r\n            v,\r\n            r,\r\n            s\r\n        );\r\n    }\r\n}\r\n\r\n/*\r\n    Marmo wallet\r\n    It has a signer, and it accepts signed messages ´Intents´ (Meta-Txs)\r\n    all messages are composed by an interpreter and a ´data´ field.\r\n*/\r\ncontract Marmo {\r\n    event Relayed(bytes32 indexed _id, address _implementation, bytes _data);\r\n    event Canceled(bytes32 indexed _id);\r\n\r\n    // Random Invalid signer address\r\n    // Intents signed with this address are invalid\r\n    address private constant INVALID_ADDRESS = address(0x9431Bab00000000000000000000000039bD955c9);\r\n\r\n    // Random slot to store signer\r\n    bytes32 private constant SIGNER_SLOT = keccak256(\"marmo.wallet.signer\");\r\n\r\n    // [1 bit (canceled) 95 bits (block) 160 bits (relayer)]\r\n    mapping(bytes32 => bytes32) private intentReceipt;\r\n\r\n    function() external payable {}\r\n\r\n    // Inits the wallet, any address can Init\r\n    // it must be called using another contract\r\n    function init(address _signer) external payable {\r\n        address signer;\r\n        bytes32 signerSlot = SIGNER_SLOT;\r\n        assembly { signer := sload(signerSlot) }\r\n        require(signer == address(0), \"Signer already defined\");\r\n        assembly { sstore(signerSlot, _signer) }\r\n    }\r\n\r\n    // Signer of the Marmo wallet\r\n    // can perform transactions by signing Intents\r\n    function signer() public view returns (address _signer) {\r\n        bytes32 signerSlot = SIGNER_SLOT;\r\n        assembly { _signer := sload(signerSlot) }\r\n    } \r\n\r\n    // Address that relayed the `_id` intent\r\n    // address(0) if the intent was not relayed\r\n    function relayedBy(bytes32 _id) external view returns (address _relayer) {\r\n        (,,_relayer) = _decodeReceipt(intentReceipt[_id]);\r\n    }\r\n\r\n    // Block when the intent was relayed\r\n    // 0 if the intent was not relayed\r\n    function relayedAt(bytes32 _id) external view returns (uint256 _block) {\r\n        (,_block,) = _decodeReceipt(intentReceipt[_id]);\r\n    }\r\n\r\n    // True if the intent was canceled\r\n    // An executed intent can't be canceled and\r\n    // a Canceled intent can't be executed\r\n    function isCanceled(bytes32 _id) external view returns (bool _canceled) {\r\n        (_canceled,,) = _decodeReceipt(intentReceipt[_id]);\r\n    }\r\n\r\n    // Relay a signed intent\r\n    //\r\n    // The implementation receives data containing the id of the 'intent' and its data,\r\n    // and it will perform all subsequent calls.\r\n    //\r\n    // The same _implementation and _data combination can only be relayed once\r\n    //\r\n    // Returns the result of the 'delegatecall' execution\r\n    function relay(\r\n        address _implementation,\r\n        bytes calldata _data,\r\n        bytes calldata _signature\r\n    ) external payable returns (\r\n        bytes memory result\r\n    ) {\r\n        // Calculate ID from\r\n        // (this, _implementation, data)\r\n        // Any change in _data results in a different ID\r\n        bytes32 id = keccak256(\r\n            abi.encodePacked(\r\n                address(this),\r\n                _implementation,\r\n                keccak256(_data)\r\n            )\r\n        );\r\n\r\n        // Read receipt only once\r\n        // if the receipt is 0, the Intent was not canceled or relayed\r\n        if (intentReceipt[id] != bytes32(0)) {\r\n            // Decode the receipt and determine if the Intent was canceled or relayed\r\n            (bool canceled, , address relayer) = _decodeReceipt(intentReceipt[id]);\r\n            require(relayer == address(0), \"Intent already relayed\");\r\n            require(!canceled, \"Intent was canceled\");\r\n            revert(\"Unknown error\");\r\n        }\r\n\r\n        // Read the signer from storage, avoid multiples 'sload' ops\r\n        address _signer = signer();\r\n\r\n        // The signer 'INVALID_ADDRESS' is considered invalid and it will always throw\r\n        // this is meant to disable the wallet safely\r\n        require(_signer != INVALID_ADDRESS, \"Signer is not a valid address\");\r\n\r\n        // Validate is the msg.sender is the signer or if the provided signature is valid\r\n        require(_signer == msg.sender || _signer == SigUtils.ecrecover2(id, _signature), \"Invalid signature\");\r\n\r\n        // Save the receipt before performing any other action\r\n        intentReceipt[id] = _encodeReceipt(false, block.number, msg.sender);\r\n\r\n        // Emit the 'relayed' event\r\n        emit Relayed(id, _implementation, _data);\r\n\r\n        // Perform 'delegatecall' to _implementation, appending the id of the intent\r\n        // to the beginning of the _data.\r\n\r\n        bool success;\r\n        (success, result) = _implementation.delegatecall(abi.encode(id, _data));\r\n\r\n        // If the 'delegatecall' failed, reverts the transaction\r\n        // forwarding the revert message\r\n        if (!success) {\r\n            assembly {\r\n                revert(add(result, 32), mload(result))\r\n            }\r\n        }\r\n    }\r\n\r\n    // Cancels a not executed Intent '_id'\r\n    // a canceled intent can't be executed\r\n    function cancel(bytes32 _id) external {\r\n        require(msg.sender == address(this), \"Only wallet can cancel txs\");\r\n\r\n        if (intentReceipt[_id] != bytes32(0)) {\r\n            (bool canceled, , address relayer) = _decodeReceipt(intentReceipt[_id]);\r\n            require(relayer == address(0), \"Intent already relayed\");\r\n            require(!canceled, \"Intent was canceled\");\r\n            revert(\"Unknown error\");\r\n        }\r\n\r\n        emit Canceled(_id);\r\n        intentReceipt[_id] = _encodeReceipt(true, 0, address(0));\r\n    }\r\n\r\n    // Encodes an Intent receipt\r\n    // into a single bytes32\r\n    // canceled (1 bit) + block (95 bits) + relayer (160 bits)\r\n    // notice: Does not validate the _block length,\r\n    // a _block overflow would not corrupt the wallet state\r\n    function _encodeReceipt(\r\n        bool _canceled,\r\n        uint256 _block,\r\n        address _relayer\r\n    ) internal pure returns (bytes32 _receipt) {\r\n        assembly {\r\n            _receipt := or(shl(255, _canceled), or(shl(160, _block), _relayer))\r\n        }\r\n    }\r\n    \r\n    // Decodes an Intent receipt\r\n    // reverse of _encodeReceipt(bool,uint256,address)\r\n    function _decodeReceipt(bytes32 _receipt) internal pure returns (\r\n        bool _canceled,\r\n        uint256 _block,\r\n        address _relayer\r\n    ) {\r\n        assembly {\r\n            _canceled := shr(255, _receipt)\r\n            _block := and(shr(160, _receipt), 0x7fffffffffffffffffffffff)\r\n            _relayer := and(_receipt, 0xffffffffffffffffffffffffffffffffffffffff)\r\n        }\r\n    }\r\n\r\n    // Used to receive ERC721 tokens\r\n    function onERC721Received(address, address, uint256, bytes calldata) external pure returns (bytes4) {\r\n        return bytes4(0x150b7a02);\r\n    }\r\n}\r\n\r\n// Bytes library to concat and transform\r\n// bytes arrays\r\nlibrary Bytes {\r\n    // Concadenates two bytes array\r\n    // Author: Gonçalo Sá <goncalo.sa@consensys.net>\r\n    function concat(\r\n        bytes memory _preBytes,\r\n        bytes memory _postBytes\r\n    ) internal pure returns (bytes memory) {\r\n        return abi.encodePacked(_preBytes, _postBytes);\r\n    }\r\n\r\n    // Concatenates a bytes array and a bytes1\r\n    function concat(bytes memory _a, bytes1 _b) internal pure returns (bytes memory _out) {\r\n        return concat(_a, abi.encodePacked(_b));\r\n    }\r\n\r\n    // Concatenates 6 bytes arrays\r\n    function concat(\r\n        bytes memory _a,\r\n        bytes memory _b,\r\n        bytes memory _c,\r\n        bytes memory _d,\r\n        bytes memory _e,\r\n        bytes memory _f\r\n    ) internal pure returns (bytes memory) {\r\n        return abi.encodePacked(\r\n            _a,\r\n            _b,\r\n            _c,\r\n            _d,\r\n            _e,\r\n            _f\r\n        );\r\n    }\r\n\r\n    // Transforms a bytes1 into bytes\r\n    function toBytes(bytes1 _a) internal pure returns (bytes memory) {\r\n        return abi.encodePacked(_a);\r\n    }\r\n\r\n    // Transform a uint256 into bytes (last 8 bits)\r\n    function toBytes1(uint256 _a) internal pure returns (bytes1 c) {\r\n        assembly { c := shl(248, _a) }\r\n    }\r\n\r\n    // Adds a bytes1 and the last 8 bits of a uint256\r\n    function plus(bytes1 _a, uint256 _b) internal pure returns (bytes1 c) {\r\n        c = toBytes1(_b);\r\n        assembly { c := add(_a, c) }\r\n    }\r\n\r\n    // Transforms a bytes into an array\r\n    // it fails if _a has more than 20 bytes\r\n    function toAddress(bytes memory _a) internal pure returns (address payable b) {\r\n        require(_a.length <= 20);\r\n        assembly {\r\n            b := shr(mul(sub(32, mload(_a)), 8), mload(add(_a, 32)))\r\n        }\r\n    }\r\n\r\n    // Returns the most significant bit of a given uint256\r\n    function mostSignificantBit(uint256 x) internal pure returns (uint256) {        \r\n        uint8 o = 0;\r\n        uint8 h = 255;\r\n        \r\n        while (h > o) {\r\n            uint8 m = uint8 ((uint16 (o) + uint16 (h)) >> 1);\r\n            uint256 t = x >> m;\r\n            if (t == 0) h = m - 1;\r\n            else if (t > 1) o = m + 1;\r\n            else return m;\r\n        }\r\n        \r\n        return h;\r\n    }\r\n\r\n    // Shrinks a given address to the minimal representation in a bytes array\r\n    function shrink(address _a) internal pure returns (bytes memory b) {\r\n        uint256 abits = mostSignificantBit(uint256(_a)) + 1;\r\n        uint256 abytes = abits / 8 + (abits % 8 == 0 ? 0 : 1);\r\n\r\n        assembly {\r\n            b := 0x0\r\n            mstore(0x0, abytes)\r\n            mstore(0x20, shl(mul(sub(32, abytes), 8), _a))\r\n        }\r\n    }\r\n}\r\n\r\nlibrary MinimalProxy {\r\n    using Bytes for bytes1;\r\n    using Bytes for bytes;\r\n\r\n    // Minimal proxy contract\r\n    // by Agusx1211\r\n    bytes constant CODE1 = hex\"60\"; // + <size>                                   // Copy code to memory\r\n    bytes constant CODE2 = hex\"80600b6000396000f3\";                               // Return and deploy contract\r\n    bytes constant CODE3 = hex\"3660008037600080366000\";   // + <pushx> + <source> // Proxy, copy calldata and start delegatecall\r\n    bytes constant CODE4 = hex\"5af43d6000803e60003d9160\"; // + <return jump>      // Do delegatecall and return jump\r\n    bytes constant CODE5 = hex\"57fd5bf3\";                                         // Return proxy\r\n\r\n    bytes1 constant BASE_SIZE = 0x1d;\r\n    bytes1 constant PUSH_1 = 0x60;\r\n    bytes1 constant BASE_RETURN_JUMP = 0x1b;\r\n\r\n    // Returns the Init code to create a\r\n    // Minimal proxy pointing to a given address\r\n    function build(address _address) internal pure returns (bytes memory initCode) {\r\n        return build(Bytes.shrink(_address));\r\n    }\r\n\r\n    function build(bytes memory _address) private pure returns (bytes memory initCode) {\r\n        require(_address.length <= 20, \"Address too long\");\r\n        initCode = Bytes.concat(\r\n            CODE1,\r\n            BASE_SIZE.plus(_address.length).toBytes(),\r\n            CODE2,\r\n            CODE3.concat(PUSH_1.plus(_address.length - 1)).concat(_address),\r\n            CODE4.concat(BASE_RETURN_JUMP.plus(_address.length)),\r\n            CODE5\r\n        );\r\n    }\r\n}\r\n\r\n// MarmoStork creates all Marmo wallets\r\n// every address has a designated marmo wallet\r\n// and can send transactions by signing Meta-Tx (Intents)\r\n//\r\n// All wallets are proxies pointing to a single\r\n// source contract, to make deployment costs viable\r\ncontract MarmoStork {\r\n    // Random Invalid signer address\r\n    // Intents signed with this address are invalid\r\n    address private constant INVALID_ADDRESS = address(0x9431Bab00000000000000000000000039bD955c9);\r\n\r\n    // Prefix of create2 address formula (EIP-1014)\r\n    bytes1 private constant CREATE2_PREFIX = byte(0xff);\r\n\r\n    // Bytecode to deploy marmo wallets\r\n    bytes public bytecode;\r\n\r\n    // Hash of the bytecode\r\n    // used to calculate create2 result\r\n    bytes32 public hash;\r\n\r\n    // Marmo Source contract\r\n    // all proxies point here\r\n    address public marmo;\r\n\r\n    // Creates a new MarmoStork (Marmo wallet Factory)\r\n    // with wallets pointing to the _source contract reference\r\n    constructor(address payable _source) public {\r\n        // Generate and save wallet creator bytecode using the provided '_source'\r\n        bytecode = MinimalProxy.build(_source);\r\n\r\n        // Precalculate init_code hash\r\n        hash = keccak256(bytecode);\r\n        \r\n        // Destroy the '_source' provided, if is not disabled\r\n        Marmo marmoc = Marmo(_source);\r\n        if (marmoc.signer() == address(0)) {\r\n            marmoc.init(INVALID_ADDRESS);\r\n        }\r\n\r\n        // Validate, the signer of _source should be \"INVALID_ADDRESS\" (disabled)\r\n        require(marmoc.signer() == INVALID_ADDRESS, \"Error init Marmo source\");\r\n\r\n        // Save the _source address, casting to address (160 bits)\r\n        marmo = address(marmoc);\r\n    }\r\n    \r\n    // Calculates the Marmo wallet for a given signer\r\n    // the wallet contract will be deployed in a deterministic manner\r\n    function marmoOf(address _signer) external view returns (address) {\r\n        // CREATE2 address\r\n        return address(\r\n            uint256(\r\n                keccak256(\r\n                    abi.encodePacked(\r\n                        CREATE2_PREFIX,\r\n                        address(this),\r\n                        bytes32(uint256(_signer)),\r\n                        hash\r\n                    )\r\n                )\r\n            )\r\n        );\r\n    }\r\n\r\n    // Deploys the Marmo wallet of a given _signer\r\n    // all ETH sent will be forwarded to the wallet\r\n    function reveal(address _signer) external payable {\r\n        // Load init code from storage\r\n        bytes memory proxyCode = bytecode;\r\n\r\n        // Create wallet proxy using CREATE2\r\n        // use _signer as salt\r\n        Marmo p;\r\n        assembly {\r\n            p := create2(0, add(proxyCode, 0x20), mload(proxyCode), _signer)\r\n        }\r\n\r\n        // Init wallet with provided _signer\r\n        // and forward all Ether\r\n        p.init.value(msg.value)(_signer);\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"marmo\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"hash\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_signer\",\"type\":\"address\"}],\"name\":\"reveal\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_signer\",\"type\":\"address\"}],\"name\":\"marmoOf\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bytecode\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_source\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"}]","ContractName":"MarmoStork","CompilerVersion":"v0.5.5+commit.47a71e8f","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"0000000000000000000000004583863934721f05cc845d19dd0e40eef1f94964","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"bzzr://2ae3ee2a0635db2e7fae7aff10c135602ff8c5c5d15d79a9d25a131ea92140c7"}]}