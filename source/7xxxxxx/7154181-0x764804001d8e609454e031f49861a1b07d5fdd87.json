{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.11;\r\n\r\n/*\r\n--------------------------------------------------------------------------------\r\nThe TBBT [TBBT] Token Smart Contract\r\n\r\nCredit:\r\nStefan CrnojeviÄ‡ scrnojevic@protonmail.ch\r\nTBBT Inc, Game Credits Inc\r\n\r\nERC20: https://github.com/ethereum/EIPs/issues/20\r\nERC223: https://github.com/ethereum/EIPs/issues/223\r\n\r\nMIT Licence\r\n--------------------------------------------------------------------------------\r\n*/\r\n\r\n/*\r\n* Contract that is working with ERC223 tokens\r\n*/\r\n\r\ncontract ContractReceiver {\r\n  function tokenFallback(address _from, uint _value, bytes _data) {\r\n    /* Fix for Mist warning */\r\n    _from;\r\n    _value;\r\n    _data;\r\n  }\r\n}\r\n\r\ncontract TBBToken {\r\n    /* Contract Constants */\r\n    string public constant _name = \"TBBT Token\";\r\n    string public constant _symbol = \"TBBT\";\r\n    uint8 public constant _decimals = 8;\r\n\r\n    /* The supply is initially 500,000,000TBBT to the precision of 8 decimals */\r\n    uint256 public constant _initialSupply = 50000000000000000;\r\n\r\n    /* Contract Variables */\r\n    address public owner;\r\n    uint256 public _currentSupply;\r\n    mapping(address => uint256) public balances;\r\n    mapping(address => mapping (address => uint256)) public allowed;\r\n\r\n    /* Constructor initializes the owner's balance and the supply  */\r\n    function TBBToken() {\r\n        owner = msg.sender;\r\n        _currentSupply = _initialSupply;\r\n        balances[owner] = _initialSupply;\r\n    }\r\n\r\n    /* ERC20 Events */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed from, address indexed to, uint256 value);\r\n\r\n    /* ERC223 Events */\r\n    event Transfer(address indexed from, address indexed to, uint value, bytes data);\r\n\r\n    /* Non-ERC Events */\r\n    event Burn(address indexed from, uint256 amount, uint256 currentSupply, bytes data);\r\n\r\n    /* ERC20 Functions */\r\n    /* Return current supply in smallest denomination (1TBBT = 100000000) */\r\n    function totalSupply() constant returns (uint256 totalSupply) {\r\n        return _initialSupply;\r\n    }\r\n\r\n    /* Returns the balance of a particular account */\r\n    function balanceOf(address _address) constant returns (uint256 balance) {\r\n        return balances[_address];\r\n    }\r\n\r\n    /* Transfer the balance from the sender's address to the address _to */\r\n    function transfer(address _to, uint _value) returns (bool success) {\r\n        if (balances[msg.sender] >= _value\r\n            && _value > 0\r\n            && balances[_to] + _value > balances[_to]) {\r\n            bytes memory empty;\r\n            if(isContract(_to)) {\r\n                return transferToContract(_to, _value, empty);\r\n            } else {\r\n                return transferToAddress(_to, _value, empty);\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /* Withdraws to address _to form the address _from up to the amount _value */\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\n        if (balances[_from] >= _value\r\n            && allowed[_from][msg.sender] >= _value\r\n            && _value > 0\r\n            && balances[_to] + _value > balances[_to]) {\r\n            balances[_from] -= _value;\r\n            allowed[_from][msg.sender] -= _value;\r\n            balances[_to] += _value;\r\n            Transfer(_from, _to, _value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /* Allows _spender to withdraw the _allowance amount form sender */\r\n    function approve(address _spender, uint256 _allowance) returns (bool success) {\r\n        if (_allowance <= _currentSupply) {\r\n            allowed[msg.sender][_spender] = _allowance;\r\n            Approval(msg.sender, _spender, _allowance);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /* Checks how much _spender can withdraw from _owner */\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n    /* ERC223 Functions */\r\n    /* Get the contract constant _name */\r\n    function name() constant returns (string name) {\r\n        return _name;\r\n    }\r\n\r\n    /* Get the contract constant _symbol */\r\n    function symbol() constant returns (string symbol) {\r\n        return _symbol;\r\n    }\r\n\r\n    /* Get the contract constant _decimals */\r\n    function decimals() constant returns (uint8 decimals) {\r\n        return _decimals;\r\n    }\r\n\r\n    /* Transfer the balance from the sender's address to the address _to with data _data */\r\n    function transfer(address _to, uint _value, bytes _data) returns (bool success) {\r\n        if (balances[msg.sender] >= _value\r\n            && _value > 0\r\n            && balances[_to] + _value > balances[_to]) {\r\n            if(isContract(_to)) {\r\n                return transferToContract(_to, _value, _data);\r\n            } else {\r\n                return transferToAddress(_to, _value, _data);\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /* Transfer function when _to represents a regular address */\r\n    function transferToAddress(address _to, uint _value, bytes _data) internal returns (bool success) {\r\n        balances[msg.sender] -= _value;\r\n        balances[_to] += _value;\r\n        Transfer(msg.sender, _to, _value);\r\n        Transfer(msg.sender, _to, _value, _data);\r\n        return true;\r\n    }\r\n\r\n    /* Transfer function when _to represents a contract address, with the caveat\r\n    that the contract needs to implement the tokenFallback function in order to receive tokens */\r\n    function transferToContract(address _to, uint _value, bytes _data) internal returns (bool success) {\r\n        balances[msg.sender] -= _value;\r\n        balances[_to] += _value;\r\n        ContractReceiver receiver = ContractReceiver(_to);\r\n        receiver.tokenFallback(msg.sender, _value, _data);\r\n        Transfer(msg.sender, _to, _value);\r\n        Transfer(msg.sender, _to, _value, _data);\r\n        return true;\r\n    }\r\n\r\n    /* Infers if whether _address is a contract based on the presence of bytecode */\r\n    function isContract(address _address) internal returns (bool is_contract) {\r\n        uint length;\r\n        if (_address == 0) return false;\r\n        assembly {\r\n            length := extcodesize(_address)\r\n        }\r\n        if(length > 0) {\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /* Non-ERC Functions */\r\n    /* Remove the specified amount of the tokens from the supply permanently */\r\n    function burn(uint256 _value, bytes _data) returns (bool success) {\r\n        if (balances[msg.sender] >= _value\r\n            && _value > 0) {\r\n            balances[msg.sender] -= _value;\r\n            _currentSupply -= _value;\r\n            Burn(msg.sender, _value, _currentSupply, _data);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /* Returns the total amount of tokens in supply */\r\n    function currentSupply() constant returns (uint256 currentSupply) {\r\n        return _currentSupply;\r\n    }\r\n\r\n    /* Returns the total amount of tokens ever burned */\r\n    function amountBurned() constant returns (uint256 amountBurned) {\r\n        return _initialSupply - _currentSupply;\r\n    }\r\n\r\n    /* Stops any attempt to send Ether to this contract */\r\n    function () {\r\n        throw;\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"tokenFallback\",\"outputs\":[],\"payable\":false,\"type\":\"function\"}]","ContractName":"ContractReceiver","CompilerVersion":"v0.4.11+commit.68ef5810","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://3fabaf667b829b3d4554b8807d5821895ecd8ae56cea82e1bef738e36993fded"}]}