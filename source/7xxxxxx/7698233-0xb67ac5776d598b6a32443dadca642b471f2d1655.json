{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.0;\r\n\r\ncontract DSMath {\r\n    function add(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x + y) >= x, \"ds-math-add-overflow\");\r\n    }\r\n    function sub(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x - y) <= x, \"ds-math-sub-underflow\");\r\n    }\r\n    function mul(uint x, uint y) internal pure returns (uint z) {\r\n        require(y == 0 || (z = x * y) / y == x, \"ds-math-mul-overflow\");\r\n    }\r\n\r\n    function min(uint x, uint y) internal pure returns (uint z) {\r\n        return x <= y ? x : y;\r\n    }\r\n    function max(uint x, uint y) internal pure returns (uint z) {\r\n        return x >= y ? x : y;\r\n    }\r\n    function imin(int x, int y) internal pure returns (int z) {\r\n        return x <= y ? x : y;\r\n    }\r\n    function imax(int x, int y) internal pure returns (int z) {\r\n        return x >= y ? x : y;\r\n    }\r\n\r\n    uint constant WAD = 10 ** 18;\r\n    uint constant RAY = 10 ** 27;\r\n\r\n    function wmul(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, y), WAD / 2) / WAD;\r\n    }\r\n    function rmul(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, y), RAY / 2) / RAY;\r\n    }\r\n    function wdiv(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, WAD), y / 2) / y;\r\n    }\r\n    function rdiv(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, RAY), y / 2) / y;\r\n    }\r\n    function rpow(uint x, uint n) internal pure returns (uint z) {\r\n        z = n % 2 != 0 ? x : RAY;\r\n\r\n        for (n /= 2; n != 0; n /= 2) {\r\n            x = rmul(x, x);\r\n\r\n            if (n % 2 != 0) {\r\n                z = rmul(z, x);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n\r\ncontract Bank is DSMath {\r\n  mapping(address => uint) public balances;\r\n\r\n  function deposit() public payable returns (uint balance) {\r\n    balances[msg.sender] = add(balances[msg.sender], msg.value);\r\n    return balances[msg.sender];\r\n  }\r\n\r\n  function withdraw(uint amount) public returns (uint remainingBalance){\r\n    require(min(amount,balances[msg.sender]) == amount);\r\n    balances[msg.sender] = sub(balances[msg.sender],amount);\r\n    msg.sender.transfer(amount);\r\n    return balances[msg.sender];\r\n  }\r\n\r\n  function balance() view public returns (uint) {\r\n    return balances[msg.sender];\r\n  }\r\n}\r\n\r\n\r\ncontract OwnsArtSplit is DSMath, Bank{\r\n    struct Bundle{\r\n        address owner;\r\n        uint decayedTime;\r\n    }\r\n    //8 bits: exponent\r\n    //124 bits: generation\r\n    //124 bits: sibling\r\n    uint public constant exponentMask    = 0xff00000000000000000000000000000000000000000000000000000000000000;\r\n    uint public constant generationMask  = 0x00fffffffffffffffffffffffffffffff0000000000000000000000000000000;\r\n    uint public constant siblingMask     = 0xff0000000000000000000000000000000fffffffffffffffffffffffffffffff;\r\n    mapping(uint => Bundle) public bundleTable;\r\n    \r\n    //maps the bundle exponent to find sibling for that bundle size\r\n    //next sibling for generation\r\n    mapping(uint8 => mapping(uint128 => uint128)) public siblingTable;\r\n\r\n    address public artist;\r\n    uint public constant price = 0.01 ether;\r\n    uint public constant resaleFee = 0.001 ether;\r\n    uint public constant maxBundlesPerPurchase = 0xff;\r\n    uint public constant maxBundleExponent = 16;\r\n    uint public constant artDecayTime = 30 days;\r\n    uint public constant itemsPerBundle = 10;\r\n    \r\n    bool private buyArtMutex = false;\r\n    \r\n    event LogPurchase(uint[] destroyedBundleID, uint[] createdBundleID1, uint[] createdBundleID2, uint decay, address buyer);\r\n    event LogBundling(uint[] bundledIDs, uint newBundleID, uint decay, address bundler);\r\n    event LogUnbundling(uint unbundledID, uint[] newBundleIDs, uint decay, address bundler);\r\n    \r\n    constructor() public {\r\n        artist = msg.sender;\r\n        bundleTable[0] = Bundle(msg.sender, now+artDecayTime);\r\n        siblingTable[0][0] = 1;\r\n    }\r\n    \r\n    function buyArtworkBundles(uint[] memory bundleIDs) public{\r\n        require(min(bundleIDs.length,maxBundlesPerPurchase)==bundleIDs.length,\"Cannot buy too many bundles at once.\");\r\n        uint8 numberOfBundles = uint8(bundleIDs.length);\r\n        require(numberOfBundles != 0,\"Must buy more than zero bundles.\");\r\n        \r\n        uint[] memory createdBundleID1  = new uint[](numberOfBundles);\r\n        uint[] memory createdBundleID2  = new uint[](numberOfBundles);\r\n        \r\n        require(!buyArtMutex,\"Only one person can buy bundles at the same time. Try again later.\");\r\n        buyArtMutex = true;\r\n        \r\n        for (uint i=0; i<numberOfBundles; i++) {\r\n            Bundle memory bundle = bundleTable[bundleIDs[i]];\r\n            (uint128 generation, , uint8 exponent) = splitBundleID(bundleIDs[i]);\r\n            require(testValidBundle(bundle),\"Bundle is invalid. Check decaytime, existence.\");\r\n            require(bundle.owner != msg.sender,\"Buyer cannot be same as current owner.\");\r\n            require(min(exponent,maxBundleExponent)==exponent,\"Exponent cannot be too large\");\r\n\r\n            //sell old bundle\r\n            uint multiplier = itemsPerBundle**uint(exponent);\r\n            balances[msg.sender] = sub(balances[msg.sender],price*multiplier);\r\n            balances[bundle.owner] = add(balances[bundle.owner],sub(price*multiplier,resaleFee*multiplier));\r\n            balances[artist] = add(balances[artist],resaleFee*multiplier);\r\n            \r\n            //destroy old bundle\r\n            delete bundleTable[bundleIDs[i]] ;//= bundle;\r\n            \r\n            //create two new bundles\r\n            uint128 sibling = siblingTable[exponent][generation+1];\r\n            uint bundleID1 = generateBundleID(generation+1,sibling,exponent);\r\n            uint bundleID2 = generateBundleID(generation+1,sibling+1,exponent);\r\n            Bundle memory newBundle = Bundle(msg.sender, add(now, artDecayTime));\r\n            bundleTable[bundleID1] = newBundle;\r\n            bundleTable[bundleID2] = newBundle;\r\n            \r\n            //save IDs for logging\r\n            createdBundleID1[i] = bundleID1;\r\n            createdBundleID2[i] = bundleID2;\r\n            \r\n            //update next sibling\r\n            siblingTable[exponent][generation+1] = siblingTable[exponent][generation+1] + 2;\r\n        }\r\n        \r\n        emit LogPurchase(bundleIDs,createdBundleID1,createdBundleID2,add(now,artDecayTime),msg.sender);\r\n        \r\n        buyArtMutex = false;\r\n    }\r\n    \r\n    function bundling(uint[] memory bundleIDs) public{\r\n        require(bundleIDs.length == itemsPerBundle);\r\n        //prevent bundling that goes over maxBundleExponent\r\n        (,,uint8 exponent) = splitBundleID(bundleIDs[0]);\r\n        require(min(exponent,maxBundleExponent-1)==exponent);\r\n        \r\n        \r\n        //deactivate and test old bundles\r\n        uint soonestDecay = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\r\n        for (uint i=0; i<itemsPerBundle; i++){\r\n            Bundle memory bundle = bundleTable[bundleIDs[i]];\r\n            (,,uint8 currentExponent) = splitBundleID(bundleIDs[i]);\r\n            require(currentExponent == exponent,\"All bundles must have the same exponent\");\r\n            require(testValidBundle(bundle),\"Bundle is invalid. Check decaytime, existence.\");\r\n            require(bundle.owner == msg.sender, \"Cannot bundle items sender does not own.\");\r\n            delete bundleTable[bundleIDs[i]];\r\n            if(min(soonestDecay,bundle.decayedTime)==bundle.decayedTime){\r\n                soonestDecay = bundle.decayedTime;\r\n            }\r\n        }\r\n        \r\n        //generate new bundle\r\n        uint128 generation = 0;\r\n        uint128 sibling = siblingTable[exponent+1][generation];\r\n        uint newBundleID = generateBundleID(generation,sibling,exponent+1);\r\n        bundleTable[newBundleID] = Bundle(msg.sender, soonestDecay);\r\n        siblingTable[exponent+1][generation] = sibling + 1;\r\n        \r\n        emit LogBundling(bundleIDs,newBundleID,soonestDecay,msg.sender);\r\n    }\r\n    \r\n    function unbundling(uint bundleID) public{\r\n        (,,uint8 exponent) = splitBundleID(bundleID);\r\n        require(min(exponent,maxBundleExponent)==exponent,\"Exponent must be less than max.\");\r\n        require(min(exponent,0)!=exponent,\"Bundle must have an exponent greater than 0.\");\r\n        Bundle memory bundle = bundleTable[bundleID];\r\n        require(testValidBundle(bundle),\"Bundle is invalid. Check decaytime, existence.\");\r\n        require(bundle.owner == msg.sender,\"Can only unbundle items owned by sender.\");\r\n        Bundle memory newBundle = Bundle(msg.sender,bundle.decayedTime);\r\n        uint[] memory newBundleIDs = new uint[](10);\r\n        for (uint i=0; i<itemsPerBundle; i++){\r\n            uint id = generateBundleID(0,siblingTable[exponent-1][0],exponent-1);\r\n            bundleTable[id] = newBundle;\r\n            newBundleIDs[i] = id;\r\n            siblingTable[exponent-1][0] = siblingTable[exponent-1][0] + 1;\r\n        }\r\n        delete bundleTable[bundleID];\r\n        \r\n        emit LogUnbundling(bundleID,newBundleIDs,newBundle.decayedTime,msg.sender);\r\n    }\r\n    \r\n    function splitBundleID(uint bundleID) pure public returns (uint128 generation, uint128 sibling, uint8 exponent){\r\n        return(uint128((bundleID&generationMask)>>124),uint128((bundleID&siblingMask)),uint8((bundleID&exponentMask)>>248));\r\n    }\r\n    \r\n    function generateBundleID(uint128 generation, uint128 sibling, uint8 exponent) pure public returns(uint bundleID){\r\n        return (uint(generation) << 124) | uint(sibling) | (uint(exponent) << 248);\r\n    }\r\n    \r\n    function testValidBundle(Bundle memory bundle) view private returns (bool){\r\n        return \r\n            (bundle.decayedTime != 0) &&\r\n            (!isDecayed(bundle.decayedTime));\r\n    }\r\n\r\n    function isDecayed(uint decayedTime) view public returns (bool){\r\n        return (min(now,decayedTime) != now);\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"generationMask\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"balances\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"bundleIDs\",\"type\":\"uint256[]\"}],\"name\":\"buyArtworkBundles\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[{\"name\":\"remainingBalance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint8\"},{\"name\":\"\",\"type\":\"uint128\"}],\"name\":\"siblingTable\",\"outputs\":[{\"name\":\"\",\"type\":\"uint128\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"artDecayTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxBundleExponent\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"artist\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"exponentMask\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"resaleFee\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"decayedTime\",\"type\":\"uint256\"}],\"name\":\"isDecayed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"bundleTable\",\"outputs\":[{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"decayedTime\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"siblingMask\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"bundleID\",\"type\":\"uint256\"}],\"name\":\"unbundling\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"bundleID\",\"type\":\"uint256\"}],\"name\":\"splitBundleID\",\"outputs\":[{\"name\":\"generation\",\"type\":\"uint128\"},{\"name\":\"sibling\",\"type\":\"uint128\"},{\"name\":\"exponent\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"price\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"itemsPerBundle\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"generation\",\"type\":\"uint128\"},{\"name\":\"sibling\",\"type\":\"uint128\"},{\"name\":\"exponent\",\"type\":\"uint8\"}],\"name\":\"generateBundleID\",\"outputs\":[{\"name\":\"bundleID\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"balance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"deposit\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"bundleIDs\",\"type\":\"uint256[]\"}],\"name\":\"bundling\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxBundlesPerPurchase\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"destroyedBundleID\",\"type\":\"uint256[]\"},{\"indexed\":false,\"name\":\"createdBundleID1\",\"type\":\"uint256[]\"},{\"indexed\":false,\"name\":\"createdBundleID2\",\"type\":\"uint256[]\"},{\"indexed\":false,\"name\":\"decay\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"buyer\",\"type\":\"address\"}],\"name\":\"LogPurchase\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"bundledIDs\",\"type\":\"uint256[]\"},{\"indexed\":false,\"name\":\"newBundleID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"decay\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"bundler\",\"type\":\"address\"}],\"name\":\"LogBundling\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"unbundledID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"newBundleIDs\",\"type\":\"uint256[]\"},{\"indexed\":false,\"name\":\"decay\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"bundler\",\"type\":\"address\"}],\"name\":\"LogUnbundling\",\"type\":\"event\"}]","ContractName":"OwnsArtSplit","CompilerVersion":"v0.5.7+commit.6da8b019","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://38cce690f4cf5045cb2df98a28c32ef6bc513307b2be49a336b1f37551776685"}]}