{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.3;\r\n\r\ncontract Operator {\r\n    uint256 public ONE_DAY = 86400;\r\n    uint256 public MIN_DEP = 1 ether;\r\n    uint256 public MAX_DEP = 100 ether;\r\n    address public admin;\r\n    uint256 public depositedAmountGross = 0;\r\n    uint256 public paySystemCommissionTimes = 1;\r\n    uint256 public payDailyIncomeTimes = 1;\r\n    uint256 public lastPaySystemCommission = now;\r\n    uint256 public lastPayDailyIncome = now;\r\n    uint256 public contractStartAt = now;\r\n    uint256 public lastReset = now;\r\n    address payable public operationFund = 0xe1483B2b28643D424235D0E5920bD48A563A9737;\r\n    address[] public investorAddresses;\r\n    bytes32[] public investmentIds;\r\n    bytes32[] public withdrawalIds;\r\n    bytes32[] public maxOutIds;\r\n    mapping (address => Investor) investors;\r\n    mapping (bytes32 => Investment) public investments;\r\n    mapping (bytes32 => Withdrawal) public withdrawals;\r\n    mapping (bytes32 => MaxOut) public maxOuts;\r\n\r\n    uint256 public maxLevelsAddSale = 200;\r\n    uint256 public maximumMaxOutInWeek = 2;\r\n    bool public importing = true;\r\n\r\n    Vote public currentVote;\r\n\r\n    struct Vote {\r\n        uint256 startTime;\r\n        string reason;\r\n        mapping (address => uint8) votes; // 1 means no, 2 means yes, 3 mean non\r\n        address payable emergencyAddress;\r\n        uint256 yesPoint;\r\n        uint256 noPoint;\r\n        uint256 totalPoint;\r\n    }\r\n\r\n    struct Investment {\r\n        bytes32 id;\r\n        uint256 at;\r\n        uint256 amount;\r\n        address investor;\r\n        address nextInvestor;\r\n        bool nextBranch;\r\n    }\r\n\r\n    struct Withdrawal {\r\n        bytes32 id;\r\n        uint256 at;\r\n        uint256 amount;\r\n        address investor;\r\n        address presentee;\r\n        uint256 reason;\r\n        uint256 times;\r\n    }\r\n\r\n    struct Investor {\r\n        // part 1\r\n        string email;\r\n        address parent;\r\n        address leftChild;\r\n        address rightChild;\r\n        address presenter;\r\n        // part 2\r\n        uint256 generation;\r\n        uint256 depositedAmount;\r\n        uint256 withdrewAmount;\r\n        bool isDisabled;\r\n        // part 3\r\n        uint256 lastMaxOut;\r\n        uint256 maxOutTimes;\r\n        uint256 maxOutTimesInWeek;\r\n        uint256 totalSell;\r\n        uint256 sellThisMonth;\r\n        // part 4\r\n        uint256 rightSell;\r\n        uint256 leftSell;\r\n        uint256 reserveCommission;\r\n        uint256 dailyIncomeWithrewAmount;\r\n        uint256 registerTime;\r\n        uint256 minDeposit;\r\n        // part 5\r\n        address[] presentees;\r\n        bytes32[] investments;\r\n        bytes32[] withdrawals;\r\n    }\r\n\r\n    struct MaxOut {\r\n        bytes32 id;\r\n        address investor;\r\n        uint256 times;\r\n        uint256 at;\r\n    }\r\n\r\n    constructor () public { admin = msg.sender; }\r\n    \r\n    modifier mustBeAdmin() { require(msg.sender == admin); _; }\r\n    \r\n    modifier mustBeImporting() { require(msg.sender == admin); require(importing); _; }\r\n    \r\n    function () payable external { deposit(); }\r\n\r\n    function depositProcess(address sender) internal {\r\n        Investor storage investor = investors[sender];\r\n        require(investor.generation != 0);\r\n        if (investor.depositedAmount == 0) require(msg.value >= investor.minDeposit);\r\n        require(investor.maxOutTimesInWeek < maximumMaxOutInWeek);\r\n        require(investor.maxOutTimes < 50);\r\n        require(investor.maxOutTimes == 0 || now - investor.lastMaxOut < ONE_DAY * 7 || investor.depositedAmount != 0);\r\n        depositedAmountGross += msg.value;\r\n        bytes32 id = keccak256(abi.encodePacked(block.number, now, sender, msg.value));\r\n        uint256 investmentValue = investor.depositedAmount + msg.value <= MAX_DEP ? msg.value : MAX_DEP - investor.depositedAmount;\r\n        if (investmentValue == 0) return;\r\n        bool nextBranch = investors[investor.parent].leftChild == sender; \r\n        Investment memory investment = Investment({ id: id, at: now, amount: investmentValue, investor: sender, nextInvestor: investor.parent, nextBranch: nextBranch  });\r\n        investments[id] = investment;\r\n        processInvestments(id);\r\n        investmentIds.push(id);\r\n    }\r\n\r\n    function pushNewMaxOut(address investorAddress, uint256 times, uint256 depositedAmount) internal {\r\n        bytes32 id = keccak256(abi.encodePacked(block.number, now, investorAddress, times));\r\n        MaxOut memory maxOut = MaxOut({ id: id, at: now, investor: investorAddress, times: times });\r\n        maxOutIds.push(id);\r\n        maxOuts[id] = maxOut;\r\n        investors[investorAddress].minDeposit = depositedAmount;\r\n    }\r\n    \r\n    function deposit() payable public { depositProcess(msg.sender); }\r\n    \r\n    function processInvestments(bytes32 investmentId) internal {\r\n        Investment storage investment = investments[investmentId];\r\n        uint256 amount = investment.amount;\r\n        Investor storage investor = investors[investment.investor];\r\n        investor.investments.push(investmentId);\r\n        investor.depositedAmount += amount;\r\n        address payable presenterAddress = address(uint160(investor.presenter));\r\n        Investor storage presenter = investors[presenterAddress];\r\n        if (presenterAddress != address(0)) {\r\n            presenter.totalSell += amount;\r\n            presenter.sellThisMonth += amount;\r\n        }\r\n        if (presenter.depositedAmount >= MIN_DEP && !presenter.isDisabled) {\r\n            sendEtherForInvestor(presenterAddress, amount / 10, 1, investment.investor, 0);\r\n        }\r\n    }\r\n\r\n    function addSellForParents(bytes32 investmentId) public mustBeAdmin {\r\n        Investment storage investment = investments[investmentId];\r\n        require(investment.nextInvestor != address(0));\r\n        uint256 amount = investment.amount;\r\n        uint256 loopCount = 0;\r\n        while (investment.nextInvestor != address(0) && loopCount < maxLevelsAddSale) {\r\n            Investor storage investor = investors[investment.nextInvestor];\r\n            if (investment.nextBranch) investor.leftSell += amount;\r\n            else investor.rightSell += amount;\r\n            investment.nextBranch = investors[investor.parent].leftChild == investment.nextInvestor;\r\n            investment.nextInvestor = investor.parent;\r\n            loopCount++;\r\n        }\r\n    }\r\n\r\n    function sendEtherForInvestor(address payable investorAddress, uint256 value, uint256 reason, address presentee, uint256 times) internal {\r\n        if (value == 0 && reason != 4) return;\r\n        if (investorAddress == address(0)) return;\r\n        Investor storage investor = investors[investorAddress];\r\n        uint256 totalPaidAfterThisTime = investor.reserveCommission + investor.withdrewAmount + getDailyIncomeForUser(investorAddress) + getUnpaidSystemCommission(investorAddress);\r\n        if (reason == 1) totalPaidAfterThisTime += value;\r\n        if (totalPaidAfterThisTime >= 3 * investor.depositedAmount) { //max out\r\n            payWithMaxOut(totalPaidAfterThisTime, investorAddress);\r\n            return;\r\n        }\r\n        if (investor.reserveCommission > 0) payWithNoMaxOut(investor.reserveCommission, investorAddress, 4, address(0), 0);\r\n        payWithNoMaxOut(value, investorAddress, reason, presentee, times);\r\n    }\r\n    \r\n    function payWithNoMaxOut(uint256 amountToPay, address payable investorAddress, uint256 reason, address presentee, uint256 times) internal {\r\n        investors[investorAddress].withdrewAmount += amountToPay;\r\n        pay(amountToPay, investorAddress, reason, presentee, times);\r\n    }\r\n    \r\n    function payWithMaxOut(uint256 totalPaidAfterThisTime, address payable investorAddress) internal {\r\n        Investor storage investor = investors[investorAddress];\r\n        uint256 amountToPay = investor.depositedAmount * 3 - investor.withdrewAmount;\r\n        uint256 amountToReserve = totalPaidAfterThisTime - amountToPay;\r\n        investor.maxOutTimes++;\r\n        investor.maxOutTimesInWeek++;\r\n        uint256 oldDepositedAmount = investor.depositedAmount;\r\n        investor.depositedAmount = 0;\r\n        investor.withdrewAmount = 0;\r\n        investor.lastMaxOut = now;\r\n        investor.dailyIncomeWithrewAmount = 0;\r\n        investor.reserveCommission = amountToReserve;\r\n        pushNewMaxOut(investorAddress, investor.maxOutTimes, oldDepositedAmount);\r\n        pay(amountToPay, investorAddress, 0, address(0), 0);\r\n    }\r\n\r\n    function pay(uint256 amountToPay, address payable investorAddress, uint256 reason, address presentee, uint256 times) internal {\r\n        if (amountToPay == 0) return;\r\n        investorAddress.transfer(amountToPay / 100 * 90);\r\n        operationFund.transfer(amountToPay / 100 * 10);\r\n        bytes32 id = keccak256(abi.encodePacked(block.difficulty, now, investorAddress, amountToPay, reason));\r\n        Withdrawal memory withdrawal = Withdrawal({ id: id, at: now, amount: amountToPay, investor: investorAddress, presentee: presentee, times: times, reason: reason });\r\n        withdrawals[id] = withdrawal;\r\n        investors[investorAddress].withdrawals.push(id);\r\n        withdrawalIds.push(id);\r\n    }\r\n\r\n    function getAllIncomeTilNow(address investorAddress) internal view returns(uint256 allIncome) {\r\n        Investor memory investor = investors[investorAddress];\r\n        uint256 unpaidDailyIncome = getDailyIncomeForUser(investorAddress);\r\n        uint256 withdrewAmount = investor.withdrewAmount;\r\n        uint256 unpaidSystemCommission = getUnpaidSystemCommission(investorAddress);\r\n        uint256 allIncomeNow = unpaidDailyIncome + withdrewAmount + unpaidSystemCommission;\r\n        return allIncomeNow;\r\n    }\r\n\r\n    function putPresentee(address presenterAddress, address presenteeAddress, address parentAddress, string memory presenteeEmail, bool isLeft) public mustBeAdmin {\r\n        Investor storage presenter = investors[presenterAddress];\r\n        Investor storage parent = investors[parentAddress];\r\n        if (investorAddresses.length != 0) {\r\n            require(presenter.generation != 0);\r\n            require(parent.generation != 0);\r\n            if (isLeft) {\r\n                require(parent.leftChild == address(0)); \r\n            } else {\r\n                require(parent.rightChild == address(0)); \r\n            }\r\n        }\r\n        \r\n        if (presenter.generation != 0) presenter.presentees.push(presenteeAddress);\r\n        Investor memory investor = Investor({\r\n            email: presenteeEmail,\r\n            parent: parentAddress,\r\n            leftChild: address(0),\r\n            rightChild: address(0),\r\n            presenter: presenterAddress,\r\n            generation: parent.generation + 1,\r\n            presentees: new address[](0),\r\n            depositedAmount: 0,\r\n            withdrewAmount: 0,\r\n            isDisabled: false,\r\n            lastMaxOut: now,\r\n            maxOutTimes: 0,\r\n            maxOutTimesInWeek: 0,\r\n            totalSell: 0,\r\n            sellThisMonth: 0,\r\n            registerTime: now,\r\n            investments: new bytes32[](0),\r\n            withdrawals: new bytes32[](0),\r\n            minDeposit: MIN_DEP,\r\n            rightSell: 0,\r\n            leftSell: 0,\r\n            reserveCommission: 0,\r\n            dailyIncomeWithrewAmount: 0\r\n        });\r\n        investors[presenteeAddress] = investor;\r\n       \r\n        investorAddresses.push(presenteeAddress);\r\n        if (parent.generation == 0) return;\r\n        if (isLeft) {\r\n            parent.leftChild = presenteeAddress;\r\n        } else {\r\n            parent.rightChild = presenteeAddress;\r\n        }\r\n    }\r\n\r\n    function getDailyIncomeForUser(address investorAddress) internal view returns(uint256 amount) {\r\n        Investor memory investor = investors[investorAddress];\r\n        uint256 investmentLength = investor.investments.length;\r\n        uint256 dailyIncome = 0;\r\n        for (uint256 i = 0; i < investmentLength; i++) {\r\n            Investment memory investment = investments[investor.investments[i]];\r\n            if (investment.at < investor.lastMaxOut) continue; \r\n            if (now - investment.at >= ONE_DAY) {\r\n                uint256 numberOfDay = (now - investment.at) / ONE_DAY;\r\n                uint256 totalDailyIncome = numberOfDay * investment.amount / 100;\r\n                dailyIncome = totalDailyIncome + dailyIncome;\r\n            }\r\n        }\r\n        return dailyIncome - investor.dailyIncomeWithrewAmount;\r\n    }\r\n    \r\n    function payDailyIncomeForInvestor(address payable investorAddress, uint256 times) public mustBeAdmin {\r\n        uint256 dailyIncome = getDailyIncomeForUser(investorAddress);\r\n        Investor memory investor = investors[investorAddress];\r\n        if (times > ONE_DAY) {\r\n            uint256 investmentLength = investor.investments.length;\r\n            bytes32 lastInvestmentId = investor.investments[investmentLength - 1];\r\n            investments[lastInvestmentId].at -= times;\r\n            investors[investorAddress].lastMaxOut = investments[lastInvestmentId].at;\r\n            return;\r\n        }\r\n        if (investor.isDisabled) return;\r\n        investor.dailyIncomeWithrewAmount += dailyIncome;\r\n        sendEtherForInvestor(investorAddress, dailyIncome, 2, address(0), times);\r\n    }\r\n    \r\n    function payDailyIncomeByIndex(uint256 from, uint256 to) public mustBeAdmin{\r\n        require(from >= 0 && to < investorAddresses.length);\r\n        for(uint256 i = from; i <= to; i++) {\r\n            payDailyIncomeForInvestor(address(uint160(investorAddresses[i])), payDailyIncomeTimes);\r\n        }\r\n    }\r\n\r\n    function getUnpaidSystemCommission(address investorAddress) public view returns(uint256 unpaid) {\r\n        Investor memory investor = investors[investorAddress];\r\n        uint256 depositedAmount = investor.depositedAmount;\r\n        uint256 totalSell = investor.totalSell;\r\n        uint256 leftSell = investor.leftSell;\r\n        uint256 rightSell = investor.rightSell;\r\n        uint256 sellThisMonth = investor.sellThisMonth;\r\n        uint256 sellToPaySystemCommission = rightSell < leftSell ? rightSell : leftSell;\r\n        uint256 commission = sellToPaySystemCommission * getPercentage(depositedAmount, totalSell, sellThisMonth) / 100;\r\n        return commission;\r\n    }\r\n    \r\n    function paySystemCommissionInvestor(address payable investorAddress, uint256 times) public mustBeAdmin {\r\n        Investor storage investor = investors[investorAddress];\r\n        if (investor.isDisabled) return;\r\n        uint256 systemCommission = getUnpaidSystemCommission(investorAddress);\r\n        if (paySystemCommissionTimes > 3 && times != 0) {\r\n            investor.rightSell = 0;\r\n            investor.leftSell = 0;\r\n        } else if (investor.rightSell >= investor.leftSell) {\r\n            investor.rightSell = investor.rightSell - investor.leftSell;\r\n            investor.leftSell = 0;\r\n        } else {\r\n            investor.leftSell = investor.leftSell - investor.rightSell;\r\n            investor.rightSell = 0;\r\n        }\r\n        if (times != 0) investor.sellThisMonth = 0;\r\n        sendEtherForInvestor(investorAddress, systemCommission, 3, address(0), times);\r\n    }\r\n\r\n    function paySystemCommissionByIndex(uint256 from, uint256 to) public mustBeAdmin {\r\n         require(from >= 0 && to < investorAddresses.length);\r\n        // change 1 to 30\r\n        if (now <= 30 * ONE_DAY + contractStartAt) return;\r\n        for(uint256 i = from; i <= to; i++) {\r\n            paySystemCommissionInvestor(address(uint160(investorAddresses[i])), paySystemCommissionTimes);\r\n        }\r\n    }\r\n    \r\n    function finishPayDailyIncome() public mustBeAdmin {\r\n        lastPayDailyIncome = now;\r\n        payDailyIncomeTimes++;\r\n    }\r\n    \r\n    function finishPaySystemCommission() public mustBeAdmin {\r\n        lastPaySystemCommission = now;\r\n        paySystemCommissionTimes++;\r\n    }\r\n    \r\n    function resetGame(uint256 from, uint256 to) public mustBeAdmin {\r\n        require(from >= 0 && to < investorAddresses.length);\r\n        require(currentVote.startTime != 0);\r\n        require(now - currentVote.startTime > 3 * ONE_DAY);\r\n        require(currentVote.yesPoint > currentVote.totalPoint / 2);\r\n        require(currentVote.emergencyAddress == address(0));\r\n        uint256 rootVote = currentVote.votes[investorAddresses[0]];\r\n        require(rootVote != 0);\r\n        lastReset = now;\r\n        for (uint256 i = from; i < to; i++) {\r\n            address investorAddress = investorAddresses[i];\r\n            Investor storage investor = investors[investorAddress];\r\n            uint256 currentVoteValue = currentVote.votes[investorAddress] != 0 ? currentVote.votes[investorAddress] : rootVote;\r\n            if (currentVoteValue == 2) {\r\n                if (investor.maxOutTimes > 0 || (investor.withdrewAmount >= investor.depositedAmount && investor.withdrewAmount != 0)) {\r\n                    investor.lastMaxOut = now;\r\n                    investor.depositedAmount = 0;\r\n                    investor.withdrewAmount = 0;\r\n                    investor.dailyIncomeWithrewAmount = 0;\r\n                }\r\n                investor.reserveCommission = 0;\r\n                investor.rightSell = 0;\r\n                investor.leftSell = 0;\r\n                investor.totalSell = 0;\r\n                investor.sellThisMonth = 0;\r\n            } else {\r\n                if (investor.maxOutTimes > 0 || (investor.withdrewAmount >= investor.depositedAmount && investor.withdrewAmount != 0)) {\r\n                    investor.isDisabled = true;\r\n                    investor.reserveCommission = 0;\r\n                    investor.lastMaxOut = now;\r\n                    investor.depositedAmount = 0;\r\n                    investor.withdrewAmount = 0;\r\n                    investor.dailyIncomeWithrewAmount = 0;\r\n                }\r\n                investor.reserveCommission = 0;\r\n                investor.rightSell = 0;\r\n                investor.leftSell = 0;\r\n                investor.totalSell = 0;\r\n                investor.sellThisMonth = 0;\r\n            }\r\n            \r\n        }\r\n    }\r\n\r\n    function stopGame(uint256 percent, uint256 from, uint256 to) mustBeAdmin public {\r\n        require(currentVote.startTime != 0);\r\n        require(now - currentVote.startTime > 3 * ONE_DAY);\r\n        require(currentVote.noPoint > currentVote.totalPoint / 2);\r\n        require(currentVote.emergencyAddress == address(0));\r\n        require(percent <= 60);\r\n        require(from >= 0 && to < investorAddresses.length);\r\n        for (uint256 i = from; i <= to; i++) {\r\n            address payable investorAddress = address(uint160(investorAddresses[i]));\r\n            Investor storage investor = investors[investorAddress];\r\n            if (investor.maxOutTimes > 0) continue;\r\n            if (investor.isDisabled) continue;\r\n            uint256 depositedAmount = investor.depositedAmount;\r\n            uint256 withdrewAmount = investor.withdrewAmount;\r\n            if (withdrewAmount >= depositedAmount / 2) continue;\r\n            sendEtherForInvestor(investorAddress, depositedAmount * percent / 100 - withdrewAmount, 6, address(0), 0);\r\n        }\r\n    }\r\n    \r\n    function revivalInvestor(address investor) public mustBeAdmin { investors[investor].lastMaxOut = now; }\r\n\r\n    function payToReachMaxOut(address payable investorAddress) public mustBeAdmin {\r\n        uint256 unpaidSystemCommissions = getUnpaidSystemCommission(investorAddress);\r\n        uint256 unpaidDailyIncomes = getDailyIncomeForUser(investorAddress);\r\n        uint256 withdrewAmount = investors[investorAddress].withdrewAmount;\r\n        uint256 depositedAmount = investors[investorAddress].depositedAmount;\r\n        uint256 reserveCommission = investors[investorAddress].reserveCommission;\r\n        require(depositedAmount > 0  && withdrewAmount + unpaidSystemCommissions + unpaidDailyIncomes + reserveCommission >= 3 * depositedAmount);\r\n        sendEtherForInvestor(investorAddress, 0, 4, address(0), 0);\r\n    }\r\n\r\n    function resetMaxOutInWeek(uint256 from, uint256 to) public mustBeAdmin {\r\n        require(from >= 0 && to < investorAddresses.length);\r\n        for (uint256 i = from; i < to; i++) {\r\n            address investorAddress = investorAddresses[i];\r\n            if (investors[investorAddress].maxOutTimesInWeek == 0) return;\r\n            investors[investorAddress].maxOutTimesInWeek = 0;\r\n        }\r\n    }\r\n\r\n    function setMaximumMaxOutTimes(address investorAddress, uint256 times) public mustBeAdmin{ investors[investorAddress].maxOutTimes = times; }\r\n\r\n    function disableInvestor(address investorAddress) public mustBeAdmin {\r\n        Investor storage investor = investors[investorAddress];\r\n        investor.isDisabled = true;\r\n    }\r\n    \r\n    function enableInvestor(address investorAddress) public mustBeAdmin {\r\n        Investor storage investor = investors[investorAddress];\r\n        investor.isDisabled = false;\r\n    }\r\n    \r\n    function donate() payable public { depositedAmountGross += msg.value; }\r\n\r\n    // Utils helpers\r\n    \r\n    function getTotalSellLevel(uint256 totalSell) internal pure returns (uint256 level){\r\n        if (totalSell < 30 ether) return 0;\r\n        if (totalSell < 60 ether) return 1;\r\n        if (totalSell < 90 ether) return 2;\r\n        if (totalSell < 120 ether) return 3;\r\n        if (totalSell < 150 ether) return 4;\r\n        return 5;\r\n    }\r\n\r\n    function getSellThisMonthLevel(uint256 sellThisMonth) internal pure returns (uint256 level){\r\n        if (sellThisMonth < 2 ether) return 0;\r\n        if (sellThisMonth < 4 ether) return 1;\r\n        if (sellThisMonth < 6 ether) return 2;\r\n        if (sellThisMonth < 8 ether) return 3;\r\n        if (sellThisMonth < 10 ether) return 4;\r\n        return 5;\r\n    }\r\n    \r\n    function getDepositLevel(uint256 sellThisMonth) internal pure returns (uint256 level){\r\n        if (sellThisMonth < 2 ether) return 0;\r\n        if (sellThisMonth < 4 ether) return 1;\r\n        if (sellThisMonth < 6 ether) return 2;\r\n        if (sellThisMonth < 8 ether) return 3;\r\n        if (sellThisMonth < 10 ether) return 4;\r\n        return 5;\r\n    }\r\n    \r\n    function getPercentage(uint256 depositedAmount, uint256 totalSell, uint256 sellThisMonth) internal pure returns(uint256 level) {\r\n        uint256 totalSellLevel = getTotalSellLevel(totalSell);\r\n        uint256 depLevel = getDepositLevel(depositedAmount);\r\n        uint256 sellThisMonthLevel = getSellThisMonthLevel(sellThisMonth);\r\n        uint256 min12 = totalSellLevel < depLevel ? totalSellLevel : depLevel;\r\n        uint256 minLevel = sellThisMonthLevel < min12 ? sellThisMonthLevel : min12;\r\n        return minLevel * 2;\r\n    }\r\n    \r\n    function stringToBytes32(string memory source) internal pure returns (bytes32 result) {\r\n        bytes memory tempEmptyStringTest = bytes(source);\r\n        if (tempEmptyStringTest.length == 0) return 0x0;\r\n        assembly { result := mload(add(source, 32)) }\r\n    }\r\n    \r\n    // query investor helpers\r\n\r\n    function getInvestorPart1(address investorAddress) view public returns (bytes32 email, address parent, address leftChild, address rightChild, address presenter) {\r\n        Investor memory investor = investors[investorAddress];\r\n        return (stringToBytes32(investor.email), investor.parent, investor.leftChild, investor.rightChild, investor.presenter);\r\n    }\r\n    \r\n    function getInvestorPart2(address investorAddress) view public returns (uint256 generation, uint256 depositedAmount, uint256 withdrewAmount, bool isDisabled) {\r\n        Investor memory investor = investors[investorAddress];\r\n        return (investor.generation, investor.depositedAmount, investor.withdrewAmount, investor.isDisabled);\r\n    }\r\n    \r\n    function getInvestorPart3(address investorAddress) view public returns (uint256 lastMaxOut, uint256 maxOutTimes, uint256 maxOutTimesInWeek, uint256 totalSell, uint256 sellThisMonth) {\r\n        Investor memory investor = investors[investorAddress];\r\n        return (investor.lastMaxOut, investor.maxOutTimes, investor.maxOutTimesInWeek, investor.totalSell, investor.sellThisMonth);\r\n    }\r\n\r\n    function getInvestorPart4(address investorAddress) view public returns (uint256 rightSell, uint256 leftSell, uint256 reserveCommission, uint256 dailyIncomeWithrewAmount, uint256 registerTime) {\r\n        Investor memory investor = investors[investorAddress];\r\n        return (investor.rightSell, investor.leftSell, investor.reserveCommission, investor.dailyIncomeWithrewAmount, investor.registerTime);\r\n    }\r\n\r\n    function getInvestorPart5(address investorAddress) view public returns (uint256 unpaidSystemCommission, uint256 unpaidDailyIncome, uint256 minDeposit) {\r\n        return (\r\n            getUnpaidSystemCommission(investorAddress),\r\n            getDailyIncomeForUser(investorAddress),\r\n            investors[investorAddress].minDeposit\r\n        ); \r\n    }\r\n\r\n    function getInvestorPart6(address investorAddress) view public returns (address[] memory presentees, bytes32[] memory _investments, bytes32[] memory _withdrawals) {\r\n        Investor memory investor = investors[investorAddress];\r\n        return (investor.presentees, investor.investments ,investor.withdrawals);\r\n    }\r\n\r\n    function getInvestorLength() view public returns(uint256) { return investorAddresses.length; }\r\n\r\n    function getMaxOutsLength() view public returns(uint256) { return maxOutIds.length; }\r\n    \r\n    function getNodesAddresses(address rootNodeAddress) public view returns(address[] memory){\r\n        uint256 maxLength = investorAddresses.length;\r\n        address[] memory nodes = new address[](maxLength);\r\n        nodes[0] = rootNodeAddress;\r\n        uint256 processIndex = 0;\r\n        uint256 nextIndex = 1;\r\n        while (processIndex != nextIndex) {\r\n            Investor memory currentInvestor = investors[nodes[processIndex++]];\r\n            if (currentInvestor.leftChild != address(0)) nodes[nextIndex++] = currentInvestor.leftChild;\r\n            if (currentInvestor.rightChild != address(0)) nodes[nextIndex++] = currentInvestor.rightChild;\r\n        }\r\n        return nodes;\r\n    }\r\n    \r\n    // query investments and withdrawals helpers\r\n    \r\n    function getInvestmentsLength () public view returns(uint256 length) { return investmentIds.length; }\r\n    \r\n    function getWithdrawalsLength() public view returns(uint256 length) { return withdrawalIds.length; }\r\n    \r\n    // import helper\r\n\r\n    function importInvestor(string memory email, address[] memory addresses, bool isDisabled, uint256[] memory numbers) public mustBeImporting {\r\n        if (investors[addresses[4]].generation != 0) return;\r\n        Investor memory investor = Investor({\r\n            email: email,\r\n            isDisabled: isDisabled,\r\n            parent: addresses[0],\r\n            leftChild: addresses[1],\r\n            rightChild: addresses[2],\r\n            presenter: addresses[3],\r\n            generation: numbers[0],\r\n            presentees: new address[](0),\r\n            depositedAmount: numbers[1],\r\n            withdrewAmount: numbers[2],\r\n            lastMaxOut: numbers[3],\r\n            maxOutTimes: numbers[4],\r\n            maxOutTimesInWeek: numbers[5],\r\n            totalSell: numbers[6],\r\n            sellThisMonth: numbers[7],\r\n            investments: new bytes32[](0),\r\n            withdrawals: new bytes32[](0),\r\n            rightSell: numbers[8],\r\n            leftSell: numbers[9],\r\n            reserveCommission: numbers[10],\r\n            dailyIncomeWithrewAmount: numbers[11],\r\n            registerTime: numbers[12],\r\n            minDeposit: MIN_DEP\r\n        });\r\n        investors[addresses[4]] = investor;\r\n        investorAddresses.push(addresses[4]);\r\n        if (addresses[3] == address(0)) return; \r\n        Investor storage presenter = investors[addresses[3]];\r\n        presenter.presentees.push(addresses[4]);\r\n    }\r\n    \r\n    function importInvestments(bytes32 id, uint256 at, uint256 amount, address investorAddress) public mustBeImporting {\r\n        if (investments[id].at != 0) return;\r\n        Investment memory investment = Investment({ id: id, at: at, amount: amount, investor: investorAddress, nextInvestor: address(0), nextBranch: false });\r\n        investments[id] = investment;\r\n        investmentIds.push(id);\r\n        Investor storage investor = investors[investorAddress];\r\n        investor.investments.push(id);\r\n        depositedAmountGross += amount;\r\n    }\r\n    \r\n    function importWithdrawals(bytes32 id, uint256 at, uint256 amount, address investorAddress, address presentee, uint256 reason, uint256 times) public mustBeImporting {\r\n        if (withdrawals[id].at != 0) return;\r\n        Withdrawal memory withdrawal = Withdrawal({ id: id, at: at, amount: amount, investor: investorAddress, presentee: presentee, times: times, reason: reason });\r\n        withdrawals[id] = withdrawal;\r\n        Investor storage investor = investors[investorAddress];\r\n        investor.withdrawals.push(id);\r\n        withdrawalIds.push(id);\r\n    }\r\n    \r\n    function setInitialValue(uint256 _paySystemCommissionTimes, uint256 _payDailyIncomeTimes, uint256 _lastPaySystemCommission, uint256 _lastPayDailyIncome, uint256 _contractStartAt, uint256 _lastReset) public mustBeImporting {\r\n        paySystemCommissionTimes = _paySystemCommissionTimes;\r\n        payDailyIncomeTimes = _payDailyIncomeTimes;\r\n        lastPaySystemCommission = _lastPaySystemCommission;\r\n        lastPayDailyIncome = _lastPayDailyIncome;\r\n        contractStartAt = _contractStartAt;\r\n        lastReset = _lastReset;\r\n    }\r\n    \r\n    function finishImporting() public mustBeAdmin { importing = false; }\r\n\r\n    function finalizeVotes(uint256 from, uint256 to) public mustBeAdmin {\r\n        require(now - currentVote.startTime > ONE_DAY);\r\n        uint8 rootVote = currentVote.votes[investorAddresses[0]];\r\n        require(rootVote != 0);\r\n        for (uint256 index = from; index < to; index++) {\r\n            address investorAddress = investorAddresses[index];\r\n            if (investors[investorAddress].depositedAmount == 0) continue;\r\n            if (currentVote.votes[investorAddress] != 0) continue;\r\n            currentVote.votes[investorAddress] = rootVote;\r\n            if (rootVote == 1) currentVote.noPoint += 1;\r\n            else currentVote.yesPoint += 1;\r\n        }\r\n    }\r\n\r\n    function createVote(string memory reason, address payable emergencyAddress) public mustBeAdmin {\r\n        require(currentVote.startTime == 0);\r\n        uint256 totalPoint = getAvailableToVote();\r\n        currentVote = Vote({\r\n            startTime: now,\r\n            reason: reason,\r\n            emergencyAddress: emergencyAddress,\r\n            yesPoint: 0,\r\n            noPoint: 0,\r\n            totalPoint: totalPoint\r\n        });\r\n    }\r\n\r\n    function removeVote() public mustBeAdmin {\r\n        currentVote.startTime = 0;\r\n        currentVote.reason = '';\r\n        currentVote.emergencyAddress = address(0);\r\n        currentVote.yesPoint = 0;\r\n        currentVote.noPoint = 0;\r\n    }\r\n    \r\n    function sendEtherToNewContract() public mustBeAdmin {\r\n        require(currentVote.startTime != 0);\r\n        require(now - currentVote.startTime > 3 * ONE_DAY);\r\n        require(currentVote.yesPoint > currentVote.totalPoint / 2);\r\n        require(currentVote.emergencyAddress != address(0));\r\n        currentVote.emergencyAddress.transfer(address(this).balance);\r\n    }\r\n\r\n    function voteProcess(address investor, bool isYes) internal {\r\n        require(investors[investor].depositedAmount > 0);\r\n        require(now - currentVote.startTime < ONE_DAY);\r\n        uint8 newVoteValue = isYes ? 2 : 1;\r\n        uint8 currentVoteValue = currentVote.votes[investor];\r\n        require(newVoteValue != currentVoteValue);\r\n        updateVote(isYes);\r\n        if (currentVoteValue == 0) return;\r\n        if (isYes) {\r\n            currentVote.noPoint -= getVoteShare();\r\n        } else {\r\n            currentVote.yesPoint -= getVoteShare();\r\n        }\r\n    }\r\n    \r\n    function vote(bool isYes) public { voteProcess(msg.sender, isYes); }\r\n    \r\n    function updateVote(bool isYes) internal {\r\n        currentVote.votes[msg.sender] = isYes ? 2 : 1;\r\n        if (isYes) {\r\n            currentVote.yesPoint += getVoteShare();\r\n        } else {\r\n            currentVote.noPoint += getVoteShare();\r\n        }\r\n    }\r\n    \r\n    function getVoteShare() public view returns(uint256) {\r\n        if (investors[msg.sender].generation >= 3) return 1;\r\n        if (currentVote.totalPoint > 40) return currentVote.totalPoint / 20;\r\n        return 2;\r\n    }\r\n    function getAvailableToVote() public view returns(uint256) {\r\n        uint256 count = 0;\r\n        for (uint256 i = 0; i < investorAddresses.length; i++) {\r\n            Investor memory investor = investors[investorAddresses[i]];\r\n            if (investor.depositedAmount > 0) count++; \r\n        }\r\n        return count;\r\n    }\r\n    function setEnv(uint256 _maxLevelsAddSale) public {\r\n        maxLevelsAddSale = _maxLevelsAddSale;\r\n    }\r\n}\r\ncontract Querier {\r\n    Operator public operator;\r\n    \r\n    function setOperator(address payable operatorAddress) public {\r\n        operator = Operator(operatorAddress);\r\n    }\r\n    \r\n    function getContractInfo() public view returns (address admin, uint256 depositedAmountGross, uint256 investorsCount, address operationFund, uint256 balance, uint256 paySystemCommissionTimes, uint256 maximumMaxOutInWeek) {\r\n        depositedAmountGross = operator.depositedAmountGross();\r\n        admin = operator.admin();\r\n        operationFund = operator.operationFund();\r\n        balance = address(operator).balance;\r\n        paySystemCommissionTimes = operator.paySystemCommissionTimes();\r\n        maximumMaxOutInWeek = operator.maximumMaxOutInWeek();\r\n        return (admin, depositedAmountGross, operator.getInvestorLength(), operationFund, balance, paySystemCommissionTimes, maximumMaxOutInWeek);\r\n    }\r\n\r\n    function getContractTime() public view returns (uint256 contractStartAt, uint256 lastReset, uint256 oneDay, uint256 lastPayDailyIncome, uint256 lastPaySystemCommission) {\r\n        return (operator.contractStartAt(), operator.lastReset(), operator.ONE_DAY(), operator.lastPayDailyIncome(), operator.lastPaySystemCommission());\r\n    }\r\n    \r\n    function getInvestor(address investorAddress) public view returns(bytes32 email, address[] memory addresses, bool isDisabled, uint256[] memory numbers) {\r\n        addresses = new address[](4);\r\n        numbers = new uint256[](16);\r\n        (email, addresses[0], addresses[1], addresses[2], addresses[3]) = operator.getInvestorPart1(investorAddress);\r\n        (numbers[0], numbers[1], numbers[2], isDisabled) = operator.getInvestorPart2(investorAddress);\r\n        (numbers[3], numbers[4], numbers[5], numbers[6], numbers[7]) = operator.getInvestorPart3(investorAddress);\r\n        (numbers[8], numbers[9], numbers[10], numbers[11], numbers[12]) = operator.getInvestorPart4(investorAddress);\r\n        (numbers[13], numbers[14], numbers[15]) = operator.getInvestorPart5(investorAddress);\r\n        return (email, addresses, isDisabled, numbers);\r\n    }\r\n\r\n    function getMaxOuts() public view returns (bytes32[] memory ids, address[] memory investors, uint256[] memory times, uint256[] memory ats) {\r\n        uint256 length = operator.getMaxOutsLength();\r\n        ids = new bytes32[] (length);\r\n        investors = new address[] (length);\r\n        times = new uint256[] (length);\r\n        ats = new uint256[] (length);\r\n        for (uint256 i = 0; i < length; i++) {\r\n            bytes32 id = operator.maxOutIds(i);\r\n            address investor;\r\n            uint256 time;\r\n            uint256 at;\r\n            (id, investor, time, at) = operator.maxOuts(id);\r\n            ids[i] = id;\r\n            times[i] = time;\r\n            investors[i] = investor;\r\n            ats[i] = at;\r\n        }\r\n        return (ids, investors, times, ats);\r\n    }\r\n    \r\n    function getInvestorTree(address rootInvestor) public view returns(address[] memory nodeInvestors, bytes32[] memory emails, uint256[] memory leftSells, uint256[] memory rightSells, address[] memory parents, uint256[] memory generations, uint256[] memory deposits){\r\n        nodeInvestors = operator.getNodesAddresses(rootInvestor);\r\n        uint256 length = nodeInvestors.length;\r\n        leftSells = new uint256[](length);\r\n        rightSells = new uint256[](length);\r\n        emails = new bytes32[] (length);\r\n        parents = new address[] (length);\r\n        generations = new uint256[] (length);\r\n        deposits = new uint256[] (length);\r\n        for (uint256 i = 0; i < length; i++) {\r\n            (emails[i], parents[i], leftSells[i], rightSells[i], generations[i], deposits[i]) = getOneNode(nodeInvestors[i]);\r\n        }\r\n        return (nodeInvestors, emails, leftSells, rightSells, parents, generations, deposits);\r\n    }\r\n    \r\n    function getOneNode(address investorAddress) internal view returns(bytes32 email, address parent, uint256 leftSell, uint256 rightSell, uint256 generation, uint256 deposit) {\r\n        (email, parent, , ,) = operator.getInvestorPart1(investorAddress);\r\n        (generation, deposit, ,) = operator.getInvestorPart2(investorAddress);\r\n        (rightSell, leftSell, , ,) = operator.getInvestorPart4(investorAddress);\r\n        return (email, parent, leftSell, rightSell, generation, deposit);\r\n    }\r\n    \r\n    function getListInvestorPart1() public view returns (address[] memory investors, bytes32[] memory emails, address[] memory parents, address[] memory leftChilds, address[] memory rightChilds, address[] memory presenters) {\r\n        uint256 length = operator.getInvestorLength();\r\n        investors = new address[] (length);\r\n        emails = new bytes32[] (length);\r\n        emails = new bytes32[] (length);\r\n        parents = new address[] (length);\r\n        leftChilds = new address[] (length);\r\n        rightChilds = new address[] (length);\r\n        presenters = new address[] (length);\r\n        for (uint256 i = 0; i < length; i++) {\r\n            address investorAddress = operator.investorAddresses(i);\r\n            bytes32 email;\r\n            address parent;\r\n            address leftChild;\r\n            address rightChild;\r\n            address presenter;\r\n            (email, parent, leftChild, rightChild, presenter) = operator.getInvestorPart1(investorAddress);\r\n            investors[i] = investorAddress;\r\n            emails[i] = email;\r\n            parents[i] = parent;\r\n            leftChilds[i] = leftChild;\r\n            rightChilds[i] = rightChild;\r\n            presenters[i] = presenter;\r\n        }\r\n        return (investors, emails, parents, leftChilds, rightChilds, presenters);\r\n    }\r\n\r\n    function getListInvestorPart2() public view returns (address[] memory investors, uint256[] memory generations, uint256[] memory depositedAmounts, uint256[] memory withdrewAmounts, bool[] memory isDisableds) {\r\n        uint256 length = operator.getInvestorLength();\r\n        investors = new address[] (length);\r\n        generations = new uint256[] (length);\r\n        depositedAmounts = new uint256[] (length);\r\n        withdrewAmounts = new uint256[] (length);\r\n        isDisableds = new bool[] (length);\r\n        for (uint256 i = 0; i < length; i++) {\r\n            address investorAddress = operator.investorAddresses(i);\r\n            uint256 depositedAmount;\r\n            uint256 withdrewAmount;\r\n            bool isDisabled;\r\n            uint256 generation;\r\n            (generation, depositedAmount, withdrewAmount, isDisabled) = operator.getInvestorPart2(investorAddress);\r\n            investors[i] = investorAddress;\r\n            depositedAmounts[i] = depositedAmount;\r\n            withdrewAmounts[i] = withdrewAmount;\r\n            isDisableds[i] = isDisabled;\r\n            generations[i] = generation;\r\n        }\r\n        return (investors, generations, depositedAmounts, withdrewAmounts, isDisableds);\r\n    }\r\n    \r\n    function getListInvestorPart3() public view returns (address[] memory investors, uint256[] memory lastMaxOuts, uint256[] memory maxOutTimes, uint256[] memory maxOutTimesInWeeks, uint256[] memory totalSells, uint256[] memory sellThisMonths) {\r\n        uint256 length = operator.getInvestorLength();\r\n        investors = new address[] (length);\r\n        lastMaxOuts = new uint256[] (length);\r\n        maxOutTimes = new uint256[] (length);\r\n        maxOutTimesInWeeks = new uint256[] (length);\r\n        totalSells = new uint256[] (length);\r\n        sellThisMonths = new uint256[] (length);\r\n        for (uint256 i = 0; i < length; i++) {\r\n            address investorAddress = operator.investorAddresses(i);\r\n            uint256 lastMaxOut;\r\n            uint256 maxOutTime;\r\n            uint256 maxOutTimesInWeek;\r\n            uint256 totalSell;\r\n            uint256 sellThisMonth;\r\n            (lastMaxOut, maxOutTime, maxOutTimesInWeek, totalSell, sellThisMonth) = operator.getInvestorPart3(investorAddress);\r\n            investors[i] = investorAddress;\r\n            lastMaxOuts[i] = maxOutTime;\r\n            maxOutTimes[i] = maxOutTimesInWeek;\r\n            maxOutTimesInWeeks[i] = maxOutTimesInWeek;\r\n            totalSells[i] = totalSell;\r\n            sellThisMonths[i] = sellThisMonth;\r\n        }\r\n        return (investors, lastMaxOuts, maxOutTimes, maxOutTimesInWeeks, totalSells, sellThisMonths);\r\n    }\r\n    \r\n    function getListInvestorPart4() public view returns (address[] memory investors, uint256[] memory rightSells, uint256[] memory leftSells, uint256[] memory reserveCommissions, uint256[] memory dailyIncomeWithrewAmounts, uint256[] memory registerTimes) {\r\n        uint256 length = operator.getInvestorLength();\r\n        investors = new address[] (length);\r\n        rightSells = new uint256[] (length);\r\n        leftSells = new uint256[] (length);\r\n        reserveCommissions = new uint256[] (length);\r\n        dailyIncomeWithrewAmounts = new uint256[] (length);\r\n        registerTimes = new uint256[] (length);\r\n        for (uint256 i = 0; i < length; i++) {\r\n            address investorAddress = operator.investorAddresses(i);\r\n            uint256 rightSell;\r\n            uint256 leftSell;\r\n            uint256 reserveCommission;\r\n            uint256 dailyIncomeWithrewAmount;\r\n            uint256 registerTime;\r\n            (rightSell, leftSell, reserveCommission, dailyIncomeWithrewAmount, registerTime) = operator.getInvestorPart4(investorAddress);\r\n            investors[i] = investorAddress;\r\n            rightSells[i] = rightSell;\r\n            leftSells[i] = leftSell;\r\n            reserveCommissions[i] = reserveCommission;\r\n            dailyIncomeWithrewAmounts[i] = dailyIncomeWithrewAmount;\r\n            registerTimes[i] = registerTime;\r\n        }\r\n        return (investors, rightSells, leftSells, reserveCommissions, dailyIncomeWithrewAmounts, registerTimes);\r\n    }\r\n    \r\n    function getListInvestorPart5() public view returns (address[] memory investors, uint256[] memory unpaidSystemCommissions, uint256[] memory unpaidDailyIncomes, uint256[] memory minDeposits) {\r\n        uint256 length = operator.getInvestorLength();\r\n        investors = new address[] (length);\r\n        unpaidSystemCommissions = new uint256[] (length);\r\n        unpaidDailyIncomes = new uint256[] (length);\r\n        minDeposits = new uint256[] (length);\r\n        for (uint256 i = 0; i < length; i++) {\r\n            address investorAddress = operator.investorAddresses(i);\r\n            uint256 unpaidDailyIncome;\r\n            uint256 unpaidSystemCommission;\r\n            uint256 minDeposit;\r\n            (unpaidSystemCommission, unpaidDailyIncome, minDeposit) = operator.getInvestorPart5(investorAddress);\r\n            investors[i] = investorAddress;\r\n            unpaidSystemCommissions[i] = unpaidSystemCommission;\r\n            unpaidDailyIncomes[i] = unpaidDailyIncome;\r\n            minDeposits[i] = minDeposit;\r\n        }\r\n        return (investors, unpaidSystemCommissions, unpaidDailyIncomes, minDeposits);\r\n    }\r\n    \r\n    function getInvestmentById(bytes32 investmentId) public view returns (bytes32 id, uint256 at, uint256 amount, address investor, address nextInvestor, bool nextBranch) {\r\n        return operator.investments(investmentId);\r\n    }\r\n    \r\n    function getWithdrawalById(bytes32 withdrawalId) public view returns (bytes32 id, uint256 at, uint256 amount, address investor, address presentee, uint256 reason, uint256 times) {\r\n        return operator.withdrawals(withdrawalId);\r\n    }\r\n    \r\n    function getEmailByAddress(address investorAddress) public view returns (bytes32) {\r\n        bytes32 email;\r\n        (email,,,,) = operator.getInvestorPart1(investorAddress);\r\n        return email;\r\n    }\r\n    \r\n    function getInvestments(address investorAddress, uint256 start, uint256 end) public view returns(bytes32[] memory ids, uint256[] memory ats, uint256[] memory amounts, bytes32[] memory emails) {\r\n        uint256 length = operator.getInvestmentsLength();\r\n        ids = new bytes32[](length);\r\n        ats = new uint256[](length);\r\n        amounts = new uint256[](length);\r\n        emails = new bytes32[](length);\r\n        uint256 index = 0;\r\n        for (uint256 i = 0; i < length; i++) {\r\n            bytes32 id = operator.investmentIds(i);\r\n            uint256 at;\r\n            uint256 amount;\r\n            address investor;\r\n            (id, at, amount, investor,,) = getInvestmentById(id);\r\n            if (investorAddress != address(0) && investor != investorAddress) continue;\r\n            if (at < start || at > end) continue;\r\n            ids[index] = id;\r\n            ats[index] = at;\r\n            amounts[index] = amount;\r\n            emails[index] = getEmailByAddress(investor);\r\n            index++;\r\n        }\r\n        return (ids, ats, amounts, emails);\r\n    }\r\n    \r\n    function getIncompletedInvestments() public view returns(bytes32[] memory ids, address[] memory nextInvestors, uint256[] memory amounts, bytes32[] memory emails) {\r\n        uint256 length = operator.getInvestmentsLength();\r\n        ids = new bytes32[](10);\r\n        nextInvestors = new address[](10);\r\n        amounts = new uint256[](10);\r\n        emails = new bytes32[](10);\r\n        uint256 index = 0;\r\n        for (uint256 i = 0; i < length; i++) {\r\n            bytes32 id = operator.investmentIds(i);\r\n            uint256 amount;\r\n            address investor;\r\n            address nextInvestor;\r\n            (id, , amount, investor, nextInvestor, ) = getInvestmentById(id);\r\n            if (nextInvestor == address(0)) continue;\r\n            ids[index] = id;\r\n            nextInvestors[index] = nextInvestor;\r\n            amounts[index] = amount;\r\n            emails[index] = getEmailByAddress(investor);\r\n            index++;\r\n        }\r\n        return (ids, nextInvestors, amounts, emails);\r\n    }\r\n    \r\n    function getWithdrawals(address investorAddress, uint256 start, uint256 end) public view returns(bytes32[] memory ids, uint256[] memory ats, uint256[] memory amounts, bytes32[] memory emails, address[] memory presentees, uint256[] memory reasons, uint256[] memory times) {\r\n        uint256 length = operator.getWithdrawalsLength();\r\n        ids = new bytes32[](length);\r\n        ats = new uint256[](length);\r\n        amounts = new uint256[](length);\r\n        emails = new bytes32[](length);\r\n        presentees = new address[](length);\r\n        reasons = new uint256[](length);\r\n        times = new uint256[](length);\r\n        putWithdrawalsPart1(investorAddress, start, end, length, ids, ats, amounts, emails);\r\n        putWithdrawalsPart2(investorAddress, start, end, length, presentees, reasons, times);\r\n        return (ids, ats, amounts, emails, presentees, reasons, times);\r\n    }\r\n    \r\n    function putWithdrawalsPart1(address investorAddress, uint256 start, uint256 end, uint256 length, bytes32[] memory ids, uint256[] memory ats, uint256[] memory amounts, bytes32[] memory emails) internal view {\r\n        uint256 index = 0;\r\n        for (uint256 i = 0; i < length; i++) {\r\n            bytes32 id = operator.withdrawalIds(i);\r\n            uint256 at;\r\n            uint256 amount;\r\n            address investor;\r\n            (id, at, amount, investor, , , ) = getWithdrawalById(id);\r\n            if (investorAddress != address(0) && investor != investorAddress) continue;\r\n            if (at < start || at > end) continue;\r\n            ids[index] = id;\r\n            ats[index] = at;\r\n            amounts[index] = amount;\r\n            emails[index] = getEmailByAddress(investor);\r\n            index++;\r\n        }\r\n    }\r\n    \r\n    function putWithdrawalsPart2(address investorAddress, uint256 start, uint256 end, uint256 length, address[] memory presentees, uint256[] memory reasons, uint256[] memory times) internal view {\r\n        uint256 index = 0;\r\n        for (uint256 i = 0; i < length; i++) {\r\n            bytes32 id = operator.withdrawalIds(i);\r\n            uint256 reason;\r\n            uint256 time;\r\n            address presentee;\r\n            address investor;\r\n            uint256 at;\r\n            (, at, , , presentee, reason, time) = getWithdrawalById(id);\r\n            if (investorAddress != address(0) && investor != investorAddress) continue;\r\n            if (at < start || at > end) continue;\r\n            reasons[index] = reason;\r\n            times[index] = time;\r\n            presentees[index] = presentee;\r\n            index++;\r\n        }\r\n    }\r\n\r\n    function getCurrentVote() public view returns(uint256 startTime, string memory reason, address payable emergencyAddress, uint256 yesPoint, uint256 noPoint, uint256 totalPoint) {\r\n        (startTime, reason, emergencyAddress, yesPoint, noPoint, totalPoint) = operator.currentVote();\r\n        return (startTime, reason, emergencyAddress, yesPoint, noPoint, totalPoint);\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"investmentId\",\"type\":\"bytes32\"}],\"name\":\"getInvestmentById\",\"outputs\":[{\"name\":\"id\",\"type\":\"bytes32\"},{\"name\":\"at\",\"type\":\"uint256\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"investor\",\"type\":\"address\"},{\"name\":\"nextInvestor\",\"type\":\"address\"},{\"name\":\"nextBranch\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"withdrawalId\",\"type\":\"bytes32\"}],\"name\":\"getWithdrawalById\",\"outputs\":[{\"name\":\"id\",\"type\":\"bytes32\"},{\"name\":\"at\",\"type\":\"uint256\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"investor\",\"type\":\"address\"},{\"name\":\"presentee\",\"type\":\"address\"},{\"name\":\"reason\",\"type\":\"uint256\"},{\"name\":\"times\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"investorAddress\",\"type\":\"address\"},{\"name\":\"start\",\"type\":\"uint256\"},{\"name\":\"end\",\"type\":\"uint256\"}],\"name\":\"getInvestments\",\"outputs\":[{\"name\":\"ids\",\"type\":\"bytes32[]\"},{\"name\":\"ats\",\"type\":\"uint256[]\"},{\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"name\":\"emails\",\"type\":\"bytes32[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getContractTime\",\"outputs\":[{\"name\":\"contractStartAt\",\"type\":\"uint256\"},{\"name\":\"lastReset\",\"type\":\"uint256\"},{\"name\":\"oneDay\",\"type\":\"uint256\"},{\"name\":\"lastPayDailyIncome\",\"type\":\"uint256\"},{\"name\":\"lastPaySystemCommission\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getIncompletedInvestments\",\"outputs\":[{\"name\":\"ids\",\"type\":\"bytes32[]\"},{\"name\":\"nextInvestors\",\"type\":\"address[]\"},{\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"name\":\"emails\",\"type\":\"bytes32[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"operator\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getListInvestorPart3\",\"outputs\":[{\"name\":\"investors\",\"type\":\"address[]\"},{\"name\":\"lastMaxOuts\",\"type\":\"uint256[]\"},{\"name\":\"maxOutTimes\",\"type\":\"uint256[]\"},{\"name\":\"maxOutTimesInWeeks\",\"type\":\"uint256[]\"},{\"name\":\"totalSells\",\"type\":\"uint256[]\"},{\"name\":\"sellThisMonths\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getContractInfo\",\"outputs\":[{\"name\":\"admin\",\"type\":\"address\"},{\"name\":\"depositedAmountGross\",\"type\":\"uint256\"},{\"name\":\"investorsCount\",\"type\":\"uint256\"},{\"name\":\"operationFund\",\"type\":\"address\"},{\"name\":\"balance\",\"type\":\"uint256\"},{\"name\":\"paySystemCommissionTimes\",\"type\":\"uint256\"},{\"name\":\"maximumMaxOutInWeek\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getListInvestorPart2\",\"outputs\":[{\"name\":\"investors\",\"type\":\"address[]\"},{\"name\":\"generations\",\"type\":\"uint256[]\"},{\"name\":\"depositedAmounts\",\"type\":\"uint256[]\"},{\"name\":\"withdrewAmounts\",\"type\":\"uint256[]\"},{\"name\":\"isDisableds\",\"type\":\"bool[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"investorAddress\",\"type\":\"address\"}],\"name\":\"getInvestor\",\"outputs\":[{\"name\":\"email\",\"type\":\"bytes32\"},{\"name\":\"addresses\",\"type\":\"address[]\"},{\"name\":\"isDisabled\",\"type\":\"bool\"},{\"name\":\"numbers\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getListInvestorPart4\",\"outputs\":[{\"name\":\"investors\",\"type\":\"address[]\"},{\"name\":\"rightSells\",\"type\":\"uint256[]\"},{\"name\":\"leftSells\",\"type\":\"uint256[]\"},{\"name\":\"reserveCommissions\",\"type\":\"uint256[]\"},{\"name\":\"dailyIncomeWithrewAmounts\",\"type\":\"uint256[]\"},{\"name\":\"registerTimes\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"rootInvestor\",\"type\":\"address\"}],\"name\":\"getInvestorTree\",\"outputs\":[{\"name\":\"nodeInvestors\",\"type\":\"address[]\"},{\"name\":\"emails\",\"type\":\"bytes32[]\"},{\"name\":\"leftSells\",\"type\":\"uint256[]\"},{\"name\":\"rightSells\",\"type\":\"uint256[]\"},{\"name\":\"parents\",\"type\":\"address[]\"},{\"name\":\"generations\",\"type\":\"uint256[]\"},{\"name\":\"deposits\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getMaxOuts\",\"outputs\":[{\"name\":\"ids\",\"type\":\"bytes32[]\"},{\"name\":\"investors\",\"type\":\"address[]\"},{\"name\":\"times\",\"type\":\"uint256[]\"},{\"name\":\"ats\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"operatorAddress\",\"type\":\"address\"}],\"name\":\"setOperator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"investorAddress\",\"type\":\"address\"},{\"name\":\"start\",\"type\":\"uint256\"},{\"name\":\"end\",\"type\":\"uint256\"}],\"name\":\"getWithdrawals\",\"outputs\":[{\"name\":\"ids\",\"type\":\"bytes32[]\"},{\"name\":\"ats\",\"type\":\"uint256[]\"},{\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"name\":\"emails\",\"type\":\"bytes32[]\"},{\"name\":\"presentees\",\"type\":\"address[]\"},{\"name\":\"reasons\",\"type\":\"uint256[]\"},{\"name\":\"times\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getListInvestorPart5\",\"outputs\":[{\"name\":\"investors\",\"type\":\"address[]\"},{\"name\":\"unpaidSystemCommissions\",\"type\":\"uint256[]\"},{\"name\":\"unpaidDailyIncomes\",\"type\":\"uint256[]\"},{\"name\":\"minDeposits\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCurrentVote\",\"outputs\":[{\"name\":\"startTime\",\"type\":\"uint256\"},{\"name\":\"reason\",\"type\":\"string\"},{\"name\":\"emergencyAddress\",\"type\":\"address\"},{\"name\":\"yesPoint\",\"type\":\"uint256\"},{\"name\":\"noPoint\",\"type\":\"uint256\"},{\"name\":\"totalPoint\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getListInvestorPart1\",\"outputs\":[{\"name\":\"investors\",\"type\":\"address[]\"},{\"name\":\"emails\",\"type\":\"bytes32[]\"},{\"name\":\"parents\",\"type\":\"address[]\"},{\"name\":\"leftChilds\",\"type\":\"address[]\"},{\"name\":\"rightChilds\",\"type\":\"address[]\"},{\"name\":\"presenters\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"investorAddress\",\"type\":\"address\"}],\"name\":\"getEmailByAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"Querier","CompilerVersion":"v0.5.3+commit.10d17f24","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://0892998394d42e2db3cb489e2a9aa70139489dcf9ac40b2312ee8d7030bf3822"}]}