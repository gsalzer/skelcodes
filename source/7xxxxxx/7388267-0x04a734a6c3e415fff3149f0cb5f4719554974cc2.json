{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.0;\r\n\r\npragma experimental ABIEncoderV2;\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ninterface IERC20 {\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n\r\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address who) external view returns (uint256);\r\n\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n     * account.\r\n     */\r\n    constructor () internal {\r\n        _owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), _owner);\r\n    }\r\n\r\n    /**\r\n     * @return the address of the owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner());\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @return true if `msg.sender` is the owner of the contract.\r\n     */\r\n    function isOwner() public view returns (bool) {\r\n        return msg.sender == _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to relinquish control of the contract.\r\n     * @notice Renouncing to ownership will leave the contract without an owner.\r\n     * It will not be possible to call the functions with the `onlyOwner`\r\n     * modifier anymore.\r\n     */\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0));\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Unsigned math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n    * @dev Multiplies two unsigned integers, reverts on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two unsigned integers, reverts on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\r\n    * reverts when dividing by zero.\r\n    */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n/**\r\n * @title SignedSafeMath\r\n * @dev Signed math operations with safety checks that revert on error\r\n */\r\nlibrary SignedSafeMath {\r\n    int256 constant private INT256_MIN = -2**255;\r\n\r\n    /**\r\n    * @dev Multiplies two signed integers, reverts on overflow.\r\n    */\r\n    function mul(int256 a, int256 b) internal pure returns (int256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        require(!(a == -1 && b == INT256_MIN)); // This is the only case of overflow not detected by the check below\r\n\r\n        int256 c = a * b;\r\n        require(c / a == b);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two signed integers truncating the quotient, reverts on division by zero.\r\n    */\r\n    function div(int256 a, int256 b) internal pure returns (int256) {\r\n        require(b != 0); // Solidity only automatically asserts when dividing by 0\r\n        require(!(b == -1 && a == INT256_MIN)); // This is the only case of overflow\r\n\r\n        int256 c = a / b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two signed integers, reverts on overflow.\r\n    */\r\n    function sub(int256 a, int256 b) internal pure returns (int256) {\r\n        int256 c = a - b;\r\n        require((b >= 0 && c <= a) || (b < 0 && c > a));\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two signed integers, reverts on overflow.\r\n    */\r\n    function add(int256 a, int256 b) internal pure returns (int256) {\r\n        int256 c = a + b;\r\n        require((b >= 0 && c >= a) || (b < 0 && c < a));\r\n\r\n        return c;\r\n    }\r\n}\r\n\r\n/**\r\n * @title Standard ERC20 token\r\n *\r\n * @dev Implementation of the basic standard token.\r\n * https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md\r\n * Originally based on code by FirstBlood:\r\n * https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\r\n *\r\n * This implementation emits additional Approval events, allowing applications to reconstruct the allowance status for\r\n * all accounts just by listening to said events. Note that this isn't required by the specification, and other\r\n * compliant implementations may not do it.\r\n */\r\ncontract ERC20 is IERC20 {\r\n    using SafeMath for uint256;\r\n\r\n    mapping (address => uint256) private _balances;\r\n\r\n    mapping (address => mapping (address => uint256)) private _allowed;\r\n\r\n    uint256 private _totalSupply;\r\n\r\n    /**\r\n    * @dev Total number of tokens in existence\r\n    */\r\n    function totalSupply() public view returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    /**\r\n    * @dev Gets the balance of the specified address.\r\n    * @param owner The address to query the balance of.\r\n    * @return An uint256 representing the amount owned by the passed address.\r\n    */\r\n    function balanceOf(address owner) public view returns (uint256) {\r\n        return _balances[owner];\r\n    }\r\n\r\n    /**\r\n     * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n     * @param owner address The address which owns the funds.\r\n     * @param spender address The address which will spend the funds.\r\n     * @return A uint256 specifying the amount of tokens still available for the spender.\r\n     */\r\n    function allowance(address owner, address spender) public view returns (uint256) {\r\n        return _allowed[owner][spender];\r\n    }\r\n\r\n    /**\r\n    * @dev Transfer token for a specified address\r\n    * @param to The address to transfer to.\r\n    * @param value The amount to be transferred.\r\n    */\r\n    function transfer(address to, uint256 value) public returns (bool) {\r\n        _transfer(msg.sender, to, value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n     * Beware that changing an allowance with this method brings the risk that someone may use both the old\r\n     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\r\n     * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     * @param spender The address which will spend the funds.\r\n     * @param value The amount of tokens to be spent.\r\n     */\r\n    function approve(address spender, uint256 value) public returns (bool) {\r\n        require(spender != address(0));\r\n\r\n        _allowed[msg.sender][spender] = value;\r\n        emit Approval(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Transfer tokens from one address to another.\r\n     * Note that while this function emits an Approval event, this is not required as per the specification,\r\n     * and other compliant implementations may not emit the event.\r\n     * @param from address The address which you want to send tokens from\r\n     * @param to address The address which you want to transfer to\r\n     * @param value uint256 the amount of tokens to be transferred\r\n     */\r\n    function transferFrom(address from, address to, uint256 value) public returns (bool) {\r\n        _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);\r\n        _transfer(from, to, value);\r\n        emit Approval(from, msg.sender, _allowed[from][msg.sender]);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Increase the amount of tokens that an owner allowed to a spender.\r\n     * approve should be called when allowed_[_spender] == 0. To increment\r\n     * allowed value is better to use this function to avoid 2 calls (and wait until\r\n     * the first transaction is mined)\r\n     * From MonolithDAO Token.sol\r\n     * Emits an Approval event.\r\n     * @param spender The address which will spend the funds.\r\n     * @param addedValue The amount of tokens to increase the allowance by.\r\n     */\r\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\r\n        require(spender != address(0));\r\n\r\n        _allowed[msg.sender][spender] = _allowed[msg.sender][spender].add(addedValue);\r\n        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Decrease the amount of tokens that an owner allowed to a spender.\r\n     * approve should be called when allowed_[_spender] == 0. To decrement\r\n     * allowed value is better to use this function to avoid 2 calls (and wait until\r\n     * the first transaction is mined)\r\n     * From MonolithDAO Token.sol\r\n     * Emits an Approval event.\r\n     * @param spender The address which will spend the funds.\r\n     * @param subtractedValue The amount of tokens to decrease the allowance by.\r\n     */\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\r\n        require(spender != address(0));\r\n\r\n        _allowed[msg.sender][spender] = _allowed[msg.sender][spender].sub(subtractedValue);\r\n        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev Transfer token for a specified addresses\r\n    * @param from The address to transfer from.\r\n    * @param to The address to transfer to.\r\n    * @param value The amount to be transferred.\r\n    */\r\n    function _transfer(address from, address to, uint256 value) internal {\r\n        require(to != address(0));\r\n\r\n        _balances[from] = _balances[from].sub(value);\r\n        _balances[to] = _balances[to].add(value);\r\n        emit Transfer(from, to, value);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function that mints an amount of the token and assigns it to\r\n     * an account. This encapsulates the modification of balances such that the\r\n     * proper events are emitted.\r\n     * @param account The account that will receive the created tokens.\r\n     * @param value The amount that will be created.\r\n     */\r\n    function _mint(address account, uint256 value) internal {\r\n        require(account != address(0));\r\n\r\n        _totalSupply = _totalSupply.add(value);\r\n        _balances[account] = _balances[account].add(value);\r\n        emit Transfer(address(0), account, value);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function that burns an amount of the token of a given\r\n     * account.\r\n     * @param account The account whose tokens will be burnt.\r\n     * @param value The amount that will be burnt.\r\n     */\r\n    function _burn(address account, uint256 value) internal {\r\n        require(account != address(0));\r\n\r\n        _totalSupply = _totalSupply.sub(value);\r\n        _balances[account] = _balances[account].sub(value);\r\n        emit Transfer(account, address(0), value);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function that burns an amount of the token of a given\r\n     * account, deducting from the sender's allowance for said account. Uses the\r\n     * internal burn function.\r\n     * Emits an Approval event (reflecting the reduced allowance).\r\n     * @param account The account whose tokens will be burnt.\r\n     * @param value The amount that will be burnt.\r\n     */\r\n    function _burnFrom(address account, uint256 value) internal {\r\n        _allowed[account][msg.sender] = _allowed[account][msg.sender].sub(value);\r\n        _burn(account, value);\r\n        emit Approval(account, msg.sender, _allowed[account][msg.sender]);\r\n    }\r\n}\r\n\r\n// The functionality that all derivative contracts expose to the admin.\r\ninterface AdminInterface {\r\n    // Initiates the shutdown process, in case of an emergency.\r\n    function emergencyShutdown() external;\r\n\r\n    // A core contract method called immediately before or after any financial transaction. It pays fees and moves money\r\n    // between margin accounts to make sure they reflect the NAV of the contract.\r\n    function remargin() external;\r\n}\r\n\r\ncontract ExpandedIERC20 is IERC20 {\r\n    // Burns a specific amount of tokens. Burns the sender's tokens, so it is safe to leave this method permissionless.\r\n    function burn(uint value) external;\r\n\r\n    // Mints tokens and adds them to the balance of the `to` address.\r\n    // Note: this method should be permissioned to only allow designated parties to mint tokens.\r\n    function mint(address to, uint value) external;\r\n}\r\n\r\n// This interface allows derivative contracts to pay Oracle fees for their use of the system.\r\ninterface StoreInterface {\r\n\r\n    // Pays Oracle fees in ETH to the store. To be used by contracts whose margin currency is ETH.\r\n    function payOracleFees() external payable;\r\n\r\n    // Pays Oracle fees in the margin currency, erc20Address, to the store. To be used if the margin currency is an\r\n    // ERC20 token rather than ETH. All approved tokens are transfered.\r\n    function payOracleFeesErc20(address erc20Address) external; \r\n\r\n    // Computes the Oracle fees that a contract should pay for a period. `pfc` is the \"profit from corruption\", or the\r\n    // maximum amount of margin currency that a token sponsor could extract from the contract through corrupting the\r\n    // price feed in their favor.\r\n    function computeOracleFees(uint startTime, uint endTime, uint pfc) external view returns (uint feeAmount);\r\n}\r\n\r\ninterface ReturnCalculatorInterface {\r\n    // Computes the return between oldPrice and newPrice.\r\n    function computeReturn(int oldPrice, int newPrice) external view returns (int assetReturn);\r\n\r\n    // Gets the effective leverage for the return calculator.\r\n    // Note: if this parameter doesn't exist for this calculator, this method should return 1.\r\n    function leverage() external view returns (int _leverage);\r\n}\r\n\r\n// This interface allows contracts to query unverified prices.\r\ninterface PriceFeedInterface {\r\n    // Whether this PriceFeeds provides prices for the given identifier.\r\n    function isIdentifierSupported(bytes32 identifier) external view returns (bool isSupported);\r\n\r\n    // Gets the latest time-price pair at which a price was published. The transaction will revert if no prices have\r\n    // been published for this identifier.\r\n    function latestPrice(bytes32 identifier) external view returns (uint publishTime, int price);\r\n\r\n    // An event fired when a price is published.\r\n    event PriceUpdated(bytes32 indexed identifier, uint indexed time, int price);\r\n}\r\n\r\ncontract AddressWhitelist is Ownable {\r\n    enum Status { None, In, Out }\r\n    mapping(address => Status) private whitelist;\r\n\r\n    address[] private whitelistIndices;\r\n\r\n    // Adds an address to the whitelist\r\n    function addToWhitelist(address newElement) external onlyOwner {\r\n        // Ignore if address is already included\r\n        if (whitelist[newElement] == Status.In) {\r\n            return;\r\n        }\r\n\r\n        // Only append new addresses to the array, never a duplicate\r\n        if (whitelist[newElement] == Status.None) {\r\n            whitelistIndices.push(newElement);\r\n        }\r\n\r\n        whitelist[newElement] = Status.In;\r\n\r\n        emit AddToWhitelist(newElement);\r\n    }\r\n\r\n    // Removes an address from the whitelist.\r\n    function removeFromWhitelist(address elementToRemove) external onlyOwner {\r\n        if (whitelist[elementToRemove] != Status.Out) {\r\n            whitelist[elementToRemove] = Status.Out;\r\n            emit RemoveFromWhitelist(elementToRemove);\r\n        }\r\n    }\r\n\r\n    // Checks whether an address is on the whitelist.\r\n    function isOnWhitelist(address elementToCheck) external view returns (bool) {\r\n        return whitelist[elementToCheck] == Status.In;\r\n    }\r\n\r\n    // Gets all addresses that are currently included in the whitelist\r\n    // Note: This method skips over, but still iterates through addresses.\r\n    // It is possible for this call to run out of gas if a large number of\r\n    // addresses have been removed. To prevent this unlikely scenario, we can\r\n    // modify the implementation so that when addresses are removed, the last addresses\r\n    // in the array is moved to the empty index.\r\n    function getWhitelist() external view returns (address[] memory activeWhitelist) {\r\n        // Determine size of whitelist first\r\n        uint activeCount = 0;\r\n        for (uint i = 0; i < whitelistIndices.length; i++) {\r\n            if (whitelist[whitelistIndices[i]] == Status.In) {\r\n                activeCount++;\r\n            }\r\n        }\r\n\r\n        // Populate whitelist\r\n        activeWhitelist = new address[](activeCount);\r\n        activeCount = 0;\r\n        for (uint i = 0; i < whitelistIndices.length; i++) {\r\n            address addr = whitelistIndices[i];\r\n            if (whitelist[addr] == Status.In) {\r\n                activeWhitelist[activeCount] = addr;\r\n                activeCount++;\r\n            }\r\n        }\r\n    }\r\n\r\n    event AddToWhitelist(address indexed addedAddress);\r\n    event RemoveFromWhitelist(address indexed removedAddress);\r\n}\r\n\r\ncontract Withdrawable is Ownable {\r\n    // Withdraws ETH from the contract.\r\n    function withdraw(uint amount) external onlyOwner {\r\n        msg.sender.transfer(amount);\r\n    }\r\n\r\n    // Withdraws ERC20 tokens from the contract.\r\n    function withdrawErc20(address erc20Address, uint amount) external onlyOwner {\r\n        IERC20 erc20 = IERC20(erc20Address);\r\n        require(erc20.transfer(msg.sender, amount));\r\n    }\r\n}\r\n\r\n// This interface allows contracts to query a verified, trusted price.\r\ninterface OracleInterface {\r\n    // Requests the Oracle price for an identifier at a time. Returns the time at which a price will be available.\r\n    // Returns 0 is the price is available now, and returns 2^256-1 if the price will never be available.  Reverts if\r\n    // the Oracle doesn't support this identifier. Only contracts registered in the Registry are authorized to call this\r\n    // method.\r\n    function requestPrice(bytes32 identifier, uint time) external returns (uint expectedTime);\r\n\r\n    // Checks whether a price has been resolved.\r\n    function hasPrice(bytes32 identifier, uint time) external view returns (bool hasPriceAvailable);\r\n\r\n    // Returns the Oracle price for identifier at a time. Reverts if the Oracle doesn't support this identifier or if\r\n    // the Oracle doesn't have a price for this time. Only contracts registered in the Registry are authorized to call\r\n    // this method.\r\n    function getPrice(bytes32 identifier, uint time) external view returns (int price);\r\n\r\n    // Returns whether the Oracle provides verified prices for the given identifier.\r\n    function isIdentifierSupported(bytes32 identifier) external view returns (bool isSupported);\r\n\r\n    // An event fired when a request for a (identifier, time) pair is made.\r\n    event VerifiedPriceRequested(bytes32 indexed identifier, uint indexed time);\r\n\r\n    // An event fired when a verified price is available for a (identifier, time) pair.\r\n    event VerifiedPriceAvailable(bytes32 indexed identifier, uint indexed time, int price);\r\n}\r\n\r\ninterface RegistryInterface {\r\n    struct RegisteredDerivative {\r\n        address derivativeAddress;\r\n        address derivativeCreator;\r\n    }\r\n\r\n    // Registers a new derivative. Only authorized derivative creators can call this method.\r\n    function registerDerivative(address[] calldata counterparties, address derivativeAddress) external;\r\n\r\n    // Adds a new derivative creator to this list of authorized creators. Only the owner of this contract can call\r\n    // this method.   \r\n    function addDerivativeCreator(address derivativeCreator) external;\r\n\r\n    // Removes a derivative creator to this list of authorized creators. Only the owner of this contract can call this\r\n    // method.  \r\n    function removeDerivativeCreator(address derivativeCreator) external;\r\n\r\n    // Returns whether the derivative has been registered with the registry (and is therefore an authorized participant\r\n    // in the UMA system).\r\n    function isDerivativeRegistered(address derivative) external view returns (bool isRegistered);\r\n\r\n    // Returns a list of all derivatives that are associated with a particular party.\r\n    function getRegisteredDerivatives(address party) external view returns (RegisteredDerivative[] memory derivatives);\r\n\r\n    // Returns all registered derivatives.\r\n    function getAllRegisteredDerivatives() external view returns (RegisteredDerivative[] memory derivatives);\r\n\r\n    // Returns whether an address is authorized to register new derivatives.\r\n    function isDerivativeCreatorAuthorized(address derivativeCreator) external view returns (bool isAuthorized);\r\n}\r\n\r\ncontract Registry is RegistryInterface, Withdrawable {\r\n\r\n    using SafeMath for uint;\r\n\r\n    // Array of all registeredDerivatives that are approved to use the UMA Oracle.\r\n    RegisteredDerivative[] private registeredDerivatives;\r\n\r\n    // This enum is required because a WasValid state is required to ensure that derivatives cannot be re-registered.\r\n    enum PointerValidity {\r\n        Invalid,\r\n        Valid,\r\n        WasValid\r\n    }\r\n\r\n    struct Pointer {\r\n        PointerValidity valid;\r\n        uint128 index;\r\n    }\r\n\r\n    // Maps from derivative address to a pointer that refers to that RegisteredDerivative in registeredDerivatives.\r\n    mapping(address => Pointer) private derivativePointers;\r\n\r\n    // Note: this must be stored outside of the RegisteredDerivative because mappings cannot be deleted and copied\r\n    // like normal data. This could be stored in the Pointer struct, but storing it there would muddy the purpose\r\n    // of the Pointer struct and break separation of concern between referential data and data.\r\n    struct PartiesMap {\r\n        mapping(address => bool) parties;\r\n    }\r\n\r\n    // Maps from derivative address to the set of parties that are involved in that derivative.\r\n    mapping(address => PartiesMap) private derivativesToParties;\r\n\r\n    // Maps from derivative creator address to whether that derivative creator has been approved to register contracts.\r\n    mapping(address => bool) private derivativeCreators;\r\n\r\n    modifier onlyApprovedDerivativeCreator {\r\n        require(derivativeCreators[msg.sender]);\r\n        _;\r\n    }\r\n\r\n    function registerDerivative(address[] calldata parties, address derivativeAddress)\r\n        external\r\n        onlyApprovedDerivativeCreator\r\n    {\r\n        // Create derivative pointer.\r\n        Pointer storage pointer = derivativePointers[derivativeAddress];\r\n\r\n        // Ensure that the pointer was not valid in the past (derivatives cannot be re-registered or double\r\n        // registered).\r\n        require(pointer.valid == PointerValidity.Invalid);\r\n        pointer.valid = PointerValidity.Valid;\r\n\r\n        registeredDerivatives.push(RegisteredDerivative(derivativeAddress, msg.sender));\r\n\r\n        // No length check necessary because we should never hit (2^127 - 1) derivatives.\r\n        pointer.index = uint128(registeredDerivatives.length.sub(1));\r\n\r\n        // Set up PartiesMap for this derivative.\r\n        PartiesMap storage partiesMap = derivativesToParties[derivativeAddress];\r\n        for (uint i = 0; i < parties.length; i = i.add(1)) {\r\n            partiesMap.parties[parties[i]] = true;\r\n        }\r\n\r\n        address[] memory partiesForEvent = parties;\r\n        emit RegisterDerivative(derivativeAddress, partiesForEvent);\r\n    }\r\n\r\n    function addDerivativeCreator(address derivativeCreator) external onlyOwner {\r\n        if (!derivativeCreators[derivativeCreator]) {\r\n            derivativeCreators[derivativeCreator] = true;\r\n            emit AddDerivativeCreator(derivativeCreator);\r\n        }\r\n    }\r\n\r\n    function removeDerivativeCreator(address derivativeCreator) external onlyOwner {\r\n        if (derivativeCreators[derivativeCreator]) {\r\n            derivativeCreators[derivativeCreator] = false;\r\n            emit RemoveDerivativeCreator(derivativeCreator);\r\n        }\r\n    }\r\n\r\n    function isDerivativeRegistered(address derivative) external view returns (bool isRegistered) {\r\n        return derivativePointers[derivative].valid == PointerValidity.Valid;\r\n    }\r\n\r\n    function getRegisteredDerivatives(address party) external view returns (RegisteredDerivative[] memory derivatives) {\r\n        // This is not ideal - we must statically allocate memory arrays. To be safe, we make a temporary array as long\r\n        // as registeredDerivatives. We populate it with any derivatives that involve the provided party. Then, we copy\r\n        // the array over to the return array, which is allocated using the correct size. Note: this is done by double\r\n        // copying each value rather than storing some referential info (like indices) in memory to reduce the number\r\n        // of storage reads. This is because storage reads are far more expensive than extra memory space (~100:1).\r\n        RegisteredDerivative[] memory tmpDerivativeArray = new RegisteredDerivative[](registeredDerivatives.length);\r\n        uint outputIndex = 0;\r\n        for (uint i = 0; i < registeredDerivatives.length; i = i.add(1)) {\r\n            RegisteredDerivative storage derivative = registeredDerivatives[i];\r\n            if (derivativesToParties[derivative.derivativeAddress].parties[party]) {\r\n                // Copy selected derivative to the temporary array.\r\n                tmpDerivativeArray[outputIndex] = derivative;\r\n                outputIndex = outputIndex.add(1);\r\n            }\r\n        }\r\n\r\n        // Copy the temp array to the return array that is set to the correct size.\r\n        derivatives = new RegisteredDerivative[](outputIndex);\r\n        for (uint j = 0; j < outputIndex; j = j.add(1)) {\r\n            derivatives[j] = tmpDerivativeArray[j];\r\n        }\r\n    }\r\n\r\n    function getAllRegisteredDerivatives() external view returns (RegisteredDerivative[] memory derivatives) {\r\n        return registeredDerivatives;\r\n    }\r\n\r\n    function isDerivativeCreatorAuthorized(address derivativeCreator) external view returns (bool isAuthorized) {\r\n        return derivativeCreators[derivativeCreator];\r\n    }\r\n\r\n    event RegisterDerivative(address indexed derivativeAddress, address[] parties);\r\n    event AddDerivativeCreator(address indexed addedDerivativeCreator);\r\n    event RemoveDerivativeCreator(address indexed removedDerivativeCreator);\r\n\r\n}\r\n\r\ncontract Testable is Ownable {\r\n\r\n    // Is the contract being run on the test network. Note: this variable should be set on construction and never\r\n    // modified.\r\n    bool public isTest;\r\n\r\n    uint private currentTime;\r\n\r\n    constructor(bool _isTest) internal {\r\n        isTest = _isTest;\r\n        if (_isTest) {\r\n            currentTime = now; // solhint-disable-line not-rely-on-time\r\n        }\r\n    }\r\n\r\n    modifier onlyIfTest {\r\n        require(isTest);\r\n        _;\r\n    }\r\n\r\n    function setCurrentTime(uint _time) external onlyOwner onlyIfTest {\r\n        currentTime = _time;\r\n    }\r\n\r\n    function getCurrentTime() public view returns (uint) {\r\n        if (isTest) {\r\n            return currentTime;\r\n        } else {\r\n            return now; // solhint-disable-line not-rely-on-time\r\n        }\r\n    }\r\n}\r\n\r\ncontract ContractCreator is Withdrawable {\r\n    Registry internal registry;\r\n    address internal oracleAddress;\r\n    address internal storeAddress;\r\n    address internal priceFeedAddress;\r\n\r\n    constructor(address registryAddress, address _oracleAddress, address _storeAddress, address _priceFeedAddress)\r\n        public\r\n    {\r\n        registry = Registry(registryAddress);\r\n        oracleAddress = _oracleAddress;\r\n        storeAddress = _storeAddress;\r\n        priceFeedAddress = _priceFeedAddress;\r\n    }\r\n\r\n    function _registerContract(address[] memory parties, address contractToRegister) internal {\r\n        registry.registerDerivative(parties, contractToRegister);\r\n    }\r\n}\r\n\r\nlibrary TokenizedDerivativeParams {\r\n    enum ReturnType {\r\n        Linear,\r\n        Compound\r\n    }\r\n\r\n    struct ConstructorParams {\r\n        address sponsor;\r\n        address admin;\r\n        address oracle;\r\n        address store;\r\n        address priceFeed;\r\n        uint defaultPenalty; // Percentage of margin requirement * 10^18\r\n        uint supportedMove; // Expected percentage move in the underlying price that the long is protected against.\r\n        bytes32 product;\r\n        uint fixedYearlyFee; // Percentage of nav * 10^18\r\n        uint disputeDeposit; // Percentage of margin requirement * 10^18\r\n        address returnCalculator;\r\n        uint startingTokenPrice;\r\n        uint expiry;\r\n        address marginCurrency;\r\n        uint withdrawLimit; // Percentage of derivativeStorage.shortBalance * 10^18\r\n        ReturnType returnType;\r\n        uint startingUnderlyingPrice;\r\n        uint creationTime;\r\n    }\r\n}\r\n\r\n// TokenizedDerivativeStorage: this library name is shortened due to it being used so often.\r\nlibrary TDS {\r\n        enum State {\r\n        // The contract is active, and tokens can be created and redeemed. Margin can be added and withdrawn (as long as\r\n        // it exceeds required levels). Remargining is allowed. Created contracts immediately begin in this state.\r\n        // Possible state transitions: Disputed, Expired, Defaulted.\r\n        Live,\r\n\r\n        // Disputed, Expired, Defaulted, and Emergency are Frozen states. In a Frozen state, the contract is frozen in\r\n        // time awaiting a resolution by the Oracle. No tokens can be created or redeemed. Margin cannot be withdrawn.\r\n        // The resolution of these states moves the contract to the Settled state. Remargining is not allowed.\r\n\r\n        // The derivativeStorage.externalAddresses.sponsor has disputed the price feed output. If the dispute is valid (i.e., the NAV calculated from the\r\n        // Oracle price differs from the NAV calculated from the price feed), the dispute fee is added to the short\r\n        // account. Otherwise, the dispute fee is added to the long margin account.\r\n        // Possible state transitions: Settled.\r\n        Disputed,\r\n\r\n        // Contract expiration has been reached.\r\n        // Possible state transitions: Settled.\r\n        Expired,\r\n\r\n        // The short margin account is below its margin requirement. The derivativeStorage.externalAddresses.sponsor can choose to confirm the default and\r\n        // move to Settle without waiting for the Oracle. Default penalties will be assessed when the contract moves to\r\n        // Settled.\r\n        // Possible state transitions: Settled.\r\n        Defaulted,\r\n\r\n        // UMA has manually triggered a shutdown of the account.\r\n        // Possible state transitions: Settled.\r\n        Emergency,\r\n\r\n        // Token price is fixed. Tokens can be redeemed by anyone. All short margin can be withdrawn. Tokens can't be\r\n        // created, and contract can't remargin.\r\n        // Possible state transitions: None.\r\n        Settled\r\n    }\r\n\r\n    // The state of the token at a particular time. The state gets updated on remargin.\r\n    struct TokenState {\r\n        int underlyingPrice;\r\n        int tokenPrice;\r\n        uint time;\r\n    }\r\n\r\n    // The information in the following struct is only valid if in the midst of a Dispute.\r\n    struct Dispute {\r\n        int disputedNav;\r\n        uint deposit;\r\n    }\r\n\r\n    struct WithdrawThrottle {\r\n        uint startTime;\r\n        uint remainingWithdrawal;\r\n    }\r\n\r\n    struct FixedParameters {\r\n        // Fixed contract parameters.\r\n        uint defaultPenalty; // Percentage of margin requirement * 10^18\r\n        uint supportedMove; // Expected percentage move that the long is protected against.\r\n        uint disputeDeposit; // Percentage of margin requirement * 10^18\r\n        uint fixedFeePerSecond; // Percentage of nav*10^18\r\n        uint withdrawLimit; // Percentage of derivativeStorage.shortBalance*10^18\r\n        bytes32 product;\r\n        TokenizedDerivativeParams.ReturnType returnType;\r\n        uint initialTokenUnderlyingRatio;\r\n        uint creationTime;\r\n        string symbol;\r\n    }\r\n\r\n    struct ExternalAddresses {\r\n        // Other addresses/contracts\r\n        address sponsor;\r\n        address admin;\r\n        address apDelegate;\r\n        OracleInterface oracle;\r\n        StoreInterface store;\r\n        PriceFeedInterface priceFeed;\r\n        ReturnCalculatorInterface returnCalculator;\r\n        IERC20 marginCurrency;\r\n    }\r\n\r\n    struct Storage {\r\n        FixedParameters fixedParameters;\r\n        ExternalAddresses externalAddresses;\r\n\r\n        // Balances\r\n        int shortBalance;\r\n        int longBalance;\r\n\r\n        State state;\r\n        uint endTime;\r\n\r\n        // The NAV of the contract always reflects the transition from (`prev`, `current`).\r\n        // In the case of a remargin, a `latest` price is retrieved from the price feed, and we shift `current` -> `prev`\r\n        // and `latest` -> `current` (and then recompute).\r\n        // In the case of a dispute, `current` might change (which is why we have to hold on to `prev`).\r\n        TokenState referenceTokenState;\r\n        TokenState currentTokenState;\r\n\r\n        int nav;  // Net asset value is measured in Wei\r\n\r\n        Dispute disputeInfo;\r\n\r\n        // Only populated once the contract enters a frozen state.\r\n        int defaultPenaltyAmount;\r\n\r\n        WithdrawThrottle withdrawThrottle;\r\n    }\r\n}\r\n\r\nlibrary TokenizedDerivativeUtils {\r\n    using TokenizedDerivativeUtils for TDS.Storage;\r\n    using SafeMath for uint;\r\n    using SignedSafeMath for int;\r\n\r\n    uint private constant SECONDS_PER_DAY = 86400;\r\n    uint private constant SECONDS_PER_YEAR = 31536000;\r\n    uint private constant INT_MAX = 2**255 - 1;\r\n    uint private constant UINT_FP_SCALING_FACTOR = 10**18;\r\n    int private constant INT_FP_SCALING_FACTOR = 10**18;\r\n\r\n    modifier onlySponsor(TDS.Storage storage s) {\r\n        require(msg.sender == s.externalAddresses.sponsor);\r\n        _;\r\n    }\r\n\r\n    modifier onlyAdmin(TDS.Storage storage s) {\r\n        require(msg.sender == s.externalAddresses.admin);\r\n        _;\r\n    }\r\n\r\n    modifier onlySponsorOrAdmin(TDS.Storage storage s) {\r\n        require(msg.sender == s.externalAddresses.sponsor || msg.sender == s.externalAddresses.admin);\r\n        _;\r\n    }\r\n\r\n    modifier onlySponsorOrApDelegate(TDS.Storage storage s) {\r\n        require(msg.sender == s.externalAddresses.sponsor || msg.sender == s.externalAddresses.apDelegate);\r\n        _;\r\n    }\r\n\r\n    // Contract initializer. Should only be called at construction.\r\n    // Note: Must be a public function because structs cannot be passed as calldata (required data type for external\r\n    // functions).\r\n    function _initialize(\r\n        TDS.Storage storage s, TokenizedDerivativeParams.ConstructorParams memory params, string memory symbol) public {\r\n\r\n        s._setFixedParameters(params, symbol);\r\n        s._setExternalAddresses(params);\r\n        \r\n        // Keep the starting token price relatively close to FP_SCALING_FACTOR to prevent users from unintentionally\r\n        // creating rounding or overflow errors.\r\n        require(params.startingTokenPrice >= UINT_FP_SCALING_FACTOR.div(10**9));\r\n        require(params.startingTokenPrice <= UINT_FP_SCALING_FACTOR.mul(10**9));\r\n\r\n        // TODO(mrice32): we should have an ideal start time rather than blindly polling.\r\n        (uint latestTime, int latestUnderlyingPrice) = s.externalAddresses.priceFeed.latestPrice(s.fixedParameters.product);\r\n\r\n        // If nonzero, take the user input as the starting price.\r\n        if (params.startingUnderlyingPrice != 0) {\r\n            latestUnderlyingPrice = _safeIntCast(params.startingUnderlyingPrice);\r\n        }\r\n\r\n        require(latestUnderlyingPrice > 0);\r\n        require(latestTime != 0);\r\n\r\n        // Keep the ratio in case it's needed for margin computation.\r\n        s.fixedParameters.initialTokenUnderlyingRatio = params.startingTokenPrice.mul(UINT_FP_SCALING_FACTOR).div(_safeUintCast(latestUnderlyingPrice));\r\n        require(s.fixedParameters.initialTokenUnderlyingRatio != 0);\r\n\r\n        // Set end time to max value of uint to implement no expiry.\r\n        if (params.expiry == 0) {\r\n            s.endTime = ~uint(0);\r\n        } else {\r\n            require(params.expiry >= latestTime);\r\n            s.endTime = params.expiry;\r\n        }\r\n\r\n        s.nav = s._computeInitialNav(latestUnderlyingPrice, latestTime, params.startingTokenPrice);\r\n\r\n        s.state = TDS.State.Live;\r\n    }\r\n\r\n    function _depositAndCreateTokens(TDS.Storage storage s, uint marginForPurchase, uint tokensToPurchase) external onlySponsorOrApDelegate(s) {\r\n        s._remarginInternal();\r\n\r\n        int newTokenNav = _computeNavForTokens(s.currentTokenState.tokenPrice, tokensToPurchase);\r\n\r\n        if (newTokenNav < 0) {\r\n            newTokenNav = 0;\r\n        }\r\n\r\n        uint positiveTokenNav = _safeUintCast(newTokenNav);\r\n\r\n        // Get any refund due to sending more margin than the argument indicated (should only be able to happen in the\r\n        // ETH case).\r\n        uint refund = s._pullSentMargin(marginForPurchase);\r\n\r\n        // Subtract newTokenNav from amount sent.\r\n        uint depositAmount = marginForPurchase.sub(positiveTokenNav);\r\n\r\n        // Deposit additional margin into the short account.\r\n        s._depositInternal(depositAmount);\r\n\r\n        // The _createTokensInternal call returns any refund due to the amount sent being larger than the amount\r\n        // required to purchase the tokens, so we add that to the running refund. This should be 0 in this case,\r\n        // but we leave this here in case of some refund being generated due to rounding errors or any bugs to ensure\r\n        // the sender never loses money.\r\n        refund = refund.add(s._createTokensInternal(tokensToPurchase, positiveTokenNav));\r\n\r\n        // Send the accumulated refund.\r\n        s._sendMargin(refund);\r\n    }\r\n\r\n    function _redeemTokens(TDS.Storage storage s, uint tokensToRedeem) external {\r\n        require(s.state == TDS.State.Live || s.state == TDS.State.Settled);\r\n        require(tokensToRedeem > 0);\r\n\r\n        if (s.state == TDS.State.Live) {\r\n            require(msg.sender == s.externalAddresses.sponsor || msg.sender == s.externalAddresses.apDelegate);\r\n            s._remarginInternal();\r\n            require(s.state == TDS.State.Live);\r\n        }\r\n\r\n        ExpandedIERC20 thisErc20Token = ExpandedIERC20(address(this));\r\n\r\n        uint initialSupply = _totalSupply();\r\n        require(initialSupply > 0);\r\n\r\n        _pullAuthorizedTokens(thisErc20Token, tokensToRedeem);\r\n        thisErc20Token.burn(tokensToRedeem);\r\n        emit TokensRedeemed(s.fixedParameters.symbol, tokensToRedeem);\r\n\r\n        // Value of the tokens is just the percentage of all the tokens multiplied by the balance of the investor\r\n        // margin account.\r\n        uint tokenPercentage = tokensToRedeem.mul(UINT_FP_SCALING_FACTOR).div(initialSupply);\r\n        uint tokenMargin = _takePercentage(_safeUintCast(s.longBalance), tokenPercentage);\r\n\r\n        s.longBalance = s.longBalance.sub(_safeIntCast(tokenMargin));\r\n        assert(s.longBalance >= 0);\r\n        s.nav = _computeNavForTokens(s.currentTokenState.tokenPrice, _totalSupply());\r\n\r\n        s._sendMargin(tokenMargin);\r\n    }\r\n\r\n    function _dispute(TDS.Storage storage s, uint depositMargin) external onlySponsor(s) {\r\n        require(\r\n            s.state == TDS.State.Live,\r\n            \"Contract must be Live to dispute\"\r\n        );\r\n\r\n        uint requiredDeposit = _safeUintCast(_takePercentage(s._getRequiredMargin(s.currentTokenState), s.fixedParameters.disputeDeposit));\r\n\r\n        uint sendInconsistencyRefund = s._pullSentMargin(depositMargin);\r\n\r\n        require(depositMargin >= requiredDeposit);\r\n        uint overpaymentRefund = depositMargin.sub(requiredDeposit);\r\n\r\n        s.state = TDS.State.Disputed;\r\n        s.endTime = s.currentTokenState.time;\r\n        s.disputeInfo.disputedNav = s.nav;\r\n        s.disputeInfo.deposit = requiredDeposit;\r\n\r\n        // Store the default penalty in case the dispute pushes the sponsor into default.\r\n        s.defaultPenaltyAmount = s._computeDefaultPenalty();\r\n        emit Disputed(s.fixedParameters.symbol, s.endTime, s.nav);\r\n\r\n        s._requestOraclePrice(s.endTime);\r\n\r\n        // Add the two types of refunds:\r\n        // 1. The refund for ETH sent if it was > depositMargin.\r\n        // 2. The refund for depositMargin > requiredDeposit.\r\n        s._sendMargin(sendInconsistencyRefund.add(overpaymentRefund));\r\n    }\r\n\r\n    function _withdraw(TDS.Storage storage s, uint amount) external onlySponsor(s) {\r\n        // Remargin before allowing a withdrawal, but only if in the live state.\r\n        if (s.state == TDS.State.Live) {\r\n            s._remarginInternal();\r\n        }\r\n\r\n        // Make sure either in Live or Settled after any necessary remargin.\r\n        require(s.state == TDS.State.Live || s.state == TDS.State.Settled);\r\n\r\n        // If the contract has been settled or is in prefunded state then can\r\n        // withdraw up to full balance. If the contract is in live state then\r\n        // must leave at least the required margin. Not allowed to withdraw in\r\n        // other states.\r\n        int withdrawableAmount;\r\n        if (s.state == TDS.State.Settled) {\r\n            withdrawableAmount = s.shortBalance;\r\n        } else {\r\n            // Update throttling snapshot and verify that this withdrawal doesn't go past the throttle limit.\r\n            uint currentTime = s.currentTokenState.time;\r\n            if (s.withdrawThrottle.startTime <= currentTime.sub(SECONDS_PER_DAY)) {\r\n                // We've passed the previous s.withdrawThrottle window. Start new one.\r\n                s.withdrawThrottle.startTime = currentTime;\r\n                s.withdrawThrottle.remainingWithdrawal = _takePercentage(_safeUintCast(s.shortBalance), s.fixedParameters.withdrawLimit);\r\n            }\r\n\r\n            int marginMaxWithdraw = s.shortBalance.sub(s._getRequiredMargin(s.currentTokenState));\r\n            int throttleMaxWithdraw = _safeIntCast(s.withdrawThrottle.remainingWithdrawal);\r\n\r\n            // Take the smallest of the two withdrawal limits.\r\n            withdrawableAmount = throttleMaxWithdraw < marginMaxWithdraw ? throttleMaxWithdraw : marginMaxWithdraw;\r\n\r\n            // Note: this line alone implicitly ensures the withdrawal throttle is not violated, but the above\r\n            // ternary is more explicit.\r\n            s.withdrawThrottle.remainingWithdrawal = s.withdrawThrottle.remainingWithdrawal.sub(amount);\r\n        }\r\n\r\n        // Can only withdraw the allowed amount.\r\n        require(\r\n            withdrawableAmount >= _safeIntCast(amount),\r\n            \"Attempting to withdraw more than allowed\"\r\n        );\r\n\r\n        // Transfer amount - Note: important to `-=` before the send so that the\r\n        // function can not be called multiple times while waiting for transfer\r\n        // to return.\r\n        s.shortBalance = s.shortBalance.sub(_safeIntCast(amount));\r\n        emit Withdrawal(s.fixedParameters.symbol, amount);\r\n        s._sendMargin(amount);\r\n    }\r\n\r\n    function _acceptPriceAndSettle(TDS.Storage storage s) external onlySponsor(s) {\r\n        // Right now, only confirming prices in the defaulted state.\r\n        require(s.state == TDS.State.Defaulted);\r\n\r\n        // Remargin on agreed upon price.\r\n        s._settleAgreedPrice();\r\n    }\r\n\r\n    function _setApDelegate(TDS.Storage storage s, address _apDelegate) external onlySponsor(s) {\r\n        s.externalAddresses.apDelegate = _apDelegate;\r\n    }\r\n\r\n    // Moves the contract into the Emergency state, where it waits on an Oracle price for the most recent remargin time.\r\n    function _emergencyShutdown(TDS.Storage storage s) external onlyAdmin(s) {\r\n        require(s.state == TDS.State.Live);\r\n        s.state = TDS.State.Emergency;\r\n        s.endTime = s.currentTokenState.time;\r\n        s.defaultPenaltyAmount = s._computeDefaultPenalty();\r\n        emit EmergencyShutdownTransition(s.fixedParameters.symbol, s.endTime);\r\n        s._requestOraclePrice(s.endTime);\r\n    }\r\n\r\n    function _settle(TDS.Storage storage s) external {\r\n        s._settleInternal();\r\n    }\r\n\r\n    function _createTokens(TDS.Storage storage s, uint marginForPurchase, uint tokensToPurchase) external onlySponsorOrApDelegate(s) {\r\n        // Returns any refund due to sending more margin than the argument indicated (should only be able to happen in\r\n        // the ETH case).\r\n        uint refund = s._pullSentMargin(marginForPurchase);\r\n\r\n        // The _createTokensInternal call returns any refund due to the amount sent being larger than the amount\r\n        // required to purchase the tokens, so we add that to the running refund.\r\n        refund = refund.add(s._createTokensInternal(tokensToPurchase, marginForPurchase));\r\n\r\n        // Send the accumulated refund.\r\n        s._sendMargin(refund);\r\n    }\r\n\r\n    function _deposit(TDS.Storage storage s, uint marginToDeposit) external onlySponsor(s) {\r\n        // Only allow the s.externalAddresses.sponsor to deposit margin.\r\n        uint refund = s._pullSentMargin(marginToDeposit);\r\n        s._depositInternal(marginToDeposit);\r\n\r\n        // Send any refund due to sending more margin than the argument indicated (should only be able to happen in the\r\n        // ETH case).\r\n        s._sendMargin(refund);\r\n    }\r\n\r\n    // Returns the expected net asset value (NAV) of the contract using the latest available Price Feed price.\r\n    function _calcNAV(TDS.Storage storage s) external view returns (int navNew) {\r\n        (TDS.TokenState memory newTokenState, ) = s._calcNewTokenStateAndBalance();\r\n        navNew = _computeNavForTokens(newTokenState.tokenPrice, _totalSupply());\r\n    }\r\n\r\n    // Returns the expected value of each the outstanding tokens of the contract using the latest available Price Feed\r\n    // price.\r\n    function _calcTokenValue(TDS.Storage storage s) external view returns (int newTokenValue) {\r\n        (TDS.TokenState memory newTokenState,) = s._calcNewTokenStateAndBalance();\r\n        newTokenValue = newTokenState.tokenPrice;\r\n    }\r\n\r\n    // Returns the expected balance of the short margin account using the latest available Price Feed price.\r\n    function _calcShortMarginBalance(TDS.Storage storage s) external view returns (int newShortMarginBalance) {\r\n        (, newShortMarginBalance) = s._calcNewTokenStateAndBalance();\r\n    }\r\n\r\n    function _calcExcessMargin(TDS.Storage storage s) external view returns (int newExcessMargin) {\r\n        (TDS.TokenState memory newTokenState, int newShortMarginBalance) = s._calcNewTokenStateAndBalance();\r\n        // If the contract is in/will be moved to a settled state, the margin requirement will be 0.\r\n        int requiredMargin = newTokenState.time >= s.endTime ? 0 : s._getRequiredMargin(newTokenState);\r\n        return newShortMarginBalance.sub(requiredMargin);\r\n    }\r\n\r\n    function _getCurrentRequiredMargin(TDS.Storage storage s) external view returns (int requiredMargin) {\r\n        if (s.state == TDS.State.Settled) {\r\n            // No margin needs to be maintained when the contract is settled.\r\n            return 0;\r\n        }\r\n\r\n         return s._getRequiredMargin(s.currentTokenState);\r\n    }\r\n\r\n    function _canBeSettled(TDS.Storage storage s) external view returns (bool canBeSettled) {\r\n        TDS.State currentState = s.state;\r\n\r\n        if (currentState == TDS.State.Settled) {\r\n            return false;\r\n        }\r\n\r\n        // Technically we should also check if price will default the contract, but that isn't a normal flow of\r\n        // operations that we want to simulate: we want to discourage the sponsor remargining into a default.\r\n        (uint priceFeedTime, ) = s._getLatestPrice();\r\n        if (currentState == TDS.State.Live && (priceFeedTime < s.endTime)) {\r\n            return false;\r\n        }\r\n\r\n        return s.externalAddresses.oracle.hasPrice(s.fixedParameters.product, s.endTime);\r\n    }\r\n\r\n    function _getUpdatedUnderlyingPrice(TDS.Storage storage s) external view returns (int underlyingPrice, uint time) {\r\n        (TDS.TokenState memory newTokenState, ) = s._calcNewTokenStateAndBalance();\r\n        return (newTokenState.underlyingPrice, newTokenState.time);\r\n    }\r\n\r\n    function _calcNewTokenStateAndBalance(TDS.Storage storage s) internal view returns (TDS.TokenState memory newTokenState, int newShortMarginBalance)\r\n    {\r\n        // TODO: there's a lot of repeated logic in this method from elsewhere in the contract. It should be extracted\r\n        // so the logic can be written once and used twice. However, much of this was written post-audit, so it was\r\n        // deemed preferable not to modify any state changing code that could potentially introduce new security\r\n        // bugs. This should be done before the next contract audit.\r\n\r\n        if (s.state == TDS.State.Settled) {\r\n            // If the contract is Settled, just return the current contract state.\r\n            return (s.currentTokenState, s.shortBalance);\r\n        }\r\n\r\n        // Grab the price feed pricetime.\r\n        (uint priceFeedTime, int priceFeedPrice) = s._getLatestPrice();\r\n\r\n        bool isContractLive = s.state == TDS.State.Live;\r\n        bool isContractPostExpiry = priceFeedTime >= s.endTime;\r\n\r\n        // If the time hasn't advanced since the last remargin, short circuit and return the most recently computed values.\r\n        if (isContractLive && priceFeedTime <= s.currentTokenState.time) {\r\n            return (s.currentTokenState, s.shortBalance);\r\n        }\r\n\r\n        // Determine which previous price state to use when computing the new NAV.\r\n        // If the contract is live, we use the reference for the linear return type or if the contract will immediately\r\n        // move to expiry. \r\n        bool shouldUseReferenceTokenState = isContractLive &&\r\n            (s.fixedParameters.returnType == TokenizedDerivativeParams.ReturnType.Linear || isContractPostExpiry);\r\n        TDS.TokenState memory lastTokenState = shouldUseReferenceTokenState ? s.referenceTokenState : s.currentTokenState;\r\n\r\n        // Use the oracle settlement price/time if the contract is frozen or will move to expiry on the next remargin.\r\n        (uint recomputeTime, int recomputePrice) = !isContractLive || isContractPostExpiry ?\r\n            (s.endTime, s.externalAddresses.oracle.getPrice(s.fixedParameters.product, s.endTime)) :\r\n            (priceFeedTime, priceFeedPrice);\r\n\r\n        // Init the returned short balance to the current short balance.\r\n        newShortMarginBalance = s.shortBalance;\r\n\r\n        // Subtract the oracle fees from the short balance.\r\n        newShortMarginBalance = isContractLive ?\r\n            newShortMarginBalance.sub(\r\n                _safeIntCast(s._computeExpectedOracleFees(s.currentTokenState.time, recomputeTime))) :\r\n            newShortMarginBalance;\r\n\r\n        // Compute the new NAV\r\n        newTokenState = s._computeNewTokenState(lastTokenState, recomputePrice, recomputeTime);\r\n        int navNew = _computeNavForTokens(newTokenState.tokenPrice, _totalSupply());\r\n        newShortMarginBalance = newShortMarginBalance.sub(_getLongDiff(navNew, s.longBalance, newShortMarginBalance));\r\n\r\n        // If the contract is frozen or will move into expiry, we need to settle it, which means adding the default\r\n        // penalty and dispute deposit if necessary.\r\n        if (!isContractLive || isContractPostExpiry) {\r\n            // Subtract default penalty (if necessary) from the short balance.\r\n            bool inDefault = !s._satisfiesMarginRequirement(newShortMarginBalance, newTokenState);\r\n            if (inDefault) {\r\n                int expectedDefaultPenalty = isContractLive ? s._computeDefaultPenalty() : s._getDefaultPenalty();\r\n                int defaultPenalty = (newShortMarginBalance < expectedDefaultPenalty) ?\r\n                    newShortMarginBalance :\r\n                    expectedDefaultPenalty;\r\n                newShortMarginBalance = newShortMarginBalance.sub(defaultPenalty);\r\n            }\r\n\r\n            // Add the dispute deposit to the short balance if necessary.\r\n            if (s.state == TDS.State.Disputed && navNew != s.disputeInfo.disputedNav) {\r\n                int depositValue = _safeIntCast(s.disputeInfo.deposit);\r\n                newShortMarginBalance = newShortMarginBalance.add(depositValue);\r\n            }\r\n        }\r\n    }\r\n\r\n    function _computeInitialNav(TDS.Storage storage s, int latestUnderlyingPrice, uint latestTime, uint startingTokenPrice)\r\n        internal\r\n        returns (int navNew)\r\n    {\r\n        int unitNav = _safeIntCast(startingTokenPrice);\r\n        s.referenceTokenState = TDS.TokenState(latestUnderlyingPrice, unitNav, latestTime);\r\n        s.currentTokenState = TDS.TokenState(latestUnderlyingPrice, unitNav, latestTime);\r\n        // Starting NAV is always 0 in the TokenizedDerivative case.\r\n        navNew = 0;\r\n    }\r\n\r\n    function _remargin(TDS.Storage storage s) external onlySponsorOrAdmin(s) {\r\n        s._remarginInternal();\r\n    }\r\n\r\n    function _withdrawUnexpectedErc20(TDS.Storage storage s, address erc20Address, uint amount) external onlySponsor(s) {\r\n        if(address(s.externalAddresses.marginCurrency) == erc20Address) {\r\n            uint currentBalance = s.externalAddresses.marginCurrency.balanceOf(address(this));\r\n            int totalBalances = s.shortBalance.add(s.longBalance);\r\n            assert(totalBalances >= 0);\r\n            uint withdrawableAmount = currentBalance.sub(_safeUintCast(totalBalances)).sub(s.disputeInfo.deposit);\r\n            require(withdrawableAmount >= amount);\r\n        }\r\n\r\n        IERC20 erc20 = IERC20(erc20Address);\r\n        require(erc20.transfer(msg.sender, amount));\r\n    }\r\n\r\n    function _setExternalAddresses(TDS.Storage storage s, TokenizedDerivativeParams.ConstructorParams memory params) internal {\r\n\r\n        // Note: not all \"ERC20\" tokens conform exactly to this interface (BNB, OMG, etc). The most common way that\r\n        // tokens fail to conform is that they do not return a bool from certain state-changing operations. This\r\n        // contract was not designed to work with those tokens because of the additional complexity they would\r\n        // introduce.\r\n        s.externalAddresses.marginCurrency = IERC20(params.marginCurrency);\r\n\r\n        s.externalAddresses.oracle = OracleInterface(params.oracle);\r\n        s.externalAddresses.store = StoreInterface(params.store);\r\n        s.externalAddresses.priceFeed = PriceFeedInterface(params.priceFeed);\r\n        s.externalAddresses.returnCalculator = ReturnCalculatorInterface(params.returnCalculator);\r\n\r\n        // Verify that the price feed and s.externalAddresses.oracle support the given s.fixedParameters.product.\r\n        require(s.externalAddresses.oracle.isIdentifierSupported(params.product));\r\n        require(s.externalAddresses.priceFeed.isIdentifierSupported(params.product));\r\n\r\n        s.externalAddresses.sponsor = params.sponsor;\r\n        s.externalAddresses.admin = params.admin;\r\n    }\r\n\r\n    function _setFixedParameters(TDS.Storage storage s, TokenizedDerivativeParams.ConstructorParams memory params, string memory symbol) internal {\r\n        // Ensure only valid enum values are provided.\r\n        require(params.returnType == TokenizedDerivativeParams.ReturnType.Compound\r\n            || params.returnType == TokenizedDerivativeParams.ReturnType.Linear);\r\n\r\n        // Fee must be 0 if the returnType is linear.\r\n        require(params.returnType == TokenizedDerivativeParams.ReturnType.Compound || params.fixedYearlyFee == 0);\r\n\r\n        // The default penalty must be less than the required margin.\r\n        require(params.defaultPenalty <= UINT_FP_SCALING_FACTOR);\r\n\r\n        s.fixedParameters.returnType = params.returnType;\r\n        s.fixedParameters.defaultPenalty = params.defaultPenalty;\r\n        s.fixedParameters.product = params.product;\r\n        s.fixedParameters.fixedFeePerSecond = params.fixedYearlyFee.div(SECONDS_PER_YEAR);\r\n        s.fixedParameters.disputeDeposit = params.disputeDeposit;\r\n        s.fixedParameters.supportedMove = params.supportedMove;\r\n        s.fixedParameters.withdrawLimit = params.withdrawLimit;\r\n        s.fixedParameters.creationTime = params.creationTime;\r\n        s.fixedParameters.symbol = symbol;\r\n    }\r\n\r\n    // _remarginInternal() allows other functions to call remargin internally without satisfying permission checks for\r\n    // _remargin().\r\n    function _remarginInternal(TDS.Storage storage s) internal {\r\n        // If the state is not live, remargining does not make sense.\r\n        require(s.state == TDS.State.Live);\r\n\r\n        (uint latestTime, int latestPrice) = s._getLatestPrice();\r\n        // Checks whether contract has ended.\r\n        if (latestTime <= s.currentTokenState.time) {\r\n            // If the price feed hasn't advanced, remargining should be a no-op.\r\n            return;\r\n        }\r\n\r\n        // Save the penalty using the current state in case it needs to be used.\r\n        int potentialPenaltyAmount = s._computeDefaultPenalty();\r\n\r\n        if (latestTime >= s.endTime) {\r\n            s.state = TDS.State.Expired;\r\n            emit Expired(s.fixedParameters.symbol, s.endTime);\r\n\r\n            // Applies the same update a second time to effectively move the current state to the reference state.\r\n            int recomputedNav = s._computeNav(s.currentTokenState.underlyingPrice, s.currentTokenState.time);\r\n            assert(recomputedNav == s.nav);\r\n\r\n            uint feeAmount = s._deductOracleFees(s.currentTokenState.time, s.endTime);\r\n\r\n            // Save the precomputed default penalty in case the expiry price pushes the sponsor into default.\r\n            s.defaultPenaltyAmount = potentialPenaltyAmount;\r\n\r\n            // We have no idea what the price was, exactly at s.endTime, so we can't set\r\n            // s.currentTokenState, or update the nav, or do anything.\r\n            s._requestOraclePrice(s.endTime);\r\n            s._payOracleFees(feeAmount);\r\n            return;\r\n        }\r\n        uint feeAmount = s._deductOracleFees(s.currentTokenState.time, latestTime);\r\n\r\n        // Update nav of contract.\r\n        int navNew = s._computeNav(latestPrice, latestTime);\r\n\r\n        // Update the balances of the contract.\r\n        s._updateBalances(navNew);\r\n\r\n        // Make sure contract has not moved into default.\r\n        bool inDefault = !s._satisfiesMarginRequirement(s.shortBalance, s.currentTokenState);\r\n        if (inDefault) {\r\n            s.state = TDS.State.Defaulted;\r\n            s.defaultPenaltyAmount = potentialPenaltyAmount;\r\n            s.endTime = latestTime; // Change end time to moment when default occurred.\r\n            emit Default(s.fixedParameters.symbol, latestTime, s.nav);\r\n            s._requestOraclePrice(latestTime);\r\n        }\r\n\r\n        s._payOracleFees(feeAmount);\r\n    }\r\n\r\n    function _createTokensInternal(TDS.Storage storage s, uint tokensToPurchase, uint navSent) internal returns (uint refund) {\r\n        s._remarginInternal();\r\n\r\n        // Verify that remargining didn't push the contract into expiry or default.\r\n        require(s.state == TDS.State.Live);\r\n\r\n        int purchasedNav = _computeNavForTokens(s.currentTokenState.tokenPrice, tokensToPurchase);\r\n\r\n        if (purchasedNav < 0) {\r\n            purchasedNav = 0;\r\n        }\r\n\r\n        // Ensures that requiredNav >= navSent.\r\n        refund = navSent.sub(_safeUintCast(purchasedNav));\r\n\r\n        s.longBalance = s.longBalance.add(purchasedNav);\r\n\r\n        ExpandedIERC20 thisErc20Token = ExpandedIERC20(address(this));\r\n\r\n        thisErc20Token.mint(msg.sender, tokensToPurchase);\r\n        emit TokensCreated(s.fixedParameters.symbol, tokensToPurchase);\r\n\r\n        s.nav = _computeNavForTokens(s.currentTokenState.tokenPrice, _totalSupply());\r\n\r\n        // Make sure this still satisfies the margin requirement.\r\n        require(s._satisfiesMarginRequirement(s.shortBalance, s.currentTokenState));\r\n    }\r\n\r\n    function _depositInternal(TDS.Storage storage s, uint value) internal {\r\n        // Make sure that we are in a \"depositable\" state.\r\n        require(s.state == TDS.State.Live);\r\n        s.shortBalance = s.shortBalance.add(_safeIntCast(value));\r\n        emit Deposited(s.fixedParameters.symbol, value);\r\n    }\r\n\r\n    function _settleInternal(TDS.Storage storage s) internal {\r\n        TDS.State startingState = s.state;\r\n        require(startingState == TDS.State.Disputed || startingState == TDS.State.Expired\r\n                || startingState == TDS.State.Defaulted || startingState == TDS.State.Emergency);\r\n        s._settleVerifiedPrice();\r\n        if (startingState == TDS.State.Disputed) {\r\n            int depositValue = _safeIntCast(s.disputeInfo.deposit);\r\n            if (s.nav != s.disputeInfo.disputedNav) {\r\n                s.shortBalance = s.shortBalance.add(depositValue);\r\n            } else {\r\n                s.longBalance = s.longBalance.add(depositValue);\r\n            }\r\n        }\r\n    }\r\n\r\n    // Deducts the fees from the margin account.\r\n    function _deductOracleFees(TDS.Storage storage s, uint lastTimeOracleFeesPaid, uint currentTime) internal returns (uint feeAmount) {\r\n        feeAmount = s._computeExpectedOracleFees(lastTimeOracleFeesPaid, currentTime);\r\n        s.shortBalance = s.shortBalance.sub(_safeIntCast(feeAmount));\r\n        // If paying the Oracle fee reduces the held margin below requirements, the rest of remargin() will default the\r\n        // contract.\r\n    }\r\n\r\n    // Pays out the fees to the Oracle.\r\n    function _payOracleFees(TDS.Storage storage s, uint feeAmount) internal {\r\n        if (feeAmount == 0) {\r\n            return;\r\n        }\r\n\r\n        if (address(s.externalAddresses.marginCurrency) == address(0x0)) {\r\n            s.externalAddresses.store.payOracleFees.value(feeAmount)();\r\n        } else {\r\n            require(s.externalAddresses.marginCurrency.approve(address(s.externalAddresses.store), feeAmount));\r\n            s.externalAddresses.store.payOracleFeesErc20(address(s.externalAddresses.marginCurrency));\r\n        }\r\n    }\r\n\r\n    function _computeExpectedOracleFees(TDS.Storage storage s, uint lastTimeOracleFeesPaid, uint currentTime)\r\n        internal\r\n        view\r\n        returns (uint feeAmount)\r\n    {\r\n        // The profit from corruption is set as the max(longBalance, shortBalance).\r\n        int pfc = s.shortBalance < s.longBalance ? s.longBalance : s.shortBalance;\r\n        uint expectedFeeAmount = s.externalAddresses.store.computeOracleFees(lastTimeOracleFeesPaid, currentTime, _safeUintCast(pfc));\r\n\r\n        // Ensure the fee returned can actually be paid by the short margin account.\r\n        uint shortBalance = _safeUintCast(s.shortBalance);\r\n        return (shortBalance < expectedFeeAmount) ? shortBalance : expectedFeeAmount;\r\n    }\r\n\r\n    function _computeNewTokenState(TDS.Storage storage s,\r\n        TDS.TokenState memory beginningTokenState, int latestUnderlyingPrice, uint recomputeTime)\r\n        internal\r\n        view\r\n        returns (TDS.TokenState memory newTokenState)\r\n    {\r\n        int underlyingReturn = s.externalAddresses.returnCalculator.computeReturn(\r\n            beginningTokenState.underlyingPrice, latestUnderlyingPrice);\r\n        int tokenReturn = underlyingReturn.sub(\r\n            _safeIntCast(s.fixedParameters.fixedFeePerSecond.mul(recomputeTime.sub(beginningTokenState.time))));\r\n        int tokenMultiplier = tokenReturn.add(INT_FP_SCALING_FACTOR);\r\n        \r\n        // In the compound case, don't allow the token price to go below 0.\r\n        if (s.fixedParameters.returnType == TokenizedDerivativeParams.ReturnType.Compound && tokenMultiplier < 0) {\r\n            tokenMultiplier = 0;\r\n        }\r\n\r\n        int newTokenPrice = _takePercentage(beginningTokenState.tokenPrice, tokenMultiplier);\r\n        newTokenState = TDS.TokenState(latestUnderlyingPrice, newTokenPrice, recomputeTime);\r\n    }\r\n\r\n    function _satisfiesMarginRequirement(TDS.Storage storage s, int balance, TDS.TokenState memory tokenState)\r\n        internal\r\n        view\r\n        returns (bool doesSatisfyRequirement) \r\n    {\r\n        return s._getRequiredMargin(tokenState) <= balance;\r\n    }\r\n\r\n    function _requestOraclePrice(TDS.Storage storage s, uint requestedTime) internal {\r\n        uint expectedTime = s.externalAddresses.oracle.requestPrice(s.fixedParameters.product, requestedTime);\r\n        if (expectedTime == 0) {\r\n            // The Oracle price is already available, settle the contract right away.\r\n            s._settleInternal();\r\n        }\r\n    }\r\n\r\n    function _getLatestPrice(TDS.Storage storage s) internal view returns (uint latestTime, int latestUnderlyingPrice) {\r\n        (latestTime, latestUnderlyingPrice) = s.externalAddresses.priceFeed.latestPrice(s.fixedParameters.product);\r\n        require(latestTime != 0);\r\n    }\r\n\r\n    function _computeNav(TDS.Storage storage s, int latestUnderlyingPrice, uint latestTime) internal returns (int navNew) {\r\n        if (s.fixedParameters.returnType == TokenizedDerivativeParams.ReturnType.Compound) {\r\n            navNew = s._computeCompoundNav(latestUnderlyingPrice, latestTime);\r\n        } else {\r\n            assert(s.fixedParameters.returnType == TokenizedDerivativeParams.ReturnType.Linear);\r\n            navNew = s._computeLinearNav(latestUnderlyingPrice, latestTime);\r\n        }\r\n    }\r\n\r\n    function _computeCompoundNav(TDS.Storage storage s, int latestUnderlyingPrice, uint latestTime) internal returns (int navNew) {\r\n        s.referenceTokenState = s.currentTokenState;\r\n        s.currentTokenState = s._computeNewTokenState(s.currentTokenState, latestUnderlyingPrice, latestTime);\r\n        navNew = _computeNavForTokens(s.currentTokenState.tokenPrice, _totalSupply());\r\n        emit NavUpdated(s.fixedParameters.symbol, navNew, s.currentTokenState.tokenPrice);\r\n    }\r\n\r\n    function _computeLinearNav(TDS.Storage storage s, int latestUnderlyingPrice, uint latestTime) internal returns (int navNew) {\r\n        // Only update the time - don't update the prices becuase all price changes are relative to the initial price.\r\n        s.referenceTokenState.time = s.currentTokenState.time;\r\n        s.currentTokenState = s._computeNewTokenState(s.referenceTokenState, latestUnderlyingPrice, latestTime);\r\n        navNew = _computeNavForTokens(s.currentTokenState.tokenPrice, _totalSupply());\r\n        emit NavUpdated(s.fixedParameters.symbol, navNew, s.currentTokenState.tokenPrice);\r\n    }\r\n\r\n    function _recomputeNav(TDS.Storage storage s, int oraclePrice, uint recomputeTime) internal returns (int navNew) {\r\n        // We're updating `last` based on what the Oracle has told us.\r\n        assert(s.endTime == recomputeTime);\r\n        s.currentTokenState = s._computeNewTokenState(s.referenceTokenState, oraclePrice, recomputeTime);\r\n        navNew = _computeNavForTokens(s.currentTokenState.tokenPrice, _totalSupply());\r\n        emit NavUpdated(s.fixedParameters.symbol, navNew, s.currentTokenState.tokenPrice);\r\n    }\r\n\r\n    // Function is internally only called by `_settleAgreedPrice` or `_settleVerifiedPrice`. This function handles all \r\n    // of the settlement logic including assessing penalties and then moves the state to `Settled`.\r\n    function _settleWithPrice(TDS.Storage storage s, int price) internal {\r\n\r\n        // Remargin at whatever price we're using (verified or unverified).\r\n        s._updateBalances(s._recomputeNav(price, s.endTime));\r\n\r\n        bool inDefault = !s._satisfiesMarginRequirement(s.shortBalance, s.currentTokenState);\r\n\r\n        if (inDefault) {\r\n            int expectedDefaultPenalty = s._getDefaultPenalty();\r\n            int penalty = (s.shortBalance < expectedDefaultPenalty) ?\r\n                s.shortBalance :\r\n                expectedDefaultPenalty;\r\n\r\n            s.shortBalance = s.shortBalance.sub(penalty);\r\n            s.longBalance = s.longBalance.add(penalty);\r\n        }\r\n\r\n        s.state = TDS.State.Settled;\r\n        emit Settled(s.fixedParameters.symbol, s.endTime, s.nav);\r\n    }\r\n\r\n    function _updateBalances(TDS.Storage storage s, int navNew) internal {\r\n        // Compute difference -- Add the difference to owner and subtract\r\n        // from counterparty. Then update nav state variable.\r\n        int longDiff = _getLongDiff(navNew, s.longBalance, s.shortBalance);\r\n        s.nav = navNew;\r\n\r\n        s.longBalance = s.longBalance.add(longDiff);\r\n        s.shortBalance = s.shortBalance.sub(longDiff);\r\n    }\r\n\r\n    function _getDefaultPenalty(TDS.Storage storage s) internal view returns (int penalty) {\r\n        return s.defaultPenaltyAmount;\r\n    }\r\n\r\n    function _computeDefaultPenalty(TDS.Storage storage s) internal view returns (int penalty) {\r\n        return _takePercentage(s._getRequiredMargin(s.currentTokenState), s.fixedParameters.defaultPenalty);\r\n    }\r\n\r\n    function _getRequiredMargin(TDS.Storage storage s, TDS.TokenState memory tokenState)\r\n        internal\r\n        view\r\n        returns (int requiredMargin)\r\n    {\r\n        int leverageMagnitude = _absoluteValue(s.externalAddresses.returnCalculator.leverage());\r\n\r\n        int effectiveNotional;\r\n        if (s.fixedParameters.returnType == TokenizedDerivativeParams.ReturnType.Linear) {\r\n            int effectiveUnitsOfUnderlying = _safeIntCast(_totalSupply().mul(s.fixedParameters.initialTokenUnderlyingRatio).div(UINT_FP_SCALING_FACTOR)).mul(leverageMagnitude);\r\n            effectiveNotional = effectiveUnitsOfUnderlying.mul(tokenState.underlyingPrice).div(INT_FP_SCALING_FACTOR);\r\n        } else {\r\n            int currentNav = _computeNavForTokens(tokenState.tokenPrice, _totalSupply());\r\n            effectiveNotional = currentNav.mul(leverageMagnitude);\r\n        }\r\n\r\n        // Take the absolute value of the notional since a negative notional has similar risk properties to a positive\r\n        // notional of the same size, and, therefore, requires the same margin.\r\n        requiredMargin = _takePercentage(_absoluteValue(effectiveNotional), s.fixedParameters.supportedMove);\r\n    }\r\n\r\n    function _pullSentMargin(TDS.Storage storage s, uint expectedMargin) internal returns (uint refund) {\r\n        if (address(s.externalAddresses.marginCurrency) == address(0x0)) {\r\n            // Refund is any amount of ETH that was sent that was above the amount that was expected.\r\n            // Note: SafeMath will force a revert if msg.value < expectedMargin.\r\n            return msg.value.sub(expectedMargin);\r\n        } else {\r\n            // If we expect an ERC20 token, no ETH should be sent.\r\n            require(msg.value == 0);\r\n            _pullAuthorizedTokens(s.externalAddresses.marginCurrency, expectedMargin);\r\n\r\n            // There is never a refund in the ERC20 case since we use the argument to determine how much to \"pull\".\r\n            return 0;\r\n        }\r\n    }\r\n\r\n    function _sendMargin(TDS.Storage storage s, uint amount) internal {\r\n        // There's no point in attempting a send if there's nothing to send.\r\n        if (amount == 0) {\r\n            return;\r\n        }\r\n\r\n        if (address(s.externalAddresses.marginCurrency) == address(0x0)) {\r\n            msg.sender.transfer(amount);\r\n        } else {\r\n            require(s.externalAddresses.marginCurrency.transfer(msg.sender, amount));\r\n        }\r\n    }\r\n\r\n    function _settleAgreedPrice(TDS.Storage storage s) internal {\r\n        int agreedPrice = s.currentTokenState.underlyingPrice;\r\n\r\n        s._settleWithPrice(agreedPrice);\r\n    }\r\n\r\n    function _settleVerifiedPrice(TDS.Storage storage s) internal {\r\n        int oraclePrice = s.externalAddresses.oracle.getPrice(s.fixedParameters.product, s.endTime);\r\n        s._settleWithPrice(oraclePrice);\r\n    }\r\n\r\n    function _pullAuthorizedTokens(IERC20 erc20, uint amountToPull) private {\r\n        // If nothing is being pulled, there's no point in calling a transfer.\r\n        if (amountToPull > 0) {\r\n            require(erc20.transferFrom(msg.sender, address(this), amountToPull));\r\n        }\r\n    }\r\n\r\n    // Gets the change in balance for the long side.\r\n    // Note: there's a function for this because signage is tricky here, and it must be done the same everywhere.\r\n    function _getLongDiff(int navNew, int longBalance, int shortBalance) private pure returns (int longDiff) {\r\n        int newLongBalance = navNew;\r\n\r\n        // Long balance cannot go below zero.\r\n        if (newLongBalance < 0) {\r\n            newLongBalance = 0;\r\n        }\r\n\r\n        longDiff = newLongBalance.sub(longBalance);\r\n\r\n        // Cannot pull more margin from the short than is available.\r\n        if (longDiff > shortBalance) {\r\n            longDiff = shortBalance;\r\n        }\r\n    }\r\n\r\n    function _computeNavForTokens(int tokenPrice, uint numTokens) private pure returns (int navNew) {\r\n        int navPreDivision = _safeIntCast(numTokens).mul(tokenPrice);\r\n        navNew = navPreDivision.div(INT_FP_SCALING_FACTOR);\r\n\r\n        // The navNew division above truncates by default. Instead, we prefer to ceil this value to ensure tokens\r\n        // cannot be purchased or backed with less than their true value.\r\n        if ((navPreDivision % INT_FP_SCALING_FACTOR) != 0) {\r\n            navNew = navNew.add(1);\r\n        }\r\n    }\r\n\r\n    function _totalSupply() private view returns (uint totalSupply) {\r\n        ExpandedIERC20 thisErc20Token = ExpandedIERC20(address(this));\r\n        return thisErc20Token.totalSupply();\r\n    }\r\n\r\n    function _takePercentage(uint value, uint percentage) private pure returns (uint result) {\r\n        return value.mul(percentage).div(UINT_FP_SCALING_FACTOR);\r\n    }\r\n\r\n    function _takePercentage(int value, uint percentage) private pure returns (int result) {\r\n        return value.mul(_safeIntCast(percentage)).div(INT_FP_SCALING_FACTOR);\r\n    }\r\n\r\n    function _takePercentage(int value, int percentage) private pure returns (int result) {\r\n        return value.mul(percentage).div(INT_FP_SCALING_FACTOR);\r\n    }\r\n\r\n    function _absoluteValue(int value) private pure returns (int result) {\r\n        return value < 0 ? value.mul(-1) : value;\r\n    }\r\n\r\n    function _safeIntCast(uint value) private pure returns (int result) {\r\n        require(value <= INT_MAX);\r\n        return int(value);\r\n    }\r\n\r\n    function _safeUintCast(int value) private pure returns (uint result) {\r\n        require(value >= 0);\r\n        return uint(value);\r\n    }\r\n\r\n    // Note that we can't have the symbol parameter be `indexed` due to:\r\n    // TypeError: Indexed reference types cannot yet be used with ABIEncoderV2.\r\n    // An event emitted when the NAV of the contract changes.\r\n    event NavUpdated(string symbol, int newNav, int newTokenPrice);\r\n    // An event emitted when the contract enters the Default state on a remargin.\r\n    event Default(string symbol, uint defaultTime, int defaultNav);\r\n    // An event emitted when the contract settles.\r\n    event Settled(string symbol, uint settleTime, int finalNav);\r\n    // An event emitted when the contract expires.\r\n    event Expired(string symbol, uint expiryTime);\r\n    // An event emitted when the contract's NAV is disputed by the sponsor.\r\n    event Disputed(string symbol, uint timeDisputed, int navDisputed);\r\n    // An event emitted when the contract enters emergency shutdown.\r\n    event EmergencyShutdownTransition(string symbol, uint shutdownTime);\r\n    // An event emitted when tokens are created.\r\n    event TokensCreated(string symbol, uint numTokensCreated);\r\n    // An event emitted when tokens are redeemed.\r\n    event TokensRedeemed(string symbol, uint numTokensRedeemed);\r\n    // An event emitted when margin currency is deposited.\r\n    event Deposited(string symbol, uint amount);\r\n    // An event emitted when margin currency is withdrawn.\r\n    event Withdrawal(string symbol, uint amount);\r\n}\r\n\r\n// TODO(mrice32): make this and TotalReturnSwap derived classes of a single base to encap common functionality.\r\ncontract TokenizedDerivative is ERC20, AdminInterface, ExpandedIERC20 {\r\n    using TokenizedDerivativeUtils for TDS.Storage;\r\n\r\n    // Note: these variables are to give ERC20 consumers information about the token.\r\n    string public name;\r\n    string public symbol;\r\n    uint8 public constant decimals = 18; // solhint-disable-line const-name-snakecase\r\n\r\n    TDS.Storage public derivativeStorage;\r\n\r\n    constructor(\r\n        TokenizedDerivativeParams.ConstructorParams memory params,\r\n        string memory _name,\r\n        string memory _symbol\r\n    ) public {\r\n        // Set token properties.\r\n        name = _name;\r\n        symbol = _symbol;\r\n\r\n        // Initialize the contract.\r\n        derivativeStorage._initialize(params, _symbol);\r\n    }\r\n\r\n    // Creates tokens with sent margin and returns additional margin.\r\n    function createTokens(uint marginForPurchase, uint tokensToPurchase) external payable {\r\n        derivativeStorage._createTokens(marginForPurchase, tokensToPurchase);\r\n    }\r\n\r\n    // Creates tokens with sent margin and deposits additional margin in short account.\r\n    function depositAndCreateTokens(uint marginForPurchase, uint tokensToPurchase) external payable {\r\n        derivativeStorage._depositAndCreateTokens(marginForPurchase, tokensToPurchase);\r\n    }\r\n\r\n    // Redeems tokens for margin currency.\r\n    function redeemTokens(uint tokensToRedeem) external {\r\n        derivativeStorage._redeemTokens(tokensToRedeem);\r\n    }\r\n\r\n    // Triggers a price dispute for the most recent remargin time.\r\n    function dispute(uint depositMargin) external payable {\r\n        derivativeStorage._dispute(depositMargin);\r\n    }\r\n\r\n    // Withdraws `amount` from short margin account.\r\n    function withdraw(uint amount) external {\r\n        derivativeStorage._withdraw(amount);\r\n    }\r\n\r\n    // Pays (Oracle and service) fees for the previous period, updates the contract NAV, moves margin between long and\r\n    // short accounts to reflect the new NAV, and checks if both accounts meet minimum requirements.\r\n    function remargin() external {\r\n        derivativeStorage._remargin();\r\n    }\r\n\r\n    // Forgo the Oracle verified price and settle the contract with last remargin price. This method is only callable on\r\n    // contracts in the `Defaulted` state, and the default penalty is always transferred from the short to the long\r\n    // account.\r\n    function acceptPriceAndSettle() external {\r\n        derivativeStorage._acceptPriceAndSettle();\r\n    }\r\n\r\n    // Assigns an address to be the contract's Delegate AP. Replaces previous value. Set to 0x0 to indicate there is no\r\n    // Delegate AP.\r\n    function setApDelegate(address apDelegate) external {\r\n        derivativeStorage._setApDelegate(apDelegate);\r\n    }\r\n\r\n    // Moves the contract into the Emergency state, where it waits on an Oracle price for the most recent remargin time.\r\n    function emergencyShutdown() external {\r\n        derivativeStorage._emergencyShutdown();\r\n    }\r\n\r\n    // Returns the expected net asset value (NAV) of the contract using the latest available Price Feed price.\r\n    function calcNAV() external view returns (int navNew) {\r\n        return derivativeStorage._calcNAV();\r\n    }\r\n\r\n    // Returns the expected value of each the outstanding tokens of the contract using the latest available Price Feed\r\n    // price.\r\n    function calcTokenValue() external view returns (int newTokenValue) {\r\n        return derivativeStorage._calcTokenValue();\r\n    }\r\n\r\n    // Returns the expected balance of the short margin account using the latest available Price Feed price.\r\n    function calcShortMarginBalance() external view returns (int newShortMarginBalance) {\r\n        return derivativeStorage._calcShortMarginBalance();\r\n    }\r\n\r\n    // Returns the expected short margin in excess of the margin requirement using the latest available Price Feed\r\n    // price.  Value will be negative if the short margin is expected to be below the margin requirement.\r\n    function calcExcessMargin() external view returns (int excessMargin) {\r\n        return derivativeStorage._calcExcessMargin();\r\n    }\r\n\r\n    // Returns the required margin, as of the last remargin. Note that `calcExcessMargin` uses updated values using the\r\n    // latest available Price Feed price.\r\n    function getCurrentRequiredMargin() external view returns (int requiredMargin) {\r\n        return derivativeStorage._getCurrentRequiredMargin();\r\n    }\r\n\r\n    // Returns whether the contract can be settled, i.e., is it valid to call settle() now.\r\n    function canBeSettled() external view returns (bool canContractBeSettled) {\r\n        return derivativeStorage._canBeSettled();\r\n    }\r\n\r\n    // Returns the updated underlying price that was used in the calc* methods above. It will be a price feed price if\r\n    // the contract is Live and will remain Live, or an Oracle price if the contract is settled/about to be settled.\r\n    // Reverts if no Oracle price is available but an Oracle price is required.\r\n    function getUpdatedUnderlyingPrice() external view returns (int underlyingPrice, uint time) {\r\n        return derivativeStorage._getUpdatedUnderlyingPrice();\r\n    }\r\n\r\n    // When an Oracle price becomes available, performs a final remargin, assesses any penalties, and moves the contract\r\n    // into the `Settled` state.\r\n    function settle() external {\r\n        derivativeStorage._settle();\r\n    }\r\n\r\n    // Adds the margin sent along with the call (or in the case of an ERC20 margin currency, authorized before the call)\r\n    // to the short account.\r\n    function deposit(uint amountToDeposit) external payable {\r\n        derivativeStorage._deposit(amountToDeposit);\r\n    }\r\n\r\n    // Allows the sponsor to withdraw any ERC20 balance that is not the margin token.\r\n    function withdrawUnexpectedErc20(address erc20Address, uint amount) external {\r\n        derivativeStorage._withdrawUnexpectedErc20(erc20Address, amount);\r\n    }\r\n\r\n    // ExpandedIERC20 methods.\r\n    modifier onlyThis {\r\n        require(msg.sender == address(this));\r\n        _;\r\n    }\r\n\r\n    // Only allow calls from this contract or its libraries to burn tokens.\r\n    function burn(uint value) external onlyThis {\r\n        // Only allow calls from this contract or its libraries to burn tokens.\r\n        _burn(msg.sender, value);\r\n    }\r\n\r\n    // Only allow calls from this contract or its libraries to mint tokens.\r\n    function mint(address to, uint256 value) external onlyThis {\r\n        _mint(to, value);\r\n    }\r\n\r\n    // These events are actually emitted by TokenizedDerivativeUtils, but we unfortunately have to define the events\r\n    // here as well.\r\n    event NavUpdated(string symbol, int newNav, int newTokenPrice);\r\n    event Default(string symbol, uint defaultTime, int defaultNav);\r\n    event Settled(string symbol, uint settleTime, int finalNav);\r\n    event Expired(string symbol, uint expiryTime);\r\n    event Disputed(string symbol, uint timeDisputed, int navDisputed);\r\n    event EmergencyShutdownTransition(string symbol, uint shutdownTime);\r\n    event TokensCreated(string symbol, uint numTokensCreated);\r\n    event TokensRedeemed(string symbol, uint numTokensRedeemed);\r\n    event Deposited(string symbol, uint amount);\r\n    event Withdrawal(string symbol, uint amount);\r\n}\r\n\r\ncontract TokenizedDerivativeCreator is ContractCreator, Testable {\r\n    struct Params {\r\n        uint defaultPenalty; // Percentage of mergin requirement * 10^18\r\n        uint supportedMove; // Expected percentage move in the underlying that the long is protected against.\r\n        bytes32 product;\r\n        uint fixedYearlyFee; // Percentage of nav * 10^18\r\n        uint disputeDeposit; // Percentage of mergin requirement * 10^18\r\n        address returnCalculator;\r\n        uint startingTokenPrice;\r\n        uint expiry;\r\n        address marginCurrency;\r\n        uint withdrawLimit; // Percentage of shortBalance * 10^18\r\n        TokenizedDerivativeParams.ReturnType returnType;\r\n        uint startingUnderlyingPrice;\r\n        string name;\r\n        string symbol;\r\n    }\r\n\r\n    AddressWhitelist public sponsorWhitelist;\r\n    AddressWhitelist public returnCalculatorWhitelist;\r\n    AddressWhitelist public marginCurrencyWhitelist;\r\n\r\n    constructor(\r\n        address registryAddress,\r\n        address _oracleAddress,\r\n        address _storeAddress,\r\n        address _priceFeedAddress,\r\n        address _sponsorWhitelist,\r\n        address _returnCalculatorWhitelist,\r\n        address _marginCurrencyWhitelist,\r\n        bool _isTest\r\n    )\r\n        public\r\n        ContractCreator(registryAddress, _oracleAddress, _storeAddress, _priceFeedAddress)\r\n        Testable(_isTest)\r\n    {\r\n        sponsorWhitelist = AddressWhitelist(_sponsorWhitelist);\r\n        returnCalculatorWhitelist = AddressWhitelist(_returnCalculatorWhitelist);\r\n        marginCurrencyWhitelist = AddressWhitelist(_marginCurrencyWhitelist);\r\n    }\r\n\r\n    function createTokenizedDerivative(Params memory params)\r\n        public\r\n        returns (address derivativeAddress)\r\n    {\r\n        TokenizedDerivative derivative = new TokenizedDerivative(_convertParams(params), params.name, params.symbol);\r\n\r\n        address[] memory parties = new address[](1);\r\n        parties[0] = msg.sender;\r\n\r\n        _registerContract(parties, address(derivative));\r\n\r\n        return address(derivative);\r\n    }\r\n\r\n    // Converts createTokenizedDerivative params to TokenizedDerivative constructor params.\r\n    function _convertParams(Params memory params)\r\n        private\r\n        view\r\n        returns (TokenizedDerivativeParams.ConstructorParams memory constructorParams)\r\n    {\r\n        // Copy and verify externally provided variables.\r\n        require(sponsorWhitelist.isOnWhitelist(msg.sender));\r\n        constructorParams.sponsor = msg.sender;\r\n\r\n        require(returnCalculatorWhitelist.isOnWhitelist(params.returnCalculator));\r\n        constructorParams.returnCalculator = params.returnCalculator;\r\n\r\n        require(marginCurrencyWhitelist.isOnWhitelist(params.marginCurrency));\r\n        constructorParams.marginCurrency = params.marginCurrency;\r\n\r\n        constructorParams.defaultPenalty = params.defaultPenalty;\r\n        constructorParams.supportedMove = params.supportedMove;\r\n        constructorParams.product = params.product;\r\n        constructorParams.fixedYearlyFee = params.fixedYearlyFee;\r\n        constructorParams.disputeDeposit = params.disputeDeposit;\r\n        constructorParams.startingTokenPrice = params.startingTokenPrice;\r\n        constructorParams.expiry = params.expiry;\r\n        constructorParams.withdrawLimit = params.withdrawLimit;\r\n        constructorParams.returnType = params.returnType;\r\n        constructorParams.startingUnderlyingPrice = params.startingUnderlyingPrice;\r\n\r\n        // Copy internal variables.\r\n        constructorParams.priceFeed = priceFeedAddress;\r\n        constructorParams.oracle = oracleAddress;\r\n        constructorParams.store = storeAddress;\r\n        constructorParams.admin = oracleAddress;\r\n        constructorParams.creationTime = getCurrentTime();\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_time\",\"type\":\"uint256\"}],\"name\":\"setCurrentTime\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCurrentTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"marginCurrencyWhitelist\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isTest\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"returnCalculatorWhitelist\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"erc20Address\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawErc20\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"components\":[{\"name\":\"defaultPenalty\",\"type\":\"uint256\"},{\"name\":\"supportedMove\",\"type\":\"uint256\"},{\"name\":\"product\",\"type\":\"bytes32\"},{\"name\":\"fixedYearlyFee\",\"type\":\"uint256\"},{\"name\":\"disputeDeposit\",\"type\":\"uint256\"},{\"name\":\"returnCalculator\",\"type\":\"address\"},{\"name\":\"startingTokenPrice\",\"type\":\"uint256\"},{\"name\":\"expiry\",\"type\":\"uint256\"},{\"name\":\"marginCurrency\",\"type\":\"address\"},{\"name\":\"withdrawLimit\",\"type\":\"uint256\"},{\"name\":\"returnType\",\"type\":\"uint8\"},{\"name\":\"startingUnderlyingPrice\",\"type\":\"uint256\"},{\"name\":\"name\",\"type\":\"string\"},{\"name\":\"symbol\",\"type\":\"string\"}],\"name\":\"params\",\"type\":\"tuple\"}],\"name\":\"createTokenizedDerivative\",\"outputs\":[{\"name\":\"derivativeAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"sponsorWhitelist\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"registryAddress\",\"type\":\"address\"},{\"name\":\"_oracleAddress\",\"type\":\"address\"},{\"name\":\"_storeAddress\",\"type\":\"address\"},{\"name\":\"_priceFeedAddress\",\"type\":\"address\"},{\"name\":\"_sponsorWhitelist\",\"type\":\"address\"},{\"name\":\"_returnCalculatorWhitelist\",\"type\":\"address\"},{\"name\":\"_marginCurrencyWhitelist\",\"type\":\"address\"},{\"name\":\"_isTest\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"TokenizedDerivativeCreator","CompilerVersion":"v0.5.0+commit.1d4f565a","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"00000000000000000000000061c35bc16f947c1e8829f4d1a19806c8099083e5000000000000000000000000d5bd3da7228bfa951eccf86af1d1bfd9fe0ff31b000000000000000000000000eeeaf812a14729988bbd8397df5e7b258fb56838000000000000000000000000eefa2052ffa4213df66b0631796dc9acf0165b1d0000000000000000000000008881093aaa054a6e0ff1b577005d66faab45127900000000000000000000000040cd9b81959d27ef82ef1cca9fed91db6a9257e6000000000000000000000000d51b412532ac2276368e79059048bc559f9912ef0000000000000000000000000000000000000000000000000000000000000000","Library":"LeveragedReturnCalculator:628e89Bf678e0Bf804469e8339F9f1b9Fb8061d7;TokenizedDerivativeUtils:0C2fD45d89fb9693B0130F8A66bE67827c278Ba7","SwarmSource":"bzzr://429a6a38fa3e77929e29867828bddb133cf11a34574eb04b75b4f78899ba1762"}]}