{"status":"1","message":"OK","result":[{"SourceCode":"// File: contracts/lib/ownership/Ownable.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\ncontract Ownable {\r\n    address public owner;\r\n    event OwnershipTransferred(address indexed previousOwner,address indexed newOwner);\r\n\r\n    /// @dev The Ownable constructor sets the original `owner` of the contract to the sender account.\r\n    constructor() public { owner = msg.sender; }\r\n\r\n    /// @dev Throws if called by any contract other than latest designated caller\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    /// @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n    /// @param newOwner The address to transfer ownership to.\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        require(newOwner != address(0));\r\n        emit OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n}\r\n\r\n// File: contracts/lib/token/FactoryTokenInterface.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\ncontract FactoryTokenInterface is Ownable {\r\n    function balanceOf(address _owner) public view returns (uint256);\r\n    function transfer(address _to, uint256 _value) public returns (bool);\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool);\r\n    function approve(address _spender, uint256 _value) public returns (bool);\r\n    function allowance(address _owner, address _spender) public view returns (uint256);\r\n    function mint(address _to, uint256 _amount) public returns (bool);\r\n    function burnFrom(address _from, uint256 _value) public;\r\n}\r\n\r\n// File: contracts/lib/token/TokenFactoryInterface.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\ncontract TokenFactoryInterface {\r\n    function create(string _name, string _symbol) public returns (FactoryTokenInterface);\r\n}\r\n\r\n// File: contracts/lib/ownership/ZapCoordinatorInterface.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\ncontract ZapCoordinatorInterface is Ownable {\r\n    function addImmutableContract(string contractName, address newAddress) external;\r\n    function updateContract(string contractName, address newAddress) external;\r\n    function getContractName(uint index) public view returns (string);\r\n    function getContract(string contractName) public view returns (address);\r\n    function updateAllDependencies() external;\r\n}\r\n\r\n// File: contracts/platform/bondage/BondageInterface.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\ncontract BondageInterface {\r\n    function bond(address, bytes32, uint256) external returns(uint256);\r\n    function unbond(address, bytes32, uint256) external returns (uint256);\r\n    function delegateBond(address, address, bytes32, uint256) external returns(uint256);\r\n    function escrowDots(address, address, bytes32, uint256) external returns (bool);\r\n    function releaseDots(address, address, bytes32, uint256) external returns (bool);\r\n    function returnDots(address, address, bytes32, uint256) external returns (bool success);\r\n    function calcZapForDots(address, bytes32, uint256) external view returns (uint256);\r\n    function currentCostOfDot(address, bytes32, uint256) public view returns (uint256);\r\n    function getDotsIssued(address, bytes32) public view returns (uint256);\r\n    function getBoundDots(address, address, bytes32) public view returns (uint256);\r\n    function getZapBound(address, bytes32) public view returns (uint256);\r\n    function dotLimit( address, bytes32) public view returns (uint256);\r\n}\r\n\r\n// File: contracts/platform/bondage/currentCost/CurrentCostInterface.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\ncontract CurrentCostInterface {\r\n    function _currentCostOfDot(address, bytes32, uint256) public view returns (uint256);\r\n    function _dotLimit(address, bytes32) public view returns (uint256);\r\n    function _costOfNDots(address, bytes32, uint256, uint256) public view returns (uint256);\r\n}\r\n\r\n// File: contracts/platform/registry/RegistryInterface.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\ncontract RegistryInterface {\r\n    function initiateProvider(uint256, bytes32) public returns (bool);\r\n    function initiateProviderCurve(bytes32, int256[], address) public returns (bool);\r\n    function setEndpointParams(bytes32, bytes32[]) public;\r\n    function getEndpointParams(address, bytes32) public view returns (bytes32[]);\r\n    function getProviderPublicKey(address) public view returns (uint256);\r\n    function getProviderTitle(address) public view returns (bytes32);\r\n    function setProviderParameter(bytes32, bytes) public;\r\n    function setProviderTitle(bytes32) public;\r\n    function clearEndpoint(bytes32) public;\r\n    function getProviderParameter(address, bytes32) public view returns (bytes);\r\n    function getAllProviderParams(address) public view returns (bytes32[]);\r\n    function getProviderCurveLength(address, bytes32) public view returns (uint256);\r\n    function getProviderCurve(address, bytes32) public view returns (int[]);\r\n    function isProviderInitiated(address) public view returns (bool);\r\n    function getAllOracles() external view returns (address[]);\r\n    function getProviderEndpoints(address) public view returns (bytes32[]);\r\n    function getEndpointBroker(address, bytes32) public view returns (address);\r\n}\r\n\r\n// File: contracts/lib/platform/SampleContest.sol\r\n\r\n/*\r\nContest where users can bond to contestant curves which mint tokens( unbondabe*), \r\nwinner decided by oracle\r\ncontract unbonds from loser curves\r\nholders of winning token allowed to take share of reserve token(zap) which was unbonded from loser curves\r\n\r\nStarting Contest:\r\n    \r\n    deploys with contest uninitialized: status = Uninitialized\r\n    \r\n    anyone can initialize new token:backed curve \r\n    \r\n    owner initializes contest with oracle: status = Initialized\r\n\r\nEnding Contest:\r\n    \r\n    owner calls close: status = ReadyToSettle\r\n    \r\n    oracle calls judge to set winning curve: status = Judged\r\n    \r\n    anyone calls settle, contest unbonds from losing curves: status = Settled\r\n    \r\n    holders of winnning token call redeem to retrieve their share of reserve token \r\n    based on their holding of winning token\r\n    \r\n    *holders of winning token can optionally unbond \r\n*/\r\n\r\ncontract SampleContest is Ownable {\r\n\r\n    CurrentCostInterface currentCost;\r\n    FactoryTokenInterface public reserveToken;\r\n    ZapCoordinatorInterface public coord;\r\n    TokenFactoryInterface public tokenFactory;\r\n    BondageInterface bondage;\r\n\r\n    enum ContestStatus { \r\n        Uninitialized,    //  \r\n        Initialized,      // ready for buys\r\n        ReadyToSettle,    // ready for judgement \r\n        Judged,           // winner determined \r\n        Settled           // value of winning tokens determined \r\n    }\r\n\r\n    address public oracle;    // address of oracle who will choose the winner\r\n    bytes32 public winner;    // curve identifier of the winner \r\n    uint256 public winValue;  // final value of the winning token\r\n    ContestStatus public status; //state of contest\r\n\r\n    mapping(bytes32 => address) public curves; // map of endpoint specifier to token-backed dotaddress\r\n    bytes32[] public curves_list; // array of endpoint specifiers\r\n\r\n    mapping(address => uint8) public redeemed; // map of address redemption state\r\n    address[] public redeemed_list;\r\n    \r\n    event DotTokenCreated(address tokenAddress);\r\n    event Bonded(bytes32 indexed endpoint, uint256 indexed numDots, address indexed sender); \r\n    event Unbonded(bytes32 indexed endpoint, uint256 indexed numDots, address indexed sender);\r\n\r\n    event Initialized(address indexed oracle);\r\n    event Closed();\r\n    event Judged(bytes32 winner);\r\n    event Settled(uint256 winValue, uint256 winTokens); \r\n    event Reset();\r\n\r\n    constructor(\r\n        address coordinator, \r\n        address factory,\r\n        uint256 providerPubKey,\r\n        bytes32 providerTitle \r\n    ){\r\n        coord = ZapCoordinatorInterface(coordinator); \r\n        reserveToken = FactoryTokenInterface(coord.getContract(\"ZAP_TOKEN\"));\r\n        //always allow bondage to transfer from wallet\r\n        reserveToken.approve(coord.getContract(\"BONDAGE\"), ~uint256(0));\r\n        tokenFactory = TokenFactoryInterface(factory);\r\n\r\n        RegistryInterface registry = RegistryInterface(coord.getContract(\"REGISTRY\")); \r\n        registry.initiateProvider(providerPubKey, providerTitle);\r\n        status = ContestStatus.Uninitialized;\r\n    }\r\n\r\n// contest lifecycle\r\n \r\n    function initializeContest(\r\n        address oracleAddress\r\n    ) onlyOwner public {\r\n        require( status == ContestStatus.Uninitialized, \"Contest already initialized\");\r\n        oracle = oracleAddress;\r\n        status = ContestStatus.Initialized;\r\n        emit Initialized(oracle);\r\n    }\r\n\r\n    function close() onlyOwner {\r\n        status = ContestStatus.ReadyToSettle; \r\n        emit Closed();\r\n    }\r\n\r\n    function judge(bytes32 endpoint) {\r\n        require( status == ContestStatus.ReadyToSettle, \"not closed\" );\r\n        require( msg.sender == oracle, \"not oracle\");\r\n        winner = endpoint;\r\n        status = ContestStatus.Judged;\r\n        emit Judged(winner);\r\n    }\r\n\r\n    function settle() {\r\n        require( status == ContestStatus.Judged, \"winner not determined\");\r\n\r\n        bondage = BondageInterface(coord.getContract(\"BONDAGE\"));\r\n        uint256 dots;\r\n        for( uint256 i = 0; i < curves_list.length; i++) {\r\n\r\n            if(curves_list[i] != winner) {\r\n                dots =  bondage.getDotsIssued(address(this), curves_list[i]);  \r\n                if( dots > 0) {\r\n                    bondage.unbond(address(this), curves_list[i], dots);                 \r\n                }  \r\n            }\r\n        } \r\n\r\n        // how many winning dots    \r\n        uint256 numWin =  bondage.getDotsIssued(address(this), winner);  \r\n        // redeemable value of each dot token\r\n        winValue = reserveToken.balanceOf(address(this)) / numWin;\r\n        status = ContestStatus.Settled;\r\n        emit Settled(winValue, numWin);\r\n    }\r\n\r\n\r\n    //TODO ensure all has been redeemed or enough time has elasped \r\n    function reset() public {\r\n        require(status == ContestStatus.Settled, \"contest not settled\");\r\n        require(msg.sender == oracle);\r\n        \r\n        delete redeemed_list;\r\n        delete curves_list;\r\n        status = ContestStatus.Initialized; \r\n        emit Reset();\r\n    }\r\n\r\n/// TokenDotFactory methods\r\n\r\n    function initializeCurve(\r\n        bytes32 endpoint, \r\n        bytes32 symbol, \r\n        int256[] curve\r\n    ) public returns(address) {\r\n        \r\n        require(curves[endpoint] == 0, \"Curve endpoint already exists or used in the past. Please choose new\");\r\n        \r\n        RegistryInterface registry = RegistryInterface(coord.getContract(\"REGISTRY\")); \r\n        require(registry.isProviderInitiated(address(this)), \"Provider not intiialized\");\r\n\r\n        registry.initiateProviderCurve(endpoint, curve, address(this));\r\n        curves[endpoint] = newToken(bytes32ToString(endpoint), bytes32ToString(symbol));\r\n        curves_list.push(endpoint);        \r\n        registry.setProviderParameter(endpoint, toBytes(curves[endpoint]));\r\n        \r\n        DotTokenCreated(curves[endpoint]);\r\n        return curves[endpoint];\r\n    }\r\n\r\n    //whether this contract holds tokens or coming from msg.sender,etc\r\n    function bond(bytes32 endpoint, uint numDots) public  {\r\n\r\n        require( status == ContestStatus.Initialized, \" contest not live\"); \r\n\r\n        bondage = BondageInterface(coord.getContract(\"BONDAGE\"));\r\n        uint256 issued = bondage.getDotsIssued(address(this), endpoint);\r\n\r\n        CurrentCostInterface cost = CurrentCostInterface(coord.getContract(\"CURRENT_COST\"));\r\n        uint256 numReserve = cost._costOfNDots(address(this), endpoint, issued + 1, numDots - 1);\r\n\r\n        require(\r\n            reserveToken.transferFrom(msg.sender, address(this), numReserve),\r\n            \"insufficient accepted token numDots approved for transfer\"\r\n        );\r\n\r\n        reserveToken.approve(address(bondage), numReserve);\r\n        bondage.bond(address(this), endpoint, numDots);\r\n        FactoryTokenInterface(curves[endpoint]).mint(msg.sender, numDots);\r\n        emit Bonded(endpoint, numDots, msg.sender);\r\n    }\r\n\r\n    //whether this contract holds tokens or coming from msg.sender,etc\r\n    function unbond(bytes32 endpoint, uint numDots) public {\r\n\r\n        require( status == ContestStatus.Settled, \" contest not settled\"); \r\n        require(redeemed[msg.sender] == 0, \"already redeeemed\");\r\n        require(winner==endpoint, \"only winners can unbond\"); \r\n\r\n        bondage = BondageInterface(coord.getContract(\"BONDAGE\"));\r\n        uint issued = bondage.getDotsIssued(address(this), winner);\r\n\r\n        currentCost = CurrentCostInterface(coord.getContract(\"CURRENT_COST\"));\r\n        uint reserveCost = currentCost._costOfNDots(address(this), winner, issued + 1 - numDots, numDots - 1);\r\n        //unbond dots\r\n        bondage.unbond(address(this), winner, numDots);\r\n\r\n        //burn dot backed token\r\n        FactoryTokenInterface curveToken = FactoryTokenInterface(curves[winner]);\r\n\r\n        uint reward = winValue * FactoryTokenInterface(getTokenAddress(winner)).balanceOf(msg.sender);\r\n        \r\n        //burn user's unbonded tokens\r\n        curveToken.burnFrom(msg.sender, numDots);\r\n\r\n        reserveToken.transfer(msg.sender, reward);\r\n        redeemed[msg.sender] = 1;\r\n\r\n        emit Unbonded(winner, numDots, msg.sender);\r\n    }\r\n\r\n    function newToken(\r\n        string name,\r\n        string symbol\r\n    ) \r\n        public\r\n        returns (address tokenAddress) \r\n    {\r\n        FactoryTokenInterface token = tokenFactory.create(name, symbol);\r\n        tokenAddress = address(token);\r\n        return tokenAddress;\r\n    }\r\n\r\n    function getTokenAddress(bytes32 endpoint) public view returns(address) {\r\n        RegistryInterface registry = RegistryInterface(coord.getContract(\"REGISTRY\")); \r\n        return bytesToAddr(registry.getProviderParameter(address(this), endpoint));\r\n    }\r\n\r\n    // https://ethereum.stackexchange.com/questions/884/how-to-convert-an-address-to-bytes-in-solidity\r\n    function toBytes(address x) public pure returns (bytes b) {\r\n        b = new bytes(20);\r\n        for (uint i = 0; i < 20; i++)\r\n            b[i] = byte(uint8(uint(x) / (2**(8*(19 - i)))));\r\n    }\r\n\r\n    //https://ethereum.stackexchange.com/questions/2519/how-to-convert-a-bytes32-to-string\r\n    function bytes32ToString(bytes32 x) public pure returns (string) {\r\n        bytes memory bytesString = new bytes(32);\r\n        bytesString = abi.encodePacked(x);\r\n        return string(bytesString);\r\n    }\r\n\r\n    //https://ethereum.stackexchange.com/questions/15350/how-to-convert-an-bytes-to-address-in-solidity\r\n    function bytesToAddr (bytes b) public pure returns (address) {\r\n        uint result = 0;\r\n        for (uint i = b.length-1; i+1 > 0; i--) {\r\n            uint c = uint(b[i]);\r\n            uint to_inc = c * ( 16 ** ((b.length - i-1) * 2));\r\n            result += to_inc;\r\n        }\r\n        return address(result);\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"endpoint\",\"type\":\"bytes32\"},{\"name\":\"symbol\",\"type\":\"bytes32\"},{\"name\":\"curve\",\"type\":\"int256[]\"}],\"name\":\"initializeCurve\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"settle\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"status\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"close\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"name\",\"type\":\"string\"},{\"name\":\"symbol\",\"type\":\"string\"}],\"name\":\"newToken\",\"outputs\":[{\"name\":\"tokenAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"endpoint\",\"type\":\"bytes32\"},{\"name\":\"numDots\",\"type\":\"uint256\"}],\"name\":\"unbond\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"endpoint\",\"type\":\"bytes32\"},{\"name\":\"numDots\",\"type\":\"uint256\"}],\"name\":\"bond\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"x\",\"type\":\"address\"}],\"name\":\"toBytes\",\"outputs\":[{\"name\":\"b\",\"type\":\"bytes\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"b\",\"type\":\"bytes\"}],\"name\":\"bytesToAddr\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"curves\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"oracleAddress\",\"type\":\"address\"}],\"name\":\"initializeContest\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"oracle\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"x\",\"type\":\"bytes32\"}],\"name\":\"bytes32ToString\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"coord\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"redeemed\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"endpoint\",\"type\":\"bytes32\"}],\"name\":\"getTokenAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"winValue\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"reset\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"winner\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"endpoint\",\"type\":\"bytes32\"}],\"name\":\"judge\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenFactory\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"curves_list\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"reserveToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"redeemed_list\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"coordinator\",\"type\":\"address\"},{\"name\":\"factory\",\"type\":\"address\"},{\"name\":\"providerPubKey\",\"type\":\"uint256\"},{\"name\":\"providerTitle\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"tokenAddress\",\"type\":\"address\"}],\"name\":\"DotTokenCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"endpoint\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"numDots\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"Bonded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"endpoint\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"numDots\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"Unbonded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"oracle\",\"type\":\"address\"}],\"name\":\"Initialized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Closed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"winner\",\"type\":\"bytes32\"}],\"name\":\"Judged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"winValue\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"winTokens\",\"type\":\"uint256\"}],\"name\":\"Settled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Reset\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"SampleContest","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000b007eca49763f31edff95623ed6c23c8c1924a16000000000000000000000000e13fef4c8e75c12f9706e8bdf28fe847ce99cb42000000000000000000000000000000000000000000000000000000000000000055506f72446f776e000000000000000000000000000000000000000000000000","Library":"","SwarmSource":"bzzr://c138ffc976688dc7da9b7c8b27cbf309a7c6ae8bed5468ff8dc6257e63d09b8d"}]}