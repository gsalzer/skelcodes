{"status":"1","message":"OK","result":[{"SourceCode":"// File: openzeppelin-solidity/contracts/token/ERC20/IERC20.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ninterface IERC20 {\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n\r\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address who) external view returns (uint256);\r\n\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/math/SafeMath.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Unsigned math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n    * @dev Multiplies two unsigned integers, reverts on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two unsigned integers, reverts on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\r\n    * reverts when dividing by zero.\r\n    */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC20/ERC20.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n\r\n/**\r\n * @title Standard ERC20 token\r\n *\r\n * @dev Implementation of the basic standard token.\r\n * https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md\r\n * Originally based on code by FirstBlood:\r\n * https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\r\n *\r\n * This implementation emits additional Approval events, allowing applications to reconstruct the allowance status for\r\n * all accounts just by listening to said events. Note that this isn't required by the specification, and other\r\n * compliant implementations may not do it.\r\n */\r\ncontract ERC20 is IERC20 {\r\n    using SafeMath for uint256;\r\n\r\n    mapping (address => uint256) private _balances;\r\n\r\n    mapping (address => mapping (address => uint256)) private _allowed;\r\n\r\n    uint256 private _totalSupply;\r\n\r\n    /**\r\n    * @dev Total number of tokens in existence\r\n    */\r\n    function totalSupply() public view returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    /**\r\n    * @dev Gets the balance of the specified address.\r\n    * @param owner The address to query the balance of.\r\n    * @return An uint256 representing the amount owned by the passed address.\r\n    */\r\n    function balanceOf(address owner) public view returns (uint256) {\r\n        return _balances[owner];\r\n    }\r\n\r\n    /**\r\n     * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n     * @param owner address The address which owns the funds.\r\n     * @param spender address The address which will spend the funds.\r\n     * @return A uint256 specifying the amount of tokens still available for the spender.\r\n     */\r\n    function allowance(address owner, address spender) public view returns (uint256) {\r\n        return _allowed[owner][spender];\r\n    }\r\n\r\n    /**\r\n    * @dev Transfer token for a specified address\r\n    * @param to The address to transfer to.\r\n    * @param value The amount to be transferred.\r\n    */\r\n    function transfer(address to, uint256 value) public returns (bool) {\r\n        _transfer(msg.sender, to, value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n     * Beware that changing an allowance with this method brings the risk that someone may use both the old\r\n     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\r\n     * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     * @param spender The address which will spend the funds.\r\n     * @param value The amount of tokens to be spent.\r\n     */\r\n    function approve(address spender, uint256 value) public returns (bool) {\r\n        require(spender != address(0));\r\n\r\n        _allowed[msg.sender][spender] = value;\r\n        emit Approval(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Transfer tokens from one address to another.\r\n     * Note that while this function emits an Approval event, this is not required as per the specification,\r\n     * and other compliant implementations may not emit the event.\r\n     * @param from address The address which you want to send tokens from\r\n     * @param to address The address which you want to transfer to\r\n     * @param value uint256 the amount of tokens to be transferred\r\n     */\r\n    function transferFrom(address from, address to, uint256 value) public returns (bool) {\r\n        _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);\r\n        _transfer(from, to, value);\r\n        emit Approval(from, msg.sender, _allowed[from][msg.sender]);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Increase the amount of tokens that an owner allowed to a spender.\r\n     * approve should be called when allowed_[_spender] == 0. To increment\r\n     * allowed value is better to use this function to avoid 2 calls (and wait until\r\n     * the first transaction is mined)\r\n     * From MonolithDAO Token.sol\r\n     * Emits an Approval event.\r\n     * @param spender The address which will spend the funds.\r\n     * @param addedValue The amount of tokens to increase the allowance by.\r\n     */\r\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\r\n        require(spender != address(0));\r\n\r\n        _allowed[msg.sender][spender] = _allowed[msg.sender][spender].add(addedValue);\r\n        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Decrease the amount of tokens that an owner allowed to a spender.\r\n     * approve should be called when allowed_[_spender] == 0. To decrement\r\n     * allowed value is better to use this function to avoid 2 calls (and wait until\r\n     * the first transaction is mined)\r\n     * From MonolithDAO Token.sol\r\n     * Emits an Approval event.\r\n     * @param spender The address which will spend the funds.\r\n     * @param subtractedValue The amount of tokens to decrease the allowance by.\r\n     */\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\r\n        require(spender != address(0));\r\n\r\n        _allowed[msg.sender][spender] = _allowed[msg.sender][spender].sub(subtractedValue);\r\n        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev Transfer token for a specified addresses\r\n    * @param from The address to transfer from.\r\n    * @param to The address to transfer to.\r\n    * @param value The amount to be transferred.\r\n    */\r\n    function _transfer(address from, address to, uint256 value) internal {\r\n        require(to != address(0));\r\n\r\n        _balances[from] = _balances[from].sub(value);\r\n        _balances[to] = _balances[to].add(value);\r\n        emit Transfer(from, to, value);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function that mints an amount of the token and assigns it to\r\n     * an account. This encapsulates the modification of balances such that the\r\n     * proper events are emitted.\r\n     * @param account The account that will receive the created tokens.\r\n     * @param value The amount that will be created.\r\n     */\r\n    function _mint(address account, uint256 value) internal {\r\n        require(account != address(0));\r\n\r\n        _totalSupply = _totalSupply.add(value);\r\n        _balances[account] = _balances[account].add(value);\r\n        emit Transfer(address(0), account, value);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function that burns an amount of the token of a given\r\n     * account.\r\n     * @param account The account whose tokens will be burnt.\r\n     * @param value The amount that will be burnt.\r\n     */\r\n    function _burn(address account, uint256 value) internal {\r\n        require(account != address(0));\r\n\r\n        _totalSupply = _totalSupply.sub(value);\r\n        _balances[account] = _balances[account].sub(value);\r\n        emit Transfer(account, address(0), value);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function that burns an amount of the token of a given\r\n     * account, deducting from the sender's allowance for said account. Uses the\r\n     * internal burn function.\r\n     * Emits an Approval event (reflecting the reduced allowance).\r\n     * @param account The account whose tokens will be burnt.\r\n     * @param value The amount that will be burnt.\r\n     */\r\n    function _burnFrom(address account, uint256 value) internal {\r\n        _allowed[account][msg.sender] = _allowed[account][msg.sender].sub(value);\r\n        _burn(account, value);\r\n        emit Approval(account, msg.sender, _allowed[account][msg.sender]);\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n     * account.\r\n     */\r\n    constructor () internal {\r\n        _owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), _owner);\r\n    }\r\n\r\n    /**\r\n     * @return the address of the owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner());\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @return true if `msg.sender` is the owner of the contract.\r\n     */\r\n    function isOwner() public view returns (bool) {\r\n        return msg.sender == _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to relinquish control of the contract.\r\n     * @notice Renouncing to ownership will leave the contract without an owner.\r\n     * It will not be possible to call the functions with the `onlyOwner`\r\n     * modifier anymore.\r\n     */\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0));\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\n// File: @gnosis.pm/mock-contract/contracts/MockContract.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\ninterface MockInterface {\r\n\t/**\r\n\t * @dev After calling this method, the mock will return `response` when it is called\r\n\t * with any calldata that is not mocked more specifically below\r\n\t * (e.g. using givenMethodReturn).\r\n\t * @param response ABI encoded response that will be returned if method is invoked\r\n\t */\r\n\tfunction givenAnyReturn(bytes calldata response) external;\r\n\tfunction givenAnyReturnBool(bool response) external;\r\n\tfunction givenAnyReturnUint(uint response) external;\r\n\tfunction givenAnyReturnAddress(address response) external;\r\n\r\n\tfunction givenAnyRevert() external;\r\n\tfunction givenAnyRevertWithMessage(string calldata message) external;\r\n\tfunction givenAnyRunOutOfGas() external;\r\n\r\n\t/**\r\n\t * @dev After calling this method, the mock will return `response` when the given\r\n\t * methodId is called regardless of arguments. If the methodId and arguments\r\n\t * are mocked more specifically (using `givenMethodAndArguments`) the latter\r\n\t * will take precedence.\r\n\t * @param method ABI encoded methodId. It is valid to pass full calldata (including arguments). The mock will extract the methodId from it\r\n\t * @param response ABI encoded response that will be returned if method is invoked\r\n\t */\r\n\tfunction givenMethodReturn(bytes calldata method, bytes calldata response) external;\r\n\tfunction givenMethodReturnBool(bytes calldata method, bool response) external;\r\n\tfunction givenMethodReturnUint(bytes calldata method, uint response) external;\r\n\tfunction givenMethodReturnAddress(bytes calldata method, address response) external;\r\n\r\n\tfunction givenMethodRevert(bytes calldata method) external;\r\n\tfunction givenMethodRevertWithMessage(bytes calldata method, string calldata message) external;\r\n\tfunction givenMethodRunOutOfGas(bytes calldata method) external;\r\n\r\n\t/**\r\n\t * @dev After calling this method, the mock will return `response` when the given\r\n\t * methodId is called with matching arguments. These exact calldataMocks will take\r\n\t * precedence over all other calldataMocks.\r\n\t * @param call ABI encoded calldata (methodId and arguments)\r\n\t * @param response ABI encoded response that will be returned if contract is invoked with calldata\r\n\t */\r\n\tfunction givenCalldataReturn(bytes calldata call, bytes calldata response) external;\r\n\tfunction givenCalldataReturnBool(bytes calldata call, bool response) external;\r\n\tfunction givenCalldataReturnUint(bytes calldata call, uint response) external;\r\n\tfunction givenCalldataReturnAddress(bytes calldata call, address response) external;\r\n\r\n\tfunction givenCalldataRevert(bytes calldata call) external;\r\n\tfunction givenCalldataRevertWithMessage(bytes calldata call, string calldata message) external;\r\n\tfunction givenCalldataRunOutOfGas(bytes calldata call) external;\r\n\r\n\t/**\r\n\t * @dev Returns the number of times anything has been called on this mock since last reset\r\n\t */\r\n\tfunction invocationCount() external returns (uint);\r\n\r\n\t/**\r\n\t * @dev Returns the number of times the given method has been called on this mock since last reset\r\n\t * @param method ABI encoded methodId. It is valid to pass full calldata (including arguments). The mock will extract the methodId from it\r\n\t */\r\n\tfunction invocationCountForMethod(bytes calldata method) external returns (uint);\r\n\r\n\t/**\r\n\t * @dev Returns the number of times this mock has been called with the exact calldata since last reset.\r\n\t * @param call ABI encoded calldata (methodId and arguments)\r\n\t */\r\n\tfunction invocationCountForCalldata(bytes calldata call) external returns (uint);\r\n\r\n\t/**\r\n\t * @dev Resets all mocked methods and invocation counts.\r\n\t */\r\n\t function reset() external;\r\n}\r\n\r\n/**\r\n * Implementation of the MockInterface.\r\n */\r\ncontract MockContract is MockInterface {\r\n\tenum MockType { Return, Revert, OutOfGas }\r\n\t\r\n\tbytes32 public constant MOCKS_LIST_START = hex\"01\";\r\n\tbytes public constant MOCKS_LIST_END = \"0xff\";\r\n\tbytes32 public constant MOCKS_LIST_END_HASH = keccak256(MOCKS_LIST_END);\r\n\tbytes4 public constant SENTINEL_ANY_MOCKS = hex\"01\";\r\n\r\n\t// A linked list allows easy iteration and inclusion checks\r\n\tmapping(bytes32 => bytes) calldataMocks;\r\n\tmapping(bytes => MockType) calldataMockTypes;\r\n\tmapping(bytes => bytes) calldataExpectations;\r\n\tmapping(bytes => string) calldataRevertMessage;\r\n\tmapping(bytes32 => uint) calldataInvocations;\r\n\r\n\tmapping(bytes4 => bytes4) methodIdMocks;\r\n\tmapping(bytes4 => MockType) methodIdMockTypes;\r\n\tmapping(bytes4 => bytes) methodIdExpectations;\r\n\tmapping(bytes4 => string) methodIdRevertMessages;\r\n\tmapping(bytes32 => uint) methodIdInvocations;\r\n\r\n\tMockType fallbackMockType;\r\n\tbytes fallbackExpectation;\r\n\tstring fallbackRevertMessage;\r\n\tuint invocations;\r\n\tuint resetCount;\r\n\r\n\tconstructor() public {\r\n\t\tcalldataMocks[MOCKS_LIST_START] = MOCKS_LIST_END;\r\n\t\tmethodIdMocks[SENTINEL_ANY_MOCKS] = SENTINEL_ANY_MOCKS;\r\n\t}\r\n\r\n\tfunction trackCalldataMock(bytes memory call) private {\r\n\t\tbytes32 callHash = keccak256(call);\r\n\t\tif (calldataMocks[callHash].length == 0) {\r\n\t\t\tcalldataMocks[callHash] = calldataMocks[MOCKS_LIST_START];\r\n\t\t\tcalldataMocks[MOCKS_LIST_START] = call;\r\n\t\t}\r\n\t}\r\n\r\n\tfunction trackMethodIdMock(bytes4 methodId) private {\r\n\t\tif (methodIdMocks[methodId] == 0x0) {\r\n\t\t\tmethodIdMocks[methodId] = methodIdMocks[SENTINEL_ANY_MOCKS];\r\n\t\t\tmethodIdMocks[SENTINEL_ANY_MOCKS] = methodId;\r\n\t\t}\r\n\t}\r\n\r\n\tfunction _givenAnyReturn(bytes memory response) internal {\r\n\t\tfallbackMockType = MockType.Return;\r\n\t\tfallbackExpectation = response;\r\n\t}\r\n\r\n\tfunction givenAnyReturn(bytes calldata response) external {\r\n\t\t_givenAnyReturn(response);\r\n\t}\r\n\r\n\tfunction givenAnyReturnBool(bool response) external {\r\n\t\tuint flag = response ? 1 : 0;\r\n\t\t_givenAnyReturn(uintToBytes(flag));\r\n\t}\r\n\r\n\tfunction givenAnyReturnUint(uint response) external {\r\n\t\t_givenAnyReturn(uintToBytes(response));\t\r\n\t}\r\n\r\n\tfunction givenAnyReturnAddress(address response) external {\r\n\t\t_givenAnyReturn(uintToBytes(uint(response)));\r\n\t}\r\n\r\n\tfunction givenAnyRevert() external {\r\n\t\tfallbackMockType = MockType.Revert;\r\n\t\tfallbackRevertMessage = \"\";\r\n\t}\r\n\r\n\tfunction givenAnyRevertWithMessage(string calldata message) external {\r\n\t\tfallbackMockType = MockType.Revert;\r\n\t\tfallbackRevertMessage = message;\r\n\t}\r\n\r\n\tfunction givenAnyRunOutOfGas() external {\r\n\t\tfallbackMockType = MockType.OutOfGas;\r\n\t}\r\n\r\n\tfunction _givenCalldataReturn(bytes memory call, bytes memory response) private  {\r\n\t\tcalldataMockTypes[call] = MockType.Return;\r\n\t\tcalldataExpectations[call] = response;\r\n\t\ttrackCalldataMock(call);\r\n\t}\r\n\r\n\tfunction givenCalldataReturn(bytes calldata call, bytes calldata response) external  {\r\n\t\t_givenCalldataReturn(call, response);\r\n\t}\r\n\r\n\tfunction givenCalldataReturnBool(bytes calldata call, bool response) external {\r\n\t\tuint flag = response ? 1 : 0;\r\n\t\t_givenCalldataReturn(call, uintToBytes(flag));\r\n\t}\r\n\r\n\tfunction givenCalldataReturnUint(bytes calldata call, uint response) external {\r\n\t\t_givenCalldataReturn(call, uintToBytes(response));\r\n\t}\r\n\r\n\tfunction givenCalldataReturnAddress(bytes calldata call, address response) external {\r\n\t\t_givenCalldataReturn(call, uintToBytes(uint(response)));\r\n\t}\r\n\r\n\tfunction _givenMethodReturn(bytes memory call, bytes memory response) private {\r\n\t\tbytes4 method = bytesToBytes4(call);\r\n\t\tmethodIdMockTypes[method] = MockType.Return;\r\n\t\tmethodIdExpectations[method] = response;\r\n\t\ttrackMethodIdMock(method);\t\t\r\n\t}\r\n\r\n\tfunction givenMethodReturn(bytes calldata call, bytes calldata response) external {\r\n\t\t_givenMethodReturn(call, response);\r\n\t}\r\n\r\n\tfunction givenMethodReturnBool(bytes calldata call, bool response) external {\r\n\t\tuint flag = response ? 1 : 0;\r\n\t\t_givenMethodReturn(call, uintToBytes(flag));\r\n\t}\r\n\r\n\tfunction givenMethodReturnUint(bytes calldata call, uint response) external {\r\n\t\t_givenMethodReturn(call, uintToBytes(response));\r\n\t}\r\n\r\n\tfunction givenMethodReturnAddress(bytes calldata call, address response) external {\r\n\t\t_givenMethodReturn(call, uintToBytes(uint(response)));\r\n\t}\r\n\r\n\tfunction givenCalldataRevert(bytes calldata call) external {\r\n\t\tcalldataMockTypes[call] = MockType.Revert;\r\n\t\tcalldataRevertMessage[call] = \"\";\r\n\t\ttrackCalldataMock(call);\r\n\t}\r\n\r\n\tfunction givenMethodRevert(bytes calldata call) external {\r\n\t\tbytes4 method = bytesToBytes4(call);\r\n\t\tmethodIdMockTypes[method] = MockType.Revert;\r\n\t\ttrackMethodIdMock(method);\t\t\r\n\t}\r\n\r\n\tfunction givenCalldataRevertWithMessage(bytes calldata call, string calldata message) external {\r\n\t\tcalldataMockTypes[call] = MockType.Revert;\r\n\t\tcalldataRevertMessage[call] = message;\r\n\t\ttrackCalldataMock(call);\r\n\t}\r\n\r\n\tfunction givenMethodRevertWithMessage(bytes calldata call, string calldata message) external {\r\n\t\tbytes4 method = bytesToBytes4(call);\r\n\t\tmethodIdMockTypes[method] = MockType.Revert;\r\n\t\tmethodIdRevertMessages[method] = message;\r\n\t\ttrackMethodIdMock(method);\t\t\r\n\t}\r\n\r\n\tfunction givenCalldataRunOutOfGas(bytes calldata call) external {\r\n\t\tcalldataMockTypes[call] = MockType.OutOfGas;\r\n\t\ttrackCalldataMock(call);\r\n\t}\r\n\r\n\tfunction givenMethodRunOutOfGas(bytes calldata call) external {\r\n\t\tbytes4 method = bytesToBytes4(call);\r\n\t\tmethodIdMockTypes[method] = MockType.OutOfGas;\r\n\t\ttrackMethodIdMock(method);\t\r\n\t}\r\n\r\n\tfunction invocationCount() external returns (uint) {\r\n\t\treturn invocations;\r\n\t}\r\n\r\n\tfunction invocationCountForMethod(bytes calldata call) external returns (uint) {\r\n\t\tbytes4 method = bytesToBytes4(call);\r\n\t\treturn methodIdInvocations[keccak256(abi.encodePacked(resetCount, method))];\r\n\t}\r\n\r\n\tfunction invocationCountForCalldata(bytes calldata call) external returns (uint) {\r\n\t\treturn calldataInvocations[keccak256(abi.encodePacked(resetCount, call))];\r\n\t}\r\n\r\n\tfunction reset() external {\r\n\t\t// Reset all exact calldataMocks\r\n\t\tbytes memory nextMock = calldataMocks[MOCKS_LIST_START];\r\n\t\tbytes32 mockHash = keccak256(nextMock);\r\n\t\t// We cannot compary bytes\r\n\t\twhile(mockHash != MOCKS_LIST_END_HASH) {\r\n\t\t\t// Reset all mock maps\r\n\t\t\tcalldataMockTypes[nextMock] = MockType.Return;\r\n\t\t\tcalldataExpectations[nextMock] = hex\"\";\r\n\t\t\tcalldataRevertMessage[nextMock] = \"\";\r\n\t\t\t// Set next mock to remove\r\n\t\t\tnextMock = calldataMocks[mockHash];\r\n\t\t\t// Remove from linked list\r\n\t\t\tcalldataMocks[mockHash] = \"\";\r\n\t\t\t// Update mock hash\r\n\t\t\tmockHash = keccak256(nextMock);\r\n\t\t}\r\n\t\t// Clear list\r\n\t\tcalldataMocks[MOCKS_LIST_START] = MOCKS_LIST_END;\r\n\r\n\t\t// Reset all any calldataMocks\r\n\t\tbytes4 nextAnyMock = methodIdMocks[SENTINEL_ANY_MOCKS];\r\n\t\twhile(nextAnyMock != SENTINEL_ANY_MOCKS) {\r\n\t\t\tbytes4 currentAnyMock = nextAnyMock;\r\n\t\t\tmethodIdMockTypes[currentAnyMock] = MockType.Return;\r\n\t\t\tmethodIdExpectations[currentAnyMock] = hex\"\";\r\n\t\t\tmethodIdRevertMessages[currentAnyMock] = \"\";\r\n\t\t\tnextAnyMock = methodIdMocks[currentAnyMock];\r\n\t\t\t// Remove from linked list\r\n\t\t\tmethodIdMocks[currentAnyMock] = 0x0;\r\n\t\t}\r\n\t\t// Clear list\r\n\t\tmethodIdMocks[SENTINEL_ANY_MOCKS] = SENTINEL_ANY_MOCKS;\r\n\r\n\t\tfallbackExpectation = \"\";\r\n\t\tfallbackMockType = MockType.Return;\r\n\t\tinvocations = 0;\r\n\t\tresetCount += 1;\r\n\t}\r\n\r\n\tfunction useAllGas() private {\r\n\t\twhile(true) {\r\n\t\t\tbool s;\r\n\t\t\tassembly {\r\n\t\t\t\t//expensive call to EC multiply contract\r\n\t\t\t\ts := call(sub(gas, 2000), 6, 0, 0x0, 0xc0, 0x0, 0x60)\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tfunction bytesToBytes4(bytes memory b) private pure returns (bytes4) {\r\n\t\tbytes4 out;\r\n\t\tfor (uint i = 0; i < 4; i++) {\r\n\t\t\tout |= bytes4(b[i] & 0xFF) >> (i * 8);\r\n\t\t}\r\n\t\treturn out;\r\n\t}\r\n\r\n\tfunction uintToBytes(uint256 x) private pure returns (bytes memory b) {\r\n\t\tb = new bytes(32);\r\n\t\tassembly { mstore(add(b, 32), x) }\r\n\t}\r\n\r\n\tfunction updateInvocationCount(bytes4 methodId, bytes memory originalMsgData) public {\r\n\t\trequire(msg.sender == address(this), \"Can only be called from the contract itself\");\r\n\t\tinvocations += 1;\r\n\t\tmethodIdInvocations[keccak256(abi.encodePacked(resetCount, methodId))] += 1;\r\n\t\tcalldataInvocations[keccak256(abi.encodePacked(resetCount, originalMsgData))] += 1;\r\n\t}\r\n\r\n\tfunction() payable external {\r\n\t\tbytes4 methodId;\r\n\t\tassembly {\r\n\t\t\tmethodId := calldataload(0)\r\n\t\t}\r\n\r\n\t\t// First, check exact matching overrides\r\n\t\tif (calldataMockTypes[msg.data] == MockType.Revert) {\r\n\t\t\trevert(calldataRevertMessage[msg.data]);\r\n\t\t}\r\n\t\tif (calldataMockTypes[msg.data] == MockType.OutOfGas) {\r\n\t\t\tuseAllGas();\r\n\t\t}\r\n\t\tbytes memory result = calldataExpectations[msg.data];\r\n\r\n\t\t// Then check method Id overrides\r\n\t\tif (result.length == 0) {\r\n\t\t\tif (methodIdMockTypes[methodId] == MockType.Revert) {\r\n\t\t\t\trevert(methodIdRevertMessages[methodId]);\r\n\t\t\t}\r\n\t\t\tif (methodIdMockTypes[methodId] == MockType.OutOfGas) {\r\n\t\t\t\tuseAllGas();\r\n\t\t\t}\r\n\t\t\tresult = methodIdExpectations[methodId];\r\n\t\t}\r\n\r\n\t\t// Last, use the fallback override\r\n\t\tif (result.length == 0) {\r\n\t\t\tif (fallbackMockType == MockType.Revert) {\r\n\t\t\t\trevert(fallbackRevertMessage);\r\n\t\t\t}\r\n\t\t\tif (fallbackMockType == MockType.OutOfGas) {\r\n\t\t\t\tuseAllGas();\r\n\t\t\t}\r\n\t\t\tresult = fallbackExpectation;\r\n\t\t}\r\n\r\n\t\t// Record invocation as separate call so we don't rollback in case we are called with STATICCALL\r\n\t\t(, bytes memory r) = address(this).call.gas(100000)(abi.encodeWithSignature(\"updateInvocationCount(bytes4,bytes)\", methodId, msg.data));\r\n\t\tassert(r.length == 0);\r\n\t\t\r\n\t\tassembly {\r\n\t\t\treturn(add(0x20, result), mload(result))\r\n\t\t}\r\n\t}\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/access/Roles.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @title Roles\r\n * @dev Library for managing addresses assigned to a Role.\r\n */\r\nlibrary Roles {\r\n    struct Role {\r\n        mapping (address => bool) bearer;\r\n    }\r\n\r\n    /**\r\n     * @dev give an account access to this role\r\n     */\r\n    function add(Role storage role, address account) internal {\r\n        require(account != address(0));\r\n        require(!has(role, account));\r\n\r\n        role.bearer[account] = true;\r\n    }\r\n\r\n    /**\r\n     * @dev remove an account's access to this role\r\n     */\r\n    function remove(Role storage role, address account) internal {\r\n        require(account != address(0));\r\n        require(has(role, account));\r\n\r\n        role.bearer[account] = false;\r\n    }\r\n\r\n    /**\r\n     * @dev check if an account has this role\r\n     * @return bool\r\n     */\r\n    function has(Role storage role, address account) internal view returns (bool) {\r\n        require(account != address(0));\r\n        return role.bearer[account];\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/access/roles/MinterRole.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\ncontract MinterRole {\r\n    using Roles for Roles.Role;\r\n\r\n    event MinterAdded(address indexed account);\r\n    event MinterRemoved(address indexed account);\r\n\r\n    Roles.Role private _minters;\r\n\r\n    constructor () internal {\r\n        _addMinter(msg.sender);\r\n    }\r\n\r\n    modifier onlyMinter() {\r\n        require(isMinter(msg.sender));\r\n        _;\r\n    }\r\n\r\n    function isMinter(address account) public view returns (bool) {\r\n        return _minters.has(account);\r\n    }\r\n\r\n    function addMinter(address account) public onlyMinter {\r\n        _addMinter(account);\r\n    }\r\n\r\n    function renounceMinter() public {\r\n        _removeMinter(msg.sender);\r\n    }\r\n\r\n    function _addMinter(address account) internal {\r\n        _minters.add(account);\r\n        emit MinterAdded(account);\r\n    }\r\n\r\n    function _removeMinter(address account) internal {\r\n        _minters.remove(account);\r\n        emit MinterRemoved(account);\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC20/ERC20Mintable.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n\r\n/**\r\n * @title ERC20Mintable\r\n * @dev ERC20 minting logic\r\n */\r\ncontract ERC20Mintable is ERC20, MinterRole {\r\n    /**\r\n     * @dev Function to mint tokens\r\n     * @param to The address that will receive the minted tokens.\r\n     * @param value The amount of tokens to mint.\r\n     * @return A boolean that indicates if the operation was successful.\r\n     */\r\n    function mint(address to, uint256 value) public onlyMinter returns (bool) {\r\n        _mint(to, value);\r\n        return true;\r\n    }\r\n}\r\n\r\n// File: contracts/interfaces/IDutchExchange.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n\r\ncontract IDutchExchange {\r\n\r\n    mapping(address => mapping(address => mapping(uint => mapping(address => uint)))) public sellerBalances;\r\n    mapping(address => mapping(address => mapping(uint => mapping(address => uint)))) public buyerBalances;\r\n    mapping(address => mapping(address => mapping(uint => mapping(address => uint)))) public claimedAmounts;\r\n    mapping(address => mapping(address => uint)) public balances;\r\n\r\n    function withdraw(address tokenAddress, uint amount) public returns (uint);\r\n    function deposit(address tokenAddress, uint amount) public returns (uint);\r\n    function ethToken() public returns(address);\r\n    function frtToken() public returns(address);\r\n    function getAuctionIndex(address token1, address token2) public view returns(uint256);\r\n    function postBuyOrder(address token1, address token2, uint256 auctionIndex, uint256 amount) public returns(uint256);\r\n    function postSellOrder(address token1, address token2, uint256 auctionIndex, uint256 tokensBought) public returns(uint256, uint256);\r\n    function getCurrentAuctionPrice(address token1, address token2, uint256 auctionIndex) public view returns(uint256, uint256);\r\n    function claimSellerFunds(address sellToken, address buyToken, address user, uint auctionIndex) public returns (uint returned, uint frtsIssued);\r\n}\r\n\r\n// File: @gnosis.pm/util-contracts/contracts/Proxy.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n/// @title Proxied - indicates that a contract will be proxied. Also defines storage requirements for Proxy.\r\n/// @author Alan Lu - <alan@gnosis.pm>\r\ncontract Proxied {\r\n    address public masterCopy;\r\n}\r\n\r\n/// @title Proxy - Generic proxy contract allows to execute all transactions applying the code of a master contract.\r\n/// @author Stefan George - <stefan@gnosis.pm>\r\ncontract Proxy is Proxied {\r\n    /// @dev Constructor function sets address of master copy contract.\r\n    /// @param _masterCopy Master copy address.\r\n    constructor(address _masterCopy) public {\r\n        require(_masterCopy != address(0), \"The master copy is required\");\r\n        masterCopy = _masterCopy;\r\n    }\r\n\r\n    /// @dev Fallback function forwards all transactions and returns all received return data.\r\n    function() external payable {\r\n        address _masterCopy = masterCopy;\r\n        assembly {\r\n            calldatacopy(0, 0, calldatasize)\r\n            let success := delegatecall(not(0), _masterCopy, 0, calldatasize, 0, 0)\r\n            returndatacopy(0, 0, returndatasize)\r\n            switch success\r\n                case 0 {\r\n                    revert(0, returndatasize)\r\n                }\r\n                default {\r\n                    return(0, returndatasize)\r\n                }\r\n        }\r\n    }\r\n}\r\n\r\n// File: @gnosis.pm/util-contracts/contracts/Token.sol\r\n\r\n/// Implements ERC 20 Token standard: https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md\r\npragma solidity ^0.5.2;\r\n\r\n/// @title Abstract token contract - Functions to be implemented by token contracts\r\ncontract Token {\r\n    /*\r\n     *  Events\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n\r\n    /*\r\n     *  Public functions\r\n     */\r\n    function transfer(address to, uint value) public returns (bool);\r\n    function transferFrom(address from, address to, uint value) public returns (bool);\r\n    function approve(address spender, uint value) public returns (bool);\r\n    function balanceOf(address owner) public view returns (uint);\r\n    function allowance(address owner, address spender) public view returns (uint);\r\n    function totalSupply() public view returns (uint);\r\n}\r\n\r\n// File: @gnosis.pm/util-contracts/contracts/Math.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n/// @title Math library - Allows calculation of logarithmic and exponential functions\r\n/// @author Alan Lu - <alan.lu@gnosis.pm>\r\n/// @author Stefan George - <stefan@gnosis.pm>\r\nlibrary GnosisMath {\r\n    /*\r\n     *  Constants\r\n     */\r\n    // This is equal to 1 in our calculations\r\n    uint public constant ONE = 0x10000000000000000;\r\n    uint public constant LN2 = 0xb17217f7d1cf79ac;\r\n    uint public constant LOG2_E = 0x171547652b82fe177;\r\n\r\n    /*\r\n     *  Public functions\r\n     */\r\n    /// @dev Returns natural exponential function value of given x\r\n    /// @param x x\r\n    /// @return e**x\r\n    function exp(int x) public pure returns (uint) {\r\n        // revert if x is > MAX_POWER, where\r\n        // MAX_POWER = int(mp.floor(mp.log(mpf(2**256 - 1) / ONE) * ONE))\r\n        require(x <= 2454971259878909886679);\r\n        // return 0 if exp(x) is tiny, using\r\n        // MIN_POWER = int(mp.floor(mp.log(mpf(1) / ONE) * ONE))\r\n        if (x < -818323753292969962227) return 0;\r\n        // Transform so that e^x -> 2^x\r\n        x = x * int(ONE) / int(LN2);\r\n        // 2^x = 2^whole(x) * 2^frac(x)\r\n        //       ^^^^^^^^^^ is a bit shift\r\n        // so Taylor expand on z = frac(x)\r\n        int shift;\r\n        uint z;\r\n        if (x >= 0) {\r\n            shift = x / int(ONE);\r\n            z = uint(x % int(ONE));\r\n        } else {\r\n            shift = x / int(ONE) - 1;\r\n            z = ONE - uint(-x % int(ONE));\r\n        }\r\n        // 2^x = 1 + (ln 2) x + (ln 2)^2/2! x^2 + ...\r\n        //\r\n        // Can generate the z coefficients using mpmath and the following lines\r\n        // >>> from mpmath import mp\r\n        // >>> mp.dps = 100\r\n        // >>> ONE =  0x10000000000000000\r\n        // >>> print('\\n'.join(hex(int(mp.log(2)**i / mp.factorial(i) * ONE)) for i in range(1, 7)))\r\n        // 0xb17217f7d1cf79ab\r\n        // 0x3d7f7bff058b1d50\r\n        // 0xe35846b82505fc5\r\n        // 0x276556df749cee5\r\n        // 0x5761ff9e299cc4\r\n        // 0xa184897c363c3\r\n        uint zpow = z;\r\n        uint result = ONE;\r\n        result += 0xb17217f7d1cf79ab * zpow / ONE;\r\n        zpow = zpow * z / ONE;\r\n        result += 0x3d7f7bff058b1d50 * zpow / ONE;\r\n        zpow = zpow * z / ONE;\r\n        result += 0xe35846b82505fc5 * zpow / ONE;\r\n        zpow = zpow * z / ONE;\r\n        result += 0x276556df749cee5 * zpow / ONE;\r\n        zpow = zpow * z / ONE;\r\n        result += 0x5761ff9e299cc4 * zpow / ONE;\r\n        zpow = zpow * z / ONE;\r\n        result += 0xa184897c363c3 * zpow / ONE;\r\n        zpow = zpow * z / ONE;\r\n        result += 0xffe5fe2c4586 * zpow / ONE;\r\n        zpow = zpow * z / ONE;\r\n        result += 0x162c0223a5c8 * zpow / ONE;\r\n        zpow = zpow * z / ONE;\r\n        result += 0x1b5253d395e * zpow / ONE;\r\n        zpow = zpow * z / ONE;\r\n        result += 0x1e4cf5158b * zpow / ONE;\r\n        zpow = zpow * z / ONE;\r\n        result += 0x1e8cac735 * zpow / ONE;\r\n        zpow = zpow * z / ONE;\r\n        result += 0x1c3bd650 * zpow / ONE;\r\n        zpow = zpow * z / ONE;\r\n        result += 0x1816193 * zpow / ONE;\r\n        zpow = zpow * z / ONE;\r\n        result += 0x131496 * zpow / ONE;\r\n        zpow = zpow * z / ONE;\r\n        result += 0xe1b7 * zpow / ONE;\r\n        zpow = zpow * z / ONE;\r\n        result += 0x9c7 * zpow / ONE;\r\n        if (shift >= 0) {\r\n            if (result >> (256 - shift) > 0) return (2 ** 256 - 1);\r\n            return result << shift;\r\n        } else return result >> (-shift);\r\n    }\r\n\r\n    /// @dev Returns natural logarithm value of given x\r\n    /// @param x x\r\n    /// @return ln(x)\r\n    function ln(uint x) public pure returns (int) {\r\n        require(x > 0);\r\n        // binary search for floor(log2(x))\r\n        int ilog2 = floorLog2(x);\r\n        int z;\r\n        if (ilog2 < 0) z = int(x << uint(-ilog2));\r\n        else z = int(x >> uint(ilog2));\r\n        // z = x * 2^-⌊log₂x⌋\r\n        // so 1 <= z < 2\r\n        // and ln z = ln x - ⌊log₂x⌋/log₂e\r\n        // so just compute ln z using artanh series\r\n        // and calculate ln x from that\r\n        int term = (z - int(ONE)) * int(ONE) / (z + int(ONE));\r\n        int halflnz = term;\r\n        int termpow = term * term / int(ONE) * term / int(ONE);\r\n        halflnz += termpow / 3;\r\n        termpow = termpow * term / int(ONE) * term / int(ONE);\r\n        halflnz += termpow / 5;\r\n        termpow = termpow * term / int(ONE) * term / int(ONE);\r\n        halflnz += termpow / 7;\r\n        termpow = termpow * term / int(ONE) * term / int(ONE);\r\n        halflnz += termpow / 9;\r\n        termpow = termpow * term / int(ONE) * term / int(ONE);\r\n        halflnz += termpow / 11;\r\n        termpow = termpow * term / int(ONE) * term / int(ONE);\r\n        halflnz += termpow / 13;\r\n        termpow = termpow * term / int(ONE) * term / int(ONE);\r\n        halflnz += termpow / 15;\r\n        termpow = termpow * term / int(ONE) * term / int(ONE);\r\n        halflnz += termpow / 17;\r\n        termpow = termpow * term / int(ONE) * term / int(ONE);\r\n        halflnz += termpow / 19;\r\n        termpow = termpow * term / int(ONE) * term / int(ONE);\r\n        halflnz += termpow / 21;\r\n        termpow = termpow * term / int(ONE) * term / int(ONE);\r\n        halflnz += termpow / 23;\r\n        termpow = termpow * term / int(ONE) * term / int(ONE);\r\n        halflnz += termpow / 25;\r\n        return (ilog2 * int(ONE)) * int(ONE) / int(LOG2_E) + 2 * halflnz;\r\n    }\r\n\r\n    /// @dev Returns base 2 logarithm value of given x\r\n    /// @param x x\r\n    /// @return logarithmic value\r\n    function floorLog2(uint x) public pure returns (int lo) {\r\n        lo = -64;\r\n        int hi = 193;\r\n        // I use a shift here instead of / 2 because it floors instead of rounding towards 0\r\n        int mid = (hi + lo) >> 1;\r\n        while ((lo + 1) < hi) {\r\n            if (mid < 0 && x << uint(-mid) < ONE || mid >= 0 && x >> uint(mid) < ONE) hi = mid;\r\n            else lo = mid;\r\n            mid = (hi + lo) >> 1;\r\n        }\r\n    }\r\n\r\n    /// @dev Returns maximum of an array\r\n    /// @param nums Numbers to look through\r\n    /// @return Maximum number\r\n    function max(int[] memory nums) public pure returns (int maxNum) {\r\n        require(nums.length > 0);\r\n        maxNum = -2 ** 255;\r\n        for (uint i = 0; i < nums.length; i++) if (nums[i] > maxNum) maxNum = nums[i];\r\n    }\r\n\r\n    /// @dev Returns whether an add operation causes an overflow\r\n    /// @param a First addend\r\n    /// @param b Second addend\r\n    /// @return Did no overflow occur?\r\n    function safeToAdd(uint a, uint b) internal pure returns (bool) {\r\n        return a + b >= a;\r\n    }\r\n\r\n    /// @dev Returns whether a subtraction operation causes an underflow\r\n    /// @param a Minuend\r\n    /// @param b Subtrahend\r\n    /// @return Did no underflow occur?\r\n    function safeToSub(uint a, uint b) internal pure returns (bool) {\r\n        return a >= b;\r\n    }\r\n\r\n    /// @dev Returns whether a multiply operation causes an overflow\r\n    /// @param a First factor\r\n    /// @param b Second factor\r\n    /// @return Did no overflow occur?\r\n    function safeToMul(uint a, uint b) internal pure returns (bool) {\r\n        return b == 0 || a * b / b == a;\r\n    }\r\n\r\n    /// @dev Returns sum if no overflow occurred\r\n    /// @param a First addend\r\n    /// @param b Second addend\r\n    /// @return Sum\r\n    function add(uint a, uint b) internal pure returns (uint) {\r\n        require(safeToAdd(a, b));\r\n        return a + b;\r\n    }\r\n\r\n    /// @dev Returns difference if no overflow occurred\r\n    /// @param a Minuend\r\n    /// @param b Subtrahend\r\n    /// @return Difference\r\n    function sub(uint a, uint b) internal pure returns (uint) {\r\n        require(safeToSub(a, b));\r\n        return a - b;\r\n    }\r\n\r\n    /// @dev Returns product if no overflow occurred\r\n    /// @param a First factor\r\n    /// @param b Second factor\r\n    /// @return Product\r\n    function mul(uint a, uint b) internal pure returns (uint) {\r\n        require(safeToMul(a, b));\r\n        return a * b;\r\n    }\r\n\r\n    /// @dev Returns whether an add operation causes an overflow\r\n    /// @param a First addend\r\n    /// @param b Second addend\r\n    /// @return Did no overflow occur?\r\n    function safeToAdd(int a, int b) internal pure returns (bool) {\r\n        return (b >= 0 && a + b >= a) || (b < 0 && a + b < a);\r\n    }\r\n\r\n    /// @dev Returns whether a subtraction operation causes an underflow\r\n    /// @param a Minuend\r\n    /// @param b Subtrahend\r\n    /// @return Did no underflow occur?\r\n    function safeToSub(int a, int b) internal pure returns (bool) {\r\n        return (b >= 0 && a - b <= a) || (b < 0 && a - b > a);\r\n    }\r\n\r\n    /// @dev Returns whether a multiply operation causes an overflow\r\n    /// @param a First factor\r\n    /// @param b Second factor\r\n    /// @return Did no overflow occur?\r\n    function safeToMul(int a, int b) internal pure returns (bool) {\r\n        return (b == 0) || (a * b / b == a);\r\n    }\r\n\r\n    /// @dev Returns sum if no overflow occurred\r\n    /// @param a First addend\r\n    /// @param b Second addend\r\n    /// @return Sum\r\n    function add(int a, int b) internal pure returns (int) {\r\n        require(safeToAdd(a, b));\r\n        return a + b;\r\n    }\r\n\r\n    /// @dev Returns difference if no overflow occurred\r\n    /// @param a Minuend\r\n    /// @param b Subtrahend\r\n    /// @return Difference\r\n    function sub(int a, int b) internal pure returns (int) {\r\n        require(safeToSub(a, b));\r\n        return a - b;\r\n    }\r\n\r\n    /// @dev Returns product if no overflow occurred\r\n    /// @param a First factor\r\n    /// @param b Second factor\r\n    /// @return Product\r\n    function mul(int a, int b) internal pure returns (int) {\r\n        require(safeToMul(a, b));\r\n        return a * b;\r\n    }\r\n}\r\n\r\n// File: @gnosis.pm/util-contracts/contracts/GnosisStandardToken.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n\r\n\r\n\r\n/**\r\n * Deprecated: Use Open Zeppeling one instead\r\n */\r\ncontract StandardTokenData {\r\n    /*\r\n     *  Storage\r\n     */\r\n    mapping(address => uint) balances;\r\n    mapping(address => mapping(address => uint)) allowances;\r\n    uint totalTokens;\r\n}\r\n\r\n/**\r\n * Deprecated: Use Open Zeppeling one instead\r\n */\r\n/// @title Standard token contract with overflow protection\r\ncontract GnosisStandardToken is Token, StandardTokenData {\r\n    using GnosisMath for *;\r\n\r\n    /*\r\n     *  Public functions\r\n     */\r\n    /// @dev Transfers sender's tokens to a given address. Returns success\r\n    /// @param to Address of token receiver\r\n    /// @param value Number of tokens to transfer\r\n    /// @return Was transfer successful?\r\n    function transfer(address to, uint value) public returns (bool) {\r\n        if (!balances[msg.sender].safeToSub(value) || !balances[to].safeToAdd(value)) {\r\n            return false;\r\n        }\r\n\r\n        balances[msg.sender] -= value;\r\n        balances[to] += value;\r\n        emit Transfer(msg.sender, to, value);\r\n        return true;\r\n    }\r\n\r\n    /// @dev Allows allowed third party to transfer tokens from one address to another. Returns success\r\n    /// @param from Address from where tokens are withdrawn\r\n    /// @param to Address to where tokens are sent\r\n    /// @param value Number of tokens to transfer\r\n    /// @return Was transfer successful?\r\n    function transferFrom(address from, address to, uint value) public returns (bool) {\r\n        if (!balances[from].safeToSub(value) || !allowances[from][msg.sender].safeToSub(\r\n            value\r\n        ) || !balances[to].safeToAdd(value)) {\r\n            return false;\r\n        }\r\n        balances[from] -= value;\r\n        allowances[from][msg.sender] -= value;\r\n        balances[to] += value;\r\n        emit Transfer(from, to, value);\r\n        return true;\r\n    }\r\n\r\n    /// @dev Sets approved amount of tokens for spender. Returns success\r\n    /// @param spender Address of allowed account\r\n    /// @param value Number of approved tokens\r\n    /// @return Was approval successful?\r\n    function approve(address spender, uint value) public returns (bool) {\r\n        allowances[msg.sender][spender] = value;\r\n        emit Approval(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n\r\n    /// @dev Returns number of allowed tokens for given address\r\n    /// @param owner Address of token owner\r\n    /// @param spender Address of token spender\r\n    /// @return Remaining allowance for spender\r\n    function allowance(address owner, address spender) public view returns (uint) {\r\n        return allowances[owner][spender];\r\n    }\r\n\r\n    /// @dev Returns number of tokens owned by given address\r\n    /// @param owner Address of token owner\r\n    /// @return Balance of owner\r\n    function balanceOf(address owner) public view returns (uint) {\r\n        return balances[owner];\r\n    }\r\n\r\n    /// @dev Returns total supply of tokens\r\n    /// @return Total supply\r\n    function totalSupply() public view returns (uint) {\r\n        return totalTokens;\r\n    }\r\n}\r\n\r\n// File: @gnosis.pm/dx-contracts/contracts/TokenFRT.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n\r\n\r\n\r\n/// @title Standard token contract with overflow protection\r\ncontract TokenFRT is Proxied, GnosisStandardToken {\r\n    address public owner;\r\n\r\n    string public constant symbol = \"MGN\";\r\n    string public constant name = \"Magnolia Token\";\r\n    uint8 public constant decimals = 18;\r\n\r\n    struct UnlockedToken {\r\n        uint amountUnlocked;\r\n        uint withdrawalTime;\r\n    }\r\n\r\n    /*\r\n     *  Storage\r\n     */\r\n    address public minter;\r\n\r\n    // user => UnlockedToken\r\n    mapping(address => UnlockedToken) public unlockedTokens;\r\n\r\n    // user => amount\r\n    mapping(address => uint) public lockedTokenBalances;\r\n\r\n    /*\r\n     *  Public functions\r\n     */\r\n\r\n    // @dev allows to set the minter of Magnolia tokens once.\r\n    // @param   _minter the minter of the Magnolia tokens, should be the DX-proxy\r\n    function updateMinter(address _minter) public {\r\n        require(msg.sender == owner, \"Only the minter can set a new one\");\r\n        require(_minter != address(0), \"The new minter must be a valid address\");\r\n\r\n        minter = _minter;\r\n    }\r\n\r\n    // @dev the intention is to set the owner as the DX-proxy, once it is deployed\r\n    // Then only an update of the DX-proxy contract after a 30 days delay could change the minter again.\r\n    function updateOwner(address _owner) public {\r\n        require(msg.sender == owner, \"Only the owner can update the owner\");\r\n        require(_owner != address(0), \"The new owner must be a valid address\");\r\n        owner = _owner;\r\n    }\r\n\r\n    function mintTokens(address user, uint amount) public {\r\n        require(msg.sender == minter, \"Only the minter can mint tokens\");\r\n\r\n        lockedTokenBalances[user] = add(lockedTokenBalances[user], amount);\r\n        totalTokens = add(totalTokens, amount);\r\n    }\r\n\r\n    /// @dev Lock Token\r\n    function lockTokens(uint amount) public returns (uint totalAmountLocked) {\r\n        // Adjust amount by balance\r\n        uint actualAmount = min(amount, balances[msg.sender]);\r\n\r\n        // Update state variables\r\n        balances[msg.sender] = sub(balances[msg.sender], actualAmount);\r\n        lockedTokenBalances[msg.sender] = add(lockedTokenBalances[msg.sender], actualAmount);\r\n\r\n        // Get return variable\r\n        totalAmountLocked = lockedTokenBalances[msg.sender];\r\n    }\r\n\r\n    function unlockTokens() public returns (uint totalAmountUnlocked, uint withdrawalTime) {\r\n        // Adjust amount by locked balances\r\n        uint amount = lockedTokenBalances[msg.sender];\r\n\r\n        if (amount > 0) {\r\n            // Update state variables\r\n            lockedTokenBalances[msg.sender] = sub(lockedTokenBalances[msg.sender], amount);\r\n            unlockedTokens[msg.sender].amountUnlocked = add(unlockedTokens[msg.sender].amountUnlocked, amount);\r\n            unlockedTokens[msg.sender].withdrawalTime = now + 24 hours;\r\n        }\r\n\r\n        // Get return variables\r\n        totalAmountUnlocked = unlockedTokens[msg.sender].amountUnlocked;\r\n        withdrawalTime = unlockedTokens[msg.sender].withdrawalTime;\r\n    }\r\n\r\n    function withdrawUnlockedTokens() public {\r\n        require(unlockedTokens[msg.sender].withdrawalTime < now, \"The tokens cannot be withdrawn yet\");\r\n        balances[msg.sender] = add(balances[msg.sender], unlockedTokens[msg.sender].amountUnlocked);\r\n        unlockedTokens[msg.sender].amountUnlocked = 0;\r\n    }\r\n\r\n    function min(uint a, uint b) public pure returns (uint) {\r\n        if (a < b) {\r\n            return a;\r\n        } else {\r\n            return b;\r\n        }\r\n    }\r\n    \r\n    /// @dev Returns whether an add operation causes an overflow\r\n    /// @param a First addend\r\n    /// @param b Second addend\r\n    /// @return Did no overflow occur?\r\n    function safeToAdd(uint a, uint b) public pure returns (bool) {\r\n        return a + b >= a;\r\n    }\r\n\r\n    /// @dev Returns whether a subtraction operation causes an underflow\r\n    /// @param a Minuend\r\n    /// @param b Subtrahend\r\n    /// @return Did no underflow occur?\r\n    function safeToSub(uint a, uint b) public pure returns (bool) {\r\n        return a >= b;\r\n    }\r\n\r\n    /// @dev Returns sum if no overflow occurred\r\n    /// @param a First addend\r\n    /// @param b Second addend\r\n    /// @return Sum\r\n    function add(uint a, uint b) public pure returns (uint) {\r\n        require(safeToAdd(a, b), \"It must be a safe adition\");\r\n        return a + b;\r\n    }\r\n\r\n    /// @dev Returns difference if no overflow occurred\r\n    /// @param a Minuend\r\n    /// @param b Subtrahend\r\n    /// @return Difference\r\n    function sub(uint a, uint b) public pure returns (uint) {\r\n        require(safeToSub(a, b), \"It must be a safe substraction\");\r\n        return a - b;\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/utils/Address.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * Utility library of inline functions on addresses\r\n */\r\nlibrary Address {\r\n    /**\r\n     * Returns whether the target address is a contract\r\n     * @dev This function will return false if invoked during the constructor of a contract,\r\n     * as the code is not actually created until after the constructor finishes.\r\n     * @param account address of the account to check\r\n     * @return whether the target address is a contract\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        uint256 size;\r\n        // XXX Currently there is no better way to check if there is a contract in an address\r\n        // than to check the size of the code at that address.\r\n        // See https://ethereum.stackexchange.com/a/14016/36603\r\n        // for more details about how this works.\r\n        // TODO Check this again before the Serenity release, because all addresses will be\r\n        // contracts then.\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { size := extcodesize(account) }\r\n        return size > 0;\r\n    }\r\n}\r\n\r\n// File: @daostack/arc/contracts/libs/SafeERC20.sol\r\n\r\n/*\r\n\r\nSafeERC20 by daostack.\r\nThe code is based on a fix by SECBIT Team.\r\n\r\nUSE WITH CAUTION & NO WARRANTY\r\n\r\nREFERENCE & RELATED READING\r\n- https://github.com/ethereum/solidity/issues/4116\r\n- https://medium.com/@chris_77367/explaining-unexpected-reverts-starting-with-solidity-0-4-22-3ada6e82308c\r\n- https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca\r\n- https://gist.github.com/BrendanChou/88a2eeb80947ff00bcf58ffdafeaeb61\r\n\r\n*/\r\npragma solidity ^0.5.2;\r\n\r\n\r\n\r\nlibrary SafeERC20 {\r\n    using Address for address;\r\n\r\n    bytes4 constant private TRANSFER_SELECTOR = bytes4(keccak256(bytes(\"transfer(address,uint256)\")));\r\n    bytes4 constant private TRANSFERFROM_SELECTOR = bytes4(keccak256(bytes(\"transferFrom(address,address,uint256)\")));\r\n    bytes4 constant private APPROVE_SELECTOR = bytes4(keccak256(bytes(\"approve(address,uint256)\")));\r\n\r\n    function safeTransfer(address _erc20Addr, address _to, uint256 _value) internal {\r\n\r\n        // Must be a contract addr first!\r\n        require(_erc20Addr.isContract());\r\n\r\n        (bool success, bytes memory returnValue) =\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        _erc20Addr.call(abi.encodeWithSelector(TRANSFER_SELECTOR, _to, _value));\r\n        // call return false when something wrong\r\n        require(success);\r\n        //check return value\r\n        require(returnValue.length == 0 || (returnValue.length == 32 && (returnValue[31] != 0)));\r\n    }\r\n\r\n    function safeTransferFrom(address _erc20Addr, address _from, address _to, uint256 _value) internal {\r\n\r\n        // Must be a contract addr first!\r\n        require(_erc20Addr.isContract());\r\n\r\n        (bool success, bytes memory returnValue) =\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        _erc20Addr.call(abi.encodeWithSelector(TRANSFERFROM_SELECTOR, _from, _to, _value));\r\n        // call return false when something wrong\r\n        require(success);\r\n        //check return value\r\n        require(returnValue.length == 0 || (returnValue.length == 32 && (returnValue[31] != 0)));\r\n    }\r\n\r\n    function safeApprove(address _erc20Addr, address _spender, uint256 _value) internal {\r\n\r\n        // Must be a contract addr first!\r\n        require(_erc20Addr.isContract());\r\n\r\n        // safeApprove should only be called when setting an initial allowance,\r\n        // or when resetting it to zero.\r\n        require((_value == 0) || (IERC20(_erc20Addr).allowance(msg.sender, _spender) == 0));\r\n\r\n        (bool success, bytes memory returnValue) =\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        _erc20Addr.call(abi.encodeWithSelector(APPROVE_SELECTOR, _spender, _value));\r\n        // call return false when something wrong\r\n        require(success);\r\n        //check return value\r\n        require(returnValue.length == 0 || (returnValue.length == 32 && (returnValue[31] != 0)));\r\n    }\r\n}\r\n\r\n// File: contracts/DxMgnPool.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract DxMgnPool is Ownable {\r\n    using SafeMath for uint;\r\n\r\n    struct Participation {\r\n        uint startAuctionCount; // how many auction passed when this participation started contributing\r\n        uint poolShares; // number of shares this participation accounts for (absolute)\r\n    }\r\n    mapping (address => bool) hasParticpationWithdrawn;\r\n    enum State {\r\n        Pooling,\r\n        PoolingEnded,\r\n        DepositWithdrawnFromDx,\r\n        MgnUnlocked\r\n    }\r\n    State public currentState = State.Pooling;\r\n\r\n    mapping (address => Participation[]) public participationsByAddress;\r\n    uint public totalPoolShares; // total number of shares in this pool\r\n    uint public totalPoolSharesCummulative; // over all auctions, the rolling sum of all shares participated\r\n    uint public totalDeposit;\r\n    uint public totalMgn;\r\n    uint public lastParticipatedAuctionIndex;\r\n    uint public auctionCount;\r\n    \r\n    ERC20 public depositToken;\r\n    ERC20 public secondaryToken;\r\n    TokenFRT public mgnToken;\r\n    IDutchExchange public dx;\r\n\r\n    uint public poolingPeriodEndTime;\r\n\r\n    constructor (\r\n        ERC20 _depositToken, \r\n        ERC20 _secondaryToken, \r\n        IDutchExchange _dx,\r\n        uint _poolingTimeSeconds\r\n    ) public Ownable()\r\n    {\r\n        depositToken = _depositToken;\r\n        secondaryToken = _secondaryToken;\r\n        dx = _dx;\r\n        mgnToken = TokenFRT(dx.frtToken());\r\n        poolingPeriodEndTime = now + _poolingTimeSeconds;\r\n    }\r\n\r\n    /**\r\n     * Public interface\r\n     */\r\n    function deposit(uint amount) public {\r\n        checkForStateUpdate();\r\n        require(currentState == State.Pooling, \"Pooling is already over\");\r\n\r\n        uint poolShares = calculatePoolShares(amount);\r\n        Participation memory participation = Participation({\r\n            startAuctionCount: isDepositTokenTurn() ? auctionCount : auctionCount + 1,\r\n            poolShares: poolShares\r\n            });\r\n        participationsByAddress[msg.sender].push(participation);\r\n        totalPoolShares += poolShares;\r\n        totalDeposit += amount;\r\n\r\n        SafeERC20.safeTransferFrom(address(depositToken), msg.sender, address(this), amount);\r\n    }\r\n\r\n    function withdrawDeposit() public returns(uint) {\r\n        require(currentState == State.DepositWithdrawnFromDx || currentState == State.MgnUnlocked, \"Funds not yet withdrawn from dx\");\r\n        require(!hasParticpationWithdrawn[msg.sender],\"sender has already withdrawn funds\");\r\n\r\n        uint totalDepositAmount = 0;\r\n        Participation[] storage participations = participationsByAddress[msg.sender];\r\n        uint length = participations.length;\r\n        for (uint i = 0; i < length; i++) {\r\n            totalDepositAmount += calculateClaimableDeposit(participations[i]);\r\n        }\r\n        hasParticpationWithdrawn[msg.sender] = true;\r\n        SafeERC20.safeTransfer(address(depositToken), msg.sender, totalDepositAmount);\r\n        return totalDepositAmount;\r\n    }\r\n\r\n    function withdrawMagnolia() public returns(uint) {\r\n        require(currentState == State.MgnUnlocked, \"MGN has not been unlocked, yet\");\r\n        require(hasParticpationWithdrawn[msg.sender], \"Withdraw deposits first\");\r\n        \r\n        uint totalMgnClaimed = 0;\r\n        Participation[] memory participations = participationsByAddress[msg.sender];\r\n        for (uint i = 0; i < participations.length; i++) {\r\n            totalMgnClaimed += calculateClaimableMgn(participations[i]);\r\n        }\r\n        delete participationsByAddress[msg.sender];\r\n        delete hasParticpationWithdrawn[msg.sender];\r\n        SafeERC20.safeTransfer(address(mgnToken), msg.sender, totalMgnClaimed);\r\n        return totalMgnClaimed;\r\n    }\r\n\r\n    function participateInAuction() public  onlyOwner() {\r\n        checkForStateUpdate();\r\n        require(currentState == State.Pooling, \"Pooling period is over.\");\r\n\r\n        uint auctionIndex = dx.getAuctionIndex(address(depositToken), address(secondaryToken));\r\n        require(auctionIndex > lastParticipatedAuctionIndex, \"Has to wait for new auction to start\");\r\n\r\n        (address sellToken, address buyToken) = sellAndBuyToken();\r\n        uint depositAmount = depositToken.balanceOf(address(this));\r\n        if (isDepositTokenTurn()) {\r\n            totalPoolSharesCummulative += 2 * totalPoolShares;\r\n            if( depositAmount > 0){\r\n                //depositing new tokens\r\n                depositToken.approve(address(dx), depositAmount);\r\n                dx.deposit(address(depositToken), depositAmount);\r\n            }\r\n        }\r\n        // Don't revert if we can't claimSellerFunds\r\n        address(dx).call(abi.encodeWithSignature(\"claimSellerFunds(address,address,address,uint256)\", buyToken, sellToken, address(this), lastParticipatedAuctionIndex));\r\n\r\n        uint amount = dx.balances(address(sellToken), address(this));\r\n        if (isDepositTokenTurn()) {\r\n            totalDeposit = amount;\r\n        }\r\n\r\n        (lastParticipatedAuctionIndex, ) = dx.postSellOrder(sellToken, buyToken, 0, amount);\r\n        auctionCount += 1;\r\n    }\r\n\r\n    function triggerMGNunlockAndClaimTokens() public {\r\n        checkForStateUpdate();\r\n        require(currentState == State.PoolingEnded, \"Pooling period is not yet over.\");\r\n        require(\r\n            dx.getAuctionIndex(address(depositToken), address(secondaryToken)) > lastParticipatedAuctionIndex, \r\n            \"Last auction is still running\"\r\n        );      \r\n        \r\n        // Don't revert if wen can't claimSellerFunds\r\n        address(dx).call(abi.encodeWithSignature(\"claimSellerFunds(address,address,address,uint256)\", secondaryToken, depositToken, address(this), lastParticipatedAuctionIndex));\r\n        mgnToken.unlockTokens();\r\n\r\n        uint amountOfFundsInDX = dx.balances(address(depositToken), address(this));\r\n        totalDeposit = amountOfFundsInDX + depositToken.balanceOf(address(this));\r\n        if(amountOfFundsInDX > 0){\r\n            dx.withdraw(address(depositToken), amountOfFundsInDX);\r\n        }\r\n        currentState = State.DepositWithdrawnFromDx;\r\n    }\r\n\r\n    function withdrawUnlockedMagnoliaFromDx() public {\r\n        require(currentState == State.DepositWithdrawnFromDx, \"Unlocking not yet triggered\");\r\n\r\n        // Implicitly we also have:\r\n        // require(unlockedTokens[msg.sender].withdrawalTime < now, \"The tokens cannot be withdrawn yet\");\r\n\r\n        mgnToken.withdrawUnlockedTokens();\r\n        totalMgn = mgnToken.balanceOf(address(this));\r\n\r\n        currentState = State.MgnUnlocked;\r\n    }\r\n\r\n    function checkForStateUpdate() public {\r\n        if (now >= poolingPeriodEndTime && isDepositTokenTurn() && currentState == State.Pooling) {\r\n            currentState = State.PoolingEnded;\r\n        }\r\n    }\r\n\r\n    /// @dev updates state and returns val\r\n    function updateAndGetCurrentState() public returns(State) {\r\n        checkForStateUpdate();\r\n\r\n        return currentState;\r\n    }\r\n\r\n    /**\r\n     * Public View Functions\r\n     */\r\n     \r\n    function numberOfParticipations(address addr) public view returns (uint) {\r\n        return participationsByAddress[addr].length;\r\n    }\r\n\r\n    function participationAtIndex(address addr, uint index) public view returns (uint, uint) {\r\n        Participation memory participation = participationsByAddress[addr][index];\r\n        return (participation.startAuctionCount, participation.poolShares);\r\n    }\r\n\r\n    function poolSharesByAddress(address userAddress) external view returns(uint[] memory) {\r\n        uint length = participationsByAddress[userAddress].length;        \r\n        uint[] memory userTotalPoolShares = new uint[](length);\r\n        \r\n        for (uint i = 0; i < length; i++) {\r\n            userTotalPoolShares[i] = participationsByAddress[userAddress][i].poolShares;\r\n        }\r\n\r\n        return userTotalPoolShares;\r\n    }\r\n\r\n    function sellAndBuyToken() public view returns(address sellToken, address buyToken) {\r\n        if (isDepositTokenTurn()) {\r\n            return (address(depositToken), address(secondaryToken));\r\n        } else {\r\n            return (address(secondaryToken), address(depositToken)); \r\n        }\r\n    }\r\n\r\n    function getAllClaimableMgnAndDeposits(address userAddress) external view returns(uint[] memory, uint[] memory) {\r\n        uint length = participationsByAddress[userAddress].length;\r\n\r\n        uint[] memory allUserClaimableMgn = new uint[](length);\r\n        uint[] memory allUserClaimableDeposit = new uint[](length);\r\n\r\n        for (uint i = 0; i < length; i++) {\r\n            allUserClaimableMgn[i] = calculateClaimableMgn(participationsByAddress[userAddress][i]);\r\n            allUserClaimableDeposit[i] = calculateClaimableDeposit(participationsByAddress[userAddress][i]);\r\n        }\r\n        return (allUserClaimableMgn, allUserClaimableDeposit);\r\n    }\r\n\r\n    /**\r\n     * Internal Helpers\r\n     */\r\n    \r\n    function calculatePoolShares(uint amount) private view returns (uint) {\r\n        if (totalDeposit == 0) {\r\n            return amount;\r\n        } else {\r\n            return totalPoolShares.mul(amount) / totalDeposit;\r\n        }\r\n    }\r\n    \r\n    function isDepositTokenTurn() private view returns (bool) {\r\n        return auctionCount % 2 == 0;\r\n    }\r\n\r\n    function calculateClaimableMgn(Participation memory participation) private view returns (uint) {\r\n        if (totalPoolSharesCummulative == 0) {\r\n            return 0;\r\n        }\r\n        uint duration = auctionCount - participation.startAuctionCount;\r\n        return totalMgn.mul(participation.poolShares).mul(duration) / totalPoolSharesCummulative;\r\n    }\r\n\r\n    function calculateClaimableDeposit(Participation memory participation) private view returns (uint) {\r\n        if (totalPoolShares == 0) {\r\n            return 0;\r\n        }\r\n        return totalDeposit.mul(participation.poolShares) / totalPoolShares;\r\n    }\r\n}\r\n\r\n// File: contracts/Coordinator.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\ncontract Coordinator {\r\n\r\n    DxMgnPool public dxMgnPool1;\r\n    DxMgnPool public dxMgnPool2;\r\n\r\n    constructor (\r\n        ERC20 _token1, \r\n        ERC20 _token2, \r\n        IDutchExchange _dx,\r\n        uint _poolingTime\r\n    ) public {\r\n        dxMgnPool1 = new DxMgnPool(_token1, _token2, _dx, _poolingTime);\r\n        dxMgnPool2 = new DxMgnPool(_token2, _token1, _dx, _poolingTime);\r\n    }\r\n\r\n    function participateInAuction() public {\r\n        dxMgnPool1.participateInAuction();\r\n        dxMgnPool2.participateInAuction();\r\n    }\r\n\r\n    function canParticipate() public returns (bool) {\r\n        uint auctionIndex = dxMgnPool1.dx().getAuctionIndex(\r\n            address(dxMgnPool1.depositToken()),\r\n            address(dxMgnPool1.secondaryToken())\r\n        );\r\n        // update the state before checking the currentState\r\n        dxMgnPool1.checkForStateUpdate();\r\n        // Since both auctions start at the same time, it suffices to check one.\r\n        return auctionIndex > dxMgnPool1.lastParticipatedAuctionIndex() && dxMgnPool1.currentState() == DxMgnPool.State.Pooling;\r\n    }\r\n\r\n    function withdrawMGNandDepositsFromBothPools() public {\r\n        address(dxMgnPool1).delegatecall(abi.encodeWithSignature(\"withdrawDeposit()\"));\r\n        address(dxMgnPool1).delegatecall(abi.encodeWithSignature(\"withdrawMagnolia()\"));\r\n\r\n        address(dxMgnPool2).delegatecall(abi.encodeWithSignature(\"withdrawDeposit()\"));\r\n        address(dxMgnPool2).delegatecall(abi.encodeWithSignature(\"withdrawMagnolia()\"));\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"currentState\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawDeposit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"sellAndBuyToken\",\"outputs\":[{\"name\":\"sellToken\",\"type\":\"address\"},{\"name\":\"buyToken\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"numberOfParticipations\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"auctionCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalPoolSharesCummulative\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"userAddress\",\"type\":\"address\"}],\"name\":\"poolSharesByAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawUnlockedMagnoliaFromDx\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalPoolShares\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"participationAtIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"userAddress\",\"type\":\"address\"}],\"name\":\"getAllClaimableMgnAndDeposits\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"},{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"triggerMGNunlockAndClaimTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"updateAndGetCurrentState\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"participationsByAddress\",\"outputs\":[{\"name\":\"startAuctionCount\",\"type\":\"uint256\"},{\"name\":\"poolShares\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"mgnToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"depositToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"dx\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawMagnolia\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"poolingPeriodEndTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"checkForStateUpdate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalMgn\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastParticipatedAuctionIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"participateInAuction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"secondaryToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalDeposit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_depositToken\",\"type\":\"address\"},{\"name\":\"_secondaryToken\",\"type\":\"address\"},{\"name\":\"_dx\",\"type\":\"address\"},{\"name\":\"_poolingTimeSeconds\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"DxMgnPool","CompilerVersion":"v0.5.2+commit.1df8f40c","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2000000000000000000000000255aa6df07540cb5d3d297f0d0d4d84cb52bc8e6000000000000000000000000b9812e2fa995ec53b5b6df34d21f9304762c54970000000000000000000000000000000000000000000000000000000000093a80","Library":"","SwarmSource":"bzzr://205a6067981d9728a3cc88734225054f4f9bbc4b85e44055bfc38ec59540102c"}]}