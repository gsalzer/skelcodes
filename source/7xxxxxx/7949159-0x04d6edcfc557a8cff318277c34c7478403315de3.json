{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.5.9;\r\n\r\n\r\n/**\r\n * https://rekt.fyi\r\n *\r\n * Mock the performance of your friend's ETH stack by sending them a REKT token, and add a bounty to it.\r\n *\r\n * REKT tokens are non-transferrable. Holders can only burn the token and collect the bounty once their\r\n * ETH balance is m times higher or their ETH is worth m times more in USD than when they received the\r\n * token, where m is a multiplier value set by users.\r\n *\r\n * copyright 2019 rekt.fyi\r\n *\r\n * This program is free software: you can redistribute it and/or modify\r\n * it under the terms of the GNU General Public License as published by\r\n * the Free Software Foundation, either version 3 of the License, or\r\n * (at your option) any later version.\r\n *\r\n * This program is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU General Public License\r\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n */\r\n\r\n\r\n/**\r\n * Libraries\r\n */\r\n\r\n/// math.sol -- mixin for inline numerical wizardry\r\n\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\nlibrary DSMath {\r\n    function add(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x + y) >= x);\r\n    }\r\n    function sub(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x - y) <= x);\r\n    }\r\n    function mul(uint x, uint y) internal pure returns (uint z) {\r\n        require(y == 0 || (z = x * y) / y == x);\r\n    }\r\n\r\n    function min(uint x, uint y) internal pure returns (uint z) {\r\n        return x <= y ? x : y;\r\n    }\r\n    function max(uint x, uint y) internal pure returns (uint z) {\r\n        return x >= y ? x : y;\r\n    }\r\n    function imin(int x, int y) internal pure returns (int z) {\r\n        return x <= y ? x : y;\r\n    }\r\n    function imax(int x, int y) internal pure returns (int z) {\r\n        return x >= y ? x : y;\r\n    }\r\n\r\n    uint constant WAD = 10 ** 18;\r\n    uint constant RAY = 10 ** 27;\r\n\r\n    function wmul(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, y), WAD / 2) / WAD;\r\n    }\r\n    function rmul(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, y), RAY / 2) / RAY;\r\n    }\r\n    function wdiv(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, WAD), y / 2) / y;\r\n    }\r\n    function rdiv(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, RAY), y / 2) / y;\r\n    }\r\n\r\n    // This famous algorithm is called \"exponentiation by squaring\"\r\n    // and calculates x^n with x as fixed-point and n as regular unsigned.\r\n    //\r\n    // It's O(log n), instead of O(n) for naive repeated multiplication.\r\n    //\r\n    // These facts are why it works:\r\n    //\r\n    //  If n is even, then x^n = (x^2)^(n/2).\r\n    //  If n is odd,  then x^n = x * x^(n-1),\r\n    //   and applying the equation for even x gives\r\n    //    x^n = x * (x^2)^((n-1) / 2).\r\n    //\r\n    //  Also, EVM division is flooring and\r\n    //    floor[(n-1) / 2] = floor[n / 2].\r\n    //\r\n    function rpow(uint x, uint n) internal pure returns (uint z) {\r\n        z = n % 2 != 0 ? x : RAY;\r\n\r\n        for (n /= 2; n != 0; n /= 2) {\r\n            x = rmul(x, x);\r\n\r\n            if (n % 2 != 0) {\r\n                z = rmul(z, x);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * External Contracts\r\n */\r\n\r\ncontract Medianizer {\r\n    function peek() public view returns (bytes32, bool) {}\r\n}\r\n\r\ncontract Dai {\r\n     function transferFrom(address src, address dst, uint wad) public returns (bool) {}\r\n}\r\n\r\n\r\n/**\r\n * Contracts\r\n */\r\n\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n    address public owner;\r\n\r\n\r\n    event OwnershipRenounced(address indexed previousOwner);\r\n    event OwnershipTransferred(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n\r\n\r\n    /**\r\n    * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n    * account.\r\n    */\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    /**\r\n    * @dev Throws if called by any account other than the owner.\r\n    */\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev Allows the current owner to relinquish control of the contract.\r\n    * @notice Renouncing to ownership will leave the contract without an owner.\r\n    * It will not be possible to call the functions with the `onlyOwner`\r\n    * modifier anymore.\r\n    */\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipRenounced(owner);\r\n        owner = address(0);\r\n    }\r\n\r\n    /**\r\n    * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n    * @param _newOwner The address to transfer ownership to.\r\n    */\r\n    function transferOwnership(address _newOwner) public onlyOwner {\r\n        _transferOwnership(_newOwner);\r\n    }\r\n\r\n    /**\r\n    * @dev Transfers control of the contract to a newOwner.\r\n    * @param _newOwner The address to transfer ownership to.\r\n    */\r\n    function _transferOwnership(address _newOwner) internal {\r\n        require(_newOwner != address(0));\r\n        emit OwnershipTransferred(owner, _newOwner);\r\n        owner = _newOwner;\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @title https://rekt.fyi\r\n * @notice Mock the performance of your friend's ETH stack by sending them a REKT token, and add a bounty to it.\r\n *\r\n * REKT tokens are non-transferrable. Holders can only burn the token and collect the bounty once their\r\n * ETH balance is m times higher or their ETH is worth m times more in USD than when they received the\r\n * token, where m is a multiplier value set by users.\r\n */\r\ncontract RektFyi is Ownable {\r\n\r\n    using DSMath for uint;\r\n\r\n    /**\r\n     * Storage\r\n     */\r\n\r\n    struct Receiver {\r\n        uint walletBalance;\r\n        uint bountyETH;\r\n        uint bountyDAI;\r\n        uint timestamp;\r\n        uint etherPrice;\r\n        address payable sender;\r\n    }\r\n\r\n    struct Vault {\r\n        uint fee;\r\n        uint bountyETH;\r\n        uint bountySAI; // DAI bounty sent here before the switch to MCD\r\n        uint bountyDAI; // DAI bounty sent here after the switch to MCD\r\n    }\r\n\r\n    struct Pot {\r\n        uint ETH;\r\n        uint DAI;\r\n    }\r\n\r\n\r\n    mapping(address => Receiver) public receiver;\r\n    mapping(address => uint) public balance;\r\n    mapping(address => address[]) private recipients;\r\n    mapping(address => Pot) public unredeemedBounty;\r\n    mapping(address => Vault) public vault;\r\n    Pot public bountyPot = Pot(0,0);\r\n    uint public feePot = 0;\r\n\r\n    bool public shutdown = false;\r\n    uint public totalSupply = 0;\r\n    uint public multiplier = 1300000000000000000; // 1.3x to start\r\n    uint public bumpBasePrice = 10000000000000000; // 0.01 ETH\r\n    uint public holdTimeCeiling = 3628800; // 6 weeks in seconds\r\n\r\n    address public medianizerAddress;\r\n    Medianizer oracle;\r\n\r\n    bool public isMCD = false;\r\n    uint public MCDswitchTimestamp = 0;\r\n    address public saiAddress;\r\n    address public daiAddress;\r\n\r\n    Dai dai;\r\n    Dai sai;\r\n\r\n\r\n    constructor(address _medianizerAddress, address _saiAddress) public {\r\n        medianizerAddress = _medianizerAddress;\r\n        oracle = Medianizer(medianizerAddress);\r\n\r\n        saiAddress = _saiAddress;\r\n        dai = Dai(saiAddress);\r\n        sai = dai;\r\n    }\r\n\r\n\r\n    /**\r\n     * Constants\r\n     */\r\n\r\n    string public constant name = \"REKT.fyi\";\r\n    string public constant symbol = \"REKT\";\r\n    uint8 public constant decimals = 0;\r\n\r\n    uint public constant WAD = 1000000000000000000;\r\n    uint public constant PRECISION = 100000000000000; // 4 orders of magnitude / decimal places\r\n    uint public constant MULTIPLIER_FLOOR = 1000000000000000000; // 1x\r\n    uint public constant MULTIPLIER_CEILING = 10000000000000000000; // 10x\r\n    uint public constant BONUS_FLOOR = 1250000000000000000; //1.25x \r\n    uint public constant BONUS_CEILING = 1800000000000000000; //1.8x\r\n    uint public constant BOUNTY_BONUS_MINIMUM = 5000000000000000000; // $5\r\n    uint public constant HOLD_SCORE_CEILING = 1000000000000000000000000000; // 1 RAY\r\n    uint public constant BUMP_INCREMENT = 100000000000000000; // 0.1x\r\n    uint public constant HOLD_TIME_MAX = 23670000; // 9 months is the maximum the owner can set with setHoldTimeCeiling(uint)\r\n    uint public constant BUMP_PRICE_MAX = 100000000000000000; //0.1 ETH is the maximum the owner can set with setBumpPrice(uint)\r\n\r\n\r\n    /**\r\n     * Events\r\n     */\r\n\r\n    event LogVaultDeposit(address indexed addr, string indexed potType, uint value);\r\n    event LogWithdraw(address indexed to, uint eth, uint sai, uint dai);\r\n    event Transfer(address indexed from, address indexed to, uint tokens);\r\n    event LogBump(uint indexed from, uint indexed to, uint cost, address indexed by);\r\n    event LogBurn(\r\n        address indexed sender,\r\n        address indexed receiver,\r\n        uint receivedAt,\r\n        uint multiplier,\r\n        uint initialETH,\r\n        uint etherPrice,\r\n        uint bountyETH,\r\n        uint bountyDAI,\r\n        uint reward\r\n        );\r\n    event LogGive(address indexed sender, address indexed receiver);\r\n\r\n\r\n    /**\r\n     * Modifiers\r\n     */\r\n\r\n    modifier shutdownNotActive() {\r\n        require(shutdown == false, \"shutdown activated\");\r\n        _;\r\n    }\r\n\r\n\r\n    modifier giveRequirementsMet(address _to) {\r\n        require(address(_to) != address(0), \"Invalid address\");\r\n        require(_to != msg.sender, \"Cannot give to yourself\");\r\n        require(balanceOf(_to) == 0, \"Receiver already has a token\");\r\n        require(_to.balance > 0, \"Receiver wallet must not be empty\");\r\n        _;\r\n    }\r\n\r\n\r\n    /**\r\n     * External functions\r\n     */\r\n\r\n    /// @notice Give somebody a REKT token, along with an optional bounty in ether.\r\n    /// @param _to The address to send the REKT token to.\r\n    function give(address _to) external payable shutdownNotActive giveRequirementsMet(_to) {\r\n        if (msg.value > 0) {\r\n            unredeemedBounty[msg.sender].ETH = unredeemedBounty[msg.sender].ETH.add(msg.value);\r\n            bountyPot.ETH = bountyPot.ETH.add(msg.value);\r\n        }\r\n        receiver[_to] = Receiver(_to.balance, msg.value, 0, now, getPrice(), msg.sender);\r\n        giveCommon(_to);\r\n    }\r\n\r\n\r\n    /// @notice Give somebody a REKT token, along with an option bounty in DAI.\r\n    /// @param _to The account to send the REKT token to.\r\n    /// @param _amount The amount of DAI to use as a bounty.\r\n    function giveWithDAI(address _to, uint _amount) external shutdownNotActive giveRequirementsMet(_to) {\r\n        if (_amount > 0) {\r\n            // If the switch has already been included in this block then MCD is active,\r\n            // but we won't be able to tell later if that's the case so block this tx.\r\n            // Its ok for the mcd switch to occur later than this function in the same block\r\n            require(MCDswitchTimestamp != now, \"Cannot send DAI during the switching block\");\r\n            require(dai.transferFrom(msg.sender, address(this), _amount), \"DAI transfer failed\");\r\n            unredeemedBounty[msg.sender].DAI = unredeemedBounty[msg.sender].DAI.add(_amount);\r\n            bountyPot.DAI = bountyPot.DAI.add(_amount);\r\n        }\r\n        receiver[_to] = Receiver(_to.balance, 0, _amount, now, getPrice(), msg.sender);\r\n        giveCommon(_to);\r\n    }\r\n\r\n\r\n    /// @notice Bump the multiplier up or down.\r\n    /// @dev Multiplier has PRECISION precision and is rounded down unless the unrounded\r\n    /// value hits the MULTIPLIER_CEILING or MULTIPLIER_FLOOR.\r\n    /// @param _up Boolean representing whether the direction of the bump is up or not.\r\n    function bump(bool _up) external payable shutdownNotActive {\r\n        require(msg.value > 0, \"Ether required\");\r\n        uint initialMultiplier = multiplier;\r\n\r\n        // amount = (value/price)*bonus*increment\r\n        uint bumpAmount = msg.value\r\n            .wdiv(bumpBasePrice)\r\n            .wmul(getBonusMultiplier(msg.sender))\r\n            .wmul(BUMP_INCREMENT);\r\n\r\n        if (_up) {\r\n            if (multiplier.add(bumpAmount) >= MULTIPLIER_CEILING) {\r\n                multiplier = MULTIPLIER_CEILING;\r\n            } else {\r\n                multiplier = multiplier.add(roundBumpAmount(bumpAmount));\r\n            }\r\n        }\r\n        else {\r\n            if (multiplier > bumpAmount) {\r\n                if (multiplier.sub(bumpAmount) <= MULTIPLIER_FLOOR) {\r\n                    multiplier = MULTIPLIER_FLOOR;\r\n                } else {\r\n                    multiplier = multiplier.sub(roundBumpAmount(bumpAmount));\r\n                }\r\n            }\r\n            else {\r\n                multiplier = MULTIPLIER_FLOOR;\r\n            }\r\n        }\r\n\r\n        emit LogBump(initialMultiplier, multiplier, msg.value, msg.sender);\r\n        feePot = feePot.add(msg.value);\r\n    }\r\n\r\n\r\n    /// @notice Burn a REKT token. If applicable, fee reward and bounty are sent to user's pots.\r\n    /// REKT tokens can only be burned if the receiver has made gains >= the multiplier\r\n    /// (unless we are in shutdown mode).\r\n    /// @param _receiver The account that currently holds the REKT token.\r\n    function burn(address _receiver) external {\r\n        require(balanceOf(_receiver) == 1, \"Nothing to burn\");\r\n        address sender = receiver[_receiver].sender;\r\n        require(\r\n            msg.sender == _receiver ||\r\n            msg.sender == sender ||\r\n            (_receiver == address(this) && msg.sender == owner),\r\n            \"Must be token sender or receiver, or must be the owner burning REKT sent to the contract\"\r\n            );\r\n\r\n        if (!shutdown) {\r\n            if (receiver[_receiver].walletBalance.wmul(multiplier) > _receiver.balance) {\r\n                uint balanceValueThen = receiver[_receiver].walletBalance.wmul(receiver[_receiver].etherPrice);\r\n                uint balanceValueNow = _receiver.balance.wmul(getPrice());\r\n                if (balanceValueThen.wmul(multiplier) > balanceValueNow) {\r\n                    revert(\"Not enough gains\");\r\n                }\r\n            }\r\n        }\r\n\r\n        balance[_receiver] = 0;\r\n        totalSupply --;\r\n        \r\n        emit Transfer(_receiver, address(0), 1);\r\n\r\n        uint feeReward = distributeBurnRewards(_receiver, sender);\r\n\r\n        emit LogBurn(\r\n            sender,\r\n            _receiver,\r\n            receiver[_receiver].timestamp,\r\n            multiplier,\r\n            receiver[_receiver].walletBalance,\r\n            receiver[_receiver].etherPrice,\r\n            receiver[_receiver].bountyETH,\r\n            receiver[_receiver].bountyDAI,\r\n            feeReward);\r\n    }\r\n\r\n\r\n    /// @notice Withdrawal of fee reward, DAI, SAI & ETH bounties for the user.\r\n    /// @param _addr The account to receive the funds and whose vault the funds will be taken from.\r\n    function withdraw(address payable _addr) external {\r\n        require(_addr != address(this), \"This contract cannot withdraw to itself\");\r\n        withdrawCommon(_addr, _addr);\r\n    }\r\n\r\n\r\n    /// @notice Withdraw from the contract's personal vault should anyone send\r\n    /// REKT to REKT.fyi with a bounty.\r\n    /// @param _destination The account to receive the funds.\r\n    function withdrawSelf(address payable _destination) external onlyOwner {\r\n        withdrawCommon(_destination, address(this));\r\n    }\r\n\r\n\r\n    /// @dev Sets a new Medianizer address in case of MakerDAO upgrades.\r\n    /// @param _addr The new address.\r\n    function setNewMedianizer(address _addr) external onlyOwner {\r\n        require(address(_addr) != address(0), \"Invalid address\");\r\n        medianizerAddress = _addr;\r\n        oracle = Medianizer(medianizerAddress);\r\n        bytes32 price;\r\n        bool ok;\r\n        (price, ok) = oracle.peek();\r\n        require(ok, \"Pricefeed error\");\r\n    }\r\n\r\n\r\n    /// @notice Sets a new DAI token address when MakerDAO upgrades to multicollateral DAI.\r\n    /// @dev DAI will now be deposited into vault[user].bountyDAI for new bounties instead\r\n    /// of vault[user].bountySAI.\r\n    /// If setMCD(address) has been included in the block already, then a user will\r\n    /// not be able to give a SAI/DAI bounty later in this block.\r\n    /// We can then determine with certainty whether they sent SAI or DAI when the time\r\n    /// comes to distribute it to a user's vault.\r\n    /// New DAI token can only be set once;\r\n    /// further changes will require shutdown and redeployment.\r\n    /// @param _addr The new address.\r\n    function setMCD(address _addr) external onlyOwner {\r\n        require(!isMCD, \"MCD has already been set\");\r\n        require(address(_addr) != address(0), \"Invalid address\");\r\n        daiAddress = _addr;\r\n        dai = Dai(daiAddress);\r\n        isMCD = true;\r\n        MCDswitchTimestamp = now;\r\n    }\r\n\r\n\r\n    /// @dev Sets a new bump price up to BUMP_PRICE_MAX.\r\n    /// @param _amount The base price of bumping by BUMP_INCREMENT.\r\n    function setBumpPrice(uint _amount) external onlyOwner {\r\n        require(_amount > 0 && _amount <= BUMP_PRICE_MAX, \"Price must not be higher than BUMP_PRICE_MAX\");\r\n        bumpBasePrice = _amount;\r\n    }\r\n\r\n\r\n    /// @dev Sets a new hold time ceiling up to HOLD_TIME_MAX.\r\n    /// @param _seconds The maximum hold time in seconds before the holdscore becomes 1 RAY.\r\n    function setHoldTimeCeiling(uint _seconds) external onlyOwner {\r\n        require(_seconds > 0 && _seconds <= HOLD_TIME_MAX, \"Hold time must not be higher than HOLD_TIME_MAX\");\r\n        holdTimeCeiling = _seconds;\r\n    }\r\n    \r\n\r\n    /// @dev Permanent shutdown of the contract.\r\n    /// No one can give or bump, everyone can burn and withdraw.\r\n    function setShutdown() external onlyOwner {\r\n        shutdown = true;\r\n    }\r\n\r\n\r\n    /**\r\n     * Public functions\r\n     */\r\n\r\n    /// @dev The proportion of the value of this bounty in relation to\r\n    /// the value of all bounties in the system.\r\n    /// @param _bounty This bounty.\r\n    /// @return A uint representing the proportion of bounty as a RAY.\r\n    function calculateBountyProportion(uint _bounty) public view returns (uint) {\r\n        return _bounty.rdiv(potValue(bountyPot.DAI, bountyPot.ETH));\r\n    }\r\n\r\n\r\n    /// @dev A score <= 1 RAY that corresponds to a duration between 0 and HOLD_SCORE_CEILING.\r\n    /// @params _receivedAtTime The timestamp of the block where the user received the REKT token.\r\n    /// @return A uint representing the score as a RAY.\r\n    function calculateHoldScore(uint _receivedAtTime) public view returns (uint) {\r\n        if (now == _receivedAtTime)\r\n        {\r\n            return 0;\r\n        }\r\n        uint timeDiff = now.sub(_receivedAtTime);\r\n        uint holdScore = timeDiff.rdiv(holdTimeCeiling);\r\n        if (holdScore > HOLD_SCORE_CEILING) {\r\n            holdScore = HOLD_SCORE_CEILING;\r\n        }\r\n        return holdScore;\r\n    }\r\n\r\n\r\n    /// @notice Returns the REKT balance of the specified address.\r\n    /// @dev Effectively a bool because the balance can only be 0 or 1.\r\n    /// @param _owner The address to query the balance of.\r\n    /// @return A uint representing the amount owned by the passed address.\r\n    function balanceOf(address _receiver) public view returns (uint) {\r\n        return balance[_receiver];\r\n    }\r\n\r\n\r\n    /// @notice Returns the total value of _dai and _eth in USD. 1 DAI = $1 is assumed.\r\n    /// @dev Price of ether taken from MakerDAO's Medianizer via getPrice().\r\n    /// @param _dai DAI to use in calculation.\r\n    /// @param _eth Ether to use in calculation.\r\n    /// @return A uint representing the total value of the inputs.\r\n    function potValue(uint _dai, uint _eth) public view returns (uint) {\r\n        return _dai.add(_eth.wmul(getPrice()));\r\n    }\r\n\r\n\r\n    /// @dev Returns the bonus multiplier represented as a WAD.\r\n    /// @param _sender The address of the sender.\r\n    /// @return A uint representing the bonus multiplier as a WAD.\r\n    function getBonusMultiplier(address _sender) public view returns (uint) {\r\n        uint bounty = potValue(unredeemedBounty[_sender].DAI, unredeemedBounty[_sender].ETH);\r\n        uint bonus = WAD;\r\n        if (bounty >= BOUNTY_BONUS_MINIMUM) {\r\n            bonus = bounty.wdiv(potValue(bountyPot.DAI, bountyPot.ETH)).add(BONUS_FLOOR);\r\n            if (bonus > BONUS_CEILING) {\r\n                bonus = BONUS_CEILING;\r\n            }\r\n        }\r\n        return bonus;\r\n    }\r\n\r\n\r\n    /// @dev Returns the addresses the sender has sent to as an array.\r\n    /// @param _sender The address of the sender.\r\n    /// @return An array of recipient addresses.\r\n    function getRecipients(address _sender) public view returns (address[] memory) {\r\n        return recipients[_sender];\r\n    }\r\n\r\n\r\n    /// @dev Returns the price of ETH in USD as per the MakerDAO Medianizer interface.\r\n    /// @return A uint representing the price of ETH in USD as a WAD.\r\n    function getPrice() public view returns (uint) {\r\n        bytes32 price;\r\n        bool ok;\r\n        (price, ok) = oracle.peek();\r\n        require(ok, \"Pricefeed error\");\r\n        return uint(price);\r\n    }\r\n\r\n\r\n    /**\r\n     * Private functions\r\n     */\r\n\r\n    /// @dev Common functionality for give(address) and giveWithDAI(address, uint).\r\n    /// @param _to The account to send the REKT token to.\r\n    function giveCommon(address _to) private {\r\n        balance[_to] = 1;\r\n        recipients[msg.sender].push(_to);\r\n        totalSupply ++;\r\n        emit Transfer(address(0), msg.sender, 1);\r\n        emit Transfer(msg.sender, _to, 1);\r\n        emit LogGive(msg.sender, _to);\r\n    }\r\n\r\n\r\n    /// @dev Assigns rewards and bounties to pots within user vaults dependant on holdScore\r\n    /// and bounty proportion compared to the total bounties within the system.\r\n    /// @param _receiver The account that received the REKT token.\r\n    /// @param _sender The account that sent the REKT token.\r\n    /// @return A uint representing the fee reward.\r\n    function distributeBurnRewards(address _receiver, address _sender) private returns (uint feeReward) {\r\n\r\n        feeReward = 0;\r\n\r\n        uint bountyETH = receiver[_receiver].bountyETH;\r\n        uint bountyDAI = receiver[_receiver].bountyDAI;\r\n        uint bountyTotal = potValue(bountyDAI, bountyETH);\r\n\r\n        if (bountyTotal > 0 ) {\r\n            uint bountyProportion = calculateBountyProportion(bountyTotal);\r\n            uint userRewardPot = bountyProportion.rmul(feePot);\r\n\r\n            if (shutdown) {\r\n                // in the shutdown state the holdscore isn't used\r\n                feeReward = userRewardPot;\r\n            } else {\r\n                uint holdScore = calculateHoldScore(receiver[_receiver].timestamp);\r\n                feeReward = userRewardPot.rmul(holdScore);\r\n            }\r\n\r\n            if (bountyETH > 0) {\r\n                // subtract bounty from the senders's bounty total and the bounty pot\r\n                unredeemedBounty[_sender].ETH = unredeemedBounty[_sender].ETH.sub(bountyETH);\r\n                bountyPot.ETH = bountyPot.ETH.sub(bountyETH);\r\n\r\n                // add bounty to receivers vault\r\n                vault[_receiver].bountyETH = vault[_receiver].bountyETH.add(bountyETH);\r\n                emit LogVaultDeposit(_receiver, 'bountyETH', bountyETH);\r\n\r\n            } else if (bountyDAI > 0) {\r\n                unredeemedBounty[_sender].DAI = unredeemedBounty[_sender].DAI.sub(bountyDAI);\r\n                bountyPot.DAI = bountyPot.DAI.sub(bountyDAI);\r\n                if (isMCD && receiver[_receiver].timestamp > MCDswitchTimestamp) {\r\n                    vault[_receiver].bountyDAI = vault[_receiver].bountyDAI.add(bountyDAI);\r\n                } else { // they would have sent SAI\r\n                    vault[_receiver].bountySAI = vault[_receiver].bountySAI.add(bountyDAI);\r\n                }\r\n                emit LogVaultDeposit(_receiver, 'bountyDAI', bountyDAI);\r\n            }\r\n\r\n            if (feeReward > 0) {\r\n                feeReward = feeReward / 2;\r\n\r\n                // subtract and add feeReward for receiver vault\r\n                feePot = feePot.sub(feeReward);\r\n                vault[_receiver].fee = vault[_receiver].fee.add(feeReward);\r\n                emit LogVaultDeposit(_receiver, 'reward', feeReward);\r\n\r\n                // subtract and add feeReward for sender vault\r\n                feePot = feePot.sub(feeReward);\r\n                vault[_sender].fee = vault[_sender].fee.add(feeReward);\r\n                emit LogVaultDeposit(_sender, 'reward', feeReward);\r\n            }\r\n        }\r\n\r\n        return feeReward;\r\n    }\r\n\r\n\r\n    /// @dev Returns a rounded bump amount represented as a WAD.\r\n    /// @param _amount The amount to be rounded.\r\n    /// @return A uint representing the amount rounded to PRECISION as a WAD.\r\n    function roundBumpAmount(uint _amount) private pure returns (uint rounded) {\r\n        require(_amount >= PRECISION, \"bump size too small to round\");\r\n        return (_amount / PRECISION).mul(PRECISION);\r\n    }\r\n\r\n\r\n    /// @dev called by withdraw(address) and withdrawSelf(address) to withdraw\r\n    /// fee reward, DAI, SAI & ETH bounties.\r\n    /// Both params will be the same for a normal user withdrawal.\r\n    /// @param _destination The account to receive the funds.\r\n    /// @param _vaultOwner The vault that the funds will be taken from.\r\n    function withdrawCommon(address payable _destination, address _vaultOwner) private {\r\n        require(address(_destination) != address(0), \"Invalid address\");\r\n        uint amountETH = vault[_vaultOwner].fee.add(vault[_vaultOwner].bountyETH);\r\n        uint amountDAI = vault[_vaultOwner].bountyDAI;\r\n        uint amountSAI = vault[_vaultOwner].bountySAI;\r\n        vault[_vaultOwner] = Vault(0,0,0,0);\r\n        emit LogWithdraw(_destination, amountETH, amountSAI, amountDAI);\r\n        if (amountDAI > 0) {\r\n            require(dai.transferFrom(address(this), _destination, amountDAI), \"DAI transfer failed\");\r\n        }\r\n        if (amountSAI > 0) {\r\n            require(sai.transferFrom(address(this), _destination, amountSAI), \"SAI transfer failed\");\r\n        }\r\n        if (amountETH > 0) {\r\n            _destination.transfer(amountETH);\r\n        }\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"bumpBasePrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"BOUNTY_BONUS_MINIMUM\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MULTIPLIER_FLOOR\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"holdTimeCeiling\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"multiplier\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"setShutdown\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_bounty\",\"type\":\"uint256\"}],\"name\":\"calculateBountyProportion\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_sender\",\"type\":\"address\"}],\"name\":\"getRecipients\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"HOLD_SCORE_CEILING\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"daiAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bountyPot\",\"outputs\":[{\"name\":\"ETH\",\"type\":\"uint256\"},{\"name\":\"DAI\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"setNewMedianizer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"feePot\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"giveWithDAI\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_destination\",\"type\":\"address\"}],\"name\":\"withdrawSelf\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isMCD\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"WAD\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"BUMP_INCREMENT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_receiver\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_receiver\",\"type\":\"address\"}],\"name\":\"burn\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"BONUS_CEILING\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_up\",\"type\":\"bool\"}],\"name\":\"bump\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"saiAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_receivedAtTime\",\"type\":\"uint256\"}],\"name\":\"calculateHoldScore\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"receiver\",\"outputs\":[{\"name\":\"walletBalance\",\"type\":\"uint256\"},{\"name\":\"bountyETH\",\"type\":\"uint256\"},{\"name\":\"bountyDAI\",\"type\":\"uint256\"},{\"name\":\"timestamp\",\"type\":\"uint256\"},{\"name\":\"etherPrice\",\"type\":\"uint256\"},{\"name\":\"sender\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_dai\",\"type\":\"uint256\"},{\"name\":\"_eth\",\"type\":\"uint256\"}],\"name\":\"potValue\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"BONUS_FLOOR\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"PRECISION\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"HOLD_TIME_MAX\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MCDswitchTimestamp\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"give\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_seconds\",\"type\":\"uint256\"}],\"name\":\"setHoldTimeCeiling\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MULTIPLIER_CEILING\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"unredeemedBounty\",\"outputs\":[{\"name\":\"ETH\",\"type\":\"uint256\"},{\"name\":\"DAI\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_sender\",\"type\":\"address\"}],\"name\":\"getBonusMultiplier\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"setBumpPrice\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"BUMP_PRICE_MAX\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"balance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"setMCD\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"vault\",\"outputs\":[{\"name\":\"fee\",\"type\":\"uint256\"},{\"name\":\"bountyETH\",\"type\":\"uint256\"},{\"name\":\"bountySAI\",\"type\":\"uint256\"},{\"name\":\"bountyDAI\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"shutdown\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"medianizerAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_medianizerAddress\",\"type\":\"address\"},{\"name\":\"_saiAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"potType\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"LogVaultDeposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"eth\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"sai\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"dai\",\"type\":\"uint256\"}],\"name\":\"LogWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"cost\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"by\",\"type\":\"address\"}],\"name\":\"LogBump\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"receivedAt\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"multiplier\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"initialETH\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"etherPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"bountyETH\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"bountyDAI\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"reward\",\"type\":\"uint256\"}],\"name\":\"LogBurn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"LogGive\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"}],\"name\":\"OwnershipRenounced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"RektFyi","CompilerVersion":"v0.5.9+commit.e560f70d","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000729d19f657bd0614b4985cf1d82531c67569197b00000000000000000000000089d24a6b4ccb1b6faa2625fe562bdd9a23260359","Library":"","SwarmSource":"bzzr://10e10582644e9e1f5bd089d29d404e9b4771404d03af87d038eb978f4e12231d"}]}