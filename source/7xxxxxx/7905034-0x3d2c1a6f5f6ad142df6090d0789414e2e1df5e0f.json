{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n// pragma experimental ABIEncoderV2;\r\n\r\ninterface CitizenInterface {\r\n    function addEarlyIncome(address _sender) external payable;\r\n    function pushTicketRefIncome(address _sender) external payable;\r\n    function addTicketEthSpend(address _citizen, uint256 _value) external payable;\r\n    function addWinIncome(address _citizen, uint256 _value) external;\r\n    function pushEarlyIncome() external payable;\r\n    function getRef(address _address) external view returns(address);\r\n    function isCitizen(address _address) external view returns(bool);\r\n}\r\n\r\ninterface DAAInterface {\r\n    function pushDividend() external payable;\r\n}\r\n\r\nlibrary SafeMath {\r\n    int256 constant private INT256_MIN = -2**255;\r\n\r\n    /**\r\n    * @dev Multiplies two unsigned integers, reverts on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Multiplies two signed integers, reverts on overflow.\r\n    */\r\n    function mul(int256 a, int256 b) internal pure returns (int256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        require(!(a == -1 && b == INT256_MIN)); // This is the only case of overflow not detected by the check below\r\n\r\n        int256 c = a * b;\r\n        require(c / a == b);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two signed integers truncating the quotient, reverts on division by zero.\r\n    */\r\n    function div(int256 a, int256 b) internal pure returns (int256) {\r\n        require(b != 0); // Solidity only automatically asserts when dividing by 0\r\n        require(!(b == -1 && a == INT256_MIN)); // This is the only case of overflow\r\n\r\n        int256 c = a / b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two signed integers, reverts on overflow.\r\n    */\r\n    function sub(int256 a, int256 b) internal pure returns (int256) {\r\n        int256 c = a - b;\r\n        require((b >= 0 && c <= a) || (b < 0 && c > a));\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two unsigned integers, reverts on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two signed integers, reverts on overflow.\r\n    */\r\n    function add(int256 a, int256 b) internal pure returns (int256) {\r\n        int256 c = a + b;\r\n        require((b >= 0 && c >= a) || (b < 0 && c < a));\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\r\n    * reverts when dividing by zero.\r\n    */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n\r\nlibrary Helper {\r\n    using SafeMath for uint256;\r\n    \r\n        \r\n    function bytes32ToUint(bytes32 n) \r\n        public\r\n        pure\r\n        returns (uint256) \r\n    {\r\n        return uint256(n);\r\n    }\r\n    \r\n    function stringToBytes32(string memory source) \r\n        public\r\n        pure\r\n        returns (bytes32 result) \r\n    {\r\n        bytes memory tempEmptyStringTest = bytes(source);\r\n        if (tempEmptyStringTest.length == 0) {\r\n            return 0x0;\r\n        }\r\n\r\n        assembly {\r\n            result := mload(add(source, 32))\r\n        }\r\n    }\r\n    \r\n    function stringToUint(string memory source) \r\n        public\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return bytes32ToUint(stringToBytes32(source));\r\n    }\r\n    \r\n    function validUsername(string _username)\r\n        public\r\n        pure\r\n        returns(bool)\r\n    {\r\n        uint256 len = bytes(_username).length;\r\n        // Im Raum [4, 18]\r\n        if ((len < 4) || (len > 18)) return false;\r\n        // Letzte Char != ' '\r\n        if (bytes(_username)[len-1] == 32) return false;\r\n        // Erste Char != '0'\r\n        return uint256(bytes(_username)[0]) != 48;\r\n    }   \r\n    \r\n    function getRandom(uint256 _seed, uint256 _range)\r\n        public\r\n        pure\r\n        returns(uint256)\r\n    {\r\n        if (_range == 0) return _seed;\r\n        return (_seed % _range) + 1;\r\n    }\r\n\r\n}\r\n\r\ncontract Ticket {\r\n    using SafeMath for uint256;\r\n    \r\n    modifier buyable() {\r\n        require(block.timestamp > round[currentRound].startRound, \"Not start, back later please\");\r\n        require(block.timestamp < round[currentRound].endRoundByClock1&&(round[currentRound].endRoundByClock2==0 ||block.timestamp < round[currentRound].endRoundByClock2), \"round over\");\r\n        _;\r\n    }\r\n    \r\n    modifier onlyAdmin() {\r\n        require(msg.sender == devTeam1, \"admin required\");\r\n        _;\r\n    }\r\n    \r\n    modifier registered(){\r\n        require(citizenContract.isCitizen(msg.sender), \"must be a citizen\");\r\n        _;\r\n    }\r\n        \r\n    modifier onlyCoreContract() {\r\n        require(isCoreContract[msg.sender], \"admin required\");\r\n        _;\r\n    }\r\n    \r\n    event BuyATicket(\r\n        address indexed buyer,\r\n        uint256 ticketFrom,\r\n        uint256 ticketTo,\r\n        uint256 creationDate\r\n    );\r\n\r\n    address devTeam1;\r\n    address devTeam2;\r\n    address devTeam3;\r\n    address devTeam4;\r\n    \r\n    uint256 TICKET_PRICE = 2*10**15; // 3 demical 0.002\r\n    \r\n    uint256 constant public ZOOM = 1000;\r\n    uint256 constant public PBASE = 24;\r\n    uint256 constant public RDIVIDER = 50000;\r\n    uint256 constant public PMULTI = 48;\r\n    \r\n    // percent\r\n    uint256 constant public EARLY_PERCENT = 20;\r\n    uint256 constant public EARLY_PERCENT_FOR_CURRENT = 70;\r\n    uint256 constant public EARLY_PERCENT_FOR_PREVIOUS = 30;\r\n    uint256 constant public REVENUE_PERCENT = 17;\r\n    uint256 constant public DEV_PERCENT = 3;\r\n    uint256 constant public DIVIDEND_PERCENT = 10;\r\n    uint256 constant public REWARD_PERCENT = 50;\r\n    \r\n    //  reward part\r\n    uint256 constant public LAST_BUY_PERCENT = 20;\r\n    uint8[6] public JACKPOT_PERCENT = [uint8(25),5,5,5,5,5];\r\n    uint256 constant public MOST_SPENDER_PERCENT = 5;\r\n    uint256 constant public MOST_F1_EARNED_PERCENT = 4;\r\n    uint8[5] public DRAW_PERCENT = [uint8(6),1,1,1,1]; // 3 demicel 0.2%\r\n    uint256 constant public NEXTROUND_PERCENT = 20;\r\n    \r\n    uint256 constant public F1_LIMIT = 1 ether;\r\n    \r\n    // clock\r\n    uint8 constant public MULTI_TICKET = 3;\r\n    uint256 constant public LIMMIT_CLOCK_2_ETH = 300 ether;\r\n    uint256 constant public ONE_MIN = 60;\r\n    uint256 constant public ONE_HOUR = 3600; \r\n    uint256 constant public ONE_DAY = 24 * ONE_HOUR;\r\n    \r\n    // contract\r\n    CitizenInterface public citizenContract;\r\n    DAAInterface public DAAContract;\r\n    mapping (address => bool) public isCoreContract;\r\n    uint256 public coreContractSum;\r\n    address[] public coreContracts;\r\n    \r\n    struct Round {\r\n        uint256 priviousTicketSum;\r\n        uint256 ticketSum;\r\n        uint256 totalEth;\r\n        uint256 totalEthRoundSpend;\r\n\r\n        address[] participant;\r\n        mapping(address => uint256) participantTicketAmount;\r\n        mapping(address => uint256) citizenTicketSpend;\r\n        mapping(address => uint256) RefF1Sum;\r\n        mapping(uint256 => Slot) ticketSlot; // from 1\r\n        uint256 ticketSlotSum;              // last\r\n        mapping( address => uint256[]) pSlot;\r\n        \r\n        uint256 earlyIncomeMarkSum;\r\n        mapping(address => uint256) earlyIncomeMark;\r\n        \r\n        uint256 startRound;\r\n        uint256 endRoundByClock1;\r\n        uint256 endRoundByClock2;\r\n        uint256 endRound;\r\n        uint8 numberClaimed;\r\n        \r\n        \r\n        bool is_running_clock2;\r\n    }\r\n    uint256 public totalEthSpendTicket;\r\n    uint256 public ticketSum;\r\n    mapping(address => uint256) public ticketSumByAddress;\r\n    mapping(uint256=> Round) public round;\r\n    uint256 public currentRound=0;\r\n    mapping(address => uint256) earlyIncomeRoundPulled;\r\n    address[4] mostSpender;\r\n    address[4] mostF1Earnerd;\r\n    mapping(address => uint256) mostF1EarnerdId;\r\n    mapping(address => uint256) mostSpenderId;\r\n    mapping(uint256 => address[])  roundWinner;\r\n        \r\n    struct Slot {\r\n        address buyer;\r\n        uint256 ticketFrom;\r\n        uint256 ticketTo;\r\n    }\r\n    \r\n    \r\n\r\n    constructor (address[4] _devTeam)\r\n        public\r\n    {\r\n        devTeam1 = _devTeam[0]; \r\n        devTeam2 = _devTeam[1]; \r\n        devTeam3 = _devTeam[2]; \r\n        devTeam4 = _devTeam[3]; \r\n        currentRound=0;\r\n        round[currentRound].startRound = 1560693600;\r\n        round[currentRound].endRoundByClock1 = round[currentRound].startRound.add(48*ONE_HOUR);\r\n        round[currentRound].endRound = round[currentRound].endRoundByClock1;\r\n    }\r\n    \r\n       // DAAContract, TicketContract, CitizenContract \r\n    function joinNetwork(address[3] _contract)\r\n        public\r\n    {\r\n        require(address(citizenContract) == 0x0,\"already setup\");\r\n        citizenContract = CitizenInterface(_contract[2]);\r\n        DAAContract = DAAInterface(_contract[0]);\r\n        for(uint256 i =0; i<3; i++){\r\n            isCoreContract[_contract[i]]=true;\r\n            coreContracts.push(_contract[i]);\r\n        }\r\n        coreContractSum = 3;\r\n    }\r\n    \r\n    function addCoreContract(address _address) public  // [dev1]\r\n        onlyAdmin()\r\n    {\r\n        require(_address!=0x0,\"Invalid address\");\r\n        isCoreContract[_address] = true;\r\n        coreContracts.push(_address);\r\n        coreContractSum+=1;\r\n    }\r\n    \r\n    function getRestHour() private view returns(uint256){\r\n        uint256 tempCurrentRound;\r\n        if (now>round[currentRound].startRound){\r\n            tempCurrentRound=currentRound;\r\n        }\r\n        else{\r\n            tempCurrentRound=currentRound-1;\r\n        }\r\n        if (now>round[tempCurrentRound].endRound) return 0;\r\n        return round[tempCurrentRound].endRound.sub(now);\r\n    }\r\n    \r\n    function getRestHourClock2() private view returns(uint256){\r\n        if (round[currentRound].is_running_clock2){\r\n            if ((round[currentRound].endRoundByClock2.sub(now)).div(ONE_HOUR)>0){\r\n                return (round[currentRound].endRoundByClock2.sub(now)).div(ONE_HOUR);\r\n            }\r\n            return 0;\r\n        }\r\n        return 48;\r\n    }\r\n    \r\n    function getTicketPrice() public view returns(uint256){\r\n        if (round[currentRound].is_running_clock2){\r\n            return TICKET_PRICE + TICKET_PRICE*(50-getRestHourClock2())*4/100;\r\n        }\r\n        return TICKET_PRICE;\r\n    }\r\n    \r\n    function softMostF1(address _ref) private {\r\n        uint256 citizen_spender = round[currentRound].RefF1Sum[_ref];\r\n        uint256 i=1;\r\n        while (i<4) {\r\n            if (mostF1Earnerd[i]==0x0||(mostF1Earnerd[i]!=0x0&&round[currentRound].RefF1Sum[mostF1Earnerd[i]]<citizen_spender)){\r\n                if (mostF1EarnerdId[_ref]!=0&&mostF1EarnerdId[_ref]<i){\r\n                    break;\r\n                }\r\n                if (mostF1EarnerdId[_ref]!=0){\r\n                    mostF1Earnerd[mostF1EarnerdId[_ref]]=0x0;\r\n                }\r\n                address temp1 = mostF1Earnerd[i];\r\n                address temp2;\r\n                uint256 j=i+1;\r\n                while (j<4&&temp1!=0x0){\r\n                    temp2 = mostF1Earnerd[j];\r\n                    mostF1Earnerd[j]=temp1;\r\n                    mostF1EarnerdId[temp1]=j;\r\n                    temp1 = temp2;\r\n                    j++;\r\n                }\r\n                mostF1Earnerd[i]=_ref;\r\n                mostF1EarnerdId[_ref]=i;\r\n                break;\r\n            }\r\n            i++;\r\n        }\r\n    } \r\n    \r\n\r\n    function softMostSpender(address _ref) private {\r\n        uint256 citizen_spender = round[currentRound].citizenTicketSpend[_ref];\r\n        uint256 i=1;\r\n        while (i<4) {\r\n            if (mostSpender[i]==0x0||(mostSpender[i]!=0x0&&round[currentRound].citizenTicketSpend[mostSpender[i]]<citizen_spender)){\r\n                if (mostSpenderId[_ref]!=0&&mostSpenderId[_ref]<i){\r\n                    break;\r\n                }\r\n                if (mostSpenderId[_ref]!=0){\r\n                    mostSpender[mostSpenderId[_ref]]=0x0;\r\n                }\r\n                address temp1 = mostSpender[i];\r\n                address temp2;\r\n                uint256 j=i+1;\r\n                while (j<4&&temp1!=0x0){\r\n                    temp2 = mostSpender[j];\r\n                    mostSpender[j]=temp1;\r\n                    mostSpenderId[temp1]=j;\r\n                    temp1 = temp2;\r\n                    j++;\r\n                }\r\n                mostSpender[i]=_ref;\r\n                mostSpenderId[_ref]=i;\r\n                break;\r\n            }\r\n            i++;\r\n        }\r\n    } \r\n    \r\n    function addTicketEthSpend(address _sender,uint256 _value) private{\r\n        citizenContract.addTicketEthSpend(_sender,_value);\r\n        \r\n        address refAdress = citizenContract.getRef(_sender);\r\n        if (refAdress != devTeam3 && round[currentRound].citizenTicketSpend[_sender]<F1_LIMIT){ // devTeam3 cannot receiver this arward.\r\n            uint256 valueFromF1;\r\n            \r\n            //  limmit at 1 ether\r\n            if (round[currentRound].citizenTicketSpend[_sender].add(_value)>F1_LIMIT){\r\n                uint256 temp = round[currentRound].citizenTicketSpend[_sender].add(_value).sub(F1_LIMIT);\r\n                valueFromF1 = _value.sub(temp);\r\n            } else {\r\n                valueFromF1 = _value;\r\n            }\r\n            \r\n            // sum f1 deposit\r\n            round[currentRound].RefF1Sum[refAdress] = round[currentRound].RefF1Sum[refAdress].add(valueFromF1);\r\n            \r\n            //  find max mostF1Earnerd\r\n            softMostF1(refAdress);\r\n            \r\n        }\r\n        \r\n        round[currentRound].citizenTicketSpend[_sender] = round[currentRound].citizenTicketSpend[_sender].add(_value);\r\n        \r\n        // find max mostSpender\r\n        softMostSpender(_sender);\r\n        \r\n        // calculate total\r\n        totalEthSpendTicket = totalEthSpendTicket.add(_value);\r\n    }\r\n    \r\n    \r\n    function isAddressTicket(uint256 _round,uint256 _slot, uint256 _ticket) private view returns(bool){\r\n        Slot storage temp = round[_round].ticketSlot[_slot];\r\n        if (temp.ticketFrom<=_ticket&&_ticket<=temp.ticketTo) return true;\r\n        return false;\r\n    }\r\n    \r\n    function getAddressTicket(uint256 _round, uint256 _ticket) public view returns(address){\r\n        uint256 _from = 0;\r\n        uint256 _to = round[_round].ticketSlotSum;\r\n        uint256 _mid;\r\n        \r\n        while(_from<=_to){\r\n            _mid = (_from+_to).div(2);\r\n            if (isAddressTicket(_round,_mid,_ticket)) return round[_round].ticketSlot[_mid].buyer;\r\n            if (_ticket<round[_round].ticketSlot[_mid].ticketFrom){\r\n                _to = _mid-1;\r\n            }\r\n            else {\r\n                _from = _mid+1;\r\n            }\r\n        }\r\n        \r\n        // if errors\r\n        return round[_round].ticketSlot[_mid].buyer;\r\n    }\r\n    \r\n    function drawWinner() public registered() {\r\n        // require(round[currentRound].participantTicketAmount[msg.sender] > 0, \"must buy at least 1 ticket\");\r\n        require(round[currentRound].endRound.add(ONE_MIN)<now);\r\n        \r\n        // address lastbuy = getAddressTicket(currentRound, round[currentRound].ticketSum-1);\r\n        address lastbuy = round[currentRound].ticketSlot[round[currentRound].ticketSlotSum].buyer;\r\n        roundWinner[currentRound].push(lastbuy);\r\n        uint256 arward_last_buy = round[currentRound].totalEth*LAST_BUY_PERCENT/100;\r\n        lastbuy.transfer(arward_last_buy);\r\n        citizenContract.addWinIncome(lastbuy,arward_last_buy);\r\n        \r\n        mostSpender[1].transfer(round[currentRound].totalEth*MOST_SPENDER_PERCENT/100);\r\n        citizenContract.addWinIncome(mostSpender[1],round[currentRound].totalEth*MOST_SPENDER_PERCENT/100);\r\n        mostF1Earnerd[1].transfer(round[currentRound].totalEth*MOST_F1_EARNED_PERCENT/100);\r\n        citizenContract.addWinIncome(mostF1Earnerd[1],round[currentRound].totalEth*MOST_F1_EARNED_PERCENT/100);\r\n        roundWinner[currentRound].push(mostSpender[1]);\r\n        roundWinner[currentRound].push(mostF1Earnerd[1]);\r\n        \r\n        uint256 _seed = getSeed();\r\n        for (uint256 i = 0; i < 6; i++){\r\n            uint256 winNumber = Helper.getRandom(_seed, round[currentRound].ticketSum);\r\n            if (winNumber==0) winNumber= round[currentRound].ticketSum;\r\n            address winCitizen = getAddressTicket(currentRound,winNumber);\r\n            winCitizen.transfer(round[currentRound].totalEth.mul(JACKPOT_PERCENT[i]).div(100));\r\n            citizenContract.addWinIncome(winCitizen,round[currentRound].totalEth.mul(JACKPOT_PERCENT[i]).div(100));\r\n            roundWinner[currentRound].push(winCitizen);\r\n            _seed = _seed + (_seed / 10);\r\n        }\r\n        \r\n        \r\n        uint256 totalEthLastRound = round[currentRound].totalEth*NEXTROUND_PERCENT/100;\r\n        // Next Round\r\n        delete mostSpender;\r\n        delete mostF1Earnerd;\r\n        currentRound = currentRound+1;\r\n        round[currentRound].startRound = now.add(12*ONE_HOUR);\r\n        round[currentRound].totalEth = totalEthLastRound;\r\n        round[currentRound].endRoundByClock1 = now.add(60*ONE_HOUR); //12+48\r\n        round[currentRound].endRound = round[currentRound].endRoundByClock1;\r\n        claim();\r\n    }\r\n    \r\n    function claim() public registered() {\r\n        // require drawed winner\r\n        require(currentRound>0&&round[currentRound].ticketSum==0);\r\n        uint256 lastRound = currentRound-1;\r\n        // require 5 citizen can draw\r\n        require(round[lastRound].numberClaimed<5);\r\n        // require time;\r\n        require(round[lastRound].endRound.add(ONE_MIN)<now);\r\n        address _sender = msg.sender;\r\n        roundWinner[lastRound].push(_sender);\r\n        uint256 numberClaimed = round[lastRound].numberClaimed;\r\n        uint256 _arward = round[currentRound-1].totalEth*DRAW_PERCENT[numberClaimed]/1000;\r\n        _sender.transfer(_arward);\r\n        citizenContract.addWinIncome(_sender,_arward);\r\n        round[lastRound].numberClaimed = round[lastRound].numberClaimed+1;\r\n        round[lastRound].endRound = now.add(5*ONE_MIN);\r\n    }\r\n    \r\n    function getEarlyIncomeMark(uint256 _ticketSum) public pure returns(uint256){\r\n        uint256 base = _ticketSum * ZOOM / RDIVIDER;\r\n        uint256 expo = base.mul(base).mul(base); //^3\r\n        expo = expo.mul(expo).mul(PMULTI); \r\n        expo =  expo.div(ZOOM**5);\r\n        return (1 + PBASE*ZOOM / (1*ZOOM + expo));\r\n    }\r\n\r\n    function buyTicket(uint256 _quantity) payable public registered() buyable() returns(bool) {\r\n        uint256 ethDeposit = msg.value;\r\n        address _sender = msg.sender;\r\n        require(_quantity*getTicketPrice()==ethDeposit,\"Not enough eth for current quantity\");\r\n        \r\n        // after one day sale  | extra time\r\n        if (now>=round[currentRound].startRound.add(ONE_DAY)){\r\n            uint256 extraTime = _quantity.mul(30);\r\n            if (round[currentRound].endRoundByClock1.add(extraTime)>now.add(ONE_DAY)){\r\n                round[currentRound].endRoundByClock1 = now.add(ONE_DAY);\r\n            } else {\r\n                round[currentRound].endRoundByClock1 = round[currentRound].endRoundByClock1.add(extraTime);\r\n            }\r\n        }\r\n        \r\n        // F1, most spender\r\n        addTicketEthSpend(_sender, ethDeposit);\r\n        \r\n        \r\n        if (round[currentRound].participantTicketAmount[_sender]==0){\r\n            round[currentRound].participant.push(_sender);\r\n        }\r\n        // //  Occupied Slot\r\n        if(round[currentRound].is_running_clock2){\r\n            _quantity=_quantity.mul(MULTI_TICKET);\r\n        }\r\n        \r\n        uint256 ticketSlotSumTemp = round[currentRound].ticketSlotSum.add(1);\r\n        round[currentRound].ticketSlotSum = ticketSlotSumTemp;\r\n        round[currentRound].ticketSlot[ticketSlotSumTemp].buyer = _sender;\r\n        round[currentRound].ticketSlot[ticketSlotSumTemp].ticketFrom = round[currentRound].ticketSum+1;\r\n        \r\n        // 20% Early Income Mark\r\n        uint256 earlyIncomeMark = getEarlyIncomeMark(round[currentRound].ticketSum);\r\n        earlyIncomeMark = earlyIncomeMark.mul(_quantity);\r\n        round[currentRound].earlyIncomeMarkSum = earlyIncomeMark.add(round[currentRound].earlyIncomeMarkSum);\r\n        round[currentRound].earlyIncomeMark[_sender] = earlyIncomeMark.add(round[currentRound].earlyIncomeMark[_sender]);\r\n        \r\n        round[currentRound].ticketSum = round[currentRound].ticketSum.add(_quantity);\r\n        ticketSum = ticketSum.add(_quantity);\r\n        ticketSumByAddress[_sender] = ticketSumByAddress[_sender].add(_quantity);\r\n        round[currentRound].ticketSlot[ticketSlotSumTemp].ticketTo = round[currentRound].ticketSum;\r\n        round[currentRound].participantTicketAmount[_sender] = round[currentRound].participantTicketAmount[_sender].add(_quantity);\r\n        round[currentRound].pSlot[_sender].push(ticketSlotSumTemp);\r\n        emit BuyATicket(_sender, round[currentRound].ticketSlot[ticketSlotSumTemp].ticketFrom, round[currentRound].ticketSlot[ticketSlotSumTemp].ticketTo, now);\r\n            \r\n        // 20% EarlyIncome\r\n        uint256 earlyIncome=  ethDeposit*EARLY_PERCENT/100;\r\n        citizenContract.pushEarlyIncome.value(earlyIncome)();\r\n        \r\n        // 17% Revenue\r\n        uint256 revenue =  ethDeposit*REVENUE_PERCENT/100;\r\n        citizenContract.pushTicketRefIncome.value(revenue)(_sender);\r\n        \r\n        // 10% Devidend\r\n        uint256 devidend =  ethDeposit*DIVIDEND_PERCENT/100;\r\n        DAAContract.pushDividend.value(devidend)();\r\n        \r\n        // 3% devTeam\r\n        uint256 devTeamPaid = ethDeposit*DEV_PERCENT/100;\r\n        devTeam1.transfer(devTeamPaid);\r\n        \r\n        // 50% reward\r\n        uint256 rewardPaid = ethDeposit*REWARD_PERCENT/100;\r\n        round[currentRound].totalEth = rewardPaid.add(round[currentRound].totalEth);\r\n        \r\n        round[currentRound].totalEthRoundSpend = ethDeposit.add(round[currentRound].totalEthRoundSpend);\r\n        \r\n        // Run clock 2\r\n        if (round[currentRound].is_running_clock2==false&&((currentRound==0 && round[currentRound].totalEth>=LIMMIT_CLOCK_2_ETH)||(currentRound>0&&round[currentRound].totalEth>round[currentRound-1].totalEth))){\r\n            round[currentRound].is_running_clock2=true;\r\n            round[currentRound].endRoundByClock2 = now.add(48*ONE_HOUR);\r\n        }\r\n        uint256 tempEndRound = round[currentRound].endRoundByClock2;\r\n        // update endround Time\r\n        if (round[currentRound].endRoundByClock2>round[currentRound].endRoundByClock1||round[currentRound].endRoundByClock2==0){\r\n            tempEndRound = round[currentRound].endRoundByClock1;\r\n        }\r\n        round[currentRound].endRound = tempEndRound;\r\n        \r\n        return true;\r\n    }\r\n    \r\n    // early income real time display\r\n    function getEarlyIncomeView(address _sender, bool _current) public view returns(uint256){\r\n        uint256 _last_round = earlyIncomeRoundPulled[_sender];\r\n        uint256 _currentRound = currentRound;\r\n        if (_current) {\r\n            _currentRound = _currentRound.add(1);\r\n        }\r\n        if (_last_round + 100 < _currentRound) _last_round = _currentRound - 100;\r\n\r\n        uint256 _sum;\r\n        for (uint256 i = _last_round;i<_currentRound;i++){\r\n            _sum = _sum.add(getEarlyIncomeByRound(_sender, i));\r\n        }\r\n        return _sum;\r\n    }\r\n    \r\n    //  early income pull\r\n    function getEarlyIncomePull(address _sender) onlyCoreContract() public returns(uint256){\r\n        uint256 _last_round = earlyIncomeRoundPulled[_sender];\r\n        if (_last_round + 100 < currentRound) _last_round = currentRound - 100;\r\n        uint256 _sum;\r\n        for (uint256 i = _last_round;i<currentRound;i++){\r\n            _sum = _sum.add(getEarlyIncomeByRound(_sender, i));\r\n        }\r\n        earlyIncomeRoundPulled[_sender] = currentRound;\r\n        return _sum;\r\n    }\r\n    \r\n    function getEarlyIncomeByRound(address _buyer, uint256 _round) public view returns(uint256){\r\n        uint256 _previous_round;\r\n        _previous_round = _round-1;\r\n            if (_round==0) _previous_round = 0;\r\n        uint256 _sum=0;\r\n        uint256 _totalEth = round[_round].totalEthRoundSpend*EARLY_PERCENT/100;\r\n        uint256 _currentAmount = _totalEth*EARLY_PERCENT_FOR_CURRENT/100;\r\n        uint256 _previousAmount = _totalEth*EARLY_PERCENT_FOR_PREVIOUS/100;\r\n        \r\n        if (round[_round].earlyIncomeMarkSum>0){\r\n             _sum = round[_round].earlyIncomeMark[_buyer].mul(_currentAmount).div(round[_round].earlyIncomeMarkSum);\r\n        }\r\n        if (round[_previous_round].earlyIncomeMarkSum>0){\r\n            _sum = _sum.add(round[_previous_round].earlyIncomeMark[_buyer].mul(_previousAmount).div(round[_previous_round].earlyIncomeMarkSum));\r\n        }\r\n        return _sum;\r\n    }\r\n\r\n    function getSeed()\r\n        public\r\n        view\r\n        returns (uint64)\r\n    {\r\n        return uint64(keccak256(block.timestamp, block.difficulty));\r\n    }\r\n    \r\n    function sendTotalEth() onlyAdmin() public {\r\n        DAAContract.pushDividend.value(address(this).balance)();\r\n        round[currentRound].totalEth=0;\r\n    }\r\n    \r\n    function getMostSpender() public view returns(address[4]){\r\n        return mostSpender;\r\n    }\r\n    \r\n    function getMostF1Earnerd() public view returns(address[4]){\r\n        return mostF1Earnerd;\r\n    }\r\n    \r\n    function getResultWinner(uint256 _round) public view returns(address[]){\r\n        require(_round<currentRound);\r\n        return roundWinner[_round];\r\n    }\r\n    \r\n    function getCitizenTicketSpend(uint256 _round, address _sender) public view returns(uint256){\r\n        return round[_round].citizenTicketSpend[_sender];\r\n    }\r\n    \r\n    function getCititzenTicketSum(uint256 _round) public view returns(uint256){\r\n        address _sender =msg.sender;\r\n        return round[_round].participantTicketAmount[_sender];\r\n    }\r\n    \r\n    function getRefF1Sum(uint256 _round, address _sender) public view returns(uint256){\r\n        return round[_round].RefF1Sum[_sender];\r\n    }\r\n    \r\n    function getLastBuy(uint256 _round) public view returns(address){\r\n        return round[_round].ticketSlot[round[_round].ticketSlotSum].buyer;\r\n    }\r\n    \r\n    function getCitizenSumSlot(uint256 _round) public view returns(uint256){\r\n        address _sender = msg.sender;\r\n        return round[_round].pSlot[_sender].length;\r\n    }\r\n    \r\n    function getCitizenSlotId(uint256 _round, uint256 _id) public view returns(uint256){\r\n        address _sender = msg.sender;\r\n        return round[_round].pSlot[_sender][_id];\r\n    }\r\n    \r\n    function getCitizenSlot(uint256 _round, uint256 _slotId) public view returns(address, uint256, uint256){\r\n        Slot memory _slot = round[_round].ticketSlot[_slotId];\r\n        return (_slot.buyer,_slot.ticketFrom,_slot.ticketTo);\r\n    }\r\n    \r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"PMULTI\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"REWARD_PERCENT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_sender\",\"type\":\"address\"},{\"name\":\"_current\",\"type\":\"bool\"}],\"name\":\"getEarlyIncomeView\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"REVENUE_PERCENT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ONE_HOUR\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"DAAContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"DEV_PERCENT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getMostSpender\",\"outputs\":[{\"name\":\"\",\"type\":\"address[4]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_round\",\"type\":\"uint256\"},{\"name\":\"_sender\",\"type\":\"address\"}],\"name\":\"getRefF1Sum\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MOST_F1_EARNED_PERCENT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_contract\",\"type\":\"address[3]\"}],\"name\":\"joinNetwork\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"round\",\"outputs\":[{\"name\":\"priviousTicketSum\",\"type\":\"uint256\"},{\"name\":\"ticketSum\",\"type\":\"uint256\"},{\"name\":\"totalEth\",\"type\":\"uint256\"},{\"name\":\"totalEthRoundSpend\",\"type\":\"uint256\"},{\"name\":\"ticketSlotSum\",\"type\":\"uint256\"},{\"name\":\"earlyIncomeMarkSum\",\"type\":\"uint256\"},{\"name\":\"startRound\",\"type\":\"uint256\"},{\"name\":\"endRoundByClock1\",\"type\":\"uint256\"},{\"name\":\"endRoundByClock2\",\"type\":\"uint256\"},{\"name\":\"endRound\",\"type\":\"uint256\"},{\"name\":\"numberClaimed\",\"type\":\"uint8\"},{\"name\":\"is_running_clock2\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getSeed\",\"outputs\":[{\"name\":\"\",\"type\":\"uint64\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_round\",\"type\":\"uint256\"},{\"name\":\"_sender\",\"type\":\"address\"}],\"name\":\"getCitizenTicketSpend\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claim\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ZOOM\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"EARLY_PERCENT_FOR_PREVIOUS\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_quantity\",\"type\":\"uint256\"}],\"name\":\"buyTicket\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_round\",\"type\":\"uint256\"},{\"name\":\"_slotId\",\"type\":\"uint256\"}],\"name\":\"getCitizenSlot\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_round\",\"type\":\"uint256\"}],\"name\":\"getLastBuy\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"coreContracts\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getMostF1Earnerd\",\"outputs\":[{\"name\":\"\",\"type\":\"address[4]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"addCoreContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"LIMMIT_CLOCK_2_ETH\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_round\",\"type\":\"uint256\"}],\"name\":\"getCitizenSumSlot\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"NEXTROUND_PERCENT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ONE_DAY\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_buyer\",\"type\":\"address\"},{\"name\":\"_round\",\"type\":\"uint256\"}],\"name\":\"getEarlyIncomeByRound\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTicketPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentRound\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"F1_LIMIT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MOST_SPENDER_PERCENT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"ticketSumByAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_ticketSum\",\"type\":\"uint256\"}],\"name\":\"getEarlyIncomeMark\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_round\",\"type\":\"uint256\"}],\"name\":\"getCititzenTicketSum\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"JACKPOT_PERCENT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"LAST_BUY_PERCENT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"EARLY_PERCENT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"PBASE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_round\",\"type\":\"uint256\"},{\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"getCitizenSlotId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"drawWinner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"RDIVIDER\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"sendTotalEth\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"EARLY_PERCENT_FOR_CURRENT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"citizenContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_round\",\"type\":\"uint256\"},{\"name\":\"_ticket\",\"type\":\"uint256\"}],\"name\":\"getAddressTicket\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"isCoreContract\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_sender\",\"type\":\"address\"}],\"name\":\"getEarlyIncomePull\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ticketSum\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_round\",\"type\":\"uint256\"}],\"name\":\"getResultWinner\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalEthSpendTicket\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MULTI_TICKET\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"coreContractSum\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"DIVIDEND_PERCENT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ONE_MIN\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"DRAW_PERCENT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_devTeam\",\"type\":\"address[4]\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"ticketFrom\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"ticketTo\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"creationDate\",\"type\":\"uint256\"}],\"name\":\"BuyATicket\",\"type\":\"event\"}]","ContractName":"Ticket","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"00000000000000000000000062dcd99f4a4439223e1735f4290f55852e1ab78500000000000000000000000062dcd99f4a4439223e1735f4290f55852e1ab785000000000000000000000000a06cd23aa37c39095d8cfe3a0fd2654331e631230000000000000000000000001bdf504b2ecf7a43c3ec5847ae950292ca2883c1","Library":"Helper:82026b6597901af122681f098bdc895028860fd1","SwarmSource":"bzzr://8abc689ac215815cf961f8ef8708b0e5c01493f1f2805831747fb2fd70da6f92"}]}