{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity >=0.5.4<0.6.0;\r\n\r\ncontract ERC20Detailed {\r\n  string private _name;\r\n  string private _symbol;\r\n  uint8 private _decimals;\r\n\r\n  constructor(string memory name, string memory symbol, uint8 decimals) public {\r\n    _name = name;\r\n    _symbol = symbol;\r\n    _decimals = decimals;\r\n  }\r\n\r\n  function name() public view returns (string memory) {\r\n    return _name;\r\n  }\r\n\r\n  function symbol() public view returns (string memory) {\r\n    return _symbol;\r\n  }\r\n\r\n  function decimals() public view returns (uint8) {\r\n    return _decimals;\r\n  }\r\n}\r\n\r\n\r\ninterface IERC20 {\r\n  function transfer(address to, uint256 value) external returns (bool);\r\n\r\n  function approve(address spender, uint256 value) external returns (bool);\r\n\r\n  function transferFrom(address from, address to, uint256 value) external returns (bool);\r\n\r\n  function totalSupply() external view returns (uint256);\r\n\r\n  function balanceOf(address who) external view returns (uint256);\r\n\r\n  function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ncontract ERC20 is IERC20 {\r\n  using SafeMath for uint256;\r\n\r\n  mapping(address => uint256) private _balances;\r\n\r\n  mapping(address => mapping(address => uint256)) private _allowed;\r\n\r\n  uint256 private _totalSupply;\r\n\r\n  function totalSupply() public view returns (uint256) {\r\n    return _totalSupply;\r\n  }\r\n\r\n  function balanceOf(address owner) public view returns (uint256) {\r\n    return _balances[owner];\r\n  }\r\n\r\n  function allowance(address owner, address spender) public view returns (uint256) {\r\n    return _allowed[owner][spender];\r\n  }\r\n\r\n  function transfer(address to, uint256 value) public returns (bool) {\r\n    _transfer(msg.sender, to, value);\r\n    return true;\r\n  }\r\n\r\n  function approve(address spender, uint256 value) public returns (bool) {\r\n    _approve(msg.sender, spender, value);\r\n    return true;\r\n  }\r\n\r\n  function transferFrom(address from, address to, uint256 value) public returns (bool) {\r\n    _transfer(from, to, value);\r\n    _approve(from, msg.sender, _allowed[from][msg.sender].sub(value));\r\n    return true;\r\n  }\r\n\r\n  function _transfer(address from, address to, uint256 value) internal {\r\n    require(to != address(0));\r\n\r\n    _balances[from] = _balances[from].sub(value);\r\n    _balances[to] = _balances[to].add(value);\r\n    emit Transfer(from, to, value);\r\n  }\r\n\r\n  function _mint(address account, uint256 value) internal {\r\n    require(account != address(0));\r\n\r\n    _totalSupply = _totalSupply.add(value);\r\n    _balances[account] = _balances[account].add(value);\r\n    emit Transfer(address(0), account, value);\r\n  }\r\n\r\n  function _burn(address account, uint256 value) internal {\r\n    require(account != address(0));\r\n\r\n    _totalSupply = _totalSupply.sub(value);\r\n    _balances[account] = _balances[account].sub(value);\r\n    emit Transfer(account, address(0), value);\r\n  }\r\n\r\n  function _approve(address owner, address spender, uint256 value) internal {\r\n    require(spender != address(0));\r\n    require(owner != address(0));\r\n\r\n    _allowed[owner][spender] = value;\r\n    emit Approval(owner, spender, value);\r\n  }\r\n}\r\n\r\n\r\ncontract Ownable {\r\n  address private _owner;\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n  constructor() internal {\r\n    _owner = msg.sender;\r\n    emit OwnershipTransferred(address(0), _owner);\r\n  }\r\n\r\n  function owner() public view returns (address) {\r\n    return _owner;\r\n  }\r\n\r\n  modifier onlyOwner() {\r\n    require(isOwner());\r\n    _;\r\n  }\r\n\r\n  function isOwner() public view returns (bool) {\r\n    return msg.sender == _owner;\r\n  }\r\n\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    _transferOwnership(newOwner);\r\n  }\r\n\r\n  function _transferOwnership(address newOwner) internal {\r\n    require(newOwner != address(0));\r\n    emit OwnershipTransferred(_owner, newOwner);\r\n    _owner = newOwner;\r\n  }\r\n}\r\n\r\nlibrary MultiSigAction {\r\n  struct Action {\r\n    uint8 actionType;\r\n    address callbackAddress;\r\n    string callbackSig;\r\n    bytes callbackData;\r\n    uint8 quorum;\r\n    address requestedBy;\r\n    address rejectedBy;\r\n    mapping(address => bool) approvedBy;\r\n    uint8 numOfApprovals;\r\n    bool rejected;\r\n    bool failed;\r\n  }\r\n\r\n  function init(\r\n    Action storage _self,\r\n    uint8 _actionType,\r\n    address _callbackAddress,\r\n    string memory _callbackSig,\r\n    bytes memory _callbackData,\r\n    uint8 _quorum\r\n  ) internal {\r\n    _self.actionType = _actionType;\r\n    _self.callbackAddress = _callbackAddress;\r\n    _self.callbackSig = _callbackSig;\r\n    _self.callbackData = _callbackData;\r\n    _self.quorum = _quorum;\r\n    _self.requestedBy = msg.sender;\r\n  }\r\n\r\n  function approve(Action storage _self) internal {\r\n    require(!_self.rejected, \"CANNOT_APPROVE_REJECTED\");\r\n    require(!_self.failed, \"CANNOT_APPROVE_FAILED\");\r\n    require(!_self.approvedBy[msg.sender], \"CANNOT_APPROVE_AGAIN\");\r\n    require(!isCompleted(_self), \"CANNOT_APPROVE_COMPLETED\");\r\n\r\n    _self.approvedBy[msg.sender] = true;\r\n    _self.numOfApprovals++;\r\n  }\r\n\r\n  function reject(Action storage _self) internal {\r\n    require(!_self.approvedBy[msg.sender], \"CANNOT_REJECT_APPROVED\");\r\n    require(!_self.failed, \"CANNOT_REJECT_FAILED\");\r\n    require(!_self.rejected, \"CANNOT_REJECT_REJECTED\");\r\n    require(!isCompleted(_self), \"CANNOT_REJECT_COMPLETED\");\r\n\r\n    _self.rejectedBy = msg.sender;\r\n    _self.rejected = true;\r\n  }\r\n\r\n  function complete(Action storage _self) internal {\r\n    require(!_self.rejected, \"CANNOT_COMPLETE_REJECTED\");\r\n    require(!_self.failed, \"CANNOT_COMPLETE_FAILED\");\r\n    require(isCompleted(_self), \"CANNNOT_COMPLETE_AGAIN\");\r\n\r\n    // solium-disable-next-line security/no-low-level-calls\r\n    (bool _success, ) = _self.callbackAddress.call(\r\n      abi.encodePacked(bytes4(keccak256(bytes(_self.callbackSig))), _self.callbackData)\r\n    );\r\n\r\n    if (!_success) {\r\n      _self.failed = true;\r\n    }\r\n  }\r\n\r\n  function isCompleted(Action storage _self) internal view returns (bool) {\r\n    return _self.numOfApprovals >= _self.quorum && !_self.failed;\r\n  }\r\n}\r\n\r\n\r\nlibrary SafeMath {\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b <= a);\r\n    uint256 c = a - b;\r\n\r\n    return c;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    require(c >= a);\r\n\r\n    return c;\r\n  }\r\n}\r\n\r\ncontract ERC20Extended is Ownable, ERC20, ERC20Detailed {\r\n  constructor(string memory _name, string memory _symbol, uint8 _decimals)\r\n    public\r\n    ERC20Detailed(_name, _symbol, _decimals)\r\n  {}\r\n\r\n  function burn(uint256 _value) public onlyOwner returns (bool) {\r\n    _burn(msg.sender, _value);\r\n    return true;\r\n  }\r\n\r\n  function mint(address _to, uint256 _value) public onlyOwner returns (bool) {\r\n    _mint(_to, _value);\r\n\r\n    return true;\r\n  }\r\n}\r\n\r\ncontract MultiSigAdministration {\r\n  event TenantRegistered(\r\n    address indexed tenant,\r\n    address[] creators,\r\n    address[] admins,\r\n    uint8 quorum\r\n  );\r\n  event ActionInitiated(address indexed tenant, uint256 indexed id, address initiatedBy);\r\n  event ActionApproved(address indexed tenant, uint256 indexed id, address approvedBy);\r\n  event ActionRejected(address indexed tenant, uint256 indexed id, address rejectedBy);\r\n  event ActionCompleted(address indexed tenant, uint256 indexed id);\r\n  event ActionFailed(address indexed tenant, uint256 indexed id);\r\n\r\n  using MultiSigAction for MultiSigAction.Action;\r\n\r\n  enum AdminAction {ADD_ADMIN, REMOVE_ADMIN, CHANGE_QUORUM, ADD_CREATOR, REMOVE_CREATOR}\r\n  uint8 private constant OTHER_ACTION = uint8(AdminAction.REMOVE_CREATOR) + 1;\r\n\r\n  mapping(address => uint256) public numOfActions;\r\n  mapping(address => mapping(address => bool)) public isAdmin;\r\n  mapping(address => uint8) public numOfAdmins;\r\n  mapping(address => mapping(address => bool)) public isCreator;\r\n  mapping(address => uint8) public quorums;\r\n  mapping(address => bool) public isRegistered;\r\n  mapping(address => uint256) public minValidActionId;\r\n\r\n  mapping(address => mapping(uint256 => MultiSigAction.Action)) private actions;\r\n\r\n  modifier onlyAdminOf(address _tenant) {\r\n    require(isAdmin[_tenant][msg.sender], \"ONLY_ADMIN_OF_TENANT\");\r\n\r\n    _;\r\n  }\r\n\r\n  modifier onlyAdminOrCreatorOf(address _tenant) {\r\n    require(\r\n      isAdmin[_tenant][msg.sender] || isCreator[_tenant][msg.sender],\r\n      \"ONLY_ADMIN_OR_CREATOR_OF_TENANT\"\r\n    );\r\n\r\n    _;\r\n  }\r\n\r\n  modifier onlyRegistered(address _tenant) {\r\n    require(isRegistered[_tenant], \"ONLY_REGISTERED_TENANT\");\r\n\r\n    _;\r\n  }\r\n\r\n  modifier onlyMe() {\r\n    require(msg.sender == address(this), \"ONLY_INTERNAL\");\r\n\r\n    _;\r\n  }\r\n\r\n  modifier onlyExistingAction(address _tenant, uint256 _id) {\r\n    require(_id <= numOfActions[_tenant], \"ONLY_EXISTING_ACTION\");\r\n    require(_id > 0, \"ONLY_EXISTING_ACTION\");\r\n\r\n    _;\r\n  }\r\n\r\n  constructor() public {}\r\n\r\n  /* Public Functions - Start */\r\n  function register(\r\n    address _tenant,\r\n    address[] memory _creators,\r\n    address[] memory _admins,\r\n    uint8 _quorum\r\n  ) public returns (bool success) {\r\n    require(\r\n      msg.sender == _tenant || msg.sender == Ownable(_tenant).owner(),\r\n      \"ONLY_TENANT_OR_TENANT_OWNER\"\r\n    );\r\n\r\n    return _register(_tenant, _creators, _admins, _quorum);\r\n  }\r\n\r\n  function initiateAdminAction(\r\n    address _tenant,\r\n    AdminAction _adminAction,\r\n    bytes memory _callbackData\r\n  ) public onlyRegistered(_tenant) onlyAdminOf(_tenant) returns (uint256 id) {\r\n    string memory _callbackSig = _getAdminActionCallbackSig(_adminAction);\r\n\r\n    uint256 _id = _initiateAction(\r\n      uint8(_adminAction),\r\n      _tenant,\r\n      address(this),\r\n      _callbackSig,\r\n      abi.encodePacked(abi.encode(_tenant), _callbackData)\r\n    );\r\n    _approveAction(_tenant, _id);\r\n\r\n    return _id;\r\n  }\r\n\r\n  function initiateAction(address _tenant, string memory _callbackSig, bytes memory _callbackData)\r\n    public\r\n    onlyRegistered(_tenant)\r\n    onlyAdminOrCreatorOf(_tenant)\r\n    returns (uint256 id)\r\n  {\r\n    uint256 _id = _initiateAction(OTHER_ACTION, _tenant, _tenant, _callbackSig, _callbackData);\r\n\r\n    if (isAdmin[_tenant][msg.sender]) {\r\n      _approveAction(_tenant, _id);\r\n    }\r\n\r\n    return _id;\r\n  }\r\n\r\n  function approveAction(address _tenant, uint256 _id)\r\n    public\r\n    onlyRegistered(_tenant)\r\n    onlyAdminOf(_tenant)\r\n    onlyExistingAction(_tenant, _id)\r\n    returns (bool success)\r\n  {\r\n    return _approveAction(_tenant, _id);\r\n  }\r\n\r\n  function rejectAction(address _tenant, uint256 _id)\r\n    public\r\n    onlyRegistered(_tenant)\r\n    onlyAdminOrCreatorOf(_tenant)\r\n    onlyExistingAction(_tenant, _id)\r\n    returns (bool success)\r\n  {\r\n    return _rejectAction(_tenant, _id);\r\n  }\r\n\r\n  function addAdmin(address _tenant, address _admin, bool _increaseQuorum) public onlyMe {\r\n    minValidActionId[_tenant] = numOfActions[_tenant] + 1;\r\n    _addAdmin(_tenant, _admin);\r\n\r\n    if (_increaseQuorum) {\r\n      uint8 _quorum = quorums[_tenant];\r\n      uint8 _newQuorum = _quorum + 1;\r\n      require(_newQuorum > _quorum, \"OVERFLOW\");\r\n\r\n      _changeQuorum(_tenant, _newQuorum);\r\n    }\r\n  }\r\n\r\n  function removeAdmin(address _tenant, address _admin, bool _decreaseQuorum) public onlyMe {\r\n    uint8 _quorum = quorums[_tenant];\r\n\r\n    if (_decreaseQuorum && _quorum > 1) {\r\n      _changeQuorum(_tenant, _quorum - 1);\r\n    }\r\n\r\n    minValidActionId[_tenant] = numOfActions[_tenant] + 1;\r\n    _removeAdmin(_tenant, _admin);\r\n  }\r\n\r\n  function changeQuorum(address _tenant, uint8 _quorum) public onlyMe {\r\n    minValidActionId[_tenant] = numOfActions[_tenant] + 1;\r\n    _changeQuorum(_tenant, _quorum);\r\n  }\r\n\r\n  function addCreator(address _tenant, address _creator) public onlyMe {\r\n    _addCreator(_tenant, _creator);\r\n  }\r\n\r\n  function removeCreator(address _tenant, address _creator) public onlyMe {\r\n    _removeCreator(_tenant, _creator);\r\n  }\r\n\r\n  function getAction(address _tenant, uint256 _id)\r\n    public\r\n    view\r\n    returns (\r\n    bool isAdminAction,\r\n    string memory callbackSig,\r\n    bytes memory callbackData,\r\n    uint8 quorum,\r\n    address requestedBy,\r\n    address rejectedBy,\r\n    uint8 numOfApprovals,\r\n    bool rejected,\r\n    bool failed,\r\n    bool completed,\r\n    bool valid\r\n  )\r\n  {\r\n    MultiSigAction.Action storage _action = _getAction(_tenant, _id);\r\n\r\n    isAdminAction = _action.callbackAddress == address(this);\r\n    callbackSig = _action.callbackSig;\r\n    callbackData = _action.callbackData;\r\n    quorum = _action.quorum;\r\n    requestedBy = _action.requestedBy;\r\n    rejectedBy = _action.rejectedBy;\r\n    numOfApprovals = _action.numOfApprovals;\r\n    rejected = _action.rejected;\r\n    failed = _action.failed;\r\n    completed = _action.isCompleted();\r\n    valid = _isActionValid(_tenant, _id);\r\n  }\r\n\r\n  function hasApprovedBy(address _tenant, uint256 _id, address _admin)\r\n    public\r\n    view\r\n    returns (bool approvedBy)\r\n  {\r\n    approvedBy = _getAction(_tenant, _id).approvedBy[_admin];\r\n  }\r\n  /* Public Functions - End */\r\n\r\n  /* Private Functions - Start */\r\n  function _getAction(address _tenant, uint256 _id)\r\n    private\r\n    view\r\n    returns (MultiSigAction.Action storage)\r\n  {\r\n    return actions[_tenant][_id];\r\n  }\r\n\r\n  function _isActionValid(address _tenant, uint256 _id) private view returns (bool) {\r\n    return _id >= minValidActionId[_tenant];\r\n  }\r\n\r\n  function _getAdminActionCallbackSig(AdminAction _adminAction)\r\n    private\r\n    pure\r\n    returns (string memory)\r\n  {\r\n    if (_adminAction == AdminAction.ADD_ADMIN) {\r\n      return \"addAdmin(address,address,bool)\";\r\n    }\r\n\r\n    if (_adminAction == AdminAction.REMOVE_ADMIN) {\r\n      return \"removeAdmin(address,address,bool)\";\r\n    }\r\n\r\n    if (_adminAction == AdminAction.CHANGE_QUORUM) {\r\n      return \"changeQuorum(address,uint8)\";\r\n    }\r\n\r\n    if (_adminAction == AdminAction.ADD_CREATOR) {\r\n      return \"addCreator(address,address)\";\r\n    }\r\n\r\n    return \"removeCreator(address,address)\";\r\n  }\r\n\r\n  function _addCreator(address _tenant, address _creator) private {\r\n    require(_creator != address(this), \"INVALID_CREATOR\");\r\n    require(!isAdmin[_tenant][_creator], \"ALREADY_ADMIN\");\r\n    require(!isCreator[_tenant][_creator], \"ALREADY_CREATOR\");\r\n\r\n    isCreator[_tenant][_creator] = true;\r\n  }\r\n\r\n  function _removeCreator(address _tenant, address _creator) private {\r\n    require(isCreator[_tenant][_creator], \"NOT_CREATOR\");\r\n\r\n    isCreator[_tenant][_creator] = false;\r\n  }\r\n\r\n  function _addAdmin(address _tenant, address _admin) private {\r\n    require(_admin != address(this), \"INVALID_ADMIN\");\r\n    require(!isAdmin[_tenant][_admin], \"ALREADY_ADMIN\");\r\n    require(!isCreator[_tenant][_admin], \"ALREADY_CREATOR\");\r\n    require(numOfAdmins[_tenant] + 1 > numOfAdmins[_tenant], \"OVERFLOW\");\r\n\r\n    numOfAdmins[_tenant]++;\r\n    isAdmin[_tenant][_admin] = true;\r\n  }\r\n\r\n  function _removeAdmin(address _tenant, address _admin) private {\r\n    require(isAdmin[_tenant][_admin], \"NOT_ADMIN\");\r\n    require(--numOfAdmins[_tenant] >= quorums[_tenant], \"TOO_FEW_ADMINS\");\r\n\r\n    isAdmin[_tenant][_admin] = false;\r\n  }\r\n\r\n  function _changeQuorum(address _tenant, uint8 _quorum) private {\r\n    require(_quorum <= numOfAdmins[_tenant], \"QUORUM_TOO_BIG\");\r\n    require(_quorum > 0, \"QUORUM_ZERO\");\r\n\r\n    quorums[_tenant] = _quorum;\r\n  }\r\n\r\n  function _register(\r\n    address _tenant,\r\n    address[] memory _creators,\r\n    address[] memory _admins,\r\n    uint8 _quorum\r\n  ) private returns (bool) {\r\n    require(_tenant != address(this), \"INVALID_TENANT\");\r\n    require(!isRegistered[_tenant], \"ALREADY_REGISTERED\");\r\n\r\n    for (uint8 i = 0; i < _admins.length; i++) {\r\n      _addAdmin(_tenant, _admins[i]);\r\n    }\r\n    _changeQuorum(_tenant, _quorum);\r\n\r\n    for (uint8 i = 0; i < _creators.length; i++) {\r\n      _addCreator(_tenant, _creators[i]);\r\n    }\r\n\r\n    isRegistered[_tenant] = true;\r\n    emit TenantRegistered(_tenant, _creators, _admins, _quorum);\r\n\r\n    return true;\r\n  }\r\n\r\n  function _initiateAction(\r\n    uint8 _actionType,\r\n    address _tenant,\r\n    address _callbackAddress,\r\n    string memory _callbackSig,\r\n    bytes memory _callbackData\r\n  ) private returns (uint256) {\r\n    uint256 _id = ++numOfActions[_tenant];\r\n    uint8 _quorum = quorums[_tenant];\r\n\r\n    if (_actionType == uint8(AdminAction.REMOVE_ADMIN)) {\r\n      require(numOfAdmins[_tenant] > 1, \"TOO_FEW_ADMINS\");\r\n\r\n      if (_quorum == numOfAdmins[_tenant] && _quorum > 2) {\r\n        _quorum = numOfAdmins[_tenant] - 1;\r\n      }\r\n    }\r\n\r\n    _getAction(_tenant, _id).init(\r\n      _actionType,\r\n      _callbackAddress,\r\n      _callbackSig,\r\n      _callbackData,\r\n      _quorum\r\n    );\r\n\r\n    emit ActionInitiated(_tenant, _id, msg.sender);\r\n\r\n    return _id;\r\n  }\r\n\r\n  function _approveAction(address _tenant, uint256 _id) private returns (bool) {\r\n    require(_isActionValid(_tenant, _id), \"ACTION_INVALIDATED\");\r\n\r\n    MultiSigAction.Action storage _action = _getAction(_tenant, _id);\r\n    _action.approve();\r\n    emit ActionApproved(_tenant, _id, msg.sender);\r\n\r\n    if (_action.isCompleted()) {\r\n      _action.complete();\r\n\r\n      if (_action.failed) {\r\n        emit ActionFailed(_tenant, _id);\r\n      } else {\r\n        emit ActionCompleted(_tenant, _id);\r\n      }\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  function _rejectAction(address _tenant, uint256 _id) private returns (bool) {\r\n    MultiSigAction.Action storage _action = _getAction(_tenant, _id);\r\n\r\n    if (isCreator[_tenant][msg.sender]) {\r\n      require(msg.sender == _action.requestedBy, \"CREATOR_REJECT_NOT_REQUESTOR\");\r\n    }\r\n\r\n    if (_action.actionType == uint8(AdminAction.REMOVE_ADMIN)) {\r\n      (, address _admin, ) = abi.decode(_action.callbackData, (address, address, bool));\r\n\r\n      require(_admin != msg.sender, \"CANNOT_REJECT_ITS_OWN_REMOVAL\");\r\n    }\r\n\r\n    _action.reject();\r\n\r\n    emit ActionRejected(_tenant, _id, msg.sender);\r\n\r\n    return true;\r\n  }\r\n  /* Private Functions - End */\r\n}\r\n\r\ncontract MultiSigProxyOwner {\r\n  event BurnRequested(address indexed owner, uint256 value);\r\n  event BurnCanceled(address indexed owner);\r\n  event BurnMinSet(uint256 burnMin);\r\n\r\n  struct BurnRequest {\r\n    uint256 actionId;\r\n    uint256 value;\r\n  }\r\n\r\n  uint256 public burnMin;\r\n  mapping(address => BurnRequest) public burnRequests;\r\n\r\n  ERC20Extended private token;\r\n  MultiSigAdministration private multiSigAdmin;\r\n  address[] private creators;\r\n\r\n  modifier onlyMultiSigAdministration {\r\n    require(msg.sender == address(multiSigAdmin));\r\n\r\n    _;\r\n  }\r\n\r\n  constructor(\r\n    address _token,\r\n    address _multiSigAdmin,\r\n    address[] memory _admins,\r\n    uint8 _quorum,\r\n    uint256 _burnMin\r\n  ) public {\r\n    token = ERC20Extended(_token);\r\n    multiSigAdmin = MultiSigAdministration(_multiSigAdmin);\r\n    burnMin = _burnMin;\r\n\r\n    creators.push(address(this));\r\n    multiSigAdmin.register(address(this), creators, _admins, _quorum);\r\n\r\n  }\r\n\r\n  function requestBurn(uint256 _value) public returns (bool) {\r\n    require(!_burnRequestExist(msg.sender), \"BURN_REQUEST_EXISTS\");\r\n    require(_value >= burnMin, \"SMALLER_THAN_MIN_BURN_AMOUNT\");\r\n\r\n    token.transferFrom(msg.sender, address(this), _value);\r\n    burnRequests[msg.sender].value = _value;\r\n    burnRequests[msg.sender].actionId = multiSigAdmin.initiateAction(\r\n      address(this),\r\n      \"burn(address,uint256)\",\r\n      abi.encode(msg.sender, _value)\r\n    );\r\n\r\n    emit BurnRequested(msg.sender, _value);\r\n\r\n    return true;\r\n  }\r\n\r\n  function cancelBurn() public returns (bool) {\r\n    uint256 _actionId = burnRequests[msg.sender].actionId;\r\n    uint256 _value = burnRequests[msg.sender].value;\r\n    _deleteBurnRequest(msg.sender);\r\n\r\n    // solium-disable-next-line security/no-low-level-calls\r\n    (bool _success, ) = address(multiSigAdmin).call(\r\n      abi.encodeWithSignature(\"rejectAction(address,uint256)\", address(this), _actionId)\r\n    );\r\n    _success;\r\n    token.transfer(msg.sender, _value);\r\n\r\n    emit BurnCanceled(msg.sender);\r\n\r\n    return true;\r\n  }\r\n\r\n  function burn(address _owner, uint256 _value) public onlyMultiSigAdministration returns (bool) {\r\n    require(burnRequests[_owner].value == _value, \"BURN_VALUE_MISMATCH\");\r\n\r\n    _deleteBurnRequest(_owner);\r\n    token.burn(_value);\r\n\r\n    return true;\r\n  }\r\n\r\n  function mint(address _to, uint256 _value) public onlyMultiSigAdministration returns (bool) {\r\n    return token.mint(_to, _value);\r\n  }\r\n\r\n  function transferOwnership(address _newOwner) public onlyMultiSigAdministration returns (bool) {\r\n    token.transferOwnership(_newOwner);\r\n\r\n    return true;\r\n  }\r\n\r\n  function setBurnMin(uint256 _burnMin) public onlyMultiSigAdministration returns (bool) {\r\n    return _setBurnMin(_burnMin);\r\n  }\r\n\r\n  function _setBurnMin(uint256 _burnMin) internal returns (bool) {\r\n    burnMin = _burnMin;\r\n    emit BurnMinSet(_burnMin);\r\n\r\n    return true;\r\n  }\r\n\r\n  function _burnRequestExist(address _owner) internal view returns (bool) {\r\n    return burnRequests[_owner].actionId != 0;\r\n  }\r\n\r\n  function _deleteBurnRequest(address _owner) internal returns (bool) {\r\n    require(_burnRequestExist(_owner), \"NO_BURN_REQUEST_EXISTS\");\r\n\r\n    burnRequests[_owner].actionId = 0;\r\n    burnRequests[_owner].value = 0;\r\n\r\n    return true;\r\n  }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"burnMin\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"requestBurn\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"burnRequests\",\"outputs\":[{\"name\":\"actionId\",\"type\":\"uint256\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"cancelBurn\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_burnMin\",\"type\":\"uint256\"}],\"name\":\"setBurnMin\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_multiSigAdmin\",\"type\":\"address\"},{\"name\":\"_admins\",\"type\":\"address[]\"},{\"name\":\"_quorum\",\"type\":\"uint8\"},{\"name\":\"_burnMin\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"BurnRequested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"BurnCanceled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"burnMin\",\"type\":\"uint256\"}],\"name\":\"BurnMinSet\",\"type\":\"event\"}]","ContractName":"MultiSigProxyOwner","CompilerVersion":"v0.5.4+commit.9549d8ff","OptimizationUsed":"1","Runs":"99999999","ConstructorArguments":"000000000000000000000000ba1ca31bf066634d438fea44699548705870ecb200000000000000000000000075a1b755200e0f6803802339cb38648a2e6ffe0200000000000000000000000000000000000000000000000000000000000000a0000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000027100000000000000000000000000000000000000000000000000000000000000001000000000000000000000000a30da8db3bae63410559ca1b1800f00b6ee0be10","Library":"","SwarmSource":"bzzr://87f17b99f3c3399b2dc0c25493056f29f65f02c30ee209d351075a81697c21eb"}]}