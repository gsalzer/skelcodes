{"status":"1","message":"OK","result":[{"SourceCode":"// solium-disable linebreak-style\r\npragma solidity ^0.5.0;\r\n\r\ncontract CryptoTycoonsVIPLib{\r\n    \r\n    address payable public owner;\r\n    \r\n    // Accumulated jackpot fund.\r\n    uint128 public jackpotSize;\r\n    uint128 public rankingRewardSize;\r\n    \r\n    mapping (address => uint) userExpPool;\r\n    mapping (address => bool) public callerMap;\r\n\r\n    event RankingRewardPayment(address indexed beneficiary, uint amount);\r\n\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner, \"OnlyOwner methods called by non-owner.\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyCaller {\r\n        bool isCaller = callerMap[msg.sender];\r\n        require(isCaller, \"onlyCaller methods called by non-caller.\");\r\n        _;\r\n    }\r\n\r\n    constructor() public{\r\n        owner = msg.sender;\r\n        callerMap[owner] = true;\r\n    }\r\n\r\n    // Fallback function deliberately left empty. It's primary use case\r\n    // is to top up the bank roll.\r\n    function () external payable {\r\n    }\r\n\r\n    function kill() external onlyOwner {\r\n        selfdestruct(owner);\r\n    }\r\n\r\n    function addCaller(address caller) public onlyOwner{\r\n        bool isCaller = callerMap[caller];\r\n        if (isCaller == false){\r\n            callerMap[caller] = true;\r\n        }\r\n    }\r\n\r\n    function deleteCaller(address caller) external onlyOwner {\r\n        bool isCaller = callerMap[caller];\r\n        if (isCaller == true) {\r\n            callerMap[caller] = false;\r\n        }\r\n    }\r\n\r\n    function addUserExp(address addr, uint256 amount) public onlyCaller{\r\n        uint exp = userExpPool[addr];\r\n        exp = exp + amount;\r\n        userExpPool[addr] = exp;\r\n    }\r\n\r\n    function getUserExp(address addr) public view returns(uint256 exp){\r\n        return userExpPool[addr];\r\n    }\r\n\r\n    function getVIPLevel(address user) public view returns (uint256 level) {\r\n        uint exp = userExpPool[user];\r\n\r\n        if(exp >= 25 ether && exp < 125 ether){\r\n            level = 1;\r\n        } else if(exp >= 125 ether && exp < 250 ether){\r\n            level = 2;\r\n        } else if(exp >= 250 ether && exp < 1250 ether){\r\n            level = 3;\r\n        } else if(exp >= 1250 ether && exp < 2500 ether){\r\n            level = 4;\r\n        } else if(exp >= 2500 ether && exp < 12500 ether){\r\n            level = 5;\r\n        } else if(exp >= 12500 ether && exp < 25000 ether){\r\n            level = 6;\r\n        } else if(exp >= 25000 ether && exp < 125000 ether){\r\n            level = 7;\r\n        } else if(exp >= 125000 ether && exp < 250000 ether){\r\n            level = 8;\r\n        } else if(exp >= 250000 ether && exp < 1250000 ether){\r\n            level = 9;\r\n        } else if(exp >= 1250000 ether){\r\n            level = 10;\r\n        } else{\r\n            level = 0;\r\n        }\r\n\r\n        return level;\r\n    }\r\n\r\n    function getVIPBounusRate(address user) public view returns (uint256 rate){\r\n        uint level = getVIPLevel(user);\r\n        return level;\r\n    }\r\n\r\n    // This function is used to bump up the jackpot fund. Cannot be used to lower it.\r\n    function increaseJackpot(uint increaseAmount) external onlyCaller {\r\n        require (increaseAmount <= address(this).balance, \"Increase amount larger than balance.\");\r\n        require (jackpotSize + increaseAmount <= address(this).balance, \"Not enough funds.\");\r\n        jackpotSize += uint128(increaseAmount);\r\n    }\r\n\r\n    function payJackpotReward(address payable to) external onlyCaller{\r\n        to.transfer(jackpotSize);\r\n        jackpotSize = 0;\r\n    }\r\n\r\n    function getJackpotSize() external view returns (uint256){\r\n        return jackpotSize;\r\n    }\r\n\r\n    function increaseRankingReward(uint amount) public onlyCaller{\r\n        require (amount <= address(this).balance, \"Increase amount larger than balance.\");\r\n        require (rankingRewardSize + amount <= address(this).balance, \"Not enough funds.\");\r\n        rankingRewardSize += uint128(amount);\r\n    }\r\n\r\n    function payRankingReward(address payable to) external onlyCaller {\r\n        uint128 prize = rankingRewardSize / 2;\r\n        rankingRewardSize = rankingRewardSize - prize;\r\n        if(to.send(prize)){\r\n            emit RankingRewardPayment(to, prize);\r\n        }\r\n    }\r\n\r\n    function getRankingRewardSize() external view returns (uint128){\r\n        return rankingRewardSize;\r\n    }\r\n}\r\ncontract CryptoTycoonsConstants{\r\n    /// *** Constants section\r\n\r\n    // Each bet is deducted 1% in favour of the house, but no less than some minimum.\r\n    // The lower bound is dictated by gas costs of the settleBet transaction, providing\r\n    // headroom for up to 10 Gwei prices.\r\n    uint constant HOUSE_EDGE_PERCENT = 1;\r\n    uint constant RANK_FUNDS_PERCENT = 7;\r\n    uint constant INVITER_BENEFIT_PERCENT = 7;\r\n    uint constant HOUSE_EDGE_MINIMUM_AMOUNT = 0.0004 ether;\r\n\r\n    // Bets lower than this amount do not participate in jackpot rolls (and are\r\n    // not deducted JACKPOT_FEE).\r\n    uint constant MIN_JACKPOT_BET = 0.1 ether;\r\n\r\n    // Chance to win jackpot (currently 0.1%) and fee deducted into jackpot fund.\r\n    uint constant JACKPOT_MODULO = 1000;\r\n    uint constant JACKPOT_FEE = 0.001 ether;\r\n\r\n    // There is minimum and maximum bets.\r\n    uint constant MIN_BET = 0.01 ether;\r\n    uint constant MAX_AMOUNT = 10 ether;\r\n\r\n    // Standard contract ownership transfer.\r\n    address payable public owner;\r\n    address payable private nextOwner;\r\n\r\n    // Croupier account.\r\n    mapping (address => bool ) croupierMap;\r\n\r\n    // Adjustable max bet profit. Used to cap bets against dynamic odds.\r\n    uint public maxProfit;\r\n\r\n    address payable public VIPLibraryAddress;\r\n\r\n    // The address corresponding to a private key used to sign placeBet commits.\r\n    address public secretSigner;\r\n\r\n    // Events that are issued to make statistic recovery easier.\r\n    event FailedPayment(address indexed beneficiary, uint amount);\r\n    event VIPPayback(address indexed beneficiary, uint amount);\r\n    event WithdrawFunds(address indexed beneficiary, uint amount);\r\n\r\n    constructor (uint _maxProfit) public {\r\n        owner = msg.sender;\r\n        secretSigner = owner;\r\n        maxProfit = _maxProfit;\r\n        croupierMap[owner] = true;\r\n    }\r\n\r\n    // Standard modifier on methods invokable only by contract owner.\r\n    modifier onlyOwner {\r\n        require (msg.sender == owner, \"OnlyOwner methods called by non-owner.\");\r\n        _;\r\n    }\r\n\r\n    // Standard modifier on methods invokable only by contract owner.\r\n    modifier onlyCroupier {\r\n        bool isCroupier = croupierMap[msg.sender];\r\n        require(isCroupier, \"OnlyCroupier methods called by non-croupier.\");\r\n        _;\r\n    }\r\n\r\n\r\n    // Fallback function deliberately left empty. It's primary use case\r\n    // is to top up the bank roll.\r\n    function () external payable {\r\n\r\n    }\r\n\r\n    // Standard contract ownership transfer implementation,\r\n    function approveNextOwner(address payable _nextOwner) external onlyOwner {\r\n        require (_nextOwner != owner, \"Cannot approve current owner.\");\r\n        nextOwner = _nextOwner;\r\n    }\r\n\r\n    function acceptNextOwner() external {\r\n        require (msg.sender == nextOwner, \"Can only accept preapproved new owner.\");\r\n        owner = nextOwner;\r\n    }\r\n\r\n    // See comment for \"secretSigner\" variable.\r\n    function setSecretSigner(address newSecretSigner) external onlyOwner {\r\n        secretSigner = newSecretSigner;\r\n    }\r\n\r\n    function getSecretSigner() external onlyOwner view returns(address){\r\n        return secretSigner;\r\n    }\r\n\r\n    function addCroupier(address newCroupier) external onlyOwner {\r\n        bool isCroupier = croupierMap[newCroupier];\r\n        if (isCroupier == false) {\r\n            croupierMap[newCroupier] = true;\r\n        }\r\n    }\r\n    \r\n    function deleteCroupier(address newCroupier) external onlyOwner {\r\n        bool isCroupier = croupierMap[newCroupier];\r\n        if (isCroupier == true) {\r\n            croupierMap[newCroupier] = false;\r\n        }\r\n    }\r\n\r\n    function setVIPLibraryAddress(address payable addr) external onlyOwner{\r\n        VIPLibraryAddress = addr;\r\n    }\r\n\r\n    // Change max bet reward. Setting this to zero effectively disables betting.\r\n    function setMaxProfit(uint _maxProfit) public onlyOwner {\r\n        require (_maxProfit < MAX_AMOUNT, \"maxProfit should be a sane number.\");\r\n        maxProfit = _maxProfit;\r\n    }\r\n    \r\n    // Funds withdrawal to cover costs of AceDice operation.\r\n    function withdrawFunds(address payable beneficiary, uint withdrawAmount) external onlyOwner {\r\n        require (withdrawAmount <= address(this).balance, \"Increase amount larger than balance.\");\r\n        if (beneficiary.send(withdrawAmount)){\r\n            emit WithdrawFunds(beneficiary, withdrawAmount);\r\n        }\r\n    }\r\n\r\n    function kill() external onlyOwner {\r\n        // require (lockedInBets == 0, \"All bets should be processed (settled or refunded) before self-destruct.\");\r\n        selfdestruct(owner);\r\n    }\r\n\r\n    function thisBalance() public view returns(uint) {\r\n        return address(this).balance;\r\n    }\r\n\r\n    function payTodayReward(address payable to) external onlyOwner {\r\n        CryptoTycoonsVIPLib vipLib = CryptoTycoonsVIPLib(VIPLibraryAddress);\r\n        vipLib.payRankingReward(to);\r\n    }\r\n\r\n    function getRankingRewardSize() external view returns (uint128) {\r\n        CryptoTycoonsVIPLib vipLib = CryptoTycoonsVIPLib(VIPLibraryAddress);\r\n        return vipLib.getRankingRewardSize();\r\n    }\r\n        \r\n    function handleVIPPaybackAndExp(CryptoTycoonsVIPLib vipLib, address payable gambler, uint amount) internal returns(uint vipPayback) {\r\n        // CryptoTycoonsVIPLib vipLib = CryptoTycoonsVIPLib(VIPLibraryAddress);\r\n        vipLib.addUserExp(gambler, amount);\r\n\r\n        uint rate = vipLib.getVIPBounusRate(gambler);\r\n\r\n        if (rate <= 0)\r\n            return 0;\r\n\r\n        vipPayback = amount * rate / 10000;\r\n        if(vipPayback > 0){\r\n            emit VIPPayback(gambler, vipPayback);\r\n        }\r\n    }\r\n\r\n    function increaseRankingFund(CryptoTycoonsVIPLib vipLib, uint amount) internal{\r\n        uint rankingFunds = uint128(amount * HOUSE_EDGE_PERCENT / 100 * RANK_FUNDS_PERCENT /100);\r\n        // uint128 rankingRewardFee = uint128(amount * HOUSE_EDGE_PERCENT / 100 * 9 /100);\r\n        VIPLibraryAddress.transfer(rankingFunds);\r\n        vipLib.increaseRankingReward(rankingFunds);\r\n    }\r\n\r\n    function getMyAccuAmount() external view returns (uint){\r\n        CryptoTycoonsVIPLib vipLib = CryptoTycoonsVIPLib(VIPLibraryAddress);\r\n        return vipLib.getUserExp(msg.sender);\r\n    }\r\n\r\n    function getJackpotSize() external view returns (uint){\r\n        CryptoTycoonsVIPLib vipLib = CryptoTycoonsVIPLib(VIPLibraryAddress);\r\n        return vipLib.getJackpotSize();\r\n    }\r\n   \r\n    function verifyCommit(uint commit, uint8 v, bytes32 r, bytes32 s) internal view {\r\n        // Check that commit is valid - it has not expired and its signature is valid.\r\n        // require (block.number <= commitLastBlock, \"Commit has expired.\");\r\n        //bytes32 signatureHash = keccak256(abi.encodePacked(commitLastBlock, commit));\r\n        bytes memory prefix = \"\\x19Ethereum Signed Message:\\n32\";\r\n        bytes memory message = abi.encodePacked(commit);\r\n        bytes32 messageHash = keccak256(abi.encodePacked(prefix, keccak256(message)));\r\n        require (secretSigner == ecrecover(messageHash, v, r, s), \"ECDSA signature is not valid.\");\r\n    }\r\n\r\n    function calcHouseEdge(uint amount) public pure returns (uint houseEdge) {\r\n        // 0.02\r\n        houseEdge = amount * HOUSE_EDGE_PERCENT / 100;\r\n        if (houseEdge < HOUSE_EDGE_MINIMUM_AMOUNT) {\r\n            houseEdge = HOUSE_EDGE_MINIMUM_AMOUNT;\r\n        }\r\n    }\r\n\r\n    function calcJackpotFee(uint amount) internal pure returns (uint jackpotFee) {\r\n        // 0.001\r\n        if (amount >= MIN_JACKPOT_BET) {\r\n            jackpotFee = JACKPOT_FEE;\r\n        }\r\n    }\r\n\r\n    function calcRankFundsFee(uint amount) internal pure returns (uint rankFundsFee) {\r\n        // 0.01 * 0.07\r\n        rankFundsFee = amount * RANK_FUNDS_PERCENT / 10000;\r\n    }\r\n\r\n    function calcInviterBenefit(uint amount) internal pure returns (uint invitationFee) {\r\n        // 0.01 * 0.07\r\n        invitationFee = amount * INVITER_BENEFIT_PERCENT / 10000;\r\n    }\r\n\r\n    function processBet(\r\n        uint betMask, uint reveal, \r\n        uint8 v, bytes32 r, bytes32 s, address payable inviter) \r\n    external payable;\r\n}\r\n\r\ncontract AceDice is CryptoTycoonsConstants(10 ether) {\r\n    \r\n    event Payment(address indexed beneficiary, uint amount, uint dice, uint rollUnder, uint betAmount);\r\n    event JackpotPayment(address indexed beneficiary, uint amount, uint dice, uint rollUnder, uint betAmount);\r\n\r\n    function processBet(\r\n        uint betMask, uint reveal, \r\n        uint8 v, bytes32 r, bytes32 s, address payable inviter) \r\n        external payable {\r\n\r\n        address payable gambler = msg.sender;\r\n\r\n        // Validate input data ranges.\r\n        uint amount = msg.value;\r\n        // require (modulo > 1 && modulo <= MAX_MODULO, \"Modulo should be within range.\");\r\n        require (amount >= MIN_BET && amount <= MAX_AMOUNT, \"Amount should be within range.\");\r\n        require (betMask > 0 && betMask <= 96, \"Mask should be within range.\");\r\n        if (inviter != address(0)){\r\n            require(gambler != inviter, \"cannot invite myself\");\r\n        }\r\n\r\n        uint commit = uint(keccak256(abi.encodePacked(reveal)));\r\n        verifyCommit(commit, v, r, s);\r\n\r\n        require (betMask > 0 && betMask <= 100, \"High modulo range, betMask larger than modulo.\");\r\n      \r\n        uint possibleWinAmount;\r\n        uint jackpotFee;\r\n\r\n        (possibleWinAmount, jackpotFee) = getDiceWinAmount(amount, betMask);\r\n\r\n        require (possibleWinAmount <= amount + maxProfit, \"maxProfit limit violation. \");\r\n\r\n        require (possibleWinAmount <= address(this).balance, \"Cannot afford to lose this bet.\");\r\n\r\n\r\n        bytes32 entropy = keccak256(abi.encodePacked(reveal, blockhash(block.number)));\r\n\r\n        processReward(gambler, amount, betMask, entropy, inviter);\r\n    }\r\n\r\n    function processReward(\r\n        address payable gambler, uint amount, \r\n        uint betMask, bytes32 entropy, address payable inviter) internal{\r\n\r\n        uint dice = uint(entropy) % 100;\r\n\r\n        CryptoTycoonsVIPLib vipLib = CryptoTycoonsVIPLib(VIPLibraryAddress);\r\n        // 1. increate vip exp\r\n        uint payAmount = handleVIPPaybackAndExp(vipLib, msg.sender, amount);\r\n\r\n        uint diceWinAmount;\r\n        uint _jackpotFee;\r\n        (diceWinAmount, _jackpotFee) = getDiceWinAmount(amount, betMask);\r\n\r\n        uint jackpotWin = 0;\r\n       \r\n        // Roll for a jackpot (if eligible).\r\n        if (amount >= MIN_JACKPOT_BET) {\r\n                        \r\n            VIPLibraryAddress.transfer(_jackpotFee);\r\n            vipLib.increaseJackpot(_jackpotFee);\r\n\r\n            // The second modulo, statistically independent from the \"main\" dice roll.\r\n            // Effectively you are playing two games at once!\r\n            // uint jackpotRng = (uint(entropy) / modulo) % JACKPOT_MODULO;\r\n\r\n            // Bingo!\r\n            if ((uint(entropy) / 100) % JACKPOT_MODULO == 0) {\r\n                jackpotWin = vipLib.getJackpotSize();\r\n                vipLib.payJackpotReward(gambler);\r\n            }\r\n        }\r\n\r\n        // Log jackpot win.\r\n        if (jackpotWin > 0) {\r\n            emit JackpotPayment(gambler, jackpotWin, dice, betMask, amount);\r\n        }\r\n\r\n        if(inviter != address(0)){\r\n            // pay 10% of house edge to inviter\r\n            inviter.transfer(amount * HOUSE_EDGE_PERCENT / 100 * INVITER_BENEFIT_PERCENT /100);\r\n        }\r\n\r\n        increaseRankingFund(vipLib, amount);\r\n\r\n        if (dice < betMask) {\r\n            payAmount += diceWinAmount;\r\n        }\r\n        \r\n        if(payAmount > 0){\r\n            if (gambler.send(payAmount)) {\r\n                emit Payment(gambler, payAmount, dice, betMask, amount);\r\n            } else {\r\n                emit FailedPayment(gambler, amount);\r\n            }\r\n        } else {\r\n            emit Payment(gambler, payAmount, dice, betMask, amount);\r\n        }\r\n        \r\n        // Send the funds to gambler.\r\n        // sendFunds(gambler, diceWin == 0 ? 1 wei : diceWin, diceWin, dice, betMask, amount);\r\n    }\r\n\r\n    // Get the expected win amount after house edge is subtracted.\r\n    function getDiceWinAmount(uint amount, uint rollUnder) private pure returns (uint winAmount, uint jackpotFee) {\r\n        require (0 < rollUnder && rollUnder <= 100, \"Win probability out of range.\");\r\n\r\n        jackpotFee = amount >= MIN_JACKPOT_BET ? JACKPOT_FEE : 0;\r\n\r\n        uint houseEdge = amount * HOUSE_EDGE_PERCENT / 100;\r\n\r\n        if (houseEdge < HOUSE_EDGE_MINIMUM_AMOUNT) {\r\n            houseEdge = HOUSE_EDGE_MINIMUM_AMOUNT;\r\n        }\r\n\r\n        require (houseEdge + jackpotFee <= amount, \"Bet doesn't even cover house edge.\");\r\n        winAmount = (amount - houseEdge - jackpotFee) * 100 / rollUnder;\r\n    }\r\n\r\n        \r\n    // Helper routine to process the payment.\r\n    // function sendFunds(address payable beneficiary, uint amount, uint successLogAmount, uint dice, uint rollUnder, uint betAmount) internal {\r\n        \r\n    // }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"thisBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"}],\"name\":\"payTodayReward\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"setVIPLibraryAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"kill\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newCroupier\",\"type\":\"address\"}],\"name\":\"addCroupier\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"calcHouseEdge\",\"outputs\":[{\"name\":\"houseEdge\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"secretSigner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getRankingRewardSize\",\"outputs\":[{\"name\":\"\",\"type\":\"uint128\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getMyAccuAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getSecretSigner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"VIPLibraryAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxProfit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"beneficiary\",\"type\":\"address\"},{\"name\":\"withdrawAmount\",\"type\":\"uint256\"}],\"name\":\"withdrawFunds\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"betMask\",\"type\":\"uint256\"},{\"name\":\"reveal\",\"type\":\"uint256\"},{\"name\":\"v\",\"type\":\"uint8\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"},{\"name\":\"inviter\",\"type\":\"address\"}],\"name\":\"processBet\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptNextOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newCroupier\",\"type\":\"address\"}],\"name\":\"deleteCroupier\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_nextOwner\",\"type\":\"address\"}],\"name\":\"approveNextOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newSecretSigner\",\"type\":\"address\"}],\"name\":\"setSecretSigner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getJackpotSize\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_maxProfit\",\"type\":\"uint256\"}],\"name\":\"setMaxProfit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"dice\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"rollUnder\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"betAmount\",\"type\":\"uint256\"}],\"name\":\"Payment\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"dice\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"rollUnder\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"betAmount\",\"type\":\"uint256\"}],\"name\":\"JackpotPayment\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"FailedPayment\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"VIPPayback\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"WithdrawFunds\",\"type\":\"event\"}]","ContractName":"AceDice","CompilerVersion":"v0.5.2+commit.1df8f40c","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://050ff086e476b322d89aae3debd2b4067de49b94708751795eaad40d46f323f2"}]}