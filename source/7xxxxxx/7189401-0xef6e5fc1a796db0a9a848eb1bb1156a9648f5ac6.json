{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.2;\r\n\r\n// File: contracts/Oracle/DSMath.sol\r\n\r\ncontract DSMath {\r\n    /*\r\n    standard uint256 functions\r\n     */\r\n\r\n    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        assert((z = x + y) >= x);\r\n    }\r\n\r\n    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        assert((z = x - y) <= x);\r\n    }\r\n\r\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        assert((z = x * y) >= x);\r\n    }\r\n\r\n    function div(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        z = x / y;\r\n    }\r\n\r\n    function min(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        return x <= y ? x : y;\r\n    }\r\n\r\n    function max(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        return x >= y ? x : y;\r\n    }\r\n\r\n    /*\r\n    uint128 functions (h is for half)\r\n     */\r\n\r\n    function hadd(uint128 x, uint128 y) internal pure returns (uint128 z) {\r\n        assert((z = x + y) >= x);\r\n    }\r\n\r\n    function hsub(uint128 x, uint128 y) internal pure returns (uint128 z) {\r\n        assert((z = x - y) <= x);\r\n    }\r\n\r\n    function hmul(uint128 x, uint128 y) internal pure returns (uint128 z) {\r\n        assert((z = x * y) >= x);\r\n    }\r\n\r\n    function hdiv(uint128 x, uint128 y) internal pure returns (uint128 z) {\r\n        z = x / y;\r\n    }\r\n\r\n    function hmin(uint128 x, uint128 y) internal pure returns (uint128 z) {\r\n        return x <= y ? x : y;\r\n    }\r\n\r\n    function hmax(uint128 x, uint128 y) internal pure returns (uint128 z) {\r\n        return x >= y ? x : y;\r\n    }\r\n\r\n    /*\r\n    int256 functions\r\n     */\r\n\r\n    function imin(int256 x, int256 y) internal pure returns (int256 z) {\r\n        return x <= y ? x : y;\r\n    }\r\n\r\n    function imax(int256 x, int256 y) internal pure returns (int256 z) {\r\n        return x >= y ? x : y;\r\n    }\r\n\r\n    /*\r\n    WAD math\r\n     */\r\n\r\n    uint128 constant WAD = 10 ** 18;\r\n\r\n    function wadd(uint128 x, uint128 y) internal pure returns (uint128) {\r\n        return hadd(x, y);\r\n    }\r\n\r\n    function wsub(uint128 x, uint128 y) internal pure returns (uint128) {\r\n        return hsub(x, y);\r\n    }\r\n\r\n    function wmul(uint128 x, uint128 y) internal pure returns (uint128 z) {\r\n        z = cast((uint256(x) * y + WAD / 2) / WAD);\r\n    }\r\n\r\n    function wdiv(uint128 x, uint128 y) internal pure returns (uint128 z) {\r\n        z = cast((uint256(x) * WAD + y / 2) / y);\r\n    }\r\n\r\n    function wmin(uint128 x, uint128 y) internal pure returns (uint128) {\r\n        return hmin(x, y);\r\n    }\r\n\r\n    function wmax(uint128 x, uint128 y) internal pure returns (uint128) {\r\n        return hmax(x, y);\r\n    }\r\n\r\n    /*\r\n    RAY math\r\n     */\r\n\r\n    uint128 constant RAY = 10 ** 27;\r\n\r\n    function radd(uint128 x, uint128 y) internal pure returns (uint128) {\r\n        return hadd(x, y);\r\n    }\r\n\r\n    function rsub(uint128 x, uint128 y) internal pure returns (uint128) {\r\n        return hsub(x, y);\r\n    }\r\n\r\n    function rmul(uint128 x, uint128 y) internal pure returns (uint128 z) {\r\n        z = cast((uint256(x) * y + RAY / 2) / RAY);\r\n    }\r\n\r\n    function rdiv(uint128 x, uint128 y) internal pure returns (uint128 z) {\r\n        z = cast((uint256(x) * RAY + y / 2) / y);\r\n    }\r\n\r\n    function rpow(uint128 x, uint64 n) internal pure returns (uint128 z) {\r\n        // This famous algorithm is called \"exponentiation by squaring\"\r\n        // and calculates x^n with x as fixed-point and n as regular unsigned.\r\n        //\r\n        // It's O(log n), instead of O(n) for naive repeated multiplication.\r\n        //\r\n        // These facts are why it works:\r\n        //\r\n        //  If n is even, then x^n = (x^2)^(n/2).\r\n        //  If n is odd,  then x^n = x * x^(n-1),\r\n        //   and applying the equation for even x gives\r\n        //    x^n = x * (x^2)^((n-1) / 2).\r\n        //\r\n        //  Also, EVM division is flooring and\r\n        //    floor[(n-1) / 2] = floor[n / 2].\r\n\r\n        z = n % 2 != 0 ? x : RAY;\r\n\r\n        for (n /= 2; n != 0; n /= 2) {\r\n            x = rmul(x, x);\r\n\r\n            if (n % 2 != 0) {\r\n                z = rmul(z, x);\r\n            }\r\n        }\r\n    }\r\n\r\n    function rmin(uint128 x, uint128 y) internal pure returns (uint128) {\r\n        return hmin(x, y);\r\n    }\r\n\r\n    function rmax(uint128 x, uint128 y) internal pure returns (uint128) {\r\n        return hmax(x, y);\r\n    }\r\n\r\n    function cast(uint256 x) internal pure returns (uint128 z) {\r\n        assert((z = uint128(x)) == x);\r\n    }\r\n\r\n}\r\n\r\n// File: contracts/Oracle/DSAuth.sol\r\n\r\ncontract DSAuthority {\r\n    function canCall(address src, address dst, bytes4 sig) public view returns (bool);\r\n}\r\n\r\n\r\ncontract DSAuthEvents {\r\n    event LogSetAuthority(address indexed authority);\r\n    event LogSetOwner(address indexed owner);\r\n}\r\n\r\n\r\ncontract DSAuth is DSAuthEvents {\r\n    DSAuthority public authority;\r\n    address public owner;\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n        emit LogSetOwner(msg.sender);\r\n    }\r\n\r\n    function setOwner(address owner_) public auth {\r\n        owner = owner_;\r\n        emit LogSetOwner(owner);\r\n    }\r\n\r\n    function setAuthority(DSAuthority authority_) public auth {\r\n        authority = authority_;\r\n        emit LogSetAuthority(address(authority));\r\n    }\r\n\r\n    modifier auth {\r\n        require(isAuthorized(msg.sender, msg.sig), \"It must be an authorized call\");\r\n        _;\r\n    }\r\n\r\n    function isAuthorized(address src, bytes4 sig) internal view returns (bool) {\r\n        if (src == address(this)) {\r\n            return true;\r\n        } else if (src == owner) {\r\n            return true;\r\n        } else if (authority == DSAuthority(0)) {\r\n            return false;\r\n        } else {\r\n            return authority.canCall(src, address(this), sig);\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/Oracle/DSNote.sol\r\n\r\ncontract DSNote {\r\n    event LogNote(\r\n        bytes4 indexed sig,\r\n        address indexed guy,\r\n        bytes32 indexed foo,\r\n        bytes32 bar,\r\n        uint wad,\r\n        bytes fax\r\n    );\r\n\r\n    modifier note {\r\n        bytes32 foo;\r\n        bytes32 bar;\r\n        // solium-disable-next-line security/no-inline-assembly\r\n        assembly {\r\n            foo := calldataload(4)\r\n            bar := calldataload(36)\r\n        }\r\n\r\n        emit LogNote(\r\n            msg.sig,\r\n            msg.sender,\r\n            foo,\r\n            bar,\r\n            msg.value,\r\n            msg.data\r\n        );\r\n\r\n        _;\r\n    }\r\n}\r\n\r\n// File: contracts/Oracle/DSThing.sol\r\n\r\ncontract DSThing is DSAuth, DSNote, DSMath {}\r\n\r\n// File: contracts/Oracle/PriceFeed.sol\r\n\r\n/// price-feed.sol\r\n\r\n// Copyright (C) 2017  DappHub, LLC\r\n\r\n// Licensed under the Apache License, Version 2.0 (the \"License\").\r\n// You may not use this file except in compliance with the License.\r\n\r\n// Unless required by applicable law or agreed to in writing, software\r\n// distributed under the License is distributed on an \"AS IS\" BASIS,\r\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND (express or implied).\r\n\r\n\r\n\r\ncontract PriceFeed is DSThing {\r\n    uint128 val;\r\n    uint32 public zzz;\r\n\r\n    function peek() public view returns (bytes32, bool) {\r\n        return (bytes32(uint256(val)), block.timestamp < zzz);\r\n    }\r\n\r\n    function read() public view returns (bytes32) {\r\n        assert(block.timestamp < zzz);\r\n        return bytes32(uint256(val));\r\n    }\r\n\r\n    function post(uint128 val_, uint32 zzz_, address med_) public payable note auth {\r\n        val = val_;\r\n        zzz = zzz_;\r\n        (bool success, ) = med_.call(abi.encodeWithSignature(\"poke()\"));\r\n        require(success, \"The poke must succeed\");\r\n    }\r\n\r\n    function void() public payable note auth {\r\n        zzz = 0;\r\n    }\r\n\r\n}\r\n\r\n// File: contracts/Oracle/DSValue.sol\r\n\r\ncontract DSValue is DSThing {\r\n    bool has;\r\n    bytes32 val;\r\n    function peek() public view returns (bytes32, bool) {\r\n        return (val, has);\r\n    }\r\n\r\n    function read() public view returns (bytes32) {\r\n        (bytes32 wut, bool _has) = peek();\r\n        assert(_has);\r\n        return wut;\r\n    }\r\n\r\n    function poke(bytes32 wut) public payable note auth {\r\n        val = wut;\r\n        has = true;\r\n    }\r\n\r\n    function void() public payable note auth {\r\n        // unset the value\r\n        has = false;\r\n    }\r\n}\r\n\r\n// File: contracts/Oracle/Medianizer.sol\r\n\r\ncontract Medianizer is DSValue {\r\n    mapping(bytes12 => address) public values;\r\n    mapping(address => bytes12) public indexes;\r\n    bytes12 public next = bytes12(uint96(1));\r\n    uint96 public minimun = 0x1;\r\n\r\n    function set(address wat) public auth {\r\n        bytes12 nextId = bytes12(uint96(next) + 1);\r\n        assert(nextId != 0x0);\r\n        set(next, wat);\r\n        next = nextId;\r\n    }\r\n\r\n    function set(bytes12 pos, address wat) public payable note auth {\r\n        require(pos != 0x0, \"pos cannot be 0x0\");\r\n        require(wat == address(0) || indexes[wat] == 0, \"wat is not defined or it has an index\");\r\n\r\n        indexes[values[pos]] = bytes12(0); // Making sure to remove a possible existing address in that position\r\n\r\n        if (wat != address(0)) {\r\n            indexes[wat] = pos;\r\n        }\r\n\r\n        values[pos] = wat;\r\n    }\r\n\r\n    function setMin(uint96 min_) public payable note auth {\r\n        require(min_ != 0x0, \"min cannot be 0x0\");\r\n        minimun = min_;\r\n    }\r\n\r\n    function setNext(bytes12 next_) public payable note auth {\r\n        require(next_ != 0x0, \"next cannot be 0x0\");\r\n        next = next_;\r\n    }\r\n\r\n    function unset(bytes12 pos) public {\r\n        set(pos, address(0));\r\n    }\r\n\r\n    function unset(address wat) public {\r\n        set(indexes[wat], address(0));\r\n    }\r\n\r\n    function poke() public {\r\n        poke(0);\r\n    }\r\n\r\n    function poke(bytes32) public payable note {\r\n        (val, has) = compute();\r\n    }\r\n\r\n    function compute() public view returns (bytes32, bool) {\r\n        bytes32[] memory wuts = new bytes32[](uint96(next) - 1);\r\n        uint96 ctr = 0;\r\n        for (uint96 i = 1; i < uint96(next); i++) {\r\n            if (values[bytes12(i)] != address(0)) {\r\n                (bytes32 wut, bool wuz) = DSValue(values[bytes12(i)]).peek();\r\n                if (wuz) {\r\n                    if (ctr == 0 || wut >= wuts[ctr - 1]) {\r\n                        wuts[ctr] = wut;\r\n                    } else {\r\n                        uint96 j = 0;\r\n                        while (wut >= wuts[j]) {\r\n                            j++;\r\n                        }\r\n                        for (uint96 k = ctr; k > j; k--) {\r\n                            wuts[k] = wuts[k - 1];\r\n                        }\r\n                        wuts[j] = wut;\r\n                    }\r\n                    ctr++;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (ctr < minimun)\r\n            return (val, false);\r\n\r\n        bytes32 value;\r\n        if (ctr % 2 == 0) {\r\n            uint128 val1 = uint128(uint(wuts[(ctr / 2) - 1]));\r\n            uint128 val2 = uint128(uint(wuts[ctr / 2]));\r\n            value = bytes32(uint256(wdiv(hadd(val1, val2), 2 ether)));\r\n        } else {\r\n            value = wuts[(ctr - 1) / 2];\r\n        }\r\n\r\n        return (value, true);\r\n    }\r\n}\r\n\r\n// File: contracts/Oracle/PriceOracleInterface.sol\r\n\r\n/*\r\nThis contract is the interface between the MakerDAO priceFeed and our DX platform.\r\n*/\r\n\r\n\r\n\r\n\r\ncontract PriceOracleInterface {\r\n    address public priceFeedSource;\r\n    address public owner;\r\n    bool public emergencyMode;\r\n\r\n    // Modifiers\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"Only the owner can do the operation\");\r\n        _;\r\n    }\r\n\r\n    /// @dev constructor of the contract\r\n    /// @param _priceFeedSource address of price Feed Source -> should be maker feeds Medianizer contract\r\n    constructor(address _owner, address _priceFeedSource) public {\r\n        owner = _owner;\r\n        priceFeedSource = _priceFeedSource;\r\n    }\r\n    \r\n    /// @dev gives the owner the possibility to put the Interface into an emergencyMode, which will\r\n    /// output always a price of 600 USD. This gives everyone time to set up a new pricefeed.\r\n    function raiseEmergency(bool _emergencyMode) public onlyOwner {\r\n        emergencyMode = _emergencyMode;\r\n    }\r\n\r\n    /// @dev updates the priceFeedSource\r\n    /// @param _owner address of owner\r\n    function updateCurator(address _owner) public onlyOwner {\r\n        owner = _owner;\r\n    }\r\n\r\n    /// @dev returns the USDETH price\r\n    function getUsdEthPricePeek() public view returns (bytes32 price, bool valid) {\r\n        return Medianizer(priceFeedSource).peek();\r\n    }\r\n\r\n    /// @dev returns the USDETH price, ie gets the USD price from Maker feed with 18 digits, but last 18 digits are cut off\r\n    function getUSDETHPrice() public view returns (uint256) {\r\n        // if the contract is in the emergencyMode, because there is an issue with the oracle, we will simply return a price of 600 USD\r\n        if (emergencyMode) {\r\n            return 600;\r\n        }\r\n        (bytes32 price, ) = Medianizer(priceFeedSource).peek();\r\n\r\n        // ensuring that there is no underflow or overflow possible,\r\n        // even if the price is compromised\r\n        uint priceUint = uint256(price)/(1 ether);\r\n        if (priceUint == 0) {\r\n            return 1;\r\n        }\r\n        if (priceUint > 1000000) {\r\n            return 1000000; \r\n        }\r\n        return priceUint;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"emergencyMode\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"updateCurator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getUsdEthPricePeek\",\"outputs\":[{\"name\":\"price\",\"type\":\"bytes32\"},{\"name\":\"valid\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_emergencyMode\",\"type\":\"bool\"}],\"name\":\"raiseEmergency\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getUSDETHPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"priceFeedSource\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_priceFeedSource\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"}]","ContractName":"PriceOracleInterface","CompilerVersion":"v0.5.2+commit.1df8f40c","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000b1f919db227048a1a45883138b9d12b9ef03df25000000000000000000000000729d19f657bd0614b4985cf1d82531c67569197b","Library":"","SwarmSource":"bzzr://51db69e24ea4038f1851c1ffa11b05ed298160919acaddf9522175b409108269"}]}