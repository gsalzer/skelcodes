{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.0;\r\n// produced by the Solididy File Flattener (c) David Appleton 2018\r\n// contact : dave@akomba.com\r\n// released under Apache 2.0 licence\r\n\r\nlibrary RLPReader {\r\n    uint8 constant STRING_SHORT_START = 0x80;\r\n    uint8 constant STRING_LONG_START  = 0xb8;\r\n    uint8 constant LIST_SHORT_START   = 0xc0;\r\n    uint8 constant LIST_LONG_START    = 0xf8;\r\n    \r\n    uint8 constant WORD_SIZE = 32;\r\n    \r\n    struct RLPItem {\r\n        uint len;\r\n        uint memPtr;\r\n    }\r\n    \r\n    /*\r\n    * @param item RLP encoded bytes\r\n    */\r\n    function toRlpItem(bytes memory item) internal pure returns (RLPItem memory) {\r\n        uint memPtr;\r\n        assembly {\r\n            memPtr := add(item, 0x20)\r\n        }\r\n        \r\n        return RLPItem(item.length, memPtr);\r\n    }\r\n    \r\n    /*\r\n    * @param item RLP encoded bytes\r\n    */\r\n    function rlpLen(RLPItem memory item) internal pure returns (uint) {\r\n        return item.len;\r\n    }\r\n    \r\n    /*\r\n    * @param item RLP encoded bytes\r\n    */\r\n    function payloadLen(RLPItem memory item) internal pure returns (uint) {\r\n        return item.len - _payloadOffset(item.memPtr);\r\n    }\r\n    \r\n    /*\r\n    * @param item RLP encoded list in bytes\r\n    */\r\n    function toList(RLPItem memory item) internal pure returns (RLPItem[] memory result) {\r\n        require(isList(item));\r\n        \r\n        uint items = numItems(item);\r\n        result = new RLPItem[](items);\r\n        \r\n        uint memPtr = item.memPtr + _payloadOffset(item.memPtr);\r\n        uint dataLen;\r\n        for (uint i = 0; i < items; i++) {\r\n            dataLen = _itemLength(memPtr);\r\n            result[i] = RLPItem(dataLen, memPtr);\r\n            memPtr = memPtr + dataLen;\r\n        }\r\n    }\r\n    \r\n    // @return indicator whether encoded payload is a list. negate this function call for isData.\r\n    function isList(RLPItem memory item) internal pure returns (bool) {\r\n        if (item.len == 0) return false;\r\n        \r\n        uint8 byte0;\r\n        uint memPtr = item.memPtr;\r\n        assembly {\r\n            byte0 := byte(0, mload(memPtr))\r\n        }\r\n        \r\n        if (byte0 < LIST_SHORT_START)\r\n            return false;\r\n        return true;\r\n    }\r\n    \r\n    /** RLPItem conversions into data types **/\r\n    \r\n    // @returns raw rlp encoding in bytes\r\n    function toRlpBytes(RLPItem memory item) internal pure returns (bytes memory) {\r\n        bytes memory result = new bytes(item.len);\r\n        if (result.length == 0) return result;\r\n        \r\n        uint ptr;\r\n        assembly {\r\n            ptr := add(0x20, result)\r\n        }\r\n        \r\n        copy(item.memPtr, ptr, item.len);\r\n        return result;\r\n    }\r\n    \r\n    // any non-zero byte is considered true\r\n    function toBoolean(RLPItem memory item) internal pure returns (bool) {\r\n        require(item.len == 1);\r\n        uint result;\r\n        uint memPtr = item.memPtr;\r\n        assembly {\r\n            result := byte(0, mload(memPtr))\r\n        }\r\n        \r\n        return result == 0 ? false : true;\r\n    }\r\n    \r\n    function toAddress(RLPItem memory item) internal pure returns (address) {\r\n        // 1 byte for the length prefix\r\n        require(item.len == 21);\r\n        \r\n        return address(toUint(item));\r\n    }\r\n    \r\n    function toUint(RLPItem memory item) internal pure returns (uint) {\r\n        require(item.len > 0 && item.len <= 33);\r\n        \r\n        uint offset = _payloadOffset(item.memPtr);\r\n        uint len = item.len - offset;\r\n        \r\n        uint result;\r\n        uint memPtr = item.memPtr + offset;\r\n        assembly {\r\n            result := mload(memPtr)\r\n        \r\n        // shfit to the correct location if neccesary\r\n            if lt(len, 32) {\r\n                result := div(result, exp(256, sub(32, len)))\r\n            }\r\n        }\r\n        \r\n        return result;\r\n    }\r\n    \r\n    // enforces 32 byte length\r\n    function toUintStrict(RLPItem memory item) internal pure returns (uint) {\r\n        // one byte prefix\r\n        require(item.len == 33);\r\n        \r\n        uint result;\r\n        uint memPtr = item.memPtr + 1;\r\n        assembly {\r\n            result := mload(memPtr)\r\n        }\r\n        \r\n        return result;\r\n    }\r\n    \r\n    function toBytes(RLPItem memory item) internal pure returns (bytes memory) {\r\n        require(item.len > 0);\r\n        \r\n        uint offset = _payloadOffset(item.memPtr);\r\n        uint len = item.len - offset; // data length\r\n        bytes memory result = new bytes(len);\r\n        \r\n        uint destPtr;\r\n        assembly {\r\n            destPtr := add(0x20, result)\r\n        }\r\n        \r\n        copy(item.memPtr + offset, destPtr, len);\r\n        return result;\r\n    }\r\n    \r\n    /*\r\n    * Private Helpers\r\n    */\r\n    \r\n    // @return number of payload items inside an encoded list.\r\n    function numItems(RLPItem memory item) private pure returns (uint) {\r\n        if (item.len == 0) return 0;\r\n        \r\n        uint count = 0;\r\n        uint currPtr = item.memPtr + _payloadOffset(item.memPtr);\r\n        uint endPtr = item.memPtr + item.len;\r\n        while (currPtr < endPtr) {\r\n            currPtr = currPtr + _itemLength(currPtr); // skip over an item\r\n            count++;\r\n        }\r\n        \r\n        return count;\r\n    }\r\n    \r\n    // @return entire rlp item byte length\r\n    function _itemLength(uint memPtr) private pure returns (uint len) {\r\n        uint byte0;\r\n        assembly {\r\n            byte0 := byte(0, mload(memPtr))\r\n        }\r\n        \r\n        if (byte0 < STRING_SHORT_START)\r\n            return 1;\r\n        \r\n        else if (byte0 < STRING_LONG_START)\r\n            return byte0 - STRING_SHORT_START + 1;\r\n        \r\n        else if (byte0 < LIST_SHORT_START) {\r\n            assembly {\r\n                let byteLen := sub(byte0, 0xb7) // # of bytes the actual length is\r\n                memPtr := add(memPtr, 1) // skip over the first byte\r\n            \r\n            /* 32 byte word size */\r\n                let dataLen := div(mload(memPtr), exp(256, sub(32, byteLen))) // right shifting to get the len\r\n                len := add(dataLen, add(byteLen, 1))\r\n            }\r\n        }\r\n        \r\n        else if (byte0 < LIST_LONG_START) {\r\n            return byte0 - LIST_SHORT_START + 1;\r\n        }\r\n        \r\n        else {\r\n            assembly {\r\n                let byteLen := sub(byte0, 0xf7)\r\n                memPtr := add(memPtr, 1)\r\n                \r\n                let dataLen := div(mload(memPtr), exp(256, sub(32, byteLen))) // right shifting to the correct length\r\n                len := add(dataLen, add(byteLen, 1))\r\n            }\r\n        }\r\n    }\r\n    \r\n    // @return number of bytes until the data\r\n    function _payloadOffset(uint memPtr) private pure returns (uint) {\r\n        uint byte0;\r\n        assembly {\r\n            byte0 := byte(0, mload(memPtr))\r\n        }\r\n        \r\n        if (byte0 < STRING_SHORT_START)\r\n            return 0;\r\n        else if (byte0 < STRING_LONG_START || (byte0 >= LIST_SHORT_START && byte0 < LIST_LONG_START))\r\n            return 1;\r\n        else if (byte0 < LIST_SHORT_START)  // being explicit\r\n            return byte0 - (STRING_LONG_START - 1) + 1;\r\n        else\r\n            return byte0 - (LIST_LONG_START - 1) + 1;\r\n    }\r\n    \r\n    /*\r\n    * @param src Pointer to source\r\n    * @param dest Pointer to destination\r\n    * @param len Amount of memory to copy from the source\r\n    */\r\n    function copy(uint src, uint dest, uint len) private pure {\r\n        if (len == 0) return;\r\n        \r\n        // copy as many word sizes as possible\r\n        for (; len >= WORD_SIZE; len -= WORD_SIZE) {\r\n            assembly {\r\n                mstore(dest, mload(src))\r\n            }\r\n            \r\n            src += WORD_SIZE;\r\n            dest += WORD_SIZE;\r\n        }\r\n        \r\n        // left over bytes. Mask is used to remove unwanted bytes from the word\r\n        uint mask = 256 ** (WORD_SIZE - len) - 1;\r\n        assembly {\r\n            let srcpart := and(mload(src), not(mask)) // zero out src\r\n            let destpart := and(mload(dest), mask) // retrieve the bytes\r\n            mstore(dest, or(destpart, srcpart))\r\n        }\r\n    }\r\n}\r\n\r\nlibrary BytesUtil {\r\n    uint8 constant WORD_SIZE = 32;\r\n\r\n    // @param _bytes raw bytes that needs to be slices\r\n    // @param start  start of the slice relative to `_bytes`\r\n    // @param len    length of the sliced byte array\r\n    function slice(bytes memory _bytes, uint start, uint len)\r\n        internal\r\n        pure\r\n        returns (bytes memory)\r\n    {\r\n        require(_bytes.length - start >= len);\r\n\r\n        if (_bytes.length == len)\r\n            return _bytes;\r\n\r\n        bytes memory result;\r\n        uint src;\r\n        uint dest;\r\n        assembly {\r\n            // memory & free memory pointer\r\n            result := mload(0x40)\r\n            mstore(result, len) // store the size in the prefix\r\n            mstore(0x40, add(result, and(add(add(0x20, len), 0x1f), not(0x1f)))) // padding\r\n\r\n            // pointers\r\n            src := add(start, add(0x20, _bytes))\r\n            dest := add(0x20, result)\r\n        }\r\n\r\n        // copy as many word sizes as possible\r\n        for(; len >= WORD_SIZE; len -= WORD_SIZE) {\r\n            assembly {\r\n                mstore(dest, mload(src))\r\n            }\r\n\r\n            src += WORD_SIZE;\r\n            dest += WORD_SIZE;\r\n        }\r\n\r\n        // copy remaining bytes\r\n        uint mask = 256 ** (WORD_SIZE - len) - 1;\r\n        assembly {\r\n            let srcpart := and(mload(src), not(mask)) // zero out src\r\n            let destpart := and(mload(dest), mask) // retrieve the bytes\r\n            mstore(dest, or(destpart, srcpart))\r\n        }\r\n\r\n        return result;\r\n    }\r\n}\r\n\r\nlibrary SafeMath {\r\n    /**\r\n    * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two signed integers, reverts on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require((b >= 0 && c >= a) || (b < 0 && c < a));\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Multiplies two unsigned integers, reverts on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    function max(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return a >= b ? a : b;\r\n    }\r\n}\r\n\r\nlibrary ECDSA {\r\n     /**\r\n     * @dev Recover signer address from a message by using their signature\r\n     * @param hash bytes32 message, the hash is the signed message. What is recovered is the signer address.\r\n     * @param signature bytes signature, the signature is generated using web3.eth.sign()\r\n     */\r\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\r\n        bytes32 r;\r\n        bytes32 s;\r\n        uint8 v;\r\n\r\n        // prefix the hash with an ethereum signed message\r\n        hash = keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\r\n\r\n        // Check the signature length\r\n        if (signature.length != 65) {\r\n            return (address(0));\r\n        }\r\n\r\n        // Divide the signature in r, s and v variables\r\n        // ecrecover takes the signature parameters, and the only way to get them\r\n        // currently is to use assembly.\r\n        // solium-disable-next-line security/no-inline-assembly\r\n        assembly {\r\n            r := mload(add(signature, 0x20))\r\n            s := mload(add(signature, 0x40))\r\n            v := byte(0, mload(add(signature, 0x60)))\r\n        }\r\n\r\n        // Version of signature should be 27 or 28, but 0 and 1 are also possible versions\r\n        if (v < 27) {\r\n            v += 27;\r\n        }\r\n\r\n        // If the version is correct return the signer address\r\n        if (v != 27 && v != 28) {\r\n            return (address(0));\r\n        } else {\r\n            // solium-disable-next-line arg-overflow\r\n            return ecrecover(hash, v, r, s);\r\n        }\r\n    }\r\n}\r\n\r\nlibrary TMSimpleMerkleTree {\r\n    using BytesUtil for bytes;\r\n\r\n    // @param leaf     a leaf of the tree\r\n    // @param index    position of this leaf in the tree that is zero indexed\r\n    // @param rootHash block header of the merkle tree\r\n    // @param proof    sequence of 32-byte hashes from the leaf up to, but excluding, the root\r\n    // @paramt total   total # of leafs in the tree\r\n    function checkMembership(bytes32 leaf, uint256 index, bytes32 rootHash, bytes memory proof, uint256 total)\r\n        internal\r\n        pure\r\n        returns (bool)\r\n    {\r\n        // variable size Merkle tree, but proof must consist of 32-byte hashes\r\n        require(proof.length % 32 == 0); // incorrect proof length\r\n\r\n        bytes32 computedHash = computeHashFromAunts(index, total, leaf, proof);\r\n        return computedHash == rootHash;\r\n    }\r\n\r\n    // helper function as described in the tendermint docs\r\n    function computeHashFromAunts(uint256 index, uint256 total, bytes32 leaf, bytes memory innerHashes)\r\n        private\r\n        pure\r\n        returns (bytes32)\r\n    {\r\n        require(index < total); // index must be within bound of the # of leave\r\n        require(total > 0); // must have one leaf node\r\n\r\n        if (total == 1) {\r\n            require(innerHashes.length == 0); // 1 txn has no proof\r\n            return leaf;\r\n        }\r\n        require(innerHashes.length != 0); // >1 txns should have a proof\r\n\r\n        uint256 numLeft = (total + 1) / 2;\r\n        bytes32 proofElement;\r\n\r\n        // prepend 0x20 byte literal to hashes\r\n        // tendermint prefixes intermediate hashes with 0x20 bytes literals\r\n        // before hashing them.\r\n        bytes memory b = new bytes(1);\r\n        assembly {\r\n            let memPtr := add(b, 0x20)\r\n            mstore8(memPtr, 0x20)\r\n        }\r\n\r\n        uint innerHashesMemOffset = innerHashes.length - 32;\r\n        if (index < numLeft) {\r\n            bytes32 leftHash = computeHashFromAunts(index, numLeft, leaf, innerHashes.slice(0, innerHashes.length - 32));\r\n            assembly {\r\n                // get the last 32-byte hash from innerHashes array\r\n                proofElement := mload(add(add(innerHashes, 0x20), innerHashesMemOffset))\r\n            }\r\n\r\n            return sha256(abi.encodePacked(b, leftHash, b, proofElement));\r\n        } else {\r\n            bytes32 rightHash = computeHashFromAunts(index-numLeft, total-numLeft, leaf, innerHashes.slice(0, innerHashes.length - 32));\r\n            assembly {\r\n                    // get the last 32-byte hash from innerHashes array\r\n                    proofElement := mload(add(add(innerHashes, 0x20), innerHashesMemOffset))\r\n            }\r\n            return sha256(abi.encodePacked(b, proofElement, b, rightHash));\r\n        }\r\n    }\r\n}\r\n\r\nlibrary MinPriorityQueue {\r\n    using SafeMath for uint256;\r\n\r\n    function insert(uint256[] storage heapList, uint256 k)\r\n        internal\r\n    {\r\n        heapList.push(k);\r\n        if (heapList.length > 1)\r\n            percUp(heapList, heapList.length.sub(1));\r\n    }\r\n\r\n    function delMin(uint256[] storage heapList)\r\n        internal\r\n        returns (uint256)\r\n    {\r\n        require(heapList.length > 0);\r\n\r\n        uint256 min = heapList[0];\r\n\r\n        // move the last element to the front\r\n        heapList[0] = heapList[heapList.length.sub(1)];\r\n        delete heapList[heapList.length.sub(1)];\r\n        heapList.length = heapList.length.sub(1);\r\n\r\n        if (heapList.length > 1) {\r\n            percDown(heapList, 0);\r\n        }\r\n\r\n        return min;\r\n    }\r\n\r\n    function minChild(uint256[] storage heapList, uint256 i)\r\n        private\r\n        view\r\n        returns (uint256)\r\n    {\r\n        uint lChild = i.mul(2).add(1);\r\n        uint rChild = i.mul(2).add(2);\r\n\r\n        if (rChild > heapList.length.sub(1) || heapList[lChild] < heapList[rChild])\r\n            return lChild;\r\n        else\r\n            return rChild;\r\n    }\r\n\r\n    function percUp(uint256[] storage heapList, uint256 i)\r\n        private\r\n    {\r\n        uint256 position = i;\r\n        uint256 value = heapList[i];\r\n\r\n        // continue to percolate up while smaller than the parent\r\n        while (i != 0 && value < heapList[i.sub(1).div(2)]) {\r\n            heapList[i] = heapList[i.sub(1).div(2)];\r\n            i = i.sub(1).div(2);\r\n        }\r\n\r\n        // place the value in the correct parent\r\n        if (position != i) heapList[i] = value;\r\n    }\r\n\r\n    function percDown(uint256[] storage heapList, uint256 i)\r\n        private\r\n    {\r\n        uint position = i;\r\n        uint value = heapList[i];\r\n\r\n        // continue to percolate down while larger than the child\r\n        uint child = minChild(heapList, i);\r\n        while(child < heapList.length && value > heapList[child]) {\r\n            heapList[i] = heapList[child];\r\n            i = child;\r\n            child = minChild(heapList, i);\r\n        }\r\n\r\n        // place value in the correct child\r\n        if (position != i) heapList[i] = value;\r\n    }\r\n}\r\n\r\ncontract PlasmaMVP {\r\n    using MinPriorityQueue for uint256[];\r\n    using BytesUtil for bytes;\r\n    using RLPReader for bytes;\r\n    using RLPReader for RLPReader.RLPItem;\r\n    using SafeMath for uint256;\r\n    using TMSimpleMerkleTree for bytes32;\r\n    using ECDSA for bytes32;\r\n\r\n    /*\r\n     * Events\r\n     */\r\n\r\n    event ChangedOperator(address oldOperator, address newOperator);\r\n\r\n    event AddedToBalances(address owner, uint256 amount);\r\n    event BlockSubmitted(bytes32 header, uint256 blockNumber, uint256 numTxns, uint256 feeAmount);\r\n    event Deposit(address depositor, uint256 amount, uint256 depositNonce, uint256 ethBlockNum);\r\n\r\n    event StartedTransactionExit(uint256[3] position, address owner, uint256 amount, bytes confirmSignatures, uint256 committedFee);\r\n    event StartedDepositExit(uint256 nonce, address owner, uint256 amount, uint256 committedFee);\r\n\r\n    event ChallengedExit(uint256[4] position, address owner, uint256 amount);\r\n    event FinalizedExit(uint256[4] position, address owner, uint256 amount);\r\n\r\n    /*\r\n     *  Storage\r\n     */\r\n\r\n    address public operator;\r\n\r\n    uint256 public lastCommittedBlock;\r\n    uint256 public depositNonce;\r\n    mapping(uint256 => plasmaBlock) public plasmaChain;\r\n    mapping(uint256 => depositStruct) public deposits;\r\n    struct plasmaBlock{\r\n        bytes32 header;\r\n        uint256 numTxns;\r\n        uint256 feeAmount;\r\n        uint256 createdAt;\r\n    }\r\n    struct depositStruct {\r\n        address owner;\r\n        uint256 amount;\r\n        uint256 createdAt;\r\n        uint256 ethBlockNum;\r\n    }\r\n\r\n    // exits\r\n    uint256 public minExitBond;\r\n    uint256[] public txExitQueue;\r\n    uint256[] public depositExitQueue;\r\n    mapping(uint256 => exit) public txExits;\r\n    mapping(uint256 => exit) public depositExits;\r\n    enum ExitState { NonExistent, Pending, Challenged, Finalized }\r\n    struct exit {\r\n        uint256 amount;\r\n        uint256 committedFee;\r\n        uint256 createdAt;\r\n        address owner;\r\n        uint256[4] position; // (blkNum, txIndex, outputIndex, depositNonce)\r\n        ExitState state; // default value is `NonExistent`\r\n    }\r\n\r\n    // funds\r\n    mapping(address => uint256) public balances;\r\n    uint256 public totalWithdrawBalance;\r\n\r\n    // constants\r\n    uint256 constant txIndexFactor = 10;\r\n    uint256 constant blockIndexFactor = 1000000;\r\n    uint256 constant lastBlockNum = 2**109;\r\n    uint256 constant feeIndex = 2**16-1;\r\n\r\n    /** Modifiers **/\r\n    modifier isBonded()\r\n    {\r\n        require(msg.value >= minExitBond);\r\n        if (msg.value > minExitBond) {\r\n            uint256 excess = msg.value.sub(minExitBond);\r\n            balances[msg.sender] = balances[msg.sender].add(excess);\r\n            totalWithdrawBalance = totalWithdrawBalance.add(excess);\r\n        }\r\n\r\n        _;\r\n    }\r\n\r\n    modifier onlyOperator()\r\n    {\r\n        require(msg.sender == operator);\r\n        _;\r\n    }\r\n\r\n    function changeOperator(address newOperator)\r\n        public\r\n        onlyOperator\r\n    {\r\n        require(newOperator != address(0));\r\n\r\n        emit ChangedOperator(operator, newOperator);\r\n        operator = newOperator;\r\n    }\r\n\r\n    constructor() public\r\n    {\r\n        operator = msg.sender;\r\n\r\n        lastCommittedBlock = 0;\r\n        depositNonce = 1;\r\n        minExitBond = 200000;\r\n    }\r\n\r\n    // @param blocks       32 byte merkle headers appended in ascending order\r\n    // @param txnsPerBlock number of transactions per block\r\n    // @param feesPerBlock amount of fees the validator has collected per block\r\n    // @param blockNum     the block number of the first header\r\n    // @notice each block is capped at 2**16-1 transactions\r\n    function submitBlock(bytes32[] memory headers, uint256[] memory txnsPerBlock, uint256[] memory feePerBlock, uint256 blockNum)\r\n        public\r\n        onlyOperator\r\n    {\r\n        require(blockNum == lastCommittedBlock.add(1));\r\n        require(headers.length == txnsPerBlock.length && txnsPerBlock.length == feePerBlock.length);\r\n\r\n        for (uint i = 0; i < headers.length && lastCommittedBlock <= lastBlockNum; i++) {\r\n            require(headers[i] != bytes32(0) && txnsPerBlock[i] > 0 && txnsPerBlock[i] < feeIndex);\r\n\r\n            lastCommittedBlock = lastCommittedBlock.add(1);\r\n            plasmaChain[lastCommittedBlock] = plasmaBlock({\r\n                header: headers[i],\r\n                numTxns: txnsPerBlock[i],\r\n                feeAmount: feePerBlock[i],\r\n                createdAt: block.timestamp\r\n            });\r\n\r\n            emit BlockSubmitted(headers[i], lastCommittedBlock, txnsPerBlock[i], feePerBlock[i]);\r\n        }\r\n   }\r\n\r\n    // @param owner owner of this deposit\r\n    function deposit(address owner)\r\n        public\r\n        payable\r\n    {\r\n        deposits[depositNonce] = depositStruct(owner, msg.value, block.timestamp, block.number);\r\n        emit Deposit(owner, msg.value, depositNonce, block.number);\r\n\r\n        depositNonce = depositNonce.add(uint256(1));\r\n    }\r\n\r\n    // @param depositNonce the nonce of the specific deposit\r\n    function startDepositExit(uint256 nonce, uint256 committedFee)\r\n        public\r\n        payable\r\n        isBonded\r\n    {\r\n        require(deposits[nonce].owner == msg.sender);\r\n        require(deposits[nonce].amount > committedFee);\r\n        require(depositExits[nonce].state == ExitState.NonExistent);\r\n\r\n        address owner = deposits[nonce].owner;\r\n        uint256 amount = deposits[nonce].amount;\r\n        uint256 priority = block.timestamp << 128 | nonce;\r\n        depositExitQueue.insert(priority);\r\n        depositExits[nonce] = exit({\r\n            owner: owner,\r\n            amount: amount,\r\n            committedFee: committedFee,\r\n            createdAt: block.timestamp,\r\n            position: [0,0,0,nonce],\r\n            state: ExitState.Pending\r\n        });\r\n\r\n        emit StartedDepositExit(nonce, owner, amount, committedFee);\r\n    }\r\n\r\n    // Transaction encoding:\r\n    // [[Blknum1, TxIndex1, Oindex1, DepositNonce1, Input1ConfirmSig,\r\n    //   Blknum2, TxIndex2, Oindex2, DepositNonce2, Input2ConfirmSig,\r\n    //   NewOwner, Denom1, NewOwner, Denom2, Fee],\r\n    //  [Signature1, Signature2]]\r\n    //\r\n    // All integers are padded to 32 bytes. Input's confirm signatures are 130 bytes for each input.\r\n    // Zero bytes if unapplicable (deposit/fee inputs) Signatures are 65 bytes in length\r\n    //\r\n    // @param txBytes rlp encoded transaction\r\n    // @notice this function will revert if the txBytes are malformed\r\n    function decodeTransaction(bytes memory txBytes)\r\n        internal\r\n        pure\r\n        returns (RLPReader.RLPItem[] memory txList, RLPReader.RLPItem[] memory sigList, bytes32 txHash)\r\n    {\r\n        // entire byte length of the rlp encoded transaction.\r\n        require(txBytes.length == 811);\r\n\r\n        RLPReader.RLPItem[] memory spendMsg = txBytes.toRlpItem().toList();\r\n        require(spendMsg.length == 2);\r\n\r\n        txList = spendMsg[0].toList();\r\n        require(txList.length == 15);\r\n\r\n        sigList = spendMsg[1].toList();\r\n        require(sigList.length == 2);\r\n\r\n        // bytes the signatures are over\r\n        txHash = keccak256(spendMsg[0].toRlpBytes());\r\n    }\r\n\r\n\r\n    // @param txPos             location of the transaction [blkNum, txIndex, outputIndex]\r\n    // @param txBytes           transaction bytes containing the exiting output\r\n    // @param proof             merkle proof of inclusion in the plasma chain\r\n    // @param confSig0          confirm signatures sent by the owners of the first input acknowledging the spend.\r\n    // @param confSig1          confirm signatures sent by the owners of the second input acknowledging the spend (if applicable).\r\n    // @notice `confirmSignatures` and `ConfirmSig0`/`ConfirmSig1` are unrelated to each other.\r\n    // @notice `confirmSignatures` is either 65 or 130 bytes in length dependent on if a second input is present\r\n    // @notice `confirmSignatures` should be empty if the output trying to be exited is a fee output\r\n    function startTransactionExit(uint256[3] memory txPos, bytes memory txBytes, bytes memory proof, bytes memory confirmSignatures, uint256 committedFee)\r\n        public\r\n        payable\r\n        isBonded\r\n    {\r\n        require(txPos[1] < feeIndex);\r\n        uint256 position = calcPosition(txPos);\r\n        require(txExits[position].state == ExitState.NonExistent);\r\n\r\n        uint256 amount = startTransactionExitHelper(txPos, txBytes, proof, confirmSignatures);\r\n        require(amount > committedFee);\r\n\r\n        // calculate the priority of the transaction taking into account the withdrawal delay attack\r\n        // withdrawal delay attack: https://github.com/FourthState/plasma-mvp-rootchain/issues/42\r\n        uint256 createdAt = plasmaChain[txPos[0]].createdAt;\r\n        txExitQueue.insert(SafeMath.max(createdAt.add(1 weeks), block.timestamp) << 128 | position);\r\n\r\n        // write exit to storage\r\n        txExits[position] = exit({\r\n            owner: msg.sender,\r\n            amount: amount,\r\n            committedFee: committedFee,\r\n            createdAt: block.timestamp,\r\n            position: [txPos[0], txPos[1], txPos[2], 0],\r\n            state: ExitState.Pending\r\n        });\r\n\r\n        emit StartedTransactionExit(txPos, msg.sender, amount, confirmSignatures, committedFee);\r\n    }\r\n\r\n    // @returns amount of the exiting transaction\r\n    // @notice the purpose of this helper was to work around the capped evm stack frame\r\n    function startTransactionExitHelper(uint256[3] memory txPos, bytes memory txBytes, bytes memory proof, bytes memory confirmSignatures)\r\n        private\r\n        view\r\n        returns (uint256)\r\n    {\r\n        bytes32 txHash;\r\n        RLPReader.RLPItem[] memory txList;\r\n        RLPReader.RLPItem[] memory sigList;\r\n        (txList, sigList, txHash) = decodeTransaction(txBytes);\r\n\r\n        uint base = txPos[2].mul(2);\r\n        require(msg.sender == txList[base.add(10)].toAddress());\r\n\r\n        plasmaBlock memory blk = plasmaChain[txPos[0]];\r\n\r\n        // Validation\r\n\r\n        bytes32 merkleHash = sha256(txBytes);\r\n        require(merkleHash.checkMembership(txPos[1], blk.header, proof, blk.numTxns));\r\n\r\n        address recoveredAddress;\r\n        bytes32 confirmationHash = sha256(abi.encodePacked(merkleHash, blk.header));\r\n\r\n        bytes memory sig = sigList[0].toBytes();\r\n        require(sig.length == 65 && confirmSignatures.length % 65 == 0 && confirmSignatures.length > 0 && confirmSignatures.length <= 130);\r\n        recoveredAddress = confirmationHash.recover(confirmSignatures.slice(0, 65));\r\n        require(recoveredAddress != address(0) && recoveredAddress == txHash.recover(sig));\r\n        if (txList[5].toUintStrict() > 0 || txList[8].toUintStrict() > 0) { // existence of a second input\r\n            sig = sigList[1].toBytes();\r\n            require(sig.length == 65 && confirmSignatures.length == 130);\r\n            recoveredAddress = confirmationHash.recover(confirmSignatures.slice(65, 65));\r\n            require(recoveredAddress != address(0) && recoveredAddress == txHash.recover(sig));\r\n        }\r\n\r\n        // check that the UTXO's two direct inputs have not been previously exited\r\n        require(validateTransactionExitInputs(txList));\r\n\r\n        return txList[base.add(11)].toUintStrict();\r\n    }\r\n\r\n    // For any attempted exit of an UTXO, validate that the UTXO's two inputs have not\r\n    // been previously exited or are currently pending an exit.\r\n    function validateTransactionExitInputs(RLPReader.RLPItem[] memory txList)\r\n        private\r\n        view\r\n        returns (bool)\r\n    {\r\n        for (uint256 i = 0; i < 2; i++) {\r\n            ExitState state;\r\n            uint256 base = uint256(5).mul(i);\r\n            uint depositNonce_ = txList[base.add(3)].toUintStrict();\r\n            if (depositNonce_ == 0) {\r\n                uint256 blkNum = txList[base].toUintStrict();\r\n                uint256 txIndex = txList[base.add(1)].toUintStrict();\r\n                uint256 outputIndex = txList[base.add(2)].toUintStrict();\r\n                uint256 position = calcPosition([blkNum, txIndex, outputIndex]);\r\n                state = txExits[position].state;\r\n            } else\r\n                state = depositExits[depositNonce_].state;\r\n\r\n            if (state != ExitState.NonExistent && state != ExitState.Challenged)\r\n                return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    // Validator of any block can call this function to exit the fees collected\r\n    // for that particular block. The fee exit is added to exit queue with the lowest priority for that block.\r\n    // In case of the fee UTXO already spent, anyone can challenge the fee exit by providing\r\n    // the spend of the fee UTXO.\r\n    // @param blockNumber the block for which the validator wants to exit fees\r\n    function startFeeExit(uint256 blockNumber, uint256 committedFee)\r\n        public\r\n        payable\r\n        onlyOperator\r\n        isBonded\r\n    {\r\n        plasmaBlock memory blk = plasmaChain[blockNumber];\r\n        require(blk.header != bytes32(0));\r\n\r\n        uint256 feeAmount = blk.feeAmount;\r\n\r\n        // nonzero fee and prevent and greater than the committed fee if spent.\r\n        // default value for a fee amount is zero. Will revert if a block for\r\n        // this number has not been committed\r\n        require(feeAmount > committedFee);\r\n\r\n        // a fee UTXO has explicitly defined position [blockNumber, 2**16 - 1, 0]\r\n        uint256 position = calcPosition([blockNumber, feeIndex, 0]);\r\n        require(txExits[position].state == ExitState.NonExistent);\r\n\r\n        txExitQueue.insert(SafeMath.max(blk.createdAt.add(1 weeks), block.timestamp) << 128 | position);\r\n\r\n        txExits[position] = exit({\r\n            owner: msg.sender,\r\n            amount: feeAmount,\r\n            committedFee: committedFee,\r\n            createdAt: block.timestamp,\r\n            position: [blockNumber, feeIndex, 0, 0],\r\n            state: ExitState.Pending\r\n        });\r\n\r\n        // pass in empty bytes for confirmSignatures for StartedTransactionExit event.\r\n        emit StartedTransactionExit([blockNumber, feeIndex, 0], operator, feeAmount, \"\", 0);\r\n}\r\n\r\n    // @param exitingTxPos     position of the invalid exiting transaction [blkNum, txIndex, outputIndex]\r\n    // @param challengingTxPos position of the challenging transaction [blkNum, txIndex]\r\n    // @param txBytes          raw transaction bytes of the challenging transaction\r\n    // @param proof            proof of inclusion for this merkle hash\r\n    // @param confirmSignature signature used to invalidate the invalid exit. Signature is over (merkleHash, block header)\r\n    // @notice The operator can challenge an exit which commits an invalid fee by simply passing in empty bytes for confirm signature as they are not needed.\r\n    //         The committed fee is checked againt the challenging tx bytes\r\n    function challengeExit(uint256[4] memory exitingTxPos, uint256[2] memory challengingTxPos, bytes memory txBytes, bytes memory proof, bytes memory confirmSignature)\r\n        public\r\n    {\r\n        bytes32 txHash;\r\n        RLPReader.RLPItem[] memory txList;\r\n        RLPReader.RLPItem[] memory sigList;\r\n        (txList, sigList, txHash) = decodeTransaction(txBytes);\r\n\r\n        // `challengingTxPos` is sequentially after `exitingTxPos`\r\n        require(exitingTxPos[0] < challengingTxPos[0] || (exitingTxPos[0] == challengingTxPos[0] && exitingTxPos[1] < challengingTxPos[1]));\r\n\r\n        // must be a direct spend\r\n        bool firstInput = exitingTxPos[0] == txList[0].toUintStrict() && exitingTxPos[1] == txList[1].toUintStrict() && exitingTxPos[2] == txList[2].toUintStrict() && exitingTxPos[3] == txList[3].toUintStrict();\r\n        require(firstInput || exitingTxPos[0] == txList[5].toUintStrict() && exitingTxPos[1] == txList[6].toUintStrict() && exitingTxPos[2] == txList[7].toUintStrict() && exitingTxPos[3] == txList[8].toUintStrict());\r\n\r\n        // transaction to be challenged should have a pending exit\r\n        exit storage exit_ = exitingTxPos[3] == 0 ? \r\n            txExits[calcPosition([exitingTxPos[0], exitingTxPos[1], exitingTxPos[2]])] : depositExits[exitingTxPos[3]];\r\n        require(exit_.state == ExitState.Pending);\r\n\r\n        plasmaBlock memory blk = plasmaChain[challengingTxPos[0]];\r\n\r\n        bytes32 merkleHash = sha256(txBytes);\r\n        require(blk.header != bytes32(0) && merkleHash.checkMembership(challengingTxPos[1], blk.header, proof, blk.numTxns));\r\n\r\n        address recoveredAddress;\r\n        // we check for confirm signatures if:\r\n        // The exiting tx is a first input and commits the correct fee\r\n        // OR\r\n        // The exiting tx is the second input in the challenging transaction\r\n        //\r\n        // If this challenge was a fee mismatch, then we check the first transaction signature\r\n        // to prevent the operator from forging invalid inclusions\r\n        //\r\n        // For a fee mismatch, the state becomes `NonExistent` so that the exit can be reopened.\r\n        // Otherwise, `Challenged` so that the exit can never be opened.\r\n        if (firstInput && exit_.committedFee != txList[14].toUintStrict()) {\r\n            bytes memory sig = sigList[0].toBytes();\r\n            recoveredAddress = txHash.recover(sig);\r\n            require(sig.length == 65 && recoveredAddress != address(0) && exit_.owner == recoveredAddress);\r\n\r\n            exit_.state = ExitState.NonExistent;\r\n        } else {\r\n            bytes32 confirmationHash = sha256(abi.encodePacked(merkleHash, blk.header));\r\n            recoveredAddress = confirmationHash.recover(confirmSignature);\r\n            require(confirmSignature.length == 65 && recoveredAddress != address(0) && exit_.owner == recoveredAddress);\r\n\r\n            exit_.state = ExitState.Challenged;\r\n        }\r\n\r\n        // exit successfully challenged. Award the sender with the bond\r\n        balances[msg.sender] = balances[msg.sender].add(minExitBond);\r\n        totalWithdrawBalance = totalWithdrawBalance.add(minExitBond);\r\n        emit AddedToBalances(msg.sender, minExitBond);\r\n\r\n        emit ChallengedExit(exit_.position, exit_.owner, exit_.amount - exit_.committedFee);\r\n    }\r\n\r\n    function finalizeDepositExits() public { finalize(depositExitQueue, true); }\r\n    function finalizeTransactionExits() public { finalize(txExitQueue, false); }\r\n\r\n    // Finalizes exits by iterating through either the depositExitQueue or txExitQueue.\r\n    // Users can determine the number of exits they're willing to process by varying\r\n    // the amount of gas allow finalize*Exits() to process.\r\n    // Each transaction takes < 80000 gas to process.\r\n    function finalize(uint256[] storage queue, bool isDeposits)\r\n        private\r\n    {\r\n        if (queue.length == 0) return;\r\n\r\n        // retrieve the lowest priority and the appropriate exit struct\r\n        uint256 priority = queue[0];\r\n        exit memory currentExit;\r\n        uint256 position;\r\n        // retrieve the right 128 bits from the priority to obtain the position\r\n        assembly {\r\n   \t        position := and(priority, div(not(0x0), exp(256, 16)))\r\n\t\t}\r\n\r\n        currentExit = isDeposits ? depositExits[position] : txExits[position];\r\n\r\n        /*\r\n        * Conditions:\r\n        *   1. Exits exist\r\n        *   2. Exits must be a week old\r\n        *   3. Funds must exist for the exit to withdraw\r\n        */\r\n        uint256 amountToAdd;\r\n        uint256 challengePeriod = isDeposits ? 5 days : 1 weeks;\r\n        while (block.timestamp.sub(currentExit.createdAt) > challengePeriod &&\r\n               plasmaChainBalance() > 0 &&\r\n               gasleft() > 80000) {\r\n\r\n            // skip currentExit if it is not in 'started/pending' state.\r\n            if (currentExit.state != ExitState.Pending) {\r\n                queue.delMin();\r\n            } else {\r\n                // reimburse the bond but remove fee allocated for the operator\r\n                amountToAdd = currentExit.amount.add(minExitBond).sub(currentExit.committedFee);\r\n                \r\n                balances[currentExit.owner] = balances[currentExit.owner].add(amountToAdd);\r\n                totalWithdrawBalance = totalWithdrawBalance.add(amountToAdd);\r\n\r\n                if (isDeposits)\r\n                    depositExits[position].state = ExitState.Finalized;\r\n                else\r\n                    txExits[position].state = ExitState.Finalized;\r\n\r\n                emit FinalizedExit(currentExit.position, currentExit.owner, amountToAdd);\r\n                emit AddedToBalances(currentExit.owner, amountToAdd);\r\n\r\n                // move onto the next oldest exit\r\n                queue.delMin();\r\n            }\r\n\r\n            if (queue.length == 0) {\r\n                return;\r\n            }\r\n\r\n            // move onto the next oldest exit\r\n            priority = queue[0];\r\n            \r\n            // retrieve the right 128 bits from the priority to obtain the position\r\n            assembly {\r\n   \t\t\t    position := and(priority, div(not(0x0), exp(256, 16)))\r\n\t\t    }\r\n             \r\n            currentExit = isDeposits ? depositExits[position] : txExits[position];\r\n        }\r\n    }\r\n\r\n    // @notice will revert if the output index is out of bounds\r\n    function calcPosition(uint256[3] memory txPos)\r\n        private\r\n        view\r\n        returns (uint256)\r\n    {\r\n        require(validatePostion([txPos[0], txPos[1], txPos[2], 0]));\r\n\r\n        uint256 position = txPos[0].mul(blockIndexFactor).add(txPos[1].mul(txIndexFactor)).add(txPos[2]);\r\n        require(position <= 2**128-1); // check for an overflow\r\n\r\n        return position;\r\n    }\r\n\r\n    function validatePostion(uint256[4] memory position)\r\n        private\r\n        view\r\n        returns (bool)\r\n    {\r\n        uint256 blkNum = position[0];\r\n        uint256 txIndex = position[1];\r\n        uint256 oIndex = position[2];\r\n        uint256 depNonce = position[3];\r\n\r\n        if (blkNum > 0) { // utxo input\r\n            // uncommitted block\r\n            if (blkNum > lastCommittedBlock)\r\n                return false;\r\n            // txIndex out of bounds for the block\r\n            if (txIndex >= plasmaChain[blkNum].numTxns && txIndex != feeIndex)\r\n                return false;\r\n            // fee input must have a zero output index\r\n            if (txIndex == feeIndex && oIndex > 0)\r\n                return false;\r\n            // deposit nonce must be zero\r\n            if (depNonce > 0)\r\n                return false;\r\n            // only two outputs\r\n            if (oIndex > 1)\r\n                return false;\r\n        } else { // deposit or fee input\r\n            // deposit input must be zero'd output position\r\n            // `blkNum` is not checked as it will fail above\r\n            if (depNonce > 0 && (txIndex > 0 || oIndex > 0))\r\n                return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    function withdraw()\r\n        public\r\n        returns (uint256)\r\n    {\r\n        if (balances[msg.sender] == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 transferAmount = balances[msg.sender];\r\n        delete balances[msg.sender];\r\n        totalWithdrawBalance = totalWithdrawBalance.sub(transferAmount);\r\n\r\n        // will revert the above deletion if it fails\r\n        msg.sender.transfer(transferAmount);\r\n        return transferAmount;\r\n    }\r\n\r\n    /*\r\n    * Getters\r\n    */\r\n\r\n    function plasmaChainBalance()\r\n        public\r\n        view\r\n        returns (uint)\r\n    {\r\n        // takes into accounts the failed withdrawals\r\n        return address(this).balance - totalWithdrawBalance;\r\n    }\r\n\r\n    function balanceOf(address _address)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return balances[_address];\r\n    }\r\n\r\n    function txQueueLength()\r\n        public\r\n        view\r\n        returns (uint)\r\n    {\r\n        return txExitQueue.length;\r\n    }\r\n\r\n    function depositQueueLength()\r\n        public \r\n        view\r\n        returns (uint)\r\n    {   \r\n        return depositExitQueue.length;\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"newOperator\",\"type\":\"address\"}],\"name\":\"changeOperator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"balances\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastCommittedBlock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"plasmaChain\",\"outputs\":[{\"name\":\"header\",\"type\":\"bytes32\"},{\"name\":\"numTxns\",\"type\":\"uint256\"},{\"name\":\"feeAmount\",\"type\":\"uint256\"},{\"name\":\"createdAt\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"plasmaChainBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"operator\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"depositExitQueue\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"txExits\",\"outputs\":[{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"committedFee\",\"type\":\"uint256\"},{\"name\":\"createdAt\",\"type\":\"uint256\"},{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"state\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"nonce\",\"type\":\"uint256\"},{\"name\":\"committedFee\",\"type\":\"uint256\"}],\"name\":\"startDepositExit\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"txExitQueue\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finalizeTransactionExits\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"deposits\",\"outputs\":[{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"createdAt\",\"type\":\"uint256\"},{\"name\":\"ethBlockNum\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"txQueueLength\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalWithdrawBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"depositQueueLength\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"depositExits\",\"outputs\":[{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"committedFee\",\"type\":\"uint256\"},{\"name\":\"createdAt\",\"type\":\"uint256\"},{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"state\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"txPos\",\"type\":\"uint256[3]\"},{\"name\":\"txBytes\",\"type\":\"bytes\"},{\"name\":\"proof\",\"type\":\"bytes\"},{\"name\":\"confirmSignatures\",\"type\":\"bytes\"},{\"name\":\"committedFee\",\"type\":\"uint256\"}],\"name\":\"startTransactionExit\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"exitingTxPos\",\"type\":\"uint256[4]\"},{\"name\":\"challengingTxPos\",\"type\":\"uint256[2]\"},{\"name\":\"txBytes\",\"type\":\"bytes\"},{\"name\":\"proof\",\"type\":\"bytes\"},{\"name\":\"confirmSignature\",\"type\":\"bytes\"}],\"name\":\"challengeExit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minExitBond\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"headers\",\"type\":\"bytes32[]\"},{\"name\":\"txnsPerBlock\",\"type\":\"uint256[]\"},{\"name\":\"feePerBlock\",\"type\":\"uint256[]\"},{\"name\":\"blockNum\",\"type\":\"uint256\"}],\"name\":\"submitBlock\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"depositNonce\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"blockNumber\",\"type\":\"uint256\"},{\"name\":\"committedFee\",\"type\":\"uint256\"}],\"name\":\"startFeeExit\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"deposit\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finalizeDepositExits\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldOperator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newOperator\",\"type\":\"address\"}],\"name\":\"ChangedOperator\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"AddedToBalances\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"header\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"blockNumber\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"numTxns\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"feeAmount\",\"type\":\"uint256\"}],\"name\":\"BlockSubmitted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"depositor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"depositNonce\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"ethBlockNum\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"position\",\"type\":\"uint256[3]\"},{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"confirmSignatures\",\"type\":\"bytes\"},{\"indexed\":false,\"name\":\"committedFee\",\"type\":\"uint256\"}],\"name\":\"StartedTransactionExit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"nonce\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"committedFee\",\"type\":\"uint256\"}],\"name\":\"StartedDepositExit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"position\",\"type\":\"uint256[4]\"},{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ChallengedExit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"position\",\"type\":\"uint256[4]\"},{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"FinalizedExit\",\"type\":\"event\"}]","ContractName":"PlasmaMVP","CompilerVersion":"v0.5.0+commit.1d4f565a","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://28612faa15ee1c2429378af8272d35aa6275e1267cebe2da94fd51b884cd18d5"}]}