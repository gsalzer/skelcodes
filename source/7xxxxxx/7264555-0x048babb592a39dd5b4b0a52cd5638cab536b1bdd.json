{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.0;\r\n\r\ninterface SwapInterface {\r\n    // Public variables\r\n    function brokerFees(address _broker) external view returns (uint256);\r\n    function redeemedAt(bytes32 _swapID) external view returns(uint256);\r\n\r\n    /// @notice Initiates the atomic swap.\r\n    ///\r\n    /// @param _swapID The unique atomic swap id.\r\n    /// @param _spender The address of the withdrawing trader.\r\n    /// @param _secretLock The hash of the secret (Hash Lock).\r\n    /// @param _timelock The unix timestamp when the swap expires.\r\n    /// @param _value The value of the atomic swap.\r\n    function initiate(\r\n        bytes32 _swapID,\r\n        address payable _spender,\r\n        bytes32 _secretLock,\r\n        uint256 _timelock,\r\n        uint256 _value\r\n    ) external payable;\r\n\r\n    /// @notice Initiates the atomic swap with broker fees.\r\n    ///\r\n    /// @param _swapID The unique atomic swap id.\r\n    /// @param _spender The address of the withdrawing trader.\r\n    /// @param _broker The address of the broker.\r\n    /// @param _brokerFee The fee to be paid to the broker on success.\r\n    /// @param _secretLock The hash of the secret (Hash Lock).\r\n    /// @param _timelock The unix timestamp when the swap expires.\r\n    /// @param _value The value of the atomic swap.\r\n    function initiateWithFees(\r\n        bytes32 _swapID,\r\n        address payable _spender,\r\n        address payable _broker,\r\n        uint256 _brokerFee,\r\n        bytes32 _secretLock,\r\n        uint256 _timelock,\r\n        uint256 _value\r\n    ) external payable;\r\n\r\n    /// @notice Redeems an atomic swap.\r\n    ///\r\n    /// @param _swapID The unique atomic swap id.\r\n    /// @param _receiver The receiver's address.\r\n    /// @param _secretKey The secret of the atomic swap.\r\n    function redeem(bytes32 _swapID, address payable _receiver, bytes32 _secretKey) external;\r\n\r\n    /// @notice Redeems an atomic swap to the spender. Can be called by anyone.\r\n    ///\r\n    /// @param _swapID The unique atomic swap id.\r\n    /// @param _secretKey The secret of the atomic swap.\r\n    function redeemToSpender(bytes32 _swapID, bytes32 _secretKey) external;\r\n\r\n    /// @notice Refunds an atomic swap.\r\n    ///\r\n    /// @param _swapID The unique atomic swap id.\r\n    function refund(bytes32 _swapID) external;\r\n\r\n    /// @notice Allows broker fee withdrawals.\r\n    ///\r\n    /// @param _amount The withdrawal amount.\r\n    function withdrawBrokerFees(uint256 _amount) external;\r\n\r\n    /// @notice Audits an atomic swap.\r\n    ///\r\n    /// @param _swapID The unique atomic swap id.\r\n    function audit(\r\n        bytes32 _swapID\r\n    ) external view returns (\r\n        uint256 timelock,\r\n        uint256 value,\r\n        address to, uint256 brokerFee,\r\n        address broker,\r\n        address from,\r\n        bytes32 secretLock\r\n    );\r\n\r\n    /// @notice Audits the secret of an atomic swap.\r\n    ///\r\n    /// @param _swapID The unique atomic swap id.\r\n    function auditSecret(bytes32 _swapID) external view  returns (bytes32 secretKey);\r\n\r\n    /// @notice Checks whether a swap is refundable or not.\r\n    ///\r\n    /// @param _swapID The unique atomic swap id.\r\n    function refundable(bytes32 _swapID) external view returns (bool);\r\n\r\n    /// @notice Checks whether a swap is initiatable or not.\r\n    ///\r\n    /// @param _swapID The unique atomic swap id.\r\n    function initiatable(bytes32 _swapID) external view returns (bool);\r\n\r\n    /// @notice Checks whether a swap is redeemable or not.\r\n    ///\r\n    /// @param _swapID The unique atomic swap id.\r\n    function redeemable(bytes32 _swapID) external view returns (bool);\r\n\r\n    /// @notice Generates a deterministic swap id using initiate swap details.\r\n    ///\r\n    /// @param _secretLock The hash of the secret.\r\n    /// @param _timelock The expiry timestamp.\r\n    function swapID(bytes32 _secretLock, uint256 _timelock) external pure returns (bytes32);\r\n}\r\n\r\ncontract BaseSwap is SwapInterface {\r\n    string public VERSION; // Passed in as a constructor parameter.\r\n\r\n    struct Swap {\r\n        uint256 timelock;\r\n        uint256 value;\r\n        uint256 brokerFee;\r\n        bytes32 secretLock;\r\n        bytes32 secretKey;\r\n        address payable funder;\r\n        address payable spender;\r\n        address payable broker;\r\n    }\r\n\r\n    enum States {\r\n        INVALID,\r\n        OPEN,\r\n        CLOSED,\r\n        EXPIRED\r\n    }\r\n\r\n    // Events\r\n    event LogOpen(bytes32 _swapID, address _spender, bytes32 _secretLock);\r\n    event LogExpire(bytes32 _swapID);\r\n    event LogClose(bytes32 _swapID, bytes32 _secretKey);\r\n\r\n    // Storage\r\n    mapping (bytes32 => Swap) internal swaps;\r\n    mapping (bytes32 => States) private _swapStates;\r\n    mapping (address => uint256) private _brokerFees;\r\n    mapping (bytes32 => uint256) private _redeemedAt;\r\n\r\n    /// @notice Throws if the swap is not invalid (i.e. has already been opened)\r\n    modifier onlyInvalidSwaps(bytes32 _swapID) {\r\n        require(_swapStates[_swapID] == States.INVALID, \"swap opened previously\");\r\n        _;\r\n    }\r\n\r\n    /// @notice Throws if the swap is not open.\r\n    modifier onlyOpenSwaps(bytes32 _swapID) {\r\n        require(_swapStates[_swapID] == States.OPEN, \"swap not open\");\r\n        _;\r\n    }\r\n\r\n    /// @notice Throws if the swap is not closed.\r\n    modifier onlyClosedSwaps(bytes32 _swapID) {\r\n        require(_swapStates[_swapID] == States.CLOSED, \"swap not redeemed\");\r\n        _;\r\n    }\r\n\r\n    /// @notice Throws if the swap is not expirable.\r\n    modifier onlyExpirableSwaps(bytes32 _swapID) {\r\n        /* solium-disable-next-line security/no-block-members */\r\n        require(now >= swaps[_swapID].timelock, \"swap not expirable\");\r\n        _;\r\n    }\r\n\r\n    /// @notice Throws if the secret key is not valid.\r\n    modifier onlyWithSecretKey(bytes32 _swapID, bytes32 _secretKey) {\r\n        require(swaps[_swapID].secretLock == sha256(abi.encodePacked(_secretKey)), \"invalid secret\");\r\n        _;\r\n    }\r\n\r\n    /// @notice Throws if the caller is not the authorized spender.\r\n    modifier onlySpender(bytes32 _swapID, address _spender) {\r\n        require(swaps[_swapID].spender == _spender, \"unauthorized spender\");\r\n        _;\r\n    }\r\n\r\n    /// @notice The contract constructor.\r\n    ///\r\n    /// @param _VERSION A string defining the contract version.\r\n    constructor(string memory _VERSION) public {\r\n        VERSION = _VERSION;\r\n    }\r\n\r\n    /// @notice Initiates the atomic swap.\r\n    ///\r\n    /// @param _swapID The unique atomic swap id.\r\n    /// @param _spender The address of the withdrawing trader.\r\n    /// @param _secretLock The hash of the secret (Hash Lock).\r\n    /// @param _timelock The unix timestamp when the swap expires.\r\n    /// @param _value The value of the atomic swap.\r\n    function initiate(\r\n        bytes32 _swapID,\r\n        address payable _spender,\r\n        bytes32 _secretLock,\r\n        uint256 _timelock,\r\n        uint256 _value\r\n    ) public onlyInvalidSwaps(_swapID) payable {\r\n        // Store the details of the swap.\r\n        Swap memory swap = Swap({\r\n            timelock: _timelock,\r\n            brokerFee: 0,\r\n            value: _value,\r\n            funder: msg.sender,\r\n            spender: _spender,\r\n            broker: address(0x0),\r\n            secretLock: _secretLock,\r\n            secretKey: 0x0\r\n        });\r\n        swaps[_swapID] = swap;\r\n        _swapStates[_swapID] = States.OPEN;\r\n\r\n        // Logs open event\r\n        emit LogOpen(_swapID, _spender, _secretLock);\r\n    }\r\n\r\n    /// @notice Initiates the atomic swap with fees.\r\n    ///\r\n    /// @param _swapID The unique atomic swap id.\r\n    /// @param _spender The address of the withdrawing trader.\r\n    /// @param _broker The address of the broker.\r\n    /// @param _brokerFee The fee to be paid to the broker on success.\r\n    /// @param _secretLock The hash of the secret (Hash Lock).\r\n    /// @param _timelock The unix timestamp when the swap expires.\r\n    /// @param _value The value of the atomic swap.\r\n    function initiateWithFees(\r\n        bytes32 _swapID,\r\n        address payable _spender,\r\n        address payable _broker,\r\n        uint256 _brokerFee,\r\n        bytes32 _secretLock,\r\n        uint256 _timelock,\r\n        uint256 _value\r\n    ) public onlyInvalidSwaps(_swapID) payable {\r\n        require(_value >= _brokerFee, \"fee must be less than value\");\r\n\r\n        // Store the details of the swap.\r\n        Swap memory swap = Swap({\r\n            timelock: _timelock,\r\n            brokerFee: _brokerFee,\r\n            value: _value - _brokerFee,\r\n            funder: msg.sender,\r\n            spender: _spender,\r\n            broker: _broker,\r\n            secretLock: _secretLock,\r\n            secretKey: 0x0\r\n        });\r\n        swaps[_swapID] = swap;\r\n        _swapStates[_swapID] = States.OPEN;\r\n\r\n        // Logs open event\r\n        emit LogOpen(_swapID, _spender, _secretLock);\r\n    }\r\n\r\n    /// @notice Redeems an atomic swap.\r\n    ///\r\n    /// @param _swapID The unique atomic swap id.\r\n    /// @param _receiver The receiver's address.\r\n    /// @param _secretKey The secret of the atomic swap.\r\n    function redeem(bytes32 _swapID, address payable _receiver, bytes32 _secretKey) public onlyOpenSwaps(_swapID) onlyWithSecretKey(_swapID, _secretKey) onlySpender(_swapID, msg.sender) {\r\n        require(_receiver != address(0x0), \"invalid receiver\");\r\n\r\n        // Close the swap.\r\n        swaps[_swapID].secretKey = _secretKey;\r\n        _swapStates[_swapID] = States.CLOSED;\r\n        /* solium-disable-next-line security/no-block-members */\r\n        _redeemedAt[_swapID] = now;\r\n\r\n        // Update the broker fees to the broker.\r\n        _brokerFees[swaps[_swapID].broker] += swaps[_swapID].brokerFee;\r\n\r\n        // Logs close event\r\n        emit LogClose(_swapID, _secretKey);\r\n    }\r\n\r\n    /// @notice Redeems an atomic swap to the spender. Can be called by anyone.\r\n    ///\r\n    /// @param _swapID The unique atomic swap id.\r\n    /// @param _secretKey The secret of the atomic swap.\r\n    function redeemToSpender(bytes32 _swapID, bytes32 _secretKey) public onlyOpenSwaps(_swapID) onlyWithSecretKey(_swapID, _secretKey) {\r\n        // Close the swap.\r\n        swaps[_swapID].secretKey = _secretKey;\r\n        _swapStates[_swapID] = States.CLOSED;\r\n        /* solium-disable-next-line security/no-block-members */\r\n        _redeemedAt[_swapID] = now;\r\n\r\n        // Update the broker fees to the broker.\r\n        _brokerFees[swaps[_swapID].broker] += swaps[_swapID].brokerFee;\r\n\r\n        // Logs close event\r\n        emit LogClose(_swapID, _secretKey);\r\n    }\r\n\r\n    /// @notice Refunds an atomic swap.\r\n    ///\r\n    /// @param _swapID The unique atomic swap id.\r\n    function refund(bytes32 _swapID) public onlyOpenSwaps(_swapID) onlyExpirableSwaps(_swapID) {\r\n        // Expire the swap.\r\n        _swapStates[_swapID] = States.EXPIRED;\r\n\r\n        // Logs expire event\r\n        emit LogExpire(_swapID);\r\n    }\r\n\r\n    /// @notice Allows broker fee withdrawals.\r\n    ///\r\n    /// @param _amount The withdrawal amount.\r\n    function withdrawBrokerFees(uint256 _amount) public {\r\n        require(_amount <= _brokerFees[msg.sender], \"insufficient withdrawable fees\");\r\n        _brokerFees[msg.sender] -= _amount;\r\n    }\r\n\r\n    /// @notice Audits an atomic swap.\r\n    ///\r\n    /// @param _swapID The unique atomic swap id.\r\n    function audit(bytes32 _swapID) external view returns (uint256 timelock, uint256 value, address to, uint256 brokerFee, address broker, address from, bytes32 secretLock) {\r\n        Swap memory swap = swaps[_swapID];\r\n        return (\r\n            swap.timelock,\r\n            swap.value,\r\n            swap.spender,\r\n            swap.brokerFee,\r\n            swap.broker,\r\n            swap.funder,\r\n            swap.secretLock\r\n        );\r\n    }\r\n\r\n    /// @notice Audits the secret of an atomic swap.\r\n    ///\r\n    /// @param _swapID The unique atomic swap id.\r\n    function auditSecret(bytes32 _swapID) external view onlyClosedSwaps(_swapID) returns (bytes32 secretKey) {\r\n        return swaps[_swapID].secretKey;\r\n    }\r\n\r\n    /// @notice Checks whether a swap is refundable or not.\r\n    ///\r\n    /// @param _swapID The unique atomic swap id.\r\n    function refundable(bytes32 _swapID) external view returns (bool) {\r\n        /* solium-disable-next-line security/no-block-members */\r\n        return (now >= swaps[_swapID].timelock && _swapStates[_swapID] == States.OPEN);\r\n    }\r\n\r\n    /// @notice Checks whether a swap is initiatable or not.\r\n    ///\r\n    /// @param _swapID The unique atomic swap id.\r\n    function initiatable(bytes32 _swapID) external view returns (bool) {\r\n        return (_swapStates[_swapID] == States.INVALID);\r\n    }\r\n\r\n    /// @notice Checks whether a swap is redeemable or not.\r\n    ///\r\n    /// @param _swapID The unique atomic swap id.\r\n    function redeemable(bytes32 _swapID) external view returns (bool) {\r\n        return (_swapStates[_swapID] == States.OPEN);\r\n    }\r\n\r\n    function redeemedAt(bytes32 _swapID) external view returns (uint256) {\r\n        return _redeemedAt[_swapID];\r\n    }\r\n\r\n    function brokerFees(address _broker) external view returns (uint256) {\r\n        return _brokerFees[_broker];\r\n    }\r\n\r\n    /// @notice Generates a deterministic swap id using initiate swap details.\r\n    ///\r\n    /// @param _secretLock The hash of the secret.\r\n    /// @param _timelock The expiry timestamp.\r\n    function swapID(bytes32 _secretLock, uint256 _timelock) external pure returns (bytes32) {\r\n        return keccak256(abi.encodePacked(_secretLock, _timelock));\r\n    }\r\n}\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Unsigned math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n    * @dev Multiplies two unsigned integers, reverts on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two unsigned integers, reverts on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\r\n    * reverts when dividing by zero.\r\n    */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n/**\r\n * @title Math\r\n * @dev Assorted math operations\r\n */\r\nlibrary Math {\r\n    /**\r\n    * @dev Returns the largest of two numbers.\r\n    */\r\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a >= b ? a : b;\r\n    }\r\n\r\n    /**\r\n    * @dev Returns the smallest of two numbers.\r\n    */\r\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n    /**\r\n    * @dev Calculates the average of two numbers. Since these are integers,\r\n    * averages of an even and odd number cannot be represented, and will be\r\n    * rounded down.\r\n    */\r\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // (a + b) / 2 can overflow, so we distribute\r\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\r\n    }\r\n}\r\n\r\n/// @notice Implements safeTransfer, safeTransferFrom and\r\n/// safeApprove for CompatibleERC20.\r\n///\r\n/// See https://github.com/ethereum/solidity/issues/4116\r\n///\r\n/// This library allows interacting with ERC20 tokens that implement any of\r\n/// these interfaces:\r\n///\r\n/// (1) transfer returns true on success, false on failure\r\n/// (2) transfer returns true on success, reverts on failure\r\n/// (3) transfer returns nothing on success, reverts on failure\r\n///\r\n/// Additionally, safeTransferFromWithFees will return the final token\r\n/// value received after accounting for token fees.\r\nlibrary CompatibleERC20Functions {\r\n    using SafeMath for uint256;\r\n\r\n    /// @notice Calls transfer on the token and reverts if the call fails.\r\n    function safeTransfer(CompatibleERC20 self, address to, uint256 amount) internal {\r\n        self.transfer(to, amount);\r\n        require(previousReturnValue(), \"transfer failed\");\r\n    }\r\n\r\n    /// @notice Calls transferFrom on the token and reverts if the call fails.\r\n    function safeTransferFrom(CompatibleERC20 self, address from, address to, uint256 amount) internal {\r\n        self.transferFrom(from, to, amount);\r\n        require(previousReturnValue(), \"transferFrom failed\");\r\n    }\r\n\r\n    /// @notice Calls approve on the token and reverts if the call fails.\r\n    function safeApprove(CompatibleERC20 self, address spender, uint256 amount) internal {\r\n        self.approve(spender, amount);\r\n        require(previousReturnValue(), \"approve failed\");\r\n    }\r\n\r\n    /// @notice Calls transferFrom on the token, reverts if the call fails and\r\n    /// returns the value transferred after fees.\r\n    function safeTransferFromWithFees(CompatibleERC20 self, address from, address to, uint256 amount) internal returns (uint256) {\r\n        uint256 balancesBefore = self.balanceOf(to);\r\n        self.transferFrom(from, to, amount);\r\n        require(previousReturnValue(), \"transferFrom failed\");\r\n        uint256 balancesAfter = self.balanceOf(to);\r\n        return Math.min(amount, balancesAfter.sub(balancesBefore));\r\n    }\r\n\r\n    /// @notice Checks the return value of the previous function. Returns true\r\n    /// if the previous function returned 32 non-zero bytes or returned zero\r\n    /// bytes.\r\n    function previousReturnValue() private pure returns (bool)\r\n    {\r\n        uint256 returnData = 0;\r\n\r\n        assembly { /* solium-disable-line security/no-inline-assembly */\r\n            // Switch on the number of bytes returned by the previous call\r\n            switch returndatasize\r\n\r\n            // 0 bytes: ERC20 of type (3), did not throw\r\n            case 0 {\r\n                returnData := 1\r\n            }\r\n\r\n            // 32 bytes: ERC20 of types (1) or (2)\r\n            case 32 {\r\n                // Copy the return data into scratch space\r\n                returndatacopy(0, 0, 32)\r\n\r\n                // Load  the return data into returnData\r\n                returnData := mload(0)\r\n            }\r\n\r\n            // Other return size: return false\r\n            default { }\r\n        }\r\n\r\n        return returnData != 0;\r\n    }\r\n}\r\n\r\n/// @notice ERC20 interface which doesn't specify the return type for transfer,\r\n/// transferFrom and approve.\r\ninterface CompatibleERC20 {\r\n    // Modified to not return boolean\r\n    function transfer(address to, uint256 value) external;\r\n    function transferFrom(address from, address to, uint256 value) external;\r\n    function approve(address spender, uint256 value) external;\r\n\r\n    // Not modifier\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address who) external view returns (uint256);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n/// @notice ERC20Swap implements the ERC20Swap interface.\r\ncontract ERC20Swap is SwapInterface, BaseSwap {\r\n    using CompatibleERC20Functions for CompatibleERC20;\r\n\r\n    address public TOKEN_ADDRESS; // Address of the ERC20 contract. Passed in as a constructor parameter\r\n\r\n    /// @notice The contract constructor.\r\n    ///\r\n    /// @param _VERSION A string defining the contract version.\r\n    constructor(string memory _VERSION, address _TOKEN_ADDRESS) BaseSwap(_VERSION) public {\r\n        TOKEN_ADDRESS = _TOKEN_ADDRESS;\r\n    }\r\n\r\n    /// @notice Initiates the atomic swap.\r\n    ///\r\n    /// @param _swapID The unique atomic swap id.\r\n    /// @param _spender The address of the withdrawing trader.\r\n    /// @param _secretLock The hash of the secret (Hash Lock).\r\n    /// @param _timelock The unix timestamp when the swap expires.\r\n    /// @param _value The value of the atomic swap.\r\n    function initiate(\r\n        bytes32 _swapID,\r\n        address payable _spender,\r\n        bytes32 _secretLock,\r\n        uint256 _timelock,\r\n        uint256 _value\r\n    ) public payable {\r\n        // To abide by the interface, the function is payable but throws if\r\n        // msg.value is non-zero\r\n        require(msg.value == 0, \"eth value must be zero\");\r\n        require(_spender != address(0x0), \"spender must not be zero\");\r\n\r\n        // Transfer the token to the contract\r\n        // TODO: Initiator will first need to call\r\n        // ERC20(TOKEN_ADDRESS).approve(address(this), _value)\r\n        // before this contract can make transfers on the initiator's behalf.\r\n        CompatibleERC20(TOKEN_ADDRESS).safeTransferFrom(msg.sender, address(this), _value);\r\n\r\n        BaseSwap.initiate(\r\n            _swapID,\r\n            _spender,\r\n            _secretLock,\r\n            _timelock,\r\n            _value\r\n        );\r\n    }\r\n\r\n    /// @notice Initiates the atomic swap with broker fees.\r\n    ///\r\n    /// @param _swapID The unique atomic swap id.\r\n    /// @param _spender The address of the withdrawing trader.\r\n    /// @param _broker The address of the broker.\r\n    /// @param _brokerFee The fee to be paid to the broker on success.\r\n    /// @param _secretLock The hash of the secret (Hash Lock).\r\n    /// @param _timelock The unix timestamp when the swap expires.\r\n    /// @param _value The value of the atomic swap.\r\n    function initiateWithFees(\r\n        bytes32 _swapID,\r\n        address payable _spender,\r\n        address payable _broker,\r\n        uint256 _brokerFee,\r\n        bytes32 _secretLock,\r\n        uint256 _timelock,\r\n        uint256 _value\r\n    ) public payable {\r\n        // To abide by the interface, the function is payable but throws if\r\n        // msg.value is non-zero\r\n        require(msg.value == 0, \"eth value must be zero\");\r\n        require(_spender != address(0x0), \"spender must not be zero\");\r\n\r\n        // Transfer the token to the contract\r\n        // TODO: Initiator will first need to call\r\n        // ERC20(TOKEN_ADDRESS).approve(address(this), _value)\r\n        // before this contract can make transfers on the initiator's behalf.\r\n        CompatibleERC20(TOKEN_ADDRESS).safeTransferFrom(msg.sender, address(this), _value);\r\n\r\n        BaseSwap.initiateWithFees(\r\n            _swapID,\r\n            _spender,\r\n            _broker,\r\n            _brokerFee,\r\n            _secretLock,\r\n            _timelock,\r\n            _value\r\n        );\r\n    }\r\n\r\n    /// @notice Redeems an atomic swap.\r\n    ///\r\n    /// @param _swapID The unique atomic swap id.\r\n    /// @param _secretKey The secret of the atomic swap.\r\n    function redeem(bytes32 _swapID, address payable _receiver, bytes32 _secretKey) public {\r\n        BaseSwap.redeem(\r\n            _swapID,\r\n            _receiver,\r\n            _secretKey\r\n        );\r\n\r\n        // Transfer the ERC20 funds from this contract to the withdrawing trader.\r\n        CompatibleERC20(TOKEN_ADDRESS).safeTransfer(_receiver, swaps[_swapID].value);\r\n    }\r\n\r\n    /// @notice Redeems an atomic swap to the spender. Can be called by anyone.\r\n    ///\r\n    /// @param _swapID The unique atomic swap id.\r\n    /// @param _secretKey The secret of the atomic swap.\r\n    function redeemToSpender(bytes32 _swapID, bytes32 _secretKey) public {\r\n        BaseSwap.redeemToSpender(\r\n            _swapID,\r\n            _secretKey\r\n        );\r\n\r\n        // Transfer the ERC20 funds from this contract to the withdrawing trader.\r\n        CompatibleERC20(TOKEN_ADDRESS).safeTransfer(swaps[_swapID].spender, swaps[_swapID].value);\r\n    }\r\n\r\n    /// @notice Refunds an atomic swap.\r\n    ///\r\n    /// @param _swapID The unique atomic swap id.\r\n    function refund(bytes32 _swapID) public {\r\n        BaseSwap.refund(_swapID);\r\n\r\n        // Transfer the ERC20 value from this contract back to the funding trader.\r\n        CompatibleERC20(TOKEN_ADDRESS).safeTransfer(swaps[_swapID].funder, swaps[_swapID].value + swaps[_swapID].brokerFee);\r\n    }\r\n\r\n    /// @notice Allows broker fee withdrawals.\r\n    ///\r\n    /// @param _amount The withdrawal amount.\r\n    function withdrawBrokerFees(uint256 _amount) public {\r\n        BaseSwap.withdrawBrokerFees(_amount);\r\n\r\n        CompatibleERC20(TOKEN_ADDRESS).safeTransfer(msg.sender, _amount);\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_swapID\",\"type\":\"bytes32\"},{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_secretLock\",\"type\":\"bytes32\"},{\"name\":\"_timelock\",\"type\":\"uint256\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"initiate\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_swapID\",\"type\":\"bytes32\"}],\"name\":\"initiatable\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TOKEN_ADDRESS\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_secretLock\",\"type\":\"bytes32\"},{\"name\":\"_timelock\",\"type\":\"uint256\"}],\"name\":\"swapID\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdrawBrokerFees\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_swapID\",\"type\":\"bytes32\"}],\"name\":\"redeemable\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_swapID\",\"type\":\"bytes32\"}],\"name\":\"refund\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_swapID\",\"type\":\"bytes32\"}],\"name\":\"auditSecret\",\"outputs\":[{\"name\":\"secretKey\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_swapID\",\"type\":\"bytes32\"}],\"name\":\"refundable\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_swapID\",\"type\":\"bytes32\"},{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_broker\",\"type\":\"address\"},{\"name\":\"_brokerFee\",\"type\":\"uint256\"},{\"name\":\"_secretLock\",\"type\":\"bytes32\"},{\"name\":\"_timelock\",\"type\":\"uint256\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"initiateWithFees\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_swapID\",\"type\":\"bytes32\"}],\"name\":\"redeemedAt\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_swapID\",\"type\":\"bytes32\"}],\"name\":\"audit\",\"outputs\":[{\"name\":\"timelock\",\"type\":\"uint256\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"brokerFee\",\"type\":\"uint256\"},{\"name\":\"broker\",\"type\":\"address\"},{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"secretLock\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_swapID\",\"type\":\"bytes32\"},{\"name\":\"_receiver\",\"type\":\"address\"},{\"name\":\"_secretKey\",\"type\":\"bytes32\"}],\"name\":\"redeem\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_swapID\",\"type\":\"bytes32\"},{\"name\":\"_secretKey\",\"type\":\"bytes32\"}],\"name\":\"redeemToSpender\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_broker\",\"type\":\"address\"}],\"name\":\"brokerFees\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"VERSION\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_VERSION\",\"type\":\"string\"},{\"name\":\"_TOKEN_ADDRESS\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_swapID\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_secretLock\",\"type\":\"bytes32\"}],\"name\":\"LogOpen\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_swapID\",\"type\":\"bytes32\"}],\"name\":\"LogExpire\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_swapID\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"_secretKey\",\"type\":\"bytes32\"}],\"name\":\"LogClose\",\"type\":\"event\"}]","ContractName":"ERC20Swap","CompilerVersion":"v0.5.0+commit.1d4f565a","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000000000000000000000000000000000000000000400000000000000000000000002260fac5e5542a773aa44fbcfedf7c193bc2c5990000000000000000000000000000000000000000000000000000000000000005312e302e31000000000000000000000000000000000000000000000000000000","Library":"","SwarmSource":"bzzr://55a628c076ff78cd5690cc607bc34a3b11d5bb9c7831086a3000bada55025609"}]}