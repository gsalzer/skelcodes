{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.25;\r\npragma experimental ABIEncoderV2;\r\n\r\nlibrary Strings {\r\n\r\n    /**\r\n     * Concat (High gas cost)\r\n     * \r\n     * Appends two strings together and returns a new value\r\n     * \r\n     * @param _base When being used for a data type this is the extended object\r\n     *              otherwise this is the string which will be the concatenated\r\n     *              prefix\r\n     * @param _value The value to be the concatenated suffix\r\n     * @return string The resulting string from combinging the base and value\r\n     */\r\n    function concat(string _base, string _value)\r\n        internal\r\n        pure\r\n        returns (string) {\r\n        bytes memory _baseBytes = bytes(_base);\r\n        bytes memory _valueBytes = bytes(_value);\r\n\r\n        assert(_valueBytes.length > 0);\r\n\r\n        string memory _tmpValue = new string(_baseBytes.length + \r\n            _valueBytes.length);\r\n        bytes memory _newValue = bytes(_tmpValue);\r\n\r\n        uint i;\r\n        uint j;\r\n\r\n        for(i = 0; i < _baseBytes.length; i++) {\r\n            _newValue[j++] = _baseBytes[i];\r\n        }\r\n\r\n        for(i = 0; i<_valueBytes.length; i++) {\r\n            _newValue[j++] = _valueBytes[i];\r\n        }\r\n\r\n        return string(_newValue);\r\n    }\r\n\r\n    /**\r\n     * Index Of\r\n     *\r\n     * Locates and returns the position of a character within a string\r\n     * \r\n     * @param _base When being used for a data type this is the extended object\r\n     *              otherwise this is the string acting as the haystack to be\r\n     *              searched\r\n     * @param _value The needle to search for, at present this is currently\r\n     *               limited to one character\r\n     * @return int The position of the needle starting from 0 and returning -1\r\n     *             in the case of no matches found\r\n     */\r\n    function indexOf(string _base, string _value)\r\n        internal\r\n        pure\r\n        returns (int) {\r\n        return _indexOf(_base, _value, 0);\r\n    }\r\n\r\n    /**\r\n     * Index Of\r\n     *\r\n     * Locates and returns the position of a character within a string starting\r\n     * from a defined offset\r\n     * \r\n     * @param _base When being used for a data type this is the extended object\r\n     *              otherwise this is the string acting as the haystack to be\r\n     *              searched\r\n     * @param _value The needle to search for, at present this is currently\r\n     *               limited to one character\r\n     * @param _offset The starting point to start searching from which can start\r\n     *                from 0, but must not exceed the length of the string\r\n     * @return int The position of the needle starting from 0 and returning -1\r\n     *             in the case of no matches found\r\n     */\r\n    function _indexOf(string _base, string _value, uint _offset)\r\n        internal\r\n        pure\r\n        returns (int) {\r\n        bytes memory _baseBytes = bytes(_base);\r\n        bytes memory _valueBytes = bytes(_value);\r\n\r\n        assert(_valueBytes.length == 1);\r\n\r\n        for(uint i = _offset; i < _baseBytes.length; i++) {\r\n            if (_baseBytes[i] == _valueBytes[0]) {\r\n                return int(i);\r\n            }\r\n        }\r\n\r\n        return -1;\r\n    }\r\n\r\n    /**\r\n     * Length\r\n     * \r\n     * Returns the length of the specified string\r\n     * \r\n     * @param _base When being used for a data type this is the extended object\r\n     *              otherwise this is the string to be measured\r\n     * @return uint The length of the passed string\r\n     */\r\n    function length(string _base)\r\n        internal\r\n        pure\r\n        returns (uint) {\r\n        bytes memory _baseBytes = bytes(_base);\r\n        return _baseBytes.length;\r\n    }\r\n\r\n    /**\r\n     * Sub String\r\n     * \r\n     * Extracts the beginning part of a string based on the desired length\r\n     * \r\n     * @param _base When being used for a data type this is the extended object\r\n     *              otherwise this is the string that will be used for \r\n     *              extracting the sub string from\r\n     * @param _length The length of the sub string to be extracted from the base\r\n     * @return string The extracted sub string\r\n     */\r\n    function substring(string _base, int _length)\r\n        internal\r\n        pure\r\n        returns (string) {\r\n        return _substring(_base, _length, 0);\r\n    }\r\n\r\n    /**\r\n     * Sub String\r\n     * \r\n     * Extracts the part of a string based on the desired length and offset. The\r\n     * offset and length must not exceed the lenth of the base string.\r\n     * \r\n     * @param _base When being used for a data type this is the extended object\r\n     *              otherwise this is the string that will be used for \r\n     *              extracting the sub string from\r\n     * @param _length The length of the sub string to be extracted from the base\r\n     * @param _offset The starting point to extract the sub string from\r\n     * @return string The extracted sub string\r\n     */\r\n    function _substring(string _base, int _length, int _offset)\r\n        internal\r\n        pure\r\n        returns (string) {\r\n        bytes memory _baseBytes = bytes(_base);\r\n\r\n        assert(uint(_offset+_length) <= _baseBytes.length);\r\n\r\n        string memory _tmp = new string(uint(_length));\r\n        bytes memory _tmpBytes = bytes(_tmp);\r\n\r\n        uint j = 0;\r\n        for(uint i = uint(_offset); i < uint(_offset+_length); i++) {\r\n          _tmpBytes[j++] = _baseBytes[i];\r\n        }\r\n\r\n        return string(_tmpBytes);\r\n    }\r\n\r\n    /**\r\n     * String Split (Very high gas cost)\r\n     *\r\n     * Splits a string into an array of strings based off the delimiter value.\r\n     * Please note this can be quite a gas expensive function due to the use of\r\n     * storage so only use if really required.\r\n     *\r\n     * @param _base When being used for a data type this is the extended object\r\n     *               otherwise this is the string value to be split.\r\n     * @param _value The delimiter to split the string on which must be a single\r\n     *               character\r\n     * @return string[] An array of values split based off the delimiter, but\r\n     *                  do not container the delimiter.\r\n     */\r\n    function split(string _base, string _value)\r\n        internal\r\n        returns (string[] storage splitArr) {\r\n        bytes memory _baseBytes = bytes(_base);\r\n        uint _offset = 0;\r\n\r\n        while(_offset < _baseBytes.length-1) {\r\n\r\n            int _limit = _indexOf(_base, _value, _offset);\r\n            if (_limit == -1) {\r\n                _limit = int(_baseBytes.length);\r\n            }\r\n\r\n            string memory _tmp = new string(uint(_limit)-_offset);\r\n            bytes memory _tmpBytes = bytes(_tmp);\r\n\r\n            uint j = 0;\r\n            for(uint i = _offset; i < uint(_limit); i++) {\r\n                _tmpBytes[j++] = _baseBytes[i];\r\n            }\r\n            _offset = uint(_limit) + 1;\r\n            splitArr.push(string(_tmpBytes));\r\n        }\r\n        return splitArr;\r\n    }\r\n\r\n    /**\r\n     * Compare To\r\n     * \r\n     * Compares the characters of two strings, to ensure that they have an \r\n     * identical footprint\r\n     * \r\n     * @param _base When being used for a data type this is the extended object\r\n     *               otherwise this is the string base to compare against\r\n     * @param _value The string the base is being compared to\r\n     * @return bool Simply notates if the two string have an equivalent\r\n     */\r\n    function compareTo(string _base, string _value) \r\n        internal\r\n        pure\r\n        returns (bool) {\r\n        bytes memory _baseBytes = bytes(_base);\r\n        bytes memory _valueBytes = bytes(_value);\r\n\r\n        if (_baseBytes.length != _valueBytes.length) {\r\n            return false;\r\n        }\r\n\r\n        for(uint i = 0; i < _baseBytes.length; i++) {\r\n            if (_baseBytes[i] != _valueBytes[i]) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Compare To Ignore Case (High gas cost)\r\n     * \r\n     * Compares the characters of two strings, converting them to the same case\r\n     * where applicable to alphabetic characters to distinguish if the values\r\n     * match.\r\n     * \r\n     * @param _base When being used for a data type this is the extended object\r\n     *               otherwise this is the string base to compare against\r\n     * @param _value The string the base is being compared to\r\n     * @return bool Simply notates if the two string have an equivalent value\r\n     *              discarding case\r\n     */\r\n    function compareToIgnoreCase(string _base, string _value)\r\n        internal\r\n        pure\r\n        returns (bool) {\r\n        bytes memory _baseBytes = bytes(_base);\r\n        bytes memory _valueBytes = bytes(_value);\r\n\r\n        if (_baseBytes.length != _valueBytes.length) {\r\n            return false;\r\n        }\r\n\r\n        for(uint i = 0; i < _baseBytes.length; i++) {\r\n            if (_baseBytes[i] != _valueBytes[i] && \r\n                _upper(_baseBytes[i]) != _upper(_valueBytes[i])) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Upper\r\n     * \r\n     * Converts all the values of a string to their corresponding upper case\r\n     * value.\r\n     * \r\n     * @param _base When being used for a data type this is the extended object\r\n     *              otherwise this is the string base to convert to upper case\r\n     * @return string \r\n     */\r\n    function upper(string _base) \r\n        internal\r\n        pure\r\n        returns (string) {\r\n        bytes memory _baseBytes = bytes(_base);\r\n        for (uint i = 0; i < _baseBytes.length; i++) {\r\n            _baseBytes[i] = _upper(_baseBytes[i]);\r\n        }\r\n        return string(_baseBytes);\r\n    }\r\n\r\n    /**\r\n     * Lower\r\n     * \r\n     * Converts all the values of a string to their corresponding lower case\r\n     * value.\r\n     * \r\n     * @param _base When being used for a data type this is the extended object\r\n     *              otherwise this is the string base to convert to lower case\r\n     * @return string \r\n     */\r\n    function lower(string _base) \r\n        internal\r\n        pure\r\n        returns (string) {\r\n        bytes memory _baseBytes = bytes(_base);\r\n        for (uint i = 0; i < _baseBytes.length; i++) {\r\n            _baseBytes[i] = _lower(_baseBytes[i]);\r\n        }\r\n        return string(_baseBytes);\r\n    }\r\n\r\n    /**\r\n     * Upper\r\n     * \r\n     * Convert an alphabetic character to upper case and return the original\r\n     * value when not alphabetic\r\n     * \r\n     * @param _b1 The byte to be converted to upper case\r\n     * @return bytes1 The converted value if the passed value was alphabetic\r\n     *                and in a lower case otherwise returns the original value\r\n     */\r\n    function _upper(bytes1 _b1)\r\n        private\r\n        pure\r\n        returns (bytes1) {\r\n\r\n        if (_b1 >= 0x61 && _b1 <= 0x7A) {\r\n            return bytes1(uint8(_b1)-32);\r\n        }\r\n\r\n        return _b1;\r\n    }\r\n\r\n    /**\r\n     * Lower\r\n     * \r\n     * Convert an alphabetic character to lower case and return the original\r\n     * value when not alphabetic\r\n     * \r\n     * @param _b1 The byte to be converted to lower case\r\n     * @return bytes1 The converted value if the passed value was alphabetic\r\n     *                and in a upper case otherwise returns the original value\r\n     */\r\n    function _lower(bytes1 _b1)\r\n        private\r\n        pure\r\n        returns (bytes1) {\r\n\r\n        if (_b1 >= 0x41 && _b1 <= 0x5A) {\r\n            return bytes1(uint8(_b1)+32);\r\n        }\r\n        \r\n        return _b1;\r\n    }\r\n}\r\n\r\ncontract Beneficiary {\r\n    /// @notice Receive ethers to the given wallet's given balance type\r\n    /// @param wallet The address of the concerned wallet\r\n    /// @param balanceType The target balance type of the wallet\r\n    function receiveEthersTo(address wallet, string balanceType)\r\n    public\r\n    payable;\r\n\r\n    /// @notice Receive token to the given wallet's given balance type\r\n    /// @dev The wallet must approve of the token transfer prior to calling this function\r\n    /// @param wallet The address of the concerned wallet\r\n    /// @param balanceType The target balance type of the wallet\r\n    /// @param amount The amount to deposit\r\n    /// @param currencyCt The address of the concerned currency contract (address(0) == ETH)\r\n    /// @param currencyId The ID of the concerned currency (0 for ETH and ERC20)\r\n    /// @param standard The standard of the token (\"\" for default registered, \"ERC20\", \"ERC721\")\r\n    function receiveTokensTo(address wallet, string balanceType, int256 amount, address currencyCt,\r\n        uint256 currencyId, string standard)\r\n    public;\r\n}\r\n\r\ncontract AccrualBeneficiary is Beneficiary {\r\n    //\r\n    // Functions\r\n    // -----------------------------------------------------------------------------------------------------------------\r\n    event CloseAccrualPeriodEvent();\r\n\r\n    //\r\n    // Functions\r\n    // -----------------------------------------------------------------------------------------------------------------\r\n    function closeAccrualPeriod(MonetaryTypesLib.Currency[])\r\n    public\r\n    {\r\n        emit CloseAccrualPeriodEvent();\r\n    }\r\n}\r\n\r\nlibrary ConstantsLib {\r\n    // Get the fraction that represents the entirety, equivalent of 100%\r\n    function PARTS_PER()\r\n    public\r\n    pure\r\n    returns (int256)\r\n    {\r\n        return 1e18;\r\n    }\r\n}\r\n\r\nlibrary CurrenciesLib {\r\n    using SafeMathUintLib for uint256;\r\n\r\n    //\r\n    // Structures\r\n    // -----------------------------------------------------------------------------------------------------------------\r\n    struct Currencies {\r\n        MonetaryTypesLib.Currency[] currencies;\r\n        mapping(address => mapping(uint256 => uint256)) indexByCurrency;\r\n    }\r\n\r\n    //\r\n    // Functions\r\n    // -----------------------------------------------------------------------------------------------------------------\r\n    function add(Currencies storage self, address currencyCt, uint256 currencyId)\r\n    internal\r\n    {\r\n        // Index is 1-based\r\n        if (0 == self.indexByCurrency[currencyCt][currencyId]) {\r\n            self.currencies.push(MonetaryTypesLib.Currency(currencyCt, currencyId));\r\n            self.indexByCurrency[currencyCt][currencyId] = self.currencies.length;\r\n        }\r\n    }\r\n\r\n    function removeByCurrency(Currencies storage self, address currencyCt, uint256 currencyId)\r\n    internal\r\n    {\r\n        // Index is 1-based\r\n        uint256 index = self.indexByCurrency[currencyCt][currencyId];\r\n        if (0 < index)\r\n            removeByIndex(self, index - 1);\r\n    }\r\n\r\n    function removeByIndex(Currencies storage self, uint256 index)\r\n    internal\r\n    {\r\n        require(index < self.currencies.length);\r\n\r\n        address currencyCt = self.currencies[index].ct;\r\n        uint256 currencyId = self.currencies[index].id;\r\n\r\n        if (index < self.currencies.length - 1) {\r\n            self.currencies[index] = self.currencies[self.currencies.length - 1];\r\n            self.indexByCurrency[self.currencies[index].ct][self.currencies[index].id] = index + 1;\r\n        }\r\n        self.currencies.length--;\r\n        self.indexByCurrency[currencyCt][currencyId] = 0;\r\n    }\r\n\r\n    function count(Currencies storage self)\r\n    internal\r\n    view\r\n    returns (uint256)\r\n    {\r\n        return self.currencies.length;\r\n    }\r\n\r\n    function has(Currencies storage self, address currencyCt, uint256 currencyId)\r\n    internal\r\n    view\r\n    returns (bool)\r\n    {\r\n        return 0 != self.indexByCurrency[currencyCt][currencyId];\r\n    }\r\n\r\n    function getByIndex(Currencies storage self, uint256 index)\r\n    internal\r\n    view\r\n    returns (MonetaryTypesLib.Currency)\r\n    {\r\n        require(index < self.currencies.length);\r\n        return self.currencies[index];\r\n    }\r\n\r\n    function getByIndices(Currencies storage self, uint256 low, uint256 up)\r\n    internal\r\n    view\r\n    returns (MonetaryTypesLib.Currency[])\r\n    {\r\n        require(0 < self.currencies.length);\r\n        require(low <= up);\r\n\r\n        up = up.clampMax(self.currencies.length - 1);\r\n        MonetaryTypesLib.Currency[] memory _currencies = new MonetaryTypesLib.Currency[](up - low + 1);\r\n        for (uint256 i = low; i <= up; i++)\r\n            _currencies[i - low] = self.currencies[i];\r\n\r\n        return _currencies;\r\n    }\r\n}\r\n\r\nlibrary DriipSettlementTypesLib {\r\n    //\r\n    // Structures\r\n    // -----------------------------------------------------------------------------------------------------------------\r\n    enum SettlementRole {Origin, Target}\r\n\r\n    struct SettlementParty {\r\n        uint256 nonce;\r\n        address wallet;\r\n        bool done;\r\n    }\r\n\r\n    struct Settlement {\r\n        string settledKind;\r\n        bytes32 settledHash;\r\n        SettlementParty origin;\r\n        SettlementParty target;\r\n    }\r\n}\r\n\r\nlibrary FungibleBalanceLib {\r\n    using SafeMathIntLib for int256;\r\n    using SafeMathUintLib for uint256;\r\n    using CurrenciesLib for CurrenciesLib.Currencies;\r\n\r\n    //\r\n    // Structures\r\n    // -----------------------------------------------------------------------------------------------------------------\r\n    struct Record {\r\n        int256 amount;\r\n        uint256 blockNumber;\r\n    }\r\n\r\n    struct Balance {\r\n        mapping(address => mapping(uint256 => int256)) amountByCurrency;\r\n        mapping(address => mapping(uint256 => Record[])) recordsByCurrency;\r\n\r\n        CurrenciesLib.Currencies inUseCurrencies;\r\n        CurrenciesLib.Currencies everUsedCurrencies;\r\n    }\r\n\r\n    //\r\n    // Functions\r\n    // -----------------------------------------------------------------------------------------------------------------\r\n    function get(Balance storage self, address currencyCt, uint256 currencyId)\r\n    internal\r\n    view\r\n    returns (int256)\r\n    {\r\n        return self.amountByCurrency[currencyCt][currencyId];\r\n    }\r\n\r\n    function getByBlockNumber(Balance storage self, address currencyCt, uint256 currencyId, uint256 blockNumber)\r\n    internal\r\n    view\r\n    returns (int256)\r\n    {\r\n        (int256 amount,) = recordByBlockNumber(self, currencyCt, currencyId, blockNumber);\r\n        return amount;\r\n    }\r\n\r\n    function set(Balance storage self, int256 amount, address currencyCt, uint256 currencyId)\r\n    internal\r\n    {\r\n        self.amountByCurrency[currencyCt][currencyId] = amount;\r\n\r\n        self.recordsByCurrency[currencyCt][currencyId].push(\r\n            Record(self.amountByCurrency[currencyCt][currencyId], block.number)\r\n        );\r\n\r\n        updateCurrencies(self, currencyCt, currencyId);\r\n    }\r\n\r\n    function add(Balance storage self, int256 amount, address currencyCt, uint256 currencyId)\r\n    internal\r\n    {\r\n        self.amountByCurrency[currencyCt][currencyId] = self.amountByCurrency[currencyCt][currencyId].add(amount);\r\n\r\n        self.recordsByCurrency[currencyCt][currencyId].push(\r\n            Record(self.amountByCurrency[currencyCt][currencyId], block.number)\r\n        );\r\n\r\n        updateCurrencies(self, currencyCt, currencyId);\r\n    }\r\n\r\n    function sub(Balance storage self, int256 amount, address currencyCt, uint256 currencyId)\r\n    internal\r\n    {\r\n        self.amountByCurrency[currencyCt][currencyId] = self.amountByCurrency[currencyCt][currencyId].sub(amount);\r\n\r\n        self.recordsByCurrency[currencyCt][currencyId].push(\r\n            Record(self.amountByCurrency[currencyCt][currencyId], block.number)\r\n        );\r\n\r\n        updateCurrencies(self, currencyCt, currencyId);\r\n    }\r\n\r\n    function transfer(Balance storage _from, Balance storage _to, int256 amount,\r\n        address currencyCt, uint256 currencyId)\r\n    internal\r\n    {\r\n        sub(_from, amount, currencyCt, currencyId);\r\n        add(_to, amount, currencyCt, currencyId);\r\n    }\r\n\r\n    function add_nn(Balance storage self, int256 amount, address currencyCt, uint256 currencyId)\r\n    internal\r\n    {\r\n        self.amountByCurrency[currencyCt][currencyId] = self.amountByCurrency[currencyCt][currencyId].add_nn(amount);\r\n\r\n        self.recordsByCurrency[currencyCt][currencyId].push(\r\n            Record(self.amountByCurrency[currencyCt][currencyId], block.number)\r\n        );\r\n\r\n        updateCurrencies(self, currencyCt, currencyId);\r\n    }\r\n\r\n    function sub_nn(Balance storage self, int256 amount, address currencyCt, uint256 currencyId)\r\n    internal\r\n    {\r\n        self.amountByCurrency[currencyCt][currencyId] = self.amountByCurrency[currencyCt][currencyId].sub_nn(amount);\r\n\r\n        self.recordsByCurrency[currencyCt][currencyId].push(\r\n            Record(self.amountByCurrency[currencyCt][currencyId], block.number)\r\n        );\r\n\r\n        updateCurrencies(self, currencyCt, currencyId);\r\n    }\r\n\r\n    function transfer_nn(Balance storage _from, Balance storage _to, int256 amount,\r\n        address currencyCt, uint256 currencyId)\r\n    internal\r\n    {\r\n        sub_nn(_from, amount, currencyCt, currencyId);\r\n        add_nn(_to, amount, currencyCt, currencyId);\r\n    }\r\n\r\n    function recordsCount(Balance storage self, address currencyCt, uint256 currencyId)\r\n    internal\r\n    view\r\n    returns (uint256)\r\n    {\r\n        return self.recordsByCurrency[currencyCt][currencyId].length;\r\n    }\r\n\r\n    function recordByBlockNumber(Balance storage self, address currencyCt, uint256 currencyId, uint256 blockNumber)\r\n    internal\r\n    view\r\n    returns (int256, uint256)\r\n    {\r\n        uint256 index = indexByBlockNumber(self, currencyCt, currencyId, blockNumber);\r\n        return 0 < index ? recordByIndex(self, currencyCt, currencyId, index - 1) : (0, 0);\r\n    }\r\n\r\n    function recordByIndex(Balance storage self, address currencyCt, uint256 currencyId, uint256 index)\r\n    internal\r\n    view\r\n    returns (int256, uint256)\r\n    {\r\n        if (0 == self.recordsByCurrency[currencyCt][currencyId].length)\r\n            return (0, 0);\r\n\r\n        index = index.clampMax(self.recordsByCurrency[currencyCt][currencyId].length - 1);\r\n        Record storage record = self.recordsByCurrency[currencyCt][currencyId][index];\r\n        return (record.amount, record.blockNumber);\r\n    }\r\n\r\n    function lastRecord(Balance storage self, address currencyCt, uint256 currencyId)\r\n    internal\r\n    view\r\n    returns (int256, uint256)\r\n    {\r\n        if (0 == self.recordsByCurrency[currencyCt][currencyId].length)\r\n            return (0, 0);\r\n\r\n        Record storage record = self.recordsByCurrency[currencyCt][currencyId][self.recordsByCurrency[currencyCt][currencyId].length - 1];\r\n        return (record.amount, record.blockNumber);\r\n    }\r\n\r\n    function hasInUseCurrency(Balance storage self, address currencyCt, uint256 currencyId)\r\n    internal\r\n    view\r\n    returns (bool)\r\n    {\r\n        return self.inUseCurrencies.has(currencyCt, currencyId);\r\n    }\r\n\r\n    function hasEverUsedCurrency(Balance storage self, address currencyCt, uint256 currencyId)\r\n    internal\r\n    view\r\n    returns (bool)\r\n    {\r\n        return self.everUsedCurrencies.has(currencyCt, currencyId);\r\n    }\r\n\r\n    function updateCurrencies(Balance storage self, address currencyCt, uint256 currencyId)\r\n    internal\r\n    {\r\n        if (0 == self.amountByCurrency[currencyCt][currencyId] && self.inUseCurrencies.has(currencyCt, currencyId))\r\n            self.inUseCurrencies.removeByCurrency(currencyCt, currencyId);\r\n        else if (!self.inUseCurrencies.has(currencyCt, currencyId)) {\r\n            self.inUseCurrencies.add(currencyCt, currencyId);\r\n            self.everUsedCurrencies.add(currencyCt, currencyId);\r\n        }\r\n    }\r\n\r\n    function indexByBlockNumber(Balance storage self, address currencyCt, uint256 currencyId, uint256 blockNumber)\r\n    internal\r\n    view\r\n    returns (uint256)\r\n    {\r\n        if (0 == self.recordsByCurrency[currencyCt][currencyId].length)\r\n            return 0;\r\n        for (uint256 i = self.recordsByCurrency[currencyCt][currencyId].length; i > 0; i--)\r\n            if (self.recordsByCurrency[currencyCt][currencyId][i - 1].blockNumber <= blockNumber)\r\n                return i;\r\n        return 0;\r\n    }\r\n}\r\n\r\ncontract Modifiable {\r\n    //\r\n    // Modifiers\r\n    // -----------------------------------------------------------------------------------------------------------------\r\n    modifier notNullAddress(address _address) {\r\n        require(_address != address(0));\r\n        _;\r\n    }\r\n\r\n    modifier notThisAddress(address _address) {\r\n        require(_address != address(this));\r\n        _;\r\n    }\r\n\r\n    modifier notNullOrThisAddress(address _address) {\r\n        require(_address != address(0));\r\n        require(_address != address(this));\r\n        _;\r\n    }\r\n\r\n    modifier notSameAddresses(address _address1, address _address2) {\r\n        if (_address1 != _address2)\r\n            _;\r\n    }\r\n}\r\n\r\nlibrary MonetaryTypesLib {\r\n    //\r\n    // Structures\r\n    // -----------------------------------------------------------------------------------------------------------------\r\n    struct Currency {\r\n        address ct;\r\n        uint256 id;\r\n    }\r\n\r\n    struct Figure {\r\n        int256 amount;\r\n        Currency currency;\r\n    }\r\n\r\n    struct NoncedAmount {\r\n        uint256 nonce;\r\n        int256 amount;\r\n    }\r\n}\r\n\r\nlibrary NahmiiTypesLib {\r\n    //\r\n    // Enums\r\n    // -----------------------------------------------------------------------------------------------------------------\r\n    enum ChallengePhase {Dispute, Closed}\r\n\r\n    //\r\n    // Structures\r\n    // -----------------------------------------------------------------------------------------------------------------\r\n    struct OriginFigure {\r\n        uint256 originId;\r\n        MonetaryTypesLib.Figure figure;\r\n    }\r\n\r\n    struct IntendedConjugateCurrency {\r\n        MonetaryTypesLib.Currency intended;\r\n        MonetaryTypesLib.Currency conjugate;\r\n    }\r\n\r\n    struct SingleFigureTotalOriginFigures {\r\n        MonetaryTypesLib.Figure single;\r\n        OriginFigure[] total;\r\n    }\r\n\r\n    struct TotalOriginFigures {\r\n        OriginFigure[] total;\r\n    }\r\n\r\n    struct CurrentPreviousInt256 {\r\n        int256 current;\r\n        int256 previous;\r\n    }\r\n\r\n    struct SingleTotalInt256 {\r\n        int256 single;\r\n        int256 total;\r\n    }\r\n\r\n    struct IntendedConjugateCurrentPreviousInt256 {\r\n        CurrentPreviousInt256 intended;\r\n        CurrentPreviousInt256 conjugate;\r\n    }\r\n\r\n    struct IntendedConjugateSingleTotalInt256 {\r\n        SingleTotalInt256 intended;\r\n        SingleTotalInt256 conjugate;\r\n    }\r\n\r\n    struct WalletOperatorHashes {\r\n        bytes32 wallet;\r\n        bytes32 operator;\r\n    }\r\n\r\n    struct Signature {\r\n        bytes32 r;\r\n        bytes32 s;\r\n        uint8 v;\r\n    }\r\n\r\n    struct Seal {\r\n        bytes32 hash;\r\n        Signature signature;\r\n    }\r\n\r\n    struct WalletOperatorSeal {\r\n        Seal wallet;\r\n        Seal operator;\r\n    }\r\n}\r\n\r\nlibrary SafeMathIntLib {\r\n    int256 constant INT256_MIN = int256((uint256(1) << 255));\r\n    int256 constant INT256_MAX = int256(~((uint256(1) << 255)));\r\n\r\n    //\r\n    //Functions below accept positive and negative integers and result must not overflow.\r\n    //\r\n    function div(int256 a, int256 b)\r\n    internal\r\n    pure\r\n    returns (int256)\r\n    {\r\n        require(a != INT256_MIN || b != - 1);\r\n        return a / b;\r\n    }\r\n\r\n    function mul(int256 a, int256 b)\r\n    internal\r\n    pure\r\n    returns (int256)\r\n    {\r\n        require(a != - 1 || b != INT256_MIN);\r\n        // overflow\r\n        require(b != - 1 || a != INT256_MIN);\r\n        // overflow\r\n        int256 c = a * b;\r\n        require((b == 0) || (c / b == a));\r\n        return c;\r\n    }\r\n\r\n    function sub(int256 a, int256 b)\r\n    internal\r\n    pure\r\n    returns (int256)\r\n    {\r\n        require((b >= 0 && a - b <= a) || (b < 0 && a - b > a));\r\n        return a - b;\r\n    }\r\n\r\n    function add(int256 a, int256 b)\r\n    internal\r\n    pure\r\n    returns (int256)\r\n    {\r\n        int256 c = a + b;\r\n        require((b >= 0 && c >= a) || (b < 0 && c < a));\r\n        return c;\r\n    }\r\n\r\n    //\r\n    //Functions below only accept positive integers and result must be greater or equal to zero too.\r\n    //\r\n    function div_nn(int256 a, int256 b)\r\n    internal\r\n    pure\r\n    returns (int256)\r\n    {\r\n        require(a >= 0 && b > 0);\r\n        return a / b;\r\n    }\r\n\r\n    function mul_nn(int256 a, int256 b)\r\n    internal\r\n    pure\r\n    returns (int256)\r\n    {\r\n        require(a >= 0 && b >= 0);\r\n        int256 c = a * b;\r\n        require(a == 0 || c / a == b);\r\n        require(c >= 0);\r\n        return c;\r\n    }\r\n\r\n    function sub_nn(int256 a, int256 b)\r\n    internal\r\n    pure\r\n    returns (int256)\r\n    {\r\n        require(a >= 0 && b >= 0 && b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add_nn(int256 a, int256 b)\r\n    internal\r\n    pure\r\n    returns (int256)\r\n    {\r\n        require(a >= 0 && b >= 0);\r\n        int256 c = a + b;\r\n        require(c >= a);\r\n        return c;\r\n    }\r\n\r\n    //\r\n    //Conversion and validation functions.\r\n    //\r\n    function abs(int256 a)\r\n    public\r\n    pure\r\n    returns (int256)\r\n    {\r\n        return a < 0 ? neg(a) : a;\r\n    }\r\n\r\n    function neg(int256 a)\r\n    public\r\n    pure\r\n    returns (int256)\r\n    {\r\n        return mul(a, - 1);\r\n    }\r\n\r\n    function toNonZeroInt256(uint256 a)\r\n    public\r\n    pure\r\n    returns (int256)\r\n    {\r\n        require(a > 0 && a < (uint256(1) << 255));\r\n        return int256(a);\r\n    }\r\n\r\n    function toInt256(uint256 a)\r\n    public\r\n    pure\r\n    returns (int256)\r\n    {\r\n        require(a >= 0 && a < (uint256(1) << 255));\r\n        return int256(a);\r\n    }\r\n\r\n    function toUInt256(int256 a)\r\n    public\r\n    pure\r\n    returns (uint256)\r\n    {\r\n        require(a >= 0);\r\n        return uint256(a);\r\n    }\r\n\r\n    function isNonZeroPositiveInt256(int256 a)\r\n    public\r\n    pure\r\n    returns (bool)\r\n    {\r\n        return (a > 0);\r\n    }\r\n\r\n    function isPositiveInt256(int256 a)\r\n    public\r\n    pure\r\n    returns (bool)\r\n    {\r\n        return (a >= 0);\r\n    }\r\n\r\n    function isNonZeroNegativeInt256(int256 a)\r\n    public\r\n    pure\r\n    returns (bool)\r\n    {\r\n        return (a < 0);\r\n    }\r\n\r\n    function isNegativeInt256(int256 a)\r\n    public\r\n    pure\r\n    returns (bool)\r\n    {\r\n        return (a <= 0);\r\n    }\r\n\r\n    //\r\n    //Clamping functions.\r\n    //\r\n    function clamp(int256 a, int256 min, int256 max)\r\n    public\r\n    pure\r\n    returns (int256)\r\n    {\r\n        if (a < min)\r\n            return min;\r\n        return (a > max) ? max : a;\r\n    }\r\n\r\n    function clampMin(int256 a, int256 min)\r\n    public\r\n    pure\r\n    returns (int256)\r\n    {\r\n        return (a < min) ? min : a;\r\n    }\r\n\r\n    function clampMax(int256 a, int256 max)\r\n    public\r\n    pure\r\n    returns (int256)\r\n    {\r\n        return (a > max) ? max : a;\r\n    }\r\n}\r\n\r\nlibrary SafeMathUintLib {\r\n    function mul(uint256 a, uint256 b)\r\n    internal\r\n    pure\r\n    returns (uint256)\r\n    {\r\n        uint256 c = a * b;\r\n        assert(a == 0 || c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b)\r\n    internal\r\n    pure\r\n    returns (uint256)\r\n    {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b)\r\n    internal\r\n    pure\r\n    returns (uint256)\r\n    {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b)\r\n    internal\r\n    pure\r\n    returns (uint256)\r\n    {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n\r\n    //\r\n    //Clamping functions.\r\n    //\r\n    function clamp(uint256 a, uint256 min, uint256 max)\r\n    public\r\n    pure\r\n    returns (uint256)\r\n    {\r\n        return (a > max) ? max : ((a < min) ? min : a);\r\n    }\r\n\r\n    function clampMin(uint256 a, uint256 min)\r\n    public\r\n    pure\r\n    returns (uint256)\r\n    {\r\n        return (a < min) ? min : a;\r\n    }\r\n\r\n    function clampMax(uint256 a, uint256 max)\r\n    public\r\n    pure\r\n    returns (uint256)\r\n    {\r\n        return (a > max) ? max : a;\r\n    }\r\n}\r\n\r\ncontract SelfDestructible {\r\n    //\r\n    // Variables\r\n    // -----------------------------------------------------------------------------------------------------------------\r\n    bool public selfDestructionDisabled;\r\n\r\n    //\r\n    // Events\r\n    // -----------------------------------------------------------------------------------------------------------------\r\n    event SelfDestructionDisabledEvent(address wallet);\r\n    event TriggerSelfDestructionEvent(address wallet);\r\n\r\n    //\r\n    // Functions\r\n    // -----------------------------------------------------------------------------------------------------------------\r\n    /// @notice Get the address of the destructor role\r\n    function destructor()\r\n    public\r\n    view\r\n    returns (address);\r\n\r\n    /// @notice Disable self-destruction of this contract\r\n    /// @dev This operation can not be undone\r\n    function disableSelfDestruction()\r\n    public\r\n    {\r\n        // Require that sender is the assigned destructor\r\n        require(destructor() == msg.sender);\r\n\r\n        // Disable self-destruction\r\n        selfDestructionDisabled = true;\r\n\r\n        // Emit event\r\n        emit SelfDestructionDisabledEvent(msg.sender);\r\n    }\r\n\r\n    /// @notice Destroy this contract\r\n    function triggerSelfDestruction()\r\n    public\r\n    {\r\n        // Require that sender is the assigned destructor\r\n        require(destructor() == msg.sender);\r\n\r\n        // Require that self-destruction has not been disabled\r\n        require(!selfDestructionDisabled);\r\n\r\n        // Emit event\r\n        emit TriggerSelfDestructionEvent(msg.sender);\r\n\r\n        // Self-destruct and reward destructor\r\n        selfdestruct(msg.sender);\r\n    }\r\n}\r\n\r\ncontract Ownable is Modifiable, SelfDestructible {\r\n    //\r\n    // Variables\r\n    // -----------------------------------------------------------------------------------------------------------------\r\n    address public deployer;\r\n    address public operator;\r\n\r\n    //\r\n    // Events\r\n    // -----------------------------------------------------------------------------------------------------------------\r\n    event SetDeployerEvent(address oldDeployer, address newDeployer);\r\n    event SetOperatorEvent(address oldOperator, address newOperator);\r\n\r\n    //\r\n    // Constructor\r\n    // -----------------------------------------------------------------------------------------------------------------\r\n    constructor(address _deployer) internal notNullOrThisAddress(_deployer) {\r\n        deployer = _deployer;\r\n        operator = _deployer;\r\n    }\r\n\r\n    //\r\n    // Functions\r\n    // -----------------------------------------------------------------------------------------------------------------\r\n    /// @notice Return the address that is able to initiate self-destruction\r\n    function destructor()\r\n    public\r\n    view\r\n    returns (address)\r\n    {\r\n        return deployer;\r\n    }\r\n\r\n    /// @notice Set the deployer of this contract\r\n    /// @param newDeployer The address of the new deployer\r\n    function setDeployer(address newDeployer)\r\n    public\r\n    onlyDeployer\r\n    notNullOrThisAddress(newDeployer)\r\n    {\r\n        if (newDeployer != deployer) {\r\n            // Set new deployer\r\n            address oldDeployer = deployer;\r\n            deployer = newDeployer;\r\n\r\n            // Emit event\r\n            emit SetDeployerEvent(oldDeployer, newDeployer);\r\n        }\r\n    }\r\n\r\n    /// @notice Set the operator of this contract\r\n    /// @param newOperator The address of the new operator\r\n    function setOperator(address newOperator)\r\n    public\r\n    onlyOperator\r\n    notNullOrThisAddress(newOperator)\r\n    {\r\n        if (newOperator != operator) {\r\n            // Set new operator\r\n            address oldOperator = operator;\r\n            operator = newOperator;\r\n\r\n            // Emit event\r\n            emit SetOperatorEvent(oldOperator, newOperator);\r\n        }\r\n    }\r\n\r\n    /// @notice Gauge whether message sender is deployer or not\r\n    /// @return true if msg.sender is deployer, else false\r\n    function isDeployer()\r\n    internal\r\n    view\r\n    returns (bool)\r\n    {\r\n        return msg.sender == deployer;\r\n    }\r\n\r\n    /// @notice Gauge whether message sender is operator or not\r\n    /// @return true if msg.sender is operator, else false\r\n    function isOperator()\r\n    internal\r\n    view\r\n    returns (bool)\r\n    {\r\n        return msg.sender == operator;\r\n    }\r\n\r\n    /// @notice Gauge whether message sender is operator or deployer on the one hand, or none of these on these on\r\n    /// on the other hand\r\n    /// @return true if msg.sender is operator, else false\r\n    function isDeployerOrOperator()\r\n    internal\r\n    view\r\n    returns (bool)\r\n    {\r\n        return isDeployer() || isOperator();\r\n    }\r\n\r\n    // Modifiers\r\n    // -----------------------------------------------------------------------------------------------------------------\r\n    modifier onlyDeployer() {\r\n        require(isDeployer());\r\n        _;\r\n    }\r\n\r\n    modifier notDeployer() {\r\n        require(!isDeployer());\r\n        _;\r\n    }\r\n\r\n    modifier onlyOperator() {\r\n        require(isOperator());\r\n        _;\r\n    }\r\n\r\n    modifier notOperator() {\r\n        require(!isOperator());\r\n        _;\r\n    }\r\n\r\n    modifier onlyDeployerOrOperator() {\r\n        require(isDeployerOrOperator());\r\n        _;\r\n    }\r\n\r\n    modifier notDeployerOrOperator() {\r\n        require(!isDeployerOrOperator());\r\n        _;\r\n    }\r\n}\r\n\r\ncontract Benefactor is Ownable {\r\n    //\r\n    // Variables\r\n    // -----------------------------------------------------------------------------------------------------------------\r\n    address[] internal beneficiaries;\r\n    mapping(address => uint256) internal beneficiaryIndexByAddress;\r\n\r\n    //\r\n    // Events\r\n    // -----------------------------------------------------------------------------------------------------------------\r\n    event RegisterBeneficiaryEvent(address beneficiary);\r\n    event DeregisterBeneficiaryEvent(address beneficiary);\r\n\r\n    //\r\n    // Functions\r\n    // -----------------------------------------------------------------------------------------------------------------\r\n    /// @notice Register the given beneficiary\r\n    /// @param beneficiary Address of beneficiary to be registered\r\n    function registerBeneficiary(address beneficiary)\r\n    public\r\n    onlyDeployer\r\n    notNullAddress(beneficiary)\r\n    returns (bool)\r\n    {\r\n        if (beneficiaryIndexByAddress[beneficiary] > 0)\r\n            return false;\r\n\r\n        beneficiaries.push(beneficiary);\r\n        beneficiaryIndexByAddress[beneficiary] = beneficiaries.length;\r\n\r\n        // Emit event\r\n        emit RegisterBeneficiaryEvent(beneficiary);\r\n\r\n        return true;\r\n    }\r\n\r\n    /// @notice Deregister the given beneficiary\r\n    /// @param beneficiary Address of beneficiary to be deregistered\r\n    function deregisterBeneficiary(address beneficiary)\r\n    public\r\n    onlyDeployer\r\n    notNullAddress(beneficiary)\r\n    returns (bool)\r\n    {\r\n        if (beneficiaryIndexByAddress[beneficiary] == 0)\r\n            return false;\r\n\r\n        uint256 idx = beneficiaryIndexByAddress[beneficiary] - 1;\r\n        if (idx < beneficiaries.length - 1) {\r\n            // Remap the last item in the array to this index\r\n            beneficiaries[idx] = beneficiaries[beneficiaries.length - 1];\r\n            beneficiaryIndexByAddress[beneficiaries[idx]] = idx + 1;\r\n        }\r\n        beneficiaries.length--;\r\n        beneficiaryIndexByAddress[beneficiary] = 0;\r\n\r\n        // Emit event\r\n        emit DeregisterBeneficiaryEvent(beneficiary);\r\n\r\n        return true;\r\n    }\r\n\r\n    /// @notice Gauge whether the given address is the one of a registered beneficiary\r\n    /// @param beneficiary Address of beneficiary\r\n    /// @return true if beneficiary is registered, else false\r\n    function isRegisteredBeneficiary(address beneficiary)\r\n    public\r\n    view\r\n    returns (bool)\r\n    {\r\n        return beneficiaryIndexByAddress[beneficiary] > 0;\r\n    }\r\n\r\n    /// @notice Get the count of registered beneficiaries\r\n    /// @return The count of registered beneficiaries\r\n    function registeredBeneficiariesCount()\r\n    public\r\n    view\r\n    returns (uint256)\r\n    {\r\n        return beneficiaries.length;\r\n    }\r\n}\r\n\r\ncontract AccrualBenefactor is Benefactor {\r\n    using SafeMathIntLib for int256;\r\n\r\n    //\r\n    // Variables\r\n    // -----------------------------------------------------------------------------------------------------------------\r\n    mapping(address => int256) private _beneficiaryFractionMap;\r\n    int256 public totalBeneficiaryFraction;\r\n\r\n    //\r\n    // Events\r\n    // -----------------------------------------------------------------------------------------------------------------\r\n    event RegisterAccrualBeneficiaryEvent(address beneficiary, int256 fraction);\r\n    event DeregisterAccrualBeneficiaryEvent(address beneficiary);\r\n\r\n    //\r\n    // Functions\r\n    // -----------------------------------------------------------------------------------------------------------------\r\n    /// @notice Register the given beneficiary for the entirety fraction\r\n    /// @param beneficiary Address of beneficiary to be registered\r\n    function registerBeneficiary(address beneficiary)\r\n    public\r\n    onlyDeployer\r\n    notNullAddress(beneficiary)\r\n    returns (bool)\r\n    {\r\n        return registerFractionalBeneficiary(beneficiary, ConstantsLib.PARTS_PER());\r\n    }\r\n\r\n    /// @notice Register the given beneficiary for the given fraction\r\n    /// @param beneficiary Address of beneficiary to be registered\r\n    /// @param fraction Fraction of benefits to be given\r\n    function registerFractionalBeneficiary(address beneficiary, int256 fraction)\r\n    public\r\n    onlyDeployer\r\n    notNullAddress(beneficiary)\r\n    returns (bool)\r\n    {\r\n        require(fraction > 0);\r\n        require(totalBeneficiaryFraction.add(fraction) <= ConstantsLib.PARTS_PER());\r\n\r\n        if (!super.registerBeneficiary(beneficiary))\r\n            return false;\r\n\r\n        _beneficiaryFractionMap[beneficiary] = fraction;\r\n        totalBeneficiaryFraction = totalBeneficiaryFraction.add(fraction);\r\n\r\n        // Emit event\r\n        emit RegisterAccrualBeneficiaryEvent(beneficiary, fraction);\r\n\r\n        return true;\r\n    }\r\n\r\n    /// @notice Deregister the given beneficiary\r\n    /// @param beneficiary Address of beneficiary to be deregistered\r\n    function deregisterBeneficiary(address beneficiary)\r\n    public\r\n    onlyDeployer\r\n    notNullAddress(beneficiary)\r\n    returns (bool)\r\n    {\r\n        if (!super.deregisterBeneficiary(beneficiary))\r\n            return false;\r\n\r\n        totalBeneficiaryFraction = totalBeneficiaryFraction.sub(_beneficiaryFractionMap[beneficiary]);\r\n        _beneficiaryFractionMap[beneficiary] = 0;\r\n\r\n        // Emit event\r\n        emit DeregisterAccrualBeneficiaryEvent(beneficiary);\r\n\r\n        return true;\r\n    }\r\n\r\n    /// @notice Get the fraction of benefits that is granted the given beneficiary\r\n    /// @param beneficiary Address of beneficiary\r\n    /// @return The beneficiary's fraction\r\n    function beneficiaryFraction(address beneficiary)\r\n    public\r\n    view\r\n    returns (int256)\r\n    {\r\n        return _beneficiaryFractionMap[beneficiary];\r\n    }\r\n}\r\n\r\ncontract CommunityVotable is Ownable {\r\n    //\r\n    // Variables\r\n    // -----------------------------------------------------------------------------------------------------------------\r\n    CommunityVote public communityVote;\r\n    bool public communityVoteFrozen;\r\n\r\n    //\r\n    // Events\r\n    // -----------------------------------------------------------------------------------------------------------------\r\n    event SetCommunityVoteEvent(CommunityVote oldCommunityVote, CommunityVote newCommunityVote);\r\n    event FreezeCommunityVoteEvent();\r\n\r\n    //\r\n    // Functions\r\n    // -----------------------------------------------------------------------------------------------------------------\r\n    /// @notice Set the community vote contract\r\n    /// @param newCommunityVote The (address of) CommunityVote contract instance\r\n    function setCommunityVote(CommunityVote newCommunityVote) \r\n    public \r\n    onlyDeployer\r\n    notNullAddress(newCommunityVote)\r\n    notSameAddresses(newCommunityVote, communityVote)\r\n    {\r\n        require(!communityVoteFrozen);\r\n\r\n        // Set new community vote\r\n        CommunityVote oldCommunityVote = communityVote;\r\n        communityVote = newCommunityVote;\r\n\r\n        // Emit event\r\n        emit SetCommunityVoteEvent(oldCommunityVote, newCommunityVote);\r\n    }\r\n\r\n    /// @notice Freeze the community vote from further updates\r\n    /// @dev This operation can not be undone\r\n    function freezeCommunityVote()\r\n    public\r\n    onlyDeployer\r\n    {\r\n        communityVoteFrozen = true;\r\n\r\n        // Emit event\r\n        emit FreezeCommunityVoteEvent();\r\n    }\r\n\r\n    //\r\n    // Modifiers\r\n    // -----------------------------------------------------------------------------------------------------------------\r\n    modifier communityVoteInitialized() {\r\n        require(communityVote != address(0));\r\n        _;\r\n    }\r\n}\r\n\r\ncontract CommunityVote is Ownable {\r\n    //\r\n    // Variables\r\n    // -----------------------------------------------------------------------------------------------------------------\r\n    mapping(address => bool) doubleSpenderByWallet;\r\n    uint256 maxDriipNonce;\r\n    uint256 maxNullNonce;\r\n    bool dataAvailable;\r\n\r\n    //\r\n    // Constructor\r\n    // -----------------------------------------------------------------------------------------------------------------\r\n    constructor(address deployer) Ownable(deployer) public {\r\n        dataAvailable = true;\r\n    }\r\n\r\n    //\r\n    // Results functions\r\n    // -----------------------------------------------------------------------------------------------------------------\r\n    /// @notice Get the double spender status of given wallet\r\n    /// @param wallet The wallet address for which to check double spender status\r\n    /// @return true if wallet is double spender, false otherwise\r\n    function isDoubleSpenderWallet(address wallet)\r\n    public\r\n    view\r\n    returns (bool)\r\n    {\r\n        return doubleSpenderByWallet[wallet];\r\n    }\r\n\r\n    /// @notice Get the max driip nonce to be accepted in settlements\r\n    /// @return the max driip nonce\r\n    function getMaxDriipNonce()\r\n    public\r\n    view\r\n    returns (uint256)\r\n    {\r\n        return maxDriipNonce;\r\n    }\r\n\r\n    /// @notice Get the max null settlement nonce to be accepted in settlements\r\n    /// @return the max driip nonce\r\n    function getMaxNullNonce()\r\n    public\r\n    view\r\n    returns (uint256)\r\n    {\r\n        return maxNullNonce;\r\n    }\r\n\r\n    /// @notice Get the data availability status\r\n    /// @return true if data is available\r\n    function isDataAvailable()\r\n    public\r\n    view\r\n    returns (bool)\r\n    {\r\n        return dataAvailable;\r\n    }\r\n}\r\n\r\ncontract Servable is Ownable {\r\n    //\r\n    // Types\r\n    // -----------------------------------------------------------------------------------------------------------------\r\n    struct ServiceInfo {\r\n        bool registered;\r\n        uint256 activationTimestamp;\r\n        mapping(bytes32 => bool) actionsEnabledMap;\r\n        bytes32[] actionsList;\r\n    }\r\n\r\n    //\r\n    // Variables\r\n    // -----------------------------------------------------------------------------------------------------------------\r\n    mapping(address => ServiceInfo) internal registeredServicesMap;\r\n    uint256 public serviceActivationTimeout;\r\n\r\n    //\r\n    // Events\r\n    // -----------------------------------------------------------------------------------------------------------------\r\n    event ServiceActivationTimeoutEvent(uint256 timeoutInSeconds);\r\n    event RegisterServiceEvent(address service);\r\n    event RegisterServiceDeferredEvent(address service, uint256 timeout);\r\n    event DeregisterServiceEvent(address service);\r\n    event EnableServiceActionEvent(address service, string action);\r\n    event DisableServiceActionEvent(address service, string action);\r\n\r\n    //\r\n    // Functions\r\n    // -----------------------------------------------------------------------------------------------------------------\r\n    /// @notice Set the service activation timeout\r\n    /// @param timeoutInSeconds The set timeout in unit of seconds\r\n    function setServiceActivationTimeout(uint256 timeoutInSeconds)\r\n    public\r\n    onlyDeployer\r\n    {\r\n        serviceActivationTimeout = timeoutInSeconds;\r\n\r\n        // Emit event\r\n        emit ServiceActivationTimeoutEvent(timeoutInSeconds);\r\n    }\r\n\r\n    /// @notice Register a service contract whose activation is immediate\r\n    /// @param service The address of the service contract to be registered\r\n    function registerService(address service)\r\n    public\r\n    onlyDeployer\r\n    notNullOrThisAddress(service)\r\n    {\r\n        _registerService(service, 0);\r\n\r\n        // Emit event\r\n        emit RegisterServiceEvent(service);\r\n    }\r\n\r\n    /// @notice Register a service contract whose activation is deferred by the service activation timeout\r\n    /// @param service The address of the service contract to be registered\r\n    function registerServiceDeferred(address service)\r\n    public\r\n    onlyDeployer\r\n    notNullOrThisAddress(service)\r\n    {\r\n        _registerService(service, serviceActivationTimeout);\r\n\r\n        // Emit event\r\n        emit RegisterServiceDeferredEvent(service, serviceActivationTimeout);\r\n    }\r\n\r\n    /// @notice Deregister a service contract\r\n    /// @param service The address of the service contract to be deregistered\r\n    function deregisterService(address service)\r\n    public\r\n    onlyDeployer\r\n    notNullOrThisAddress(service)\r\n    {\r\n        require(registeredServicesMap[service].registered);\r\n\r\n        registeredServicesMap[service].registered = false;\r\n\r\n        // Emit event\r\n        emit DeregisterServiceEvent(service);\r\n    }\r\n\r\n    /// @notice Enable a named action in an already registered service contract\r\n    /// @param service The address of the registered service contract\r\n    /// @param action The name of the action to be enabled\r\n    function enableServiceAction(address service, string action)\r\n    public\r\n    onlyDeployer\r\n    notNullOrThisAddress(service)\r\n    {\r\n        require(registeredServicesMap[service].registered);\r\n\r\n        bytes32 actionHash = hashString(action);\r\n\r\n        require(!registeredServicesMap[service].actionsEnabledMap[actionHash]);\r\n\r\n        registeredServicesMap[service].actionsEnabledMap[actionHash] = true;\r\n        registeredServicesMap[service].actionsList.push(actionHash);\r\n\r\n        // Emit event\r\n        emit EnableServiceActionEvent(service, action);\r\n    }\r\n\r\n    /// @notice Enable a named action in a service contract\r\n    /// @param service The address of the service contract\r\n    /// @param action The name of the action to be disabled\r\n    function disableServiceAction(address service, string action)\r\n    public\r\n    onlyDeployer\r\n    notNullOrThisAddress(service)\r\n    {\r\n        bytes32 actionHash = hashString(action);\r\n\r\n        require(registeredServicesMap[service].actionsEnabledMap[actionHash]);\r\n\r\n        registeredServicesMap[service].actionsEnabledMap[actionHash] = false;\r\n\r\n        // Emit event\r\n        emit DisableServiceActionEvent(service, action);\r\n    }\r\n\r\n    /// @notice Gauge whether a service contract is registered\r\n    /// @param service The address of the service contract\r\n    /// @return true if service is registered, else false\r\n    function isRegisteredService(address service)\r\n    public\r\n    view\r\n    returns (bool)\r\n    {\r\n        return registeredServicesMap[service].registered;\r\n    }\r\n\r\n    /// @notice Gauge whether a service contract is registered and active\r\n    /// @param service The address of the service contract\r\n    /// @return true if service is registered and activate, else false\r\n    function isRegisteredActiveService(address service)\r\n    public\r\n    view\r\n    returns (bool)\r\n    {\r\n        return isRegisteredService(service) && block.timestamp >= registeredServicesMap[service].activationTimestamp;\r\n    }\r\n\r\n    /// @notice Gauge whether a service contract action is enabled which implies also registered and active\r\n    /// @param service The address of the service contract\r\n    /// @param action The name of action\r\n    function isEnabledServiceAction(address service, string action)\r\n    public\r\n    view\r\n    returns (bool)\r\n    {\r\n        bytes32 actionHash = hashString(action);\r\n        return isRegisteredActiveService(service) && registeredServicesMap[service].actionsEnabledMap[actionHash];\r\n    }\r\n\r\n    //\r\n    // Internal functions\r\n    // -----------------------------------------------------------------------------------------------------------------\r\n    function hashString(string _string)\r\n    internal\r\n    pure\r\n    returns (bytes32)\r\n    {\r\n        return keccak256(abi.encodePacked(_string));\r\n    }\r\n\r\n    //\r\n    // Private functions\r\n    // -----------------------------------------------------------------------------------------------------------------\r\n    function _registerService(address service, uint256 timeout)\r\n    private\r\n    {\r\n        if (!registeredServicesMap[service].registered) {\r\n            registeredServicesMap[service].registered = true;\r\n            registeredServicesMap[service].activationTimestamp = block.timestamp + timeout;\r\n        }\r\n    }\r\n\r\n    //\r\n    // Modifiers\r\n    // -----------------------------------------------------------------------------------------------------------------\r\n    modifier onlyActiveService() {\r\n        require(isRegisteredActiveService(msg.sender));\r\n        _;\r\n    }\r\n\r\n    modifier onlyEnabledServiceAction(string action) {\r\n        require(isEnabledServiceAction(msg.sender, action));\r\n        _;\r\n    }\r\n}\r\n\r\ncontract DriipSettlementState is Ownable, Servable, CommunityVotable {\r\n    using SafeMathIntLib for int256;\r\n    using SafeMathUintLib for uint256;\r\n\r\n    //\r\n    // Constants\r\n    // -----------------------------------------------------------------------------------------------------------------\r\n    string constant public INIT_SETTLEMENT_ACTION = \"init_settlement\";\r\n    string constant public SET_SETTLEMENT_ROLE_DONE_ACTION = \"set_settlement_role_done\";\r\n    string constant public SET_MAX_NONCE_ACTION = \"set_max_nonce\";\r\n    string constant public SET_MAX_DRIIP_NONCE_ACTION = \"set_max_driip_nonce\";\r\n    string constant public SET_FEE_TOTAL_ACTION = \"set_fee_total\";\r\n\r\n    //\r\n    // Variables\r\n    // -----------------------------------------------------------------------------------------------------------------\r\n    uint256 public maxDriipNonce;\r\n\r\n    DriipSettlementTypesLib.Settlement[] public settlements;\r\n    mapping(address => uint256[]) public walletSettlementIndices;\r\n    mapping(address => mapping(uint256 => uint256)) public walletNonceSettlementIndex;\r\n    mapping(address => mapping(address => mapping(uint256 => uint256))) public walletCurrencyMaxNonce;\r\n\r\n    mapping(address => mapping(address => mapping(address => mapping(address => mapping(uint256 => MonetaryTypesLib.NoncedAmount))))) public totalFeesMap;\r\n\r\n    //\r\n    // Events\r\n    // -----------------------------------------------------------------------------------------------------------------\r\n    event InitSettlementEvent(DriipSettlementTypesLib.Settlement settlement);\r\n    event SetSettlementRoleDoneEvent(address wallet, uint256 nonce,\r\n        DriipSettlementTypesLib.SettlementRole settlementRole, bool done);\r\n    event SetMaxNonceByWalletAndCurrencyEvent(address wallet, MonetaryTypesLib.Currency currency,\r\n        uint256 maxNonce);\r\n    event SetMaxDriipNonceEvent(uint256 maxDriipNonce);\r\n    event UpdateMaxDriipNonceFromCommunityVoteEvent(uint256 maxDriipNonce);\r\n    event SetTotalFeeEvent(address wallet, Beneficiary beneficiary, address destination,\r\n        MonetaryTypesLib.Currency currency, MonetaryTypesLib.NoncedAmount totalFee);\r\n\r\n    //\r\n    // Constructor\r\n    // -----------------------------------------------------------------------------------------------------------------\r\n    constructor(address deployer) Ownable(deployer) public {\r\n    }\r\n\r\n    //\r\n    // Functions\r\n    // -----------------------------------------------------------------------------------------------------------------\r\n    /// @notice Get the count of settlements\r\n    function settlementsCount()\r\n    public\r\n    view\r\n    returns (uint256)\r\n    {\r\n        return settlements.length;\r\n    }\r\n\r\n    /// @notice Get the count of settlements for given wallet\r\n    /// @param wallet The address for which to return settlement count\r\n    /// @return count of settlements for the provided wallet\r\n    function settlementsCountByWallet(address wallet)\r\n    public\r\n    view\r\n    returns (uint256)\r\n    {\r\n        return walletSettlementIndices[wallet].length;\r\n    }\r\n\r\n    /// @notice Get settlement of given wallet and index\r\n    /// @param wallet The address for which to return settlement\r\n    /// @param index The wallet's settlement index\r\n    /// @return settlement for the provided wallet and index\r\n    function settlementByWalletAndIndex(address wallet, uint256 index)\r\n    public\r\n    view\r\n    returns (DriipSettlementTypesLib.Settlement)\r\n    {\r\n        require(walletSettlementIndices[wallet].length > index);\r\n        return settlements[walletSettlementIndices[wallet][index] - 1];\r\n    }\r\n\r\n    /// @notice Get settlement of given wallet and wallet nonce\r\n    /// @param wallet The address for which to return settlement\r\n    /// @param nonce The wallet's nonce\r\n    /// @return settlement for the provided wallet and index\r\n    function settlementByWalletAndNonce(address wallet, uint256 nonce)\r\n    public\r\n    view\r\n    returns (DriipSettlementTypesLib.Settlement)\r\n    {\r\n        require(0 < walletNonceSettlementIndex[wallet][nonce]);\r\n        return settlements[walletNonceSettlementIndex[wallet][nonce] - 1];\r\n    }\r\n\r\n    /// @notice Initialize settlement, i.e. create one if no such settlement exists\r\n    /// for the double pair of wallets and nonces\r\n    /// @param settledKind The kind of driip of the settlement\r\n    /// @param settledHash The hash of driip of the settlement\r\n    /// @param originWallet The address of the origin wallet\r\n    /// @param originNonce The wallet nonce of the origin wallet\r\n    /// @param targetWallet The address of the target wallet\r\n    /// @param targetNonce The wallet nonce of the target wallet\r\n    function initSettlement(string settledKind, bytes32 settledHash, address originWallet,\r\n        uint256 originNonce, address targetWallet, uint256 targetNonce)\r\n    public\r\n    onlyEnabledServiceAction(INIT_SETTLEMENT_ACTION)\r\n    {\r\n        if (\r\n            0 == walletNonceSettlementIndex[originWallet][originNonce] &&\r\n            0 == walletNonceSettlementIndex[targetWallet][targetNonce]\r\n        ) {\r\n            // Create new settlement\r\n            settlements.length++;\r\n\r\n            // Get the 0-based index\r\n            uint256 index = settlements.length - 1;\r\n\r\n            // Update settlement\r\n            settlements[index].settledKind = settledKind;\r\n            settlements[index].settledHash = settledHash;\r\n            settlements[index].origin.nonce = originNonce;\r\n            settlements[index].origin.wallet = originWallet;\r\n            settlements[index].target.nonce = targetNonce;\r\n            settlements[index].target.wallet = targetWallet;\r\n\r\n            // Emit event\r\n            emit InitSettlementEvent(settlements[index]);\r\n\r\n            // Store 1-based index value\r\n            index++;\r\n            walletSettlementIndices[originWallet].push(index);\r\n            walletSettlementIndices[targetWallet].push(index);\r\n            walletNonceSettlementIndex[originWallet][originNonce] = index;\r\n            walletNonceSettlementIndex[targetWallet][targetNonce] = index;\r\n        }\r\n    }\r\n\r\n    /// @notice Gauge whether the settlement is done wrt the given settlement role\r\n    /// @param wallet The address of the concerned wallet\r\n    /// @param nonce The nonce of the concerned wallet\r\n    /// @param settlementRole The settlement role\r\n    /// @return True if settlement is done for role, else false\r\n    function isSettlementRoleDone(address wallet, uint256 nonce,\r\n        DriipSettlementTypesLib.SettlementRole settlementRole)\r\n    public\r\n    view\r\n    returns (bool)\r\n    {\r\n        // Get the 1-based index of the settlement\r\n        uint256 index = walletNonceSettlementIndex[wallet][nonce];\r\n\r\n        // Return false if settlement does not exist\r\n        if (0 == index)\r\n            return false;\r\n\r\n        // Return done of settlement role\r\n        if (DriipSettlementTypesLib.SettlementRole.Origin == settlementRole)\r\n            return settlements[index - 1].origin.done;\r\n        else // DriipSettlementTypesLib.SettlementRole.Target == settlementRole\r\n            return settlements[index - 1].target.done;\r\n    }\r\n\r\n    /// @notice Set the done of the given settlement role in the given settlement\r\n    /// @param wallet The address of the concerned wallet\r\n    /// @param nonce The nonce of the concerned wallet\r\n    /// @param settlementRole The settlement role\r\n    /// @param done The done flag\r\n    function setSettlementRoleDone(address wallet, uint256 nonce,\r\n        DriipSettlementTypesLib.SettlementRole settlementRole, bool done)\r\n    public\r\n    onlyEnabledServiceAction(SET_SETTLEMENT_ROLE_DONE_ACTION)\r\n    {\r\n        // Get the 1-based index of the settlement\r\n        uint256 index = walletNonceSettlementIndex[wallet][nonce];\r\n\r\n        // Require the existence of settlement\r\n        require(0 != index);\r\n\r\n        // Update the settlement role done value\r\n        if (DriipSettlementTypesLib.SettlementRole.Origin == settlementRole)\r\n            settlements[index - 1].origin.done = done;\r\n        else // DriipSettlementTypesLib.SettlementRole.Target == settlementRole\r\n            settlements[index - 1].target.done = done;\r\n\r\n        // Emit event\r\n        emit SetSettlementRoleDoneEvent(wallet, nonce, settlementRole, done);\r\n    }\r\n\r\n    /// @notice Set the max (driip) nonce\r\n    /// @param _maxDriipNonce The max nonce\r\n    function setMaxDriipNonce(uint256 _maxDriipNonce)\r\n    public\r\n    onlyEnabledServiceAction(SET_MAX_DRIIP_NONCE_ACTION)\r\n    {\r\n        maxDriipNonce = _maxDriipNonce;\r\n\r\n        // Emit event\r\n        emit SetMaxDriipNonceEvent(maxDriipNonce);\r\n    }\r\n\r\n    /// @notice Update the max driip nonce property from CommunityVote contract\r\n    function updateMaxDriipNonceFromCommunityVote()\r\n    public\r\n    {\r\n        uint256 _maxDriipNonce = communityVote.getMaxDriipNonce();\r\n        if (0 == _maxDriipNonce)\r\n            return;\r\n\r\n        maxDriipNonce = _maxDriipNonce;\r\n\r\n        // Emit event\r\n        emit UpdateMaxDriipNonceFromCommunityVoteEvent(maxDriipNonce);\r\n    }\r\n\r\n    /// @notice Get the max nonce of the given wallet and currency\r\n    /// @param wallet The address of the concerned wallet\r\n    /// @param currency The concerned currency\r\n    /// @return The max nonce\r\n    function maxNonceByWalletAndCurrency(address wallet, MonetaryTypesLib.Currency currency)\r\n    public\r\n    view\r\n    returns (uint256)\r\n    {\r\n        return walletCurrencyMaxNonce[wallet][currency.ct][currency.id];\r\n    }\r\n\r\n    /// @notice Set the max nonce of the given wallet and currency\r\n    /// @param wallet The address of the concerned wallet\r\n    /// @param currency The concerned currency\r\n    /// @param maxNonce The max nonce\r\n    function setMaxNonceByWalletAndCurrency(address wallet, MonetaryTypesLib.Currency currency,\r\n        uint256 maxNonce)\r\n    public\r\n    onlyEnabledServiceAction(SET_MAX_NONCE_ACTION)\r\n    {\r\n        // Update max nonce value\r\n        walletCurrencyMaxNonce[wallet][currency.ct][currency.id] = maxNonce;\r\n\r\n        // Emit event\r\n        emit SetMaxNonceByWalletAndCurrencyEvent(wallet, currency, maxNonce);\r\n    }\r\n\r\n    /// @notice Get the total fee payed by the given wallet to the given beneficiary and destination\r\n    /// in the given currency\r\n    /// @param wallet The address of the concerned wallet\r\n    /// @param beneficiary The concerned beneficiary\r\n    /// @param destination The concerned destination\r\n    /// @param currency The concerned currency\r\n    /// @return The total fee\r\n    function totalFee(address wallet, Beneficiary beneficiary, address destination,\r\n        MonetaryTypesLib.Currency currency)\r\n    public\r\n    view\r\n    returns (MonetaryTypesLib.NoncedAmount)\r\n    {\r\n        return totalFeesMap[wallet][address(beneficiary)][destination][currency.ct][currency.id];\r\n    }\r\n\r\n    /// @notice Set the total fee payed by the given wallet to the given beneficiary and destination\r\n    /// in the given currency\r\n    /// @param wallet The address of the concerned wallet\r\n    /// @param beneficiary The concerned beneficiary\r\n    /// @param destination The concerned destination\r\n    /// @param _totalFee The total fee\r\n    function setTotalFee(address wallet, Beneficiary beneficiary, address destination,\r\n        MonetaryTypesLib.Currency currency, MonetaryTypesLib.NoncedAmount _totalFee)\r\n    public\r\n    onlyEnabledServiceAction(SET_FEE_TOTAL_ACTION)\r\n    {\r\n        // Update total fees value\r\n        totalFeesMap[wallet][address(beneficiary)][destination][currency.ct][currency.id] = _totalFee;\r\n\r\n        // Emit event\r\n        emit SetTotalFeeEvent(wallet, beneficiary, destination, currency, _totalFee);\r\n    }\r\n}\r\n\r\ncontract TransferController {\r\n    //\r\n    // Events\r\n    // -----------------------------------------------------------------------------------------------------------------\r\n    event CurrencyTransferred(address from, address to, uint256 value,\r\n        address currencyCt, uint256 currencyId);\r\n\r\n    //\r\n    // Functions\r\n    // -----------------------------------------------------------------------------------------------------------------\r\n    function isFungible()\r\n    public\r\n    view\r\n    returns (bool);\r\n\r\n    /// @notice MUST be called with DELEGATECALL\r\n    function receive(address from, address to, uint256 value, address currencyCt, uint256 currencyId)\r\n    public;\r\n\r\n    /// @notice MUST be called with DELEGATECALL\r\n    function approve(address to, uint256 value, address currencyCt, uint256 currencyId)\r\n    public;\r\n\r\n    /// @notice MUST be called with DELEGATECALL\r\n    function dispatch(address from, address to, uint256 value, address currencyCt, uint256 currencyId)\r\n    public;\r\n\r\n    //----------------------------------------\r\n\r\n    function getReceiveSignature()\r\n    public\r\n    pure\r\n    returns (bytes4)\r\n    {\r\n        return bytes4(keccak256(\"receive(address,address,uint256,address,uint256)\"));\r\n    }\r\n\r\n    function getApproveSignature()\r\n    public\r\n    pure\r\n    returns (bytes4)\r\n    {\r\n        return bytes4(keccak256(\"approve(address,uint256,address,uint256)\"));\r\n    }\r\n\r\n    function getDispatchSignature()\r\n    public\r\n    pure\r\n    returns (bytes4)\r\n    {\r\n        return bytes4(keccak256(\"dispatch(address,address,uint256,address,uint256)\"));\r\n    }\r\n}\r\n\r\ncontract TransferControllerManageable is Ownable {\r\n    //\r\n    // Variables\r\n    // -----------------------------------------------------------------------------------------------------------------\r\n    TransferControllerManager public transferControllerManager;\r\n\r\n    //\r\n    // Events\r\n    // -----------------------------------------------------------------------------------------------------------------\r\n    event SetTransferControllerManagerEvent(TransferControllerManager oldTransferControllerManager,\r\n        TransferControllerManager newTransferControllerManager);\r\n\r\n    //\r\n    // Functions\r\n    // -----------------------------------------------------------------------------------------------------------------\r\n    /// @notice Set the currency manager contract\r\n    /// @param newTransferControllerManager The (address of) TransferControllerManager contract instance\r\n    function setTransferControllerManager(TransferControllerManager newTransferControllerManager)\r\n    public\r\n    onlyDeployer\r\n    notNullAddress(newTransferControllerManager)\r\n    notSameAddresses(newTransferControllerManager, transferControllerManager)\r\n    {\r\n        //set new currency manager\r\n        TransferControllerManager oldTransferControllerManager = transferControllerManager;\r\n        transferControllerManager = newTransferControllerManager;\r\n\r\n        // Emit event\r\n        emit SetTransferControllerManagerEvent(oldTransferControllerManager, newTransferControllerManager);\r\n    }\r\n\r\n    /// @notice Get the transfer controller of the given currency contract address and standard\r\n    function transferController(address currencyCt, string standard)\r\n    internal\r\n    view\r\n    returns (TransferController)\r\n    {\r\n        return transferControllerManager.transferController(currencyCt, standard);\r\n    }\r\n\r\n    //\r\n    // Modifiers\r\n    // -----------------------------------------------------------------------------------------------------------------\r\n    modifier transferControllerManagerInitialized() {\r\n        require(transferControllerManager != address(0));\r\n        _;\r\n    }\r\n}\r\n\r\ncontract PartnerFund is Ownable, Beneficiary, TransferControllerManageable {\r\n    using FungibleBalanceLib for FungibleBalanceLib.Balance;\r\n    using TxHistoryLib for TxHistoryLib.TxHistory;\r\n    using SafeMathIntLib for int256;\r\n    using Strings for string;\r\n\r\n    //\r\n    // Structures\r\n    // -----------------------------------------------------------------------------------------------------------------\r\n    struct Partner {\r\n        bytes32 nameHash;\r\n\r\n        uint256 fee;\r\n        address wallet;\r\n        uint256 index;\r\n\r\n        bool operatorCanUpdate;\r\n        bool partnerCanUpdate;\r\n\r\n        FungibleBalanceLib.Balance active;\r\n        FungibleBalanceLib.Balance staged;\r\n\r\n        TxHistoryLib.TxHistory txHistory;\r\n        FullBalanceHistory[] fullBalanceHistory;\r\n    }\r\n\r\n    struct FullBalanceHistory {\r\n        uint256 listIndex;\r\n        int256 balance;\r\n        uint256 blockNumber;\r\n    }\r\n\r\n    //\r\n    // Variables\r\n    // -----------------------------------------------------------------------------------------------------------------\r\n    Partner[] private partners;\r\n\r\n    mapping(bytes32 => uint256) private _indexByNameHash;\r\n    mapping(address => uint256) private _indexByWallet;\r\n\r\n    //\r\n    // Events\r\n    // -----------------------------------------------------------------------------------------------------------------\r\n    event ReceiveEvent(address from, int256 amount, address currencyCt, uint256 currencyId);\r\n    event RegisterPartnerByNameEvent(string name, uint256 fee, address wallet);\r\n    event RegisterPartnerByNameHashEvent(bytes32 nameHash, uint256 fee, address wallet);\r\n    event SetFeeByIndexEvent(uint256 index, uint256 oldFee, uint256 newFee);\r\n    event SetFeeByNameEvent(string name, uint256 oldFee, uint256 newFee);\r\n    event SetFeeByNameHashEvent(bytes32 nameHash, uint256 oldFee, uint256 newFee);\r\n    event SetFeeByWalletEvent(address wallet, uint256 oldFee, uint256 newFee);\r\n    event SetPartnerWalletByIndexEvent(uint256 index, address oldWallet, address newWallet);\r\n    event SetPartnerWalletByNameEvent(string name, address oldWallet, address newWallet);\r\n    event SetPartnerWalletByNameHashEvent(bytes32 nameHash, address oldWallet, address newWallet);\r\n    event SetPartnerWalletByWalletEvent(address oldWallet, address newWallet);\r\n    event StageEvent(address from, int256 amount, address currencyCt, uint256 currencyId);\r\n    event WithdrawEvent(address to, int256 amount, address currencyCt, uint256 currencyId);\r\n\r\n    //\r\n    // Constructor\r\n    // -----------------------------------------------------------------------------------------------------------------\r\n    constructor(address deployer) Ownable(deployer) public {\r\n    }\r\n\r\n    //\r\n    // Functions\r\n    // -----------------------------------------------------------------------------------------------------------------\r\n    /// @notice Fallback function that deposits ethers\r\n    function() public payable {\r\n        _receiveEthersTo(\r\n            indexByWallet(msg.sender) - 1, SafeMathIntLib.toNonZeroInt256(msg.value)\r\n        );\r\n    }\r\n\r\n    /// @notice Receive ethers to\r\n    /// @param tag The tag of the concerned partner\r\n    function receiveEthersTo(address tag, string)\r\n    public\r\n    payable\r\n    {\r\n        _receiveEthersTo(\r\n            uint256(tag) - 1, SafeMathIntLib.toNonZeroInt256(msg.value)\r\n        );\r\n    }\r\n\r\n    /// @notice Receive tokens\r\n    /// @param amount The concerned amount\r\n    /// @param currencyCt The address of the concerned currency contract (address(0) == ETH)\r\n    /// @param currencyId The ID of the concerned currency (0 for ETH and ERC20)\r\n    /// @param standard The standard of token (\"ERC20\", \"ERC721\")\r\n    function receiveTokens(string, int256 amount, address currencyCt,\r\n        uint256 currencyId, string standard)\r\n    public\r\n    {\r\n        _receiveTokensTo(\r\n            indexByWallet(msg.sender) - 1, amount, currencyCt, currencyId, standard\r\n        );\r\n    }\r\n\r\n    /// @notice Receive tokens to\r\n    /// @param tag The tag of the concerned partner\r\n    /// @param amount The concerned amount\r\n    /// @param currencyCt The address of the concerned currency contract (address(0) == ETH)\r\n    /// @param currencyId The ID of the concerned currency (0 for ETH and ERC20)\r\n    /// @param standard The standard of token (\"ERC20\", \"ERC721\")\r\n    function receiveTokensTo(address tag, string, int256 amount, address currencyCt,\r\n        uint256 currencyId, string standard)\r\n    public\r\n    {\r\n        _receiveTokensTo(\r\n            uint256(tag) - 1, amount, currencyCt, currencyId, standard\r\n        );\r\n    }\r\n\r\n    /// @notice Hash name\r\n    /// @param name The name to be hashed\r\n    /// @return The hash value\r\n    function hashName(string name)\r\n    public\r\n    pure\r\n    returns (bytes32)\r\n    {\r\n        return keccak256(abi.encodePacked(name.upper()));\r\n    }\r\n\r\n    /// @notice Get deposit by partner and deposit indices\r\n    /// @param partnerIndex The index of the concerned partner\r\n    /// @param depositIndex The index of the concerned deposit\r\n    /// return The deposit parameters\r\n    function depositByIndices(uint256 partnerIndex, uint256 depositIndex)\r\n    public\r\n    view\r\n    returns (int256 balance, uint256 blockNumber, address currencyCt, uint256 currencyId)\r\n    {\r\n        // Require partner index is one of registered partner\r\n        require(0 < partnerIndex && partnerIndex <= partners.length);\r\n\r\n        return _depositByIndices(partnerIndex - 1, depositIndex);\r\n    }\r\n\r\n    /// @notice Get deposit by partner name and deposit indices\r\n    /// @param name The name of the concerned partner\r\n    /// @param depositIndex The index of the concerned deposit\r\n    /// return The deposit parameters\r\n    function depositByName(string name, uint depositIndex)\r\n    public\r\n    view\r\n    returns (int256 balance, uint256 blockNumber, address currencyCt, uint256 currencyId)\r\n    {\r\n        // Implicitly require that partner name is registered\r\n        return _depositByIndices(indexByName(name) - 1, depositIndex);\r\n    }\r\n\r\n    /// @notice Get deposit by partner name hash and deposit indices\r\n    /// @param nameHash The hashed name of the concerned partner\r\n    /// @param depositIndex The index of the concerned deposit\r\n    /// return The deposit parameters\r\n    function depositByNameHash(bytes32 nameHash, uint depositIndex)\r\n    public\r\n    view\r\n    returns (int256 balance, uint256 blockNumber, address currencyCt, uint256 currencyId)\r\n    {\r\n        // Implicitly require that partner name hash is registered\r\n        return _depositByIndices(indexByNameHash(nameHash) - 1, depositIndex);\r\n    }\r\n\r\n    /// @notice Get deposit by partner wallet and deposit indices\r\n    /// @param wallet The wallet of the concerned partner\r\n    /// @param depositIndex The index of the concerned deposit\r\n    /// return The deposit parameters\r\n    function depositByWallet(address wallet, uint depositIndex)\r\n    public\r\n    view\r\n    returns (int256 balance, uint256 blockNumber, address currencyCt, uint256 currencyId)\r\n    {\r\n        // Implicitly require that partner wallet is registered\r\n        return _depositByIndices(indexByWallet(wallet) - 1, depositIndex);\r\n    }\r\n\r\n    /// @notice Get deposits count by partner index\r\n    /// @param index The index of the concerned partner\r\n    /// return The deposits count\r\n    function depositsCountByIndex(uint256 index)\r\n    public\r\n    view\r\n    returns (uint256)\r\n    {\r\n        // Require partner index is one of registered partner\r\n        require(0 < index && index <= partners.length);\r\n\r\n        return _depositsCountByIndex(index - 1);\r\n    }\r\n\r\n    /// @notice Get deposits count by partner name\r\n    /// @param name The name of the concerned partner\r\n    /// return The deposits count\r\n    function depositsCountByName(string name)\r\n    public\r\n    view\r\n    returns (uint256)\r\n    {\r\n        // Implicitly require that partner name is registered\r\n        return _depositsCountByIndex(indexByName(name) - 1);\r\n    }\r\n\r\n    /// @notice Get deposits count by partner name hash\r\n    /// @param nameHash The hashed name of the concerned partner\r\n    /// return The deposits count\r\n    function depositsCountByNameHash(bytes32 nameHash)\r\n    public\r\n    view\r\n    returns (uint256)\r\n    {\r\n        // Implicitly require that partner name hash is registered\r\n        return _depositsCountByIndex(indexByNameHash(nameHash) - 1);\r\n    }\r\n\r\n    /// @notice Get deposits count by partner wallet\r\n    /// @param wallet The wallet of the concerned partner\r\n    /// return The deposits count\r\n    function depositsCountByWallet(address wallet)\r\n    public\r\n    view\r\n    returns (uint256)\r\n    {\r\n        // Implicitly require that partner wallet is registered\r\n        return _depositsCountByIndex(indexByWallet(wallet) - 1);\r\n    }\r\n\r\n    /// @notice Get active balance by partner index and currency\r\n    /// @param index The index of the concerned partner\r\n    /// @param currencyCt The address of the concerned currency contract (address(0) == ETH)\r\n    /// @param currencyId The ID of the concerned currency (0 for ETH and ERC20)\r\n    /// return The active balance\r\n    function activeBalanceByIndex(uint256 index, address currencyCt, uint256 currencyId)\r\n    public\r\n    view\r\n    returns (int256)\r\n    {\r\n        // Require partner index is one of registered partner\r\n        require(0 < index && index <= partners.length);\r\n\r\n        return _activeBalanceByIndex(index - 1, currencyCt, currencyId);\r\n    }\r\n\r\n    /// @notice Get active balance by partner name and currency\r\n    /// @param name The name of the concerned partner\r\n    /// @param currencyCt The address of the concerned currency contract (address(0) == ETH)\r\n    /// @param currencyId The ID of the concerned currency (0 for ETH and ERC20)\r\n    /// return The active balance\r\n    function activeBalanceByName(string name, address currencyCt, uint256 currencyId)\r\n    public\r\n    view\r\n    returns (int256)\r\n    {\r\n        // Implicitly require that partner name is registered\r\n        return _activeBalanceByIndex(indexByName(name) - 1, currencyCt, currencyId);\r\n    }\r\n\r\n    /// @notice Get active balance by partner name hash and currency\r\n    /// @param nameHash The hashed name of the concerned partner\r\n    /// @param currencyCt The address of the concerned currency contract (address(0) == ETH)\r\n    /// @param currencyId The ID of the concerned currency (0 for ETH and ERC20)\r\n    /// return The active balance\r\n    function activeBalanceByNameHash(bytes32 nameHash, address currencyCt, uint256 currencyId)\r\n    public\r\n    view\r\n    returns (int256)\r\n    {\r\n        // Implicitly require that partner name hash is registered\r\n        return _activeBalanceByIndex(indexByNameHash(nameHash) - 1, currencyCt, currencyId);\r\n    }\r\n\r\n    /// @notice Get active balance by partner wallet and currency\r\n    /// @param wallet The wallet of the concerned partner\r\n    /// @param currencyCt The address of the concerned currency contract (address(0) == ETH)\r\n    /// @param currencyId The ID of the concerned currency (0 for ETH and ERC20)\r\n    /// return The active balance\r\n    function activeBalanceByWallet(address wallet, address currencyCt, uint256 currencyId)\r\n    public\r\n    view\r\n    returns (int256)\r\n    {\r\n        // Implicitly require that partner wallet is registered\r\n        return _activeBalanceByIndex(indexByWallet(wallet) - 1, currencyCt, currencyId);\r\n    }\r\n\r\n    /// @notice Get staged balance by partner index and currency\r\n    /// @param index The index of the concerned partner\r\n    /// @param currencyCt The address of the concerned currency contract (address(0) == ETH)\r\n    /// @param currencyId The ID of the concerned currency (0 for ETH and ERC20)\r\n    /// return The staged balance\r\n    function stagedBalanceByIndex(uint256 index, address currencyCt, uint256 currencyId)\r\n    public\r\n    view\r\n    returns (int256)\r\n    {\r\n        // Require partner index is one of registered partner\r\n        require(0 < index && index <= partners.length);\r\n\r\n        return _stagedBalanceByIndex(index - 1, currencyCt, currencyId);\r\n    }\r\n\r\n    /// @notice Get staged balance by partner name and currency\r\n    /// @param name The name of the concerned partner\r\n    /// @param currencyCt The address of the concerned currency contract (address(0) == ETH)\r\n    /// @param currencyId The ID of the concerned currency (0 for ETH and ERC20)\r\n    /// return The staged balance\r\n    function stagedBalanceByName(string name, address currencyCt, uint256 currencyId)\r\n    public\r\n    view\r\n    returns (int256)\r\n    {\r\n        // Implicitly require that partner name is registered\r\n        return _stagedBalanceByIndex(indexByName(name) - 1, currencyCt, currencyId);\r\n    }\r\n\r\n    /// @notice Get staged balance by partner name hash and currency\r\n    /// @param nameHash The hashed name of the concerned partner\r\n    /// @param currencyCt The address of the concerned currency contract (address(0) == ETH)\r\n    /// @param currencyId The ID of the concerned currency (0 for ETH and ERC20)\r\n    /// return The staged balance\r\n    function stagedBalanceByNameHash(bytes32 nameHash, address currencyCt, uint256 currencyId)\r\n    public\r\n    view\r\n    returns (int256)\r\n    {\r\n        // Implicitly require that partner name is registered\r\n        return _stagedBalanceByIndex(indexByNameHash(nameHash) - 1, currencyCt, currencyId);\r\n    }\r\n\r\n    /// @notice Get staged balance by partner wallet and currency\r\n    /// @param wallet The wallet of the concerned partner\r\n    /// @param currencyCt The address of the concerned currency contract (address(0) == ETH)\r\n    /// @param currencyId The ID of the concerned currency (0 for ETH and ERC20)\r\n    /// return The staged balance\r\n    function stagedBalanceByWallet(address wallet, address currencyCt, uint256 currencyId)\r\n    public\r\n    view\r\n    returns (int256)\r\n    {\r\n        // Implicitly require that partner wallet is registered\r\n        return _stagedBalanceByIndex(indexByWallet(wallet) - 1, currencyCt, currencyId);\r\n    }\r\n\r\n    /// @notice Get the number of partners\r\n    /// @return The number of partners\r\n    function partnersCount()\r\n    public\r\n    view\r\n    returns (uint256)\r\n    {\r\n        return partners.length;\r\n    }\r\n\r\n    /// @notice Register a partner by name\r\n    /// @param name The name of the concerned partner\r\n    /// @param fee The partner's fee fraction\r\n    /// @param wallet The partner's wallet\r\n    /// @param partnerCanUpdate Indicator of whether partner can update fee and wallet\r\n    /// @param operatorCanUpdate Indicator of whether operator can update fee and wallet\r\n    function registerByName(string name, uint256 fee, address wallet,\r\n        bool partnerCanUpdate, bool operatorCanUpdate)\r\n    public\r\n    onlyOperator\r\n    {\r\n        // Require not empty name string\r\n        require(bytes(name).length > 0);\r\n\r\n        // Hash name\r\n        bytes32 nameHash = hashName(name);\r\n\r\n        // Register partner\r\n        _registerPartnerByNameHash(nameHash, fee, wallet, partnerCanUpdate, operatorCanUpdate);\r\n\r\n        // Emit event\r\n        emit RegisterPartnerByNameEvent(name, fee, wallet);\r\n    }\r\n\r\n    /// @notice Register a partner by name hash\r\n    /// @param nameHash The hashed name of the concerned partner\r\n    /// @param fee The partner's fee fraction\r\n    /// @param wallet The partner's wallet\r\n    /// @param partnerCanUpdate Indicator of whether partner can update fee and wallet\r\n    /// @param operatorCanUpdate Indicator of whether operator can update fee and wallet\r\n    function registerByNameHash(bytes32 nameHash, uint256 fee, address wallet,\r\n        bool partnerCanUpdate, bool operatorCanUpdate)\r\n    public\r\n    onlyOperator\r\n    {\r\n        // Register partner\r\n        _registerPartnerByNameHash(nameHash, fee, wallet, partnerCanUpdate, operatorCanUpdate);\r\n\r\n        // Emit event\r\n        emit RegisterPartnerByNameHashEvent(nameHash, fee, wallet);\r\n    }\r\n\r\n    /// @notice Gets the 1-based index of partner by its name\r\n    /// @dev Reverts if name does not correspond to registered partner\r\n    /// @return Index of partner by given name\r\n    function indexByNameHash(bytes32 nameHash)\r\n    public\r\n    view\r\n    returns (uint256)\r\n    {\r\n        uint256 index = _indexByNameHash[nameHash];\r\n        require(0 < index);\r\n        return index;\r\n    }\r\n\r\n    /// @notice Gets the 1-based index of partner by its name\r\n    /// @dev Reverts if name does not correspond to registered partner\r\n    /// @return Index of partner by given name\r\n    function indexByName(string name)\r\n    public\r\n    view\r\n    returns (uint256)\r\n    {\r\n        return indexByNameHash(hashName(name));\r\n    }\r\n\r\n    /// @notice Gets the 1-based index of partner by its wallet\r\n    /// @dev Reverts if wallet does not correspond to registered partner\r\n    /// @return Index of partner by given wallet\r\n    function indexByWallet(address wallet)\r\n    public\r\n    view\r\n    returns (uint256)\r\n    {\r\n        uint256 index = _indexByWallet[wallet];\r\n        require(0 < index);\r\n        return index;\r\n    }\r\n\r\n    /// @notice Gauge whether a partner by the given name is registered\r\n    /// @param name The name of the concerned partner\r\n    /// @return true if partner is registered, else false\r\n    function isRegisteredByName(string name)\r\n    public\r\n    view\r\n    returns (bool)\r\n    {\r\n        return (0 < _indexByNameHash[hashName(name)]);\r\n    }\r\n\r\n    /// @notice Gauge whether a partner by the given name hash is registered\r\n    /// @param nameHash The hashed name of the concerned partner\r\n    /// @return true if partner is registered, else false\r\n    function isRegisteredByNameHash(bytes32 nameHash)\r\n    public\r\n    view\r\n    returns (bool)\r\n    {\r\n        return (0 < _indexByNameHash[nameHash]);\r\n    }\r\n\r\n    /// @notice Gauge whether a partner by the given wallet is registered\r\n    /// @param wallet The wallet of the concerned partner\r\n    /// @return true if partner is registered, else false\r\n    function isRegisteredByWallet(address wallet)\r\n    public\r\n    view\r\n    returns (bool)\r\n    {\r\n        return (0 < _indexByWallet[wallet]);\r\n    }\r\n\r\n    /// @notice Get the partner fee fraction by the given partner index\r\n    /// @param index The index of the concerned partner\r\n    /// @return The fee fraction\r\n    function feeByIndex(uint256 index)\r\n    public\r\n    view\r\n    returns (uint256)\r\n    {\r\n        // Require partner index is one of registered partner\r\n        require(0 < index && index <= partners.length);\r\n\r\n        return _partnerFeeByIndex(index - 1);\r\n    }\r\n\r\n    /// @notice Get the partner fee fraction by the given partner name\r\n    /// @param name The name of the concerned partner\r\n    /// @return The fee fraction\r\n    function feeByName(string name)\r\n    public\r\n    view\r\n    returns (uint256)\r\n    {\r\n        // Get fee, implicitly requiring that partner name is registered\r\n        return _partnerFeeByIndex(indexByName(name) - 1);\r\n    }\r\n\r\n    /// @notice Get the partner fee fraction by the given partner name hash\r\n    /// @param nameHash The hashed name of the concerned partner\r\n    /// @return The fee fraction\r\n    function feeByNameHash(bytes32 nameHash)\r\n    public\r\n    view\r\n    returns (uint256)\r\n    {\r\n        // Get fee, implicitly requiring that partner name hash is registered\r\n        return _partnerFeeByIndex(indexByNameHash(nameHash) - 1);\r\n    }\r\n\r\n    /// @notice Get the partner fee fraction by the given partner wallet\r\n    /// @param wallet The wallet of the concerned partner\r\n    /// @return The fee fraction\r\n    function feeByWallet(address wallet)\r\n    public\r\n    view\r\n    returns (uint256)\r\n    {\r\n        // Get fee, implicitly requiring that partner wallet is registered\r\n        return _partnerFeeByIndex(indexByWallet(wallet) - 1);\r\n    }\r\n\r\n    /// @notice Set the partner fee fraction by the given partner index\r\n    /// @param index The index of the concerned partner\r\n    /// @param newFee The partner's fee fraction\r\n    function setFeeByIndex(uint256 index, uint256 newFee)\r\n    public\r\n    {\r\n        // Require partner index is one of registered partner\r\n        require(0 < index && index <= partners.length);\r\n\r\n        // Update fee\r\n        uint256 oldFee = _setPartnerFeeByIndex(index - 1, newFee);\r\n\r\n        // Emit event\r\n        emit SetFeeByIndexEvent(index, oldFee, newFee);\r\n    }\r\n\r\n    /// @notice Set the partner fee fraction by the given partner name\r\n    /// @param name The name of the concerned partner\r\n    /// @param newFee The partner's fee fraction\r\n    function setFeeByName(string name, uint256 newFee)\r\n    public\r\n    {\r\n        // Update fee, implicitly requiring that partner name is registered\r\n        uint256 oldFee = _setPartnerFeeByIndex(indexByName(name) - 1, newFee);\r\n\r\n        // Emit event\r\n        emit SetFeeByNameEvent(name, oldFee, newFee);\r\n    }\r\n\r\n    /// @notice Set the partner fee fraction by the given partner name hash\r\n    /// @param nameHash The hashed name of the concerned partner\r\n    /// @param newFee The partner's fee fraction\r\n    function setFeeByNameHash(bytes32 nameHash, uint256 newFee)\r\n    public\r\n    {\r\n        // Update fee, implicitly requiring that partner name hash is registered\r\n        uint256 oldFee = _setPartnerFeeByIndex(indexByNameHash(nameHash) - 1, newFee);\r\n\r\n        // Emit event\r\n        emit SetFeeByNameHashEvent(nameHash, oldFee, newFee);\r\n    }\r\n\r\n    /// @notice Set the partner fee fraction by the given partner wallet\r\n    /// @param wallet The wallet of the concerned partner\r\n    /// @param newFee The partner's fee fraction\r\n    function setFeeByWallet(address wallet, uint256 newFee)\r\n    public\r\n    {\r\n        // Update fee, implicitly requiring that partner wallet is registered\r\n        uint256 oldFee = _setPartnerFeeByIndex(indexByWallet(wallet) - 1, newFee);\r\n\r\n        // Emit event\r\n        emit SetFeeByWalletEvent(wallet, oldFee, newFee);\r\n    }\r\n\r\n    /// @notice Get the partner wallet by the given partner index\r\n    /// @param index The index of the concerned partner\r\n    /// @return The wallet\r\n    function walletByIndex(uint256 index)\r\n    public\r\n    view\r\n    returns (address)\r\n    {\r\n        // Require partner index is one of registered partner\r\n        require(0 < index && index <= partners.length);\r\n\r\n        return partners[index - 1].wallet;\r\n    }\r\n\r\n    /// @notice Get the partner wallet by the given partner name\r\n    /// @param name The name of the concerned partner\r\n    /// @return The wallet\r\n    function walletByName(string name)\r\n    public\r\n    view\r\n    returns (address)\r\n    {\r\n        // Get wallet, implicitly requiring that partner name is registered\r\n        return partners[indexByName(name) - 1].wallet;\r\n    }\r\n\r\n    /// @notice Get the partner wallet by the given partner name hash\r\n    /// @param nameHash The hashed name of the concerned partner\r\n    /// @return The wallet\r\n    function walletByNameHash(bytes32 nameHash)\r\n    public\r\n    view\r\n    returns (address)\r\n    {\r\n        // Get wallet, implicitly requiring that partner name hash is registered\r\n        return partners[indexByNameHash(nameHash) - 1].wallet;\r\n    }\r\n\r\n    /// @notice Set the partner wallet by the given partner index\r\n    /// @param index The index of the concerned partner\r\n    /// @return newWallet The partner's wallet\r\n    function setWalletByIndex(uint256 index, address newWallet)\r\n    public\r\n    {\r\n        // Require partner index is one of registered partner\r\n        require(0 < index && index <= partners.length);\r\n\r\n        // Update wallet\r\n        address oldWallet = _setPartnerWalletByIndex(index - 1, newWallet);\r\n\r\n        // Emit event\r\n        emit SetPartnerWalletByIndexEvent(index, oldWallet, newWallet);\r\n    }\r\n\r\n    /// @notice Set the partner wallet by the given partner name\r\n    /// @param name The name of the concerned partner\r\n    /// @return newWallet The partner's wallet\r\n    function setWalletByName(string name, address newWallet)\r\n    public\r\n    {\r\n        // Update wallet\r\n        address oldWallet = _setPartnerWalletByIndex(indexByName(name) - 1, newWallet);\r\n\r\n        // Emit event\r\n        emit SetPartnerWalletByNameEvent(name, oldWallet, newWallet);\r\n    }\r\n\r\n    /// @notice Set the partner wallet by the given partner name hash\r\n    /// @param nameHash The hashed name of the concerned partner\r\n    /// @return newWallet The partner's wallet\r\n    function setWalletByNameHash(bytes32 nameHash, address newWallet)\r\n    public\r\n    {\r\n        // Update wallet\r\n        address oldWallet = _setPartnerWalletByIndex(indexByNameHash(nameHash) - 1, newWallet);\r\n\r\n        // Emit event\r\n        emit SetPartnerWalletByNameHashEvent(nameHash, oldWallet, newWallet);\r\n    }\r\n\r\n    /// @notice Set the new partner wallet by the given old partner wallet\r\n    /// @param oldWallet The old wallet of the concerned partner\r\n    /// @return newWallet The partner's new wallet\r\n    function setWalletByWallet(address oldWallet, address newWallet)\r\n    public\r\n    {\r\n        // Update wallet\r\n        _setPartnerWalletByIndex(indexByWallet(oldWallet) - 1, newWallet);\r\n\r\n        // Emit event\r\n        emit SetPartnerWalletByWalletEvent(oldWallet, newWallet);\r\n    }\r\n\r\n    /// @notice Stage the amount for subsequent withdrawal\r\n    /// @param amount The concerned amount to stage\r\n    /// @param currencyCt The address of the concerned currency contract (address(0) == ETH)\r\n    /// @param currencyId The ID of the concerned currency (0 for ETH and ERC20)\r\n    function stage(int256 amount, address currencyCt, uint256 currencyId)\r\n    public\r\n    {\r\n        // Get index, implicitly requiring that msg.sender is wallet of registered partner\r\n        uint256 index = indexByWallet(msg.sender);\r\n\r\n        // Require positive amount\r\n        require(amount.isPositiveInt256());\r\n\r\n        // Clamp amount to move\r\n        amount = amount.clampMax(partners[index - 1].active.get(currencyCt, currencyId));\r\n\r\n        partners[index - 1].active.sub(amount, currencyCt, currencyId);\r\n        partners[index - 1].staged.add(amount, currencyCt, currencyId);\r\n\r\n        partners[index - 1].txHistory.addDeposit(amount, currencyCt, currencyId);\r\n\r\n        // Add to full deposit history\r\n        partners[index - 1].fullBalanceHistory.push(\r\n            FullBalanceHistory(\r\n                partners[index - 1].txHistory.depositsCount() - 1,\r\n                partners[index - 1].active.get(currencyCt, currencyId),\r\n                block.number\r\n            )\r\n        );\r\n\r\n        // Emit event\r\n        emit StageEvent(msg.sender, amount, currencyCt, currencyId);\r\n    }\r\n\r\n    /// @notice Withdraw the given amount from staged balance\r\n    /// @param amount The concerned amount to withdraw\r\n    /// @param currencyCt The address of the concerned currency contract (address(0) == ETH)\r\n    /// @param currencyId The ID of the concerned currency (0 for ETH and ERC20)\r\n    /// @param standard The standard of the token (\"\" for default registered, \"ERC20\", \"ERC721\")\r\n    function withdraw(int256 amount, address currencyCt, uint256 currencyId, string standard)\r\n    public\r\n    {\r\n        // Get index, implicitly requiring that msg.sender is wallet of registered partner\r\n        uint256 index = indexByWallet(msg.sender);\r\n\r\n        // Require positive amount\r\n        require(amount.isPositiveInt256());\r\n\r\n        // Clamp amount to move\r\n        amount = amount.clampMax(partners[index - 1].staged.get(currencyCt, currencyId));\r\n\r\n        partners[index - 1].staged.sub(amount, currencyCt, currencyId);\r\n\r\n        // Execute transfer\r\n        if (address(0) == currencyCt && 0 == currencyId)\r\n            msg.sender.transfer(uint256(amount));\r\n\r\n        else {\r\n            TransferController controller = transferController(currencyCt, standard);\r\n            require(\r\n                address(controller).delegatecall(\r\n                    controller.getDispatchSignature(), this, msg.sender, uint256(amount), currencyCt, currencyId\r\n                )\r\n            );\r\n        }\r\n\r\n        // Emit event\r\n        emit WithdrawEvent(msg.sender, amount, currencyCt, currencyId);\r\n    }\r\n\r\n    //\r\n    // Private functions\r\n    // -----------------------------------------------------------------------------------------------------------------\r\n    /// @dev index is 0-based\r\n    function _receiveEthersTo(uint256 index, int256 amount)\r\n    private\r\n    {\r\n        // Require that index is within bounds\r\n        require(index < partners.length);\r\n\r\n        // Add to active\r\n        partners[index].active.add(amount, address(0), 0);\r\n        partners[index].txHistory.addDeposit(amount, address(0), 0);\r\n\r\n        // Add to full deposit history\r\n        partners[index].fullBalanceHistory.push(\r\n            FullBalanceHistory(\r\n                partners[index].txHistory.depositsCount() - 1,\r\n                partners[index].active.get(address(0), 0),\r\n                block.number\r\n            )\r\n        );\r\n\r\n        // Emit event\r\n        emit ReceiveEvent(msg.sender, amount, address(0), 0);\r\n    }\r\n\r\n    /// @dev index is 0-based\r\n    function _receiveTokensTo(uint256 index, int256 amount, address currencyCt,\r\n        uint256 currencyId, string standard)\r\n    private\r\n    {\r\n        // Require that index is within bounds\r\n        require(index < partners.length);\r\n\r\n        require(amount.isNonZeroPositiveInt256());\r\n\r\n        // Execute transfer\r\n        TransferController controller = transferController(currencyCt, standard);\r\n        require(\r\n            address(controller).delegatecall(\r\n                controller.getReceiveSignature(), msg.sender, this, uint256(amount), currencyCt, currencyId\r\n            )\r\n        );\r\n\r\n        // Add to active\r\n        partners[index].active.add(amount, currencyCt, currencyId);\r\n        partners[index].txHistory.addDeposit(amount, currencyCt, currencyId);\r\n\r\n        // Add to full deposit history\r\n        partners[index].fullBalanceHistory.push(\r\n            FullBalanceHistory(\r\n                partners[index].txHistory.depositsCount() - 1,\r\n                partners[index].active.get(currencyCt, currencyId),\r\n                block.number\r\n            )\r\n        );\r\n\r\n        // Emit event\r\n        emit ReceiveEvent(msg.sender, amount, currencyCt, currencyId);\r\n    }\r\n\r\n    /// @dev partnerIndex is 0-based\r\n    function _depositByIndices(uint256 partnerIndex, uint256 depositIndex)\r\n    private\r\n    view\r\n    returns (int256 balance, uint256 blockNumber, address currencyCt, uint256 currencyId)\r\n    {\r\n        require(depositIndex < partners[partnerIndex].fullBalanceHistory.length);\r\n\r\n        FullBalanceHistory storage entry = partners[partnerIndex].fullBalanceHistory[depositIndex];\r\n        (,, currencyCt, currencyId) = partners[partnerIndex].txHistory.deposit(entry.listIndex);\r\n\r\n        balance = entry.balance;\r\n        blockNumber = entry.blockNumber;\r\n    }\r\n\r\n    /// @dev index is 0-based\r\n    function _depositsCountByIndex(uint256 index)\r\n    private\r\n    view\r\n    returns (uint256)\r\n    {\r\n        return partners[index].fullBalanceHistory.length;\r\n    }\r\n\r\n    /// @dev index is 0-based\r\n    function _activeBalanceByIndex(uint256 index, address currencyCt, uint256 currencyId)\r\n    private\r\n    view\r\n    returns (int256)\r\n    {\r\n        return partners[index].active.get(currencyCt, currencyId);\r\n    }\r\n\r\n    /// @dev index is 0-based\r\n    function _stagedBalanceByIndex(uint256 index, address currencyCt, uint256 currencyId)\r\n    private\r\n    view\r\n    returns (int256)\r\n    {\r\n        return partners[index].staged.get(currencyCt, currencyId);\r\n    }\r\n\r\n    function _registerPartnerByNameHash(bytes32 nameHash, uint256 fee, address wallet,\r\n        bool partnerCanUpdate, bool operatorCanUpdate)\r\n    private\r\n    {\r\n        // Require that the name is not previously registered\r\n        require(0 == _indexByNameHash[nameHash]);\r\n\r\n        // Require possibility to update\r\n        require(partnerCanUpdate || operatorCanUpdate);\r\n\r\n        // Add new partner\r\n        partners.length++;\r\n\r\n        // Reference by 1-based index\r\n        uint256 index = partners.length;\r\n\r\n        // Update partner map\r\n        partners[index - 1].nameHash = nameHash;\r\n        partners[index - 1].fee = fee;\r\n        partners[index - 1].wallet = wallet;\r\n        partners[index - 1].partnerCanUpdate = partnerCanUpdate;\r\n        partners[index - 1].operatorCanUpdate = operatorCanUpdate;\r\n        partners[index - 1].index = index;\r\n\r\n        // Update name hash to index map\r\n        _indexByNameHash[nameHash] = index;\r\n\r\n        // Update wallet to index map\r\n        _indexByWallet[wallet] = index;\r\n    }\r\n\r\n    /// @dev index is 0-based\r\n    function _setPartnerFeeByIndex(uint256 index, uint256 fee)\r\n    private\r\n    returns (uint256)\r\n    {\r\n        uint256 oldFee = partners[index].fee;\r\n\r\n        // If operator tries to change verify that operator has access\r\n        if (isOperator())\r\n            require(partners[index].operatorCanUpdate);\r\n\r\n        else {\r\n            // Require that msg.sender is partner\r\n            require(msg.sender == partners[index].wallet);\r\n\r\n            // If partner tries to change verify that partner has access\r\n            require(partners[index].partnerCanUpdate);\r\n        }\r\n\r\n        // Update stored fee\r\n        partners[index].fee = fee;\r\n\r\n        return oldFee;\r\n    }\r\n\r\n    // @dev index is 0-based\r\n    function _setPartnerWalletByIndex(uint256 index, address newWallet)\r\n    private\r\n    returns (address)\r\n    {\r\n        address oldWallet = partners[index].wallet;\r\n\r\n        // If address has not been set operator is the only allowed to change it\r\n        if (oldWallet == address(0))\r\n            require(isOperator());\r\n\r\n        // Else if operator tries to change verify that operator has access\r\n        else if (isOperator())\r\n            require(partners[index].operatorCanUpdate);\r\n\r\n        else {\r\n            // Require that msg.sender is partner\r\n            require(msg.sender == oldWallet);\r\n\r\n            // If partner tries to change verify that partner has access\r\n            require(partners[index].partnerCanUpdate);\r\n\r\n            // Require that new wallet is not zero-address if it can not be changed by operator\r\n            require(partners[index].operatorCanUpdate || newWallet != address(0));\r\n        }\r\n\r\n        // Update stored wallet\r\n        partners[index].wallet = newWallet;\r\n\r\n        // Update address to tag map\r\n        if (oldWallet != address(0))\r\n            _indexByWallet[oldWallet] = 0;\r\n        if (newWallet != address(0))\r\n            _indexByWallet[newWallet] = index;\r\n\r\n        return oldWallet;\r\n    }\r\n\r\n    // @dev index is 0-based\r\n    function _partnerFeeByIndex(uint256 index)\r\n    private\r\n    view\r\n    returns (uint256)\r\n    {\r\n        return partners[index].fee;\r\n    }\r\n}\r\n\r\ncontract RevenueFund is Ownable, AccrualBeneficiary, AccrualBenefactor, TransferControllerManageable {\r\n    using FungibleBalanceLib for FungibleBalanceLib.Balance;\r\n    using TxHistoryLib for TxHistoryLib.TxHistory;\r\n    using SafeMathIntLib for int256;\r\n    using SafeMathUintLib for uint256;\r\n    using CurrenciesLib for CurrenciesLib.Currencies;\r\n\r\n    //\r\n    // Variables\r\n    // -----------------------------------------------------------------------------------------------------------------\r\n    FungibleBalanceLib.Balance periodAccrual;\r\n    CurrenciesLib.Currencies periodCurrencies;\r\n\r\n    FungibleBalanceLib.Balance aggregateAccrual;\r\n    CurrenciesLib.Currencies aggregateCurrencies;\r\n\r\n    TxHistoryLib.TxHistory private txHistory;\r\n\r\n    //\r\n    // Events\r\n    // -----------------------------------------------------------------------------------------------------------------\r\n    event ReceiveEvent(address from, int256 amount, address currencyCt, uint256 currencyId);\r\n    event CloseAccrualPeriodEvent();\r\n    event RegisterServiceEvent(address service);\r\n    event DeregisterServiceEvent(address service);\r\n\r\n    //\r\n    // Constructor\r\n    // -----------------------------------------------------------------------------------------------------------------\r\n    constructor(address deployer) Ownable(deployer) public {\r\n    }\r\n\r\n    //\r\n    // Functions\r\n    // -----------------------------------------------------------------------------------------------------------------\r\n    /// @notice Fallback function that deposits ethers\r\n    function() public payable {\r\n        receiveEthersTo(msg.sender, \"\");\r\n    }\r\n\r\n    /// @notice Receive ethers to\r\n    /// @param wallet The concerned wallet address\r\n    function receiveEthersTo(address wallet, string)\r\n    public\r\n    payable\r\n    {\r\n        int256 amount = SafeMathIntLib.toNonZeroInt256(msg.value);\r\n\r\n        // Add to balances\r\n        periodAccrual.add(amount, address(0), 0);\r\n        aggregateAccrual.add(amount, address(0), 0);\r\n\r\n        // Add currency to stores of currencies\r\n        periodCurrencies.add(address(0), 0);\r\n        aggregateCurrencies.add(address(0), 0);\r\n\r\n        // Add to transaction history\r\n        txHistory.addDeposit(amount, address(0), 0);\r\n\r\n        // Emit event\r\n        emit ReceiveEvent(wallet, amount, address(0), 0);\r\n    }\r\n\r\n    /// @notice Receive tokens\r\n    /// @param amount The concerned amount\r\n    /// @param currencyCt The address of the concerned currency contract (address(0) == ETH)\r\n    /// @param currencyId The ID of the concerned currency (0 for ETH and ERC20)\r\n    /// @param standard The standard of token (\"ERC20\", \"ERC721\")\r\n    function receiveTokens(string balanceType, int256 amount, address currencyCt,\r\n        uint256 currencyId, string standard)\r\n    public\r\n    {\r\n        receiveTokensTo(msg.sender, balanceType, amount, currencyCt, currencyId, standard);\r\n    }\r\n\r\n    /// @notice Receive tokens to\r\n    /// @param wallet The address of the concerned wallet\r\n    /// @param amount The concerned amount\r\n    /// @param currencyCt The address of the concerned currency contract (address(0) == ETH)\r\n    /// @param currencyId The ID of the concerned currency (0 for ETH and ERC20)\r\n    /// @param standard The standard of token (\"ERC20\", \"ERC721\")\r\n    function receiveTokensTo(address wallet, string, int256 amount,\r\n        address currencyCt, uint256 currencyId, string standard)\r\n    public\r\n    {\r\n        require(amount.isNonZeroPositiveInt256());\r\n\r\n        // Execute transfer\r\n        TransferController controller = transferController(currencyCt, standard);\r\n        require(\r\n            address(controller).delegatecall(\r\n                controller.getReceiveSignature(), msg.sender, this, uint256(amount), currencyCt, currencyId\r\n            )\r\n        );\r\n\r\n        // Add to balances\r\n        periodAccrual.add(amount, currencyCt, currencyId);\r\n        aggregateAccrual.add(amount, currencyCt, currencyId);\r\n\r\n        // Add currency to stores of currencies\r\n        periodCurrencies.add(currencyCt, currencyId);\r\n        aggregateCurrencies.add(currencyCt, currencyId);\r\n\r\n        // Add to transaction history\r\n        txHistory.addDeposit(amount, currencyCt, currencyId);\r\n\r\n        // Emit event\r\n        emit ReceiveEvent(wallet, amount, currencyCt, currencyId);\r\n    }\r\n\r\n    /// @notice Get the period accrual balance of the given currency\r\n    /// @param currencyCt The address of the concerned currency contract (address(0) == ETH)\r\n    /// @param currencyId The ID of the concerned currency (0 for ETH and ERC20)\r\n    /// @return The current period's accrual balance\r\n    function periodAccrualBalance(address currencyCt, uint256 currencyId)\r\n    public\r\n    view\r\n    returns (int256)\r\n    {\r\n        return periodAccrual.get(currencyCt, currencyId);\r\n    }\r\n\r\n    /// @notice Get the aggregate accrual balance of the given currency, including contribution from the\r\n    /// current accrual period\r\n    /// @param currencyCt The address of the concerned currency contract (address(0) == ETH)\r\n    /// @param currencyId The ID of the concerned currency (0 for ETH and ERC20)\r\n    /// @return The aggregate accrual balance\r\n    function aggregateAccrualBalance(address currencyCt, uint256 currencyId)\r\n    public\r\n    view\r\n    returns (int256)\r\n    {\r\n        return aggregateAccrual.get(currencyCt, currencyId);\r\n    }\r\n\r\n    /// @notice Get the count of currencies recorded in the accrual period\r\n    /// @return The number of currencies in the current accrual period\r\n    function periodCurrenciesCount()\r\n    public\r\n    view\r\n    returns (uint256)\r\n    {\r\n        return periodCurrencies.count();\r\n    }\r\n\r\n    /// @notice Get the currencies with indices in the given range that have been recorded in the current accrual period\r\n    /// @param low The lower currency index\r\n    /// @param up The upper currency index\r\n    /// @return The currencies of the given index range in the current accrual period\r\n    function periodCurrenciesByIndices(uint256 low, uint256 up)\r\n    public\r\n    view\r\n    returns (MonetaryTypesLib.Currency[])\r\n    {\r\n        return periodCurrencies.getByIndices(low, up);\r\n    }\r\n\r\n    /// @notice Get the count of currencies ever recorded\r\n    /// @return The number of currencies ever recorded\r\n    function aggregateCurrenciesCount()\r\n    public\r\n    view\r\n    returns (uint256)\r\n    {\r\n        return aggregateCurrencies.count();\r\n    }\r\n\r\n    /// @notice Get the currencies with indices in the given range that have ever been recorded\r\n    /// @param low The lower currency index\r\n    /// @param up The upper currency index\r\n    /// @return The currencies of the given index range ever recorded\r\n    function aggregateCurrenciesByIndices(uint256 low, uint256 up)\r\n    public\r\n    view\r\n    returns (MonetaryTypesLib.Currency[])\r\n    {\r\n        return aggregateCurrencies.getByIndices(low, up);\r\n    }\r\n\r\n    /// @notice Get the count of deposits\r\n    /// @return The count of deposits\r\n    function depositsCount()\r\n    public\r\n    view\r\n    returns (uint256)\r\n    {\r\n        return txHistory.depositsCount();\r\n    }\r\n\r\n    /// @notice Get the deposit at the given index\r\n    /// @return The deposit at the given index\r\n    function deposit(uint index)\r\n    public\r\n    view\r\n    returns (int256 amount, uint256 blockNumber, address currencyCt, uint256 currencyId)\r\n    {\r\n        return txHistory.deposit(index);\r\n    }\r\n\r\n    /// @notice Close the current accrual period of the given currencies\r\n    /// @param currencies The concerned currencies\r\n    function closeAccrualPeriod(MonetaryTypesLib.Currency[] currencies)\r\n    public\r\n    onlyOperator\r\n    {\r\n        require(ConstantsLib.PARTS_PER() == totalBeneficiaryFraction);\r\n\r\n        // Execute transfer\r\n        for (uint256 i = 0; i < currencies.length; i++) {\r\n            MonetaryTypesLib.Currency memory currency = currencies[i];\r\n\r\n            int256 remaining = periodAccrual.get(currency.ct, currency.id);\r\n\r\n            if (0 >= remaining)\r\n                continue;\r\n\r\n            for (uint256 j = 0; j < beneficiaries.length; j++) {\r\n                address beneficiaryAddress = beneficiaries[j];\r\n\r\n                if (beneficiaryFraction(beneficiaryAddress) > 0) {\r\n                    int256 transferable = periodAccrual.get(currency.ct, currency.id)\r\n                    .mul(beneficiaryFraction(beneficiaryAddress))\r\n                    .div(ConstantsLib.PARTS_PER());\r\n\r\n                    if (transferable > remaining)\r\n                        transferable = remaining;\r\n\r\n                    if (transferable > 0) {\r\n                        // Transfer ETH to the beneficiary\r\n                        if (currency.ct == address(0))\r\n                            AccrualBeneficiary(beneficiaryAddress).receiveEthersTo.value(uint256(transferable))(address(0), \"\");\r\n\r\n                        // Transfer token to the beneficiary\r\n                        else {\r\n                            TransferController controller = transferController(currency.ct, \"\");\r\n                            require(\r\n                                address(controller).delegatecall(\r\n                                    controller.getApproveSignature(), beneficiaryAddress, uint256(transferable), currency.ct, currency.id\r\n                                )\r\n                            );\r\n\r\n                            AccrualBeneficiary(beneficiaryAddress).receiveTokensTo(address(0), \"\", transferable, currency.ct, currency.id, \"\");\r\n                        }\r\n\r\n                        remaining = remaining.sub(transferable);\r\n                    }\r\n                }\r\n            }\r\n\r\n            // Roll over remaining to next accrual period\r\n            periodAccrual.set(remaining, currency.ct, currency.id);\r\n        }\r\n\r\n        // Close accrual period of accrual beneficiaries\r\n        for (j = 0; j < beneficiaries.length; j++) {\r\n            beneficiaryAddress = beneficiaries[j];\r\n\r\n            // Require that beneficiary fraction is strictly positive\r\n            if (0 >= beneficiaryFraction(beneficiaryAddress))\r\n                continue;\r\n\r\n            // Close accrual period\r\n            AccrualBeneficiary(beneficiaryAddress).closeAccrualPeriod(currencies);\r\n        }\r\n\r\n        // Emit event\r\n        emit CloseAccrualPeriodEvent();\r\n    }\r\n}\r\n\r\ncontract TransferControllerManager is Ownable {\r\n    //\r\n    // Constants\r\n    // -----------------------------------------------------------------------------------------------------------------\r\n    struct CurrencyInfo {\r\n        bytes32 standard;\r\n        bool blacklisted;\r\n    }\r\n\r\n    //\r\n    // Variables\r\n    // -----------------------------------------------------------------------------------------------------------------\r\n    mapping(bytes32 => address) public registeredTransferControllers;\r\n    mapping(address => CurrencyInfo) public registeredCurrencies;\r\n\r\n    //\r\n    // Events\r\n    // -----------------------------------------------------------------------------------------------------------------\r\n    event RegisterTransferControllerEvent(string standard, address controller);\r\n    event ReassociateTransferControllerEvent(string oldStandard, string newStandard, address controller);\r\n\r\n    event RegisterCurrencyEvent(address currencyCt, string standard);\r\n    event DeregisterCurrencyEvent(address currencyCt);\r\n    event BlacklistCurrencyEvent(address currencyCt);\r\n    event WhitelistCurrencyEvent(address currencyCt);\r\n\r\n    //\r\n    // Constructor\r\n    // -----------------------------------------------------------------------------------------------------------------\r\n    constructor(address deployer) Ownable(deployer) public {\r\n    }\r\n\r\n    //\r\n    // Functions\r\n    // -----------------------------------------------------------------------------------------------------------------\r\n    function registerTransferController(string standard, address controller)\r\n    external\r\n    onlyDeployer\r\n    notNullAddress(controller)\r\n    {\r\n        require(bytes(standard).length > 0);\r\n        bytes32 standardHash = keccak256(abi.encodePacked(standard));\r\n\r\n        require(registeredTransferControllers[standardHash] == address(0));\r\n\r\n        registeredTransferControllers[standardHash] = controller;\r\n\r\n        // Emit event\r\n        emit RegisterTransferControllerEvent(standard, controller);\r\n    }\r\n\r\n    function reassociateTransferController(string oldStandard, string newStandard, address controller)\r\n    external\r\n    onlyDeployer\r\n    notNullAddress(controller)\r\n    {\r\n        require(bytes(newStandard).length > 0);\r\n        bytes32 oldStandardHash = keccak256(abi.encodePacked(oldStandard));\r\n        bytes32 newStandardHash = keccak256(abi.encodePacked(newStandard));\r\n\r\n        require(registeredTransferControllers[oldStandardHash] != address(0));\r\n        require(registeredTransferControllers[newStandardHash] == address(0));\r\n\r\n        registeredTransferControllers[newStandardHash] = registeredTransferControllers[oldStandardHash];\r\n        registeredTransferControllers[oldStandardHash] = address(0);\r\n\r\n        // Emit event\r\n        emit ReassociateTransferControllerEvent(oldStandard, newStandard, controller);\r\n    }\r\n\r\n    function registerCurrency(address currencyCt, string standard)\r\n    external\r\n    onlyOperator\r\n    notNullAddress(currencyCt)\r\n    {\r\n        require(bytes(standard).length > 0);\r\n        bytes32 standardHash = keccak256(abi.encodePacked(standard));\r\n\r\n        require(registeredCurrencies[currencyCt].standard == bytes32(0));\r\n\r\n        registeredCurrencies[currencyCt].standard = standardHash;\r\n\r\n        // Emit event\r\n        emit RegisterCurrencyEvent(currencyCt, standard);\r\n    }\r\n\r\n    function deregisterCurrency(address currencyCt)\r\n    external\r\n    onlyOperator\r\n    {\r\n        require(registeredCurrencies[currencyCt].standard != 0);\r\n\r\n        registeredCurrencies[currencyCt].standard = bytes32(0);\r\n        registeredCurrencies[currencyCt].blacklisted = false;\r\n\r\n        // Emit event\r\n        emit DeregisterCurrencyEvent(currencyCt);\r\n    }\r\n\r\n    function blacklistCurrency(address currencyCt)\r\n    external\r\n    onlyOperator\r\n    {\r\n        require(registeredCurrencies[currencyCt].standard != bytes32(0));\r\n\r\n        registeredCurrencies[currencyCt].blacklisted = true;\r\n\r\n        // Emit event\r\n        emit BlacklistCurrencyEvent(currencyCt);\r\n    }\r\n\r\n    function whitelistCurrency(address currencyCt)\r\n    external\r\n    onlyOperator\r\n    {\r\n        require(registeredCurrencies[currencyCt].standard != bytes32(0));\r\n\r\n        registeredCurrencies[currencyCt].blacklisted = false;\r\n\r\n        // Emit event\r\n        emit WhitelistCurrencyEvent(currencyCt);\r\n    }\r\n\r\n    /**\r\n    @notice The provided standard takes priority over assigned interface to currency\r\n    */\r\n    function transferController(address currencyCt, string standard)\r\n    public\r\n    view\r\n    returns (TransferController)\r\n    {\r\n        if (bytes(standard).length > 0) {\r\n            bytes32 standardHash = keccak256(abi.encodePacked(standard));\r\n\r\n            require(registeredTransferControllers[standardHash] != address(0));\r\n            return TransferController(registeredTransferControllers[standardHash]);\r\n        }\r\n\r\n        require(registeredCurrencies[currencyCt].standard != bytes32(0));\r\n        require(!registeredCurrencies[currencyCt].blacklisted);\r\n\r\n        address controllerAddress = registeredTransferControllers[registeredCurrencies[currencyCt].standard];\r\n        require(controllerAddress != address(0));\r\n\r\n        return TransferController(controllerAddress);\r\n    }\r\n}\r\n\r\nlibrary TxHistoryLib {\r\n    //\r\n    // Structures\r\n    // -----------------------------------------------------------------------------------------------------------------\r\n    struct AssetEntry {\r\n        int256 amount;\r\n        uint256 blockNumber;\r\n        address currencyCt;      //0 for ethers\r\n        uint256 currencyId;\r\n    }\r\n\r\n    struct TxHistory {\r\n        AssetEntry[] deposits;\r\n        mapping(address => mapping(uint256 => AssetEntry[])) currencyDeposits;\r\n\r\n        AssetEntry[] withdrawals;\r\n        mapping(address => mapping(uint256 => AssetEntry[])) currencyWithdrawals;\r\n    }\r\n\r\n    //\r\n    // Functions\r\n    // -----------------------------------------------------------------------------------------------------------------\r\n    function addDeposit(TxHistory storage self, int256 amount, address currencyCt, uint256 currencyId)\r\n    internal\r\n    {\r\n        AssetEntry memory deposit = AssetEntry(amount, block.number, currencyCt, currencyId);\r\n        self.deposits.push(deposit);\r\n        self.currencyDeposits[currencyCt][currencyId].push(deposit);\r\n    }\r\n\r\n    function addWithdrawal(TxHistory storage self, int256 amount, address currencyCt, uint256 currencyId)\r\n    internal\r\n    {\r\n        AssetEntry memory withdrawal = AssetEntry(amount, block.number, currencyCt, currencyId);\r\n        self.withdrawals.push(withdrawal);\r\n        self.currencyWithdrawals[currencyCt][currencyId].push(withdrawal);\r\n    }\r\n\r\n    //----\r\n\r\n    function deposit(TxHistory storage self, uint index)\r\n    internal\r\n    view\r\n    returns (int256 amount, uint256 blockNumber, address currencyCt, uint256 currencyId)\r\n    {\r\n        require(index < self.deposits.length);\r\n\r\n        amount = self.deposits[index].amount;\r\n        blockNumber = self.deposits[index].blockNumber;\r\n        currencyCt = self.deposits[index].currencyCt;\r\n        currencyId = self.deposits[index].currencyId;\r\n    }\r\n\r\n    function depositsCount(TxHistory storage self)\r\n    internal\r\n    view\r\n    returns (uint256)\r\n    {\r\n        return self.deposits.length;\r\n    }\r\n\r\n    function currencyDeposit(TxHistory storage self, address currencyCt, uint256 currencyId, uint index)\r\n    internal\r\n    view\r\n    returns (int256 amount, uint256 blockNumber)\r\n    {\r\n        require(index < self.currencyDeposits[currencyCt][currencyId].length);\r\n\r\n        amount = self.currencyDeposits[currencyCt][currencyId][index].amount;\r\n        blockNumber = self.currencyDeposits[currencyCt][currencyId][index].blockNumber;\r\n    }\r\n\r\n    function currencyDepositsCount(TxHistory storage self, address currencyCt, uint256 currencyId)\r\n    internal\r\n    view\r\n    returns (uint256)\r\n    {\r\n        return self.currencyDeposits[currencyCt][currencyId].length;\r\n    }\r\n\r\n    //----\r\n\r\n    function withdrawal(TxHistory storage self, uint index)\r\n    internal\r\n    view\r\n    returns (int256 amount, uint256 blockNumber, address currencyCt, uint256 currencyId)\r\n    {\r\n        require(index < self.withdrawals.length);\r\n\r\n        amount = self.withdrawals[index].amount;\r\n        blockNumber = self.withdrawals[index].blockNumber;\r\n        currencyCt = self.withdrawals[index].currencyCt;\r\n        currencyId = self.withdrawals[index].currencyId;\r\n    }\r\n\r\n    function withdrawalsCount(TxHistory storage self)\r\n    internal\r\n    view\r\n    returns (uint256)\r\n    {\r\n        return self.withdrawals.length;\r\n    }\r\n\r\n    function currencyWithdrawal(TxHistory storage self, address currencyCt, uint256 currencyId, uint index)\r\n    internal\r\n    view\r\n    returns (int256 amount, uint256 blockNumber)\r\n    {\r\n        require(index < self.currencyWithdrawals[currencyCt][currencyId].length);\r\n\r\n        amount = self.currencyWithdrawals[currencyCt][currencyId][index].amount;\r\n        blockNumber = self.currencyWithdrawals[currencyCt][currencyId][index].blockNumber;\r\n    }\r\n\r\n    function currencyWithdrawalsCount(TxHistory storage self, address currencyCt, uint256 currencyId)\r\n    internal\r\n    view\r\n    returns (uint256)\r\n    {\r\n        return self.currencyWithdrawals[currencyCt][currencyId].length;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"settlements\",\"outputs\":[{\"name\":\"settledKind\",\"type\":\"string\"},{\"name\":\"settledHash\",\"type\":\"bytes32\"},{\"components\":[{\"name\":\"nonce\",\"type\":\"uint256\"},{\"name\":\"wallet\",\"type\":\"address\"},{\"name\":\"done\",\"type\":\"bool\"}],\"name\":\"origin\",\"type\":\"tuple\"},{\"components\":[{\"name\":\"nonce\",\"type\":\"uint256\"},{\"name\":\"wallet\",\"type\":\"address\"},{\"name\":\"done\",\"type\":\"bool\"}],\"name\":\"target\",\"type\":\"tuple\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"SET_MAX_NONCE_ACTION\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"SET_FEE_TOTAL_ACTION\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"wallet\",\"type\":\"address\"},{\"components\":[{\"name\":\"ct\",\"type\":\"address\"},{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"currency\",\"type\":\"tuple\"},{\"name\":\"maxNonce\",\"type\":\"uint256\"}],\"name\":\"setMaxNonceByWalletAndCurrency\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"service\",\"type\":\"address\"}],\"name\":\"isRegisteredActiveService\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"triggerSelfDestruction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"service\",\"type\":\"address\"},{\"name\":\"action\",\"type\":\"string\"}],\"name\":\"enableServiceAction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"service\",\"type\":\"address\"}],\"name\":\"isRegisteredService\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"selfDestructionDisabled\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"wallet\",\"type\":\"address\"},{\"components\":[{\"name\":\"ct\",\"type\":\"address\"},{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"currency\",\"type\":\"tuple\"}],\"name\":\"maxNonceByWalletAndCurrency\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"service\",\"type\":\"address\"},{\"name\":\"action\",\"type\":\"string\"}],\"name\":\"disableServiceAction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"serviceActivationTimeout\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"SET_MAX_DRIIP_NONCE_ACTION\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"totalFeesMap\",\"outputs\":[{\"name\":\"nonce\",\"type\":\"uint256\"},{\"name\":\"amount\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"destructor\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_maxDriipNonce\",\"type\":\"uint256\"}],\"name\":\"setMaxDriipNonce\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"service\",\"type\":\"address\"}],\"name\":\"deregisterService\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"operator\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"updateMaxDriipNonceFromCommunityVote\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"service\",\"type\":\"address\"},{\"name\":\"action\",\"type\":\"string\"}],\"name\":\"isEnabledServiceAction\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"freezeCommunityVote\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"wallet\",\"type\":\"address\"},{\"name\":\"nonce\",\"type\":\"uint256\"},{\"name\":\"settlementRole\",\"type\":\"uint8\"}],\"name\":\"isSettlementRoleDone\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"wallet\",\"type\":\"address\"},{\"name\":\"beneficiary\",\"type\":\"address\"},{\"name\":\"destination\",\"type\":\"address\"},{\"components\":[{\"name\":\"ct\",\"type\":\"address\"},{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"currency\",\"type\":\"tuple\"}],\"name\":\"totalFee\",\"outputs\":[{\"components\":[{\"name\":\"nonce\",\"type\":\"uint256\"},{\"name\":\"amount\",\"type\":\"int256\"}],\"name\":\"\",\"type\":\"tuple\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"SET_SETTLEMENT_ROLE_DONE_ACTION\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"disableSelfDestruction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"wallet\",\"type\":\"address\"},{\"name\":\"beneficiary\",\"type\":\"address\"},{\"name\":\"destination\",\"type\":\"address\"},{\"components\":[{\"name\":\"ct\",\"type\":\"address\"},{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"currency\",\"type\":\"tuple\"},{\"components\":[{\"name\":\"nonce\",\"type\":\"uint256\"},{\"name\":\"amount\",\"type\":\"int256\"}],\"name\":\"_totalFee\",\"type\":\"tuple\"}],\"name\":\"setTotalFee\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"timeoutInSeconds\",\"type\":\"uint256\"}],\"name\":\"setServiceActivationTimeout\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"settledKind\",\"type\":\"string\"},{\"name\":\"settledHash\",\"type\":\"bytes32\"},{\"name\":\"originWallet\",\"type\":\"address\"},{\"name\":\"originNonce\",\"type\":\"uint256\"},{\"name\":\"targetWallet\",\"type\":\"address\"},{\"name\":\"targetNonce\",\"type\":\"uint256\"}],\"name\":\"initSettlement\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxDriipNonce\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"settlementsCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"service\",\"type\":\"address\"}],\"name\":\"registerServiceDeferred\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"communityVoteFrozen\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"walletSettlementIndices\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newDeployer\",\"type\":\"address\"}],\"name\":\"setDeployer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOperator\",\"type\":\"address\"}],\"name\":\"setOperator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"communityVote\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"wallet\",\"type\":\"address\"},{\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"settlementByWalletAndIndex\",\"outputs\":[{\"components\":[{\"name\":\"settledKind\",\"type\":\"string\"},{\"name\":\"settledHash\",\"type\":\"bytes32\"},{\"components\":[{\"name\":\"nonce\",\"type\":\"uint256\"},{\"name\":\"wallet\",\"type\":\"address\"},{\"name\":\"done\",\"type\":\"bool\"}],\"name\":\"origin\",\"type\":\"tuple\"},{\"components\":[{\"name\":\"nonce\",\"type\":\"uint256\"},{\"name\":\"wallet\",\"type\":\"address\"},{\"name\":\"done\",\"type\":\"bool\"}],\"name\":\"target\",\"type\":\"tuple\"}],\"name\":\"\",\"type\":\"tuple\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"wallet\",\"type\":\"address\"},{\"name\":\"nonce\",\"type\":\"uint256\"}],\"name\":\"settlementByWalletAndNonce\",\"outputs\":[{\"components\":[{\"name\":\"settledKind\",\"type\":\"string\"},{\"name\":\"settledHash\",\"type\":\"bytes32\"},{\"components\":[{\"name\":\"nonce\",\"type\":\"uint256\"},{\"name\":\"wallet\",\"type\":\"address\"},{\"name\":\"done\",\"type\":\"bool\"}],\"name\":\"origin\",\"type\":\"tuple\"},{\"components\":[{\"name\":\"nonce\",\"type\":\"uint256\"},{\"name\":\"wallet\",\"type\":\"address\"},{\"name\":\"done\",\"type\":\"bool\"}],\"name\":\"target\",\"type\":\"tuple\"}],\"name\":\"\",\"type\":\"tuple\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"deployer\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"walletNonceSettlementIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"INIT_SETTLEMENT_ACTION\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newCommunityVote\",\"type\":\"address\"}],\"name\":\"setCommunityVote\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"wallet\",\"type\":\"address\"},{\"name\":\"nonce\",\"type\":\"uint256\"},{\"name\":\"settlementRole\",\"type\":\"uint8\"},{\"name\":\"done\",\"type\":\"bool\"}],\"name\":\"setSettlementRoleDone\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"walletCurrencyMaxNonce\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"settlementsCountByWallet\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"service\",\"type\":\"address\"}],\"name\":\"registerService\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"deployer\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"components\":[{\"name\":\"settledKind\",\"type\":\"string\"},{\"name\":\"settledHash\",\"type\":\"bytes32\"},{\"components\":[{\"name\":\"nonce\",\"type\":\"uint256\"},{\"name\":\"wallet\",\"type\":\"address\"},{\"name\":\"done\",\"type\":\"bool\"}],\"name\":\"origin\",\"type\":\"tuple\"},{\"components\":[{\"name\":\"nonce\",\"type\":\"uint256\"},{\"name\":\"wallet\",\"type\":\"address\"},{\"name\":\"done\",\"type\":\"bool\"}],\"name\":\"target\",\"type\":\"tuple\"}],\"indexed\":false,\"name\":\"settlement\",\"type\":\"tuple\"}],\"name\":\"InitSettlementEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"wallet\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"nonce\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"settlementRole\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"done\",\"type\":\"bool\"}],\"name\":\"SetSettlementRoleDoneEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"wallet\",\"type\":\"address\"},{\"components\":[{\"name\":\"ct\",\"type\":\"address\"},{\"name\":\"id\",\"type\":\"uint256\"}],\"indexed\":false,\"name\":\"currency\",\"type\":\"tuple\"},{\"indexed\":false,\"name\":\"maxNonce\",\"type\":\"uint256\"}],\"name\":\"SetMaxNonceByWalletAndCurrencyEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"maxDriipNonce\",\"type\":\"uint256\"}],\"name\":\"SetMaxDriipNonceEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"maxDriipNonce\",\"type\":\"uint256\"}],\"name\":\"UpdateMaxDriipNonceFromCommunityVoteEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"wallet\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"destination\",\"type\":\"address\"},{\"components\":[{\"name\":\"ct\",\"type\":\"address\"},{\"name\":\"id\",\"type\":\"uint256\"}],\"indexed\":false,\"name\":\"currency\",\"type\":\"tuple\"},{\"components\":[{\"name\":\"nonce\",\"type\":\"uint256\"},{\"name\":\"amount\",\"type\":\"int256\"}],\"indexed\":false,\"name\":\"totalFee\",\"type\":\"tuple\"}],\"name\":\"SetTotalFeeEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldCommunityVote\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newCommunityVote\",\"type\":\"address\"}],\"name\":\"SetCommunityVoteEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"FreezeCommunityVoteEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"timeoutInSeconds\",\"type\":\"uint256\"}],\"name\":\"ServiceActivationTimeoutEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"service\",\"type\":\"address\"}],\"name\":\"RegisterServiceEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"service\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"timeout\",\"type\":\"uint256\"}],\"name\":\"RegisterServiceDeferredEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"service\",\"type\":\"address\"}],\"name\":\"DeregisterServiceEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"service\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"action\",\"type\":\"string\"}],\"name\":\"EnableServiceActionEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"service\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"action\",\"type\":\"string\"}],\"name\":\"DisableServiceActionEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldDeployer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newDeployer\",\"type\":\"address\"}],\"name\":\"SetDeployerEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldOperator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newOperator\",\"type\":\"address\"}],\"name\":\"SetOperatorEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"SelfDestructionDisabledEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"TriggerSelfDestructionEvent\",\"type\":\"event\"}]","ContractName":"DriipSettlementState","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"0","ConstructorArguments":"000000000000000000000000f05179bac3d1fbef58a2fcd7ad0f769840027cc6","Library":"","SwarmSource":"bzzr://cf20968eff338a3e11ae9076c00522cd6470af9fd24fdc82a7f6d5d26846ddbd"}]}