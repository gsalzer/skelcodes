{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n/*\r\n *     ______   _                                 ______                 _          \r\n *====(_____ \\=| |===============================(____  \\===============| |=============*\r\n *     _____) )| |  _____  _   _  _____   ____    ____)  )  ___    ___  | |  _\r\n *    |  ____/ | | (____ || | | || ___ | / ___)  |  __  (  / _ \\  / _ \\ | |_/ )\r\n *    | |      | | / ___ || |_| || ____|| |      | |__)  )| |_| || |_| ||  _ (\r\n *====|_|=======\\_)\\_____|=\\__  ||_____)|_|======|______/==\\___/==\\___/=|_|=\\_)=========*\r\n *                        (____/\r\n * ╔═╗┌─┐┌┐┌┌┬┐┬─┐┌─┐┌─┐┌┬┐  ╔═╗┌─┐┌┬┐┌─┐ ┌──────────┐                       \r\n * ║  │ ││││ │ ├┬┘├─┤│   │   ║  │ │ ││├┤  │ Inventor │                      \r\n * ╚═╝└─┘┘└┘ ┴ ┴└─┴ ┴└─┘ ┴   ╚═╝└─┘─┴┘└─┘ └──────────┘    \r\n */\r\n\r\ninterface JIincForwarderInterface {\r\n    function deposit() external payable returns(bool);\r\n    function status() external view returns(address, address, bool);\r\n    function startMigration(address _newCorpBank) external returns(bool);\r\n    function cancelMigration() external returns(bool);\r\n    function finishMigration() external returns(bool);\r\n    function setup(address _firstCorpBank) external;\r\n}\r\n\r\ninterface PlayerBookReceiverInterface {\r\n    function receivePlayerInfo(uint256 _pID, address _addr, bytes32 _name, uint256 _laff) external;\r\n    function receivePlayerNameList(uint256 _pID, bytes32 _name) external;\r\n}\r\n\r\ninterface TeamJustInterface {\r\n    function requiredSignatures() external view returns(uint256);\r\n    function requiredDevSignatures() external view returns(uint256);\r\n    function adminCount() external view returns(uint256);\r\n    function devCount() external view returns(uint256);\r\n    function adminName(address _who) external view returns(bytes32);\r\n    function isAdmin(address _who) external view returns(bool);\r\n    function isDev(address _who) external view returns(bool);\r\n}\r\n\r\ncontract PlayerBook {\r\n    using NameFilter for string;\r\n    using SafeMath for uint256;\r\n    \r\n    JIincForwarderInterface constant private Jekyll_Island_Inc = JIincForwarderInterface(0x80526AA5f9A2905809Aa8E1b861eca7895982c70);\r\n    TeamJustInterface constant private TeamJust = TeamJustInterface(0x4f3c021b75E5bdff3199b2ea7a883d7CE7307dA0);\r\n    \r\n    MSFun.Data private msData;\r\n    function multiSigDev(bytes32 _whatFunction) private returns (bool) {return(MSFun.multiSig(msData, TeamJust.requiredDevSignatures(), _whatFunction));}\r\n    function deleteProposal(bytes32 _whatFunction) private {MSFun.deleteProposal(msData, _whatFunction);}\r\n    function deleteAnyProposal(bytes32 _whatFunction) onlyDevs() public {MSFun.deleteProposal(msData, _whatFunction);}\r\n    function checkData(bytes32 _whatFunction) onlyDevs() public view returns(bytes32, uint256) {return(MSFun.checkMsgData(msData, _whatFunction), MSFun.checkCount(msData, _whatFunction));}\r\n    function checkSignersByAddress(bytes32 _whatFunction, uint256 _signerA, uint256 _signerB, uint256 _signerC) onlyDevs() public view returns(address, address, address) {return(MSFun.checkSigner(msData, _whatFunction, _signerA), MSFun.checkSigner(msData, _whatFunction, _signerB), MSFun.checkSigner(msData, _whatFunction, _signerC));}\r\n    function checkSignersByName(bytes32 _whatFunction, uint256 _signerA, uint256 _signerB, uint256 _signerC) onlyDevs() public view returns(bytes32, bytes32, bytes32) {return(TeamJust.adminName(MSFun.checkSigner(msData, _whatFunction, _signerA)), TeamJust.adminName(MSFun.checkSigner(msData, _whatFunction, _signerB)), TeamJust.adminName(MSFun.checkSigner(msData, _whatFunction, _signerC)));}\r\n//==============================================================================\r\n//     _| _ _|_ _    _ _ _|_    _   .\r\n//    (_|(_| | (_|  _\\(/_ | |_||_)  .\r\n//=============================|================================================    \r\n    uint256 public registrationFee_ = 10 finney;            // price to register a name\r\n    mapping(uint256 => PlayerBookReceiverInterface) public games_;  // mapping of our game interfaces for sending your account info to games\r\n    mapping(address => bytes32) public gameNames_;          // lookup a games name\r\n    mapping(address => uint256) public gameIDs_;            // lokup a games ID\r\n    uint256 public gID_;        // total number of games\r\n    uint256 public pID_;        // total number of players\r\n    mapping (address => uint256) public pIDxAddr_;          // (addr => pID) returns player id by address\r\n    mapping (bytes32 => uint256) public pIDxName_;          // (name => pID) returns player id by name\r\n    mapping (uint256 => Player) public plyr_;               // (pID => data) player data\r\n    mapping (uint256 => mapping (bytes32 => bool)) public plyrNames_; // (pID => name => bool) list of names a player owns.  (used so you can change your display name amoungst any name you own)\r\n    mapping (uint256 => mapping (uint256 => bytes32)) public plyrNameList_; // (pID => nameNum => name) list of names a player owns\r\n    struct Player {\r\n        address addr;\r\n        bytes32 name;\r\n        uint256 laff;\r\n        uint256 names;\r\n    }\r\n//==============================================================================\r\n//     _ _  _  __|_ _    __|_ _  _  .\r\n//    (_(_)| |_\\ | | |_|(_ | (_)|   .  (initial data setup upon contract deploy)\r\n//==============================================================================    \r\n    constructor()\r\n        public\r\n    {\r\n        // premine the dev names (sorry not sorry)\r\n            // No keys are purchased with this method, it's simply locking our addresses,\r\n            // PID's and names for referral codes.\r\n        plyr_[1].addr = 0xAE81cCb079B49f9149E54235802ad22a83A6e0dF;\r\n        plyr_[1].name = \"justo\";\r\n        plyr_[1].names = 1;\r\n        pIDxAddr_[0xAE81cCb079B49f9149E54235802ad22a83A6e0dF] = 1;\r\n        pIDxName_[\"justo\"] = 1;\r\n        plyrNames_[1][\"justo\"] = true;\r\n        plyrNameList_[1][1] = \"justo\";\r\n        \r\n        plyr_[2].addr = 0x79Afe7a736bf84Bf5E61FE0480A59395F162a317;\r\n        plyr_[2].name = \"mantso\";\r\n        plyr_[2].names = 1;\r\n        pIDxAddr_[0x79Afe7a736bf84Bf5E61FE0480A59395F162a317] = 2;\r\n        pIDxName_[\"mantso\"] = 2;\r\n        plyrNames_[2][\"mantso\"] = true;\r\n        plyrNameList_[2][1] = \"mantso\";\r\n        \r\n        plyr_[3].addr = 0xAE81cCb079B49f9149E54235802ad22a83A6e0dF;\r\n        plyr_[3].name = \"sumpunk\";\r\n        plyr_[3].names = 1;\r\n        pIDxAddr_[0xAE81cCb079B49f9149E54235802ad22a83A6e0dF] = 3;\r\n        pIDxName_[\"sumpunk\"] = 3;\r\n        plyrNames_[3][\"sumpunk\"] = true;\r\n        plyrNameList_[3][1] = \"sumpunk\";\r\n        \r\n        plyr_[4].addr = 0x79Afe7a736bf84Bf5E61FE0480A59395F162a317;\r\n        plyr_[4].name = \"inventor\";\r\n        plyr_[4].names = 1;\r\n        pIDxAddr_[0x79Afe7a736bf84Bf5E61FE0480A59395F162a317] = 4;\r\n        pIDxName_[\"inventor\"] = 4;\r\n        plyrNames_[4][\"inventor\"] = true;\r\n        plyrNameList_[4][1] = \"inventor\";\r\n        \r\n        pID_ = 4;\r\n    }\r\n//==============================================================================\r\n//     _ _  _  _|. |`. _  _ _  .\r\n//    | | |(_)(_||~|~|(/_| _\\  .  (these are safety checks)\r\n//==============================================================================    \r\n    /**\r\n     * @dev prevents contracts from interacting with fomo3d \r\n     */\r\n    modifier isHuman() {\r\n        address _addr = msg.sender;\r\n        uint256 _codeLength;\r\n        \r\n        assembly {_codeLength := extcodesize(_addr)}\r\n        require(_codeLength == 0, \"sorry humans only\");\r\n        _;\r\n    }\r\n    \r\n    modifier onlyDevs() \r\n    {\r\n        require(TeamJust.isDev(msg.sender) == true, \"msg sender is not a dev\");\r\n        _;\r\n    }\r\n    \r\n    modifier isRegisteredGame()\r\n    {\r\n        require(gameIDs_[msg.sender] != 0);\r\n        _;\r\n    }\r\n//==============================================================================\r\n//     _    _  _ _|_ _  .\r\n//    (/_\\/(/_| | | _\\  .\r\n//==============================================================================    \r\n    // fired whenever a player registers a name\r\n    event onNewName\r\n    (\r\n        uint256 indexed playerID,\r\n        address indexed playerAddress,\r\n        bytes32 indexed playerName,\r\n        bool isNewPlayer,\r\n        uint256 affiliateID,\r\n        address affiliateAddress,\r\n        bytes32 affiliateName,\r\n        uint256 amountPaid,\r\n        uint256 timeStamp\r\n    );\r\n//==============================================================================\r\n//     _  _ _|__|_ _  _ _  .\r\n//    (_|(/_ |  | (/_| _\\  . (for UI & viewing things on etherscan)\r\n//=====_|=======================================================================\r\n    function checkIfNameValid(string _nameStr)\r\n        public\r\n        view\r\n        returns(bool)\r\n    {\r\n        bytes32 _name = _nameStr.nameFilter();\r\n        if (pIDxName_[_name] == 0)\r\n            return (true);\r\n        else \r\n            return (false);\r\n    }\r\n//==============================================================================\r\n//     _    |_ |. _   |`    _  __|_. _  _  _  .\r\n//    |_)|_||_)||(_  ~|~|_|| |(_ | |(_)| |_\\  .  (use these to interact with contract)\r\n//====|=========================================================================    \r\n    /**\r\n     * @dev registers a name.  UI will always display the last name you registered.\r\n     * but you will still own all previously registered names to use as affiliate \r\n     * links.\r\n     * - must pay a registration fee.\r\n     * - name must be unique\r\n     * - names will be converted to lowercase\r\n     * - name cannot start or end with a space \r\n     * - cannot have more than 1 space in a row\r\n     * - cannot be only numbers\r\n     * - cannot start with 0x \r\n     * - name must be at least 1 char\r\n     * - max length of 32 characters long\r\n     * - allowed characters: a-z, 0-9, and space\r\n     * -functionhash- 0x921dec21 (using ID for affiliate)\r\n     * -functionhash- 0x3ddd4698 (using address for affiliate)\r\n     * -functionhash- 0x685ffd83 (using name for affiliate)\r\n     * @param _nameString players desired name\r\n     * @param _affCode affiliate ID, address, or name of who refered you\r\n     * @param _all set to true if you want this to push your info to all games \r\n     * (this might cost a lot of gas)\r\n     */\r\n    function registerNameXID(string _nameString, uint256 _affCode, bool _all)\r\n        isHuman()\r\n        public\r\n        payable \r\n    {\r\n        // make sure name fees paid\r\n        require (msg.value >= registrationFee_, \"umm.....  you have to pay the name fee\");\r\n        \r\n        // filter name + condition checks\r\n        bytes32 _name = NameFilter.nameFilter(_nameString);\r\n        \r\n        // set up address \r\n        address _addr = msg.sender;\r\n        \r\n        // set up our tx event data and determine if player is new or not\r\n        bool _isNewPlayer = determinePID(_addr);\r\n        \r\n        // fetch player id\r\n        uint256 _pID = pIDxAddr_[_addr];\r\n        \r\n        // manage affiliate residuals\r\n        // if no affiliate code was given, no new affiliate code was given, or the \r\n        // player tried to use their own pID as an affiliate code, lolz\r\n        if (_affCode != 0 && _affCode != plyr_[_pID].laff && _affCode != _pID) \r\n        {\r\n            // update last affiliate \r\n            plyr_[_pID].laff = _affCode;\r\n        } else if (_affCode == _pID) {\r\n            _affCode = 0;\r\n        }\r\n        \r\n        // register name \r\n        registerNameCore(_pID, _addr, _affCode, _name, _isNewPlayer, _all);\r\n    }\r\n    \r\n    function registerNameXaddr(string _nameString, address _affCode, bool _all)\r\n        isHuman()\r\n        public\r\n        payable \r\n    {\r\n        // make sure name fees paid\r\n        require (msg.value >= registrationFee_, \"umm.....  you have to pay the name fee\");\r\n        \r\n        // filter name + condition checks\r\n        bytes32 _name = NameFilter.nameFilter(_nameString);\r\n        \r\n        // set up address \r\n        address _addr = msg.sender;\r\n        \r\n        // set up our tx event data and determine if player is new or not\r\n        bool _isNewPlayer = determinePID(_addr);\r\n        \r\n        // fetch player id\r\n        uint256 _pID = pIDxAddr_[_addr];\r\n        \r\n        // manage affiliate residuals\r\n        // if no affiliate code was given or player tried to use their own, lolz\r\n        uint256 _affID;\r\n        if (_affCode != address(0) && _affCode != _addr)\r\n        {\r\n            // get affiliate ID from aff Code \r\n            _affID = pIDxAddr_[_affCode];\r\n            \r\n            // if affID is not the same as previously stored \r\n            if (_affID != plyr_[_pID].laff)\r\n            {\r\n                // update last affiliate\r\n                plyr_[_pID].laff = _affID;\r\n            }\r\n        }\r\n        \r\n        // register name \r\n        registerNameCore(_pID, _addr, _affID, _name, _isNewPlayer, _all);\r\n    }\r\n    \r\n    function registerNameXname(string _nameString, bytes32 _affCode, bool _all)\r\n        isHuman()\r\n        public\r\n        payable \r\n    {\r\n        // make sure name fees paid\r\n        require (msg.value >= registrationFee_, \"umm.....  you have to pay the name fee\");\r\n        \r\n        // filter name + condition checks\r\n        bytes32 _name = NameFilter.nameFilter(_nameString);\r\n        \r\n        // set up address \r\n        address _addr = msg.sender;\r\n        \r\n        // set up our tx event data and determine if player is new or not\r\n        bool _isNewPlayer = determinePID(_addr);\r\n        \r\n        // fetch player id\r\n        uint256 _pID = pIDxAddr_[_addr];\r\n        \r\n        // manage affiliate residuals\r\n        // if no affiliate code was given or player tried to use their own, lolz\r\n        uint256 _affID;\r\n        if (_affCode != \"\" && _affCode != _name)\r\n        {\r\n            // get affiliate ID from aff Code \r\n            _affID = pIDxName_[_affCode];\r\n            \r\n            // if affID is not the same as previously stored \r\n            if (_affID != plyr_[_pID].laff)\r\n            {\r\n                // update last affiliate\r\n                plyr_[_pID].laff = _affID;\r\n            }\r\n        }\r\n        \r\n        // register name \r\n        registerNameCore(_pID, _addr, _affID, _name, _isNewPlayer, _all);\r\n    }\r\n    \r\n    /**\r\n     * @dev players, if you registered a profile, before a game was released, or\r\n     * set the all bool to false when you registered, use this function to push\r\n     * your profile to a single game.  also, if you've  updated your name, you\r\n     * can use this to push your name to games of your choosing.\r\n     * -functionhash- 0x81c5b206\r\n     * @param _gameID game id \r\n     */\r\n    function addMeToGame(uint256 _gameID)\r\n        isHuman()\r\n        public\r\n    {\r\n        require(_gameID <= gID_, \"silly player, that game doesn't exist yet\");\r\n        address _addr = msg.sender;\r\n        uint256 _pID = pIDxAddr_[_addr];\r\n        require(_pID != 0, \"hey there buddy, you dont even have an account\");\r\n        uint256 _totalNames = plyr_[_pID].names;\r\n        \r\n        // add players profile and most recent name\r\n        games_[_gameID].receivePlayerInfo(_pID, _addr, plyr_[_pID].name, plyr_[_pID].laff);\r\n        \r\n        // add list of all names\r\n        if (_totalNames > 1)\r\n            for (uint256 ii = 1; ii <= _totalNames; ii++)\r\n                games_[_gameID].receivePlayerNameList(_pID, plyrNameList_[_pID][ii]);\r\n    }\r\n    \r\n    /**\r\n     * @dev players, use this to push your player profile to all registered games.\r\n     * -functionhash- 0x0c6940ea\r\n     */\r\n    function addMeToAllGames()\r\n        isHuman()\r\n        public\r\n    {\r\n        address _addr = msg.sender;\r\n        uint256 _pID = pIDxAddr_[_addr];\r\n        require(_pID != 0, \"hey there buddy, you dont even have an account\");\r\n        uint256 _laff = plyr_[_pID].laff;\r\n        uint256 _totalNames = plyr_[_pID].names;\r\n        bytes32 _name = plyr_[_pID].name;\r\n        \r\n        for (uint256 i = 1; i <= gID_; i++)\r\n        {\r\n            games_[i].receivePlayerInfo(_pID, _addr, _name, _laff);\r\n            if (_totalNames > 1)\r\n                for (uint256 ii = 1; ii <= _totalNames; ii++)\r\n                    games_[i].receivePlayerNameList(_pID, plyrNameList_[_pID][ii]);\r\n        }\r\n                \r\n    }\r\n    \r\n    /**\r\n     * @dev players use this to change back to one of your old names.  tip, you'll\r\n     * still need to push that info to existing games.\r\n     * -functionhash- 0xb9291296\r\n     * @param _nameString the name you want to use \r\n     */\r\n    function useMyOldName(string _nameString)\r\n        isHuman()\r\n        public \r\n    {\r\n        // filter name, and get pID\r\n        bytes32 _name = _nameString.nameFilter();\r\n        uint256 _pID = pIDxAddr_[msg.sender];\r\n        \r\n        // make sure they own the name \r\n        require(plyrNames_[_pID][_name] == true, \"umm... thats not a name you own\");\r\n        \r\n        // update their current name \r\n        plyr_[_pID].name = _name;\r\n    }\r\n    \r\n//==============================================================================\r\n//     _ _  _ _   | _  _ . _  .\r\n//    (_(_)| (/_  |(_)(_||(_  . \r\n//=====================_|=======================================================    \r\n    function registerNameCore(uint256 _pID, address _addr, uint256 _affID, bytes32 _name, bool _isNewPlayer, bool _all)\r\n        private\r\n    {\r\n        // if names already has been used, require that current msg sender owns the name\r\n        if (pIDxName_[_name] != 0)\r\n            require(plyrNames_[_pID][_name] == true, \"sorry that names already taken\");\r\n        \r\n        // add name to player profile, registry, and name book\r\n        plyr_[_pID].name = _name;\r\n        pIDxName_[_name] = _pID;\r\n        if (plyrNames_[_pID][_name] == false)\r\n        {\r\n            plyrNames_[_pID][_name] = true;\r\n            plyr_[_pID].names++;\r\n            plyrNameList_[_pID][plyr_[_pID].names] = _name;\r\n        }\r\n        \r\n        // registration fee goes directly to community rewards\r\n        Jekyll_Island_Inc.deposit.value(address(this).balance)();\r\n        \r\n        // push player info to games\r\n        if (_all == true)\r\n            for (uint256 i = 1; i <= gID_; i++)\r\n                games_[i].receivePlayerInfo(_pID, _addr, _name, _affID);\r\n        \r\n        // fire event\r\n        emit onNewName(_pID, _addr, _name, _isNewPlayer, _affID, plyr_[_affID].addr, plyr_[_affID].name, msg.value, now);\r\n    }\r\n//==============================================================================\r\n//    _|_ _  _ | _  .\r\n//     | (_)(_)|_\\  .\r\n//==============================================================================    \r\n    function determinePID(address _addr)\r\n        private\r\n        returns (bool)\r\n    {\r\n        if (pIDxAddr_[_addr] == 0)\r\n        {\r\n            pID_++;\r\n            pIDxAddr_[_addr] = pID_;\r\n            plyr_[pID_].addr = _addr;\r\n            \r\n            // set the new player bool to true\r\n            return (true);\r\n        } else {\r\n            return (false);\r\n        }\r\n    }\r\n//==============================================================================\r\n//   _   _|_ _  _ _  _ |   _ _ || _  .\r\n//  (/_>< | (/_| | |(_||  (_(_|||_\\  .\r\n//==============================================================================\r\n    function getPlayerID(address _addr)\r\n        isRegisteredGame()\r\n        external\r\n        returns (uint256)\r\n    {\r\n        determinePID(_addr);\r\n        return (pIDxAddr_[_addr]);\r\n    }\r\n    function getPlayerName(uint256 _pID)\r\n        external\r\n        view\r\n        returns (bytes32)\r\n    {\r\n        return (plyr_[_pID].name);\r\n    }\r\n    function getPlayerLAff(uint256 _pID)\r\n        external\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return (plyr_[_pID].laff);\r\n    }\r\n    function getPlayerAddr(uint256 _pID)\r\n        external\r\n        view\r\n        returns (address)\r\n    {\r\n        return (plyr_[_pID].addr);\r\n    }\r\n    function getNameFee()\r\n        external\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return(registrationFee_);\r\n    }\r\n    function registerNameXIDFromDapp(address _addr, bytes32 _name, uint256 _affCode, bool _all)\r\n        isRegisteredGame()\r\n        external\r\n        payable\r\n        returns(bool, uint256)\r\n    {\r\n        // make sure name fees paid\r\n        require (msg.value >= registrationFee_, \"umm.....  you have to pay the name fee\");\r\n        \r\n        // set up our tx event data and determine if player is new or not\r\n        bool _isNewPlayer = determinePID(_addr);\r\n        \r\n        // fetch player id\r\n        uint256 _pID = pIDxAddr_[_addr];\r\n        \r\n        // manage affiliate residuals\r\n        // if no affiliate code was given, no new affiliate code was given, or the \r\n        // player tried to use their own pID as an affiliate code, lolz\r\n        uint256 _affID = _affCode;\r\n        if (_affID != 0 && _affID != plyr_[_pID].laff && _affID != _pID) \r\n        {\r\n            // update last affiliate \r\n            plyr_[_pID].laff = _affID;\r\n        } else if (_affID == _pID) {\r\n            _affID = 0;\r\n        }\r\n        \r\n        // register name \r\n        registerNameCore(_pID, _addr, _affID, _name, _isNewPlayer, _all);\r\n        \r\n        return(_isNewPlayer, _affID);\r\n    }\r\n    function registerNameXaddrFromDapp(address _addr, bytes32 _name, address _affCode, bool _all)\r\n        isRegisteredGame()\r\n        external\r\n        payable\r\n        returns(bool, uint256)\r\n    {\r\n        // make sure name fees paid\r\n        require (msg.value >= registrationFee_, \"umm.....  you have to pay the name fee\");\r\n        \r\n        // set up our tx event data and determine if player is new or not\r\n        bool _isNewPlayer = determinePID(_addr);\r\n        \r\n        // fetch player id\r\n        uint256 _pID = pIDxAddr_[_addr];\r\n        \r\n        // manage affiliate residuals\r\n        // if no affiliate code was given or player tried to use their own, lolz\r\n        uint256 _affID;\r\n        if (_affCode != address(0) && _affCode != _addr)\r\n        {\r\n            // get affiliate ID from aff Code \r\n            _affID = pIDxAddr_[_affCode];\r\n            \r\n            // if affID is not the same as previously stored \r\n            if (_affID != plyr_[_pID].laff)\r\n            {\r\n                // update last affiliate\r\n                plyr_[_pID].laff = _affID;\r\n            }\r\n        }\r\n        \r\n        // register name \r\n        registerNameCore(_pID, _addr, _affID, _name, _isNewPlayer, _all);\r\n        \r\n        return(_isNewPlayer, _affID);\r\n    }\r\n    function registerNameXnameFromDapp(address _addr, bytes32 _name, bytes32 _affCode, bool _all)\r\n        isRegisteredGame()\r\n        external\r\n        payable\r\n        returns(bool, uint256)\r\n    {\r\n        // make sure name fees paid\r\n        require (msg.value >= registrationFee_, \"umm.....  you have to pay the name fee\");\r\n        \r\n        // set up our tx event data and determine if player is new or not\r\n        bool _isNewPlayer = determinePID(_addr);\r\n        \r\n        // fetch player id\r\n        uint256 _pID = pIDxAddr_[_addr];\r\n        \r\n        // manage affiliate residuals\r\n        // if no affiliate code was given or player tried to use their own, lolz\r\n        uint256 _affID;\r\n        if (_affCode != \"\" && _affCode != _name)\r\n        {\r\n            // get affiliate ID from aff Code \r\n            _affID = pIDxName_[_affCode];\r\n            \r\n            // if affID is not the same as previously stored \r\n            if (_affID != plyr_[_pID].laff)\r\n            {\r\n                // update last affiliate\r\n                plyr_[_pID].laff = _affID;\r\n            }\r\n        }\r\n        \r\n        // register name \r\n        registerNameCore(_pID, _addr, _affID, _name, _isNewPlayer, _all);\r\n        \r\n        return(_isNewPlayer, _affID);\r\n    }\r\n    \r\n//==============================================================================\r\n//   _ _ _|_    _   .\r\n//  _\\(/_ | |_||_)  .\r\n//=============|================================================================\r\n    function addGame(address _gameAddress, string _gameNameStr)\r\n        onlyDevs()\r\n        public\r\n    {\r\n        require(gameIDs_[_gameAddress] == 0, \"derp, that games already been registered\");\r\n        \r\n        if (multiSigDev(\"addGame\") == true)\r\n        {deleteProposal(\"addGame\");\r\n            gID_++;\r\n            bytes32 _name = _gameNameStr.nameFilter();\r\n            gameIDs_[_gameAddress] = gID_;\r\n            gameNames_[_gameAddress] = _name;\r\n            games_[gID_] = PlayerBookReceiverInterface(_gameAddress);\r\n        \r\n            games_[gID_].receivePlayerInfo(1, plyr_[1].addr, plyr_[1].name, 0);\r\n            games_[gID_].receivePlayerInfo(2, plyr_[2].addr, plyr_[2].name, 0);\r\n            games_[gID_].receivePlayerInfo(3, plyr_[3].addr, plyr_[3].name, 0);\r\n            games_[gID_].receivePlayerInfo(4, plyr_[4].addr, plyr_[4].name, 0);\r\n        }\r\n    }\r\n    \r\n    function setRegistrationFee(uint256 _fee)\r\n        onlyDevs()\r\n        public\r\n    {\r\n        if (multiSigDev(\"setRegistrationFee\") == true)\r\n        {deleteProposal(\"setRegistrationFee\");\r\n            registrationFee_ = _fee;\r\n        }\r\n    }\r\n        \r\n} \r\n\r\n/**\r\n* @title -Name Filter- v0.1.9\r\n* ┌┬┐┌─┐┌─┐┌┬┐   ╦╦ ╦╔═╗╔╦╗  ┌─┐┬─┐┌─┐┌─┐┌─┐┌┐┌┌┬┐┌─┐\r\n*  │ ├┤ ├─┤│││   ║║ ║╚═╗ ║   ├─┘├┬┘├┤ └─┐├┤ │││ │ └─┐\r\n*  ┴ └─┘┴ ┴┴ ┴  ╚╝╚═╝╚═╝ ╩   ┴  ┴└─└─┘└─┘└─┘┘└┘ ┴ └─┘\r\n*                                  _____                      _____\r\n*                                 (, /     /)       /) /)    (, /      /)          /)\r\n*          ┌─┐                      /   _ (/_      // //       /  _   // _   __  _(/\r\n*          ├─┤                  ___/___(/_/(__(_/_(/_(/_   ___/__/_)_(/_(_(_/ (_(_(_\r\n*          ┴ ┴                /   /          .-/ _____   (__ /                               \r\n*                            (__ /          (_/ (, /                                      /)™ \r\n*                                                 /  __  __ __ __  _   __ __  _  _/_ _  _(/\r\n* ┌─┐┬─┐┌─┐┌┬┐┬ ┬┌─┐┌┬┐                          /__/ (_(__(_)/ (_/_)_(_)/ (_(_(_(__(/_(_(_\r\n* ├─┘├┬┘│ │ │││ ││   │                      (__ /              .-/  © Jekyll Island Inc. 2018\r\n* ┴  ┴└─└─┘─┴┘└─┘└─┘ ┴                                        (_/\r\n*              _       __    _      ____      ____  _   _    _____  ____  ___  \r\n*=============| |\\ |  / /\\  | |\\/| | |_ =====| |_  | | | |    | |  | |_  | |_)==============*\r\n*=============|_| \\| /_/--\\ |_|  | |_|__=====|_|   |_| |_|__  |_|  |_|__ |_| \\==============*\r\n*\r\n* ╔═╗┌─┐┌┐┌┌┬┐┬─┐┌─┐┌─┐┌┬┐  ╔═╗┌─┐┌┬┐┌─┐ ┌──────────┐\r\n* ║  │ ││││ │ ├┬┘├─┤│   │   ║  │ │ ││├┤  │ Inventor │\r\n* ╚═╝└─┘┘└┘ ┴ ┴└─┴ ┴└─┘ ┴   ╚═╝└─┘─┴┘└─┘ └──────────┘\r\n*/\r\nlibrary NameFilter {\r\n    \r\n    /**\r\n     * @dev filters name strings\r\n     * -converts uppercase to lower case.  \r\n     * -makes sure it does not start/end with a space\r\n     * -makes sure it does not contain multiple spaces in a row\r\n     * -cannot be only numbers\r\n     * -cannot start with 0x \r\n     * -restricts characters to A-Z, a-z, 0-9, and space.\r\n     * @return reprocessed string in bytes32 format\r\n     */\r\n    function nameFilter(string _input)\r\n        internal\r\n        pure\r\n        returns(bytes32)\r\n    {\r\n        bytes memory _temp = bytes(_input);\r\n        uint256 _length = _temp.length;\r\n        \r\n        //sorry limited to 32 characters\r\n        require (_length <= 32 && _length > 0, \"string must be between 1 and 32 characters\");\r\n        // make sure it doesnt start with or end with space\r\n        require(_temp[0] != 0x20 && _temp[_length-1] != 0x20, \"string cannot start or end with space\");\r\n        // make sure first two characters are not 0x\r\n        if (_temp[0] == 0x30)\r\n        {\r\n            require(_temp[1] != 0x78, \"string cannot start with 0x\");\r\n            require(_temp[1] != 0x58, \"string cannot start with 0X\");\r\n        }\r\n        \r\n        // create a bool to track if we have a non number character\r\n        bool _hasNonNumber;\r\n        \r\n        // convert & check\r\n        for (uint256 i = 0; i < _length; i++)\r\n        {\r\n            // if its uppercase A-Z\r\n            if (_temp[i] > 0x40 && _temp[i] < 0x5b)\r\n            {\r\n                // convert to lower case a-z\r\n                _temp[i] = byte(uint(_temp[i]) + 32);\r\n                \r\n                // we have a non number\r\n                if (_hasNonNumber == false)\r\n                    _hasNonNumber = true;\r\n            } else {\r\n                require\r\n                (\r\n                    // require character is a space\r\n                    _temp[i] == 0x20 || \r\n                    // OR lowercase a-z\r\n                    (_temp[i] > 0x60 && _temp[i] < 0x7b) ||\r\n                    // or 0-9\r\n                    (_temp[i] > 0x2f && _temp[i] < 0x3a),\r\n                    \"string contains invalid characters\"\r\n                );\r\n                // make sure theres not 2x spaces in a row\r\n                if (_temp[i] == 0x20)\r\n                    require( _temp[i+1] != 0x20, \"string cannot contain consecutive spaces\");\r\n                \r\n                // see if we have a character other than a number\r\n                if (_hasNonNumber == false && (_temp[i] < 0x30 || _temp[i] > 0x39))\r\n                    _hasNonNumber = true;    \r\n            }\r\n        }\r\n        \r\n        require(_hasNonNumber == true, \"string cannot be only numbers\");\r\n        \r\n        bytes32 _ret;\r\n        assembly {\r\n            _ret := mload(add(_temp, 32))\r\n        }\r\n        return (_ret);\r\n    }\r\n}\r\n\r\n/**\r\n * @title SafeMath v0.1.9\r\n * @dev Math operations with safety checks that throw on error\r\n * change notes:  original SafeMath library from OpenZeppelin modified by Inventor\r\n * - added sqrt\r\n * - added sq\r\n * - added pwr \r\n * - changed asserts to requires with error log outputs\r\n * - removed div, its useless\r\n */\r\nlibrary SafeMath {\r\n    \r\n    /**\r\n    * @dev Multiplies two numbers, throws on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) \r\n        internal \r\n        pure \r\n        returns (uint256 c) \r\n    {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        c = a * b;\r\n        require(c / a == b, \"SafeMath mul failed\");\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n        returns (uint256) \r\n    {\r\n        require(b <= a, \"SafeMath sub failed\");\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, throws on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n        returns (uint256 c) \r\n    {\r\n        c = a + b;\r\n        require(c >= a, \"SafeMath add failed\");\r\n        return c;\r\n    }\r\n    \r\n    /**\r\n     * @dev gives square root of given x.\r\n     */\r\n    function sqrt(uint256 x)\r\n        internal\r\n        pure\r\n        returns (uint256 y) \r\n    {\r\n        uint256 z = ((add(x,1)) / 2);\r\n        y = x;\r\n        while (z < y) \r\n        {\r\n            y = z;\r\n            z = ((add((x / z),z)) / 2);\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * @dev gives square. multiplies x by x\r\n     */\r\n    function sq(uint256 x)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return (mul(x,x));\r\n    }\r\n    \r\n    /**\r\n     * @dev x to the power of y \r\n     */\r\n    function pwr(uint256 x, uint256 y)\r\n        internal \r\n        pure \r\n        returns (uint256)\r\n    {\r\n        if (x==0)\r\n            return (0);\r\n        else if (y==0)\r\n            return (1);\r\n        else \r\n        {\r\n            uint256 z = x;\r\n            for (uint256 i=1; i < y; i++)\r\n                z = mul(z,x);\r\n            return (z);\r\n        }\r\n    }\r\n}\r\n\r\n/** @title -MSFun- v0.2.4\r\n * ┌┬┐┌─┐┌─┐┌┬┐   ╦╦ ╦╔═╗╔╦╗  ┌─┐┬─┐┌─┐┌─┐┌─┐┌┐┌┌┬┐┌─┐\r\n *  │ ├┤ ├─┤│││   ║║ ║╚═╗ ║   ├─┘├┬┘├┤ └─┐├┤ │││ │ └─┐\r\n *  ┴ └─┘┴ ┴┴ ┴  ╚╝╚═╝╚═╝ ╩   ┴  ┴└─└─┘└─┘└─┘┘└┘ ┴ └─┘\r\n *                                  _____                      _____\r\n *                                 (, /     /)       /) /)    (, /      /)          /)\r\n *          ┌─┐                      /   _ (/_      // //       /  _   // _   __  _(/\r\n *          ├─┤                  ___/___(/_/(__(_/_(/_(/_   ___/__/_)_(/_(_(_/ (_(_(_\r\n *          ┴ ┴                /   /          .-/ _____   (__ /                               \r\n *                            (__ /          (_/ (, /                                      /)™ \r\n *                                                 /  __  __ __ __  _   __ __  _  _/_ _  _(/\r\n * ┌─┐┬─┐┌─┐┌┬┐┬ ┬┌─┐┌┬┐                          /__/ (_(__(_)/ (_/_)_(_)/ (_(_(_(__(/_(_(_\r\n * ├─┘├┬┘│ │ │││ ││   │                      (__ /              .-/  © Jekyll Island Inc. 2018\r\n * ┴  ┴└─└─┘─┴┘└─┘└─┘ ┴                                        (_/\r\n *  _           _             _  _  _  _             _  _  _  _  _                                      \r\n *=(_) _     _ (_)==========_(_)(_)(_)(_)_==========(_)(_)(_)(_)(_)================================*\r\n * (_)(_)   (_)(_)         (_)          (_)         (_)       _         _    _  _  _  _                 \r\n * (_) (_)_(_) (_)         (_)_  _  _  _            (_) _  _ (_)       (_)  (_)(_)(_)(_)_               \r\n * (_)   (_)   (_)           (_)(_)(_)(_)_          (_)(_)(_)(_)       (_)  (_)        (_)              \r\n * (_)         (_)  _  _    _           (_)  _  _   (_)      (_)       (_)  (_)        (_)  _  _        \r\n *=(_)=========(_)=(_)(_)==(_)_  _  _  _(_)=(_)(_)==(_)======(_)_  _  _(_)_ (_)========(_)=(_)(_)==*\r\n * (_)         (_) (_)(_)    (_)(_)(_)(_)   (_)(_)  (_)        (_)(_)(_) (_)(_)        (_) (_)(_)\r\n *\r\n * ╔═╗┌─┐┌┐┌┌┬┐┬─┐┌─┐┌─┐┌┬┐  ╔═╗┌─┐┌┬┐┌─┐ ┌──────────┐\r\n * ║  │ ││││ │ ├┬┘├─┤│   │   ║  │ │ ││├┤  │ Inventor │\r\n * ╚═╝└─┘┘└┘ ┴ ┴└─┴ ┴└─┘ ┴   ╚═╝└─┘─┴┘└─┘ └──────────┘\r\n *  \r\n *         ┌──────────────────────────────────────────────────────────────────────┐\r\n *         │ MSFun, is an importable library that gives your contract the ability │\r\n *         │ add multiSig requirement to functions.                               │\r\n *         └──────────────────────────────────────────────────────────────────────┘\r\n *                                ┌────────────────────┐\r\n *                                │ Setup Instructions │\r\n *                                └────────────────────┘\r\n * (Step 1) import the library into your contract\r\n * \r\n *    import \"./MSFun.sol\";\r\n *\r\n * (Step 2) set up the signature data for msFun\r\n * \r\n *     MSFun.Data private msData;\r\n *                                ┌────────────────────┐\r\n *                                │ Usage Instructions │\r\n *                                └────────────────────┘\r\n * at the beginning of a function\r\n * \r\n *     function functionName() \r\n *     {\r\n *         if (MSFun.multiSig(msData, required signatures, \"functionName\") == true)\r\n *         {\r\n *             MSFun.deleteProposal(msData, \"functionName\");\r\n * \r\n *             // put function body here \r\n *         }\r\n *     }\r\n *                           ┌────────────────────────────────┐\r\n *                           │ Optional Wrappers For TeamJust │\r\n *                           └────────────────────────────────┘\r\n * multiSig wrapper function (cuts down on inputs, improves readability)\r\n * this wrapper is HIGHLY recommended\r\n * \r\n *     function multiSig(bytes32 _whatFunction) private returns (bool) {return(MSFun.multiSig(msData, TeamJust.requiredSignatures(), _whatFunction));}\r\n *     function multiSigDev(bytes32 _whatFunction) private returns (bool) {return(MSFun.multiSig(msData, TeamJust.requiredDevSignatures(), _whatFunction));}\r\n *\r\n * wrapper for delete proposal (makes code cleaner)\r\n *     \r\n *     function deleteProposal(bytes32 _whatFunction) private {MSFun.deleteProposal(msData, _whatFunction);}\r\n *                             ┌────────────────────────────┐\r\n *                             │ Utility & Vanity Functions │\r\n *                             └────────────────────────────┘\r\n * delete any proposal is highly recommended.  without it, if an admin calls a multiSig\r\n * function, with argument inputs that the other admins do not agree upon, the function\r\n * can never be executed until the undesirable arguments are approved.\r\n * \r\n *     function deleteAnyProposal(bytes32 _whatFunction) onlyDevs() public {MSFun.deleteProposal(msData, _whatFunction);}\r\n * \r\n * for viewing who has signed a proposal & proposal data\r\n *     \r\n *     function checkData(bytes32 _whatFunction) onlyAdmins() public view returns(bytes32, uint256) {return(MSFun.checkMsgData(msData, _whatFunction), MSFun.checkCount(msData, _whatFunction));}\r\n *\r\n * lets you check address of up to 3 signers (address)\r\n * \r\n *     function checkSignersByAddress(bytes32 _whatFunction, uint256 _signerA, uint256 _signerB, uint256 _signerC) onlyAdmins() public view returns(address, address, address) {return(MSFun.checkSigner(msData, _whatFunction, _signerA), MSFun.checkSigner(msData, _whatFunction, _signerB), MSFun.checkSigner(msData, _whatFunction, _signerC));}\r\n *\r\n * same as above but will return names in string format.\r\n *\r\n *     function checkSignersByName(bytes32 _whatFunction, uint256 _signerA, uint256 _signerB, uint256 _signerC) onlyAdmins() public view returns(bytes32, bytes32, bytes32) {return(TeamJust.adminName(MSFun.checkSigner(msData, _whatFunction, _signerA)), TeamJust.adminName(MSFun.checkSigner(msData, _whatFunction, _signerB)), TeamJust.adminName(MSFun.checkSigner(msData, _whatFunction, _signerC)));}\r\n *                             ┌──────────────────────────┐\r\n *                             │ Functions In Depth Guide │\r\n *                             └──────────────────────────┘\r\n * In the following examples, the Data is the proposal set for this library.  And\r\n * the bytes32 is the name of the function.\r\n *\r\n * MSFun.multiSig(Data, uint256, bytes32) - Manages creating/updating multiSig \r\n *      proposal for the function being called.  The uint256 is the required \r\n *      number of signatures needed before the multiSig will return true.  \r\n *      Upon first call, multiSig will create a proposal and store the arguments \r\n *      passed with the function call as msgData.  Any admins trying to sign the \r\n *      function call will need to send the same argument values. Once required\r\n *      number of signatures is reached this will return a bool of true.\r\n * \r\n * MSFun.deleteProposal(Data, bytes32) - once multiSig unlocks the function body,\r\n *      you will want to delete the proposal data.  This does that.\r\n *\r\n * MSFun.checkMsgData(Data, bytes32) - checks the message data for any given proposal \r\n * \r\n * MSFun.checkCount(Data, bytes32) - checks the number of admins that have signed\r\n *      the proposal \r\n * \r\n * MSFun.checkSigners(data, bytes32, uint256) - checks the address of a given signer.\r\n *      the uint256, is the log number of the signer (ie 1st signer, 2nd signer)\r\n */\r\n\r\nlibrary MSFun {\r\n    //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n    // DATA SETS\r\n    //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n    // contact data setup\r\n    struct Data \r\n    {\r\n        mapping (bytes32 => ProposalData) proposal_;\r\n    }\r\n    struct ProposalData \r\n    {\r\n        // a hash of msg.data \r\n        bytes32 msgData;\r\n        // number of signers\r\n        uint256 count;\r\n        // tracking of wither admins have signed\r\n        mapping (address => bool) admin;\r\n        // list of admins who have signed\r\n        mapping (uint256 => address) log;\r\n    }\r\n    \r\n    //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n    // MULTI SIG FUNCTIONS\r\n    //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n    function multiSig(Data storage self, uint256 _requiredSignatures, bytes32 _whatFunction)\r\n        internal\r\n        returns(bool) \r\n    {\r\n        // our proposal key will be a hash of our function name + our contracts address \r\n        // by adding our contracts address to this, we prevent anyone trying to circumvent\r\n        // the proposal's security via external calls.\r\n        bytes32 _whatProposal = whatProposal(_whatFunction);\r\n        \r\n        // this is just done to make the code more readable.  grabs the signature count\r\n        uint256 _currentCount = self.proposal_[_whatProposal].count;\r\n        \r\n        // store the address of the person sending the function call.  we use msg.sender \r\n        // here as a layer of security.  in case someone imports our contract and tries to \r\n        // circumvent function arguments.  still though, our contract that imports this\r\n        // library and calls multisig, needs to use onlyAdmin modifiers or anyone who\r\n        // calls the function will be a signer. \r\n        address _whichAdmin = msg.sender;\r\n        \r\n        // prepare our msg data.  by storing this we are able to verify that all admins\r\n        // are approving the same argument input to be executed for the function.  we hash \r\n        // it and store in bytes32 so its size is known and comparable\r\n        bytes32 _msgData = keccak256(msg.data);\r\n        \r\n        // check to see if this is a new execution of this proposal or not\r\n        if (_currentCount == 0)\r\n        {\r\n            // if it is, lets record the original signers data\r\n            self.proposal_[_whatProposal].msgData = _msgData;\r\n            \r\n            // record original senders signature\r\n            self.proposal_[_whatProposal].admin[_whichAdmin] = true;        \r\n            \r\n            // update log (used to delete records later, and easy way to view signers)\r\n            // also useful if the calling function wants to give something to a \r\n            // specific signer.  \r\n            self.proposal_[_whatProposal].log[_currentCount] = _whichAdmin;  \r\n            \r\n            // track number of signatures\r\n            self.proposal_[_whatProposal].count += 1;  \r\n            \r\n            // if we now have enough signatures to execute the function, lets\r\n            // return a bool of true.  we put this here in case the required signatures\r\n            // is set to 1.\r\n            if (self.proposal_[_whatProposal].count == _requiredSignatures) {\r\n                return(true);\r\n            }            \r\n        // if its not the first execution, lets make sure the msgData matches\r\n        } else if (self.proposal_[_whatProposal].msgData == _msgData) {\r\n            // msgData is a match\r\n            // make sure admin hasnt already signed\r\n            if (self.proposal_[_whatProposal].admin[_whichAdmin] == false) \r\n            {\r\n                // record their signature\r\n                self.proposal_[_whatProposal].admin[_whichAdmin] = true;        \r\n                \r\n                // update log (used to delete records later, and easy way to view signers)\r\n                self.proposal_[_whatProposal].log[_currentCount] = _whichAdmin;  \r\n                \r\n                // track number of signatures\r\n                self.proposal_[_whatProposal].count += 1;  \r\n            }\r\n            \r\n            // if we now have enough signatures to execute the function, lets\r\n            // return a bool of true.\r\n            // we put this here for a few reasons.  (1) in normal operation, if \r\n            // that last recorded signature got us to our required signatures.  we \r\n            // need to return bool of true.  (2) if we have a situation where the \r\n            // required number of signatures was adjusted to at or lower than our current \r\n            // signature count, by putting this here, an admin who has already signed,\r\n            // can call the function again to make it return a true bool.  but only if\r\n            // they submit the correct msg data\r\n            if (self.proposal_[_whatProposal].count == _requiredSignatures) {\r\n                return(true);\r\n            }\r\n        }\r\n    }\r\n    \r\n    \r\n    // deletes proposal signature data after successfully executing a multiSig function\r\n    function deleteProposal(Data storage self, bytes32 _whatFunction)\r\n        internal\r\n    {\r\n        //done for readability sake\r\n        bytes32 _whatProposal = whatProposal(_whatFunction);\r\n        address _whichAdmin;\r\n        \r\n        //delete the admins votes & log.   i know for loops are terrible.  but we have to do this \r\n        //for our data stored in mappings.  simply deleting the proposal itself wouldn't accomplish this.\r\n        for (uint256 i=0; i < self.proposal_[_whatProposal].count; i++) {\r\n            _whichAdmin = self.proposal_[_whatProposal].log[i];\r\n            delete self.proposal_[_whatProposal].admin[_whichAdmin];\r\n            delete self.proposal_[_whatProposal].log[i];\r\n        }\r\n        //delete the rest of the data in the record\r\n        delete self.proposal_[_whatProposal];\r\n    }\r\n    \r\n    //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n    // HELPER FUNCTIONS\r\n    //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n\r\n    function whatProposal(bytes32 _whatFunction)\r\n        private\r\n        view\r\n        returns(bytes32)\r\n    {\r\n        return(keccak256(abi.encodePacked(_whatFunction,this)));\r\n    }\r\n    \r\n    //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n    // VANITY FUNCTIONS\r\n    //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n    // returns a hashed version of msg.data sent by original signer for any given function\r\n    function checkMsgData (Data storage self, bytes32 _whatFunction)\r\n        internal\r\n        view\r\n        returns (bytes32 msg_data)\r\n    {\r\n        bytes32 _whatProposal = whatProposal(_whatFunction);\r\n        return (self.proposal_[_whatProposal].msgData);\r\n    }\r\n    \r\n    // returns number of signers for any given function\r\n    function checkCount (Data storage self, bytes32 _whatFunction)\r\n        internal\r\n        view\r\n        returns (uint256 signature_count)\r\n    {\r\n        bytes32 _whatProposal = whatProposal(_whatFunction);\r\n        return (self.proposal_[_whatProposal].count);\r\n    }\r\n    \r\n    // returns address of an admin who signed for any given function\r\n    function checkSigner (Data storage self, bytes32 _whatFunction, uint256 _signer)\r\n        internal\r\n        view\r\n        returns (address signer)\r\n    {\r\n        require(_signer > 0, \"MSFun checkSigner failed - 0 not allowed\");\r\n        bytes32 _whatProposal = whatProposal(_whatFunction);\r\n        return (self.proposal_[_whatProposal].log[_signer - 1]);\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[],\"name\":\"addMeToAllGames\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_whatFunction\",\"type\":\"bytes32\"}],\"name\":\"deleteAnyProposal\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"pIDxAddr_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"registrationFee_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getNameFee\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"plyrNames_\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"gameNames_\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"pIDxName_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_nameString\",\"type\":\"string\"},{\"name\":\"_affCode\",\"type\":\"address\"},{\"name\":\"_all\",\"type\":\"bool\"}],\"name\":\"registerNameXaddr\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_gameAddress\",\"type\":\"address\"},{\"name\":\"_gameNameStr\",\"type\":\"string\"}],\"name\":\"addGame\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pID_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_pID\",\"type\":\"uint256\"}],\"name\":\"getPlayerAddr\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_nameString\",\"type\":\"string\"},{\"name\":\"_affCode\",\"type\":\"bytes32\"},{\"name\":\"_all\",\"type\":\"bool\"}],\"name\":\"registerNameXname\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_nameStr\",\"type\":\"string\"}],\"name\":\"checkIfNameValid\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"},{\"name\":\"_name\",\"type\":\"bytes32\"},{\"name\":\"_affCode\",\"type\":\"bytes32\"},{\"name\":\"_all\",\"type\":\"bool\"}],\"name\":\"registerNameXnameFromDapp\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_whatFunction\",\"type\":\"bytes32\"},{\"name\":\"_signerA\",\"type\":\"uint256\"},{\"name\":\"_signerB\",\"type\":\"uint256\"},{\"name\":\"_signerC\",\"type\":\"uint256\"}],\"name\":\"checkSignersByAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_gameID\",\"type\":\"uint256\"}],\"name\":\"addMeToGame\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_pID\",\"type\":\"uint256\"}],\"name\":\"getPlayerName\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_nameString\",\"type\":\"string\"},{\"name\":\"_affCode\",\"type\":\"uint256\"},{\"name\":\"_all\",\"type\":\"bool\"}],\"name\":\"registerNameXID\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"plyrNameList_\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_whatFunction\",\"type\":\"bytes32\"}],\"name\":\"checkData\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"},{\"name\":\"_name\",\"type\":\"bytes32\"},{\"name\":\"_affCode\",\"type\":\"address\"},{\"name\":\"_all\",\"type\":\"bool\"}],\"name\":\"registerNameXaddrFromDapp\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_nameString\",\"type\":\"string\"}],\"name\":\"useMyOldName\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"gID_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"},{\"name\":\"_name\",\"type\":\"bytes32\"},{\"name\":\"_affCode\",\"type\":\"uint256\"},{\"name\":\"_all\",\"type\":\"bool\"}],\"name\":\"registerNameXIDFromDapp\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_fee\",\"type\":\"uint256\"}],\"name\":\"setRegistrationFee\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"games_\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"gameIDs_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"plyr_\",\"outputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"name\",\"type\":\"bytes32\"},{\"name\":\"laff\",\"type\":\"uint256\"},{\"name\":\"names\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_pID\",\"type\":\"uint256\"}],\"name\":\"getPlayerLAff\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"getPlayerID\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_whatFunction\",\"type\":\"bytes32\"},{\"name\":\"_signerA\",\"type\":\"uint256\"},{\"name\":\"_signerB\",\"type\":\"uint256\"},{\"name\":\"_signerC\",\"type\":\"uint256\"}],\"name\":\"checkSignersByName\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"},{\"name\":\"\",\"type\":\"bytes32\"},{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"playerID\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"playerAddress\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"playerName\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"isNewPlayer\",\"type\":\"bool\"},{\"indexed\":false,\"name\":\"affiliateID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"affiliateAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"affiliateName\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"amountPaid\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timeStamp\",\"type\":\"uint256\"}],\"name\":\"onNewName\",\"type\":\"event\"}]","ContractName":"PlayerBook","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://06e82f71836472a4c97041cf3c665086d32a61c2c7f0579f72149c61a12d4da3"}]}