{"status":"1","message":"OK","result":[{"SourceCode":"/*\r\n\r\n    Copyright 2019 dYdX Trading Inc.\r\n\r\n    Licensed under the Apache License, Version 2.0 (the \"License\");\r\n    you may not use this file except in compliance with the License.\r\n    You may obtain a copy of the License at\r\n\r\n    http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n    Unless required by applicable law or agreed to in writing, software\r\n    distributed under the License is distributed on an \"AS IS\" BASIS,\r\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n    See the License for the specific language governing permissions and\r\n    limitations under the License.\r\n\r\n*/\r\n\r\npragma solidity 0.5.7;\r\npragma experimental ABIEncoderV2;\r\n\r\n// File: openzeppelin-solidity/contracts/math/SafeMath.sol\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Unsigned math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n    * @dev Multiplies two unsigned integers, reverts on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two unsigned integers, reverts on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\r\n    * reverts when dividing by zero.\r\n    */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: contracts/protocol/lib/Require.sol\r\n\r\n/**\r\n * @title Require\r\n * @author dYdX\r\n *\r\n * Stringifies parameters to pretty-print revert messages. Costs more gas than regular require()\r\n */\r\nlibrary Require {\r\n\r\n    // ============ Constants ============\r\n\r\n    uint256 constant ASCII_ZERO = 48; // '0'\r\n    uint256 constant ASCII_RELATIVE_ZERO = 87; // 'a' - 10\r\n    uint256 constant ASCII_LOWER_EX = 120; // 'x'\r\n    bytes2 constant COLON = 0x3a20; // ': '\r\n    bytes2 constant COMMA = 0x2c20; // ', '\r\n    bytes2 constant LPAREN = 0x203c; // ' <'\r\n    byte constant RPAREN = 0x3e; // '>'\r\n    uint256 constant FOUR_BIT_MASK = 0xf;\r\n\r\n    // ============ Library Functions ============\r\n\r\n    function that(\r\n        bool must,\r\n        bytes32 file,\r\n        bytes32 reason\r\n    )\r\n        internal\r\n        pure\r\n    {\r\n        if (!must) {\r\n            revert(\r\n                string(\r\n                    abi.encodePacked(\r\n                        stringify(file),\r\n                        COLON,\r\n                        stringify(reason)\r\n                    )\r\n                )\r\n            );\r\n        }\r\n    }\r\n\r\n    function that(\r\n        bool must,\r\n        bytes32 file,\r\n        bytes32 reason,\r\n        uint256 payloadA\r\n    )\r\n        internal\r\n        pure\r\n    {\r\n        if (!must) {\r\n            revert(\r\n                string(\r\n                    abi.encodePacked(\r\n                        stringify(file),\r\n                        COLON,\r\n                        stringify(reason),\r\n                        LPAREN,\r\n                        stringify(payloadA),\r\n                        RPAREN\r\n                    )\r\n                )\r\n            );\r\n        }\r\n    }\r\n\r\n    function that(\r\n        bool must,\r\n        bytes32 file,\r\n        bytes32 reason,\r\n        uint256 payloadA,\r\n        uint256 payloadB\r\n    )\r\n        internal\r\n        pure\r\n    {\r\n        if (!must) {\r\n            revert(\r\n                string(\r\n                    abi.encodePacked(\r\n                        stringify(file),\r\n                        COLON,\r\n                        stringify(reason),\r\n                        LPAREN,\r\n                        stringify(payloadA),\r\n                        COMMA,\r\n                        stringify(payloadB),\r\n                        RPAREN\r\n                    )\r\n                )\r\n            );\r\n        }\r\n    }\r\n\r\n    function that(\r\n        bool must,\r\n        bytes32 file,\r\n        bytes32 reason,\r\n        address payloadA\r\n    )\r\n        internal\r\n        pure\r\n    {\r\n        if (!must) {\r\n            revert(\r\n                string(\r\n                    abi.encodePacked(\r\n                        stringify(file),\r\n                        COLON,\r\n                        stringify(reason),\r\n                        LPAREN,\r\n                        stringify(payloadA),\r\n                        RPAREN\r\n                    )\r\n                )\r\n            );\r\n        }\r\n    }\r\n\r\n    function that(\r\n        bool must,\r\n        bytes32 file,\r\n        bytes32 reason,\r\n        address payloadA,\r\n        uint256 payloadB\r\n    )\r\n        internal\r\n        pure\r\n    {\r\n        if (!must) {\r\n            revert(\r\n                string(\r\n                    abi.encodePacked(\r\n                        stringify(file),\r\n                        COLON,\r\n                        stringify(reason),\r\n                        LPAREN,\r\n                        stringify(payloadA),\r\n                        COMMA,\r\n                        stringify(payloadB),\r\n                        RPAREN\r\n                    )\r\n                )\r\n            );\r\n        }\r\n    }\r\n\r\n    function that(\r\n        bool must,\r\n        bytes32 file,\r\n        bytes32 reason,\r\n        address payloadA,\r\n        uint256 payloadB,\r\n        uint256 payloadC\r\n    )\r\n        internal\r\n        pure\r\n    {\r\n        if (!must) {\r\n            revert(\r\n                string(\r\n                    abi.encodePacked(\r\n                        stringify(file),\r\n                        COLON,\r\n                        stringify(reason),\r\n                        LPAREN,\r\n                        stringify(payloadA),\r\n                        COMMA,\r\n                        stringify(payloadB),\r\n                        COMMA,\r\n                        stringify(payloadC),\r\n                        RPAREN\r\n                    )\r\n                )\r\n            );\r\n        }\r\n    }\r\n\r\n    // ============ Private Functions ============\r\n\r\n    function stringify(\r\n        bytes32 input\r\n    )\r\n        private\r\n        pure\r\n        returns (bytes memory)\r\n    {\r\n        // put the input bytes into the result\r\n        bytes memory result = abi.encodePacked(input);\r\n\r\n        // determine the length of the input by finding the location of the last non-zero byte\r\n        for (uint256 i = 32; i > 0; ) {\r\n            // reverse-for-loops with unsigned integer\r\n            /* solium-disable-next-line security/no-modify-for-iter-var */\r\n            i--;\r\n\r\n            // find the last non-zero byte in order to determine the length\r\n            if (result[i] != 0) {\r\n                uint256 length = i + 1;\r\n\r\n                /* solium-disable-next-line security/no-inline-assembly */\r\n                assembly {\r\n                    mstore(result, length) // r.length = length;\r\n                }\r\n\r\n                return result;\r\n            }\r\n        }\r\n\r\n        // all bytes are zero\r\n        return new bytes(0);\r\n    }\r\n\r\n    function stringify(\r\n        uint256 input\r\n    )\r\n        private\r\n        pure\r\n        returns (bytes memory)\r\n    {\r\n        if (input == 0) {\r\n            return \"0\";\r\n        }\r\n\r\n        // get the final string length\r\n        uint256 j = input;\r\n        uint256 length;\r\n        while (j != 0) {\r\n            length++;\r\n            j /= 10;\r\n        }\r\n\r\n        // allocate the string\r\n        bytes memory bstr = new bytes(length);\r\n\r\n        // populate the string starting with the least-significant character\r\n        j = input;\r\n        for (uint256 i = length; i > 0; ) {\r\n            // reverse-for-loops with unsigned integer\r\n            /* solium-disable-next-line security/no-modify-for-iter-var */\r\n            i--;\r\n\r\n            // take last decimal digit\r\n            bstr[i] = byte(uint8(ASCII_ZERO + (j % 10)));\r\n\r\n            // remove the last decimal digit\r\n            j /= 10;\r\n        }\r\n\r\n        return bstr;\r\n    }\r\n\r\n    function stringify(\r\n        address input\r\n    )\r\n        private\r\n        pure\r\n        returns (bytes memory)\r\n    {\r\n        uint256 z = uint256(input);\r\n\r\n        // addresses are \"0x\" followed by 20 bytes of data which take up 2 characters each\r\n        bytes memory result = new bytes(42);\r\n\r\n        // populate the result with \"0x\"\r\n        result[0] = byte(uint8(ASCII_ZERO));\r\n        result[1] = byte(uint8(ASCII_LOWER_EX));\r\n\r\n        // for each byte (starting from the lowest byte), populate the result with two characters\r\n        for (uint256 i = 0; i < 20; i++) {\r\n            // each byte takes two characters\r\n            uint256 shift = i * 2;\r\n\r\n            // populate the least-significant character\r\n            result[41 - shift] = char(z & FOUR_BIT_MASK);\r\n            z = z >> 4;\r\n\r\n            // populate the most-significant character\r\n            result[40 - shift] = char(z & FOUR_BIT_MASK);\r\n            z = z >> 4;\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    function char(\r\n        uint256 input\r\n    )\r\n        private\r\n        pure\r\n        returns (byte)\r\n    {\r\n        // return ASCII digit (0-9)\r\n        if (input < 10) {\r\n            return byte(uint8(input + ASCII_ZERO));\r\n        }\r\n\r\n        // return ASCII letter (a-f)\r\n        return byte(uint8(input + ASCII_RELATIVE_ZERO));\r\n    }\r\n}\r\n\r\n// File: contracts/protocol/lib/Math.sol\r\n\r\n/**\r\n * @title Math\r\n * @author dYdX\r\n *\r\n * Library for non-standard Math functions\r\n */\r\nlibrary Math {\r\n    using SafeMath for uint256;\r\n\r\n    // ============ Constants ============\r\n\r\n    bytes32 constant FILE = \"Math\";\r\n\r\n    // ============ Library Functions ============\r\n\r\n    /*\r\n     * Return target * (numerator / denominator).\r\n     */\r\n    function getPartial(\r\n        uint256 target,\r\n        uint256 numerator,\r\n        uint256 denominator\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return target.mul(numerator).div(denominator);\r\n    }\r\n\r\n    /*\r\n     * Return target * (numerator / denominator), but rounded up.\r\n     */\r\n    function getPartialRoundUp(\r\n        uint256 target,\r\n        uint256 numerator,\r\n        uint256 denominator\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        if (target == 0 || numerator == 0) {\r\n            // SafeMath will check for zero denominator\r\n            return SafeMath.div(0, denominator);\r\n        }\r\n        return target.mul(numerator).sub(1).div(denominator).add(1);\r\n    }\r\n\r\n    function to128(\r\n        uint256 number\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint128)\r\n    {\r\n        uint128 result = uint128(number);\r\n        Require.that(\r\n            result == number,\r\n            FILE,\r\n            \"Unsafe cast to uint128\"\r\n        );\r\n        return result;\r\n    }\r\n\r\n    function to96(\r\n        uint256 number\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint96)\r\n    {\r\n        uint96 result = uint96(number);\r\n        Require.that(\r\n            result == number,\r\n            FILE,\r\n            \"Unsafe cast to uint96\"\r\n        );\r\n        return result;\r\n    }\r\n\r\n    function to32(\r\n        uint256 number\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint32)\r\n    {\r\n        uint32 result = uint32(number);\r\n        Require.that(\r\n            result == number,\r\n            FILE,\r\n            \"Unsafe cast to uint32\"\r\n        );\r\n        return result;\r\n    }\r\n\r\n    function min(\r\n        uint256 a,\r\n        uint256 b\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n    function max(\r\n        uint256 a,\r\n        uint256 b\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return a > b ? a : b;\r\n    }\r\n}\r\n\r\n// File: contracts/protocol/lib/Decimal.sol\r\n\r\n/**\r\n * @title Decimal\r\n * @author dYdX\r\n *\r\n * Library that defines a fixed-point number with 18 decimal places.\r\n */\r\nlibrary Decimal {\r\n    using SafeMath for uint256;\r\n\r\n    // ============ Constants ============\r\n\r\n    uint256 constant BASE = 10**18;\r\n\r\n    // ============ Structs ============\r\n\r\n    struct D256 {\r\n        uint256 value;\r\n    }\r\n\r\n    // ============ Functions ============\r\n\r\n    function one()\r\n        internal\r\n        pure\r\n        returns (D256 memory)\r\n    {\r\n        return D256({ value: BASE });\r\n    }\r\n\r\n    function onePlus(\r\n        D256 memory d\r\n    )\r\n        internal\r\n        pure\r\n        returns (D256 memory)\r\n    {\r\n        return D256({ value: d.value.add(BASE) });\r\n    }\r\n\r\n    function mul(\r\n        uint256 target,\r\n        D256 memory d\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return Math.getPartial(target, d.value, BASE);\r\n    }\r\n\r\n    function div(\r\n        uint256 target,\r\n        D256 memory d\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return Math.getPartial(target, BASE, d.value);\r\n    }\r\n}\r\n\r\n// File: contracts/protocol/lib/Time.sol\r\n\r\n/**\r\n * @title Time\r\n * @author dYdX\r\n *\r\n * Library for dealing with time, assuming timestamps fit within 32 bits (valid until year 2106)\r\n */\r\nlibrary Time {\r\n\r\n    // ============ Library Functions ============\r\n\r\n    function currentTime()\r\n        internal\r\n        view\r\n        returns (uint32)\r\n    {\r\n        return Math.to32(block.timestamp);\r\n    }\r\n}\r\n\r\n// File: contracts/protocol/lib/Types.sol\r\n\r\n/**\r\n * @title Types\r\n * @author dYdX\r\n *\r\n * Library for interacting with the basic structs used in Solo\r\n */\r\nlibrary Types {\r\n    using Math for uint256;\r\n\r\n    // ============ AssetAmount ============\r\n\r\n    enum AssetDenomination {\r\n        Wei, // the amount is denominated in wei\r\n        Par  // the amount is denominated in par\r\n    }\r\n\r\n    enum AssetReference {\r\n        Delta, // the amount is given as a delta from the current value\r\n        Target // the amount is given as an exact number to end up at\r\n    }\r\n\r\n    struct AssetAmount {\r\n        bool sign; // true if positive\r\n        AssetDenomination denomination;\r\n        AssetReference ref;\r\n        uint256 value;\r\n    }\r\n\r\n    // ============ Par (Principal Amount) ============\r\n\r\n    // Total borrow and supply values for a market\r\n    struct TotalPar {\r\n        uint128 borrow;\r\n        uint128 supply;\r\n    }\r\n\r\n    // Individual principal amount for an account\r\n    struct Par {\r\n        bool sign; // true if positive\r\n        uint128 value;\r\n    }\r\n\r\n    function zeroPar()\r\n        internal\r\n        pure\r\n        returns (Par memory)\r\n    {\r\n        return Par({\r\n            sign: false,\r\n            value: 0\r\n        });\r\n    }\r\n\r\n    function sub(\r\n        Par memory a,\r\n        Par memory b\r\n    )\r\n        internal\r\n        pure\r\n        returns (Par memory)\r\n    {\r\n        return add(a, negative(b));\r\n    }\r\n\r\n    function add(\r\n        Par memory a,\r\n        Par memory b\r\n    )\r\n        internal\r\n        pure\r\n        returns (Par memory)\r\n    {\r\n        Par memory result;\r\n        if (a.sign == b.sign) {\r\n            result.sign = a.sign;\r\n            result.value = SafeMath.add(a.value, b.value).to128();\r\n        } else {\r\n            if (a.value >= b.value) {\r\n                result.sign = a.sign;\r\n                result.value = SafeMath.sub(a.value, b.value).to128();\r\n            } else {\r\n                result.sign = b.sign;\r\n                result.value = SafeMath.sub(b.value, a.value).to128();\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    function equals(\r\n        Par memory a,\r\n        Par memory b\r\n    )\r\n        internal\r\n        pure\r\n        returns (bool)\r\n    {\r\n        if (a.value == b.value) {\r\n            if (a.value == 0) {\r\n                return true;\r\n            }\r\n            return a.sign == b.sign;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function negative(\r\n        Par memory a\r\n    )\r\n        internal\r\n        pure\r\n        returns (Par memory)\r\n    {\r\n        return Par({\r\n            sign: !a.sign,\r\n            value: a.value\r\n        });\r\n    }\r\n\r\n    function isNegative(\r\n        Par memory a\r\n    )\r\n        internal\r\n        pure\r\n        returns (bool)\r\n    {\r\n        return !a.sign && a.value > 0;\r\n    }\r\n\r\n    function isPositive(\r\n        Par memory a\r\n    )\r\n        internal\r\n        pure\r\n        returns (bool)\r\n    {\r\n        return a.sign && a.value > 0;\r\n    }\r\n\r\n    function isZero(\r\n        Par memory a\r\n    )\r\n        internal\r\n        pure\r\n        returns (bool)\r\n    {\r\n        return a.value == 0;\r\n    }\r\n\r\n    // ============ Wei (Token Amount) ============\r\n\r\n    // Individual token amount for an account\r\n    struct Wei {\r\n        bool sign; // true if positive\r\n        uint256 value;\r\n    }\r\n\r\n    function zeroWei()\r\n        internal\r\n        pure\r\n        returns (Wei memory)\r\n    {\r\n        return Wei({\r\n            sign: false,\r\n            value: 0\r\n        });\r\n    }\r\n\r\n    function sub(\r\n        Wei memory a,\r\n        Wei memory b\r\n    )\r\n        internal\r\n        pure\r\n        returns (Wei memory)\r\n    {\r\n        return add(a, negative(b));\r\n    }\r\n\r\n    function add(\r\n        Wei memory a,\r\n        Wei memory b\r\n    )\r\n        internal\r\n        pure\r\n        returns (Wei memory)\r\n    {\r\n        Wei memory result;\r\n        if (a.sign == b.sign) {\r\n            result.sign = a.sign;\r\n            result.value = SafeMath.add(a.value, b.value);\r\n        } else {\r\n            if (a.value >= b.value) {\r\n                result.sign = a.sign;\r\n                result.value = SafeMath.sub(a.value, b.value);\r\n            } else {\r\n                result.sign = b.sign;\r\n                result.value = SafeMath.sub(b.value, a.value);\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    function equals(\r\n        Wei memory a,\r\n        Wei memory b\r\n    )\r\n        internal\r\n        pure\r\n        returns (bool)\r\n    {\r\n        if (a.value == b.value) {\r\n            if (a.value == 0) {\r\n                return true;\r\n            }\r\n            return a.sign == b.sign;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function negative(\r\n        Wei memory a\r\n    )\r\n        internal\r\n        pure\r\n        returns (Wei memory)\r\n    {\r\n        return Wei({\r\n            sign: !a.sign,\r\n            value: a.value\r\n        });\r\n    }\r\n\r\n    function isNegative(\r\n        Wei memory a\r\n    )\r\n        internal\r\n        pure\r\n        returns (bool)\r\n    {\r\n        return !a.sign && a.value > 0;\r\n    }\r\n\r\n    function isPositive(\r\n        Wei memory a\r\n    )\r\n        internal\r\n        pure\r\n        returns (bool)\r\n    {\r\n        return a.sign && a.value > 0;\r\n    }\r\n\r\n    function isZero(\r\n        Wei memory a\r\n    )\r\n        internal\r\n        pure\r\n        returns (bool)\r\n    {\r\n        return a.value == 0;\r\n    }\r\n}\r\n\r\n// File: contracts/protocol/lib/Interest.sol\r\n\r\n/**\r\n * @title Interest\r\n * @author dYdX\r\n *\r\n * Library for managing the interest rate and interest indexes of Solo\r\n */\r\nlibrary Interest {\r\n    using Math for uint256;\r\n    using SafeMath for uint256;\r\n\r\n    // ============ Constants ============\r\n\r\n    bytes32 constant FILE = \"Interest\";\r\n    uint64 constant BASE = 10**18;\r\n\r\n    // ============ Structs ============\r\n\r\n    struct Rate {\r\n        uint256 value;\r\n    }\r\n\r\n    struct Index {\r\n        uint96 borrow;\r\n        uint96 supply;\r\n        uint32 lastUpdate;\r\n    }\r\n\r\n    // ============ Library Functions ============\r\n\r\n    /**\r\n     * Get a new market Index based on the old index and market interest rate.\r\n     * Calculate interest for borrowers by using the formula rate * time. Approximates\r\n     * continuously-compounded interest when called frequently, but is much more\r\n     * gas-efficient to calculate. For suppliers, the interest rate is adjusted by the earningsRate,\r\n     * then prorated the across all suppliers.\r\n     *\r\n     * @param  index         The old index for a market\r\n     * @param  rate          The current interest rate of the market\r\n     * @param  totalPar      The total supply and borrow par values of the market\r\n     * @param  earningsRate  The portion of the interest that is forwarded to the suppliers\r\n     * @return               The updated index for a market\r\n     */\r\n    function calculateNewIndex(\r\n        Index memory index,\r\n        Rate memory rate,\r\n        Types.TotalPar memory totalPar,\r\n        Decimal.D256 memory earningsRate\r\n    )\r\n        internal\r\n        view\r\n        returns (Index memory)\r\n    {\r\n        (\r\n            Types.Wei memory supplyWei,\r\n            Types.Wei memory borrowWei\r\n        ) = totalParToWei(totalPar, index);\r\n\r\n        // get interest increase for borrowers\r\n        uint32 currentTime = Time.currentTime();\r\n        uint256 borrowInterest = rate.value.mul(uint256(currentTime).sub(index.lastUpdate));\r\n\r\n        // get interest increase for suppliers\r\n        uint256 supplyInterest;\r\n        if (Types.isZero(supplyWei)) {\r\n            supplyInterest = 0;\r\n        } else {\r\n            supplyInterest = Decimal.mul(borrowInterest, earningsRate);\r\n            if (borrowWei.value < supplyWei.value) {\r\n                supplyInterest = Math.getPartial(supplyInterest, borrowWei.value, supplyWei.value);\r\n            }\r\n        }\r\n        assert(supplyInterest <= borrowInterest);\r\n\r\n        return Index({\r\n            borrow: Math.getPartial(index.borrow, borrowInterest, BASE).add(index.borrow).to96(),\r\n            supply: Math.getPartial(index.supply, supplyInterest, BASE).add(index.supply).to96(),\r\n            lastUpdate: currentTime\r\n        });\r\n    }\r\n\r\n    function newIndex()\r\n        internal\r\n        view\r\n        returns (Index memory)\r\n    {\r\n        return Index({\r\n            borrow: BASE,\r\n            supply: BASE,\r\n            lastUpdate: Time.currentTime()\r\n        });\r\n    }\r\n\r\n    /*\r\n     * Convert a principal amount to a token amount given an index.\r\n     */\r\n    function parToWei(\r\n        Types.Par memory input,\r\n        Index memory index\r\n    )\r\n        internal\r\n        pure\r\n        returns (Types.Wei memory)\r\n    {\r\n        uint256 inputValue = uint256(input.value);\r\n        if (input.sign) {\r\n            return Types.Wei({\r\n                sign: true,\r\n                value: inputValue.getPartial(index.supply, BASE)\r\n            });\r\n        } else {\r\n            return Types.Wei({\r\n                sign: false,\r\n                value: inputValue.getPartialRoundUp(index.borrow, BASE)\r\n            });\r\n        }\r\n    }\r\n\r\n    /*\r\n     * Convert a token amount to a principal amount given an index.\r\n     */\r\n    function weiToPar(\r\n        Types.Wei memory input,\r\n        Index memory index\r\n    )\r\n        internal\r\n        pure\r\n        returns (Types.Par memory)\r\n    {\r\n        if (input.sign) {\r\n            return Types.Par({\r\n                sign: true,\r\n                value: input.value.getPartial(BASE, index.supply).to128()\r\n            });\r\n        } else {\r\n            return Types.Par({\r\n                sign: false,\r\n                value: input.value.getPartialRoundUp(BASE, index.borrow).to128()\r\n            });\r\n        }\r\n    }\r\n\r\n    /*\r\n     * Convert the total supply and borrow principal amounts of a market to total supply and borrow\r\n     * token amounts.\r\n     */\r\n    function totalParToWei(\r\n        Types.TotalPar memory totalPar,\r\n        Index memory index\r\n    )\r\n        internal\r\n        pure\r\n        returns (Types.Wei memory, Types.Wei memory)\r\n    {\r\n        Types.Par memory supplyPar = Types.Par({\r\n            sign: true,\r\n            value: totalPar.supply\r\n        });\r\n        Types.Par memory borrowPar = Types.Par({\r\n            sign: false,\r\n            value: totalPar.borrow\r\n        });\r\n        Types.Wei memory supplyWei = parToWei(supplyPar, index);\r\n        Types.Wei memory borrowWei = parToWei(borrowPar, index);\r\n        return (supplyWei, borrowWei);\r\n    }\r\n}\r\n\r\n// File: contracts/protocol/interfaces/IInterestSetter.sol\r\n\r\n/**\r\n * @title IInterestSetter\r\n * @author dYdX\r\n *\r\n * Interface that Interest Setters for Solo must implement in order to report interest rates.\r\n */\r\ninterface IInterestSetter {\r\n\r\n    // ============ Public Functions ============\r\n\r\n    /**\r\n     * Get the interest rate of a token given some borrowed and supplied amounts\r\n     *\r\n     * @param  token        The address of the ERC20 token for the market\r\n     * @param  borrowWei    The total borrowed token amount for the market\r\n     * @param  supplyWei    The total supplied token amount for the market\r\n     * @return              The interest rate per second\r\n     */\r\n    function getInterestRate(\r\n        address token,\r\n        uint256 borrowWei,\r\n        uint256 supplyWei\r\n    )\r\n        external\r\n        view\r\n        returns (Interest.Rate memory);\r\n}\r\n\r\n// File: contracts/external/interestsetters/PolynomialInterestSetter.sol\r\n\r\n/**\r\n * @title PolynomialInterestSetter\r\n * @author dYdX\r\n *\r\n * Interest setter that sets interest based on a polynomial of the usage percentage of the market.\r\n */\r\ncontract PolynomialInterestSetter is\r\n    IInterestSetter\r\n{\r\n    using Math for uint256;\r\n    using SafeMath for uint256;\r\n\r\n    // ============ Constants ============\r\n\r\n    uint256 constant PERCENT = 100;\r\n\r\n    uint256 constant BASE = 10 ** 18;\r\n\r\n    uint256 constant SECONDS_IN_A_YEAR = 60 * 60 * 24 * 365;\r\n\r\n    uint256 constant BYTE = 8;\r\n\r\n    // ============ Structs ============\r\n\r\n    struct PolyStorage {\r\n        uint128 maxAPR;\r\n        uint128 coefficients;\r\n    }\r\n\r\n    // ============ Storage ============\r\n\r\n    PolyStorage g_storage;\r\n\r\n    // ============ Constructor ============\r\n\r\n    constructor(\r\n        PolyStorage memory params\r\n    )\r\n        public\r\n    {\r\n        // verify that all coefficients add up to 100%\r\n        uint256 sumOfCoefficients = 0;\r\n        for (\r\n            uint256 coefficients = params.coefficients;\r\n            coefficients != 0;\r\n            coefficients >>= BYTE\r\n        ) {\r\n            sumOfCoefficients += coefficients % 256;\r\n        }\r\n        require(\r\n            sumOfCoefficients == PERCENT,\r\n            \"Coefficients must sum to 100\"\r\n        );\r\n\r\n        // store the params\r\n        g_storage = params;\r\n    }\r\n\r\n    // ============ Public Functions ============\r\n\r\n    /**\r\n     * Get the interest rate given some borrowed and supplied amounts. The interest function is a\r\n     * polynomial function of the utilization (borrowWei / supplyWei) of the market.\r\n     *\r\n     *   - If borrowWei > supplyWei then the utilization is considered to be equal to 1.\r\n     *   - If both are zero, then the utilization is considered to be equal to 0.\r\n     *\r\n     * @return The interest rate per second (times 10 ** 18)\r\n     */\r\n    function getInterestRate(\r\n        address /* token */,\r\n        uint256 borrowWei,\r\n        uint256 supplyWei\r\n    )\r\n        external\r\n        view\r\n        returns (Interest.Rate memory)\r\n    {\r\n        if (borrowWei == 0) {\r\n            return Interest.Rate({\r\n                value: 0\r\n            });\r\n        }\r\n\r\n        PolyStorage memory s = g_storage;\r\n        uint256 maxAPR = s.maxAPR;\r\n\r\n        if (borrowWei >= supplyWei) {\r\n            return Interest.Rate({\r\n                value: maxAPR / SECONDS_IN_A_YEAR\r\n            });\r\n        }\r\n\r\n        uint256 result = 0;\r\n        uint256 polynomial = BASE;\r\n\r\n        // for each non-zero coefficient...\r\n        uint256 coefficients = s.coefficients;\r\n        while (true) {\r\n            // gets the lowest-order byte\r\n            uint256 coefficient = coefficients % 256;\r\n\r\n            // if non-zero, add to result\r\n            if (coefficient != 0) {\r\n                // no safeAdd since there are at most 16 coefficients\r\n                // no safeMul since (coefficient < 256 && polynomial <= 10**18)\r\n                result += coefficient * polynomial;\r\n\r\n                // break if this is the last non-zero coefficient\r\n                if (coefficient == coefficients) {\r\n                    break;\r\n                }\r\n            }\r\n\r\n            // increase the order of the polynomial term\r\n            // no safeDiv since supplyWei must be stricly larger than borrowWei\r\n            polynomial = polynomial.mul(borrowWei) / supplyWei;\r\n\r\n            // move to next coefficient\r\n            coefficients >>= BYTE;\r\n        }\r\n\r\n        // normalize the result\r\n        // no safeMul since result fits within 72 bits and maxAPR fits within 128 bits\r\n        // no safeDiv since the divisor is a non-zero constant\r\n        return Interest.Rate({\r\n            value: result * maxAPR / (SECONDS_IN_A_YEAR * BASE * PERCENT)\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Get the maximum APR that this interestSetter will return. The actual APY may be higher\r\n     * depending on how often the interest is compounded.\r\n     *\r\n     * @return The maximum APR\r\n     */\r\n    function getMaxAPR()\r\n        external\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return g_storage.maxAPR;\r\n    }\r\n\r\n    /**\r\n     * Get all of the coefficients of the interest calculation, starting from the coefficient for\r\n     * the first-order utilization variable.\r\n     *\r\n     * @return The coefficients\r\n     */\r\n    function getCoefficients()\r\n        external\r\n        view\r\n        returns (uint256[] memory)\r\n    {\r\n        // allocate new array with maximum of 16 coefficients\r\n        uint256[] memory result = new uint256[](16);\r\n\r\n        // add the coefficients to the array\r\n        uint256 numCoefficients = 0;\r\n        for (\r\n            uint256 coefficients = g_storage.coefficients;\r\n            coefficients != 0;\r\n            coefficients >>= BYTE\r\n        ) {\r\n            result[numCoefficients] = coefficients % 256;\r\n            numCoefficients++;\r\n        }\r\n\r\n        // modify result.length to match numCoefficients\r\n        /* solium-disable-next-line security/no-inline-assembly */\r\n        assembly {\r\n            mstore(result, numCoefficients)\r\n        }\r\n\r\n        return result;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"getMaxAPR\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCoefficients\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"borrowWei\",\"type\":\"uint256\"},{\"name\":\"supplyWei\",\"type\":\"uint256\"}],\"name\":\"getInterestRate\",\"outputs\":[{\"components\":[{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"\",\"type\":\"tuple\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"name\":\"maxAPR\",\"type\":\"uint128\"},{\"name\":\"coefficients\",\"type\":\"uint128\"}],\"name\":\"params\",\"type\":\"tuple\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"}]","ContractName":"PolynomialInterestSetter","CompilerVersion":"v0.5.7+commit.6da8b019","OptimizationUsed":"1","Runs":"10000","ConstructorArguments":"0000000000000000000000000000000000000000000000000de0b6b3a764000000000000000000000000000000000000000000000000000000005000000a0a00","Library":"","SwarmSource":"bzzr://48af2d9629474f4b37687f3807aba12f4e343da394cb73dfe8dd4198972c368c"}]}