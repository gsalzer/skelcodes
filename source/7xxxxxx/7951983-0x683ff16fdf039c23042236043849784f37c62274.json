{"status":"1","message":"OK","result":[{"SourceCode":"/*\r\n * Price Adjustments for the last 100 NFTs in the Crypto stamp On-Chain Shop\r\n *\r\n * Developed by capacity.at\r\n * for post.at\r\n */\r\n\r\n\r\n// File: node_modules\\openzeppelin-solidity\\contracts\\introspection\\IERC165.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Interface of the ERC165 standard, as defined in the\r\n * [EIP](https://eips.ethereum.org/EIPS/eip-165).\r\n *\r\n * Implementers can declare support of contract interfaces, which can then be\r\n * queried by others (`ERC165Checker`).\r\n *\r\n * For an implementation, see `ERC165`.\r\n */\r\ninterface IERC165 {\r\n    /**\r\n     * @dev Returns true if this contract implements the interface defined by\r\n     * `interfaceId`. See the corresponding\r\n     * [EIP section](https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified)\r\n     * to learn more about how these ids are created.\r\n     *\r\n     * This function call must use less than 30 000 gas.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\n// File: openzeppelin-solidity\\contracts\\token\\ERC721\\IERC721.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n/**\r\n * @dev Required interface of an ERC721 compliant contract.\r\n */\r\ncontract IERC721 is IERC165 {\r\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\r\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\r\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n\r\n    /**\r\n     * @dev Returns the number of NFTs in `owner`'s account.\r\n     */\r\n    function balanceOf(address owner) public view returns (uint256 balance);\r\n\r\n    /**\r\n     * @dev Returns the owner of the NFT specified by `tokenId`.\r\n     */\r\n    function ownerOf(uint256 tokenId) public view returns (address owner);\r\n\r\n    /**\r\n     * @dev Transfers a specific NFT (`tokenId`) from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * \r\n     *\r\n     * Requirements:\r\n     * - `from`, `to` cannot be zero.\r\n     * - `tokenId` must be owned by `from`.\r\n     * - If the caller is not `from`, it must be have been allowed to move this\r\n     * NFT by either `approve` or `setApproveForAll`.\r\n     */\r\n    function safeTransferFrom(address from, address to, uint256 tokenId) public;\r\n    /**\r\n     * @dev Transfers a specific NFT (`tokenId`) from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Requirements:\r\n     * - If the caller is not `from`, it must be approved to move this NFT by\r\n     * either `approve` or `setApproveForAll`.\r\n     */\r\n    function transferFrom(address from, address to, uint256 tokenId) public;\r\n    function approve(address to, uint256 tokenId) public;\r\n    function getApproved(uint256 tokenId) public view returns (address operator);\r\n\r\n    function setApprovalForAll(address operator, bool _approved) public;\r\n    function isApprovedForAll(address owner, address operator) public view returns (bool);\r\n\r\n\r\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public;\r\n}\r\n\r\n// File: contracts\\PricingStrategy.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\ncontract PricingStrategy {\r\n\r\n    function adjustPrice(uint256 oldprice, uint256 remainingPieces) public view returns (uint256); //returns the new price\r\n\r\n}\r\n\r\n// File: contracts\\AdjustableLast100PricingStrategy.sol\r\n\r\n/*\r\n\r\n*/\r\npragma solidity ^0.5.0;\r\n\r\n\r\n\r\n\r\ncontract AdjustableLast100PricingStrategy is PricingStrategy {\r\n\r\n\r\n    address public beneficiary;\r\n    uint256 public factor;\r\n\r\n    constructor (address _beneficiary) public {\r\n        beneficiary = _beneficiary;\r\n        factor = 108; // 8% increase\r\n    }\r\n\r\n\r\n    modifier onlyBeneficiary() {\r\n        require(msg.sender == beneficiary, \"Only the current benefinicary can call this function.\");\r\n        _;\r\n    }\r\n\r\n    function setFactor(uint256 _newFactor)\r\n    public\r\n    onlyBeneficiary\r\n    {\r\n        require(_newFactor > 0, \"You need to provide a price modifier\");\r\n        factor = _newFactor;\r\n    }\r\n\r\n\r\n    /**\r\n    calculates a new price based on the old price and other params referenced\r\n    */\r\n    function adjustPrice(uint256 _oldPrice, uint256 _remainingPieces) public view returns (uint256){\r\n        if (_remainingPieces < 100) {\r\n            return _oldPrice * factor / 100;\r\n        } else {\r\n            return _oldPrice;\r\n        }\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"beneficiary\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"factor\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newFactor\",\"type\":\"uint256\"}],\"name\":\"setFactor\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_oldPrice\",\"type\":\"uint256\"},{\"name\":\"_remainingPieces\",\"type\":\"uint256\"}],\"name\":\"adjustPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"}]","ContractName":"AdjustableLast100PricingStrategy","CompilerVersion":"v0.5.7+commit.6da8b019","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000cebb9ae52a3d61c4ed1528fba93e5beaaa40e9e2","Library":"","SwarmSource":"bzzr://600db830ef792e693e1397d74fc7689bc7838f9390a5e453a9a4c7d70cbc8f47"}]}