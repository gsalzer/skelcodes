{"status":"1","message":"OK","result":[{"SourceCode":"// Full Contract Sources : https://github.com/DigixGlobal/dao-contracts\r\n// File: @digix/cacp-contracts-dao/contracts/ACOwned.sol\r\npragma solidity ^0.4.25;\r\n/// @title Owner based access control\r\n/// @author DigixGlobal\r\ncontract ACOwned {\r\n\r\n  address public owner;\r\n  address public new_owner;\r\n  bool is_ac_owned_init;\r\n\r\n  /// @dev Modifier to check if msg.sender is the contract owner\r\n  modifier if_owner() {\r\n    require(is_owner());\r\n    _;\r\n  }\r\n\r\n  function init_ac_owned()\r\n           internal\r\n           returns (bool _success)\r\n  {\r\n    if (is_ac_owned_init == false) {\r\n      owner = msg.sender;\r\n      is_ac_owned_init = true;\r\n    }\r\n    _success = true;\r\n  }\r\n\r\n  function is_owner()\r\n           private\r\n           constant\r\n           returns (bool _is_owner)\r\n  {\r\n    _is_owner = (msg.sender == owner);\r\n  }\r\n\r\n  function change_owner(address _new_owner)\r\n           if_owner()\r\n           public\r\n           returns (bool _success)\r\n  {\r\n    new_owner = _new_owner;\r\n    _success = true;\r\n  }\r\n\r\n  function claim_ownership()\r\n           public\r\n           returns (bool _success)\r\n  {\r\n    require(msg.sender == new_owner);\r\n    owner = new_owner;\r\n    _success = true;\r\n  }\r\n}\r\n\r\n// File: @digix/cacp-contracts-dao/contracts/Constants.sol\r\n/// @title Some useful constants\r\n/// @author DigixGlobal\r\ncontract Constants {\r\n  address constant NULL_ADDRESS = address(0x0);\r\n  uint256 constant ZERO = uint256(0);\r\n  bytes32 constant EMPTY = bytes32(0x0);\r\n}\r\n\r\n// File: @digix/cacp-contracts-dao/contracts/ContractResolver.sol\r\n/// @title Contract Name Registry\r\n/// @author DigixGlobal\r\ncontract ContractResolver is ACOwned, Constants {\r\n\r\n  mapping (bytes32 => address) contracts;\r\n  bool public locked_forever;\r\n\r\n  modifier unless_registered(bytes32 _key) {\r\n    require(contracts[_key] == NULL_ADDRESS);\r\n    _;\r\n  }\r\n\r\n  modifier if_owner_origin() {\r\n    require(tx.origin == owner);\r\n    _;\r\n  }\r\n\r\n  /// Function modifier to check if msg.sender corresponds to the resolved address of a given key\r\n  /// @param _contract The resolver key\r\n  modifier if_sender_is(bytes32 _contract) {\r\n    require(msg.sender == get_contract(_contract));\r\n    _;\r\n  }\r\n\r\n  modifier if_not_locked() {\r\n    require(locked_forever == false);\r\n    _;\r\n  }\r\n\r\n  /// @dev ContractResolver constructor will perform the following: 1. Set msg.sender as the contract owner.\r\n  constructor() public\r\n  {\r\n    require(init_ac_owned());\r\n    locked_forever = false;\r\n  }\r\n\r\n  /// @dev Called at contract initialization\r\n  /// @param _key bytestring for CACP name\r\n  /// @param _contract_address The address of the contract to be registered\r\n  /// @return _success if the operation is successful\r\n  function init_register_contract(bytes32 _key, address _contract_address)\r\n           if_owner_origin()\r\n           if_not_locked()\r\n           unless_registered(_key)\r\n           public\r\n           returns (bool _success)\r\n  {\r\n    require(_contract_address != NULL_ADDRESS);\r\n    contracts[_key] = _contract_address;\r\n    _success = true;\r\n  }\r\n\r\n  /// @dev Lock the resolver from any further modifications.  This can only be called from the owner\r\n  /// @return _success if the operation is successful\r\n  function lock_resolver_forever()\r\n           if_owner\r\n           public\r\n           returns (bool _success)\r\n  {\r\n    locked_forever = true;\r\n    _success = true;\r\n  }\r\n\r\n  /// @dev Get address of a contract\r\n  /// @param _key the bytestring name of the contract to look up\r\n  /// @return _contract the address of the contract\r\n  function get_contract(bytes32 _key)\r\n           public\r\n           view\r\n           returns (address _contract)\r\n  {\r\n    require(contracts[_key] != NULL_ADDRESS);\r\n    _contract = contracts[_key];\r\n  }\r\n}\r\n\r\n// File: @digix/cacp-contracts-dao/contracts/ResolverClient.sol\r\n/// @title Contract Resolver Interface\r\n/// @author DigixGlobal\r\ncontract ResolverClient {\r\n\r\n  /// The address of the resolver contract for this project\r\n  address public resolver;\r\n  bytes32 public key;\r\n\r\n  /// Make our own address available to us as a constant\r\n  address public CONTRACT_ADDRESS;\r\n\r\n  /// Function modifier to check if msg.sender corresponds to the resolved address of a given key\r\n  /// @param _contract The resolver key\r\n  modifier if_sender_is(bytes32 _contract) {\r\n    require(sender_is(_contract));\r\n    _;\r\n  }\r\n\r\n  function sender_is(bytes32 _contract) internal view returns (bool _isFrom) {\r\n    _isFrom = msg.sender == ContractResolver(resolver).get_contract(_contract);\r\n  }\r\n\r\n  modifier if_sender_is_from(bytes32[3] _contracts) {\r\n    require(sender_is_from(_contracts));\r\n    _;\r\n  }\r\n\r\n  function sender_is_from(bytes32[3] _contracts) internal view returns (bool _isFrom) {\r\n    uint256 _n = _contracts.length;\r\n    for (uint256 i = 0; i < _n; i++) {\r\n      if (_contracts[i] == bytes32(0x0)) continue;\r\n      if (msg.sender == ContractResolver(resolver).get_contract(_contracts[i])) {\r\n        _isFrom = true;\r\n        break;\r\n      }\r\n    }\r\n  }\r\n\r\n  /// Function modifier to check resolver's locking status.\r\n  modifier unless_resolver_is_locked() {\r\n    require(is_locked() == false);\r\n    _;\r\n  }\r\n\r\n  /// @dev Initialize new contract\r\n  /// @param _key the resolver key for this contract\r\n  /// @return _success if the initialization is successful\r\n  function init(bytes32 _key, address _resolver)\r\n           internal\r\n           returns (bool _success)\r\n  {\r\n    bool _is_locked = ContractResolver(_resolver).locked_forever();\r\n    if (_is_locked == false) {\r\n      CONTRACT_ADDRESS = address(this);\r\n      resolver = _resolver;\r\n      key = _key;\r\n      require(ContractResolver(resolver).init_register_contract(key, CONTRACT_ADDRESS));\r\n      _success = true;\r\n    }  else {\r\n      _success = false;\r\n    }\r\n  }\r\n\r\n  /// @dev Check if resolver is locked\r\n  /// @return _locked if the resolver is currently locked\r\n  function is_locked()\r\n           private\r\n           view\r\n           returns (bool _locked)\r\n  {\r\n    _locked = ContractResolver(resolver).locked_forever();\r\n  }\r\n\r\n  /// @dev Get the address of a contract\r\n  /// @param _key the resolver key to look up\r\n  /// @return _contract the address of the contract\r\n  function get_contract(bytes32 _key)\r\n           public\r\n           view\r\n           returns (address _contract)\r\n  {\r\n    _contract = ContractResolver(resolver).get_contract(_key);\r\n  }\r\n}\r\n\r\n// File: @digix/solidity-collections/contracts/lib/DoublyLinkedList.sol\r\nlibrary DoublyLinkedList {\r\n\r\n  struct Item {\r\n    bytes32 item;\r\n    uint256 previous_index;\r\n    uint256 next_index;\r\n  }\r\n\r\n  struct Data {\r\n    uint256 first_index;\r\n    uint256 last_index;\r\n    uint256 count;\r\n    mapping(bytes32 => uint256) item_index;\r\n    mapping(uint256 => bool) valid_indexes;\r\n    Item[] collection;\r\n  }\r\n\r\n  struct IndexedUint {\r\n    mapping(bytes32 => Data) data;\r\n  }\r\n\r\n  struct IndexedAddress {\r\n    mapping(bytes32 => Data) data;\r\n  }\r\n\r\n  struct IndexedBytes {\r\n    mapping(bytes32 => Data) data;\r\n  }\r\n\r\n  struct Address {\r\n    Data data;\r\n  }\r\n\r\n  struct Bytes {\r\n    Data data;\r\n  }\r\n\r\n  struct Uint {\r\n    Data data;\r\n  }\r\n\r\n  uint256 constant NONE = uint256(0);\r\n  bytes32 constant EMPTY_BYTES = bytes32(0x0);\r\n  address constant NULL_ADDRESS = address(0x0);\r\n\r\n  function find(Data storage self, bytes32 _item)\r\n           public\r\n           constant\r\n           returns (uint256 _item_index)\r\n  {\r\n    if ((self.item_index[_item] == NONE) && (self.count == NONE)) {\r\n      _item_index = NONE;\r\n    } else {\r\n      _item_index = self.item_index[_item];\r\n    }\r\n  }\r\n\r\n  function get(Data storage self, uint256 _item_index)\r\n           public\r\n           constant\r\n           returns (bytes32 _item)\r\n  {\r\n    if (self.valid_indexes[_item_index] == true) {\r\n      _item = self.collection[_item_index - 1].item;\r\n    } else {\r\n      _item = EMPTY_BYTES;\r\n    }\r\n  }\r\n\r\n  function append(Data storage self, bytes32 _data)\r\n           internal\r\n           returns (bool _success)\r\n  {\r\n    if (find(self, _data) != NONE || _data == bytes32(\"\")) { // rejects addition of empty values\r\n      _success = false;\r\n    } else {\r\n      uint256 _index = uint256(self.collection.push(Item({item: _data, previous_index: self.last_index, next_index: NONE})));\r\n      if (self.last_index == NONE) {\r\n        if ((self.first_index != NONE) || (self.count != NONE)) {\r\n          revert();\r\n        } else {\r\n          self.first_index = self.last_index = _index;\r\n          self.count = 1;\r\n        }\r\n      } else {\r\n        self.collection[self.last_index - 1].next_index = _index;\r\n        self.last_index = _index;\r\n        self.count++;\r\n      }\r\n      self.valid_indexes[_index] = true;\r\n      self.item_index[_data] = _index;\r\n      _success = true;\r\n    }\r\n  }\r\n\r\n  function remove(Data storage self, uint256 _index)\r\n           internal\r\n           returns (bool _success)\r\n  {\r\n    if (self.valid_indexes[_index] == true) {\r\n      Item memory item = self.collection[_index - 1];\r\n      if (item.previous_index == NONE) {\r\n        self.first_index = item.next_index;\r\n      } else {\r\n        self.collection[item.previous_index - 1].next_index = item.next_index;\r\n      }\r\n\r\n      if (item.next_index == NONE) {\r\n        self.last_index = item.previous_index;\r\n      } else {\r\n        self.collection[item.next_index - 1].previous_index = item.previous_index;\r\n      }\r\n      delete self.collection[_index - 1];\r\n      self.valid_indexes[_index] = false;\r\n      delete self.item_index[item.item];\r\n      self.count--;\r\n      _success = true;\r\n    } else {\r\n      _success = false;\r\n    }\r\n  }\r\n\r\n  function remove_item(Data storage self, bytes32 _item)\r\n           internal\r\n           returns (bool _success)\r\n  {\r\n    uint256 _item_index = find(self, _item);\r\n    if (_item_index != NONE) {\r\n      require(remove(self, _item_index));\r\n      _success = true;\r\n    } else {\r\n      _success = false;\r\n    }\r\n    return _success;\r\n  }\r\n\r\n  function total(Data storage self)\r\n           public\r\n           constant\r\n           returns (uint256 _total_count)\r\n  {\r\n    _total_count = self.count;\r\n  }\r\n\r\n  function start(Data storage self)\r\n           public\r\n           constant\r\n           returns (uint256 _item_index)\r\n  {\r\n    _item_index = self.first_index;\r\n    return _item_index;\r\n  }\r\n\r\n  function start_item(Data storage self)\r\n           public\r\n           constant\r\n           returns (bytes32 _item)\r\n  {\r\n    uint256 _item_index = start(self);\r\n    if (_item_index != NONE) {\r\n      _item = get(self, _item_index);\r\n    } else {\r\n      _item = EMPTY_BYTES;\r\n    }\r\n  }\r\n\r\n  function end(Data storage self)\r\n           public\r\n           constant\r\n           returns (uint256 _item_index)\r\n  {\r\n    _item_index = self.last_index;\r\n    return _item_index;\r\n  }\r\n\r\n  function end_item(Data storage self)\r\n           public\r\n           constant\r\n           returns (bytes32 _item)\r\n  {\r\n    uint256 _item_index = end(self);\r\n    if (_item_index != NONE) {\r\n      _item = get(self, _item_index);\r\n    } else {\r\n      _item = EMPTY_BYTES;\r\n    }\r\n  }\r\n\r\n  function valid(Data storage self, uint256 _item_index)\r\n           public\r\n           constant\r\n           returns (bool _yes)\r\n  {\r\n    _yes = self.valid_indexes[_item_index];\r\n    //_yes = ((_item_index - 1) < self.collection.length);\r\n  }\r\n\r\n  function valid_item(Data storage self, bytes32 _item)\r\n           public\r\n           constant\r\n           returns (bool _yes)\r\n  {\r\n    uint256 _item_index = self.item_index[_item];\r\n    _yes = self.valid_indexes[_item_index];\r\n  }\r\n\r\n  function previous(Data storage self, uint256 _current_index)\r\n           public\r\n           constant\r\n           returns (uint256 _previous_index)\r\n  {\r\n    if (self.valid_indexes[_current_index] == true) {\r\n      _previous_index = self.collection[_current_index - 1].previous_index;\r\n    } else {\r\n      _previous_index = NONE;\r\n    }\r\n  }\r\n\r\n  function previous_item(Data storage self, bytes32 _current_item)\r\n           public\r\n           constant\r\n           returns (bytes32 _previous_item)\r\n  {\r\n    uint256 _current_index = find(self, _current_item);\r\n    if (_current_index != NONE) {\r\n      uint256 _previous_index = previous(self, _current_index);\r\n      _previous_item = get(self, _previous_index);\r\n    } else {\r\n      _previous_item = EMPTY_BYTES;\r\n    }\r\n  }\r\n\r\n  function next(Data storage self, uint256 _current_index)\r\n           public\r\n           constant\r\n           returns (uint256 _next_index)\r\n  {\r\n    if (self.valid_indexes[_current_index] == true) {\r\n      _next_index = self.collection[_current_index - 1].next_index;\r\n    } else {\r\n      _next_index = NONE;\r\n    }\r\n  }\r\n\r\n  function next_item(Data storage self, bytes32 _current_item)\r\n           public\r\n           constant\r\n           returns (bytes32 _next_item)\r\n  {\r\n    uint256 _current_index = find(self, _current_item);\r\n    if (_current_index != NONE) {\r\n      uint256 _next_index = next(self, _current_index);\r\n      _next_item = get(self, _next_index);\r\n    } else {\r\n      _next_item = EMPTY_BYTES;\r\n    }\r\n  }\r\n\r\n  function find(Uint storage self, uint256 _item)\r\n           public\r\n           constant\r\n           returns (uint256 _item_index)\r\n  {\r\n    _item_index = find(self.data, bytes32(_item));\r\n  }\r\n\r\n  function get(Uint storage self, uint256 _item_index)\r\n           public\r\n           constant\r\n           returns (uint256 _item)\r\n  {\r\n    _item = uint256(get(self.data, _item_index));\r\n  }\r\n\r\n\r\n  function append(Uint storage self, uint256 _data)\r\n           public\r\n           returns (bool _success)\r\n  {\r\n    _success = append(self.data, bytes32(_data));\r\n  }\r\n\r\n  function remove(Uint storage self, uint256 _index)\r\n           internal\r\n           returns (bool _success)\r\n  {\r\n    _success = remove(self.data, _index);\r\n  }\r\n\r\n  function remove_item(Uint storage self, uint256 _item)\r\n           public\r\n           returns (bool _success)\r\n  {\r\n    _success = remove_item(self.data, bytes32(_item));\r\n  }\r\n\r\n  function total(Uint storage self)\r\n           public\r\n           constant\r\n           returns (uint256 _total_count)\r\n  {\r\n    _total_count = total(self.data);\r\n  }\r\n\r\n  function start(Uint storage self)\r\n           public\r\n           constant\r\n           returns (uint256 _index)\r\n  {\r\n    _index = start(self.data);\r\n  }\r\n\r\n  function start_item(Uint storage self)\r\n           public\r\n           constant\r\n           returns (uint256 _start_item)\r\n  {\r\n    _start_item = uint256(start_item(self.data));\r\n  }\r\n\r\n\r\n  function end(Uint storage self)\r\n           public\r\n           constant\r\n           returns (uint256 _index)\r\n  {\r\n    _index = end(self.data);\r\n  }\r\n\r\n  function end_item(Uint storage self)\r\n           public\r\n           constant\r\n           returns (uint256 _end_item)\r\n  {\r\n    _end_item = uint256(end_item(self.data));\r\n  }\r\n\r\n  function valid(Uint storage self, uint256 _item_index)\r\n           public\r\n           constant\r\n           returns (bool _yes)\r\n  {\r\n    _yes = valid(self.data, _item_index);\r\n  }\r\n\r\n  function valid_item(Uint storage self, uint256 _item)\r\n           public\r\n           constant\r\n           returns (bool _yes)\r\n  {\r\n    _yes = valid_item(self.data, bytes32(_item));\r\n  }\r\n\r\n  function previous(Uint storage self, uint256 _current_index)\r\n           public\r\n           constant\r\n           returns (uint256 _previous_index)\r\n  {\r\n    _previous_index = previous(self.data, _current_index);\r\n  }\r\n\r\n  function previous_item(Uint storage self, uint256 _current_item)\r\n           public\r\n           constant\r\n           returns (uint256 _previous_item)\r\n  {\r\n    _previous_item = uint256(previous_item(self.data, bytes32(_current_item)));\r\n  }\r\n\r\n  function next(Uint storage self, uint256 _current_index)\r\n           public\r\n           constant\r\n           returns (uint256 _next_index)\r\n  {\r\n    _next_index = next(self.data, _current_index);\r\n  }\r\n\r\n  function next_item(Uint storage self, uint256 _current_item)\r\n           public\r\n           constant\r\n           returns (uint256 _next_item)\r\n  {\r\n    _next_item = uint256(next_item(self.data, bytes32(_current_item)));\r\n  }\r\n\r\n  function find(Address storage self, address _item)\r\n           public\r\n           constant\r\n           returns (uint256 _item_index)\r\n  {\r\n    _item_index = find(self.data, bytes32(_item));\r\n  }\r\n\r\n  function get(Address storage self, uint256 _item_index)\r\n           public\r\n           constant\r\n           returns (address _item)\r\n  {\r\n    _item = address(get(self.data, _item_index));\r\n  }\r\n\r\n\r\n  function find(IndexedUint storage self, bytes32 _collection_index, uint256 _item)\r\n           public\r\n           constant\r\n           returns (uint256 _item_index)\r\n  {\r\n    _item_index = find(self.data[_collection_index], bytes32(_item));\r\n  }\r\n\r\n  function get(IndexedUint storage self, bytes32 _collection_index, uint256 _item_index)\r\n           public\r\n           constant\r\n           returns (uint256 _item)\r\n  {\r\n    _item = uint256(get(self.data[_collection_index], _item_index));\r\n  }\r\n\r\n\r\n  function append(IndexedUint storage self, bytes32 _collection_index, uint256 _data)\r\n           public\r\n           returns (bool _success)\r\n  {\r\n    _success = append(self.data[_collection_index], bytes32(_data));\r\n  }\r\n\r\n  function remove(IndexedUint storage self, bytes32 _collection_index, uint256 _index)\r\n           internal\r\n           returns (bool _success)\r\n  {\r\n    _success = remove(self.data[_collection_index], _index);\r\n  }\r\n\r\n  function remove_item(IndexedUint storage self, bytes32 _collection_index, uint256 _item)\r\n           public\r\n           returns (bool _success)\r\n  {\r\n    _success = remove_item(self.data[_collection_index], bytes32(_item));\r\n  }\r\n\r\n  function total(IndexedUint storage self, bytes32 _collection_index)\r\n           public\r\n           constant\r\n           returns (uint256 _total_count)\r\n  {\r\n    _total_count = total(self.data[_collection_index]);\r\n  }\r\n\r\n  function start(IndexedUint storage self, bytes32 _collection_index)\r\n           public\r\n           constant\r\n           returns (uint256 _index)\r\n  {\r\n    _index = start(self.data[_collection_index]);\r\n  }\r\n\r\n  function start_item(IndexedUint storage self, bytes32 _collection_index)\r\n           public\r\n           constant\r\n           returns (uint256 _start_item)\r\n  {\r\n    _start_item = uint256(start_item(self.data[_collection_index]));\r\n  }\r\n\r\n\r\n  function end(IndexedUint storage self, bytes32 _collection_index)\r\n           public\r\n           constant\r\n           returns (uint256 _index)\r\n  {\r\n    _index = end(self.data[_collection_index]);\r\n  }\r\n\r\n  function end_item(IndexedUint storage self, bytes32 _collection_index)\r\n           public\r\n           constant\r\n           returns (uint256 _end_item)\r\n  {\r\n    _end_item = uint256(end_item(self.data[_collection_index]));\r\n  }\r\n\r\n  function valid(IndexedUint storage self, bytes32 _collection_index, uint256 _item_index)\r\n           public\r\n           constant\r\n           returns (bool _yes)\r\n  {\r\n    _yes = valid(self.data[_collection_index], _item_index);\r\n  }\r\n\r\n  function valid_item(IndexedUint storage self, bytes32 _collection_index, uint256 _item)\r\n           public\r\n           constant\r\n           returns (bool _yes)\r\n  {\r\n    _yes = valid_item(self.data[_collection_index], bytes32(_item));\r\n  }\r\n\r\n  function previous(IndexedUint storage self, bytes32 _collection_index, uint256 _current_index)\r\n           public\r\n           constant\r\n           returns (uint256 _previous_index)\r\n  {\r\n    _previous_index = previous(self.data[_collection_index], _current_index);\r\n  }\r\n\r\n  function previous_item(IndexedUint storage self, bytes32 _collection_index, uint256 _current_item)\r\n           public\r\n           constant\r\n           returns (uint256 _previous_item)\r\n  {\r\n    _previous_item = uint256(previous_item(self.data[_collection_index], bytes32(_current_item)));\r\n  }\r\n\r\n  function next(IndexedUint storage self, bytes32 _collection_index, uint256 _current_index)\r\n           public\r\n           constant\r\n           returns (uint256 _next_index)\r\n  {\r\n    _next_index = next(self.data[_collection_index], _current_index);\r\n  }\r\n\r\n  function next_item(IndexedUint storage self, bytes32 _collection_index, uint256 _current_item)\r\n           public\r\n           constant\r\n           returns (uint256 _next_item)\r\n  {\r\n    _next_item = uint256(next_item(self.data[_collection_index], bytes32(_current_item)));\r\n  }\r\n\r\n  function append(Address storage self, address _data)\r\n           public\r\n           returns (bool _success)\r\n  {\r\n    _success = append(self.data, bytes32(_data));\r\n  }\r\n\r\n  function remove(Address storage self, uint256 _index)\r\n           internal\r\n           returns (bool _success)\r\n  {\r\n    _success = remove(self.data, _index);\r\n  }\r\n\r\n\r\n  function remove_item(Address storage self, address _item)\r\n           public\r\n           returns (bool _success)\r\n  {\r\n    _success = remove_item(self.data, bytes32(_item));\r\n  }\r\n\r\n  function total(Address storage self)\r\n           public\r\n           constant\r\n           returns (uint256 _total_count)\r\n  {\r\n    _total_count = total(self.data);\r\n  }\r\n\r\n  function start(Address storage self)\r\n           public\r\n           constant\r\n           returns (uint256 _index)\r\n  {\r\n    _index = start(self.data);\r\n  }\r\n\r\n  function start_item(Address storage self)\r\n           public\r\n           constant\r\n           returns (address _start_item)\r\n  {\r\n    _start_item = address(start_item(self.data));\r\n  }\r\n\r\n\r\n  function end(Address storage self)\r\n           public\r\n           constant\r\n           returns (uint256 _index)\r\n  {\r\n    _index = end(self.data);\r\n  }\r\n\r\n  function end_item(Address storage self)\r\n           public\r\n           constant\r\n           returns (address _end_item)\r\n  {\r\n    _end_item = address(end_item(self.data));\r\n  }\r\n\r\n  function valid(Address storage self, uint256 _item_index)\r\n           public\r\n           constant\r\n           returns (bool _yes)\r\n  {\r\n    _yes = valid(self.data, _item_index);\r\n  }\r\n\r\n  function valid_item(Address storage self, address _item)\r\n           public\r\n           constant\r\n           returns (bool _yes)\r\n  {\r\n    _yes = valid_item(self.data, bytes32(_item));\r\n  }\r\n\r\n  function previous(Address storage self, uint256 _current_index)\r\n           public\r\n           constant\r\n           returns (uint256 _previous_index)\r\n  {\r\n    _previous_index = previous(self.data, _current_index);\r\n  }\r\n\r\n  function previous_item(Address storage self, address _current_item)\r\n           public\r\n           constant\r\n           returns (address _previous_item)\r\n  {\r\n    _previous_item = address(previous_item(self.data, bytes32(_current_item)));\r\n  }\r\n\r\n  function next(Address storage self, uint256 _current_index)\r\n           public\r\n           constant\r\n           returns (uint256 _next_index)\r\n  {\r\n    _next_index = next(self.data, _current_index);\r\n  }\r\n\r\n  function next_item(Address storage self, address _current_item)\r\n           public\r\n           constant\r\n           returns (address _next_item)\r\n  {\r\n    _next_item = address(next_item(self.data, bytes32(_current_item)));\r\n  }\r\n\r\n  function append(IndexedAddress storage self, bytes32 _collection_index, address _data)\r\n           public\r\n           returns (bool _success)\r\n  {\r\n    _success = append(self.data[_collection_index], bytes32(_data));\r\n  }\r\n\r\n  function remove(IndexedAddress storage self, bytes32 _collection_index, uint256 _index)\r\n           internal\r\n           returns (bool _success)\r\n  {\r\n    _success = remove(self.data[_collection_index], _index);\r\n  }\r\n\r\n\r\n  function remove_item(IndexedAddress storage self, bytes32 _collection_index, address _item)\r\n           public\r\n           returns (bool _success)\r\n  {\r\n    _success = remove_item(self.data[_collection_index], bytes32(_item));\r\n  }\r\n\r\n  function total(IndexedAddress storage self, bytes32 _collection_index)\r\n           public\r\n           constant\r\n           returns (uint256 _total_count)\r\n  {\r\n    _total_count = total(self.data[_collection_index]);\r\n  }\r\n\r\n  function start(IndexedAddress storage self, bytes32 _collection_index)\r\n           public\r\n           constant\r\n           returns (uint256 _index)\r\n  {\r\n    _index = start(self.data[_collection_index]);\r\n  }\r\n\r\n  function start_item(IndexedAddress storage self, bytes32 _collection_index)\r\n           public\r\n           constant\r\n           returns (address _start_item)\r\n  {\r\n    _start_item = address(start_item(self.data[_collection_index]));\r\n  }\r\n\r\n\r\n  function end(IndexedAddress storage self, bytes32 _collection_index)\r\n           public\r\n           constant\r\n           returns (uint256 _index)\r\n  {\r\n    _index = end(self.data[_collection_index]);\r\n  }\r\n\r\n  function end_item(IndexedAddress storage self, bytes32 _collection_index)\r\n           public\r\n           constant\r\n           returns (address _end_item)\r\n  {\r\n    _end_item = address(end_item(self.data[_collection_index]));\r\n  }\r\n\r\n  function valid(IndexedAddress storage self, bytes32 _collection_index, uint256 _item_index)\r\n           public\r\n           constant\r\n           returns (bool _yes)\r\n  {\r\n    _yes = valid(self.data[_collection_index], _item_index);\r\n  }\r\n\r\n  function valid_item(IndexedAddress storage self, bytes32 _collection_index, address _item)\r\n           public\r\n           constant\r\n           returns (bool _yes)\r\n  {\r\n    _yes = valid_item(self.data[_collection_index], bytes32(_item));\r\n  }\r\n\r\n  function previous(IndexedAddress storage self, bytes32 _collection_index, uint256 _current_index)\r\n           public\r\n           constant\r\n           returns (uint256 _previous_index)\r\n  {\r\n    _previous_index = previous(self.data[_collection_index], _current_index);\r\n  }\r\n\r\n  function previous_item(IndexedAddress storage self, bytes32 _collection_index, address _current_item)\r\n           public\r\n           constant\r\n           returns (address _previous_item)\r\n  {\r\n    _previous_item = address(previous_item(self.data[_collection_index], bytes32(_current_item)));\r\n  }\r\n\r\n  function next(IndexedAddress storage self, bytes32 _collection_index, uint256 _current_index)\r\n           public\r\n           constant\r\n           returns (uint256 _next_index)\r\n  {\r\n    _next_index = next(self.data[_collection_index], _current_index);\r\n  }\r\n\r\n  function next_item(IndexedAddress storage self, bytes32 _collection_index, address _current_item)\r\n           public\r\n           constant\r\n           returns (address _next_item)\r\n  {\r\n    _next_item = address(next_item(self.data[_collection_index], bytes32(_current_item)));\r\n  }\r\n\r\n\r\n  function find(Bytes storage self, bytes32 _item)\r\n           public\r\n           constant\r\n           returns (uint256 _item_index)\r\n  {\r\n    _item_index = find(self.data, _item);\r\n  }\r\n\r\n  function get(Bytes storage self, uint256 _item_index)\r\n           public\r\n           constant\r\n           returns (bytes32 _item)\r\n  {\r\n    _item = get(self.data, _item_index);\r\n  }\r\n\r\n\r\n  function append(Bytes storage self, bytes32 _data)\r\n           public\r\n           returns (bool _success)\r\n  {\r\n    _success = append(self.data, _data);\r\n  }\r\n\r\n  function remove(Bytes storage self, uint256 _index)\r\n           internal\r\n           returns (bool _success)\r\n  {\r\n    _success = remove(self.data, _index);\r\n  }\r\n\r\n\r\n  function remove_item(Bytes storage self, bytes32 _item)\r\n           public\r\n           returns (bool _success)\r\n  {\r\n    _success = remove_item(self.data, _item);\r\n  }\r\n\r\n  function total(Bytes storage self)\r\n           public\r\n           constant\r\n           returns (uint256 _total_count)\r\n  {\r\n    _total_count = total(self.data);\r\n  }\r\n\r\n  function start(Bytes storage self)\r\n           public\r\n           constant\r\n           returns (uint256 _index)\r\n  {\r\n    _index = start(self.data);\r\n  }\r\n\r\n  function start_item(Bytes storage self)\r\n           public\r\n           constant\r\n           returns (bytes32 _start_item)\r\n  {\r\n    _start_item = start_item(self.data);\r\n  }\r\n\r\n\r\n  function end(Bytes storage self)\r\n           public\r\n           constant\r\n           returns (uint256 _index)\r\n  {\r\n    _index = end(self.data);\r\n  }\r\n\r\n  function end_item(Bytes storage self)\r\n           public\r\n           constant\r\n           returns (bytes32 _end_item)\r\n  {\r\n    _end_item = end_item(self.data);\r\n  }\r\n\r\n  function valid(Bytes storage self, uint256 _item_index)\r\n           public\r\n           constant\r\n           returns (bool _yes)\r\n  {\r\n    _yes = valid(self.data, _item_index);\r\n  }\r\n\r\n  function valid_item(Bytes storage self, bytes32 _item)\r\n           public\r\n           constant\r\n           returns (bool _yes)\r\n  {\r\n    _yes = valid_item(self.data, _item);\r\n  }\r\n\r\n  function previous(Bytes storage self, uint256 _current_index)\r\n           public\r\n           constant\r\n           returns (uint256 _previous_index)\r\n  {\r\n    _previous_index = previous(self.data, _current_index);\r\n  }\r\n\r\n  function previous_item(Bytes storage self, bytes32 _current_item)\r\n           public\r\n           constant\r\n           returns (bytes32 _previous_item)\r\n  {\r\n    _previous_item = previous_item(self.data, _current_item);\r\n  }\r\n\r\n  function next(Bytes storage self, uint256 _current_index)\r\n           public\r\n           constant\r\n           returns (uint256 _next_index)\r\n  {\r\n    _next_index = next(self.data, _current_index);\r\n  }\r\n\r\n  function next_item(Bytes storage self, bytes32 _current_item)\r\n           public\r\n           constant\r\n           returns (bytes32 _next_item)\r\n  {\r\n    _next_item = next_item(self.data, _current_item);\r\n  }\r\n\r\n  function append(IndexedBytes storage self, bytes32 _collection_index, bytes32 _data)\r\n           public\r\n           returns (bool _success)\r\n  {\r\n    _success = append(self.data[_collection_index], bytes32(_data));\r\n  }\r\n\r\n  function remove(IndexedBytes storage self, bytes32 _collection_index, uint256 _index)\r\n           internal\r\n           returns (bool _success)\r\n  {\r\n    _success = remove(self.data[_collection_index], _index);\r\n  }\r\n\r\n\r\n  function remove_item(IndexedBytes storage self, bytes32 _collection_index, bytes32 _item)\r\n           public\r\n           returns (bool _success)\r\n  {\r\n    _success = remove_item(self.data[_collection_index], bytes32(_item));\r\n  }\r\n\r\n  function total(IndexedBytes storage self, bytes32 _collection_index)\r\n           public\r\n           constant\r\n           returns (uint256 _total_count)\r\n  {\r\n    _total_count = total(self.data[_collection_index]);\r\n  }\r\n\r\n  function start(IndexedBytes storage self, bytes32 _collection_index)\r\n           public\r\n           constant\r\n           returns (uint256 _index)\r\n  {\r\n    _index = start(self.data[_collection_index]);\r\n  }\r\n\r\n  function start_item(IndexedBytes storage self, bytes32 _collection_index)\r\n           public\r\n           constant\r\n           returns (bytes32 _start_item)\r\n  {\r\n    _start_item = bytes32(start_item(self.data[_collection_index]));\r\n  }\r\n\r\n\r\n  function end(IndexedBytes storage self, bytes32 _collection_index)\r\n           public\r\n           constant\r\n           returns (uint256 _index)\r\n  {\r\n    _index = end(self.data[_collection_index]);\r\n  }\r\n\r\n  function end_item(IndexedBytes storage self, bytes32 _collection_index)\r\n           public\r\n           constant\r\n           returns (bytes32 _end_item)\r\n  {\r\n    _end_item = bytes32(end_item(self.data[_collection_index]));\r\n  }\r\n\r\n  function valid(IndexedBytes storage self, bytes32 _collection_index, uint256 _item_index)\r\n           public\r\n           constant\r\n           returns (bool _yes)\r\n  {\r\n    _yes = valid(self.data[_collection_index], _item_index);\r\n  }\r\n\r\n  function valid_item(IndexedBytes storage self, bytes32 _collection_index, bytes32 _item)\r\n           public\r\n           constant\r\n           returns (bool _yes)\r\n  {\r\n    _yes = valid_item(self.data[_collection_index], bytes32(_item));\r\n  }\r\n\r\n  function previous(IndexedBytes storage self, bytes32 _collection_index, uint256 _current_index)\r\n           public\r\n           constant\r\n           returns (uint256 _previous_index)\r\n  {\r\n    _previous_index = previous(self.data[_collection_index], _current_index);\r\n  }\r\n\r\n  function previous_item(IndexedBytes storage self, bytes32 _collection_index, bytes32 _current_item)\r\n           public\r\n           constant\r\n           returns (bytes32 _previous_item)\r\n  {\r\n    _previous_item = bytes32(previous_item(self.data[_collection_index], bytes32(_current_item)));\r\n  }\r\n\r\n  function next(IndexedBytes storage self, bytes32 _collection_index, uint256 _current_index)\r\n           public\r\n           constant\r\n           returns (uint256 _next_index)\r\n  {\r\n    _next_index = next(self.data[_collection_index], _current_index);\r\n  }\r\n\r\n  function next_item(IndexedBytes storage self, bytes32 _collection_index, bytes32 _current_item)\r\n           public\r\n           constant\r\n           returns (bytes32 _next_item)\r\n  {\r\n    _next_item = bytes32(next_item(self.data[_collection_index], bytes32(_current_item)));\r\n  }\r\n}\r\n\r\n// File: @digix/solidity-collections/contracts/abstract/IndexedAddressIteratorStorage.sol\r\n/**\r\n  @title Indexed Address IteratorStorage\r\n  @author DigixGlobal Pte Ltd\r\n  @notice This contract utilizes: [Doubly Linked List](/DoublyLinkedList)\r\n*/\r\ncontract IndexedAddressIteratorStorage {\r\n\r\n  using DoublyLinkedList for DoublyLinkedList.IndexedAddress;\r\n  /**\r\n    @notice Reads the first item from an Indexed Address Doubly Linked List\r\n    @param _list The source list\r\n    @param _collection_index Index of the Collection to evaluate\r\n    @return {\"_item\" : \"First item on the list\"}\r\n  */\r\n  function read_first_from_indexed_addresses(DoublyLinkedList.IndexedAddress storage _list, bytes32 _collection_index)\r\n           internal\r\n           constant\r\n           returns (address _item)\r\n  {\r\n    _item = _list.start_item(_collection_index);\r\n  }\r\n\r\n  /**\r\n    @notice Reads the last item from an Indexed Address Doubly Linked list\r\n    @param _list The source list\r\n    @param _collection_index Index of the Collection to evaluate\r\n    @return {\"_item\" : \"First item on the list\"}\r\n  */\r\n  function read_last_from_indexed_addresses(DoublyLinkedList.IndexedAddress storage _list, bytes32 _collection_index)\r\n           internal\r\n           constant\r\n           returns (address _item)\r\n  {\r\n    _item = _list.end_item(_collection_index);\r\n  }\r\n\r\n  /**\r\n    @notice Reads the next item from an Indexed Address Doubly Linked List based on the specified `_current_item`\r\n    @param _list The source list\r\n    @param _collection_index Index of the Collection to evaluate\r\n    @param _current_item The current item to use as base line\r\n    @return {\"_item\": \"The next item on the list\"}\r\n  */\r\n  function read_next_from_indexed_addresses(DoublyLinkedList.IndexedAddress storage _list, bytes32 _collection_index, address _current_item)\r\n           internal\r\n           constant\r\n           returns (address _item)\r\n  {\r\n    _item = _list.next_item(_collection_index, _current_item);\r\n  }\r\n\r\n  /**\r\n    @notice Reads the previous item from an Index Address Doubly Linked List based on the specified `_current_item`\r\n    @param _list The source list\r\n    @param _collection_index Index of the Collection to evaluate\r\n    @param _current_item The current item to use as base line\r\n    @return {\"_item\" : \"The previous item on the list\"}\r\n  */\r\n  function read_previous_from_indexed_addresses(DoublyLinkedList.IndexedAddress storage _list, bytes32 _collection_index, address _current_item)\r\n           internal\r\n           constant\r\n           returns (address _item)\r\n  {\r\n    _item = _list.previous_item(_collection_index, _current_item);\r\n  }\r\n\r\n\r\n  /**\r\n    @notice Reads the total number of items in an Indexed Address Doubly Linked List\r\n    @param _list  The source list\r\n    @param _collection_index Index of the Collection to evaluate\r\n    @return {\"_count\": \"Length of the Doubly Linked list\"}\r\n  */\r\n  function read_total_indexed_addresses(DoublyLinkedList.IndexedAddress storage _list, bytes32 _collection_index)\r\n           internal\r\n           constant\r\n           returns (uint256 _count)\r\n  {\r\n    _count = _list.total(_collection_index);\r\n  }\r\n}\r\n\r\n// File: @digix/solidity-collections/contracts/abstract/UintIteratorStorage.sol\r\n/**\r\n  @title Uint Iterator Storage\r\n  @author DigixGlobal Pte Ltd\r\n*/\r\ncontract UintIteratorStorage {\r\n\r\n  using DoublyLinkedList for DoublyLinkedList.Uint;\r\n\r\n  /**\r\n    @notice Returns the first item from a `DoublyLinkedList.Uint` list\r\n    @param _list The DoublyLinkedList.Uint list\r\n    @return {\"_item\": \"The first item\"}\r\n  */\r\n  function read_first_from_uints(DoublyLinkedList.Uint storage _list)\r\n           internal\r\n           constant\r\n           returns (uint256 _item)\r\n  {\r\n    _item = _list.start_item();\r\n  }\r\n\r\n  /**\r\n    @notice Returns the last item from a `DoublyLinkedList.Uint` list\r\n    @param _list The DoublyLinkedList.Uint list\r\n    @return {\"_item\": \"The last item\"}\r\n  */\r\n  function read_last_from_uints(DoublyLinkedList.Uint storage _list)\r\n           internal\r\n           constant\r\n           returns (uint256 _item)\r\n  {\r\n    _item = _list.end_item();\r\n  }\r\n\r\n  /**\r\n    @notice Returns the next item from a `DoublyLinkedList.Uint` list based on the specified `_current_item`\r\n    @param _list The DoublyLinkedList.Uint list\r\n    @param _current_item The current item\r\n    @return {\"_item\": \"The next item\"}\r\n  */\r\n  function read_next_from_uints(DoublyLinkedList.Uint storage _list, uint256 _current_item)\r\n           internal\r\n           constant\r\n           returns (uint256 _item)\r\n  {\r\n    _item = _list.next_item(_current_item);\r\n  }\r\n\r\n  /**\r\n    @notice Returns the previous item from a `DoublyLinkedList.Uint` list based on the specified `_current_item`\r\n    @param _list The DoublyLinkedList.Uint list\r\n    @param _current_item The current item\r\n    @return {\"_item\": \"The previous item\"}\r\n  */\r\n  function read_previous_from_uints(DoublyLinkedList.Uint storage _list, uint256 _current_item)\r\n           internal\r\n           constant\r\n           returns (uint256 _item)\r\n  {\r\n    _item = _list.previous_item(_current_item);\r\n  }\r\n\r\n  /**\r\n    @notice Returns the total count of itemsfrom a `DoublyLinkedList.Uint` list\r\n    @param _list The DoublyLinkedList.Uint list\r\n    @return {\"_count\": \"The total count of items\"}\r\n  */\r\n  function read_total_uints(DoublyLinkedList.Uint storage _list)\r\n           internal\r\n           constant\r\n           returns (uint256 _count)\r\n  {\r\n    _count = _list.total();\r\n  }\r\n}\r\n\r\n// File: @digix/cdap/contracts/storage/DirectoryStorage.sol\r\n/**\r\n@title Directory Storage contains information of a directory\r\n@author DigixGlobal\r\n*/\r\ncontract DirectoryStorage is IndexedAddressIteratorStorage, UintIteratorStorage {\r\n\r\n  using DoublyLinkedList for DoublyLinkedList.IndexedAddress;\r\n  using DoublyLinkedList for DoublyLinkedList.Uint;\r\n\r\n  struct User {\r\n    bytes32 document;\r\n    bool active;\r\n  }\r\n\r\n  struct Group {\r\n    bytes32 name;\r\n    bytes32 document;\r\n    uint256 role_id;\r\n    mapping(address => User) members_by_address;\r\n  }\r\n\r\n  struct System {\r\n    DoublyLinkedList.Uint groups;\r\n    DoublyLinkedList.IndexedAddress groups_collection;\r\n    mapping (uint256 => Group) groups_by_id;\r\n    mapping (address => uint256) group_ids_by_address;\r\n    mapping (uint256 => bytes32) roles_by_id;\r\n    bool initialized;\r\n    uint256 total_groups;\r\n  }\r\n\r\n  System system;\r\n\r\n  /**\r\n  @notice Initializes directory settings\r\n  @return _success If directory initialization is successful\r\n  */\r\n  function initialize_directory()\r\n           internal\r\n           returns (bool _success)\r\n  {\r\n    require(system.initialized == false);\r\n    system.total_groups = 0;\r\n    system.initialized = true;\r\n    internal_create_role(1, \"root\");\r\n    internal_create_group(1, \"root\", \"\");\r\n    _success = internal_update_add_user_to_group(1, tx.origin, \"\");\r\n  }\r\n\r\n  /**\r\n  @notice Creates a new role with the given information\r\n  @param _role_id Id of the new role\r\n  @param _name Name of the new role\r\n  @return {\"_success\": \"If creation of new role is successful\"}\r\n  */\r\n  function internal_create_role(uint256 _role_id, bytes32 _name)\r\n           internal\r\n           returns (bool _success)\r\n  {\r\n    require(_role_id > 0);\r\n    require(_name != bytes32(0x0));\r\n    system.roles_by_id[_role_id] = _name;\r\n    _success = true;\r\n  }\r\n\r\n  /**\r\n  @notice Returns the role's name of a role id\r\n  @param _role_id Id of the role\r\n  @return {\"_name\": \"Name of the role\"}\r\n  */\r\n  function read_role(uint256 _role_id)\r\n           public\r\n           constant\r\n           returns (bytes32 _name)\r\n  {\r\n    _name = system.roles_by_id[_role_id];\r\n  }\r\n\r\n  /**\r\n  @notice Creates a new group with the given information\r\n  @param _role_id Role id of the new group\r\n  @param _name Name of the new group\r\n  @param _document Document of the new group\r\n  @return {\r\n    \"_success\": \"If creation of the new group is successful\",\r\n    \"_group_id: \"Id of the new group\"\r\n  }\r\n  */\r\n  function internal_create_group(uint256 _role_id, bytes32 _name, bytes32 _document)\r\n           internal\r\n           returns (bool _success, uint256 _group_id)\r\n  {\r\n    require(_role_id > 0);\r\n    require(read_role(_role_id) != bytes32(0x0));\r\n    _group_id = ++system.total_groups;\r\n    system.groups.append(_group_id);\r\n    system.groups_by_id[_group_id].role_id = _role_id;\r\n    system.groups_by_id[_group_id].name = _name;\r\n    system.groups_by_id[_group_id].document = _document;\r\n    _success = true;\r\n  }\r\n\r\n  /**\r\n  @notice Returns the group's information\r\n  @param _group_id Id of the group\r\n  @return {\r\n    \"_role_id\": \"Role id of the group\",\r\n    \"_name: \"Name of the group\",\r\n    \"_document: \"Document of the group\"\r\n  }\r\n  */\r\n  function read_group(uint256 _group_id)\r\n           public\r\n           constant\r\n           returns (uint256 _role_id, bytes32 _name, bytes32 _document, uint256 _members_count)\r\n  {\r\n    if (system.groups.valid_item(_group_id)) {\r\n      _role_id = system.groups_by_id[_group_id].role_id;\r\n      _name = system.groups_by_id[_group_id].name;\r\n      _document = system.groups_by_id[_group_id].document;\r\n      _members_count = read_total_indexed_addresses(system.groups_collection, bytes32(_group_id));\r\n    } else {\r\n      _role_id = 0;\r\n      _name = \"invalid\";\r\n      _document = \"\";\r\n      _members_count = 0;\r\n    }\r\n  }\r\n\r\n  /**\r\n  @notice Adds new user with the given information to a group\r\n  @param _group_id Id of the group\r\n  @param _user Address of the new user\r\n  @param _document Information of the new user\r\n  @return {\"_success\": \"If adding new user to a group is successful\"}\r\n  */\r\n  function internal_update_add_user_to_group(uint256 _group_id, address _user, bytes32 _document)\r\n           internal\r\n           returns (bool _success)\r\n  {\r\n    if (system.groups_by_id[_group_id].members_by_address[_user].active == false && system.group_ids_by_address[_user] == 0 && system.groups_by_id[_group_id].role_id != 0) {\r\n\r\n      system.groups_by_id[_group_id].members_by_address[_user].active = true;\r\n      system.group_ids_by_address[_user] = _group_id;\r\n      system.groups_collection.append(bytes32(_group_id), _user);\r\n      system.groups_by_id[_group_id].members_by_address[_user].document = _document;\r\n      _success = true;\r\n    } else {\r\n      _success = false;\r\n    }\r\n  }\r\n\r\n  /**\r\n  @notice Removes user from its group\r\n  @param _user Address of the user\r\n  @return {\"_success\": \"If removing of user is successful\"}\r\n  */\r\n  function internal_destroy_group_user(address _user)\r\n           internal\r\n           returns (bool _success)\r\n  {\r\n    uint256 _group_id = system.group_ids_by_address[_user];\r\n    if ((_group_id == 1) && (system.groups_collection.total(bytes32(_group_id)) == 1)) {\r\n      _success = false;\r\n    } else {\r\n      system.groups_by_id[_group_id].members_by_address[_user].active = false;\r\n      system.group_ids_by_address[_user] = 0;\r\n      delete system.groups_by_id[_group_id].members_by_address[_user];\r\n      _success = system.groups_collection.remove_item(bytes32(_group_id), _user);\r\n    }\r\n  }\r\n\r\n  /**\r\n  @notice Returns the role id of a user\r\n  @param _user Address of a user\r\n  @return {\"_role_id\": \"Role id of the user\"}\r\n  */\r\n  function read_user_role_id(address _user)\r\n           constant\r\n           public\r\n           returns (uint256 _role_id)\r\n  {\r\n    uint256 _group_id = system.group_ids_by_address[_user];\r\n    _role_id = system.groups_by_id[_group_id].role_id;\r\n  }\r\n\r\n  /**\r\n  @notice Returns the user's information\r\n  @param _user Address of the user\r\n  @return {\r\n    \"_group_id\": \"Group id of the user\",\r\n    \"_role_id\": \"Role id of the user\",\r\n    \"_document\": \"Information of the user\"\r\n  }\r\n  */\r\n  function read_user(address _user)\r\n           public\r\n           constant\r\n           returns (uint256 _group_id, uint256 _role_id, bytes32 _document)\r\n  {\r\n    _group_id = system.group_ids_by_address[_user];\r\n    _role_id = system.groups_by_id[_group_id].role_id;\r\n    _document = system.groups_by_id[_group_id].members_by_address[_user].document;\r\n  }\r\n\r\n  /**\r\n  @notice Returns the id of the first group\r\n  @return {\"_group_id\": \"Id of the first group\"}\r\n  */\r\n  function read_first_group()\r\n           view\r\n           external\r\n           returns (uint256 _group_id)\r\n  {\r\n    _group_id = read_first_from_uints(system.groups);\r\n  }\r\n\r\n  /**\r\n  @notice Returns the id of the last group\r\n  @return {\"_group_id\": \"Id of the last group\"}\r\n  */\r\n  function read_last_group()\r\n           view\r\n           external\r\n           returns (uint256 _group_id)\r\n  {\r\n    _group_id = read_last_from_uints(system.groups);\r\n  }\r\n\r\n  /**\r\n  @notice Returns the id of the previous group depending on the given current group\r\n  @param _current_group_id Id of the current group\r\n  @return {\"_group_id\": \"Id of the previous group\"}\r\n  */\r\n  function read_previous_group_from_group(uint256 _current_group_id)\r\n           view\r\n           external\r\n           returns (uint256 _group_id)\r\n  {\r\n    _group_id = read_previous_from_uints(system.groups, _current_group_id);\r\n  }\r\n\r\n  /**\r\n  @notice Returns the id of the next group depending on the given current group\r\n  @param _current_group_id Id of the current group\r\n  @return {\"_group_id\": \"Id of the next group\"}\r\n  */\r\n  function read_next_group_from_group(uint256 _current_group_id)\r\n           view\r\n           external\r\n           returns (uint256 _group_id)\r\n  {\r\n    _group_id = read_next_from_uints(system.groups, _current_group_id);\r\n  }\r\n\r\n  /**\r\n  @notice Returns the total number of groups\r\n  @return {\"_total_groups\": \"Total number of groups\"}\r\n  */\r\n  function read_total_groups()\r\n           view\r\n           external\r\n           returns (uint256 _total_groups)\r\n  {\r\n    _total_groups = read_total_uints(system.groups);\r\n  }\r\n\r\n  /**\r\n  @notice Returns the first user of a group\r\n  @param _group_id Id of the group\r\n  @return {\"_user\": \"Address of the user\"}\r\n  */\r\n  function read_first_user_in_group(bytes32 _group_id)\r\n           view\r\n           external\r\n           returns (address _user)\r\n  {\r\n    _user = read_first_from_indexed_addresses(system.groups_collection, bytes32(_group_id));\r\n  }\r\n\r\n  /**\r\n  @notice Returns the last user of a group\r\n  @param _group_id Id of the group\r\n  @return {\"_user\": \"Address of the user\"}\r\n  */\r\n  function read_last_user_in_group(bytes32 _group_id)\r\n           view\r\n           external\r\n           returns (address _user)\r\n  {\r\n    _user = read_last_from_indexed_addresses(system.groups_collection, bytes32(_group_id));\r\n  }\r\n\r\n  /**\r\n  @notice Returns the next user of a group depending on the given current user\r\n  @param _group_id Id of the group\r\n  @param _current_user Address of the current user\r\n  @return {\"_user\": \"Address of the next user\"}\r\n  */\r\n  function read_next_user_in_group(bytes32 _group_id, address _current_user)\r\n           view\r\n           external\r\n           returns (address _user)\r\n  {\r\n    _user = read_next_from_indexed_addresses(system.groups_collection, bytes32(_group_id), _current_user);\r\n  }\r\n\r\n  /**\r\n  @notice Returns the previous user of a group depending on the given current user\r\n  @param _group_id Id of the group\r\n  @param _current_user Address of the current user\r\n  @return {\"_user\": \"Address of the last user\"}\r\n  */\r\n  function read_previous_user_in_group(bytes32 _group_id, address _current_user)\r\n           view\r\n           external\r\n           returns (address _user)\r\n  {\r\n    _user = read_previous_from_indexed_addresses(system.groups_collection, bytes32(_group_id), _current_user);\r\n  }\r\n\r\n  /**\r\n  @notice Returns the total number of users of a group\r\n  @param _group_id Id of the group\r\n  @return {\"_total_users\": \"Total number of users\"}\r\n  */\r\n  function read_total_users_in_group(bytes32 _group_id)\r\n           view\r\n           external\r\n           returns (uint256 _total_users)\r\n  {\r\n    _total_users = read_total_indexed_addresses(system.groups_collection, bytes32(_group_id));\r\n  }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/math/SafeMath.sol\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\r\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (_a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    c = _a * _b;\r\n    assert(c / _a == _b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    // assert(_b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = _a / _b;\r\n    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\r\n    return _a / _b;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    assert(_b <= _a);\r\n    return _a - _b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\r\n    c = _a + _b;\r\n    assert(c >= _a);\r\n    return c;\r\n  }\r\n}\r\n\r\n// File: contracts/common/DaoConstants.sol\r\ncontract DaoConstants {\r\n    using SafeMath for uint256;\r\n    bytes32 EMPTY_BYTES = bytes32(0x0);\r\n    address EMPTY_ADDRESS = address(0x0);\r\n\r\n\r\n    bytes32 PROPOSAL_STATE_PREPROPOSAL = \"proposal_state_preproposal\";\r\n    bytes32 PROPOSAL_STATE_DRAFT = \"proposal_state_draft\";\r\n    bytes32 PROPOSAL_STATE_MODERATED = \"proposal_state_moderated\";\r\n    bytes32 PROPOSAL_STATE_ONGOING = \"proposal_state_ongoing\";\r\n    bytes32 PROPOSAL_STATE_CLOSED = \"proposal_state_closed\";\r\n    bytes32 PROPOSAL_STATE_ARCHIVED = \"proposal_state_archived\";\r\n\r\n    uint256 PRL_ACTION_STOP = 1;\r\n    uint256 PRL_ACTION_PAUSE = 2;\r\n    uint256 PRL_ACTION_UNPAUSE = 3;\r\n\r\n    uint256 COLLATERAL_STATUS_UNLOCKED = 1;\r\n    uint256 COLLATERAL_STATUS_LOCKED = 2;\r\n    uint256 COLLATERAL_STATUS_CLAIMED = 3;\r\n\r\n    bytes32 INTERMEDIATE_DGD_IDENTIFIER = \"inter_dgd_id\";\r\n    bytes32 INTERMEDIATE_MODERATOR_DGD_IDENTIFIER = \"inter_mod_dgd_id\";\r\n    bytes32 INTERMEDIATE_BONUS_CALCULATION_IDENTIFIER = \"inter_bonus_calculation_id\";\r\n\r\n    // interactive contracts\r\n    bytes32 CONTRACT_DAO = \"dao\";\r\n    bytes32 CONTRACT_DAO_SPECIAL_PROPOSAL = \"dao:special:proposal\";\r\n    bytes32 CONTRACT_DAO_STAKE_LOCKING = \"dao:stake-locking\";\r\n    bytes32 CONTRACT_DAO_VOTING = \"dao:voting\";\r\n    bytes32 CONTRACT_DAO_VOTING_CLAIMS = \"dao:voting:claims\";\r\n    bytes32 CONTRACT_DAO_SPECIAL_VOTING_CLAIMS = \"dao:svoting:claims\";\r\n    bytes32 CONTRACT_DAO_IDENTITY = \"dao:identity\";\r\n    bytes32 CONTRACT_DAO_REWARDS_MANAGER = \"dao:rewards-manager\";\r\n    bytes32 CONTRACT_DAO_REWARDS_MANAGER_EXTRAS = \"dao:rewards-extras\";\r\n    bytes32 CONTRACT_DAO_ROLES = \"dao:roles\";\r\n    bytes32 CONTRACT_DAO_FUNDING_MANAGER = \"dao:funding-manager\";\r\n    bytes32 CONTRACT_DAO_WHITELISTING = \"dao:whitelisting\";\r\n    bytes32 CONTRACT_DAO_INFORMATION = \"dao:information\";\r\n\r\n    // service contracts\r\n    bytes32 CONTRACT_SERVICE_ROLE = \"service:role\";\r\n    bytes32 CONTRACT_SERVICE_DAO_INFO = \"service:dao:info\";\r\n    bytes32 CONTRACT_SERVICE_DAO_LISTING = \"service:dao:listing\";\r\n    bytes32 CONTRACT_SERVICE_DAO_CALCULATOR = \"service:dao:calculator\";\r\n\r\n    // storage contracts\r\n    bytes32 CONTRACT_STORAGE_DAO = \"storage:dao\";\r\n    bytes32 CONTRACT_STORAGE_DAO_COUNTER = \"storage:dao:counter\";\r\n    bytes32 CONTRACT_STORAGE_DAO_UPGRADE = \"storage:dao:upgrade\";\r\n    bytes32 CONTRACT_STORAGE_DAO_IDENTITY = \"storage:dao:identity\";\r\n    bytes32 CONTRACT_STORAGE_DAO_POINTS = \"storage:dao:points\";\r\n    bytes32 CONTRACT_STORAGE_DAO_SPECIAL = \"storage:dao:special\";\r\n    bytes32 CONTRACT_STORAGE_DAO_CONFIG = \"storage:dao:config\";\r\n    bytes32 CONTRACT_STORAGE_DAO_STAKE = \"storage:dao:stake\";\r\n    bytes32 CONTRACT_STORAGE_DAO_REWARDS = \"storage:dao:rewards\";\r\n    bytes32 CONTRACT_STORAGE_DAO_WHITELISTING = \"storage:dao:whitelisting\";\r\n    bytes32 CONTRACT_STORAGE_INTERMEDIATE_RESULTS = \"storage:intermediate:results\";\r\n\r\n    bytes32 CONTRACT_DGD_TOKEN = \"t:dgd\";\r\n    bytes32 CONTRACT_DGX_TOKEN = \"t:dgx\";\r\n    bytes32 CONTRACT_BADGE_TOKEN = \"t:badge\";\r\n\r\n    uint8 ROLES_ROOT = 1;\r\n    uint8 ROLES_FOUNDERS = 2;\r\n    uint8 ROLES_PRLS = 3;\r\n    uint8 ROLES_KYC_ADMINS = 4;\r\n\r\n    uint256 QUARTER_DURATION = 90 days;\r\n\r\n    bytes32 CONFIG_MINIMUM_LOCKED_DGD = \"min_dgd_participant\";\r\n    bytes32 CONFIG_MINIMUM_DGD_FOR_MODERATOR = \"min_dgd_moderator\";\r\n    bytes32 CONFIG_MINIMUM_REPUTATION_FOR_MODERATOR = \"min_reputation_moderator\";\r\n\r\n    bytes32 CONFIG_LOCKING_PHASE_DURATION = \"locking_phase_duration\";\r\n    bytes32 CONFIG_QUARTER_DURATION = \"quarter_duration\";\r\n    bytes32 CONFIG_VOTING_COMMIT_PHASE = \"voting_commit_phase\";\r\n    bytes32 CONFIG_VOTING_PHASE_TOTAL = \"voting_phase_total\";\r\n    bytes32 CONFIG_INTERIM_COMMIT_PHASE = \"interim_voting_commit_phase\";\r\n    bytes32 CONFIG_INTERIM_PHASE_TOTAL = \"interim_voting_phase_total\";\r\n\r\n    bytes32 CONFIG_DRAFT_QUORUM_FIXED_PORTION_NUMERATOR = \"draft_quorum_fixed_numerator\";\r\n    bytes32 CONFIG_DRAFT_QUORUM_FIXED_PORTION_DENOMINATOR = \"draft_quorum_fixed_denominator\";\r\n    bytes32 CONFIG_DRAFT_QUORUM_SCALING_FACTOR_NUMERATOR = \"draft_quorum_sfactor_numerator\";\r\n    bytes32 CONFIG_DRAFT_QUORUM_SCALING_FACTOR_DENOMINATOR = \"draft_quorum_sfactor_denominator\";\r\n    bytes32 CONFIG_VOTING_QUORUM_FIXED_PORTION_NUMERATOR = \"vote_quorum_fixed_numerator\";\r\n    bytes32 CONFIG_VOTING_QUORUM_FIXED_PORTION_DENOMINATOR = \"vote_quorum_fixed_denominator\";\r\n    bytes32 CONFIG_VOTING_QUORUM_SCALING_FACTOR_NUMERATOR = \"vote_quorum_sfactor_numerator\";\r\n    bytes32 CONFIG_VOTING_QUORUM_SCALING_FACTOR_DENOMINATOR = \"vote_quorum_sfactor_denominator\";\r\n    bytes32 CONFIG_FINAL_REWARD_SCALING_FACTOR_NUMERATOR = \"final_reward_sfactor_numerator\";\r\n    bytes32 CONFIG_FINAL_REWARD_SCALING_FACTOR_DENOMINATOR = \"final_reward_sfactor_denominator\";\r\n\r\n    bytes32 CONFIG_DRAFT_QUOTA_NUMERATOR = \"draft_quota_numerator\";\r\n    bytes32 CONFIG_DRAFT_QUOTA_DENOMINATOR = \"draft_quota_denominator\";\r\n    bytes32 CONFIG_VOTING_QUOTA_NUMERATOR = \"voting_quota_numerator\";\r\n    bytes32 CONFIG_VOTING_QUOTA_DENOMINATOR = \"voting_quota_denominator\";\r\n\r\n    bytes32 CONFIG_MINIMAL_QUARTER_POINT = \"minimal_qp\";\r\n    bytes32 CONFIG_QUARTER_POINT_SCALING_FACTOR = \"quarter_point_scaling_factor\";\r\n    bytes32 CONFIG_REPUTATION_POINT_SCALING_FACTOR = \"rep_point_scaling_factor\";\r\n\r\n    bytes32 CONFIG_MODERATOR_MINIMAL_QUARTER_POINT = \"minimal_mod_qp\";\r\n    bytes32 CONFIG_MODERATOR_QUARTER_POINT_SCALING_FACTOR = \"mod_qp_scaling_factor\";\r\n    bytes32 CONFIG_MODERATOR_REPUTATION_POINT_SCALING_FACTOR = \"mod_rep_point_scaling_factor\";\r\n\r\n    bytes32 CONFIG_QUARTER_POINT_DRAFT_VOTE = \"quarter_point_draft_vote\";\r\n    bytes32 CONFIG_QUARTER_POINT_VOTE = \"quarter_point_vote\";\r\n    bytes32 CONFIG_QUARTER_POINT_INTERIM_VOTE = \"quarter_point_interim_vote\";\r\n\r\n    /// this is per 10000 ETHs\r\n    bytes32 CONFIG_QUARTER_POINT_MILESTONE_COMPLETION_PER_10000ETH = \"q_p_milestone_completion\";\r\n\r\n    bytes32 CONFIG_BONUS_REPUTATION_NUMERATOR = \"bonus_reputation_numerator\";\r\n    bytes32 CONFIG_BONUS_REPUTATION_DENOMINATOR = \"bonus_reputation_denominator\";\r\n\r\n    bytes32 CONFIG_SPECIAL_PROPOSAL_COMMIT_PHASE = \"special_proposal_commit_phase\";\r\n    bytes32 CONFIG_SPECIAL_PROPOSAL_PHASE_TOTAL = \"special_proposal_phase_total\";\r\n\r\n    bytes32 CONFIG_SPECIAL_QUOTA_NUMERATOR = \"config_special_quota_numerator\";\r\n    bytes32 CONFIG_SPECIAL_QUOTA_DENOMINATOR = \"config_special_quota_denominator\";\r\n\r\n    bytes32 CONFIG_SPECIAL_PROPOSAL_QUORUM_NUMERATOR = \"special_quorum_numerator\";\r\n    bytes32 CONFIG_SPECIAL_PROPOSAL_QUORUM_DENOMINATOR = \"special_quorum_denominator\";\r\n\r\n    bytes32 CONFIG_MAXIMUM_REPUTATION_DEDUCTION = \"config_max_reputation_deduction\";\r\n    bytes32 CONFIG_PUNISHMENT_FOR_NOT_LOCKING = \"config_punishment_not_locking\";\r\n\r\n    bytes32 CONFIG_REPUTATION_PER_EXTRA_QP_NUM = \"config_rep_per_extra_qp_num\";\r\n    bytes32 CONFIG_REPUTATION_PER_EXTRA_QP_DEN = \"config_rep_per_extra_qp_den\";\r\n\r\n    bytes32 CONFIG_MAXIMUM_MODERATOR_REPUTATION_DEDUCTION = \"config_max_m_rp_deduction\";\r\n    bytes32 CONFIG_REPUTATION_PER_EXTRA_MODERATOR_QP_NUM = \"config_rep_per_extra_m_qp_num\";\r\n    bytes32 CONFIG_REPUTATION_PER_EXTRA_MODERATOR_QP_DEN = \"config_rep_per_extra_m_qp_den\";\r\n\r\n    bytes32 CONFIG_PORTION_TO_MODERATORS_NUM = \"config_mod_portion_num\";\r\n    bytes32 CONFIG_PORTION_TO_MODERATORS_DEN = \"config_mod_portion_den\";\r\n\r\n    bytes32 CONFIG_DRAFT_VOTING_PHASE = \"config_draft_voting_phase\";\r\n\r\n    bytes32 CONFIG_REPUTATION_POINT_BOOST_FOR_BADGE = \"config_rp_boost_per_badge\";\r\n\r\n    bytes32 CONFIG_VOTE_CLAIMING_DEADLINE = \"config_claiming_deadline\";\r\n\r\n    bytes32 CONFIG_PREPROPOSAL_COLLATERAL = \"config_preproposal_collateral\";\r\n\r\n    bytes32 CONFIG_MAX_FUNDING_FOR_NON_DIGIX = \"config_max_funding_nonDigix\";\r\n    bytes32 CONFIG_MAX_MILESTONES_FOR_NON_DIGIX = \"config_max_milestones_nonDigix\";\r\n    bytes32 CONFIG_NON_DIGIX_PROPOSAL_CAP_PER_QUARTER = \"config_nonDigix_proposal_cap\";\r\n\r\n    bytes32 CONFIG_PROPOSAL_DEAD_DURATION = \"config_dead_duration\";\r\n    bytes32 CONFIG_CARBON_VOTE_REPUTATION_BONUS = \"config_cv_reputation\";\r\n}\r\n\r\n// File: contracts/storage/DaoIdentityStorage.sol\r\ncontract DaoIdentityStorage is ResolverClient, DaoConstants, DirectoryStorage {\r\n\r\n    // struct for KYC details\r\n    // doc is the IPFS doc hash for any information regarding this KYC\r\n    // id_expiration is the UTC timestamp at which this KYC will expire\r\n    // at any time after this, the user's KYC is invalid, and that user\r\n    // MUST re-KYC before doing any proposer related operation in DigixDAO\r\n    struct KycDetails {\r\n        bytes32 doc;\r\n        uint256 id_expiration;\r\n    }\r\n\r\n    // a mapping of address to the KYC details\r\n    mapping (address => KycDetails) kycInfo;\r\n\r\n    constructor(address _resolver)\r\n        public\r\n    {\r\n        require(init(CONTRACT_STORAGE_DAO_IDENTITY, _resolver));\r\n        require(initialize_directory());\r\n    }\r\n\r\n    function create_group(uint256 _role_id, bytes32 _name, bytes32 _document)\r\n        public\r\n        returns (bool _success, uint256 _group_id)\r\n    {\r\n        require(sender_is(CONTRACT_DAO_IDENTITY));\r\n        (_success, _group_id) = internal_create_group(_role_id, _name, _document);\r\n        require(_success);\r\n    }\r\n\r\n    function create_role(uint256 _role_id, bytes32 _name)\r\n        public\r\n        returns (bool _success)\r\n    {\r\n        require(sender_is(CONTRACT_DAO_IDENTITY));\r\n        _success = internal_create_role(_role_id, _name);\r\n        require(_success);\r\n    }\r\n\r\n    function update_add_user_to_group(uint256 _group_id, address _user, bytes32 _document)\r\n        public\r\n        returns (bool _success)\r\n    {\r\n        require(sender_is(CONTRACT_DAO_IDENTITY));\r\n        _success = internal_update_add_user_to_group(_group_id, _user, _document);\r\n        require(_success);\r\n    }\r\n\r\n    function update_remove_group_user(address _user)\r\n        public\r\n        returns (bool _success)\r\n    {\r\n        require(sender_is(CONTRACT_DAO_IDENTITY));\r\n        _success = internal_destroy_group_user(_user);\r\n        require(_success);\r\n    }\r\n\r\n    function update_kyc(address _user, bytes32 _doc, uint256 _id_expiration)\r\n        public\r\n    {\r\n        require(sender_is(CONTRACT_DAO_IDENTITY));\r\n        kycInfo[_user].doc = _doc;\r\n        kycInfo[_user].id_expiration = _id_expiration;\r\n    }\r\n\r\n    function read_kyc_info(address _user)\r\n        public\r\n        view\r\n        returns (bytes32 _doc, uint256 _id_expiration)\r\n    {\r\n        _doc = kycInfo[_user].doc;\r\n        _id_expiration = kycInfo[_user].id_expiration;\r\n    }\r\n\r\n    function is_kyc_approved(address _user)\r\n        public\r\n        view\r\n        returns (bool _approved)\r\n    {\r\n        uint256 _id_expiration;\r\n        (,_id_expiration) = read_kyc_info(_user);\r\n        _approved = _id_expiration > now;\r\n    }\r\n}\r\n\r\n// File: contracts/storage/DaoWhitelistingStorage.sol\r\n// This contract is basically created to restrict read access to\r\n// ethereum accounts, and whitelisted contracts\r\ncontract DaoWhitelistingStorage is ResolverClient, DaoConstants {\r\n\r\n    // we want to avoid the scenario in which an on-chain bribing contract\r\n    // can be deployed to distribute funds in a trustless way by verifying\r\n    // on-chain votes. This mapping marks whether a contract address is whitelisted\r\n    // to read from the read functions in DaoStorage, DaoSpecialStorage, etc.\r\n    mapping (address => bool) public whitelist;\r\n\r\n    constructor(address _resolver)\r\n        public\r\n    {\r\n        require(init(CONTRACT_STORAGE_DAO_WHITELISTING, _resolver));\r\n    }\r\n\r\n    function setWhitelisted(address _contractAddress, bool _senderIsAllowedToRead)\r\n        public\r\n    {\r\n        require(sender_is(CONTRACT_DAO_WHITELISTING));\r\n        whitelist[_contractAddress] = _senderIsAllowedToRead;\r\n    }\r\n}\r\n\r\n// File: contracts/common/DaoWhitelistingCommon.sol\r\ncontract DaoWhitelistingCommon is ResolverClient, DaoConstants {\r\n\r\n    function daoWhitelistingStorage()\r\n        internal\r\n        view\r\n        returns (DaoWhitelistingStorage _contract)\r\n    {\r\n        _contract = DaoWhitelistingStorage(get_contract(CONTRACT_STORAGE_DAO_WHITELISTING));\r\n    }\r\n\r\n    /**\r\n    @notice Check if a certain address is whitelisted to read sensitive information in the storage layer\r\n    @dev if the address is an account, it is allowed to read. If the address is a contract, it has to be in the whitelist\r\n    */\r\n    function senderIsAllowedToRead()\r\n        internal\r\n        view\r\n        returns (bool _senderIsAllowedToRead)\r\n    {\r\n        // msg.sender is allowed to read only if its an EOA or a whitelisted contract\r\n        _senderIsAllowedToRead = (msg.sender == tx.origin) || daoWhitelistingStorage().whitelist(msg.sender);\r\n    }\r\n}\r\n\r\n// File: contracts/common/IdentityCommon.sol\r\ncontract IdentityCommon is DaoWhitelistingCommon {\r\n\r\n    modifier if_root() {\r\n        require(identity_storage().read_user_role_id(msg.sender) == ROLES_ROOT);\r\n        _;\r\n    }\r\n\r\n    modifier if_founder() {\r\n        require(is_founder());\r\n        _;\r\n    }\r\n\r\n    function is_founder()\r\n        internal\r\n        view\r\n        returns (bool _isFounder)\r\n    {\r\n        _isFounder = identity_storage().read_user_role_id(msg.sender) == ROLES_FOUNDERS;\r\n    }\r\n\r\n    modifier if_prl() {\r\n        require(identity_storage().read_user_role_id(msg.sender) == ROLES_PRLS);\r\n        _;\r\n    }\r\n\r\n    modifier if_kyc_admin() {\r\n        require(identity_storage().read_user_role_id(msg.sender) == ROLES_KYC_ADMINS);\r\n        _;\r\n    }\r\n\r\n    function identity_storage()\r\n        internal\r\n        view\r\n        returns (DaoIdentityStorage _contract)\r\n    {\r\n        _contract = DaoIdentityStorage(get_contract(CONTRACT_STORAGE_DAO_IDENTITY));\r\n    }\r\n}\r\n\r\n// File: contracts/interactive/DaoIdentity.sol\r\n/**\r\n@title Contract to manage the admin roles in DAO (founders, prls, kyc admins)\r\n@author Digix Holdings\r\n*/\r\ncontract DaoIdentity is IdentityCommon {\r\n\r\n    /**\r\n    @notice Constructor (create initial roles, groups)\r\n    @param _resolver Address of Contract Resolver\r\n    */\r\n    constructor(address _resolver)\r\n        public\r\n    {\r\n        require(init(CONTRACT_DAO_IDENTITY, _resolver));\r\n        // create the three roles and the three corresponding groups\r\n        // the root role, and root group are already created, with only the contract deployer in it\r\n        // After deployment, the contract deployer will call addGroupUser to add a multi-sig to be another root\r\n        // The multi-sig will then call removeGroupUser to remove the contract deployer from root role\r\n        // From then on, the multi-sig will be the only root account\r\n        identity_storage().create_role(ROLES_FOUNDERS, \"founders\");\r\n        identity_storage().create_role(ROLES_PRLS, \"prls\");\r\n        identity_storage().create_role(ROLES_KYC_ADMINS, \"kycadmins\");\r\n        identity_storage().create_group(ROLES_FOUNDERS, \"founders_group\", \"\"); // group_id = 2\r\n        identity_storage().create_group(ROLES_PRLS, \"prls_group\", \"\"); // group_id = 3\r\n        identity_storage().create_group(ROLES_KYC_ADMINS, \"kycadmins_group\", \"\"); // group_id = 4\r\n    }\r\n\r\n    /**\r\n    @notice Function to add an address to a group (only root can call this function)\r\n    @param _group_id ID of the group to be added in\r\n    @param _user Ethereum address of the user\r\n    @param _doc hash of IPFS doc containing details of this user\r\n    */\r\n    function addGroupUser(uint256 _group_id, address _user, bytes32 _doc)\r\n        public\r\n        if_root()\r\n    {\r\n        identity_storage().update_add_user_to_group(_group_id, _user, _doc);\r\n    }\r\n\r\n    /**\r\n    @notice Function to remove a user from group (only root can call this)\r\n    @param _user Ethereum address of the user to be removed from their group\r\n    */\r\n    function removeGroupUser(address _user)\r\n        public\r\n        if_root()\r\n    {\r\n        identity_storage().update_remove_group_user(_user);\r\n    }\r\n\r\n    /**\r\n    @notice Function to update the KYC data of user (expiry data of valid KYC) (can only be called by the KYC ADMIN role)\r\n    @param _user Ethereum address of the user\r\n    @param _doc hash of the IPFS doc containing kyc information about this user\r\n    @param _id_expiration expiry date of the KYC\r\n    */\r\n    function updateKyc(address _user, bytes32 _doc, uint256 _id_expiration)\r\n        public\r\n        if_kyc_admin()\r\n    {\r\n        privateUpdateKyc(_user, _doc, _id_expiration);\r\n    }\r\n\r\n    /**\r\n    @notice Function to update the KYC data of multiple users (expiry data of valid KYC) (can only be called by the KYC ADMIN role)\r\n    @param _users Ethereum addresses of the users\r\n    @param _docs hashes of the IPFS docs containing kyc information about these users\r\n    @param _id_expirations expiry dates of the KYC docs for these users\r\n    */\r\n    function bulkUpdateKyc(address[] _users, bytes32[] _docs, uint256[] _id_expirations)\r\n        external\r\n        if_kyc_admin()\r\n    {\r\n        uint256 _n = _users.length;\r\n        for (uint256 _i = 0; _i < _n; _i++) {\r\n            privateUpdateKyc(_users[_i], _docs[_i], _id_expirations[_i]);\r\n        }\r\n    }\r\n\r\n    function privateUpdateKyc(address _user, bytes32 _doc, uint256 _id_expiration)\r\n        private\r\n    {\r\n        identity_storage().update_kyc(_user, _doc, _id_expiration);\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"resolver\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"key\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_key\",\"type\":\"bytes32\"}],\"name\":\"get_contract\",\"outputs\":[{\"name\":\"_contract\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_group_id\",\"type\":\"uint256\"},{\"name\":\"_user\",\"type\":\"address\"},{\"name\":\"_doc\",\"type\":\"bytes32\"}],\"name\":\"addGroupUser\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_user\",\"type\":\"address\"},{\"name\":\"_doc\",\"type\":\"bytes32\"},{\"name\":\"_id_expiration\",\"type\":\"uint256\"}],\"name\":\"updateKyc\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"removeGroupUser\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_users\",\"type\":\"address[]\"},{\"name\":\"_docs\",\"type\":\"bytes32[]\"},{\"name\":\"_id_expirations\",\"type\":\"uint256[]\"}],\"name\":\"bulkUpdateKyc\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CONTRACT_ADDRESS\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_resolver\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"}]","ContractName":"DaoIdentity","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000005f60ef7e1443f82ca7de947711f0966ca6e3b5","Library":"","SwarmSource":"bzzr://5bae4282b9febe91ba8658c98de1a5642cfb8f1f0dc19ca32175addf8b3655e0"}]}