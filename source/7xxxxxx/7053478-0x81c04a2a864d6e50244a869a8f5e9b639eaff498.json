{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\n/*\r\n*   gibmireinbier\r\n*   0xA4a799086aE18D7db6C4b57f496B081b44888888\r\n*   gibmireinbier@gmail.com\r\n*/\r\n\r\nlibrary SafeMath {\r\n    int256 constant private INT256_MIN = -2**255;\r\n\r\n    /**\r\n    * @dev Multiplies two unsigned integers, reverts on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Multiplies two signed integers, reverts on overflow.\r\n    */\r\n    function mul(int256 a, int256 b) internal pure returns (int256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        require(!(a == -1 && b == INT256_MIN)); // This is the only case of overflow not detected by the check below\r\n\r\n        int256 c = a * b;\r\n        require(c / a == b);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two signed integers truncating the quotient, reverts on division by zero.\r\n    */\r\n    function div(int256 a, int256 b) internal pure returns (int256) {\r\n        require(b != 0); // Solidity only automatically asserts when dividing by 0\r\n        require(!(b == -1 && a == INT256_MIN)); // This is the only case of overflow\r\n\r\n        int256 c = a / b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two signed integers, reverts on overflow.\r\n    */\r\n    function sub(int256 a, int256 b) internal pure returns (int256) {\r\n        int256 c = a - b;\r\n        require((b >= 0 && c <= a) || (b < 0 && c > a));\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two unsigned integers, reverts on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two signed integers, reverts on overflow.\r\n    */\r\n    function add(int256 a, int256 b) internal pure returns (int256) {\r\n        int256 c = a + b;\r\n        require((b >= 0 && c >= a) || (b < 0 && c < a));\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\r\n    * reverts when dividing by zero.\r\n    */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}\r\n\r\nlibrary Helper {\r\n    using SafeMath for uint256;\r\n\r\n    uint256 constant public ZOOM = 1000;\r\n    uint256 constant public SDIVIDER = 3450000;\r\n    uint256 constant public PDIVIDER = 3450000;\r\n    uint256 constant public RDIVIDER = 1580000;\r\n    // Starting LS price (SLP)\r\n    uint256 constant public SLP = 0.002 ether;\r\n    // Starting Added Time (SAT)\r\n    uint256 constant public SAT = 30; // seconds\r\n    // Price normalization (PN)\r\n    uint256 constant public PN = 777;\r\n    // EarlyIncome base\r\n    uint256 constant public PBASE = 13;\r\n    uint256 constant public PMULTI = 26;\r\n    uint256 constant public LBase = 15;\r\n\r\n    uint256 constant public ONE_HOUR = 3600;\r\n    uint256 constant public ONE_DAY = 24 * ONE_HOUR;\r\n    //uint256 constant public TIMEOUT0 = 3 * ONE_HOUR;\r\n    uint256 constant public TIMEOUT1 = 12 * ONE_HOUR;\r\n    \r\n    function bytes32ToString (bytes32 data)\r\n        public\r\n        pure\r\n        returns (string) \r\n    {\r\n        bytes memory bytesString = new bytes(32);\r\n        for (uint j=0; j<32; j++) {\r\n            byte char = byte(bytes32(uint(data) * 2 ** (8 * j)));\r\n            if (char != 0) {\r\n                bytesString[j] = char;\r\n            }\r\n        }\r\n        return string(bytesString);\r\n    }\r\n    \r\n    function uintToBytes32(uint256 n)\r\n        public\r\n        pure\r\n        returns (bytes32) \r\n    {\r\n        return bytes32(n);\r\n    }\r\n    \r\n    function bytes32ToUint(bytes32 n) \r\n        public\r\n        pure\r\n        returns (uint256) \r\n    {\r\n        return uint256(n);\r\n    }\r\n    \r\n    function stringToBytes32(string memory source) \r\n        public\r\n        pure\r\n        returns (bytes32 result) \r\n    {\r\n        bytes memory tempEmptyStringTest = bytes(source);\r\n        if (tempEmptyStringTest.length == 0) {\r\n            return 0x0;\r\n        }\r\n\r\n        assembly {\r\n            result := mload(add(source, 32))\r\n        }\r\n    }\r\n    \r\n    function stringToUint(string memory source) \r\n        public\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return bytes32ToUint(stringToBytes32(source));\r\n    }\r\n    \r\n    function uintToString(uint256 _uint) \r\n        public\r\n        pure\r\n        returns (string)\r\n    {\r\n        return bytes32ToString(uintToBytes32(_uint));\r\n    }\r\n\r\n/*     \r\n    function getSlice(uint256 begin, uint256 end, string text) public pure returns (string) {\r\n        bytes memory a = new bytes(end-begin+1);\r\n        for(uint i = 0; i <= end - begin; i++){\r\n            a[i] = bytes(text)[i + begin - 1];\r\n        }\r\n        return string(a);    \r\n    }\r\n */\r\n    function validUsername(string _username)\r\n        public\r\n        pure\r\n        returns(bool)\r\n    {\r\n        uint256 len = bytes(_username).length;\r\n        // Im Raum [4, 18]\r\n        if ((len < 4) || (len > 18)) return false;\r\n        // Letzte Char != ' '\r\n        if (bytes(_username)[len-1] == 32) return false;\r\n        // Erste Char != '0'\r\n        return uint256(bytes(_username)[0]) != 48;\r\n    }\r\n\r\n    // Lottery Helper\r\n\r\n    // Seconds added per LT = SAT - ((Current no. of LT + 1) / SDIVIDER)^6\r\n    function getAddedTime(uint256 _rTicketSum, uint256 _tAmount)\r\n        public\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        //Luppe = 10000 = 10^4\r\n        uint256 base = (_rTicketSum + 1).mul(10000) / SDIVIDER;\r\n        uint256 expo = base;\r\n        expo = expo.mul(expo).mul(expo); // ^3\r\n        expo = expo.mul(expo); // ^6\r\n        // div 10000^6\r\n        expo = expo / (10**24);\r\n\r\n        if (expo > SAT) return 0;\r\n        return (SAT - expo).mul(_tAmount);\r\n    }\r\n\r\n    function getNewEndTime(uint256 toAddTime, uint256 slideEndTime, uint256 fixedEndTime)\r\n        public\r\n        view\r\n        returns(uint256)\r\n    {\r\n        uint256 _slideEndTime = (slideEndTime).add(toAddTime);\r\n        uint256 timeout = _slideEndTime.sub(block.timestamp);\r\n        // timeout capped at TIMEOUT1\r\n        if (timeout > TIMEOUT1) timeout = TIMEOUT1;\r\n        _slideEndTime = (block.timestamp).add(timeout);\r\n        // Capped at fixedEndTime\r\n        if (_slideEndTime > fixedEndTime)  return fixedEndTime;\r\n        return _slideEndTime;\r\n    }\r\n\r\n    // get random in range [1, _range] with _seed\r\n    function getRandom(uint256 _seed, uint256 _range)\r\n        public\r\n        pure\r\n        returns(uint256)\r\n    {\r\n        if (_range == 0) return _seed;\r\n        return (_seed % _range) + 1;\r\n    }\r\n\r\n\r\n    function getEarlyIncomeMul(uint256 _ticketSum)\r\n        public\r\n        pure\r\n        returns(uint256)\r\n    {\r\n        // Early-Multiplier = 1 + PBASE / (1 + PMULTI * ((Current No. of LT)/RDIVIDER)^6)\r\n        uint256 base = _ticketSum * ZOOM / RDIVIDER;\r\n        uint256 expo = base.mul(base).mul(base); //^3\r\n        expo = expo.mul(expo) / (ZOOM**6); //^6\r\n        return (1 + PBASE / (1 + expo.mul(PMULTI)));\r\n    }\r\n\r\n    // get reveiced Tickets, based on current round ticketSum\r\n    function getTAmount(uint256 _ethAmount, uint256 _ticketSum) \r\n        public\r\n        pure\r\n        returns(uint256)\r\n    {\r\n        uint256 _tPrice = getTPrice(_ticketSum);\r\n        return _ethAmount.div(_tPrice);\r\n    }\r\n\r\n    // Lotto-Multiplier = 1 + LBase * (Current No. of Tickets / PDivider)^6\r\n    function getTMul(uint256 _ticketSum) // Unit Wei\r\n        public\r\n        pure\r\n        returns(uint256)\r\n    {\r\n        uint256 base = _ticketSum * ZOOM / PDIVIDER;\r\n        uint256 expo = base.mul(base).mul(base);\r\n        expo = expo.mul(expo); // ^6\r\n        return 1 + expo.mul(LBase) / (10**18);\r\n    }\r\n\r\n    // get ticket price, based on current round ticketSum\r\n    //unit in ETH, no need / zoom^6\r\n    function getTPrice(uint256 _ticketSum)\r\n        public\r\n        pure\r\n        returns(uint256)\r\n    {\r\n        uint256 base = (_ticketSum + 1).mul(ZOOM) / PDIVIDER;\r\n        uint256 expo = base;\r\n        expo = expo.mul(expo).mul(expo); // ^3\r\n        expo = expo.mul(expo); // ^6\r\n        uint256 tPrice = SLP + expo / PN;\r\n        return tPrice;\r\n    }\r\n\r\n    // get weight of slot, chance to win grandPot\r\n    function getSlotWeight(uint256 _ethAmount, uint256 _ticketSum)\r\n        public\r\n        pure\r\n        returns(uint256)\r\n    {\r\n        uint256 _tAmount = getTAmount(_ethAmount, _ticketSum);\r\n        uint256 _tMul = getTMul(_ticketSum);\r\n        return (_tAmount).mul(_tMul);\r\n    }\r\n\r\n    // used to draw grandpot results\r\n    // weightRange = roundWeight * grandpot / (grandpot - initGrandPot)\r\n    // grandPot = initGrandPot + round investedSum(for grandPot)\r\n    function getWeightRange(uint256 grandPot, uint256 initGrandPot, uint256 curRWeight)\r\n        public\r\n        pure\r\n        returns(uint256)\r\n    {\r\n        //calculate round grandPot-investedSum\r\n        uint256 grandPotInvest = grandPot - initGrandPot;\r\n        if (grandPotInvest == 0) return 8;\r\n        uint256 zoomMul = grandPot * ZOOM / grandPotInvest;\r\n        uint256 weightRange = zoomMul * curRWeight / ZOOM;\r\n        if (weightRange < curRWeight) weightRange = curRWeight;\r\n        return weightRange;\r\n    }\r\n}\r\n\r\ninterface DevTeamInterface {\r\n    function setF2mAddress(address _address) public;\r\n    function setLotteryAddress(address _address) public;\r\n    function setCitizenAddress(address _address) public;\r\n    function setBankAddress(address _address) public;\r\n    function setRewardAddress(address _address) public;\r\n    function setWhitelistAddress(address _address) public;\r\n\r\n    function setupNetwork() public;\r\n}\r\n\r\ninterface LotteryInterface {\r\n    function joinNetwork(address[6] _contract) public;\r\n    // call one time\r\n    function activeFirstRound() public;\r\n    // Core Functions\r\n    function pushToPot() public payable;\r\n    function finalizeable() public view returns(bool);\r\n    // bounty\r\n    function finalize() public;\r\n    function buy(string _sSalt) public payable;\r\n    function buyFor(string _sSalt, address _sender) public payable;\r\n    //function withdraw() public;\r\n    function withdrawFor(address _sender) public returns(uint256);\r\n\r\n    function getRewardBalance(address _buyer) public view returns(uint256);\r\n    function getTotalPot() public view returns(uint256);\r\n    // EarlyIncome\r\n    function getEarlyIncomeByAddress(address _buyer) public view returns(uint256);\r\n    // included claimed amount\r\n    // function getEarlyIncomeByAddressRound(address _buyer, uint256 _rId) public view returns(uint256);\r\n    function getCurEarlyIncomeByAddress(address _buyer) public view returns(uint256);\r\n    // function getCurEarlyIncomeByAddressRound(address _buyer, uint256 _rId) public view returns(uint256);\r\n    function getCurRoundId() public view returns(uint256);\r\n    // set endRound, prepare to upgrade new version\r\n    function setLastRound(uint256 _lastRoundId) public;\r\n    function getPInvestedSumByRound(uint256 _rId, address _buyer) public view returns(uint256);\r\n    function cashoutable(address _address) public view returns(bool);\r\n    function isLastRound() public view returns(bool);\r\n}\r\n\r\ncontract Reward {\r\n    using SafeMath for uint256;\r\n\r\n    event NewReward(address indexed _lucker, uint256[5] _info);\r\n    \r\n    modifier onlyOwner() {\r\n        require(msg.sender == address(lotteryContract), \"This is just log for lottery contract\");\r\n        _;\r\n    }\r\n\r\n    modifier claimable() {\r\n        require(\r\n            rest > 1 && \r\n            block.number > lastBlock &&\r\n            lastRoundClaim[msg.sender] < lastRoundId,\r\n            \"out of stock in this round, block or already claimed\");\r\n        _;\r\n    }\r\n\r\n/*     \r\n    enum RewardType {\r\n        Minor, 0\r\n        Major, 1\r\n        Grand, 2\r\n        Bounty 3\r\n        SBounty 4 // smal bounty\r\n    } \r\n*/\r\n\r\n    struct Rewards {\r\n        address lucker;\r\n        uint256 time;\r\n        uint256 rId;\r\n        uint256 value;\r\n        uint256 winNumber;\r\n        uint256 rewardType;\r\n    }\r\n\r\n    Rewards[] public rewardList;\r\n    // reward array by address\r\n    mapping( address => uint256[]) public pReward;\r\n    // reward sum by address\r\n    mapping( address => uint256) public pRewardedSum;\r\n    // reward sum by address, round\r\n    mapping( address => mapping(uint256 => uint256)) public pRewardedSumPerRound;\r\n    // reward sum by round\r\n    mapping( uint256 => uint256) public rRewardedSum;\r\n    // reward sum all round, all addresses\r\n    uint256 public rewardedSum;\r\n    \r\n    // last claimed round by address to check timeout\r\n    // timeout balance will be pushed to dividends\r\n    mapping(address => uint256) lastRoundClaim;\r\n\r\n    LotteryInterface lotteryContract;\r\n\r\n    //////////////////////////////////////////////////////////\r\n    \r\n    // rest times for sBounty, small bountys free for all (round-players) after each round\r\n    uint256 public rest = 0;\r\n    // last block that sBounty claimed, to prevent 2 time claimed in same block\r\n    uint256 public lastBlock = 0;\r\n    // sBounty will be saved in logs of last round\r\n    // new round will be started after sBountys pushed\r\n    uint256 public lastRoundId;\r\n\r\n    constructor (address _devTeam)\r\n        public\r\n    {\r\n        // register address in network\r\n        DevTeamInterface(_devTeam).setRewardAddress(address(this));\r\n    }\r\n\r\n    // _contract = [f2mAddress, bankAddress, citizenAddress, lotteryAddress, rewardAddress, whitelistAddress];\r\n    function joinNetwork(address[6] _contract)\r\n        public\r\n    {\r\n        require((address(lotteryContract) == 0x0),\"already setup\");\r\n        lotteryContract = LotteryInterface(_contract[3]);\r\n    }\r\n\r\n    // sBounty program\r\n    // rules :\r\n    // 1. accept only eth from lottery contract\r\n    // 2. one claim per block\r\n    // 3. one claim per address (reset each round)\r\n\r\n    function getSBounty()\r\n        public\r\n        view\r\n        returns(uint256, uint256, uint256)\r\n    {\r\n        uint256 sBountyAmount = rest < 2 ? 0 : address(this).balance / (rest-1);\r\n        return (rest, sBountyAmount, lastRoundId);\r\n    }\r\n\r\n    // pushed from lottery contract only\r\n    function pushBounty(uint256 _curRoundId) \r\n        public \r\n        payable \r\n        onlyOwner() \r\n    {\r\n        rest = 8;\r\n        lastBlock = block.number;\r\n        lastRoundId = _curRoundId;\r\n    }\r\n\r\n    function claim()\r\n        public\r\n        claimable()\r\n    {\r\n        address _sender = msg.sender;\r\n        uint256 rInvested = lotteryContract.getPInvestedSumByRound(lastRoundId, _sender);\r\n        require(rInvested > 0, \"sorry, not invested no bounty\");\r\n        lastBlock = block.number;\r\n        lastRoundClaim[_sender] = lastRoundId;\r\n        rest = rest - 1;\r\n        uint256 claimAmount = address(this).balance / rest;\r\n        _sender.transfer(claimAmount);\r\n        mintRewardCore(\r\n            _sender,\r\n            lastRoundId,\r\n            0,\r\n            0,\r\n            claimAmount,\r\n            4\r\n        );\r\n    }\r\n\r\n    // rewards sealed by lottery contract\r\n    function mintReward(\r\n        address _lucker,\r\n        uint256 _curRoundId,\r\n        uint256 _tNumberFrom,\r\n        uint256 _tNumberTo,\r\n        uint256 _value,\r\n        uint256 _rewardType)\r\n        public\r\n        onlyOwner()\r\n    {\r\n        mintRewardCore(\r\n            _lucker,\r\n            _curRoundId,\r\n            _tNumberFrom,\r\n            _tNumberTo,\r\n            _value,\r\n            _rewardType);\r\n    }\r\n\r\n    // reward logs generator\r\n    function mintRewardCore(\r\n        address _lucker,\r\n        uint256 _curRoundId,\r\n        uint256 _tNumberFrom,\r\n        uint256 _tNumberTo,\r\n        uint256 _value,\r\n        uint256 _rewardType)\r\n        private\r\n    {\r\n        Rewards memory _reward;\r\n        _reward.lucker = _lucker;\r\n        _reward.time = block.timestamp;\r\n        _reward.rId = _curRoundId;\r\n        _reward.value = _value;\r\n\r\n        // get winning number if rewardType is not bounty or sBounty\r\n        // seed = rewardList.length to be sure that seed changed after\r\n        // every reward minting\r\n        if (_rewardType < 3)\r\n        _reward.winNumber = getWinNumberBySlot(_tNumberFrom, _tNumberTo);\r\n\r\n        _reward.rewardType = _rewardType;\r\n        rewardList.push(_reward);\r\n        pReward[_lucker].push(rewardList.length - 1);\r\n        // reward sum logs\r\n        pRewardedSum[_lucker] += _value;\r\n        rRewardedSum[_curRoundId] += _value;\r\n        rewardedSum += _value;\r\n        pRewardedSumPerRound[_lucker][_curRoundId] += _value;\r\n        emit NewReward(_reward.lucker, [_reward.time, _reward.rId, _reward.value, _reward.winNumber, uint256(_reward.rewardType)]);\r\n    }\r\n\r\n    function getWinNumberBySlot(uint256 _tNumberFrom, uint256 _tNumberTo)\r\n        public\r\n        view\r\n        returns(uint256)\r\n    {\r\n        //uint256 _seed = uint256(keccak256(rewardList.length));\r\n        uint256 _seed = rewardList.length * block.number + block.timestamp;\r\n        // get random number in range (1, _to - _from + 1)\r\n        uint256 _winNr = Helper.getRandom(_seed, _tNumberTo + 1 - _tNumberFrom);\r\n        return _tNumberFrom + _winNr - 1;\r\n    }\r\n\r\n    function getPRewardLength(address _sender)\r\n        public\r\n        view\r\n        returns(uint256)\r\n    {\r\n        return pReward[_sender].length;\r\n    }\r\n\r\n    function getRewardListLength()\r\n        public\r\n        view\r\n        returns(uint256)\r\n    {\r\n        return rewardList.length;\r\n    }\r\n\r\n    function getPRewardId(address _sender, uint256 i)\r\n        public\r\n        view\r\n        returns(uint256)\r\n    {\r\n        return pReward[_sender][i];\r\n    }\r\n\r\n    function getPRewardedSumByRound(uint256 _rId, address _buyer)\r\n        public\r\n        view\r\n        returns(uint256)\r\n    {\r\n        return pRewardedSumPerRound[_buyer][_rId];\r\n    }\r\n\r\n    function getRewardedSumByRound(uint256 _rId)\r\n        public\r\n        view\r\n        returns(uint256)\r\n    {\r\n        return rRewardedSum[_rId];\r\n    }\r\n\r\n    function getRewardInfo(uint256 _id)\r\n        public\r\n        view\r\n        returns(\r\n            address,\r\n            uint256,\r\n            uint256,\r\n            uint256,\r\n            uint256,\r\n            uint256\r\n        )\r\n    {\r\n        Rewards memory _reward = rewardList[_id];\r\n        return (\r\n            _reward.lucker,\r\n            _reward.winNumber,\r\n            _reward.time,\r\n            _reward.rId,\r\n            _reward.value,\r\n            _reward.rewardType\r\n        );\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"pReward\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"rewardList\",\"outputs\":[{\"name\":\"lucker\",\"type\":\"address\"},{\"name\":\"time\",\"type\":\"uint256\"},{\"name\":\"rId\",\"type\":\"uint256\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"winNumber\",\"type\":\"uint256\"},{\"name\":\"rewardType\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"getRewardInfo\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"pRewardedSumPerRound\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_contract\",\"type\":\"address[6]\"}],\"name\":\"joinNetwork\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastRoundId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"pRewardedSum\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claim\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getRewardListLength\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"rRewardedSum\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastBlock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_rId\",\"type\":\"uint256\"}],\"name\":\"getRewardedSumByRound\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_sender\",\"type\":\"address\"},{\"name\":\"i\",\"type\":\"uint256\"}],\"name\":\"getPRewardId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rewardedSum\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getSBounty\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tNumberFrom\",\"type\":\"uint256\"},{\"name\":\"_tNumberTo\",\"type\":\"uint256\"}],\"name\":\"getWinNumberBySlot\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rest\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_rId\",\"type\":\"uint256\"},{\"name\":\"_buyer\",\"type\":\"address\"}],\"name\":\"getPRewardedSumByRound\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_curRoundId\",\"type\":\"uint256\"}],\"name\":\"pushBounty\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_sender\",\"type\":\"address\"}],\"name\":\"getPRewardLength\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_lucker\",\"type\":\"address\"},{\"name\":\"_curRoundId\",\"type\":\"uint256\"},{\"name\":\"_tNumberFrom\",\"type\":\"uint256\"},{\"name\":\"_tNumberTo\",\"type\":\"uint256\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_rewardType\",\"type\":\"uint256\"}],\"name\":\"mintReward\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_devTeam\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_lucker\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_info\",\"type\":\"uint256[5]\"}],\"name\":\"NewReward\",\"type\":\"event\"}]","ContractName":"Reward","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"00000000000000000000000096504e1f83e380984b1d4eccc0e8b9f0559b2ad2","Library":"Helper:c85ca9fdfcf2193f2f2f34969aba95826bfe1260","SwarmSource":"bzzr://140a144f3701eb3b6f26c715797b9bbb32cfcf5f28b9638684fc71a99b82f62e"}]}