{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.3;\r\n\r\ncontract Ownable \r\n{\r\n    address private owner;\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    constructor() public \r\n    {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner() \r\n    {\r\n        require(msg.sender == owner, \"Only owner can call this function.\");\r\n        _;\r\n    }\r\n\r\n    function isOwner() public view returns(bool) \r\n    {\r\n        return msg.sender == owner;\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public onlyOwner \r\n    {\r\n        require(newOwner != address(0));\r\n        emit OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n}\r\n\r\ncontract IERC20\r\n{\r\n    uint256 public tokenTotalSupply;\r\n    string private tokenName;\r\n    string private tokenSymbol;\r\n    \r\n    function balanceOf(address who) external view returns (uint256);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\r\n\r\n    function name() external view returns (string memory);\r\n    function symbol() external view returns (string memory);\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    function burnOwnTokens(uint256 amountToBurn) external;\r\n    function setCrowdsale(address crowdsaleAddress, uint256 crowdsaleAmount) external;\r\n}\r\n\r\ncontract IERC223 is IERC20\r\n{\r\n    function transfer(address to, uint value, bytes memory data) public returns (bool);\r\n    function transferFrom(address from, address to, uint value, bytes memory data) public returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint value, bytes data);\r\n}\r\n\r\ncontract IERC223Receiver \r\n{ \r\n    function tokenFallback(address from, address sender, uint value, bytes memory data) public returns (bool);\r\n}\r\n\r\ncontract IMigrationAgent\r\n{\r\n    function finalizeMigration() external;\r\n    function migrateTokens(address owner, uint256 tokens) public;\r\n}\r\n\r\ncontract IMigrationSource\r\n{\r\n    address private migrationAgentAddress;\r\n    IMigrationAgent private migrationAgentContract;\r\n    bool private isMigrated;\r\n\r\n    event MigratedFrom(address indexed owner, uint256 tokens);\r\n\r\n    function setMigrationAgent(address agent) external;\r\n    function migrate() external;\r\n    function finalizeMigration() external;\r\n}\r\n\r\nlibrary SafeMath \r\n{\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) \r\n    {\r\n        if (a == 0) \r\n        {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"Multiplying error.\");\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) \r\n    {\r\n        require(b > 0, \"Division error.\");\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) \r\n    {\r\n        require(b <= a, \"Subtraction error.\");\r\n        uint256 c = a - b;\r\n        return c;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) \r\n    {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"Adding error.\");\r\n        return c;\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) \r\n    {\r\n        require(b != 0, \"Mod error.\");\r\n        return a % b;\r\n    }\r\n}\r\n\r\ncontract EggToken is IERC223, Ownable, IMigrationSource\r\n{\r\n    using SafeMath for uint256;\r\n\r\n    uint256 private tokenTotalSupply;\r\n    string private tokenName;\r\n    string private tokenSymbol;\r\n    uint8 private tokenDecimals;\r\n\r\n    mapping (address => uint256) private balances;\r\n    mapping (address => mapping (address => uint256)) private allowances;\r\n\r\n    address private migrationAgentAddress;\r\n    IMigrationAgent private migrationAgentContract;\r\n    bool private isMigrated;\r\n    bool private isCrowdsaleSet;\r\n    \r\n    address private owner;\r\n    \r\n    constructor(string memory name, \r\n                string memory symbol, \r\n                uint256 totalSupply, \r\n                address developmentTeamAddress, \r\n                uint256 developmentTeamBalance, \r\n                address marketingTeamAddress, \r\n                uint256 marketingTeamBalance, \r\n                address productTeamAddress, \r\n                uint256 productTeamBalance, \r\n                address airdropAddress,\r\n                uint256 airdropBalance) public \r\n    {\r\n        tokenName = name;\r\n        tokenSymbol = symbol;\r\n        tokenDecimals = 18;\r\n\r\n        tokenTotalSupply = totalSupply;\r\n        \r\n        balances[developmentTeamAddress] = developmentTeamBalance;\r\n        balances[marketingTeamAddress] = marketingTeamBalance;\r\n        balances[productTeamAddress] = productTeamBalance;\r\n        balances[airdropAddress] = airdropBalance;\r\n    }\r\n\r\n    function setCrowdsale(address crowdsaleAddress, uint256 crowdsaleBalance) onlyOwner validAddress(crowdsaleAddress) external\r\n    {\r\n        require(!isCrowdsaleSet, \"Crowdsale address was already set.\");\r\n        isCrowdsaleSet = true;\r\n        tokenTotalSupply = tokenTotalSupply.add(crowdsaleBalance);\r\n        balances[crowdsaleAddress] = crowdsaleBalance;\r\n    }\r\n    \r\n    function approve(address spender, uint256 value) validAddress(spender) external returns (bool) \r\n    {\r\n        allowances[msg.sender][spender] = value;\r\n        emit Approval(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n    \r\n    function transfer(address to, uint256 value) external returns (bool) \r\n    {\r\n        return transfer(to, value, new bytes(0));\r\n    }\r\n    \r\n    function transferFrom(address from, address to, uint256 value) external returns (bool)\r\n    {\r\n        return transferFrom(from, to, value, new bytes(0));\r\n    }\r\n    \r\n    function transferBatch(address[] calldata to, uint256 value) external returns (bool) \r\n    {\r\n        return transferBatch(to, value, new bytes(0));\r\n    }\r\n\r\n    function transfer(address to, uint256 value, bytes memory data) validAddress(to) enoughBalance(msg.sender, value) public returns (bool)\r\n    {\r\n        balances[msg.sender] = balances[msg.sender].sub(value);\r\n        balances[to] = balances[to].add(value);\r\n        if (isContract(to))\r\n        {\r\n            contractFallback(msg.sender, to, value, data);\r\n        }\r\n        emit Transfer(msg.sender, to, value, data);\r\n        emit Transfer(msg.sender, to, value);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address from, address to, uint256 value, bytes memory data) validAddress(to) enoughBalance(from, value) public returns (bool)\r\n    {\r\n        require(value <= allowances[from][msg.sender], \"Transfer value exceeds the allowance.\");\r\n\r\n        balances[from] = balances[from].sub(value);\r\n        balances[to] = balances[to].add(value);\r\n        allowances[from][msg.sender] = allowances[from][msg.sender].sub(value);\r\n        if (isContract(to))\r\n        {\r\n            contractFallback(from, to, value, data);\r\n        }\r\n        emit Transfer(from, to, value, data);\r\n        emit Transfer(from, to, value);\r\n        return true;\r\n    }\r\n\r\n    function transferBatch(address[] memory to, uint256 value, bytes memory data) public returns (bool)\r\n    {\r\n        uint256 totalValue = value.mul(to.length);\r\n        checkBalance(msg.sender, totalValue);\r\n        balances[msg.sender] = balances[msg.sender].sub(totalValue);\r\n\r\n        uint256 i = 0;\r\n        while (i < to.length) \r\n        {\r\n            checkAddressValidity(to[i]);\r\n            balances[to[i]] = balances[to[i]].add(value);\r\n            if (isContract(to[i]))\r\n            {\r\n                contractFallback(msg.sender, to[i], value, data);\r\n            }\r\n            emit Transfer(msg.sender, to[i], value, data);\r\n            emit Transfer(msg.sender, to[i], value);\r\n            i++;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    function contractFallback(address sender, address to, uint256 value, bytes memory data) private returns (bool) \r\n    {\r\n        IERC223Receiver reciever = IERC223Receiver(to);\r\n        return reciever.tokenFallback(msg.sender, sender, value, data);\r\n    }\r\n\r\n    function isContract(address to) internal view returns (bool) \r\n    {\r\n        uint length;\r\n        assembly { length := extcodesize(to) }\r\n        return length > 0;\r\n    }\r\n    \r\n    function increaseAllowance(address spender, uint256 addedValue) validAddress(spender) external returns (bool)\r\n    {\r\n        allowances[msg.sender][spender] = allowances[msg.sender][spender].add(addedValue);\r\n        emit Approval(msg.sender, spender, allowances[msg.sender][spender]);\r\n        return true;\r\n    }\r\n    \r\n    function decreaseAllowance(address spender, uint256 subtractedValue) validAddress(spender) external returns (bool)\r\n    {\r\n        allowances[msg.sender][spender] = allowances[msg.sender][spender].sub(subtractedValue);\r\n        emit Approval(msg.sender, spender, allowances[msg.sender][spender]);\r\n        return true;\r\n    }\r\n\r\n    function burnOwnTokens(uint256 amountToBurn) enoughBalance(msg.sender, amountToBurn) external \r\n    {\r\n        require(balances[msg.sender] >= amountToBurn, \"Can't burn more tokens than you own.\");\r\n        tokenTotalSupply = tokenTotalSupply.sub(amountToBurn);\r\n        balances[msg.sender] = balances[msg.sender].sub(amountToBurn);\r\n        emit Transfer(msg.sender, address(0), amountToBurn, new bytes(0));\r\n        emit Transfer(msg.sender, address(0), amountToBurn);\r\n    }\r\n\r\n    function transferAnyERC20Token(address tokenAddress, uint256 tokens) public onlyOwner returns (bool success) \r\n    {\r\n        return IERC20(tokenAddress).transfer(owner, tokens);\r\n    }\r\n\r\n    function balanceOf(address balanceOwner) external view returns (uint256) \r\n    {\r\n        return balances[balanceOwner];\r\n    }\r\n    \r\n    function allowance(address balanceOwner, address spender) external view returns (uint256)\r\n    {\r\n        return allowances[balanceOwner][spender];\r\n    }\r\n\r\n    function name() external view returns(string memory) {\r\n        return tokenName;\r\n    }\r\n\r\n    function symbol() external view returns(string memory) {\r\n        return tokenSymbol;\r\n    }\r\n\r\n    function decimals() external view returns(uint8) {\r\n        return tokenDecimals;\r\n    }\r\n\r\n    function totalSupply() external view returns (uint256) \r\n    {\r\n        return tokenTotalSupply;\r\n    }\r\n\r\n    modifier validAddress(address _address) \r\n    {\r\n        checkAddressValidity(_address);\r\n        _;\r\n    }\r\n\r\n    modifier enoughBalance(address from, uint256 value) \r\n    {\r\n        checkBalance(from, value);\r\n        _;\r\n    }\r\n\r\n    function checkAddressValidity(address _address) internal view\r\n    {\r\n        require(_address != address(0), \"The address can't be blank.\");\r\n        require(_address != address(this), \"The address can't point to Egg smart contract.\");\r\n    }\r\n\r\n    function checkBalance(address from, uint256 value) internal view\r\n    {\r\n        require(value <= balances[from], \"Specified address has less tokens than required for this operation.\");\r\n    }\r\n    \r\n    function setMigrationAgent(address agent) onlyOwner validAddress(agent) external\r\n    {\r\n        require(migrationAgentAddress == address(0), \"Migration Agent was specified already.\");\r\n        require(!isMigrated, 'Contract was already migrated.');\r\n        migrationAgentAddress = agent;\r\n        migrationAgentContract = IMigrationAgent(agent);\r\n    }\r\n\r\n    function migrate() external\r\n    {\r\n        require(migrationAgentAddress != address(0), \"Migration is closed or haven't started.\");\r\n\r\n        uint256 migratedAmount = balances[msg.sender];\r\n        require(migratedAmount > 0, \"No tokens to migrate.\");\r\n\r\n        balances[msg.sender] = 0;\r\n        emit MigratedFrom(msg.sender, migratedAmount);\r\n        migrationAgentContract.migrateTokens(msg.sender, migratedAmount);\r\n    }\r\n\r\n    function finalizeMigration() external\r\n    {\r\n        require(msg.sender == migrationAgentAddress, \"Only Migration Agent can finalize the migration.\");\r\n        migrationAgentAddress = address(0);\r\n        isMigrated = true;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"crowdsaleAddress\",\"type\":\"address\"},{\"name\":\"crowdsaleBalance\",\"type\":\"uint256\"}],\"name\":\"setCrowdsale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"balanceOwner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"agent\",\"type\":\"address\"}],\"name\":\"setMigrationAgent\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address[]\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"transferBatch\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address[]\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transferBatch\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"migrate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finalizeMigration\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenAddress\",\"type\":\"address\"},{\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"transferAnyERC20Token\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"balanceOwner\",\"type\":\"address\"},{\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amountToBurn\",\"type\":\"uint256\"}],\"name\":\"burnOwnTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenTotalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"name\",\"type\":\"string\"},{\"name\":\"symbol\",\"type\":\"string\"},{\"name\":\"totalSupply\",\"type\":\"uint256\"},{\"name\":\"developmentTeamAddress\",\"type\":\"address\"},{\"name\":\"developmentTeamBalance\",\"type\":\"uint256\"},{\"name\":\"marketingTeamAddress\",\"type\":\"address\"},{\"name\":\"marketingTeamBalance\",\"type\":\"uint256\"},{\"name\":\"productTeamAddress\",\"type\":\"address\"},{\"name\":\"productTeamBalance\",\"type\":\"uint256\"},{\"name\":\"airdropAddress\",\"type\":\"address\"},{\"name\":\"airdropBalance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"MigratedFrom\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"EggToken","CompilerVersion":"v0.5.3+commit.10d17f24","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000000000000000000000000000000000000000016000000000000000000000000000000000000000000000000000000000000001a000000000000000000000000000000000000000000d0d094863f85864ada000000000000000000000000000001c9512f82cda557b2c69b65737f9e23368d2281e00000000000000000000000000000000000000000052b7d2dcc80cd2e40000000000000000000000000000003cd0a1615d10da7e7e619d7c957dcf9c17264b75000000000000000000000000000000000000000009b18ab5df7180b6b8000000000000000000000000000000ae9137f9e0cca9880530e5a18ba97102c53fb05f000000000000000000000000000000000000000002e87669c308736a040000000000000000000000000000007bb3cd844210f477070fa7170c7148ef4884ef43000000000000000000000000000000000000000000205055e4b657710da00000000000000000000000000000000000000000000000000000000000000000000945676720546f6b656e000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000034547470000000000000000000000000000000000000000000000000000000000","Library":"","SwarmSource":"bzzr://40ad6907111d3407466e1bd4c28912764f109d6148c84cda468836590339dce8"}]}