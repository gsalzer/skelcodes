{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.5.2;\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ninterface IERC20 {\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n\r\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address who) external view returns (uint256);\r\n\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n/**\r\n * @title Math\r\n * @dev Assorted math operations\r\n */\r\nlibrary Math {\r\n    /**\r\n    * @dev Returns the largest of two numbers.\r\n    */\r\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a >= b ? a : b;\r\n    }\r\n\r\n    /**\r\n    * @dev Returns the smallest of two numbers.\r\n    */\r\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n    /**\r\n    * @dev Calculates the average of two numbers. Since these are integers,\r\n    * averages of an even and odd number cannot be represented, and will be\r\n    * rounded down.\r\n    */\r\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // (a + b) / 2 can overflow, so we distribute\r\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\r\n    }\r\n}\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Unsigned math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n    * @dev Multiplies two unsigned integers, reverts on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath#mul: Integer overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, \"SafeMath#div: Invalid divisor zero\");\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"SafeMath#sub: Integer underflow\");\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two unsigned integers, reverts on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath#add: Integer overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\r\n    * reverts when dividing by zero.\r\n    */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0, \"SafeMath#mod: Invalid divisor zero\");\r\n        return a % b;\r\n    }\r\n}\r\n\r\ncontract IUniswapExchange {\r\n    // Address of ERC20 token sold on this exchange\r\n    function tokenAddress() external view returns (address token);\r\n    // Address of Uniswap Factory\r\n    function factoryAddress() external view returns (address factory);\r\n    // Provide Liquidity\r\n    function addLiquidity(uint256 min_liquidity, uint256 max_tokens, uint256 deadline) external payable returns (uint256);\r\n    function removeLiquidity(uint256 amount, uint256 min_eth, uint256 min_tokens, uint256 deadline) external returns (uint256, uint256);\r\n    // Get Prices\r\n    function getEthToTokenInputPrice(uint256 eth_sold) external view returns (uint256 tokens_bought);\r\n    function getEthToTokenOutputPrice(uint256 tokens_bought) external view returns (uint256 eth_sold);\r\n    function getTokenToEthInputPrice(uint256 tokens_sold) external view returns (uint256 eth_bought);\r\n    function getTokenToEthOutputPrice(uint256 eth_bought) external view returns (uint256 tokens_sold);\r\n    // Trade ETH to ERC20\r\n    function ethToTokenSwapInput(uint256 min_tokens, uint256 deadline) external payable returns (uint256  tokens_bought);\r\n    function ethToTokenTransferInput(uint256 min_tokens, uint256 deadline, address recipient) external payable returns (uint256  tokens_bought);\r\n    function ethToTokenSwapOutput(uint256 tokens_bought, uint256 deadline) external payable returns (uint256  eth_sold);\r\n    function ethToTokenTransferOutput(uint256 tokens_bought, uint256 deadline, address recipient) external payable returns (uint256  eth_sold);\r\n    // Trade ERC20 to ETH\r\n    function tokenToEthSwapInput(uint256 tokens_sold, uint256 min_eth, uint256 deadline) external returns (uint256  eth_bought);\r\n    function tokenToEthTransferInput(uint256 tokens_sold, uint256 min_tokens, uint256 deadline, address recipient) external returns (uint256  eth_bought);\r\n    function tokenToEthSwapOutput(uint256 eth_bought, uint256 max_tokens, uint256 deadline) external returns (uint256  tokens_sold);\r\n    function tokenToEthTransferOutput(uint256 eth_bought, uint256 max_tokens, uint256 deadline, address recipient) external returns (uint256  tokens_sold);\r\n    // Trade ERC20 to ERC20\r\n    function tokenToTokenSwapInput(uint256 tokens_sold, uint256 min_tokens_bought, uint256 min_eth_bought, uint256 deadline, address token_addr) external returns (uint256  tokens_bought);\r\n    function tokenToTokenTransferInput(uint256 tokens_sold, uint256 min_tokens_bought, uint256 min_eth_bought, uint256 deadline, address recipient, address token_addr) external returns (uint256  tokens_bought);\r\n    function tokenToTokenSwapOutput(uint256 tokens_bought, uint256 max_tokens_sold, uint256 max_eth_sold, uint256 deadline, address token_addr) external returns (uint256  tokens_sold);\r\n    function tokenToTokenTransferOutput(uint256 tokens_bought, uint256 max_tokens_sold, uint256 max_eth_sold, uint256 deadline, address recipient, address token_addr) external returns (uint256  tokens_sold);\r\n    // Trade ERC20 to Custom Pool\r\n    function tokenToExchangeSwapInput(uint256 tokens_sold, uint256 min_tokens_bought, uint256 min_eth_bought, uint256 deadline, address exchange_addr) external returns (uint256  tokens_bought);\r\n    function tokenToExchangeTransferInput(uint256 tokens_sold, uint256 min_tokens_bought, uint256 min_eth_bought, uint256 deadline, address recipient, address exchange_addr) external returns (uint256  tokens_bought);\r\n    function tokenToExchangeSwapOutput(uint256 tokens_bought, uint256 max_tokens_sold, uint256 max_eth_sold, uint256 deadline, address exchange_addr) external returns (uint256  tokens_sold);\r\n    function tokenToExchangeTransferOutput(uint256 tokens_bought, uint256 max_tokens_sold, uint256 max_eth_sold, uint256 deadline, address recipient, address exchange_addr) external returns (uint256  tokens_sold);\r\n    // ERC20 comaptibility for liquidity tokens\r\n    bytes32 public name;\r\n    bytes32 public symbol;\r\n    uint256 public decimals;\r\n    function transfer(address _to, uint256 _value) external returns (bool);\r\n    function transferFrom(address _from, address _to, uint256 value) external returns (bool);\r\n    function approve(address _spender, uint256 _value) external returns (bool);\r\n    function allowance(address _owner, address _spender) external view returns (uint256);\r\n    function balanceOf(address _owner) external view returns (uint256);\r\n    // Never use\r\n    function setup(address token_addr) external;\r\n}\r\n\r\ncontract IUniswapFactory {\r\n    // Public Variables\r\n    address public exchangeTemplate;\r\n    uint256 public tokenCount;\r\n    // Create Exchange\r\n    function createExchange(address token) external returns (address payable exchange);\r\n    // Get Exchange and Token Info\r\n    function getExchange(address token) external view returns (address payable exchange);\r\n    function getToken(address exchange) external view returns (address token);\r\n    function getTokenWithId(uint256 tokenId) external view returns (address token);\r\n}\r\n\r\n/**\r\n * @title Standard ERC20 token\r\n *\r\n * @dev Implementation of the basic standard token.\r\n * https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md\r\n * Originally based on code by FirstBlood:\r\n * https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\r\n *\r\n * This implementation emits additional Approval events, allowing applications to reconstruct the allowance status for\r\n * all accounts just by listening to said events. Note that this isn't required by the specification, and other\r\n * compliant implementations may not do it.\r\n */\r\ncontract ERC20 is IERC20 {\r\n    using SafeMath for uint256;\r\n\r\n    mapping (address => uint256) private _balances;\r\n\r\n    mapping (address => mapping (address => uint256)) private _allowed;\r\n\r\n    uint256 private _totalSupply;\r\n\r\n    /**\r\n    * @dev Total number of tokens in existence\r\n    */\r\n    function totalSupply() public view returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    /**\r\n    * @dev Gets the balance of the specified address.\r\n    * @param owner The address to query the balance of.\r\n    * @return An uint256 representing the amount owned by the passed address.\r\n    */\r\n    function balanceOf(address owner) public view returns (uint256) {\r\n        return _balances[owner];\r\n    }\r\n\r\n    /**\r\n     * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n     * @param owner address The address which owns the funds.\r\n     * @param spender address The address which will spend the funds.\r\n     * @return A uint256 specifying the amount of tokens still available for the spender.\r\n     */\r\n    function allowance(address owner, address spender) public view returns (uint256) {\r\n        return _allowed[owner][spender];\r\n    }\r\n\r\n    /**\r\n    * @dev Transfer token for a specified address\r\n    * @param to The address to transfer to.\r\n    * @param value The amount to be transferred.\r\n    */\r\n    function transfer(address to, uint256 value) public returns (bool) {\r\n        _transfer(msg.sender, to, value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n     * Beware that changing an allowance with this method brings the risk that someone may use both the old\r\n     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\r\n     * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     * @param spender The address which will spend the funds.\r\n     * @param value The amount of tokens to be spent.\r\n     */\r\n    function approve(address spender, uint256 value) public returns (bool) {\r\n        require(spender != address(0), \"ERC20#approve: Cannot approve address zero\");\r\n\r\n        _allowed[msg.sender][spender] = value;\r\n        emit Approval(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Transfer tokens from one address to another.\r\n     * Note that while this function emits an Approval event, this is not required as per the specification,\r\n     * and other compliant implementations may not emit the event.\r\n     * @param from address The address which you want to send tokens from\r\n     * @param to address The address which you want to transfer to\r\n     * @param value uint256 the amount of tokens to be transferred\r\n     */\r\n    function transferFrom(address from, address to, uint256 value) public returns (bool) {\r\n        _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);\r\n        _transfer(from, to, value);\r\n        emit Approval(from, msg.sender, _allowed[from][msg.sender]);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Increase the amount of tokens that an owner allowed to a spender.\r\n     * approve should be called when allowed_[_spender] == 0. To increment\r\n     * allowed value is better to use this function to avoid 2 calls (and wait until\r\n     * the first transaction is mined)\r\n     * From MonolithDAO Token.sol\r\n     * Emits an Approval event.\r\n     * @param spender The address which will spend the funds.\r\n     * @param addedValue The amount of tokens to increase the allowance by.\r\n     */\r\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\r\n        require(spender != address(0), \"ERC20#increaseAllowance: Cannot increase allowance for address zero\");\r\n\r\n        _allowed[msg.sender][spender] = _allowed[msg.sender][spender].add(addedValue);\r\n        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Decrease the amount of tokens that an owner allowed to a spender.\r\n     * approve should be called when allowed_[_spender] == 0. To decrement\r\n     * allowed value is better to use this function to avoid 2 calls (and wait until\r\n     * the first transaction is mined)\r\n     * From MonolithDAO Token.sol\r\n     * Emits an Approval event.\r\n     * @param spender The address which will spend the funds.\r\n     * @param subtractedValue The amount of tokens to decrease the allowance by.\r\n     */\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\r\n        require(spender != address(0), \"ERC20#decreaseAllowance: Cannot decrease allowance for address zero\");\r\n\r\n        _allowed[msg.sender][spender] = _allowed[msg.sender][spender].sub(subtractedValue);\r\n        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev Transfer token for a specified addresses\r\n    * @param from The address to transfer from.\r\n    * @param to The address to transfer to.\r\n    * @param value The amount to be transferred.\r\n    */\r\n    function _transfer(address from, address to, uint256 value) internal {\r\n        require(to != address(0), \"ERC20#_transfer: Cannot transfer to address zero\");\r\n\r\n        _balances[from] = _balances[from].sub(value);\r\n        _balances[to] = _balances[to].add(value);\r\n        emit Transfer(from, to, value);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function that mints an amount of the token and assigns it to\r\n     * an account. This encapsulates the modification of balances such that the\r\n     * proper events are emitted.\r\n     * @param account The account that will receive the created tokens.\r\n     * @param value The amount that will be created.\r\n     */\r\n    function _mint(address account, uint256 value) internal {\r\n        require(account != address(0), \"ERC20#_mint: Cannot mint to address zero\");\r\n\r\n        _totalSupply = _totalSupply.add(value);\r\n        _balances[account] = _balances[account].add(value);\r\n        emit Transfer(address(0), account, value);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function that burns an amount of the token of a given\r\n     * account.\r\n     * @param account The account whose tokens will be burnt.\r\n     * @param value The amount that will be burnt.\r\n     */\r\n    function _burn(address account, uint256 value) internal {\r\n        require(account != address(0), \"ERC20#_burn: Cannot burn from address zero\");\r\n\r\n        _totalSupply = _totalSupply.sub(value);\r\n        _balances[account] = _balances[account].sub(value);\r\n        emit Transfer(account, address(0), value);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function that burns an amount of the token of a given\r\n     * account, deducting from the sender's allowance for said account. Uses the\r\n     * internal burn function.\r\n     * Emits an Approval event (reflecting the reduced allowance).\r\n     * @param account The account whose tokens will be burnt.\r\n     * @param value The amount that will be burnt.\r\n     */\r\n    function _burnFrom(address account, uint256 value) internal {\r\n        _allowed[account][msg.sender] = _allowed[account][msg.sender].sub(value);\r\n        _burn(account, value);\r\n        emit Approval(account, msg.sender, _allowed[account][msg.sender]);\r\n    }\r\n}\r\n\r\ncontract OracleToken is ERC20 {\r\n    string public name = \"Polaris Token\";\r\n    string public symbol = \"PLRS\";\r\n    uint8 public decimals = 18;\r\n    address public oracle;\r\n    address public token;\r\n\r\n    constructor(address _token) public payable {\r\n        oracle = msg.sender;\r\n        token = _token;\r\n    }\r\n\r\n    function () external payable {}\r\n\r\n    function mint(address to, uint amount) public returns (bool) {\r\n        require(msg.sender == oracle, \"OracleToken::mint: Only Oracle can call mint\");\r\n        _mint(to, amount);\r\n        return true;\r\n    }\r\n\r\n    function redeem(uint amount) public {\r\n        uint ethAmount = address(this).balance.mul(amount).div(totalSupply());\r\n        _burn(msg.sender, amount);\r\n        msg.sender.transfer(ethAmount);\r\n    }\r\n}\r\n\r\npragma experimental ABIEncoderV2;\r\n\r\n\r\ncontract Polaris {\r\n    using Math for uint;\r\n    using SafeMath for uint;\r\n\r\n    event NewMedian(address indexed token, uint ethReserve, uint tokenReserve);\r\n    event Subscribe(address indexed token, address indexed subscriber, uint amount);\r\n    event Unsubscribe(address indexed token, address indexed subscriber, uint amount);\r\n\r\n    uint8 public constant MAX_CHECKPOINTS = 15;\r\n\r\n    // Reward for a successful poke, in oracle tokens\r\n    uint public constant CHECKPOINT_REWARD = 1e18;\r\n\r\n    // Conditions for checkpoint reward\r\n    uint public constant MIN_PRICE_CHANGE = .01e18; // 1%\r\n    uint public constant MAX_TIME_SINCE_LAST_CHECKPOINT = 3 hours;\r\n\r\n    uint public constant PENDING_PERIOD = 3.5 minutes;\r\n\r\n    address public constant ETHER = address(0);\r\n\r\n    // Monthly subscription fee to subscribe to a single oracle\r\n    uint public constant MONTHLY_SUBSCRIPTION_FEE = 5 ether;\r\n    uint public constant ONE_MONTH_IN_SECONDS = 30 days;\r\n\r\n    IUniswapFactory public uniswap;\r\n\r\n    struct Account {\r\n        uint balance;\r\n        uint collectionTimestamp;\r\n    }\r\n\r\n    struct Checkpoint {\r\n        uint ethReserve;\r\n        uint tokenReserve;\r\n    }\r\n\r\n    struct Medianizer {\r\n        uint8 tail;\r\n        uint pendingStartTimestamp;\r\n        uint latestTimestamp;\r\n        Checkpoint[] prices;\r\n        Checkpoint[] pending;\r\n        Checkpoint median;\r\n    }\r\n\r\n    // Token => Subscriber => Account\r\n    mapping (address => mapping (address => Account)) public accounts;\r\n\r\n    // Token => Oracle Token (reward for poking)\r\n    mapping (address => OracleToken) public oracleTokens;\r\n\r\n    // Token => Medianizer\r\n    mapping (address => Medianizer) private medianizers;\r\n\r\n    constructor(IUniswapFactory _uniswap) public {\r\n        uniswap = _uniswap;\r\n    }\r\n\r\n    /**\r\n     * @dev Subscribe to read the price of a given token (e.g, DAI).\r\n     * @param token The address of the token to subscribe to.\r\n     */\r\n    function subscribe(address token) public payable {\r\n        Account storage account = accounts[token][msg.sender];\r\n        _collect(token, account);\r\n        account.balance = account.balance.add(msg.value);\r\n        require(account.balance >= MONTHLY_SUBSCRIPTION_FEE, \"Polaris::subscribe: Account balance is below the minimum\");\r\n        emit Subscribe(token, msg.sender, msg.value);\r\n    }\r\n\r\n    /**\r\n     * @dev Unsubscribe to a given token (e.g, DAI).\r\n     * @param token The address of the token to unsubscribe from.\r\n     * @param amount The requested amount to withdraw, in wei.\r\n     * @return The actual amount withdrawn, in wei.\r\n     */\r\n    function unsubscribe(address token, uint amount) public returns (uint) {\r\n        Account storage account = accounts[token][msg.sender];\r\n        _collect(token, account);\r\n        uint maxWithdrawAmount = account.balance.sub(MONTHLY_SUBSCRIPTION_FEE);\r\n        uint actualWithdrawAmount = amount.min(maxWithdrawAmount);\r\n        account.balance = account.balance.sub(actualWithdrawAmount);\r\n        msg.sender.transfer(actualWithdrawAmount);\r\n        emit Unsubscribe(token, msg.sender, actualWithdrawAmount);\r\n    }\r\n\r\n    /**\r\n     * @dev Collect subscription fees from a subscriber.\r\n     * @param token The address of the subscribed token to collect fees from.\r\n     * @param who The address of the subscriber.\r\n     */\r\n    function collect(address token, address who) public {\r\n        Account storage account = accounts[token][who];\r\n        _collect(token, account);\r\n    }\r\n\r\n    /**\r\n     * @dev Add a new price checkpoint.\r\n     * @param token The address of the token to checkpoint.\r\n     */\r\n    function poke(address token) public {\r\n        require(_isHuman(), \"Polaris::poke: Poke must be called by an externally owned account\");\r\n        OracleToken oracleToken = oracleTokens[token];\r\n\r\n        // Get the current reserves from Uniswap\r\n        Checkpoint memory checkpoint = _newCheckpoint(token);\r\n\r\n        if (address(oracleToken) == address(0)) {\r\n            _initializeMedianizer(token, checkpoint);\r\n        } else {\r\n            Medianizer storage medianizer = medianizers[token];\r\n\r\n            require(medianizer.latestTimestamp != block.timestamp, \"Polaris::poke: Cannot poke more than once per block\");\r\n\r\n            // See if checkpoint should be rewarded\r\n            if (_willRewardCheckpoint(token, checkpoint)) {\r\n                oracleToken.mint(msg.sender, CHECKPOINT_REWARD);\r\n            }\r\n\r\n            // If pending checkpoints are old, reset pending checkpoints\r\n            if (block.timestamp.sub(medianizer.pendingStartTimestamp) > PENDING_PERIOD || medianizer.pending.length == MAX_CHECKPOINTS) {\r\n                medianizer.pending.length = 0;\r\n                medianizer.tail = (medianizer.tail + 1) % MAX_CHECKPOINTS;\r\n                medianizer.pendingStartTimestamp = block.timestamp;\r\n            }\r\n\r\n            medianizer.latestTimestamp = block.timestamp;\r\n\r\n            // Add the checkpoint to the pending array\r\n            medianizer.pending.push(checkpoint);\r\n            \r\n            // Add the pending median to the prices array\r\n            medianizer.prices[medianizer.tail] = _medianize(medianizer.pending);\r\n            \r\n            // Find and store the prices median\r\n            medianizer.median = _medianize(medianizer.prices);\r\n\r\n            emit NewMedian(token, medianizer.median.ethReserve, medianizer.median.tokenReserve);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Get price data for a given token.\r\n     * @param token The address of the token to query.\r\n     * @return The price data struct.\r\n     */\r\n    function getMedianizer(address token) public view returns (Medianizer memory) {\r\n        require(_isSubscriber(accounts[token][msg.sender]) || _isHuman(), \"Polaris::getMedianizer: Not subscribed\");\r\n        return medianizers[token];\r\n    }\r\n\r\n    /**\r\n     * @notice This uses the x * y = k bonding curve to determine the destination amount based on the medianized price.\r\n     *              ð™x = (ð™y * x) / (y + ð™y)\r\n     * @dev Get the amount of destination token, based on a given amount of source token.\r\n     * @param src The address of the source token.\r\n     * @param dest The address of the destination token.\r\n     * @param srcAmount The amount of the source token.\r\n     * @return The amount of destination token.\r\n     */\r\n    function getDestAmount(address src, address dest, uint srcAmount) public view returns (uint) {\r\n        if (!_isHuman()) {\r\n            require(src == ETHER || _isSubscriber(accounts[src][msg.sender]), \"Polaris::getDestAmount: Not subscribed\");\r\n            require(dest == ETHER || _isSubscriber(accounts[dest][msg.sender]), \"Polaris::getDestAmount: Not subscribed\");    \r\n        }\r\n\r\n        if (src == dest) {\r\n            return srcAmount;\r\n        } else if (src == ETHER) {\r\n            Checkpoint memory median = medianizers[dest].median;\r\n            return srcAmount.mul(median.tokenReserve).div(median.ethReserve.add(srcAmount));\r\n        } else if (dest == ETHER) {\r\n            Checkpoint memory median = medianizers[src].median;\r\n            return srcAmount.mul(median.ethReserve).div(median.tokenReserve.add(srcAmount));\r\n        } else {\r\n            Checkpoint memory srcMedian = medianizers[src].median;\r\n            Checkpoint memory destMedian = medianizers[dest].median;\r\n            \r\n            uint ethAmount = srcAmount.mul(srcMedian.ethReserve).div(srcMedian.tokenReserve.add(srcAmount));\r\n            return ethAmount.mul(destMedian.ethReserve).div(destMedian.tokenReserve.add(ethAmount));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Determine whether a given checkpoint would be rewarded with newly minted oracle tokens.\r\n     * @param token The address of the token to query checkpoint for.\r\n     * @return True if given checkpoint satisfies any of the following:\r\n     *              Less than required checkpoints exist to calculate a valid median\r\n     *              Exceeds max time since last checkpoint\r\n     *              Exceeds minimum price change from median AND no pending checkpoints\r\n     *              Exceeds minimum percent change from pending checkpoints median\r\n     *              Exceeds minimum percent change from last checkpoint\r\n     */\r\n    function willRewardCheckpoint(address token) public view returns (bool) {\r\n        Checkpoint memory checkpoint = _newCheckpoint(token);\r\n        return _willRewardCheckpoint(token, checkpoint);\r\n    }\r\n\r\n    /**\r\n     * @dev Get the account for a given subscriber of a token feed.\r\n     * @param token The token to query the account of the given subscriber.\r\n     * @param who The subscriber to query the account of the given token feed.\r\n     * @return The account of the subscriber of the given token feed.\r\n     */\r\n    function getAccount(address token, address who) public view returns (Account memory) {\r\n        return accounts[token][who];\r\n    }\r\n\r\n    /**\r\n     * @dev Get the owed amount for a given subscriber of a token feed.\r\n     * @param token The token to query the owed amount of the given subscriber.\r\n     * @param who The subscriber to query the owed amount for the given token feed.\r\n     * @return The owed amount of the subscriber of the given token feed.\r\n     */\r\n    function getOwedAmount(address token, address who) public view returns (uint) {\r\n        Account storage account = accounts[token][who];\r\n        return _getOwedAmount(account);\r\n    }\r\n\r\n    /**\r\n     * @dev Update the subscriber balance of a given token feed.\r\n     * @param token The token to collect subscription revenues for.\r\n     * @param account The subscriber account to collect subscription revenues from.\r\n     */\r\n    function _collect(address token, Account storage account) internal {\r\n        if (account.balance == 0) {\r\n            account.collectionTimestamp = block.timestamp;\r\n            return;\r\n        }\r\n\r\n        uint owedAmount = _getOwedAmount(account);\r\n        OracleToken oracleToken = oracleTokens[token];\r\n\r\n        // If the subscriber does not have enough, collect the remaining balance\r\n        if (owedAmount >= account.balance) {\r\n            address(oracleToken).transfer(account.balance);\r\n            account.balance = 0;\r\n        } else {\r\n            address(oracleToken).transfer(owedAmount);\r\n            account.balance = account.balance.sub(owedAmount);\r\n        }\r\n\r\n        account.collectionTimestamp = block.timestamp;\r\n    }\r\n\r\n    /**\r\n     * @dev Initialize the medianizer\r\n     * @param token The token to initialize the medianizer for.\r\n     * @param checkpoint The new checkpoint to initialize the medianizer with.\r\n     */\r\n    function _initializeMedianizer(address token, Checkpoint memory checkpoint) internal {\r\n        address payable exchange = uniswap.getExchange(token);\r\n        require(exchange != address(0), \"Polaris::_initializeMedianizer: Token must exist on Uniswap\");\r\n\r\n        OracleToken oracleToken = new OracleToken(token);\r\n        oracleTokens[token] = oracleToken;\r\n        // Reward additional oracle tokens for the first poke to compensate for extra gas costs\r\n        oracleToken.mint(msg.sender, CHECKPOINT_REWARD.mul(10));\r\n\r\n        Medianizer storage medianizer = medianizers[token];\r\n        medianizer.pending.push(checkpoint);\r\n        medianizer.median = checkpoint;\r\n        medianizer.latestTimestamp = block.timestamp;\r\n        medianizer.pendingStartTimestamp = block.timestamp;\r\n\r\n        // Hydrate prices queue\r\n        for (uint i = 0; i < MAX_CHECKPOINTS; i++) {\r\n            medianizer.prices.push(checkpoint);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Find the median given an array of checkpoints.\r\n     * @param checkpoints The array of checkpoints to find the median.\r\n     * @return The median checkpoint within the given array.\r\n     */\r\n    function _medianize(Checkpoint[] memory checkpoints) internal pure returns (Checkpoint memory) {\r\n        // To minimize complexity, return the higher of the two middle checkpoints in even-sized arrays instead of the average.\r\n        uint k = checkpoints.length.div(2); \r\n        uint left = 0;\r\n        uint right = checkpoints.length.sub(1);\r\n\r\n        while (left < right) {\r\n            uint pivotIndex = left.add(right).div(2);\r\n            Checkpoint memory pivotCheckpoint = checkpoints[pivotIndex];\r\n\r\n            (checkpoints[pivotIndex], checkpoints[right]) = (checkpoints[right], checkpoints[pivotIndex]);\r\n            uint storeIndex = left;\r\n            for (uint i = left; i < right; i++) {\r\n                if (_isLessThan(checkpoints[i], pivotCheckpoint)) {\r\n                    (checkpoints[storeIndex], checkpoints[i]) = (checkpoints[i], checkpoints[storeIndex]);\r\n                    storeIndex++;\r\n                }\r\n            }\r\n\r\n            (checkpoints[storeIndex], checkpoints[right]) = (checkpoints[right], checkpoints[storeIndex]);\r\n            if (storeIndex < k) {\r\n                left = storeIndex.add(1);\r\n            } else {\r\n                right = storeIndex;\r\n            }\r\n        }\r\n\r\n        return checkpoints[k];\r\n    }\r\n\r\n    /**\r\n     * @dev Determine if checkpoint x is less than checkpoint y.\r\n     * @param x The first checkpoint for comparison.\r\n     * @param y The second checkpoint for comparison.\r\n     * @return True if x is less than y.\r\n     */\r\n    function _isLessThan(Checkpoint memory x, Checkpoint memory y) internal pure returns (bool) {\r\n        return x.ethReserve.mul(y.tokenReserve) < y.ethReserve.mul(x.tokenReserve);\r\n    }\r\n\r\n    /**\r\n     * @dev Check if msg.sender is an externally owned account.\r\n     * @return True if msg.sender is an externally owned account, false if smart contract.\r\n     */\r\n    function _isHuman() internal view returns (bool) {\r\n        return msg.sender == tx.origin;\r\n    }\r\n\r\n    /**\r\n     * @dev Get the reserve values of a Uniswap exchange for a given token.\r\n     * @param token The token to query the reserve values for.\r\n     * @return A checkpoint holding the appropriate reserve values.\r\n     */\r\n    function _newCheckpoint(address token) internal view returns (Checkpoint memory) {\r\n        address payable exchange = uniswap.getExchange(token);\r\n        return Checkpoint({\r\n            ethReserve: exchange.balance,\r\n            tokenReserve: IERC20(token).balanceOf(exchange)\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @dev Get subscriber status of a given account for a given token.\r\n     * @param account The account to query.\r\n     * @return True if subscribed.\r\n     */\r\n    function _isSubscriber(Account storage account) internal view returns (bool) {\r\n        // Strict inequality to return false for users who never subscribed and owe zero.      \r\n        return account.balance > _getOwedAmount(account);\r\n    }\r\n\r\n    /**\r\n     * @dev Get amount owed by an account. Accrued amount minus collections.\r\n     * @param account The account to query.\r\n     * @return Amount owed.\r\n     */\r\n    function _getOwedAmount(Account storage account) internal view returns (uint) {\r\n        if (account.collectionTimestamp == 0) return 0;\r\n\r\n        uint timeElapsed = block.timestamp.sub(account.collectionTimestamp);\r\n        return MONTHLY_SUBSCRIPTION_FEE.mul(timeElapsed).div(ONE_MONTH_IN_SECONDS);\r\n    }\r\n\r\n    /**\r\n     * @dev Determine whether a given checkpoint would be rewarded with newly minted oracle tokens.\r\n     * @param token The address of the token to query checkpoint for.\r\n     * @param checkpoint The checkpoint to test for reward of oracle tokens.\r\n     * @return True if given checkpoint satisfies any of the following:\r\n     *              Less than required checkpoints exist to calculate a valid median\r\n     *              Exceeds max time since last checkpoint\r\n     *              Exceeds minimum price change from median AND no pending checkpoints\r\n     *              Exceeds minimum percent change from pending checkpoints median\r\n     *              Exceeds minimum percent change from last checkpoint\r\n     */\r\n    function _willRewardCheckpoint(address token, Checkpoint memory checkpoint) internal view returns (bool) {\r\n        Medianizer memory medianizer = medianizers[token];\r\n\r\n        return (\r\n            medianizer.prices.length < MAX_CHECKPOINTS ||\r\n            block.timestamp.sub(medianizer.latestTimestamp) >= MAX_TIME_SINCE_LAST_CHECKPOINT ||\r\n            (block.timestamp.sub(medianizer.pendingStartTimestamp) >= PENDING_PERIOD && _percentChange(medianizer.median, checkpoint) >= MIN_PRICE_CHANGE) ||\r\n            _percentChange(medianizer.prices[medianizer.tail], checkpoint) >= MIN_PRICE_CHANGE ||\r\n            _percentChange(medianizer.pending[medianizer.pending.length.sub(1)], checkpoint) >= MIN_PRICE_CHANGE\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Get the percent change between two checkpoints.\r\n     * @param x The first checkpoint.\r\n     * @param y The second checkpoint.\r\n     * @return The absolute value of the percent change, with 18 decimals of precision (e.g., .01e18 = 1%).\r\n     */\r\n    function _percentChange(Checkpoint memory x, Checkpoint memory y) internal pure returns (uint) {\r\n        uint a = x.ethReserve.mul(y.tokenReserve);\r\n        uint b = y.ethReserve.mul(x.tokenReserve);\r\n        uint diff = a > b ? a.sub(b) : b.sub(a);\r\n        return diff.mul(10 ** 18).div(a);\r\n    }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"MONTHLY_SUBSCRIPTION_FEE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"}],\"name\":\"willRewardCheckpoint\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_TIME_SINCE_LAST_CHECKPOINT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"uniswap\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getMedianizer\",\"outputs\":[{\"components\":[{\"name\":\"tail\",\"type\":\"uint8\"},{\"name\":\"pendingStartTimestamp\",\"type\":\"uint256\"},{\"name\":\"latestTimestamp\",\"type\":\"uint256\"},{\"components\":[{\"name\":\"ethReserve\",\"type\":\"uint256\"},{\"name\":\"tokenReserve\",\"type\":\"uint256\"}],\"name\":\"prices\",\"type\":\"tuple[]\"},{\"components\":[{\"name\":\"ethReserve\",\"type\":\"uint256\"},{\"name\":\"tokenReserve\",\"type\":\"uint256\"}],\"name\":\"pending\",\"type\":\"tuple[]\"},{\"components\":[{\"name\":\"ethReserve\",\"type\":\"uint256\"},{\"name\":\"tokenReserve\",\"type\":\"uint256\"}],\"name\":\"median\",\"type\":\"tuple\"}],\"name\":\"\",\"type\":\"tuple\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"}],\"name\":\"subscribe\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ETHER\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_CHECKPOINTS\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ONE_MONTH_IN_SECONDS\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CHECKPOINT_REWARD\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"oracleTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"unsubscribe\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"who\",\"type\":\"address\"}],\"name\":\"collect\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"who\",\"type\":\"address\"}],\"name\":\"getOwedAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"accounts\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"},{\"name\":\"collectionTimestamp\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"}],\"name\":\"poke\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MIN_PRICE_CHANGE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"src\",\"type\":\"address\"},{\"name\":\"dest\",\"type\":\"address\"},{\"name\":\"srcAmount\",\"type\":\"uint256\"}],\"name\":\"getDestAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"who\",\"type\":\"address\"}],\"name\":\"getAccount\",\"outputs\":[{\"components\":[{\"name\":\"balance\",\"type\":\"uint256\"},{\"name\":\"collectionTimestamp\",\"type\":\"uint256\"}],\"name\":\"\",\"type\":\"tuple\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"PENDING_PERIOD\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_uniswap\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"ethReserve\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokenReserve\",\"type\":\"uint256\"}],\"name\":\"NewMedian\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"subscriber\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Subscribe\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"subscriber\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Unsubscribe\",\"type\":\"event\"}]","ContractName":"Polaris","CompilerVersion":"v0.5.2+commit.1df8f40c","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000c0a47dfe034b400b47bdad5fecda2621de6c4d95","Library":"","SwarmSource":"bzzr://27f78db4ee58efae0039bbd3f856c4ddf728b547472e6873e51150243cb78df1"}]}