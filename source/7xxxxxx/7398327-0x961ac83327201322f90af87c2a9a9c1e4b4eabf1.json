{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.5.3;\r\ninterface erc20token {\r\n    function transfer(address _to, uint256 _amount) external returns (bool);\r\n    function balanceOf(address _p) external returns (uint256);\r\n    function decimals() external returns (uint256);\r\n}\r\ncontract dapMerkle {\r\n    \r\n    /* variables */\r\n    bytes32 public root;\r\n    erc20token public token;\r\n    address payable owner;\r\n    uint256 public amountSent;\r\n    \r\n    /* storage */\r\n    mapping (address => bool) public sent;\r\n    \r\n    /* events */\r\n    event tokensSent(address to, uint256 amount);\r\n    event rootChanged(bytes32 root);\r\n    \r\n    /* modifiers */\r\n    modifier onlyOwner(){\r\n        if (msg.sender == owner){\r\n            _;\r\n        }\r\n    }\r\n    constructor (address _token, bytes32 _merkleRoot) public{\r\n        owner = msg.sender;\r\n        root = _merkleRoot;\r\n        token = erc20token(_token);\r\n    }\r\n    function setRoot(bytes32 _root) external onlyOwner {\r\n        root = _root;\r\n        emit rootChanged(_root);\r\n    }\r\n    \r\n    function getTokenBalance() external returns (uint256){\r\n        return token.balanceOf(address(this));\r\n    }\r\n    \r\n    function abortAirdrop() onlyOwner external{\r\n        require(token.balanceOf(address(this)) > 0);\r\n        assert( token.transfer(owner, token.balanceOf( address(this) ) ) );\r\n        selfdestruct(owner);\r\n    }\r\n    function getTokens(bytes32[] calldata _proof, address _receiver, uint256 _amount) external returns (bool){\r\n        require (!sent[_receiver]);\r\n        require (_amount > 0);\r\n        require( verify(_proof, makeLeaf(_receiver, _amount)) );\r\n        uint256 decimals = token.decimals();\r\n        uint256 amount = _amount*(10**decimals);\r\n        sent[_receiver] = true;\r\n        assert(token.transfer(_receiver, amount));\r\n        amountSent += _amount;\r\n        emit tokensSent(_receiver, _amount);\r\n        return true;\r\n        \r\n    }\r\n\r\n     function addressToAsciiString(address x) internal pure returns (string memory) {\r\n        bytes memory s = new bytes(40);\r\n        for (uint i = 0; i < 20; i++) {\r\n            byte b = byte(uint8(uint(x) / (2**(8*(19 - i)))));\r\n            byte hi = byte(uint8(b) / 16);\r\n            byte lo = byte(uint8(b) - 16 * uint8(hi));\r\n            s[2*i] = char(hi);\r\n            s[2*i+1] = char(lo);\r\n        }\r\n        return string(s);\r\n    }\r\n\r\n    function char(byte b) internal pure returns (byte c) {\r\n        if (b < byte(uint8(10))) return byte(uint8(b) + 0x30);\r\n        else return byte(uint8(b) + 0x57);\r\n    }\r\n    \r\n    function uintToStr(uint i) internal pure returns (string memory){\r\n        if (i == 0) return \"0\";\r\n        uint j = i;\r\n        uint length;\r\n        while (j != 0){\r\n            length++;\r\n            j /= 10;\r\n        }\r\n        bytes memory bstr = new bytes(length);\r\n        uint k = length - 1;\r\n        while (i != 0){\r\n            bstr[k--] = byte(uint8(48 + i % 10));\r\n            i /= 10;\r\n        }\r\n        return string(bstr);\r\n    }\r\n    \r\n     function makeLeaf(address _a, uint256 _n) internal pure returns(bytes32) {\r\n        string memory prefix = \"0x\";\r\n        string memory space = \" \";\r\n\r\n        \r\n        bytes memory _ba = bytes(prefix);\r\n        bytes memory _bb = bytes(addressToAsciiString(_a));\r\n        bytes memory _bc = bytes(space);\r\n        bytes memory _bd = bytes(uintToStr(_n));\r\n        string memory abcde = new string(_ba.length + _bb.length + _bc.length + _bd.length);\r\n        bytes memory babcde = bytes(abcde);\r\n        uint k = 0;\r\n        for (uint8 i = 0; i < _ba.length; i++) babcde[k++] = _ba[i];\r\n        for (uint8 i = 0; i < _bb.length; i++) babcde[k++] = _bb[i];\r\n        for (uint8 i = 0; i < _bc.length; i++) babcde[k++] = _bc[i];\r\n        for (uint8 i = 0; i < _bd.length; i++) babcde[k++] = _bd[i];\r\n\r\n        return keccak256(babcde);\r\n    }\r\n    function verify(bytes32[] memory proof, bytes32 leaf) internal view returns (bool) {\r\n        bytes32 computedHash = leaf;\r\n\r\n        for (uint256 i = 0; i < proof.length; i++) {\r\n            bytes32 proofElement = proof[i];\r\n\r\n            if (computedHash < proofElement) {\r\n                // Hash(current computed hash + current element of the proof)\r\n                computedHash = keccak256(abi.encodePacked(computedHash, proofElement));\r\n            } else {\r\n                // Hash(current element of the proof + current computed hash)\r\n                computedHash = keccak256(abi.encodePacked(proofElement, computedHash));\r\n            }\r\n        }\r\n\r\n        // Check if the computed hash (root) is equal to the provided root\r\n        return computedHash == root;\r\n    }\r\n    function makeString(address _a, uint256 _n) external pure returns(bytes memory){\r\n        string memory prefix = \"0x\";\r\n        string memory space = \" \";\r\n\r\n        \r\n        bytes memory _ba = bytes(prefix);\r\n        bytes memory _bb = bytes(addressToAsciiString(_a));\r\n        bytes memory _bc = bytes(space);\r\n        bytes memory _bd = bytes(uintToStr(_n));\r\n        string memory abcde = new string(_ba.length + _bb.length + _bc.length + _bd.length);\r\n        bytes memory babcde = bytes(abcde);\r\n        uint k = 0;\r\n        for (uint8 i = 0; i < _ba.length; i++) babcde[k++] = _ba[i];\r\n        for (uint8 i = 0; i < _bb.length; i++) babcde[k++] = _bb[i];\r\n        for (uint8 i = 0; i < _bc.length; i++) babcde[k++] = _bc[i];\r\n        for (uint8 i = 0; i < _bd.length; i++) babcde[k++] = _bd[i];\r\n\r\n        return babcde;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"amountSent\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"abortAirdrop\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"sent\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"getTokenBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_proof\",\"type\":\"bytes32[]\"},{\"name\":\"_receiver\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"getTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_root\",\"type\":\"bytes32\"}],\"name\":\"setRoot\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_a\",\"type\":\"address\"},{\"name\":\"_n\",\"type\":\"uint256\"}],\"name\":\"makeString\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"root\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_merkleRoot\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"tokensSent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"root\",\"type\":\"bytes32\"}],\"name\":\"rootChanged\",\"type\":\"event\"}]","ContractName":"dapMerkle","CompilerVersion":"v0.5.3+commit.10d17f24","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000e4404db877e4c2fa39942b8002bda9f45edc031d77dcdcc33a203ce1c11b068b9786badc3158638f383aeb33846b2877eb9a709f","Library":"","SwarmSource":"bzzr://8a9bfeb411d056caf4854b5c19c80df8235d4cf76444d9a79eed725611c579a7"}]}