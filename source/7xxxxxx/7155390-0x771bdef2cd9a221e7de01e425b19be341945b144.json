{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\n/**\r\n * @title EnumerableSetAddress\r\n * @dev Library containing logic for an enumerable set of address values -- supports checking for presence, adding,\r\n * removing elements, and enumerating elements (without preserving order between mutable operations).\r\n */\r\nlibrary EnumerableSetAddress {\r\n\r\n    struct Data {\r\n        address[] elements;\r\n        mapping(address => uint160) elementToIndex;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns whether the set contains a given element\r\n     *\r\n     * @param self Data storage Reference to set data\r\n     * @param value address Value being checked for existence\r\n     * @return bool\r\n     */\r\n    function contains(Data storage self, address value) external view returns (bool) {\r\n        uint160 mappingIndex = self.elementToIndex[value];\r\n        return (mappingIndex < self.elements.length) && (self.elements[mappingIndex] == value);\r\n    }\r\n\r\n    /**\r\n     * @dev Adds a new element to the set.  Element must not belong to set yet.\r\n     *\r\n     * @param self Data storage Reference to set data\r\n     * @param value address Value being added\r\n     */\r\n    function add(Data storage self, address value) external {\r\n        uint160 mappingIndex = self.elementToIndex[value];\r\n        require(!((mappingIndex < self.elements.length) && (self.elements[mappingIndex] == value)));\r\n\r\n        self.elementToIndex[value] = uint160(self.elements.length);\r\n        self.elements.push(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Removes an element from the set.  Element must already belong to set.\r\n     *\r\n     * @param self Data storage Reference to set data\r\n     * @param value address Value being removed\r\n     */\r\n    function remove(Data storage self, address value) external {\r\n        uint160 currentElementIndex = self.elementToIndex[value];\r\n        require((currentElementIndex < self.elements.length) && (self.elements[currentElementIndex] == value));\r\n\r\n        uint160 lastElementIndex = uint160(self.elements.length - 1);\r\n        address lastElement = self.elements[lastElementIndex];\r\n\r\n        self.elements[currentElementIndex] = lastElement;\r\n        self.elements[lastElementIndex] = 0;\r\n        self.elements.length--;\r\n\r\n        self.elementToIndex[lastElement] = currentElementIndex;\r\n        self.elementToIndex[value] = 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the number of elements on the set.\r\n     *\r\n     * @param self Data storage Reference to set data\r\n     * @return uint160\r\n     */\r\n    function size(Data storage self) external view returns (uint160) {\r\n        return uint160(self.elements.length);\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the N-th element from the set, 0-indexed.  Note that the ordering is not necessarily consistent\r\n     * before and after add, remove operations.\r\n     *\r\n     * @param self Data storage Reference to set data\r\n     * @param index uint160 0-indexed position of the element being queried\r\n     * @return address\r\n     */\r\n    function get(Data storage self, uint160 index) external view returns (address) {\r\n        return self.elements[index];\r\n    }\r\n\r\n    /**\r\n     * @dev Mark the set as empty (not containing any further elements).\r\n     *\r\n     * @param self Data storage Reference to set data\r\n     */\r\n    function clear(Data storage self) external {\r\n        self.elements.length = 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Copy all data from a source set to a target set\r\n     *\r\n     * @param source Data storage Reference to source data\r\n     * @param target Data storage Reference to target data\r\n     */\r\n    function copy(Data storage source, Data storage target) external {\r\n        uint160 numElements = uint160(source.elements.length);\r\n\r\n        target.elements.length = numElements;\r\n        for (uint160 index = 0; index < numElements; index++) {\r\n            address element = source.elements[index];\r\n            target.elements[index] = element;\r\n            target.elementToIndex[element] = index;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Adds all elements from another set into this set, if they are not already present\r\n     *\r\n     * @param self Data storage Reference to set being edited\r\n     * @param other Data storage Reference to set items are being added from\r\n     */\r\n    function addAll(Data storage self, Data storage other) external {\r\n        uint160 numElements = uint160(other.elements.length);\r\n\r\n        for (uint160 index = 0; index < numElements; index++) {\r\n            address value = other.elements[index];\r\n\r\n            uint160 mappingIndex = self.elementToIndex[value];\r\n            if (!((mappingIndex < self.elements.length) && (self.elements[mappingIndex] == value))) {\r\n                self.elementToIndex[value] = uint160(self.elements.length);\r\n                self.elements.push(value);\r\n            }\r\n        }\r\n    }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"self\",\"type\":\"EnumerableSetAddress.Data storage\"}],\"name\":\"size\",\"outputs\":[{\"name\":\"\",\"type\":\"uint160\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"self\",\"type\":\"EnumerableSetAddress.Data storage\"},{\"name\":\"value\",\"type\":\"address\"}],\"name\":\"add\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"self\",\"type\":\"EnumerableSetAddress.Data storage\"},{\"name\":\"value\",\"type\":\"address\"}],\"name\":\"remove\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"self\",\"type\":\"EnumerableSetAddress.Data storage\"},{\"name\":\"index\",\"type\":\"uint160\"}],\"name\":\"get\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"self\",\"type\":\"EnumerableSetAddress.Data storage\"},{\"name\":\"other\",\"type\":\"EnumerableSetAddress.Data storage\"}],\"name\":\"addAll\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"self\",\"type\":\"EnumerableSetAddress.Data storage\"},{\"name\":\"value\",\"type\":\"address\"}],\"name\":\"contains\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"source\",\"type\":\"EnumerableSetAddress.Data storage\"},{\"name\":\"target\",\"type\":\"EnumerableSetAddress.Data storage\"}],\"name\":\"copy\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"self\",\"type\":\"EnumerableSetAddress.Data storage\"}],\"name\":\"clear\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"EnumerableSetAddress","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"10000","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://9467d1fbdfd7cdb4c14f10094e294555af7e660644496264a6b13f92189368b9"}]}