{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.7;\r\n\r\n/**\r\n * Copy right (c) Donex UG (haftungsbeschraenkt)\r\n * All rights reserved\r\n * Version 0.2.1 (BETA)\r\n */\r\n\r\ncontract Master {\r\n\r\n    address payable ownerAddress;\r\n    address constant oracleAddress = 0xE8013bD526100Ebf67ace0E0F21a296D8974f0A4;\r\n\r\n    mapping (uint => bool) public validDueDate;\r\n\r\n\r\n    event NewContract (\r\n        address contractAddress\r\n    );\r\n\r\n\r\n    modifier onlyByOwner () {\r\n        require(msg.sender ==  ownerAddress);\r\n        _;\r\n    }\r\n\r\n\r\n    constructor () public {\r\n        ownerAddress = msg.sender;\r\n    }\r\n\r\n\r\n    /**\r\n     * @notice Create a contract representing a conditional payment.\r\n     * @dev The creator address can be used to connect another smart contract to this master.\r\n     * @param creator Provide the address of the creator of this contract.\r\n     * @param long Decide if you want to be in the long or short position of your contract.\r\n     * @param dueDate Set the due date of your contract. Note that the due date needs to match a valid due date.\r\n     * @param strikePrice Choose a strike price which will be used on the due date for calculation of the payout. Make sure that the format is correct.\r\n     */\r\n    function createConditionalPayment\r\n    (\r\n        address payable creator,\r\n        bool long,\r\n        uint256 dueDate,\r\n        uint256 strikePrice\r\n    )\r\n        payable\r\n        public\r\n        returns(address newDerivativeAddress)\r\n    {\r\n        require(validDueDate[dueDate]);\r\n        ConditionalPayment conditionalPayment = (new ConditionalPayment).value(msg.value)\r\n        (\r\n            creator,\r\n            long,\r\n            dueDate,\r\n            strikePrice\r\n        );\r\n\r\n        emit NewContract(address(conditionalPayment));\r\n\r\n        return address(conditionalPayment);\r\n    }\r\n\r\n    /// @notice This function will be called by every conditional payment contract at settlement and requests the price from the oracle.\r\n    function settle\r\n    (\r\n        uint256 dueDate\r\n    )\r\n        public\r\n        payable\r\n        returns (uint256)\r\n    {\r\n        Oracle o = Oracle(oracleAddress);\r\n        return o.sendPrice(dueDate);\r\n    }\r\n\r\n\r\n    /**\r\n     * Owner functions\r\n     */\r\n\r\n    function setValidDueDate\r\n    (\r\n        uint dueDate,\r\n        bool valid\r\n    )\r\n        public\r\n        onlyByOwner\r\n    {\r\n        validDueDate[dueDate] = valid;\r\n    }\r\n\r\n    function withdrawFees ()\r\n        public\r\n        onlyByOwner\r\n    {\r\n        msg.sender.transfer(address(this).balance);\r\n    }\r\n\r\n    function balanceOfFactory ()\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return (address(this).balance);\r\n    }\r\n\r\n}\r\n\r\n\r\n\r\n/**\r\n * @title This contract serves as a conditional payment based on the spot price of an asset on the due date compared to a strike price.\r\n * @notice Use the Master to create this contract.\r\n */\r\ncontract ConditionalPayment {\r\n\r\n    address payable public masterAddress;\r\n\r\n    address constant public withdrawFunctionsAddress = 0x0b564F0aD4dcb35Cd43eff2f26Bf96B670eaBF5e;\r\n\r\n    address payable public creator;\r\n\r\n    uint256 public dueDate;\r\n    uint256 public strikePrice;\r\n    bool public creatorLong;\r\n\r\n    uint8 public countCounterparties;\r\n\r\n    bool public isSettled;\r\n    uint256 public settlementPrice;\r\n\r\n    uint256 public totalStakeCounterparties;\r\n\r\n    mapping(address => uint256) public stakes;\r\n\r\n\r\n    event ContractAltered ();\r\n\r\n    event UpdatedParticipant\r\n    (\r\n        address indexed participant,\r\n        uint256 stake\r\n    );\r\n\r\n\r\n    modifier onlyByCreator()\r\n    {\r\n        require(msg.sender ==  creator);\r\n        _;\r\n    }\r\n\r\n    modifier onlyIncremental(uint amount)\r\n    {\r\n        require(amount % (0.1 ether) == 0);\r\n        _;\r\n    }\r\n\r\n    modifier nonZeroMsgValue()\r\n    {\r\n        require(msg.value > 0);\r\n        _;\r\n    }\r\n\r\n    modifier dueDateInFuture()\r\n    {\r\n        _;\r\n        require(now < dueDate);\r\n    }\r\n\r\n    modifier nonZeroStrikePrice(uint256 newStrikePrice)\r\n    {\r\n        require(newStrikePrice > 0);\r\n        _;\r\n    }\r\n\r\n    modifier emitsContractAlteredEvent()\r\n    {\r\n        _;\r\n        emit ContractAltered();\r\n    }\r\n\r\n    modifier emitsUpdatedParticipantEvent(address participant)\r\n    {\r\n        _;\r\n        emit UpdatedParticipant(participant,stakes[participant]);\r\n    }\r\n\r\n\r\n    constructor\r\n    (\r\n        address payable _creator,\r\n        bool _long,\r\n        uint256 _dueDate,\r\n        uint256 _strikePrice\r\n    )\r\n        payable\r\n        public\r\n        onlyIncremental(msg.value)\r\n        nonZeroStrikePrice(_strikePrice)\r\n        nonZeroMsgValue\r\n        dueDateInFuture\r\n        emitsUpdatedParticipantEvent(_creator)\r\n    {\r\n        masterAddress = msg.sender;\r\n\r\n        creator = _creator;\r\n        creatorLong = _long;\r\n        stakes[creator] = msg.value;\r\n\r\n        strikePrice = _strikePrice;\r\n        dueDate = _dueDate;\r\n    }\r\n\r\n\r\n    /// @notice The strike price can be changed as long as no counterpary has been found. Use this in order to make the conditional payment more attractive to be entered.\r\n    function changeStrikePrice (uint256 newStrikePrice)\r\n        public\r\n        nonZeroStrikePrice(newStrikePrice)\r\n        onlyByCreator\r\n        emitsContractAlteredEvent\r\n    {\r\n        require(countCounterparties == 0);\r\n\r\n        strikePrice = newStrikePrice;\r\n    }\r\n\r\n\r\n    /// @notice As a creator you can reduce your stake to the total stake of the counterparties at minimum.\r\n    function reduceStake (uint256 amount)\r\n        public\r\n        onlyByCreator\r\n        onlyIncremental(amount)\r\n        emitsContractAlteredEvent\r\n        emitsUpdatedParticipantEvent(creator)\r\n    {\r\n        uint256 maxWithdrawAmount = stakes[msg.sender] - totalStakeCounterparties;\r\n        if(amount < maxWithdrawAmount)\r\n        {\r\n            stakes[msg.sender] -= amount;\r\n            msg.sender.transfer(amount);\r\n        }\r\n        else\r\n        {\r\n            stakes[msg.sender] -= maxWithdrawAmount;\r\n            msg.sender.transfer(maxWithdrawAmount);\r\n        }\r\n    }\r\n\r\n\r\n    /// @notice As a creator you can add stake which allows more counterparties.\r\n    function addStake ()\r\n        public\r\n        payable\r\n        onlyByCreator\r\n        onlyIncremental(msg.value)\r\n        emitsContractAlteredEvent\r\n        emitsUpdatedParticipantEvent(creator)\r\n    {\r\n        stakes[msg.sender] += msg.value;\r\n    }\r\n\r\n\r\n    /**\r\n     * @notice Sign the contract. Note you will be subjected to fees at the time of settlement.\r\n     * @param requestedStrikePrice Since the strike price could have potentially been changed by the creator during your transaction, make sure to enter the strike price you saw before making this transaction.\r\n     */\r\n    function signContract (uint256 requestedStrikePrice)\r\n        payable\r\n        public\r\n        onlyIncremental(msg.value)\r\n        nonZeroMsgValue\r\n        dueDateInFuture\r\n        emitsContractAlteredEvent\r\n        emitsUpdatedParticipantEvent(msg.sender)\r\n    {\r\n        require(msg.sender != creator);\r\n        require(requestedStrikePrice == strikePrice);\r\n        totalStakeCounterparties += msg.value;\r\n        require(totalStakeCounterparties <= stakes[creator]);\r\n\r\n        if (stakes[msg.sender] == 0)\r\n        {\r\n            countCounterparties += 1;\r\n        }\r\n        stakes[msg.sender] += msg.value;\r\n    }\r\n\r\n\r\n    /// @notice Withdraw your stake as soon as the due date is reached and the price is available from the oracle.\r\n    function withdraw ()\r\n        public\r\n        emitsContractAlteredEvent\r\n    {\r\n        require(now > dueDate);\r\n        require(countCounterparties > 0);\r\n\r\n        if (isSettled == false)\r\n        {\r\n            Master m = Master(masterAddress);\r\n            settlementPrice = m.settle.value(totalStakeCounterparties/200)(dueDate);\r\n            isSettled = true;\r\n        }\r\n\r\n        uint256 stakeMemory = stakes[msg.sender];\r\n        Withdraw w = Withdraw(withdrawFunctionsAddress);\r\n        if (msg.sender == creator)\r\n        {\r\n            stakes[msg.sender] = 0;\r\n            msg.sender.transfer(w.amountCreator(\r\n                creatorLong,\r\n                stakeMemory,\r\n                settlementPrice,\r\n                strikePrice,\r\n                totalStakeCounterparties));\r\n        }\r\n        if (stakes[msg.sender] != 0)\r\n        {\r\n            stakes[msg.sender] = 0;\r\n            msg.sender.transfer(w.amountCounterparty(\r\n                creatorLong,\r\n                stakeMemory,\r\n                settlementPrice,\r\n                strikePrice));\r\n        }\r\n    }\r\n\r\n\r\n    /// @notice In case anything went wrong, you are able to withdraw your stake 90 days after the due date.\r\n    function unsettledWithdraw ()\r\n        public\r\n        emitsContractAlteredEvent\r\n    {\r\n        require (now > dueDate + 90 days);\r\n        require (isSettled == false);\r\n\r\n        uint256 stakeMemory = stakes[msg.sender];\r\n        stakes[msg.sender] = 0;\r\n        msg.sender.transfer(stakeMemory);\r\n    }\r\n\r\n}\r\n\r\n\r\n\r\n\r\ninterface Oracle {\r\n\r\n    function sendPrice (uint256 dueDate)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n}\r\n\r\n\r\ninterface Withdraw {\r\n\r\n    function amountCreator\r\n    (\r\n        bool makerLong,\r\n        uint256 stakeMemory,\r\n        uint256 settlementPrice,\r\n        uint256 strikePrice,\r\n        uint256 totalStakeAllTakers\r\n    )\r\n        external\r\n        pure\r\n        returns (uint256);\r\n\r\n\r\n    function amountCounterparty\r\n    (\r\n        bool makerLong,\r\n        uint256 stakeMemory,\r\n        uint256 settlementPrice,\r\n        uint256 strikePrice\r\n    )\r\n        external\r\n        pure\r\n        returns (uint256);\r\n\r\n}","ABI":"[{\"constant\":false,\"inputs\":[],\"name\":\"withdrawFees\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"validDueDate\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"balanceOfFactory\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"dueDate\",\"type\":\"uint256\"}],\"name\":\"settle\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"creator\",\"type\":\"address\"},{\"name\":\"long\",\"type\":\"bool\"},{\"name\":\"dueDate\",\"type\":\"uint256\"},{\"name\":\"strikePrice\",\"type\":\"uint256\"}],\"name\":\"createConditionalPayment\",\"outputs\":[{\"name\":\"newDerivativeAddress\",\"type\":\"address\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"dueDate\",\"type\":\"uint256\"},{\"name\":\"valid\",\"type\":\"bool\"}],\"name\":\"setValidDueDate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"contractAddress\",\"type\":\"address\"}],\"name\":\"NewContract\",\"type\":\"event\"}]","ContractName":"Master","CompilerVersion":"v0.5.7+commit.6da8b019","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://7e7487acfae5c18ade9029195640dda7534b1428986fb0226bd672a5ea907be1"}]}