{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.7;\r\n\r\nlibrary ECDSA {\r\n    /**\r\n     * @dev Recover signer address from a message by using their signature\r\n     * @param hash bytes32 message, the hash is the signed message. What is recovered is the signer address.\r\n     * @param signature bytes signature, the signature is generated using web3.eth.sign()\r\n     */\r\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\r\n        bytes32 r;\r\n        bytes32 s;\r\n        uint8 v;\r\n\r\n        // Check the signature length\r\n        if (signature.length != 65) {\r\n            return (address(0));\r\n        }\r\n\r\n        // Divide the signature in r, s and v variables\r\n        // ecrecover takes the signature parameters, and the only way to get them\r\n        // currently is to use assembly.\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n            r := mload(add(signature, 0x20))\r\n            s := mload(add(signature, 0x40))\r\n            v := byte(0, mload(add(signature, 0x60)))\r\n        }\r\n\r\n        // Version of signature should be 27 or 28, but 0 and 1 are also possible versions\r\n        if (v < 27) {\r\n            v += 27;\r\n        }\r\n\r\n        // If the version is correct return the signer address\r\n        if (v != 27 && v != 28) {\r\n            return (address(0));\r\n        } else {\r\n            return ecrecover(hash, v, r, s);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * toEthSignedMessageHash\r\n     * @dev prefix a bytes32 value with \"\\x19Ethereum Signed Message:\"\r\n     * and hash the result\r\n     */\r\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\r\n        // 32 is the length in bytes of hash,\r\n        // enforced by the type signature above\r\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\r\n    }\r\n}\r\n\r\ncontract Ownable {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n     * account.\r\n     */\r\n    constructor () internal {\r\n        _owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), _owner);\r\n    }\r\n\r\n    /**\r\n     * @return the address of the owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner());\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @return true if `msg.sender` is the owner of the contract.\r\n     */\r\n    function isOwner() public view returns (bool) {\r\n        return msg.sender == _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to relinquish control of the contract.\r\n     * @notice Renouncing to ownership will leave the contract without an owner.\r\n     * It will not be possible to call the functions with the `onlyOwner`\r\n     * modifier anymore.\r\n     */\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0));\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\ncontract FizzyRoles is Ownable {\r\n    address private _signer;\r\n    address payable private _assetManager;\r\n    address private _oracle;\r\n\r\n    event SignershipTransferred(address previousSigner, address newSigner);\r\n    event AssetManagerChanged(address payable previousAssetManager, address payable newAssetManager);\r\n    event OracleChanged(address previousOracle, address newOracle);\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the asset manager.\r\n     */\r\n    modifier onlyAssetManager() {\r\n        require(_assetManager == msg.sender, \"Sender is not the asset manager\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the oracle.\r\n     */\r\n    modifier onlyOracle() {\r\n        require(_oracle == msg.sender, \"Sender is not the oracle\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev The FizzyRoles constructor set the original signer, asset manager and oracle to the creator account.\r\n     */\r\n    constructor () internal {\r\n        _signer = msg.sender;\r\n        _assetManager = msg.sender;\r\n        _oracle = msg.sender;\r\n        emit SignershipTransferred(address(0), _signer);\r\n        emit AssetManagerChanged(address(0), _assetManager);\r\n        emit OracleChanged(address(0), _oracle);\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to transfer the signership to a newSigner.\r\n     * @param newSigner The address to transfer signership to.\r\n     */\r\n    function transferSignership(address newSigner) external onlyOwner {\r\n        require(newSigner != address(0), \"newSigner should not be address(0).\");\r\n        emit SignershipTransferred(_signer, newSigner);\r\n        _signer = newSigner;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to change the asset manager to a newManager.\r\n     * @param newManager The address to change asset management to.\r\n     */\r\n    function changeAssetManager(address payable newManager) external onlyOwner {\r\n        require(newManager != address(0), \"newManager should not be address(0).\");\r\n        emit AssetManagerChanged(_assetManager, newManager);\r\n        _assetManager = newManager;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to change the oracle to a newOracle.\r\n     * @param newOracle The address to change oracle to.\r\n     */\r\n    function changeOracle(address newOracle) external onlyOwner {\r\n        require(newOracle != address(0), \"newOracle should not be address(0).\");\r\n        emit OracleChanged(_oracle, newOracle);\r\n        _oracle = newOracle;\r\n    }\r\n\r\n    /**\r\n     * @return the address of the signer\r\n     */\r\n    function getSigner() public view returns(address) {\r\n        return _signer;\r\n    }\r\n\r\n    /**\r\n     * @return the address of the oracle\r\n     */\r\n    function getOracle() public view returns(address) {\r\n        return _oracle;\r\n    }\r\n\r\n    /**\r\n     * @return the address of the asset manager\r\n     */\r\n    function getAssetManager() public view returns(address payable) {\r\n        return _assetManager;\r\n    }\r\n}\r\n\r\ncontract Fizzy is FizzyRoles {\r\n\r\n    /**\r\n     * @dev Possible covered conditions.\r\n     * Each bit of a uint256 match a condition.\r\n     */\r\n    uint256 constant NONE       = 0;\r\n    uint256 constant CANCELLED  = 2**0;\r\n    uint256 constant DIVERTED   = 2**1;\r\n    uint256 constant REDIRECTED = 2**2;\r\n    uint256 constant DELAY      = 2**3;\r\n    uint256 constant MANUAL     = 2**4;\r\n\r\n    /**\r\n     * @dev Represents the status of an insurance.\r\n     * - Open: we do not have landing data for the flight\r\n     * - ClosedCompensated: the user received an indemnity and the insurance can not be updated\r\n     * - ClosedNotCompensated: the user did not received an indemnity and the insurance can not be updated\r\n     */\r\n    enum InsuranceStatus {\r\n        Open, ClosedCompensated, ClosedNotCompensated\r\n    }\r\n\r\n    /**\r\n     * @dev Structure representing an insurance.\r\n     * @param productId The productId of the insurance.\r\n     * @param premium The premium of the insurance.\r\n     * @param indemnity The indemnity amount sent to the user if one of the conditions of the insurance is fullfilled.\r\n     * @param limitArrivalTime Timestamp in seconds after which the delayCondition (when covered) is triggered when the flight land.\r\n     * @param conditions Flight statuses triggering compensation.\r\n     * @param InsuranceStatus The status of the insurance.\r\n     * @param compensationAddress The indemnity is sent to this address if the insurance has been paid in cryptocurrency and should be compensated.\r\n     */\r\n    struct Insurance {\r\n        uint256         productId;\r\n        uint256         premium;\r\n        uint256         indemnity;\r\n        uint256         limitArrivalTime;\r\n        uint256         conditions;\r\n        InsuranceStatus status;\r\n        address payable compensationAddress;\r\n    }\r\n\r\n    /**\r\n     * @dev Mapping of a flightId to an array of insurances.\r\n     */\r\n    mapping(bytes32 => Insurance[]) private insuranceList;\r\n\r\n    /**\r\n     * @dev Mapping of a productId to a boolean.\r\n     */\r\n    mapping(uint256 => bool) private boughtProductIds;\r\n\r\n    /**\r\n     * @dev Event triggered when an insurance is created.\r\n     * @param flightId The flightId of the insurance. Format: <carrier_code><flight_number>.<timestamp_in_sec_of_departure_date>\r\n     * @param productId ID string of product linked to the insurance.\r\n     * @param premium Amount of premium paid by the client.\r\n     * @param indemnity Amount (potentially) perceived by the client.\r\n     * @param limitArrivalTime Maximum time after which we trigger the delay compensation (timestamp in sec).\r\n     * @param conditions Flight statuses triggering compensation.\r\n     * @param compensationAddress The indemnity is sent to this address if the insurance has been paid in cryptocurrency and should be compensated.\r\n     */\r\n\r\n    event InsuranceCreation(\r\n        bytes32         flightId,\r\n        uint256         productId,\r\n        uint256         premium,\r\n        uint256         indemnity,\r\n        uint256         limitArrivalTime,\r\n        uint256         conditions,\r\n        address payable compensationAddress\r\n    );\r\n\r\n    /**\r\n     * @dev Event triggered when an insurance is updated.\r\n     * @param flightId The flightId of the insurance. Format: <carrier_code><flight_number>.<timestamp_in_sec_of_departure_date>\r\n     * @param productId ID string of product linked to the insurance.\r\n     * @param premium Amount of premium paid by the client.\r\n     * @param indemnity Amount (potentially) perceived by the client.\r\n     * @param triggeredCondition The condition triggered.\r\n     * @param status The new status of the insurance.\r\n     */\r\n    event InsuranceUpdate(\r\n        bytes32         flightId,\r\n        uint256         productId,\r\n        uint256         premium,\r\n        uint256         indemnity,\r\n        uint256         triggeredCondition,\r\n        InsuranceStatus status\r\n    );\r\n\r\n    /**\r\n     * @return the count of the insurances.\r\n     */\r\n    function getInsurancesCount(bytes32 flightId) public view returns (uint256) {\r\n        return insuranceList[flightId].length;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the specified insurance.\r\n     * @param flightId The flightId containing the insurance.\r\n     * @param index The index of the insurance in the array of the flight.\r\n     * @return An insurance\r\n     */\r\n    function getInsurance(bytes32 flightId, uint256 index) public view returns (uint256         productId,\r\n                                                                uint256         premium,\r\n                                                                uint256         indemnity,\r\n                                                                uint256         limitArrivalTime,\r\n                                                                uint256         conditions,\r\n                                                                InsuranceStatus status,\r\n                                                                address payable compensationAddress) {\r\n        productId = insuranceList[flightId][index].productId;\r\n        premium = insuranceList[flightId][index].premium;\r\n        indemnity = insuranceList[flightId][index].indemnity;\r\n        limitArrivalTime = insuranceList[flightId][index].limitArrivalTime;\r\n        conditions = insuranceList[flightId][index].conditions;\r\n        status = insuranceList[flightId][index].status;\r\n        compensationAddress = insuranceList[flightId][index].compensationAddress;\r\n    }\r\n\r\n\r\n    /**\r\n     * @return True if a product is bought, false otherwise.\r\n     */\r\n    function isProductBought(uint256 productId) public view returns (bool) {\r\n        return boughtProductIds[productId];\r\n    }\r\n\r\n    /**\r\n    * @dev Allow the owner to add a new insurance for the given flight.\r\n    *       A maximum amount of policies per flight is enforced service side.\r\n    * @param flightId The flightId of the insurance. Format: <carrier_code><flight_number>.<timestamp_in_sec_of_departure_date>\r\n    * @param productId ID string of product linked to the insurance.\r\n    * @param premium Amount of premium paid by the client.\r\n    * @param indemnity Amount (potentially) perceived by the client.\r\n    * @param limitArrivalTime Maximum time after which we trigger the delay compensation (timestamp in sec).\r\n    * @param conditions Flight statuses triggering compensation.\r\n    */\r\n    function addNewInsurance(\r\n        bytes32 flightId,\r\n        uint256 productId,\r\n        uint256 premium,\r\n        uint256 indemnity,\r\n        uint256 limitArrivalTime,\r\n        uint256 conditions\r\n        ) external onlyOwner {\r\n\r\n        _addNewInsurance(flightId, productId, premium, indemnity, limitArrivalTime, conditions, address(0));\r\n    }\r\n\r\n    /**\r\n    * @dev Set the actual arrival time of a flight.\r\n    *       Out of gas: a maximum amount of policies per flight is enforced server side.\r\n    * @param flightId <carrier_code><flight_number>.<timestamp_in_sec_of_departure_date>\r\n    * @param actualArrivalTime The actual arrival time of the flight (timestamp in sec)\r\n    */\r\n    function setFlightLandedAndArrivalTime(\r\n        bytes32 flightId,\r\n        uint256 actualArrivalTime)\r\n        external\r\n        onlyOracle {\r\n\r\n        for (uint i = 0; i < insuranceList[flightId].length; i++) {\r\n            Insurance memory insurance = insuranceList[flightId][i];\r\n            if (insurance.status == InsuranceStatus.Open) {\r\n                InsuranceStatus newStatus;\r\n                uint256 triggeredCondition;\r\n\r\n                if (_containsCondition(insurance.conditions, DELAY)) {\r\n                    if (actualArrivalTime > insurance.limitArrivalTime) {\r\n                        triggeredCondition = DELAY;\r\n                        newStatus = InsuranceStatus.ClosedCompensated;\r\n                        compensateIfEtherPayment(insurance);\r\n                    } else {\r\n                        triggeredCondition = NONE;\r\n                        newStatus = InsuranceStatus.ClosedNotCompensated;\r\n                        noCompensateIfEtherPayment(insurance);\r\n                    }\r\n                } else {\r\n                    triggeredCondition = NONE;\r\n                    newStatus = InsuranceStatus.ClosedNotCompensated;\r\n                    noCompensateIfEtherPayment(insurance);\r\n                }\r\n\r\n                insuranceList[flightId][i].status = newStatus;\r\n\r\n                emit InsuranceUpdate(\r\n                    flightId,\r\n                    insurance.productId,\r\n                    insurance.premium,\r\n                    insurance.indemnity,\r\n                    triggeredCondition,\r\n                    newStatus\r\n                    );\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Trigger an insurance's condition for a flight.\r\n    *       Out of gas: a maximum amount of policies per flight is enforced server side.\r\n    * @param flightId <carrier_code><flight_number>.<timestamp_in_sec_of_departure_date>\r\n    * @param conditionToTrigger insurance condition triggered.\r\n    */\r\n    function triggerCondition(\r\n        bytes32 flightId,\r\n        uint256 conditionToTrigger)\r\n        external\r\n        onlyOracle {\r\n\r\n        for (uint i = 0; i < insuranceList[flightId].length; i++) {\r\n            Insurance memory insurance = insuranceList[flightId][i];\r\n\r\n            if (insurance.status == InsuranceStatus.Open) {\r\n                InsuranceStatus newInsuranceStatus;\r\n                uint256 triggeredCondition;\r\n\r\n                if (_containsCondition(insurance.conditions, conditionToTrigger)) {\r\n                    triggeredCondition = conditionToTrigger;\r\n                    newInsuranceStatus = InsuranceStatus.ClosedCompensated;\r\n                    compensateIfEtherPayment(insurance);\r\n                } else {\r\n                    triggeredCondition = NONE;\r\n                    newInsuranceStatus = InsuranceStatus.ClosedNotCompensated;\r\n                    noCompensateIfEtherPayment(insurance);\r\n                }\r\n\r\n                insuranceList[flightId][i].status = newInsuranceStatus;\r\n\r\n                emit InsuranceUpdate(\r\n                    flightId,\r\n                    insurance.productId,\r\n                    insurance.premium,\r\n                    insurance.indemnity,\r\n                    triggeredCondition,\r\n                    newInsuranceStatus\r\n                    );\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Manually resolve an insurance contract\r\n    *       Out of gas: a maximum amount of policies per flight is enforced server side.\r\n    * @param flightId <carrier_code><flight_number>.<timestamp_in_sec_of_departure_date>\r\n    * @param productId ID string of the product linked to the insurance.\r\n    * @param newStatus ID of the resolution status for this insurance contract.\r\n    */\r\n    function manualInsuranceResolution(\r\n        bytes32 flightId,\r\n        uint256 productId,\r\n        InsuranceStatus newStatus\r\n    )\r\n        external\r\n        onlyOwner {\r\n        require(newStatus == InsuranceStatus.ClosedCompensated || newStatus == InsuranceStatus.ClosedNotCompensated,\r\n                \"Insurance already compensated.\");\r\n\r\n        for (uint i = 0; i < insuranceList[flightId].length; i++) {\r\n            Insurance memory insurance = insuranceList[flightId][i];\r\n            if (insurance.status == InsuranceStatus.Open && insurance.productId == productId) {\r\n                if (newStatus == InsuranceStatus.ClosedCompensated) {\r\n                    compensateIfEtherPayment(insurance);\r\n                } else if (newStatus == InsuranceStatus.ClosedNotCompensated) {\r\n                    noCompensateIfEtherPayment(insurance);\r\n                }\r\n\r\n                insuranceList[flightId][i].status = newStatus;\r\n\r\n                emit InsuranceUpdate(\r\n                    flightId,\r\n                    insurance.productId,\r\n                    insurance.premium,\r\n                    insurance.indemnity,\r\n                    MANUAL,\r\n                    newStatus\r\n                    );\r\n            }\r\n        }\r\n    }\r\n\r\n    function _addNewInsurance (\r\n        bytes32 flightId,\r\n        uint256 productId,\r\n        uint256 premium,\r\n        uint256 indemnity,\r\n        uint256  limitArrivalTime,\r\n        uint256 conditions,\r\n        address payable compensationAddress\r\n    ) internal {\r\n\r\n        require(boughtProductIds[productId] == false, \"This product has already been bought.\");\r\n\r\n        Insurance memory newInsurance;\r\n        newInsurance.productId = productId;\r\n        newInsurance.premium = premium;\r\n        newInsurance.indemnity = indemnity;\r\n        newInsurance.limitArrivalTime = limitArrivalTime;\r\n        newInsurance.conditions = conditions;\r\n        newInsurance.status = InsuranceStatus.Open;\r\n        newInsurance.compensationAddress = compensationAddress;\r\n\r\n        insuranceList[flightId].push(newInsurance);\r\n\r\n        boughtProductIds[productId] = true;\r\n\r\n        emit InsuranceCreation(flightId, productId, premium, indemnity, limitArrivalTime, conditions, compensationAddress);\r\n    }\r\n\r\n    function _compensate(address payable to, uint256 amount, uint256 productId) internal returns (bool success);\r\n    function _noCompensate(uint256 amount) internal returns (bool success);\r\n\r\n    /**\r\n     * @dev Compensate the customer if the compensation address is different from address(0).\r\n     * @param insurance Insurance to compensate.\r\n     */\r\n    function compensateIfEtherPayment(Insurance memory insurance) private {\r\n        if (insurance.compensationAddress != address(0)) {\r\n            _compensate(insurance.compensationAddress, insurance.indemnity, insurance.productId);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Do not compensate the insurance. Add indemnity to available exposure.\r\n     * @param insurance Closed insurance which will not be compensated.\r\n     */\r\n    function noCompensateIfEtherPayment(Insurance memory insurance) private {\r\n        if (insurance.compensationAddress != address(0)) {\r\n            _noCompensate(insurance.indemnity);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Check if the conditions covered by the insurance includes the specified condition.\r\n     * @param a All the conditions covered by the insurance.\r\n     * @param b Single condition to check.\r\n     * @return True if the condition to check is included in the covered conditions, false otherwise.\r\n     */\r\n    function _containsCondition(uint256 a, uint256 b) private pure returns (bool) {\r\n        return (a & b) != 0;\r\n    }\r\n}\r\n\r\ncontract FizzyCrypto is Fizzy {\r\n\r\n    uint256 private _availableExposure;\r\n    uint256 private _collectedTaxes;\r\n\r\n    event EtherCompensation(uint256 amount, address to, uint256 productId);\r\n    event EtherCompensationError(uint256 amount, address to, uint256 productId);\r\n\r\n    /**\r\n    * @dev Throws if called with a timestampLimit greater than the block timestamp.\r\n    * @param timestampLimit Timestamp to compare to the block timestamp.\r\n    */\r\n    modifier beforeTimestampLimit(uint256 timestampLimit) {\r\n        require(timestampLimit >= now, \"The transaction is invalid: the timestamp limit has been reached.\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev Throws if called with an amount greater than the available exposure.\r\n    * @param amount Amount to compare to the available exposure.\r\n    */\r\n    modifier enoughExposure(uint256 amount) {\r\n        require(_availableExposure >= amount, \"Available exposure can not be reached\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev Throws if called with an amount greater than the collected taxes.\r\n    * @param amount Amount to compare to the collected taxes.\r\n    */\r\n    modifier enoughTaxes(uint256 amount) {\r\n        require(_collectedTaxes >= amount, \"Cannot withdraw more taxes than all collected taxes\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev Allows the asset manager to deposit ether on the smart contract.\r\n    */\r\n    function deposit() external payable onlyAssetManager {\r\n        _availableExposure = _availableExposure + msg.value;\r\n    }\r\n\r\n    /**\r\n    * @dev Allows the asset manager to withdraw ether from the smart contract.\r\n    * @param amount Amount of ether to withdraw. Can not be greater than the available exposure.\r\n    */\r\n    function withdraw(uint256 amount) external onlyAssetManager enoughExposure(amount) {\r\n        _availableExposure = _availableExposure - amount;\r\n        msg.sender.transfer(amount);\r\n    }\r\n\r\n    /**\r\n    * @dev Allows the asset manager to withdraw taxes from the smart contract.\r\n    * @param amount Amount of taxes to withdraw. Can not be greater than the available taxes.\r\n    */\r\n    function withdrawTaxes(uint256 amount) external onlyAssetManager enoughTaxes(amount) {\r\n        _collectedTaxes = _collectedTaxes - amount;\r\n        msg.sender.transfer(amount);\r\n    }\r\n\r\n    /**\r\n    * @dev Allows a customer to buy an insurance with ether.\r\n    *       There is currently a maximum of 10 insurances available for each flight. It is enforced server side.\r\n    * @param flightId The flightId of the insurance. Format: <carrier_code><flight_number>.<timestamp_in_sec_of_departure_date>\r\n    * @param productId ID string of product linked to the insurance.\r\n    * @param premium Amount of premium paid by the client.\r\n    * @param indemnity Amount (potentially) perceived by the client.\r\n    * @param taxes Taxes included in the premium.\r\n    * @param limitArrivalTime Maximum time after which we trigger the delay compensation (timestamp in sec).\r\n    * @param conditions Flight statuses triggering compensation.\r\n    * @param timestampLimit Maximum timestamp to accept the transaction.\r\n    * @param buyerAddress Address of the buyer.\r\n    * @param signature Signature of the parameters.\r\n    */\r\n    function buyInsurance(\r\n        bytes32        flightId,\r\n        uint256        productId,\r\n        uint256        premium,\r\n        uint256        indemnity,\r\n        uint256        taxes,\r\n        uint256        limitArrivalTime,\r\n        uint256        conditions,\r\n        uint256        timestampLimit,\r\n        address        buyerAddress,\r\n        bytes calldata signature\r\n    )\r\n        external\r\n        payable\r\n        beforeTimestampLimit(timestampLimit)\r\n        enoughExposure(indemnity)\r\n    {\r\n        _checkSignature(flightId, productId, premium, indemnity, taxes, limitArrivalTime, conditions, timestampLimit, buyerAddress, signature);\r\n\r\n        require(buyerAddress == msg.sender, \"Wrong buyer address.\");\r\n        require(premium >= taxes, \"The taxes must be included in the premium.\");\r\n        require(premium == msg.value, \"The amount sent does not match the price of the order.\");\r\n\r\n        _addNewInsurance(flightId, productId, premium, indemnity, limitArrivalTime, conditions, msg.sender);\r\n\r\n        _availableExposure = _availableExposure + premium - taxes - indemnity;\r\n        _collectedTaxes = _collectedTaxes + taxes;\r\n    }\r\n\r\n    /**\r\n     * @return The available exposure.\r\n     */\r\n    function availableExposure() external view returns(uint256) {\r\n        return _availableExposure;\r\n    }\r\n\r\n    /**\r\n    * @return The collected taxes.\r\n    */\r\n    function collectedTaxes() external view returns(uint256) {\r\n        return _collectedTaxes;\r\n    }\r\n\r\n    /**\r\n     * @dev Sends an indemnity to a user.\r\n     * @param to The ethereum address of the user.\r\n     * @param amount The amount of ether to send to the user.\r\n     * @param productId The productId of the insurance.\r\n     */\r\n    function _compensate(address payable to, uint256 amount, uint256 productId) internal returns (bool) {\r\n        if(to.send(amount)) {\r\n            emit EtherCompensation(amount, to, productId);\r\n            return true;\r\n        } else {\r\n            getAssetManager().transfer(amount);\r\n            emit EtherCompensationError(amount, to, productId);\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Add the indemnity amount of an insurance to the available exposure.\r\n    *       Called when no condition of the insurance was triggered.\r\n    * @param amount Amount of the indemnity which will be added to the available exposure.\r\n    */\r\n    function _noCompensate(uint256 amount) internal returns (bool) {\r\n        _availableExposure = _availableExposure + amount;\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev Check the signature of the parameters. Throws if the decyphered address is not equals to the signer address.\r\n    * @param flightId The flightId of the insurance. Format: <carrier_code><flight_number>.<timestamp_in_sec_of_departure_date>\r\n    * @param productId ID string of product linked to the insurance.\r\n    * @param premium Amount of premium paid by the client.\r\n    * @param indemnity Amount (potentially) perceived by the client.\r\n    * @param taxes Taxes included in the premium.\r\n    * @param limitArrivalTime Maximum time after which we trigger the delay compensation (timestamp in sec).\r\n    * @param conditions Flight statuses triggering compensation.\r\n    * @param timestampLimit Maximum timestamp to accept the transaction.\r\n    * @param buyerAddress Address of the buyer.\r\n    * @param signature Signature of the parameters.\r\n    */\r\n    function _checkSignature(\r\n        bytes32 flightId,\r\n        uint256 productId,\r\n        uint256 premium,\r\n        uint256 indemnity,\r\n        uint256 taxes,\r\n        uint256 limitArrivalTime,\r\n        uint256 conditions,\r\n        uint256 timestampLimit,\r\n        address buyerAddress,\r\n        bytes memory signature\r\n    ) private view {\r\n\r\n        bytes32 messageHash = keccak256(abi.encodePacked(\r\n            flightId,\r\n            productId,\r\n            premium,\r\n            indemnity,\r\n            taxes,\r\n            limitArrivalTime,\r\n            conditions,\r\n            timestampLimit,\r\n            buyerAddress\r\n        ));\r\n\r\n        address decypheredAddress = ECDSA.recover(ECDSA.toEthSignedMessageHash(messageHash), signature);\r\n        require(decypheredAddress == getSigner(), \"The signature is invalid if it does not match the _signer address.\");\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"flightId\",\"type\":\"bytes32\"},{\"name\":\"productId\",\"type\":\"uint256\"},{\"name\":\"newStatus\",\"type\":\"uint8\"}],\"name\":\"manualInsuranceResolution\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAssetManager\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"flightId\",\"type\":\"bytes32\"},{\"name\":\"actualArrivalTime\",\"type\":\"uint256\"}],\"name\":\"setFlightLandedAndArrivalTime\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawTaxes\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOracle\",\"type\":\"address\"}],\"name\":\"changeOracle\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newSigner\",\"type\":\"address\"}],\"name\":\"transferSignership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"flightId\",\"type\":\"bytes32\"},{\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getInsurance\",\"outputs\":[{\"name\":\"productId\",\"type\":\"uint256\"},{\"name\":\"premium\",\"type\":\"uint256\"},{\"name\":\"indemnity\",\"type\":\"uint256\"},{\"name\":\"limitArrivalTime\",\"type\":\"uint256\"},{\"name\":\"conditions\",\"type\":\"uint256\"},{\"name\":\"status\",\"type\":\"uint8\"},{\"name\":\"compensationAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getSigner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getOracle\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"flightId\",\"type\":\"bytes32\"},{\"name\":\"productId\",\"type\":\"uint256\"},{\"name\":\"premium\",\"type\":\"uint256\"},{\"name\":\"indemnity\",\"type\":\"uint256\"},{\"name\":\"limitArrivalTime\",\"type\":\"uint256\"},{\"name\":\"conditions\",\"type\":\"uint256\"}],\"name\":\"addNewInsurance\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"productId\",\"type\":\"uint256\"}],\"name\":\"isProductBought\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"collectedTaxes\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"flightId\",\"type\":\"bytes32\"}],\"name\":\"getInsurancesCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"deposit\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"flightId\",\"type\":\"bytes32\"},{\"name\":\"conditionToTrigger\",\"type\":\"uint256\"}],\"name\":\"triggerCondition\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"flightId\",\"type\":\"bytes32\"},{\"name\":\"productId\",\"type\":\"uint256\"},{\"name\":\"premium\",\"type\":\"uint256\"},{\"name\":\"indemnity\",\"type\":\"uint256\"},{\"name\":\"taxes\",\"type\":\"uint256\"},{\"name\":\"limitArrivalTime\",\"type\":\"uint256\"},{\"name\":\"conditions\",\"type\":\"uint256\"},{\"name\":\"timestampLimit\",\"type\":\"uint256\"},{\"name\":\"buyerAddress\",\"type\":\"address\"},{\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"buyInsurance\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newManager\",\"type\":\"address\"}],\"name\":\"changeAssetManager\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"availableExposure\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"productId\",\"type\":\"uint256\"}],\"name\":\"EtherCompensation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"productId\",\"type\":\"uint256\"}],\"name\":\"EtherCompensationError\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"flightId\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"productId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"premium\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"indemnity\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"limitArrivalTime\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"conditions\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"compensationAddress\",\"type\":\"address\"}],\"name\":\"InsuranceCreation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"flightId\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"productId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"premium\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"indemnity\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"triggeredCondition\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"status\",\"type\":\"uint8\"}],\"name\":\"InsuranceUpdate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"previousSigner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newSigner\",\"type\":\"address\"}],\"name\":\"SignershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"previousAssetManager\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newAssetManager\",\"type\":\"address\"}],\"name\":\"AssetManagerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"previousOracle\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newOracle\",\"type\":\"address\"}],\"name\":\"OracleChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"FizzyCrypto","CompilerVersion":"v0.5.7+commit.6da8b019","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://3a0765e6131ad9be45c76edae10e8082ba18ba47032ff3ee5a8238f2b0a74439"}]}