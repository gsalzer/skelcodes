{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\n// File: node_modules\\zeppelin-solidity\\contracts\\math\\Math.sol\r\n\r\n/**\r\n * @title Math\r\n * @dev Assorted math operations\r\n */\r\nlibrary Math {\r\n  function max64(uint64 a, uint64 b) internal pure returns (uint64) {\r\n    return a >= b ? a : b;\r\n  }\r\n\r\n  function min64(uint64 a, uint64 b) internal pure returns (uint64) {\r\n    return a < b ? a : b;\r\n  }\r\n\r\n  function max256(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    return a >= b ? a : b;\r\n  }\r\n\r\n  function min256(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    return a < b ? a : b;\r\n  }\r\n}\r\n\r\n// File: node_modules\\zeppelin-solidity\\contracts\\ownership\\Ownable.sol\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipRenounced(address indexed previousOwner);\r\n  event OwnershipTransferred(\r\n    address indexed previousOwner,\r\n    address indexed newOwner\r\n  );\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  constructor() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to relinquish control of the contract.\r\n   * @notice Renouncing to ownership will leave the contract without an owner.\r\n   * It will not be possible to call the functions with the `onlyOwner`\r\n   * modifier anymore.\r\n   */\r\n  function renounceOwnership() public onlyOwner {\r\n    emit OwnershipRenounced(owner);\r\n    owner = address(0);\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address _newOwner) public onlyOwner {\r\n    _transferOwnership(_newOwner);\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function _transferOwnership(address _newOwner) internal {\r\n    require(_newOwner != address(0));\r\n    emit OwnershipTransferred(owner, _newOwner);\r\n    owner = _newOwner;\r\n  }\r\n}\r\n\r\n// File: node_modules\\zeppelin-solidity\\contracts\\math\\SafeMath.sol\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return a / b;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n// File: node_modules\\zeppelin-solidity\\contracts\\payment\\Escrow.sol\r\n\r\n/**\r\n * @title Escrow\r\n * @dev Base escrow contract, holds funds destinated to a payee until they\r\n * withdraw them. The contract that uses the escrow as its payment method\r\n * should be its owner, and provide public methods redirecting to the escrow's\r\n * deposit and withdraw.\r\n */\r\ncontract Escrow is Ownable {\r\n  using SafeMath for uint256;\r\n\r\n  event Deposited(address indexed payee, uint256 weiAmount);\r\n  event Withdrawn(address indexed payee, uint256 weiAmount);\r\n\r\n  mapping(address => uint256) private deposits;\r\n\r\n  function depositsOf(address _payee) public view returns (uint256) {\r\n    return deposits[_payee];\r\n  }\r\n\r\n  /**\r\n  * @dev Stores the sent amount as credit to be withdrawn.\r\n  * @param _payee The destination address of the funds.\r\n  */\r\n  function deposit(address _payee) public onlyOwner payable {\r\n    uint256 amount = msg.value;\r\n    deposits[_payee] = deposits[_payee].add(amount);\r\n\r\n    emit Deposited(_payee, amount);\r\n  }\r\n\r\n  /**\r\n  * @dev Withdraw accumulated balance for a payee.\r\n  * @param _payee The address whose funds will be withdrawn and transferred to.\r\n  */\r\n  function withdraw(address _payee) public onlyOwner {\r\n    uint256 payment = deposits[_payee];\r\n    assert(address(this).balance >= payment);\r\n\r\n    deposits[_payee] = 0;\r\n\r\n    _payee.transfer(payment);\r\n\r\n    emit Withdrawn(_payee, payment);\r\n  }\r\n}\r\n\r\n// File: node_modules\\zeppelin-solidity\\contracts\\payment\\ConditionalEscrow.sol\r\n\r\n/**\r\n * @title ConditionalEscrow\r\n * @dev Base abstract escrow to only allow withdrawal if a condition is met.\r\n */\r\ncontract ConditionalEscrow is Escrow {\r\n  /**\r\n  * @dev Returns whether an address is allowed to withdraw their funds. To be\r\n  * implemented by derived contracts.\r\n  * @param _payee The destination address of the funds.\r\n  */\r\n  function withdrawalAllowed(address _payee) public view returns (bool);\r\n\r\n  function withdraw(address _payee) public {\r\n    require(withdrawalAllowed(_payee));\r\n    super.withdraw(_payee);\r\n  }\r\n}\r\n\r\n// File: node_modules\\zeppelin-solidity\\contracts\\payment\\RefundEscrow.sol\r\n\r\n/**\r\n * @title RefundEscrow\r\n * @dev Escrow that holds funds for a beneficiary, deposited from multiple parties.\r\n * The contract owner may close the deposit period, and allow for either withdrawal\r\n * by the beneficiary, or refunds to the depositors.\r\n */\r\ncontract RefundEscrow is Ownable, ConditionalEscrow {\r\n  enum State { Active, Refunding, Closed }\r\n\r\n  event Closed();\r\n  event RefundsEnabled();\r\n\r\n  State public state;\r\n  address public beneficiary;\r\n\r\n  /**\r\n   * @dev Constructor.\r\n   * @param _beneficiary The beneficiary of the deposits.\r\n   */\r\n  constructor(address _beneficiary) public {\r\n    require(_beneficiary != address(0));\r\n    beneficiary = _beneficiary;\r\n    state = State.Active;\r\n  }\r\n\r\n  /**\r\n   * @dev Stores funds that may later be refunded.\r\n   * @param _refundee The address funds will be sent to if a refund occurs.\r\n   */\r\n  function deposit(address _refundee) public payable {\r\n    require(state == State.Active);\r\n    super.deposit(_refundee);\r\n  }\r\n\r\n  /**\r\n   * @dev Allows for the beneficiary to withdraw their funds, rejecting\r\n   * further deposits.\r\n   */\r\n  function close() public onlyOwner {\r\n    require(state == State.Active);\r\n    state = State.Closed;\r\n    emit Closed();\r\n  }\r\n\r\n  /**\r\n   * @dev Allows for refunds to take place, rejecting further deposits.\r\n   */\r\n  function enableRefunds() public onlyOwner {\r\n    require(state == State.Active);\r\n    state = State.Refunding;\r\n    emit RefundsEnabled();\r\n  }\r\n\r\n  /**\r\n   * @dev Withdraws the beneficiary's funds.\r\n   */\r\n  function beneficiaryWithdraw() public {\r\n    require(state == State.Closed);\r\n    beneficiary.transfer(address(this).balance);\r\n  }\r\n\r\n  /**\r\n   * @dev Returns whether refundees can withdraw their deposits (be refunded).\r\n   */\r\n  function withdrawalAllowed(address _payee) public view returns (bool) {\r\n    return state == State.Refunding;\r\n  }\r\n}\r\n\r\n// File: contracts\\ClinicAllRefundEscrow.sol\r\n\r\n/**\r\n * @title ClinicAllRefundEscrow\r\n * @dev Escrow that holds funds for a beneficiary, deposited from multiple parties.\r\n * The contract owner may close the deposit period, and allow for either withdrawal\r\n * by the beneficiary, or refunds to the depositors.\r\n */\r\ncontract ClinicAllRefundEscrow is RefundEscrow {\r\n  using Math for uint256;\r\n\r\n  struct RefundeeRecord {\r\n    bool isRefunded;\r\n    uint256 index;\r\n  }\r\n\r\n  mapping(address => RefundeeRecord) public refundees;\r\n  address[] public refundeesList;\r\n\r\n  event Deposited(address indexed payee, uint256 weiAmount);\r\n  event Withdrawn(address indexed payee, uint256 weiAmount);\r\n\r\n  mapping(address => uint256) public deposits;\r\n  mapping(address => uint256) public beneficiaryDeposits;\r\n\r\n  // Amount of wei deposited by beneficiary\r\n  uint256 public beneficiaryDepositedAmount;\r\n\r\n  // Amount of wei deposited by investors to CrowdSale\r\n  uint256 public investorsDepositedToCrowdSaleAmount;\r\n\r\n  /**\r\n   * @dev Constructor.\r\n   * @param _beneficiary The beneficiary of the deposits.\r\n   */\r\n  constructor(address _beneficiary)\r\n  RefundEscrow(_beneficiary)\r\n  public {\r\n  }\r\n\r\n  function depositsOf(address _payee) public view returns (uint256) {\r\n    return deposits[_payee];\r\n  }\r\n\r\n  function beneficiaryDepositsOf(address _payee) public view returns (uint256) {\r\n    return beneficiaryDeposits[_payee];\r\n  }\r\n\r\n  /**\r\n   * Internal. Is being user by parent classes, just for keeping the interface.\r\n   * @dev Stores funds that may later be refunded.\r\n   * @param _refundee The address funds will be sent to if a refund occurs.\r\n   */\r\n  function deposit(address _refundee) public payable {\r\n    uint256 amount = msg.value;\r\n    beneficiaryDeposits[_refundee] = beneficiaryDeposits[_refundee].add(amount);\r\n    beneficiaryDepositedAmount = beneficiaryDepositedAmount.add(amount);\r\n  }\r\n\r\n  /**\r\n * @dev Stores funds that may later be refunded.\r\n * @param _refundee The address funds will be sent to if a refund occurs.\r\n * @param _value The amount of funds will be sent to if a refund occurs.\r\n */\r\n  function depositFunds(address _refundee, uint256 _value) public onlyOwner {\r\n    require(state == State.Active, \"Funds deposition is possible only in the Active state.\");\r\n\r\n    uint256 amount = _value;\r\n    deposits[_refundee] = deposits[_refundee].add(amount);\r\n    investorsDepositedToCrowdSaleAmount = investorsDepositedToCrowdSaleAmount.add(amount);\r\n\r\n    emit Deposited(_refundee, amount);\r\n\r\n    RefundeeRecord storage _data = refundees[_refundee];\r\n    _data.isRefunded = false;\r\n\r\n    if (_data.index == uint256(0)) {\r\n      refundeesList.push(_refundee);\r\n      _data.index = refundeesList.length.sub(1);\r\n    }\r\n  }\r\n\r\n  /**\r\n  * @dev Allows for the beneficiary to withdraw their funds, rejecting\r\n  * further deposits.\r\n  */\r\n  function close() public onlyOwner {\r\n    super.close();\r\n  }\r\n\r\n  function withdraw(address _payee) public onlyOwner {\r\n    require(state == State.Refunding, \"Funds withdrawal is possible only in the Refunding state.\");\r\n    require(depositsOf(_payee) > 0, \"An investor should have non-negative deposit for withdrawal.\");\r\n\r\n    RefundeeRecord storage _data = refundees[_payee];\r\n    require(_data.isRefunded == false, \"An investor should not be refunded.\");\r\n\r\n    uint256 payment = deposits[_payee];\r\n    assert(address(this).balance >= payment);\r\n\r\n    deposits[_payee] = 0;\r\n\r\n    investorsDepositedToCrowdSaleAmount = investorsDepositedToCrowdSaleAmount.sub(payment);\r\n\r\n    _payee.transfer(payment);\r\n\r\n    emit Withdrawn(_payee, payment);\r\n\r\n    _data.isRefunded = true;\r\n\r\n    removeRefundeeByIndex(_data.index);\r\n  }\r\n\r\n  /**\r\n  @dev Owner can do manual refund here if investore has \"BAD\" money\r\n  @param _payee address of investor that needs to refund with next manual ETH sending\r\n  */\r\n  function manualRefund(address _payee) public onlyOwner {\r\n    uint256 payment = deposits[_payee];\r\n    RefundeeRecord storage _data = refundees[_payee];\r\n\r\n    investorsDepositedToCrowdSaleAmount = investorsDepositedToCrowdSaleAmount.sub(payment);\r\n    deposits[_payee] = 0;\r\n    _data.isRefunded = true;\r\n\r\n    removeRefundeeByIndex(_data.index);\r\n  }\r\n\r\n  /**\r\n  * @dev Remove refundee referenced index from the internal list\r\n  * @param _indexToDelete An index in an array for deletion\r\n  */\r\n  function removeRefundeeByIndex(uint256 _indexToDelete) private {\r\n    if ((refundeesList.length > 0) && (_indexToDelete < refundeesList.length)) {\r\n      uint256 _lastIndex = refundeesList.length.sub(1);\r\n      refundeesList[_indexToDelete] = refundeesList[_lastIndex];\r\n      refundeesList.length--;\r\n    }\r\n  }\r\n  /**\r\n  * @dev Get refundee list length\r\n  */\r\n  function refundeesListLength() public onlyOwner view returns (uint256) {\r\n    return refundeesList.length;\r\n  }\r\n\r\n  /**\r\n  * @dev Auto refund\r\n  * @param _txFee The cost of executing refund code\r\n  */\r\n  function withdrawChunk(uint256 _txFee, uint256 _chunkLength) public onlyOwner returns (uint256, address[]) {\r\n    require(state == State.Refunding, \"Funds withdrawal is possible only in the Refunding state.\");\r\n\r\n    uint256 _refundeesCount = refundeesList.length;\r\n    require(_chunkLength >= _refundeesCount);\r\n    require(_txFee > 0, \"Transaction fee should be above zero.\");\r\n    require(_refundeesCount > 0, \"List of investors should not be empty.\");\r\n    uint256 _weiRefunded = 0;\r\n    require(address(this).balance > (_chunkLength.mul(_txFee)), \"Account's ballance should allow to pay all tx fees.\");\r\n    address[] memory _refundeesListCopy = new address[](_chunkLength);\r\n\r\n    uint256 i;\r\n    for (i = 0; i < _chunkLength; i++) {\r\n      address _refundee = refundeesList[i];\r\n      RefundeeRecord storage _data = refundees[_refundee];\r\n      if (_data.isRefunded == false) {\r\n        if (depositsOf(_refundee) > _txFee) {\r\n          uint256 _deposit = depositsOf(_refundee);\r\n          if (_deposit > _txFee) {\r\n            _weiRefunded = _weiRefunded.add(_deposit);\r\n            uint256 _paymentWithoutTxFee = _deposit.sub(_txFee);\r\n            _refundee.transfer(_paymentWithoutTxFee);\r\n            emit Withdrawn(_refundee, _paymentWithoutTxFee);\r\n            _data.isRefunded = true;\r\n            _refundeesListCopy[i] = _refundee;\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    for (i = 0; i < _chunkLength; i++) {\r\n      if (address(0) != _refundeesListCopy[i]) {\r\n        RefundeeRecord storage _dataCleanup = refundees[_refundeesListCopy[i]];\r\n        require(_dataCleanup.isRefunded == true, \"Investors in this list should be refunded.\");\r\n        removeRefundeeByIndex(_dataCleanup.index);\r\n      }\r\n    }\r\n\r\n    return (_weiRefunded, _refundeesListCopy);\r\n  }\r\n\r\n  /**\r\n  * @dev Auto refund\r\n  * @param _txFee The cost of executing refund code\r\n  */\r\n  function withdrawEverything(uint256 _txFee) public onlyOwner returns (uint256, address[]) {\r\n    require(state == State.Refunding, \"Funds withdrawal is possible only in the Refunding state.\");\r\n    return withdrawChunk(_txFee, refundeesList.length);\r\n  }\r\n\r\n  /**\r\n  * @dev Withdraws all beneficiary's funds.\r\n  */\r\n  function beneficiaryWithdraw() public {\r\n    //This methods is intentionally is overriden here to prevent uncontrollable funds transferring to a beneficiary. Only owner should be able to do this\r\n    //require(state == State.Closed);\r\n    //beneficiary.transfer(address(this).balance);\r\n  }\r\n\r\n  /**\r\n  * @dev Withdraws the part of beneficiary's funds.\r\n  */\r\n  function beneficiaryWithdrawChunk(uint256 _value) public onlyOwner {\r\n    require(_value <= address(this).balance, \"Withdraw part can not be more than current balance\");\r\n    beneficiaryDepositedAmount = beneficiaryDepositedAmount.sub(_value);\r\n    beneficiary.transfer(_value);\r\n  }\r\n\r\n  /**\r\n  * @dev Withdraws all beneficiary's funds.\r\n  */\r\n  function beneficiaryWithdrawAll() public onlyOwner {\r\n    uint256 _value = address(this).balance;\r\n    beneficiaryDepositedAmount = beneficiaryDepositedAmount.sub(_value);\r\n    beneficiary.transfer(_value);\r\n  }\r\n\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_payee\",\"type\":\"address\"}],\"name\":\"manualRefund\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"beneficiaryWithdrawAll\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"beneficiaryDepositedAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"beneficiary\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"close\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"refundeesListLength\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_payee\",\"type\":\"address\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"refundeesList\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_payee\",\"type\":\"address\"}],\"name\":\"withdrawalAllowed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"beneficiaryDeposits\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"enableRefunds\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_txFee\",\"type\":\"uint256\"}],\"name\":\"withdrawEverything\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_refundee\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"depositFunds\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"beneficiaryWithdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"investorsDepositedToCrowdSaleAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"state\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_payee\",\"type\":\"address\"}],\"name\":\"beneficiaryDepositsOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"beneficiaryWithdrawChunk\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_payee\",\"type\":\"address\"}],\"name\":\"depositsOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"refundees\",\"outputs\":[{\"name\":\"isRefunded\",\"type\":\"bool\"},{\"name\":\"index\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_refundee\",\"type\":\"address\"}],\"name\":\"deposit\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_txFee\",\"type\":\"uint256\"},{\"name\":\"_chunkLength\",\"type\":\"uint256\"}],\"name\":\"withdrawChunk\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"deposits\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"payee\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"weiAmount\",\"type\":\"uint256\"}],\"name\":\"Deposited\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"payee\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"weiAmount\",\"type\":\"uint256\"}],\"name\":\"Withdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Closed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"RefundsEnabled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"}],\"name\":\"OwnershipRenounced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"ClinicAllRefundEscrow","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000e7f2ca9f90c486c675452514eb074a09128c6921","Library":"","SwarmSource":"bzzr://8f44979867f5282b72aa1a17b5799d00112faeac950c97f37a1120e2a0916712"}]}