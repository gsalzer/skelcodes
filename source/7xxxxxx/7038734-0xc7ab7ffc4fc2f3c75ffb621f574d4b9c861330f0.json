{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\n// File: contracts/lib/ownership/Ownable.sol\r\n\r\ncontract Ownable {\r\n    address public owner;\r\n    event OwnershipTransferred(address indexed previousOwner,address indexed newOwner);\r\n\r\n    /// @dev The Ownable constructor sets the original `owner` of the contract to the sender account.\r\n    constructor() public { owner = msg.sender; }\r\n\r\n    /// @dev Throws if called by any contract other than latest designated caller\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    /// @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n    /// @param newOwner The address to transfer ownership to.\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n       require(newOwner != address(0));\r\n       emit OwnershipTransferred(owner, newOwner);\r\n       owner = newOwner;\r\n    }\r\n}\r\n\r\n// File: contracts/lib/lifecycle/Destructible.sol\r\n\r\ncontract Destructible is Ownable {\r\n\tfunction selfDestruct() public onlyOwner {\r\n\t\tselfdestruct(owner);\r\n\t}\r\n}\r\n\r\n// File: contracts/lib/ownership/ZapCoordinatorInterface.sol\r\n\r\ncontract ZapCoordinatorInterface is Ownable {\r\n\tfunction addImmutableContract(string contractName, address newAddress) external;\r\n\tfunction updateContract(string contractName, address newAddress) external;\r\n\tfunction getContractName(uint index) public view returns (string);\r\n\tfunction getContract(string contractName) public view returns (address);\r\n\tfunction updateAllDependencies() external;\r\n}\r\n\r\n// File: contracts/lib/ownership/Upgradable.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\ncontract Upgradable {\r\n\r\n\taddress coordinatorAddr;\r\n\tZapCoordinatorInterface coordinator;\r\n\r\n\tconstructor(address c) public{\r\n\t\tcoordinatorAddr = c;\r\n\t\tcoordinator = ZapCoordinatorInterface(c);\r\n\t}\r\n\r\n    function updateDependencies() external coordinatorOnly {\r\n       _updateDependencies();\r\n    }\r\n\r\n    function _updateDependencies() internal;\r\n\r\n    modifier coordinatorOnly() {\r\n    \trequire(msg.sender == coordinatorAddr, \"Error: Coordinator Only Function\");\r\n    \t_;\r\n    }\r\n}\r\n\r\n// File: contracts/platform/database/DatabaseInterface.sol\r\n\r\ncontract DatabaseInterface is Ownable {\r\n\tfunction setStorageContract(address _storageContract, bool _allowed) public;\r\n\t/*** Bytes32 ***/\r\n\tfunction getBytes32(bytes32 key) external view returns(bytes32);\r\n\tfunction setBytes32(bytes32 key, bytes32 value) external;\r\n\t/*** Number **/\r\n\tfunction getNumber(bytes32 key) external view returns(uint256);\r\n\tfunction setNumber(bytes32 key, uint256 value) external;\r\n\t/*** Bytes ***/\r\n\tfunction getBytes(bytes32 key) external view returns(bytes);\r\n\tfunction setBytes(bytes32 key, bytes value) external;\r\n\t/*** String ***/\r\n\tfunction getString(bytes32 key) external view returns(string);\r\n\tfunction setString(bytes32 key, string value) external;\r\n\t/*** Bytes Array ***/\r\n\tfunction getBytesArray(bytes32 key) external view returns (bytes32[]);\r\n\tfunction getBytesArrayIndex(bytes32 key, uint256 index) external view returns (bytes32);\r\n\tfunction getBytesArrayLength(bytes32 key) external view returns (uint256);\r\n\tfunction pushBytesArray(bytes32 key, bytes32 value) external;\r\n\tfunction setBytesArrayIndex(bytes32 key, uint256 index, bytes32 value) external;\r\n\tfunction setBytesArray(bytes32 key, bytes32[] value) external;\r\n\t/*** Int Array ***/\r\n\tfunction getIntArray(bytes32 key) external view returns (int[]);\r\n\tfunction getIntArrayIndex(bytes32 key, uint256 index) external view returns (int);\r\n\tfunction getIntArrayLength(bytes32 key) external view returns (uint256);\r\n\tfunction pushIntArray(bytes32 key, int value) external;\r\n\tfunction setIntArrayIndex(bytes32 key, uint256 index, int value) external;\r\n\tfunction setIntArray(bytes32 key, int[] value) external;\r\n\t/*** Address Array ***/\r\n\tfunction getAddressArray(bytes32 key) external view returns (address[]);\r\n\tfunction getAddressArrayIndex(bytes32 key, uint256 index) external view returns (address);\r\n\tfunction getAddressArrayLength(bytes32 key) external view returns (uint256);\r\n\tfunction pushAddressArray(bytes32 key, address value) external;\r\n\tfunction setAddressArrayIndex(bytes32 key, uint256 index, address value) external;\r\n\tfunction setAddressArray(bytes32 key, address[] value) external;\r\n}\r\n\r\n// File: contracts/platform/registry/RegistryInterface.sol\r\n\r\n// Technically an abstract contract, not interface (solidity compiler devs are working to fix this right now)\r\n\r\ncontract RegistryInterface {\r\n    function initiateProvider(uint256, bytes32) public returns (bool);\r\n    function initiateProviderCurve(bytes32, int256[], address) public returns (bool);\r\n    function setEndpointParams(bytes32, bytes32[]) public;\r\n    function getEndpointParams(address, bytes32) public view returns (bytes32[]);\r\n    function getProviderPublicKey(address) public view returns (uint256);\r\n    function getProviderTitle(address) public view returns (bytes32);\r\n    function setProviderParameter(bytes32, bytes) public;\r\n    function setProviderTitle(bytes32) public;\r\n    function clearEndpoint(bytes32) public;\r\n    function getProviderParameter(address, bytes32) public view returns (bytes);\r\n    function getAllProviderParams(address) public view returns (bytes32[]);\r\n    function getProviderCurveLength(address, bytes32) public view returns (uint256);\r\n    function getProviderCurve(address, bytes32) public view returns (int[]);\r\n    function isProviderInitiated(address) public view returns (bool);\r\n    function getAllOracles() external view returns (address[]);\r\n    function getProviderEndpoints(address) public view returns (bytes32[]);\r\n    function getEndpointBroker(address, bytes32) public view returns (address);\r\n}\r\n\r\n// File: contracts/platform/registry/Registry.sol\r\n\r\n// v1.0\r\n\r\n\r\n\r\n\r\n\r\ncontract Registry is Destructible, RegistryInterface, Upgradable {\r\n\r\n    event NewProvider(\r\n        address indexed provider,\r\n        bytes32 indexed title\r\n    );\r\n\r\n    event NewCurve(\r\n        address indexed provider,\r\n        bytes32 indexed endpoint,\r\n        int[] curve,\r\n        address indexed broker\r\n    );\r\n\r\n    DatabaseInterface public db;\r\n\r\n    constructor(address c) Upgradable(c) public {\r\n        _updateDependencies();\r\n    }\r\n\r\n    function _updateDependencies() internal {\r\n        address databaseAddress = coordinator.getContract(\"DATABASE\");\r\n        db = DatabaseInterface(databaseAddress);\r\n    }\r\n\r\n    /// @dev initiates a provider.\r\n    /// If no address->Oracle mapping exists, Oracle object is created\r\n    /// @param publicKey unique id for provider. used for encyrpted key swap for subscription endpoints\r\n    /// @param title name\r\n    function initiateProvider(\r\n        uint256 publicKey,\r\n        bytes32 title\r\n    )\r\n        public\r\n        returns (bool)\r\n    {\r\n        require(!isProviderInitiated(msg.sender), \"Error: Provider is already initiated\");\r\n        createOracle(msg.sender, publicKey, title);\r\n        addOracle(msg.sender);\r\n        emit NewProvider(msg.sender, title);\r\n        return true;\r\n    }\r\n\r\n    /// @dev initiates an endpoint specific provider curve\r\n    /// If oracle[specfifier] is uninitialized, Curve is mapped to endpoint\r\n    /// @param endpoint specifier of endpoint. currently \"smart_contract\" or \"socket_subscription\"\r\n    /// @param curve flattened array of all segments, coefficients across all polynomial terms, [e0,l0,c0,c1,c2,...]\r\n    /// @param broker address for endpoint. if non-zero address, only this address will be able to bond/unbond \r\n    function initiateProviderCurve(\r\n        bytes32 endpoint,\r\n        int256[] curve,\r\n        address broker\r\n    )\r\n        returns (bool)\r\n    {\r\n        // Provider must be initiated\r\n        require(isProviderInitiated(msg.sender), \"Error: Provider is not yet initiated\");\r\n        // Can't reset their curve\r\n        require(getCurveUnset(msg.sender, endpoint), \"Error: Curve is already set\");\r\n        // Can't initiate null endpoint\r\n        require(endpoint != bytes32(0), \"Error: Can't initiate null endpoint\");\r\n\r\n        setCurve(msg.sender, endpoint, curve);        \r\n        db.pushBytesArray(keccak256(abi.encodePacked('oracles', msg.sender, 'endpoints')), endpoint);\r\n        db.setBytes32(keccak256(abi.encodePacked('oracles', msg.sender, endpoint, 'broker')), bytes32(broker));\r\n\r\n        emit NewCurve(msg.sender, endpoint, curve, broker);\r\n\r\n        return true;\r\n    }\r\n\r\n    // Sets provider data\r\n    function setProviderParameter(bytes32 key, bytes value) public {\r\n        // Provider must be initiated\r\n        require(isProviderInitiated(msg.sender), \"Error: Provider is not yet initiated\");\r\n\r\n        if(!isProviderParamInitialized(msg.sender, key)){\r\n            // initialize this provider param\r\n            db.setNumber(keccak256(abi.encodePacked('oracles', msg.sender, 'is_param_set', key)), 1);\r\n            db.pushBytesArray(keccak256(abi.encodePacked('oracles', msg.sender, 'providerParams')), key);\r\n        }\r\n        db.setBytes(keccak256(abi.encodePacked('oracles', msg.sender, 'providerParams', key)), value);\r\n    }\r\n\r\n    // Gets provider data\r\n    function getProviderParameter(address provider, bytes32 key) public view returns (bytes){\r\n        // Provider must be initiated\r\n        require(isProviderInitiated(provider), \"Error: Provider is not yet initiated\");\r\n        require(isProviderParamInitialized(provider, key), \"Error: Provider Parameter is not yet initialized\");\r\n        return db.getBytes(keccak256(abi.encodePacked('oracles', provider, 'providerParams', key)));\r\n    }\r\n\r\n    // Gets keys of all provider params\r\n    function getAllProviderParams(address provider) public view returns (bytes32[]){\r\n        // Provider must be initiated\r\n        require(isProviderInitiated(provider), \"Error: Provider is not yet initiated\");\r\n        return db.getBytesArray(keccak256(abi.encodePacked('oracles', provider, 'providerParams')));\r\n    }\r\n\r\n    // Set endpoint specific parameters for a given endpoint\r\n    function setEndpointParams(bytes32 endpoint, bytes32[] endpointParams) public {\r\n        // Provider must be initiated\r\n        require(isProviderInitiated(msg.sender), \"Error: Provider is not yet initialized\");\r\n        // Can't set endpoint params on an unset provider\r\n        require(!getCurveUnset(msg.sender, endpoint), \"Error: Curve is not yet set\");\r\n\r\n        db.setBytesArray(keccak256(abi.encodePacked('oracles', msg.sender, 'endpointParams', endpoint)), endpointParams);\r\n    }\r\n\r\n    //Set title for registered provider account\r\n    function setProviderTitle(bytes32 title) public {\r\n\r\n        require(isProviderInitiated(msg.sender), \"Error: Provider is not initiated\");\r\n        db.setBytes32(keccak256(abi.encodePacked('oracles', msg.sender, \"title\")), title);\r\n    }\r\n\r\n    //Clear an endpoint with no bonds\r\n    function clearEndpoint(bytes32 endpoint) public {\r\n\r\n        require(isProviderInitiated(msg.sender), \"Error: Provider is not initiated\");\r\n\r\n        uint256 bound = db.getNumber(keccak256(abi.encodePacked('totalBound', msg.sender, endpoint)));\r\n        require(bound == 0, \"Error: Endpoint must have no bonds\");\r\n\r\n        int256[] memory nullArray = new int256[](0);\r\n        bytes32[] memory endpoints =  db.getBytesArray(keccak256(abi.encodePacked(\"oracles\", msg.sender, \"endpoints\")));\r\n        for(uint256 i = 0; i < endpoints.length; i++) {\r\n            if( endpoints[i] == endpoint ) {\r\n               db.setBytesArrayIndex(keccak256(abi.encodePacked(\"oracles\", msg.sender, \"endpoints\")), i, bytes32(0));\r\n               break; \r\n            }\r\n        }\r\n        db.pushBytesArray(keccak256(abi.encodePacked('oracles', msg.sender, 'endpoints')), bytes32(0));\r\n        db.setBytes32(keccak256(abi.encodePacked('oracles', msg.sender, endpoint, 'broker')), bytes32(0));\r\n        db.setIntArray(keccak256(abi.encodePacked('oracles', msg.sender, 'curves', endpoint)), nullArray);\r\n    }\r\n\r\n    /// @return public key\r\n    function getProviderPublicKey(address provider) public view returns (uint256) {\r\n        return getPublicKey(provider);\r\n    }\r\n\r\n    /// @return oracle name\r\n    function getProviderTitle(address provider) public view returns (bytes32) {\r\n        return getTitle(provider);\r\n    }\r\n\r\n\r\n    /// @dev get curve paramaters from oracle\r\n    function getProviderCurve(\r\n        address provider,\r\n        bytes32 endpoint\r\n    )\r\n        public\r\n        view\r\n        returns (int[])\r\n    {\r\n        require(!getCurveUnset(provider, endpoint), \"Error: Curve is not yet set\");\r\n        return db.getIntArray(keccak256(abi.encodePacked('oracles', provider, 'curves', endpoint)));\r\n    }\r\n\r\n    function getProviderCurveLength(address provider, bytes32 endpoint) public view returns (uint256){\r\n        require(!getCurveUnset(provider, endpoint), \"Error: Curve is not yet set\");\r\n        return db.getIntArray(keccak256(abi.encodePacked('oracles', provider, 'curves', endpoint))).length;\r\n    }\r\n\r\n    /// @dev is provider initiated\r\n    /// @param oracleAddress the provider address\r\n    /// @return Whether or not the provider has initiated in the Registry.\r\n    function isProviderInitiated(address oracleAddress) public view returns (bool) {\r\n        return getProviderTitle(oracleAddress) != 0;\r\n    }\r\n\r\n    /*** STORAGE FUNCTIONS ***/\r\n    /// @dev get public key of provider\r\n    function getPublicKey(address provider) public view returns (uint256) {\r\n        return db.getNumber(keccak256(abi.encodePacked(\"oracles\", provider, \"publicKey\")));\r\n    }\r\n\r\n    /// @dev get title of provider\r\n    function getTitle(address provider) public view returns (bytes32) {\r\n        return db.getBytes32(keccak256(abi.encodePacked(\"oracles\", provider, \"title\")));\r\n    }\r\n\r\n    /// @dev get the endpoints of a provider\r\n    function getProviderEndpoints(address provider) public view returns (bytes32[]) {\r\n        return db.getBytesArray(keccak256(abi.encodePacked(\"oracles\", provider, \"endpoints\")));\r\n    }\r\n\r\n    /// @dev get all endpoint params\r\n    function getEndpointParams(address provider, bytes32 endpoint) public view returns (bytes32[]) {\r\n        return db.getBytesArray(keccak256(abi.encodePacked('oracles', provider, 'endpointParams', endpoint)));\r\n    }\r\n\r\n    /// @dev get broker address for endpoint\r\n    function getEndpointBroker(address oracleAddress, bytes32 endpoint) public view returns (address) {\r\n        return address(db.getBytes32(keccak256(abi.encodePacked('oracles', oracleAddress, endpoint, 'broker'))));\r\n    }\r\n\r\n    function getCurveUnset(address provider, bytes32 endpoint) public view returns (bool) {\r\n        return db.getIntArrayLength(keccak256(abi.encodePacked('oracles', provider, 'curves', endpoint))) == 0;\r\n    }\r\n\r\n    /// @dev get provider address by index\r\n    function getOracleAddress(uint256 index) public view returns (address) {\r\n        return db.getAddressArrayIndex(keccak256(abi.encodePacked('oracleIndex')), index);\r\n    }\r\n\r\n    /// @dev get all oracle addresses\r\n    function getAllOracles() external view returns (address[]) {\r\n        return db.getAddressArray(keccak256(abi.encodePacked('oracleIndex')));\r\n    }\r\n\r\n    ///  @dev add new provider to mapping\r\n    function createOracle(address provider, uint256 publicKey, bytes32 title) private {\r\n        db.setNumber(keccak256(abi.encodePacked('oracles', provider, \"publicKey\")), uint256(publicKey));\r\n        db.setBytes32(keccak256(abi.encodePacked('oracles', provider, \"title\")), title);\r\n    }\r\n\r\n    /// @dev add new provider address to oracles array\r\n    function addOracle(address provider) private {\r\n        db.pushAddressArray(keccak256(abi.encodePacked('oracleIndex')), provider);\r\n    }\r\n\r\n    /// @dev initialize new curve for provider\r\n    /// @param provider address of provider\r\n    /// @param endpoint endpoint specifier\r\n    /// @param curve flattened array of all segments, coefficients across all polynomial terms, [l0,c0,c1,c2,..., ck, e0, ...]\r\n    function setCurve(\r\n        address provider,\r\n        bytes32 endpoint,\r\n        int[] curve\r\n    )\r\n        private\r\n    {\r\n        uint prevEnd = 1;\r\n        uint index = 0;\r\n\r\n        // Validate the curve\r\n        while ( index < curve.length ) {\r\n            // Validate the length of the piece\r\n            int len = curve[index];\r\n            require(len > 0, \"Error: Invalid Curve\");\r\n\r\n            // Validate the end index of the piece\r\n            uint endIndex = index + uint(len) + 1;\r\n            require(endIndex < curve.length, \"Error: Invalid Curve\");\r\n\r\n            // Validate that the end is continuous\r\n            int end = curve[endIndex];\r\n            require(uint(end) > prevEnd, \"Error: Invalid Curve\");\r\n\r\n            prevEnd = uint(end);\r\n            index += uint(len) + 2; \r\n        }\r\n\r\n        db.setIntArray(keccak256(abi.encodePacked('oracles', provider, 'curves', endpoint)), curve);\r\n    }\r\n\r\n    // Determines whether this parameter has been initialized\r\n    function isProviderParamInitialized(address provider, bytes32 key) private view returns (bool){\r\n        uint256 val = db.getNumber(keccak256(abi.encodePacked('oracles', provider, 'is_param_set', key)));\r\n        return (val == 1) ? true : false;\r\n    }\r\n\r\n    /*************************************** STORAGE ****************************************\r\n    * 'oracles', provider, 'endpoints' => {bytes32[]} array of endpoints for this oracle\r\n    * 'oracles', provider, 'endpointParams', endpoint => {bytes32[]} array of params for this endpoint\r\n    * 'oracles', provider, 'curves', endpoint => {uint[]} curve array for this endpoint\r\n    * 'oracles', provider, 'broker', endpoint => {bytes32} broker address for this endpoint\r\n    * 'oracles', provider, 'is_param_set', key => {uint} Is this provider parameter set (0/1)\r\n    * 'oracles', provider, \"publicKey\" => {uint} public key for this oracle\r\n    * 'oracles', provider, \"title\" => {bytes32} title of this oracle\r\n    ****************************************************************************************/\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"oracleAddress\",\"type\":\"address\"}],\"name\":\"isProviderInitiated\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"provider\",\"type\":\"address\"},{\"name\":\"endpoint\",\"type\":\"bytes32\"}],\"name\":\"getProviderCurve\",\"outputs\":[{\"name\":\"\",\"type\":\"int256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"endpoint\",\"type\":\"bytes32\"},{\"name\":\"curve\",\"type\":\"int256[]\"},{\"name\":\"broker\",\"type\":\"address\"}],\"name\":\"initiateProviderCurve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"provider\",\"type\":\"address\"}],\"name\":\"getAllProviderParams\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"db\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"provider\",\"type\":\"address\"},{\"name\":\"key\",\"type\":\"bytes32\"}],\"name\":\"getProviderParameter\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"provider\",\"type\":\"address\"}],\"name\":\"getProviderPublicKey\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"provider\",\"type\":\"address\"}],\"name\":\"getProviderTitle\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"provider\",\"type\":\"address\"},{\"name\":\"endpoint\",\"type\":\"bytes32\"}],\"name\":\"getCurveUnset\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"key\",\"type\":\"bytes32\"},{\"name\":\"value\",\"type\":\"bytes\"}],\"name\":\"setProviderParameter\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAllOracles\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"updateDependencies\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"provider\",\"type\":\"address\"}],\"name\":\"getPublicKey\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"provider\",\"type\":\"address\"},{\"name\":\"endpoint\",\"type\":\"bytes32\"}],\"name\":\"getProviderCurveLength\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"endpoint\",\"type\":\"bytes32\"}],\"name\":\"clearEndpoint\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getOracleAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"oracleAddress\",\"type\":\"address\"},{\"name\":\"endpoint\",\"type\":\"bytes32\"}],\"name\":\"getEndpointBroker\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"selfDestruct\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"provider\",\"type\":\"address\"}],\"name\":\"getProviderEndpoints\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"publicKey\",\"type\":\"uint256\"},{\"name\":\"title\",\"type\":\"bytes32\"}],\"name\":\"initiateProvider\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"provider\",\"type\":\"address\"},{\"name\":\"endpoint\",\"type\":\"bytes32\"}],\"name\":\"getEndpointParams\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"provider\",\"type\":\"address\"}],\"name\":\"getTitle\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"title\",\"type\":\"bytes32\"}],\"name\":\"setProviderTitle\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"endpoint\",\"type\":\"bytes32\"},{\"name\":\"endpointParams\",\"type\":\"bytes32[]\"}],\"name\":\"setEndpointParams\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"c\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"provider\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"title\",\"type\":\"bytes32\"}],\"name\":\"NewProvider\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"provider\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"endpoint\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"curve\",\"type\":\"int256[]\"},{\"indexed\":true,\"name\":\"broker\",\"type\":\"address\"}],\"name\":\"NewCurve\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"Registry","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000b007eca49763f31edff95623ed6c23c8c1924a16","Library":"","SwarmSource":"bzzr://40e6b900ae9f12e1ac21fe1e31f46c4faf531c524e11e552c642825cbc44759c"}]}