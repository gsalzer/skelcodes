{"status":"1","message":"OK","result":[{"SourceCode":"{\"Escrow.sol\":{\"content\":\"pragma solidity ^0.5.7;\\n\\nimport \\\"Ownable.sol\\\";\\nimport \\\"IERC20.sol\\\";\\nimport \\\"SafeMath.sol\\\";\\n\\n\\ncontract Escrow is Ownable {\\n\\n    using SafeMath for uint;\\n\\n    event Allocate(address indexed _beneficiary, uint amount, uint releaseDate);\\n    event Withdraw(address indexed _beneficiary, uint amount, uint time);\\n    event Release(address indexed _beneficiary, uint amount, uint time);\\n    \\n    struct TokenLock {\\n        uint amount;\\n        uint releaseDate;\\n    }\\n\\n    // Global variables\\n    uint private timeLockPeriod = 3 * 365 days; // 3 years\\n    uint public lockedContributions;\\n\\n    IERC20 public idealCoinToken;\\n\\n    mapping (address =\\u003e TokenLock[]) public allocations;\\n\\n    constructor(address _idealCoinToken) public Ownable() {\\n        require(_idealCoinToken != address(0), \\\"Cannot initialize Escrow contract with zero address token\\\");\\n        lockedContributions = 0;\\n        idealCoinToken = IERC20(_idealCoinToken); \\n    }\\n\\n    // Allocate tokens to an address\\n    function allocate(address _beneficiary, uint _amount) public onlyOwner {\\n        require(_beneficiary != address(0), \\\"Cannot assign tokens to zero address\\\");\\n        require(_amount \\u003e 0, \\\"Cannot assign zero tokens\\\");\\n        require(lockedContributions.add(_amount) \\u003c= idealCoinToken.balanceOf(address(this)), \\\"Insufficient contract token balance to allocate additional funds to escrow\\\");\\n        \\n        // Create new token lock:\\n        TokenLock memory newTokenLock;\\n        newTokenLock.amount = _amount;\\n        newTokenLock.releaseDate = now + timeLockPeriod;\\n        allocations[_beneficiary].push(newTokenLock);\\n\\n        lockedContributions = lockedContributions.add(_amount); \\n        emit Allocate(_beneficiary, _amount, now + timeLockPeriod);\\n    }\\n\\n    // Withdraw available tokens allocated to msg.sender\\n    function withdraw() public returns (uint) {\\n        require(allocations[msg.sender].length \\u003e 0, \\\"Account has not been allocated any tokens\\\");\\n        uint availableTokens = 0;\\n        \\n        for (uint i = 0; i \\u003c allocations[msg.sender].length; i++){\\n            if (block.timestamp \\u003e allocations[msg.sender][i].releaseDate){\\n                availableTokens = availableTokens.add(allocations[msg.sender][i].amount);\\n                allocations[msg.sender][i].amount = 0;\\n            }\\n        }\\n\\n        require(availableTokens \\u003e 0, \\\"No tokens currently available for withdrawal\\\");\\n        require(idealCoinToken.transfer(msg.sender, availableTokens), \\\"Failed to transfer tokens to contributor\\\");\\n        lockedContributions = lockedContributions.sub(availableTokens);\\n        emit Withdraw(msg.sender, availableTokens, now);\\n        return availableTokens;\\n    }\\n\\n    // Force release escrowed tokens to a specific beneficiary \\n    function release(address _beneficiary) public onlyOwner returns (uint) {\\n        require(allocations[_beneficiary].length \\u003e 0, \\\"Account has not been allocated any tokens\\\");\\n        uint availableTokens = 0;\\n        \\n        for (uint i = 0; i \\u003c allocations[_beneficiary].length; i++){\\n            availableTokens = availableTokens.add(allocations[_beneficiary][i].amount);\\n            allocations[_beneficiary][i].amount = 0;\\n        }\\n        \\n        require(availableTokens \\u003e 0, \\\"No tokens currently available for withdrawal\\\");\\n        require(idealCoinToken.transfer(_beneficiary, availableTokens), \\\"Failed to transfer tokens\\\");\\n        lockedContributions = lockedContributions.sub(availableTokens);\\n        emit Withdraw(_beneficiary, availableTokens, now);\\n        emit Release(_beneficiary, availableTokens, now);\\n        return availableTokens;\\n    }\\n\\n    // Get the unalloacted balance of tokens held by the contract\\n    function getAvailableBalance() public view returns (uint) {\\n        return idealCoinToken.balanceOf(address(this)).sub(lockedContributions);\\n    }\\n\\n    // Withdraw unallocated tokens back to the owner account\\n    function withdrawUnallocatedTokens() public onlyOwner {\\n        uint unallocatedBalance = getAvailableBalance();\\n        require(unallocatedBalance \\u003e 0, \\\"All tokens are locked in escrow\\\");\\n        idealCoinToken.transfer(owner(), unallocatedBalance);\\n    }\\n\\n    // Get the amount of tokens and release times for tokens allocated to an account\\n    function lockedBalances(address _beneficiary) public view returns (uint[] memory, uint[] memory) {\\n        uint[] memory amounts = new uint[](allocations[_beneficiary].length);\\n        uint[] memory releaseDates = new uint[](allocations[_beneficiary].length);\\n\\n        for (uint i = 0; i \\u003c allocations[_beneficiary].length; i++) {\\n            TokenLock storage tokenLock = allocations[_beneficiary][i];\\n            amounts[i] = tokenLock.amount;\\n            releaseDates[i] = tokenLock.releaseDate;\\n        }\\n\\n        return (amounts, releaseDates);\\n    }\\n}\"},\"IERC20.sol\":{\"content\":\"pragma solidity ^0.5.2;\\n\\n/**\\n * @title ERC20 interface\\n * @dev see https://eips.ethereum.org/EIPS/eip-20\\n */\\ninterface IERC20 {\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\\n\\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOf(address who) external view returns (uint256);\\n\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"},\"Ownable.sol\":{\"content\":\"pragma solidity ^0.5.2;\\n\\n/**\\n * @title Ownable\\n * @dev The Ownable contract has an owner address, and provides basic authorization control\\n * functions, this simplifies the implementation of \\\"user permissions\\\".\\n */\\ncontract Ownable {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\\n     * account.\\n     */\\n    constructor () internal {\\n        _owner = msg.sender;\\n        emit OwnershipTransferred(address(0), _owner);\\n    }\\n\\n    /**\\n     * @return the address of the owner.\\n     */\\n    function owner() public view returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(isOwner());\\n        _;\\n    }\\n\\n    /**\\n     * @return true if `msg.sender` is the owner of the contract.\\n     */\\n    function isOwner() public view returns (bool) {\\n        return msg.sender == _owner;\\n    }\\n\\n    /**\\n     * @dev Allows the current owner to relinquish control of the contract.\\n     * It will not be possible to call the functions with the `onlyOwner`\\n     * modifier anymore.\\n     * @notice Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\\n     * @param newOwner The address to transfer ownership to.\\n     */\\n    function transferOwnership(address newOwner) public onlyOwner {\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers control of the contract to a newOwner.\\n     * @param newOwner The address to transfer ownership to.\\n     */\\n    function _transferOwnership(address newOwner) internal {\\n        require(newOwner != address(0));\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\\n\"},\"SafeMath.sol\":{\"content\":\"pragma solidity ^0.5.2;\\n\\n/**\\n * @title SafeMath\\n * @dev Unsigned math operations with safety checks that revert on error\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Multiplies two unsigned integers, reverts on overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring \\u0027a\\u0027 not being zero, but the\\n        // benefit is lost if \\u0027b\\u0027 is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b);\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Solidity only automatically asserts when dividing by 0\\n        require(b \\u003e 0);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn\\u0027t hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b \\u003c= a);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Adds two unsigned integers, reverts on overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c \\u003e= a);\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\\n     * reverts when dividing by zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b != 0);\\n        return a % b;\\n    }\\n}\\n\"}}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"allocations\",\"outputs\":[{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"releaseDate\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"lockedBalances\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"},{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"release\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAvailableBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lockedContributions\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"allocate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawUnallocatedTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"idealCoinToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_idealCoinToken\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"releaseDate\",\"type\":\"uint256\"}],\"name\":\"Allocate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"Release\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"Escrow","CompilerVersion":"v0.5.7+commit.6da8b019","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"0000000000000000000000002d153f2adccbe9364f9e4ed5843308abd0bf93da","Library":"","SwarmSource":"bzzr://a0244faf39a6e682c2fff754fc7cbdd5e8b14c07a4037d97d2312ccfa6094176"}]}