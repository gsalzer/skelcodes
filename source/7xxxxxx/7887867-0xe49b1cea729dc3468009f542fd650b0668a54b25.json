{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity >=0.5.4 <0.6.0;\r\n\r\ninterface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes calldata _extraData) external; }\r\n\r\n\r\ncontract TheAO {\r\n\taddress public theAO;\r\n\taddress public nameTAOPositionAddress;\r\n\r\n\t// Check whether an address is whitelisted and granted access to transact\r\n\t// on behalf of others\r\n\tmapping (address => bool) public whitelist;\r\n\r\n\tconstructor() public {\r\n\t\ttheAO = msg.sender;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Checks if msg.sender is in whitelist.\r\n\t */\r\n\tmodifier inWhitelist() {\r\n\t\trequire (whitelist[msg.sender] == true);\r\n\t\t_;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Transfer ownership of The AO to new address\r\n\t * @param _theAO The new address to be transferred\r\n\t */\r\n\tfunction transferOwnership(address _theAO) public {\r\n\t\trequire (msg.sender == theAO);\r\n\t\trequire (_theAO != address(0));\r\n\t\ttheAO = _theAO;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Whitelist `_account` address to transact on behalf of others\r\n\t * @param _account The address to whitelist\r\n\t * @param _whitelist Either to whitelist or not\r\n\t */\r\n\tfunction setWhitelist(address _account, bool _whitelist) public {\r\n\t\trequire (msg.sender == theAO);\r\n\t\trequire (_account != address(0));\r\n\t\twhitelist[_account] = _whitelist;\r\n\t}\r\n}\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n\t/**\r\n\t * @dev Multiplies two numbers, throws on overflow.\r\n\t */\r\n\tfunction mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n\t\t// Gas optimization: this is cheaper than asserting 'a' not being zero, but the\r\n\t\t// benefit is lost if 'b' is also tested.\r\n\t\t// See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n\t\tif (a == 0) {\r\n\t\t\treturn 0;\r\n\t\t}\r\n\r\n\t\tc = a * b;\r\n\t\tassert(c / a == b);\r\n\t\treturn c;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Integer division of two numbers, truncating the quotient.\r\n\t */\r\n\tfunction div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\t\t// assert(b > 0); // Solidity automatically throws when dividing by 0\r\n\t\t// uint256 c = a / b;\r\n\t\t// assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\t\treturn a / b;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n\t */\r\n\tfunction sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\t\tassert(b <= a);\r\n\t\treturn a - b;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Adds two numbers, throws on overflow.\r\n\t */\r\n\tfunction add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n\t\tc = a + b;\r\n\t\tassert(c >= a);\r\n\t\treturn c;\r\n\t}\r\n}\r\n\r\n\r\ninterface INameAccountRecovery {\r\n\tfunction isCompromised(address _id) external view returns (bool);\r\n}\r\n\r\n\r\ninterface INamePublicKey {\r\n\tfunction initialize(address _id, address _defaultKey, address _writerKey) external returns (bool);\r\n\r\n\tfunction isKeyExist(address _id, address _key) external view returns (bool);\r\n\r\n\tfunction getDefaultKey(address _id) external view returns (address);\r\n\r\n\tfunction whitelistAddKey(address _id, address _key) external returns (bool);\r\n}\r\n\r\n\r\ninterface INameTAOPosition {\r\n\tfunction senderIsAdvocate(address _sender, address _id) external view returns (bool);\r\n\tfunction senderIsListener(address _sender, address _id) external view returns (bool);\r\n\tfunction senderIsSpeaker(address _sender, address _id) external view returns (bool);\r\n\tfunction senderIsPosition(address _sender, address _id) external view returns (bool);\r\n\tfunction getAdvocate(address _id) external view returns (address);\r\n\tfunction nameIsAdvocate(address _nameId, address _id) external view returns (bool);\r\n\tfunction nameIsPosition(address _nameId, address _id) external view returns (bool);\r\n\tfunction initialize(address _id, address _advocateId, address _listenerId, address _speakerId) external returns (bool);\r\n\tfunction determinePosition(address _sender, address _id) external view returns (uint256);\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title TAOCurrency\r\n */\r\ncontract TAOCurrency is TheAO {\r\n\tusing SafeMath for uint256;\r\n\r\n\t// Public variables of the contract\r\n\tstring public name;\r\n\tstring public symbol;\r\n\tuint8 public decimals;\r\n\r\n\t// To differentiate denomination of TAO Currency\r\n\tuint256 public powerOfTen;\r\n\r\n\tuint256 public totalSupply;\r\n\r\n\t// This creates an array with all balances\r\n\t// address is the address of nameId, not the eth public address\r\n\tmapping (address => uint256) public balanceOf;\r\n\r\n\t// This generates a public event on the blockchain that will notify clients\r\n\t// address is the address of TAO/Name Id, not eth public address\r\n\tevent Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n\t// This notifies clients about the amount burnt\r\n\t// address is the address of TAO/Name Id, not eth public address\r\n\tevent Burn(address indexed from, uint256 value);\r\n\r\n\t/**\r\n\t * Constructor function\r\n\t *\r\n\t * Initializes contract with initial supply TAOCurrency to the creator of the contract\r\n\t */\r\n\tconstructor (string memory _name, string memory _symbol, address _nameTAOPositionAddress) public {\r\n\t\tname = _name;\t\t// Set the name for display purposes\r\n\t\tsymbol = _symbol;\t// Set the symbol for display purposes\r\n\r\n\t\tpowerOfTen = 0;\r\n\t\tdecimals = 0;\r\n\r\n\t\tsetNameTAOPositionAddress(_nameTAOPositionAddress);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Checks if the calling contract address is The AO\r\n\t *\t\tOR\r\n\t *\t\tIf The AO is set to a Name/TAO, then check if calling address is the Advocate\r\n\t */\r\n\tmodifier onlyTheAO {\r\n\t\trequire (AOLibrary.isTheAO(msg.sender, theAO, nameTAOPositionAddress));\r\n\t\t_;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Check if `_id` is a Name or a TAO\r\n\t */\r\n\tmodifier isNameOrTAO(address _id) {\r\n\t\trequire (AOLibrary.isName(_id) || AOLibrary.isTAO(_id));\r\n\t\t_;\r\n\t}\r\n\r\n\t/***** The AO ONLY METHODS *****/\r\n\t/**\r\n\t * @dev Transfer ownership of The AO to new address\r\n\t * @param _theAO The new address to be transferred\r\n\t */\r\n\tfunction transferOwnership(address _theAO) public onlyTheAO {\r\n\t\trequire (_theAO != address(0));\r\n\t\ttheAO = _theAO;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Whitelist `_account` address to transact on behalf of others\r\n\t * @param _account The address to whitelist\r\n\t * @param _whitelist Either to whitelist or not\r\n\t */\r\n\tfunction setWhitelist(address _account, bool _whitelist) public onlyTheAO {\r\n\t\trequire (_account != address(0));\r\n\t\twhitelist[_account] = _whitelist;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev The AO set the NameTAOPosition Address\r\n\t * @param _nameTAOPositionAddress The address of NameTAOPosition\r\n\t */\r\n\tfunction setNameTAOPositionAddress(address _nameTAOPositionAddress) public onlyTheAO {\r\n\t\trequire (_nameTAOPositionAddress != address(0));\r\n\t\tnameTAOPositionAddress = _nameTAOPositionAddress;\r\n\t}\r\n\r\n\t/***** PUBLIC METHODS *****/\r\n\t/**\r\n\t * @dev transfer TAOCurrency from other address\r\n\t *\r\n\t * Send `_value` TAOCurrency to `_to` in behalf of `_from`\r\n\t *\r\n\t * @param _from The address of the sender\r\n\t * @param _to The address of the recipient\r\n\t * @param _value the amount to send\r\n\t */\r\n\tfunction transferFrom(address _from, address _to, uint256 _value) public inWhitelist isNameOrTAO(_from) isNameOrTAO(_to) returns (bool) {\r\n\t\t_transfer(_from, _to, _value);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Create `mintedAmount` TAOCurrency and send it to `target`\r\n\t * @param target Address to receive TAOCurrency\r\n\t * @param mintedAmount The amount of TAOCurrency it will receive\r\n\t * @return true on success\r\n\t */\r\n\tfunction mint(address target, uint256 mintedAmount) public inWhitelist isNameOrTAO(target) returns (bool) {\r\n\t\t_mint(target, mintedAmount);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t *\r\n\t * @dev Whitelisted address remove `_value` TAOCurrency from the system irreversibly on behalf of `_from`.\r\n\t *\r\n\t * @param _from the address of the sender\r\n\t * @param _value the amount of money to burn\r\n\t */\r\n\tfunction whitelistBurnFrom(address _from, uint256 _value) public inWhitelist isNameOrTAO(_from) returns (bool success) {\r\n\t\trequire(balanceOf[_from] >= _value);                // Check if the targeted balance is enough\r\n\t\tbalanceOf[_from] = balanceOf[_from].sub(_value);    // Subtract from the targeted balance\r\n\t\ttotalSupply = totalSupply.sub(_value);              // Update totalSupply\r\n\t\temit Burn(_from, _value);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/***** INTERNAL METHODS *****/\r\n\t/**\r\n\t * @dev Send `_value` TAOCurrency from `_from` to `_to`\r\n\t * @param _from The address of sender\r\n\t * @param _to The address of the recipient\r\n\t * @param _value The amount to send\r\n\t */\r\n\tfunction _transfer(address _from, address _to, uint256 _value) internal {\r\n\t\trequire (_to != address(0));\t\t\t\t\t\t\t// Prevent transfer to 0x0 address. Use burn() instead\r\n\t\trequire (balanceOf[_from] >= _value);\t\t\t\t\t// Check if the sender has enough\r\n\t\trequire (balanceOf[_to].add(_value) >= balanceOf[_to]); // Check for overflows\r\n\t\tuint256 previousBalances = balanceOf[_from].add(balanceOf[_to]);\r\n\t\tbalanceOf[_from] = balanceOf[_from].sub(_value);        // Subtract from the sender\r\n\t\tbalanceOf[_to] = balanceOf[_to].add(_value);            // Add the same to the recipient\r\n\t\temit Transfer(_from, _to, _value);\r\n\t\tassert(balanceOf[_from].add(balanceOf[_to]) == previousBalances);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Create `mintedAmount` TAOCurrency and send it to `target`\r\n\t * @param target Address to receive TAOCurrency\r\n\t * @param mintedAmount The amount of TAOCurrency it will receive\r\n\t */\r\n\tfunction _mint(address target, uint256 mintedAmount) internal {\r\n\t\tbalanceOf[target] = balanceOf[target].add(mintedAmount);\r\n\t\ttotalSupply = totalSupply.add(mintedAmount);\r\n\t\temit Transfer(address(0), address(this), mintedAmount);\r\n\t\temit Transfer(address(this), target, mintedAmount);\r\n\t}\r\n}\r\n\r\n\r\ninterface IAOSetting {\r\n\tfunction getSettingValuesByTAOName(address _taoId, string calldata _settingName) external view returns (uint256, bool, address, bytes32, string memory);\r\n\tfunction getSettingTypes() external view returns (uint8, uint8, uint8, uint8, uint8);\r\n\r\n\tfunction settingTypeLookup(uint256 _settingId) external view returns (uint8);\r\n}\r\n\r\n\r\ninterface IAOIonLot {\r\n\tfunction createPrimordialLot(address _account, uint256 _primordialAmount, uint256 _multiplier, uint256 _networkBonusAmount) external returns (bytes32);\r\n\r\n\tfunction createWeightedMultiplierLot(address _account, uint256 _amount, uint256 _weightedMultiplier) external returns (bytes32);\r\n\r\n\tfunction lotById(bytes32 _lotId) external view returns (bytes32, address, uint256, uint256);\r\n\r\n\tfunction totalLotsByAddress(address _lotOwner) external view returns (uint256);\r\n\r\n\tfunction createBurnLot(address _account, uint256 _amount, uint256 _multiplierAfterBurn) external returns (bool);\r\n\r\n\tfunction createConvertLot(address _account, uint256 _amount, uint256 _multiplierAfterConversion) external returns (bool);\r\n}\r\n\r\n\r\ninterface IAOPurchaseReceipt {\r\n\tfunction senderIsBuyer(bytes32 _purchaseReceiptId, address _sender) external view returns (bool);\r\n\r\n\tfunction getById(bytes32 _purchaseReceiptId) external view returns (bytes32, bytes32, bytes32, address, uint256, uint256, uint256, string memory, address, uint256);\r\n\r\n\tfunction isExist(bytes32 _purchaseReceiptId) external view returns (bool);\r\n}\r\n\r\n\r\ninterface IAOContentHost {\r\n\tfunction create(address _host, bytes32 _stakedContentId, string calldata _encChallenge, string calldata _contentDatKey, string calldata _metadataDatKey) external returns (bool);\r\n\r\n\tfunction getById(bytes32 _contentHostId) external view returns (bytes32, bytes32, address, string memory, string memory);\r\n\r\n\tfunction contentHostPrice(bytes32 _contentHostId) external view returns (uint256);\r\n\r\n\tfunction contentHostPaidByAO(bytes32 _contentHostId) external view returns (uint256);\r\n\r\n\tfunction isExist(bytes32 _contentHostId) external view returns (bool);\r\n}\r\n\r\n\r\ninterface IAOStakedContent {\r\n\tfunction getById(bytes32 _stakedContentId) external view returns (bytes32, address, uint256, uint256, uint256, uint256, bool, uint256);\r\n\r\n\tfunction create(address _stakeOwner, bytes32 _contentId, uint256 _networkIntegerAmount, uint256 _networkFractionAmount, bytes8 _denomination, uint256 _primordialAmount, uint256 _profitPercentage) external returns (bytes32);\r\n\r\n\tfunction isActive(bytes32 _stakedContentId) external view returns (bool);\r\n}\r\n\r\n\r\ninterface IAOContent {\r\n\tfunction create(address _creator, string calldata _baseChallenge, uint256 _fileSize, bytes32 _contentUsageType, address _taoId) external returns (bytes32);\r\n\r\n\tfunction isAOContentUsageType(bytes32 _contentId) external view returns (bool);\r\n\r\n\tfunction getById(bytes32 _contentId) external view returns (address, uint256, bytes32, address, bytes32, uint8, bytes32, bytes32, string memory);\r\n\r\n\tfunction getBaseChallenge(bytes32 _contentId) external view returns (string memory);\r\n}\r\n\r\n\r\ninterface INameFactory {\r\n\tfunction nonces(address _nameId) external view returns (uint256);\r\n\tfunction incrementNonce(address _nameId) external returns (uint256);\r\n\tfunction ethAddressToNameId(address _ethAddress) external view returns (address);\r\n\tfunction setNameNewAddress(address _id, address _newAddress) external returns (bool);\r\n\tfunction nameIdToEthAddress(address _nameId) external view returns (address);\r\n}\r\n\r\n\r\ninterface IAOEarning {\r\n\tfunction calculateEarning(bytes32 _purchaseReceiptId) external returns (bool);\r\n\r\n\tfunction releaseEarning(bytes32 _purchaseReceiptId) external returns (bool);\r\n\r\n\tfunction getTotalStakedContentEarning(bytes32 _stakedContentId) external view returns (uint256, uint256, uint256);\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract TokenERC20 {\r\n\t// Public variables of the token\r\n\tstring public name;\r\n\tstring public symbol;\r\n\tuint8 public decimals = 18;\r\n\t// 18 decimals is the strongly suggested default, avoid changing it\r\n\tuint256 public totalSupply;\r\n\r\n\t// This creates an array with all balances\r\n\tmapping (address => uint256) public balanceOf;\r\n\tmapping (address => mapping (address => uint256)) public allowance;\r\n\r\n\t// This generates a public event on the blockchain that will notify clients\r\n\tevent Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n\t// This generates a public event on the blockchain that will notify clients\r\n\tevent Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n\r\n\t// This notifies clients about the amount burnt\r\n\tevent Burn(address indexed from, uint256 value);\r\n\r\n\t/**\r\n\t * Constructor function\r\n\t *\r\n\t * Initializes contract with initial supply tokens to the creator of the contract\r\n\t */\r\n\tconstructor (uint256 initialSupply, string memory tokenName, string memory tokenSymbol) public {\r\n\t\ttotalSupply = initialSupply * 10 ** uint256(decimals);  // Update total supply with the decimal amount\r\n\t\tbalanceOf[msg.sender] = totalSupply;                // Give the creator all initial tokens\r\n\t\tname = tokenName;                                   // Set the name for display purposes\r\n\t\tsymbol = tokenSymbol;                               // Set the symbol for display purposes\r\n\t}\r\n\r\n\t/**\r\n\t * Internal transfer, only can be called by this contract\r\n\t */\r\n\tfunction _transfer(address _from, address _to, uint _value) internal {\r\n\t\t// Prevent transfer to 0x0 address. Use burn() instead\r\n\t\trequire(_to != address(0));\r\n\t\t// Check if the sender has enough\r\n\t\trequire(balanceOf[_from] >= _value);\r\n\t\t// Check for overflows\r\n\t\trequire(balanceOf[_to] + _value > balanceOf[_to]);\r\n\t\t// Save this for an assertion in the future\r\n\t\tuint previousBalances = balanceOf[_from] + balanceOf[_to];\r\n\t\t// Subtract from the sender\r\n\t\tbalanceOf[_from] -= _value;\r\n\t\t// Add the same to the recipient\r\n\t\tbalanceOf[_to] += _value;\r\n\t\temit Transfer(_from, _to, _value);\r\n\t\t// Asserts are used to use static analysis to find bugs in your code. They should never fail\r\n\t\tassert(balanceOf[_from] + balanceOf[_to] == previousBalances);\r\n\t}\r\n\r\n\t/**\r\n\t * Transfer tokens\r\n\t *\r\n\t * Send `_value` tokens to `_to` from your account\r\n\t *\r\n\t * @param _to The address of the recipient\r\n\t * @param _value the amount to send\r\n\t */\r\n\tfunction transfer(address _to, uint256 _value) public returns (bool success) {\r\n\t\t_transfer(msg.sender, _to, _value);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * Transfer tokens from other address\r\n\t *\r\n\t * Send `_value` tokens to `_to` in behalf of `_from`\r\n\t *\r\n\t * @param _from The address of the sender\r\n\t * @param _to The address of the recipient\r\n\t * @param _value the amount to send\r\n\t */\r\n\tfunction transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\r\n\t\trequire(_value <= allowance[_from][msg.sender]);     // Check allowance\r\n\t\tallowance[_from][msg.sender] -= _value;\r\n\t\t_transfer(_from, _to, _value);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * Set allowance for other address\r\n\t *\r\n\t * Allows `_spender` to spend no more than `_value` tokens in your behalf\r\n\t *\r\n\t * @param _spender The address authorized to spend\r\n\t * @param _value the max amount they can spend\r\n\t */\r\n\tfunction approve(address _spender, uint256 _value) public returns (bool success) {\r\n\t\tallowance[msg.sender][_spender] = _value;\r\n\t\temit Approval(msg.sender, _spender, _value);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * Set allowance for other address and notify\r\n\t *\r\n\t * Allows `_spender` to spend no more than `_value` tokens in your behalf, and then ping the contract about it\r\n\t *\r\n\t * @param _spender The address authorized to spend\r\n\t * @param _value the max amount they can spend\r\n\t * @param _extraData some extra information to send to the approved contract\r\n\t */\r\n\tfunction approveAndCall(address _spender, uint256 _value, bytes memory _extraData) public returns (bool success) {\r\n\t\ttokenRecipient spender = tokenRecipient(_spender);\r\n\t\tif (approve(_spender, _value)) {\r\n\t\t\tspender.receiveApproval(msg.sender, _value, address(this), _extraData);\r\n\t\t\treturn true;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Destroy tokens\r\n\t *\r\n\t * Remove `_value` tokens from the system irreversibly\r\n\t *\r\n\t * @param _value the amount of money to burn\r\n\t */\r\n\tfunction burn(uint256 _value) public returns (bool success) {\r\n\t\trequire(balanceOf[msg.sender] >= _value);   // Check if the sender has enough\r\n\t\tbalanceOf[msg.sender] -= _value;            // Subtract from the sender\r\n\t\ttotalSupply -= _value;                      // Updates totalSupply\r\n\t\temit Burn(msg.sender, _value);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * Destroy tokens from other account\r\n\t *\r\n\t * Remove `_value` tokens from the system irreversibly on behalf of `_from`.\r\n\t *\r\n\t * @param _from the address of the sender\r\n\t * @param _value the amount of money to burn\r\n\t */\r\n\tfunction burnFrom(address _from, uint256 _value) public returns (bool success) {\r\n\t\trequire(balanceOf[_from] >= _value);                // Check if the targeted balance is enough\r\n\t\trequire(_value <= allowance[_from][msg.sender]);    // Check allowance\r\n\t\tbalanceOf[_from] -= _value;                         // Subtract from the targeted balance\r\n\t\tallowance[_from][msg.sender] -= _value;             // Subtract from the sender's allowance\r\n\t\ttotalSupply -= _value;                              // Update totalSupply\r\n\t\temit Burn(_from, _value);\r\n\t\treturn true;\r\n\t}\r\n}\r\n\r\n\r\n/**\r\n * @title TAO\r\n */\r\ncontract TAO {\r\n\tusing SafeMath for uint256;\r\n\r\n\taddress public vaultAddress;\r\n\tstring public name;\t\t\t\t// the name for this TAO\r\n\taddress public originId;\t\t// the ID of the Name that created this TAO. If Name, it's the eth address\r\n\r\n\t// TAO's data\r\n\tstring public datHash;\r\n\tstring public database;\r\n\tstring public keyValue;\r\n\tbytes32 public contentId;\r\n\r\n\t/**\r\n\t * 0 = TAO\r\n\t * 1 = Name\r\n\t */\r\n\tuint8 public typeId;\r\n\r\n\t/**\r\n\t * @dev Constructor function\r\n\t */\r\n\tconstructor (string memory _name,\r\n\t\taddress _originId,\r\n\t\tstring memory _datHash,\r\n\t\tstring memory _database,\r\n\t\tstring memory _keyValue,\r\n\t\tbytes32 _contentId,\r\n\t\taddress _vaultAddress\r\n\t) public {\r\n\t\tname = _name;\r\n\t\toriginId = _originId;\r\n\t\tdatHash = _datHash;\r\n\t\tdatabase = _database;\r\n\t\tkeyValue = _keyValue;\r\n\t\tcontentId = _contentId;\r\n\r\n\t\t// Creating TAO\r\n\t\ttypeId = 0;\r\n\r\n\t\tvaultAddress = _vaultAddress;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Checks if calling address is Vault contract\r\n\t */\r\n\tmodifier onlyVault {\r\n\t\trequire (msg.sender == vaultAddress);\r\n\t\t_;\r\n\t}\r\n\r\n\t/**\r\n\t * Will receive any ETH sent\r\n\t */\r\n\tfunction () external payable {\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Allows Vault to transfer `_amount` of ETH from this TAO to `_recipient`\r\n\t * @param _recipient The recipient address\r\n\t * @param _amount The amount to transfer\r\n\t * @return true on success\r\n\t */\r\n\tfunction transferEth(address payable _recipient, uint256 _amount) public onlyVault returns (bool) {\r\n\t\t_recipient.transfer(_amount);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Allows Vault to transfer `_amount` of ERC20 Token from this TAO to `_recipient`\r\n\t * @param _erc20TokenAddress The address of ERC20 Token\r\n\t * @param _recipient The recipient address\r\n\t * @param _amount The amount to transfer\r\n\t * @return true on success\r\n\t */\r\n\tfunction transferERC20(address _erc20TokenAddress, address _recipient, uint256 _amount) public onlyVault returns (bool) {\r\n\t\tTokenERC20 _erc20 = TokenERC20(_erc20TokenAddress);\r\n\t\t_erc20.transfer(_recipient, _amount);\r\n\t\treturn true;\r\n\t}\r\n}\r\n\r\n\r\n\r\n\r\n/**\r\n * @title Name\r\n */\r\ncontract Name is TAO {\r\n\t/**\r\n\t * @dev Constructor function\r\n\t */\r\n\tconstructor (string memory _name, address _originId, string memory _datHash, string memory _database, string memory _keyValue, bytes32 _contentId, address _vaultAddress)\r\n\t\tTAO (_name, _originId, _datHash, _database, _keyValue, _contentId, _vaultAddress) public {\r\n\t\t// Creating Name\r\n\t\ttypeId = 1;\r\n\t}\r\n}\r\n\r\n\r\n\r\n\r\n/**\r\n * @title AOLibrary\r\n */\r\nlibrary AOLibrary {\r\n\tusing SafeMath for uint256;\r\n\r\n\tuint256 constant private _MULTIPLIER_DIVISOR = 10 ** 6; // 1000000 = 1\r\n\tuint256 constant private _PERCENTAGE_DIVISOR = 10 ** 6; // 100% = 1000000\r\n\r\n\t/**\r\n\t * @dev Check whether or not the given TAO ID is a TAO\r\n\t * @param _taoId The ID of the TAO\r\n\t * @return true if yes. false otherwise\r\n\t */\r\n\tfunction isTAO(address _taoId) public view returns (bool) {\r\n\t\treturn (_taoId != address(0) && bytes(TAO(address(uint160(_taoId))).name()).length > 0 && TAO(address(uint160(_taoId))).originId() != address(0) && TAO(address(uint160(_taoId))).typeId() == 0);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Check whether or not the given Name ID is a Name\r\n\t * @param _nameId The ID of the Name\r\n\t * @return true if yes. false otherwise\r\n\t */\r\n\tfunction isName(address _nameId) public view returns (bool) {\r\n\t\treturn (_nameId != address(0) && bytes(TAO(address(uint160(_nameId))).name()).length > 0 && Name(address(uint160(_nameId))).originId() != address(0) && Name(address(uint160(_nameId))).typeId() == 1);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Check if `_tokenAddress` is a valid ERC20 Token address\r\n\t * @param _tokenAddress The ERC20 Token address to check\r\n\t */\r\n\tfunction isValidERC20TokenAddress(address _tokenAddress) public view returns (bool) {\r\n\t\tif (_tokenAddress == address(0)) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tTokenERC20 _erc20 = TokenERC20(_tokenAddress);\r\n\t\treturn (_erc20.totalSupply() >= 0 && bytes(_erc20.name()).length > 0 && bytes(_erc20.symbol()).length > 0);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Checks if the calling contract address is The AO\r\n\t *\t\tOR\r\n\t *\t\tIf The AO is set to a Name/TAO, then check if calling address is the Advocate\r\n\t * @param _sender The address to check\r\n\t * @param _theAO The AO address\r\n\t * @param _nameTAOPositionAddress The address of NameTAOPosition\r\n\t * @return true if yes, false otherwise\r\n\t */\r\n\tfunction isTheAO(address _sender, address _theAO, address _nameTAOPositionAddress) public view returns (bool) {\r\n\t\treturn (_sender == _theAO ||\r\n\t\t\t(\r\n\t\t\t\t(isTAO(_theAO) || isName(_theAO)) &&\r\n\t\t\t\t_nameTAOPositionAddress != address(0) &&\r\n\t\t\t\tINameTAOPosition(_nameTAOPositionAddress).senderIsAdvocate(_sender, _theAO)\r\n\t\t\t)\r\n\t\t);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Return the divisor used to correctly calculate percentage.\r\n\t *\t\tPercentage stored throughout AO contracts covers 4 decimals,\r\n\t *\t\tso 1% is 10000, 1.25% is 12500, etc\r\n\t */\r\n\tfunction PERCENTAGE_DIVISOR() public pure returns (uint256) {\r\n\t\treturn _PERCENTAGE_DIVISOR;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Return the divisor used to correctly calculate multiplier.\r\n\t *\t\tMultiplier stored throughout AO contracts covers 6 decimals,\r\n\t *\t\tso 1 is 1000000, 0.023 is 23000, etc\r\n\t */\r\n\tfunction MULTIPLIER_DIVISOR() public pure returns (uint256) {\r\n\t\treturn _MULTIPLIER_DIVISOR;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev deploy a TAO\r\n\t * @param _name The name of the TAO\r\n\t * @param _originId The Name ID the creates the TAO\r\n\t * @param _datHash The datHash of this TAO\r\n\t * @param _database The database for this TAO\r\n\t * @param _keyValue The key/value pair to be checked on the database\r\n\t * @param _contentId The contentId related to this TAO\r\n\t * @param _nameTAOVaultAddress The address of NameTAOVault\r\n\t */\r\n\tfunction deployTAO(string memory _name,\r\n\t\taddress _originId,\r\n\t\tstring memory _datHash,\r\n\t\tstring memory _database,\r\n\t\tstring memory _keyValue,\r\n\t\tbytes32 _contentId,\r\n\t\taddress _nameTAOVaultAddress\r\n\t\t) public returns (TAO _tao) {\r\n\t\t_tao = new TAO(_name, _originId, _datHash, _database, _keyValue, _contentId, _nameTAOVaultAddress);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev deploy a Name\r\n\t * @param _name The name of the Name\r\n\t * @param _originId The eth address the creates the Name\r\n\t * @param _datHash The datHash of this Name\r\n\t * @param _database The database for this Name\r\n\t * @param _keyValue The key/value pair to be checked on the database\r\n\t * @param _contentId The contentId related to this Name\r\n\t * @param _nameTAOVaultAddress The address of NameTAOVault\r\n\t */\r\n\tfunction deployName(string memory _name,\r\n\t\taddress _originId,\r\n\t\tstring memory _datHash,\r\n\t\tstring memory _database,\r\n\t\tstring memory _keyValue,\r\n\t\tbytes32 _contentId,\r\n\t\taddress _nameTAOVaultAddress\r\n\t\t) public returns (Name _myName) {\r\n\t\t_myName = new Name(_name, _originId, _datHash, _database, _keyValue, _contentId, _nameTAOVaultAddress);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Calculate the new weighted multiplier when adding `_additionalPrimordialAmount` at `_additionalWeightedMultiplier` to the current `_currentPrimordialBalance` at `_currentWeightedMultiplier`\r\n\t * @param _currentWeightedMultiplier Account's current weighted multiplier\r\n\t * @param _currentPrimordialBalance Account's current primordial ion balance\r\n\t * @param _additionalWeightedMultiplier The weighted multiplier to be added\r\n\t * @param _additionalPrimordialAmount The primordial ion amount to be added\r\n\t * @return the new primordial weighted multiplier\r\n\t */\r\n\tfunction calculateWeightedMultiplier(uint256 _currentWeightedMultiplier, uint256 _currentPrimordialBalance, uint256 _additionalWeightedMultiplier, uint256 _additionalPrimordialAmount) public pure returns (uint256) {\r\n\t\tif (_currentWeightedMultiplier > 0) {\r\n\t\t\tuint256 _totalWeightedIons = (_currentWeightedMultiplier.mul(_currentPrimordialBalance)).add(_additionalWeightedMultiplier.mul(_additionalPrimordialAmount));\r\n\t\t\tuint256 _totalIons = _currentPrimordialBalance.add(_additionalPrimordialAmount);\r\n\t\t\treturn _totalWeightedIons.div(_totalIons);\r\n\t\t} else {\r\n\t\t\treturn _additionalWeightedMultiplier;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Calculate the primordial ion multiplier on a given lot\r\n\t *\t\tTotal Primordial Mintable = T\r\n\t *\t\tTotal Primordial Minted = M\r\n\t *\t\tStarting Multiplier = S\r\n\t *\t\tEnding Multiplier = E\r\n\t *\t\tTo Purchase = P\r\n\t *\t\tMultiplier for next Lot of Amount = (1 - ((M + P/2) / T)) x (S-E)\r\n\t *\r\n\t * @param _purchaseAmount The amount of primordial ion intended to be purchased\r\n\t * @param _totalPrimordialMintable Total Primordial ion mintable\r\n\t * @param _totalPrimordialMinted Total Primordial ion minted so far\r\n\t * @param _startingMultiplier The starting multiplier in (10 ** 6)\r\n\t * @param _endingMultiplier The ending multiplier in (10 ** 6)\r\n\t * @return The multiplier in (10 ** 6)\r\n\t */\r\n\tfunction calculatePrimordialMultiplier(uint256 _purchaseAmount, uint256 _totalPrimordialMintable, uint256 _totalPrimordialMinted, uint256 _startingMultiplier, uint256 _endingMultiplier) public pure returns (uint256) {\r\n\t\tif (_purchaseAmount > 0 && _purchaseAmount <= _totalPrimordialMintable.sub(_totalPrimordialMinted)) {\r\n\t\t\t/**\r\n\t\t\t * Let temp = M + (P/2)\r\n\t\t\t * Multiplier = (1 - (temp / T)) x (S-E)\r\n\t\t\t */\r\n\t\t\tuint256 temp = _totalPrimordialMinted.add(_purchaseAmount.div(2));\r\n\r\n\t\t\t/**\r\n\t\t\t * Multiply multiplier with _MULTIPLIER_DIVISOR/_MULTIPLIER_DIVISOR to account for 6 decimals\r\n\t\t\t * so, Multiplier = (_MULTIPLIER_DIVISOR/_MULTIPLIER_DIVISOR) * (1 - (temp / T)) * (S-E)\r\n\t\t\t * Multiplier = ((_MULTIPLIER_DIVISOR * (1 - (temp / T))) * (S-E)) / _MULTIPLIER_DIVISOR\r\n\t\t\t * Multiplier = ((_MULTIPLIER_DIVISOR - ((_MULTIPLIER_DIVISOR * temp) / T)) * (S-E)) / _MULTIPLIER_DIVISOR\r\n\t\t\t * Take out the division by _MULTIPLIER_DIVISOR for now and include in later calculation\r\n\t\t\t * Multiplier = (_MULTIPLIER_DIVISOR - ((_MULTIPLIER_DIVISOR * temp) / T)) * (S-E)\r\n\t\t\t */\r\n\t\t\tuint256 multiplier = (_MULTIPLIER_DIVISOR.sub(_MULTIPLIER_DIVISOR.mul(temp).div(_totalPrimordialMintable))).mul(_startingMultiplier.sub(_endingMultiplier));\r\n\t\t\t/**\r\n\t\t\t * Since _startingMultiplier and _endingMultiplier are in 6 decimals\r\n\t\t\t * Need to divide multiplier by _MULTIPLIER_DIVISOR\r\n\t\t\t */\r\n\t\t\treturn multiplier.div(_MULTIPLIER_DIVISOR);\r\n\t\t} else {\r\n\t\t\treturn 0;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Calculate the bonus percentage of network ion on a given lot\r\n\t *\t\tTotal Primordial Mintable = T\r\n\t *\t\tTotal Primordial Minted = M\r\n\t *\t\tStarting Network Bonus Multiplier = Bs\r\n\t *\t\tEnding Network Bonus Multiplier = Be\r\n\t *\t\tTo Purchase = P\r\n\t *\t\tAO Bonus % = B% = (1 - ((M + P/2) / T)) x (Bs-Be)\r\n\t *\r\n\t * @param _purchaseAmount The amount of primordial ion intended to be purchased\r\n\t * @param _totalPrimordialMintable Total Primordial ion intable\r\n\t * @param _totalPrimordialMinted Total Primordial ion minted so far\r\n\t * @param _startingMultiplier The starting Network ion bonus multiplier\r\n\t * @param _endingMultiplier The ending Network ion bonus multiplier\r\n\t * @return The bonus percentage\r\n\t */\r\n\tfunction calculateNetworkBonusPercentage(uint256 _purchaseAmount, uint256 _totalPrimordialMintable, uint256 _totalPrimordialMinted, uint256 _startingMultiplier, uint256 _endingMultiplier) public pure returns (uint256) {\r\n\t\tif (_purchaseAmount > 0 && _purchaseAmount <= _totalPrimordialMintable.sub(_totalPrimordialMinted)) {\r\n\t\t\t/**\r\n\t\t\t * Let temp = M + (P/2)\r\n\t\t\t * B% = (1 - (temp / T)) x (Bs-Be)\r\n\t\t\t */\r\n\t\t\tuint256 temp = _totalPrimordialMinted.add(_purchaseAmount.div(2));\r\n\r\n\t\t\t/**\r\n\t\t\t * Multiply B% with _PERCENTAGE_DIVISOR/_PERCENTAGE_DIVISOR to account for 6 decimals\r\n\t\t\t * so, B% = (_PERCENTAGE_DIVISOR/_PERCENTAGE_DIVISOR) * (1 - (temp / T)) * (Bs-Be)\r\n\t\t\t * B% = ((_PERCENTAGE_DIVISOR * (1 - (temp / T))) * (Bs-Be)) / _PERCENTAGE_DIVISOR\r\n\t\t\t * B% = ((_PERCENTAGE_DIVISOR - ((_PERCENTAGE_DIVISOR * temp) / T)) * (Bs-Be)) / _PERCENTAGE_DIVISOR\r\n\t\t\t * Take out the division by _PERCENTAGE_DIVISOR for now and include in later calculation\r\n\t\t\t * B% = (_PERCENTAGE_DIVISOR - ((_PERCENTAGE_DIVISOR * temp) / T)) * (Bs-Be)\r\n\t\t\t * But since Bs and Be are in 6 decimals, need to divide by _PERCENTAGE_DIVISOR\r\n\t\t\t * B% = (_PERCENTAGE_DIVISOR - ((_PERCENTAGE_DIVISOR * temp) / T)) * (Bs-Be) / _PERCENTAGE_DIVISOR\r\n\t\t\t */\r\n\t\t\tuint256 bonusPercentage = (_PERCENTAGE_DIVISOR.sub(_PERCENTAGE_DIVISOR.mul(temp).div(_totalPrimordialMintable))).mul(_startingMultiplier.sub(_endingMultiplier)).div(_PERCENTAGE_DIVISOR);\r\n\t\t\treturn bonusPercentage;\r\n\t\t} else {\r\n\t\t\treturn 0;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Calculate the bonus amount of network ion on a given lot\r\n\t *\t\tAO Bonus Amount = B% x P\r\n\t *\r\n\t * @param _purchaseAmount The amount of primordial ion intended to be purchased\r\n\t * @param _totalPrimordialMintable Total Primordial ion intable\r\n\t * @param _totalPrimordialMinted Total Primordial ion minted so far\r\n\t * @param _startingMultiplier The starting Network ion bonus multiplier\r\n\t * @param _endingMultiplier The ending Network ion bonus multiplier\r\n\t * @return The bonus percentage\r\n\t */\r\n\tfunction calculateNetworkBonusAmount(uint256 _purchaseAmount, uint256 _totalPrimordialMintable, uint256 _totalPrimordialMinted, uint256 _startingMultiplier, uint256 _endingMultiplier) public pure returns (uint256) {\r\n\t\tuint256 bonusPercentage = calculateNetworkBonusPercentage(_purchaseAmount, _totalPrimordialMintable, _totalPrimordialMinted, _startingMultiplier, _endingMultiplier);\r\n\t\t/**\r\n\t\t * Since bonusPercentage is in _PERCENTAGE_DIVISOR format, need to divide it with _PERCENTAGE DIVISOR\r\n\t\t * when calculating the network ion bonus amount\r\n\t\t */\r\n\t\tuint256 networkBonus = bonusPercentage.mul(_purchaseAmount).div(_PERCENTAGE_DIVISOR);\r\n\t\treturn networkBonus;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Calculate the maximum amount of Primordial an account can burn\r\n\t *\t\t_primordialBalance = P\r\n\t *\t\t_currentWeightedMultiplier = M\r\n\t *\t\t_maximumMultiplier = S\r\n\t *\t\t_amountToBurn = B\r\n\t *\t\tB = ((S x P) - (P x M)) / S\r\n\t *\r\n\t * @param _primordialBalance Account's primordial ion balance\r\n\t * @param _currentWeightedMultiplier Account's current weighted multiplier\r\n\t * @param _maximumMultiplier The maximum multiplier of this account\r\n\t * @return The maximum burn amount\r\n\t */\r\n\tfunction calculateMaximumBurnAmount(uint256 _primordialBalance, uint256 _currentWeightedMultiplier, uint256 _maximumMultiplier) public pure returns (uint256) {\r\n\t\treturn (_maximumMultiplier.mul(_primordialBalance).sub(_primordialBalance.mul(_currentWeightedMultiplier))).div(_maximumMultiplier);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Calculate the new multiplier after burning primordial ion\r\n\t *\t\t_primordialBalance = P\r\n\t *\t\t_currentWeightedMultiplier = M\r\n\t *\t\t_amountToBurn = B\r\n\t *\t\t_newMultiplier = E\r\n\t *\t\tE = (P x M) / (P - B)\r\n\t *\r\n\t * @param _primordialBalance Account's primordial ion balance\r\n\t * @param _currentWeightedMultiplier Account's current weighted multiplier\r\n\t * @param _amountToBurn The amount of primordial ion to burn\r\n\t * @return The new multiplier\r\n\t */\r\n\tfunction calculateMultiplierAfterBurn(uint256 _primordialBalance, uint256 _currentWeightedMultiplier, uint256 _amountToBurn) public pure returns (uint256) {\r\n\t\treturn _primordialBalance.mul(_currentWeightedMultiplier).div(_primordialBalance.sub(_amountToBurn));\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Calculate the new multiplier after converting network ion to primordial ion\r\n\t *\t\t_primordialBalance = P\r\n\t *\t\t_currentWeightedMultiplier = M\r\n\t *\t\t_amountToConvert = C\r\n\t *\t\t_newMultiplier = E\r\n\t *\t\tE = (P x M) / (P + C)\r\n\t *\r\n\t * @param _primordialBalance Account's primordial ion balance\r\n\t * @param _currentWeightedMultiplier Account's current weighted multiplier\r\n\t * @param _amountToConvert The amount of network ion to convert\r\n\t * @return The new multiplier\r\n\t */\r\n\tfunction calculateMultiplierAfterConversion(uint256 _primordialBalance, uint256 _currentWeightedMultiplier, uint256 _amountToConvert) public pure returns (uint256) {\r\n\t\treturn _primordialBalance.mul(_currentWeightedMultiplier).div(_primordialBalance.add(_amountToConvert));\r\n\t}\r\n\r\n\t/**\r\n\t * @dev count num of digits\r\n\t * @param number uint256 of the nuumber to be checked\r\n\t * @return uint8 num of digits\r\n\t */\r\n\tfunction numDigits(uint256 number) public pure returns (uint8) {\r\n\t\tuint8 digits = 0;\r\n\t\twhile(number != 0) {\r\n\t\t\tnumber = number.div(10);\r\n\t\t\tdigits++;\r\n\t\t}\r\n\t\treturn digits;\r\n\t}\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ninterface ionRecipient {\r\n\tfunction receiveApproval(address _from, uint256 _value, address _token, bytes calldata _extraData) external;\r\n}\r\n\r\n/**\r\n * @title AOIonInterface\r\n */\r\ncontract AOIonInterface is TheAO {\r\n\tusing SafeMath for uint256;\r\n\r\n\taddress public namePublicKeyAddress;\r\n\taddress public nameAccountRecoveryAddress;\r\n\r\n\tINameTAOPosition internal _nameTAOPosition;\r\n\tINamePublicKey internal _namePublicKey;\r\n\tINameAccountRecovery internal _nameAccountRecovery;\r\n\r\n\t// Public variables of the contract\r\n\tstring public name;\r\n\tstring public symbol;\r\n\tuint8 public decimals;\r\n\tuint256 public totalSupply;\r\n\r\n\t// To differentiate denomination of AO\r\n\tuint256 public powerOfTen;\r\n\r\n\t/***** NETWORK ION VARIABLES *****/\r\n\tuint256 public sellPrice;\r\n\tuint256 public buyPrice;\r\n\r\n\t// This creates an array with all balances\r\n\tmapping (address => uint256) public balanceOf;\r\n\tmapping (address => mapping (address => uint256)) public allowance;\r\n\tmapping (address => bool) public frozenAccount;\r\n\tmapping (address => uint256) public stakedBalance;\r\n\tmapping (address => uint256) public escrowedBalance;\r\n\r\n\t// This generates a public event on the blockchain that will notify clients\r\n\tevent FrozenFunds(address target, bool frozen);\r\n\tevent Stake(address indexed from, uint256 value);\r\n\tevent Unstake(address indexed from, uint256 value);\r\n\tevent Escrow(address indexed from, address indexed to, uint256 value);\r\n\tevent Unescrow(address indexed from, uint256 value);\r\n\r\n\t// This generates a public event on the blockchain that will notify clients\r\n\tevent Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n\t// This generates a public event on the blockchain that will notify clients\r\n\tevent Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n\r\n\t// This notifies clients about the amount burnt\r\n\tevent Burn(address indexed from, uint256 value);\r\n\r\n\t/**\r\n\t * @dev Constructor function\r\n\t */\r\n\tconstructor(string memory _name, string memory _symbol, address _nameTAOPositionAddress, address _namePublicKeyAddress, address _nameAccountRecoveryAddress) public {\r\n\t\tsetNameTAOPositionAddress(_nameTAOPositionAddress);\r\n\t\tsetNamePublicKeyAddress(_namePublicKeyAddress);\r\n\t\tsetNameAccountRecoveryAddress(_nameAccountRecoveryAddress);\r\n\t\tname = _name;           // Set the name for display purposes\r\n\t\tsymbol = _symbol;       // Set the symbol for display purposes\r\n\t\tpowerOfTen = 0;\r\n\t\tdecimals = 0;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Checks if the calling contract address is The AO\r\n\t *\t\tOR\r\n\t *\t\tIf The AO is set to a Name/TAO, then check if calling address is the Advocate\r\n\t */\r\n\tmodifier onlyTheAO {\r\n\t\trequire (AOLibrary.isTheAO(msg.sender, theAO, nameTAOPositionAddress));\r\n\t\t_;\r\n\t}\r\n\r\n\t/***** The AO ONLY METHODS *****/\r\n\t/**\r\n\t * @dev Transfer ownership of The AO to new address\r\n\t * @param _theAO The new address to be transferred\r\n\t */\r\n\tfunction transferOwnership(address _theAO) public onlyTheAO {\r\n\t\trequire (_theAO != address(0));\r\n\t\ttheAO = _theAO;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Whitelist `_account` address to transact on behalf of others\r\n\t * @param _account The address to whitelist\r\n\t * @param _whitelist Either to whitelist or not\r\n\t */\r\n\tfunction setWhitelist(address _account, bool _whitelist) public onlyTheAO {\r\n\t\trequire (_account != address(0));\r\n\t\twhitelist[_account] = _whitelist;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev The AO set the NameTAOPosition Address\r\n\t * @param _nameTAOPositionAddress The address of NameTAOPosition\r\n\t */\r\n\tfunction setNameTAOPositionAddress(address _nameTAOPositionAddress) public onlyTheAO {\r\n\t\trequire (_nameTAOPositionAddress != address(0));\r\n\t\tnameTAOPositionAddress = _nameTAOPositionAddress;\r\n\t\t_nameTAOPosition = INameTAOPosition(nameTAOPositionAddress);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev The AO set the NamePublicKey Address\r\n\t * @param _namePublicKeyAddress The address of NamePublicKey\r\n\t */\r\n\tfunction setNamePublicKeyAddress(address _namePublicKeyAddress) public onlyTheAO {\r\n\t\trequire (_namePublicKeyAddress != address(0));\r\n\t\tnamePublicKeyAddress = _namePublicKeyAddress;\r\n\t\t_namePublicKey = INamePublicKey(namePublicKeyAddress);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev The AO set the NameAccountRecovery Address\r\n\t * @param _nameAccountRecoveryAddress The address of NameAccountRecovery\r\n\t */\r\n\tfunction setNameAccountRecoveryAddress(address _nameAccountRecoveryAddress) public onlyTheAO {\r\n\t\trequire (_nameAccountRecoveryAddress != address(0));\r\n\t\tnameAccountRecoveryAddress = _nameAccountRecoveryAddress;\r\n\t\t_nameAccountRecovery = INameAccountRecovery(nameAccountRecoveryAddress);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Allows TheAO to transfer `_amount` of ETH from this address to `_recipient`\r\n\t * @param _recipient The recipient address\r\n\t * @param _amount The amount to transfer\r\n\t */\r\n\tfunction transferEth(address payable _recipient, uint256 _amount) public onlyTheAO {\r\n\t\trequire (_recipient != address(0));\r\n\t\t_recipient.transfer(_amount);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Prevent/Allow target from sending & receiving ions\r\n\t * @param target Address to be frozen\r\n\t * @param freeze Either to freeze it or not\r\n\t */\r\n\tfunction freezeAccount(address target, bool freeze) public onlyTheAO {\r\n\t\tfrozenAccount[target] = freeze;\r\n\t\temit FrozenFunds(target, freeze);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Allow users to buy ions for `newBuyPrice` eth and sell ions for `newSellPrice` eth\r\n\t * @param newSellPrice Price users can sell to the contract\r\n\t * @param newBuyPrice Price users can buy from the contract\r\n\t */\r\n\tfunction setPrices(uint256 newSellPrice, uint256 newBuyPrice) public onlyTheAO {\r\n\t\tsellPrice = newSellPrice;\r\n\t\tbuyPrice = newBuyPrice;\r\n\t}\r\n\r\n\t/***** NETWORK ION WHITELISTED ADDRESS ONLY METHODS *****/\r\n\t/**\r\n\t * @dev Create `mintedAmount` ions and send it to `target`\r\n\t * @param target Address to receive the ions\r\n\t * @param mintedAmount The amount of ions it will receive\r\n\t * @return true on success\r\n\t */\r\n\tfunction mint(address target, uint256 mintedAmount) public inWhitelist returns (bool) {\r\n\t\t_mint(target, mintedAmount);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Stake `_value` ions on behalf of `_from`\r\n\t * @param _from The address of the target\r\n\t * @param _value The amount to stake\r\n\t * @return true on success\r\n\t */\r\n\tfunction stakeFrom(address _from, uint256 _value) public inWhitelist returns (bool) {\r\n\t\trequire (balanceOf[_from] >= _value);\t\t\t\t\t\t// Check if the targeted balance is enough\r\n\t\tbalanceOf[_from] = balanceOf[_from].sub(_value);\t\t\t// Subtract from the targeted balance\r\n\t\tstakedBalance[_from] = stakedBalance[_from].add(_value);\t// Add to the targeted staked balance\r\n\t\temit Stake(_from, _value);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Unstake `_value` ions on behalf of `_from`\r\n\t * @param _from The address of the target\r\n\t * @param _value The amount to unstake\r\n\t * @return true on success\r\n\t */\r\n\tfunction unstakeFrom(address _from, uint256 _value) public inWhitelist returns (bool) {\r\n\t\trequire (stakedBalance[_from] >= _value);\t\t\t\t\t// Check if the targeted staked balance is enough\r\n\t\tstakedBalance[_from] = stakedBalance[_from].sub(_value);\t// Subtract from the targeted staked balance\r\n\t\tbalanceOf[_from] = balanceOf[_from].add(_value);\t\t\t// Add to the targeted balance\r\n\t\temit Unstake(_from, _value);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Store `_value` from `_from` to `_to` in escrow\r\n\t * @param _from The address of the sender\r\n\t * @param _to The address of the recipient\r\n\t * @param _value The amount of network ions to put in escrow\r\n\t * @return true on success\r\n\t */\r\n\tfunction escrowFrom(address _from, address _to, uint256 _value) public inWhitelist returns (bool) {\r\n\t\trequire (balanceOf[_from] >= _value);\t\t\t\t\t\t// Check if the targeted balance is enough\r\n\t\tbalanceOf[_from] = balanceOf[_from].sub(_value);\t\t\t// Subtract from the targeted balance\r\n\t\tescrowedBalance[_to] = escrowedBalance[_to].add(_value);\t// Add to the targeted escrowed balance\r\n\t\temit Escrow(_from, _to, _value);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Create `mintedAmount` ions and send it to `target` escrow balance\r\n\t * @param target Address to receive ions\r\n\t * @param mintedAmount The amount of ions it will receive in escrow\r\n\t */\r\n\tfunction mintEscrow(address target, uint256 mintedAmount) public inWhitelist returns (bool) {\r\n\t\tescrowedBalance[target] = escrowedBalance[target].add(mintedAmount);\r\n\t\ttotalSupply = totalSupply.add(mintedAmount);\r\n\t\temit Escrow(address(this), target, mintedAmount);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Release escrowed `_value` from `_from`\r\n\t * @param _from The address of the sender\r\n\t * @param _value The amount of escrowed network ions to be released\r\n\t * @return true on success\r\n\t */\r\n\tfunction unescrowFrom(address _from, uint256 _value) public inWhitelist returns (bool) {\r\n\t\trequire (escrowedBalance[_from] >= _value);\t\t\t\t\t\t// Check if the targeted escrowed balance is enough\r\n\t\tescrowedBalance[_from] = escrowedBalance[_from].sub(_value);\t// Subtract from the targeted escrowed balance\r\n\t\tbalanceOf[_from] = balanceOf[_from].add(_value);\t\t\t\t// Add to the targeted balance\r\n\t\temit Unescrow(_from, _value);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t *\r\n\t * @dev Whitelisted address remove `_value` ions from the system irreversibly on behalf of `_from`.\r\n\t *\r\n\t * @param _from the address of the sender\r\n\t * @param _value the amount of money to burn\r\n\t */\r\n\tfunction whitelistBurnFrom(address _from, uint256 _value) public inWhitelist returns (bool success) {\r\n\t\trequire(balanceOf[_from] >= _value);                // Check if the targeted balance is enough\r\n\t\tbalanceOf[_from] = balanceOf[_from].sub(_value);    // Subtract from the targeted balance\r\n\t\ttotalSupply = totalSupply.sub(_value);              // Update totalSupply\r\n\t\temit Burn(_from, _value);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Whitelisted address transfer ions from other address\r\n\t *\r\n\t * Send `_value` ions to `_to` on behalf of `_from`\r\n\t *\r\n\t * @param _from The address of the sender\r\n\t * @param _to The address of the recipient\r\n\t * @param _value the amount to send\r\n\t */\r\n\tfunction whitelistTransferFrom(address _from, address _to, uint256 _value) public inWhitelist returns (bool success) {\r\n\t\t_transfer(_from, _to, _value);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/***** PUBLIC METHODS *****/\r\n\t/**\r\n\t * Transfer ions\r\n\t *\r\n\t * Send `_value` ions to `_to` from your account\r\n\t *\r\n\t * @param _to The address of the recipient\r\n\t * @param _value the amount to send\r\n\t */\r\n\tfunction transfer(address _to, uint256 _value) public returns (bool success) {\r\n\t\t_transfer(msg.sender, _to, _value);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * Transfer ions from other address\r\n\t *\r\n\t * Send `_value` ions to `_to` in behalf of `_from`\r\n\t *\r\n\t * @param _from The address of the sender\r\n\t * @param _to The address of the recipient\r\n\t * @param _value the amount to send\r\n\t */\r\n\tfunction transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\r\n\t\trequire(_value <= allowance[_from][msg.sender]);     // Check allowance\r\n\t\tallowance[_from][msg.sender] -= _value;\r\n\t\t_transfer(_from, _to, _value);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * Transfer ions between public key addresses in a Name\r\n\t * @param _nameId The ID of the Name\r\n\t * @param _from The address of the sender\r\n\t * @param _to The address of the recipient\r\n\t * @param _value the amount to send\r\n\t */\r\n\tfunction transferBetweenPublicKeys(address _nameId, address _from, address _to, uint256 _value) public returns (bool success) {\r\n\t\trequire (AOLibrary.isName(_nameId));\r\n\t\trequire (_nameTAOPosition.senderIsAdvocate(msg.sender, _nameId));\r\n\t\trequire (!_nameAccountRecovery.isCompromised(_nameId));\r\n\t\t// Make sure _from exist in the Name's Public Keys\r\n\t\trequire (_namePublicKey.isKeyExist(_nameId, _from));\r\n\t\t// Make sure _to exist in the Name's Public Keys\r\n\t\trequire (_namePublicKey.isKeyExist(_nameId, _to));\r\n\t\t_transfer(_from, _to, _value);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * Set allowance for other address\r\n\t *\r\n\t * Allows `_spender` to spend no more than `_value` ions in your behalf\r\n\t *\r\n\t * @param _spender The address authorized to spend\r\n\t * @param _value the max amount they can spend\r\n\t */\r\n\tfunction approve(address _spender, uint256 _value) public returns (bool success) {\r\n\t\tallowance[msg.sender][_spender] = _value;\r\n\t\temit Approval(msg.sender, _spender, _value);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * Set allowance for other address and notify\r\n\t *\r\n\t * Allows `_spender` to spend no more than `_value` ions in your behalf, and then ping the contract about it\r\n\t *\r\n\t * @param _spender The address authorized to spend\r\n\t * @param _value the max amount they can spend\r\n\t * @param _extraData some extra information to send to the approved contract\r\n\t */\r\n\tfunction approveAndCall(address _spender, uint256 _value, bytes memory _extraData) public returns (bool success) {\r\n\t\tionRecipient spender = ionRecipient(_spender);\r\n\t\tif (approve(_spender, _value)) {\r\n\t\t\tspender.receiveApproval(msg.sender, _value, address(this), _extraData);\r\n\t\t\treturn true;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Destroy ions\r\n\t *\r\n\t * Remove `_value` ions from the system irreversibly\r\n\t *\r\n\t * @param _value the amount of money to burn\r\n\t */\r\n\tfunction burn(uint256 _value) public returns (bool success) {\r\n\t\trequire(balanceOf[msg.sender] >= _value);   // Check if the sender has enough\r\n\t\tbalanceOf[msg.sender] -= _value;            // Subtract from the sender\r\n\t\ttotalSupply -= _value;                      // Updates totalSupply\r\n\t\temit Burn(msg.sender, _value);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * Destroy ions from other account\r\n\t *\r\n\t * Remove `_value` ions from the system irreversibly on behalf of `_from`.\r\n\t *\r\n\t * @param _from the address of the sender\r\n\t * @param _value the amount of money to burn\r\n\t */\r\n\tfunction burnFrom(address _from, uint256 _value) public returns (bool success) {\r\n\t\trequire(balanceOf[_from] >= _value);                // Check if the targeted balance is enough\r\n\t\trequire(_value <= allowance[_from][msg.sender]);    // Check allowance\r\n\t\tbalanceOf[_from] -= _value;                         // Subtract from the targeted balance\r\n\t\tallowance[_from][msg.sender] -= _value;             // Subtract from the sender's allowance\r\n\t\ttotalSupply -= _value;                              // Update totalSupply\r\n\t\temit Burn(_from, _value);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Buy ions from contract by sending ether\r\n\t */\r\n\tfunction buy() public payable {\r\n\t\trequire (buyPrice > 0);\r\n\t\tuint256 amount = msg.value.div(buyPrice);\r\n\t\t_transfer(address(this), msg.sender, amount);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Sell `amount` ions to contract\r\n\t * @param amount The amount of ions to be sold\r\n\t */\r\n\tfunction sell(uint256 amount) public {\r\n\t\trequire (sellPrice > 0);\r\n\t\taddress myAddress = address(this);\r\n\t\trequire (myAddress.balance >= amount.mul(sellPrice));\r\n\t\t_transfer(msg.sender, address(this), amount);\r\n\t\tmsg.sender.transfer(amount.mul(sellPrice));\r\n\t}\r\n\r\n\t/***** INTERNAL METHODS *****/\r\n\t/**\r\n\t * @dev Send `_value` ions from `_from` to `_to`\r\n\t * @param _from The address of sender\r\n\t * @param _to The address of the recipient\r\n\t * @param _value The amount to send\r\n\t */\r\n\tfunction _transfer(address _from, address _to, uint256 _value) internal {\r\n\t\trequire (_to != address(0));\t\t\t\t\t\t\t// Prevent transfer to 0x0 address. Use burn() instead\r\n\t\trequire (balanceOf[_from] >= _value);\t\t\t\t\t// Check if the sender has enough\r\n\t\trequire (balanceOf[_to].add(_value) >= balanceOf[_to]); // Check for overflows\r\n\t\trequire (!frozenAccount[_from]);\t\t\t\t\t\t// Check if sender is frozen\r\n\t\trequire (!frozenAccount[_to]);\t\t\t\t\t\t\t// Check if recipient is frozen\r\n\t\tuint256 previousBalances = balanceOf[_from].add(balanceOf[_to]);\r\n\t\tbalanceOf[_from] = balanceOf[_from].sub(_value);        // Subtract from the sender\r\n\t\tbalanceOf[_to] = balanceOf[_to].add(_value);            // Add the same to the recipient\r\n\t\temit Transfer(_from, _to, _value);\r\n\t\tassert(balanceOf[_from].add(balanceOf[_to]) == previousBalances);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Create `mintedAmount` ions and send it to `target`\r\n\t * @param target Address to receive the ions\r\n\t * @param mintedAmount The amount of ions it will receive\r\n\t */\r\n\tfunction _mint(address target, uint256 mintedAmount) internal {\r\n\t\tbalanceOf[target] = balanceOf[target].add(mintedAmount);\r\n\t\ttotalSupply = totalSupply.add(mintedAmount);\r\n\t\temit Transfer(address(0), address(this), mintedAmount);\r\n\t\temit Transfer(address(this), target, mintedAmount);\r\n\t}\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title AOETH\r\n */\r\ncontract AOETH is TheAO, TokenERC20, tokenRecipient {\r\n\tusing SafeMath for uint256;\r\n\r\n\taddress public aoIonAddress;\r\n\r\n\tAOIon internal _aoIon;\r\n\r\n\tuint256 public totalERC20Tokens;\r\n\tuint256 public totalTokenExchanges;\r\n\r\n\tstruct ERC20Token {\r\n\t\taddress tokenAddress;\r\n\t\tuint256 price;\t\t\t// price of this ERC20 Token to AOETH\r\n\t\tuint256 maxQuantity;\t// To prevent too much exposure to a given asset\r\n\t\tuint256 exchangedQuantity;\t// Running total (total AOETH exchanged from this specific ERC20 Token)\r\n\t\tbool active;\r\n\t}\r\n\r\n\tstruct TokenExchange {\r\n\t\tbytes32 exchangeId;\r\n\t\taddress buyer;\t\t\t// The buyer address\r\n\t\taddress tokenAddress;\t// The address of ERC20 Token\r\n\t\tuint256 price;\t\t\t// price of ERC20 Token to AOETH\r\n\t\tuint256 sentAmount;\t\t// Amount of ERC20 Token sent\r\n\t\tuint256 receivedAmount;\t// Amount of AOETH received\r\n\t\tbytes extraData; // Extra data\r\n\t}\r\n\r\n\t// Mapping from id to ERC20Token object\r\n\tmapping (uint256 => ERC20Token) internal erc20Tokens;\r\n\tmapping (address => uint256) internal erc20TokenIdLookup;\r\n\r\n\t// Mapping from id to TokenExchange object\r\n\tmapping (uint256 => TokenExchange) internal tokenExchanges;\r\n\tmapping (bytes32 => uint256) internal tokenExchangeIdLookup;\r\n\tmapping (address => uint256) public totalAddressTokenExchanges;\r\n\r\n\t// Event to be broadcasted to public when TheAO adds an ERC20 Token\r\n\tevent AddERC20Token(address indexed tokenAddress, uint256 price, uint256 maxQuantity);\r\n\r\n\t// Event to be broadcasted to public when TheAO sets price for ERC20 Token\r\n\tevent SetPrice(address indexed tokenAddress, uint256 price);\r\n\r\n\t// Event to be broadcasted to public when TheAO sets max quantity for ERC20 Token\r\n\tevent SetMaxQuantity(address indexed tokenAddress, uint256 maxQuantity);\r\n\r\n\t// Event to be broadcasted to public when TheAO sets active status for ERC20 Token\r\n\tevent SetActive(address indexed tokenAddress, bool active);\r\n\r\n\t// Event to be broadcasted to public when user exchanges ERC20 Token for AOETH\r\n\tevent ExchangeToken(bytes32 indexed exchangeId, address indexed from, address tokenAddress, string tokenName, string tokenSymbol, uint256 sentTokenAmount, uint256 receivedAOETHAmount, bytes extraData);\r\n\r\n\t/**\r\n\t * @dev Constructor function\r\n\t */\r\n\tconstructor(uint256 initialSupply, string memory tokenName, string memory tokenSymbol, address _aoIonAddress, address _nameTAOPositionAddress)\r\n\t\tTokenERC20(initialSupply, tokenName, tokenSymbol) public {\r\n\t\tsetAOIonAddress(_aoIonAddress);\r\n\t\tsetNameTAOPositionAddress(_nameTAOPositionAddress);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Checks if the calling contract address is The AO\r\n\t *\t\tOR\r\n\t *\t\tIf The AO is set to a Name/TAO, then check if calling address is the Advocate\r\n\t */\r\n\tmodifier onlyTheAO {\r\n\t\trequire (AOLibrary.isTheAO(msg.sender, theAO, nameTAOPositionAddress));\r\n\t\t_;\r\n\t}\r\n\r\n\t/***** The AO ONLY METHODS *****/\r\n\t/**\r\n\t * @dev Transfer ownership of The AO to new address\r\n\t * @param _theAO The new address to be transferred\r\n\t */\r\n\tfunction transferOwnership(address _theAO) public onlyTheAO {\r\n\t\trequire (_theAO != address(0));\r\n\t\ttheAO = _theAO;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Whitelist `_account` address to transact on behalf of others\r\n\t * @param _account The address to whitelist\r\n\t * @param _whitelist Either to whitelist or not\r\n\t */\r\n\tfunction setWhitelist(address _account, bool _whitelist) public onlyTheAO {\r\n\t\trequire (_account != address(0));\r\n\t\twhitelist[_account] = _whitelist;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev The AO set the AOIon Address\r\n\t * @param _aoIonAddress The address of AOIon\r\n\t */\r\n\tfunction setAOIonAddress(address _aoIonAddress) public onlyTheAO {\r\n\t\trequire (_aoIonAddress != address(0));\r\n\t\taoIonAddress = _aoIonAddress;\r\n\t\t_aoIon = AOIon(_aoIonAddress);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev The AO set the NameTAOPosition Address\r\n\t * @param _nameTAOPositionAddress The address of NameTAOPosition\r\n\t */\r\n\tfunction setNameTAOPositionAddress(address _nameTAOPositionAddress) public onlyTheAO {\r\n\t\trequire (_nameTAOPositionAddress != address(0));\r\n\t\tnameTAOPositionAddress = _nameTAOPositionAddress;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Allows TheAO to transfer `_amount` of ERC20 Token from this address to `_recipient`\r\n\t * @param _erc20TokenAddress The address of ERC20 Token\r\n\t * @param _recipient The recipient address\r\n\t * @param _amount The amount to transfer\r\n\t */\r\n\tfunction transferERC20(address _erc20TokenAddress, address _recipient, uint256 _amount) public onlyTheAO {\r\n\t\tTokenERC20 _erc20 = TokenERC20(_erc20TokenAddress);\r\n\t\trequire (_erc20.transfer(_recipient, _amount));\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Add an ERC20 Token to the list\r\n\t * @param _tokenAddress The address of the ERC20 Token\r\n\t * @param _price The price of this token to AOETH\r\n\t * @param _maxQuantity Maximum quantity allowed for exchange\r\n\t */\r\n\tfunction addERC20Token(address _tokenAddress, uint256 _price, uint256 _maxQuantity) public onlyTheAO {\r\n\t\trequire (_tokenAddress != address(0) && _price > 0 && _maxQuantity > 0);\r\n\t\trequire (AOLibrary.isValidERC20TokenAddress(_tokenAddress));\r\n\t\trequire (erc20TokenIdLookup[_tokenAddress] == 0);\r\n\r\n\t\ttotalERC20Tokens++;\r\n\t\terc20TokenIdLookup[_tokenAddress] = totalERC20Tokens;\r\n\t\tERC20Token storage _erc20Token = erc20Tokens[totalERC20Tokens];\r\n\t\t_erc20Token.tokenAddress = _tokenAddress;\r\n\t\t_erc20Token.price = _price;\r\n\t\t_erc20Token.maxQuantity = _maxQuantity;\r\n\t\t_erc20Token.active = true;\r\n\t\temit AddERC20Token(_erc20Token.tokenAddress, _erc20Token.price, _erc20Token.maxQuantity);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Set price for existing ERC20 Token\r\n\t * @param _tokenAddress The address of the ERC20 Token\r\n\t * @param _price The price of this token to AOETH\r\n\t */\r\n\tfunction setPrice(address _tokenAddress, uint256 _price) public onlyTheAO {\r\n\t\trequire (erc20TokenIdLookup[_tokenAddress] > 0);\r\n\t\trequire (_price > 0);\r\n\r\n\t\tERC20Token storage _erc20Token = erc20Tokens[erc20TokenIdLookup[_tokenAddress]];\r\n\t\t_erc20Token.price = _price;\r\n\t\temit SetPrice(_erc20Token.tokenAddress, _erc20Token.price);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Set max quantity for existing ERC20 Token\r\n\t * @param _tokenAddress The address of the ERC20 Token\r\n\t * @param _maxQuantity The max exchange quantity for this token\r\n\t */\r\n\tfunction setMaxQuantity(address _tokenAddress, uint256 _maxQuantity) public onlyTheAO {\r\n\t\trequire (erc20TokenIdLookup[_tokenAddress] > 0);\r\n\r\n\t\tERC20Token storage _erc20Token = erc20Tokens[erc20TokenIdLookup[_tokenAddress]];\r\n\t\trequire (_maxQuantity > _erc20Token.exchangedQuantity);\r\n\t\t_erc20Token.maxQuantity = _maxQuantity;\r\n\t\temit SetMaxQuantity(_erc20Token.tokenAddress, _erc20Token.maxQuantity);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Set active status for existing ERC20 Token\r\n\t * @param _tokenAddress The address of the ERC20 Token\r\n\t * @param _active The active status for this token\r\n\t */\r\n\tfunction setActive(address _tokenAddress, bool _active) public onlyTheAO {\r\n\t\trequire (erc20TokenIdLookup[_tokenAddress] > 0);\r\n\r\n\t\tERC20Token storage _erc20Token = erc20Tokens[erc20TokenIdLookup[_tokenAddress]];\r\n\t\t_erc20Token.active = _active;\r\n\t\temit SetActive(_erc20Token.tokenAddress, _erc20Token.active);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Whitelisted address transfer tokens from other address\r\n\t *\r\n\t * Send `_value` tokens to `_to` on behalf of `_from`\r\n\t *\r\n\t * @param _from The address of the sender\r\n\t * @param _to The address of the recipient\r\n\t * @param _value the amount to send\r\n\t */\r\n\tfunction whitelistTransferFrom(address _from, address _to, uint256 _value) public inWhitelist returns (bool success) {\r\n\t\t_transfer(_from, _to, _value);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/***** PUBLIC METHODS *****/\r\n\t/**\r\n\t * @dev Get an ERC20 Token information given an ID\r\n\t * @param _id The internal ID of the ERC20 Token\r\n\t * @return The ERC20 Token address\r\n\t * @return The name of the token\r\n\t * @return The symbol of the token\r\n\t * @return The price of this token to AOETH\r\n\t * @return The max quantity for exchange\r\n\t * @return The total AOETH exchanged from this token\r\n\t * @return The status of this token\r\n\t */\r\n\tfunction getById(uint256 _id) public view returns (address, string memory, string memory, uint256, uint256, uint256, bool) {\r\n\t\trequire (erc20Tokens[_id].tokenAddress != address(0));\r\n\t\tERC20Token memory _erc20Token = erc20Tokens[_id];\r\n\t\treturn (\r\n\t\t\t_erc20Token.tokenAddress,\r\n\t\t\tTokenERC20(_erc20Token.tokenAddress).name(),\r\n\t\t\tTokenERC20(_erc20Token.tokenAddress).symbol(),\r\n\t\t\t_erc20Token.price,\r\n\t\t\t_erc20Token.maxQuantity,\r\n\t\t\t_erc20Token.exchangedQuantity,\r\n\t\t\t_erc20Token.active\r\n\t\t);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Get an ERC20 Token information given an address\r\n\t * @param _tokenAddress The address of the ERC20 Token\r\n\t * @return The ERC20 Token address\r\n\t * @return The name of the token\r\n\t * @return The symbol of the token\r\n\t * @return The price of this token to AOETH\r\n\t * @return The max quantity for exchange\r\n\t * @return The total AOETH exchanged from this token\r\n\t * @return The status of this token\r\n\t */\r\n\tfunction getByAddress(address _tokenAddress) public view returns (address, string memory, string memory, uint256, uint256, uint256, bool) {\r\n\t\trequire (erc20TokenIdLookup[_tokenAddress] > 0);\r\n\t\treturn getById(erc20TokenIdLookup[_tokenAddress]);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev When a user approves AOETH to spend on his/her behalf (i.e exchange to AOETH)\r\n\t * @param _from The user address that approved AOETH\r\n\t * @param _value The amount that the user approved\r\n\t * @param _token The address of the ERC20 Token\r\n\t * @param _extraData The extra data sent during the approval\r\n\t */\r\n\tfunction receiveApproval(address _from, uint256 _value, address _token, bytes calldata _extraData) external {\r\n\t\trequire (_from != address(0));\r\n\t\trequire (AOLibrary.isValidERC20TokenAddress(_token));\r\n\r\n\t\t// Check if the token is supported\r\n\t\trequire (erc20TokenIdLookup[_token] > 0);\r\n\t\tERC20Token storage _erc20Token = erc20Tokens[erc20TokenIdLookup[_token]];\r\n\t\trequire (_erc20Token.active && _erc20Token.price > 0 && _erc20Token.exchangedQuantity < _erc20Token.maxQuantity);\r\n\r\n\t\tuint256 amountToTransfer = _value.div(_erc20Token.price);\r\n\t\trequire (_erc20Token.maxQuantity.sub(_erc20Token.exchangedQuantity) >= amountToTransfer);\r\n\t\trequire (_aoIon.availableETH() >= amountToTransfer);\r\n\r\n\t\t// Transfer the ERC20 Token from the `_from` address to here\r\n\t\trequire (TokenERC20(_token).transferFrom(_from, address(this), _value));\r\n\r\n\t\t_erc20Token.exchangedQuantity = _erc20Token.exchangedQuantity.add(amountToTransfer);\r\n\t\tbalanceOf[_from] = balanceOf[_from].add(amountToTransfer);\r\n\t\ttotalSupply = totalSupply.add(amountToTransfer);\r\n\r\n\t\t// Store the TokenExchange information\r\n\t\ttotalTokenExchanges++;\r\n\t\ttotalAddressTokenExchanges[_from]++;\r\n\t\tbytes32 _exchangeId = keccak256(abi.encodePacked(this, _from, totalTokenExchanges));\r\n\t\ttokenExchangeIdLookup[_exchangeId] = totalTokenExchanges;\r\n\r\n\t\tTokenExchange storage _tokenExchange = tokenExchanges[totalTokenExchanges];\r\n\t\t_tokenExchange.exchangeId = _exchangeId;\r\n\t\t_tokenExchange.buyer = _from;\r\n\t\t_tokenExchange.tokenAddress = _token;\r\n\t\t_tokenExchange.price = _erc20Token.price;\r\n\t\t_tokenExchange.sentAmount = _value;\r\n\t\t_tokenExchange.receivedAmount = amountToTransfer;\r\n\t\t_tokenExchange.extraData = _extraData;\r\n\r\n\t\temit ExchangeToken(_tokenExchange.exchangeId, _tokenExchange.buyer, _tokenExchange.tokenAddress, TokenERC20(_token).name(), TokenERC20(_token).symbol(), _tokenExchange.sentAmount, _tokenExchange.receivedAmount, _tokenExchange.extraData);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Get TokenExchange information given an exchange ID\r\n\t * @param _exchangeId The exchange ID to query\r\n\t * @return The buyer address\r\n\t * @return The sent ERC20 Token address\r\n\t * @return The ERC20 Token name\r\n\t * @return The ERC20 Token symbol\r\n\t * @return The price of ERC20 Token to AOETH\r\n\t * @return The amount of ERC20 Token sent\r\n\t * @return The amount of AOETH received\r\n\t * @return Extra data during the transaction\r\n\t */\r\n\tfunction getTokenExchangeById(bytes32 _exchangeId) public view returns (address, address, string memory, string memory, uint256, uint256,  uint256, bytes memory) {\r\n\t\trequire (tokenExchangeIdLookup[_exchangeId] > 0);\r\n\t\tTokenExchange memory _tokenExchange = tokenExchanges[tokenExchangeIdLookup[_exchangeId]];\r\n\t\treturn (\r\n\t\t\t_tokenExchange.buyer,\r\n\t\t\t_tokenExchange.tokenAddress,\r\n\t\t\tTokenERC20(_tokenExchange.tokenAddress).name(),\r\n\t\t\tTokenERC20(_tokenExchange.tokenAddress).symbol(),\r\n\t\t\t_tokenExchange.price,\r\n\t\t\t_tokenExchange.sentAmount,\r\n\t\t\t_tokenExchange.receivedAmount,\r\n\t\t\t_tokenExchange.extraData\r\n\t\t);\r\n\t}\r\n}\r\n\r\n\r\n/**\r\n * @title AOIon\r\n */\r\ncontract AOIon is AOIonInterface {\r\n\tusing SafeMath for uint256;\r\n\r\n\taddress public aoIonLotAddress;\r\n\taddress public settingTAOId;\r\n\taddress public aoSettingAddress;\r\n\taddress public aoethAddress;\r\n\r\n\t// AO Dev Team addresses to receive Primordial/Network Ions\r\n\taddress public aoDevTeam1 = 0x146CbD9821e6A42c8ff6DC903fe91CB69625A105;\r\n\taddress public aoDevTeam2 = 0x4810aF1dA3aC827259eEa72ef845F4206C703E8D;\r\n\r\n\tIAOIonLot internal _aoIonLot;\r\n\tIAOSetting internal _aoSetting;\r\n\tAOETH internal _aoeth;\r\n\r\n\t/***** PRIMORDIAL ION VARIABLES *****/\r\n\tuint256 public primordialTotalSupply;\r\n\tuint256 public primordialTotalBought;\r\n\tuint256 public primordialSellPrice;\r\n\tuint256 public primordialBuyPrice;\r\n\tuint256 public totalEthForPrimordial;\t// Total ETH sent for Primordial AO+\r\n\tuint256 public totalRedeemedAOETH;\t\t// Total AOETH redeemed for Primordial AO+\r\n\r\n\t// Total available primordial ion for sale 3,377,699,720,527,872 AO+\r\n\tuint256 constant public TOTAL_PRIMORDIAL_FOR_SALE = 3377699720527872;\r\n\r\n\tmapping (address => uint256) public primordialBalanceOf;\r\n\tmapping (address => mapping (address => uint256)) public primordialAllowance;\r\n\r\n\t// Mapping from owner's lot weighted multiplier to the amount of staked ions\r\n\tmapping (address => mapping (uint256 => uint256)) public primordialStakedBalance;\r\n\r\n\tevent PrimordialTransfer(address indexed from, address indexed to, uint256 value);\r\n\tevent PrimordialApproval(address indexed _owner, address indexed _spender, uint256 _value);\r\n\tevent PrimordialBurn(address indexed from, uint256 value);\r\n\tevent PrimordialStake(address indexed from, uint256 value, uint256 weightedMultiplier);\r\n\tevent PrimordialUnstake(address indexed from, uint256 value, uint256 weightedMultiplier);\r\n\r\n\tevent NetworkExchangeEnded();\r\n\r\n\tbool public networkExchangeEnded;\r\n\r\n\t// Mapping from owner to his/her current weighted multiplier\r\n\tmapping (address => uint256) internal ownerWeightedMultiplier;\r\n\r\n\t// Mapping from owner to his/her max multiplier (multiplier of account's first Lot)\r\n\tmapping (address => uint256) internal ownerMaxMultiplier;\r\n\r\n\t// Event to be broadcasted to public when user buys primordial ion\r\n\t// payWith 1 == with Ethereum\r\n\t// payWith 2 == with AOETH\r\n\tevent BuyPrimordial(address indexed lotOwner, bytes32 indexed lotId, uint8 payWith, uint256 sentAmount, uint256 refundedAmount);\r\n\r\n\t/**\r\n\t * @dev Constructor function\r\n\t */\r\n\tconstructor(string memory _name, string memory _symbol, address _settingTAOId, address _aoSettingAddress, address _nameTAOPositionAddress, address _namePublicKeyAddress, address _nameAccountRecoveryAddress)\r\n\t\tAOIonInterface(_name, _symbol, _nameTAOPositionAddress, _namePublicKeyAddress, _nameAccountRecoveryAddress) public {\r\n\t\tsetSettingTAOId(_settingTAOId);\r\n\t\tsetAOSettingAddress(_aoSettingAddress);\r\n\r\n\t\tpowerOfTen = 0;\r\n\t\tdecimals = 0;\r\n\t\tsetPrimordialPrices(0, 10 ** 8); // Set Primordial buy price to 0.1 gwei/ion\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Checks if buyer can buy primordial ion\r\n\t */\r\n\tmodifier canBuyPrimordial(uint256 _sentAmount, bool _withETH) {\r\n\t\trequire (networkExchangeEnded == false &&\r\n\t\t\tprimordialTotalBought < TOTAL_PRIMORDIAL_FOR_SALE &&\r\n\t\t\tprimordialBuyPrice > 0 &&\r\n\t\t\t_sentAmount > 0 &&\r\n\t\t\tavailablePrimordialForSaleInETH() > 0 &&\r\n\t\t\t(\r\n\t\t\t\t(_withETH && availableETH() > 0) ||\r\n\t\t\t\t(!_withETH && totalRedeemedAOETH < _aoeth.totalSupply())\r\n\t\t\t)\r\n\t\t);\r\n\t\t_;\r\n\t}\r\n\r\n\t/***** The AO ONLY METHODS *****/\r\n\t/**\r\n\t * @dev The AO sets AOIonLot address\r\n\t * @param _aoIonLotAddress The address of AOIonLot\r\n\t */\r\n\tfunction setAOIonLotAddress(address _aoIonLotAddress) public onlyTheAO {\r\n\t\trequire (_aoIonLotAddress != address(0));\r\n\t\taoIonLotAddress = _aoIonLotAddress;\r\n\t\t_aoIonLot = IAOIonLot(_aoIonLotAddress);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev The AO sets setting TAO ID\r\n\t * @param _settingTAOId The new setting TAO ID to set\r\n\t */\r\n\tfunction setSettingTAOId(address _settingTAOId) public onlyTheAO {\r\n\t\trequire (AOLibrary.isTAO(_settingTAOId));\r\n\t\tsettingTAOId = _settingTAOId;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev The AO sets AO Setting address\r\n\t * @param _aoSettingAddress The address of AOSetting\r\n\t */\r\n\tfunction setAOSettingAddress(address _aoSettingAddress) public onlyTheAO {\r\n\t\trequire (_aoSettingAddress != address(0));\r\n\t\taoSettingAddress = _aoSettingAddress;\r\n\t\t_aoSetting = IAOSetting(_aoSettingAddress);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Set AO Dev team addresses to receive Primordial/Network ions during network exchange\r\n\t * @param _aoDevTeam1 The first AO dev team address\r\n\t * @param _aoDevTeam2 The second AO dev team address\r\n\t */\r\n\tfunction setAODevTeamAddresses(address _aoDevTeam1, address _aoDevTeam2) public onlyTheAO {\r\n\t\taoDevTeam1 = _aoDevTeam1;\r\n\t\taoDevTeam2 = _aoDevTeam2;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Set AOETH address\r\n\t * @param _aoethAddress The address of AOETH\r\n\t */\r\n\tfunction setAOETHAddress(address _aoethAddress) public onlyTheAO {\r\n\t\trequire (_aoethAddress != address(0));\r\n\t\taoethAddress = _aoethAddress;\r\n\t\t_aoeth = AOETH(_aoethAddress);\r\n\t}\r\n\r\n\t/***** PRIMORDIAL ION THE AO ONLY METHODS *****/\r\n\t/**\r\n\t * @dev Allow users to buy Primordial ions for `newBuyPrice` eth and sell Primordial ions for `newSellPrice` eth\r\n\t * @param newPrimordialSellPrice Price users can sell to the contract\r\n\t * @param newPrimordialBuyPrice Price users can buy from the contract\r\n\t */\r\n\tfunction setPrimordialPrices(uint256 newPrimordialSellPrice, uint256 newPrimordialBuyPrice) public onlyTheAO {\r\n\t\tprimordialSellPrice = newPrimordialSellPrice;\r\n\t\tprimordialBuyPrice = newPrimordialBuyPrice;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Only the AO can force end network exchange\r\n\t */\r\n\tfunction endNetworkExchange() public onlyTheAO {\r\n\t\trequire (!networkExchangeEnded);\r\n\t\tnetworkExchangeEnded = true;\r\n\t\temit NetworkExchangeEnded();\r\n\t}\r\n\r\n\t/***** PRIMORDIAL ION WHITELISTED ADDRESS ONLY METHODS *****/\r\n\t/**\r\n\t * @dev Stake `_value` Primordial ions at `_weightedMultiplier ` multiplier on behalf of `_from`\r\n\t * @param _from The address of the target\r\n\t * @param _value The amount of Primordial ions to stake\r\n\t * @param _weightedMultiplier The weighted multiplier of the Primordial ions\r\n\t * @return true on success\r\n\t */\r\n\tfunction stakePrimordialFrom(address _from, uint256 _value, uint256 _weightedMultiplier) public inWhitelist returns (bool) {\r\n\t\t// Check if the targeted balance is enough\r\n\t\trequire (primordialBalanceOf[_from] >= _value);\r\n\t\t// Make sure the weighted multiplier is the same as account's current weighted multiplier\r\n\t\trequire (_weightedMultiplier == ownerWeightedMultiplier[_from]);\r\n\t\t// Subtract from the targeted balance\r\n\t\tprimordialBalanceOf[_from] = primordialBalanceOf[_from].sub(_value);\r\n\t\t// Add to the targeted staked balance\r\n\t\tprimordialStakedBalance[_from][_weightedMultiplier] = primordialStakedBalance[_from][_weightedMultiplier].add(_value);\r\n\t\temit PrimordialStake(_from, _value, _weightedMultiplier);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Unstake `_value` Primordial ions at `_weightedMultiplier` on behalf of `_from`\r\n\t * @param _from The address of the target\r\n\t * @param _value The amount to unstake\r\n\t * @param _weightedMultiplier The weighted multiplier of the Primordial ions\r\n\t * @return true on success\r\n\t */\r\n\tfunction unstakePrimordialFrom(address _from, uint256 _value, uint256 _weightedMultiplier) public inWhitelist returns (bool) {\r\n\t\t// Check if the targeted staked balance is enough\r\n\t\trequire (primordialStakedBalance[_from][_weightedMultiplier] >= _value);\r\n\t\t// Subtract from the targeted staked balance\r\n\t\tprimordialStakedBalance[_from][_weightedMultiplier] = primordialStakedBalance[_from][_weightedMultiplier].sub(_value);\r\n\t\t// Add to the targeted balance\r\n\t\tprimordialBalanceOf[_from] = primordialBalanceOf[_from].add(_value);\r\n\t\temit PrimordialUnstake(_from, _value, _weightedMultiplier);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Send `_value` primordial ions to `_to` on behalf of `_from`\r\n\t * @param _from The address of the sender\r\n\t * @param _to The address of the recipient\r\n\t * @param _value The amount to send\r\n\t * @return true on success\r\n\t */\r\n\tfunction whitelistTransferPrimordialFrom(address _from, address _to, uint256 _value) public inWhitelist returns (bool) {\r\n\t\treturn _createLotAndTransferPrimordial(_from, _to, _value);\r\n\t}\r\n\r\n\t/***** PUBLIC METHODS *****/\r\n\t/***** PRIMORDIAL ION PUBLIC METHODS *****/\r\n\t/**\r\n\t * @dev Buy Primordial ions from contract by sending ether\r\n\t */\r\n\tfunction buyPrimordial() public payable canBuyPrimordial(msg.value, true) {\r\n\t\t(uint256 amount, uint256 remainderBudget, bool shouldEndNetworkExchange) = _calculateAmountAndRemainderBudget(msg.value, true);\r\n\t\trequire (amount > 0);\r\n\r\n\t\t// Ends network exchange if necessary\r\n\t\tif (shouldEndNetworkExchange) {\r\n\t\t\tnetworkExchangeEnded = true;\r\n\t\t\temit NetworkExchangeEnded();\r\n\t\t}\r\n\r\n\t\t// Update totalEthForPrimordial\r\n\t\ttotalEthForPrimordial = totalEthForPrimordial.add(msg.value.sub(remainderBudget));\r\n\r\n\t\t// Send the primordial ion to buyer and reward AO devs\r\n\t\tbytes32 _lotId = _sendPrimordialAndRewardDev(amount, msg.sender);\r\n\r\n\t\temit BuyPrimordial(msg.sender, _lotId, 1, msg.value, remainderBudget);\r\n\r\n\t\t// Send remainder budget back to buyer if exist\r\n\t\tif (remainderBudget > 0) {\r\n\t\t\tmsg.sender.transfer(remainderBudget);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Buy Primordial ion from contract by sending AOETH\r\n\t */\r\n\tfunction buyPrimordialWithAOETH(uint256 _aoethAmount) public canBuyPrimordial(_aoethAmount, false) {\r\n\t\t(uint256 amount, uint256 remainderBudget, bool shouldEndNetworkExchange) = _calculateAmountAndRemainderBudget(_aoethAmount, false);\r\n\t\trequire (amount > 0);\r\n\r\n\t\t// Ends network exchange if necessary\r\n\t\tif (shouldEndNetworkExchange) {\r\n\t\t\tnetworkExchangeEnded = true;\r\n\t\t\temit NetworkExchangeEnded();\r\n\t\t}\r\n\r\n\t\t// Calculate the actual AOETH that was charged for this transaction\r\n\t\tuint256 actualCharge = _aoethAmount.sub(remainderBudget);\r\n\r\n\t\t// Update totalRedeemedAOETH\r\n\t\ttotalRedeemedAOETH = totalRedeemedAOETH.add(actualCharge);\r\n\r\n\t\t// Transfer AOETH from buyer to here\r\n\t\trequire (_aoeth.whitelistTransferFrom(msg.sender, address(this), actualCharge));\r\n\r\n\t\t// Send the primordial ion to buyer and reward AO devs\r\n\t\tbytes32 _lotId = _sendPrimordialAndRewardDev(amount, msg.sender);\r\n\r\n\t\temit BuyPrimordial(msg.sender, _lotId, 2, _aoethAmount, remainderBudget);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Send `_value` Primordial ions to `_to` from your account\r\n\t * @param _to The address of the recipient\r\n\t * @param _value The amount to send\r\n\t * @return true on success\r\n\t */\r\n\tfunction transferPrimordial(address _to, uint256 _value) public returns (bool) {\r\n\t\treturn _createLotAndTransferPrimordial(msg.sender, _to, _value);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Send `_value` Primordial ions to `_to` from `_from`\r\n\t * @param _from The address of the sender\r\n\t * @param _to The address of the recipient\r\n\t * @param _value The amount to send\r\n\t * @return true on success\r\n\t */\r\n\tfunction transferPrimordialFrom(address _from, address _to, uint256 _value) public returns (bool) {\r\n\t\trequire (_value <= primordialAllowance[_from][msg.sender]);\r\n\t\tprimordialAllowance[_from][msg.sender] = primordialAllowance[_from][msg.sender].sub(_value);\r\n\r\n\t\treturn _createLotAndTransferPrimordial(_from, _to, _value);\r\n\t}\r\n\r\n\t/**\r\n\t * Transfer primordial ions between public key addresses in a Name\r\n\t * @param _nameId The ID of the Name\r\n\t * @param _from The address of the sender\r\n\t * @param _to The address of the recipient\r\n\t * @param _value the amount to send\r\n\t */\r\n\tfunction transferPrimordialBetweenPublicKeys(address _nameId, address _from, address _to, uint256 _value) public returns (bool) {\r\n\t\trequire (AOLibrary.isName(_nameId));\r\n\t\trequire (_nameTAOPosition.senderIsAdvocate(msg.sender, _nameId));\r\n\t\trequire (!_nameAccountRecovery.isCompromised(_nameId));\r\n\t\t// Make sure _from exist in the Name's Public Keys\r\n\t\trequire (_namePublicKey.isKeyExist(_nameId, _from));\r\n\t\t// Make sure _to exist in the Name's Public Keys\r\n\t\trequire (_namePublicKey.isKeyExist(_nameId, _to));\r\n\t\treturn _createLotAndTransferPrimordial(_from, _to, _value);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Allows `_spender` to spend no more than `_value` Primordial ions in your behalf\r\n\t * @param _spender The address authorized to spend\r\n\t * @param _value The max amount they can spend\r\n\t * @return true on success\r\n\t */\r\n\tfunction approvePrimordial(address _spender, uint256 _value) public returns (bool) {\r\n\t\tprimordialAllowance[msg.sender][_spender] = _value;\r\n\t\temit PrimordialApproval(msg.sender, _spender, _value);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Allows `_spender` to spend no more than `_value` Primordial ions in your behalf, and then ping the contract about it\r\n\t * @param _spender The address authorized to spend\r\n\t * @param _value The max amount they can spend\r\n\t * @param _extraData some extra information to send to the approved contract\r\n\t * @return true on success\r\n\t */\r\n\tfunction approvePrimordialAndCall(address _spender, uint256 _value, bytes memory _extraData) public returns (bool) {\r\n\t\ttokenRecipient spender = tokenRecipient(_spender);\r\n\t\tif (approvePrimordial(_spender, _value)) {\r\n\t\t\tspender.receiveApproval(msg.sender, _value, address(this), _extraData);\r\n\t\t\treturn true;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Remove `_value` Primordial ions from the system irreversibly\r\n\t *\t\tand re-weight the account's multiplier after burn\r\n\t * @param _value The amount to burn\r\n\t * @return true on success\r\n\t */\r\n\tfunction burnPrimordial(uint256 _value) public returns (bool) {\r\n\t\trequire (primordialBalanceOf[msg.sender] >= _value);\r\n\t\trequire (calculateMaximumBurnAmount(msg.sender) >= _value);\r\n\r\n\t\t// Update the account's multiplier\r\n\t\townerWeightedMultiplier[msg.sender] = calculateMultiplierAfterBurn(msg.sender, _value);\r\n\t\tprimordialBalanceOf[msg.sender] = primordialBalanceOf[msg.sender].sub(_value);\r\n\t\tprimordialTotalSupply = primordialTotalSupply.sub(_value);\r\n\r\n\t\t// Store burn lot info\r\n\t\trequire (_aoIonLot.createBurnLot(msg.sender, _value, ownerWeightedMultiplier[msg.sender]));\r\n\t\temit PrimordialBurn(msg.sender, _value);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Remove `_value` Primordial ions from the system irreversibly on behalf of `_from`\r\n\t *\t\tand re-weight `_from`'s multiplier after burn\r\n\t * @param _from The address of sender\r\n\t * @param _value The amount to burn\r\n\t * @return true on success\r\n\t */\r\n\tfunction burnPrimordialFrom(address _from, uint256 _value) public returns (bool) {\r\n\t\trequire (primordialBalanceOf[_from] >= _value);\r\n\t\trequire (primordialAllowance[_from][msg.sender] >= _value);\r\n\t\trequire (calculateMaximumBurnAmount(_from) >= _value);\r\n\r\n\t\t// Update `_from`'s multiplier\r\n\t\townerWeightedMultiplier[_from] = calculateMultiplierAfterBurn(_from, _value);\r\n\t\tprimordialBalanceOf[_from] = primordialBalanceOf[_from].sub(_value);\r\n\t\tprimordialAllowance[_from][msg.sender] = primordialAllowance[_from][msg.sender].sub(_value);\r\n\t\tprimordialTotalSupply = primordialTotalSupply.sub(_value);\r\n\r\n\t\t// Store burn lot info\r\n\t\trequire (_aoIonLot.createBurnLot(_from, _value, ownerWeightedMultiplier[_from]));\r\n\t\temit PrimordialBurn(_from, _value);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Return the average weighted multiplier of all lots owned by an address\r\n\t * @param _lotOwner The address of the lot owner\r\n\t * @return the weighted multiplier of the address (in 10 ** 6)\r\n\t */\r\n\tfunction weightedMultiplierByAddress(address _lotOwner) public view returns (uint256) {\r\n\t\treturn ownerWeightedMultiplier[_lotOwner];\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Return the max multiplier of an address\r\n\t * @param _target The address to query\r\n\t * @return the max multiplier of the address (in 10 ** 6)\r\n\t */\r\n\tfunction maxMultiplierByAddress(address _target) public view returns (uint256) {\r\n\t\treturn (_aoIonLot.totalLotsByAddress(_target) > 0) ? ownerMaxMultiplier[_target] : 0;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Calculate the primordial ion multiplier, bonus network ion percentage, and the\r\n\t *\t\tbonus network ion amount on a given lot when someone purchases primordial ion\r\n\t *\t\tduring network exchange\r\n\t * @param _purchaseAmount The amount of primordial ion intended to be purchased\r\n\t * @return The multiplier in (10 ** 6)\r\n\t * @return The bonus percentage\r\n\t * @return The amount of network ion as bonus\r\n\t */\r\n\tfunction calculateMultiplierAndBonus(uint256 _purchaseAmount) public view returns (uint256, uint256, uint256) {\r\n\t\t(uint256 startingPrimordialMultiplier, uint256 endingPrimordialMultiplier, uint256 startingNetworkBonusMultiplier, uint256 endingNetworkBonusMultiplier) = _getSettingVariables();\r\n\t\treturn (\r\n\t\t\tAOLibrary.calculatePrimordialMultiplier(_purchaseAmount, TOTAL_PRIMORDIAL_FOR_SALE, primordialTotalBought, startingPrimordialMultiplier, endingPrimordialMultiplier),\r\n\t\t\tAOLibrary.calculateNetworkBonusPercentage(_purchaseAmount, TOTAL_PRIMORDIAL_FOR_SALE, primordialTotalBought, startingNetworkBonusMultiplier, endingNetworkBonusMultiplier),\r\n\t\t\tAOLibrary.calculateNetworkBonusAmount(_purchaseAmount, TOTAL_PRIMORDIAL_FOR_SALE, primordialTotalBought, startingNetworkBonusMultiplier, endingNetworkBonusMultiplier)\r\n\t\t);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Calculate the maximum amount of Primordial an account can burn\r\n\t * @param _account The address of the account\r\n\t * @return The maximum primordial ion amount to burn\r\n\t */\r\n\tfunction calculateMaximumBurnAmount(address _account) public view returns (uint256) {\r\n\t\treturn AOLibrary.calculateMaximumBurnAmount(primordialBalanceOf[_account], ownerWeightedMultiplier[_account], ownerMaxMultiplier[_account]);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Calculate account's new multiplier after burn `_amountToBurn` primordial ions\r\n\t * @param _account The address of the account\r\n\t * @param _amountToBurn The amount of primordial ion to burn\r\n\t * @return The new multiplier in (10 ** 6)\r\n\t */\r\n\tfunction calculateMultiplierAfterBurn(address _account, uint256 _amountToBurn) public view returns (uint256) {\r\n\t\trequire (calculateMaximumBurnAmount(_account) >= _amountToBurn);\r\n\t\treturn AOLibrary.calculateMultiplierAfterBurn(primordialBalanceOf[_account], ownerWeightedMultiplier[_account], _amountToBurn);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Calculate account's new multiplier after converting `amountToConvert` network ion to primordial ion\r\n\t * @param _account The address of the account\r\n\t * @param _amountToConvert The amount of network ion to convert\r\n\t * @return The new multiplier in (10 ** 6)\r\n\t */\r\n\tfunction calculateMultiplierAfterConversion(address _account, uint256 _amountToConvert) public view returns (uint256) {\r\n\t\treturn AOLibrary.calculateMultiplierAfterConversion(primordialBalanceOf[_account], ownerWeightedMultiplier[_account], _amountToConvert);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Convert `_value` of network ions to primordial ions\r\n\t *\t\tand re-weight the account's multiplier after conversion\r\n\t * @param _value The amount to convert\r\n\t * @return true on success\r\n\t */\r\n\tfunction convertToPrimordial(uint256 _value) public returns (bool) {\r\n\t\trequire (balanceOf[msg.sender] >= _value);\r\n\r\n\t\t// Update the account's multiplier\r\n\t\townerWeightedMultiplier[msg.sender] = calculateMultiplierAfterConversion(msg.sender, _value);\r\n\t\t// Burn network ion\r\n\t\tburn(_value);\r\n\t\t// mint primordial ion\r\n\t\t_mintPrimordial(msg.sender, _value);\r\n\r\n\t\trequire (_aoIonLot.createConvertLot(msg.sender, _value, ownerWeightedMultiplier[msg.sender]));\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Get quantity of AO+ left in Network Exchange\r\n\t * @return The quantity of AO+ left in Network Exchange\r\n\t */\r\n\tfunction availablePrimordialForSale() public view returns (uint256) {\r\n\t\treturn TOTAL_PRIMORDIAL_FOR_SALE.sub(primordialTotalBought);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Get quantity of AO+ in ETH left in Network Exchange (i.e How much ETH is there total that can be\r\n\t *\t\texchanged for AO+\r\n\t * @return The quantity of AO+ in ETH left in Network Exchange\r\n\t */\r\n\tfunction availablePrimordialForSaleInETH() public view returns (uint256) {\r\n\t\treturn availablePrimordialForSale().mul(primordialBuyPrice);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Get maximum quantity of AOETH or ETH that can still be sold\r\n\t * @return The maximum quantity of AOETH or ETH that can still be sold\r\n\t */\r\n\tfunction availableETH() public view returns (uint256) {\r\n\t\tif (availablePrimordialForSaleInETH() > 0) {\r\n\t\t\tuint256 _availableETH = availablePrimordialForSaleInETH().sub(_aoeth.totalSupply().sub(totalRedeemedAOETH));\r\n\t\t\tif (availablePrimordialForSale() == 1 && _availableETH < primordialBuyPrice) {\r\n\t\t\t\treturn primordialBuyPrice;\r\n\t\t\t} else {\r\n\t\t\t\treturn _availableETH;\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\treturn 0;\r\n\t\t}\r\n\t}\r\n\r\n\t/***** INTERNAL METHODS *****/\r\n\t/***** PRIMORDIAL ION INTERNAL METHODS *****/\r\n\t/**\r\n\t * @dev Calculate the amount of ion the buyer will receive and remaining budget if exist\r\n\t *\t\twhen he/she buys primordial ion\r\n\t * @param _budget The amount of ETH sent by buyer\r\n\t * @param _withETH Whether or not buyer is paying with ETH\r\n\t * @return uint256 of the amount the buyer will receiver\r\n\t * @return uint256 of the remaining budget, if exist\r\n\t * @return bool whether or not the network exchange should end\r\n\t */\r\n\tfunction _calculateAmountAndRemainderBudget(uint256 _budget, bool _withETH) internal view returns (uint256, uint256, bool) {\r\n\t\t// Calculate the amount of ion\r\n\t\tuint256 amount = _budget.div(primordialBuyPrice);\r\n\r\n\t\t// If we need to return ETH to the buyer, in the case\r\n\t\t// where the buyer sends more ETH than available primordial ion to be purchased\r\n\t\tuint256 remainderEth = _budget.sub(amount.mul(primordialBuyPrice));\r\n\r\n\t\tuint256 _availableETH = availableETH();\r\n\t\t// If paying with ETH, it can't exceed availableETH\r\n\t\tif (_withETH && _budget > availableETH()) {\r\n\t\t\t// Calculate the amount of ions\r\n\t\t\tamount = _availableETH.div(primordialBuyPrice);\r\n\t\t\tremainderEth = _budget.sub(amount.mul(primordialBuyPrice));\r\n\t\t}\r\n\r\n\t\t// Make sure primordialTotalBought is not overflowing\r\n\t\tbool shouldEndNetworkExchange = false;\r\n\t\tif (primordialTotalBought.add(amount) >= TOTAL_PRIMORDIAL_FOR_SALE) {\r\n\t\t\tamount = TOTAL_PRIMORDIAL_FOR_SALE.sub(primordialTotalBought);\r\n\t\t\tshouldEndNetworkExchange = true;\r\n\t\t\tremainderEth = _budget.sub(amount.mul(primordialBuyPrice));\r\n\t\t}\r\n\t\treturn (amount, remainderEth, shouldEndNetworkExchange);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Actually sending the primordial ion to buyer and reward AO devs accordingly\r\n\t * @param amount The amount of primordial ion to be sent to buyer\r\n\t * @param to The recipient of ion\r\n\t * @return the lot Id of the buyer\r\n\t */\r\n\tfunction _sendPrimordialAndRewardDev(uint256 amount, address to) internal returns (bytes32) {\r\n\t\t(uint256 startingPrimordialMultiplier,, uint256 startingNetworkBonusMultiplier, uint256 endingNetworkBonusMultiplier) = _getSettingVariables();\r\n\r\n\t\t// Update primordialTotalBought\r\n\t\t(uint256 multiplier, uint256 networkBonusPercentage, uint256 networkBonusAmount) = calculateMultiplierAndBonus(amount);\r\n\t\tprimordialTotalBought = primordialTotalBought.add(amount);\r\n\t\tbytes32 _lotId = _createPrimordialLot(to, amount, multiplier, networkBonusAmount);\r\n\r\n\t\t// Calculate The AO and AO Dev Team's portion of Primordial and Network ion Bonus\r\n\t\tuint256 inverseMultiplier = startingPrimordialMultiplier.sub(multiplier); // Inverse of the buyer's multiplier\r\n\t\tuint256 theAONetworkBonusAmount = (startingNetworkBonusMultiplier.sub(networkBonusPercentage).add(endingNetworkBonusMultiplier)).mul(amount).div(AOLibrary.PERCENTAGE_DIVISOR());\r\n\t\tif (aoDevTeam1 != address(0)) {\r\n\t\t\t_createPrimordialLot(aoDevTeam1, amount.div(2), inverseMultiplier, theAONetworkBonusAmount.div(2));\r\n\t\t}\r\n\t\tif (aoDevTeam2 != address(0)) {\r\n\t\t\t_createPrimordialLot(aoDevTeam2, amount.div(2), inverseMultiplier, theAONetworkBonusAmount.div(2));\r\n\t\t}\r\n\t\t_mint(theAO, theAONetworkBonusAmount);\r\n\t\treturn _lotId;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Create a lot with `primordialAmount` of primordial ions with `_multiplier` for an `account`\r\n\t *\t\tduring network exchange, and reward `_networkBonusAmount` if exist\r\n\t * @param _account Address of the lot owner\r\n\t * @param _primordialAmount The amount of primordial ions to be stored in the lot\r\n\t * @param _multiplier The multiplier for this lot in (10 ** 6)\r\n\t * @param _networkBonusAmount The network ion bonus amount\r\n\t * @return Created lot Id\r\n\t */\r\n\tfunction _createPrimordialLot(address _account, uint256 _primordialAmount, uint256 _multiplier, uint256 _networkBonusAmount) internal returns (bytes32) {\r\n\t\tbytes32 lotId = _aoIonLot.createPrimordialLot(_account, _primordialAmount, _multiplier, _networkBonusAmount);\r\n\r\n\t\townerWeightedMultiplier[_account] = AOLibrary.calculateWeightedMultiplier(ownerWeightedMultiplier[_account], primordialBalanceOf[_account], _multiplier, _primordialAmount);\r\n\r\n\t\t// If this is the first lot, set this as the max multiplier of the account\r\n\t\tif (_aoIonLot.totalLotsByAddress(_account) == 1) {\r\n\t\t\townerMaxMultiplier[_account] = _multiplier;\r\n\t\t}\r\n\t\t_mintPrimordial(_account, _primordialAmount);\r\n\t\t_mint(_account, _networkBonusAmount);\r\n\r\n\t\treturn lotId;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Create `mintedAmount` Primordial ions and send it to `target`\r\n\t * @param target Address to receive the Primordial ions\r\n\t * @param mintedAmount The amount of Primordial ions it will receive\r\n\t */\r\n\tfunction _mintPrimordial(address target, uint256 mintedAmount) internal {\r\n\t\tprimordialBalanceOf[target] = primordialBalanceOf[target].add(mintedAmount);\r\n\t\tprimordialTotalSupply = primordialTotalSupply.add(mintedAmount);\r\n\t\temit PrimordialTransfer(address(0), address(this), mintedAmount);\r\n\t\temit PrimordialTransfer(address(this), target, mintedAmount);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Create a lot with `amount` of ions at `weightedMultiplier` for an `account`\r\n\t * @param _account Address of lot owner\r\n\t * @param _amount The amount of ions\r\n\t * @param _weightedMultiplier The multiplier of the lot (in 10^6)\r\n\t * @return bytes32 of new created lot ID\r\n\t */\r\n\tfunction _createWeightedMultiplierLot(address _account, uint256 _amount, uint256 _weightedMultiplier) internal returns (bytes32) {\r\n\t\trequire (_account != address(0));\r\n\t\trequire (_amount > 0);\r\n\r\n\t\tbytes32 lotId = _aoIonLot.createWeightedMultiplierLot(_account, _amount, _weightedMultiplier);\r\n\t\t// If this is the first lot, set this as the max multiplier of the account\r\n\t\tif (_aoIonLot.totalLotsByAddress(_account) == 1) {\r\n\t\t\townerMaxMultiplier[_account] = _weightedMultiplier;\r\n\t\t}\r\n\t\treturn lotId;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Create Lot and send `_value` Primordial ions from `_from` to `_to`\r\n\t * @param _from The address of sender\r\n\t * @param _to The address of the recipient\r\n\t * @param _value The amount to send\r\n\t * @return true on success\r\n\t */\r\n\tfunction _createLotAndTransferPrimordial(address _from, address _to, uint256 _value) internal returns (bool) {\r\n\t\tbytes32 _createdLotId = _createWeightedMultiplierLot(_to, _value, ownerWeightedMultiplier[_from]);\r\n\t\t(, address _lotOwner,,) = _aoIonLot.lotById(_createdLotId);\r\n\r\n\t\t// Make sure the new lot is created successfully\r\n\t\trequire (_lotOwner == _to);\r\n\r\n\t\t// Update the weighted multiplier of the recipient\r\n\t\townerWeightedMultiplier[_to] = AOLibrary.calculateWeightedMultiplier(ownerWeightedMultiplier[_to], primordialBalanceOf[_to], ownerWeightedMultiplier[_from], _value);\r\n\r\n\t\t// Transfer the Primordial ions\r\n\t\trequire (_transferPrimordial(_from, _to, _value));\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Send `_value` Primordial ions from `_from` to `_to`\r\n\t * @param _from The address of sender\r\n\t * @param _to The address of the recipient\r\n\t * @param _value The amount to send\r\n\t */\r\n\tfunction _transferPrimordial(address _from, address _to, uint256 _value) internal returns (bool) {\r\n\t\trequire (_to != address(0));\t\t\t\t\t\t\t\t\t// Prevent transfer to 0x0 address. Use burn() instead\r\n\t\trequire (primordialBalanceOf[_from] >= _value);\t\t\t\t\t\t// Check if the sender has enough\r\n\t\trequire (primordialBalanceOf[_to].add(_value) >= primordialBalanceOf[_to]);\t// Check for overflows\r\n\t\trequire (!frozenAccount[_from]);\t\t\t\t\t\t\t\t// Check if sender is frozen\r\n\t\trequire (!frozenAccount[_to]);\t\t\t\t\t\t\t\t\t// Check if recipient is frozen\r\n\t\tuint256 previousBalances = primordialBalanceOf[_from].add(primordialBalanceOf[_to]);\r\n\t\tprimordialBalanceOf[_from] = primordialBalanceOf[_from].sub(_value);\t\t\t// Subtract from the sender\r\n\t\tprimordialBalanceOf[_to] = primordialBalanceOf[_to].add(_value);\t\t\t\t// Add the same to the recipient\r\n\t\temit PrimordialTransfer(_from, _to, _value);\r\n\t\tassert(primordialBalanceOf[_from].add(primordialBalanceOf[_to]) == previousBalances);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Get setting variables\r\n\t * @return startingPrimordialMultiplier The starting multiplier used to calculate primordial ion\r\n\t * @return endingPrimordialMultiplier The ending multiplier used to calculate primordial ion\r\n\t * @return startingNetworkBonusMultiplier The starting multiplier used to calculate network ion bonus\r\n\t * @return endingNetworkBonusMultiplier The ending multiplier used to calculate network ion bonus\r\n\t */\r\n\tfunction _getSettingVariables() internal view returns (uint256, uint256, uint256, uint256) {\r\n\t\t(uint256 startingPrimordialMultiplier,,,,) = _aoSetting.getSettingValuesByTAOName(settingTAOId, 'startingPrimordialMultiplier');\r\n\t\t(uint256 endingPrimordialMultiplier,,,,) = _aoSetting.getSettingValuesByTAOName(settingTAOId, 'endingPrimordialMultiplier');\r\n\r\n\t\t(uint256 startingNetworkBonusMultiplier,,,,) = _aoSetting.getSettingValuesByTAOName(settingTAOId, 'startingNetworkBonusMultiplier');\r\n\t\t(uint256 endingNetworkBonusMultiplier,,,,) = _aoSetting.getSettingValuesByTAOName(settingTAOId, 'endingNetworkBonusMultiplier');\r\n\r\n\t\treturn (startingPrimordialMultiplier, endingPrimordialMultiplier, startingNetworkBonusMultiplier, endingNetworkBonusMultiplier);\r\n\t}\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract Pathos is TAOCurrency {\r\n\t/**\r\n\t * @dev Constructor function\r\n\t */\r\n\tconstructor(string memory _name, string memory _symbol, address _nameTAOPositionAddress)\r\n\t\tTAOCurrency(_name, _symbol, _nameTAOPositionAddress) public {}\r\n}\r\n\r\n\r\n\r\n\r\n\r\ncontract Ethos is TAOCurrency {\r\n\t/**\r\n\t * @dev Constructor function\r\n\t */\r\n\tconstructor(string memory _name, string memory _symbol, address _nameTAOPositionAddress)\r\n\t\tTAOCurrency(_name, _symbol, _nameTAOPositionAddress) public {}\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title AOEarning\r\n *\r\n * This contract stores the earning from staking/hosting content on AO\r\n */\r\ncontract AOEarning is TheAO, IAOEarning {\r\n\tusing SafeMath for uint256;\r\n\r\n\taddress public settingTAOId;\r\n\taddress public aoSettingAddress;\r\n\taddress public aoIonAddress;\r\n\taddress public nameFactoryAddress;\r\n\taddress public pathosAddress;\r\n\taddress public ethosAddress;\r\n\taddress public aoContentAddress;\r\n\taddress public aoStakedContentAddress;\r\n\taddress public aoContentHostAddress;\r\n\taddress public aoPurchaseReceiptAddress;\r\n\taddress public namePublicKeyAddress;\r\n\r\n\tIAOSetting internal _aoSetting;\r\n\tAOIon internal _aoIon;\r\n\tINameFactory internal _nameFactory;\r\n\tPathos internal _pathos;\r\n\tEthos internal _ethos;\r\n\tIAOContent internal _aoContent;\r\n\tIAOStakedContent internal _aoStakedContent;\r\n\tIAOContentHost internal _aoContentHost;\r\n\tIAOPurchaseReceipt internal _aoPurchaseReceipt;\r\n\tINamePublicKey internal _namePublicKey;\r\n\r\n\t// Total earning from staking content from all nodes\r\n\tuint256 public totalStakedContentEarning;\r\n\r\n\t// Total earning from hosting content from all nodes\r\n\tuint256 public totalContentHostEarning;\r\n\r\n\t// Total The AO earning\r\n\tuint256 public totalTheAOEarning;\r\n\r\n\t// Mapping from PurchaseReceipt ID to its escrowed earning status\r\n\tmapping (bytes32 => bool) internal purchaseReceiptEarningEscrowed;\r\n\r\n\t// Mapping from PurchaseReceipt ID to its unescrowed earning status\r\n\tmapping (bytes32 => bool) internal purchaseReceiptEarningUnescrowed;\r\n\r\n\t// Mapping from address to his/her earning from content that he/she staked\r\n\tmapping (address => uint256) public ownerStakedContentEarning;\r\n\r\n\t// Mapping from address to his/her earning from content that he/she hosted\r\n\tmapping (address => uint256) public ownerContentHostEarning;\r\n\r\n\t// Mapping from address to his/her network price earning\r\n\t// i.e, when staked amount = filesize\r\n\tmapping (address => uint256) public ownerNetworkPriceEarning;\r\n\r\n\t// Mapping from address to his/her content price earning\r\n\t// i.e, when staked amount > filesize\r\n\tmapping (address => uint256) public ownerContentPriceEarning;\r\n\r\n\t// Mapping from address to his/her inflation bonus\r\n\tmapping (address => uint256) public ownerInflationBonusAccrued;\r\n\r\n\tstruct Earning {\r\n\t\tbytes32 purchaseReceiptId;\r\n\t\tuint256 paymentEarning;\r\n\t\tuint256 inflationBonus;\r\n\t\tuint256 pathosAmount;\r\n\t\tuint256 ethosAmount;\r\n\t}\r\n\r\n\t// Mapping from address to earning from staking content of a PurchaseReceipt ID\r\n\tmapping (address => mapping(bytes32 => Earning)) public ownerPurchaseReceiptStakeEarnings;\r\n\r\n\t// Mapping from address to earning from hosting content of a PurchaseReceipt ID\r\n\tmapping (address => mapping(bytes32 => Earning)) public ownerPurchaseReceiptHostEarnings;\r\n\r\n\t// Mapping from PurchaaseReceipt ID to earning for The AO\r\n\tmapping (bytes32 => Earning) public theAOPurchaseReceiptEarnings;\r\n\r\n\t// Mapping from StakedContent ID to it's total earning from staking\r\n\tmapping (bytes32 => uint256) public stakedContentStakeEarning;\r\n\r\n\t// Mapping from StakedContent ID to it's total earning from hosting\r\n\tmapping (bytes32 => uint256) public stakedContentHostEarning;\r\n\r\n\t// Mapping from StakedContent ID to it's total earning earned by The AO\r\n\tmapping (bytes32 => uint256) public stakedContentTheAOEarning;\r\n\r\n\t// Mapping from content host ID to it's total earning\r\n\tmapping (bytes32 => uint256) public contentHostEarning;\r\n\r\n\t// Event to be broadcasted to public when content creator/host earns the payment split in escrow when request node buys the content\r\n\t// recipientType:\r\n\t// 0 => Content Creator (Stake Owner)\r\n\t// 1 => Node Host\r\n\t// 2 => The AO\r\n\tevent PaymentEarningEscrowed(address indexed recipient, bytes32 indexed purchaseReceiptId, uint256 price, uint256 recipientProfitPercentage, uint256 recipientPaymentEarning, uint8 recipientType);\r\n\r\n\t// Event to be broadcasted to public when content creator/host/The AO earns inflation bonus in escrow when request node buys the content\r\n\t// recipientType:\r\n\t// 0 => Content Creator (Stake Owner)\r\n\t// 1 => Node Host\r\n\t// 2 => The AO\r\n\tevent InflationBonusEscrowed(address indexed recipient, bytes32 indexed purchaseReceiptId, uint256 totalInflationBonusAmount, uint256 recipientProfitPercentage, uint256 recipientInflationBonus, uint8 recipientType);\r\n\r\n\t// Event to be broadcasted to public when content creator/host/The AO earning is released from escrow\r\n\t// recipientType:\r\n\t// 0 => Content Creator (Stake Owner)\r\n\t// 1 => Node Host\r\n\t// 2 => The AO\r\n\tevent EarningUnescrowed(address indexed recipient, bytes32 indexed purchaseReceiptId, uint256 paymentEarning, uint256 inflationBonus, uint8 recipientType);\r\n\r\n\t// Event to be broadcasted to public when content creator's Name earns Pathos when a node buys a content\r\n\tevent PathosEarned(address indexed nameId, bytes32 indexed purchaseReceiptId, uint256 amount);\r\n\r\n\t// Event to be broadcasted to public when host's Name earns Ethos when a node buys a content\r\n\tevent EthosEarned(address indexed nameId, bytes32 indexed purchaseReceiptId, uint256 amount);\r\n\r\n\t/**\r\n\t * @dev Constructor function\r\n\t * @param _settingTAOId The TAO ID that controls the setting\r\n\t * @param _aoSettingAddress The address of AOSetting\r\n\t * @param _aoIonAddress The address of AOIon\r\n\t * @param _nameFactoryAddress The address of NameFactory\r\n\t * @param _pathosAddress The address of Pathos\r\n\t * @param _ethosAddress The address of Ethos\r\n\t * @param _namePublicKeyAddress The address of NamePublicKey\r\n\t * @param _nameTAOPositionAddress The address of NameTAOPosition\r\n\t */\r\n\tconstructor(address _settingTAOId,\r\n\t\taddress _aoSettingAddress,\r\n\t\taddress _aoIonAddress,\r\n\t\taddress _nameFactoryAddress,\r\n\t\taddress _pathosAddress,\r\n\t\taddress _ethosAddress,\r\n\t\taddress _aoContentAddress,\r\n\t\taddress _namePublicKeyAddress,\r\n\t\taddress _nameTAOPositionAddress) public {\r\n\t\tsetSettingTAOId(_settingTAOId);\r\n\t\tsetAOSettingAddress(_aoSettingAddress);\r\n\t\tsetAOIonAddress(_aoIonAddress);\r\n\t\tsetNameFactoryAddress(_nameFactoryAddress);\r\n\t\tsetPathosAddress(_pathosAddress);\r\n\t\tsetEthosAddress(_ethosAddress);\r\n\t\tsetAOContentAddress(_aoContentAddress);\r\n\t\tsetNamePublicKeyAddress(_namePublicKeyAddress);\r\n\t\tsetNameTAOPositionAddress(_nameTAOPositionAddress);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Checks if the calling contract address is The AO\r\n\t *\t\tOR\r\n\t *\t\tIf The AO is set to a Name/TAO, then check if calling address is the Advocate\r\n\t */\r\n\tmodifier onlyTheAO {\r\n\t\trequire (AOLibrary.isTheAO(msg.sender, theAO, nameTAOPositionAddress));\r\n\t\t_;\r\n\t}\r\n\r\n\t/***** The AO ONLY METHODS *****/\r\n\t/**\r\n\t * @dev Transfer ownership of The AO to new address\r\n\t * @param _theAO The new address to be transferred\r\n\t */\r\n\tfunction transferOwnership(address _theAO) public onlyTheAO {\r\n\t\trequire (_theAO != address(0));\r\n\t\ttheAO = _theAO;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Whitelist `_account` address to transact on behalf of others\r\n\t * @param _account The address to whitelist\r\n\t * @param _whitelist Either to whitelist or not\r\n\t */\r\n\tfunction setWhitelist(address _account, bool _whitelist) public onlyTheAO {\r\n\t\trequire (_account != address(0));\r\n\t\twhitelist[_account] = _whitelist;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev The AO sets setting TAO ID\r\n\t * @param _settingTAOId The new setting TAO ID to set\r\n\t */\r\n\tfunction setSettingTAOId(address _settingTAOId) public onlyTheAO {\r\n\t\trequire (AOLibrary.isTAO(_settingTAOId));\r\n\t\tsettingTAOId = _settingTAOId;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev The AO sets AO Setting address\r\n\t * @param _aoSettingAddress The address of AOSetting\r\n\t */\r\n\tfunction setAOSettingAddress(address _aoSettingAddress) public onlyTheAO {\r\n\t\trequire (_aoSettingAddress != address(0));\r\n\t\taoSettingAddress = _aoSettingAddress;\r\n\t\t_aoSetting = IAOSetting(_aoSettingAddress);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev The AO sets AOIon address\r\n\t * @param _aoIonAddress The address of AOIon\r\n\t */\r\n\tfunction setAOIonAddress(address _aoIonAddress) public onlyTheAO {\r\n\t\trequire (_aoIonAddress != address(0));\r\n\t\taoIonAddress = _aoIonAddress;\r\n\t\t_aoIon = AOIon(_aoIonAddress);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev The AO sets NameFactory address\r\n\t * @param _nameFactoryAddress The address of NameFactory\r\n\t */\r\n\tfunction setNameFactoryAddress(address _nameFactoryAddress) public onlyTheAO {\r\n\t\trequire (_nameFactoryAddress != address(0));\r\n\t\tnameFactoryAddress = _nameFactoryAddress;\r\n\t\t_nameFactory = INameFactory(_nameFactoryAddress);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev The AO sets Pathos address\r\n\t * @param _pathosAddress The address of Pathos\r\n\t */\r\n\tfunction setPathosAddress(address _pathosAddress) public onlyTheAO {\r\n\t\trequire (_pathosAddress != address(0));\r\n\t\tpathosAddress = _pathosAddress;\r\n\t\t_pathos = Pathos(_pathosAddress);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev The AO sets Ethos address\r\n\t * @param _ethosAddress The address of Ethos\r\n\t */\r\n\tfunction setEthosAddress(address _ethosAddress) public onlyTheAO {\r\n\t\trequire (_ethosAddress != address(0));\r\n\t\tethosAddress = _ethosAddress;\r\n\t\t_ethos = Ethos(_ethosAddress);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev The AO sets AOContent address\r\n\t * @param _aoContentAddress The address of AOContent\r\n\t */\r\n\tfunction setAOContentAddress(address _aoContentAddress) public onlyTheAO {\r\n\t\trequire (_aoContentAddress != address(0));\r\n\t\taoContentAddress = _aoContentAddress;\r\n\t\t_aoContent = IAOContent(_aoContentAddress);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev The AO sets AOStakedContent address\r\n\t * @param _aoStakedContentAddress The address of AOStakedContent\r\n\t */\r\n\tfunction setAOStakedContentAddress(address _aoStakedContentAddress) public onlyTheAO {\r\n\t\trequire (_aoStakedContentAddress != address(0));\r\n\t\taoStakedContentAddress = _aoStakedContentAddress;\r\n\t\t_aoStakedContent = IAOStakedContent(_aoStakedContentAddress);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev The AO sets AOContentHost address\r\n\t * @param _aoContentHostAddress The address of AOContentHost\r\n\t */\r\n\tfunction setAOContentHostAddress(address _aoContentHostAddress) public onlyTheAO {\r\n\t\trequire (_aoContentHostAddress != address(0));\r\n\t\taoContentHostAddress = _aoContentHostAddress;\r\n\t\t_aoContentHost = IAOContentHost(_aoContentHostAddress);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev The AO sets AOPurchaseReceipt address\r\n\t * @param _aoPurchaseReceiptAddress The address of AOPurchaseReceipt\r\n\t */\r\n\tfunction setAOPurchaseReceiptAddress(address _aoPurchaseReceiptAddress) public onlyTheAO {\r\n\t\trequire (_aoPurchaseReceiptAddress != address(0));\r\n\t\taoPurchaseReceiptAddress = _aoPurchaseReceiptAddress;\r\n\t\t_aoPurchaseReceipt = IAOPurchaseReceipt(_aoPurchaseReceiptAddress);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev The AO sets NamePublicKey address\r\n\t * @param _namePublicKeyAddress The address of NamePublicKey\r\n\t */\r\n\tfunction setNamePublicKeyAddress(address _namePublicKeyAddress) public onlyTheAO {\r\n\t\trequire (_namePublicKeyAddress != address(0));\r\n\t\tnamePublicKeyAddress = _namePublicKeyAddress;\r\n\t\t_namePublicKey = INamePublicKey(_namePublicKeyAddress);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev The AO set the NameTAOPosition Address\r\n\t * @param _nameTAOPositionAddress The address of NameTAOPosition\r\n\t */\r\n\tfunction setNameTAOPositionAddress(address _nameTAOPositionAddress) public onlyTheAO {\r\n\t\trequire (_nameTAOPositionAddress != address(0));\r\n\t\tnameTAOPositionAddress = _nameTAOPositionAddress;\r\n\t}\r\n\r\n\t/***** PUBLIC METHODS *****/\r\n\t/**\r\n\t * @dev Calculate the content creator/host/The AO earning when request node buys the content.\r\n\t *\t\tAlso at this stage, all of the earnings are stored in escrow\r\n\t * @param _purchaseReceiptId The ID of the purchase receipt object\r\n\t * @return true on success\r\n\t */\r\n\tfunction calculateEarning(bytes32 _purchaseReceiptId) external inWhitelist returns (bool) {\r\n\t\trequire (_aoPurchaseReceipt.isExist(_purchaseReceiptId));\r\n\t\trequire (!purchaseReceiptEarningEscrowed[_purchaseReceiptId]);\r\n\t\tpurchaseReceiptEarningEscrowed[_purchaseReceiptId] = true;\r\n\r\n\t\t// Split the payment earning between content creator and host and store them in escrow\r\n\t\t_escrowPaymentEarning(_purchaseReceiptId);\r\n\r\n\t\t// Calculate the inflation bonus earning for content creator/node/The AO in escrow\r\n\t\t_escrowInflationBonus(_purchaseReceiptId);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Release the payment earning and inflation bonus that is in escrow for specific PurchaseReceipt ID\r\n\t * @param _purchaseReceiptId The purchase receipt ID to check\r\n\t * @return true on success\r\n\t */\r\n\tfunction releaseEarning(bytes32 _purchaseReceiptId) external inWhitelist returns (bool) {\r\n\t\trequire (_aoPurchaseReceipt.isExist(_purchaseReceiptId));\r\n\t\trequire (purchaseReceiptEarningEscrowed[_purchaseReceiptId] && !purchaseReceiptEarningUnescrowed[_purchaseReceiptId]);\r\n\t\tpurchaseReceiptEarningUnescrowed[_purchaseReceiptId] = true;\r\n\r\n\t\t(bytes32 _contentHostId, bytes32 _stakedContentId, bytes32 _contentId,,, uint256 _amountPaidByBuyer,,,,) = _aoPurchaseReceipt.getById(_purchaseReceiptId);\r\n\t\t(, address _stakeOwner,,,,,,) = _aoStakedContent.getById(_stakedContentId);\r\n\t\t(,, address _host,,) = _aoContentHost.getById(_contentHostId);\r\n\t\t(, uint256 _fileSize,,,,,,,) = _aoContent.getById(_contentId);\r\n\r\n\t\t// Release the earning in escrow for stake owner\r\n\t\t_releaseEarning(_stakedContentId, _contentHostId, _purchaseReceiptId, _amountPaidByBuyer > _fileSize, _stakeOwner, 0);\r\n\r\n\t\t// Release the earning in escrow for host\r\n\t\t_releaseEarning(_stakedContentId, _contentHostId, _purchaseReceiptId, _amountPaidByBuyer > _fileSize, _host, 1);\r\n\r\n\t\t// Release the earning in escrow for The AO\r\n\t\t_releaseEarning(_stakedContentId, _contentHostId, _purchaseReceiptId, _amountPaidByBuyer > _fileSize, theAO, 2);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Return the earning information of a StakedContent ID\r\n\t * @param _stakedContentId The ID of the staked content\r\n\t * @return the total earning from staking this content\r\n\t * @return the total earning from hosting this content\r\n\t * @return the total The AO earning of this content\r\n\t */\r\n\tfunction getTotalStakedContentEarning(bytes32 _stakedContentId) external view returns (uint256, uint256, uint256) {\r\n\t\treturn (\r\n\t\t\tstakedContentStakeEarning[_stakedContentId],\r\n\t\t\tstakedContentHostEarning[_stakedContentId],\r\n\t\t\tstakedContentTheAOEarning[_stakedContentId]\r\n\t\t);\r\n\t}\r\n\r\n\t/***** INTERNAL METHODS *****/\r\n\t/**\r\n\t * @dev Calculate the payment split for content creator/host and store them in escrow\r\n\t * @param _purchaseReceiptId The ID of the purchase receipt object\r\n\t */\r\n\tfunction _escrowPaymentEarning(bytes32 _purchaseReceiptId) internal {\r\n\t\t(uint256 _stakeOwnerEarning, uint256 _pathosAmount) = _escrowStakeOwnerPaymentEarning(_purchaseReceiptId);\r\n\t\t(uint256 _ethosAmount) = _escrowHostPaymentEarning(_purchaseReceiptId, _stakeOwnerEarning);\r\n\t\t_escrowTheAOPaymentEarning(_purchaseReceiptId, _pathosAmount, _ethosAmount);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Calculate the payment split for content creator and store them in escrow\r\n\t * @param _purchaseReceiptId The ID of the purchase receipt object\r\n\t * @return The stake owner's earning amount\r\n\t * @return The pathos earned from this transaction\r\n\t */\r\n\tfunction _escrowStakeOwnerPaymentEarning(bytes32 _purchaseReceiptId) internal returns (uint256, uint256) {\r\n\t\t(uint256 inflationRate,,) = _getSettingVariables();\r\n\t\t(, bytes32 _stakedContentId, bytes32 _contentId, address _buyer, uint256 _price,,,,,) = _aoPurchaseReceipt.getById(_purchaseReceiptId);\r\n\t\t(, address _stakeOwner,,,, uint256 _profitPercentage,,) = _aoStakedContent.getById(_stakedContentId);\r\n\r\n\t\tEarning storage _ownerPurchaseReceiptStakeEarning = ownerPurchaseReceiptStakeEarnings[_stakeOwner][_purchaseReceiptId];\r\n\t\t_ownerPurchaseReceiptStakeEarning.purchaseReceiptId = _purchaseReceiptId;\r\n\r\n\t\t// Store how much the content creator (stake owner) earns in escrow\r\n\t\t// If content is AO Content Usage Type, stake owner earns 0%\r\n\t\t// and all profit goes to the serving host node\r\n\t\t_ownerPurchaseReceiptStakeEarning.paymentEarning = _aoContent.isAOContentUsageType(_contentId) ? (_price.mul(_profitPercentage)).div(AOLibrary.PERCENTAGE_DIVISOR()) : 0;\r\n\t\t// Pathos = Price X Node Share X Inflation Rate\r\n\t\t_ownerPurchaseReceiptStakeEarning.pathosAmount = _price.mul(AOLibrary.PERCENTAGE_DIVISOR().sub(_profitPercentage)).mul(inflationRate).div(AOLibrary.PERCENTAGE_DIVISOR()).div(AOLibrary.PERCENTAGE_DIVISOR());\r\n\t\trequire (_aoIon.escrowFrom(_namePublicKey.getDefaultKey(_buyer), _namePublicKey.getDefaultKey(_stakeOwner), _ownerPurchaseReceiptStakeEarning.paymentEarning));\r\n\t\temit PaymentEarningEscrowed(_stakeOwner, _purchaseReceiptId, _price, _profitPercentage, _ownerPurchaseReceiptStakeEarning.paymentEarning, 0);\r\n\t\treturn (_ownerPurchaseReceiptStakeEarning.paymentEarning, _ownerPurchaseReceiptStakeEarning.pathosAmount);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Calculate the payment split for host node and store them in escrow\r\n\t * @param _purchaseReceiptId The ID of the purchase receipt object\r\n\t * @param _stakeOwnerEarning The stake owner's earning amount\r\n\t * @return The ethos earned from this transaction\r\n\t */\r\n\tfunction _escrowHostPaymentEarning(bytes32 _purchaseReceiptId, uint256 _stakeOwnerEarning) internal returns (uint256) {\r\n\t\t(uint256 inflationRate,,) = _getSettingVariables();\r\n\t\t(bytes32 _contentHostId, bytes32 _stakedContentId, bytes32 _contentId, address _buyer, uint256 _price,,,,,) = _aoPurchaseReceipt.getById(_purchaseReceiptId);\r\n\t\t(,,,,, uint256 _profitPercentage,,) = _aoStakedContent.getById(_stakedContentId);\r\n\t\t(,, address _host,,) = _aoContentHost.getById(_contentHostId);\r\n\r\n\t\t// Store how much the node host earns in escrow\r\n\t\tEarning storage _ownerPurchaseReceiptHostEarning = ownerPurchaseReceiptHostEarnings[_host][_purchaseReceiptId];\r\n\t\t_ownerPurchaseReceiptHostEarning.purchaseReceiptId = _purchaseReceiptId;\r\n\t\t_ownerPurchaseReceiptHostEarning.paymentEarning = _price.sub(_stakeOwnerEarning);\r\n\t\t// Ethos = Price X Creator Share X Inflation Rate\r\n\t\t_ownerPurchaseReceiptHostEarning.ethosAmount = _price.mul(_profitPercentage).mul(inflationRate).div(AOLibrary.PERCENTAGE_DIVISOR()).div(AOLibrary.PERCENTAGE_DIVISOR());\r\n\r\n\t\tif (_aoContent.isAOContentUsageType(_contentId)) {\r\n\t\t\trequire (_aoIon.escrowFrom(_namePublicKey.getDefaultKey(_buyer), _namePublicKey.getDefaultKey(_host), _ownerPurchaseReceiptHostEarning.paymentEarning));\r\n\t\t} else {\r\n\t\t\t// If not AO Content usage type, we want to mint to the host\r\n\t\t\trequire (_aoIon.mintEscrow(_namePublicKey.getDefaultKey(_host), _ownerPurchaseReceiptHostEarning.paymentEarning));\r\n\t\t}\r\n\t\temit PaymentEarningEscrowed(_host, _purchaseReceiptId, _price, AOLibrary.PERCENTAGE_DIVISOR().sub(_profitPercentage), _ownerPurchaseReceiptHostEarning.paymentEarning, 1);\r\n\t\treturn _ownerPurchaseReceiptHostEarning.ethosAmount;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Calculate the earning for The AO and store them in escrow\r\n\t * @param _purchaseReceiptId The ID of the purchase receipt object\r\n\t * @param _pathosAmount The amount of pathos earned by stake owner\r\n\t * @param _ethosAmount The amount of ethos earned by host node\r\n\t */\r\n\tfunction _escrowTheAOPaymentEarning(bytes32 _purchaseReceiptId, uint256 _pathosAmount, uint256 _ethosAmount) internal {\r\n\t\t(,,uint256 theAOEthosEarnedRate) = _getSettingVariables();\r\n\t\t(,,,, uint256 _price,,,,,) = _aoPurchaseReceipt.getById(_purchaseReceiptId);\r\n\r\n\t\t// Store how much The AO earns in escrow\r\n\t\tEarning storage _theAOPurchaseReceiptEarning = theAOPurchaseReceiptEarnings[_purchaseReceiptId];\r\n\t\t_theAOPurchaseReceiptEarning.purchaseReceiptId = _purchaseReceiptId;\r\n\t\t// Pathos + X% of Ethos\r\n\t\t_theAOPurchaseReceiptEarning.paymentEarning = _pathosAmount.add(_ethosAmount.mul(theAOEthosEarnedRate).div(AOLibrary.PERCENTAGE_DIVISOR()));\r\n\t\trequire (_aoIon.mintEscrow(theAO, _theAOPurchaseReceiptEarning.paymentEarning));\r\n\t\temit PaymentEarningEscrowed(theAO, _purchaseReceiptId, _price, 0, _theAOPurchaseReceiptEarning.paymentEarning, 2);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Mint the inflation bonus for content creator/host/The AO and store them in escrow\r\n\t * @param _purchaseReceiptId The ID of the purchase receipt object\r\n\t */\r\n\tfunction _escrowInflationBonus(\r\n\t\tbytes32 _purchaseReceiptId\r\n\t) internal {\r\n\t\t(, uint256 theAOCut,) = _getSettingVariables();\r\n\t\tuint256 _inflationBonusAmount = _calculateInflationBonus(_purchaseReceiptId);\r\n\t\t(bytes32 _contentHostId, bytes32 _stakedContentId, bytes32 _contentId,,,,,,,) = _aoPurchaseReceipt.getById(_purchaseReceiptId);\r\n\t\t(, address _stakeOwner,,,, uint256 _profitPercentage,,) = _aoStakedContent.getById(_stakedContentId);\r\n\t\t(,, address _host,,) = _aoContentHost.getById(_contentHostId);\r\n\r\n\t\tif (_inflationBonusAmount > 0) {\r\n\t\t\t// Store how much the content creator earns in escrow\r\n\t\t\tuint256 _stakeOwnerInflationBonus = _aoContent.isAOContentUsageType(_contentId) ? (_inflationBonusAmount.mul(_profitPercentage)).div(AOLibrary.PERCENTAGE_DIVISOR()) : 0;\r\n\t\t\tEarning storage _ownerPurchaseReceiptStakeEarning = ownerPurchaseReceiptStakeEarnings[_stakeOwner][_purchaseReceiptId];\r\n\t\t\t_ownerPurchaseReceiptStakeEarning.inflationBonus = _stakeOwnerInflationBonus;\r\n\t\t\trequire (_aoIon.mintEscrow(_namePublicKey.getDefaultKey(_stakeOwner), _ownerPurchaseReceiptStakeEarning.inflationBonus));\r\n\t\t\temit InflationBonusEscrowed(_stakeOwner, _purchaseReceiptId, _inflationBonusAmount, _profitPercentage, _ownerPurchaseReceiptStakeEarning.inflationBonus, 0);\r\n\r\n\t\t\t// Store how much the host earns in escrow\r\n\t\t\tEarning storage _ownerPurchaseReceiptHostEarning = ownerPurchaseReceiptHostEarnings[_host][_purchaseReceiptId];\r\n\t\t\t_ownerPurchaseReceiptHostEarning.inflationBonus = _inflationBonusAmount.sub(_stakeOwnerInflationBonus);\r\n\t\t\trequire (_aoIon.mintEscrow(_namePublicKey.getDefaultKey(_host), _ownerPurchaseReceiptHostEarning.inflationBonus));\r\n\t\t\temit InflationBonusEscrowed(_host, _purchaseReceiptId, _inflationBonusAmount, AOLibrary.PERCENTAGE_DIVISOR().sub(_profitPercentage), _ownerPurchaseReceiptHostEarning.inflationBonus, 1);\r\n\r\n\t\t\t// Store how much the The AO earns in escrow\r\n\t\t\tEarning storage _theAOPurchaseReceiptEarning = theAOPurchaseReceiptEarnings[_purchaseReceiptId];\r\n\t\t\t_theAOPurchaseReceiptEarning.inflationBonus = (_inflationBonusAmount.mul(theAOCut)).div(AOLibrary.PERCENTAGE_DIVISOR());\r\n\t\t\trequire (_aoIon.mintEscrow(theAO, _theAOPurchaseReceiptEarning.inflationBonus));\r\n\t\t\temit InflationBonusEscrowed(theAO, _purchaseReceiptId, _inflationBonusAmount, theAOCut, _theAOPurchaseReceiptEarning.inflationBonus, 2);\r\n\t\t} else {\r\n\t\t\temit InflationBonusEscrowed(_stakeOwner, _purchaseReceiptId, 0, _profitPercentage, 0, 0);\r\n\t\t\temit InflationBonusEscrowed(_host, _purchaseReceiptId, 0, AOLibrary.PERCENTAGE_DIVISOR().sub(_profitPercentage), 0, 1);\r\n\t\t\temit InflationBonusEscrowed(theAO, _purchaseReceiptId, 0, theAOCut, 0, 2);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Calculate the inflation bonus amount\r\n\t * @param _purchaseReceiptId The ID of the PurchaseReceipt\r\n\t * @return the bonus network amount\r\n\t */\r\n\tfunction _calculateInflationBonus(bytes32 _purchaseReceiptId) internal view returns (uint256) {\r\n\t\t(uint256 inflationRate,,) = _getSettingVariables();\r\n\t\t(, bytes32 _stakedContentId,,,,,,,,) = _aoPurchaseReceipt.getById(_purchaseReceiptId);\r\n\t\t(,,uint256 _networkAmount, uint256 _primordialAmount, uint256 _primordialWeightedMultiplier,,,) = _aoStakedContent.getById(_stakedContentId);\r\n\r\n\t\tuint256 _networkBonus = _networkAmount.mul(inflationRate).div(AOLibrary.PERCENTAGE_DIVISOR());\r\n\t\tuint256 _primordialBonus = _primordialAmount.mul(_primordialWeightedMultiplier).div(AOLibrary.MULTIPLIER_DIVISOR()).mul(inflationRate).div(AOLibrary.PERCENTAGE_DIVISOR());\r\n\t\treturn _networkBonus.add(_primordialBonus);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Release the escrowed earning for a specific PurchaseReceipt ID for an account\r\n\t * @param _stakedContentId The ID of the staked content\r\n\t * @param _contentHostId The ID of the hosted content\r\n\t * @param _purchaseReceiptId The purchase receipt ID\r\n\t * @param _buyerPaidMoreThanFileSize Whether or not the request node paid more than filesize when buying the content\r\n\t * @param _account The address of account that made the earning (content creator/host)\r\n\t * @param _recipientType The type of the earning recipient (0 => content creator. 1 => host. 2 => theAO)\r\n\t */\r\n\tfunction _releaseEarning(bytes32 _stakedContentId, bytes32 _contentHostId, bytes32 _purchaseReceiptId, bool _buyerPaidMoreThanFileSize, address _account, uint8 _recipientType) internal {\r\n\t\t// Make sure the recipient type is valid\r\n\t\trequire (_recipientType >= 0 && _recipientType <= 2);\r\n\r\n\t\tuint256 _paymentEarning;\r\n\t\tuint256 _inflationBonus;\r\n\t\tuint256 _totalEarning;\r\n\t\tuint256 _pathosAmount;\r\n\t\tuint256 _ethosAmount;\r\n\t\tif (_recipientType == 0) {\r\n\t\t\tEarning storage _earning = ownerPurchaseReceiptStakeEarnings[_account][_purchaseReceiptId];\r\n\t\t\t_paymentEarning = _earning.paymentEarning;\r\n\t\t\t_inflationBonus = _earning.inflationBonus;\r\n\t\t\t_pathosAmount = _earning.pathosAmount;\r\n\t\t\t_earning.paymentEarning = 0;\r\n\t\t\t_earning.inflationBonus = 0;\r\n\t\t\t_earning.pathosAmount = 0;\r\n\t\t\t_earning.ethosAmount = 0;\r\n\t\t\t_totalEarning = _paymentEarning.add(_inflationBonus);\r\n\r\n\t\t\t// Update the global var settings\r\n\t\t\ttotalStakedContentEarning = totalStakedContentEarning.add(_totalEarning);\r\n\t\t\townerStakedContentEarning[_account] = ownerStakedContentEarning[_account].add(_totalEarning);\r\n\t\t\tstakedContentStakeEarning[_stakedContentId] = stakedContentStakeEarning[_stakedContentId].add(_totalEarning);\r\n\t\t\tif (_buyerPaidMoreThanFileSize) {\r\n\t\t\t\townerContentPriceEarning[_account] = ownerContentPriceEarning[_account].add(_totalEarning);\r\n\t\t\t} else {\r\n\t\t\t\townerNetworkPriceEarning[_account] = ownerNetworkPriceEarning[_account].add(_totalEarning);\r\n\t\t\t}\r\n\t\t\townerInflationBonusAccrued[_account] = ownerInflationBonusAccrued[_account].add(_inflationBonus);\r\n\r\n\t\t\t// Reward the content creator/stake owner with some Pathos\r\n\t\t\trequire (_pathos.mint(_account, _pathosAmount));\r\n\t\t\temit PathosEarned(_account, _purchaseReceiptId, _pathosAmount);\r\n\t\t\trequire (_aoIon.unescrowFrom(_namePublicKey.getDefaultKey(_account), _totalEarning));\r\n\t\t} else if (_recipientType == 1) {\r\n\t\t\tEarning storage _earning = ownerPurchaseReceiptHostEarnings[_account][_purchaseReceiptId];\r\n\t\t\t_paymentEarning = _earning.paymentEarning;\r\n\t\t\t_inflationBonus = _earning.inflationBonus;\r\n\t\t\t_ethosAmount = _earning.ethosAmount;\r\n\t\t\t_earning.paymentEarning = 0;\r\n\t\t\t_earning.inflationBonus = 0;\r\n\t\t\t_earning.pathosAmount = 0;\r\n\t\t\t_earning.ethosAmount = 0;\r\n\t\t\t_totalEarning = _paymentEarning.add(_inflationBonus);\r\n\r\n\t\t\t// Update the global var settings\r\n\t\t\ttotalContentHostEarning = totalContentHostEarning.add(_totalEarning);\r\n\t\t\townerContentHostEarning[_account] = ownerContentHostEarning[_account].add(_totalEarning);\r\n\t\t\tstakedContentHostEarning[_stakedContentId] = stakedContentHostEarning[_stakedContentId].add(_totalEarning);\r\n\t\t\tcontentHostEarning[_contentHostId] = contentHostEarning[_contentHostId].add(_totalEarning);\r\n\t\t\tif (_buyerPaidMoreThanFileSize) {\r\n\t\t\t\townerContentPriceEarning[_account] = ownerContentPriceEarning[_account].add(_totalEarning);\r\n\t\t\t} else {\r\n\t\t\t\townerNetworkPriceEarning[_account] = ownerNetworkPriceEarning[_account].add(_totalEarning);\r\n\t\t\t}\r\n\t\t\townerInflationBonusAccrued[_account] = ownerInflationBonusAccrued[_account].add(_inflationBonus);\r\n\r\n\t\t\t// Reward the host node with some Ethos\r\n\t\t\trequire (_ethos.mint(_account, _ethosAmount));\r\n\t\t\temit EthosEarned(_account, _purchaseReceiptId, _ethosAmount);\r\n\t\t\trequire (_aoIon.unescrowFrom(_namePublicKey.getDefaultKey(_account), _totalEarning));\r\n\t\t} else {\r\n\t\t\tEarning storage _earning = theAOPurchaseReceiptEarnings[_purchaseReceiptId];\r\n\t\t\t_paymentEarning = _earning.paymentEarning;\r\n\t\t\t_inflationBonus = _earning.inflationBonus;\r\n\t\t\t_earning.paymentEarning = 0;\r\n\t\t\t_earning.inflationBonus = 0;\r\n\t\t\t_earning.pathosAmount = 0;\r\n\t\t\t_earning.ethosAmount = 0;\r\n\t\t\t_totalEarning = _paymentEarning.add(_inflationBonus);\r\n\r\n\t\t\t// Update the global var settings\r\n\t\t\ttotalTheAOEarning = totalTheAOEarning.add(_totalEarning);\r\n\t\t\townerInflationBonusAccrued[_account] = ownerInflationBonusAccrued[_account].add(_inflationBonus);\r\n\t\t\tstakedContentTheAOEarning[_stakedContentId] = stakedContentTheAOEarning[_stakedContentId].add(_totalEarning);\r\n\t\t\trequire (_aoIon.unescrowFrom(_account, _totalEarning));\r\n\t\t}\r\n\t\temit EarningUnescrowed(_account, _purchaseReceiptId, _paymentEarning, _inflationBonus, _recipientType);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Get setting variables\r\n\t * @return inflationRate The rate to use when calculating inflation bonus\r\n\t * @return theAOCut The rate to use when calculating the AO earning\r\n\t * @return theAOEthosEarnedRate The rate to use when calculating the Ethos to AO rate for the AO\r\n\t */\r\n\tfunction _getSettingVariables() internal view returns (uint256, uint256, uint256) {\r\n\t\t(uint256 inflationRate,,,,) = _aoSetting.getSettingValuesByTAOName(settingTAOId, 'inflationRate');\r\n\t\t(uint256 theAOCut,,,,) = _aoSetting.getSettingValuesByTAOName(settingTAOId, 'theAOCut');\r\n\t\t(uint256 theAOEthosEarnedRate,,,,) = _aoSetting.getSettingValuesByTAOName(settingTAOId, 'theAOEthosEarnedRate');\r\n\r\n\t\treturn (inflationRate, theAOCut, theAOEthosEarnedRate);\r\n\t}\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_aoSettingAddress\",\"type\":\"address\"}],\"name\":\"setAOSettingAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"aoStakedContentAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalStakedContentEarning\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_ethosAddress\",\"type\":\"address\"}],\"name\":\"setEthosAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"aoSettingAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"contentHostEarning\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"ownerContentPriceEarning\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"ownerStakedContentEarning\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"aoIonAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_aoStakedContentAddress\",\"type\":\"address\"}],\"name\":\"setAOStakedContentAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_stakedContentId\",\"type\":\"bytes32\"}],\"name\":\"getTotalStakedContentEarning\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pathosAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_purchaseReceiptId\",\"type\":\"bytes32\"}],\"name\":\"releaseEarning\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nameTAOPositionAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_account\",\"type\":\"address\"},{\"name\":\"_whitelist\",\"type\":\"bool\"}],\"name\":\"setWhitelist\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_nameTAOPositionAddress\",\"type\":\"address\"}],\"name\":\"setNameTAOPositionAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_namePublicKeyAddress\",\"type\":\"address\"}],\"name\":\"setNamePublicKeyAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"stakedContentTheAOEarning\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_pathosAddress\",\"type\":\"address\"}],\"name\":\"setPathosAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalContentHostEarning\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"aoContentAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_aoContentAddress\",\"type\":\"address\"}],\"name\":\"setAOContentAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"ownerPurchaseReceiptHostEarnings\",\"outputs\":[{\"name\":\"purchaseReceiptId\",\"type\":\"bytes32\"},{\"name\":\"paymentEarning\",\"type\":\"uint256\"},{\"name\":\"inflationBonus\",\"type\":\"uint256\"},{\"name\":\"pathosAmount\",\"type\":\"uint256\"},{\"name\":\"ethosAmount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_nameFactoryAddress\",\"type\":\"address\"}],\"name\":\"setNameFactoryAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ethosAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"ownerPurchaseReceiptStakeEarnings\",\"outputs\":[{\"name\":\"purchaseReceiptId\",\"type\":\"bytes32\"},{\"name\":\"paymentEarning\",\"type\":\"uint256\"},{\"name\":\"inflationBonus\",\"type\":\"uint256\"},{\"name\":\"pathosAmount\",\"type\":\"uint256\"},{\"name\":\"ethosAmount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"aoContentHostAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"whitelist\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"theAO\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nameFactoryAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_aoPurchaseReceiptAddress\",\"type\":\"address\"}],\"name\":\"setAOPurchaseReceiptAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"stakedContentStakeEarning\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalTheAOEarning\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"ownerInflationBonusAccrued\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"ownerNetworkPriceEarning\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_aoContentHostAddress\",\"type\":\"address\"}],\"name\":\"setAOContentHostAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"theAOPurchaseReceiptEarnings\",\"outputs\":[{\"name\":\"purchaseReceiptId\",\"type\":\"bytes32\"},{\"name\":\"paymentEarning\",\"type\":\"uint256\"},{\"name\":\"inflationBonus\",\"type\":\"uint256\"},{\"name\":\"pathosAmount\",\"type\":\"uint256\"},{\"name\":\"ethosAmount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_settingTAOId\",\"type\":\"address\"}],\"name\":\"setSettingTAOId\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"ownerContentHostEarning\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"namePublicKeyAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_purchaseReceiptId\",\"type\":\"bytes32\"}],\"name\":\"calculateEarning\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"aoPurchaseReceiptAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"settingTAOId\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"stakedContentHostEarning\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_theAO\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_aoIonAddress\",\"type\":\"address\"}],\"name\":\"setAOIonAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_settingTAOId\",\"type\":\"address\"},{\"name\":\"_aoSettingAddress\",\"type\":\"address\"},{\"name\":\"_aoIonAddress\",\"type\":\"address\"},{\"name\":\"_nameFactoryAddress\",\"type\":\"address\"},{\"name\":\"_pathosAddress\",\"type\":\"address\"},{\"name\":\"_ethosAddress\",\"type\":\"address\"},{\"name\":\"_aoContentAddress\",\"type\":\"address\"},{\"name\":\"_namePublicKeyAddress\",\"type\":\"address\"},{\"name\":\"_nameTAOPositionAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"purchaseReceiptId\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"price\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"recipientProfitPercentage\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"recipientPaymentEarning\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"recipientType\",\"type\":\"uint8\"}],\"name\":\"PaymentEarningEscrowed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"purchaseReceiptId\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"totalInflationBonusAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"recipientProfitPercentage\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"recipientInflationBonus\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"recipientType\",\"type\":\"uint8\"}],\"name\":\"InflationBonusEscrowed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"purchaseReceiptId\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"paymentEarning\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"inflationBonus\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"recipientType\",\"type\":\"uint8\"}],\"name\":\"EarningUnescrowed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"nameId\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"purchaseReceiptId\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"PathosEarned\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"nameId\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"purchaseReceiptId\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"EthosEarned\",\"type\":\"event\"}]","ContractName":"AOEarning","CompilerVersion":"v0.5.4+commit.9549d8ff","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000ec7aa72cb653b773b8c8c66a2e3e05669f4ef362000000000000000000000000bd314084ac5872598fdff2f31567084fc9c442700000000000000000000000007fea965a502f3f17851a57bcc57e95e03d83e98a00000000000000000000000010fbf61e4cce57d72eed8b5d9728134ce374bd82000000000000000000000000b1b8ea7d3f55436c3cd5afcd89e56cce85a0b8b30000000000000000000000003ecc8d4ab143fb5d87024dc886762aea0254aebd0000000000000000000000008db3ae7ad65b18282947ada2a6156a47b04cac9300000000000000000000000051bedad07ab8c2470556d565f98307d89380a6da0000000000000000000000001f7f65b220a0f2d48b28390380f57468e7a382fe","Library":"AOLibrary:1150d53299Abb7DE27464D01B626728f5c840229","SwarmSource":"bzzr://2388f57c3741e8d4e10beb2bb7a12fbb1c6b26ef8d2fc54afa898bb22f328fee"}]}