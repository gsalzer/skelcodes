{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\n// File: contracts/lib/ownership/Ownable.sol\r\n\r\ncontract Ownable {\r\n    address public owner;\r\n    event OwnershipTransferred(address indexed previousOwner,address indexed newOwner);\r\n\r\n    /// @dev The Ownable constructor sets the original `owner` of the contract to the sender account.\r\n    constructor() public { owner = msg.sender; }\r\n\r\n    /// @dev Throws if called by any contract other than latest designated caller\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    /// @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n    /// @param newOwner The address to transfer ownership to.\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n       require(newOwner != address(0));\r\n       emit OwnershipTransferred(owner, newOwner);\r\n       owner = newOwner;\r\n    }\r\n}\r\n\r\n// File: contracts/lib/token/FactoryTokenInterface.sol\r\n\r\ncontract FactoryTokenInterface is Ownable {\r\n    function balanceOf(address _owner) public view returns (uint256);\r\n    function transfer(address _to, uint256 _value) public returns (bool);\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool);\r\n    function approve(address _spender, uint256 _value) public returns (bool);\r\n    function allowance(address _owner, address _spender) public view returns (uint256);\r\n    function mint(address _to, uint256 _amount) public returns (bool);\r\n    function burnFrom(address _from, uint256 _value) public;\r\n}\r\n\r\n// File: contracts/lib/token/TokenFactoryInterface.sol\r\n\r\ncontract TokenFactoryInterface {\r\n    function create(string _name, string _symbol) public returns (FactoryTokenInterface);\r\n}\r\n\r\n// File: contracts/lib/ownership/ZapCoordinatorInterface.sol\r\n\r\ncontract ZapCoordinatorInterface is Ownable {\r\n\tfunction addImmutableContract(string contractName, address newAddress) external;\r\n\tfunction updateContract(string contractName, address newAddress) external;\r\n\tfunction getContractName(uint index) public view returns (string);\r\n\tfunction getContract(string contractName) public view returns (address);\r\n\tfunction updateAllDependencies() external;\r\n}\r\n\r\n// File: contracts/platform/bondage/BondageInterface.sol\r\n\r\ncontract BondageInterface {\r\n    function bond(address, bytes32, uint256) external returns(uint256);\r\n    function unbond(address, bytes32, uint256) external returns (uint256);\r\n    function delegateBond(address, address, bytes32, uint256) external returns(uint256);\r\n    function escrowDots(address, address, bytes32, uint256) external returns (bool);\r\n    function releaseDots(address, address, bytes32, uint256) external returns (bool);\r\n    function returnDots(address, address, bytes32, uint256) external returns (bool success);\r\n    function calcZapForDots(address, bytes32, uint256) external view returns (uint256);\r\n    function currentCostOfDot(address, bytes32, uint256) public view returns (uint256);\r\n    function getDotsIssued(address, bytes32) public view returns (uint256);\r\n    function getBoundDots(address, address, bytes32) public view returns (uint256);\r\n    function getZapBound(address, bytes32) public view returns (uint256);\r\n    function dotLimit( address, bytes32) public view returns (uint256);\r\n}\r\n\r\n// File: contracts/platform/bondage/currentCost/CurrentCostInterface.sol\r\n\r\ncontract CurrentCostInterface {    \r\n    function _currentCostOfDot(address, bytes32, uint256) public view returns (uint256);\r\n    function _dotLimit(address, bytes32) public view returns (uint256);\r\n    function _costOfNDots(address, bytes32, uint256, uint256) public view returns (uint256);\r\n}\r\n\r\n// File: contracts/platform/registry/RegistryInterface.sol\r\n\r\n// Technically an abstract contract, not interface (solidity compiler devs are working to fix this right now)\r\n\r\ncontract RegistryInterface {\r\n    function initiateProvider(uint256, bytes32) public returns (bool);\r\n    function initiateProviderCurve(bytes32, int256[], address) public returns (bool);\r\n    function setEndpointParams(bytes32, bytes32[]) public;\r\n    function getEndpointParams(address, bytes32) public view returns (bytes32[]);\r\n    function getProviderPublicKey(address) public view returns (uint256);\r\n    function getProviderTitle(address) public view returns (bytes32);\r\n    function setProviderParameter(bytes32, bytes) public;\r\n    function setProviderTitle(bytes32) public;\r\n    function clearEndpoint(bytes32) public;\r\n    function getProviderParameter(address, bytes32) public view returns (bytes);\r\n    function getAllProviderParams(address) public view returns (bytes32[]);\r\n    function getProviderCurveLength(address, bytes32) public view returns (uint256);\r\n    function getProviderCurve(address, bytes32) public view returns (int[]);\r\n    function isProviderInitiated(address) public view returns (bool);\r\n    function getAllOracles() external view returns (address[]);\r\n    function getProviderEndpoints(address) public view returns (bytes32[]);\r\n    function getEndpointBroker(address, bytes32) public view returns (address);\r\n}\r\n\r\n// File: contracts/lib/platform/TokenDotFactory.sol\r\n\r\ncontract TokenDotFactory is Ownable {\r\n\r\n    CurrentCostInterface currentCost;\r\n    FactoryTokenInterface public reserveToken;\r\n    ZapCoordinatorInterface public coord;\r\n    TokenFactoryInterface public tokenFactory;\r\n    BondageInterface bondage;\r\n\r\n    mapping(bytes32 => address) public curves;\r\n\r\n    event DotTokenCreated(address tokenAddress);\r\n\r\n    constructor(\r\n        address coordinator, \r\n        address factory,\r\n        uint256 providerPubKey,\r\n        bytes32 providerTitle \r\n    ){\r\n        coord = ZapCoordinatorInterface(coordinator); \r\n        reserveToken = FactoryTokenInterface(coord.getContract(\"ZAP_TOKEN\"));\r\n        //always allow bondage to transfer from wallet\r\n        reserveToken.approve(coord.getContract(\"BONDAGE\"), ~uint256(0));\r\n        tokenFactory = TokenFactoryInterface(factory);\r\n\r\n        RegistryInterface registry = RegistryInterface(coord.getContract(\"REGISTRY\")); \r\n        registry.initiateProvider(providerPubKey, providerTitle);\r\n    }\r\n\r\n    function initializeCurve(\r\n        bytes32 specifier, \r\n        bytes32 symbol, \r\n        int256[] curve\r\n    ) public returns(address) {\r\n        \r\n        require(curves[specifier] == 0, \"Curve specifier already exists\");\r\n        \r\n        RegistryInterface registry = RegistryInterface(coord.getContract(\"REGISTRY\")); \r\n        require(registry.isProviderInitiated(address(this)), \"Provider not intiialized\");\r\n\r\n        registry.initiateProviderCurve(specifier, curve, address(this));\r\n        curves[specifier] = newToken(bytes32ToString(specifier), bytes32ToString(symbol));\r\n        \r\n        registry.setProviderParameter(specifier, toBytes(curves[specifier]));\r\n        \r\n        DotTokenCreated(curves[specifier]);\r\n        return curves[specifier];\r\n    }\r\n\r\n    //whether this contract holds tokens or coming from msg.sender,etc\r\n    function bond(bytes32 specifier, uint numDots) public  {\r\n\r\n        bondage = BondageInterface(coord.getContract(\"BONDAGE\"));\r\n        uint256 issued = bondage.getDotsIssued(address(this), specifier);\r\n\r\n        CurrentCostInterface cost = CurrentCostInterface(coord.getContract(\"CURRENT_COST\"));\r\n        uint256 numReserve = cost._costOfNDots(address(this), specifier, issued + 1, numDots - 1);\r\n\r\n        require(\r\n            reserveToken.transferFrom(msg.sender, address(this), numReserve),\r\n            \"insufficient accepted token numDots approved for transfer\"\r\n        );\r\n\r\n        reserveToken.approve(address(bondage), numReserve);\r\n        bondage.bond(address(this), specifier, numDots);\r\n        FactoryTokenInterface(curves[specifier]).mint(msg.sender, numDots);\r\n\r\n    }\r\n\r\n    //whether this contract holds tokens or coming from msg.sender,etc\r\n    function unbond(bytes32 specifier, uint numDots) public {\r\n\r\n        bondage = BondageInterface(coord.getContract(\"BONDAGE\"));\r\n        uint issued = bondage.getDotsIssued(address(this), specifier);\r\n\r\n        currentCost = CurrentCostInterface(coord.getContract(\"CURRENT_COST\"));\r\n        uint reserveCost = currentCost._costOfNDots(address(this), specifier, issued + 1 - numDots, numDots - 1);\r\n\r\n        //unbond dots\r\n        bondage.unbond(address(this), specifier, numDots);\r\n        //burn dot backed token\r\n        FactoryTokenInterface curveToken = FactoryTokenInterface(curves[specifier]);\r\n        curveToken.burnFrom(msg.sender, numDots);\r\n\r\n        require(reserveToken.transfer(msg.sender, reserveCost), \"Error: Transfer failed\");\r\n    }\r\n\r\n    function newToken(\r\n        string name,\r\n        string symbol\r\n    ) \r\n        public\r\n        returns (address tokenAddress) \r\n    {\r\n        FactoryTokenInterface token = tokenFactory.create(name, symbol);\r\n        tokenAddress = address(token);\r\n        return tokenAddress;\r\n    }\r\n\r\n    function getTokenAddress(bytes32 specifier) public view returns(address) {\r\n        RegistryInterface registry = RegistryInterface(coord.getContract(\"REGISTRY\")); \r\n        return bytesToAddr(registry.getProviderParameter(address(this), specifier));\r\n    }\r\n\r\n    // https://ethereum.stackexchange.com/questions/884/how-to-convert-an-address-to-bytes-in-solidity\r\n    function toBytes(address x) public pure returns (bytes b) {\r\n        b = new bytes(20);\r\n        for (uint i = 0; i < 20; i++)\r\n            b[i] = byte(uint8(uint(x) / (2**(8*(19 - i)))));\r\n    }\r\n\r\n    //https://ethereum.stackexchange.com/questions/2519/how-to-convert-a-bytes32-to-string\r\n    function bytes32ToString(bytes32 x) public pure returns (string) {\r\n        bytes memory bytesString = new bytes(32);\r\n\r\n        bytesString = abi.encodePacked(x);\r\n\r\n        return string(bytesString);\r\n    }\r\n\r\n    //https://ethereum.stackexchange.com/questions/15350/how-to-convert-an-bytes-to-address-in-solidity\r\n    function bytesToAddr (bytes b) public pure returns (address) {\r\n        uint result = 0;\r\n        for (uint i = b.length-1; i+1 > 0; i--) {\r\n            uint c = uint(b[i]);\r\n            uint to_inc = c * ( 16 ** ((b.length - i-1) * 2));\r\n            result += to_inc;\r\n        }\r\n        return address(result);\r\n    }\r\n\r\n\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"specifier\",\"type\":\"bytes32\"},{\"name\":\"symbol\",\"type\":\"bytes32\"},{\"name\":\"curve\",\"type\":\"int256[]\"}],\"name\":\"initializeCurve\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"name\",\"type\":\"string\"},{\"name\":\"symbol\",\"type\":\"string\"}],\"name\":\"newToken\",\"outputs\":[{\"name\":\"tokenAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"specifier\",\"type\":\"bytes32\"},{\"name\":\"numDots\",\"type\":\"uint256\"}],\"name\":\"unbond\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"specifier\",\"type\":\"bytes32\"},{\"name\":\"numDots\",\"type\":\"uint256\"}],\"name\":\"bond\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"x\",\"type\":\"address\"}],\"name\":\"toBytes\",\"outputs\":[{\"name\":\"b\",\"type\":\"bytes\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"b\",\"type\":\"bytes\"}],\"name\":\"bytesToAddr\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"curves\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"x\",\"type\":\"bytes32\"}],\"name\":\"bytes32ToString\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"coord\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"specifier\",\"type\":\"bytes32\"}],\"name\":\"getTokenAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenFactory\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"reserveToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"coordinator\",\"type\":\"address\"},{\"name\":\"factory\",\"type\":\"address\"},{\"name\":\"providerPubKey\",\"type\":\"uint256\"},{\"name\":\"providerTitle\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"tokenAddress\",\"type\":\"address\"}],\"name\":\"DotTokenCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"TokenDotFactory","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000b007eca49763f31edff95623ed6c23c8c1924a16000000000000000000000000e13fef4c8e75c12f9706e8bdf28fe847ce99cb42000000036b5252a719be12e4aa87faf67a410ce894d0f79a997fc21ee379ff3d546f6b656e446f74466163746f72790000000000000000000000000000000000","Library":"","SwarmSource":"bzzr://8e1bd9b21092c8cb7dc3286c8de637d3df68b3c722e9d6f534fd60a394604c08"}]}