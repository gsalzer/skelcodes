{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.25;\r\npragma experimental ABIEncoderV2;\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 {\r\n  function totalSupply() public view returns (uint256);\r\n\r\n  function balanceOf(address _who) public view returns (uint256);\r\n\r\n  function allowance(address _owner, address _spender)\r\n    public view returns (uint256);\r\n\r\n  function transfer(address _to, uint256 _value) public returns (bool);\r\n\r\n  function approve(address _spender, uint256 _value)\r\n    public returns (bool);\r\n\r\n  function transferFrom(address _from, address _to, uint256 _value)\r\n    public returns (bool);\r\n\r\n  function decimals() public view returns (uint256);\r\n\r\n  event Transfer(\r\n    address indexed from,\r\n    address indexed to,\r\n    uint256 value\r\n  );\r\n\r\n  event Approval(\r\n    address indexed owner,\r\n    address indexed spender,\r\n    uint256 value\r\n  );\r\n}\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, reverts on overflow.\r\n  */\r\n  function mul(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (_a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    uint256 c = _a * _b;\r\n    require(c / _a == _b);\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\r\n  */\r\n  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    require(_b > 0); // Solidity only automatically asserts when dividing by 0\r\n    uint256 c = _a / _b;\r\n    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    require(_b <= _a);\r\n    uint256 c = _a - _b;\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, reverts on overflow.\r\n  */\r\n  function add(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    uint256 c = _a + _b;\r\n    require(c >= _a);\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\r\n  * reverts when dividing by zero.\r\n  */\r\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b != 0);\r\n    return a % b;\r\n  }\r\n}\r\n\r\n/*\r\n    Modified Util contract as used by Kyber Network\r\n*/\r\n\r\nlibrary Utils {\r\n\r\n    uint256 constant internal PRECISION = (10**18);\r\n    uint256 constant internal MAX_QTY   = (10**28); // 10B tokens\r\n    uint256 constant internal MAX_RATE  = (PRECISION * 10**6); // up to 1M tokens per ETH\r\n    uint256 constant internal MAX_DECIMALS = 18;\r\n    uint256 constant internal ETH_DECIMALS = 18;\r\n    uint256 constant internal MAX_UINT = 2**256-1;\r\n\r\n    // Currently constants can't be accessed from other contracts, so providing functions to do that here\r\n    function precision() internal pure returns (uint256) { return PRECISION; }\r\n    function max_qty() internal pure returns (uint256) { return MAX_QTY; }\r\n    function max_rate() internal pure returns (uint256) { return MAX_RATE; }\r\n    function max_decimals() internal pure returns (uint256) { return MAX_DECIMALS; }\r\n    function eth_decimals() internal pure returns (uint256) { return ETH_DECIMALS; }\r\n    function max_uint() internal pure returns (uint256) { return MAX_UINT; }\r\n\r\n    /// @notice Retrieve the number of decimals used for a given ERC20 token\r\n    /// @dev As decimals are an optional feature in ERC20, this contract uses `call` to\r\n    /// ensure that an exception doesn't cause transaction failure\r\n    /// @param token the token for which we should retrieve the decimals\r\n    /// @return decimals the number of decimals in the given token\r\n    function getDecimals(address token)\r\n        internal\r\n        view\r\n        returns (uint256 decimals)\r\n    {\r\n        bytes4 functionSig = bytes4(keccak256(\"decimals()\"));\r\n\r\n        /// @dev Using assembly due to issues with current solidity `address.call()`\r\n        /// implementation: https://github.com/ethereum/solidity/issues/2884\r\n        assembly {\r\n            // Pointer to next free memory slot\r\n            let ptr := mload(0x40)\r\n            // Store functionSig variable at ptr\r\n            mstore(ptr,functionSig)\r\n            let functionSigLength := 0x04\r\n            let wordLength := 0x20\r\n\r\n            let success := call(\r\n                                5000, // Amount of gas\r\n                                token, // Address to call\r\n                                0, // ether to send\r\n                                ptr, // ptr to input data\r\n                                functionSigLength, // size of data\r\n                                ptr, // where to store output data (overwrite input)\r\n                                wordLength // size of output data (32 bytes)\r\n                               )\r\n\r\n            switch success\r\n            case 0 {\r\n                decimals := 0 // If the token doesn't implement `decimals()`, return 0 as default\r\n            }\r\n            case 1 {\r\n                decimals := mload(ptr) // Set decimals to return data from call\r\n            }\r\n            mstore(0x40,add(ptr,0x04)) // Reset the free memory pointer to the next known free location\r\n        }\r\n    }\r\n\r\n    /// @dev Checks that a given address has its token allowance and balance set above the given amount\r\n    /// @param tokenOwner the address which should have custody of the token\r\n    /// @param tokenAddress the address of the token to check\r\n    /// @param tokenAmount the amount of the token which should be set\r\n    /// @param addressToAllow the address which should be allowed to transfer the token\r\n    /// @return bool true if the allowance and balance is set, false if not\r\n    function tokenAllowanceAndBalanceSet(\r\n        address tokenOwner,\r\n        address tokenAddress,\r\n        uint256 tokenAmount,\r\n        address addressToAllow\r\n    )\r\n        internal\r\n        view\r\n        returns (bool)\r\n    {\r\n        return (\r\n            ERC20(tokenAddress).allowance(tokenOwner, addressToAllow) >= tokenAmount &&\r\n            ERC20(tokenAddress).balanceOf(tokenOwner) >= tokenAmount\r\n        );\r\n    }\r\n\r\n    function calcDstQty(uint srcQty, uint srcDecimals, uint dstDecimals, uint rate) internal pure returns (uint) {\r\n        if (dstDecimals >= srcDecimals) {\r\n            require((dstDecimals - srcDecimals) <= MAX_DECIMALS);\r\n            return (srcQty * rate * (10**(dstDecimals - srcDecimals))) / PRECISION;\r\n        } else {\r\n            require((srcDecimals - dstDecimals) <= MAX_DECIMALS);\r\n            return (srcQty * rate) / (PRECISION * (10**(srcDecimals - dstDecimals)));\r\n        }\r\n    }\r\n\r\n    function calcSrcQty(uint dstQty, uint srcDecimals, uint dstDecimals, uint rate) internal pure returns (uint) {\r\n\r\n        //source quantity is rounded up. to avoid dest quantity being too low.\r\n        uint numerator;\r\n        uint denominator;\r\n        if (srcDecimals >= dstDecimals) {\r\n            require((srcDecimals - dstDecimals) <= MAX_DECIMALS);\r\n            numerator = (PRECISION * dstQty * (10**(srcDecimals - dstDecimals)));\r\n            denominator = rate;\r\n        } else {\r\n            require((dstDecimals - srcDecimals) <= MAX_DECIMALS);\r\n            numerator = (PRECISION * dstQty);\r\n            denominator = (rate * (10**(dstDecimals - srcDecimals)));\r\n        }\r\n        return (numerator + denominator - 1) / denominator; //avoid rounding down errors\r\n    }\r\n\r\n    function calcDestAmount(ERC20 src, ERC20 dest, uint srcAmount, uint rate) internal view returns (uint) {\r\n        return calcDstQty(srcAmount, getDecimals(src), getDecimals(dest), rate);\r\n    }\r\n\r\n    function calcSrcAmount(ERC20 src, ERC20 dest, uint destAmount, uint rate) internal view returns (uint) {\r\n        return calcSrcQty(destAmount, getDecimals(src), getDecimals(dest), rate);\r\n    }\r\n\r\n    function calcRateFromQty(uint srcAmount, uint destAmount, uint srcDecimals, uint dstDecimals)\r\n        internal pure returns (uint)\r\n    {\r\n        require(srcAmount <= MAX_QTY);\r\n        require(destAmount <= MAX_QTY);\r\n\r\n        if (dstDecimals >= srcDecimals) {\r\n            require((dstDecimals - srcDecimals) <= MAX_DECIMALS);\r\n            return (destAmount * PRECISION / ((10 ** (dstDecimals - srcDecimals)) * srcAmount));\r\n        } else {\r\n            require((srcDecimals - dstDecimals) <= MAX_DECIMALS);\r\n            return (destAmount * PRECISION * (10 ** (srcDecimals - dstDecimals)) / srcAmount);\r\n        }\r\n    }\r\n\r\n    /// @notice Bringing this in from the Math library as we've run out of space in TotlePrimary (see EIP-170)\r\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a < b ? a : b;\r\n    }\r\n}\r\n\r\nlibrary ERC20SafeTransfer {\r\n    function safeTransfer(address _tokenAddress, address _to, uint256 _value) internal returns (bool success) {\r\n\r\n        require(_tokenAddress.call(bytes4(keccak256(\"transfer(address,uint256)\")), _to, _value));\r\n\r\n        return fetchReturnData();\r\n    }\r\n\r\n    function safeTransferFrom(address _tokenAddress, address _from, address _to, uint256 _value) internal returns (bool success) {\r\n\r\n        require(_tokenAddress.call(bytes4(keccak256(\"transferFrom(address,address,uint256)\")), _from, _to, _value));\r\n\r\n        return fetchReturnData();\r\n    }\r\n\r\n    function safeApprove(address _tokenAddress, address _spender, uint256 _value) internal returns (bool success) {\r\n\r\n        require(_tokenAddress.call(bytes4(keccak256(\"approve(address,uint256)\")), _spender, _value));\r\n\r\n        return fetchReturnData();\r\n    }\r\n\r\n    function fetchReturnData() internal returns (bool success){\r\n        assembly {\r\n            switch returndatasize()\r\n            case 0 {\r\n                success := 1\r\n            }\r\n            case 32 {\r\n                returndatacopy(0, 0, 32)\r\n                success := mload(0)\r\n            }\r\n            default {\r\n                revert(0, 0)\r\n            }\r\n        }\r\n    }\r\n\r\n}\r\n\r\n/// @title A contract which is used to check and set allowances of tokens\r\n/// @dev In order to use this contract is must be inherited in the contract which is using\r\n/// its functionality\r\ncontract AllowanceSetter {\r\n    uint256 constant MAX_UINT = 2**256 - 1;\r\n\r\n    /// @notice A function which allows the caller to approve the max amount of any given token\r\n    /// @dev In order to function correctly, token allowances should not be set anywhere else in\r\n    /// the inheriting contract\r\n    /// @param addressToApprove the address which we want to approve to transfer the token\r\n    /// @param token the token address which we want to call approve on\r\n    function approveAddress(address addressToApprove, address token) internal {\r\n        if(ERC20(token).allowance(address(this), addressToApprove) == 0) {\r\n            require(ERC20SafeTransfer.safeApprove(token, addressToApprove, MAX_UINT));\r\n        }\r\n    }\r\n\r\n}\r\n\r\ncontract ErrorReporter {\r\n    function revertTx(string reason) public pure {\r\n        revert(reason);\r\n    }\r\n}\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n  event OwnershipRenounced(address indexed previousOwner);\r\n  event OwnershipTransferred(\r\n    address indexed previousOwner,\r\n    address indexed newOwner\r\n  );\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  constructor() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to relinquish control of the contract.\r\n   * @notice Renouncing to ownership will leave the contract without an owner.\r\n   * It will not be possible to call the functions with the `onlyOwner`\r\n   * modifier anymore.\r\n   */\r\n  function renounceOwnership() public onlyOwner {\r\n    emit OwnershipRenounced(owner);\r\n    owner = address(0);\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address _newOwner) public onlyOwner {\r\n    _transferOwnership(_newOwner);\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function _transferOwnership(address _newOwner) internal {\r\n    require(_newOwner != address(0));\r\n    emit OwnershipTransferred(owner, _newOwner);\r\n    owner = _newOwner;\r\n  }\r\n}\r\n\r\n/// @title A contract which can be used to ensure only the TotlePrimary contract can call\r\n/// some functions\r\n/// @dev Defines a modifier which should be used when only the totle contract should\r\n/// able able to call a function\r\ncontract TotleControl is Ownable {\r\n    mapping(address => bool) public authorizedPrimaries;\r\n\r\n    /// @dev A modifier which only allows code execution if msg.sender equals totlePrimary address\r\n    modifier onlyTotle() {\r\n        require(authorizedPrimaries[msg.sender]);\r\n        _;\r\n    }\r\n\r\n    /// @notice Contract constructor\r\n    /// @dev As this contract inherits ownable, msg.sender will become the contract owner\r\n    /// @param _totlePrimary the address of the contract to be set as totlePrimary\r\n    constructor(address _totlePrimary) public {\r\n        authorizedPrimaries[_totlePrimary] = true;\r\n    }\r\n\r\n    /// @notice A function which allows only the owner to change the address of totlePrimary\r\n    /// @dev onlyOwner modifier only allows the contract owner to run the code\r\n    /// @param _totlePrimary the address of the contract to be set as totlePrimary\r\n    function addTotle(\r\n        address _totlePrimary\r\n    ) external onlyOwner {\r\n        authorizedPrimaries[_totlePrimary] = true;\r\n    }\r\n\r\n    function removeTotle(\r\n        address _totlePrimary\r\n    ) external onlyOwner {\r\n        authorizedPrimaries[_totlePrimary] = false;\r\n    }\r\n}\r\n\r\n/// @title A contract which allows its owner to withdraw any ether which is contained inside\r\ncontract Withdrawable is Ownable {\r\n\r\n    /// @notice Withdraw ether contained in this contract and send it back to owner\r\n    /// @dev onlyOwner modifier only allows the contract owner to run the code\r\n    /// @param _token The address of the token that the user wants to withdraw\r\n    /// @param _amount The amount of tokens that the caller wants to withdraw\r\n    /// @return bool value indicating whether the transfer was successful\r\n    function withdrawToken(address _token, uint256 _amount) external onlyOwner returns (bool) {\r\n        return ERC20SafeTransfer.safeTransfer(_token, owner, _amount);\r\n    }\r\n\r\n    /// @notice Withdraw ether contained in this contract and send it back to owner\r\n    /// @dev onlyOwner modifier only allows the contract owner to run the code\r\n    /// @param _amount The amount of ether that the caller wants to withdraw\r\n    function withdrawETH(uint256 _amount) external onlyOwner {\r\n        owner.transfer(_amount);\r\n    }\r\n}\r\n\r\n/**\r\n * @title Pausable\r\n * @dev Base contract which allows children to implement an emergency stop mechanism.\r\n */\r\ncontract Pausable is Ownable {\r\n  event Paused();\r\n  event Unpaused();\r\n\r\n  bool private _paused = false;\r\n\r\n  /**\r\n   * @return true if the contract is paused, false otherwise.\r\n   */\r\n  function paused() public view returns (bool) {\r\n    return _paused;\r\n  }\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is not paused.\r\n   */\r\n  modifier whenNotPaused() {\r\n    require(!_paused, \"Contract is paused.\");\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is paused.\r\n   */\r\n  modifier whenPaused() {\r\n    require(_paused, \"Contract not paused.\");\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to pause, triggers stopped state\r\n   */\r\n  function pause() public onlyOwner whenNotPaused {\r\n    _paused = true;\r\n    emit Paused();\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to unpause, returns to normal state\r\n   */\r\n  function unpause() public onlyOwner whenPaused {\r\n    _paused = false;\r\n    emit Unpaused();\r\n  }\r\n}\r\n\r\ncontract SelectorProvider {\r\n    bytes4 constant getAmountToGiveSelector = bytes4(keccak256(\"getAmountToGive(bytes)\"));\r\n    bytes4 constant staticExchangeChecksSelector = bytes4(keccak256(\"staticExchangeChecks(bytes)\"));\r\n    bytes4 constant performBuyOrderSelector = bytes4(keccak256(\"performBuyOrder(bytes,uint256)\"));\r\n    bytes4 constant performSellOrderSelector = bytes4(keccak256(\"performSellOrder(bytes,uint256)\"));\r\n\r\n    function getSelector(bytes4 genericSelector) public pure returns (bytes4);\r\n}\r\n\r\n/// @title Interface for all exchange handler contracts\r\ncontract ExchangeHandler is SelectorProvider, TotleControl, Withdrawable, Pausable {\r\n\r\n    /*\r\n    *   State Variables\r\n    */\r\n\r\n    ErrorReporter public errorReporter;\r\n    /* Logger public logger; */\r\n    /*\r\n    *   Modifiers\r\n    */\r\n\r\n    /// @notice Constructor\r\n    /// @dev Calls the constructor of the inherited TotleControl\r\n    /// @param totlePrimary the address of the totlePrimary contract\r\n    constructor(\r\n        address totlePrimary,\r\n        address _errorReporter\r\n        /* ,address _logger */\r\n    )\r\n        TotleControl(totlePrimary)\r\n        public\r\n    {\r\n        require(_errorReporter != address(0x0));\r\n        /* require(_logger != address(0x0)); */\r\n        errorReporter = ErrorReporter(_errorReporter);\r\n        /* logger = Logger(_logger); */\r\n    }\r\n\r\n    /// @notice Gets the amount that Totle needs to give for this order\r\n    /// @param genericPayload the data for this order in a generic format\r\n    /// @return amountToGive amount taker needs to give in order to fill the order\r\n    function getAmountToGive(\r\n        bytes genericPayload\r\n    )\r\n        public\r\n        view\r\n        returns (uint256 amountToGive)\r\n    {\r\n        bool success;\r\n        bytes4 functionSelector = getSelector(this.getAmountToGive.selector);\r\n\r\n        assembly {\r\n            let functionSelectorLength := 0x04\r\n            let functionSelectorOffset := 0x1C\r\n            let scratchSpace := 0x0\r\n            let wordLength := 0x20\r\n            let bytesLength := mload(genericPayload)\r\n            let totalLength := add(functionSelectorLength, bytesLength)\r\n            let startOfNewData := add(genericPayload, functionSelectorOffset)\r\n\r\n            mstore(add(scratchSpace, functionSelectorOffset), functionSelector)\r\n            let functionSelectorCorrect := mload(scratchSpace)\r\n            mstore(genericPayload, functionSelectorCorrect)\r\n\r\n            success := delegatecall(\r\n                            gas,\r\n                            address, // This address of the current contract\r\n                            startOfNewData, // Start data at the beginning of the functionSelector\r\n                            totalLength, // Total length of all data, including functionSelector\r\n                            scratchSpace, // Use the first word of memory (scratch space) to store our return variable.\r\n                            wordLength // Length of return variable is one word\r\n                           )\r\n            amountToGive := mload(scratchSpace)\r\n            if eq(success, 0) { revert(0, 0) }\r\n        }\r\n    }\r\n\r\n    /// @notice Perform exchange-specific checks on the given order\r\n    /// @dev this should be called to check for payload errors\r\n    /// @param genericPayload the data for this order in a generic format\r\n    /// @return checksPassed value representing pass or fail\r\n    function staticExchangeChecks(\r\n        bytes genericPayload\r\n    )\r\n        public\r\n        view\r\n        returns (bool checksPassed)\r\n    {\r\n        bool success;\r\n        bytes4 functionSelector = getSelector(this.staticExchangeChecks.selector);\r\n        assembly {\r\n            let functionSelectorLength := 0x04\r\n            let functionSelectorOffset := 0x1C\r\n            let scratchSpace := 0x0\r\n            let wordLength := 0x20\r\n            let bytesLength := mload(genericPayload)\r\n            let totalLength := add(functionSelectorLength, bytesLength)\r\n            let startOfNewData := add(genericPayload, functionSelectorOffset)\r\n\r\n            mstore(add(scratchSpace, functionSelectorOffset), functionSelector)\r\n            let functionSelectorCorrect := mload(scratchSpace)\r\n            mstore(genericPayload, functionSelectorCorrect)\r\n\r\n            success := delegatecall(\r\n                            gas,\r\n                            address, // This address of the current contract\r\n                            startOfNewData, // Start data at the beginning of the functionSelector\r\n                            totalLength, // Total length of all data, including functionSelector\r\n                            scratchSpace, // Use the first word of memory (scratch space) to store our return variable.\r\n                            wordLength // Length of return variable is one word\r\n                           )\r\n            checksPassed := mload(scratchSpace)\r\n            if eq(success, 0) { revert(0, 0) }\r\n        }\r\n    }\r\n\r\n    /// @notice Perform a buy order at the exchange\r\n    /// @param genericPayload the data for this order in a generic format\r\n    /// @param  amountToGiveForOrder amount that should be spent on this order\r\n    /// @return amountSpentOnOrder the amount that would be spent on the order\r\n    /// @return amountReceivedFromOrder the amount that was received from this order\r\n    function performBuyOrder(\r\n        bytes genericPayload,\r\n        uint256 amountToGiveForOrder\r\n    )\r\n        public\r\n        payable\r\n        returns (uint256 amountSpentOnOrder, uint256 amountReceivedFromOrder)\r\n    {\r\n        bool success;\r\n        bytes4 functionSelector = getSelector(this.performBuyOrder.selector);\r\n        assembly {\r\n            let callDataOffset := 0x44\r\n            let functionSelectorOffset := 0x1C\r\n            let functionSelectorLength := 0x04\r\n            let scratchSpace := 0x0\r\n            let wordLength := 0x20\r\n            let startOfFreeMemory := mload(0x40)\r\n\r\n            calldatacopy(startOfFreeMemory, callDataOffset, calldatasize)\r\n\r\n            let bytesLength := mload(startOfFreeMemory)\r\n            let totalLength := add(add(functionSelectorLength, bytesLength), wordLength)\r\n\r\n            mstore(add(scratchSpace, functionSelectorOffset), functionSelector)\r\n\r\n            let functionSelectorCorrect := mload(scratchSpace)\r\n\r\n            mstore(startOfFreeMemory, functionSelectorCorrect)\r\n\r\n            mstore(add(startOfFreeMemory, add(wordLength, bytesLength)), amountToGiveForOrder)\r\n\r\n            let startOfNewData := add(startOfFreeMemory,functionSelectorOffset)\r\n\r\n            success := delegatecall(\r\n                            gas,\r\n                            address, // This address of the current contract\r\n                            startOfNewData, // Start data at the beginning of the functionSelector\r\n                            totalLength, // Total length of all data, including functionSelector\r\n                            scratchSpace, // Use the first word of memory (scratch space) to store our return variable.\r\n                            mul(wordLength, 0x02) // Length of return variables is two words\r\n                          )\r\n            amountSpentOnOrder := mload(scratchSpace)\r\n            amountReceivedFromOrder := mload(add(scratchSpace, wordLength))\r\n            if eq(success, 0) { revert(0, 0) }\r\n        }\r\n    }\r\n\r\n    /// @notice Perform a sell order at the exchange\r\n    /// @param genericPayload the data for this order in a generic format\r\n    /// @param  amountToGiveForOrder amount that should be spent on this order\r\n    /// @return amountSpentOnOrder the amount that would be spent on the order\r\n    /// @return amountReceivedFromOrder the amount that was received from this order\r\n    function performSellOrder(\r\n        bytes genericPayload,\r\n        uint256 amountToGiveForOrder\r\n    )\r\n        public\r\n        returns (uint256 amountSpentOnOrder, uint256 amountReceivedFromOrder)\r\n    {\r\n        bool success;\r\n        bytes4 functionSelector = getSelector(this.performSellOrder.selector);\r\n        assembly {\r\n            let callDataOffset := 0x44\r\n            let functionSelectorOffset := 0x1C\r\n            let functionSelectorLength := 0x04\r\n            let scratchSpace := 0x0\r\n            let wordLength := 0x20\r\n            let startOfFreeMemory := mload(0x40)\r\n\r\n            calldatacopy(startOfFreeMemory, callDataOffset, calldatasize)\r\n\r\n            let bytesLength := mload(startOfFreeMemory)\r\n            let totalLength := add(add(functionSelectorLength, bytesLength), wordLength)\r\n\r\n            mstore(add(scratchSpace, functionSelectorOffset), functionSelector)\r\n\r\n            let functionSelectorCorrect := mload(scratchSpace)\r\n\r\n            mstore(startOfFreeMemory, functionSelectorCorrect)\r\n\r\n            mstore(add(startOfFreeMemory, add(wordLength, bytesLength)), amountToGiveForOrder)\r\n\r\n            let startOfNewData := add(startOfFreeMemory,functionSelectorOffset)\r\n\r\n            success := delegatecall(\r\n                            gas,\r\n                            address, // This address of the current contract\r\n                            startOfNewData, // Start data at the beginning of the functionSelector\r\n                            totalLength, // Total length of all data, including functionSelector\r\n                            scratchSpace, // Use the first word of memory (scratch space) to store our return variable.\r\n                            mul(wordLength, 0x02) // Length of return variables is two words\r\n                          )\r\n            amountSpentOnOrder := mload(scratchSpace)\r\n            amountReceivedFromOrder := mload(add(scratchSpace, wordLength))\r\n            if eq(success, 0) { revert(0, 0) }\r\n        }\r\n    }\r\n}\r\n\r\ninterface TokenStoreExchange {\r\n\r\n   //Trading\r\n   function trade(address _tokenGet, uint _amountGet, address _tokenGive, uint _amountGive,\r\n       uint _expires, uint _nonce, address _user, uint8 _v, bytes32 _r, bytes32 _s, uint _amount) external;\r\n\r\n   // Get info\r\n   function fee() external constant returns(uint256);\r\n   function availableVolume(address _tokenGet, uint _amountGet, address _tokenGive, uint _amountGive, uint _expires,\r\n       uint _nonce, address _user, uint8 _v, bytes32 _r, bytes32 _s) external constant returns(uint);\r\n\r\n   //Balance deposit/withdraw functions\r\n   function deposit() external payable; //Deposit ETH\r\n   function withdraw(uint256 amount) external; //Withdraw ETH\r\n   function depositToken(address _token, uint _amount) external;\r\n   function withdrawToken(address _token, uint _amount) external;\r\n\r\n}\r\n\r\n/// @title Handler for TokenStore exchange\r\ncontract TokenStoreHandler is ExchangeHandler, AllowanceSetter {\r\n\r\n    /*\r\n    *   Types\r\n    */\r\n    struct OrderData {\r\n        address takerToken; //For a Totle sell, takerToken is the token address\r\n        uint256 takerAmount;\r\n        address makerToken; //For a Totle sell, makerToken is 0x0 (ETH)\r\n        uint256 makerAmount;\r\n        uint256 expires;\r\n        uint256 nonce;\r\n        address user; //Maker\r\n        uint8 v;\r\n        bytes32 r;\r\n        bytes32 s;\r\n    }\r\n\r\n    TokenStoreExchange exchange;\r\n\r\n    /// @notice Constructor\r\n    /// @param _exchange the address of the token store exchange\r\n    /// @param _totlePrimary the address of the totlePrimary contract\r\n    /// @param errorReporter the address of of the errorReporter contract\r\n    constructor(\r\n        address _exchange,\r\n        address _totlePrimary,\r\n        address errorReporter/*,\r\n        address logger*/\r\n    ) ExchangeHandler(_totlePrimary, errorReporter/*, logger*/) public {\r\n        exchange = TokenStoreExchange(_exchange);\r\n    }\r\n\r\n    /*\r\n    *   Internal functions\r\n    */\r\n\r\n    /// @notice Gets the amount that TotlePrimary needs to give for this order\r\n    /// @param data OrderData struct containing order values\r\n    /// @return amountToGive amount taker needs to give in order to fill the order\r\n    function getAmountToGive(\r\n        OrderData data\r\n    )\r\n        public\r\n        view\r\n        whenNotPaused\r\n        onlyTotle\r\n        returns (uint256 amountToGive)\r\n    {\r\n        uint256 feePercentage = exchange.fee();\r\n        uint256 availableVolume = exchange.availableVolume(data.takerToken, data.takerAmount, data.makerToken, data.makerAmount, data.expires,\r\n            data.nonce, data.user, data.v, data.r, data.s);\r\n        uint256 fee = SafeMath.div(SafeMath.mul(availableVolume, feePercentage), 1 ether);\r\n        return SafeMath.add(availableVolume, fee);\r\n    }\r\n\r\n    /// @notice Perform exchange-specific checks on the given order\r\n    /// @dev This should be called to check for payload errors\r\n    /// @param data OrderData struct containing order values\r\n    /// @return checksPassed value representing pass or fail\r\n    function staticExchangeChecks(\r\n        OrderData data\r\n    )\r\n        public\r\n        view\r\n        whenNotPaused\r\n        onlyTotle\r\n        returns (bool checksPassed)\r\n    {\r\n        bytes32 hash = sha256(abi.encodePacked(address(exchange), data.takerToken, data.takerAmount, data.makerToken, data.makerAmount, data.expires, data.nonce));\r\n        if (ecrecover(sha3(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash)), data.v, data.r, data.s) != data.user || block.number > data.expires) {\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /// @dev Perform a buy order at the exchange\r\n    /// @param data OrderData struct containing order values\r\n    /// @param  amountToGiveForOrder amount that should be spent on this order\r\n    /// @return amountSpentOnOrder the amount that would be spent on the order\r\n    /// @return amountReceivedFromOrder the amount that was received from this order\r\n    function performBuyOrder(\r\n        OrderData data,\r\n        uint256 amountToGiveForOrder\r\n    )\r\n        public\r\n        payable\r\n        whenNotPaused\r\n        onlyTotle\r\n        returns (uint256 amountSpentOnOrder, uint256 amountReceivedFromOrder)\r\n    {\r\n        amountSpentOnOrder = amountToGiveForOrder;\r\n        exchange.deposit.value(amountToGiveForOrder)();\r\n        uint256 amountToSpend = removeFee(amountToGiveForOrder);\r\n        amountReceivedFromOrder = SafeMath.div(SafeMath.mul(amountToSpend, data.makerAmount), data.takerAmount);\r\n        exchange.trade(data.takerToken, data.takerAmount, data.makerToken, data.makerAmount, data.expires, data.nonce, data.user, data.v, data.r, data.s, amountToSpend);\r\n        /* logger.log(\"Performing TokenStore buy order arg2: amountSpentOnOrder, arg3: amountReceivedFromOrder\", amountSpentOnOrder, amountReceivedFromOrder);  */\r\n        exchange.withdrawToken(data.makerToken, amountReceivedFromOrder);\r\n        if (!ERC20SafeTransfer.safeTransfer(data.makerToken, msg.sender, amountReceivedFromOrder)){\r\n            errorReporter.revertTx(\"Failed to transfer tokens to totle primary\");\r\n        }\r\n\r\n    }\r\n\r\n    /// @dev Perform a sell order at the exchange\r\n    /// @param data OrderData struct containing order values\r\n    /// @param  amountToGiveForOrder amount that should be spent on this order\r\n    /// @return amountSpentOnOrder the amount that would be spent on the order\r\n    /// @return amountReceivedFromOrder the amount that was received from this order\r\n    function performSellOrder(\r\n        OrderData data,\r\n        uint256 amountToGiveForOrder\r\n    )\r\n        public\r\n        whenNotPaused\r\n        onlyTotle\r\n        returns (uint256 amountSpentOnOrder, uint256 amountReceivedFromOrder)\r\n    {\r\n        amountSpentOnOrder = amountToGiveForOrder;\r\n        approveAddress(address(exchange), data.takerToken);\r\n        exchange.depositToken(data.takerToken, amountToGiveForOrder);\r\n        uint256 amountToSpend = removeFee(amountToGiveForOrder);\r\n        amountReceivedFromOrder = SafeMath.div(SafeMath.mul(amountToSpend, data.makerAmount), data.takerAmount);\r\n        exchange.trade(data.takerToken, data.takerAmount, data.makerToken, data.makerAmount, data.expires, data.nonce, data.user, data.v, data.r, data.s, amountToSpend);\r\n        /* logger.log(\"Performing TokenStore sell order arg2: amountSpentOnOrder, arg3: amountReceivedFromOrder\",amountSpentOnOrder,amountReceivedFromOrder); */\r\n        exchange.withdraw(amountReceivedFromOrder);\r\n        msg.sender.transfer(amountReceivedFromOrder);\r\n    }\r\n\r\n    function removeFee(uint256 totalAmount) internal constant returns (uint256){\r\n      uint256 feePercentage = exchange.fee();\r\n      return SafeMath.div(SafeMath.mul(totalAmount, 1 ether), SafeMath.add(feePercentage, 1 ether));\r\n\r\n    }\r\n\r\n    function getSelector(bytes4 genericSelector) public pure returns (bytes4) {\r\n        if (genericSelector == getAmountToGiveSelector) {\r\n            return bytes4(keccak256(\"getAmountToGive((address,uint256,address,uint256,uint256,uint256,address,uint8,bytes32,bytes32))\"));\r\n        } else if (genericSelector == staticExchangeChecksSelector) {\r\n            return bytes4(keccak256(\"staticExchangeChecks((address,uint256,address,uint256,uint256,uint256,address,uint8,bytes32,bytes32))\"));\r\n        } else if (genericSelector == performBuyOrderSelector) {\r\n            return bytes4(keccak256(\"performBuyOrder((address,uint256,address,uint256,uint256,uint256,address,uint8,bytes32,bytes32),uint256)\"));\r\n        } else if (genericSelector == performSellOrderSelector) {\r\n            return bytes4(keccak256(\"performSellOrder((address,uint256,address,uint256,uint256,uint256,address,uint8,bytes32,bytes32),uint256)\"));\r\n        } else {\r\n            return bytes4(0x0);\r\n        }\r\n    }\r\n\r\n    /// @notice payable fallback to block EOA sending eth\r\n    /// @dev this should fail if an EOA (or contract with 0 bytecode size) tries to send ETH to this contract\r\n    function() public payable {\r\n        // Check in here that the sender is a contract! (to stop accidents)\r\n        uint256 size;\r\n        address sender = msg.sender;\r\n        assembly {\r\n            size := extcodesize(sender)\r\n        }\r\n        require(size > 0);\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"errorReporter\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"components\":[{\"name\":\"takerToken\",\"type\":\"address\"},{\"name\":\"takerAmount\",\"type\":\"uint256\"},{\"name\":\"makerToken\",\"type\":\"address\"},{\"name\":\"makerAmount\",\"type\":\"uint256\"},{\"name\":\"expires\",\"type\":\"uint256\"},{\"name\":\"nonce\",\"type\":\"uint256\"},{\"name\":\"user\",\"type\":\"address\"},{\"name\":\"v\",\"type\":\"uint8\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"data\",\"type\":\"tuple\"},{\"name\":\"amountToGiveForOrder\",\"type\":\"uint256\"}],\"name\":\"performBuyOrder\",\"outputs\":[{\"name\":\"amountSpentOnOrder\",\"type\":\"uint256\"},{\"name\":\"amountReceivedFromOrder\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_totlePrimary\",\"type\":\"address\"}],\"name\":\"addTotle\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"genericPayload\",\"type\":\"bytes\"},{\"name\":\"amountToGiveForOrder\",\"type\":\"uint256\"}],\"name\":\"performSellOrder\",\"outputs\":[{\"name\":\"amountSpentOnOrder\",\"type\":\"uint256\"},{\"name\":\"amountReceivedFromOrder\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"components\":[{\"name\":\"takerToken\",\"type\":\"address\"},{\"name\":\"takerAmount\",\"type\":\"uint256\"},{\"name\":\"makerToken\",\"type\":\"address\"},{\"name\":\"makerAmount\",\"type\":\"uint256\"},{\"name\":\"expires\",\"type\":\"uint256\"},{\"name\":\"nonce\",\"type\":\"uint256\"},{\"name\":\"user\",\"type\":\"address\"},{\"name\":\"v\",\"type\":\"uint8\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"data\",\"type\":\"tuple\"}],\"name\":\"getAmountToGive\",\"outputs\":[{\"name\":\"amountToGive\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdrawToken\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_totlePrimary\",\"type\":\"address\"}],\"name\":\"removeTotle\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"genericPayload\",\"type\":\"bytes\"}],\"name\":\"getAmountToGive\",\"outputs\":[{\"name\":\"amountToGive\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"genericPayload\",\"type\":\"bytes\"}],\"name\":\"staticExchangeChecks\",\"outputs\":[{\"name\":\"checksPassed\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"authorizedPrimaries\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"genericPayload\",\"type\":\"bytes\"},{\"name\":\"amountToGiveForOrder\",\"type\":\"uint256\"}],\"name\":\"performBuyOrder\",\"outputs\":[{\"name\":\"amountSpentOnOrder\",\"type\":\"uint256\"},{\"name\":\"amountReceivedFromOrder\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"genericSelector\",\"type\":\"bytes4\"}],\"name\":\"getSelector\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes4\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"components\":[{\"name\":\"takerToken\",\"type\":\"address\"},{\"name\":\"takerAmount\",\"type\":\"uint256\"},{\"name\":\"makerToken\",\"type\":\"address\"},{\"name\":\"makerAmount\",\"type\":\"uint256\"},{\"name\":\"expires\",\"type\":\"uint256\"},{\"name\":\"nonce\",\"type\":\"uint256\"},{\"name\":\"user\",\"type\":\"address\"},{\"name\":\"v\",\"type\":\"uint8\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"data\",\"type\":\"tuple\"}],\"name\":\"staticExchangeChecks\",\"outputs\":[{\"name\":\"checksPassed\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdrawETH\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"components\":[{\"name\":\"takerToken\",\"type\":\"address\"},{\"name\":\"takerAmount\",\"type\":\"uint256\"},{\"name\":\"makerToken\",\"type\":\"address\"},{\"name\":\"makerAmount\",\"type\":\"uint256\"},{\"name\":\"expires\",\"type\":\"uint256\"},{\"name\":\"nonce\",\"type\":\"uint256\"},{\"name\":\"user\",\"type\":\"address\"},{\"name\":\"v\",\"type\":\"uint8\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"data\",\"type\":\"tuple\"},{\"name\":\"amountToGiveForOrder\",\"type\":\"uint256\"}],\"name\":\"performSellOrder\",\"outputs\":[{\"name\":\"amountSpentOnOrder\",\"type\":\"uint256\"},{\"name\":\"amountReceivedFromOrder\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_exchange\",\"type\":\"address\"},{\"name\":\"_totlePrimary\",\"type\":\"address\"},{\"name\":\"errorReporter\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"}],\"name\":\"OwnershipRenounced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"TokenStoreHandler","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"999","ConstructorArguments":"0000000000000000000000001ce7ae555139c5ef5a57cc8d814a867ee6ee33d800000000000000000000000099eca38b58ceeaf0fed5351df21d5b4c5599531400000000000000000000000076b87390400359941561956632bbbe3f42439e32","Library":"","SwarmSource":"bzzr://63219114969615e6da4d5c3569cd6dd07fdf6605b442ca636a33118d1a885a63"}]}