{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\n// File: contracts/AraProxy.sol\r\n\r\n/**\r\n * @title AraProxy\r\n * @dev Gives the possibility to delegate any call to a foreign implementation.\r\n */\r\ncontract AraProxy {\r\n\r\n  bytes32 private constant registryPosition_ = keccak256(\"io.ara.proxy.registry\");\r\n  bytes32 private constant implementationPosition_ = keccak256(\"io.ara.proxy.implementation\");\r\n\r\n  modifier restricted() {\r\n    bytes32 registryPosition = registryPosition_;\r\n    address registryAddress;\r\n    assembly {\r\n      registryAddress := sload(registryPosition)\r\n    }\r\n    require(\r\n      msg.sender == registryAddress,\r\n      \"Only the AraRegistry can upgrade this proxy.\"\r\n    );\r\n    _;\r\n  }\r\n\r\n  /**\r\n  * @dev the constructor sets the AraRegistry address\r\n  */\r\n  constructor(address _registryAddress, address _implementationAddress) public {\r\n    bytes32 registryPosition = registryPosition_;\r\n    bytes32 implementationPosition = implementationPosition_;\r\n    assembly {\r\n      sstore(registryPosition, _registryAddress)\r\n      sstore(implementationPosition, _implementationAddress)\r\n    }\r\n  }\r\n\r\n  function setImplementation(address _newImplementation) public restricted {\r\n    require(_newImplementation != address(0));\r\n    bytes32 implementationPosition = implementationPosition_;\r\n    assembly {\r\n      sstore(implementationPosition, _newImplementation)\r\n    }\r\n  }\r\n\r\n  /**\r\n  * @dev Fallback function allowing to perform a delegatecall to the given implementation.\r\n  * This function will return whatever the implementation call returns\r\n  */\r\n  function () payable public {\r\n    bytes32 implementationPosition = implementationPosition_;\r\n    address _impl;\r\n    assembly {\r\n      _impl := sload(implementationPosition)\r\n    }\r\n\r\n    assembly {\r\n      let ptr := mload(0x40)\r\n      calldatacopy(ptr, 0, calldatasize)\r\n      let result := delegatecall(gas, _impl, ptr, calldatasize, 0, 0)\r\n      let size := returndatasize\r\n      returndatacopy(ptr, 0, size)\r\n\r\n      switch result\r\n      case 0 { revert(ptr, size) }\r\n      default { return(ptr, size) }\r\n    }\r\n  }\r\n}\r\n\r\n// File: contracts/AraRegistry.sol\r\n\r\ncontract AraRegistry {\r\n  address public owner_;\r\n  mapping (bytes32 => UpgradeableContract) private contracts_; // keccak256(contractname) => struct\r\n\r\n  struct UpgradeableContract {\r\n    bool initialized_;\r\n\r\n    address proxy_;\r\n    string latestVersion_;\r\n    mapping (string => address) versions_;\r\n  }\r\n\r\n  event UpgradeableContractAdded(bytes32 _contractName, string _version, address _address);\r\n  event ContractUpgraded(bytes32 _contractName, string _version, address _address);\r\n  event ProxyDeployed(bytes32 _contractName, address _address);\r\n\r\n  constructor() public {\r\n    owner_ = msg.sender;\r\n  }\r\n\r\n  modifier restricted() {\r\n    require (\r\n      msg.sender == owner_,\r\n      \"Sender not authorized.\"\r\n    );\r\n    _;\r\n  }\r\n\r\n  function getLatestVersionAddress(bytes32 _contractName) public view returns (address) {\r\n    return contracts_[_contractName].versions_[contracts_[_contractName].latestVersion_];\r\n  }\r\n\r\n  function getUpgradeableContractAddress(bytes32 _contractName, string _version) public view returns (address) {\r\n    return contracts_[_contractName].versions_[_version];\r\n  }\r\n\r\n  function addNewUpgradeableContract(bytes32 _contractName, string _version, bytes _code, bytes _data) public restricted {\r\n    require(!contracts_[_contractName].initialized_, \"Upgradeable contract already exists. Try upgrading instead.\");\r\n    address deployedAddress;\r\n    assembly {\r\n      deployedAddress := create(0, add(_code, 0x20), mload(_code))\r\n    }\r\n\r\n    contracts_[_contractName].initialized_ = true;\r\n    contracts_[_contractName].latestVersion_ = _version;\r\n    contracts_[_contractName].versions_[_version] = deployedAddress;\r\n    _deployProxy(_contractName, deployedAddress, _data);\r\n\r\n    emit UpgradeableContractAdded(_contractName, _version, deployedAddress);\r\n  }\r\n\r\n  function upgradeContract(bytes32 _contractName, string _version, bytes _code) public restricted {\r\n    require(contracts_[_contractName].initialized_, \"Upgradeable contract must exist before it can be upgraded. Try adding one instead.\");\r\n    address deployedAddress;\r\n    assembly {\r\n      deployedAddress := create(0, add(_code, 0x20), mload(_code))\r\n    }\r\n\r\n    AraProxy proxy = AraProxy(contracts_[_contractName].proxy_);\r\n    proxy.setImplementation(deployedAddress);\r\n\r\n    contracts_[_contractName].latestVersion_ = _version;\r\n    contracts_[_contractName].versions_[_version] = deployedAddress;\r\n\r\n    emit ContractUpgraded(_contractName, _version, deployedAddress);\r\n  }\r\n\r\n  function _deployProxy(bytes32 _contractName, address _implementationAddress, bytes _data) private {\r\n    require(contracts_[_contractName].proxy_ == address(0), \"Only one proxy can exist per upgradeable contract.\");\r\n    AraProxy proxy = new AraProxy(address(this), _implementationAddress);\r\n    require(address(proxy).call(abi.encodeWithSignature(\"init(bytes)\", _data)), \"Init failed.\");\r\n    contracts_[_contractName].proxy_ = proxy;\r\n\r\n    emit ProxyDeployed(_contractName, proxy);\r\n  }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_contractName\",\"type\":\"bytes32\"},{\"name\":\"_version\",\"type\":\"string\"},{\"name\":\"_code\",\"type\":\"bytes\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"addNewUpgradeableContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_contractName\",\"type\":\"bytes32\"}],\"name\":\"getLatestVersionAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_contractName\",\"type\":\"bytes32\"},{\"name\":\"_version\",\"type\":\"string\"},{\"name\":\"_code\",\"type\":\"bytes\"}],\"name\":\"upgradeContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner_\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_contractName\",\"type\":\"bytes32\"},{\"name\":\"_version\",\"type\":\"string\"}],\"name\":\"getUpgradeableContractAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_contractName\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"_version\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"UpgradeableContractAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_contractName\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"_version\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"ContractUpgraded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_contractName\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"ProxyDeployed\",\"type\":\"event\"}]","ContractName":"AraRegistry","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://7d3419398c4d599785e79eecefec172631e086031ce6074caf141272207de308"}]}