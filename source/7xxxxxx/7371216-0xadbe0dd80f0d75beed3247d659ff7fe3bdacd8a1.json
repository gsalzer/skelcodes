{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.25;\r\npragma experimental ABIEncoderV2;\r\npragma experimental \"v0.5.0\";\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that revert on error\r\n * https://github.com/OpenZeppelin/openzeppelin-solidity/blob/d17ae0b806b2f8e69b291284bbf30321640609e3/contracts/math/SafeMath.sol\r\n */\r\nlibrary SafeMath {\r\n\tint256 constant private INT256_MIN = -2**255;\r\n\r\n\t/**\r\n\t* @dev Multiplies two unsigned integers, reverts on overflow.\r\n\t*/\r\n\tfunction mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\t\t// Gas optimization: this is cheaper than requiring 'a' not being zero, but the benefit is lost if 'b' is also tested.\r\n\t\t// See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n\t\tif (a == 0) {\r\n\t\t\treturn 0;\r\n\t\t}\r\n\r\n\t\tuint256 c = a * b;\r\n\t\trequire(c / a == b);\r\n\r\n\t\treturn c;\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Multiplies two signed integers, reverts on overflow.\r\n\t*/\r\n\tfunction mul(int256 a, int256 b) internal pure returns (int256) {\r\n\t\t// Gas optimization: this is cheaper than requiring 'a' not being zero, but the benefit is lost if 'b' is also tested.\r\n\t\t// See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n\t\tif (a == 0) {\r\n\t\t\treturn 0;\r\n\t\t}\r\n\r\n\t\trequire(!(a == -1 && b == INT256_MIN)); // This is the only case of overflow not detected by the check below\r\n\r\n\t\tint256 c = a * b;\r\n\t\trequire(c / a == b);\r\n\r\n\t\treturn c;\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\r\n\t*/\r\n\tfunction div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\t\t// Solidity only automatically asserts when dividing by 0\r\n\t\trequire(b > 0);\r\n\t\tuint256 c = a / b;\r\n\t\t// assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n\t\treturn c;\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Integer division of two signed integers truncating the quotient, reverts on division by zero.\r\n\t*/\r\n\tfunction div(int256 a, int256 b) internal pure returns (int256) {\r\n\t\trequire(b != 0); // Solidity only automatically asserts when dividing by 0\r\n\t\trequire(!(b == -1 && a == INT256_MIN)); // This is the only case of overflow\r\n\r\n\t\tint256 c = a / b;\r\n\r\n\t\treturn c;\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n\t*/\r\n\tfunction sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\t\trequire(b <= a);\r\n\t\tuint256 c = a - b;\r\n\r\n\t\treturn c;\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Subtracts two signed integers, reverts on overflow.\r\n\t*/\r\n\tfunction sub(int256 a, int256 b) internal pure returns (int256) {\r\n\t\tint256 c = a - b;\r\n\t\trequire((b >= 0 && c <= a) || (b < 0 && c > a));\r\n\r\n\t\treturn c;\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Adds two unsigned integers, reverts on overflow.\r\n\t*/\r\n\tfunction add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\t\tuint256 c = a + b;\r\n\t\trequire(c >= a);\r\n\r\n\t\treturn c;\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Adds two signed integers, reverts on overflow.\r\n\t*/\r\n\tfunction add(int256 a, int256 b) internal pure returns (int256) {\r\n\t\tint256 c = a + b;\r\n\t\trequire((b >= 0 && c >= a) || (b < 0 && c < a));\r\n\r\n\t\treturn c;\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo), reverts when dividing by zero.\r\n\t*/\r\n\tfunction mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\t\trequire(b != 0);\r\n\t\treturn a % b;\r\n\t}\r\n}\r\n\r\n/**\r\n* @title Convenience and rounding functions when dealing with numbers already factored by 10**18 or 10**27\r\n* @dev Math operations with safety checks that throw on error\r\n* https://github.com/dapphub/ds-math/blob/87bef2f67b043819b7195ce6df3058bd3c321107/src/math.sol\r\n*/\r\nlibrary SafeMathFixedPoint {\r\n\tusing SafeMath for uint256;\r\n\r\n\tfunction mul27(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n\t\tz = x.mul(y).add(5 * 10**26).div(10**27);\r\n\t}\r\n\tfunction mul18(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n\t\tz = x.mul(y).add(5 * 10**17).div(10**18);\r\n\t}\r\n\r\n\tfunction div18(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n\t\tz = x.mul(10**18).add(y.div(2)).div(y);\r\n\t}\r\n\tfunction div27(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n\t\tz = x.mul(10**27).add(y.div(2)).div(y);\r\n\t}\r\n}\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/179\r\n * https://github.com/OpenZeppelin/openzeppelin-solidity/blob/master/contracts/token/ERC20/ERC20Basic.sol\r\n */\r\ncontract ERC20Basic {\r\n\tfunction totalSupply() public view returns (uint256);\r\n\tfunction balanceOf(address who) public view returns (uint256);\r\n\tfunction transfer(address to, uint256 value) public returns (bool);\r\n\tevent Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n * https://github.com/OpenZeppelin/openzeppelin-solidity/blob/master/contracts/token/ERC20/ERC20.sol\r\n */\r\ncontract ERC20 is ERC20Basic {\r\n\tfunction allowance(address owner, address spender) public view returns (uint256);\r\n\tfunction transferFrom(address from, address to, uint256 value) public returns (bool);\r\n\tfunction approve(address spender, uint256 value) public returns (bool);\r\n\tevent Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n * https://github.com/OpenZeppelin/openzeppelin-solidity/blob/master/contracts/ownership/Ownable.sol\r\n */\r\ncontract Ownable {\r\n\taddress public owner;\r\n\r\n\tevent OwnershipRenounced(address indexed previousOwner);\r\n\tevent OwnershipTransferred(\r\n\t\taddress indexed previousOwner,\r\n\t\taddress indexed newOwner\r\n\t);\r\n\r\n\t/**\r\n\t * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n\t * account.\r\n\t */\r\n\tconstructor() public {\r\n\t\towner = msg.sender;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Throws if called by any account other than the owner.\r\n\t */\r\n\tmodifier onlyOwner() {\r\n\t\trequire(msg.sender == owner);\r\n\t\t_;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n\t * @param newOwner The address to transfer ownership to.\r\n\t */\r\n\tfunction transferOwnership(address newOwner) public onlyOwner {\r\n\t\trequire(newOwner != address(0));\r\n\t\temit OwnershipTransferred(owner, newOwner);\r\n\t\towner = newOwner;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Allows the current owner to relinquish control of the contract.\r\n\t */\r\n\tfunction renounceOwnership() public onlyOwner {\r\n\t\temit OwnershipRenounced(owner);\r\n\t\towner = address(0);\r\n\t}\r\n}\r\n\r\n/**\r\n * @title Claimable\r\n * @dev Extension for the Ownable contract, where the ownership needs to be claimed.\r\n * This allows the new owner to accept the transfer.\r\n * https://github.com/OpenZeppelin/openzeppelin-solidity/blob/master/contracts/ownership/Claimable.sol\r\n */\r\ncontract Claimable is Ownable {\r\n\taddress public pendingOwner;\r\n\r\n\t/**\r\n\t * @dev Modifier throws if called by any account other than the pendingOwner.\r\n\t */\r\n\tmodifier onlyPendingOwner() {\r\n\t\trequire(msg.sender == pendingOwner);\r\n\t\t_;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Allows the current owner to set the pendingOwner address.\r\n\t * @param newOwner The address to transfer ownership to.\r\n\t */\r\n\tfunction transferOwnership(address newOwner) onlyOwner public {\r\n\t\tpendingOwner = newOwner;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Allows the pendingOwner address to finalize the transfer.\r\n\t */\r\n\tfunction claimOwnership() onlyPendingOwner public {\r\n\t\temit OwnershipTransferred(owner, pendingOwner);\r\n\t\towner = pendingOwner;\r\n\t\tpendingOwner = address(0);\r\n\t}\r\n}\r\n\r\n/**\r\n * @title Pausable\r\n * @dev Base contract which allows children to implement an emergency stop mechanism.\r\n * https://github.com/OpenZeppelin/openzeppelin-solidity/blob/master/contracts/lifecycle/Pausable.sol\r\n */\r\ncontract Pausable is Ownable {\r\n\tevent Pause();\r\n\tevent Unpause();\r\n\r\n\tbool public paused = false;\r\n\r\n\r\n\t/**\r\n\t * @dev Modifier to make a function callable only when the contract is not paused.\r\n\t */\r\n\tmodifier whenNotPaused() {\r\n\t\trequire(!paused);\r\n\t\t_;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Modifier to make a function callable only when the contract is paused.\r\n\t */\r\n\tmodifier whenPaused() {\r\n\t\trequire(paused);\r\n\t\t_;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev called by the owner to pause, triggers stopped state\r\n\t */\r\n\tfunction pause() onlyOwner whenNotPaused public {\r\n\t\tpaused = true;\r\n\t\temit Pause();\r\n\t}\r\n\r\n\t/**\r\n\t * @dev called by the owner to unpause, returns to normal state\r\n\t */\r\n\tfunction unpause() onlyOwner whenPaused public {\r\n\t\tpaused = false;\r\n\t\temit Unpause();\r\n\t}\r\n}\r\n\r\ncontract Dai is ERC20 {\r\n\r\n}\r\n\r\ncontract Weth is ERC20 {\r\n\tfunction deposit() public payable;\r\n\tfunction withdraw(uint wad) public;\r\n}\r\n\r\ncontract Mkr is ERC20 {\r\n\r\n}\r\n\r\ncontract Peth is ERC20 {\r\n\r\n}\r\n\r\ncontract MatchingMarket {\r\n\tfunction getBuyAmount(ERC20 tokenToBuy, ERC20 tokenToPay, uint256 amountToPay) external view returns(uint256 amountBought);\r\n\tfunction getPayAmount(ERC20 tokenToPay, ERC20 tokenToBuy, uint amountToBuy) public constant returns (uint amountPaid);\r\n\tfunction getBestOffer(ERC20 sell_gem, ERC20 buy_gem) public constant returns(uint offerId);\r\n\tfunction getWorseOffer(uint id) public constant returns(uint offerId);\r\n\tfunction getOffer(uint id) public constant returns (uint pay_amt, ERC20 pay_gem, uint buy_amt, ERC20 buy_gem);\r\n\tfunction sellAllAmount(ERC20 pay_gem, uint pay_amt, ERC20 buy_gem, uint min_fill_amount) public returns (uint fill_amt);\r\n\tfunction buyAllAmount(ERC20 buy_gem, uint buy_amt, ERC20 pay_gem, uint max_fill_amount) public returns (uint fill_amt);\r\n}\r\n\r\ncontract DSValue {\r\n\tfunction read() external view returns(bytes32);\r\n}\r\n\r\ncontract Maker {\r\n\tfunction sai() external view returns(Dai);\r\n\tfunction gem() external view returns(Weth);\r\n\tfunction gov() external view returns(Mkr);\r\n\tfunction skr() external view returns(Peth);\r\n\tfunction pip() external view returns(DSValue);\r\n\tfunction pep() external view returns(DSValue);\r\n\r\n\t// Join-Exit Spread\r\n\t uint256 public gap;\r\n\r\n\tstruct Cup {\r\n\t\t// CDP owner\r\n\t\taddress lad;\r\n\t\t// Locked collateral (in SKR)\r\n\t\tuint256 ink;\r\n\t\t// Outstanding normalised debt (tax only)\r\n\t\tuint256 art;\r\n\t\t// Outstanding normalised debt\r\n\t\tuint256 ire;\r\n\t}\r\n\r\n\tuint256 public cupi;\r\n\tmapping (bytes32 => Cup) public cups;\r\n\r\n\tfunction lad(bytes32 cup) public view returns (address);\r\n\tfunction per() public view returns (uint ray);\r\n\tfunction tab(bytes32 cup) public returns (uint);\r\n\tfunction ink(bytes32 cup) public returns (uint);\r\n\tfunction rap(bytes32 cup) public returns (uint);\r\n\tfunction chi() public returns (uint);\r\n\r\n\tfunction open() public returns (bytes32 cup);\r\n\tfunction give(bytes32 cup, address guy) public;\r\n\tfunction lock(bytes32 cup, uint wad) public;\r\n\tfunction free(bytes32 cup, uint wad) public;\r\n\tfunction draw(bytes32 cup, uint wad) public;\r\n\tfunction join(uint wad) public;\r\n\tfunction exit(uint wad) public;\r\n\tfunction wipe(bytes32 cup, uint wad) public;\r\n}\r\n\r\ncontract DSProxy {\r\n\t// Technically from DSAuth\r\n\taddress public owner;\r\n\r\n\tfunction execute(address _target, bytes _data) public payable returns (bytes32 response);\r\n}\r\n\r\ncontract ProxyRegistry {\r\n\tmapping(address => DSProxy) public proxies;\r\n\tfunction build(address owner) public returns (DSProxy proxy);\r\n}\r\n\r\ncontract LiquidLong is Ownable, Claimable, Pausable {\r\n\tusing SafeMath for uint256;\r\n\tusing SafeMathFixedPoint for uint256;\r\n\r\n\tuint256 public providerFeePerEth;\r\n\r\n\tMatchingMarket public matchingMarket;\r\n\tMaker public maker;\r\n\tDai public dai;\r\n\tWeth public weth;\r\n\tPeth public peth;\r\n\tMkr public mkr;\r\n\r\n\tProxyRegistry public proxyRegistry;\r\n\r\n\tstruct CDP {\r\n\t\tuint256 id;\r\n\t\tuint256 debtInAttodai;\r\n\t\tuint256 lockedAttoeth;\r\n\t\taddress owner;\r\n\t\tbool userOwned;\r\n\t}\r\n\r\n\tevent NewCup(address user, uint256 cup);\r\n\tevent CloseCup(address user, uint256 cup);\r\n\r\n\tconstructor(MatchingMarket _matchingMarket, Maker _maker, ProxyRegistry _proxyRegistry) public payable {\r\n\t\tproviderFeePerEth = 0.01 ether;\r\n\r\n\t\tmatchingMarket = _matchingMarket;\r\n\t\tmaker = _maker;\r\n\t\tdai = maker.sai();\r\n\t\tweth = maker.gem();\r\n\t\tpeth = maker.skr();\r\n\t\tmkr = maker.gov();\r\n\r\n\t\t// MatchingMarket buy/sell\r\n\t\tdai.approve(address(_matchingMarket), uint256(-1));\r\n\t\tweth.approve(address(_matchingMarket), uint256(-1));\r\n\t\t// Wipe\r\n\t\tdai.approve(address(_maker), uint256(-1));\r\n\t\tmkr.approve(address(_maker), uint256(-1));\r\n\t\t// Join\r\n\t\tweth.approve(address(_maker), uint256(-1));\r\n\t\t// Lock\r\n\t\tpeth.approve(address(_maker), uint256(-1));\r\n\r\n\t\tproxyRegistry = _proxyRegistry;\r\n\r\n\t\tif (msg.value > 0) {\r\n\t\t\tweth.deposit.value(msg.value)();\r\n\t\t}\r\n\t}\r\n\r\n\t// Receive ETH from WETH withdraw\r\n\tfunction () external payable {\r\n\t}\r\n\r\n\tfunction wethDeposit() public payable {\r\n\t\tweth.deposit.value(msg.value)();\r\n\t}\r\n\r\n\tfunction wethWithdraw(uint256 _amount) public onlyOwner {\r\n\t\tweth.withdraw(_amount);\r\n\t\towner.transfer(_amount);\r\n\t}\r\n\r\n\tfunction attowethBalance() public view returns (uint256 _attoweth) {\r\n\t\treturn weth.balanceOf(address(this));\r\n\t}\r\n\r\n\tfunction ethWithdraw() public onlyOwner {\r\n\t\tuint256 _amount = address(this).balance;\r\n\t\towner.transfer(_amount);\r\n\t}\r\n\r\n\tfunction transferTokens(ERC20 _token) public onlyOwner {\r\n\t\t_token.transfer(owner, _token.balanceOf(this));\r\n\t}\r\n\r\n\tfunction ethPriceInUsd() public view returns (uint256 _attousd) {\r\n\t\treturn uint256(maker.pip().read());\r\n\t}\r\n\r\n\tfunction estimateDaiSaleProceeds(uint256 _attodaiToSell) public view returns (uint256 _daiPaid, uint256 _wethBought) {\r\n\t\treturn getPayPriceAndAmount(dai, weth, _attodaiToSell);\r\n\t}\r\n\r\n\t// buy/pay are from the perspective of the taker/caller (MatchingMarket contracts use buy/pay terminology from perspective of the maker)\r\n\tfunction getPayPriceAndAmount(ERC20 _payGem, ERC20 _buyGem, uint256 _payDesiredAmount) public view returns (uint256 _paidAmount, uint256 _boughtAmount) {\r\n\t\tuint256 _offerId = matchingMarket.getBestOffer(_buyGem, _payGem);\r\n\t\twhile (_offerId != 0) {\r\n\t\t\tuint256 _payRemaining = _payDesiredAmount.sub(_paidAmount);\r\n\t\t\t(uint256 _buyAvailableInOffer,  , uint256 _payAvailableInOffer,) = matchingMarket.getOffer(_offerId);\r\n\t\t\tif (_payRemaining <= _payAvailableInOffer) {\r\n\t\t\t\tuint256 _buyRemaining = _payRemaining.mul(_buyAvailableInOffer).div(_payAvailableInOffer);\r\n\t\t\t\t_paidAmount = _paidAmount.add(_payRemaining);\r\n\t\t\t\t_boughtAmount = _boughtAmount.add(_buyRemaining);\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\t_paidAmount = _paidAmount.add(_payAvailableInOffer);\r\n\t\t\t_boughtAmount = _boughtAmount.add(_buyAvailableInOffer);\r\n\t\t\t_offerId = matchingMarket.getWorseOffer(_offerId);\r\n\t\t}\r\n\t\treturn (_paidAmount, _boughtAmount);\r\n\t}\r\n\r\n\tfunction estimateDaiPurchaseCosts(uint256 _attodaiToBuy) public view returns (uint256 _wethPaid, uint256 _daiBought) {\r\n\t\treturn getBuyPriceAndAmount(weth, dai, _attodaiToBuy);\r\n\t}\r\n\r\n\t// buy/pay are from the perspective of the taker/caller (MatchingMarket contracts use buy/pay terminology from perspective of the maker)\r\n\tfunction getBuyPriceAndAmount(ERC20 _payGem, ERC20 _buyGem, uint256 _buyDesiredAmount) public view returns (uint256 _paidAmount, uint256 _boughtAmount) {\r\n\t\tuint256 _offerId = matchingMarket.getBestOffer(_buyGem, _payGem);\r\n\t\twhile (_offerId != 0) {\r\n\t\t\tuint256 _buyRemaining = _buyDesiredAmount.sub(_boughtAmount);\r\n\t\t\t(uint256 _buyAvailableInOffer, , uint256 _payAvailableInOffer,) = matchingMarket.getOffer(_offerId);\r\n\t\t\tif (_buyRemaining <= _buyAvailableInOffer) {\r\n\t\t\t\t// TODO: verify this logic is correct\r\n\t\t\t\tuint256 _payRemaining = _buyRemaining.mul(_payAvailableInOffer).div(_buyAvailableInOffer);\r\n\t\t\t\t_paidAmount = _paidAmount.add(_payRemaining);\r\n\t\t\t\t_boughtAmount = _boughtAmount.add(_buyRemaining);\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\t_paidAmount = _paidAmount.add(_payAvailableInOffer);\r\n\t\t\t_boughtAmount = _boughtAmount.add(_buyAvailableInOffer);\r\n\t\t\t_offerId = matchingMarket.getWorseOffer(_offerId);\r\n\t\t}\r\n\t\treturn (_paidAmount, _boughtAmount);\r\n\t}\r\n\r\n\tmodifier wethBalanceIncreased() {\r\n\t\tuint256 _startingAttowethBalance = weth.balanceOf(this);\r\n\t\t_;\r\n\t\trequire(weth.balanceOf(this) > _startingAttowethBalance);\r\n\t}\r\n\r\n\t// TODO: change affiliate fee to be 50% of service fee, no parameter needed\r\n\tfunction openCdp(uint256 _leverage, uint256 _leverageSizeInAttoeth, uint256 _allowedFeeInAttoeth, address _affiliateAddress) public payable wethBalanceIncreased returns (bytes32 _cdpId) {\r\n\t\trequire(_leverage >= 100 && _leverage <= 300);\r\n\t\tuint256 _lockedInCdpInAttoeth = _leverageSizeInAttoeth.mul(_leverage).div(100);\r\n\t\tuint256 _loanInAttoeth = _lockedInCdpInAttoeth.sub(_leverageSizeInAttoeth);\r\n\t\tuint256 _feeInAttoeth = _loanInAttoeth.mul18(providerFeePerEth);\r\n\t\trequire(_feeInAttoeth <= _allowedFeeInAttoeth);\r\n\t\tuint256 _drawInAttodai = _loanInAttoeth.mul18(uint256(maker.pip().read()));\r\n\t\tuint256 _attopethLockedInCdp = _lockedInCdpInAttoeth.div27(maker.per());\r\n\r\n\t\t// Convert all incoming eth to weth (we will pay back later if too much)\r\n\t\tweth.deposit.value(msg.value)();\r\n\t\t// Open CDP\r\n\t\t_cdpId = maker.open();\r\n\t\t// Convert WETH into PETH\r\n\t\tmaker.join(_attopethLockedInCdp);\r\n\t\t// Store PETH in CDP\r\n\t\tmaker.lock(_cdpId, _attopethLockedInCdp);\r\n\t\t// Withdraw DAI from CDP\r\n\t\tmaker.draw(_cdpId, _drawInAttodai);\r\n\t\t// Sell DAI for WETH\r\n\t\tsellDai(_drawInAttodai, _lockedInCdpInAttoeth, _feeInAttoeth);\r\n\t\t// Pay provider fee\r\n\t\tif (_affiliateAddress != address(0)) {\r\n\t\t\t// Fee charged is constant. If affiliate provided, split fee with affiliate\r\n\t\t\t// Don't bother sending eth to owner, the owner has all non-async-sent eth anyway\r\n\t\t\tweth.transfer(_affiliateAddress, _feeInAttoeth.div(2));\r\n\t\t}\r\n\r\n\t\temit NewCup(msg.sender, uint256(_cdpId));\r\n\r\n\t\tgiveCdpToProxy(msg.sender, _cdpId);\r\n\t}\r\n\r\n\tfunction giveCdpToProxy(address _ownerOfProxy, bytes32 _cdpId) private {\r\n\t\tDSProxy _proxy = proxyRegistry.proxies(_ownerOfProxy);\r\n\t\tif (_proxy == DSProxy(0) || _proxy.owner() != _ownerOfProxy) {\r\n\t\t\t_proxy = proxyRegistry.build(_ownerOfProxy);\r\n\t\t}\r\n\t\t// Send the CDP to the owner's proxy instead of directly to owner\r\n\t\tmaker.give(_cdpId, _proxy);\r\n\t}\r\n\r\n\t// extracted function to mitigate stack depth issues\r\n\tfunction sellDai(uint256 _drawInAttodai, uint256 _lockedInCdpInAttoeth, uint256 _feeInAttoeth) private {\r\n\t\tuint256 _wethBoughtInAttoweth = matchingMarket.sellAllAmount(dai, _drawInAttodai, weth, 0);\r\n\t\t// SafeMath failure below catches not enough eth provided\r\n\t\tuint256 _refundDue = msg.value.add(_wethBoughtInAttoweth).sub(_lockedInCdpInAttoeth).sub(_feeInAttoeth);\r\n\t\tif (_refundDue > 0) {\r\n\t\t\tweth.withdraw(_refundDue);\r\n\t\t\trequire(msg.sender.call.value(_refundDue)());\r\n\t\t}\r\n\t}\r\n\r\n\t// closeCdp is intended to be a delegate call that executes as a user's DSProxy\r\n\tfunction closeCdp(LiquidLong _liquidLong, uint256 _cdpId, uint256 _minimumValueInAttoeth) external returns (uint256 _payoutOwnerInAttoeth) {\r\n\t\taddress _owner = DSProxy(this).owner();\r\n\t\tuint256 _startingAttoethBalance = _owner.balance;\r\n\r\n\t\t// This is delegated, we cannot use storage\r\n\t\tMaker _maker = _liquidLong.maker();\r\n\r\n\t\t// if the CDP is already empty, early return (this allows this method to be called off-chain to check estimated payout and not fail for empty CDPs)\r\n\t\tuint256 _lockedPethInAttopeth = _maker.ink(bytes32(_cdpId));\r\n\t\tif (_lockedPethInAttopeth == 0) return 0;\r\n\r\n\t\t_maker.give(bytes32(_cdpId), _liquidLong);\r\n\t\t_payoutOwnerInAttoeth = _liquidLong.closeGiftedCdp(bytes32(_cdpId), _minimumValueInAttoeth, _owner);\r\n\r\n\t\trequire(_maker.lad(bytes32(_cdpId)) == address(this));\r\n\t\trequire(_owner.balance > _startingAttoethBalance);\r\n\t\treturn _payoutOwnerInAttoeth;\r\n\t}\r\n\r\n\t// Close cdp that was just received as part of the same transaction\r\n\tfunction closeGiftedCdp(bytes32 _cdpId, uint256 _minimumValueInAttoeth, address _recipient) external wethBalanceIncreased returns (uint256 _payoutOwnerInAttoeth) {\r\n\t\trequire(_recipient != address(0));\r\n\t\tuint256 _lockedPethInAttopeth = maker.ink(_cdpId);\r\n\t\tuint256 _debtInAttodai = maker.tab(_cdpId);\r\n\r\n\t\t// Calculate what we need to claim out of the CDP in Weth\r\n\t\tuint256 _lockedWethInAttoweth = _lockedPethInAttopeth.div27(maker.per());\r\n\r\n\t\t// Buy DAI and wipe the entire CDP\r\n\t\t// Pass in _lockedWethInAttoweth as \"max fill amount\". If buying DAI costs more in eth than the entire CDP has locked up, revert (we will fail later anyway)\r\n\t\tuint256 _wethSoldInAttoweth = matchingMarket.buyAllAmount(dai, _debtInAttodai, weth, _lockedWethInAttoweth);\r\n\t\tuint256 _providerFeeInAttoeth = _wethSoldInAttoweth.mul18(providerFeePerEth);\r\n\r\n\t\t// Calculating governance fee is difficult and gas-intense. Just look up how wiping impacts balance\r\n\t\t// Then convert that difference into weth, the only asset we charge in. This will require loading up\r\n\t\t// mkr periodically\r\n\t\tuint256 _mkrBalanceBeforeInAttomkr = mkr.balanceOf(this);\r\n\t\tmaker.wipe(_cdpId, _debtInAttodai);\r\n\t\tuint256 _mkrBurnedInAttomkr = _mkrBalanceBeforeInAttomkr.sub(mkr.balanceOf(this));\r\n\t\tuint256 _ethValueOfBurnedMkrInAttoeth = _mkrBurnedInAttomkr.mul(uint256(maker.pep().read())) // converts Mkr to DAI\r\n\t\t\t.div(uint256(maker.pip().read())); // converts DAI to ETH\r\n\r\n\t\t// Relying on safe-math to revert a situation where LiquidLong would lose weth\r\n\t\t_payoutOwnerInAttoeth = _lockedWethInAttoweth.sub(_wethSoldInAttoweth).sub(_providerFeeInAttoeth).sub(_ethValueOfBurnedMkrInAttoeth);\r\n\r\n\t\t// Ensure remaining peth in CDP is greater than the value they requested as minimum value\r\n\t\trequire(_payoutOwnerInAttoeth >= _minimumValueInAttoeth);\r\n\r\n\t\t// Pull that value from the CDP, convert it back to WETH for next time\r\n\t\t// We rely on \"free\" reverting the transaction if there is not enough peth to profitably close CDP\r\n\t\tmaker.free(_cdpId, _lockedPethInAttopeth);\r\n\t\tmaker.exit(_lockedPethInAttopeth);\r\n\r\n\t\t// DSProxy (or other proxy?) will have issued this request, send it back to the proxy contract. CDP is empty and valueless\r\n\t\tmaker.give(_cdpId, msg.sender);\r\n\r\n\t\tweth.withdraw(_payoutOwnerInAttoeth);\r\n\t\trequire(_recipient.call.value(_payoutOwnerInAttoeth)());\r\n\t\temit CloseCup(msg.sender, uint256(_cdpId));\r\n\t}\r\n\r\n\t// Retrieve CDPs by EFFECTIVE owner, which address owns the DSProxy which owns the CDPs\r\n\tfunction getCdps(address _owner, uint32 _offset, uint32 _pageSize) public returns (CDP[] _cdps) {\r\n\t\t// resolve a owner to a proxy, then query by that proxy\r\n\t\tDSProxy _cdpProxy = proxyRegistry.proxies(_owner);\r\n\t\trequire(_cdpProxy != address(0));\r\n\t\treturn getCdpsByAddresses(_owner, _cdpProxy, _offset, _pageSize);\r\n\t}\r\n\r\n\t// Retrieve CDPs by TRUE owner, as registered in Maker\r\n\tfunction getCdpsByAddresses(address _owner, address _proxy, uint32 _offset, uint32 _pageSize) public returns (CDP[] _cdps) {\r\n\t\t_cdps = new CDP[](getCdpCountByOwnerAndProxy(_owner, _proxy, _offset, _pageSize));\r\n\t\tuint256 _cdpCount = cdpCount();\r\n\t\tuint32 _matchCount = 0;\r\n\t\tfor (uint32 _i = _offset; _i <= _cdpCount && _i < _offset + _pageSize; ++_i) {\r\n\t\t\taddress _cdpOwner = maker.lad(bytes32(_i));\r\n\t\t\tif (_cdpOwner != _owner && _cdpOwner != _proxy) continue;\r\n\t\t\t_cdps[_matchCount] = getCdpDetailsById(_i, _owner);\r\n\t\t\t++_matchCount;\r\n\t\t}\r\n\t\treturn _cdps;\r\n\t}\r\n\r\n\tfunction cdpCount() public view returns (uint32 _cdpCount) {\r\n\t\tuint256 count = maker.cupi();\r\n\t\trequire(count < 2**32);\r\n\t\treturn uint32(count);\r\n\t}\r\n\r\n\tfunction getCdpCountByOwnerAndProxy(address _owner, address _proxy, uint32 _offset, uint32 _pageSize) private view returns (uint32 _count) {\r\n\t\tuint256 _cdpCount = cdpCount();\r\n\t\t_count = 0;\r\n\t\tfor (uint32 _i = _offset; _i <= _cdpCount && _i < _offset + _pageSize; ++_i) {\r\n\t\t\taddress _cdpOwner = maker.lad(bytes32(_i));\r\n\t\t\tif (_cdpOwner != _owner && _cdpOwner != _proxy) continue;\r\n\t\t\t++_count;\r\n\t\t}\r\n\t\treturn _count;\r\n\t}\r\n\r\n\tfunction getCdpDetailsById(uint32 _cdpId, address _owner) private returns (CDP _cdp) {\r\n\t\t(address _cdpOwner, uint256 _collateral,,) = maker.cups(bytes32(_cdpId));\r\n\t\t// this one line makes this function not `view`. tab calls chi, which calls drip which mutates state and we can't directly access _chi to bypass this\r\n\t\tuint256 _debtInAttodai = maker.tab(bytes32(_cdpId));\r\n\t\t// Adjust locked attoeth to factor in peth/weth ratio\r\n\t\tuint256 _lockedAttoeth = (_collateral + 1).mul27(maker.gap().mul18(maker.per()));\r\n\t\t_cdp = CDP({\r\n\t\t\tid: _cdpId,\r\n\t\t\tdebtInAttodai: _debtInAttodai,\r\n\t\t\tlockedAttoeth: _lockedAttoeth,\r\n\t\t\towner: _cdpOwner,\r\n\t\t\tuserOwned: _cdpOwner == _owner\r\n\t\t});\r\n\t\treturn _cdp;\r\n\t}\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"transferTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_cdpId\",\"type\":\"bytes32\"},{\"name\":\"_minimumValueInAttoeth\",\"type\":\"uint256\"},{\"name\":\"_recipient\",\"type\":\"address\"}],\"name\":\"closeGiftedCdp\",\"outputs\":[{\"name\":\"_payoutOwnerInAttoeth\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_payGem\",\"type\":\"address\"},{\"name\":\"_buyGem\",\"type\":\"address\"},{\"name\":\"_payDesiredAmount\",\"type\":\"uint256\"}],\"name\":\"getPayPriceAndAmount\",\"outputs\":[{\"name\":\"_paidAmount\",\"type\":\"uint256\"},{\"name\":\"_boughtAmount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_proxy\",\"type\":\"address\"},{\"name\":\"_offset\",\"type\":\"uint32\"},{\"name\":\"_pageSize\",\"type\":\"uint32\"}],\"name\":\"getCdpsByAddresses\",\"outputs\":[{\"components\":[{\"name\":\"id\",\"type\":\"uint256\"},{\"name\":\"debtInAttodai\",\"type\":\"uint256\"},{\"name\":\"lockedAttoeth\",\"type\":\"uint256\"},{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"userOwned\",\"type\":\"bool\"}],\"name\":\"_cdps\",\"type\":\"tuple[]\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_leverage\",\"type\":\"uint256\"},{\"name\":\"_leverageSizeInAttoeth\",\"type\":\"uint256\"},{\"name\":\"_allowedFeeInAttoeth\",\"type\":\"uint256\"},{\"name\":\"_affiliateAddress\",\"type\":\"address\"}],\"name\":\"openCdp\",\"outputs\":[{\"name\":\"_cdpId\",\"type\":\"bytes32\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"wethDeposit\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_attodaiToBuy\",\"type\":\"uint256\"}],\"name\":\"estimateDaiPurchaseCosts\",\"outputs\":[{\"name\":\"_wethPaid\",\"type\":\"uint256\"},{\"name\":\"_daiBought\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"weth\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claimOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maker\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"ethWithdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_attodaiToSell\",\"type\":\"uint256\"}],\"name\":\"estimateDaiSaleProceeds\",\"outputs\":[{\"name\":\"_daiPaid\",\"type\":\"uint256\"},{\"name\":\"_wethBought\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ethPriceInUsd\",\"outputs\":[{\"name\":\"_attousd\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_payGem\",\"type\":\"address\"},{\"name\":\"_buyGem\",\"type\":\"address\"},{\"name\":\"_buyDesiredAmount\",\"type\":\"uint256\"}],\"name\":\"getBuyPriceAndAmount\",\"outputs\":[{\"name\":\"_paidAmount\",\"type\":\"uint256\"},{\"name\":\"_boughtAmount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"peth\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"mkr\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"attowethBalance\",\"outputs\":[{\"name\":\"_attoweth\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"wethWithdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"proxyRegistry\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_offset\",\"type\":\"uint32\"},{\"name\":\"_pageSize\",\"type\":\"uint32\"}],\"name\":\"getCdps\",\"outputs\":[{\"components\":[{\"name\":\"id\",\"type\":\"uint256\"},{\"name\":\"debtInAttodai\",\"type\":\"uint256\"},{\"name\":\"lockedAttoeth\",\"type\":\"uint256\"},{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"userOwned\",\"type\":\"bool\"}],\"name\":\"_cdps\",\"type\":\"tuple[]\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"matchingMarket\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_liquidLong\",\"type\":\"address\"},{\"name\":\"_cdpId\",\"type\":\"uint256\"},{\"name\":\"_minimumValueInAttoeth\",\"type\":\"uint256\"}],\"name\":\"closeCdp\",\"outputs\":[{\"name\":\"_payoutOwnerInAttoeth\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pendingOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"cdpCount\",\"outputs\":[{\"name\":\"_cdpCount\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"dai\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"providerFeePerEth\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_matchingMarket\",\"type\":\"address\"},{\"name\":\"_maker\",\"type\":\"address\"},{\"name\":\"_proxyRegistry\",\"type\":\"address\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"cup\",\"type\":\"uint256\"}],\"name\":\"NewCup\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"cup\",\"type\":\"uint256\"}],\"name\":\"CloseCup\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"}],\"name\":\"OwnershipRenounced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"LiquidLong","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"500","ConstructorArguments":"00000000000000000000000039755357759ce0d7f32dc8dc45414cca409ae24e000000000000000000000000448a5065aebb8e423f0896e6c5d525c040f59af30000000000000000000000004678f0a6958e4d2bc4f1baf7bc52e8f3564f3fe4","Library":"","SwarmSource":"bzzr://fefc8f4b06a2517e5e42ccd27ef978c78073d5180c0b8c23b5d2bb919ed49adc"}]}