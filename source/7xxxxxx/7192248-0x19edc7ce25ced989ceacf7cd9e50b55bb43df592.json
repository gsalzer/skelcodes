{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.0;\r\npragma experimental ABIEncoderV2;\r\n\r\ninterface IERC20 {\r\n  function transfer(address to, uint256 value) external returns (bool);\r\n  function approve(address spender, uint256 value) external returns (bool);\r\n  function transferFrom(address from, address to, uint256 value) external returns (bool);\r\n  function totalSupply() external view returns (uint256);\r\n  function balanceOf(address who) external view returns (uint256);\r\n}\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return a / b;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\ncontract Bombastic {\r\n  using SafeMath for uint256;\r\n  \r\n  IERC20 public BOMB = IERC20(0x1F4F33C3A163b9Ad84613C1c61337CbFD7C8839f);\r\n  uint256 public START_PRICE = 21;\r\n  uint256 public FEE = 2;\r\n  uint256 public INTERVAL = 12 hours;\r\n  uint256 public ids;\r\n\r\n  struct Round {\r\n    address starter;\r\n    uint256 countdown;\r\n    address [] tickets;\r\n    address winner;\r\n    uint256 winnings;\r\n    uint256 started;\r\n    uint256 ended;\r\n  }\r\n\r\n  mapping(uint256 => Round) rounds;\r\n\r\n  modifier isHuman() {\r\n    address _addr = msg.sender;\r\n    require(_addr == tx.origin);\r\n    uint256 _codeLength;\r\n\r\n    assembly {_codeLength := extcodesize(_addr)}\r\n    require(_codeLength == 0);\r\n    _;\r\n  }\r\n\r\n  function start() external isHuman() {\r\n    Round storage round = rounds[ids];\r\n\r\n    // round must not have started\r\n    require(round.countdown == 0);\r\n\r\n    // start round\r\n    round.countdown = now.add(INTERVAL);\r\n\r\n    // add to pot\r\n    require(BOMB.transferFrom(msg.sender, address(this), START_PRICE));\r\n\r\n    // set round starter\r\n    round.starter = msg.sender;\r\n\r\n    // set start time\r\n    round.started = now;\r\n\r\n    // add a ticket\r\n    round.tickets.push(msg.sender);\r\n  }\r\n\r\n  function buy() external isHuman() {\r\n    Round storage round = rounds[ids];\r\n\r\n    // round must have started\r\n    require(round.countdown != 0);\r\n\r\n    // round must not have finished\r\n    require(now <= round.countdown);\r\n\r\n    // add to countdown\r\n    round.countdown = now.add(INTERVAL);\r\n\r\n    // add to pot\r\n    require(BOMB.transferFrom(msg.sender, address(this), FEE));\r\n\r\n    // pay starter\r\n    require(BOMB.transferFrom(msg.sender, round.starter, FEE));\r\n\r\n    // add a ticket\r\n    round.tickets.push(msg.sender);\r\n  }\r\n\r\n  function draw() external isHuman() {\r\n    Round storage round = rounds[ids];\r\n\r\n    // round must have started\r\n    require(round.countdown != 0);\r\n\r\n    // round must have finished\r\n    require(now > round.countdown);\r\n\r\n    // start next round\r\n    ids = ids.add(1);\r\n\r\n    // set end time\r\n    round.ended = now;\r\n\r\n    // get winner\r\n    round.winner = round.tickets[_winner(round.tickets.length)];\r\n\r\n    // update winnings\r\n    round.winnings = BOMB.balanceOf(address(this));\r\n\r\n    // transfer to winner\r\n    require(BOMB.transfer(round.winner, round.winnings));\r\n  }\r\n\r\n  function _winner(uint256 length) internal view returns (uint256) {\r\n    uint256 seed = uint256(keccak256(abi.encodePacked(\r\n      (block.timestamp).add\r\n      (block.difficulty).add\r\n      ((uint256(keccak256(abi.encodePacked(block.coinbase)))) / (now)).add\r\n      (block.gaslimit).add\r\n      ((uint256(keccak256(abi.encodePacked(msg.sender)))) / (now)).add\r\n      (block.number)\r\n    )));\r\n    return seed % length;\r\n  }\r\n\r\n  function getCurrentRound() view external returns (Round memory, uint256, uint256) {\r\n    return (rounds[ids], BOMB.balanceOf(address(this)), ids);\r\n  }\r\n\r\n  function getRound(uint256 _roundNum) view external returns (Round memory) {\r\n    return rounds[_roundNum];\r\n  }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[],\"name\":\"draw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"START_PRICE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"BOMB\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"INTERVAL\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_roundNum\",\"type\":\"uint256\"}],\"name\":\"getRound\",\"outputs\":[{\"components\":[{\"name\":\"starter\",\"type\":\"address\"},{\"name\":\"countdown\",\"type\":\"uint256\"},{\"name\":\"tickets\",\"type\":\"address[]\"},{\"name\":\"winner\",\"type\":\"address\"},{\"name\":\"winnings\",\"type\":\"uint256\"},{\"name\":\"started\",\"type\":\"uint256\"},{\"name\":\"ended\",\"type\":\"uint256\"}],\"name\":\"\",\"type\":\"tuple\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCurrentRound\",\"outputs\":[{\"components\":[{\"name\":\"starter\",\"type\":\"address\"},{\"name\":\"countdown\",\"type\":\"uint256\"},{\"name\":\"tickets\",\"type\":\"address[]\"},{\"name\":\"winner\",\"type\":\"address\"},{\"name\":\"winnings\",\"type\":\"uint256\"},{\"name\":\"started\",\"type\":\"uint256\"},{\"name\":\"ended\",\"type\":\"uint256\"}],\"name\":\"\",\"type\":\"tuple\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"buy\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"start\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"FEE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ids\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"Bombastic","CompilerVersion":"v0.5.1+commit.c8a2cb62","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://8d8946633ccce94bd2e302a858a548cf6348f8cb43fc32f1fa64469245223c43"}]}