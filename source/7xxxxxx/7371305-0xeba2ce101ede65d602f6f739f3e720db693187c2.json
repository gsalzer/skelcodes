{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.0;\r\n\r\nlibrary SafeMath {\r\n\r\n    /**\r\n    * @dev Multiplies two numbers, throws on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two numbers, truncating the quotient.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        // uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return a / b;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, throws on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}\r\n\r\nlibrary SafeMath64 {\r\n\r\n    /**\r\n    * @dev Multiplies two numbers, throws on overflow.\r\n    */\r\n    function mul(uint64 a, uint64 b) internal pure returns (uint64 c) {\r\n        // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two numbers, truncating the quotient.\r\n    */\r\n    function div(uint64 a, uint64 b) internal pure returns (uint64) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        // uint64 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return a / b;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint64 a, uint64 b) internal pure returns (uint64) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, throws on overflow.\r\n    */\r\n    function add(uint64 a, uint64 b) internal pure returns (uint64 c) {\r\n        c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}\r\n\r\ninterface EBInterface {\r\n    \r\n    function owns(address, uint) external returns (bool);\r\n\r\n    function getPartById(uint) external returns (\r\n        uint32 tokenId, \r\n        uint8 partType, \r\n        uint8 partSubType,  \r\n        uint8 rarity, \r\n        uint8 element,\r\n        uint32 battlesLastDay, \r\n        uint32 experience, \r\n        uint32 forgeTime, \r\n        uint32 battlesLastReset\r\n    );\r\n}\r\n\r\ninterface EBMarketplace {\r\n\r\n    function getAuction(uint id) external returns (address, uint, uint, uint, uint);\r\n \r\n}\r\n\r\ncontract Ownable {\r\n\r\n    address payable public owner;\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    function setOwner(address payable _owner) public onlyOwner {\r\n        owner = _owner;\r\n    }\r\n\r\n    function getOwner() public view returns (address payable) {\r\n        return owner;\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner, \"must be owner to call this function\");\r\n        _;\r\n    }\r\n\r\n}\r\n\r\ncontract ICards {\r\n\r\n    enum Rarity {\r\n        Common, Rare, Epic, Legendary, Mythic\r\n    }\r\n\r\n    function getRandomCard(Rarity rarity, uint16 random) public view returns (uint16);\r\n    function createCard(address user, uint16 proto, uint16 purity) public returns (uint);\r\n\r\n\r\n}\r\n\r\ncontract Pack {\r\n\r\n    enum Type {\r\n        Rare, Epic, Legendary, Shiny\r\n    }\r\n\r\n}\r\n\r\ncontract RarityProvider {\r\n\r\n    ICards cards;\r\n\r\n    constructor(ICards _cards) public {\r\n        cards = _cards;\r\n    }\r\n\r\n    struct RandomnessComponents {\r\n        uint random;\r\n        uint32 rarity;\r\n        uint16 quality;\r\n        uint16 purity;\r\n        uint16 proto;\r\n    }\r\n\r\n    // return 'length' bytes of 'num' starting at 'start'\r\n    function extract(uint num, uint length, uint start) internal pure returns (uint) {\r\n        return (((1 << (length * 8)) - 1) & (num >> ((start - 1) * 8)));\r\n    }\r\n\r\n    // divides the random seed into components\r\n    function getComponents(\r\n        uint cardIndex, uint rand\r\n    ) internal pure returns (\r\n        RandomnessComponents memory\r\n    ) {\r\n        uint random = uint(keccak256(abi.encodePacked(cardIndex, rand)));\r\n        return RandomnessComponents({\r\n            random: random,\r\n            rarity: uint32(extract(random, 4, 10) % 1000000),\r\n            quality: uint16(extract(random, 2, 4) % 1000),\r\n            purity: uint16(extract(random, 2, 6) % 1000),\r\n            proto: uint16(extract(random, 2, 8) % (2**16-1))\r\n        });\r\n    }\r\n\r\n    function getCardDetails(Pack.Type packType, uint cardIndex, uint result) internal view returns (uint16, uint16) {\r\n        if (packType == Pack.Type.Shiny) {\r\n            return _getShinyCardDetails(cardIndex, result);\r\n        } else if (packType == Pack.Type.Legendary) {\r\n            return _getLegendaryCardDetails(cardIndex, result);\r\n        } else if (packType == Pack.Type.Epic) {\r\n            return _getEpicCardDetails(cardIndex, result);\r\n        }\r\n        return _getRareCardDetails(cardIndex, result);\r\n    }\r\n\r\n    function _getShinyCardDetails(uint cardIndex, uint result) internal view returns (uint16 proto, uint16 purity) {\r\n        \r\n        RandomnessComponents memory rc = getComponents(cardIndex, result); \r\n\r\n        ICards.Rarity rarity;\r\n\r\n        if (cardIndex == 4) {\r\n            rarity = _getLegendaryPlusRarity(rc.rarity);\r\n            purity = _getShinyPurityBase(rc.quality) + rc.purity;\r\n        } else if (cardIndex == 3) {\r\n            rarity = _getRarePlusRarity(rc.rarity);\r\n            purity = _getPurityBase(rc.quality) + rc.purity;\r\n        } else {\r\n            rarity = _getCommonPlusRarity(rc.rarity);\r\n            purity = _getPurityBase(rc.quality) + rc.purity;\r\n        }\r\n        proto = cards.getRandomCard(rarity, rc.proto);\r\n        return (proto, purity);\r\n    }\r\n\r\n    function _getLegendaryCardDetails(uint cardIndex, uint result) internal view returns (uint16 proto, uint16 purity) {\r\n        \r\n        RandomnessComponents memory rc = getComponents(cardIndex, result);\r\n\r\n        ICards.Rarity rarity;\r\n\r\n        if (cardIndex == 4) {\r\n            rarity = _getLegendaryPlusRarity(rc.rarity);\r\n        } else if (cardIndex == 3) {\r\n            rarity = _getRarePlusRarity(rc.rarity);\r\n        } else {\r\n            rarity = _getCommonPlusRarity(rc.rarity);\r\n        }\r\n\r\n        purity = _getPurityBase(rc.quality) + rc.purity;\r\n    \r\n        proto = cards.getRandomCard(rarity, rc.proto);\r\n\r\n        return (proto, purity);\r\n    } \r\n\r\n\r\n    function _getEpicCardDetails(uint cardIndex, uint result) internal view returns (uint16 proto, uint16 purity) {\r\n        \r\n        RandomnessComponents memory rc = getComponents(cardIndex, result);\r\n\r\n        ICards.Rarity rarity;\r\n\r\n        if (cardIndex == 4) {\r\n            rarity = _getEpicPlusRarity(rc.rarity);\r\n        } else {\r\n            rarity = _getCommonPlusRarity(rc.rarity);\r\n        }\r\n\r\n        purity = _getPurityBase(rc.quality) + rc.purity;\r\n    \r\n        proto = cards.getRandomCard(rarity, rc.proto);\r\n\r\n        return (proto, purity);\r\n    } \r\n\r\n    function _getRareCardDetails(uint cardIndex, uint result) internal view returns (uint16 proto, uint16 purity) {\r\n\r\n        RandomnessComponents memory rc = getComponents(cardIndex, result);\r\n\r\n        ICards.Rarity rarity;\r\n\r\n        if (cardIndex == 4) {\r\n            rarity = _getRarePlusRarity(rc.rarity);\r\n        } else {\r\n            rarity = _getCommonPlusRarity(rc.rarity);\r\n        }\r\n\r\n        purity = _getPurityBase(rc.quality) + rc.purity;\r\n    \r\n        proto = cards.getRandomCard(rarity, rc.proto);\r\n        return (proto, purity);\r\n    }  \r\n\r\n\r\n    function _getCommonPlusRarity(uint32 rand) internal pure returns (ICards.Rarity) {\r\n        if (rand == 999999) {\r\n            return ICards.Rarity.Mythic;\r\n        } else if (rand >= 998345) {\r\n            return ICards.Rarity.Legendary;\r\n        } else if (rand >= 986765) {\r\n            return ICards.Rarity.Epic;\r\n        } else if (rand >= 924890) {\r\n            return ICards.Rarity.Rare;\r\n        } else {\r\n            return ICards.Rarity.Common;\r\n        }\r\n    }\r\n\r\n    function _getRarePlusRarity(uint32 rand) internal pure returns (ICards.Rarity) {\r\n        if (rand == 999999) {\r\n            return ICards.Rarity.Mythic;\r\n        } else if (rand >= 981615) {\r\n            return ICards.Rarity.Legendary;\r\n        } else if (rand >= 852940) {\r\n            return ICards.Rarity.Epic;\r\n        } else {\r\n            return ICards.Rarity.Rare;\r\n        } \r\n    }\r\n\r\n    function _getEpicPlusRarity(uint32 rand) internal pure returns (ICards.Rarity) {\r\n        if (rand == 999999) {\r\n            return ICards.Rarity.Mythic;\r\n        } else if (rand >= 981615) {\r\n            return ICards.Rarity.Legendary;\r\n        } else {\r\n            return ICards.Rarity.Epic;\r\n        }\r\n    }\r\n\r\n    function _getLegendaryPlusRarity(uint32 rand) internal pure returns (ICards.Rarity) {\r\n        if (rand == 999999) {\r\n            return ICards.Rarity.Mythic;\r\n        } else {\r\n            return ICards.Rarity.Legendary;\r\n        } \r\n    }\r\n\r\n    // store purity and shine as one number to save users gas\r\n    function _getPurityBase(uint16 randOne) internal pure returns (uint16) {\r\n        if (randOne >= 998) {\r\n            return 3000;\r\n        } else if (randOne >= 988) {\r\n            return 2000;\r\n        } else if (randOne >= 938) {\r\n            return 1000;\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    function _getShinyPurityBase(uint16 randOne) internal pure returns (uint16) {\r\n        if (randOne >= 998) {\r\n            return 3000;\r\n        } else if (randOne >= 748) {\r\n            return 2000;\r\n        } else {\r\n            return 1000;\r\n        }\r\n    }\r\n\r\n    function getShine(uint16 purity) public pure returns (uint8) {\r\n        return uint8(purity / 1000);\r\n    }\r\n\r\n}\r\n\r\ncontract EtherbotsPack is Ownable, RarityProvider {\r\n\r\n    using SafeMath for uint256;\r\n    using SafeMath64 for uint64;\r\n\r\n    // fired after user purchases count packs, producing purchase with id \r\n    event ClaimMade(uint indexed id, address user, uint count, uint[] partIDs);\r\n    // fired after the callback transaction is successful, replaces RandomnessReceived\r\n    event CallbackMade(uint indexed id, address indexed user, uint count, uint randomness);\r\n    // fired after a recommit for a purchase\r\n    event Recommit(uint indexed id, address indexed user, uint count);\r\n    // fired after a card is activated, replaces PacksOpened\r\n    event CardActivated(uint indexed claimID, uint cardIndex, uint indexed cardID, uint16 proto, uint16 purity);\r\n\r\n    // Rex, Arcane Sphere, Pyrocannon, Aetherrust, Magic Missile Launcher, Firewall\r\n    uint16[] commons = [400, 413, 414, 421, 427, 428]; \r\n    // Banisher, Daemonbot, Nethersaur, Trident\r\n    uint16[] rares = [389, 415, 416, 422]; \r\n    // Golden Sabre, Howler Golem, Hasty Trade\r\n    uint16[] epics = [424, 425, 426]; \r\n    // Iron Horse, Chest\r\n    uint16[] legendaries = [382, 420]; \r\n    // Golden Golem\r\n    uint16 exclusive = 417;\r\n\r\n    uint public commitLag = 0;\r\n    uint16 public activationLimit = 40;\r\n    uint16 public multiplier = 4;\r\n    bool public canClaim = true;\r\n\r\n    struct Claim {\r\n        uint randomness;\r\n        uint[] state;\r\n        address user;\r\n        uint64 commit;\r\n        uint16 count;\r\n        uint16[3] exCounts;\r\n        uint16[3] counts;        \r\n    }\r\n\r\n    mapping(uint => bool) public claimed;\r\n\r\n    // TODO: should this be public?\r\n    Claim[] public claims;\r\n\r\n    EBInterface public eb; \r\n    EBMarketplace public em; \r\n\r\n    constructor(ICards _cards, EBInterface _eb, EBMarketplace _em) RarityProvider(_cards) public payable {\r\n        eb = _eb;\r\n        em = _em;\r\n    }\r\n\r\n    function setCommitLag(uint lag) public onlyOwner {\r\n        require(commitLag < 100, \"can't have a commit lag of >100 blocks\");\r\n        commitLag = lag;\r\n    }\r\n\r\n    function setActivationLimit(uint16 _limit) public onlyOwner {\r\n        activationLimit = _limit;\r\n    }\r\n\r\n    function setCanClaim(bool _can) public onlyOwner {\r\n        canClaim = _can;\r\n    }\r\n\r\n    function claimParts(uint[] memory parts) public {\r\n        \r\n        require(parts.length > 0, \"must submit some parts\");\r\n        require(parts.length <= 1000, \"must submit <=1000 parts per purchase\");\r\n        require(parts.length % 4 == 0, \"must submit a multiple of 4 parts at a time\");\r\n        require(canClaim, \"must be able to claim\");\r\n\r\n        require(ownsOrAuctioning(parts), \"user must control all parts\");\r\n        require(canBeClaimed(parts), \"at least one part was already claimed\");\r\n\r\n        uint packs = parts.length.div(4).mul(multiplier);\r\n\r\n        Claim memory claim = Claim({ \r\n            user: msg.sender,\r\n            count: uint16(packs),\r\n            randomness: 0,\r\n            commit: getCommitBlock(),\r\n            exCounts: [uint16(0), 0, 0],\r\n            counts: [uint16(0), 0, 0],\r\n            state: new uint256[](getStateSize(packs))\r\n        });\r\n\r\n        uint8 partType;\r\n        uint8 subType;\r\n        uint8 rarity;\r\n\r\n        for (uint i = 0; i < parts.length; i++) {\r\n            (, partType, subType, rarity, , , , ,) = eb.getPartById(parts[i]);\r\n            require(rarity > 0, \"invalid rarity\");\r\n            // rarity is (1, 2, 3)\r\n            if (isExclusive(partType, subType)) {\r\n                claim.exCounts[rarity-1] += multiplier;\r\n            } else {\r\n                claim.counts[rarity-1] += multiplier;\r\n            }\r\n        }\r\n\r\n        uint id = claims.push(claim) - 1;\r\n\r\n        emit ClaimMade(id, msg.sender, packs, parts);\r\n    }\r\n\r\n    function ownsOrAuctioning(uint[] memory parts) public returns (bool) {\r\n        for (uint i = 0; i < parts.length; i++) {\r\n            uint id = parts[i];\r\n            if (!eb.owns(msg.sender, id)) {\r\n                address seller;\r\n                // returns an active auction \r\n                // will revert if inactive - this is fine, they don't own it then\r\n                (seller, , , , ) = em.getAuction(id);\r\n                if (seller != msg.sender) {\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    function canBeClaimed(uint[] memory parts) public returns (bool) {\r\n        for (uint i = 0; i < parts.length; i++) {\r\n            uint id = parts[i];\r\n            if (id > 18214) {\r\n                return false;\r\n            }\r\n            if (claimed[id]) {\r\n                return false;\r\n            }\r\n            claimed[id] = true;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    function getCounts(uint id) public view returns (uint16[3] memory counts, uint16[3] memory exCounts) {\r\n        Claim memory c = claims[id];\r\n        return (c.counts, c.exCounts);\r\n    }\r\n\r\n    function callback(uint id) public {\r\n\r\n        Claim storage c = claims[id];\r\n\r\n        require(c.randomness == 0, \"can only callback once\");\r\n        require(uint64(block.number) > c.commit, \"cannot callback before commit\");\r\n        require(c.commit.add(uint64(256)) >= block.number, \"must recommit\");\r\n\r\n        bytes32 bhash = blockhash(c.commit);\r\n        require(uint(bhash) != 0, \"blockhash must not be zero\");\r\n\r\n        c.randomness = uint(keccak256(abi.encodePacked(id, bhash, address(this))));\r\n\r\n        emit CallbackMade(id, c.user, c.count, c.randomness);\r\n    }\r\n\r\n    function recommit(uint id) public {\r\n        Claim storage c = claims[id];\r\n        require(c.randomness == 0, \"randomness already set\");\r\n        require(block.number >= c.commit.add(uint64(256)), \"no need to recommit\");\r\n        c.commit = getCommitBlock();\r\n        emit Recommit(id, c.user, c.count);\r\n    }\r\n\r\n    function predictPacks(uint id) external view returns (uint16[] memory protos, uint16[] memory purities) {\r\n\r\n        Claim memory c = claims[id];\r\n\r\n        require(c.randomness != 0, \"randomness not yet set\");\r\n\r\n        uint result = c.randomness;\r\n\r\n        uint cardCount = uint(c.count).mul(5);\r\n\r\n        purities = new uint16[](cardCount);\r\n        protos = new uint16[](cardCount);\r\n\r\n        for (uint i = 0; i < cardCount; i++) {\r\n            (protos[i], purities[i]) = getCard(c, i, result);\r\n        }\r\n\r\n        return (protos, purities);\r\n    }\r\n\r\n    function getCommitBlock() internal view returns (uint64) {\r\n        return uint64(block.number.add(commitLag));\r\n    }\r\n\r\n    function getStateSize(uint count) public pure returns (uint) {\r\n        return count.mul(5).sub(1).div(256).add(1);\r\n    }\r\n\r\n    function isExclusive(uint partType, uint partSubType) public pure returns (bool) {\r\n        // checks whether the part is a lambo or AP\r\n        return (partType == 3) && (partSubType == 14 || partSubType == 16);\r\n    }\r\n\r\n    function getCard(Claim memory c, uint index, uint result) internal view returns (uint16 proto, uint16 purity) {\r\n\r\n        RandomnessComponents memory rc = getComponents(index, result);\r\n\r\n        uint16 progress = c.exCounts[0];\r\n\r\n        if (progress > index) {\r\n            proto = exclusive;\r\n            purity = _getPurityBase(rc.quality) + rc.purity;\r\n            return (proto, purity);\r\n        }\r\n\r\n        progress += c.exCounts[1];\r\n        if (progress > index) {\r\n            proto = exclusive;\r\n            // will be a random shadow\r\n            purity = _getPurityBase(940) + rc.purity;\r\n            return (proto, purity);\r\n        } \r\n\r\n        progress += c.exCounts[2];\r\n        if (progress > index) {\r\n            proto = exclusive;\r\n            // will be a random gold\r\n            purity = _getPurityBase(990) + rc.purity;\r\n            return (proto, purity);\r\n        }\r\n\r\n        progress += c.counts[0];\r\n        if (progress > index) {\r\n            proto = getRandomCard(rc.rarity, rc.proto);\r\n            purity = _getPurityBase(rc.quality) + rc.purity;\r\n            return (proto, purity);\r\n        }\r\n\r\n        progress += c.counts[1];\r\n        if (progress > index) {\r\n            proto = getRandomCard(rc.rarity, rc.proto);\r\n            // will be a random shadow\r\n            purity = _getPurityBase(940) + rc.purity;\r\n            return (proto, purity);\r\n        } \r\n\r\n        progress += c.counts[2];\r\n        if (progress > index) {\r\n            proto = getRandomCard(rc.rarity, rc.proto);\r\n            // will be a random gold\r\n            purity = _getPurityBase(990) + rc.purity;\r\n            return (proto, purity);\r\n        }\r\n\r\n        // 5 cards for 4 parts --> left over cards just get base stats\r\n        proto = getRandomCard(rc.rarity, rc.proto);\r\n        purity = _getPurityBase(rc.quality) + rc.purity;\r\n\r\n        return (proto, purity);\r\n    }  \r\n\r\n    function getRandomCard(uint32 rarityRandom, uint16 protoRandom) internal view returns (uint16) {\r\n        // adjusted from normal probabilities to ensure more appropriate distribution of cards\r\n        if (rarityRandom >= 970000) {\r\n            return legendaries[protoRandom % legendaries.length];\r\n        } else if (rarityRandom >= 890000) {\r\n            return epics[protoRandom % epics.length];\r\n        } else if (rarityRandom >= 670000) {\r\n            return rares[protoRandom % rares.length];\r\n        } else {\r\n            return commons[protoRandom % commons.length];\r\n        }\r\n    }\r\n\r\n    function activateMultiple(uint[] memory pIDs, uint[] memory cardIndices) \r\n        public returns (uint[] memory ids, uint16[] memory protos, uint16[] memory purities) {\r\n        uint len = pIDs.length;\r\n        require(len > 0, \"can't activate no cards\");\r\n        require(len <= activationLimit, \"can't activate more than the activation limit\");\r\n        require(len == cardIndices.length, \"must have the same length\");\r\n        ids = new uint[](len);\r\n        protos = new uint16[](len);\r\n        purities = new uint16[](len);\r\n        for (uint i = 0; i < len; i++) {\r\n            (ids[i], protos[i], purities[i]) = activate(pIDs[i], cardIndices[i]);\r\n        }\r\n        return (ids, protos, purities);\r\n    }\r\n\r\n    function activate(uint claimID, uint cardIndex) public returns (uint id, uint16 proto, uint16 purity) {\r\n        Claim storage c = claims[claimID];\r\n        \r\n        require(c.randomness != 0, \"must have been a callback\");\r\n        uint cardCount = uint(c.count).mul(5);\r\n        require(cardIndex < cardCount, \"not a valid card index\");\r\n        uint bit = getStateBit(claimID, cardIndex);\r\n        // can only activate each card once\r\n        require(bit == 0, \"card has already been activated\");\r\n        uint x = cardIndex.div(256);\r\n        uint pos = cardIndex % 256;\r\n        // mark the card as activated by flipping the relevant bit\r\n        c.state[x] ^= uint(1) << pos;\r\n        // create the card\r\n        (proto, purity) = getCard(c, cardIndex, c.randomness);\r\n        id = cards.createCard(c.user, proto, purity);\r\n        emit CardActivated(claimID, cardIndex, id, proto, purity);\r\n        return (id, proto, purity);\r\n    }\r\n\r\n    function isActivated(uint purchaseID, uint cardIndex) public view returns (bool) {\r\n        return getStateBit(purchaseID, cardIndex) != 0;\r\n    }\r\n\r\n    function getStateBit(uint claimID, uint cardIndex) public view returns (uint) {\r\n        Claim memory c = claims[claimID];\r\n        uint x = cardIndex.div(256);\r\n        uint slot = c.state[x];\r\n        uint pos = cardIndex % 256;\r\n        uint bit = (slot >> pos) & uint(1);\r\n        return bit;\r\n    }\r\n\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"parts\",\"type\":\"uint256[]\"}],\"name\":\"claimParts\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"lag\",\"type\":\"uint256\"}],\"name\":\"setCommitLag\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"multiplier\",\"outputs\":[{\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"claimID\",\"type\":\"uint256\"},{\"name\":\"cardIndex\",\"type\":\"uint256\"}],\"name\":\"getStateBit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"commitLag\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"recommit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"purchaseID\",\"type\":\"uint256\"},{\"name\":\"cardIndex\",\"type\":\"uint256\"}],\"name\":\"isActivated\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"eb\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"parts\",\"type\":\"uint256[]\"}],\"name\":\"ownsOrAuctioning\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"canClaim\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"count\",\"type\":\"uint256\"}],\"name\":\"getStateSize\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"purity\",\"type\":\"uint16\"}],\"name\":\"getShine\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"claimID\",\"type\":\"uint256\"},{\"name\":\"cardIndex\",\"type\":\"uint256\"}],\"name\":\"activate\",\"outputs\":[{\"name\":\"id\",\"type\":\"uint256\"},{\"name\":\"proto\",\"type\":\"uint16\"},{\"name\":\"purity\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getCounts\",\"outputs\":[{\"name\":\"counts\",\"type\":\"uint16[3]\"},{\"name\":\"exCounts\",\"type\":\"uint16[3]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"parts\",\"type\":\"uint256[]\"}],\"name\":\"canBeClaimed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"claims\",\"outputs\":[{\"name\":\"randomness\",\"type\":\"uint256\"},{\"name\":\"user\",\"type\":\"address\"},{\"name\":\"commit\",\"type\":\"uint64\"},{\"name\":\"count\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"activationLimit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"em\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_can\",\"type\":\"bool\"}],\"name\":\"setCanClaim\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"predictPacks\",\"outputs\":[{\"name\":\"protos\",\"type\":\"uint16[]\"},{\"name\":\"purities\",\"type\":\"uint16[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_limit\",\"type\":\"uint16\"}],\"name\":\"setActivationLimit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"claimed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"partType\",\"type\":\"uint256\"},{\"name\":\"partSubType\",\"type\":\"uint256\"}],\"name\":\"isExclusive\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"callback\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"pIDs\",\"type\":\"uint256[]\"},{\"name\":\"cardIndices\",\"type\":\"uint256[]\"}],\"name\":\"activateMultiple\",\"outputs\":[{\"name\":\"ids\",\"type\":\"uint256[]\"},{\"name\":\"protos\",\"type\":\"uint16[]\"},{\"name\":\"purities\",\"type\":\"uint16[]\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_cards\",\"type\":\"address\"},{\"name\":\"_eb\",\"type\":\"address\"},{\"name\":\"_em\",\"type\":\"address\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"count\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"partIDs\",\"type\":\"uint256[]\"}],\"name\":\"ClaimMade\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"count\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"randomness\",\"type\":\"uint256\"}],\"name\":\"CallbackMade\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"count\",\"type\":\"uint256\"}],\"name\":\"Recommit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"claimID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"cardIndex\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"cardID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"proto\",\"type\":\"uint16\"},{\"indexed\":false,\"name\":\"purity\",\"type\":\"uint16\"}],\"name\":\"CardActivated\",\"type\":\"event\"}]","ContractName":"EtherbotsPack","CompilerVersion":"v0.5.0+commit.1d4f565a","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000006ebeaf8e8e946f0716e6533a6f2cefc83f60e8ab000000000000000000000000d2f81cd7a20d60c0d558496c7169a20968389b4000000000000000000000000098ecf84ac50aa3c090f88b04676babc296d03527","Library":"","SwarmSource":"bzzr://4be03b1d3d92e896775ce041833d086c1555f68b886cd10e1eb3c24de9a067f1"}]}