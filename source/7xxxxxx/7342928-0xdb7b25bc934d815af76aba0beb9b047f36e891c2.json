{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.0;\r\n\r\nlibrary SafeCast {\r\n    /**\r\n     * Cast unsigned a to signed a.\r\n     */\r\n    function castToInt(uint a) internal pure returns(int) {\r\n        assert(a < (1 << 255));\r\n        return int(a);\r\n    }\r\n\r\n    /**\r\n     * Cast signed a to unsigned a.\r\n     */\r\n    function castToUint(int a) internal pure returns(uint) {\r\n        assert(a >= 0);\r\n        return uint(a);\r\n    }\r\n}\r\n\r\nlibrary SafeMath {\r\n\r\n    /**\r\n    * @dev Multiplies two unsigned integers, throws on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Multiplies two signed integers, throws on overflow.\r\n    */\r\n    function mul(int256 a, int256 b) internal pure returns (int256) {\r\n        // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        int256 c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two unsigned integers, truncating the quotient.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        // uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return a / b;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two signed integers, truncating the quotient.\r\n    */\r\n    function div(int256 a, int256 b) internal pure returns (int256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        // Overflow only happens when the smallest negative int is multiplied by -1.\r\n        int256 INT256_MIN = int256((uint256(1) << 255));\r\n        assert(a != INT256_MIN || b != - 1);\r\n        return a / b;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two unsigned integers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two signed integers, throws on overflow.\r\n    */\r\n    function sub(int256 a, int256 b) internal pure returns (int256) {\r\n        int256 c = a - b;\r\n        assert((b >= 0 && c <= a) || (b < 0 && c > a));\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two unsigned integers, throws on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two signed integers, throws on overflow.\r\n    */\r\n    function add(int256 a, int256 b) internal pure returns (int256) {\r\n        int256 c = a + b;\r\n        assert((b >= 0 && c >= a) || (b < 0 && c < a));\r\n        return c;\r\n    }\r\n}\r\n\r\ninterface GameInterface {\r\n    function maxBet(uint _num, uint _bankRoll) external view returns(uint);\r\n\r\n    function resultNumber(bytes32 _serverSeed, bytes32 _userSeed, uint _num) external view returns(uint);\r\n\r\n    function userProfit(uint _num, uint _betValue, uint _resultNum) external view returns(int);\r\n\r\n    function maxUserProfit(uint _num, uint _betValue) external view returns(int);\r\n}\r\n\r\ncontract Utilities {\r\n    using SafeCast for int;\r\n    using SafeCast for uint;\r\n    using SafeMath for int;\r\n    using SafeMath for uint;\r\n\r\n    uint constant public PROBABILITY_DIVISOR = 10000;\r\n    uint constant public HOUSE_EDGE = 150;\r\n    uint constant public HOUSE_EDGE_DIVISOR = 10000;\r\n\r\n    /**\r\n     * @dev Calc max bet we allow\r\n     * We definitely do not allow bets greater than kelly criterion would allow.\r\n     * => The max bet is limited to the max profit of houseEdge * bankroll.\r\n     * => maxBet = houseEdge / (1/p * (1 - houseEdge) - 1) * bankroll, with p is win probability.\r\n     * The max bet can be further restricted on backend.\r\n     * @param _winProbability winProbability.\r\n     * @return max allowed bet.\r\n     */\r\n    function maxBetFromProbability(uint _winProbability, uint _bankRoll) public pure returns(uint) {\r\n        assert(0 < _winProbability && _winProbability < PROBABILITY_DIVISOR);\r\n\r\n        uint tmp1 = PROBABILITY_DIVISOR.mul(HOUSE_EDGE_DIVISOR).div(_winProbability);\r\n        uint tmp2 = PROBABILITY_DIVISOR.mul(HOUSE_EDGE).div(_winProbability);\r\n\r\n        uint enumerator = HOUSE_EDGE.mul(_bankRoll);\r\n        uint denominator = tmp1.sub(tmp2).sub(HOUSE_EDGE_DIVISOR);\r\n        return enumerator.div(denominator);\r\n    }\r\n\r\n    /**\r\n     * Calculate user profit from total won.\r\n     * @param _totalWon user winnings.\r\n     * @param _betValue bet value.\r\n     * @return user profit.\r\n     */\r\n    function calcProfitFromTotalWon(uint _totalWon, uint _betValue) public pure returns(int) {\r\n        uint houseEdgeValue = _totalWon.mul(HOUSE_EDGE).div(HOUSE_EDGE_DIVISOR);\r\n\r\n        return _totalWon.castToInt().sub(houseEdgeValue.castToInt()).sub(_betValue.castToInt());\r\n    }\r\n\r\n    /**\r\n     * @dev Generates a 256 bit random number by combining server and user seed.\r\n     * @param _serverSeed server seed.\r\n     * @param _userSeed user seed.\r\n     * @return random number generated by combining server and user seed.\r\n     */\r\n    function generateRandomNumber(bytes32 _serverSeed, bytes32 _userSeed) public pure returns(uint) {\r\n        bytes32 combinedHash = keccak256(abi.encodePacked(_serverSeed, _userSeed));\r\n        return uint(combinedHash);\r\n    }\r\n}\r\n\r\ncontract Keno is GameInterface, Utilities {\r\n    using SafeCast for uint;\r\n    using SafeMath for uint;\r\n\r\n    /// @dev divider for PAY_OUT and MAX_BET\r\n    uint public constant DIVIDER = 1000;\r\n\r\n    /// @dev #selectable fields\r\n    uint public constant SELECTABLE_FIELDS = 10;\r\n\r\n    /// @dev #available fields\r\n    uint public constant FIELDS = 40;\r\n\r\n    /// @dev max bet table as fraction of bankroll\r\n    uint16[11] public MAX_BET = [0, 5, 10, 7, 5, 4, 4, 2, 2, 2, 1];\r\n\r\n    /// @dev payout multiplier table, first index: selected fields, second: hits\r\n    uint24[][11] public PAY_OUT;\r\n\r\n    event LogGameCreated(uint num);\r\n\r\n    constructor() public {\r\n        // setup payout table\r\n        PAY_OUT[0]  = [0];\r\n        PAY_OUT[1]  = [0, 3940];\r\n        PAY_OUT[2]  = [0, 2000, 3740];\r\n        PAY_OUT[3]  = [0, 1000, 3150, 9400];\r\n        PAY_OUT[4]  = [0, 800, 1700, 5300, 24500];\r\n        PAY_OUT[5]  = [0, 250, 1400, 4000, 16600, 42000];\r\n        PAY_OUT[6]  = [0, 0, 1000, 3650, 7000, 16000, 46000];\r\n        PAY_OUT[7]  = [0, 0, 460, 3000, 4400, 14000, 39000, 80000];\r\n        PAY_OUT[8]  = [0, 0, 0, 2250, 4000, 11000, 30000, 67000, 90000];\r\n        PAY_OUT[9]  = [0, 0, 0, 1550, 3000, 8000, 14000, 37000, 65000, 100000];\r\n        PAY_OUT[10] = [0, 0, 0, 1400, 2200, 4400, 8000, 28000, 60000, 120000, 200000];\r\n    }\r\n\r\n    modifier onlyValidNum(uint _betNum) {\r\n        require(_betNum > 0 && _betNum < (1 << FIELDS) && getSelectedBits(_betNum) <= SELECTABLE_FIELDS, \"Invalid num\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyValidResultNum(uint _resultNum) {\r\n        require(_resultNum < (1 << FIELDS) && getSelectedBits(_resultNum) == SELECTABLE_FIELDS);\r\n        _;\r\n    }\r\n\r\n    function maxBet(uint _betNum, uint _bankRoll) external onlyValidNum(_betNum) view returns(uint) {\r\n        uint fields = getSelectedBits(_betNum);\r\n        return uint(MAX_BET[fields]).mul(_bankRoll).div(DIVIDER);\r\n    }\r\n\r\n    function resultNumber(bytes32 _serverSeed, bytes32 _userSeed, uint _betNum) external onlyValidNum(_betNum) view returns(uint) {\r\n        uint resultNum = 0;\r\n        bytes32 seed = keccak256(abi.encodePacked(_serverSeed, _userSeed));\r\n\r\n        for (uint i = 0; i < SELECTABLE_FIELDS; i++) {\r\n            uint randNum = uint(seed) % (FIELDS - i);\r\n\r\n            uint pos = 0;\r\n            uint resultPos = 0;\r\n            for (;;) {\r\n                if (resultNum & (1 << resultPos) == 0) {\r\n                    if (pos == randNum) {\r\n                        break;\r\n                    }\r\n                    pos++;\r\n                }\r\n                resultPos++;\r\n            }\r\n            resultNum |= 1 << resultPos;\r\n\r\n            // update seed\r\n            seed = keccak256(abi.encodePacked(seed));\r\n        }\r\n\r\n        return resultNum;\r\n    }\r\n\r\n    function userProfit(uint _betNum, uint _betValue, uint _resultNum)\r\n        external\r\n        onlyValidNum(_betNum)\r\n        onlyValidResultNum(_resultNum)\r\n        view\r\n        returns(int)\r\n    {\r\n        uint hits = getSelectedBits(_betNum & _resultNum);\r\n        uint selected = getSelectedBits(_betNum);\r\n\r\n        return calcProfit(_betValue, selected, hits);\r\n    }\r\n\r\n    function maxUserProfit(uint _betNum, uint _betValue) external onlyValidNum(_betNum) view returns(int) {\r\n        uint selected = getSelectedBits(_betNum);\r\n\r\n        return calcProfit(_betValue, selected, selected);\r\n    }\r\n\r\n    function calcProfit(uint _betValue, uint _selected, uint _hits) private view returns(int) {\r\n        assert(_hits <= _selected);\r\n        assert(_selected <= SELECTABLE_FIELDS);\r\n\r\n        uint payoutMultiplier = PAY_OUT[_selected][_hits];\r\n        uint payout = _betValue.mul(payoutMultiplier).div(DIVIDER);\r\n        return payout.castToInt().sub(_betValue.castToInt());\r\n    }\r\n\r\n    function getSelectedBits(uint _num) private pure returns(uint) {\r\n        uint selectedBits = 0;\r\n        // Could be calculated more efficient.\r\n        // But as it's only needed if a conflict arises, let's keep it simple.\r\n        for (uint i = 0; i < FIELDS; i++) {\r\n            if (_num & (1 << i) > 0) {\r\n                selectedBits += 1;\r\n            }\r\n        }\r\n        return selectedBits;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"_serverSeed\",\"type\":\"bytes32\"},{\"name\":\"_userSeed\",\"type\":\"bytes32\"}],\"name\":\"generateRandomNumber\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_totalWon\",\"type\":\"uint256\"},{\"name\":\"_betValue\",\"type\":\"uint256\"}],\"name\":\"calcProfitFromTotalWon\",\"outputs\":[{\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"DIVIDER\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_betNum\",\"type\":\"uint256\"},{\"name\":\"_betValue\",\"type\":\"uint256\"}],\"name\":\"maxUserProfit\",\"outputs\":[{\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"PAY_OUT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint24\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_betNum\",\"type\":\"uint256\"},{\"name\":\"_bankRoll\",\"type\":\"uint256\"}],\"name\":\"maxBet\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"HOUSE_EDGE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"SELECTABLE_FIELDS\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_betNum\",\"type\":\"uint256\"},{\"name\":\"_betValue\",\"type\":\"uint256\"},{\"name\":\"_resultNum\",\"type\":\"uint256\"}],\"name\":\"userProfit\",\"outputs\":[{\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"MAX_BET\",\"outputs\":[{\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_winProbability\",\"type\":\"uint256\"},{\"name\":\"_bankRoll\",\"type\":\"uint256\"}],\"name\":\"maxBetFromProbability\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_serverSeed\",\"type\":\"bytes32\"},{\"name\":\"_userSeed\",\"type\":\"bytes32\"},{\"name\":\"_betNum\",\"type\":\"uint256\"}],\"name\":\"resultNumber\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"HOUSE_EDGE_DIVISOR\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"FIELDS\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"PROBABILITY_DIVISOR\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"num\",\"type\":\"uint256\"}],\"name\":\"LogGameCreated\",\"type\":\"event\"}]","ContractName":"Keno","CompilerVersion":"v0.5.0+commit.1d4f565a","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://3390915bb33f10d252227f757e122ff32c8d93d709b31b0fe0455c3db9229a9f"}]}