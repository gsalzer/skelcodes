{"status":"1","message":"OK","result":[{"SourceCode":"// full contract sources : https://github.com/DigixGlobal/dao-contracts\r\n\r\npragma solidity 0.4.25;\r\n\r\n// File: @digix/solidity-collections/contracts/abstract/AddressIteratorInteractive.sol\r\n/**\r\n  @title Address Iterator Interactive\r\n  @author DigixGlobal Pte Ltd\r\n*/\r\ncontract AddressIteratorInteractive {\r\n\r\n  /**\r\n    @notice Lists a Address collection from start or end\r\n    @param _count Total number of Address items to return\r\n    @param _function_first Function that returns the First Address item in the list\r\n    @param _function_last Function that returns the last Address item in the list\r\n    @param _function_next Function that returns the Next Address item in the list\r\n    @param _function_previous Function that returns previous Address item in the list\r\n    @param _from_start whether to read from start (or end) of the list\r\n    @return {\"_address_items\" : \"Collection of reversed Address list\"}\r\n  */\r\n  function list_addresses(uint256 _count,\r\n                                 function () external constant returns (address) _function_first,\r\n                                 function () external constant returns (address) _function_last,\r\n                                 function (address) external constant returns (address) _function_next,\r\n                                 function (address) external constant returns (address) _function_previous,\r\n                                 bool _from_start)\r\n           internal\r\n           constant\r\n           returns (address[] _address_items)\r\n  {\r\n    if (_from_start) {\r\n      _address_items = private_list_addresses_from_address(_function_first(), _count, true, _function_last, _function_next);\r\n    } else {\r\n      _address_items = private_list_addresses_from_address(_function_last(), _count, true, _function_first, _function_previous);\r\n    }\r\n  }\r\n\r\n\r\n\r\n  /**\r\n    @notice Lists a Address collection from some `_current_item`, going forwards or backwards depending on `_from_start`\r\n    @param _current_item The current Item\r\n    @param _count Total number of Address items to return\r\n    @param _function_first Function that returns the First Address item in the list\r\n    @param _function_last Function that returns the last Address item in the list\r\n    @param _function_next Function that returns the Next Address item in the list\r\n    @param _function_previous Function that returns previous Address item in the list\r\n    @param _from_start whether to read in the forwards ( or backwards) direction\r\n    @return {\"_address_items\" :\"Collection/list of Address\"}\r\n  */\r\n  function list_addresses_from(address _current_item, uint256 _count,\r\n                                function () external constant returns (address) _function_first,\r\n                                function () external constant returns (address) _function_last,\r\n                                function (address) external constant returns (address) _function_next,\r\n                                function (address) external constant returns (address) _function_previous,\r\n                                bool _from_start)\r\n           internal\r\n           constant\r\n           returns (address[] _address_items)\r\n  {\r\n    if (_from_start) {\r\n      _address_items = private_list_addresses_from_address(_current_item, _count, false, _function_last, _function_next);\r\n    } else {\r\n      _address_items = private_list_addresses_from_address(_current_item, _count, false, _function_first, _function_previous);\r\n    }\r\n  }\r\n\r\n\r\n  /**\r\n    @notice a private function to lists a Address collection starting from some `_current_item` (which could be included or excluded), in the forwards or backwards direction\r\n    @param _current_item The current Item\r\n    @param _count Total number of Address items to return\r\n    @param _including_current Whether the `_current_item` should be included in the result\r\n    @param _function_last Function that returns the address where we stop reading more address\r\n    @param _function_next Function that returns the next address to read after some address (could be backwards or forwards in the physical collection)\r\n    @return {\"_address_items\" :\"Collection/list of Address\"}\r\n  */\r\n  function private_list_addresses_from_address(address _current_item, uint256 _count, bool _including_current,\r\n                                 function () external constant returns (address) _function_last,\r\n                                 function (address) external constant returns (address) _function_next)\r\n           private\r\n           constant\r\n           returns (address[] _address_items)\r\n  {\r\n    uint256 _i;\r\n    uint256 _real_count = 0;\r\n    address _last_item;\r\n\r\n    _last_item = _function_last();\r\n    if (_count == 0 || _last_item == address(0x0)) {\r\n      _address_items = new address[](0);\r\n    } else {\r\n      address[] memory _items_temp = new address[](_count);\r\n      address _this_item;\r\n      if (_including_current == true) {\r\n        _items_temp[0] = _current_item;\r\n        _real_count = 1;\r\n      }\r\n      _this_item = _current_item;\r\n      for (_i = _real_count; (_i < _count) && (_this_item != _last_item);_i++) {\r\n        _this_item = _function_next(_this_item);\r\n        if (_this_item != address(0x0)) {\r\n          _real_count++;\r\n          _items_temp[_i] = _this_item;\r\n        }\r\n      }\r\n\r\n      _address_items = new address[](_real_count);\r\n      for(_i = 0;_i < _real_count;_i++) {\r\n        _address_items[_i] = _items_temp[_i];\r\n      }\r\n    }\r\n  }\r\n\r\n\r\n  /** DEPRECATED\r\n    @notice private function to list a Address collection starting from the start or end of the list\r\n    @param _count Total number of Address item to return\r\n    @param _function_total Function that returns the Total number of Address item in the list\r\n    @param _function_first Function that returns the First Address item in the list\r\n    @param _function_next Function that returns the Next Address item in the list\r\n    @return {\"_address_items\" :\"Collection/list of Address\"}\r\n  */\r\n  /*function list_addresses_from_start_or_end(uint256 _count,\r\n                                 function () external constant returns (uint256) _function_total,\r\n                                 function () external constant returns (address) _function_first,\r\n                                 function (address) external constant returns (address) _function_next)\r\n\r\n           private\r\n           constant\r\n           returns (address[] _address_items)\r\n  {\r\n    uint256 _i;\r\n    address _current_item;\r\n    uint256 _real_count = _function_total();\r\n\r\n    if (_count > _real_count) {\r\n      _count = _real_count;\r\n    }\r\n\r\n    address[] memory _items_tmp = new address[](_count);\r\n\r\n    if (_count > 0) {\r\n      _current_item = _function_first();\r\n      _items_tmp[0] = _current_item;\r\n\r\n      for(_i = 1;_i <= (_count - 1);_i++) {\r\n        _current_item = _function_next(_current_item);\r\n        if (_current_item != address(0x0)) {\r\n          _items_tmp[_i] = _current_item;\r\n        }\r\n      }\r\n      _address_items = _items_tmp;\r\n    } else {\r\n      _address_items = new address[](0);\r\n    }\r\n  }*/\r\n\r\n  /** DEPRECATED\r\n    @notice a private function to lists a Address collection starting from some `_current_item`, could be forwards or backwards\r\n    @param _current_item The current Item\r\n    @param _count Total number of Address items to return\r\n    @param _function_last Function that returns the bytes where we stop reading more bytes\r\n    @param _function_next Function that returns the next bytes to read after some bytes (could be backwards or forwards in the physical collection)\r\n    @return {\"_address_items\" :\"Collection/list of Address\"}\r\n  */\r\n  /*function list_addresses_from_byte(address _current_item, uint256 _count,\r\n                                 function () external constant returns (address) _function_last,\r\n                                 function (address) external constant returns (address) _function_next)\r\n           private\r\n           constant\r\n           returns (address[] _address_items)\r\n  {\r\n    uint256 _i;\r\n    uint256 _real_count = 0;\r\n\r\n    if (_count == 0) {\r\n      _address_items = new address[](0);\r\n    } else {\r\n      address[] memory _items_temp = new address[](_count);\r\n\r\n      address _start_item;\r\n      address _last_item;\r\n\r\n      _last_item = _function_last();\r\n\r\n      if (_last_item != _current_item) {\r\n        _start_item = _function_next(_current_item);\r\n        if (_start_item != address(0x0)) {\r\n          _items_temp[0] = _start_item;\r\n          _real_count = 1;\r\n          for(_i = 1;(_i <= (_count - 1)) && (_start_item != _last_item);_i++) {\r\n            _start_item = _function_next(_start_item);\r\n            if (_start_item != address(0x0)) {\r\n              _real_count++;\r\n              _items_temp[_i] = _start_item;\r\n            }\r\n          }\r\n          _address_items = new address[](_real_count);\r\n          for(_i = 0;_i <= (_real_count - 1);_i++) {\r\n            _address_items[_i] = _items_temp[_i];\r\n          }\r\n        } else {\r\n          _address_items = new address[](0);\r\n        }\r\n      } else {\r\n        _address_items = new address[](0);\r\n      }\r\n    }\r\n  }*/\r\n}\r\n\r\n// File: @digix/solidity-collections/contracts/abstract/BytesIteratorInteractive.sol\r\n/**\r\n  @title Bytes Iterator Interactive\r\n  @author DigixGlobal Pte Ltd\r\n*/\r\ncontract BytesIteratorInteractive {\r\n\r\n  /**\r\n    @notice Lists a Bytes collection from start or end\r\n    @param _count Total number of Bytes items to return\r\n    @param _function_first Function that returns the First Bytes item in the list\r\n    @param _function_last Function that returns the last Bytes item in the list\r\n    @param _function_next Function that returns the Next Bytes item in the list\r\n    @param _function_previous Function that returns previous Bytes item in the list\r\n    @param _from_start whether to read from start (or end) of the list\r\n    @return {\"_bytes_items\" : \"Collection of reversed Bytes list\"}\r\n  */\r\n  function list_bytesarray(uint256 _count,\r\n                                 function () external constant returns (bytes32) _function_first,\r\n                                 function () external constant returns (bytes32) _function_last,\r\n                                 function (bytes32) external constant returns (bytes32) _function_next,\r\n                                 function (bytes32) external constant returns (bytes32) _function_previous,\r\n                                 bool _from_start)\r\n           internal\r\n           constant\r\n           returns (bytes32[] _bytes_items)\r\n  {\r\n    if (_from_start) {\r\n      _bytes_items = private_list_bytes_from_bytes(_function_first(), _count, true, _function_last, _function_next);\r\n    } else {\r\n      _bytes_items = private_list_bytes_from_bytes(_function_last(), _count, true, _function_first, _function_previous);\r\n    }\r\n  }\r\n\r\n  /**\r\n    @notice Lists a Bytes collection from some `_current_item`, going forwards or backwards depending on `_from_start`\r\n    @param _current_item The current Item\r\n    @param _count Total number of Bytes items to return\r\n    @param _function_first Function that returns the First Bytes item in the list\r\n    @param _function_last Function that returns the last Bytes item in the list\r\n    @param _function_next Function that returns the Next Bytes item in the list\r\n    @param _function_previous Function that returns previous Bytes item in the list\r\n    @param _from_start whether to read in the forwards ( or backwards) direction\r\n    @return {\"_bytes_items\" :\"Collection/list of Bytes\"}\r\n  */\r\n  function list_bytesarray_from(bytes32 _current_item, uint256 _count,\r\n                                function () external constant returns (bytes32) _function_first,\r\n                                function () external constant returns (bytes32) _function_last,\r\n                                function (bytes32) external constant returns (bytes32) _function_next,\r\n                                function (bytes32) external constant returns (bytes32) _function_previous,\r\n                                bool _from_start)\r\n           internal\r\n           constant\r\n           returns (bytes32[] _bytes_items)\r\n  {\r\n    if (_from_start) {\r\n      _bytes_items = private_list_bytes_from_bytes(_current_item, _count, false, _function_last, _function_next);\r\n    } else {\r\n      _bytes_items = private_list_bytes_from_bytes(_current_item, _count, false, _function_first, _function_previous);\r\n    }\r\n  }\r\n\r\n  /**\r\n    @notice A private function to lists a Bytes collection starting from some `_current_item` (which could be included or excluded), in the forwards or backwards direction\r\n    @param _current_item The current Item\r\n    @param _count Total number of Bytes items to return\r\n    @param _including_current Whether the `_current_item` should be included in the result\r\n    @param _function_last Function that returns the bytes where we stop reading more bytes\r\n    @param _function_next Function that returns the next bytes to read after some bytes (could be backwards or forwards in the physical collection)\r\n    @return {\"_address_items\" :\"Collection/list of Bytes\"}\r\n  */\r\n  function private_list_bytes_from_bytes(bytes32 _current_item, uint256 _count, bool _including_current,\r\n                                 function () external constant returns (bytes32) _function_last,\r\n                                 function (bytes32) external constant returns (bytes32) _function_next)\r\n           private\r\n           constant\r\n           returns (bytes32[] _bytes32_items)\r\n  {\r\n    uint256 _i;\r\n    uint256 _real_count = 0;\r\n    bytes32 _last_item;\r\n\r\n    _last_item = _function_last();\r\n    if (_count == 0 || _last_item == bytes32(0x0)) {\r\n      _bytes32_items = new bytes32[](0);\r\n    } else {\r\n      bytes32[] memory _items_temp = new bytes32[](_count);\r\n      bytes32 _this_item;\r\n      if (_including_current == true) {\r\n        _items_temp[0] = _current_item;\r\n        _real_count = 1;\r\n      }\r\n      _this_item = _current_item;\r\n      for (_i = _real_count; (_i < _count) && (_this_item != _last_item);_i++) {\r\n        _this_item = _function_next(_this_item);\r\n        if (_this_item != bytes32(0x0)) {\r\n          _real_count++;\r\n          _items_temp[_i] = _this_item;\r\n        }\r\n      }\r\n\r\n      _bytes32_items = new bytes32[](_real_count);\r\n      for(_i = 0;_i < _real_count;_i++) {\r\n        _bytes32_items[_i] = _items_temp[_i];\r\n      }\r\n    }\r\n  }\r\n\r\n\r\n\r\n\r\n  ////// DEPRECATED FUNCTIONS (old versions)\r\n\r\n  /**\r\n    @notice a private function to lists a Bytes collection starting from some `_current_item`, could be forwards or backwards\r\n    @param _current_item The current Item\r\n    @param _count Total number of Bytes items to return\r\n    @param _function_last Function that returns the bytes where we stop reading more bytes\r\n    @param _function_next Function that returns the next bytes to read after some bytes (could be backwards or forwards in the physical collection)\r\n    @return {\"_bytes_items\" :\"Collection/list of Bytes\"}\r\n  */\r\n  /*function list_bytes_from_bytes(bytes32 _current_item, uint256 _count,\r\n                                 function () external constant returns (bytes32) _function_last,\r\n                                 function (bytes32) external constant returns (bytes32) _function_next)\r\n           private\r\n           constant\r\n           returns (bytes32[] _bytes_items)\r\n  {\r\n    uint256 _i;\r\n    uint256 _real_count = 0;\r\n\r\n    if (_count == 0) {\r\n      _bytes_items = new bytes32[](0);\r\n    } else {\r\n      bytes32[] memory _items_temp = new bytes32[](_count);\r\n\r\n      bytes32 _start_item;\r\n      bytes32 _last_item;\r\n\r\n      _last_item = _function_last();\r\n\r\n      if (_last_item != _current_item) {\r\n        _start_item = _function_next(_current_item);\r\n        if (_start_item != bytes32(0x0)) {\r\n          _items_temp[0] = _start_item;\r\n          _real_count = 1;\r\n          for(_i = 1;(_i <= (_count - 1)) && (_start_item != _last_item);_i++) {\r\n            _start_item = _function_next(_start_item);\r\n            if (_start_item != bytes32(0x0)) {\r\n              _real_count++;\r\n              _items_temp[_i] = _start_item;\r\n            }\r\n          }\r\n          _bytes_items = new bytes32[](_real_count);\r\n          for(_i = 0;_i <= (_real_count - 1);_i++) {\r\n            _bytes_items[_i] = _items_temp[_i];\r\n          }\r\n        } else {\r\n          _bytes_items = new bytes32[](0);\r\n        }\r\n      } else {\r\n        _bytes_items = new bytes32[](0);\r\n      }\r\n    }\r\n  }*/\r\n\r\n  /**\r\n    @notice private function to list a Bytes collection starting from the start or end of the list\r\n    @param _count Total number of Bytes item to return\r\n    @param _function_total Function that returns the Total number of Bytes item in the list\r\n    @param _function_first Function that returns the First Bytes item in the list\r\n    @param _function_next Function that returns the Next Bytes item in the list\r\n    @return {\"_bytes_items\" :\"Collection/list of Bytes\"}\r\n  */\r\n  /*function list_bytes_from_start_or_end(uint256 _count,\r\n                                 function () external constant returns (uint256) _function_total,\r\n                                 function () external constant returns (bytes32) _function_first,\r\n                                 function (bytes32) external constant returns (bytes32) _function_next)\r\n\r\n           private\r\n           constant\r\n           returns (bytes32[] _bytes_items)\r\n  {\r\n    uint256 _i;\r\n    bytes32 _current_item;\r\n    uint256 _real_count = _function_total();\r\n\r\n    if (_count > _real_count) {\r\n      _count = _real_count;\r\n    }\r\n\r\n    bytes32[] memory _items_tmp = new bytes32[](_count);\r\n\r\n    if (_count > 0) {\r\n      _current_item = _function_first();\r\n      _items_tmp[0] = _current_item;\r\n\r\n      for(_i = 1;_i <= (_count - 1);_i++) {\r\n        _current_item = _function_next(_current_item);\r\n        if (_current_item != bytes32(0x0)) {\r\n          _items_tmp[_i] = _current_item;\r\n        }\r\n      }\r\n      _bytes_items = _items_tmp;\r\n    } else {\r\n      _bytes_items = new bytes32[](0);\r\n    }\r\n  }*/\r\n}\r\n\r\n// File: @digix/solidity-collections/contracts/abstract/IndexedBytesIteratorInteractive.sol\r\n/**\r\n  @title Indexed Bytes Iterator Interactive\r\n  @author DigixGlobal Pte Ltd\r\n*/\r\ncontract IndexedBytesIteratorInteractive {\r\n\r\n  /**\r\n    @notice Lists an indexed Bytes collection from start or end\r\n    @param _collection_index Index of the Collection to list\r\n    @param _count Total number of Bytes items to return\r\n    @param _function_first Function that returns the First Bytes item in the list\r\n    @param _function_last Function that returns the last Bytes item in the list\r\n    @param _function_next Function that returns the Next Bytes item in the list\r\n    @param _function_previous Function that returns previous Bytes item in the list\r\n    @param _from_start whether to read from start (or end) of the list\r\n    @return {\"_bytes_items\" : \"Collection of reversed Bytes list\"}\r\n  */\r\n  function list_indexed_bytesarray(bytes32 _collection_index, uint256 _count,\r\n                              function (bytes32) external constant returns (bytes32) _function_first,\r\n                              function (bytes32) external constant returns (bytes32) _function_last,\r\n                              function (bytes32, bytes32) external constant returns (bytes32) _function_next,\r\n                              function (bytes32, bytes32) external constant returns (bytes32) _function_previous,\r\n                              bool _from_start)\r\n           internal\r\n           constant\r\n           returns (bytes32[] _indexed_bytes_items)\r\n  {\r\n    if (_from_start) {\r\n      _indexed_bytes_items = private_list_indexed_bytes_from_bytes(_collection_index, _function_first(_collection_index), _count, true, _function_last, _function_next);\r\n    } else {\r\n      _indexed_bytes_items = private_list_indexed_bytes_from_bytes(_collection_index, _function_last(_collection_index), _count, true, _function_first, _function_previous);\r\n    }\r\n  }\r\n\r\n  /**\r\n    @notice Lists an indexed Bytes collection from some `_current_item`, going forwards or backwards depending on `_from_start`\r\n    @param _collection_index Index of the Collection to list\r\n    @param _current_item The current Item\r\n    @param _count Total number of Bytes items to return\r\n    @param _function_first Function that returns the First Bytes item in the list\r\n    @param _function_last Function that returns the last Bytes item in the list\r\n    @param _function_next Function that returns the Next Bytes item in the list\r\n    @param _function_previous Function that returns previous Bytes item in the list\r\n    @param _from_start whether to read in the forwards ( or backwards) direction\r\n    @return {\"_bytes_items\" :\"Collection/list of Bytes\"}\r\n  */\r\n  function list_indexed_bytesarray_from(bytes32 _collection_index, bytes32 _current_item, uint256 _count,\r\n                                function (bytes32) external constant returns (bytes32) _function_first,\r\n                                function (bytes32) external constant returns (bytes32) _function_last,\r\n                                function (bytes32, bytes32) external constant returns (bytes32) _function_next,\r\n                                function (bytes32, bytes32) external constant returns (bytes32) _function_previous,\r\n                                bool _from_start)\r\n           internal\r\n           constant\r\n           returns (bytes32[] _indexed_bytes_items)\r\n  {\r\n    if (_from_start) {\r\n      _indexed_bytes_items = private_list_indexed_bytes_from_bytes(_collection_index, _current_item, _count, false, _function_last, _function_next);\r\n    } else {\r\n      _indexed_bytes_items = private_list_indexed_bytes_from_bytes(_collection_index, _current_item, _count, false, _function_first, _function_previous);\r\n    }\r\n  }\r\n\r\n  /**\r\n    @notice a private function to lists an indexed Bytes collection starting from some `_current_item` (which could be included or excluded), in the forwards or backwards direction\r\n    @param _collection_index Index of the Collection to list\r\n    @param _current_item The item where we start reading from the list\r\n    @param _count Total number of Bytes items to return\r\n    @param _including_current Whether the `_current_item` should be included in the result\r\n    @param _function_last Function that returns the bytes where we stop reading more bytes\r\n    @param _function_next Function that returns the next bytes to read after another bytes (could be backwards or forwards in the physical collection)\r\n    @return {\"_bytes_items\" :\"Collection/list of Bytes\"}\r\n  */\r\n  function private_list_indexed_bytes_from_bytes(bytes32 _collection_index, bytes32 _current_item, uint256 _count, bool _including_current,\r\n                                         function (bytes32) external constant returns (bytes32) _function_last,\r\n                                         function (bytes32, bytes32) external constant returns (bytes32) _function_next)\r\n           private\r\n           constant\r\n           returns (bytes32[] _indexed_bytes_items)\r\n  {\r\n    uint256 _i;\r\n    uint256 _real_count = 0;\r\n    bytes32 _last_item;\r\n\r\n    _last_item = _function_last(_collection_index);\r\n    if (_count == 0 || _last_item == bytes32(0x0)) {  // if count is 0 or the collection is empty, returns empty array\r\n      _indexed_bytes_items = new bytes32[](0);\r\n    } else {\r\n      bytes32[] memory _items_temp = new bytes32[](_count);\r\n      bytes32 _this_item;\r\n      if (_including_current) {\r\n        _items_temp[0] = _current_item;\r\n        _real_count = 1;\r\n      }\r\n      _this_item = _current_item;\r\n      for (_i = _real_count; (_i < _count) && (_this_item != _last_item);_i++) {\r\n        _this_item = _function_next(_collection_index, _this_item);\r\n        if (_this_item != bytes32(0x0)) {\r\n          _real_count++;\r\n          _items_temp[_i] = _this_item;\r\n        }\r\n      }\r\n\r\n      _indexed_bytes_items = new bytes32[](_real_count);\r\n      for(_i = 0;_i < _real_count;_i++) {\r\n        _indexed_bytes_items[_i] = _items_temp[_i];\r\n      }\r\n    }\r\n  }\r\n\r\n\r\n  // old function, DEPRECATED\r\n  /*function list_indexed_bytes_from_bytes(bytes32 _collection_index, bytes32 _current_item, uint256 _count,\r\n                                         function (bytes32) external constant returns (bytes32) _function_last,\r\n                                         function (bytes32, bytes32) external constant returns (bytes32) _function_next)\r\n           private\r\n           constant\r\n           returns (bytes32[] _indexed_bytes_items)\r\n  {\r\n    uint256 _i;\r\n    uint256 _real_count = 0;\r\n    if (_count == 0) {\r\n      _indexed_bytes_items = new bytes32[](0);\r\n    } else {\r\n      bytes32[] memory _items_temp = new bytes32[](_count);\r\n\r\n      bytes32 _start_item;\r\n      bytes32 _last_item;\r\n\r\n      _last_item = _function_last(_collection_index);\r\n\r\n      if (_last_item != _current_item) {\r\n        _start_item = _function_next(_collection_index, _current_item);\r\n        if (_start_item != bytes32(0x0)) {\r\n          _items_temp[0] = _start_item;\r\n          _real_count = 1;\r\n          for(_i = 1;(_i <= (_count - 1)) && (_start_item != _last_item);_i++) {\r\n            _start_item = _function_next(_collection_index, _start_item);\r\n            if (_start_item != bytes32(0x0)) {\r\n              _real_count++;\r\n              _items_temp[_i] = _start_item;\r\n            }\r\n          }\r\n          _indexed_bytes_items = new bytes32[](_real_count);\r\n          for(_i = 0;_i <= (_real_count - 1);_i++) {\r\n            _indexed_bytes_items[_i] = _items_temp[_i];\r\n          }\r\n        } else {\r\n          _indexed_bytes_items = new bytes32[](0);\r\n        }\r\n      } else {\r\n        _indexed_bytes_items = new bytes32[](0);\r\n      }\r\n    }\r\n  }*/\r\n}\r\n\r\n// File: @digix/solidity-collections/contracts/lib/DoublyLinkedList.sol\r\nlibrary DoublyLinkedList {\r\n\r\n  struct Item {\r\n    bytes32 item;\r\n    uint256 previous_index;\r\n    uint256 next_index;\r\n  }\r\n\r\n  struct Data {\r\n    uint256 first_index;\r\n    uint256 last_index;\r\n    uint256 count;\r\n    mapping(bytes32 => uint256) item_index;\r\n    mapping(uint256 => bool) valid_indexes;\r\n    Item[] collection;\r\n  }\r\n\r\n  struct IndexedUint {\r\n    mapping(bytes32 => Data) data;\r\n  }\r\n\r\n  struct IndexedAddress {\r\n    mapping(bytes32 => Data) data;\r\n  }\r\n\r\n  struct IndexedBytes {\r\n    mapping(bytes32 => Data) data;\r\n  }\r\n\r\n  struct Address {\r\n    Data data;\r\n  }\r\n\r\n  struct Bytes {\r\n    Data data;\r\n  }\r\n\r\n  struct Uint {\r\n    Data data;\r\n  }\r\n\r\n  uint256 constant NONE = uint256(0);\r\n  bytes32 constant EMPTY_BYTES = bytes32(0x0);\r\n  address constant NULL_ADDRESS = address(0x0);\r\n\r\n  function find(Data storage self, bytes32 _item)\r\n           public\r\n           constant\r\n           returns (uint256 _item_index)\r\n  {\r\n    if ((self.item_index[_item] == NONE) && (self.count == NONE)) {\r\n      _item_index = NONE;\r\n    } else {\r\n      _item_index = self.item_index[_item];\r\n    }\r\n  }\r\n\r\n  function get(Data storage self, uint256 _item_index)\r\n           public\r\n           constant\r\n           returns (bytes32 _item)\r\n  {\r\n    if (self.valid_indexes[_item_index] == true) {\r\n      _item = self.collection[_item_index - 1].item;\r\n    } else {\r\n      _item = EMPTY_BYTES;\r\n    }\r\n  }\r\n\r\n  function append(Data storage self, bytes32 _data)\r\n           internal\r\n           returns (bool _success)\r\n  {\r\n    if (find(self, _data) != NONE || _data == bytes32(\"\")) { // rejects addition of empty values\r\n      _success = false;\r\n    } else {\r\n      uint256 _index = uint256(self.collection.push(Item({item: _data, previous_index: self.last_index, next_index: NONE})));\r\n      if (self.last_index == NONE) {\r\n        if ((self.first_index != NONE) || (self.count != NONE)) {\r\n          revert();\r\n        } else {\r\n          self.first_index = self.last_index = _index;\r\n          self.count = 1;\r\n        }\r\n      } else {\r\n        self.collection[self.last_index - 1].next_index = _index;\r\n        self.last_index = _index;\r\n        self.count++;\r\n      }\r\n      self.valid_indexes[_index] = true;\r\n      self.item_index[_data] = _index;\r\n      _success = true;\r\n    }\r\n  }\r\n\r\n  function remove(Data storage self, uint256 _index)\r\n           internal\r\n           returns (bool _success)\r\n  {\r\n    if (self.valid_indexes[_index] == true) {\r\n      Item memory item = self.collection[_index - 1];\r\n      if (item.previous_index == NONE) {\r\n        self.first_index = item.next_index;\r\n      } else {\r\n        self.collection[item.previous_index - 1].next_index = item.next_index;\r\n      }\r\n\r\n      if (item.next_index == NONE) {\r\n        self.last_index = item.previous_index;\r\n      } else {\r\n        self.collection[item.next_index - 1].previous_index = item.previous_index;\r\n      }\r\n      delete self.collection[_index - 1];\r\n      self.valid_indexes[_index] = false;\r\n      delete self.item_index[item.item];\r\n      self.count--;\r\n      _success = true;\r\n    } else {\r\n      _success = false;\r\n    }\r\n  }\r\n\r\n  function remove_item(Data storage self, bytes32 _item)\r\n           internal\r\n           returns (bool _success)\r\n  {\r\n    uint256 _item_index = find(self, _item);\r\n    if (_item_index != NONE) {\r\n      require(remove(self, _item_index));\r\n      _success = true;\r\n    } else {\r\n      _success = false;\r\n    }\r\n    return _success;\r\n  }\r\n\r\n  function total(Data storage self)\r\n           public\r\n           constant\r\n           returns (uint256 _total_count)\r\n  {\r\n    _total_count = self.count;\r\n  }\r\n\r\n  function start(Data storage self)\r\n           public\r\n           constant\r\n           returns (uint256 _item_index)\r\n  {\r\n    _item_index = self.first_index;\r\n    return _item_index;\r\n  }\r\n\r\n  function start_item(Data storage self)\r\n           public\r\n           constant\r\n           returns (bytes32 _item)\r\n  {\r\n    uint256 _item_index = start(self);\r\n    if (_item_index != NONE) {\r\n      _item = get(self, _item_index);\r\n    } else {\r\n      _item = EMPTY_BYTES;\r\n    }\r\n  }\r\n\r\n  function end(Data storage self)\r\n           public\r\n           constant\r\n           returns (uint256 _item_index)\r\n  {\r\n    _item_index = self.last_index;\r\n    return _item_index;\r\n  }\r\n\r\n  function end_item(Data storage self)\r\n           public\r\n           constant\r\n           returns (bytes32 _item)\r\n  {\r\n    uint256 _item_index = end(self);\r\n    if (_item_index != NONE) {\r\n      _item = get(self, _item_index);\r\n    } else {\r\n      _item = EMPTY_BYTES;\r\n    }\r\n  }\r\n\r\n  function valid(Data storage self, uint256 _item_index)\r\n           public\r\n           constant\r\n           returns (bool _yes)\r\n  {\r\n    _yes = self.valid_indexes[_item_index];\r\n    //_yes = ((_item_index - 1) < self.collection.length);\r\n  }\r\n\r\n  function valid_item(Data storage self, bytes32 _item)\r\n           public\r\n           constant\r\n           returns (bool _yes)\r\n  {\r\n    uint256 _item_index = self.item_index[_item];\r\n    _yes = self.valid_indexes[_item_index];\r\n  }\r\n\r\n  function previous(Data storage self, uint256 _current_index)\r\n           public\r\n           constant\r\n           returns (uint256 _previous_index)\r\n  {\r\n    if (self.valid_indexes[_current_index] == true) {\r\n      _previous_index = self.collection[_current_index - 1].previous_index;\r\n    } else {\r\n      _previous_index = NONE;\r\n    }\r\n  }\r\n\r\n  function previous_item(Data storage self, bytes32 _current_item)\r\n           public\r\n           constant\r\n           returns (bytes32 _previous_item)\r\n  {\r\n    uint256 _current_index = find(self, _current_item);\r\n    if (_current_index != NONE) {\r\n      uint256 _previous_index = previous(self, _current_index);\r\n      _previous_item = get(self, _previous_index);\r\n    } else {\r\n      _previous_item = EMPTY_BYTES;\r\n    }\r\n  }\r\n\r\n  function next(Data storage self, uint256 _current_index)\r\n           public\r\n           constant\r\n           returns (uint256 _next_index)\r\n  {\r\n    if (self.valid_indexes[_current_index] == true) {\r\n      _next_index = self.collection[_current_index - 1].next_index;\r\n    } else {\r\n      _next_index = NONE;\r\n    }\r\n  }\r\n\r\n  function next_item(Data storage self, bytes32 _current_item)\r\n           public\r\n           constant\r\n           returns (bytes32 _next_item)\r\n  {\r\n    uint256 _current_index = find(self, _current_item);\r\n    if (_current_index != NONE) {\r\n      uint256 _next_index = next(self, _current_index);\r\n      _next_item = get(self, _next_index);\r\n    } else {\r\n      _next_item = EMPTY_BYTES;\r\n    }\r\n  }\r\n\r\n  function find(Uint storage self, uint256 _item)\r\n           public\r\n           constant\r\n           returns (uint256 _item_index)\r\n  {\r\n    _item_index = find(self.data, bytes32(_item));\r\n  }\r\n\r\n  function get(Uint storage self, uint256 _item_index)\r\n           public\r\n           constant\r\n           returns (uint256 _item)\r\n  {\r\n    _item = uint256(get(self.data, _item_index));\r\n  }\r\n\r\n\r\n  function append(Uint storage self, uint256 _data)\r\n           public\r\n           returns (bool _success)\r\n  {\r\n    _success = append(self.data, bytes32(_data));\r\n  }\r\n\r\n  function remove(Uint storage self, uint256 _index)\r\n           internal\r\n           returns (bool _success)\r\n  {\r\n    _success = remove(self.data, _index);\r\n  }\r\n\r\n  function remove_item(Uint storage self, uint256 _item)\r\n           public\r\n           returns (bool _success)\r\n  {\r\n    _success = remove_item(self.data, bytes32(_item));\r\n  }\r\n\r\n  function total(Uint storage self)\r\n           public\r\n           constant\r\n           returns (uint256 _total_count)\r\n  {\r\n    _total_count = total(self.data);\r\n  }\r\n\r\n  function start(Uint storage self)\r\n           public\r\n           constant\r\n           returns (uint256 _index)\r\n  {\r\n    _index = start(self.data);\r\n  }\r\n\r\n  function start_item(Uint storage self)\r\n           public\r\n           constant\r\n           returns (uint256 _start_item)\r\n  {\r\n    _start_item = uint256(start_item(self.data));\r\n  }\r\n\r\n\r\n  function end(Uint storage self)\r\n           public\r\n           constant\r\n           returns (uint256 _index)\r\n  {\r\n    _index = end(self.data);\r\n  }\r\n\r\n  function end_item(Uint storage self)\r\n           public\r\n           constant\r\n           returns (uint256 _end_item)\r\n  {\r\n    _end_item = uint256(end_item(self.data));\r\n  }\r\n\r\n  function valid(Uint storage self, uint256 _item_index)\r\n           public\r\n           constant\r\n           returns (bool _yes)\r\n  {\r\n    _yes = valid(self.data, _item_index);\r\n  }\r\n\r\n  function valid_item(Uint storage self, uint256 _item)\r\n           public\r\n           constant\r\n           returns (bool _yes)\r\n  {\r\n    _yes = valid_item(self.data, bytes32(_item));\r\n  }\r\n\r\n  function previous(Uint storage self, uint256 _current_index)\r\n           public\r\n           constant\r\n           returns (uint256 _previous_index)\r\n  {\r\n    _previous_index = previous(self.data, _current_index);\r\n  }\r\n\r\n  function previous_item(Uint storage self, uint256 _current_item)\r\n           public\r\n           constant\r\n           returns (uint256 _previous_item)\r\n  {\r\n    _previous_item = uint256(previous_item(self.data, bytes32(_current_item)));\r\n  }\r\n\r\n  function next(Uint storage self, uint256 _current_index)\r\n           public\r\n           constant\r\n           returns (uint256 _next_index)\r\n  {\r\n    _next_index = next(self.data, _current_index);\r\n  }\r\n\r\n  function next_item(Uint storage self, uint256 _current_item)\r\n           public\r\n           constant\r\n           returns (uint256 _next_item)\r\n  {\r\n    _next_item = uint256(next_item(self.data, bytes32(_current_item)));\r\n  }\r\n\r\n  function find(Address storage self, address _item)\r\n           public\r\n           constant\r\n           returns (uint256 _item_index)\r\n  {\r\n    _item_index = find(self.data, bytes32(_item));\r\n  }\r\n\r\n  function get(Address storage self, uint256 _item_index)\r\n           public\r\n           constant\r\n           returns (address _item)\r\n  {\r\n    _item = address(get(self.data, _item_index));\r\n  }\r\n\r\n\r\n  function find(IndexedUint storage self, bytes32 _collection_index, uint256 _item)\r\n           public\r\n           constant\r\n           returns (uint256 _item_index)\r\n  {\r\n    _item_index = find(self.data[_collection_index], bytes32(_item));\r\n  }\r\n\r\n  function get(IndexedUint storage self, bytes32 _collection_index, uint256 _item_index)\r\n           public\r\n           constant\r\n           returns (uint256 _item)\r\n  {\r\n    _item = uint256(get(self.data[_collection_index], _item_index));\r\n  }\r\n\r\n\r\n  function append(IndexedUint storage self, bytes32 _collection_index, uint256 _data)\r\n           public\r\n           returns (bool _success)\r\n  {\r\n    _success = append(self.data[_collection_index], bytes32(_data));\r\n  }\r\n\r\n  function remove(IndexedUint storage self, bytes32 _collection_index, uint256 _index)\r\n           internal\r\n           returns (bool _success)\r\n  {\r\n    _success = remove(self.data[_collection_index], _index);\r\n  }\r\n\r\n  function remove_item(IndexedUint storage self, bytes32 _collection_index, uint256 _item)\r\n           public\r\n           returns (bool _success)\r\n  {\r\n    _success = remove_item(self.data[_collection_index], bytes32(_item));\r\n  }\r\n\r\n  function total(IndexedUint storage self, bytes32 _collection_index)\r\n           public\r\n           constant\r\n           returns (uint256 _total_count)\r\n  {\r\n    _total_count = total(self.data[_collection_index]);\r\n  }\r\n\r\n  function start(IndexedUint storage self, bytes32 _collection_index)\r\n           public\r\n           constant\r\n           returns (uint256 _index)\r\n  {\r\n    _index = start(self.data[_collection_index]);\r\n  }\r\n\r\n  function start_item(IndexedUint storage self, bytes32 _collection_index)\r\n           public\r\n           constant\r\n           returns (uint256 _start_item)\r\n  {\r\n    _start_item = uint256(start_item(self.data[_collection_index]));\r\n  }\r\n\r\n\r\n  function end(IndexedUint storage self, bytes32 _collection_index)\r\n           public\r\n           constant\r\n           returns (uint256 _index)\r\n  {\r\n    _index = end(self.data[_collection_index]);\r\n  }\r\n\r\n  function end_item(IndexedUint storage self, bytes32 _collection_index)\r\n           public\r\n           constant\r\n           returns (uint256 _end_item)\r\n  {\r\n    _end_item = uint256(end_item(self.data[_collection_index]));\r\n  }\r\n\r\n  function valid(IndexedUint storage self, bytes32 _collection_index, uint256 _item_index)\r\n           public\r\n           constant\r\n           returns (bool _yes)\r\n  {\r\n    _yes = valid(self.data[_collection_index], _item_index);\r\n  }\r\n\r\n  function valid_item(IndexedUint storage self, bytes32 _collection_index, uint256 _item)\r\n           public\r\n           constant\r\n           returns (bool _yes)\r\n  {\r\n    _yes = valid_item(self.data[_collection_index], bytes32(_item));\r\n  }\r\n\r\n  function previous(IndexedUint storage self, bytes32 _collection_index, uint256 _current_index)\r\n           public\r\n           constant\r\n           returns (uint256 _previous_index)\r\n  {\r\n    _previous_index = previous(self.data[_collection_index], _current_index);\r\n  }\r\n\r\n  function previous_item(IndexedUint storage self, bytes32 _collection_index, uint256 _current_item)\r\n           public\r\n           constant\r\n           returns (uint256 _previous_item)\r\n  {\r\n    _previous_item = uint256(previous_item(self.data[_collection_index], bytes32(_current_item)));\r\n  }\r\n\r\n  function next(IndexedUint storage self, bytes32 _collection_index, uint256 _current_index)\r\n           public\r\n           constant\r\n           returns (uint256 _next_index)\r\n  {\r\n    _next_index = next(self.data[_collection_index], _current_index);\r\n  }\r\n\r\n  function next_item(IndexedUint storage self, bytes32 _collection_index, uint256 _current_item)\r\n           public\r\n           constant\r\n           returns (uint256 _next_item)\r\n  {\r\n    _next_item = uint256(next_item(self.data[_collection_index], bytes32(_current_item)));\r\n  }\r\n\r\n  function append(Address storage self, address _data)\r\n           public\r\n           returns (bool _success)\r\n  {\r\n    _success = append(self.data, bytes32(_data));\r\n  }\r\n\r\n  function remove(Address storage self, uint256 _index)\r\n           internal\r\n           returns (bool _success)\r\n  {\r\n    _success = remove(self.data, _index);\r\n  }\r\n\r\n\r\n  function remove_item(Address storage self, address _item)\r\n           public\r\n           returns (bool _success)\r\n  {\r\n    _success = remove_item(self.data, bytes32(_item));\r\n  }\r\n\r\n  function total(Address storage self)\r\n           public\r\n           constant\r\n           returns (uint256 _total_count)\r\n  {\r\n    _total_count = total(self.data);\r\n  }\r\n\r\n  function start(Address storage self)\r\n           public\r\n           constant\r\n           returns (uint256 _index)\r\n  {\r\n    _index = start(self.data);\r\n  }\r\n\r\n  function start_item(Address storage self)\r\n           public\r\n           constant\r\n           returns (address _start_item)\r\n  {\r\n    _start_item = address(start_item(self.data));\r\n  }\r\n\r\n\r\n  function end(Address storage self)\r\n           public\r\n           constant\r\n           returns (uint256 _index)\r\n  {\r\n    _index = end(self.data);\r\n  }\r\n\r\n  function end_item(Address storage self)\r\n           public\r\n           constant\r\n           returns (address _end_item)\r\n  {\r\n    _end_item = address(end_item(self.data));\r\n  }\r\n\r\n  function valid(Address storage self, uint256 _item_index)\r\n           public\r\n           constant\r\n           returns (bool _yes)\r\n  {\r\n    _yes = valid(self.data, _item_index);\r\n  }\r\n\r\n  function valid_item(Address storage self, address _item)\r\n           public\r\n           constant\r\n           returns (bool _yes)\r\n  {\r\n    _yes = valid_item(self.data, bytes32(_item));\r\n  }\r\n\r\n  function previous(Address storage self, uint256 _current_index)\r\n           public\r\n           constant\r\n           returns (uint256 _previous_index)\r\n  {\r\n    _previous_index = previous(self.data, _current_index);\r\n  }\r\n\r\n  function previous_item(Address storage self, address _current_item)\r\n           public\r\n           constant\r\n           returns (address _previous_item)\r\n  {\r\n    _previous_item = address(previous_item(self.data, bytes32(_current_item)));\r\n  }\r\n\r\n  function next(Address storage self, uint256 _current_index)\r\n           public\r\n           constant\r\n           returns (uint256 _next_index)\r\n  {\r\n    _next_index = next(self.data, _current_index);\r\n  }\r\n\r\n  function next_item(Address storage self, address _current_item)\r\n           public\r\n           constant\r\n           returns (address _next_item)\r\n  {\r\n    _next_item = address(next_item(self.data, bytes32(_current_item)));\r\n  }\r\n\r\n  function append(IndexedAddress storage self, bytes32 _collection_index, address _data)\r\n           public\r\n           returns (bool _success)\r\n  {\r\n    _success = append(self.data[_collection_index], bytes32(_data));\r\n  }\r\n\r\n  function remove(IndexedAddress storage self, bytes32 _collection_index, uint256 _index)\r\n           internal\r\n           returns (bool _success)\r\n  {\r\n    _success = remove(self.data[_collection_index], _index);\r\n  }\r\n\r\n\r\n  function remove_item(IndexedAddress storage self, bytes32 _collection_index, address _item)\r\n           public\r\n           returns (bool _success)\r\n  {\r\n    _success = remove_item(self.data[_collection_index], bytes32(_item));\r\n  }\r\n\r\n  function total(IndexedAddress storage self, bytes32 _collection_index)\r\n           public\r\n           constant\r\n           returns (uint256 _total_count)\r\n  {\r\n    _total_count = total(self.data[_collection_index]);\r\n  }\r\n\r\n  function start(IndexedAddress storage self, bytes32 _collection_index)\r\n           public\r\n           constant\r\n           returns (uint256 _index)\r\n  {\r\n    _index = start(self.data[_collection_index]);\r\n  }\r\n\r\n  function start_item(IndexedAddress storage self, bytes32 _collection_index)\r\n           public\r\n           constant\r\n           returns (address _start_item)\r\n  {\r\n    _start_item = address(start_item(self.data[_collection_index]));\r\n  }\r\n\r\n\r\n  function end(IndexedAddress storage self, bytes32 _collection_index)\r\n           public\r\n           constant\r\n           returns (uint256 _index)\r\n  {\r\n    _index = end(self.data[_collection_index]);\r\n  }\r\n\r\n  function end_item(IndexedAddress storage self, bytes32 _collection_index)\r\n           public\r\n           constant\r\n           returns (address _end_item)\r\n  {\r\n    _end_item = address(end_item(self.data[_collection_index]));\r\n  }\r\n\r\n  function valid(IndexedAddress storage self, bytes32 _collection_index, uint256 _item_index)\r\n           public\r\n           constant\r\n           returns (bool _yes)\r\n  {\r\n    _yes = valid(self.data[_collection_index], _item_index);\r\n  }\r\n\r\n  function valid_item(IndexedAddress storage self, bytes32 _collection_index, address _item)\r\n           public\r\n           constant\r\n           returns (bool _yes)\r\n  {\r\n    _yes = valid_item(self.data[_collection_index], bytes32(_item));\r\n  }\r\n\r\n  function previous(IndexedAddress storage self, bytes32 _collection_index, uint256 _current_index)\r\n           public\r\n           constant\r\n           returns (uint256 _previous_index)\r\n  {\r\n    _previous_index = previous(self.data[_collection_index], _current_index);\r\n  }\r\n\r\n  function previous_item(IndexedAddress storage self, bytes32 _collection_index, address _current_item)\r\n           public\r\n           constant\r\n           returns (address _previous_item)\r\n  {\r\n    _previous_item = address(previous_item(self.data[_collection_index], bytes32(_current_item)));\r\n  }\r\n\r\n  function next(IndexedAddress storage self, bytes32 _collection_index, uint256 _current_index)\r\n           public\r\n           constant\r\n           returns (uint256 _next_index)\r\n  {\r\n    _next_index = next(self.data[_collection_index], _current_index);\r\n  }\r\n\r\n  function next_item(IndexedAddress storage self, bytes32 _collection_index, address _current_item)\r\n           public\r\n           constant\r\n           returns (address _next_item)\r\n  {\r\n    _next_item = address(next_item(self.data[_collection_index], bytes32(_current_item)));\r\n  }\r\n\r\n\r\n  function find(Bytes storage self, bytes32 _item)\r\n           public\r\n           constant\r\n           returns (uint256 _item_index)\r\n  {\r\n    _item_index = find(self.data, _item);\r\n  }\r\n\r\n  function get(Bytes storage self, uint256 _item_index)\r\n           public\r\n           constant\r\n           returns (bytes32 _item)\r\n  {\r\n    _item = get(self.data, _item_index);\r\n  }\r\n\r\n\r\n  function append(Bytes storage self, bytes32 _data)\r\n           public\r\n           returns (bool _success)\r\n  {\r\n    _success = append(self.data, _data);\r\n  }\r\n\r\n  function remove(Bytes storage self, uint256 _index)\r\n           internal\r\n           returns (bool _success)\r\n  {\r\n    _success = remove(self.data, _index);\r\n  }\r\n\r\n\r\n  function remove_item(Bytes storage self, bytes32 _item)\r\n           public\r\n           returns (bool _success)\r\n  {\r\n    _success = remove_item(self.data, _item);\r\n  }\r\n\r\n  function total(Bytes storage self)\r\n           public\r\n           constant\r\n           returns (uint256 _total_count)\r\n  {\r\n    _total_count = total(self.data);\r\n  }\r\n\r\n  function start(Bytes storage self)\r\n           public\r\n           constant\r\n           returns (uint256 _index)\r\n  {\r\n    _index = start(self.data);\r\n  }\r\n\r\n  function start_item(Bytes storage self)\r\n           public\r\n           constant\r\n           returns (bytes32 _start_item)\r\n  {\r\n    _start_item = start_item(self.data);\r\n  }\r\n\r\n\r\n  function end(Bytes storage self)\r\n           public\r\n           constant\r\n           returns (uint256 _index)\r\n  {\r\n    _index = end(self.data);\r\n  }\r\n\r\n  function end_item(Bytes storage self)\r\n           public\r\n           constant\r\n           returns (bytes32 _end_item)\r\n  {\r\n    _end_item = end_item(self.data);\r\n  }\r\n\r\n  function valid(Bytes storage self, uint256 _item_index)\r\n           public\r\n           constant\r\n           returns (bool _yes)\r\n  {\r\n    _yes = valid(self.data, _item_index);\r\n  }\r\n\r\n  function valid_item(Bytes storage self, bytes32 _item)\r\n           public\r\n           constant\r\n           returns (bool _yes)\r\n  {\r\n    _yes = valid_item(self.data, _item);\r\n  }\r\n\r\n  function previous(Bytes storage self, uint256 _current_index)\r\n           public\r\n           constant\r\n           returns (uint256 _previous_index)\r\n  {\r\n    _previous_index = previous(self.data, _current_index);\r\n  }\r\n\r\n  function previous_item(Bytes storage self, bytes32 _current_item)\r\n           public\r\n           constant\r\n           returns (bytes32 _previous_item)\r\n  {\r\n    _previous_item = previous_item(self.data, _current_item);\r\n  }\r\n\r\n  function next(Bytes storage self, uint256 _current_index)\r\n           public\r\n           constant\r\n           returns (uint256 _next_index)\r\n  {\r\n    _next_index = next(self.data, _current_index);\r\n  }\r\n\r\n  function next_item(Bytes storage self, bytes32 _current_item)\r\n           public\r\n           constant\r\n           returns (bytes32 _next_item)\r\n  {\r\n    _next_item = next_item(self.data, _current_item);\r\n  }\r\n\r\n  function append(IndexedBytes storage self, bytes32 _collection_index, bytes32 _data)\r\n           public\r\n           returns (bool _success)\r\n  {\r\n    _success = append(self.data[_collection_index], bytes32(_data));\r\n  }\r\n\r\n  function remove(IndexedBytes storage self, bytes32 _collection_index, uint256 _index)\r\n           internal\r\n           returns (bool _success)\r\n  {\r\n    _success = remove(self.data[_collection_index], _index);\r\n  }\r\n\r\n\r\n  function remove_item(IndexedBytes storage self, bytes32 _collection_index, bytes32 _item)\r\n           public\r\n           returns (bool _success)\r\n  {\r\n    _success = remove_item(self.data[_collection_index], bytes32(_item));\r\n  }\r\n\r\n  function total(IndexedBytes storage self, bytes32 _collection_index)\r\n           public\r\n           constant\r\n           returns (uint256 _total_count)\r\n  {\r\n    _total_count = total(self.data[_collection_index]);\r\n  }\r\n\r\n  function start(IndexedBytes storage self, bytes32 _collection_index)\r\n           public\r\n           constant\r\n           returns (uint256 _index)\r\n  {\r\n    _index = start(self.data[_collection_index]);\r\n  }\r\n\r\n  function start_item(IndexedBytes storage self, bytes32 _collection_index)\r\n           public\r\n           constant\r\n           returns (bytes32 _start_item)\r\n  {\r\n    _start_item = bytes32(start_item(self.data[_collection_index]));\r\n  }\r\n\r\n\r\n  function end(IndexedBytes storage self, bytes32 _collection_index)\r\n           public\r\n           constant\r\n           returns (uint256 _index)\r\n  {\r\n    _index = end(self.data[_collection_index]);\r\n  }\r\n\r\n  function end_item(IndexedBytes storage self, bytes32 _collection_index)\r\n           public\r\n           constant\r\n           returns (bytes32 _end_item)\r\n  {\r\n    _end_item = bytes32(end_item(self.data[_collection_index]));\r\n  }\r\n\r\n  function valid(IndexedBytes storage self, bytes32 _collection_index, uint256 _item_index)\r\n           public\r\n           constant\r\n           returns (bool _yes)\r\n  {\r\n    _yes = valid(self.data[_collection_index], _item_index);\r\n  }\r\n\r\n  function valid_item(IndexedBytes storage self, bytes32 _collection_index, bytes32 _item)\r\n           public\r\n           constant\r\n           returns (bool _yes)\r\n  {\r\n    _yes = valid_item(self.data[_collection_index], bytes32(_item));\r\n  }\r\n\r\n  function previous(IndexedBytes storage self, bytes32 _collection_index, uint256 _current_index)\r\n           public\r\n           constant\r\n           returns (uint256 _previous_index)\r\n  {\r\n    _previous_index = previous(self.data[_collection_index], _current_index);\r\n  }\r\n\r\n  function previous_item(IndexedBytes storage self, bytes32 _collection_index, bytes32 _current_item)\r\n           public\r\n           constant\r\n           returns (bytes32 _previous_item)\r\n  {\r\n    _previous_item = bytes32(previous_item(self.data[_collection_index], bytes32(_current_item)));\r\n  }\r\n\r\n  function next(IndexedBytes storage self, bytes32 _collection_index, uint256 _current_index)\r\n           public\r\n           constant\r\n           returns (uint256 _next_index)\r\n  {\r\n    _next_index = next(self.data[_collection_index], _current_index);\r\n  }\r\n\r\n  function next_item(IndexedBytes storage self, bytes32 _collection_index, bytes32 _current_item)\r\n           public\r\n           constant\r\n           returns (bytes32 _next_item)\r\n  {\r\n    _next_item = bytes32(next_item(self.data[_collection_index], bytes32(_current_item)));\r\n  }\r\n}\r\n\r\n// File: @digix/solidity-collections/contracts/abstract/BytesIteratorStorage.sol\r\n/**\r\n  @title Bytes Iterator Storage\r\n  @author DigixGlobal Pte Ltd\r\n*/\r\ncontract BytesIteratorStorage {\r\n\r\n  // Initialize Doubly Linked List of Bytes\r\n  using DoublyLinkedList for DoublyLinkedList.Bytes;\r\n\r\n  /**\r\n    @notice Reads the first item from the list of Bytes\r\n    @param _list The source list\r\n    @return {\"_item\": \"The first item from the list\"}\r\n  */\r\n  function read_first_from_bytesarray(DoublyLinkedList.Bytes storage _list)\r\n           internal\r\n           constant\r\n           returns (bytes32 _item)\r\n  {\r\n    _item = _list.start_item();\r\n  }\r\n\r\n  /**\r\n    @notice Reads the last item from the list of Bytes\r\n    @param _list The source list\r\n    @return {\"_item\": \"The last item from the list\"}\r\n  */\r\n  function read_last_from_bytesarray(DoublyLinkedList.Bytes storage _list)\r\n           internal\r\n           constant\r\n           returns (bytes32 _item)\r\n  {\r\n    _item = _list.end_item();\r\n  }\r\n\r\n  /**\r\n    @notice Reads the next item on the list of Bytes\r\n    @param _list The source list\r\n    @param _current_item The current item to be used as base line\r\n    @return {\"_item\": \"The next item from the list based on the specieid `_current_item`\"}\r\n    TODO: Need to verify what happens if the specified `_current_item` is the last item from the list\r\n  */\r\n  function read_next_from_bytesarray(DoublyLinkedList.Bytes storage _list, bytes32 _current_item)\r\n           internal\r\n           constant\r\n           returns (bytes32 _item)\r\n  {\r\n    _item = _list.next_item(_current_item);\r\n  }\r\n\r\n  /**\r\n    @notice Reads the previous item on the list of Bytes\r\n    @param _list The source list\r\n    @param _current_item The current item to be used as base line\r\n    @return {\"_item\": \"The previous item from the list based on the spcified `_current_item`\"}\r\n    TODO: Need to verify what happens if the specified `_current_item` is the first item from the list\r\n  */\r\n  function read_previous_from_bytesarray(DoublyLinkedList.Bytes storage _list, bytes32 _current_item)\r\n           internal\r\n           constant\r\n           returns (bytes32 _item)\r\n  {\r\n    _item = _list.previous_item(_current_item);\r\n  }\r\n\r\n  /**\r\n    @notice Reads the list of Bytes and returns the length of the list\r\n    @param _list The source list\r\n    @return {\"count\": \"`uint256` The lenght of the list\"}\r\n\r\n  */\r\n  function read_total_bytesarray(DoublyLinkedList.Bytes storage _list)\r\n           internal\r\n           constant\r\n           returns (uint256 _count)\r\n  {\r\n    _count = _list.total();\r\n  }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/math/SafeMath.sol\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\r\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (_a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    c = _a * _b;\r\n    assert(c / _a == _b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    // assert(_b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = _a / _b;\r\n    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\r\n    return _a / _b;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    assert(_b <= _a);\r\n    return _a - _b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\r\n    c = _a + _b;\r\n    assert(c >= _a);\r\n    return c;\r\n  }\r\n}\r\n\r\n// File: contracts/common/DaoConstants.sol\r\ncontract DaoConstants {\r\n    using SafeMath for uint256;\r\n    bytes32 EMPTY_BYTES = bytes32(0x0);\r\n    address EMPTY_ADDRESS = address(0x0);\r\n\r\n\r\n    bytes32 PROPOSAL_STATE_PREPROPOSAL = \"proposal_state_preproposal\";\r\n    bytes32 PROPOSAL_STATE_DRAFT = \"proposal_state_draft\";\r\n    bytes32 PROPOSAL_STATE_MODERATED = \"proposal_state_moderated\";\r\n    bytes32 PROPOSAL_STATE_ONGOING = \"proposal_state_ongoing\";\r\n    bytes32 PROPOSAL_STATE_CLOSED = \"proposal_state_closed\";\r\n    bytes32 PROPOSAL_STATE_ARCHIVED = \"proposal_state_archived\";\r\n\r\n    uint256 PRL_ACTION_STOP = 1;\r\n    uint256 PRL_ACTION_PAUSE = 2;\r\n    uint256 PRL_ACTION_UNPAUSE = 3;\r\n\r\n    uint256 COLLATERAL_STATUS_UNLOCKED = 1;\r\n    uint256 COLLATERAL_STATUS_LOCKED = 2;\r\n    uint256 COLLATERAL_STATUS_CLAIMED = 3;\r\n\r\n    bytes32 INTERMEDIATE_DGD_IDENTIFIER = \"inter_dgd_id\";\r\n    bytes32 INTERMEDIATE_MODERATOR_DGD_IDENTIFIER = \"inter_mod_dgd_id\";\r\n    bytes32 INTERMEDIATE_BONUS_CALCULATION_IDENTIFIER = \"inter_bonus_calculation_id\";\r\n\r\n    // interactive contracts\r\n    bytes32 CONTRACT_DAO = \"dao\";\r\n    bytes32 CONTRACT_DAO_SPECIAL_PROPOSAL = \"dao:special:proposal\";\r\n    bytes32 CONTRACT_DAO_STAKE_LOCKING = \"dao:stake-locking\";\r\n    bytes32 CONTRACT_DAO_VOTING = \"dao:voting\";\r\n    bytes32 CONTRACT_DAO_VOTING_CLAIMS = \"dao:voting:claims\";\r\n    bytes32 CONTRACT_DAO_SPECIAL_VOTING_CLAIMS = \"dao:svoting:claims\";\r\n    bytes32 CONTRACT_DAO_IDENTITY = \"dao:identity\";\r\n    bytes32 CONTRACT_DAO_REWARDS_MANAGER = \"dao:rewards-manager\";\r\n    bytes32 CONTRACT_DAO_REWARDS_MANAGER_EXTRAS = \"dao:rewards-extras\";\r\n    bytes32 CONTRACT_DAO_ROLES = \"dao:roles\";\r\n    bytes32 CONTRACT_DAO_FUNDING_MANAGER = \"dao:funding-manager\";\r\n    bytes32 CONTRACT_DAO_WHITELISTING = \"dao:whitelisting\";\r\n    bytes32 CONTRACT_DAO_INFORMATION = \"dao:information\";\r\n\r\n    // service contracts\r\n    bytes32 CONTRACT_SERVICE_ROLE = \"service:role\";\r\n    bytes32 CONTRACT_SERVICE_DAO_INFO = \"service:dao:info\";\r\n    bytes32 CONTRACT_SERVICE_DAO_LISTING = \"service:dao:listing\";\r\n    bytes32 CONTRACT_SERVICE_DAO_CALCULATOR = \"service:dao:calculator\";\r\n\r\n    // storage contracts\r\n    bytes32 CONTRACT_STORAGE_DAO = \"storage:dao\";\r\n    bytes32 CONTRACT_STORAGE_DAO_COUNTER = \"storage:dao:counter\";\r\n    bytes32 CONTRACT_STORAGE_DAO_UPGRADE = \"storage:dao:upgrade\";\r\n    bytes32 CONTRACT_STORAGE_DAO_IDENTITY = \"storage:dao:identity\";\r\n    bytes32 CONTRACT_STORAGE_DAO_POINTS = \"storage:dao:points\";\r\n    bytes32 CONTRACT_STORAGE_DAO_SPECIAL = \"storage:dao:special\";\r\n    bytes32 CONTRACT_STORAGE_DAO_CONFIG = \"storage:dao:config\";\r\n    bytes32 CONTRACT_STORAGE_DAO_STAKE = \"storage:dao:stake\";\r\n    bytes32 CONTRACT_STORAGE_DAO_REWARDS = \"storage:dao:rewards\";\r\n    bytes32 CONTRACT_STORAGE_DAO_WHITELISTING = \"storage:dao:whitelisting\";\r\n    bytes32 CONTRACT_STORAGE_INTERMEDIATE_RESULTS = \"storage:intermediate:results\";\r\n\r\n    bytes32 CONTRACT_DGD_TOKEN = \"t:dgd\";\r\n    bytes32 CONTRACT_DGX_TOKEN = \"t:dgx\";\r\n    bytes32 CONTRACT_BADGE_TOKEN = \"t:badge\";\r\n\r\n    uint8 ROLES_ROOT = 1;\r\n    uint8 ROLES_FOUNDERS = 2;\r\n    uint8 ROLES_PRLS = 3;\r\n    uint8 ROLES_KYC_ADMINS = 4;\r\n\r\n    uint256 QUARTER_DURATION = 90 days;\r\n\r\n    bytes32 CONFIG_MINIMUM_LOCKED_DGD = \"min_dgd_participant\";\r\n    bytes32 CONFIG_MINIMUM_DGD_FOR_MODERATOR = \"min_dgd_moderator\";\r\n    bytes32 CONFIG_MINIMUM_REPUTATION_FOR_MODERATOR = \"min_reputation_moderator\";\r\n\r\n    bytes32 CONFIG_LOCKING_PHASE_DURATION = \"locking_phase_duration\";\r\n    bytes32 CONFIG_QUARTER_DURATION = \"quarter_duration\";\r\n    bytes32 CONFIG_VOTING_COMMIT_PHASE = \"voting_commit_phase\";\r\n    bytes32 CONFIG_VOTING_PHASE_TOTAL = \"voting_phase_total\";\r\n    bytes32 CONFIG_INTERIM_COMMIT_PHASE = \"interim_voting_commit_phase\";\r\n    bytes32 CONFIG_INTERIM_PHASE_TOTAL = \"interim_voting_phase_total\";\r\n\r\n    bytes32 CONFIG_DRAFT_QUORUM_FIXED_PORTION_NUMERATOR = \"draft_quorum_fixed_numerator\";\r\n    bytes32 CONFIG_DRAFT_QUORUM_FIXED_PORTION_DENOMINATOR = \"draft_quorum_fixed_denominator\";\r\n    bytes32 CONFIG_DRAFT_QUORUM_SCALING_FACTOR_NUMERATOR = \"draft_quorum_sfactor_numerator\";\r\n    bytes32 CONFIG_DRAFT_QUORUM_SCALING_FACTOR_DENOMINATOR = \"draft_quorum_sfactor_denominator\";\r\n    bytes32 CONFIG_VOTING_QUORUM_FIXED_PORTION_NUMERATOR = \"vote_quorum_fixed_numerator\";\r\n    bytes32 CONFIG_VOTING_QUORUM_FIXED_PORTION_DENOMINATOR = \"vote_quorum_fixed_denominator\";\r\n    bytes32 CONFIG_VOTING_QUORUM_SCALING_FACTOR_NUMERATOR = \"vote_quorum_sfactor_numerator\";\r\n    bytes32 CONFIG_VOTING_QUORUM_SCALING_FACTOR_DENOMINATOR = \"vote_quorum_sfactor_denominator\";\r\n    bytes32 CONFIG_FINAL_REWARD_SCALING_FACTOR_NUMERATOR = \"final_reward_sfactor_numerator\";\r\n    bytes32 CONFIG_FINAL_REWARD_SCALING_FACTOR_DENOMINATOR = \"final_reward_sfactor_denominator\";\r\n\r\n    bytes32 CONFIG_DRAFT_QUOTA_NUMERATOR = \"draft_quota_numerator\";\r\n    bytes32 CONFIG_DRAFT_QUOTA_DENOMINATOR = \"draft_quota_denominator\";\r\n    bytes32 CONFIG_VOTING_QUOTA_NUMERATOR = \"voting_quota_numerator\";\r\n    bytes32 CONFIG_VOTING_QUOTA_DENOMINATOR = \"voting_quota_denominator\";\r\n\r\n    bytes32 CONFIG_MINIMAL_QUARTER_POINT = \"minimal_qp\";\r\n    bytes32 CONFIG_QUARTER_POINT_SCALING_FACTOR = \"quarter_point_scaling_factor\";\r\n    bytes32 CONFIG_REPUTATION_POINT_SCALING_FACTOR = \"rep_point_scaling_factor\";\r\n\r\n    bytes32 CONFIG_MODERATOR_MINIMAL_QUARTER_POINT = \"minimal_mod_qp\";\r\n    bytes32 CONFIG_MODERATOR_QUARTER_POINT_SCALING_FACTOR = \"mod_qp_scaling_factor\";\r\n    bytes32 CONFIG_MODERATOR_REPUTATION_POINT_SCALING_FACTOR = \"mod_rep_point_scaling_factor\";\r\n\r\n    bytes32 CONFIG_QUARTER_POINT_DRAFT_VOTE = \"quarter_point_draft_vote\";\r\n    bytes32 CONFIG_QUARTER_POINT_VOTE = \"quarter_point_vote\";\r\n    bytes32 CONFIG_QUARTER_POINT_INTERIM_VOTE = \"quarter_point_interim_vote\";\r\n\r\n    /// this is per 10000 ETHs\r\n    bytes32 CONFIG_QUARTER_POINT_MILESTONE_COMPLETION_PER_10000ETH = \"q_p_milestone_completion\";\r\n\r\n    bytes32 CONFIG_BONUS_REPUTATION_NUMERATOR = \"bonus_reputation_numerator\";\r\n    bytes32 CONFIG_BONUS_REPUTATION_DENOMINATOR = \"bonus_reputation_denominator\";\r\n\r\n    bytes32 CONFIG_SPECIAL_PROPOSAL_COMMIT_PHASE = \"special_proposal_commit_phase\";\r\n    bytes32 CONFIG_SPECIAL_PROPOSAL_PHASE_TOTAL = \"special_proposal_phase_total\";\r\n\r\n    bytes32 CONFIG_SPECIAL_QUOTA_NUMERATOR = \"config_special_quota_numerator\";\r\n    bytes32 CONFIG_SPECIAL_QUOTA_DENOMINATOR = \"config_special_quota_denominator\";\r\n\r\n    bytes32 CONFIG_SPECIAL_PROPOSAL_QUORUM_NUMERATOR = \"special_quorum_numerator\";\r\n    bytes32 CONFIG_SPECIAL_PROPOSAL_QUORUM_DENOMINATOR = \"special_quorum_denominator\";\r\n\r\n    bytes32 CONFIG_MAXIMUM_REPUTATION_DEDUCTION = \"config_max_reputation_deduction\";\r\n    bytes32 CONFIG_PUNISHMENT_FOR_NOT_LOCKING = \"config_punishment_not_locking\";\r\n\r\n    bytes32 CONFIG_REPUTATION_PER_EXTRA_QP_NUM = \"config_rep_per_extra_qp_num\";\r\n    bytes32 CONFIG_REPUTATION_PER_EXTRA_QP_DEN = \"config_rep_per_extra_qp_den\";\r\n\r\n    bytes32 CONFIG_MAXIMUM_MODERATOR_REPUTATION_DEDUCTION = \"config_max_m_rp_deduction\";\r\n    bytes32 CONFIG_REPUTATION_PER_EXTRA_MODERATOR_QP_NUM = \"config_rep_per_extra_m_qp_num\";\r\n    bytes32 CONFIG_REPUTATION_PER_EXTRA_MODERATOR_QP_DEN = \"config_rep_per_extra_m_qp_den\";\r\n\r\n    bytes32 CONFIG_PORTION_TO_MODERATORS_NUM = \"config_mod_portion_num\";\r\n    bytes32 CONFIG_PORTION_TO_MODERATORS_DEN = \"config_mod_portion_den\";\r\n\r\n    bytes32 CONFIG_DRAFT_VOTING_PHASE = \"config_draft_voting_phase\";\r\n\r\n    bytes32 CONFIG_REPUTATION_POINT_BOOST_FOR_BADGE = \"config_rp_boost_per_badge\";\r\n\r\n    bytes32 CONFIG_VOTE_CLAIMING_DEADLINE = \"config_claiming_deadline\";\r\n\r\n    bytes32 CONFIG_PREPROPOSAL_COLLATERAL = \"config_preproposal_collateral\";\r\n\r\n    bytes32 CONFIG_MAX_FUNDING_FOR_NON_DIGIX = \"config_max_funding_nonDigix\";\r\n    bytes32 CONFIG_MAX_MILESTONES_FOR_NON_DIGIX = \"config_max_milestones_nonDigix\";\r\n    bytes32 CONFIG_NON_DIGIX_PROPOSAL_CAP_PER_QUARTER = \"config_nonDigix_proposal_cap\";\r\n\r\n    bytes32 CONFIG_PROPOSAL_DEAD_DURATION = \"config_dead_duration\";\r\n    bytes32 CONFIG_CARBON_VOTE_REPUTATION_BONUS = \"config_cv_reputation\";\r\n}\r\n\r\n// File: @digix/cacp-contracts-dao/contracts/ACOwned.sol\r\n/// @title Owner based access control\r\n/// @author DigixGlobal\r\ncontract ACOwned {\r\n\r\n  address public owner;\r\n  address public new_owner;\r\n  bool is_ac_owned_init;\r\n\r\n  /// @dev Modifier to check if msg.sender is the contract owner\r\n  modifier if_owner() {\r\n    require(is_owner());\r\n    _;\r\n  }\r\n\r\n  function init_ac_owned()\r\n           internal\r\n           returns (bool _success)\r\n  {\r\n    if (is_ac_owned_init == false) {\r\n      owner = msg.sender;\r\n      is_ac_owned_init = true;\r\n    }\r\n    _success = true;\r\n  }\r\n\r\n  function is_owner()\r\n           private\r\n           constant\r\n           returns (bool _is_owner)\r\n  {\r\n    _is_owner = (msg.sender == owner);\r\n  }\r\n\r\n  function change_owner(address _new_owner)\r\n           if_owner()\r\n           public\r\n           returns (bool _success)\r\n  {\r\n    new_owner = _new_owner;\r\n    _success = true;\r\n  }\r\n\r\n  function claim_ownership()\r\n           public\r\n           returns (bool _success)\r\n  {\r\n    require(msg.sender == new_owner);\r\n    owner = new_owner;\r\n    _success = true;\r\n  }\r\n}\r\n\r\n// File: @digix/cacp-contracts-dao/contracts/Constants.sol\r\n/// @title Some useful constants\r\n/// @author DigixGlobal\r\ncontract Constants {\r\n  address constant NULL_ADDRESS = address(0x0);\r\n  uint256 constant ZERO = uint256(0);\r\n  bytes32 constant EMPTY = bytes32(0x0);\r\n}\r\n\r\n// File: @digix/cacp-contracts-dao/contracts/ContractResolver.sol\r\n/// @title Contract Name Registry\r\n/// @author DigixGlobal\r\ncontract ContractResolver is ACOwned, Constants {\r\n\r\n  mapping (bytes32 => address) contracts;\r\n  bool public locked_forever;\r\n\r\n  modifier unless_registered(bytes32 _key) {\r\n    require(contracts[_key] == NULL_ADDRESS);\r\n    _;\r\n  }\r\n\r\n  modifier if_owner_origin() {\r\n    require(tx.origin == owner);\r\n    _;\r\n  }\r\n\r\n  /// Function modifier to check if msg.sender corresponds to the resolved address of a given key\r\n  /// @param _contract The resolver key\r\n  modifier if_sender_is(bytes32 _contract) {\r\n    require(msg.sender == get_contract(_contract));\r\n    _;\r\n  }\r\n\r\n  modifier if_not_locked() {\r\n    require(locked_forever == false);\r\n    _;\r\n  }\r\n\r\n  /// @dev ContractResolver constructor will perform the following: 1. Set msg.sender as the contract owner.\r\n  constructor() public\r\n  {\r\n    require(init_ac_owned());\r\n    locked_forever = false;\r\n  }\r\n\r\n  /// @dev Called at contract initialization\r\n  /// @param _key bytestring for CACP name\r\n  /// @param _contract_address The address of the contract to be registered\r\n  /// @return _success if the operation is successful\r\n  function init_register_contract(bytes32 _key, address _contract_address)\r\n           if_owner_origin()\r\n           if_not_locked()\r\n           unless_registered(_key)\r\n           public\r\n           returns (bool _success)\r\n  {\r\n    require(_contract_address != NULL_ADDRESS);\r\n    contracts[_key] = _contract_address;\r\n    _success = true;\r\n  }\r\n\r\n  /// @dev Lock the resolver from any further modifications.  This can only be called from the owner\r\n  /// @return _success if the operation is successful\r\n  function lock_resolver_forever()\r\n           if_owner\r\n           public\r\n           returns (bool _success)\r\n  {\r\n    locked_forever = true;\r\n    _success = true;\r\n  }\r\n\r\n  /// @dev Get address of a contract\r\n  /// @param _key the bytestring name of the contract to look up\r\n  /// @return _contract the address of the contract\r\n  function get_contract(bytes32 _key)\r\n           public\r\n           view\r\n           returns (address _contract)\r\n  {\r\n    require(contracts[_key] != NULL_ADDRESS);\r\n    _contract = contracts[_key];\r\n  }\r\n}\r\n\r\n// File: @digix/cacp-contracts-dao/contracts/ResolverClient.sol\r\n/// @title Contract Resolver Interface\r\n/// @author DigixGlobal\r\ncontract ResolverClient {\r\n\r\n  /// The address of the resolver contract for this project\r\n  address public resolver;\r\n  bytes32 public key;\r\n\r\n  /// Make our own address available to us as a constant\r\n  address public CONTRACT_ADDRESS;\r\n\r\n  /// Function modifier to check if msg.sender corresponds to the resolved address of a given key\r\n  /// @param _contract The resolver key\r\n  modifier if_sender_is(bytes32 _contract) {\r\n    require(sender_is(_contract));\r\n    _;\r\n  }\r\n\r\n  function sender_is(bytes32 _contract) internal view returns (bool _isFrom) {\r\n    _isFrom = msg.sender == ContractResolver(resolver).get_contract(_contract);\r\n  }\r\n\r\n  modifier if_sender_is_from(bytes32[3] _contracts) {\r\n    require(sender_is_from(_contracts));\r\n    _;\r\n  }\r\n\r\n  function sender_is_from(bytes32[3] _contracts) internal view returns (bool _isFrom) {\r\n    uint256 _n = _contracts.length;\r\n    for (uint256 i = 0; i < _n; i++) {\r\n      if (_contracts[i] == bytes32(0x0)) continue;\r\n      if (msg.sender == ContractResolver(resolver).get_contract(_contracts[i])) {\r\n        _isFrom = true;\r\n        break;\r\n      }\r\n    }\r\n  }\r\n\r\n  /// Function modifier to check resolver's locking status.\r\n  modifier unless_resolver_is_locked() {\r\n    require(is_locked() == false);\r\n    _;\r\n  }\r\n\r\n  /// @dev Initialize new contract\r\n  /// @param _key the resolver key for this contract\r\n  /// @return _success if the initialization is successful\r\n  function init(bytes32 _key, address _resolver)\r\n           internal\r\n           returns (bool _success)\r\n  {\r\n    bool _is_locked = ContractResolver(_resolver).locked_forever();\r\n    if (_is_locked == false) {\r\n      CONTRACT_ADDRESS = address(this);\r\n      resolver = _resolver;\r\n      key = _key;\r\n      require(ContractResolver(resolver).init_register_contract(key, CONTRACT_ADDRESS));\r\n      _success = true;\r\n    }  else {\r\n      _success = false;\r\n    }\r\n  }\r\n\r\n  /// @dev Check if resolver is locked\r\n  /// @return _locked if the resolver is currently locked\r\n  function is_locked()\r\n           private\r\n           view\r\n           returns (bool _locked)\r\n  {\r\n    _locked = ContractResolver(resolver).locked_forever();\r\n  }\r\n\r\n  /// @dev Get the address of a contract\r\n  /// @param _key the resolver key to look up\r\n  /// @return _contract the address of the contract\r\n  function get_contract(bytes32 _key)\r\n           public\r\n           view\r\n           returns (address _contract)\r\n  {\r\n    _contract = ContractResolver(resolver).get_contract(_key);\r\n  }\r\n}\r\n\r\n// File: contracts/storage/DaoWhitelistingStorage.sol\r\n// This contract is basically created to restrict read access to\r\n// ethereum accounts, and whitelisted contracts\r\ncontract DaoWhitelistingStorage is ResolverClient, DaoConstants {\r\n\r\n    // we want to avoid the scenario in which an on-chain bribing contract\r\n    // can be deployed to distribute funds in a trustless way by verifying\r\n    // on-chain votes. This mapping marks whether a contract address is whitelisted\r\n    // to read from the read functions in DaoStorage, DaoSpecialStorage, etc.\r\n    mapping (address => bool) public whitelist;\r\n\r\n    constructor(address _resolver)\r\n        public\r\n    {\r\n        require(init(CONTRACT_STORAGE_DAO_WHITELISTING, _resolver));\r\n    }\r\n\r\n    function setWhitelisted(address _contractAddress, bool _senderIsAllowedToRead)\r\n        public\r\n    {\r\n        require(sender_is(CONTRACT_DAO_WHITELISTING));\r\n        whitelist[_contractAddress] = _senderIsAllowedToRead;\r\n    }\r\n}\r\n\r\n// File: contracts/common/DaoWhitelistingCommon.sol\r\ncontract DaoWhitelistingCommon is ResolverClient, DaoConstants {\r\n\r\n    function daoWhitelistingStorage()\r\n        internal\r\n        view\r\n        returns (DaoWhitelistingStorage _contract)\r\n    {\r\n        _contract = DaoWhitelistingStorage(get_contract(CONTRACT_STORAGE_DAO_WHITELISTING));\r\n    }\r\n\r\n    /**\r\n    @notice Check if a certain address is whitelisted to read sensitive information in the storage layer\r\n    @dev if the address is an account, it is allowed to read. If the address is a contract, it has to be in the whitelist\r\n    */\r\n    function senderIsAllowedToRead()\r\n        internal\r\n        view\r\n        returns (bool _senderIsAllowedToRead)\r\n    {\r\n        // msg.sender is allowed to read only if its an EOA or a whitelisted contract\r\n        _senderIsAllowedToRead = (msg.sender == tx.origin) || daoWhitelistingStorage().whitelist(msg.sender);\r\n    }\r\n}\r\n\r\n// File: contracts/lib/DaoStructs.sol\r\nlibrary DaoStructs {\r\n    using DoublyLinkedList for DoublyLinkedList.Bytes;\r\n    using SafeMath for uint256;\r\n    bytes32 constant EMPTY_BYTES = bytes32(0x0);\r\n\r\n    struct PrlAction {\r\n        // UTC timestamp at which the PRL action was done\r\n        uint256 at;\r\n\r\n        // IPFS hash of the document summarizing the action\r\n        bytes32 doc;\r\n\r\n        // Type of action\r\n        // check PRL_ACTION_* in \"./../common/DaoConstants.sol\"\r\n        uint256 actionId;\r\n    }\r\n\r\n    struct Voting {\r\n        // UTC timestamp at which the voting round starts\r\n        uint256 startTime;\r\n\r\n        // Mapping of whether a commit was used in this voting round\r\n        mapping (bytes32 => bool) usedCommits;\r\n\r\n        // Mapping of commits by address. These are the commits during the commit phase in a voting round\r\n        // This only stores the most recent commit in the voting round\r\n        // In case a vote is edited, the previous commit is overwritten by the new commit\r\n        // Only this new commit is verified at the reveal phase\r\n        mapping (address => bytes32) commits;\r\n\r\n        // This mapping is updated after the reveal phase, when votes are revealed\r\n        // It is a mapping of address to weight of vote\r\n        // Weight implies the lockedDGDStake of the address, at the time of revealing\r\n        // If the address voted \"NO\", or didn't vote, this would be 0\r\n        mapping (address => uint256) yesVotes;\r\n\r\n        // This mapping is updated after the reveal phase, when votes are revealed\r\n        // It is a mapping of address to weight of vote\r\n        // Weight implies the lockedDGDStake of the address, at the time of revealing\r\n        // If the address voted \"YES\", or didn't vote, this would be 0\r\n        mapping (address => uint256) noVotes;\r\n\r\n        // Boolean whether the voting round passed or not\r\n        bool passed;\r\n\r\n        // Boolean whether the voting round results were claimed or not\r\n        // refer the claimProposalVotingResult function in \"./../interative/DaoVotingClaims.sol\"\r\n        bool claimed;\r\n\r\n        // Boolean whether the milestone following this voting round was funded or not\r\n        // The milestone is funded when the proposer calls claimFunding in \"./../interactive/DaoFundingManager.sol\"\r\n        bool funded;\r\n    }\r\n\r\n    struct ProposalVersion {\r\n        // IPFS doc hash of this version of the proposal\r\n        bytes32 docIpfsHash;\r\n\r\n        // UTC timestamp at which this version was created\r\n        uint256 created;\r\n\r\n        // The number of milestones in the proposal as per this version\r\n        uint256 milestoneCount;\r\n\r\n        // The final reward asked by the proposer for completion of the entire proposal\r\n        uint256 finalReward;\r\n\r\n        // List of fundings required by the proposal as per this version\r\n        // The numbers are in wei\r\n        uint256[] milestoneFundings;\r\n\r\n        // When a proposal is finalized (calling Dao.finalizeProposal), the proposer can no longer add proposal versions\r\n        // However, they can still add more details to this final proposal version, in the form of IPFS docs.\r\n        // These IPFS docs are stored in this array\r\n        bytes32[] moreDocs;\r\n    }\r\n\r\n    struct Proposal {\r\n        // ID of the proposal. Also the IPFS hash of the first ProposalVersion\r\n        bytes32 proposalId;\r\n\r\n        // current state of the proposal\r\n        // refer PROPOSAL_STATE_* in \"./../common/DaoConstants.sol\"\r\n        bytes32 currentState;\r\n\r\n        // UTC timestamp at which the proposal was created\r\n        uint256 timeCreated;\r\n\r\n        // DoublyLinkedList of IPFS doc hashes of the various versions of the proposal\r\n        DoublyLinkedList.Bytes proposalVersionDocs;\r\n\r\n        // Mapping of version (IPFS doc hash) to ProposalVersion struct\r\n        mapping (bytes32 => ProposalVersion) proposalVersions;\r\n\r\n        // Voting struct for the draft voting round\r\n        Voting draftVoting;\r\n\r\n        // Mapping of voting round index (starts from 0) to Voting struct\r\n        // votingRounds[0] is the Voting round of the proposal, which lasts for get_uint_config(CONFIG_VOTING_PHASE_TOTAL)\r\n        // votingRounds[i] for i>0 are the Interim Voting rounds of the proposal, which lasts for get_uint_config(CONFIG_INTERIM_PHASE_TOTAL)\r\n        mapping (uint256 => Voting) votingRounds;\r\n\r\n        // Every proposal has a collateral tied to it with a value of\r\n        // get_uint_config(CONFIG_PREPROPOSAL_COLLATERAL) (refer \"./../storage/DaoConfigsStorage.sol\")\r\n        // Collateral can be in different states\r\n        // refer COLLATERAL_STATUS_* in \"./../common/DaoConstants.sol\"\r\n        uint256 collateralStatus;\r\n        uint256 collateralAmount;\r\n\r\n        // The final version of the proposal\r\n        // Every proposal needs to be finalized before it can be voted on\r\n        // This is the IPFS doc hash of the final version\r\n        bytes32 finalVersion;\r\n\r\n        // List of PrlAction structs\r\n        // These are all the actions done by the PRL on the proposal\r\n        PrlAction[] prlActions;\r\n\r\n        // Address of the user who created the proposal\r\n        address proposer;\r\n\r\n        // Address of the moderator who endorsed the proposal\r\n        address endorser;\r\n\r\n        // Boolean whether the proposal is paused/stopped at the moment\r\n        bool isPausedOrStopped;\r\n\r\n        // Boolean whether the proposal was created by a founder role\r\n        bool isDigix;\r\n    }\r\n\r\n    function countVotes(Voting storage _voting, address[] _allUsers)\r\n        external\r\n        view\r\n        returns (uint256 _for, uint256 _against)\r\n    {\r\n        uint256 _n = _allUsers.length;\r\n        for (uint256 i = 0; i < _n; i++) {\r\n            if (_voting.yesVotes[_allUsers[i]] > 0) {\r\n                _for = _for.add(_voting.yesVotes[_allUsers[i]]);\r\n            } else if (_voting.noVotes[_allUsers[i]] > 0) {\r\n                _against = _against.add(_voting.noVotes[_allUsers[i]]);\r\n            }\r\n        }\r\n    }\r\n\r\n    // get the list of voters who voted _vote (true-yes/false-no)\r\n    function listVotes(Voting storage _voting, address[] _allUsers, bool _vote)\r\n        external\r\n        view\r\n        returns (address[] memory _voters, uint256 _length)\r\n    {\r\n        uint256 _n = _allUsers.length;\r\n        uint256 i;\r\n        _length = 0;\r\n        _voters = new address[](_n);\r\n        if (_vote == true) {\r\n            for (i = 0; i < _n; i++) {\r\n                if (_voting.yesVotes[_allUsers[i]] > 0) {\r\n                    _voters[_length] = _allUsers[i];\r\n                    _length++;\r\n                }\r\n            }\r\n        } else {\r\n            for (i = 0; i < _n; i++) {\r\n                if (_voting.noVotes[_allUsers[i]] > 0) {\r\n                    _voters[_length] = _allUsers[i];\r\n                    _length++;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    function readVote(Voting storage _voting, address _voter)\r\n        public\r\n        view\r\n        returns (bool _vote, uint256 _weight)\r\n    {\r\n        if (_voting.yesVotes[_voter] > 0) {\r\n            _weight = _voting.yesVotes[_voter];\r\n            _vote = true;\r\n        } else {\r\n            _weight = _voting.noVotes[_voter]; // if _voter didnt vote at all, the weight will be 0 anyway\r\n            _vote = false;\r\n        }\r\n    }\r\n\r\n    function revealVote(\r\n        Voting storage _voting,\r\n        address _voter,\r\n        bool _vote,\r\n        uint256 _weight\r\n    )\r\n        public\r\n    {\r\n        if (_vote) {\r\n            _voting.yesVotes[_voter] = _weight;\r\n        } else {\r\n            _voting.noVotes[_voter] = _weight;\r\n        }\r\n    }\r\n\r\n    function readVersion(ProposalVersion storage _version)\r\n        public\r\n        view\r\n        returns (\r\n            bytes32 _doc,\r\n            uint256 _created,\r\n            uint256[] _milestoneFundings,\r\n            uint256 _finalReward\r\n        )\r\n    {\r\n        _doc = _version.docIpfsHash;\r\n        _created = _version.created;\r\n        _milestoneFundings = _version.milestoneFundings;\r\n        _finalReward = _version.finalReward;\r\n    }\r\n\r\n    // read the funding for a particular milestone of a finalized proposal\r\n    // if _milestoneId is the same as _milestoneCount, it returns the final reward\r\n    function readProposalMilestone(Proposal storage _proposal, uint256 _milestoneIndex)\r\n        public\r\n        view\r\n        returns (uint256 _funding)\r\n    {\r\n        bytes32 _finalVersion = _proposal.finalVersion;\r\n        uint256 _milestoneCount = _proposal.proposalVersions[_finalVersion].milestoneFundings.length;\r\n        require(_milestoneIndex <= _milestoneCount);\r\n        require(_finalVersion != EMPTY_BYTES); // the proposal must have been finalized\r\n\r\n        if (_milestoneIndex < _milestoneCount) {\r\n            _funding = _proposal.proposalVersions[_finalVersion].milestoneFundings[_milestoneIndex];\r\n        } else {\r\n            _funding = _proposal.proposalVersions[_finalVersion].finalReward;\r\n        }\r\n    }\r\n\r\n    function addProposalVersion(\r\n        Proposal storage _proposal,\r\n        bytes32 _newDoc,\r\n        uint256[] _newMilestoneFundings,\r\n        uint256 _finalReward\r\n    )\r\n        public\r\n    {\r\n        _proposal.proposalVersionDocs.append(_newDoc);\r\n        _proposal.proposalVersions[_newDoc].docIpfsHash = _newDoc;\r\n        _proposal.proposalVersions[_newDoc].created = now;\r\n        _proposal.proposalVersions[_newDoc].milestoneCount = _newMilestoneFundings.length;\r\n        _proposal.proposalVersions[_newDoc].milestoneFundings = _newMilestoneFundings;\r\n        _proposal.proposalVersions[_newDoc].finalReward = _finalReward;\r\n    }\r\n\r\n    struct SpecialProposal {\r\n        // ID of the special proposal\r\n        // This is the IPFS doc hash of the proposal\r\n        bytes32 proposalId;\r\n\r\n        // UTC timestamp at which the proposal was created\r\n        uint256 timeCreated;\r\n\r\n        // Voting struct for the special proposal\r\n        Voting voting;\r\n\r\n        // List of the new uint256 configs as per the special proposal\r\n        uint256[] uintConfigs;\r\n\r\n        // List of the new address configs as per the special proposal\r\n        address[] addressConfigs;\r\n\r\n        // List of the new bytes32 configs as per the special proposal\r\n        bytes32[] bytesConfigs;\r\n\r\n        // Address of the user who created the special proposal\r\n        // This address should also be in the ROLES_FOUNDERS group\r\n        // refer \"./../storage/DaoIdentityStorage.sol\"\r\n        address proposer;\r\n    }\r\n\r\n    // All configs are as per the DaoConfigsStorage values at the time when\r\n    // calculateGlobalRewardsBeforeNewQuarter is called by founder in that quarter\r\n    struct DaoQuarterInfo {\r\n        // The minimum quarter points required\r\n        // below this, reputation will be deducted\r\n        uint256 minimalParticipationPoint;\r\n\r\n        // The scaling factor for quarter point\r\n        uint256 quarterPointScalingFactor;\r\n\r\n        // The scaling factor for reputation point\r\n        uint256 reputationPointScalingFactor;\r\n\r\n        // The summation of effectiveDGDs in the previous quarter\r\n        // The effectiveDGDs represents the effective participation in DigixDAO in a quarter\r\n        // Which depends on lockedDGDStake, quarter point and reputation point\r\n        // This value is the summation of all participant effectiveDGDs\r\n        // It will be used to calculate the fraction of effectiveDGD a user has,\r\n        // which will determine his portion of DGX rewards for that quarter\r\n        uint256 totalEffectiveDGDPreviousQuarter;\r\n\r\n        // The minimum moderator quarter point required\r\n        // below this, reputation will be deducted for moderators\r\n        uint256 moderatorMinimalParticipationPoint;\r\n\r\n        // the scaling factor for moderator quarter point\r\n        uint256 moderatorQuarterPointScalingFactor;\r\n\r\n        // the scaling factor for moderator reputation point\r\n        uint256 moderatorReputationPointScalingFactor;\r\n\r\n        // The summation of effectiveDGDs (only specific to moderators)\r\n        uint256 totalEffectiveModeratorDGDLastQuarter;\r\n\r\n        // UTC timestamp from which the DGX rewards for the previous quarter are distributable to Holders\r\n        uint256 dgxDistributionDay;\r\n\r\n        // This is the rewards pool for the previous quarter. This is the sum of the DGX fees coming in from the collector, and the demurrage that has incurred\r\n        // when user call claimRewards() in the previous quarter.\r\n        // more graphical explanation: https://ipfs.io/ipfs/QmZDgFFMbyF3dvuuDfoXv5F6orq4kaDPo7m3QvnseUguzo\r\n        uint256 dgxRewardsPoolLastQuarter;\r\n\r\n        // The summation of all dgxRewardsPoolLastQuarter up until this quarter\r\n        uint256 sumRewardsFromBeginning;\r\n    }\r\n\r\n    // There are many function calls where all calculations/summations cannot be done in one transaction\r\n    // and require multiple transactions.\r\n    // This struct stores the intermediate results in between the calculating transactions\r\n    // These intermediate results are stored in IntermediateResultsStorage\r\n    struct IntermediateResults {\r\n        // weight of \"FOR\" votes counted up until the current calculation step\r\n        uint256 currentForCount;\r\n\r\n        // weight of \"AGAINST\" votes counted up until the current calculation step\r\n        uint256 currentAgainstCount;\r\n\r\n        // summation of effectiveDGDs up until the iteration of calculation\r\n        uint256 currentSumOfEffectiveBalance;\r\n\r\n        // Address of user until which the calculation has been done\r\n        address countedUntil;\r\n    }\r\n}\r\n\r\n// File: contracts/storage/DaoStorage.sol\r\ncontract DaoStorage is DaoWhitelistingCommon, BytesIteratorStorage {\r\n    using DoublyLinkedList for DoublyLinkedList.Bytes;\r\n    using DaoStructs for DaoStructs.Voting;\r\n    using DaoStructs for DaoStructs.Proposal;\r\n    using DaoStructs for DaoStructs.ProposalVersion;\r\n\r\n    // List of all the proposals ever created in DigixDAO\r\n    DoublyLinkedList.Bytes allProposals;\r\n\r\n    // mapping of Proposal struct by its ID\r\n    // ID is also the IPFS doc hash of the first ever version of this proposal\r\n    mapping (bytes32 => DaoStructs.Proposal) proposalsById;\r\n\r\n    // mapping from state of a proposal to list of all proposals in that state\r\n    // proposals are added/removed from the state's list as their states change\r\n    // eg. when proposal is endorsed, when proposal is funded, etc\r\n    mapping (bytes32 => DoublyLinkedList.Bytes) proposalsByState;\r\n\r\n    constructor(address _resolver) public {\r\n        require(init(CONTRACT_STORAGE_DAO, _resolver));\r\n    }\r\n\r\n    /////////////////////////////// READ FUNCTIONS //////////////////////////////\r\n\r\n    /// @notice read all information and details of proposal\r\n    /// @param _proposalId Proposal ID, i.e. hash of IPFS doc Proposal ID, i.e. hash of IPFS doc\r\n    /// return {\r\n    ///   \"_doc\": \"Original IPFS doc of proposal, also ID of proposal\",\r\n    ///   \"_proposer\": \"Address of the proposer\",\r\n    ///   \"_endorser\": \"Address of the moderator that endorsed the proposal\",\r\n    ///   \"_state\": \"Current state of the proposal\",\r\n    ///   \"_timeCreated\": \"UTC timestamp at which proposal was created\",\r\n    ///   \"_nVersions\": \"Number of versions of the proposal\",\r\n    ///   \"_latestVersionDoc\": \"IPFS doc hash of the latest version of this proposal\",\r\n    ///   \"_finalVersion\": \"If finalized, the version of the final proposal\",\r\n    ///   \"_pausedOrStopped\": \"If the proposal is paused/stopped at the moment\",\r\n    ///   \"_isDigixProposal\": \"If the proposal has been created by founder or not\"\r\n    /// }\r\n    function readProposal(bytes32 _proposalId)\r\n        public\r\n        view\r\n        returns (\r\n            bytes32 _doc,\r\n            address _proposer,\r\n            address _endorser,\r\n            bytes32 _state,\r\n            uint256 _timeCreated,\r\n            uint256 _nVersions,\r\n            bytes32 _latestVersionDoc,\r\n            bytes32 _finalVersion,\r\n            bool _pausedOrStopped,\r\n            bool _isDigixProposal\r\n        )\r\n    {\r\n        require(senderIsAllowedToRead());\r\n        DaoStructs.Proposal storage _proposal = proposalsById[_proposalId];\r\n        _doc = _proposal.proposalId;\r\n        _proposer = _proposal.proposer;\r\n        _endorser = _proposal.endorser;\r\n        _state = _proposal.currentState;\r\n        _timeCreated = _proposal.timeCreated;\r\n        _nVersions = read_total_bytesarray(_proposal.proposalVersionDocs);\r\n        _latestVersionDoc = read_last_from_bytesarray(_proposal.proposalVersionDocs);\r\n        _finalVersion = _proposal.finalVersion;\r\n        _pausedOrStopped = _proposal.isPausedOrStopped;\r\n        _isDigixProposal = _proposal.isDigix;\r\n    }\r\n\r\n    function readProposalProposer(bytes32 _proposalId)\r\n        public\r\n        view\r\n        returns (address _proposer)\r\n    {\r\n        _proposer = proposalsById[_proposalId].proposer;\r\n    }\r\n\r\n    function readTotalPrlActions(bytes32 _proposalId)\r\n        public\r\n        view\r\n        returns (uint256 _length)\r\n    {\r\n        _length = proposalsById[_proposalId].prlActions.length;\r\n    }\r\n\r\n    function readPrlAction(bytes32 _proposalId, uint256 _index)\r\n        public\r\n        view\r\n        returns (uint256 _actionId, uint256 _time, bytes32 _doc)\r\n    {\r\n        DaoStructs.PrlAction[] memory _actions = proposalsById[_proposalId].prlActions;\r\n        require(_index < _actions.length);\r\n        _actionId = _actions[_index].actionId;\r\n        _time = _actions[_index].at;\r\n        _doc = _actions[_index].doc;\r\n    }\r\n\r\n    function readProposalDraftVotingResult(bytes32 _proposalId)\r\n        public\r\n        view\r\n        returns (bool _result)\r\n    {\r\n        require(senderIsAllowedToRead());\r\n        _result = proposalsById[_proposalId].draftVoting.passed;\r\n    }\r\n\r\n    function readProposalVotingResult(bytes32 _proposalId, uint256 _index)\r\n        public\r\n        view\r\n        returns (bool _result)\r\n    {\r\n        require(senderIsAllowedToRead());\r\n        _result = proposalsById[_proposalId].votingRounds[_index].passed;\r\n    }\r\n\r\n    function readProposalDraftVotingTime(bytes32 _proposalId)\r\n        public\r\n        view\r\n        returns (uint256 _start)\r\n    {\r\n        require(senderIsAllowedToRead());\r\n        _start = proposalsById[_proposalId].draftVoting.startTime;\r\n    }\r\n\r\n    function readProposalVotingTime(bytes32 _proposalId, uint256 _index)\r\n        public\r\n        view\r\n        returns (uint256 _start)\r\n    {\r\n        require(senderIsAllowedToRead());\r\n        _start = proposalsById[_proposalId].votingRounds[_index].startTime;\r\n    }\r\n\r\n    function readDraftVotingCount(bytes32 _proposalId, address[] _allUsers)\r\n        external\r\n        view\r\n        returns (uint256 _for, uint256 _against)\r\n    {\r\n        require(senderIsAllowedToRead());\r\n        return proposalsById[_proposalId].draftVoting.countVotes(_allUsers);\r\n    }\r\n\r\n    function readVotingCount(bytes32 _proposalId, uint256 _index, address[] _allUsers)\r\n        external\r\n        view\r\n        returns (uint256 _for, uint256 _against)\r\n    {\r\n        require(senderIsAllowedToRead());\r\n        return proposalsById[_proposalId].votingRounds[_index].countVotes(_allUsers);\r\n    }\r\n\r\n    function readVotingRoundVotes(bytes32 _proposalId, uint256 _index, address[] _allUsers, bool _vote)\r\n        external\r\n        view\r\n        returns (address[] memory _voters, uint256 _length)\r\n    {\r\n        require(senderIsAllowedToRead());\r\n        return proposalsById[_proposalId].votingRounds[_index].listVotes(_allUsers, _vote);\r\n    }\r\n\r\n    function readDraftVote(bytes32 _proposalId, address _voter)\r\n        public\r\n        view\r\n        returns (bool _vote, uint256 _weight)\r\n    {\r\n        require(senderIsAllowedToRead());\r\n        return proposalsById[_proposalId].draftVoting.readVote(_voter);\r\n    }\r\n\r\n    /// @notice returns the latest committed vote by a voter on a proposal\r\n    /// @param _proposalId proposal ID\r\n    /// @param _voter address of the voter\r\n    /// @return {\r\n    ///   \"_commitHash\": \"\"\r\n    /// }\r\n    function readComittedVote(bytes32 _proposalId, uint256 _index, address _voter)\r\n        public\r\n        view\r\n        returns (bytes32 _commitHash)\r\n    {\r\n        require(senderIsAllowedToRead());\r\n        _commitHash = proposalsById[_proposalId].votingRounds[_index].commits[_voter];\r\n    }\r\n\r\n    function readVote(bytes32 _proposalId, uint256 _index, address _voter)\r\n        public\r\n        view\r\n        returns (bool _vote, uint256 _weight)\r\n    {\r\n        require(senderIsAllowedToRead());\r\n        return proposalsById[_proposalId].votingRounds[_index].readVote(_voter);\r\n    }\r\n\r\n    /// @notice get all information and details of the first proposal\r\n    /// return {\r\n    ///   \"_id\": \"\"\r\n    /// }\r\n    function getFirstProposal()\r\n        public\r\n        view\r\n        returns (bytes32 _id)\r\n    {\r\n        _id = read_first_from_bytesarray(allProposals);\r\n    }\r\n\r\n    /// @notice get all information and details of the last proposal\r\n    /// return {\r\n    ///   \"_id\": \"\"\r\n    /// }\r\n    function getLastProposal()\r\n        public\r\n        view\r\n        returns (bytes32 _id)\r\n    {\r\n        _id = read_last_from_bytesarray(allProposals);\r\n    }\r\n\r\n    /// @notice get all information and details of proposal next to _proposalId\r\n    /// @param _proposalId Proposal ID, i.e. hash of IPFS doc\r\n    /// return {\r\n    ///   \"_id\": \"\"\r\n    /// }\r\n    function getNextProposal(bytes32 _proposalId)\r\n        public\r\n        view\r\n        returns (bytes32 _id)\r\n    {\r\n        _id = read_next_from_bytesarray(\r\n            allProposals,\r\n            _proposalId\r\n        );\r\n    }\r\n\r\n    /// @notice get all information and details of proposal previous to _proposalId\r\n    /// @param _proposalId Proposal ID, i.e. hash of IPFS doc\r\n    /// return {\r\n    ///   \"_id\": \"\"\r\n    /// }\r\n    function getPreviousProposal(bytes32 _proposalId)\r\n        public\r\n        view\r\n        returns (bytes32 _id)\r\n    {\r\n        _id = read_previous_from_bytesarray(\r\n            allProposals,\r\n            _proposalId\r\n        );\r\n    }\r\n\r\n    /// @notice get all information and details of the first proposal in state _stateId\r\n    /// @param _stateId State ID of the proposal\r\n    /// return {\r\n    ///   \"_id\": \"\"\r\n    /// }\r\n    function getFirstProposalInState(bytes32 _stateId)\r\n        public\r\n        view\r\n        returns (bytes32 _id)\r\n    {\r\n        require(senderIsAllowedToRead());\r\n        _id = read_first_from_bytesarray(proposalsByState[_stateId]);\r\n    }\r\n\r\n    /// @notice get all information and details of the last proposal in state _stateId\r\n    /// @param _stateId State ID of the proposal\r\n    /// return {\r\n    ///   \"_id\": \"\"\r\n    /// }\r\n    function getLastProposalInState(bytes32 _stateId)\r\n        public\r\n        view\r\n        returns (bytes32 _id)\r\n    {\r\n        require(senderIsAllowedToRead());\r\n        _id = read_last_from_bytesarray(proposalsByState[_stateId]);\r\n    }\r\n\r\n    /// @notice get all information and details of the next proposal to _proposalId in state _stateId\r\n    /// @param _stateId State ID of the proposal\r\n    /// return {\r\n    ///   \"_id\": \"\"\r\n    /// }\r\n    function getNextProposalInState(bytes32 _stateId, bytes32 _proposalId)\r\n        public\r\n        view\r\n        returns (bytes32 _id)\r\n    {\r\n        require(senderIsAllowedToRead());\r\n        _id = read_next_from_bytesarray(\r\n            proposalsByState[_stateId],\r\n            _proposalId\r\n        );\r\n    }\r\n\r\n    /// @notice get all information and details of the previous proposal to _proposalId in state _stateId\r\n    /// @param _stateId State ID of the proposal\r\n    /// return {\r\n    ///   \"_id\": \"\"\r\n    /// }\r\n    function getPreviousProposalInState(bytes32 _stateId, bytes32 _proposalId)\r\n        public\r\n        view\r\n        returns (bytes32 _id)\r\n    {\r\n        require(senderIsAllowedToRead());\r\n        _id = read_previous_from_bytesarray(\r\n            proposalsByState[_stateId],\r\n            _proposalId\r\n        );\r\n    }\r\n\r\n    /// @notice read proposal version details for a specific version\r\n    /// @param _proposalId Proposal ID, i.e. hash of IPFS doc\r\n    /// @param _version Version of proposal, i.e. hash of IPFS doc for specific version\r\n    /// return {\r\n    ///   \"_doc\": \"\",\r\n    ///   \"_created\": \"\",\r\n    ///   \"_milestoneFundings\": \"\"\r\n    /// }\r\n    function readProposalVersion(bytes32 _proposalId, bytes32 _version)\r\n        public\r\n        view\r\n        returns (\r\n            bytes32 _doc,\r\n            uint256 _created,\r\n            uint256[] _milestoneFundings,\r\n            uint256 _finalReward\r\n        )\r\n    {\r\n        return proposalsById[_proposalId].proposalVersions[_version].readVersion();\r\n    }\r\n\r\n    /**\r\n    @notice Read the fundings of a finalized proposal\r\n    @return {\r\n        \"_fundings\": \"fundings for the milestones\",\r\n        \"_finalReward\": \"the final reward\"\r\n    }\r\n    */\r\n    function readProposalFunding(bytes32 _proposalId)\r\n        public\r\n        view\r\n        returns (uint256[] memory _fundings, uint256 _finalReward)\r\n    {\r\n        require(senderIsAllowedToRead());\r\n        bytes32 _finalVersion = proposalsById[_proposalId].finalVersion;\r\n        require(_finalVersion != EMPTY_BYTES);\r\n        _fundings = proposalsById[_proposalId].proposalVersions[_finalVersion].milestoneFundings;\r\n        _finalReward = proposalsById[_proposalId].proposalVersions[_finalVersion].finalReward;\r\n    }\r\n\r\n    function readProposalMilestone(bytes32 _proposalId, uint256 _index)\r\n        public\r\n        view\r\n        returns (uint256 _funding)\r\n    {\r\n        require(senderIsAllowedToRead());\r\n        _funding = proposalsById[_proposalId].readProposalMilestone(_index);\r\n    }\r\n\r\n    /// @notice get proposal version details for the first version\r\n    /// @param _proposalId Proposal ID, i.e. hash of IPFS doc\r\n    /// return {\r\n    ///   \"_version\": \"\"\r\n    /// }\r\n    function getFirstProposalVersion(bytes32 _proposalId)\r\n        public\r\n        view\r\n        returns (bytes32 _version)\r\n    {\r\n        DaoStructs.Proposal storage _proposal = proposalsById[_proposalId];\r\n        _version = read_first_from_bytesarray(_proposal.proposalVersionDocs);\r\n    }\r\n\r\n    /// @notice get proposal version details for the last version\r\n    /// @param _proposalId Proposal ID, i.e. hash of IPFS doc\r\n    /// return {\r\n    ///   \"_version\": \"\"\r\n    /// }\r\n    function getLastProposalVersion(bytes32 _proposalId)\r\n        public\r\n        view\r\n        returns (bytes32 _version)\r\n    {\r\n        DaoStructs.Proposal storage _proposal = proposalsById[_proposalId];\r\n        _version = read_last_from_bytesarray(_proposal.proposalVersionDocs);\r\n    }\r\n\r\n    /// @notice get proposal version details for the next version to _version\r\n    /// @param _proposalId Proposal ID, i.e. hash of IPFS doc\r\n    /// @param _version Version of proposal\r\n    /// return {\r\n    ///   \"_nextVersion\": \"\"\r\n    /// }\r\n    function getNextProposalVersion(bytes32 _proposalId, bytes32 _version)\r\n        public\r\n        view\r\n        returns (bytes32 _nextVersion)\r\n    {\r\n        DaoStructs.Proposal storage _proposal = proposalsById[_proposalId];\r\n        _nextVersion = read_next_from_bytesarray(\r\n            _proposal.proposalVersionDocs,\r\n            _version\r\n        );\r\n    }\r\n\r\n    /// @notice get proposal version details for the previous version to _version\r\n    /// @param _proposalId Proposal ID, i.e. hash of IPFS doc\r\n    /// @param _version Version of proposal\r\n    /// return {\r\n    ///   \"_previousVersion\": \"\"\r\n    /// }\r\n    function getPreviousProposalVersion(bytes32 _proposalId, bytes32 _version)\r\n        public\r\n        view\r\n        returns (bytes32 _previousVersion)\r\n    {\r\n        DaoStructs.Proposal storage _proposal = proposalsById[_proposalId];\r\n        _previousVersion = read_previous_from_bytesarray(\r\n            _proposal.proposalVersionDocs,\r\n            _version\r\n        );\r\n    }\r\n\r\n    function isDraftClaimed(bytes32 _proposalId)\r\n        public\r\n        view\r\n        returns (bool _claimed)\r\n    {\r\n        _claimed = proposalsById[_proposalId].draftVoting.claimed;\r\n    }\r\n\r\n    function isClaimed(bytes32 _proposalId, uint256 _index)\r\n        public\r\n        view\r\n        returns (bool _claimed)\r\n    {\r\n        _claimed = proposalsById[_proposalId].votingRounds[_index].claimed;\r\n    }\r\n\r\n    function readProposalCollateralStatus(bytes32 _proposalId)\r\n        public\r\n        view\r\n        returns (uint256 _status)\r\n    {\r\n        require(senderIsAllowedToRead());\r\n        _status = proposalsById[_proposalId].collateralStatus;\r\n    }\r\n\r\n    function readProposalCollateralAmount(bytes32 _proposalId)\r\n        public\r\n        view\r\n        returns (uint256 _amount)\r\n    {\r\n        _amount = proposalsById[_proposalId].collateralAmount;\r\n    }\r\n\r\n    /// @notice Read the additional docs that are added after the proposal is finalized\r\n    /// @dev Will throw if the propsal is not finalized yet\r\n    function readProposalDocs(bytes32 _proposalId)\r\n        public\r\n        view\r\n        returns (bytes32[] _moreDocs)\r\n    {\r\n        bytes32 _finalVersion = proposalsById[_proposalId].finalVersion;\r\n        require(_finalVersion != EMPTY_BYTES);\r\n        _moreDocs = proposalsById[_proposalId].proposalVersions[_finalVersion].moreDocs;\r\n    }\r\n\r\n    function readIfMilestoneFunded(bytes32 _proposalId, uint256 _milestoneId)\r\n        public\r\n        view\r\n        returns (bool _funded)\r\n    {\r\n        require(senderIsAllowedToRead());\r\n        _funded = proposalsById[_proposalId].votingRounds[_milestoneId].funded;\r\n    }\r\n\r\n    ////////////////////////////// WRITE FUNCTIONS //////////////////////////////\r\n\r\n    function addProposal(\r\n        bytes32 _doc,\r\n        address _proposer,\r\n        uint256[] _milestoneFundings,\r\n        uint256 _finalReward,\r\n        bool _isFounder\r\n    )\r\n        external\r\n    {\r\n        require(sender_is(CONTRACT_DAO));\r\n        require(\r\n          (proposalsById[_doc].proposalId == EMPTY_BYTES) &&\r\n          (_doc != EMPTY_BYTES)\r\n        );\r\n\r\n        allProposals.append(_doc);\r\n        proposalsByState[PROPOSAL_STATE_PREPROPOSAL].append(_doc);\r\n        proposalsById[_doc].proposalId = _doc;\r\n        proposalsById[_doc].proposer = _proposer;\r\n        proposalsById[_doc].currentState = PROPOSAL_STATE_PREPROPOSAL;\r\n        proposalsById[_doc].timeCreated = now;\r\n        proposalsById[_doc].isDigix = _isFounder;\r\n        proposalsById[_doc].addProposalVersion(_doc, _milestoneFundings, _finalReward);\r\n    }\r\n\r\n    function editProposal(\r\n        bytes32 _proposalId,\r\n        bytes32 _newDoc,\r\n        uint256[] _newMilestoneFundings,\r\n        uint256 _finalReward\r\n    )\r\n        external\r\n    {\r\n        require(sender_is(CONTRACT_DAO));\r\n\r\n        proposalsById[_proposalId].addProposalVersion(_newDoc, _newMilestoneFundings, _finalReward);\r\n    }\r\n\r\n    /// @notice change fundings of a proposal\r\n    /// @dev Will throw if the proposal is not finalized yet\r\n    function changeFundings(bytes32 _proposalId, uint256[] _newMilestoneFundings, uint256 _finalReward)\r\n        external\r\n    {\r\n        require(sender_is(CONTRACT_DAO));\r\n\r\n        bytes32 _finalVersion = proposalsById[_proposalId].finalVersion;\r\n        require(_finalVersion != EMPTY_BYTES);\r\n        proposalsById[_proposalId].proposalVersions[_finalVersion].milestoneFundings = _newMilestoneFundings;\r\n        proposalsById[_proposalId].proposalVersions[_finalVersion].finalReward = _finalReward;\r\n    }\r\n\r\n    /// @dev Will throw if the proposal is not finalized yet\r\n    function addProposalDoc(bytes32 _proposalId, bytes32 _newDoc)\r\n        public\r\n    {\r\n        require(sender_is(CONTRACT_DAO));\r\n\r\n        bytes32 _finalVersion = proposalsById[_proposalId].finalVersion;\r\n        require(_finalVersion != EMPTY_BYTES); //already checked in interactive layer, but why not\r\n        proposalsById[_proposalId].proposalVersions[_finalVersion].moreDocs.push(_newDoc);\r\n    }\r\n\r\n    function finalizeProposal(bytes32 _proposalId)\r\n        public\r\n    {\r\n        require(sender_is(CONTRACT_DAO));\r\n\r\n        proposalsById[_proposalId].finalVersion = getLastProposalVersion(_proposalId);\r\n    }\r\n\r\n    function updateProposalEndorse(\r\n        bytes32 _proposalId,\r\n        address _endorser\r\n    )\r\n        public\r\n    {\r\n        require(sender_is(CONTRACT_DAO));\r\n\r\n        DaoStructs.Proposal storage _proposal = proposalsById[_proposalId];\r\n        _proposal.endorser = _endorser;\r\n        _proposal.currentState = PROPOSAL_STATE_DRAFT;\r\n        proposalsByState[PROPOSAL_STATE_PREPROPOSAL].remove_item(_proposalId);\r\n        proposalsByState[PROPOSAL_STATE_DRAFT].append(_proposalId);\r\n    }\r\n\r\n    function setProposalDraftPass(bytes32 _proposalId, bool _result)\r\n        public\r\n    {\r\n        require(sender_is(CONTRACT_DAO_VOTING_CLAIMS));\r\n\r\n        proposalsById[_proposalId].draftVoting.passed = _result;\r\n        if (_result) {\r\n            proposalsByState[PROPOSAL_STATE_DRAFT].remove_item(_proposalId);\r\n            proposalsByState[PROPOSAL_STATE_MODERATED].append(_proposalId);\r\n            proposalsById[_proposalId].currentState = PROPOSAL_STATE_MODERATED;\r\n        } else {\r\n            closeProposalInternal(_proposalId);\r\n        }\r\n    }\r\n\r\n    function setProposalPass(bytes32 _proposalId, uint256 _index, bool _result)\r\n        public\r\n    {\r\n        require(sender_is(CONTRACT_DAO_VOTING_CLAIMS));\r\n\r\n        if (!_result) {\r\n            closeProposalInternal(_proposalId);\r\n        } else if (_index == 0) {\r\n            proposalsByState[PROPOSAL_STATE_MODERATED].remove_item(_proposalId);\r\n            proposalsByState[PROPOSAL_STATE_ONGOING].append(_proposalId);\r\n            proposalsById[_proposalId].currentState = PROPOSAL_STATE_ONGOING;\r\n        }\r\n        proposalsById[_proposalId].votingRounds[_index].passed = _result;\r\n    }\r\n\r\n    function setProposalDraftVotingTime(\r\n        bytes32 _proposalId,\r\n        uint256 _time\r\n    )\r\n        public\r\n    {\r\n        require(sender_is(CONTRACT_DAO));\r\n\r\n        proposalsById[_proposalId].draftVoting.startTime = _time;\r\n    }\r\n\r\n    function setProposalVotingTime(\r\n        bytes32 _proposalId,\r\n        uint256 _index,\r\n        uint256 _time\r\n    )\r\n        public\r\n    {\r\n        require(sender_is_from([CONTRACT_DAO, CONTRACT_DAO_VOTING_CLAIMS, EMPTY_BYTES]));\r\n\r\n        proposalsById[_proposalId].votingRounds[_index].startTime = _time;\r\n    }\r\n\r\n    function setDraftVotingClaim(bytes32 _proposalId, bool _claimed)\r\n        public\r\n    {\r\n        require(sender_is(CONTRACT_DAO_VOTING_CLAIMS));\r\n        proposalsById[_proposalId].draftVoting.claimed = _claimed;\r\n    }\r\n\r\n    function setVotingClaim(bytes32 _proposalId, uint256 _index, bool _claimed)\r\n        public\r\n    {\r\n        require(sender_is(CONTRACT_DAO_VOTING_CLAIMS));\r\n        proposalsById[_proposalId].votingRounds[_index].claimed = _claimed;\r\n    }\r\n\r\n    function setProposalCollateralStatus(bytes32 _proposalId, uint256 _status)\r\n        public\r\n    {\r\n        require(sender_is_from([CONTRACT_DAO_VOTING_CLAIMS, CONTRACT_DAO_FUNDING_MANAGER, CONTRACT_DAO]));\r\n        proposalsById[_proposalId].collateralStatus = _status;\r\n    }\r\n\r\n    function setProposalCollateralAmount(bytes32 _proposalId, uint256 _amount)\r\n        public\r\n    {\r\n        require(sender_is(CONTRACT_DAO));\r\n        proposalsById[_proposalId].collateralAmount = _amount;\r\n    }\r\n\r\n    function updateProposalPRL(\r\n        bytes32 _proposalId,\r\n        uint256 _action,\r\n        bytes32 _doc,\r\n        uint256 _time\r\n    )\r\n        public\r\n    {\r\n        require(sender_is(CONTRACT_DAO));\r\n        require(proposalsById[_proposalId].currentState != PROPOSAL_STATE_CLOSED);\r\n\r\n        DaoStructs.PrlAction memory prlAction;\r\n        prlAction.at = _time;\r\n        prlAction.doc = _doc;\r\n        prlAction.actionId = _action;\r\n        proposalsById[_proposalId].prlActions.push(prlAction);\r\n\r\n        if (_action == PRL_ACTION_PAUSE) {\r\n          proposalsById[_proposalId].isPausedOrStopped = true;\r\n        } else if (_action == PRL_ACTION_UNPAUSE) {\r\n          proposalsById[_proposalId].isPausedOrStopped = false;\r\n        } else { // STOP\r\n          proposalsById[_proposalId].isPausedOrStopped = true;\r\n          closeProposalInternal(_proposalId);\r\n        }\r\n    }\r\n\r\n    function closeProposalInternal(bytes32 _proposalId)\r\n        internal\r\n    {\r\n        bytes32 _currentState = proposalsById[_proposalId].currentState;\r\n        proposalsByState[_currentState].remove_item(_proposalId);\r\n        proposalsByState[PROPOSAL_STATE_CLOSED].append(_proposalId);\r\n        proposalsById[_proposalId].currentState = PROPOSAL_STATE_CLOSED;\r\n    }\r\n\r\n    function addDraftVote(\r\n        bytes32 _proposalId,\r\n        address _voter,\r\n        bool _vote,\r\n        uint256 _weight\r\n    )\r\n        public\r\n    {\r\n        require(sender_is(CONTRACT_DAO_VOTING));\r\n\r\n        DaoStructs.Proposal storage _proposal = proposalsById[_proposalId];\r\n        if (_vote) {\r\n            _proposal.draftVoting.yesVotes[_voter] = _weight;\r\n            if (_proposal.draftVoting.noVotes[_voter] > 0) { // minimize number of writes to storage, since EIP-1087 is not implemented yet\r\n                _proposal.draftVoting.noVotes[_voter] = 0;\r\n            }\r\n        } else {\r\n            _proposal.draftVoting.noVotes[_voter] = _weight;\r\n            if (_proposal.draftVoting.yesVotes[_voter] > 0) {\r\n                _proposal.draftVoting.yesVotes[_voter] = 0;\r\n            }\r\n        }\r\n    }\r\n\r\n    function commitVote(\r\n        bytes32 _proposalId,\r\n        bytes32 _hash,\r\n        address _voter,\r\n        uint256 _index\r\n    )\r\n        public\r\n    {\r\n        require(sender_is(CONTRACT_DAO_VOTING));\r\n\r\n        proposalsById[_proposalId].votingRounds[_index].commits[_voter] = _hash;\r\n    }\r\n\r\n    function revealVote(\r\n        bytes32 _proposalId,\r\n        address _voter,\r\n        bool _vote,\r\n        uint256 _weight,\r\n        uint256 _index\r\n    )\r\n        public\r\n    {\r\n        require(sender_is(CONTRACT_DAO_VOTING));\r\n\r\n        proposalsById[_proposalId].votingRounds[_index].revealVote(_voter, _vote, _weight);\r\n    }\r\n\r\n    function closeProposal(bytes32 _proposalId)\r\n        public\r\n    {\r\n        require(sender_is(CONTRACT_DAO));\r\n        closeProposalInternal(_proposalId);\r\n    }\r\n\r\n    function archiveProposal(bytes32 _proposalId)\r\n        public\r\n    {\r\n        require(sender_is(CONTRACT_DAO_VOTING_CLAIMS));\r\n        bytes32 _currentState = proposalsById[_proposalId].currentState;\r\n        proposalsByState[_currentState].remove_item(_proposalId);\r\n        proposalsByState[PROPOSAL_STATE_ARCHIVED].append(_proposalId);\r\n        proposalsById[_proposalId].currentState = PROPOSAL_STATE_ARCHIVED;\r\n    }\r\n\r\n    function setMilestoneFunded(bytes32 _proposalId, uint256 _milestoneId)\r\n        public\r\n    {\r\n        require(sender_is(CONTRACT_DAO_FUNDING_MANAGER));\r\n        proposalsById[_proposalId].votingRounds[_milestoneId].funded = true;\r\n    }\r\n}\r\n\r\n// File: @digix/solidity-collections/contracts/abstract/AddressIteratorStorage.sol\r\n/**\r\n  @title Address Iterator Storage\r\n  @author DigixGlobal Pte Ltd\r\n  @notice See: [Doubly Linked List](/DoublyLinkedList)\r\n*/\r\ncontract AddressIteratorStorage {\r\n\r\n  // Initialize Doubly Linked List of Address\r\n  using DoublyLinkedList for DoublyLinkedList.Address;\r\n\r\n  /**\r\n    @notice Reads the first item from the list of Address\r\n    @param _list The source list\r\n    @return {\"_item\" : \"The first item from the list\"}\r\n  */\r\n  function read_first_from_addresses(DoublyLinkedList.Address storage _list)\r\n           internal\r\n           constant\r\n           returns (address _item)\r\n  {\r\n    _item = _list.start_item();\r\n  }\r\n\r\n\r\n  /**\r\n    @notice Reads the last item from the list of Address\r\n    @param _list The source list\r\n    @return {\"_item\" : \"The last item from the list\"}\r\n  */\r\n  function read_last_from_addresses(DoublyLinkedList.Address storage _list)\r\n           internal\r\n           constant\r\n           returns (address _item)\r\n  {\r\n    _item = _list.end_item();\r\n  }\r\n\r\n  /**\r\n    @notice Reads the next item on the list of Address\r\n    @param _list The source list\r\n    @param _current_item The current item to be used as base line\r\n    @return {\"_item\" : \"The next item from the list based on the specieid `_current_item`\"}\r\n  */\r\n  function read_next_from_addresses(DoublyLinkedList.Address storage _list, address _current_item)\r\n           internal\r\n           constant\r\n           returns (address _item)\r\n  {\r\n    _item = _list.next_item(_current_item);\r\n  }\r\n\r\n  /**\r\n    @notice Reads the previous item on the list of Address\r\n    @param _list The source list\r\n    @param _current_item The current item to be used as base line\r\n    @return {\"_item\" : \"The previous item from the list based on the spcified `_current_item`\"}\r\n  */\r\n  function read_previous_from_addresses(DoublyLinkedList.Address storage _list, address _current_item)\r\n           internal\r\n           constant\r\n           returns (address _item)\r\n  {\r\n    _item = _list.previous_item(_current_item);\r\n  }\r\n\r\n  /**\r\n    @notice Reads the list of Address and returns the length of the list\r\n    @param _list The source list\r\n    @return {\"_count\": \"The lenght of the list\"}\r\n  */\r\n  function read_total_addresses(DoublyLinkedList.Address storage _list)\r\n           internal\r\n           constant\r\n           returns (uint256 _count)\r\n  {\r\n    _count = _list.total();\r\n  }\r\n}\r\n\r\n// File: contracts/storage/DaoStakeStorage.sol\r\ncontract DaoStakeStorage is ResolverClient, DaoConstants, AddressIteratorStorage {\r\n    using DoublyLinkedList for DoublyLinkedList.Address;\r\n\r\n    // This is the DGD stake of a user (one that is considered in the DAO)\r\n    mapping (address => uint256) public lockedDGDStake;\r\n\r\n    // This is the actual number of DGDs locked by user\r\n    // may be more than the lockedDGDStake\r\n    // in case they locked during the main phase\r\n    mapping (address => uint256) public actualLockedDGD;\r\n\r\n    // The total locked DGDs in the DAO (summation of lockedDGDStake)\r\n    uint256 public totalLockedDGDStake;\r\n\r\n    // The total locked DGDs by moderators\r\n    uint256 public totalModeratorLockedDGDStake;\r\n\r\n    // The list of participants in DAO\r\n    // actual participants will be subset of this list\r\n    DoublyLinkedList.Address allParticipants;\r\n\r\n    // The list of moderators in DAO\r\n    // actual moderators will be subset of this list\r\n    DoublyLinkedList.Address allModerators;\r\n\r\n    // Boolean to mark if an address has redeemed\r\n    // reputation points for their DGD Badge\r\n    mapping (address => bool) public redeemedBadge;\r\n\r\n    // mapping to note whether an address has claimed their\r\n    // reputation bonus for carbon vote participation\r\n    mapping (address => bool) public carbonVoteBonusClaimed;\r\n\r\n    constructor(address _resolver) public {\r\n        require(init(CONTRACT_STORAGE_DAO_STAKE, _resolver));\r\n    }\r\n\r\n    function redeemBadge(address _user)\r\n        public\r\n    {\r\n        require(sender_is(CONTRACT_DAO_STAKE_LOCKING));\r\n        redeemedBadge[_user] = true;\r\n    }\r\n\r\n    function setCarbonVoteBonusClaimed(address _user)\r\n        public\r\n    {\r\n        require(sender_is(CONTRACT_DAO_STAKE_LOCKING));\r\n        carbonVoteBonusClaimed[_user] = true;\r\n    }\r\n\r\n    function updateTotalLockedDGDStake(uint256 _totalLockedDGDStake)\r\n        public\r\n    {\r\n        require(sender_is_from([CONTRACT_DAO_STAKE_LOCKING, CONTRACT_DAO_REWARDS_MANAGER, EMPTY_BYTES]));\r\n        totalLockedDGDStake = _totalLockedDGDStake;\r\n    }\r\n\r\n    function updateTotalModeratorLockedDGDs(uint256 _totalLockedDGDStake)\r\n        public\r\n    {\r\n        require(sender_is_from([CONTRACT_DAO_STAKE_LOCKING, CONTRACT_DAO_REWARDS_MANAGER, EMPTY_BYTES]));\r\n        totalModeratorLockedDGDStake = _totalLockedDGDStake;\r\n    }\r\n\r\n    function updateUserDGDStake(address _user, uint256 _actualLockedDGD, uint256 _lockedDGDStake)\r\n        public\r\n    {\r\n        require(sender_is(CONTRACT_DAO_STAKE_LOCKING));\r\n        actualLockedDGD[_user] = _actualLockedDGD;\r\n        lockedDGDStake[_user] = _lockedDGDStake;\r\n    }\r\n\r\n    function readUserDGDStake(address _user)\r\n        public\r\n        view\r\n        returns (\r\n            uint256 _actualLockedDGD,\r\n            uint256 _lockedDGDStake\r\n        )\r\n    {\r\n        _actualLockedDGD = actualLockedDGD[_user];\r\n        _lockedDGDStake = lockedDGDStake[_user];\r\n    }\r\n\r\n    function addToParticipantList(address _user)\r\n        public\r\n        returns (bool _success)\r\n    {\r\n        require(sender_is(CONTRACT_DAO_STAKE_LOCKING));\r\n        _success = allParticipants.append(_user);\r\n    }\r\n\r\n    function removeFromParticipantList(address _user)\r\n        public\r\n        returns (bool _success)\r\n    {\r\n        require(sender_is(CONTRACT_DAO_STAKE_LOCKING));\r\n        _success = allParticipants.remove_item(_user);\r\n    }\r\n\r\n    function addToModeratorList(address _user)\r\n        public\r\n        returns (bool _success)\r\n    {\r\n        require(sender_is(CONTRACT_DAO_STAKE_LOCKING));\r\n        _success = allModerators.append(_user);\r\n    }\r\n\r\n    function removeFromModeratorList(address _user)\r\n        public\r\n        returns (bool _success)\r\n    {\r\n        require(sender_is(CONTRACT_DAO_STAKE_LOCKING));\r\n        _success = allModerators.remove_item(_user);\r\n    }\r\n\r\n    function isInParticipantList(address _user)\r\n        public\r\n        view\r\n        returns (bool _is)\r\n    {\r\n        _is = allParticipants.find(_user) != 0;\r\n    }\r\n\r\n    function isInModeratorsList(address _user)\r\n        public\r\n        view\r\n        returns (bool _is)\r\n    {\r\n        _is = allModerators.find(_user) != 0;\r\n    }\r\n\r\n    function readFirstModerator()\r\n        public\r\n        view\r\n        returns (address _item)\r\n    {\r\n        _item = read_first_from_addresses(allModerators);\r\n    }\r\n\r\n    function readLastModerator()\r\n        public\r\n        view\r\n        returns (address _item)\r\n    {\r\n        _item = read_last_from_addresses(allModerators);\r\n    }\r\n\r\n    function readNextModerator(address _current_item)\r\n        public\r\n        view\r\n        returns (address _item)\r\n    {\r\n        _item = read_next_from_addresses(allModerators, _current_item);\r\n    }\r\n\r\n    function readPreviousModerator(address _current_item)\r\n        public\r\n        view\r\n        returns (address _item)\r\n    {\r\n        _item = read_previous_from_addresses(allModerators, _current_item);\r\n    }\r\n\r\n    function readTotalModerators()\r\n        public\r\n        view\r\n        returns (uint256 _total_count)\r\n    {\r\n        _total_count = read_total_addresses(allModerators);\r\n    }\r\n\r\n    function readFirstParticipant()\r\n        public\r\n        view\r\n        returns (address _item)\r\n    {\r\n        _item = read_first_from_addresses(allParticipants);\r\n    }\r\n\r\n    function readLastParticipant()\r\n        public\r\n        view\r\n        returns (address _item)\r\n    {\r\n        _item = read_last_from_addresses(allParticipants);\r\n    }\r\n\r\n    function readNextParticipant(address _current_item)\r\n        public\r\n        view\r\n        returns (address _item)\r\n    {\r\n        _item = read_next_from_addresses(allParticipants, _current_item);\r\n    }\r\n\r\n    function readPreviousParticipant(address _current_item)\r\n        public\r\n        view\r\n        returns (address _item)\r\n    {\r\n        _item = read_previous_from_addresses(allParticipants, _current_item);\r\n    }\r\n\r\n    function readTotalParticipant()\r\n        public\r\n        view\r\n        returns (uint256 _total_count)\r\n    {\r\n        _total_count = read_total_addresses(allParticipants);\r\n    }\r\n}\r\n\r\n// File: contracts/service/DaoListingService.sol\r\n/**\r\n@title Contract to list various storage states from DigixDAO\r\n@author Digix Holdings\r\n*/\r\ncontract DaoListingService is\r\n    AddressIteratorInteractive,\r\n    BytesIteratorInteractive,\r\n    IndexedBytesIteratorInteractive,\r\n    DaoWhitelistingCommon\r\n{\r\n\r\n    /**\r\n    @notice Constructor\r\n    @param _resolver address of contract resolver\r\n    */\r\n    constructor(address _resolver) public {\r\n        require(init(CONTRACT_SERVICE_DAO_LISTING, _resolver));\r\n    }\r\n\r\n    function daoStakeStorage()\r\n        internal\r\n        view\r\n        returns (DaoStakeStorage _contract)\r\n    {\r\n        _contract = DaoStakeStorage(get_contract(CONTRACT_STORAGE_DAO_STAKE));\r\n    }\r\n\r\n    function daoStorage()\r\n        internal\r\n        view\r\n        returns (DaoStorage _contract)\r\n    {\r\n        _contract = DaoStorage(get_contract(CONTRACT_STORAGE_DAO));\r\n    }\r\n\r\n    /**\r\n    @notice function to list moderators\r\n    @dev note that this list may include some additional entries that are\r\n         not moderators in the current quarter. This may happen if they\r\n         were moderators in the previous quarter, but have not confirmed\r\n         their participation in the current quarter. For a single address,\r\n         a better way to know if moderator or not is:\r\n         Dao.isModerator(_user)\r\n    @param _count number of addresses to list\r\n    @param _from_start boolean, whether to list from start or end\r\n    @return {\r\n      \"_moderators\": \"list of moderator addresses\"\r\n    }\r\n    */\r\n    function listModerators(uint256 _count, bool _from_start)\r\n        public\r\n        view\r\n        returns (address[] _moderators)\r\n    {\r\n        _moderators = list_addresses(\r\n            _count,\r\n            daoStakeStorage().readFirstModerator,\r\n            daoStakeStorage().readLastModerator,\r\n            daoStakeStorage().readNextModerator,\r\n            daoStakeStorage().readPreviousModerator,\r\n            _from_start\r\n        );\r\n    }\r\n\r\n    /**\r\n    @notice function to list moderators from a particular moderator\r\n    @dev note that this list may include some additional entries that are\r\n         not moderators in the current quarter. This may happen if they\r\n         were moderators in the previous quarter, but have not confirmed\r\n         their participation in the current quarter. For a single address,\r\n         a better way to know if moderator or not is:\r\n         Dao.isModerator(_user)\r\n\r\n         Another note: this function will start listing AFTER the _currentModerator\r\n         For example: we have [address1, address2, address3, address4]. listModeratorsFrom(address1, 2, true) = [address2, address3]\r\n    @param _currentModerator start the list after this moderator address\r\n    @param _count number of addresses to list\r\n    @param _from_start boolean, whether to list from start or end\r\n    @return {\r\n      \"_moderators\": \"list of moderator addresses\"\r\n    }\r\n    */\r\n    function listModeratorsFrom(\r\n        address _currentModerator,\r\n        uint256 _count,\r\n        bool _from_start\r\n    )\r\n        public\r\n        view\r\n        returns (address[] _moderators)\r\n    {\r\n        _moderators = list_addresses_from(\r\n            _currentModerator,\r\n            _count,\r\n            daoStakeStorage().readFirstModerator,\r\n            daoStakeStorage().readLastModerator,\r\n            daoStakeStorage().readNextModerator,\r\n            daoStakeStorage().readPreviousModerator,\r\n            _from_start\r\n        );\r\n    }\r\n\r\n    /**\r\n    @notice function to list participants\r\n    @dev note that this list may include some additional entries that are\r\n         not participants in the current quarter. This may happen if they\r\n         were participants in the previous quarter, but have not confirmed\r\n         their participation in the current quarter. For a single address,\r\n         a better way to know if participant or not is:\r\n         Dao.isParticipant(_user)\r\n    @param _count number of addresses to list\r\n    @param _from_start boolean, whether to list from start or end\r\n    @return {\r\n      \"_participants\": \"list of participant addresses\"\r\n    }\r\n    */\r\n    function listParticipants(uint256 _count, bool _from_start)\r\n        public\r\n        view\r\n        returns (address[] _participants)\r\n    {\r\n        _participants = list_addresses(\r\n            _count,\r\n            daoStakeStorage().readFirstParticipant,\r\n            daoStakeStorage().readLastParticipant,\r\n            daoStakeStorage().readNextParticipant,\r\n            daoStakeStorage().readPreviousParticipant,\r\n            _from_start\r\n        );\r\n    }\r\n\r\n    /**\r\n    @notice function to list participants from a particular participant\r\n    @dev note that this list may include some additional entries that are\r\n         not participants in the current quarter. This may happen if they\r\n         were participants in the previous quarter, but have not confirmed\r\n         their participation in the current quarter. For a single address,\r\n         a better way to know if participant or not is:\r\n         contracts.dao.isParticipant(_user)\r\n\r\n         Another note: this function will start listing AFTER the _currentParticipant\r\n         For example: we have [address1, address2, address3, address4]. listParticipantsFrom(address1, 2, true) = [address2, address3]\r\n    @param _currentParticipant list from AFTER this participant address\r\n    @param _count number of addresses to list\r\n    @param _from_start boolean, whether to list from start or end\r\n    @return {\r\n      \"_participants\": \"list of participant addresses\"\r\n    }\r\n    */\r\n    function listParticipantsFrom(\r\n        address _currentParticipant,\r\n        uint256 _count,\r\n        bool _from_start\r\n    )\r\n        public\r\n        view\r\n        returns (address[] _participants)\r\n    {\r\n        _participants = list_addresses_from(\r\n            _currentParticipant,\r\n            _count,\r\n            daoStakeStorage().readFirstParticipant,\r\n            daoStakeStorage().readLastParticipant,\r\n            daoStakeStorage().readNextParticipant,\r\n            daoStakeStorage().readPreviousParticipant,\r\n            _from_start\r\n        );\r\n    }\r\n\r\n    /**\r\n    @notice function to list _count no. of proposals\r\n    @param _count number of proposals to list\r\n    @param _from_start boolean value, true if count from start, false if count from end\r\n    @return {\r\n      \"_proposals\": \"the list of proposal IDs\"\r\n    }\r\n    */\r\n    function listProposals(\r\n        uint256 _count,\r\n        bool _from_start\r\n    )\r\n        public\r\n        view\r\n        returns (bytes32[] _proposals)\r\n    {\r\n        _proposals = list_bytesarray(\r\n            _count,\r\n            daoStorage().getFirstProposal,\r\n            daoStorage().getLastProposal,\r\n            daoStorage().getNextProposal,\r\n            daoStorage().getPreviousProposal,\r\n            _from_start\r\n        );\r\n    }\r\n\r\n    /**\r\n    @notice function to list _count no. of proposals from AFTER _currentProposal\r\n    @param _currentProposal ID of proposal to list proposals from\r\n    @param _count number of proposals to list\r\n    @param _from_start boolean value, true if count forwards, false if count backwards\r\n    @return {\r\n      \"_proposals\": \"the list of proposal IDs\"\r\n    }\r\n    */\r\n    function listProposalsFrom(\r\n        bytes32 _currentProposal,\r\n        uint256 _count,\r\n        bool _from_start\r\n    )\r\n        public\r\n        view\r\n        returns (bytes32[] _proposals)\r\n    {\r\n        _proposals = list_bytesarray_from(\r\n            _currentProposal,\r\n            _count,\r\n            daoStorage().getFirstProposal,\r\n            daoStorage().getLastProposal,\r\n            daoStorage().getNextProposal,\r\n            daoStorage().getPreviousProposal,\r\n            _from_start\r\n        );\r\n    }\r\n\r\n    /**\r\n    @notice function to list _count no. of proposals in state _stateId\r\n    @param _stateId state of proposal\r\n    @param _count number of proposals to list\r\n    @param _from_start boolean value, true if count from start, false if count from end\r\n    @return {\r\n      \"_proposals\": \"the list of proposal IDs\"\r\n    }\r\n    */\r\n    function listProposalsInState(\r\n        bytes32 _stateId,\r\n        uint256 _count,\r\n        bool _from_start\r\n    )\r\n        public\r\n        view\r\n        returns (bytes32[] _proposals)\r\n    {\r\n        require(senderIsAllowedToRead());\r\n        _proposals = list_indexed_bytesarray(\r\n            _stateId,\r\n            _count,\r\n            daoStorage().getFirstProposalInState,\r\n            daoStorage().getLastProposalInState,\r\n            daoStorage().getNextProposalInState,\r\n            daoStorage().getPreviousProposalInState,\r\n            _from_start\r\n        );\r\n    }\r\n\r\n    /**\r\n    @notice function to list _count no. of proposals in state _stateId from AFTER _currentProposal\r\n    @param _stateId state of proposal\r\n    @param _currentProposal ID of proposal to list proposals from\r\n    @param _count number of proposals to list\r\n    @param _from_start boolean value, true if count forwards, false if count backwards\r\n    @return {\r\n      \"_proposals\": \"the list of proposal IDs\"\r\n    }\r\n    */\r\n    function listProposalsInStateFrom(\r\n        bytes32 _stateId,\r\n        bytes32 _currentProposal,\r\n        uint256 _count,\r\n        bool _from_start\r\n    )\r\n        public\r\n        view\r\n        returns (bytes32[] _proposals)\r\n    {\r\n        require(senderIsAllowedToRead());\r\n        _proposals = list_indexed_bytesarray_from(\r\n            _stateId,\r\n            _currentProposal,\r\n            _count,\r\n            daoStorage().getFirstProposalInState,\r\n            daoStorage().getLastProposalInState,\r\n            daoStorage().getNextProposalInState,\r\n            daoStorage().getPreviousProposalInState,\r\n            _from_start\r\n        );\r\n    }\r\n\r\n    /**\r\n    @notice function to list proposal versions\r\n    @param _proposalId ID of the proposal\r\n    @param _count number of proposal versions to list\r\n    @param _from_start boolean, true to list from start, false to list from end\r\n    @return {\r\n      \"_versions\": \"list of proposal versions\"\r\n    }\r\n    */\r\n    function listProposalVersions(\r\n        bytes32 _proposalId,\r\n        uint256 _count,\r\n        bool _from_start\r\n    )\r\n        public\r\n        view\r\n        returns (bytes32[] _versions)\r\n    {\r\n        _versions = list_indexed_bytesarray(\r\n            _proposalId,\r\n            _count,\r\n            daoStorage().getFirstProposalVersion,\r\n            daoStorage().getLastProposalVersion,\r\n            daoStorage().getNextProposalVersion,\r\n            daoStorage().getPreviousProposalVersion,\r\n            _from_start\r\n        );\r\n    }\r\n\r\n    /**\r\n    @notice function to list proposal versions from AFTER a particular version\r\n    @param _proposalId ID of the proposal\r\n    @param _currentVersion version to list _count versions from\r\n    @param _count number of proposal versions to list\r\n    @param _from_start boolean, true to list from start, false to list from end\r\n    @return {\r\n      \"_versions\": \"list of proposal versions\"\r\n    }\r\n    */\r\n    function listProposalVersionsFrom(\r\n        bytes32 _proposalId,\r\n        bytes32 _currentVersion,\r\n        uint256 _count,\r\n        bool _from_start\r\n    )\r\n        public\r\n        view\r\n        returns (bytes32[] _versions)\r\n    {\r\n        _versions = list_indexed_bytesarray_from(\r\n            _proposalId,\r\n            _currentVersion,\r\n            _count,\r\n            daoStorage().getFirstProposalVersion,\r\n            daoStorage().getLastProposalVersion,\r\n            daoStorage().getNextProposalVersion,\r\n            daoStorage().getPreviousProposalVersion,\r\n            _from_start\r\n        );\r\n    }\r\n}\r\n\r\n// File: @digix/solidity-collections/contracts/abstract/IndexedAddressIteratorStorage.sol\r\n/**\r\n  @title Indexed Address IteratorStorage\r\n  @author DigixGlobal Pte Ltd\r\n  @notice This contract utilizes: [Doubly Linked List](/DoublyLinkedList)\r\n*/\r\ncontract IndexedAddressIteratorStorage {\r\n\r\n  using DoublyLinkedList for DoublyLinkedList.IndexedAddress;\r\n  /**\r\n    @notice Reads the first item from an Indexed Address Doubly Linked List\r\n    @param _list The source list\r\n    @param _collection_index Index of the Collection to evaluate\r\n    @return {\"_item\" : \"First item on the list\"}\r\n  */\r\n  function read_first_from_indexed_addresses(DoublyLinkedList.IndexedAddress storage _list, bytes32 _collection_index)\r\n           internal\r\n           constant\r\n           returns (address _item)\r\n  {\r\n    _item = _list.start_item(_collection_index);\r\n  }\r\n\r\n  /**\r\n    @notice Reads the last item from an Indexed Address Doubly Linked list\r\n    @param _list The source list\r\n    @param _collection_index Index of the Collection to evaluate\r\n    @return {\"_item\" : \"First item on the list\"}\r\n  */\r\n  function read_last_from_indexed_addresses(DoublyLinkedList.IndexedAddress storage _list, bytes32 _collection_index)\r\n           internal\r\n           constant\r\n           returns (address _item)\r\n  {\r\n    _item = _list.end_item(_collection_index);\r\n  }\r\n\r\n  /**\r\n    @notice Reads the next item from an Indexed Address Doubly Linked List based on the specified `_current_item`\r\n    @param _list The source list\r\n    @param _collection_index Index of the Collection to evaluate\r\n    @param _current_item The current item to use as base line\r\n    @return {\"_item\": \"The next item on the list\"}\r\n  */\r\n  function read_next_from_indexed_addresses(DoublyLinkedList.IndexedAddress storage _list, bytes32 _collection_index, address _current_item)\r\n           internal\r\n           constant\r\n           returns (address _item)\r\n  {\r\n    _item = _list.next_item(_collection_index, _current_item);\r\n  }\r\n\r\n  /**\r\n    @notice Reads the previous item from an Index Address Doubly Linked List based on the specified `_current_item`\r\n    @param _list The source list\r\n    @param _collection_index Index of the Collection to evaluate\r\n    @param _current_item The current item to use as base line\r\n    @return {\"_item\" : \"The previous item on the list\"}\r\n  */\r\n  function read_previous_from_indexed_addresses(DoublyLinkedList.IndexedAddress storage _list, bytes32 _collection_index, address _current_item)\r\n           internal\r\n           constant\r\n           returns (address _item)\r\n  {\r\n    _item = _list.previous_item(_collection_index, _current_item);\r\n  }\r\n\r\n\r\n  /**\r\n    @notice Reads the total number of items in an Indexed Address Doubly Linked List\r\n    @param _list  The source list\r\n    @param _collection_index Index of the Collection to evaluate\r\n    @return {\"_count\": \"Length of the Doubly Linked list\"}\r\n  */\r\n  function read_total_indexed_addresses(DoublyLinkedList.IndexedAddress storage _list, bytes32 _collection_index)\r\n           internal\r\n           constant\r\n           returns (uint256 _count)\r\n  {\r\n    _count = _list.total(_collection_index);\r\n  }\r\n}\r\n\r\n// File: @digix/solidity-collections/contracts/abstract/UintIteratorStorage.sol\r\n/**\r\n  @title Uint Iterator Storage\r\n  @author DigixGlobal Pte Ltd\r\n*/\r\ncontract UintIteratorStorage {\r\n\r\n  using DoublyLinkedList for DoublyLinkedList.Uint;\r\n\r\n  /**\r\n    @notice Returns the first item from a `DoublyLinkedList.Uint` list\r\n    @param _list The DoublyLinkedList.Uint list\r\n    @return {\"_item\": \"The first item\"}\r\n  */\r\n  function read_first_from_uints(DoublyLinkedList.Uint storage _list)\r\n           internal\r\n           constant\r\n           returns (uint256 _item)\r\n  {\r\n    _item = _list.start_item();\r\n  }\r\n\r\n  /**\r\n    @notice Returns the last item from a `DoublyLinkedList.Uint` list\r\n    @param _list The DoublyLinkedList.Uint list\r\n    @return {\"_item\": \"The last item\"}\r\n  */\r\n  function read_last_from_uints(DoublyLinkedList.Uint storage _list)\r\n           internal\r\n           constant\r\n           returns (uint256 _item)\r\n  {\r\n    _item = _list.end_item();\r\n  }\r\n\r\n  /**\r\n    @notice Returns the next item from a `DoublyLinkedList.Uint` list based on the specified `_current_item`\r\n    @param _list The DoublyLinkedList.Uint list\r\n    @param _current_item The current item\r\n    @return {\"_item\": \"The next item\"}\r\n  */\r\n  function read_next_from_uints(DoublyLinkedList.Uint storage _list, uint256 _current_item)\r\n           internal\r\n           constant\r\n           returns (uint256 _item)\r\n  {\r\n    _item = _list.next_item(_current_item);\r\n  }\r\n\r\n  /**\r\n    @notice Returns the previous item from a `DoublyLinkedList.Uint` list based on the specified `_current_item`\r\n    @param _list The DoublyLinkedList.Uint list\r\n    @param _current_item The current item\r\n    @return {\"_item\": \"The previous item\"}\r\n  */\r\n  function read_previous_from_uints(DoublyLinkedList.Uint storage _list, uint256 _current_item)\r\n           internal\r\n           constant\r\n           returns (uint256 _item)\r\n  {\r\n    _item = _list.previous_item(_current_item);\r\n  }\r\n\r\n  /**\r\n    @notice Returns the total count of itemsfrom a `DoublyLinkedList.Uint` list\r\n    @param _list The DoublyLinkedList.Uint list\r\n    @return {\"_count\": \"The total count of items\"}\r\n  */\r\n  function read_total_uints(DoublyLinkedList.Uint storage _list)\r\n           internal\r\n           constant\r\n           returns (uint256 _count)\r\n  {\r\n    _count = _list.total();\r\n  }\r\n}\r\n\r\n// File: @digix/cdap/contracts/storage/DirectoryStorage.sol\r\n/**\r\n@title Directory Storage contains information of a directory\r\n@author DigixGlobal\r\n*/\r\ncontract DirectoryStorage is IndexedAddressIteratorStorage, UintIteratorStorage {\r\n\r\n  using DoublyLinkedList for DoublyLinkedList.IndexedAddress;\r\n  using DoublyLinkedList for DoublyLinkedList.Uint;\r\n\r\n  struct User {\r\n    bytes32 document;\r\n    bool active;\r\n  }\r\n\r\n  struct Group {\r\n    bytes32 name;\r\n    bytes32 document;\r\n    uint256 role_id;\r\n    mapping(address => User) members_by_address;\r\n  }\r\n\r\n  struct System {\r\n    DoublyLinkedList.Uint groups;\r\n    DoublyLinkedList.IndexedAddress groups_collection;\r\n    mapping (uint256 => Group) groups_by_id;\r\n    mapping (address => uint256) group_ids_by_address;\r\n    mapping (uint256 => bytes32) roles_by_id;\r\n    bool initialized;\r\n    uint256 total_groups;\r\n  }\r\n\r\n  System system;\r\n\r\n  /**\r\n  @notice Initializes directory settings\r\n  @return _success If directory initialization is successful\r\n  */\r\n  function initialize_directory()\r\n           internal\r\n           returns (bool _success)\r\n  {\r\n    require(system.initialized == false);\r\n    system.total_groups = 0;\r\n    system.initialized = true;\r\n    internal_create_role(1, \"root\");\r\n    internal_create_group(1, \"root\", \"\");\r\n    _success = internal_update_add_user_to_group(1, tx.origin, \"\");\r\n  }\r\n\r\n  /**\r\n  @notice Creates a new role with the given information\r\n  @param _role_id Id of the new role\r\n  @param _name Name of the new role\r\n  @return {\"_success\": \"If creation of new role is successful\"}\r\n  */\r\n  function internal_create_role(uint256 _role_id, bytes32 _name)\r\n           internal\r\n           returns (bool _success)\r\n  {\r\n    require(_role_id > 0);\r\n    require(_name != bytes32(0x0));\r\n    system.roles_by_id[_role_id] = _name;\r\n    _success = true;\r\n  }\r\n\r\n  /**\r\n  @notice Returns the role's name of a role id\r\n  @param _role_id Id of the role\r\n  @return {\"_name\": \"Name of the role\"}\r\n  */\r\n  function read_role(uint256 _role_id)\r\n           public\r\n           constant\r\n           returns (bytes32 _name)\r\n  {\r\n    _name = system.roles_by_id[_role_id];\r\n  }\r\n\r\n  /**\r\n  @notice Creates a new group with the given information\r\n  @param _role_id Role id of the new group\r\n  @param _name Name of the new group\r\n  @param _document Document of the new group\r\n  @return {\r\n    \"_success\": \"If creation of the new group is successful\",\r\n    \"_group_id: \"Id of the new group\"\r\n  }\r\n  */\r\n  function internal_create_group(uint256 _role_id, bytes32 _name, bytes32 _document)\r\n           internal\r\n           returns (bool _success, uint256 _group_id)\r\n  {\r\n    require(_role_id > 0);\r\n    require(read_role(_role_id) != bytes32(0x0));\r\n    _group_id = ++system.total_groups;\r\n    system.groups.append(_group_id);\r\n    system.groups_by_id[_group_id].role_id = _role_id;\r\n    system.groups_by_id[_group_id].name = _name;\r\n    system.groups_by_id[_group_id].document = _document;\r\n    _success = true;\r\n  }\r\n\r\n  /**\r\n  @notice Returns the group's information\r\n  @param _group_id Id of the group\r\n  @return {\r\n    \"_role_id\": \"Role id of the group\",\r\n    \"_name: \"Name of the group\",\r\n    \"_document: \"Document of the group\"\r\n  }\r\n  */\r\n  function read_group(uint256 _group_id)\r\n           public\r\n           constant\r\n           returns (uint256 _role_id, bytes32 _name, bytes32 _document, uint256 _members_count)\r\n  {\r\n    if (system.groups.valid_item(_group_id)) {\r\n      _role_id = system.groups_by_id[_group_id].role_id;\r\n      _name = system.groups_by_id[_group_id].name;\r\n      _document = system.groups_by_id[_group_id].document;\r\n      _members_count = read_total_indexed_addresses(system.groups_collection, bytes32(_group_id));\r\n    } else {\r\n      _role_id = 0;\r\n      _name = \"invalid\";\r\n      _document = \"\";\r\n      _members_count = 0;\r\n    }\r\n  }\r\n\r\n  /**\r\n  @notice Adds new user with the given information to a group\r\n  @param _group_id Id of the group\r\n  @param _user Address of the new user\r\n  @param _document Information of the new user\r\n  @return {\"_success\": \"If adding new user to a group is successful\"}\r\n  */\r\n  function internal_update_add_user_to_group(uint256 _group_id, address _user, bytes32 _document)\r\n           internal\r\n           returns (bool _success)\r\n  {\r\n    if (system.groups_by_id[_group_id].members_by_address[_user].active == false && system.group_ids_by_address[_user] == 0 && system.groups_by_id[_group_id].role_id != 0) {\r\n\r\n      system.groups_by_id[_group_id].members_by_address[_user].active = true;\r\n      system.group_ids_by_address[_user] = _group_id;\r\n      system.groups_collection.append(bytes32(_group_id), _user);\r\n      system.groups_by_id[_group_id].members_by_address[_user].document = _document;\r\n      _success = true;\r\n    } else {\r\n      _success = false;\r\n    }\r\n  }\r\n\r\n  /**\r\n  @notice Removes user from its group\r\n  @param _user Address of the user\r\n  @return {\"_success\": \"If removing of user is successful\"}\r\n  */\r\n  function internal_destroy_group_user(address _user)\r\n           internal\r\n           returns (bool _success)\r\n  {\r\n    uint256 _group_id = system.group_ids_by_address[_user];\r\n    if ((_group_id == 1) && (system.groups_collection.total(bytes32(_group_id)) == 1)) {\r\n      _success = false;\r\n    } else {\r\n      system.groups_by_id[_group_id].members_by_address[_user].active = false;\r\n      system.group_ids_by_address[_user] = 0;\r\n      delete system.groups_by_id[_group_id].members_by_address[_user];\r\n      _success = system.groups_collection.remove_item(bytes32(_group_id), _user);\r\n    }\r\n  }\r\n\r\n  /**\r\n  @notice Returns the role id of a user\r\n  @param _user Address of a user\r\n  @return {\"_role_id\": \"Role id of the user\"}\r\n  */\r\n  function read_user_role_id(address _user)\r\n           constant\r\n           public\r\n           returns (uint256 _role_id)\r\n  {\r\n    uint256 _group_id = system.group_ids_by_address[_user];\r\n    _role_id = system.groups_by_id[_group_id].role_id;\r\n  }\r\n\r\n  /**\r\n  @notice Returns the user's information\r\n  @param _user Address of the user\r\n  @return {\r\n    \"_group_id\": \"Group id of the user\",\r\n    \"_role_id\": \"Role id of the user\",\r\n    \"_document\": \"Information of the user\"\r\n  }\r\n  */\r\n  function read_user(address _user)\r\n           public\r\n           constant\r\n           returns (uint256 _group_id, uint256 _role_id, bytes32 _document)\r\n  {\r\n    _group_id = system.group_ids_by_address[_user];\r\n    _role_id = system.groups_by_id[_group_id].role_id;\r\n    _document = system.groups_by_id[_group_id].members_by_address[_user].document;\r\n  }\r\n\r\n  /**\r\n  @notice Returns the id of the first group\r\n  @return {\"_group_id\": \"Id of the first group\"}\r\n  */\r\n  function read_first_group()\r\n           view\r\n           external\r\n           returns (uint256 _group_id)\r\n  {\r\n    _group_id = read_first_from_uints(system.groups);\r\n  }\r\n\r\n  /**\r\n  @notice Returns the id of the last group\r\n  @return {\"_group_id\": \"Id of the last group\"}\r\n  */\r\n  function read_last_group()\r\n           view\r\n           external\r\n           returns (uint256 _group_id)\r\n  {\r\n    _group_id = read_last_from_uints(system.groups);\r\n  }\r\n\r\n  /**\r\n  @notice Returns the id of the previous group depending on the given current group\r\n  @param _current_group_id Id of the current group\r\n  @return {\"_group_id\": \"Id of the previous group\"}\r\n  */\r\n  function read_previous_group_from_group(uint256 _current_group_id)\r\n           view\r\n           external\r\n           returns (uint256 _group_id)\r\n  {\r\n    _group_id = read_previous_from_uints(system.groups, _current_group_id);\r\n  }\r\n\r\n  /**\r\n  @notice Returns the id of the next group depending on the given current group\r\n  @param _current_group_id Id of the current group\r\n  @return {\"_group_id\": \"Id of the next group\"}\r\n  */\r\n  function read_next_group_from_group(uint256 _current_group_id)\r\n           view\r\n           external\r\n           returns (uint256 _group_id)\r\n  {\r\n    _group_id = read_next_from_uints(system.groups, _current_group_id);\r\n  }\r\n\r\n  /**\r\n  @notice Returns the total number of groups\r\n  @return {\"_total_groups\": \"Total number of groups\"}\r\n  */\r\n  function read_total_groups()\r\n           view\r\n           external\r\n           returns (uint256 _total_groups)\r\n  {\r\n    _total_groups = read_total_uints(system.groups);\r\n  }\r\n\r\n  /**\r\n  @notice Returns the first user of a group\r\n  @param _group_id Id of the group\r\n  @return {\"_user\": \"Address of the user\"}\r\n  */\r\n  function read_first_user_in_group(bytes32 _group_id)\r\n           view\r\n           external\r\n           returns (address _user)\r\n  {\r\n    _user = read_first_from_indexed_addresses(system.groups_collection, bytes32(_group_id));\r\n  }\r\n\r\n  /**\r\n  @notice Returns the last user of a group\r\n  @param _group_id Id of the group\r\n  @return {\"_user\": \"Address of the user\"}\r\n  */\r\n  function read_last_user_in_group(bytes32 _group_id)\r\n           view\r\n           external\r\n           returns (address _user)\r\n  {\r\n    _user = read_last_from_indexed_addresses(system.groups_collection, bytes32(_group_id));\r\n  }\r\n\r\n  /**\r\n  @notice Returns the next user of a group depending on the given current user\r\n  @param _group_id Id of the group\r\n  @param _current_user Address of the current user\r\n  @return {\"_user\": \"Address of the next user\"}\r\n  */\r\n  function read_next_user_in_group(bytes32 _group_id, address _current_user)\r\n           view\r\n           external\r\n           returns (address _user)\r\n  {\r\n    _user = read_next_from_indexed_addresses(system.groups_collection, bytes32(_group_id), _current_user);\r\n  }\r\n\r\n  /**\r\n  @notice Returns the previous user of a group depending on the given current user\r\n  @param _group_id Id of the group\r\n  @param _current_user Address of the current user\r\n  @return {\"_user\": \"Address of the last user\"}\r\n  */\r\n  function read_previous_user_in_group(bytes32 _group_id, address _current_user)\r\n           view\r\n           external\r\n           returns (address _user)\r\n  {\r\n    _user = read_previous_from_indexed_addresses(system.groups_collection, bytes32(_group_id), _current_user);\r\n  }\r\n\r\n  /**\r\n  @notice Returns the total number of users of a group\r\n  @param _group_id Id of the group\r\n  @return {\"_total_users\": \"Total number of users\"}\r\n  */\r\n  function read_total_users_in_group(bytes32 _group_id)\r\n           view\r\n           external\r\n           returns (uint256 _total_users)\r\n  {\r\n    _total_users = read_total_indexed_addresses(system.groups_collection, bytes32(_group_id));\r\n  }\r\n}\r\n\r\n// File: contracts/storage/DaoIdentityStorage.sol\r\ncontract DaoIdentityStorage is ResolverClient, DaoConstants, DirectoryStorage {\r\n\r\n    // struct for KYC details\r\n    // doc is the IPFS doc hash for any information regarding this KYC\r\n    // id_expiration is the UTC timestamp at which this KYC will expire\r\n    // at any time after this, the user's KYC is invalid, and that user\r\n    // MUST re-KYC before doing any proposer related operation in DigixDAO\r\n    struct KycDetails {\r\n        bytes32 doc;\r\n        uint256 id_expiration;\r\n    }\r\n\r\n    // a mapping of address to the KYC details\r\n    mapping (address => KycDetails) kycInfo;\r\n\r\n    constructor(address _resolver)\r\n        public\r\n    {\r\n        require(init(CONTRACT_STORAGE_DAO_IDENTITY, _resolver));\r\n        require(initialize_directory());\r\n    }\r\n\r\n    function create_group(uint256 _role_id, bytes32 _name, bytes32 _document)\r\n        public\r\n        returns (bool _success, uint256 _group_id)\r\n    {\r\n        require(sender_is(CONTRACT_DAO_IDENTITY));\r\n        (_success, _group_id) = internal_create_group(_role_id, _name, _document);\r\n        require(_success);\r\n    }\r\n\r\n    function create_role(uint256 _role_id, bytes32 _name)\r\n        public\r\n        returns (bool _success)\r\n    {\r\n        require(sender_is(CONTRACT_DAO_IDENTITY));\r\n        _success = internal_create_role(_role_id, _name);\r\n        require(_success);\r\n    }\r\n\r\n    function update_add_user_to_group(uint256 _group_id, address _user, bytes32 _document)\r\n        public\r\n        returns (bool _success)\r\n    {\r\n        require(sender_is(CONTRACT_DAO_IDENTITY));\r\n        _success = internal_update_add_user_to_group(_group_id, _user, _document);\r\n        require(_success);\r\n    }\r\n\r\n    function update_remove_group_user(address _user)\r\n        public\r\n        returns (bool _success)\r\n    {\r\n        require(sender_is(CONTRACT_DAO_IDENTITY));\r\n        _success = internal_destroy_group_user(_user);\r\n        require(_success);\r\n    }\r\n\r\n    function update_kyc(address _user, bytes32 _doc, uint256 _id_expiration)\r\n        public\r\n    {\r\n        require(sender_is(CONTRACT_DAO_IDENTITY));\r\n        kycInfo[_user].doc = _doc;\r\n        kycInfo[_user].id_expiration = _id_expiration;\r\n    }\r\n\r\n    function read_kyc_info(address _user)\r\n        public\r\n        view\r\n        returns (bytes32 _doc, uint256 _id_expiration)\r\n    {\r\n        _doc = kycInfo[_user].doc;\r\n        _id_expiration = kycInfo[_user].id_expiration;\r\n    }\r\n\r\n    function is_kyc_approved(address _user)\r\n        public\r\n        view\r\n        returns (bool _approved)\r\n    {\r\n        uint256 _id_expiration;\r\n        (,_id_expiration) = read_kyc_info(_user);\r\n        _approved = _id_expiration > now;\r\n    }\r\n}\r\n\r\n// File: contracts/common/IdentityCommon.sol\r\ncontract IdentityCommon is DaoWhitelistingCommon {\r\n\r\n    modifier if_root() {\r\n        require(identity_storage().read_user_role_id(msg.sender) == ROLES_ROOT);\r\n        _;\r\n    }\r\n\r\n    modifier if_founder() {\r\n        require(is_founder());\r\n        _;\r\n    }\r\n\r\n    function is_founder()\r\n        internal\r\n        view\r\n        returns (bool _isFounder)\r\n    {\r\n        _isFounder = identity_storage().read_user_role_id(msg.sender) == ROLES_FOUNDERS;\r\n    }\r\n\r\n    modifier if_prl() {\r\n        require(identity_storage().read_user_role_id(msg.sender) == ROLES_PRLS);\r\n        _;\r\n    }\r\n\r\n    modifier if_kyc_admin() {\r\n        require(identity_storage().read_user_role_id(msg.sender) == ROLES_KYC_ADMINS);\r\n        _;\r\n    }\r\n\r\n    function identity_storage()\r\n        internal\r\n        view\r\n        returns (DaoIdentityStorage _contract)\r\n    {\r\n        _contract = DaoIdentityStorage(get_contract(CONTRACT_STORAGE_DAO_IDENTITY));\r\n    }\r\n}\r\n\r\n// File: contracts/storage/DaoConfigsStorage.sol\r\ncontract DaoConfigsStorage is ResolverClient, DaoConstants {\r\n\r\n    // mapping of config name to config value\r\n    // config names can be found in DaoConstants contract\r\n    mapping (bytes32 => uint256) public uintConfigs;\r\n\r\n    // mapping of config name to config value\r\n    // config names can be found in DaoConstants contract\r\n    mapping (bytes32 => address) public addressConfigs;\r\n\r\n    // mapping of config name to config value\r\n    // config names can be found in DaoConstants contract\r\n    mapping (bytes32 => bytes32) public bytesConfigs;\r\n\r\n    uint256 ONE_BILLION = 1000000000;\r\n    uint256 ONE_MILLION = 1000000;\r\n\r\n    constructor(address _resolver)\r\n        public\r\n    {\r\n        require(init(CONTRACT_STORAGE_DAO_CONFIG, _resolver));\r\n\r\n        uintConfigs[CONFIG_LOCKING_PHASE_DURATION] = 10 days;\r\n        uintConfigs[CONFIG_QUARTER_DURATION] = QUARTER_DURATION;\r\n        uintConfigs[CONFIG_VOTING_COMMIT_PHASE] = 14 days;\r\n        uintConfigs[CONFIG_VOTING_PHASE_TOTAL] = 21 days;\r\n        uintConfigs[CONFIG_INTERIM_COMMIT_PHASE] = 7 days;\r\n        uintConfigs[CONFIG_INTERIM_PHASE_TOTAL] = 14 days;\r\n\r\n\r\n\r\n        uintConfigs[CONFIG_DRAFT_QUORUM_FIXED_PORTION_NUMERATOR] = 5; // 5%\r\n        uintConfigs[CONFIG_DRAFT_QUORUM_FIXED_PORTION_DENOMINATOR] = 100; // 5%\r\n        uintConfigs[CONFIG_DRAFT_QUORUM_SCALING_FACTOR_NUMERATOR] = 35; // 35%\r\n        uintConfigs[CONFIG_DRAFT_QUORUM_SCALING_FACTOR_DENOMINATOR] = 100; // 35%\r\n\r\n\r\n        uintConfigs[CONFIG_VOTING_QUORUM_FIXED_PORTION_NUMERATOR] = 5; // 5%\r\n        uintConfigs[CONFIG_VOTING_QUORUM_FIXED_PORTION_DENOMINATOR] = 100; // 5%\r\n        uintConfigs[CONFIG_VOTING_QUORUM_SCALING_FACTOR_NUMERATOR] = 25; // 25%\r\n        uintConfigs[CONFIG_VOTING_QUORUM_SCALING_FACTOR_DENOMINATOR] = 100; // 25%\r\n\r\n        uintConfigs[CONFIG_DRAFT_QUOTA_NUMERATOR] = 1; // >50%\r\n        uintConfigs[CONFIG_DRAFT_QUOTA_DENOMINATOR] = 2; // >50%\r\n        uintConfigs[CONFIG_VOTING_QUOTA_NUMERATOR] = 1; // >50%\r\n        uintConfigs[CONFIG_VOTING_QUOTA_DENOMINATOR] = 2; // >50%\r\n\r\n\r\n        uintConfigs[CONFIG_QUARTER_POINT_DRAFT_VOTE] = ONE_BILLION;\r\n        uintConfigs[CONFIG_QUARTER_POINT_VOTE] = ONE_BILLION;\r\n        uintConfigs[CONFIG_QUARTER_POINT_INTERIM_VOTE] = ONE_BILLION;\r\n\r\n        uintConfigs[CONFIG_QUARTER_POINT_MILESTONE_COMPLETION_PER_10000ETH] = 20000 * ONE_BILLION;\r\n\r\n        uintConfigs[CONFIG_BONUS_REPUTATION_NUMERATOR] = 15; // 15% bonus for consistent votes\r\n        uintConfigs[CONFIG_BONUS_REPUTATION_DENOMINATOR] = 100; // 15% bonus for consistent votes\r\n\r\n        uintConfigs[CONFIG_SPECIAL_PROPOSAL_COMMIT_PHASE] = 28 days;\r\n        uintConfigs[CONFIG_SPECIAL_PROPOSAL_PHASE_TOTAL] = 35 days;\r\n\r\n\r\n\r\n        uintConfigs[CONFIG_SPECIAL_QUOTA_NUMERATOR] = 1; // >50%\r\n        uintConfigs[CONFIG_SPECIAL_QUOTA_DENOMINATOR] = 2; // >50%\r\n\r\n        uintConfigs[CONFIG_SPECIAL_PROPOSAL_QUORUM_NUMERATOR] = 40; // 40%\r\n        uintConfigs[CONFIG_SPECIAL_PROPOSAL_QUORUM_DENOMINATOR] = 100; // 40%\r\n\r\n        uintConfigs[CONFIG_MAXIMUM_REPUTATION_DEDUCTION] = 8334 * ONE_MILLION;\r\n\r\n        uintConfigs[CONFIG_PUNISHMENT_FOR_NOT_LOCKING] = 1666 * ONE_MILLION;\r\n        uintConfigs[CONFIG_REPUTATION_PER_EXTRA_QP_NUM] = 1; // 1 extra QP gains 1/1 RP\r\n        uintConfigs[CONFIG_REPUTATION_PER_EXTRA_QP_DEN] = 1;\r\n\r\n\r\n        uintConfigs[CONFIG_MINIMAL_QUARTER_POINT] = 2 * ONE_BILLION;\r\n        uintConfigs[CONFIG_QUARTER_POINT_SCALING_FACTOR] = 400 * ONE_BILLION;\r\n        uintConfigs[CONFIG_REPUTATION_POINT_SCALING_FACTOR] = 2000 * ONE_BILLION;\r\n\r\n        uintConfigs[CONFIG_MODERATOR_MINIMAL_QUARTER_POINT] = 4 * ONE_BILLION;\r\n        uintConfigs[CONFIG_MODERATOR_QUARTER_POINT_SCALING_FACTOR] = 400 * ONE_BILLION;\r\n        uintConfigs[CONFIG_MODERATOR_REPUTATION_POINT_SCALING_FACTOR] = 2000 * ONE_BILLION;\r\n\r\n        uintConfigs[CONFIG_PORTION_TO_MODERATORS_NUM] = 42; //4.2% of DGX to moderator voting activity\r\n        uintConfigs[CONFIG_PORTION_TO_MODERATORS_DEN] = 1000;\r\n\r\n        uintConfigs[CONFIG_DRAFT_VOTING_PHASE] = 10 days;\r\n\r\n        uintConfigs[CONFIG_REPUTATION_POINT_BOOST_FOR_BADGE] = 412500 * ONE_MILLION;\r\n\r\n        uintConfigs[CONFIG_FINAL_REWARD_SCALING_FACTOR_NUMERATOR] = 7; // 7%\r\n        uintConfigs[CONFIG_FINAL_REWARD_SCALING_FACTOR_DENOMINATOR] = 100; // 7%\r\n\r\n        uintConfigs[CONFIG_MAXIMUM_MODERATOR_REPUTATION_DEDUCTION] = 12500 * ONE_MILLION;\r\n        uintConfigs[CONFIG_REPUTATION_PER_EXTRA_MODERATOR_QP_NUM] = 1;\r\n        uintConfigs[CONFIG_REPUTATION_PER_EXTRA_MODERATOR_QP_DEN] = 1;\r\n\r\n        uintConfigs[CONFIG_VOTE_CLAIMING_DEADLINE] = 10 days;\r\n\r\n        uintConfigs[CONFIG_MINIMUM_LOCKED_DGD] = 10 * ONE_BILLION;\r\n        uintConfigs[CONFIG_MINIMUM_DGD_FOR_MODERATOR] = 842 * ONE_BILLION;\r\n        uintConfigs[CONFIG_MINIMUM_REPUTATION_FOR_MODERATOR] = 400 * ONE_BILLION;\r\n\r\n        uintConfigs[CONFIG_PREPROPOSAL_COLLATERAL] = 2 ether;\r\n\r\n        uintConfigs[CONFIG_MAX_FUNDING_FOR_NON_DIGIX] = 100 ether;\r\n        uintConfigs[CONFIG_MAX_MILESTONES_FOR_NON_DIGIX] = 5;\r\n        uintConfigs[CONFIG_NON_DIGIX_PROPOSAL_CAP_PER_QUARTER] = 80;\r\n\r\n        uintConfigs[CONFIG_PROPOSAL_DEAD_DURATION] = 90 days;\r\n        uintConfigs[CONFIG_CARBON_VOTE_REPUTATION_BONUS] = 10 * ONE_BILLION;\r\n    }\r\n\r\n    function updateUintConfigs(uint256[] _uintConfigs)\r\n        external\r\n    {\r\n        require(sender_is(CONTRACT_DAO_SPECIAL_VOTING_CLAIMS));\r\n        uintConfigs[CONFIG_LOCKING_PHASE_DURATION] = _uintConfigs[0];\r\n        /*\r\n        This used to be a config that can be changed. Now, _uintConfigs[1] is just a dummy config that doesnt do anything\r\n        uintConfigs[CONFIG_QUARTER_DURATION] = _uintConfigs[1];\r\n        */\r\n        uintConfigs[CONFIG_VOTING_COMMIT_PHASE] = _uintConfigs[2];\r\n        uintConfigs[CONFIG_VOTING_PHASE_TOTAL] = _uintConfigs[3];\r\n        uintConfigs[CONFIG_INTERIM_COMMIT_PHASE] = _uintConfigs[4];\r\n        uintConfigs[CONFIG_INTERIM_PHASE_TOTAL] = _uintConfigs[5];\r\n        uintConfigs[CONFIG_DRAFT_QUORUM_FIXED_PORTION_NUMERATOR] = _uintConfigs[6];\r\n        uintConfigs[CONFIG_DRAFT_QUORUM_FIXED_PORTION_DENOMINATOR] = _uintConfigs[7];\r\n        uintConfigs[CONFIG_DRAFT_QUORUM_SCALING_FACTOR_NUMERATOR] = _uintConfigs[8];\r\n        uintConfigs[CONFIG_DRAFT_QUORUM_SCALING_FACTOR_DENOMINATOR] = _uintConfigs[9];\r\n        uintConfigs[CONFIG_VOTING_QUORUM_FIXED_PORTION_NUMERATOR] = _uintConfigs[10];\r\n        uintConfigs[CONFIG_VOTING_QUORUM_FIXED_PORTION_DENOMINATOR] = _uintConfigs[11];\r\n        uintConfigs[CONFIG_VOTING_QUORUM_SCALING_FACTOR_NUMERATOR] = _uintConfigs[12];\r\n        uintConfigs[CONFIG_VOTING_QUORUM_SCALING_FACTOR_DENOMINATOR] = _uintConfigs[13];\r\n        uintConfigs[CONFIG_DRAFT_QUOTA_NUMERATOR] = _uintConfigs[14];\r\n        uintConfigs[CONFIG_DRAFT_QUOTA_DENOMINATOR] = _uintConfigs[15];\r\n        uintConfigs[CONFIG_VOTING_QUOTA_NUMERATOR] = _uintConfigs[16];\r\n        uintConfigs[CONFIG_VOTING_QUOTA_DENOMINATOR] = _uintConfigs[17];\r\n        uintConfigs[CONFIG_QUARTER_POINT_DRAFT_VOTE] = _uintConfigs[18];\r\n        uintConfigs[CONFIG_QUARTER_POINT_VOTE] = _uintConfigs[19];\r\n        uintConfigs[CONFIG_QUARTER_POINT_INTERIM_VOTE] = _uintConfigs[20];\r\n        uintConfigs[CONFIG_MINIMAL_QUARTER_POINT] = _uintConfigs[21];\r\n        uintConfigs[CONFIG_QUARTER_POINT_MILESTONE_COMPLETION_PER_10000ETH] = _uintConfigs[22];\r\n        uintConfigs[CONFIG_BONUS_REPUTATION_NUMERATOR] = _uintConfigs[23];\r\n        uintConfigs[CONFIG_BONUS_REPUTATION_DENOMINATOR] = _uintConfigs[24];\r\n        uintConfigs[CONFIG_SPECIAL_PROPOSAL_COMMIT_PHASE] = _uintConfigs[25];\r\n        uintConfigs[CONFIG_SPECIAL_PROPOSAL_PHASE_TOTAL] = _uintConfigs[26];\r\n        uintConfigs[CONFIG_SPECIAL_QUOTA_NUMERATOR] = _uintConfigs[27];\r\n        uintConfigs[CONFIG_SPECIAL_QUOTA_DENOMINATOR] = _uintConfigs[28];\r\n        uintConfigs[CONFIG_SPECIAL_PROPOSAL_QUORUM_NUMERATOR] = _uintConfigs[29];\r\n        uintConfigs[CONFIG_SPECIAL_PROPOSAL_QUORUM_DENOMINATOR] = _uintConfigs[30];\r\n        uintConfigs[CONFIG_MAXIMUM_REPUTATION_DEDUCTION] = _uintConfigs[31];\r\n        uintConfigs[CONFIG_PUNISHMENT_FOR_NOT_LOCKING] = _uintConfigs[32];\r\n        uintConfigs[CONFIG_REPUTATION_PER_EXTRA_QP_NUM] = _uintConfigs[33];\r\n        uintConfigs[CONFIG_REPUTATION_PER_EXTRA_QP_DEN] = _uintConfigs[34];\r\n        uintConfigs[CONFIG_QUARTER_POINT_SCALING_FACTOR] = _uintConfigs[35];\r\n        uintConfigs[CONFIG_REPUTATION_POINT_SCALING_FACTOR] = _uintConfigs[36];\r\n        uintConfigs[CONFIG_MODERATOR_MINIMAL_QUARTER_POINT] = _uintConfigs[37];\r\n        uintConfigs[CONFIG_MODERATOR_QUARTER_POINT_SCALING_FACTOR] = _uintConfigs[38];\r\n        uintConfigs[CONFIG_MODERATOR_REPUTATION_POINT_SCALING_FACTOR] = _uintConfigs[39];\r\n        uintConfigs[CONFIG_PORTION_TO_MODERATORS_NUM] = _uintConfigs[40];\r\n        uintConfigs[CONFIG_PORTION_TO_MODERATORS_DEN] = _uintConfigs[41];\r\n        uintConfigs[CONFIG_DRAFT_VOTING_PHASE] = _uintConfigs[42];\r\n        uintConfigs[CONFIG_REPUTATION_POINT_BOOST_FOR_BADGE] = _uintConfigs[43];\r\n        uintConfigs[CONFIG_FINAL_REWARD_SCALING_FACTOR_NUMERATOR] = _uintConfigs[44];\r\n        uintConfigs[CONFIG_FINAL_REWARD_SCALING_FACTOR_DENOMINATOR] = _uintConfigs[45];\r\n        uintConfigs[CONFIG_MAXIMUM_MODERATOR_REPUTATION_DEDUCTION] = _uintConfigs[46];\r\n        uintConfigs[CONFIG_REPUTATION_PER_EXTRA_MODERATOR_QP_NUM] = _uintConfigs[47];\r\n        uintConfigs[CONFIG_REPUTATION_PER_EXTRA_MODERATOR_QP_DEN] = _uintConfigs[48];\r\n        uintConfigs[CONFIG_VOTE_CLAIMING_DEADLINE] = _uintConfigs[49];\r\n        uintConfigs[CONFIG_MINIMUM_LOCKED_DGD] = _uintConfigs[50];\r\n        uintConfigs[CONFIG_MINIMUM_DGD_FOR_MODERATOR] = _uintConfigs[51];\r\n        uintConfigs[CONFIG_MINIMUM_REPUTATION_FOR_MODERATOR] = _uintConfigs[52];\r\n        uintConfigs[CONFIG_PREPROPOSAL_COLLATERAL] = _uintConfigs[53];\r\n        uintConfigs[CONFIG_MAX_FUNDING_FOR_NON_DIGIX] = _uintConfigs[54];\r\n        uintConfigs[CONFIG_MAX_MILESTONES_FOR_NON_DIGIX] = _uintConfigs[55];\r\n        uintConfigs[CONFIG_NON_DIGIX_PROPOSAL_CAP_PER_QUARTER] = _uintConfigs[56];\r\n        uintConfigs[CONFIG_PROPOSAL_DEAD_DURATION] = _uintConfigs[57];\r\n        uintConfigs[CONFIG_CARBON_VOTE_REPUTATION_BONUS] = _uintConfigs[58];\r\n    }\r\n\r\n    function readUintConfigs()\r\n        public\r\n        view\r\n        returns (uint256[])\r\n    {\r\n        uint256[] memory _uintConfigs = new uint256[](59);\r\n        _uintConfigs[0] = uintConfigs[CONFIG_LOCKING_PHASE_DURATION];\r\n        _uintConfigs[1] = uintConfigs[CONFIG_QUARTER_DURATION];\r\n        _uintConfigs[2] = uintConfigs[CONFIG_VOTING_COMMIT_PHASE];\r\n        _uintConfigs[3] = uintConfigs[CONFIG_VOTING_PHASE_TOTAL];\r\n        _uintConfigs[4] = uintConfigs[CONFIG_INTERIM_COMMIT_PHASE];\r\n        _uintConfigs[5] = uintConfigs[CONFIG_INTERIM_PHASE_TOTAL];\r\n        _uintConfigs[6] = uintConfigs[CONFIG_DRAFT_QUORUM_FIXED_PORTION_NUMERATOR];\r\n        _uintConfigs[7] = uintConfigs[CONFIG_DRAFT_QUORUM_FIXED_PORTION_DENOMINATOR];\r\n        _uintConfigs[8] = uintConfigs[CONFIG_DRAFT_QUORUM_SCALING_FACTOR_NUMERATOR];\r\n        _uintConfigs[9] = uintConfigs[CONFIG_DRAFT_QUORUM_SCALING_FACTOR_DENOMINATOR];\r\n        _uintConfigs[10] = uintConfigs[CONFIG_VOTING_QUORUM_FIXED_PORTION_NUMERATOR];\r\n        _uintConfigs[11] = uintConfigs[CONFIG_VOTING_QUORUM_FIXED_PORTION_DENOMINATOR];\r\n        _uintConfigs[12] = uintConfigs[CONFIG_VOTING_QUORUM_SCALING_FACTOR_NUMERATOR];\r\n        _uintConfigs[13] = uintConfigs[CONFIG_VOTING_QUORUM_SCALING_FACTOR_DENOMINATOR];\r\n        _uintConfigs[14] = uintConfigs[CONFIG_DRAFT_QUOTA_NUMERATOR];\r\n        _uintConfigs[15] = uintConfigs[CONFIG_DRAFT_QUOTA_DENOMINATOR];\r\n        _uintConfigs[16] = uintConfigs[CONFIG_VOTING_QUOTA_NUMERATOR];\r\n        _uintConfigs[17] = uintConfigs[CONFIG_VOTING_QUOTA_DENOMINATOR];\r\n        _uintConfigs[18] = uintConfigs[CONFIG_QUARTER_POINT_DRAFT_VOTE];\r\n        _uintConfigs[19] = uintConfigs[CONFIG_QUARTER_POINT_VOTE];\r\n        _uintConfigs[20] = uintConfigs[CONFIG_QUARTER_POINT_INTERIM_VOTE];\r\n        _uintConfigs[21] = uintConfigs[CONFIG_MINIMAL_QUARTER_POINT];\r\n        _uintConfigs[22] = uintConfigs[CONFIG_QUARTER_POINT_MILESTONE_COMPLETION_PER_10000ETH];\r\n        _uintConfigs[23] = uintConfigs[CONFIG_BONUS_REPUTATION_NUMERATOR];\r\n        _uintConfigs[24] = uintConfigs[CONFIG_BONUS_REPUTATION_DENOMINATOR];\r\n        _uintConfigs[25] = uintConfigs[CONFIG_SPECIAL_PROPOSAL_COMMIT_PHASE];\r\n        _uintConfigs[26] = uintConfigs[CONFIG_SPECIAL_PROPOSAL_PHASE_TOTAL];\r\n        _uintConfigs[27] = uintConfigs[CONFIG_SPECIAL_QUOTA_NUMERATOR];\r\n        _uintConfigs[28] = uintConfigs[CONFIG_SPECIAL_QUOTA_DENOMINATOR];\r\n        _uintConfigs[29] = uintConfigs[CONFIG_SPECIAL_PROPOSAL_QUORUM_NUMERATOR];\r\n        _uintConfigs[30] = uintConfigs[CONFIG_SPECIAL_PROPOSAL_QUORUM_DENOMINATOR];\r\n        _uintConfigs[31] = uintConfigs[CONFIG_MAXIMUM_REPUTATION_DEDUCTION];\r\n        _uintConfigs[32] = uintConfigs[CONFIG_PUNISHMENT_FOR_NOT_LOCKING];\r\n        _uintConfigs[33] = uintConfigs[CONFIG_REPUTATION_PER_EXTRA_QP_NUM];\r\n        _uintConfigs[34] = uintConfigs[CONFIG_REPUTATION_PER_EXTRA_QP_DEN];\r\n        _uintConfigs[35] = uintConfigs[CONFIG_QUARTER_POINT_SCALING_FACTOR];\r\n        _uintConfigs[36] = uintConfigs[CONFIG_REPUTATION_POINT_SCALING_FACTOR];\r\n        _uintConfigs[37] = uintConfigs[CONFIG_MODERATOR_MINIMAL_QUARTER_POINT];\r\n        _uintConfigs[38] = uintConfigs[CONFIG_MODERATOR_QUARTER_POINT_SCALING_FACTOR];\r\n        _uintConfigs[39] = uintConfigs[CONFIG_MODERATOR_REPUTATION_POINT_SCALING_FACTOR];\r\n        _uintConfigs[40] = uintConfigs[CONFIG_PORTION_TO_MODERATORS_NUM];\r\n        _uintConfigs[41] = uintConfigs[CONFIG_PORTION_TO_MODERATORS_DEN];\r\n        _uintConfigs[42] = uintConfigs[CONFIG_DRAFT_VOTING_PHASE];\r\n        _uintConfigs[43] = uintConfigs[CONFIG_REPUTATION_POINT_BOOST_FOR_BADGE];\r\n        _uintConfigs[44] = uintConfigs[CONFIG_FINAL_REWARD_SCALING_FACTOR_NUMERATOR];\r\n        _uintConfigs[45] = uintConfigs[CONFIG_FINAL_REWARD_SCALING_FACTOR_DENOMINATOR];\r\n        _uintConfigs[46] = uintConfigs[CONFIG_MAXIMUM_MODERATOR_REPUTATION_DEDUCTION];\r\n        _uintConfigs[47] = uintConfigs[CONFIG_REPUTATION_PER_EXTRA_MODERATOR_QP_NUM];\r\n        _uintConfigs[48] = uintConfigs[CONFIG_REPUTATION_PER_EXTRA_MODERATOR_QP_DEN];\r\n        _uintConfigs[49] = uintConfigs[CONFIG_VOTE_CLAIMING_DEADLINE];\r\n        _uintConfigs[50] = uintConfigs[CONFIG_MINIMUM_LOCKED_DGD];\r\n        _uintConfigs[51] = uintConfigs[CONFIG_MINIMUM_DGD_FOR_MODERATOR];\r\n        _uintConfigs[52] = uintConfigs[CONFIG_MINIMUM_REPUTATION_FOR_MODERATOR];\r\n        _uintConfigs[53] = uintConfigs[CONFIG_PREPROPOSAL_COLLATERAL];\r\n        _uintConfigs[54] = uintConfigs[CONFIG_MAX_FUNDING_FOR_NON_DIGIX];\r\n        _uintConfigs[55] = uintConfigs[CONFIG_MAX_MILESTONES_FOR_NON_DIGIX];\r\n        _uintConfigs[56] = uintConfigs[CONFIG_NON_DIGIX_PROPOSAL_CAP_PER_QUARTER];\r\n        _uintConfigs[57] = uintConfigs[CONFIG_PROPOSAL_DEAD_DURATION];\r\n        _uintConfigs[58] = uintConfigs[CONFIG_CARBON_VOTE_REPUTATION_BONUS];\r\n        return _uintConfigs;\r\n    }\r\n}\r\n\r\n// File: contracts/storage/DaoProposalCounterStorage.sol\r\ncontract DaoProposalCounterStorage is ResolverClient, DaoConstants {\r\n\r\n    constructor(address _resolver) public {\r\n        require(init(CONTRACT_STORAGE_DAO_COUNTER, _resolver));\r\n    }\r\n\r\n    // This is to mark the number of proposals that have been funded in a specific quarter\r\n    // this is to take care of the cap on the number of funded proposals in a quarter\r\n    mapping (uint256 => uint256) public proposalCountByQuarter;\r\n\r\n    function addNonDigixProposalCountInQuarter(uint256 _quarterNumber)\r\n        public\r\n    {\r\n        require(sender_is(CONTRACT_DAO_VOTING_CLAIMS));\r\n        proposalCountByQuarter[_quarterNumber] = proposalCountByQuarter[_quarterNumber].add(1);\r\n    }\r\n}\r\n\r\n// File: contracts/storage/DaoUpgradeStorage.sol\r\ncontract DaoUpgradeStorage is ResolverClient, DaoConstants {\r\n\r\n    // this UTC timestamp marks the start of the first quarter\r\n    // of DigixDAO. All time related calculations in DaoCommon\r\n    // depend on this value\r\n    uint256 public startOfFirstQuarter;\r\n\r\n    // this boolean marks whether the DAO contracts have been replaced\r\n    // by newer versions or not. The process of migration is done by deploying\r\n    // a new set of contracts, transferring funds from these contracts to the new ones\r\n    // migrating some state variables, and finally setting this boolean to true\r\n    // All operations in these contracts that may transfer tokens, claim ether,\r\n    // boost one's reputation, etc. SHOULD fail if this is true\r\n    bool public isReplacedByNewDao;\r\n\r\n    // this is the address of the new Dao contract\r\n    address public newDaoContract;\r\n\r\n    // this is the address of the new DaoFundingManager contract\r\n    // ether funds will be moved from the current version's contract to this\r\n    // new contract\r\n    address public newDaoFundingManager;\r\n\r\n    // this is the address of the new DaoRewardsManager contract\r\n    // DGX funds will be moved from the current version of contract to this\r\n    // new contract\r\n    address public newDaoRewardsManager;\r\n\r\n    constructor(address _resolver) public {\r\n        require(init(CONTRACT_STORAGE_DAO_UPGRADE, _resolver));\r\n    }\r\n\r\n    function setStartOfFirstQuarter(uint256 _start)\r\n        public\r\n    {\r\n        require(sender_is(CONTRACT_DAO));\r\n        startOfFirstQuarter = _start;\r\n    }\r\n\r\n\r\n    function setNewContractAddresses(\r\n        address _newDaoContract,\r\n        address _newDaoFundingManager,\r\n        address _newDaoRewardsManager\r\n    )\r\n        public\r\n    {\r\n        require(sender_is(CONTRACT_DAO));\r\n        newDaoContract = _newDaoContract;\r\n        newDaoFundingManager = _newDaoFundingManager;\r\n        newDaoRewardsManager = _newDaoRewardsManager;\r\n    }\r\n\r\n\r\n    function updateForDaoMigration()\r\n        public\r\n    {\r\n        require(sender_is(CONTRACT_DAO));\r\n        isReplacedByNewDao = true;\r\n    }\r\n}\r\n\r\n// File: contracts/storage/DaoSpecialStorage.sol\r\ncontract DaoSpecialStorage is DaoWhitelistingCommon {\r\n    using DoublyLinkedList for DoublyLinkedList.Bytes;\r\n    using DaoStructs for DaoStructs.SpecialProposal;\r\n    using DaoStructs for DaoStructs.Voting;\r\n\r\n    // List of all the special proposals ever created in DigixDAO\r\n    DoublyLinkedList.Bytes proposals;\r\n\r\n    // mapping of the SpecialProposal struct by its ID\r\n    // ID is also the IPFS doc hash of the proposal\r\n    mapping (bytes32 => DaoStructs.SpecialProposal) proposalsById;\r\n\r\n    constructor(address _resolver) public {\r\n        require(init(CONTRACT_STORAGE_DAO_SPECIAL, _resolver));\r\n    }\r\n\r\n    function addSpecialProposal(\r\n        bytes32 _proposalId,\r\n        address _proposer,\r\n        uint256[] _uintConfigs,\r\n        address[] _addressConfigs,\r\n        bytes32[] _bytesConfigs\r\n    )\r\n        public\r\n    {\r\n        require(sender_is(CONTRACT_DAO_SPECIAL_PROPOSAL));\r\n        require(\r\n          (proposalsById[_proposalId].proposalId == EMPTY_BYTES) &&\r\n          (_proposalId != EMPTY_BYTES)\r\n        );\r\n        proposals.append(_proposalId);\r\n        proposalsById[_proposalId].proposalId = _proposalId;\r\n        proposalsById[_proposalId].proposer = _proposer;\r\n        proposalsById[_proposalId].timeCreated = now;\r\n        proposalsById[_proposalId].uintConfigs = _uintConfigs;\r\n        proposalsById[_proposalId].addressConfigs = _addressConfigs;\r\n        proposalsById[_proposalId].bytesConfigs = _bytesConfigs;\r\n    }\r\n\r\n    function readProposal(bytes32 _proposalId)\r\n        public\r\n        view\r\n        returns (\r\n            bytes32 _id,\r\n            address _proposer,\r\n            uint256 _timeCreated,\r\n            uint256 _timeVotingStarted\r\n        )\r\n    {\r\n        _id = proposalsById[_proposalId].proposalId;\r\n        _proposer = proposalsById[_proposalId].proposer;\r\n        _timeCreated = proposalsById[_proposalId].timeCreated;\r\n        _timeVotingStarted = proposalsById[_proposalId].voting.startTime;\r\n    }\r\n\r\n    function readProposalProposer(bytes32 _proposalId)\r\n        public\r\n        view\r\n        returns (address _proposer)\r\n    {\r\n        _proposer = proposalsById[_proposalId].proposer;\r\n    }\r\n\r\n    function readConfigs(bytes32 _proposalId)\r\n        public\r\n        view\r\n        returns (\r\n            uint256[] memory _uintConfigs,\r\n            address[] memory _addressConfigs,\r\n            bytes32[] memory _bytesConfigs\r\n        )\r\n    {\r\n        _uintConfigs = proposalsById[_proposalId].uintConfigs;\r\n        _addressConfigs = proposalsById[_proposalId].addressConfigs;\r\n        _bytesConfigs = proposalsById[_proposalId].bytesConfigs;\r\n    }\r\n\r\n    function readVotingCount(bytes32 _proposalId, address[] _allUsers)\r\n        external\r\n        view\r\n        returns (uint256 _for, uint256 _against)\r\n    {\r\n        require(senderIsAllowedToRead());\r\n        return proposalsById[_proposalId].voting.countVotes(_allUsers);\r\n    }\r\n\r\n    function readVotingTime(bytes32 _proposalId)\r\n        public\r\n        view\r\n        returns (uint256 _start)\r\n    {\r\n        require(senderIsAllowedToRead());\r\n        _start = proposalsById[_proposalId].voting.startTime;\r\n    }\r\n\r\n    function commitVote(\r\n        bytes32 _proposalId,\r\n        bytes32 _hash,\r\n        address _voter\r\n    )\r\n        public\r\n    {\r\n        require(sender_is(CONTRACT_DAO_VOTING));\r\n        proposalsById[_proposalId].voting.commits[_voter] = _hash;\r\n    }\r\n\r\n    function readComittedVote(bytes32 _proposalId, address _voter)\r\n        public\r\n        view\r\n        returns (bytes32 _commitHash)\r\n    {\r\n        require(senderIsAllowedToRead());\r\n        _commitHash = proposalsById[_proposalId].voting.commits[_voter];\r\n    }\r\n\r\n    function setVotingTime(bytes32 _proposalId, uint256 _time)\r\n        public\r\n    {\r\n        require(sender_is(CONTRACT_DAO_SPECIAL_PROPOSAL));\r\n        proposalsById[_proposalId].voting.startTime = _time;\r\n    }\r\n\r\n    function readVotingResult(bytes32 _proposalId)\r\n        public\r\n        view\r\n        returns (bool _result)\r\n    {\r\n        require(senderIsAllowedToRead());\r\n        _result = proposalsById[_proposalId].voting.passed;\r\n    }\r\n\r\n    function setPass(bytes32 _proposalId, bool _result)\r\n        public\r\n    {\r\n        require(sender_is(CONTRACT_DAO_SPECIAL_VOTING_CLAIMS));\r\n        proposalsById[_proposalId].voting.passed = _result;\r\n    }\r\n\r\n    function setVotingClaim(bytes32 _proposalId, bool _claimed)\r\n        public\r\n    {\r\n        require(sender_is(CONTRACT_DAO_SPECIAL_VOTING_CLAIMS));\r\n        DaoStructs.SpecialProposal storage _proposal = proposalsById[_proposalId];\r\n        _proposal.voting.claimed = _claimed;\r\n    }\r\n\r\n    function isClaimed(bytes32 _proposalId)\r\n        public\r\n        view\r\n        returns (bool _claimed)\r\n    {\r\n        require(senderIsAllowedToRead());\r\n        _claimed = proposalsById[_proposalId].voting.claimed;\r\n    }\r\n\r\n    function readVote(bytes32 _proposalId, address _voter)\r\n        public\r\n        view\r\n        returns (bool _vote, uint256 _weight)\r\n    {\r\n        require(senderIsAllowedToRead());\r\n        return proposalsById[_proposalId].voting.readVote(_voter);\r\n    }\r\n\r\n    function revealVote(\r\n        bytes32 _proposalId,\r\n        address _voter,\r\n        bool _vote,\r\n        uint256 _weight\r\n    )\r\n        public\r\n    {\r\n        require(sender_is(CONTRACT_DAO_VOTING));\r\n        proposalsById[_proposalId].voting.revealVote(_voter, _vote, _weight);\r\n    }\r\n}\r\n\r\n// File: contracts/storage/DaoPointsStorage.sol\r\ncontract DaoPointsStorage is ResolverClient, DaoConstants {\r\n\r\n    // struct for a non-transferrable token\r\n    struct Token {\r\n        uint256 totalSupply;\r\n        mapping (address => uint256) balance;\r\n    }\r\n\r\n    // the reputation point token\r\n    // since reputation is cumulative, we only need to store one value\r\n    Token reputationPoint;\r\n\r\n    // since quarter points are specific to quarters, we need a mapping from\r\n    // quarter number to the quarter point token for that quarter\r\n    mapping (uint256 => Token) quarterPoint;\r\n\r\n    // the same is the case with quarter moderator points\r\n    // these are specific to quarters\r\n    mapping (uint256 => Token) quarterModeratorPoint;\r\n\r\n    constructor(address _resolver)\r\n        public\r\n    {\r\n        require(init(CONTRACT_STORAGE_DAO_POINTS, _resolver));\r\n    }\r\n\r\n    /// @notice add quarter points for a _participant for a _quarterNumber\r\n    function addQuarterPoint(address _participant, uint256 _point, uint256 _quarterNumber)\r\n        public\r\n        returns (uint256 _newPoint, uint256 _newTotalPoint)\r\n    {\r\n        require(sender_is_from([CONTRACT_DAO_VOTING, CONTRACT_DAO_VOTING_CLAIMS, EMPTY_BYTES]));\r\n        quarterPoint[_quarterNumber].totalSupply = quarterPoint[_quarterNumber].totalSupply.add(_point);\r\n        quarterPoint[_quarterNumber].balance[_participant] = quarterPoint[_quarterNumber].balance[_participant].add(_point);\r\n\r\n        _newPoint = quarterPoint[_quarterNumber].balance[_participant];\r\n        _newTotalPoint = quarterPoint[_quarterNumber].totalSupply;\r\n    }\r\n\r\n    function addModeratorQuarterPoint(address _participant, uint256 _point, uint256 _quarterNumber)\r\n        public\r\n        returns (uint256 _newPoint, uint256 _newTotalPoint)\r\n    {\r\n        require(sender_is_from([CONTRACT_DAO_VOTING, CONTRACT_DAO_VOTING_CLAIMS, EMPTY_BYTES]));\r\n        quarterModeratorPoint[_quarterNumber].totalSupply = quarterModeratorPoint[_quarterNumber].totalSupply.add(_point);\r\n        quarterModeratorPoint[_quarterNumber].balance[_participant] = quarterModeratorPoint[_quarterNumber].balance[_participant].add(_point);\r\n\r\n        _newPoint = quarterModeratorPoint[_quarterNumber].balance[_participant];\r\n        _newTotalPoint = quarterModeratorPoint[_quarterNumber].totalSupply;\r\n    }\r\n\r\n    /// @notice get quarter points for a _participant in a _quarterNumber\r\n    function getQuarterPoint(address _participant, uint256 _quarterNumber)\r\n        public\r\n        view\r\n        returns (uint256 _point)\r\n    {\r\n        _point = quarterPoint[_quarterNumber].balance[_participant];\r\n    }\r\n\r\n    function getQuarterModeratorPoint(address _participant, uint256 _quarterNumber)\r\n        public\r\n        view\r\n        returns (uint256 _point)\r\n    {\r\n        _point = quarterModeratorPoint[_quarterNumber].balance[_participant];\r\n    }\r\n\r\n    /// @notice get total quarter points for a particular _quarterNumber\r\n    function getTotalQuarterPoint(uint256 _quarterNumber)\r\n        public\r\n        view\r\n        returns (uint256 _totalPoint)\r\n    {\r\n        _totalPoint = quarterPoint[_quarterNumber].totalSupply;\r\n    }\r\n\r\n    function getTotalQuarterModeratorPoint(uint256 _quarterNumber)\r\n        public\r\n        view\r\n        returns (uint256 _totalPoint)\r\n    {\r\n        _totalPoint = quarterModeratorPoint[_quarterNumber].totalSupply;\r\n    }\r\n\r\n    /// @notice add reputation points for a _participant\r\n    function increaseReputation(address _participant, uint256 _point)\r\n        public\r\n        returns (uint256 _newPoint, uint256 _totalPoint)\r\n    {\r\n        require(sender_is_from([CONTRACT_DAO_VOTING_CLAIMS, CONTRACT_DAO_REWARDS_MANAGER, CONTRACT_DAO_STAKE_LOCKING]));\r\n        reputationPoint.totalSupply = reputationPoint.totalSupply.add(_point);\r\n        reputationPoint.balance[_participant] = reputationPoint.balance[_participant].add(_point);\r\n\r\n        _newPoint = reputationPoint.balance[_participant];\r\n        _totalPoint = reputationPoint.totalSupply;\r\n    }\r\n\r\n    /// @notice subtract reputation points for a _participant\r\n    function reduceReputation(address _participant, uint256 _point)\r\n        public\r\n        returns (uint256 _newPoint, uint256 _totalPoint)\r\n    {\r\n        require(sender_is_from([CONTRACT_DAO_VOTING_CLAIMS, CONTRACT_DAO_REWARDS_MANAGER, EMPTY_BYTES]));\r\n        uint256 _toDeduct = _point;\r\n        if (reputationPoint.balance[_participant] > _point) {\r\n            reputationPoint.balance[_participant] = reputationPoint.balance[_participant].sub(_point);\r\n        } else {\r\n            _toDeduct = reputationPoint.balance[_participant];\r\n            reputationPoint.balance[_participant] = 0;\r\n        }\r\n\r\n        reputationPoint.totalSupply = reputationPoint.totalSupply.sub(_toDeduct);\r\n\r\n        _newPoint = reputationPoint.balance[_participant];\r\n        _totalPoint = reputationPoint.totalSupply;\r\n    }\r\n\r\n  /// @notice get reputation points for a _participant\r\n  function getReputation(address _participant)\r\n      public\r\n      view\r\n      returns (uint256 _point)\r\n  {\r\n      _point = reputationPoint.balance[_participant];\r\n  }\r\n\r\n  /// @notice get total reputation points distributed in the dao\r\n  function getTotalReputation()\r\n      public\r\n      view\r\n      returns (uint256 _totalPoint)\r\n  {\r\n      _totalPoint = reputationPoint.totalSupply;\r\n  }\r\n}\r\n\r\n// File: contracts/storage/DaoRewardsStorage.sol\r\n// this contract will receive DGXs fees from the DGX fees distributors\r\ncontract DaoRewardsStorage is ResolverClient, DaoConstants {\r\n    using DaoStructs for DaoStructs.DaoQuarterInfo;\r\n\r\n    // DaoQuarterInfo is a struct that stores the quarter specific information\r\n    // regarding totalEffectiveDGDs, DGX distribution day, etc. pls check\r\n    // docs in lib/DaoStructs\r\n    mapping(uint256 => DaoStructs.DaoQuarterInfo) public allQuartersInfo;\r\n\r\n    // Mapping that stores the DGX that can be claimed as rewards by\r\n    // an address (a participant of DigixDAO)\r\n    mapping(address => uint256) public claimableDGXs;\r\n\r\n    // This stores the total DGX value that has been claimed by participants\r\n    // this can be done by calling the DaoRewardsManager.claimRewards method\r\n    // Note that this value is the only outgoing DGX from DaoRewardsManager contract\r\n    // Note that this value also takes into account the demurrage that has been paid\r\n    // by participants for simply holding their DGXs in the DaoRewardsManager contract\r\n    uint256 public totalDGXsClaimed;\r\n\r\n    // The Quarter ID in which the user last participated in\r\n    // To participate means they had locked more than CONFIG_MINIMUM_LOCKED_DGD\r\n    // DGD tokens. In addition, they should not have withdrawn those tokens in the same\r\n    // quarter. Basically, in the main phase of the quarter, if DaoCommon.isParticipant(_user)\r\n    // was true, they were participants. And that quarter was their lastParticipatedQuarter\r\n    mapping (address => uint256) public lastParticipatedQuarter;\r\n\r\n    // This mapping is only used to update the lastParticipatedQuarter to the\r\n    // previousLastParticipatedQuarter in case users lock and withdraw DGDs\r\n    // within the same quarter's locking phase\r\n    mapping (address => uint256) public previousLastParticipatedQuarter;\r\n\r\n    // This number marks the Quarter in which the rewards were last updated for that user\r\n    // Since the rewards calculation for a specific quarter is only done once that\r\n    // quarter is completed, we need this value to note the last quarter when the rewards were updated\r\n    // We then start adding the rewards for all quarters after that quarter, until the current quarter\r\n    mapping (address => uint256) public lastQuarterThatRewardsWasUpdated;\r\n\r\n    // Similar as the lastQuarterThatRewardsWasUpdated, but this is for reputation updates\r\n    // Note that reputation can also be deducted for no participation (not locking DGDs)\r\n    // This value is used to update the reputation based on all quarters from the lastQuarterThatReputationWasUpdated\r\n    // to the current quarter\r\n    mapping (address => uint256) public lastQuarterThatReputationWasUpdated;\r\n\r\n    constructor(address _resolver)\r\n           public\r\n    {\r\n        require(init(CONTRACT_STORAGE_DAO_REWARDS, _resolver));\r\n    }\r\n\r\n    function updateQuarterInfo(\r\n        uint256 _quarterNumber,\r\n        uint256 _minimalParticipationPoint,\r\n        uint256 _quarterPointScalingFactor,\r\n        uint256 _reputationPointScalingFactor,\r\n        uint256 _totalEffectiveDGDPreviousQuarter,\r\n\r\n        uint256 _moderatorMinimalQuarterPoint,\r\n        uint256 _moderatorQuarterPointScalingFactor,\r\n        uint256 _moderatorReputationPointScalingFactor,\r\n        uint256 _totalEffectiveModeratorDGDLastQuarter,\r\n\r\n        uint256 _dgxDistributionDay,\r\n        uint256 _dgxRewardsPoolLastQuarter,\r\n        uint256 _sumRewardsFromBeginning\r\n    )\r\n        public\r\n    {\r\n        require(sender_is(CONTRACT_DAO_REWARDS_MANAGER));\r\n        allQuartersInfo[_quarterNumber].minimalParticipationPoint = _minimalParticipationPoint;\r\n        allQuartersInfo[_quarterNumber].quarterPointScalingFactor = _quarterPointScalingFactor;\r\n        allQuartersInfo[_quarterNumber].reputationPointScalingFactor = _reputationPointScalingFactor;\r\n        allQuartersInfo[_quarterNumber].totalEffectiveDGDPreviousQuarter = _totalEffectiveDGDPreviousQuarter;\r\n\r\n        allQuartersInfo[_quarterNumber].moderatorMinimalParticipationPoint = _moderatorMinimalQuarterPoint;\r\n        allQuartersInfo[_quarterNumber].moderatorQuarterPointScalingFactor = _moderatorQuarterPointScalingFactor;\r\n        allQuartersInfo[_quarterNumber].moderatorReputationPointScalingFactor = _moderatorReputationPointScalingFactor;\r\n        allQuartersInfo[_quarterNumber].totalEffectiveModeratorDGDLastQuarter = _totalEffectiveModeratorDGDLastQuarter;\r\n\r\n        allQuartersInfo[_quarterNumber].dgxDistributionDay = _dgxDistributionDay;\r\n        allQuartersInfo[_quarterNumber].dgxRewardsPoolLastQuarter = _dgxRewardsPoolLastQuarter;\r\n        allQuartersInfo[_quarterNumber].sumRewardsFromBeginning = _sumRewardsFromBeginning;\r\n    }\r\n\r\n    function updateClaimableDGX(address _user, uint256 _newClaimableDGX)\r\n        public\r\n    {\r\n        require(sender_is(CONTRACT_DAO_REWARDS_MANAGER));\r\n        claimableDGXs[_user] = _newClaimableDGX;\r\n    }\r\n\r\n    function updateLastParticipatedQuarter(address _user, uint256 _lastQuarter)\r\n        public\r\n    {\r\n        require(sender_is(CONTRACT_DAO_STAKE_LOCKING));\r\n        lastParticipatedQuarter[_user] = _lastQuarter;\r\n    }\r\n\r\n    function updatePreviousLastParticipatedQuarter(address _user, uint256 _lastQuarter)\r\n        public\r\n    {\r\n        require(sender_is(CONTRACT_DAO_STAKE_LOCKING));\r\n        previousLastParticipatedQuarter[_user] = _lastQuarter;\r\n    }\r\n\r\n    function updateLastQuarterThatRewardsWasUpdated(address _user, uint256 _lastQuarter)\r\n        public\r\n    {\r\n        require(sender_is_from([CONTRACT_DAO_REWARDS_MANAGER, CONTRACT_DAO_STAKE_LOCKING, EMPTY_BYTES]));\r\n        lastQuarterThatRewardsWasUpdated[_user] = _lastQuarter;\r\n    }\r\n\r\n    function updateLastQuarterThatReputationWasUpdated(address _user, uint256 _lastQuarter)\r\n        public\r\n    {\r\n        require(sender_is_from([CONTRACT_DAO_REWARDS_MANAGER, CONTRACT_DAO_STAKE_LOCKING, EMPTY_BYTES]));\r\n        lastQuarterThatReputationWasUpdated[_user] = _lastQuarter;\r\n    }\r\n\r\n    function addToTotalDgxClaimed(uint256 _dgxClaimed)\r\n        public\r\n    {\r\n        require(sender_is(CONTRACT_DAO_REWARDS_MANAGER));\r\n        totalDGXsClaimed = totalDGXsClaimed.add(_dgxClaimed);\r\n    }\r\n\r\n    function readQuarterInfo(uint256 _quarterNumber)\r\n        public\r\n        view\r\n        returns (\r\n            uint256 _minimalParticipationPoint,\r\n            uint256 _quarterPointScalingFactor,\r\n            uint256 _reputationPointScalingFactor,\r\n            uint256 _totalEffectiveDGDPreviousQuarter,\r\n\r\n            uint256 _moderatorMinimalQuarterPoint,\r\n            uint256 _moderatorQuarterPointScalingFactor,\r\n            uint256 _moderatorReputationPointScalingFactor,\r\n            uint256 _totalEffectiveModeratorDGDLastQuarter,\r\n\r\n            uint256 _dgxDistributionDay,\r\n            uint256 _dgxRewardsPoolLastQuarter,\r\n            uint256 _sumRewardsFromBeginning\r\n        )\r\n    {\r\n        _minimalParticipationPoint = allQuartersInfo[_quarterNumber].minimalParticipationPoint;\r\n        _quarterPointScalingFactor = allQuartersInfo[_quarterNumber].quarterPointScalingFactor;\r\n        _reputationPointScalingFactor = allQuartersInfo[_quarterNumber].reputationPointScalingFactor;\r\n        _totalEffectiveDGDPreviousQuarter = allQuartersInfo[_quarterNumber].totalEffectiveDGDPreviousQuarter;\r\n        _moderatorMinimalQuarterPoint = allQuartersInfo[_quarterNumber].moderatorMinimalParticipationPoint;\r\n        _moderatorQuarterPointScalingFactor = allQuartersInfo[_quarterNumber].moderatorQuarterPointScalingFactor;\r\n        _moderatorReputationPointScalingFactor = allQuartersInfo[_quarterNumber].moderatorReputationPointScalingFactor;\r\n        _totalEffectiveModeratorDGDLastQuarter = allQuartersInfo[_quarterNumber].totalEffectiveModeratorDGDLastQuarter;\r\n        _dgxDistributionDay = allQuartersInfo[_quarterNumber].dgxDistributionDay;\r\n        _dgxRewardsPoolLastQuarter = allQuartersInfo[_quarterNumber].dgxRewardsPoolLastQuarter;\r\n        _sumRewardsFromBeginning = allQuartersInfo[_quarterNumber].sumRewardsFromBeginning;\r\n    }\r\n\r\n    function readQuarterGeneralInfo(uint256 _quarterNumber)\r\n        public\r\n        view\r\n        returns (\r\n            uint256 _dgxDistributionDay,\r\n            uint256 _dgxRewardsPoolLastQuarter,\r\n            uint256 _sumRewardsFromBeginning\r\n        )\r\n    {\r\n        _dgxDistributionDay = allQuartersInfo[_quarterNumber].dgxDistributionDay;\r\n        _dgxRewardsPoolLastQuarter = allQuartersInfo[_quarterNumber].dgxRewardsPoolLastQuarter;\r\n        _sumRewardsFromBeginning = allQuartersInfo[_quarterNumber].sumRewardsFromBeginning;\r\n    }\r\n\r\n    function readQuarterModeratorInfo(uint256 _quarterNumber)\r\n        public\r\n        view\r\n        returns (\r\n            uint256 _moderatorMinimalQuarterPoint,\r\n            uint256 _moderatorQuarterPointScalingFactor,\r\n            uint256 _moderatorReputationPointScalingFactor,\r\n            uint256 _totalEffectiveModeratorDGDLastQuarter\r\n        )\r\n    {\r\n        _moderatorMinimalQuarterPoint = allQuartersInfo[_quarterNumber].moderatorMinimalParticipationPoint;\r\n        _moderatorQuarterPointScalingFactor = allQuartersInfo[_quarterNumber].moderatorQuarterPointScalingFactor;\r\n        _moderatorReputationPointScalingFactor = allQuartersInfo[_quarterNumber].moderatorReputationPointScalingFactor;\r\n        _totalEffectiveModeratorDGDLastQuarter = allQuartersInfo[_quarterNumber].totalEffectiveModeratorDGDLastQuarter;\r\n    }\r\n\r\n    function readQuarterParticipantInfo(uint256 _quarterNumber)\r\n        public\r\n        view\r\n        returns (\r\n            uint256 _minimalParticipationPoint,\r\n            uint256 _quarterPointScalingFactor,\r\n            uint256 _reputationPointScalingFactor,\r\n            uint256 _totalEffectiveDGDPreviousQuarter\r\n        )\r\n    {\r\n        _minimalParticipationPoint = allQuartersInfo[_quarterNumber].minimalParticipationPoint;\r\n        _quarterPointScalingFactor = allQuartersInfo[_quarterNumber].quarterPointScalingFactor;\r\n        _reputationPointScalingFactor = allQuartersInfo[_quarterNumber].reputationPointScalingFactor;\r\n        _totalEffectiveDGDPreviousQuarter = allQuartersInfo[_quarterNumber].totalEffectiveDGDPreviousQuarter;\r\n    }\r\n\r\n    function readDgxDistributionDay(uint256 _quarterNumber)\r\n        public\r\n        view\r\n        returns (uint256 _distributionDay)\r\n    {\r\n        _distributionDay = allQuartersInfo[_quarterNumber].dgxDistributionDay;\r\n    }\r\n\r\n    function readTotalEffectiveDGDLastQuarter(uint256 _quarterNumber)\r\n        public\r\n        view\r\n        returns (uint256 _totalEffectiveDGDPreviousQuarter)\r\n    {\r\n        _totalEffectiveDGDPreviousQuarter = allQuartersInfo[_quarterNumber].totalEffectiveDGDPreviousQuarter;\r\n    }\r\n\r\n    function readTotalEffectiveModeratorDGDLastQuarter(uint256 _quarterNumber)\r\n        public\r\n        view\r\n        returns (uint256 _totalEffectiveModeratorDGDLastQuarter)\r\n    {\r\n        _totalEffectiveModeratorDGDLastQuarter = allQuartersInfo[_quarterNumber].totalEffectiveModeratorDGDLastQuarter;\r\n    }\r\n\r\n    function readRewardsPoolOfLastQuarter(uint256 _quarterNumber)\r\n        public\r\n        view\r\n        returns (uint256 _rewardsPool)\r\n    {\r\n        _rewardsPool = allQuartersInfo[_quarterNumber].dgxRewardsPoolLastQuarter;\r\n    }\r\n}\r\n\r\n// File: contracts/storage/IntermediateResultsStorage.sol\r\ncontract IntermediateResultsStorage is ResolverClient, DaoConstants {\r\n    using DaoStructs for DaoStructs.IntermediateResults;\r\n\r\n    constructor(address _resolver) public {\r\n        require(init(CONTRACT_STORAGE_INTERMEDIATE_RESULTS, _resolver));\r\n    }\r\n\r\n    // There are scenarios in which we must loop across all participants/moderators\r\n    // in a function call. For a big number of operations, the function call may be short of gas\r\n    // To tackle this, we use an IntermediateResults struct to store the intermediate results\r\n    // The same function is then called multiple times until all operations are completed\r\n    // If the operations cannot be done in that iteration, the intermediate results are stored\r\n    // else, the final outcome is returned\r\n    // Please check the lib/DaoStructs for docs on this struct\r\n    mapping (bytes32 => DaoStructs.IntermediateResults) allIntermediateResults;\r\n\r\n    function getIntermediateResults(bytes32 _key)\r\n        public\r\n        view\r\n        returns (\r\n            address _countedUntil,\r\n            uint256 _currentForCount,\r\n            uint256 _currentAgainstCount,\r\n            uint256 _currentSumOfEffectiveBalance\r\n        )\r\n    {\r\n        _countedUntil = allIntermediateResults[_key].countedUntil;\r\n        _currentForCount = allIntermediateResults[_key].currentForCount;\r\n        _currentAgainstCount = allIntermediateResults[_key].currentAgainstCount;\r\n        _currentSumOfEffectiveBalance = allIntermediateResults[_key].currentSumOfEffectiveBalance;\r\n    }\r\n\r\n    function resetIntermediateResults(bytes32 _key)\r\n        public\r\n    {\r\n        require(sender_is_from([CONTRACT_DAO_REWARDS_MANAGER, CONTRACT_DAO_VOTING_CLAIMS, CONTRACT_DAO_SPECIAL_VOTING_CLAIMS]));\r\n        allIntermediateResults[_key].countedUntil = address(0x0);\r\n    }\r\n\r\n    function setIntermediateResults(\r\n        bytes32 _key,\r\n        address _countedUntil,\r\n        uint256 _currentForCount,\r\n        uint256 _currentAgainstCount,\r\n        uint256 _currentSumOfEffectiveBalance\r\n    )\r\n        public\r\n    {\r\n        require(sender_is_from([CONTRACT_DAO_REWARDS_MANAGER, CONTRACT_DAO_VOTING_CLAIMS, CONTRACT_DAO_SPECIAL_VOTING_CLAIMS]));\r\n        allIntermediateResults[_key].countedUntil = _countedUntil;\r\n        allIntermediateResults[_key].currentForCount = _currentForCount;\r\n        allIntermediateResults[_key].currentAgainstCount = _currentAgainstCount;\r\n        allIntermediateResults[_key].currentSumOfEffectiveBalance = _currentSumOfEffectiveBalance;\r\n    }\r\n}\r\n\r\n// File: contracts/lib/MathHelper.sol\r\nlibrary MathHelper {\r\n\r\n  using SafeMath for uint256;\r\n\r\n  function max(uint256 a, uint256 b) internal pure returns (uint256 _max){\r\n      _max = b;\r\n      if (a > b) {\r\n          _max = a;\r\n      }\r\n  }\r\n\r\n  function min(uint256 a, uint256 b) internal pure returns (uint256 _min){\r\n      _min = b;\r\n      if (a < b) {\r\n          _min = a;\r\n      }\r\n  }\r\n\r\n  function sumNumbers(uint256[] _numbers) internal pure returns (uint256 _sum) {\r\n      for (uint256 i=0;i<_numbers.length;i++) {\r\n          _sum = _sum.add(_numbers[i]);\r\n      }\r\n  }\r\n}\r\n\r\n// File: contracts/common/DaoCommonMini.sol\r\ncontract DaoCommonMini is IdentityCommon {\r\n\r\n    using MathHelper for MathHelper;\r\n\r\n    /**\r\n    @notice Check if the DAO contracts have been replaced by a new set of contracts\r\n    @return _isNotReplaced true if it is not replaced, false if it has already been replaced\r\n    */\r\n    function isDaoNotReplaced()\r\n        public\r\n        view\r\n        returns (bool _isNotReplaced)\r\n    {\r\n        _isNotReplaced = !daoUpgradeStorage().isReplacedByNewDao();\r\n    }\r\n\r\n    /**\r\n    @notice Check if it is currently in the locking phase\r\n    @dev No governance activities can happen in the locking phase. The locking phase is from t=0 to t=CONFIG_LOCKING_PHASE_DURATION-1\r\n    @return _isLockingPhase true if it is in the locking phase\r\n    */\r\n    function isLockingPhase()\r\n        public\r\n        view\r\n        returns (bool _isLockingPhase)\r\n    {\r\n        _isLockingPhase = currentTimeInQuarter() < getUintConfig(CONFIG_LOCKING_PHASE_DURATION);\r\n    }\r\n\r\n    /**\r\n    @notice Check if it is currently in a main phase.\r\n    @dev The main phase is where all the governance activities could take plase. If the DAO is replaced, there can never be any more main phase.\r\n    @return _isMainPhase true if it is in a main phase\r\n    */\r\n    function isMainPhase()\r\n        public\r\n        view\r\n        returns (bool _isMainPhase)\r\n    {\r\n        _isMainPhase =\r\n            isDaoNotReplaced() &&\r\n            currentTimeInQuarter() >= getUintConfig(CONFIG_LOCKING_PHASE_DURATION);\r\n    }\r\n\r\n    /**\r\n    @notice Check if the calculateGlobalRewardsBeforeNewQuarter function has been done for a certain quarter\r\n    @dev However, there is no need to run calculateGlobalRewardsBeforeNewQuarter for the first quarter\r\n    */\r\n    modifier ifGlobalRewardsSet(uint256 _quarterNumber) {\r\n        if (_quarterNumber > 1) {\r\n            require(daoRewardsStorage().readDgxDistributionDay(_quarterNumber) > 0);\r\n        }\r\n        _;\r\n    }\r\n\r\n    /**\r\n    @notice require that it is currently during a phase, which is within _relativePhaseStart and _relativePhaseEnd seconds, after the _startingPoint\r\n    */\r\n    function requireInPhase(uint256 _startingPoint, uint256 _relativePhaseStart, uint256 _relativePhaseEnd)\r\n        internal\r\n        view\r\n    {\r\n        require(_startingPoint > 0);\r\n        require(now < _startingPoint.add(_relativePhaseEnd));\r\n        require(now >= _startingPoint.add(_relativePhaseStart));\r\n    }\r\n\r\n    /**\r\n    @notice Get the current quarter index\r\n    @dev Quarter indexes starts from 1\r\n    @return _quarterNumber the current quarter index\r\n    */\r\n    function currentQuarterNumber()\r\n        public\r\n        view\r\n        returns(uint256 _quarterNumber)\r\n    {\r\n        _quarterNumber = getQuarterNumber(now);\r\n    }\r\n\r\n    /**\r\n    @notice Get the quarter index of a timestamp\r\n    @dev Quarter indexes starts from 1\r\n    @return _index the quarter index\r\n    */\r\n    function getQuarterNumber(uint256 _time)\r\n        internal\r\n        view\r\n        returns (uint256 _index)\r\n    {\r\n        require(startOfFirstQuarterIsSet());\r\n        _index =\r\n            _time.sub(daoUpgradeStorage().startOfFirstQuarter())\r\n            .div(getUintConfig(CONFIG_QUARTER_DURATION))\r\n            .add(1);\r\n    }\r\n\r\n    /**\r\n    @notice Get the relative time in quarter of a timestamp\r\n    @dev For example, the timeInQuarter of the first second of any quarter n-th is always 1\r\n    */\r\n    function timeInQuarter(uint256 _time)\r\n        internal\r\n        view\r\n        returns (uint256 _timeInQuarter)\r\n    {\r\n        require(startOfFirstQuarterIsSet()); // must be already set\r\n        _timeInQuarter =\r\n            _time.sub(daoUpgradeStorage().startOfFirstQuarter())\r\n            % getUintConfig(CONFIG_QUARTER_DURATION);\r\n    }\r\n\r\n    /**\r\n    @notice Check if the start of first quarter is already set\r\n    @return _isSet true if start of first quarter is already set\r\n    */\r\n    function startOfFirstQuarterIsSet()\r\n        internal\r\n        view\r\n        returns (bool _isSet)\r\n    {\r\n        _isSet = daoUpgradeStorage().startOfFirstQuarter() != 0;\r\n    }\r\n\r\n    /**\r\n    @notice Get the current relative time in the quarter\r\n    @dev For example: the currentTimeInQuarter of the first second of any quarter is 1\r\n    @return _currentT the current relative time in the quarter\r\n    */\r\n    function currentTimeInQuarter()\r\n        public\r\n        view\r\n        returns (uint256 _currentT)\r\n    {\r\n        _currentT = timeInQuarter(now);\r\n    }\r\n\r\n    /**\r\n    @notice Get the time remaining in the quarter\r\n    */\r\n    function getTimeLeftInQuarter(uint256 _time)\r\n        internal\r\n        view\r\n        returns (uint256 _timeLeftInQuarter)\r\n    {\r\n        _timeLeftInQuarter = getUintConfig(CONFIG_QUARTER_DURATION).sub(timeInQuarter(_time));\r\n    }\r\n\r\n    function daoListingService()\r\n        internal\r\n        view\r\n        returns (DaoListingService _contract)\r\n    {\r\n        _contract = DaoListingService(get_contract(CONTRACT_SERVICE_DAO_LISTING));\r\n    }\r\n\r\n    function daoConfigsStorage()\r\n        internal\r\n        view\r\n        returns (DaoConfigsStorage _contract)\r\n    {\r\n        _contract = DaoConfigsStorage(get_contract(CONTRACT_STORAGE_DAO_CONFIG));\r\n    }\r\n\r\n    function daoStakeStorage()\r\n        internal\r\n        view\r\n        returns (DaoStakeStorage _contract)\r\n    {\r\n        _contract = DaoStakeStorage(get_contract(CONTRACT_STORAGE_DAO_STAKE));\r\n    }\r\n\r\n    function daoStorage()\r\n        internal\r\n        view\r\n        returns (DaoStorage _contract)\r\n    {\r\n        _contract = DaoStorage(get_contract(CONTRACT_STORAGE_DAO));\r\n    }\r\n\r\n    function daoProposalCounterStorage()\r\n        internal\r\n        view\r\n        returns (DaoProposalCounterStorage _contract)\r\n    {\r\n        _contract = DaoProposalCounterStorage(get_contract(CONTRACT_STORAGE_DAO_COUNTER));\r\n    }\r\n\r\n    function daoUpgradeStorage()\r\n        internal\r\n        view\r\n        returns (DaoUpgradeStorage _contract)\r\n    {\r\n        _contract = DaoUpgradeStorage(get_contract(CONTRACT_STORAGE_DAO_UPGRADE));\r\n    }\r\n\r\n    function daoSpecialStorage()\r\n        internal\r\n        view\r\n        returns (DaoSpecialStorage _contract)\r\n    {\r\n        _contract = DaoSpecialStorage(get_contract(CONTRACT_STORAGE_DAO_SPECIAL));\r\n    }\r\n\r\n    function daoPointsStorage()\r\n        internal\r\n        view\r\n        returns (DaoPointsStorage _contract)\r\n    {\r\n        _contract = DaoPointsStorage(get_contract(CONTRACT_STORAGE_DAO_POINTS));\r\n    }\r\n\r\n    function daoRewardsStorage()\r\n        internal\r\n        view\r\n        returns (DaoRewardsStorage _contract)\r\n    {\r\n        _contract = DaoRewardsStorage(get_contract(CONTRACT_STORAGE_DAO_REWARDS));\r\n    }\r\n\r\n    function intermediateResultsStorage()\r\n        internal\r\n        view\r\n        returns (IntermediateResultsStorage _contract)\r\n    {\r\n        _contract = IntermediateResultsStorage(get_contract(CONTRACT_STORAGE_INTERMEDIATE_RESULTS));\r\n    }\r\n\r\n    function getUintConfig(bytes32 _configKey)\r\n        public\r\n        view\r\n        returns (uint256 _configValue)\r\n    {\r\n        _configValue = daoConfigsStorage().uintConfigs(_configKey);\r\n    }\r\n}\r\n\r\n// File: contracts/common/DaoCommon.sol\r\ncontract DaoCommon is DaoCommonMini {\r\n\r\n    using MathHelper for MathHelper;\r\n\r\n    /**\r\n    @notice Check if the transaction is called by the proposer of a proposal\r\n    @return _isFromProposer true if the caller is the proposer\r\n    */\r\n    function isFromProposer(bytes32 _proposalId)\r\n        internal\r\n        view\r\n        returns (bool _isFromProposer)\r\n    {\r\n        _isFromProposer = msg.sender == daoStorage().readProposalProposer(_proposalId);\r\n    }\r\n\r\n    /**\r\n    @notice Check if the proposal can still be \"editted\", or in other words, added more versions\r\n    @dev Once the proposal is finalized, it can no longer be editted. The proposer will still be able to add docs and change fundings though.\r\n    @return _isEditable true if the proposal is editable\r\n    */\r\n    function isEditable(bytes32 _proposalId)\r\n        internal\r\n        view\r\n        returns (bool _isEditable)\r\n    {\r\n        bytes32 _finalVersion;\r\n        (,,,,,,,_finalVersion,,) = daoStorage().readProposal(_proposalId);\r\n        _isEditable = _finalVersion == EMPTY_BYTES;\r\n    }\r\n\r\n    /**\r\n    @notice returns the balance of DaoFundingManager, which is the wei in DigixDAO\r\n    */\r\n    function weiInDao()\r\n        internal\r\n        view\r\n        returns (uint256 _wei)\r\n    {\r\n        _wei = get_contract(CONTRACT_DAO_FUNDING_MANAGER).balance;\r\n    }\r\n\r\n    /**\r\n    @notice Check if it is after the draft voting phase of the proposal\r\n    */\r\n    modifier ifAfterDraftVotingPhase(bytes32 _proposalId) {\r\n        uint256 _start = daoStorage().readProposalDraftVotingTime(_proposalId);\r\n        require(_start > 0); // Draft voting must have started. In other words, proposer must have finalized the proposal\r\n        require(now >= _start.add(getUintConfig(CONFIG_DRAFT_VOTING_PHASE)));\r\n        _;\r\n    }\r\n\r\n    modifier ifCommitPhase(bytes32 _proposalId, uint8 _index) {\r\n        requireInPhase(\r\n            daoStorage().readProposalVotingTime(_proposalId, _index),\r\n            0,\r\n            getUintConfig(_index == 0 ? CONFIG_VOTING_COMMIT_PHASE : CONFIG_INTERIM_COMMIT_PHASE)\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier ifRevealPhase(bytes32 _proposalId, uint256 _index) {\r\n      requireInPhase(\r\n          daoStorage().readProposalVotingTime(_proposalId, _index),\r\n          getUintConfig(_index == 0 ? CONFIG_VOTING_COMMIT_PHASE : CONFIG_INTERIM_COMMIT_PHASE),\r\n          getUintConfig(_index == 0 ? CONFIG_VOTING_PHASE_TOTAL : CONFIG_INTERIM_PHASE_TOTAL)\r\n      );\r\n      _;\r\n    }\r\n\r\n    modifier ifAfterProposalRevealPhase(bytes32 _proposalId, uint256 _index) {\r\n      uint256 _start = daoStorage().readProposalVotingTime(_proposalId, _index);\r\n      require(_start > 0);\r\n      require(now >= _start.add(getUintConfig(_index == 0 ? CONFIG_VOTING_PHASE_TOTAL : CONFIG_INTERIM_PHASE_TOTAL)));\r\n      _;\r\n    }\r\n\r\n    modifier ifDraftVotingPhase(bytes32 _proposalId) {\r\n        requireInPhase(\r\n            daoStorage().readProposalDraftVotingTime(_proposalId),\r\n            0,\r\n            getUintConfig(CONFIG_DRAFT_VOTING_PHASE)\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier isProposalState(bytes32 _proposalId, bytes32 _STATE) {\r\n        bytes32 _currentState;\r\n        (,,,_currentState,,,,,,) = daoStorage().readProposal(_proposalId);\r\n        require(_currentState == _STATE);\r\n        _;\r\n    }\r\n\r\n    modifier ifDraftNotClaimed(bytes32 _proposalId) {\r\n        require(daoStorage().isDraftClaimed(_proposalId) == false);\r\n        _;\r\n    }\r\n\r\n    modifier ifNotClaimed(bytes32 _proposalId, uint256 _index) {\r\n        require(daoStorage().isClaimed(_proposalId, _index) == false);\r\n        _;\r\n    }\r\n\r\n    modifier ifNotClaimedSpecial(bytes32 _proposalId) {\r\n        require(daoSpecialStorage().isClaimed(_proposalId) == false);\r\n        _;\r\n    }\r\n\r\n    modifier hasNotRevealed(bytes32 _proposalId, uint256 _index) {\r\n        uint256 _voteWeight;\r\n        (, _voteWeight) = daoStorage().readVote(_proposalId, _index, msg.sender);\r\n        require(_voteWeight == uint(0));\r\n        _;\r\n    }\r\n\r\n    modifier hasNotRevealedSpecial(bytes32 _proposalId) {\r\n        uint256 _weight;\r\n        (,_weight) = daoSpecialStorage().readVote(_proposalId, msg.sender);\r\n        require(_weight == uint256(0));\r\n        _;\r\n    }\r\n\r\n    modifier ifAfterRevealPhaseSpecial(bytes32 _proposalId) {\r\n      uint256 _start = daoSpecialStorage().readVotingTime(_proposalId);\r\n      require(_start > 0);\r\n      require(now.sub(_start) >= getUintConfig(CONFIG_SPECIAL_PROPOSAL_PHASE_TOTAL));\r\n      _;\r\n    }\r\n\r\n    modifier ifCommitPhaseSpecial(bytes32 _proposalId) {\r\n        requireInPhase(\r\n            daoSpecialStorage().readVotingTime(_proposalId),\r\n            0,\r\n            getUintConfig(CONFIG_SPECIAL_PROPOSAL_COMMIT_PHASE)\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier ifRevealPhaseSpecial(bytes32 _proposalId) {\r\n        requireInPhase(\r\n            daoSpecialStorage().readVotingTime(_proposalId),\r\n            getUintConfig(CONFIG_SPECIAL_PROPOSAL_COMMIT_PHASE),\r\n            getUintConfig(CONFIG_SPECIAL_PROPOSAL_PHASE_TOTAL)\r\n        );\r\n        _;\r\n    }\r\n\r\n    function daoWhitelistingStorage()\r\n        internal\r\n        view\r\n        returns (DaoWhitelistingStorage _contract)\r\n    {\r\n        _contract = DaoWhitelistingStorage(get_contract(CONTRACT_STORAGE_DAO_WHITELISTING));\r\n    }\r\n\r\n    function getAddressConfig(bytes32 _configKey)\r\n        public\r\n        view\r\n        returns (address _configValue)\r\n    {\r\n        _configValue = daoConfigsStorage().addressConfigs(_configKey);\r\n    }\r\n\r\n    function getBytesConfig(bytes32 _configKey)\r\n        public\r\n        view\r\n        returns (bytes32 _configValue)\r\n    {\r\n        _configValue = daoConfigsStorage().bytesConfigs(_configKey);\r\n    }\r\n\r\n    /**\r\n    @notice Check if a user is a participant in the current quarter\r\n    */\r\n    function isParticipant(address _user)\r\n        public\r\n        view\r\n        returns (bool _is)\r\n    {\r\n        _is =\r\n            (daoRewardsStorage().lastParticipatedQuarter(_user) == currentQuarterNumber())\r\n            && (daoStakeStorage().lockedDGDStake(_user) >= getUintConfig(CONFIG_MINIMUM_LOCKED_DGD));\r\n    }\r\n\r\n    /**\r\n    @notice Check if a user is a moderator in the current quarter\r\n    */\r\n    function isModerator(address _user)\r\n        public\r\n        view\r\n        returns (bool _is)\r\n    {\r\n        _is =\r\n            (daoRewardsStorage().lastParticipatedQuarter(_user) == currentQuarterNumber())\r\n            && (daoStakeStorage().lockedDGDStake(_user) >= getUintConfig(CONFIG_MINIMUM_DGD_FOR_MODERATOR))\r\n            && (daoPointsStorage().getReputation(_user) >= getUintConfig(CONFIG_MINIMUM_REPUTATION_FOR_MODERATOR));\r\n    }\r\n\r\n    /**\r\n    @notice Calculate the start of a specific milestone of a specific proposal.\r\n    @dev This is calculated from the voting start of the voting round preceding the milestone\r\n         This would throw if the voting start is 0 (the voting round has not started yet)\r\n         Note that if the milestoneIndex is exactly the same as the number of milestones,\r\n         This will just return the end of the last voting round.\r\n    */\r\n    function startOfMilestone(bytes32 _proposalId, uint256 _milestoneIndex)\r\n        internal\r\n        view\r\n        returns (uint256 _milestoneStart)\r\n    {\r\n        uint256 _startOfPrecedingVotingRound = daoStorage().readProposalVotingTime(_proposalId, _milestoneIndex);\r\n        require(_startOfPrecedingVotingRound > 0);\r\n        // the preceding voting round must have started\r\n\r\n        if (_milestoneIndex == 0) { // This is the 1st milestone, which starts after voting round 0\r\n            _milestoneStart =\r\n                _startOfPrecedingVotingRound\r\n                .add(getUintConfig(CONFIG_VOTING_PHASE_TOTAL));\r\n        } else { // if its the n-th milestone, it starts after voting round n-th\r\n            _milestoneStart =\r\n                _startOfPrecedingVotingRound\r\n                .add(getUintConfig(CONFIG_INTERIM_PHASE_TOTAL));\r\n        }\r\n    }\r\n\r\n    /**\r\n    @notice Calculate the actual voting start for a voting round, given the tentative start\r\n    @dev The tentative start is the ideal start. For example, when a proposer finish a milestone, it should be now\r\n         However, sometimes the tentative start is too close to the end of the quarter, hence, the actual voting start should be pushed to the next quarter\r\n    */\r\n    function getTimelineForNextVote(\r\n        uint256 _index,\r\n        uint256 _tentativeVotingStart\r\n    )\r\n        internal\r\n        view\r\n        returns (uint256 _actualVotingStart)\r\n    {\r\n        uint256 _timeLeftInQuarter = getTimeLeftInQuarter(_tentativeVotingStart);\r\n        uint256 _votingDuration = getUintConfig(_index == 0 ? CONFIG_VOTING_PHASE_TOTAL : CONFIG_INTERIM_PHASE_TOTAL);\r\n        _actualVotingStart = _tentativeVotingStart;\r\n        if (timeInQuarter(_tentativeVotingStart) < getUintConfig(CONFIG_LOCKING_PHASE_DURATION)) { // if the tentative start is during a locking phase\r\n            _actualVotingStart = _tentativeVotingStart.add(\r\n                getUintConfig(CONFIG_LOCKING_PHASE_DURATION).sub(timeInQuarter(_tentativeVotingStart))\r\n            );\r\n        } else if (_timeLeftInQuarter < _votingDuration.add(getUintConfig(CONFIG_VOTE_CLAIMING_DEADLINE))) { // if the time left in quarter is not enough to vote and claim voting\r\n            _actualVotingStart = _tentativeVotingStart.add(\r\n                _timeLeftInQuarter.add(getUintConfig(CONFIG_LOCKING_PHASE_DURATION)).add(1)\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n    @notice Check if we can add another non-Digix proposal in this quarter\r\n    @dev There is a max cap to the number of non-Digix proposals CONFIG_NON_DIGIX_PROPOSAL_CAP_PER_QUARTER\r\n    */\r\n    function checkNonDigixProposalLimit(bytes32 _proposalId)\r\n        internal\r\n        view\r\n    {\r\n        require(isNonDigixProposalsWithinLimit(_proposalId));\r\n    }\r\n\r\n    function isNonDigixProposalsWithinLimit(bytes32 _proposalId)\r\n        internal\r\n        view\r\n        returns (bool _withinLimit)\r\n    {\r\n        bool _isDigixProposal;\r\n        (,,,,,,,,,_isDigixProposal) = daoStorage().readProposal(_proposalId);\r\n        _withinLimit = true;\r\n        if (!_isDigixProposal) {\r\n            _withinLimit = daoProposalCounterStorage().proposalCountByQuarter(currentQuarterNumber()) < getUintConfig(CONFIG_NON_DIGIX_PROPOSAL_CAP_PER_QUARTER);\r\n        }\r\n    }\r\n\r\n    /**\r\n    @notice If its a non-Digix proposal, check if the fundings are within limit\r\n    @dev There is a max cap to the fundings and number of milestones for non-Digix proposals\r\n    */\r\n    function checkNonDigixFundings(uint256[] _milestonesFundings, uint256 _finalReward)\r\n        internal\r\n        view\r\n    {\r\n        if (!is_founder()) {\r\n            require(_milestonesFundings.length <= getUintConfig(CONFIG_MAX_MILESTONES_FOR_NON_DIGIX));\r\n            require(MathHelper.sumNumbers(_milestonesFundings).add(_finalReward) <= getUintConfig(CONFIG_MAX_FUNDING_FOR_NON_DIGIX));\r\n        }\r\n    }\r\n\r\n    /**\r\n    @notice Check if msg.sender can do operations as a proposer\r\n    @dev Note that this function does not check if he is the proposer of the proposal\r\n    */\r\n    function senderCanDoProposerOperations()\r\n        internal\r\n        view\r\n    {\r\n        require(isMainPhase());\r\n        require(isParticipant(msg.sender));\r\n        require(identity_storage().is_kyc_approved(msg.sender));\r\n    }\r\n}\r\n\r\n// File: contracts/interactive/DaoSpecialProposal.sol\r\ncontract DaoSpecialProposal is DaoCommon {\r\n\r\n    event StartSpecialProposal(bytes32 indexed _specialProposalId);\r\n\r\n    constructor(address _resolver) public {\r\n        require(init(CONTRACT_DAO_SPECIAL_PROPOSAL, _resolver));\r\n    }\r\n\r\n    /**\r\n    @notice Function to create a Special Proposal (can only be created by the founders)\r\n    @param _doc hash of the IPFS doc of the special proposal details\r\n    @param _uintConfigs Array of the new UINT256 configs\r\n    @param _addressConfigs Array of the new Address configs\r\n    @param _bytesConfigs Array of the new Bytes32 configs\r\n    @return {\r\n      \"_success\": \"true if created special successfully\"\r\n    }\r\n    */\r\n    function createSpecialProposal(\r\n        bytes32 _doc,\r\n        uint256[] _uintConfigs,\r\n        address[] _addressConfigs,\r\n        bytes32[] _bytesConfigs\r\n    )\r\n        external\r\n        if_founder()\r\n        returns (bool _success)\r\n    {\r\n        require(isMainPhase());\r\n        address _proposer = msg.sender;\r\n        daoSpecialStorage().addSpecialProposal(\r\n            _doc,\r\n            _proposer,\r\n            _uintConfigs,\r\n            _addressConfigs,\r\n            _bytesConfigs\r\n        );\r\n        _success = true;\r\n    }\r\n\r\n    /**\r\n    @notice Function to set start of voting round for special proposal\r\n    @param _proposalId ID of the special proposal\r\n    */\r\n    function startSpecialProposalVoting(\r\n        bytes32 _proposalId\r\n    )\r\n        public\r\n    {\r\n        require(isMainPhase());\r\n        require(daoSpecialStorage().readProposalProposer(_proposalId) == msg.sender);\r\n        require(daoSpecialStorage().readVotingTime(_proposalId) == 0); // voting hasnt started yet\r\n        require(getTimeLeftInQuarter(now) > getUintConfig(CONFIG_SPECIAL_PROPOSAL_PHASE_TOTAL).add(getUintConfig(CONFIG_VOTE_CLAIMING_DEADLINE)));\r\n        daoSpecialStorage().setVotingTime(_proposalId, now);\r\n\r\n        emit StartSpecialProposal(_proposalId);\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"resolver\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_configKey\",\"type\":\"bytes32\"}],\"name\":\"getAddressConfig\",\"outputs\":[{\"name\":\"_configValue\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_doc\",\"type\":\"bytes32\"},{\"name\":\"_uintConfigs\",\"type\":\"uint256[]\"},{\"name\":\"_addressConfigs\",\"type\":\"address[]\"},{\"name\":\"_bytesConfigs\",\"type\":\"bytes32[]\"}],\"name\":\"createSpecialProposal\",\"outputs\":[{\"name\":\"_success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"key\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_key\",\"type\":\"bytes32\"}],\"name\":\"get_contract\",\"outputs\":[{\"name\":\"_contract\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_proposalId\",\"type\":\"bytes32\"}],\"name\":\"startSpecialProposalVoting\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentTimeInQuarter\",\"outputs\":[{\"name\":\"_currentT\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isMainPhase\",\"outputs\":[{\"name\":\"_isMainPhase\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isLockingPhase\",\"outputs\":[{\"name\":\"_isLockingPhase\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentQuarterNumber\",\"outputs\":[{\"name\":\"_quarterNumber\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"isParticipant\",\"outputs\":[{\"name\":\"_is\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_configKey\",\"type\":\"bytes32\"}],\"name\":\"getBytesConfig\",\"outputs\":[{\"name\":\"_configValue\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_configKey\",\"type\":\"bytes32\"}],\"name\":\"getUintConfig\",\"outputs\":[{\"name\":\"_configValue\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isDaoNotReplaced\",\"outputs\":[{\"name\":\"_isNotReplaced\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CONTRACT_ADDRESS\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"isModerator\",\"outputs\":[{\"name\":\"_is\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_resolver\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_specialProposalId\",\"type\":\"bytes32\"}],\"name\":\"StartSpecialProposal\",\"type\":\"event\"}]","ContractName":"DaoSpecialProposal","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000005f60ef7e1443f82ca7de947711f0966ca6e3b5","Library":"","SwarmSource":"bzzr://06ca7d72838845a347f4283998f1a0d1973e24865cd011266c3ebe67a17bc97d"}]}