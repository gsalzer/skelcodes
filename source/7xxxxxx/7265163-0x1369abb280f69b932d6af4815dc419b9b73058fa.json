{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.25;\r\n\r\n\r\n// ----------------------------------------------------------------------------\r\n// Safe maths\r\n// ----------------------------------------------------------------------------\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return a / b;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n// ----------------------------------------------------------------------------\r\n// Ownable contract\r\n// ----------------------------------------------------------------------------\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  constructor() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n}\r\n\r\n/**\r\n * @title Claimable\r\n * @dev Extension for the Ownable contract, where the ownership needs to be claimed.\r\n * This allows the new owner to accept the transfer.\r\n */\r\ncontract Claimable is Ownable {\r\n  address public pendingOwner;\r\n\r\n  event OwnershipTransferPending(address indexed owner, address indexed pendingOwner);\r\n\r\n  /**\r\n   * @dev Modifier throws if called by any account other than the pendingOwner.\r\n   */\r\n  modifier onlyPendingOwner() {\r\n    require(msg.sender == pendingOwner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to set the pendingOwner address.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) onlyOwner public {\r\n    require(newOwner != address(0));\r\n    emit OwnershipTransferPending(owner, pendingOwner);\r\n    pendingOwner = newOwner;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the pendingOwner address to finalize the transfer.\r\n   */\r\n  function claimOwnership() onlyPendingOwner public {\r\n    emit OwnershipTransferred(owner, pendingOwner);\r\n    owner = pendingOwner;\r\n    pendingOwner = address(0);\r\n  }\r\n}\r\n\r\n// ----------------------------------------------------------------------------\r\n// Pausable contract\r\n// ----------------------------------------------------------------------------\r\n/**\r\n * @title Pausable\r\n * @dev Base contract which allows children to implement an emergency stop mechanism.\r\n */\r\ncontract Pausable is Claimable {\r\n  event Pause();\r\n  event Unpause();\r\n\r\n  bool public paused = false;\r\n\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is not paused.\r\n   */\r\n  modifier whenNotPaused() {\r\n    require(!paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is paused.\r\n   */\r\n  modifier whenPaused() {\r\n    require(paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to pause, triggers stopped state\r\n   */\r\n  function pause() onlyOwner whenNotPaused public {\r\n    paused = true;\r\n    emit Pause();\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to unpause, returns to normal state\r\n   */\r\n  function unpause() onlyOwner whenPaused public {\r\n    paused = false;\r\n    emit Unpause();\r\n  }\r\n}\r\n\r\n// ----------------------------------------------------------------------------\r\n// Administratable contract\r\n// ----------------------------------------------------------------------------\r\n/**\r\n * @title Administratable\r\n * @dev The Admin contract has the list of admin addresses.\r\n */\r\ncontract Administratable is Claimable {\r\n  struct MintStruct {\r\n    uint256 mintedTotal;\r\n    uint256 lastMintTimestamp;\r\n  }\r\n\r\n  struct BurnStruct {\r\n    uint256 burntTotal;\r\n    uint256 lastBurnTimestamp;\r\n  }\r\n\r\n  mapping(address => bool) public admins;\r\n  mapping(address => MintStruct) public mintLimiter;\r\n  mapping(address => BurnStruct) public burnLimiter;\r\n\r\n  event AdminAddressAdded(address indexed addr);\r\n  event AdminAddressRemoved(address indexed addr);\r\n\r\n\r\n  /**\r\n   * @dev Throws if called by any account that's not admin or owner.\r\n   */\r\n  modifier onlyAdmin() {\r\n    require(admins[msg.sender] || msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev add an address to the admin list\r\n   * @param addr address\r\n   * @return true if the address was added to the admin list, false if the address was already in the admin list\r\n   */\r\n  function addAddressToAdmin(address addr) onlyOwner public returns(bool success) {\r\n    if (!admins[addr]) {\r\n      admins[addr] = true;\r\n      mintLimiter[addr] = MintStruct(0, 0);\r\n      burnLimiter[addr] = BurnStruct(0, 0);\r\n      emit AdminAddressAdded(addr);\r\n      success = true;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev remove an address from the admin list\r\n   * @param addr address\r\n   * @return true if the address was removed from the admin list,\r\n   * false if the address wasn't in the admin list in the first place\r\n   */\r\n  function removeAddressFromAdmin(address addr) onlyOwner public returns(bool success) {\r\n    if (admins[addr]) {\r\n      admins[addr] = false;\r\n      delete mintLimiter[addr];\r\n      delete burnLimiter[addr];\r\n      emit AdminAddressRemoved(addr);\r\n      success = true;\r\n    }\r\n  }\r\n}\r\n/**\r\n * @title Callable\r\n * @dev Extension for the Claimable contract.\r\n * This allows the contract only be called by certain contract.\r\n */\r\ncontract Callable is Claimable {\r\n  mapping(address => bool) public callers;\r\n\r\n  event CallerAddressAdded(address indexed addr);\r\n  event CallerAddressRemoved(address indexed addr);\r\n\r\n\r\n  /**\r\n   * @dev Modifier throws if called by any account other than the callers or owner.\r\n   */\r\n  modifier onlyCaller() {\r\n    require(callers[msg.sender]);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev add an address to the caller list\r\n   * @param addr address\r\n   * @return true if the address was added to the caller list, false if the address was already in the caller list\r\n   */\r\n  function addAddressToCaller(address addr) onlyOwner public returns(bool success) {\r\n    if (!callers[addr]) {\r\n      callers[addr] = true;\r\n      emit CallerAddressAdded(addr);\r\n      success = true;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev remove an address from the caller list\r\n   * @param addr address\r\n   * @return true if the address was removed from the caller list,\r\n   * false if the address wasn't in the caller list in the first place\r\n   */\r\n  function removeAddressFromCaller(address addr) onlyOwner public returns(bool success) {\r\n    if (callers[addr]) {\r\n      callers[addr] = false;\r\n      emit CallerAddressRemoved(addr);\r\n      success = true;\r\n    }\r\n  }\r\n}\r\n\r\n// ----------------------------------------------------------------------------\r\n// Blacklist\r\n// ----------------------------------------------------------------------------\r\n/**\r\n * @title Blacklist\r\n * @dev The Blacklist contract has a blacklist of addresses, and provides basic authorization control functions.\r\n */\r\ncontract Blacklist is Callable {\r\n  mapping(address => bool) public blacklist;\r\n\r\n  function addAddressToBlacklist(address addr) onlyCaller public returns (bool success) {\r\n    if (!blacklist[addr]) {\r\n      blacklist[addr] = true;\r\n      success = true;\r\n    }\r\n  }\r\n\r\n  function removeAddressFromBlacklist(address addr) onlyCaller public returns (bool success) {\r\n    if (blacklist[addr]) {\r\n      blacklist[addr] = false;\r\n      success = true;\r\n    }\r\n  }\r\n}\r\n\r\n// ----------------------------------------------------------------------------\r\n// Allowance\r\n// ----------------------------------------------------------------------------\r\n/**\r\n * @title Allowance\r\n * @dev Storage for the Allowance List.\r\n */\r\ncontract Allowance is Callable {\r\n  using SafeMath for uint256;\r\n\r\n  mapping (address => mapping (address => uint256)) public allowanceOf;\r\n\r\n  function addAllowance(address _holder, address _spender, uint256 _value) onlyCaller public {\r\n    allowanceOf[_holder][_spender] = allowanceOf[_holder][_spender].add(_value);\r\n  }\r\n\r\n  function subAllowance(address _holder, address _spender, uint256 _value) onlyCaller public {\r\n    uint256 oldValue = allowanceOf[_holder][_spender];\r\n    if (_value > oldValue) {\r\n      allowanceOf[_holder][_spender] = 0;\r\n    } else {\r\n      allowanceOf[_holder][_spender] = oldValue.sub(_value);\r\n    }\r\n  }\r\n\r\n  function setAllowance(address _holder, address _spender, uint256 _value) onlyCaller public {\r\n    allowanceOf[_holder][_spender] = _value;\r\n  }\r\n}\r\n\r\n// ----------------------------------------------------------------------------\r\n// Balance\r\n// ----------------------------------------------------------------------------\r\n/**\r\n * @title Balance\r\n * @dev Storage for the Balance List.\r\n */\r\ncontract Balance is Callable {\r\n  using SafeMath for uint256;\r\n\r\n  mapping (address => uint256) public balanceOf;\r\n\r\n  uint256 public totalSupply;\r\n\r\n  function addBalance(address _addr, uint256 _value) onlyCaller public {\r\n    balanceOf[_addr] = balanceOf[_addr].add(_value);\r\n  }\r\n\r\n  function subBalance(address _addr, uint256 _value) onlyCaller public {\r\n    balanceOf[_addr] = balanceOf[_addr].sub(_value);\r\n  }\r\n\r\n  function setBalance(address _addr, uint256 _value) onlyCaller public {\r\n    balanceOf[_addr] = _value;\r\n  }\r\n\r\n  function addTotalSupply(uint256 _value) onlyCaller public {\r\n    totalSupply = totalSupply.add(_value);\r\n  }\r\n\r\n  function subTotalSupply(uint256 _value) onlyCaller public {\r\n    totalSupply = totalSupply.sub(_value);\r\n  }\r\n}\r\n\r\n// ----------------------------------------------------------------------------\r\n// Blacklistable\r\n// ----------------------------------------------------------------------------\r\n/**\r\n * @title Blacklistable\r\n * @dev A contract for the blacklist modifiers.\r\n */\r\ncontract Blacklistable {\r\n  Blacklist internal _blacklist;\r\n\r\n  constructor(\r\n    Blacklist _blacklistContract\r\n  ) public {\r\n    _blacklist = _blacklistContract;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if the given address is blacklisted.\r\n   */\r\n  modifier onlyNotBlacklistedAddr(address addr) {\r\n    require(!_blacklist.blacklist(addr));\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if one of the given addresses is blacklisted.\r\n   */\r\n  modifier onlyNotBlacklistedAddrs(address[] addrs) {\r\n    for (uint256 i = 0; i < addrs.length; i++) {\r\n      require(!_blacklist.blacklist(addrs[i]));\r\n    }\r\n    _;\r\n  }\r\n\r\n  function blacklist(address addr) public view returns (bool) {\r\n    return _blacklist.blacklist(addr);\r\n  }\r\n}\r\n\r\n/**\r\n * @title ControllerTest\r\n * @dev A contract for managing the minting, burning, blacklisting and administration of the tokens.\r\n */\r\ncontract ControllerTest is Pausable, Administratable, Blacklistable {\r\n  using SafeMath for uint256;\r\n  Balance internal _balances;\r\n\r\n  uint256 constant decimals = 18;\r\n  uint256 constant maxBLBatch = 100;\r\n  uint256 public dailyMintLimit = 10000 * 10 ** decimals;\r\n  uint256 public dailyBurnLimit = 10000 * 10 ** decimals;\r\n  uint256 constant dayInSeconds = 86400;\r\n\r\n  constructor(\r\n    Balance _balanceContract, Blacklist _blacklistContract\r\n  ) Blacklistable(_blacklistContract) public {\r\n    _balances = _balanceContract;\r\n  }\r\n\r\n  // This notifies clients about the amount burnt\r\n  event Burn(address indexed from, uint256 value);\r\n  // This notifies clients about the amount mint\r\n  event Mint(address indexed to, uint256 value);\r\n  // This notifies clients about the amount of limit mint by some admin\r\n  event LimitMint(address indexed admin, address indexed to, uint256 value);\r\n  // This notifies clients about the amount of limit burn by some admin\r\n  event LimitBurn(address indexed admin, address indexed from, uint256 value);\r\n\r\n  event BlacklistedAddressAdded(address indexed addr);\r\n  event BlacklistedAddressRemoved(address indexed addr);\r\n\r\n  // blacklist operations\r\n  function _addToBlacklist(address addr) internal returns (bool success) {\r\n    success = _blacklist.addAddressToBlacklist(addr);\r\n    if (success) {\r\n      emit BlacklistedAddressAdded(addr);\r\n    }\r\n  }\r\n\r\n  function _removeFromBlacklist(address addr) internal returns (bool success) {\r\n    success = _blacklist.removeAddressFromBlacklist(addr);\r\n    if (success) {\r\n      emit BlacklistedAddressRemoved(addr);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev add an address to the blacklist\r\n   * @param addr address\r\n   * @return true if the address was added to the blacklist, false if the address was already in the blacklist\r\n   */\r\n  function addAddressToBlacklist(address addr) onlyAdmin whenNotPaused public returns (bool) {\r\n    return _addToBlacklist(addr);\r\n  }\r\n\r\n  /**\r\n   * @dev add addresses to the blacklist\r\n   * @param addrs addresses\r\n   * @return true if at least one address was added to the blacklist,\r\n   * false if all addresses were already in the blacklist\r\n   */\r\n  function addAddressesToBlacklist(address[] addrs) onlyAdmin whenNotPaused public returns (bool success) {\r\n    uint256 cnt = uint256(addrs.length);\r\n    require(cnt <= maxBLBatch);\r\n    success = true;\r\n    for (uint256 i = 0; i < addrs.length; i++) {\r\n      if (!_addToBlacklist(addrs[i])) {\r\n        success = false;\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev remove an address from the blacklist\r\n   * @param addr address\r\n   * @return true if the address was removed from the blacklist,\r\n   * false if the address wasn't in the blacklist in the first place\r\n   */\r\n  function removeAddressFromBlacklist(address addr) onlyAdmin whenNotPaused public returns (bool) {\r\n    return _removeFromBlacklist(addr);\r\n  }\r\n\r\n  /**\r\n   * @dev remove addresses from the blacklist\r\n   * @param addrs addresses\r\n   * @return true if at least one address was removed from the blacklist,\r\n   * false if all addresses weren't in the blacklist in the first place\r\n   */\r\n  function removeAddressesFromBlacklist(address[] addrs) onlyAdmin whenNotPaused public returns (bool success) {\r\n    success = true;\r\n    for (uint256 i = 0; i < addrs.length; i++) {\r\n      if (!_removeFromBlacklist(addrs[i])) {\r\n        success = false;\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Destroy tokens from other account\r\n   *\r\n   * Remove `_amount` tokens from the system irreversibly on behalf of `_from`.\r\n   *\r\n   * @param _from the address of the sender\r\n   * @param _amount the amount of money to burn\r\n   */\r\n  function burnFrom(address _from, uint256 _amount) onlyOwner whenNotPaused\r\n  public returns (bool success) {\r\n    require(_balances.balanceOf(_from) >= _amount);    // Check if the targeted balance is enough\r\n    _balances.subBalance(_from, _amount);              // Subtract from the targeted balance\r\n    _balances.subTotalSupply(_amount);\r\n    emit Burn(_from, _amount);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Destroy tokens from other account\r\n   * If the burn total amount exceeds the daily threshold, this operation will fail\r\n   *\r\n   * Remove `_amount` tokens from the system irreversibly on behalf of `_from`.\r\n   *\r\n   * @param _from the address of the sender\r\n   * @param _amount the amount of money to burn\r\n   */\r\n  function limitBurnFrom(address _from, uint256 _amount) onlyAdmin whenNotPaused\r\n  public returns (bool success) {\r\n    require(_balances.balanceOf(_from) >= _amount && _amount <= dailyBurnLimit);\r\n    if (burnLimiter[msg.sender].lastBurnTimestamp.div(dayInSeconds) != now.div(dayInSeconds)) {\r\n      burnLimiter[msg.sender].burntTotal = 0;\r\n    }\r\n    require(burnLimiter[msg.sender].burntTotal.add(_amount) <= dailyBurnLimit);\r\n    _balances.subBalance(_from, _amount);              // Subtract from the targeted balance\r\n    _balances.subTotalSupply(_amount);\r\n    burnLimiter[msg.sender].lastBurnTimestamp = now;\r\n    burnLimiter[msg.sender].burntTotal = burnLimiter[msg.sender].burntTotal.add(_amount);\r\n    emit LimitBurn(msg.sender, _from, _amount);\r\n    emit Burn(_from, _amount);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n    * Add `_amount` tokens to the pool and to the `_to` address' balance.\r\n    * If the mint total amount exceeds the daily threshold, this operation will fail\r\n    *\r\n    * @param _to the address that will receive the given amount of tokens\r\n    * @param _amount the amount of tokens it will receive\r\n    */\r\n  function limitMint(address _to, uint256 _amount)\r\n  onlyAdmin whenNotPaused onlyNotBlacklistedAddr(_to)\r\n  public returns (bool success) {\r\n    require(_to != msg.sender);\r\n    require(_amount <= dailyMintLimit);\r\n    if (mintLimiter[msg.sender].lastMintTimestamp.div(dayInSeconds) != now.div(dayInSeconds)) {\r\n      mintLimiter[msg.sender].mintedTotal = 0;\r\n    }\r\n    require(mintLimiter[msg.sender].mintedTotal.add(_amount) <= dailyMintLimit);\r\n    _balances.addBalance(_to, _amount);\r\n    _balances.addTotalSupply(_amount);\r\n    mintLimiter[msg.sender].lastMintTimestamp = now;\r\n    mintLimiter[msg.sender].mintedTotal = mintLimiter[msg.sender].mintedTotal.add(_amount);\r\n    emit LimitMint(msg.sender, _to, _amount);\r\n    emit Mint(_to, _amount);\r\n    return true;\r\n  }\r\n\r\n  function setDailyMintLimit(uint256 _limit) onlyOwner public returns (bool) {\r\n    dailyMintLimit = _limit;\r\n    return true;\r\n  }\r\n\r\n  function setDailyBurnLimit(uint256 _limit) onlyOwner public returns (bool) {\r\n    dailyBurnLimit = _limit;\r\n    return true;\r\n  }\r\n\r\n  /**\r\n    * Add `_amount` tokens to the pool and to the `_to` address' balance\r\n    *\r\n    * @param _to the address that will receive the given amount of tokens\r\n    * @param _amount the amount of tokens it will receive\r\n    */\r\n  function mint(address _to, uint256 _amount)\r\n  onlyOwner whenNotPaused onlyNotBlacklistedAddr(_to)\r\n  public returns (bool success) {\r\n    _balances.addBalance(_to, _amount);\r\n    _balances.addTotalSupply(_amount);\r\n    emit Mint(_to, _amount);\r\n    return true;\r\n  }\r\n}\r\n\r\n// ----------------------------------------------------------------------------\r\n// ContractInterface\r\n// ----------------------------------------------------------------------------\r\ncontract ContractInterface {\r\n  function totalSupply() public view returns (uint256);\r\n  function balanceOf(address tokenOwner) public view returns (uint256);\r\n  function allowance(address tokenOwner, address spender) public view returns (uint256);\r\n  function transfer(address to, uint256 value) public returns (bool);\r\n  function approve(address spender, uint256 value) public returns (bool);\r\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\r\n  function batchTransfer(address[] to, uint256 value) public returns (bool);\r\n  function increaseApproval(address spender, uint256 value) public returns (bool);\r\n  function decreaseApproval(address spender, uint256 value) public returns (bool);\r\n  function burn(uint256 value) public returns (bool);\r\n\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n  event Approval(address indexed tokenOwner, address indexed spender, uint256 value);\r\n  // This notifies clients about the amount burnt\r\n  event Burn(address indexed from, uint256 value);\r\n}\r\n\r\n// ----------------------------------------------------------------------------\r\n// V_test contract\r\n// ----------------------------------------------------------------------------\r\ncontract V_test is ContractInterface, Pausable, Blacklistable {\r\n  using SafeMath for uint256;\r\n\r\n  // variables of the token\r\n  uint8 public constant decimals = 18;\r\n  uint256 constant maxBatch = 100;\r\n\r\n  string public name;\r\n  string public symbol;\r\n\r\n  Balance internal _balances;\r\n  Allowance internal _allowance;\r\n\r\n  constructor(string _tokenName, string _tokenSymbol,\r\n    Balance _balanceContract, Allowance _allowanceContract,\r\n    Blacklist _blacklistContract\r\n  ) Blacklistable(_blacklistContract) public {\r\n    name = _tokenName;                                        // Set the name for display purposes\r\n    symbol = _tokenSymbol;                                    // Set the symbol for display purposes\r\n    _balances = _balanceContract;\r\n    _allowance = _allowanceContract;\r\n  }\r\n\r\n  function totalSupply() public view returns (uint256) {\r\n    return _balances.totalSupply();\r\n  }\r\n\r\n  function balanceOf(address _addr) public view returns (uint256) {\r\n    return _balances.balanceOf(_addr);\r\n  }\r\n\r\n  /**\r\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n   * @param _owner address The address which owns the funds.\r\n   * @param _spender address The address which will spend the funds.\r\n   * @return A uint256 specifying the amount of tokens still available for the spender.\r\n   */\r\n  function allowance(address _owner, address _spender) public view returns (uint256) {\r\n    return _allowance.allowanceOf(_owner, _spender);\r\n  }\r\n\r\n  /**\r\n   *  @dev Internal transfer, only can be called by this contract\r\n   */\r\n  function _transfer(address _from, address _to, uint256 _value) internal {\r\n    require(_value > 0);                                               // transfering value must be greater than 0\r\n    require(_to != 0x0);                                               // Prevent transfer to 0x0 address. Use burn() instead\r\n    require(_balances.balanceOf(_from) >= _value);                     // Check if the sender has enough\r\n    uint256 previousBalances = _balances.balanceOf(_from).add(_balances.balanceOf(_to)); // Save this for an assertion in the future\r\n    _balances.subBalance(_from, _value);                 // Subtract from the sender\r\n    _balances.addBalance(_to, _value);                     // Add the same to the recipient\r\n    emit Transfer(_from, _to, _value);\r\n    // Asserts are used to use static analysis to find bugs in your code. They should never fail\r\n    assert(_balances.balanceOf(_from) + _balances.balanceOf(_to) == previousBalances);\r\n  }\r\n\r\n  /**\r\n   * @dev Transfer tokens\r\n   * Send `_value` tokens to `_to` from your account\r\n   *\r\n   * @param _to The address of the recipient\r\n   * @param _value the amount to send\r\n   */\r\n  function transfer(address _to, uint256 _value)\r\n  whenNotPaused onlyNotBlacklistedAddr(msg.sender) onlyNotBlacklistedAddr(_to)\r\n  public returns (bool) {\r\n    _transfer(msg.sender, _to, _value);\r\n    return true;\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Transfer tokens to multiple accounts\r\n   * Send `_value` tokens to all addresses in `_to` from your account\r\n   *\r\n   * @param _to The addresses of the recipients\r\n   * @param _value the amount to send\r\n   */\r\n  function batchTransfer(address[] _to, uint256 _value)\r\n  whenNotPaused onlyNotBlacklistedAddr(msg.sender) onlyNotBlacklistedAddrs(_to)\r\n  public returns (bool) {\r\n    uint256 cnt = uint256(_to.length);\r\n    require(cnt > 0 && cnt <= maxBatch && _value > 0);\r\n    uint256 amount = _value.mul(cnt);\r\n    require(_balances.balanceOf(msg.sender) >= amount);\r\n\r\n    for (uint256 i = 0; i < cnt; i++) {\r\n      _transfer(msg.sender, _to[i], _value);\r\n    }\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Transfer tokens from other address\r\n   * Send `_value` tokens to `_to` in behalf of `_from`\r\n   *\r\n   * @param _from The address of the sender\r\n   * @param _to The address of the recipient\r\n   * @param _value the amount to send\r\n   */\r\n  function transferFrom(address _from, address _to, uint256 _value)\r\n  whenNotPaused onlyNotBlacklistedAddr(_from) onlyNotBlacklistedAddr(_to)\r\n  public returns (bool) {\r\n    require(_allowance.allowanceOf(_from, msg.sender) >= _value);     // Check allowance\r\n    _allowance.subAllowance(_from, msg.sender, _value);\r\n    _transfer(_from, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n   *\r\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\r\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\r\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\r\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _value The amount of tokens to be spent.\r\n   *\r\n   * Allows `_spender` to spend no more than `_value` tokens in your behalf\r\n   *\r\n   * @param _spender The address authorized to spend\r\n   * @param _value the max amount they can spend\r\n   */\r\n  function approve(address _spender, uint256 _value)\r\n  whenNotPaused onlyNotBlacklistedAddr(msg.sender) onlyNotBlacklistedAddr(_spender)\r\n  public returns (bool) {\r\n    _allowance.setAllowance(msg.sender, _spender, _value);\r\n    emit Approval(msg.sender, _spender, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Increase the amount of tokens that an owner allowed to a spender.\r\n   *\r\n   * approve should be called when allowed[_spender] == 0. To increment\r\n   * allowed value is better to use this function to avoid 2 calls (and wait until\r\n   * the first transaction is mined)\r\n   * From MonolithDAO Token.sol\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _addedValue The amount of tokens to increase the allowance by.\r\n   */\r\n  function increaseApproval(address _spender, uint256 _addedValue)\r\n  whenNotPaused onlyNotBlacklistedAddr(msg.sender) onlyNotBlacklistedAddr(_spender)\r\n  public returns (bool) {\r\n    _allowance.addAllowance(msg.sender, _spender, _addedValue);\r\n    emit Approval(msg.sender, _spender, _allowance.allowanceOf(msg.sender, _spender));\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Decrease the amount of tokens that an owner allowed to a spender.\r\n   *\r\n   * approve should be called when allowed[_spender] == 0. To decrement\r\n   * allowed value is better to use this function to avoid 2 calls (and wait until\r\n   * the first transaction is mined)\r\n   * From MonolithDAO Token.sol\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _subtractedValue The amount of tokens to decrease the allowance by.\r\n   */\r\n  function decreaseApproval(address _spender, uint256 _subtractedValue)\r\n  whenNotPaused onlyNotBlacklistedAddr(msg.sender) onlyNotBlacklistedAddr(_spender)\r\n  public returns (bool) {\r\n    _allowance.subAllowance(msg.sender, _spender, _subtractedValue);\r\n    emit Approval(msg.sender, _spender, _allowance.allowanceOf(msg.sender, _spender));\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Destroy tokens\r\n   * Remove `_value` tokens from the system irreversibly\r\n   *\r\n   * @param _value the amount of money to burn\r\n   */\r\n  function burn(uint256 _value) whenNotPaused onlyNotBlacklistedAddr(msg.sender)\r\n  public returns (bool success) {\r\n    require(_balances.balanceOf(msg.sender) >= _value);         // Check if the sender has enough\r\n    _balances.subBalance(msg.sender, _value);                   // Subtract from the sender\r\n    _balances.subTotalSupply(_value);                           // Updates totalSupply\r\n    emit Burn(msg.sender, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Change name and symbol of the tokens\r\n   *\r\n   * @param _name the new name of the token\r\n   * @param _symbol the new symbol of the token\r\n   */\r\n  function changeName(string _name, string _symbol) onlyOwner public {\r\n    name = _name;\r\n    symbol = _symbol;\r\n  }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"addAddressToCaller\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claimOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_holder\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"addAllowance\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"callers\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_holder\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"subAllowance\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_holder\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"setAllowance\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"removeAddressFromCaller\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pendingOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"CallerAddressAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"CallerAddressRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"pendingOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferPending\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"Allowance","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://569caf39693d9cc65307896ce4dae618b2beb733b92d35b04335878e308471a2"}]}