{"status":"1","message":"OK","result":[{"SourceCode":"// Multi-signature wallet for easily transfers of ETH and ERC20 tokens\r\n// Developed by Phenom.Team <info@phenom.team>\r\npragma solidity ^0.4.24;\r\n\r\n/**\r\n *   @title ERC20\r\n *   @dev Standart ERC20 token interface\r\n */\r\n\r\n /**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n    address public owner;\r\n\r\n\r\n    event OwnershipRenounced(address indexed previousOwner);\r\n    event OwnershipTransferred(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n\r\n\r\n      /**\r\n       * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n       * account.\r\n       */\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n      /**\r\n       * @dev Throws if called by any account other than the owner.\r\n       */\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"msg.sender is not Owner\");\r\n        _;\r\n    }\r\n\r\n      /**\r\n       * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n       * @param newOwner The address to transfer ownership to.\r\n       */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        require(newOwner != address(0), \"Owner must not be zero-address\");\r\n        emit OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n\r\n      /**\r\n       * @dev Allows the current owner to relinquish control of the contract.\r\n       */\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipRenounced(owner);\r\n        owner = address(0);\r\n    }\r\n}\r\n\r\ncontract ERC20 {\r\n    uint public totalSupply;\r\n\r\n    mapping(address => uint) balances;\r\n    mapping(address => mapping (address => uint)) allowed;\r\n\r\n    function balanceOf(address _owner) public view returns (uint);\r\n    function transfer(address _to, uint _value) public returns (bool);\r\n    function transferFrom(address _from, address _to, uint _value) public returns (bool);\r\n    function approve(address _spender, uint _value) public  returns (bool);\r\n    function allowance(address _owner, address _spender) public view returns (uint);\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint _value);\r\n\r\n} \r\n\r\n/// @title Multisignature wallet\r\ncontract MultiSigWallet {\r\n\r\n    //Events\r\n    event TransactionCreated(uint indexed _txId, uint indexed _timestamp, address indexed _creator);\r\n    event TranscationSended(uint indexed _txId, uint indexed _timestamp);\r\n    event TranscationSigned(uint indexed _txId, uint indexed _timestamp, address indexed _signer);\r\n    event TranscationUnsigned(uint indexed _txId, uint indexed _timestamp, address indexed _signer);\r\n    event Deposit(uint _amount, address indexed _sender);\r\n    \r\n    //Trunsaction struct\r\n    struct Transcation {\r\n        address to;\r\n        address tokenAddress; // if tx is ether transfer  token address equals address(0) \r\n        uint amount;\r\n        uint confirmations;\r\n        bool done;\r\n        mapping (address => bool) confirmed;\r\n    }\r\n\r\n    //adresses of signers\r\n    address[] public signers;\r\n    \r\n    //numbers of signs to perform tx\r\n    uint public requiredConfirmations;\r\n    \r\n    //trancations count\r\n    uint public txCount;\r\n    \r\n    //mappings\r\n    mapping (uint => Transcation) public transactions; // trancations\r\n    mapping (address => bool) isSigner; // signers\r\n\r\n    // name of the wallet\r\n    string public name;\r\n    \r\n\r\n    modifier onlySigners {\r\n        require(isSigner[msg.sender], \"msg.sender is not Signer\");\r\n        _;\r\n    } \r\n\r\n    \r\n   /**\r\n    *   @dev Contract constructor sets signers list, required number of confirmations and name of the wallet.\r\n    *   @param _signers                     signers list\r\n    *   @param _requiredConfirmations       required number of confirmations\r\n    *   @param _name                        name of the wallet\r\n    */\r\n    constructor(\r\n        address[] _signers, \r\n        uint _requiredConfirmations,\r\n        string _name\r\n    ) \r\n    public {\r\n        require( \r\n            _requiredConfirmations <= _signers.length && \r\n            _requiredConfirmations > 0,\r\n            \"required confirmations must be > 0 and less than number of signers\"\r\n        );\r\n        requiredConfirmations = _requiredConfirmations;\r\n        for (uint i = 0; i < _signers.length; i++) {\r\n            signers.push(_signers[i]);\r\n            isSigner[_signers[i]] = true;\r\n        }\r\n        name = _name;\r\n    }\r\n\r\n   /**\r\n    *   @dev Fallback function\r\n    */\r\n    function() public payable {\r\n        require(msg.value > 0, \"value must be > 0\");\r\n        emit Deposit(msg.value, msg.sender);\r\n    }\r\n    \r\n    function getSigners() public view returns (address[]) {\r\n        return signers;\r\n    }\r\n\r\n   /**\r\n    *   @dev Allows to create a new transaction\r\n    */\r\n    function createTransaction(\r\n        address _to, \r\n        address _tokenAddress,\r\n        uint _amount\r\n    ) \r\n    public \r\n    onlySigners {\r\n        txCount++;\r\n        transactions[txCount] = Transcation(\r\n            _to,\r\n            _tokenAddress,\r\n            _amount,\r\n            0,\r\n            false\r\n        );\r\n        emit TransactionCreated(txCount, now, msg.sender);\r\n        signTransaction(txCount);\r\n    }\r\n\r\n   /**\r\n    *   @dev Allows to sign a transaction\r\n    */\r\n    function signTransaction(uint _txId) public  onlySigners {\r\n        require(!transactions[_txId].confirmed[msg.sender] && _txId <= txCount, \"must be a valid unsigned tx\");\r\n        transactions[_txId].confirmed[msg.sender] = true;\r\n        transactions[_txId].confirmations++;\r\n        emit TranscationSigned(_txId, now, msg.sender);\r\n        if (transactions[_txId].confirmations >= requiredConfirmations) {\r\n            _sendTransaction(_txId);\r\n      }\r\n    }\r\n    \r\n    function getTransactionsId(\r\n        bool _pending, \r\n        bool _done,\r\n        bool _tokenTransfers,\r\n        bool _etherTransfers, \r\n        uint _tailSize\r\n    ) \r\n    public \r\n    view returns(uint[] _txIdList) {\r\n        uint[] memory tempList = new uint[](txCount);\r\n        uint count = 0;\r\n        uint id = txCount;\r\n        while(id > 0 && count < _tailSize) {\r\n            if ((_pending && !transactions[id].done || _done && transactions[id].done) && \r\n                (_tokenTransfers && transactions[id].tokenAddress != address(0) || \r\n                 _etherTransfers && transactions[id].tokenAddress == address(0))\r\n                ) \r\n                {\r\n                tempList[count] = id;\r\n                count++;\r\n                }\r\n            id--;\r\n        }\r\n        _txIdList = new uint[](count);\r\n        for (uint i = 0; i < count; i++) {\r\n            _txIdList[i] = tempList[i];\r\n        }\r\n    }\r\n\r\n    /*\r\n    *   @dev Allows to check whether tx is signed by signer\r\n    */\r\n    function isSigned(uint _txId, address _signer) \r\n        public\r\n        view\r\n        returns (bool _isSigned) \r\n    {\r\n        _isSigned = transactions[_txId].confirmed[_signer];\r\n    }\r\n    \r\n    function unsignTransaction(uint _txId) external onlySigners {\r\n        require(\r\n            transactions[_txId].confirmed[msg.sender] && \r\n            !transactions[_txId].done,\r\n            \"must be a valid signed tx\"\r\n        );\r\n        transactions[_txId].confirmed[msg.sender] = false;\r\n        transactions[_txId].confirmations--;\r\n        emit TranscationUnsigned(_txId, now, msg.sender);\r\n    }\r\n\r\n    //executing tx\r\n    function _sendTransaction(uint _txId) private {\r\n        require(!transactions[_txId].done, \"transaction must not be done\");\r\n        transactions[_txId].done = true;\r\n        if ( transactions[_txId].tokenAddress == address(0)) {\r\n            transactions[_txId].to.transfer(transactions[_txId].amount);\r\n        } else {\r\n            ERC20 token = ERC20(transactions[_txId].tokenAddress);\r\n            require(token.transfer(transactions[_txId].to, transactions[_txId].amount), \"token transfer failded\");\r\n        }\r\n        emit TranscationSended(_txId, now);\r\n    }\r\n\r\n}\r\n\r\n\r\n/// @title Multisignature wallet factory\r\ncontract MultiSigWalletCreator is Ownable() {\r\n\r\n    // wallets\r\n    mapping(address => bool) public isMultiSigWallet;\r\n\r\n    mapping(address => address[]) public wallets;\r\n\r\n    mapping(address => uint) public numberOfWallets;\r\n\r\n    // information about system\r\n    string public currentSystemInfo;\r\n\r\n    event walletCreated(address indexed _creator, address indexed _wallet);\r\n\r\n    function createMultiSigWallet(\r\n        address[] _signers, \r\n        uint _requiredConfirmations,\r\n        string _name\r\n        )\r\n        public\r\n        returns (address wallet)\r\n    {\r\n        wallet = new MultiSigWallet(_signers, _requiredConfirmations, _name);\r\n        isMultiSigWallet[wallet] = true;    \r\n        for (uint i = 0; i < _signers.length; i++) {\r\n            wallets[_signers[i]].push(wallet);\r\n            numberOfWallets[_signers[i]]++;\r\n        }\r\n        emit walletCreated(msg.sender, wallet);\r\n    }\r\n\r\n    function setCurrentSystemInfo(string _info) public onlyOwner {\r\n        currentSystemInfo = _info;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"isMultiSigWallet\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"wallets\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentSystemInfo\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_signers\",\"type\":\"address[]\"},{\"name\":\"_requiredConfirmations\",\"type\":\"uint256\"},{\"name\":\"_name\",\"type\":\"string\"}],\"name\":\"createMultiSigWallet\",\"outputs\":[{\"name\":\"wallet\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_info\",\"type\":\"string\"}],\"name\":\"setCurrentSystemInfo\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"numberOfWallets\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_creator\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_wallet\",\"type\":\"address\"}],\"name\":\"walletCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"}],\"name\":\"OwnershipRenounced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"MultiSigWalletCreator","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://1e10e99d6228ce2e2c5b2c54b72dd52232f44148801daed15efcfca55bac0afd"}]}