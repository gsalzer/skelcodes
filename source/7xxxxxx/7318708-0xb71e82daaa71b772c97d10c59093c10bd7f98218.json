{"status":"1","message":"OK","result":[{"SourceCode":"/*\r\n * Kryptium House Smart Contract v.1.1.0\r\n * Copyright Â© 2019 Kryptium Team <info@kryptium.io>\r\n * Author: Giannis Zarifis <jzarifis@kryptium.io>\r\n * \r\n * A decentralised betting house in the form of an Ethereum smart contract which \r\n * registers bets, escrows the amounts wagered and transfers funds following the \r\n * outcomes of the corresponding events. It can be fully autonomous or managed \r\n * and might charge a commission for its services.\r\n *\r\n * This program is free to use according the Terms of Use available at\r\n * <https://kryptium.io/terms-of-use/>. You cannot resell it or copy any\r\n * part of it or modify it without permission from the Kryptium Team.\r\n *\r\n * This program is distributed in the hope that it will be useful, but WITHOUT \r\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\r\n * FOR A PARTICULAR PURPOSE. See the Terms and Conditions for more details.\r\n */\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * SafeMath\r\n * Math operations with safety checks that throw on error\r\n */\r\ncontract SafeMath {\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a * b;\r\n        assert(a == 0 || c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b != 0); // Solidity automatically throws when dividing by 0\r\n        uint256 c = a / b;\r\n        assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n\r\n    function mulByFraction(uint256 number, uint256 numerator, uint256 denominator) internal pure returns (uint256) {\r\n        return div(mul(number, numerator), denominator);\r\n    }\r\n}\r\n\r\ncontract Owned {\r\n\r\n    address public owner;\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address newOwner) onlyOwner public {\r\n        require(newOwner != address(0x0));\r\n        owner = newOwner;\r\n    }\r\n}\r\n\r\n/*\r\nOracle smart contract interface\r\n*/\r\ninterface OracleContract {\r\n    function eventOutputs(uint eventId, uint outputId) external view returns (bool isSet, string memory title, uint possibleResultsCount, uint  eventOutputType, string memory announcement, uint decimals); \r\n    function owner() external view returns (address);\r\n    function getEventForHousePlaceBet(uint id) external view returns (uint closeDateTime, uint freezeDateTime, bool isCancelled); \r\n    function getEventOutcomeIsSet(uint eventId, uint outputId) external view returns (bool isSet);\r\n    function getEventOutcome(uint eventId, uint outputId) external view returns (uint outcome); \r\n    function getEventOutcomeNumeric(uint eventId, uint outputId) external view returns(uint256 outcome1, uint256 outcome2,uint256 outcome3,uint256 outcome4, uint256 outcome5, uint256 outcome6);\r\n}\r\n\r\n/*\r\nHouse smart contract interface\r\n*/\r\ninterface HouseContract {\r\n    function owner() external view returns (address); \r\n    function isHouse() external view returns (bool); \r\n}\r\n\r\n\r\n\r\n/*\r\n * Kryptium House Smart Contract.\r\n */\r\ncontract House is SafeMath, Owned {\r\n\r\n    //enum Category { football, basket }\r\n\r\n    enum BetType { headtohead, multiuser, poolbet }\r\n\r\n    enum BetEvent { placeBet, callBet, removeBet, refuteBet, settleWinnedBet, settleCancelledBet, increaseWager, cancelledByHouse }\r\n\r\n    uint private betNextId;\r\n\r\n\r\n    struct Bet { \r\n        uint id;\r\n        address oracleAddress;\r\n        uint eventId;\r\n        uint outputId;\r\n        uint outcome;\r\n        bool isOutcomeSet;\r\n        uint closeDateTime;\r\n        uint freezeDateTime;\r\n        bool isCancelled;\r\n        uint256 minimumWager;\r\n        uint256 maximumWager;\r\n        uint256 payoutRate;\r\n        address createdBy;\r\n        BetType betType;\r\n    } \r\n\r\n\r\n    struct HouseData { \r\n        bool managed;\r\n        string  name;\r\n        string  creatorName;\r\n        string  countryISO; \r\n        address oracleAddress;\r\n        address oldOracleAddress;       \r\n        bool  newBetsPaused;\r\n        uint  housePercentage;\r\n        uint oraclePercentage;   \r\n        uint version;\r\n        string shortMessage;              \r\n    } \r\n\r\n    address public _newHouseAddress;\r\n\r\n    HouseData public houseData;  \r\n\r\n    // This creates an array with all bets\r\n    mapping (uint => Bet) public bets;\r\n\r\n    //Last betting activity timestamp\r\n    uint public lastBettingActivity;\r\n\r\n    //Total bets\r\n    uint public totalBets;\r\n\r\n    //Total amount played on bets\r\n    uint public totalAmountOnBets;\r\n\r\n    //Total amount on Bet\r\n    mapping (uint => uint256) public betTotalAmount;\r\n\r\n    //Totalbets on bet\r\n    mapping (uint => uint) public betTotalBets;\r\n\r\n    //Bet Refutes amount\r\n    mapping (uint => uint256) public betRefutedAmount;\r\n\r\n    //Total amount placed on a bet forecast\r\n    mapping (uint => mapping (uint => uint256)) public betForcastTotalAmount;    \r\n\r\n    //Player bet total amount on a Bet\r\n    mapping (address => mapping (uint => uint256)) public playerBetTotalAmount;\r\n\r\n    //Player bet total bets on a Bet\r\n    mapping (address => mapping (uint => uint)) public playerBetTotalBets;\r\n\r\n    //Player wager for a Bet.Output.Forecast\r\n    mapping (address => mapping (uint => mapping (uint => uint256))) public playerBetForecastWager;\r\n\r\n    //head to head bets forecasts\r\n    mapping (uint => mapping (address => uint)) public headToHeadForecasts;  \r\n\r\n    //head to head bets max accepted forecasts\r\n    mapping (uint => uint) public headToHeadMaxAcceptedForecasts;  \r\n\r\n    //Player output(cause or win or refund)  of a bet\r\n    mapping (address => mapping (uint => uint256)) public playerOutputFromBet;    \r\n\r\n    //Player bet Refuted\r\n    mapping (address => mapping (uint => bool)) public playerBetRefuted;    \r\n\r\n    //Player bet Settled\r\n    mapping (address => mapping (uint => bool)) public playerBetSettled; \r\n\r\n\r\n    //Total bets placed by player\r\n    mapping (address => uint) public totalPlayerBets;\r\n\r\n\r\n    //Total amount placed for bets by player\r\n    mapping (address => uint256) public totalPlayerBetsAmount;\r\n\r\n    // User balances\r\n    mapping (address => uint256) public balance;\r\n\r\n    // Stores the house owners percentage as part per thousand \r\n    mapping (address => uint) public ownerPerc;\r\n\r\n    //The array of house owners\r\n    address[] public owners;\r\n\r\n    //The House and Oracle edge has been paid\r\n    mapping (uint => bool) public housePaid;\r\n\r\n    //The total remaining House amount collected from fees for Bet\r\n    mapping (uint => uint256) public houseEdgeAmountForBet;\r\n\r\n    //The total remaining Oracle amount collected from fees for Bet\r\n    mapping (uint => uint256) public oracleEdgeAmountForBet;\r\n\r\n    //The total House fees\r\n    uint256 public houseTotalFees;\r\n\r\n    //The total Oracle fees\r\n    mapping (address => uint256) public oracleTotalFees;\r\n\r\n    // Notifies clients that a new house is launched\r\n    event HouseCreated();\r\n\r\n    // Notifies clients that a house data has changed\r\n    event HousePropertiesUpdated();    \r\n\r\n    event BetPlacedOrModified(uint id, address sender, BetEvent betEvent, uint256 amount, uint forecast, string createdBy, uint closeDateTime);\r\n\r\n\r\n    event transfer(address indexed wallet, uint256 amount,bool inbound);\r\n\r\n    event testevent(uint betTotalAmount, uint AcceptedWager, uint headToHeadForecastsOPEN, uint matchedANDforecast, uint matchedORforecast, uint headToHeadMaxAcceptedForecast);\r\n\r\n\r\n    /**\r\n     * Constructor function\r\n     * Initializes House contract\r\n     */\r\n    constructor(bool managed, string memory houseName, string memory houseCreatorName, string memory houseCountryISO, address oracleAddress, address[] memory ownerAddress, uint[] memory ownerPercentage, uint housePercentage,uint oraclePercentage, uint version) public {\r\n        require(add(housePercentage,oraclePercentage)<1000,\"House + Oracle percentage should be lower than 100%\");\r\n        houseData.managed = managed;\r\n        houseData.name = houseName;\r\n        houseData.creatorName = houseCreatorName;\r\n        houseData.countryISO = houseCountryISO;\r\n        houseData.housePercentage = housePercentage;\r\n        houseData.oraclePercentage = oraclePercentage; \r\n        houseData.oracleAddress = oracleAddress;\r\n        houseData.shortMessage = \"\";\r\n        houseData.newBetsPaused = true;\r\n        houseData.version = version;\r\n        uint ownersTotal = 0;\r\n        for (uint i = 0; i<ownerAddress.length; i++) {\r\n            owners.push(ownerAddress[i]);\r\n            ownerPerc[ownerAddress[i]] = ownerPercentage[i];\r\n            ownersTotal += ownerPercentage[i];\r\n            }\r\n        require(ownersTotal == 1000);    \r\n        emit HouseCreated();\r\n    }\r\n\r\n\r\n\r\n    /**\r\n     * Check if valid house contract\r\n     */\r\n    function isHouse() public pure returns(bool response) {\r\n        return true;    \r\n    }\r\n\r\n     /**\r\n     * Updates House Data function\r\n     *\r\n     */\r\n    function updateHouseProperties(string memory houseName, string memory houseCreatorName, string memory houseCountryISO) onlyOwner public {\r\n        houseData.name = houseName;\r\n        houseData.creatorName = houseCreatorName;\r\n        houseData.countryISO = houseCountryISO;     \r\n        emit HousePropertiesUpdated();\r\n    }    \r\n\r\n    /**\r\n     * Updates House Oracle function\r\n     *\r\n     */\r\n    function changeHouseOracle(address oracleAddress, uint oraclePercentage) onlyOwner public {\r\n        require(add(houseData.housePercentage,oraclePercentage)<1000,\"House + Oracle percentage should be lower than 100%\");\r\n        if (oracleAddress != houseData.oracleAddress) {\r\n            houseData.oldOracleAddress = houseData.oracleAddress;\r\n            houseData.oracleAddress = oracleAddress;\r\n        }\r\n        houseData.oraclePercentage = oraclePercentage;\r\n        emit HousePropertiesUpdated();\r\n    } \r\n\r\n    /**\r\n     * Updates House percentage function\r\n     *\r\n     */\r\n    function changeHouseEdge(uint housePercentage) onlyOwner public {\r\n        require(housePercentage != houseData.housePercentage,\"New percentage is identical with current\");\r\n        require(add(housePercentage,houseData.oraclePercentage)<1000,\"House + Oracle percentage should be lower than 100%\");\r\n        houseData.housePercentage = housePercentage;\r\n        emit HousePropertiesUpdated();\r\n    } \r\n\r\n\r\n\r\n    function updateBetDataFromOracle(uint betId) private {\r\n        if (!bets[betId].isOutcomeSet) {\r\n            (bets[betId].isOutcomeSet) = OracleContract(bets[betId].oracleAddress).getEventOutcomeIsSet(bets[betId].eventId,bets[betId].outputId); \r\n            if (bets[betId].isOutcomeSet) {\r\n                (bets[betId].outcome) = OracleContract(bets[betId].oracleAddress).getEventOutcome(bets[betId].eventId,bets[betId].outputId); \r\n            }\r\n        }     \r\n        if (!bets[betId].isCancelled) {\r\n        (bets[betId].closeDateTime, bets[betId].freezeDateTime, bets[betId].isCancelled) = OracleContract(bets[betId].oracleAddress).getEventForHousePlaceBet(bets[betId].eventId);      \r\n        }  \r\n        if (!bets[betId].isOutcomeSet && bets[betId].freezeDateTime <= now) {\r\n            bets[betId].isCancelled = true;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get the possibleResultsCount of an Event.Output as uint.\r\n     * Should be changed in a future version to use an Oracle function that directly returns possibleResultsCount instead of receive the whole eventOutputs structure\r\n     */\r\n    function getEventOutputMaxUint(address oracleAddress, uint eventId, uint outputId) private view returns (uint) {\r\n        (bool isSet, string memory title, uint possibleResultsCount, uint  eventOutputType, string memory announcement, uint decimals) = OracleContract(oracleAddress).eventOutputs(eventId,outputId);\r\n        return 2 ** possibleResultsCount - 1;\r\n    }\r\n\r\n\r\nfunction checkPayoutRate(uint256 payoutRate) public view {\r\n    uint256 multBase = 10 ** 18;\r\n    uint256 houseFees = houseData.housePercentage + houseData.oraclePercentage;\r\n    uint256 check1 = div(multBase , (1000 - houseFees));\r\n    check1 = div(mul(100000 , check1), multBase);\r\n    uint256 check2 = 10000;\r\n    if (houseFees > 0) {\r\n        check2 =  div(multBase , houseFees);\r\n        check2 = div(mul(100000 ,check2), multBase);\r\n    }\r\n    require(payoutRate>check1 && payoutRate<check2,\"Payout rate out of accepted range\");\r\n}\r\n\r\n\r\n    /*\r\n     * Place a Bet\r\n     */\r\n    function placeBet(uint eventId, BetType betType,uint outputId, uint forecast, uint256 wager, uint closingDateTime, uint256 minimumWager, uint256 maximumWager, uint256 payoutRate, string memory createdBy) public {\r\n        require(wager>0,\"Wager should be greater than zero\");\r\n        require(balance[msg.sender]>=wager,\"Not enough balance\");\r\n        require(!houseData.newBetsPaused,\"Bets are paused right now\");\r\n        require(betType == BetType.headtohead || betType == BetType.poolbet,\"Only poolbet and headtohead bets are implemented\");\r\n        betNextId += 1;\r\n        bets[betNextId].id = betNextId;\r\n        bets[betNextId].oracleAddress = houseData.oracleAddress;\r\n        bets[betNextId].outputId = outputId;\r\n        bets[betNextId].eventId = eventId;\r\n        bets[betNextId].betType = betType;\r\n        bets[betNextId].createdBy = msg.sender;\r\n        updateBetDataFromOracle(betNextId);\r\n        require(!bets[betNextId].isCancelled,\"Event has been cancelled\");\r\n        require(!bets[betNextId].isOutcomeSet,\"Event has already an outcome\");\r\n        if (closingDateTime>0) {\r\n            bets[betNextId].closeDateTime = closingDateTime;\r\n        }  \r\n        require(bets[betNextId].closeDateTime >= now,\"Close time has passed\");\r\n        if (betType == BetType.poolbet) {\r\n            if (minimumWager != 0) {\r\n                bets[betNextId].minimumWager = minimumWager;\r\n            } else {\r\n                bets[betNextId].minimumWager = wager;\r\n            }\r\n            if (maximumWager != 0) {\r\n                bets[betNextId].maximumWager = maximumWager;\r\n            }\r\n        } else if (betType == BetType.headtohead) {\r\n            checkPayoutRate(payoutRate);\r\n            uint maxAcceptedForecast = getEventOutputMaxUint(bets[betNextId].oracleAddress, bets[betNextId].eventId, bets[betNextId].outputId);\r\n            headToHeadMaxAcceptedForecasts[betNextId] = maxAcceptedForecast;\r\n            require(forecast>0 && forecast < maxAcceptedForecast,\"Forecast should be grater than zero and less than Max accepted forecast(All options true)\");\r\n            bets[betNextId].payoutRate = payoutRate;\r\n            headToHeadForecasts[betNextId][msg.sender] = forecast;\r\n        }\r\n              \r\n        playerBetTotalBets[msg.sender][betNextId] = 1;\r\n        betTotalBets[betNextId] = 1;\r\n        betTotalAmount[betNextId] = wager;\r\n        totalBets += 1;\r\n        totalAmountOnBets += wager;\r\n        if (houseData.housePercentage>0) {\r\n            houseEdgeAmountForBet[betNextId] += mulByFraction(wager, houseData.housePercentage, 1000);\r\n        }\r\n        if (houseData.oraclePercentage>0) {\r\n            oracleEdgeAmountForBet[betNextId] += mulByFraction(wager, houseData.oraclePercentage, 1000);\r\n        }\r\n\r\n        balance[msg.sender] -= wager;\r\n\r\n \r\n        betForcastTotalAmount[betNextId][forecast] = wager;\r\n\r\n        playerBetTotalAmount[msg.sender][betNextId] = wager;\r\n\r\n        playerBetForecastWager[msg.sender][betNextId][forecast] = wager;\r\n\r\n        totalPlayerBets[msg.sender] += 1;\r\n\r\n        totalPlayerBetsAmount[msg.sender] += wager;\r\n\r\n        lastBettingActivity = block.number;\r\n        \r\n        emit BetPlacedOrModified(betNextId, msg.sender, BetEvent.placeBet, wager, forecast, createdBy, bets[betNextId].closeDateTime);\r\n    }  \r\n\r\n    /*\r\n     * Call a Bet\r\n     */\r\n    function callBet(uint betId, uint forecast, uint256 wager, string memory createdBy) public {\r\n        require(wager>0,\"Wager should be greater than zero\");\r\n        require(balance[msg.sender]>=wager,\"Not enough balance\");\r\n        require(bets[betId].betType == BetType.headtohead || bets[betId].betType == BetType.poolbet,\"Only poolbet and headtohead bets are implemented\");\r\n        require(bets[betId].betType != BetType.headtohead || betTotalBets[betId] == 1,\"Head to head bet has been already called\");\r\n        require(wager>=bets[betId].minimumWager,\"Wager is lower than the minimum accepted\");\r\n        require(bets[betId].maximumWager==0 || wager<=bets[betId].maximumWager,\"Wager is higher then the maximum accepted\");\r\n        updateBetDataFromOracle(betId);\r\n        require(!bets[betId].isCancelled,\"Bet has been cancelled\");\r\n        require(!bets[betId].isOutcomeSet,\"Event has already an outcome\");\r\n        require(bets[betId].closeDateTime >= now,\"Close time has passed\");\r\n        if (bets[betId].betType == BetType.headtohead) {\r\n            require(bets[betId].createdBy != msg.sender,\"Player has been opened the bet\");\r\n            require(wager == mulByFraction( betTotalAmount[betId], bets[betId].payoutRate - 100, 100),\"Wager should be equal to [Opened bet Wager  * PayoutRate - 100]\");\r\n            require(headToHeadForecasts[betId][bets[betId].createdBy] & forecast == 0,\"Forecast overlaps opened bet forecast\");\r\n            require(headToHeadForecasts[betId][bets[betId].createdBy] | forecast == headToHeadMaxAcceptedForecasts[betId],\"Forecast should be opposite to the opened\");\r\n            headToHeadForecasts[betId][msg.sender] = forecast;           \r\n        } else if (bets[betId].betType == BetType.poolbet) {\r\n            require(playerBetForecastWager[msg.sender][betId][forecast] == 0,\"Already placed a bet on this forecast, use increaseWager method instead\");\r\n        }\r\n\r\n        betTotalBets[betId] += 1;\r\n        betTotalAmount[betId] += wager;\r\n        totalAmountOnBets += wager;\r\n        if (houseData.housePercentage>0) {\r\n            houseEdgeAmountForBet[betId] += mulByFraction(wager, houseData.housePercentage, 1000);\r\n        }\r\n        if (houseData.oraclePercentage>0) {\r\n            oracleEdgeAmountForBet[betId] += mulByFraction(wager, houseData.oraclePercentage, 1000);\r\n        }\r\n\r\n\r\n        balance[msg.sender] -= wager;\r\n\r\n        playerBetTotalBets[msg.sender][betId] += 1;\r\n\r\n        betForcastTotalAmount[betId][forecast] += wager;\r\n\r\n        playerBetTotalAmount[msg.sender][betId] += wager;\r\n\r\n        playerBetForecastWager[msg.sender][betId][forecast] = wager;\r\n\r\n        totalPlayerBets[msg.sender] += 1;\r\n\r\n        totalPlayerBetsAmount[msg.sender] += wager;\r\n\r\n        lastBettingActivity = block.number;\r\n\r\n        emit BetPlacedOrModified(betId, msg.sender, BetEvent.callBet, wager, forecast, createdBy, bets[betId].closeDateTime);   \r\n    }  \r\n\r\n    /*\r\n     * Increase wager\r\n     */\r\n    function increaseWager(uint betId, uint forecast, uint256 additionalWager, string memory createdBy) public {\r\n        require(additionalWager>0,\"Increase wager amount should be greater than zero\");\r\n        require(balance[msg.sender]>=additionalWager,\"Not enough balance\");\r\n        require(bets[betId].betType == BetType.poolbet,\"Only poolbet supports the increaseWager\");\r\n        require(playerBetForecastWager[msg.sender][betId][forecast] > 0,\"Haven't placed any bet for this forecast. Use callBet instead\");\r\n        uint256 wager = playerBetForecastWager[msg.sender][betId][forecast] + additionalWager;\r\n        require(bets[betId].maximumWager==0 || wager<=bets[betId].maximumWager,\"The updated wager is higher then the maximum accepted\");\r\n        updateBetDataFromOracle(betId);\r\n        require(!bets[betId].isCancelled,\"Bet has been cancelled\");\r\n        require(!bets[betId].isOutcomeSet,\"Event has already an outcome\");\r\n        require(bets[betId].closeDateTime >= now,\"Close time has passed\");\r\n        betTotalAmount[betId] += additionalWager;\r\n        totalAmountOnBets += additionalWager;\r\n        if (houseData.housePercentage>0) {\r\n            houseEdgeAmountForBet[betId] += mulByFraction(additionalWager, houseData.housePercentage, 1000);\r\n        }\r\n        if (houseData.oraclePercentage>0) {\r\n            oracleEdgeAmountForBet[betId] += mulByFraction(additionalWager, houseData.oraclePercentage, 1000);\r\n        }\r\n\r\n        balance[msg.sender] -= additionalWager;\r\n\r\n        betForcastTotalAmount[betId][forecast] += additionalWager;\r\n\r\n        playerBetTotalAmount[msg.sender][betId] += additionalWager;\r\n\r\n        playerBetForecastWager[msg.sender][betId][forecast] += additionalWager;\r\n\r\n        totalPlayerBetsAmount[msg.sender] += additionalWager;\r\n\r\n        lastBettingActivity = block.number;\r\n\r\n        emit BetPlacedOrModified(betId, msg.sender, BetEvent.increaseWager, additionalWager, forecast, createdBy, bets[betId].closeDateTime);       \r\n    }\r\n\r\n    /*\r\n     * Remove a Bet\r\n     */\r\n    function removeBet(uint betId, string memory createdBy) public {\r\n        require(bets[betId].createdBy == msg.sender,\"Caller and player created don't match\");\r\n        require(playerBetTotalBets[msg.sender][betId] > 0, \"Player should has placed at least one bet\");\r\n        require(betTotalBets[betId] == playerBetTotalBets[msg.sender][betId],\"The bet has been called by other player\");\r\n        require(bets[betId].betType == BetType.headtohead || bets[betId].betType == BetType.poolbet,\"Only poolbet and headtohead bets are implemented\");\r\n        updateBetDataFromOracle(betId);  \r\n        bets[betId].isCancelled = true;\r\n        uint256 wager = betTotalAmount[betId];\r\n        betTotalBets[betId] = 0;\r\n        betTotalAmount[betId] = 0;\r\n        totalBets -= playerBetTotalBets[msg.sender][betId];\r\n        totalAmountOnBets -= wager;\r\n        houseEdgeAmountForBet[betId] = 0;\r\n        oracleEdgeAmountForBet[betId] = 0;\r\n        balance[msg.sender] += wager;\r\n        playerBetTotalAmount[msg.sender][betId] = 0;\r\n        totalPlayerBets[msg.sender] -= playerBetTotalBets[msg.sender][betId];\r\n        totalPlayerBetsAmount[msg.sender] -= wager;\r\n        playerBetTotalBets[msg.sender][betId] = 0;\r\n        lastBettingActivity = block.number;       \r\n        emit BetPlacedOrModified(betId, msg.sender, BetEvent.removeBet, wager, 0, createdBy, bets[betId].closeDateTime);      \r\n    } \r\n\r\n    /*\r\n     * Refute a Bet\r\n     */\r\n    function refuteBet(uint betId, string memory createdBy) public {\r\n        require(playerBetTotalAmount[msg.sender][betId]>0,\"Caller hasn't placed any bet\");\r\n        require(!playerBetRefuted[msg.sender][betId],\"Already refuted\");\r\n        require(bets[betId].betType == BetType.headtohead || bets[betId].betType == BetType.poolbet,\"Only poolbet and headtohead bets are implemented\");\r\n        updateBetDataFromOracle(betId);  \r\n        require(bets[betId].isOutcomeSet, \"Refute isn't allowed when no outcome has been set\");\r\n        require(bets[betId].freezeDateTime > now, \"Refute isn't allowed when Event freeze has passed\");\r\n        playerBetRefuted[msg.sender][betId] = true;\r\n        betRefutedAmount[betId] += playerBetTotalAmount[msg.sender][betId];\r\n        if (betRefutedAmount[betId] >= betTotalAmount[betId]) {\r\n            bets[betId].isCancelled = true;   \r\n        }\r\n        lastBettingActivity = block.number;       \r\n        emit BetPlacedOrModified(betId, msg.sender, BetEvent.refuteBet, 0, 0, createdBy, bets[betId].closeDateTime);    \r\n    } \r\n\r\n\r\n    /*\r\n     * Settle a Bet\r\n     */\r\n    function settleBet(uint betId, string memory createdBy) public {\r\n        require(playerBetTotalAmount[msg.sender][betId]>0, \"Caller hasn't placed any bet\");\r\n        require(!playerBetSettled[msg.sender][betId],\"Already settled\");\r\n        require(bets[betId].betType == BetType.headtohead || bets[betId].betType == BetType.poolbet,\"Only poolbet and headtohead bets are implemented\");\r\n        updateBetDataFromOracle(betId);\r\n        require(bets[betId].isCancelled || bets[betId].isOutcomeSet,\"Bet should be cancelled or has an outcome\");\r\n        require(bets[betId].freezeDateTime <= now,\"Bet payments are freezed\");\r\n        BetEvent betEvent;\r\n        if (bets[betId].isCancelled) {\r\n            betEvent = BetEvent.settleCancelledBet;\r\n            houseEdgeAmountForBet[betId] = 0;\r\n            oracleEdgeAmountForBet[betId] = 0;\r\n            playerOutputFromBet[msg.sender][betId] = playerBetTotalAmount[msg.sender][betId];            \r\n        } else {\r\n            if (!housePaid[betId] && houseEdgeAmountForBet[betId] > 0) {\r\n                for (uint i = 0; i<owners.length; i++) {\r\n                    balance[owners[i]] += mulByFraction(houseEdgeAmountForBet[betId], ownerPerc[owners[i]], 1000);\r\n                }\r\n                houseTotalFees += houseEdgeAmountForBet[betId];\r\n            }   \r\n            if (!housePaid[betId] && oracleEdgeAmountForBet[betId] > 0) {\r\n                address oracleOwner = HouseContract(bets[betId].oracleAddress).owner();\r\n                balance[oracleOwner] += oracleEdgeAmountForBet[betId];\r\n                oracleTotalFees[bets[betId].oracleAddress] += oracleEdgeAmountForBet[betId];\r\n            }\r\n            housePaid[betId] = true;\r\n            uint256 totalBetAmountAfterFees = betTotalAmount[betId] - houseEdgeAmountForBet[betId] - oracleEdgeAmountForBet[betId];\r\n            if (bets[betId].betType == BetType.poolbet) {\r\n                if (betForcastTotalAmount[betId][bets[betId].outcome]>0) {                  \r\n                    playerOutputFromBet[msg.sender][betId] = mulByFraction(totalBetAmountAfterFees, playerBetForecastWager[msg.sender][betId][bets[betId].outcome], betForcastTotalAmount[betId][bets[betId].outcome]);            \r\n                } else {\r\n                    playerOutputFromBet[msg.sender][betId] = playerBetTotalAmount[msg.sender][betId] - mulByFraction(playerBetTotalAmount[msg.sender][betId], houseData.housePercentage, 1000) - mulByFraction(playerBetTotalAmount[msg.sender][betId], houseData.oraclePercentage, 1000);\r\n                }\r\n            } else if (bets[betId].betType == BetType.headtohead) {\r\n                if (headToHeadForecasts[betId][msg.sender] & (2 ** bets[betId].outcome) > 0) {\r\n                    playerOutputFromBet[msg.sender][betId] = totalBetAmountAfterFees;\r\n                } else {\r\n                    playerOutputFromBet[msg.sender][betId] = 0;\r\n                }\r\n            }\r\n            require(playerOutputFromBet[msg.sender][betId] > 0,\"Settled amount should be grater than zero\");\r\n            betEvent = BetEvent.settleWinnedBet;\r\n        }      \r\n        playerBetSettled[msg.sender][betId] = true;\r\n        balance[msg.sender] += playerOutputFromBet[msg.sender][betId];\r\n        lastBettingActivity = block.number;\r\n        emit BetPlacedOrModified(betId, msg.sender, betEvent, playerOutputFromBet[msg.sender][betId],0, createdBy, bets[betId].closeDateTime);  \r\n    } \r\n\r\n    function() external payable {\r\n        balance[msg.sender] = add(balance[msg.sender],msg.value);\r\n        emit transfer(msg.sender,msg.value,true);\r\n    }\r\n\r\n\r\n    /**\r\n    * Checks if a player has betting activity on House \r\n    */\r\n    function isPlayer(address playerAddress) public view returns(bool) {\r\n        return (totalPlayerBets[playerAddress] > 0);\r\n    }\r\n\r\n    /**\r\n    * Update House short message \r\n    */\r\n    function updateShortMessage(string memory shortMessage) onlyOwner public {\r\n        houseData.shortMessage = shortMessage;\r\n        emit HousePropertiesUpdated();\r\n    }\r\n\r\n\r\n    /**\r\n    * Starts betting\r\n    */\r\n    function startNewBets(string memory shortMessage) onlyOwner public {\r\n        houseData.shortMessage = shortMessage;\r\n        houseData.newBetsPaused = false;\r\n        emit HousePropertiesUpdated();\r\n    }\r\n\r\n    /**\r\n    * Pauses betting\r\n    */\r\n    function stopNewBets(string memory shortMessage) onlyOwner public {\r\n        houseData.shortMessage = shortMessage;\r\n        houseData.newBetsPaused = true;\r\n        emit HousePropertiesUpdated();\r\n    }\r\n\r\n    /**\r\n    * Link House to a new version\r\n    */\r\n    function linkToNewHouse(address newHouseAddress) onlyOwner public {\r\n        require(newHouseAddress!=address(this),\"New address is current address\");\r\n        require(HouseContract(newHouseAddress).isHouse(),\"New address should be a House smart contract\");\r\n        _newHouseAddress = newHouseAddress;\r\n        houseData.newBetsPaused = true;\r\n        emit HousePropertiesUpdated();\r\n    }\r\n\r\n    /**\r\n    * UnLink House from a newer version\r\n    */\r\n    function unLinkNewHouse() onlyOwner public {\r\n        _newHouseAddress = address(0);\r\n        houseData.newBetsPaused = false;\r\n        emit HousePropertiesUpdated();\r\n    }\r\n\r\n    /**\r\n    * Cancels a Bet\r\n    */\r\n    function cancelBet(uint betId) onlyOwner public {\r\n        require(houseData.managed, \"Cancel available on managed Houses\");\r\n        updateBetDataFromOracle(betId);\r\n        require(bets[betId].freezeDateTime > now,\"Freeze time passed\");       \r\n        bets[betId].isCancelled = true;\r\n        emit BetPlacedOrModified(betId, msg.sender, BetEvent.cancelledByHouse, 0, 0, \"\", bets[betId].closeDateTime);  \r\n    }\r\n\r\n    /**\r\n    * Settle fees of Oracle and House for a bet\r\n    */\r\n    function settleBetFees(uint betId) onlyOwner public {\r\n        require(bets[betId].isCancelled || bets[betId].isOutcomeSet,\"Bet should be cancelled or has an outcome\");\r\n        require(bets[betId].freezeDateTime <= now,\"Bet payments are freezed\");\r\n        if (!housePaid[betId] && houseEdgeAmountForBet[betId] > 0) {\r\n            for (uint i = 0; i<owners.length; i++) {\r\n                balance[owners[i]] += mulByFraction(houseEdgeAmountForBet[betId], ownerPerc[owners[i]], 1000);\r\n            }\r\n            houseTotalFees += houseEdgeAmountForBet[betId];\r\n        }   \r\n        if (!housePaid[betId] && oracleEdgeAmountForBet[betId] > 0) {\r\n            address oracleOwner = HouseContract(bets[betId].oracleAddress).owner();\r\n            balance[oracleOwner] += oracleEdgeAmountForBet[betId];\r\n            oracleTotalFees[bets[betId].oracleAddress] += oracleEdgeAmountForBet[betId];\r\n        }\r\n        housePaid[betId] = true;\r\n    }\r\n\r\n    /**\r\n    * Withdraw the requested amount to the sender address\r\n    */\r\n    function withdraw(uint256 amount) public {\r\n        require(address(this).balance>=amount,\"Insufficient House balance. Shouldn't have happened\");\r\n        require(balance[msg.sender]>=amount,\"Insufficient balance\");\r\n        balance[msg.sender] = sub(balance[msg.sender],amount);\r\n        msg.sender.transfer(amount);\r\n        emit transfer(msg.sender,amount,false);\r\n    }\r\n\r\n    /**\r\n    * Withdraw the requested amount to an address\r\n    */\r\n    function withdrawToAddress(address payable destinationAddress,uint256 amount) public {\r\n        require(address(this).balance>=amount);\r\n        require(balance[msg.sender]>=amount,\"Insufficient balance\");\r\n        balance[msg.sender] = sub(balance[msg.sender],amount);\r\n        destinationAddress.transfer(amount);\r\n        emit transfer(msg.sender,amount,false);\r\n    }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"owners\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"betId\",\"type\":\"uint256\"},{\"name\":\"forecast\",\"type\":\"uint256\"},{\"name\":\"wager\",\"type\":\"uint256\"},{\"name\":\"createdBy\",\"type\":\"string\"}],\"name\":\"callBet\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"houseEdgeAmountForBet\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"playerAddress\",\"type\":\"address\"}],\"name\":\"isPlayer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"betId\",\"type\":\"uint256\"},{\"name\":\"createdBy\",\"type\":\"string\"}],\"name\":\"refuteBet\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"houseTotalFees\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"housePaid\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"bets\",\"outputs\":[{\"name\":\"id\",\"type\":\"uint256\"},{\"name\":\"oracleAddress\",\"type\":\"address\"},{\"name\":\"eventId\",\"type\":\"uint256\"},{\"name\":\"outputId\",\"type\":\"uint256\"},{\"name\":\"outcome\",\"type\":\"uint256\"},{\"name\":\"isOutcomeSet\",\"type\":\"bool\"},{\"name\":\"closeDateTime\",\"type\":\"uint256\"},{\"name\":\"freezeDateTime\",\"type\":\"uint256\"},{\"name\":\"isCancelled\",\"type\":\"bool\"},{\"name\":\"minimumWager\",\"type\":\"uint256\"},{\"name\":\"maximumWager\",\"type\":\"uint256\"},{\"name\":\"payoutRate\",\"type\":\"uint256\"},{\"name\":\"createdBy\",\"type\":\"address\"},{\"name\":\"betType\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"payoutRate\",\"type\":\"uint256\"}],\"name\":\"checkPayoutRate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"betId\",\"type\":\"uint256\"},{\"name\":\"createdBy\",\"type\":\"string\"}],\"name\":\"settleBet\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"playerBetTotalBets\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"betId\",\"type\":\"uint256\"}],\"name\":\"cancelBet\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"destinationAddress\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawToAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"ownerPerc\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"betId\",\"type\":\"uint256\"}],\"name\":\"settleBetFees\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"playerBetRefuted\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"shortMessage\",\"type\":\"string\"}],\"name\":\"startNewBets\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalAmountOnBets\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"headToHeadForecasts\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"betId\",\"type\":\"uint256\"},{\"name\":\"forecast\",\"type\":\"uint256\"},{\"name\":\"additionalWager\",\"type\":\"uint256\"},{\"name\":\"createdBy\",\"type\":\"string\"}],\"name\":\"increaseWager\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"betTotalBets\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"playerBetForecastWager\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isHouse\",\"outputs\":[{\"name\":\"response\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"totalPlayerBets\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unLinkNewHouse\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"oracleEdgeAmountForBet\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"playerBetTotalAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"shortMessage\",\"type\":\"string\"}],\"name\":\"stopNewBets\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"houseData\",\"outputs\":[{\"name\":\"managed\",\"type\":\"bool\"},{\"name\":\"name\",\"type\":\"string\"},{\"name\":\"creatorName\",\"type\":\"string\"},{\"name\":\"countryISO\",\"type\":\"string\"},{\"name\":\"oracleAddress\",\"type\":\"address\"},{\"name\":\"oldOracleAddress\",\"type\":\"address\"},{\"name\":\"newBetsPaused\",\"type\":\"bool\"},{\"name\":\"housePercentage\",\"type\":\"uint256\"},{\"name\":\"oraclePercentage\",\"type\":\"uint256\"},{\"name\":\"version\",\"type\":\"uint256\"},{\"name\":\"shortMessage\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"betRefutedAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"oracleTotalFees\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"playerOutputFromBet\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"oracleAddress\",\"type\":\"address\"},{\"name\":\"oraclePercentage\",\"type\":\"uint256\"}],\"name\":\"changeHouseOracle\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_newHouseAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"playerBetSettled\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"betForcastTotalAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"headToHeadMaxAcceptedForecasts\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newHouseAddress\",\"type\":\"address\"}],\"name\":\"linkToNewHouse\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"eventId\",\"type\":\"uint256\"},{\"name\":\"betType\",\"type\":\"uint8\"},{\"name\":\"outputId\",\"type\":\"uint256\"},{\"name\":\"forecast\",\"type\":\"uint256\"},{\"name\":\"wager\",\"type\":\"uint256\"},{\"name\":\"closingDateTime\",\"type\":\"uint256\"},{\"name\":\"minimumWager\",\"type\":\"uint256\"},{\"name\":\"maximumWager\",\"type\":\"uint256\"},{\"name\":\"payoutRate\",\"type\":\"uint256\"},{\"name\":\"createdBy\",\"type\":\"string\"}],\"name\":\"placeBet\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"betId\",\"type\":\"uint256\"},{\"name\":\"createdBy\",\"type\":\"string\"}],\"name\":\"removeBet\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"betTotalAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalBets\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"shortMessage\",\"type\":\"string\"}],\"name\":\"updateShortMessage\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"houseName\",\"type\":\"string\"},{\"name\":\"houseCreatorName\",\"type\":\"string\"},{\"name\":\"houseCountryISO\",\"type\":\"string\"}],\"name\":\"updateHouseProperties\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"balance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"housePercentage\",\"type\":\"uint256\"}],\"name\":\"changeHouseEdge\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastBettingActivity\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"totalPlayerBetsAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"managed\",\"type\":\"bool\"},{\"name\":\"houseName\",\"type\":\"string\"},{\"name\":\"houseCreatorName\",\"type\":\"string\"},{\"name\":\"houseCountryISO\",\"type\":\"string\"},{\"name\":\"oracleAddress\",\"type\":\"address\"},{\"name\":\"ownerAddress\",\"type\":\"address[]\"},{\"name\":\"ownerPercentage\",\"type\":\"uint256[]\"},{\"name\":\"housePercentage\",\"type\":\"uint256\"},{\"name\":\"oraclePercentage\",\"type\":\"uint256\"},{\"name\":\"version\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"HouseCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"HousePropertiesUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"betEvent\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"forecast\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"createdBy\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"closeDateTime\",\"type\":\"uint256\"}],\"name\":\"BetPlacedOrModified\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"wallet\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"inbound\",\"type\":\"bool\"}],\"name\":\"transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"betTotalAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"AcceptedWager\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"headToHeadForecastsOPEN\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"matchedANDforecast\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"matchedORforecast\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"headToHeadMaxAcceptedForecast\",\"type\":\"uint256\"}],\"name\":\"testevent\",\"type\":\"event\"}]","ContractName":"House","CompilerVersion":"v0.5.2+commit.1df8f40c","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000140000000000000000000000000000000000000000000000000000000000000018000000000000000000000000000000000000000000000000000000000000001c000000000000000000000000047e437a8a1d35529814835a55e97dbce10bd522f00000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000240000000000000000000000000000000000000000000000000000000000000001400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000067000000000000000000000000000000000000000000000000000000000000000a4e657742657420762e3300000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000d4e6577426574204576656e747300000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000d316413c82bc4a23c2b52d43504f91c15f906208000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000003e8","Library":"","SwarmSource":"bzzr://4ead4b8f341888d75451b8b7542f6eab0c5341dd8c1a3d654872100abd6d5e14"}]}