{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.7;\r\n/**\r\n    INSTRUCTION:\r\n    Send more then or equal to [minPayment] or 0.01 ETH to one of Wallet Contract address\r\n    [wallet_0, wallet_1, wallet_2], after round end send to This contract 0 ETH\r\n    transaction and if you choise won, take your winnings.\r\n\r\n    DAPP:     https://smartlottery.clab\r\n    BOT:      http://t.me/SmartLotteryGame_bot\r\n    LICENSE:  Under proprietary rights. All rights reserved.\r\n              Except <lib.SafeMath, cont.Ownable, lib.Address> under The MIT License (MIT)\r\n    AUTHOR:   http://t.me/pironmind\r\n\r\n*/\r\n\r\n/**\r\n * Utility library of inline functions on addresses\r\n */\r\nlibrary Address {\r\n    function isContract(address account) internal view returns (bool) {\r\n        uint256 size;\r\n        assembly { size := extcodesize(account) }\r\n        return size > 0;\r\n    }\r\n}\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Unsigned math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n    function mul(uint256 a, uint256 b) external pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) external pure returns (uint256) {\r\n        require(b > 0);\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) external pure returns (uint256) {\r\n        require(b <= a);\r\n        uint256 c = a - b;\r\n        return c;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) external pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n        return c;\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n/**\r\n * Interface of Secure contract\r\n */\r\ninterface ISecure {\r\n    function getRandomNumber(uint8 _limit, uint8 _totalPlayers, uint _games, uint _countTxs)\r\n    external\r\n    view\r\n    returns(uint);\r\n\r\n    function checkTrasted() external payable returns(bool);\r\n}\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    constructor () internal {\r\n        _owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), _owner);\r\n    }\r\n\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(isOwner());\r\n        _;\r\n    }\r\n\r\n    function isOwner() public view returns (bool) {\r\n        return msg.sender == _owner;\r\n    }\r\n\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0));\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\n/**\r\n * @title Wallet\r\n * @dev The Wallet contract is the payable contract with a term of life in a single round.\r\n */\r\ncontract Wallet {\r\n    using Address for address;\r\n    using SafeMath for uint256;\r\n    using SafeMath for uint8;\r\n\r\n    SmartLotteryGame public slg;\r\n\r\n    uint256 private _totalRised;\r\n    uint8 private _players;\r\n    bool closedOut = false;\r\n    uint public gameId;\r\n    uint256 public minPaymnent;\r\n\r\n    struct bet {\r\n        address wallet;\r\n        uint256 balance;\r\n    }\r\n\r\n    mapping(uint8 => bet) public bets;\r\n\r\n    modifier canAcceptPayment {\r\n        require(msg.value >= minPaymnent);\r\n        _;\r\n    }\r\n\r\n    modifier canDoTrx() {\r\n        require(Address.isContract(msg.sender) != true);\r\n        _;\r\n    }\r\n\r\n    modifier isClosedOut {\r\n        require(!closedOut);\r\n        _;\r\n    }\r\n\r\n    modifier onlyCreator() {\r\n        require(msg.sender == address(slg));\r\n        _;\r\n    }\r\n\r\n    constructor(uint _gameId, uint256 _minPayment) public {\r\n        slg = SmartLotteryGame(msg.sender);\r\n        gameId = _gameId;\r\n        minPaymnent = _minPayment;\r\n    }\r\n\r\n    function totalPlayers() public view returns(uint8) {\r\n        return _players;\r\n    }\r\n\r\n    function totalBets() public view returns(uint256) {\r\n        return _totalRised;\r\n    }\r\n\r\n    function finishDay() external onlyCreator returns(uint256) {\r\n        uint256 balance = address(this).balance;\r\n        if (balance >= minPaymnent) {\r\n            slg.getFunds.value(balance)();\r\n            return balance;\r\n        } else {\r\n            return 0;\r\n        }\r\n    }\r\n\r\n    function closeContract() external onlyCreator returns(bool) {\r\n        return closedOut = true;\r\n    }\r\n\r\n    function addPlayer(uint8 _id, address _player, uint256 _amount)\r\n    internal\r\n    returns(bool) {\r\n        bets[_id].wallet = _player;\r\n        bets[_id].balance = _amount;\r\n        return true;\r\n    }\r\n\r\n    function()\r\n    payable\r\n    canAcceptPayment\r\n    canDoTrx\r\n    isClosedOut\r\n    external {\r\n        _totalRised = _totalRised.add(msg.value);\r\n        _players = uint8((_players).add(1));\r\n        addPlayer(_players, msg.sender, msg.value);\r\n        slg.participate();\r\n    }\r\n}\r\n\r\ncontract SmartLotteryGame is Ownable {\r\n    using SafeMath for *;\r\n\r\n    event Withdrawn(address indexed requestor, uint256 weiAmount);\r\n    event Deposited(address indexed payee, uint256 weiAmount);\r\n    event WinnerWallet(address indexed wallet, uint256 bank);\r\n\r\n    address public secure;\r\n\r\n    uint public games = 1;\r\n    uint256 public minPayment = 10**16;\r\n\r\n    Wallet public wallet_0 = new Wallet(games, minPayment);\r\n    Wallet public wallet_1 = new Wallet(games, minPayment);\r\n    Wallet public wallet_2 = new Wallet(games, minPayment);\r\n\r\n    uint256 public finishTime;\r\n    uint256 constant roundDuration = 86400;\r\n\r\n    uint internal _nonceId = 0;\r\n    uint internal _maxPlayers = 100;\r\n    uint internal _tp = 0;\r\n    uint internal _winner;\r\n    uint8[] internal _particWallets = new uint8[](0);\r\n    uint256 internal _fund;\r\n    uint256 internal _commission;\r\n    uint256 internal _totalBetsWithoutCommission;\r\n\r\n    mapping(uint => Wallet) public wallets;\r\n    mapping(address => uint256) private _deposits;\r\n\r\n    struct wins{\r\n        address winner;\r\n        uint256 time;\r\n        address w0;\r\n        address w1;\r\n        address w2;\r\n    }\r\n\r\n    struct bet {\r\n        address wallet;\r\n        uint256 balance;\r\n    }\r\n\r\n    mapping(uint => wins) public gamesLog;\r\n\r\n    modifier isReady() {\r\n        require(secure != address(0));\r\n        _;\r\n    }\r\n\r\n    modifier onlyWallets() {\r\n        require(\r\n            msg.sender == address(wallet_0) ||\r\n            msg.sender == address(wallet_1) ||\r\n            msg.sender == address(wallet_2)\r\n        );\r\n        _;\r\n    }\r\n\r\n    constructor() public {\r\n        wallets[0] = wallet_0;\r\n        wallets[1] = wallet_1;\r\n        wallets[2] = wallet_2;\r\n        finishTime = now.add(roundDuration);\r\n    }\r\n\r\n    function _deposit(address payee, uint256 amount) internal {\r\n        _deposits[payee] = _deposits[payee].add(amount);\r\n        emit Deposited(payee, amount);\r\n    }\r\n\r\n    function _raiseFunds() internal returns (uint256) {\r\n        _fund = _fund.add(wallet_0.finishDay());\r\n        _fund = _fund.add(wallet_1.finishDay());\r\n        return _fund.add(wallet_2.finishDay());\r\n    }\r\n\r\n    function _winnerSelection() internal {\r\n        uint8 winner;\r\n        for(uint8 i=0; i<3; i++) {\r\n            if(wallets[i].totalPlayers() > 0) {\r\n                _particWallets.push(i);\r\n            }\r\n        }\r\n        // random choose one of three wallets\r\n        winner = uint8(ISecure(secure)\r\n            .getRandomNumber(\r\n                uint8(_particWallets.length),\r\n                uint8(_tp),\r\n                uint(games),\r\n                _nonceId\r\n            ));\r\n\r\n        _winner = _particWallets[winner];\r\n    }\r\n\r\n    function _distribute() internal {\r\n        bet memory p;\r\n\r\n        _tp = wallets[_winner].totalPlayers();\r\n        uint256 accommulDeposit = 0;\r\n        uint256 percents = 0;\r\n        uint256 onDeposit = 0;\r\n\r\n        _commission = _fund.mul(15).div(100);\r\n        _totalBetsWithoutCommission = _fund.sub(_commission);\r\n\r\n        for (uint8 i = 1; i <= _tp; i++) {\r\n            (p.wallet, p.balance) = wallets[_winner].bets(i);\r\n            percents = (p.balance)\r\n            .mul(10000)\r\n            .div(wallets[_winner].totalBets());\r\n            onDeposit = _totalBetsWithoutCommission\r\n            .mul(percents)\r\n            .div(10000);\r\n            accommulDeposit = accommulDeposit.add(onDeposit);\r\n            _deposit(p.wallet, onDeposit);\r\n        }\r\n        _deposit(owner(), _fund.sub(accommulDeposit));\r\n    }\r\n\r\n    function _cleanState() internal {\r\n        _fund = 0;\r\n        _particWallets = new uint8[](0);\r\n    }\r\n\r\n    function _log(address winner, uint256 fund) internal {\r\n        gamesLog[games].winner = winner;\r\n        gamesLog[games].time = now;\r\n        gamesLog[games].w0 = address(wallet_0);\r\n        gamesLog[games].w1 = address(wallet_1);\r\n        gamesLog[games].w2 = address(wallet_2);\r\n        emit WinnerWallet(winner, fund);\r\n    }\r\n\r\n    function _paymentValidator(address _payee, uint256 _amount) internal {\r\n        if(_payee != address(wallet_0) &&\r\n        _payee != address(wallet_1) &&\r\n        _payee != address(wallet_2))\r\n        {\r\n            if(_amount == uint(0)) {\r\n                if(depositOf(_payee) != uint(0)) {\r\n                    withdraw();\r\n                } else {\r\n                    revert(\"You have zero balance\");\r\n                }\r\n            } else {\r\n                revert(\"You can't do nonzero transaction\");\r\n            }\r\n        }\r\n    }\r\n\r\n    function _closeWallets() internal returns (bool) {\r\n        wallets[0].closeContract();\r\n        wallets[1].closeContract();\r\n        return wallets[2].closeContract();\r\n    }\r\n\r\n    function _issueWallets() internal returns (bool) {\r\n        wallets[0] = wallet_0 = new Wallet(games, minPayment);\r\n        wallets[1] = wallet_1 = new Wallet(games, minPayment);\r\n        wallets[2] = wallet_2 = new Wallet(games, minPayment);\r\n        return true;\r\n    }\r\n\r\n    function _switchWallets() internal {\r\n        if(_closeWallets()) {\r\n            _issueWallets();\r\n        } else { revert(\"break on switch\");}\r\n    }\r\n\r\n    function _totalPlayers() internal view returns(uint) {\r\n        return wallets[0].totalPlayers()\r\n        .add(wallets[1].totalPlayers())\r\n        .add(wallets[2].totalPlayers());\r\n    }\r\n\r\n    function depositOf(address payee) public view returns (uint256) {\r\n        return _deposits[payee];\r\n    }\r\n\r\n    function lastWinner() public view returns(address) {\r\n        return gamesLog[games].winner;\r\n    }\r\n\r\n    function participate()\r\n    external\r\n    onlyWallets\r\n    isReady\r\n    {\r\n        _nonceId = _nonceId.add(1);\r\n        _tp = _totalPlayers();\r\n\r\n        if (now >= finishTime && 1 == _tp) {\r\n            finishTime = now.add(roundDuration);\r\n            return;\r\n        }\r\n\r\n        if (now >= finishTime || _tp >= _maxPlayers) {\r\n            // send all funds to this wallet\r\n            _fund = _raiseFunds();\r\n            // if it has participators\r\n            if(_fund > 0) {\r\n                // get winner\r\n                _winnerSelection();\r\n                // do distribute\r\n                _distribute();\r\n                // log data\r\n                _log(address(wallets[_winner]), _fund);\r\n                // clear state\r\n                _cleanState();\r\n                // update round\r\n                finishTime = now.add(roundDuration);\r\n                // set next game\r\n                games = games.add(1);\r\n                // issue new wallets\r\n                return _switchWallets();\r\n            }\r\n        }\r\n    }\r\n\r\n    function setMinPayment(uint256 _value) public onlyOwner {\r\n        minPayment = _value;\r\n    }\r\n\r\n    function setSecure(address _address) public onlyOwner returns (bool) {\r\n        secure = _address;\r\n        return true;\r\n    }\r\n\r\n    function withdraw() public {\r\n        uint256 payment = _deposits[msg.sender];\r\n        _deposits[msg.sender] = 0;\r\n        msg.sender.transfer(payment);\r\n        emit Withdrawn(msg.sender, payment);\r\n    }\r\n\r\n    function getFunds() public payable onlyWallets {}\r\n\r\n    function() external payable {\r\n        _paymentValidator(msg.sender, msg.value);\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"payee\",\"type\":\"address\"}],\"name\":\"depositOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minPayment\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"getFunds\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"gamesLog\",\"outputs\":[{\"name\":\"winner\",\"type\":\"address\"},{\"name\":\"time\",\"type\":\"uint256\"},{\"name\":\"w0\",\"type\":\"address\"},{\"name\":\"w1\",\"type\":\"address\"},{\"name\":\"w2\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"finishTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"setSecure\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"setMinPayment\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"wallet_2\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"wallets\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"games\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"secure\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"wallet_1\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"participate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"wallet_0\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastWinner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"requestor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"weiAmount\",\"type\":\"uint256\"}],\"name\":\"Withdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"payee\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"weiAmount\",\"type\":\"uint256\"}],\"name\":\"Deposited\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"wallet\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"bank\",\"type\":\"uint256\"}],\"name\":\"WinnerWallet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"SmartLotteryGame","CompilerVersion":"v0.5.7+commit.6da8b019","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"SafeMath:231773551c008D9DF068E8742691C52d1D86b2FE","SwarmSource":"bzzr://d922317975b5a24ae61ef4e188616a60a43a5f1f8363b9520dd1e80672185f0b"}]}