{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity >=0.4.21 <0.6.0;\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Unsigned math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Multiplies two unsigned integers, reverts on overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Adds two unsigned integers, reverts on overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\r\n     * reverts when dividing by zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n/**\r\n * @title ERC20Old interface\r\n */\r\ncontract IERC20Old {\r\n  function totalSupply() public view returns (uint256);\r\n\r\n  function balanceOf(address who) public view returns (uint256);\r\n  \r\n  function transfer(address to, uint256 value) public;\r\n  \r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ninterface IERC20 {\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n\r\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address who) external view returns (uint256);\r\n\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ncontract DecenterPayouts {\r\n\r\n    using SafeMath for uint256;\r\n\r\n    address public owner;\r\n    IERC20 public daiContract;\r\n\r\n    uint public totalCompensation = 0;\r\n    uint public daiBalanceAllocated = 0;\r\n\r\n    mapping(address => uint) public shares;\r\n    mapping(address => uint) public balances;\r\n    mapping(address => uint) public daiBalances;\r\n    \r\n    address[] public allAddresses;\r\n\r\n// ---------------------------------------------------------------------------------------------\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    modifier ifDaiBalanceNeedUpdate() {\r\n        if (daiBalanceAllocated < daiContract.balanceOf(address(this))) _;\r\n    }\r\n\r\n// ---------------------------------------------------------------------------------------------\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n        // not sure if we should allow this address to be changed\r\n        // because maybe at some point DAI might move to other token standard with some way of transition of tokens\r\n        // but we can deploy new contract if that happens\r\n        daiContract = IERC20(0x89d24A6b4CcB1B6fAA2625fE562bDD9a23260359);    \r\n\r\n        setShareForAddress(0xad79cc871f62409A3aB55C390bd34439e4fC1101, 2000);\r\n        setShareForAddress(0x00158A74921620b39E5c3aFE4dca79feb2c2C143, 2000);\r\n        setShareForAddress(0xD9020855796503009540D924EAaa571C24e003eB, 2000);\r\n        setShareForAddress(0x005cE84caA772a1a87607Fa47f9bAfA457980b20, 2000);\r\n        setShareForAddress(0x1955c2b76b1cF245795950e75eB176080879Da50, 2000);\r\n        setShareForAddress(0x4bB9A1E3bA4AEe6F6bb76De1384E7417fd2C9Dc2, 2000);\r\n        setShareForAddress(0x575F0F46C427EE49dC1fE04874e661dB161AC54E, 1800);\r\n        setShareForAddress(0xd408FB6eFAba343A527b64c0f9d1D730d11717F4, 1500);\r\n        setShareForAddress(0x46015322832a58fA12e669a1ABffa4b63251EEe6, 1400);\r\n        setShareForAddress(0x3e5598681E03026d785215adfB3173acF3Cf2B60, 1200);\r\n    }\r\n\r\n// ---------------------------------------------------------------------------------------------\r\n\r\n    function setNewOwner(address _owner) public onlyOwner {\r\n        // just in case that its sent by accident\r\n        require(_owner != address(0));\r\n        \r\n        owner = _owner;\r\n    }\r\n       \r\n    // should take care that setting shares to 0 will disable possibility to withdraw for that user\r\n    // make sure that specific user doesn't have balance or daiBalance\r\n    // only owner can set shares (set to 0 if you want to remove user)\r\n    function setShareForAddress(address _to, uint _share) public onlyOwner {\r\n        // it will be done only if needed\r\n        // but needs to allocate DAI balance before shares are changed\r\n        updateDaiBalance();\r\n\r\n        if (shares[_to] == 0) {\r\n            addAddress(_to);\r\n        }\r\n\r\n        totalCompensation = totalCompensation.sub(shares[_to]);\r\n        totalCompensation = totalCompensation.add(_share);\r\n        shares[_to] = _share;\r\n\r\n        if (_share == 0) {\r\n            removeAddress(_to);\r\n        }\r\n    }\r\n\r\n    function () external payable {\r\n        \r\n        allocateBalance(msg.value, false);\r\n    }\r\n\r\n    // only update if DAI contract is added and if it is needed\r\n    function updateDaiBalance() public ifDaiBalanceNeedUpdate {\r\n        uint daiBalance = daiContract.balanceOf(address(this));\r\n        uint toAllocate = daiBalance.sub(daiBalanceAllocated);\r\n\r\n        allocateBalance(toAllocate, true);\r\n\r\n        daiBalanceAllocated = daiBalance;\r\n    }\r\n\r\n    function withdraw() public {\r\n        require(shares[msg.sender] > 0);\r\n        \r\n        // it will be done only if needed\r\n        // but needs to allocate DAI balance before someone withdraws part of it\r\n        updateDaiBalance();\r\n        \r\n        // withdraw ether balance\r\n        uint val = balances[msg.sender];\r\n        balances[msg.sender] = 0;\r\n        if (val > 0) {\r\n            msg.sender.transfer(val);\r\n        }\r\n\r\n        // withdraw DAI balance\r\n        val = daiBalances[msg.sender];\r\n        daiBalances[msg.sender] = 0;\r\n        // contracts DAI balance is changing, so we need to change daiBalanceAllocated also\r\n        daiBalanceAllocated -= val;\r\n        if (val > 0) {\r\n           daiContract.transfer(msg.sender, val);\r\n        }\r\n    }\r\n\r\n    // bool _new says if token returns bool on transfer method, most tokens are considered as new\r\n    function withdrawOtherTokens(address _tokenAddress, bool _new) public onlyOwner {\r\n        if (_new){\r\n            // current erc20 returns bool if transfer succeeded\r\n            IERC20 token = IERC20(_tokenAddress);\r\n            uint val = token.balanceOf(address(this));\r\n\r\n            require(token.transfer(msg.sender, val));\r\n        } else {\r\n            // old erc20 doesn't return bool if it succeeded or not\r\n            IERC20Old token = IERC20Old(_tokenAddress);\r\n            uint val = token.balanceOf(address(this));\r\n\r\n            token.transfer(msg.sender, val);\r\n        }\r\n    }\r\n    \r\n    function withdrawEther() public onlyOwner {\r\n\r\n        msg.sender.transfer(address(this).balance);\r\n    }\r\n\r\n// ---------------------------------------------------------------------------------------------\r\n\r\n    function allocateBalance(uint _val, bool _dai) private {\r\n        uint count = allAddresses.length;\r\n\r\n        for (uint i=0; i<count; i++) {\r\n            address _adr = allAddresses[i];\r\n            uint part = _val.mul(shares[_adr]).div(totalCompensation);\r\n\r\n            if (_dai) {\r\n                daiBalances[_adr] += part;\r\n            } else {\r\n                balances[_adr] += part;\r\n            }\r\n        }\r\n    }  \r\n    \r\n    function addAddress(address _address) private {\r\n        allAddresses.push(_address);\r\n    }\r\n\r\n    function removeAddress(address _address) private {\r\n        uint count = allAddresses.length;\r\n        uint pos = count+1;\r\n\r\n        for (uint i=0; i<count; i++) {\r\n            if (_address == allAddresses[i]) {\r\n                pos = i;\r\n                break;\r\n            }\r\n        }\r\n\r\n        // if count is 0, this will always fail\r\n        require(pos < count);\r\n        \r\n        allAddresses[pos] = allAddresses[count - 1];\r\n        delete allAddresses[count - 1];\r\n        allAddresses.length--;\r\n    }        \r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"balances\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"daiContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_share\",\"type\":\"uint256\"}],\"name\":\"setShareForAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"daiBalanceAllocated\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawEther\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"updateDaiBalance\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"shares\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"name\":\"_new\",\"type\":\"bool\"}],\"name\":\"withdrawOtherTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"allAddresses\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"daiBalances\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalCompensation\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"setNewOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"}]","ContractName":"DecenterPayouts","CompilerVersion":"v0.5.1+commit.c8a2cb62","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://7a1306c0f9ac0c8f36945e6483cb0ed340454dc9a95c2d73718eb24c5f9f1db0"}]}