{"status":"1","message":"OK","result":[{"SourceCode":"/*\r\n\r\nIntroducing \"STAKE THEM ALL\" Version 1.0\r\n\"STAKE THEM ALL\" is playable @ https://stakethemall.io (Ethereum Edition) and https://trx.stakethemall.io (TRON Edition)\r\n\r\nAbout the game :\r\n\r\n\"STAKE THEM ALL\" IS A FUN AND REWARDING PHYSICS GAME RUNNING ON THE BLOCKCHAIN\r\nHAVE FUN WHILE PARTICIPATING TO THE HDX20 TOKEN PRICE APPRECIATION @ https://hdx20.io\r\n\r\nHow to play \"STAKE THEM ALL\":\r\n\r\nChallenge MODE\r\n--------------\r\nSet the difficulty of your CHALLENGE by choosing how many cube you want\r\nto stack on top of each other and get rewarded on success.\r\n\r\nBuilder MODE\r\n------------\r\nStack 15 cubes in order to reach the maximum height. \r\nThe best score, if not beaten within a 24H countdown, wins the whole POT.   \r\n   \r\n\r\nThis product is copyrighted. Any unauthorized copy, modification, or use without express written consent from HyperDevbox is prohibited.\r\n\r\nCopyright 2019 HyperDevbox\r\n\r\n*/\r\n\r\n\r\n\r\n\r\npragma solidity ^0.4.25;\r\n\r\n\r\ninterface HDX20Interface\r\n{\r\n    function() payable external;\r\n    \r\n    \r\n    function buyTokenFromGame( address _customerAddress , address _referrer_address ) payable external returns(uint256);\r\n  \r\n    function payWithToken( uint256 _eth , address _player_address ) external returns(uint256);\r\n  \r\n    function appreciateTokenPrice() payable external;\r\n   \r\n    function totalSupply() external view returns(uint256); \r\n    \r\n    function ethBalanceOf(address _customerAddress) external view returns(uint256);\r\n  \r\n    function balanceOf(address _playerAddress) external view returns(uint256);\r\n    \r\n    function sellingPrice( bool includeFees) external view returns(uint256);\r\n  \r\n}\r\n\r\n\r\n\r\ncontract stakethemall\r\n{\r\n     HDX20Interface private HDXcontract = HDX20Interface(0x8942a5995bd168f347f7ec58f25a54a9a064f882);\r\n     \r\n     using SafeMath for uint256;\r\n     using SafeMath128 for uint128;\r\n     \r\n     /*==============================\r\n    =            EVENTS            =\r\n    ==============================*/\r\n    event OwnershipTransferred(\r\n        \r\n         address previousOwner,\r\n         address nextOwner,\r\n          uint256 timeStamp\r\n         );\r\n         \r\n    event HDXcontractChanged(\r\n        \r\n         address previous,\r\n         address next,\r\n         uint256 timeStamp\r\n         );\r\n \r\n  \r\n    \r\n\t    \r\n     event onWithdrawGains(\r\n        address customerAddress,\r\n        uint256 ethereumWithdrawn,\r\n        uint256 timeStamp\r\n    );\r\n    \r\n     event onBuyMode1(\r\n        address     customerAddress,\r\n        uint256     BatchID,\r\n        uint256     BatchBlockTimeout,  \r\n        uint32      Challenge\r\n        );  \r\n        \r\n    event onBuyMode2(\r\n        address     customerAddress,\r\n        uint256     BatchID,\r\n        uint256     BatchBlockTimeout,  \r\n        uint256     nb_token\r\n        );   \r\n        \r\n    event onNewScoreMode1(\r\n        uint256 score,\r\n        address customerAddress,\r\n        uint256 winning,\r\n        uint256 nb_token\r\n    ); \r\n    \r\n    event onNewScoreMode2(\r\n        uint256 score,\r\n        address       customerAddress,\r\n        bool    newHighscore\r\n      \r\n    ); \r\n        \r\n  \r\n        \r\n    event onChangeMinimumPrice(\r\n        \r\n         uint256 minimum,\r\n         uint256 timeStamp\r\n         );\r\n         \r\n  \r\n      event onChangeBlockTimeout(\r\n        \r\n         uint32 b1,\r\n         uint32 b2\r\n         );\r\n         \r\n        event onChangeTreasurePercentage(\r\n        \r\n         uint32 percentage\r\n         );\r\n         \r\n       \r\n         \r\n    /*==============================\r\n    =            MODIFIERS         =\r\n    ==============================*/\r\n    modifier onlyOwner\r\n    {\r\n        require (msg.sender == owner );\r\n        _;\r\n    }\r\n    \r\n    modifier onlyFromHDXToken\r\n    {\r\n        require (msg.sender == address( HDXcontract ));\r\n        _;\r\n    }\r\n   \r\n     modifier onlyDirectTransaction\r\n    {\r\n        require (msg.sender == tx.origin);\r\n        _;\r\n    }\r\n\r\n  \r\n    address public owner;\r\n  \r\n   \r\n    address public signerAuthority = 0xf77444cE64f3F46ba6b63F6b9411dF9c589E3319;\r\n   \r\n    \r\n\r\n    constructor () public\r\n    {\r\n        owner = msg.sender;\r\n       \r\n        GameRoundData.extraData[0] = 20; //mode1 20%\r\n        GameRoundData.extraData[1] = 0; //mode2 current highscore\r\n\t    GameRoundData.extraData[2] = uint32((3600*1) / 15);     //1 hour\r\n\t    GameRoundData.extraData[3] = uint32((3600*24) / 15);     //24 hour\r\n        \r\n        \r\n        if ( address(this).balance > 0)\r\n        {\r\n            owner.transfer( address(this).balance );\r\n        }\r\n    }\r\n    \r\n    function changeOwner(address _nextOwner) public\r\n    onlyOwner\r\n    {\r\n        require (_nextOwner != owner);\r\n        require(_nextOwner != address(0));\r\n         \r\n        emit OwnershipTransferred(owner, _nextOwner , now);\r\n         \r\n        owner = _nextOwner;\r\n    }\r\n    \r\n    function changeSigner(address _nextSigner) public\r\n    onlyOwner\r\n    {\r\n        require (_nextSigner != signerAuthority);\r\n        require(_nextSigner != address(0));\r\n      \r\n        signerAuthority = _nextSigner;\r\n    }\r\n    \r\n    function changeHDXcontract(address _next) public\r\n    onlyOwner\r\n    {\r\n        require (_next != address( HDXcontract ));\r\n        require( _next != address(0));\r\n         \r\n        emit HDXcontractChanged(address(HDXcontract), _next , now);\r\n         \r\n        HDXcontract  = HDX20Interface( _next);\r\n    }\r\n  \r\n  \r\n    function changeMinimumPrice( uint256 newmini) public\r\n    onlyOwner\r\n    {\r\n      \r\n      if (newmini>0)\r\n      {\r\n          minimumSharePrice = newmini;\r\n      }\r\n       \r\n      emit onChangeMinimumPrice( newmini , now ); \r\n    }\r\n    \r\n    \r\n    function changeBlockTimeout( uint32 b1 , uint32 b2) public\r\n    onlyOwner\r\n    {\r\n        require( b1>0 && b2>0 );\r\n        \r\n       \r\n        GameRoundData.extraData[2] = b1;\r\n        GameRoundData.extraData[3] = b2;\r\n            \r\n        emit onChangeBlockTimeout( b1,b2 ); \r\n        \r\n       \r\n       \r\n    }\r\n    \r\n    function changeTreasurePercentage( uint32 percentage) public\r\n    onlyOwner\r\n    {\r\n        require( percentage>0 && percentage<=100);\r\n        \r\n        GameRoundData.extraData[0] = percentage;\r\n          \r\n        emit onChangeTreasurePercentage( percentage ); \r\n       \r\n       \r\n       \r\n    }\r\n    \r\n     /*================================\r\n    =       GAMES VARIABLES         =\r\n    ================================*/\r\n    \r\n    struct PlayerData_s\r\n    {\r\n   \r\n        uint256 chest;  \r\n        uint256 payoutsTo;\r\n       \r\n\t\t//credit locked until we validate the score mode1\r\n\t\tuint256         mode1LockedCredit;\t\r\n\t\tuint256         mode1BatchID;         \r\n        uint256         mode1BlockTimeout;   \r\n        \r\n        uint256         mode2BatchID;         \r\n        uint256         mode2BlockTimeout;   \r\n\r\n\t\tuint32[2]\t\tpackedData;\t\t//[0] = mode1 challenge how ,any cube to stack;\r\n\t\t                                //[1] = mode1 multiplier\r\n\t\t\t\t\t\t\r\n    }\r\n    \r\n    \r\n    struct GameRoundData_s\r\n    {\r\n\t   \r\n\t   //mode1 \r\n\t   uint256\t\t\t\ttreasureAmount;\r\n\t   \r\n\t   //mode2\r\n\t   uint256              potAmount;\r\n\t   address\t\t\t\tcurrentPotWinner;\r\n\t   uint256              potBlockCountdown;\r\n\t          \r\n       uint256              hdx20AppreciationPayout;\r\n       uint256              devAppreciationPayout;\r\n\t   \r\n       //********************************************************************************************\r\n\t   \r\n\t   uint32[4]\t\t\textraData;\t\t//[0] = mode1 percentage    treasure\r\n\t\t\t\t\t\t\t\t\t        //[1] =\tmode2 current       highscore\r\n                                            //[2] = mode1 and mode2 blocktimeout  how manyblock to submit a valid score\r\n                                            //[3] = mode2 countdown how many block\r\n                                           \r\n                                            \r\n    }\r\n      \r\n   \r\n    mapping (address => PlayerData_s)   private PlayerData;\r\n       \r\n    GameRoundData_s   private GameRoundData;\r\n   \r\n    uint8 constant private HDX20BuyFees = 5;\r\n     \r\n    uint8 constant private DevFees = 5;\r\n\tuint8 constant private AppreciationFees = 15;\t\t\r\n\r\n\tuint8 constant private TreasureAppreciation = 80;\r\n   \tuint8 constant private PotAppreciation = 80;\r\n   \t\r\n   \r\n    uint256 constant internal magnitude = 1e18;\r\n     \r\n    uint256 private minimumSharePrice = 0.1 ether;\r\n    \r\n\r\n    uint256 constant thresholdForAppreciation = 0.05 ether;\r\n      \r\n    /*================================\r\n    =       PUBLIC FUNCTIONS         =\r\n    ================================*/\r\n    \r\n    //fallback will be called only from the HDX token contract to fund the game from customers's HDX20\r\n    \r\n     function()\r\n     payable\r\n     public\r\n     onlyFromHDXToken \r\n    {\r\n       \r\n      \r\n      \r\n          \r\n    }\r\n    \r\n    function ChargePot() public payable\r\n    {\r\n\t\tuint256 _val = msg.value;\r\n\t\t\r\n\t\tGameRoundData.potAmount = GameRoundData.potAmount.add( _val );\r\n\t\r\n    }\r\n    \r\n    function ChargeTreasure() public payable\r\n    {\r\n\t\tuint256 _val = msg.value;\r\n\t\r\n\t\t\r\n\t\tGameRoundData.treasureAmount = GameRoundData.treasureAmount.add( _val );\r\n\t\t\t\t   \r\n    }\r\n\t\r\n\t//mode1\r\n\tfunction AddTreasure( uint256 _val ) private\r\n\t{\r\n\t\r\n\t\tGameRoundData.treasureAmount = GameRoundData.treasureAmount.add( _val.mul( TreasureAppreciation ) / 100 );\r\n\t\t\r\n\t\t//now HDX20 appreciation and dev account\r\n\t\t\r\n\t\tuint256 _appreciation = SafeMath.mul( _val , AppreciationFees) / 100; \r\n          \r\n        uint256 _dev = SafeMath.mul( _val , DevFees) / 100;  \r\n\t\t\r\n\t\t_dev = _dev.add( GameRoundData.devAppreciationPayout );\r\n\t\t\r\n\t\tif (_dev>= thresholdForAppreciation )\r\n\t\t{\r\n\t\t\tGameRoundData.devAppreciationPayout = 0;\r\n\t\t\t\r\n\t\t\tHDXcontract.buyTokenFromGame.value( _dev )( owner , address(0));\t\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\t GameRoundData.devAppreciationPayout = _dev;\r\n\t\t}\r\n\t\r\n\t\t_appreciation = _appreciation.add( GameRoundData.hdx20AppreciationPayout );\r\n\t\t\r\n\t\tif (_appreciation>= thresholdForAppreciation)\r\n\t\t{\r\n\t\t\tGameRoundData.hdx20AppreciationPayout = 0;\r\n\t\t\t\r\n\t\t\tHDXcontract.appreciateTokenPrice.value( _appreciation )();\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tGameRoundData.hdx20AppreciationPayout = _appreciation;\r\n\t\t}\r\n\t\t\r\n\t}\r\n\t\r\n    //mode2\r\n\tfunction AddPot( uint256 _val ) private\r\n\t{\r\n\t    \r\n        \r\n\t\tGameRoundData.potAmount = GameRoundData.potAmount.add( _val.mul( PotAppreciation ) / 100 );\r\n\t\t\r\n\t\t//now HDX20 appreciation and dev account\r\n\t\t\r\n\t\tuint256 _appreciation = SafeMath.mul( _val , AppreciationFees) / 100; \r\n          \r\n        uint256 _dev = SafeMath.mul( _val , DevFees) / 100;  \r\n\t\t\r\n\t\t_dev = _dev.add( GameRoundData.devAppreciationPayout );\r\n\t\t\r\n\t\tif (_dev>= thresholdForAppreciation )\r\n\t\t{\r\n\t\t\tGameRoundData.devAppreciationPayout = 0;\r\n\t\t\t\r\n\t\t\tHDXcontract.buyTokenFromGame.value( _dev )( owner , address(0));\t\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\t GameRoundData.devAppreciationPayout = _dev;\r\n\t\t}\r\n\t\r\n\t\t_appreciation = _appreciation.add( GameRoundData.hdx20AppreciationPayout );\r\n\t\t\r\n\t\tif (_appreciation>= thresholdForAppreciation)\r\n\t\t{\r\n\t\t\tGameRoundData.hdx20AppreciationPayout = 0;\r\n\t\t\t\r\n\t\t\tHDXcontract.appreciateTokenPrice.value( _appreciation )();\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tGameRoundData.hdx20AppreciationPayout = _appreciation;\r\n\t\t}\r\n\t\t\r\n\t}\r\n    \r\n    \r\n    function ValidMode1Score( uint256 score, uint256 mode1BatchID , bytes32 r , bytes32 s , uint8 v) public\r\n    onlyDirectTransaction\r\n    {\r\n        address _customer_address = msg.sender;\r\n      \r\n        GameVar_s memory gamevar;\r\n        gamevar.score = score;\r\n        gamevar.BatchID = mode1BatchID;\r\n        gamevar.r = r;\r\n        gamevar.s = s;\r\n        gamevar.v = v;\r\n   \r\n        checkPayPot();\r\n   \r\n        coreValidMode1Score( _customer_address , gamevar  );\r\n    }\r\n    \r\n    function ValidMode2Score( uint256 score, uint256 mode2BatchID , bytes32 r , bytes32 s , uint8 v) public\r\n    onlyDirectTransaction\r\n    {\r\n        address _customer_address = msg.sender;\r\n      \r\n        GameVar_s memory gamevar;\r\n        gamevar.score = score;\r\n        gamevar.BatchID = mode2BatchID;\r\n        gamevar.r = r;\r\n        gamevar.s = s;\r\n        gamevar.v = v;\r\n        \r\n        checkPayPot();\r\n   \r\n        coreValidMode2Score( _customer_address , gamevar  );\r\n    }\r\n    \r\n    struct GameVar_s\r\n    {\r\n        uint256  BatchID;\r\n       \r\n \t    uint256   score;\r\n\t\r\n        bytes32  r;\r\n        bytes32  s;\r\n        uint8    v;\r\n        uint32   multiplier;\r\n    }\r\n    \r\n\tfunction checkPayPot() private\r\n\t{\r\n\t    uint256 b1 =  GameRoundData.potBlockCountdown;\r\n\t    \r\n\t    if (b1>0)\r\n\t    {\r\n\t        if (block.number>=b1)\r\n\t        {\r\n    \t\t    address _winner = GameRoundData.currentPotWinner;\r\n    \t\t    uint256 _j = GameRoundData.potAmount/2;\r\n    \t\t\r\n    \t\t   \r\n    \t\t\r\n    \t\t    if (_winner != address(0))\r\n    \t\t    {\r\n    \t\t\t    PlayerData[ _winner ].chest = PlayerData[ _winner ].chest.add( _j ); \r\n    \t\t    }\r\n    \t\t    \r\n        \t\tGameRoundData.currentPotWinner = address(0);\r\n        \t\tGameRoundData.potAmount = GameRoundData.potAmount.sub( _j );\r\n        \t\t\r\n        \t    //highscore to 0\r\n        \t\tGameRoundData.extraData[1] = 0;\r\n        \t\t//block at 0\r\n        \t\tGameRoundData.potBlockCountdown = 0;\r\n        \t\t\r\n    \t\t}\r\n\t    }\r\n\t\t\r\n\t}\r\n  \r\n    \r\n    function coreValidMode1Score( address _player_address , GameVar_s gamevar) private\r\n    {\r\n    \r\n        PlayerData_s storage  _PlayerData = PlayerData[ _player_address];\r\n                \r\n        require((gamevar.BatchID != 0) && (gamevar.BatchID == _PlayerData.mode1BatchID) && ( _PlayerData.mode1LockedCredit>0 ));\r\n        \r\n        if (block.number>=_PlayerData.mode1BlockTimeout || (ecrecover(keccak256(abi.encodePacked( gamevar.score,gamevar.BatchID )) , gamevar.v, gamevar.r, gamevar.s) != signerAuthority))\r\n        {\r\n            gamevar.score = 0;\r\n        }\r\n\t\t\r\n\t\r\n\t    if (gamevar.score> _PlayerData.packedData[0]) \tgamevar.score =  _PlayerData.packedData[0];\r\n\t    \r\n\t    uint256 _winning =0;\r\n\t    uint256 _hdx20 = 0;\r\n\t    uint256 _nb_token = 0;\r\n\t    uint256 _minimum =  _PlayerData.mode1LockedCredit.mul(5) / 100;\r\n\t   \r\n\t    \r\n\t   \r\n\t    if (gamevar.score>0)\r\n\t    {\r\n\t        uint256 _gain;\r\n\t    \r\n\t        //percentage of treasure      \r\n\t        _gain = GameRoundData.treasureAmount.mul( GameRoundData.extraData[0]) / 100;\r\n\t        \r\n\t        //scale the gain based the credit size\r\n\t        _gain = _gain.mul( _PlayerData.packedData[1]) / 10;\r\n\t   \r\n\t        //triple cube curve     \r\n\t        _gain = _gain.mul( _PlayerData.packedData[0] * _PlayerData.packedData[0] * _PlayerData.packedData[0] );\r\n\t        _gain /= (10*10*10);\r\n\t        \r\n\t          //maximum x2\r\n\t        if (_gain>_PlayerData.mode1LockedCredit) _gain = _PlayerData.mode1LockedCredit;\r\n\t        \r\n\t        //succed challenge ?\r\n\t        if (gamevar.score==_PlayerData.packedData[0])\r\n\t        {\r\n\t            _winning = _PlayerData.mode1LockedCredit.add( _gain);\r\n\t        }\r\n\t        else\r\n\t        {\r\n\t            _winning = _PlayerData.mode1LockedCredit.sub( _gain );\r\n\t            _gain = (_gain).mul( gamevar.score-1 );\r\n\t            _gain /= uint256( _PlayerData.packedData[0] );\r\n\t            _winning = _winning.add( _gain );\r\n\t        }\r\n\t    }\r\n\t    \r\n\t    if (_winning<_minimum) _winning = _minimum;\r\n\t    \r\n\t   //winning cannot be zero \r\n\t   \r\n\t   //HDX20BuyFees\r\n        _hdx20 = (_winning.mul(HDX20BuyFees)) / 100;\r\n\t\r\n\t    _nb_token =   HDXcontract.buyTokenFromGame.value( _hdx20 )( _player_address , address(0)); \r\n\t     \r\n\t\t//credit the player for what is won minus the HDX20\r\n\t\t_PlayerData.chest = _PlayerData.chest.add( _winning - _hdx20 );\r\n\t\t\r\n\t\t//loosing some ?\r\n\t\t\r\n\t\tif (_PlayerData.mode1LockedCredit> _winning)\r\n\t\t{\r\n\t\t\t\r\n\t\t\tAddTreasure( _PlayerData.mode1LockedCredit - _winning );\r\n\t\t}\r\n\t\t\r\n\t\t//we need to pay the difference from the treasure\r\n\t\tif (_winning>_PlayerData.mode1LockedCredit)\r\n\t\t{\r\n\t\t    GameRoundData.treasureAmount = GameRoundData.treasureAmount.sub( _winning - _PlayerData.mode1LockedCredit);\r\n\t\t}\r\n\t\r\n        //ok reset it so we can get a new one\r\n        _PlayerData.mode1BatchID = 0;\r\n        _PlayerData.mode1LockedCredit = 0;\r\n\t\t\r\n        emit onNewScoreMode1( gamevar.score , _player_address , _winning , _nb_token );\r\n\r\n    }\r\n    \r\n    function coreValidMode2Score( address _player_address , GameVar_s gamevar) private\r\n    {\r\n    \r\n        PlayerData_s storage  _PlayerData = PlayerData[ _player_address];\r\n        \r\n                \r\n        if ((gamevar.BatchID != 0) && (gamevar.BatchID == _PlayerData.mode2BatchID))\r\n        {\r\n                \r\n            if (block.number>=_PlayerData.mode2BlockTimeout || (ecrecover(keccak256(abi.encodePacked( gamevar.score,gamevar.BatchID )) , gamevar.v, gamevar.r, gamevar.s) != signerAuthority))\r\n            {\r\n                gamevar.score = 0;\r\n            }\r\n    \t\t\r\n    \t\r\n    \t    if (gamevar.score>80*2*15) \tgamevar.score = 80*2*15;\r\n    \t    \r\n    \t    bool _newHighscore = false;\r\n    \t    \r\n    \t    //new highscore\r\n    \t    if (gamevar.score > GameRoundData.extraData[1])\r\n    \t    {\r\n    \t        GameRoundData.extraData[1] = uint32(gamevar.score);\r\n    \t        GameRoundData.currentPotWinner = _player_address;\r\n    \t        GameRoundData.potBlockCountdown = block.number + uint256( GameRoundData.extraData[3] ); //24 hours countdown start\r\n    \t        \r\n    \t        _newHighscore = true;\r\n    \t        \r\n    \t    }\r\n    \t    \r\n    \t    emit onNewScoreMode2( gamevar.score , _player_address , _newHighscore);\r\n        }\r\n\t \r\n        //ok reset it so we can get a new one\r\n        _PlayerData.mode2BatchID = 0;\r\n     \r\n\t\t\r\n\r\n    }\r\n    \r\n    \r\n    function BuyMode1WithDividends( uint256 eth , uint32 challenge, uint256 score, uint256 BatchID,  address _referrer_address , bytes32 r , bytes32 s , uint8 v) public\r\n    onlyDirectTransaction\r\n    {\r\n        \r\n        require( (eth==minimumSharePrice || eth==minimumSharePrice*5 || eth==minimumSharePrice*10) && (challenge>=4 && challenge<=10) );\r\n  \r\n        address _customer_address = msg.sender;\r\n        \r\n        checkPayPot();\r\n        \r\n        GameVar_s memory gamevar;\r\n        gamevar.score = score;\r\n        gamevar.BatchID = BatchID;\r\n        gamevar.r = r;\r\n        gamevar.s = s;\r\n        gamevar.v = v;\r\n        gamevar.multiplier = uint32(eth / minimumSharePrice);\r\n      \r\n        \r\n        eth = HDXcontract.payWithToken( eth , _customer_address );\r\n       \r\n        require( eth>0 );\r\n       \r\n         \r\n        CoreBuyMode1( _customer_address , eth , challenge, _referrer_address , gamevar );\r\n        \r\n       \r\n    }\r\n    \r\n \r\n    \r\n    function BuyMode1( uint32 challenge, uint256 score, uint256 BatchID, address _referrer_address , bytes32 r , bytes32 s , uint8 v ) public payable\r\n    onlyDirectTransaction\r\n    {\r\n     \r\n        address _customer_address = msg.sender;\r\n        uint256 eth = msg.value;\r\n        \r\n        require( (eth==minimumSharePrice || eth==minimumSharePrice*5 || eth==minimumSharePrice*10) && (challenge>=4 && challenge<=10));\r\n        \r\n        checkPayPot();\r\n   \r\n        GameVar_s memory gamevar;\r\n        gamevar.score = score;\r\n        gamevar.BatchID = BatchID;\r\n        gamevar.r = r;\r\n        gamevar.s = s;\r\n        gamevar.v = v;\r\n        gamevar.multiplier = uint32(eth / minimumSharePrice);\r\n     \r\n        CoreBuyMode1( _customer_address , eth , challenge, _referrer_address, gamevar);\r\n     \r\n    }\r\n    \r\n    \r\n    function BuyMode2WithDividends( uint256 eth , uint256 score, uint256 BatchID,  address _referrer_address , bytes32 r , bytes32 s , uint8 v) public\r\n    onlyDirectTransaction\r\n    {\r\n        \r\n        require( (eth==minimumSharePrice) );\r\n  \r\n        address _customer_address = msg.sender;\r\n        \r\n        checkPayPot();\r\n        \r\n        GameVar_s memory gamevar;\r\n        gamevar.score = score;\r\n        gamevar.BatchID = BatchID;\r\n        gamevar.r = r;\r\n        gamevar.s = s;\r\n        gamevar.v = v;\r\n      \r\n        \r\n        eth = HDXcontract.payWithToken( eth , _customer_address );\r\n       \r\n        require( eth>0 );\r\n       \r\n         \r\n        CoreBuyMode2( _customer_address , eth , _referrer_address , gamevar );\r\n        \r\n       \r\n    }\r\n    \r\n    \r\n    function BuyMode2( uint256 score, uint256 BatchID, address _referrer_address , bytes32 r , bytes32 s , uint8 v ) public payable\r\n    onlyDirectTransaction\r\n    {\r\n     \r\n        address _customer_address = msg.sender;\r\n        uint256 eth = msg.value;\r\n        \r\n        require( (eth==minimumSharePrice));\r\n        \r\n        checkPayPot();\r\n   \r\n        GameVar_s memory gamevar;\r\n        gamevar.score = score;\r\n        gamevar.BatchID = BatchID;\r\n        gamevar.r = r;\r\n        gamevar.s = s;\r\n        gamevar.v = v;\r\n     \r\n   \r\n        CoreBuyMode2( _customer_address , eth , _referrer_address, gamevar);\r\n     \r\n    }\r\n    \r\n    /*================================\r\n    =       CORE BUY FUNCTIONS       =\r\n    ================================*/\r\n    \r\n    function CoreBuyMode1( address _player_address , uint256 eth , uint32 challenge,  address _referrer_address , GameVar_s gamevar) private\r\n    {\r\n    \r\n        PlayerData_s storage  _PlayerData = PlayerData[ _player_address];\r\n         \r\n        //we need to validate the score before buying a torpedo batch\r\n        if (gamevar.BatchID !=0 || _PlayerData.mode1BatchID !=0)\r\n        {\r\n             coreValidMode1Score( _player_address , gamevar);\r\n        }\r\n        \r\n        //if we can continue then everything is fine let's create the new batch\r\n        \r\n        _PlayerData.packedData[0] = challenge;\r\n        _PlayerData.packedData[1] = gamevar.multiplier;\r\n        \r\n        _PlayerData.mode1BlockTimeout = block.number + (uint256(GameRoundData.extraData[2]));\r\n        _PlayerData.mode1BatchID = uint256((keccak256(abi.encodePacked( block.number,1,challenge, _player_address , address(this)))));\r\n      \r\n\t\t_PlayerData.mode1LockedCredit =  eth;\r\n\t\r\n        \r\n        emit onBuyMode1( _player_address, _PlayerData.mode1BatchID , _PlayerData.mode1BlockTimeout,  _PlayerData.packedData[0]);\r\n            \r\n        \r\n    }\r\n    \r\n    \r\n    function CoreBuyMode2( address _player_address , uint256 eth ,  address _referrer_address , GameVar_s gamevar) private\r\n    {\r\n    \r\n        PlayerData_s storage  _PlayerData = PlayerData[ _player_address];\r\n         \r\n        //we need to validate the score before buying a torpedo batch\r\n        if (gamevar.BatchID !=0 || _PlayerData.mode2BatchID !=0)\r\n        {\r\n             coreValidMode2Score( _player_address , gamevar);\r\n        }\r\n        \r\n        //if we can continue then everything is fine let's create the new batch\r\n        \r\n       \r\n        _PlayerData.mode2BlockTimeout = block.number + (uint256(GameRoundData.extraData[2]));\r\n        _PlayerData.mode2BatchID = uint256((keccak256(abi.encodePacked( block.number,2, _player_address , address(this)))));\r\n      \r\n         //HDX20BuyFees\r\n        uint256 _tempo = (eth.mul(HDX20BuyFees)) / 100;\r\n\t\r\n\t    eth = eth.sub( _tempo );\t\r\n\t\r\n        uint256 _nb_token =   HDXcontract.buyTokenFromGame.value( _tempo )( _player_address , _referrer_address);\r\n        \r\n        AddPot( eth );\r\n        \r\n        emit onBuyMode2( _player_address, _PlayerData.mode2BatchID , _PlayerData.mode2BlockTimeout, _nb_token );\r\n            \r\n        \r\n    }\r\n    \r\n    function getPotGain( address _player_address) private view\r\n    returns( uint256)\r\n\t{\r\n\t    uint256 b1 =  GameRoundData.potBlockCountdown;\r\n\t    \r\n\t    if (b1>0)\r\n\t    {\r\n\t        if (block.number>=b1 && _player_address==GameRoundData.currentPotWinner)\r\n\t        {\r\n\t            return( GameRoundData.potAmount/2);\r\n\t          \r\n    \t\t}\r\n\t    }\r\n\t    \r\n\t    return( 0 );\r\n\t\t\r\n\t}\r\n   \r\n    \r\n    function get_Gains(address _player_address) private view\r\n    returns( uint256)\r\n    {\r\n       \r\n        uint256 _gains = PlayerData[ _player_address ].chest;\r\n        \r\n        //we may have to temporary add the current pot gain to reflect the correct position\r\n        \r\n        _gains = _gains.add( getPotGain(_player_address ) );\r\n        \r\n        if (_gains > PlayerData[ _player_address].payoutsTo)\r\n        {\r\n            _gains -= PlayerData[ _player_address].payoutsTo;\r\n        }\r\n        else _gains = 0;\r\n     \r\n    \r\n        return( _gains );\r\n        \r\n    }\r\n    \r\n    \r\n    function WithdrawGains() public \r\n   \r\n    {\r\n        address _customer_address = msg.sender;\r\n        \r\n        checkPayPot();\r\n        \r\n        uint256 _gains = get_Gains( _customer_address );\r\n        \r\n        require( _gains>0);\r\n        \r\n        PlayerData[ _customer_address ].payoutsTo = PlayerData[ _customer_address ].payoutsTo.add( _gains );\r\n        \r\n      \r\n        emit onWithdrawGains( _customer_address , _gains , now);\r\n        \r\n        _customer_address.transfer( _gains );\r\n        \r\n        \r\n    }\r\n    \r\n   \r\n  \r\n    \r\n     /*================================\r\n    =  VIEW AND HELPERS FUNCTIONS    =\r\n    ================================*/\r\n  \r\n    \r\n    function view_get_Treasure() public\r\n    view\r\n    returns(uint256)\r\n    {\r\n      \r\n      return( GameRoundData.treasureAmount );  \r\n    }\r\n\t\r\n\tfunction view_get_Pot() public\r\n    view\r\n    returns(uint256)\r\n    {\r\n      \r\n      return( GameRoundData.potAmount );  \r\n    }\r\n \r\n    function view_get_gameData() public\r\n    view\r\n    returns( \r\n             uint256 treasure,\r\n\t\t\t uint256 pot,\r\n\t\t\t uint32  highscore ,\r\n\t\t\t address highscore_address ,\r\n\t\t\r\n\t\t\t uint256 mode1BatchID,\r\n\t\t     uint256 mode1BlockTimeout,\r\n\t\t     uint32  mode1Challenge,\r\n\t\t     uint256 mode1Multiplier,\r\n\t\t     \r\n\t\t\t uint256 mode2BatchID,\r\n\t\t\t uint256 mode2BlockTimeout,\r\n\t\t\t \r\n\t\t\t uint256 potBlockCountdown,\r\n\t\t\t \r\n\t\t\t uint32  percentage)\r\n    {\r\n        address _player_address = msg.sender;\r\n\t\t\r\n\t\ttreasure = GameRoundData.treasureAmount;\r\n\t\tpot = GameRoundData.potAmount;\r\n\t\thighscore = GameRoundData.extraData[1];\r\n\t\thighscore_address = GameRoundData.currentPotWinner;\r\n\t\tpercentage = GameRoundData.extraData[0];\r\n\t\t      \r\n        mode1BatchID = PlayerData[_player_address].mode1BatchID;\r\n        mode1BlockTimeout = PlayerData[_player_address].mode1BlockTimeout;\r\n        mode1Challenge = PlayerData[_player_address].packedData[0];\r\n        mode1Multiplier =  PlayerData[_player_address].packedData[1];\r\n        \r\n        mode2BatchID =  PlayerData[_player_address].mode2BatchID;\r\n        mode2BlockTimeout = PlayerData[ _player_address].mode2BlockTimeout;\r\n        \r\n        potBlockCountdown = GameRoundData.potBlockCountdown;\r\n        \r\n      \r\n       \r\n    }\r\n  \r\n       \r\n  \r\n    \r\n    function view_get_Gains()\r\n    public\r\n    view\r\n    returns( uint256 gains)\r\n    {\r\n        \r\n        address _player_address = msg.sender;\r\n   \r\n        uint256 _gains = PlayerData[ _player_address ].chest;\r\n        \r\n        _gains = _gains.add( getPotGain( _player_address ) );\r\n        \r\n        if (_gains > PlayerData[ _player_address].payoutsTo)\r\n        {\r\n            _gains -= PlayerData[ _player_address].payoutsTo;\r\n        }\r\n        else _gains = 0;\r\n     \r\n    \r\n        return( _gains );\r\n        \r\n    }\r\n  \r\n  \r\n    \r\n    function view_get_gameStates() public \r\n    view\r\n    returns( uint256 minimumshare ,\r\n\t\t     uint256 blockNumberCurrent,\r\n\t\t     uint32  blockScoreTimeout,\r\n\t\t     uint32  blockPotTimout\r\n\t\t   \r\n\t\t    )\r\n    {\r\n       \r\n        \r\n        return( minimumSharePrice ,  block.number   , GameRoundData.extraData[2] , GameRoundData.extraData[3] );\r\n    }\r\n    \r\n    function view_get_pendingHDX20Appreciation()\r\n    public\r\n    view\r\n    returns(uint256)\r\n    {\r\n        return GameRoundData.hdx20AppreciationPayout;\r\n    }\r\n    \r\n    function view_get_pendingDevAppreciation()\r\n    public\r\n    view\r\n    returns(uint256)\r\n    {\r\n        return GameRoundData.devAppreciationPayout;\r\n    }\r\n  \r\n \r\n \r\n    function totalEthereumBalance()\r\n    public\r\n    view\r\n    returns(uint256)\r\n    {\r\n        return address(this).balance;\r\n    }\r\n    \r\n  \r\n    \r\n    function view_get_blockNumbers()\r\n    public\r\n    view\r\n    returns( uint256 b1 )\r\n    {\r\n        return( block.number);\r\n        \r\n    }\r\n    \r\n  \r\n    \r\n   \r\n}\r\n\r\n\r\nlibrary SafeMath {\r\n    \r\n   \r\n    function mul(uint256 a, uint256 b) \r\n        internal \r\n        pure \r\n        returns (uint256 c) \r\n    {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        c = a * b;\r\n        require(c / a == b);\r\n        return c;\r\n    }\r\n\r\n   \r\n    function sub(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n        returns (uint256) \r\n    {\r\n        require(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n   \r\n    function add(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n        returns (uint256 c) \r\n    {\r\n        c = a + b;\r\n        require(c >= a);\r\n        return c;\r\n    }\r\n    \r\n   \r\n    \r\n  \r\n    \r\n   \r\n}\r\n\r\n\r\nlibrary SafeMath128 {\r\n    \r\n   \r\n    function mul(uint128 a, uint128 b) \r\n        internal \r\n        pure \r\n        returns (uint128 c) \r\n    {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        c = a * b;\r\n        require(c / a == b);\r\n        return c;\r\n    }\r\n\r\n   \r\n    function sub(uint128 a, uint128 b)\r\n        internal\r\n        pure\r\n        returns (uint128) \r\n    {\r\n        require(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n   \r\n    function add(uint128 a, uint128 b)\r\n        internal\r\n        pure\r\n        returns (uint128 c) \r\n    {\r\n        c = a + b;\r\n        require(c >= a);\r\n        return c;\r\n    }\r\n    \r\n   \r\n    \r\n  \r\n    \r\n   \r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"view_get_Treasure\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"score\",\"type\":\"uint256\"},{\"name\":\"BatchID\",\"type\":\"uint256\"},{\"name\":\"_referrer_address\",\"type\":\"address\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"},{\"name\":\"v\",\"type\":\"uint8\"}],\"name\":\"BuyMode2\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newmini\",\"type\":\"uint256\"}],\"name\":\"changeMinimumPrice\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"view_get_Pot\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"view_get_gameStates\",\"outputs\":[{\"name\":\"minimumshare\",\"type\":\"uint256\"},{\"name\":\"blockNumberCurrent\",\"type\":\"uint256\"},{\"name\":\"blockScoreTimeout\",\"type\":\"uint32\"},{\"name\":\"blockPotTimout\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"ChargePot\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"score\",\"type\":\"uint256\"},{\"name\":\"mode2BatchID\",\"type\":\"uint256\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"},{\"name\":\"v\",\"type\":\"uint8\"}],\"name\":\"ValidMode2Score\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"eth\",\"type\":\"uint256\"},{\"name\":\"score\",\"type\":\"uint256\"},{\"name\":\"BatchID\",\"type\":\"uint256\"},{\"name\":\"_referrer_address\",\"type\":\"address\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"},{\"name\":\"v\",\"type\":\"uint8\"}],\"name\":\"BuyMode2WithDividends\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_next\",\"type\":\"address\"}],\"name\":\"changeHDXcontract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"signerAuthority\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalEthereumBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"percentage\",\"type\":\"uint32\"}],\"name\":\"changeTreasurePercentage\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"challenge\",\"type\":\"uint32\"},{\"name\":\"score\",\"type\":\"uint256\"},{\"name\":\"BatchID\",\"type\":\"uint256\"},{\"name\":\"_referrer_address\",\"type\":\"address\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"},{\"name\":\"v\",\"type\":\"uint8\"}],\"name\":\"BuyMode1\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"eth\",\"type\":\"uint256\"},{\"name\":\"challenge\",\"type\":\"uint32\"},{\"name\":\"score\",\"type\":\"uint256\"},{\"name\":\"BatchID\",\"type\":\"uint256\"},{\"name\":\"_referrer_address\",\"type\":\"address\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"},{\"name\":\"v\",\"type\":\"uint8\"}],\"name\":\"BuyMode1WithDividends\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"view_get_Gains\",\"outputs\":[{\"name\":\"gains\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"view_get_gameData\",\"outputs\":[{\"name\":\"treasure\",\"type\":\"uint256\"},{\"name\":\"pot\",\"type\":\"uint256\"},{\"name\":\"highscore\",\"type\":\"uint32\"},{\"name\":\"highscore_address\",\"type\":\"address\"},{\"name\":\"mode1BatchID\",\"type\":\"uint256\"},{\"name\":\"mode1BlockTimeout\",\"type\":\"uint256\"},{\"name\":\"mode1Challenge\",\"type\":\"uint32\"},{\"name\":\"mode1Multiplier\",\"type\":\"uint256\"},{\"name\":\"mode2BatchID\",\"type\":\"uint256\"},{\"name\":\"mode2BlockTimeout\",\"type\":\"uint256\"},{\"name\":\"potBlockCountdown\",\"type\":\"uint256\"},{\"name\":\"percentage\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"view_get_pendingDevAppreciation\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_nextOwner\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_nextSigner\",\"type\":\"address\"}],\"name\":\"changeSigner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"view_get_blockNumbers\",\"outputs\":[{\"name\":\"b1\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"view_get_pendingHDX20Appreciation\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"WithdrawGains\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"score\",\"type\":\"uint256\"},{\"name\":\"mode1BatchID\",\"type\":\"uint256\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"},{\"name\":\"v\",\"type\":\"uint8\"}],\"name\":\"ValidMode1Score\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"ChargeTreasure\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"b1\",\"type\":\"uint32\"},{\"name\":\"b2\",\"type\":\"uint32\"}],\"name\":\"changeBlockTimeout\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"nextOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"timeStamp\",\"type\":\"uint256\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"previous\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"next\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"timeStamp\",\"type\":\"uint256\"}],\"name\":\"HDXcontractChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"customerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"ethereumWithdrawn\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timeStamp\",\"type\":\"uint256\"}],\"name\":\"onWithdrawGains\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"customerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"BatchID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"BatchBlockTimeout\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"Challenge\",\"type\":\"uint32\"}],\"name\":\"onBuyMode1\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"customerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"BatchID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"BatchBlockTimeout\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"nb_token\",\"type\":\"uint256\"}],\"name\":\"onBuyMode2\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"score\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"customerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"winning\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"nb_token\",\"type\":\"uint256\"}],\"name\":\"onNewScoreMode1\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"score\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"customerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newHighscore\",\"type\":\"bool\"}],\"name\":\"onNewScoreMode2\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"minimum\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timeStamp\",\"type\":\"uint256\"}],\"name\":\"onChangeMinimumPrice\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"b1\",\"type\":\"uint32\"},{\"indexed\":false,\"name\":\"b2\",\"type\":\"uint32\"}],\"name\":\"onChangeBlockTimeout\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"percentage\",\"type\":\"uint32\"}],\"name\":\"onChangeTreasurePercentage\",\"type\":\"event\"}]","ContractName":"stakethemall","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://2842e49c25a34c6c9091cdfddc28a9e56e9d1d7f9f37c9e5080422565e02b252"}]}