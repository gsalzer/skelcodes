{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.9;\r\n\r\n/**\r\n* @title Math\r\n* @dev Assorted math operations\r\n*/\r\nlibrary Math {\r\n/**\r\n* @dev Returns the largest of two numbers.\r\n*/\r\nfunction max(uint256 a, uint256 b) internal pure returns (uint256) {\r\nreturn a >= b ? a : b;\r\n}\r\n\r\n/**\r\n* @dev Returns the smallest of two numbers.\r\n*/\r\nfunction min(uint256 a, uint256 b) internal pure returns (uint256) {\r\nreturn a < b ? a : b;\r\n}\r\n\r\n/**\r\n* @dev Calculates the average of two numbers. Since these are integers,\r\n* averages of an even and odd number cannot be represented, and will be\r\n* rounded down.\r\n*/\r\nfunction average(uint256 a, uint256 b) internal pure returns (uint256) {\r\n// (a + b) / 2 can overflow, so we distribute\r\nreturn (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\r\n}\r\n}\r\n\r\n\r\n/**\r\n* @title Roles\r\n* @dev Library for managing addresses assigned to a Role.\r\n*/\r\nlibrary Roles {\r\nstruct Role {\r\nmapping (address => bool) bearer;\r\n}\r\n\r\n/**\r\n* @dev give an account access to this role\r\n*/\r\nfunction add(Role storage role, address account) internal {\r\nrequire(account != address(0));\r\nrequire(!has(role, account));\r\n\r\nrole.bearer[account] = true;\r\n}\r\n\r\n/**\r\n* @dev remove an account's access to this role\r\n*/\r\nfunction remove(Role storage role, address account) internal {\r\nrequire(account != address(0));\r\nrequire(has(role, account));\r\n\r\nrole.bearer[account] = false;\r\n}\r\n\r\n/**\r\n* @dev check if an account has this role\r\n* @return bool\r\n*/\r\nfunction has(Role storage role, address account) internal view returns (bool) {\r\nrequire(account != address(0));\r\nreturn role.bearer[account];\r\n}\r\n}\r\n\r\n\r\n/**\r\n* @title SafeMath\r\n* @dev Unsigned math operations with safety checks that revert on error\r\n*/\r\nlibrary SafeMath {\r\n/**\r\n* @dev Multiplies two unsigned integers, reverts on overflow.\r\n*/\r\nfunction mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n// Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n// benefit is lost if 'b' is also tested.\r\n// See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\nif (a == 0) {\r\nreturn 0;\r\n}\r\n\r\nuint256 c = a * b;\r\nrequire(c / a == b);\r\n\r\nreturn c;\r\n}\r\n\r\n/**\r\n* @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\r\n*/\r\nfunction div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n// Solidity only automatically asserts when dividing by 0\r\nrequire(b > 0);\r\nuint256 c = a / b;\r\n// assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\nreturn c;\r\n}\r\n\r\n/**\r\n* @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n*/\r\nfunction sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\nrequire(b <= a);\r\nuint256 c = a - b;\r\n\r\nreturn c;\r\n}\r\n\r\n/**\r\n* @dev Adds two unsigned integers, reverts on overflow.\r\n*/\r\nfunction add(uint256 a, uint256 b) internal pure returns (uint256) {\r\nuint256 c = a + b;\r\nrequire(c >= a);\r\n\r\nreturn c;\r\n}\r\n\r\n/**\r\n* @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\r\n* reverts when dividing by zero.\r\n*/\r\nfunction mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\nrequire(b != 0);\r\nreturn a % b;\r\n}\r\n}\r\n\r\n\r\n\r\n\r\ncontract MinterRole {\r\nusing Roles for Roles.Role;\r\n\r\nevent MinterAdded(address indexed account);\r\nevent MinterRemoved(address indexed account);\r\n\r\nRoles.Role private _minters;\r\n\r\nconstructor () internal {\r\n_addMinter(msg.sender);\r\n}\r\n\r\nmodifier onlyMinter() {\r\nrequire(isMinter(msg.sender));\r\n_;\r\n}\r\n\r\nfunction isMinter(address account) public view returns (bool) {\r\nreturn _minters.has(account);\r\n}\r\n\r\nfunction addMinter(address account) public onlyMinter {\r\n_addMinter(account);\r\n}\r\n\r\nfunction renounceMinter() public {\r\n_removeMinter(msg.sender);\r\n}\r\n\r\nfunction _addMinter(address account) internal {\r\n_minters.add(account);\r\nemit MinterAdded(account);\r\n}\r\n\r\nfunction _removeMinter(address account) internal {\r\n_minters.remove(account);\r\nemit MinterRemoved(account);\r\n}\r\n}\r\n\r\n\r\n/**\r\n* @title ERC20 interface\r\n* @dev see https://eips.ethereum.org/EIPS/eip-20\r\n*/\r\ninterface IERC20 {\r\nfunction transfer(address to, uint256 value) external returns (bool);\r\n\r\nfunction approve(address spender, uint256 value) external returns (bool);\r\n\r\nfunction transferFrom(address from, address to, uint256 value) external returns (bool);\r\n\r\nfunction totalSupply() external view returns (uint256);\r\n\r\nfunction balanceOf(address who) external view returns (uint256);\r\n\r\nfunction allowance(address owner, address spender) external view returns (uint256);\r\n\r\nevent Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\nevent Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\ncontract ApproveAndCallFallBack {\r\nfunction receiveApproval(address from, uint256 _amount, address _token, bytes memory _data) public;\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n* @title Standard ERC20 token\r\n*\r\n* @dev Implementation of the basic standard token.\r\n* https://eips.ethereum.org/EIPS/eip-20\r\n* Originally based on code by FirstBlood:\r\n* https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\r\n*\r\n* This implementation emits additional Approval events, allowing applications to reconstruct the allowance status for\r\n* all accounts just by listening to said events. Note that this isn't required by the specification, and other\r\n* compliant implementations may not do it.\r\n*/\r\ncontract ERC20 is IERC20 {\r\nusing SafeMath for uint256;\r\n\r\nmapping (address => uint256) private _balances;\r\n\r\nmapping (address => mapping (address => uint256)) private _allowed;\r\n\r\nuint256 private _totalSupply;\r\n\r\n/**\r\n* @dev Total number of tokens in existence\r\n*/\r\nfunction totalSupply() public view returns (uint256) {\r\nreturn _totalSupply;\r\n}\r\n\r\n/**\r\n* @dev Gets the balance of the specified address.\r\n* @param owner The address to query the balance of.\r\n* @return A uint256 representing the amount owned by the passed address.\r\n*/\r\nfunction balanceOf(address owner) public view returns (uint256) {\r\nreturn _balances[owner];\r\n}\r\n\r\n/**\r\n* @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n* @param owner address The address which owns the funds.\r\n* @param spender address The address which will spend the funds.\r\n* @return A uint256 specifying the amount of tokens still available for the spender.\r\n*/\r\nfunction allowance(address owner, address spender) public view returns (uint256) {\r\nreturn _allowed[owner][spender];\r\n}\r\n\r\n/**\r\n* @dev Transfer token to a specified address\r\n* @param to The address to transfer to.\r\n* @param value The amount to be transferred.\r\n*/\r\nfunction transfer(address to, uint256 value) public returns (bool) {\r\n_transfer(msg.sender, to, value);\r\nreturn true;\r\n}\r\n\r\n/**\r\n* @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n* Beware that changing an allowance with this method brings the risk that someone may use both the old\r\n* and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\r\n* race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\r\n* https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n* @param spender The address which will spend the funds.\r\n* @param value The amount of tokens to be spent.\r\n*/\r\nfunction approve(address spender, uint256 value) public returns (bool) {\r\n_approve(msg.sender, spender, value);\r\nreturn true;\r\n}\r\n\r\n/**\r\n* @dev Transfer tokens from one address to another.\r\n* Note that while this function emits an Approval event, this is not required as per the specification,\r\n* and other compliant implementations may not emit the event.\r\n* @param from address The address which you want to send tokens from\r\n* @param to address The address which you want to transfer to\r\n* @param value uint256 the amount of tokens to be transferred\r\n*/\r\nfunction transferFrom(address from, address to, uint256 value) public returns (bool) {\r\n_transfer(from, to, value);\r\n_approve(from, msg.sender, _allowed[from][msg.sender].sub(value));\r\nreturn true;\r\n}\r\n\r\n/**\r\n* @dev Increase the amount of tokens that an owner allowed to a spender.\r\n* approve should be called when _allowed[msg.sender][spender] == 0. To increment\r\n* allowed value is better to use this function to avoid 2 calls (and wait until\r\n* the first transaction is mined)\r\n* From MonolithDAO Token.sol\r\n* Emits an Approval event.\r\n* @param spender The address which will spend the funds.\r\n* @param addedValue The amount of tokens to increase the allowance by.\r\n*/\r\nfunction increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\r\n_approve(msg.sender, spender, _allowed[msg.sender][spender].add(addedValue));\r\nreturn true;\r\n}\r\n\r\n/**\r\n* @dev Decrease the amount of tokens that an owner allowed to a spender.\r\n* approve should be called when _allowed[msg.sender][spender] == 0. To decrement\r\n* allowed value is better to use this function to avoid 2 calls (and wait until\r\n* the first transaction is mined)\r\n* From MonolithDAO Token.sol\r\n* Emits an Approval event.\r\n* @param spender The address which will spend the funds.\r\n* @param subtractedValue The amount of tokens to decrease the allowance by.\r\n*/\r\nfunction decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\r\n_approve(msg.sender, spender, _allowed[msg.sender][spender].sub(subtractedValue));\r\nreturn true;\r\n}\r\n\r\n/**\r\n* @dev Transfer token for a specified addresses\r\n* @param from The address to transfer from.\r\n* @param to The address to transfer to.\r\n* @param value The amount to be transferred.\r\n*/\r\nfunction _transfer(address from, address to, uint256 value) internal {\r\nrequire(to != address(0));\r\n\r\n_balances[from] = _balances[from].sub(value);\r\n_balances[to] = _balances[to].add(value);\r\nemit Transfer(from, to, value);\r\n}\r\n\r\n/**\r\n* @dev Internal function that mints an amount of the token and assigns it to\r\n* an account. This encapsulates the modification of balances such that the\r\n* proper events are emitted.\r\n* @param account The account that will receive the created tokens.\r\n* @param value The amount that will be created.\r\n*/\r\nfunction _mint(address account, uint256 value) internal {\r\nrequire(account != address(0));\r\n\r\n_totalSupply = _totalSupply.add(value);\r\n_balances[account] = _balances[account].add(value);\r\nemit Transfer(address(0), account, value);\r\n}\r\n\r\n/**\r\n* @dev Internal function that burns an amount of the token of a given\r\n* account.\r\n* @param account The account whose tokens will be burnt.\r\n* @param value The amount that will be burnt.\r\n*/\r\nfunction _burn(address account, uint256 value) internal {\r\nrequire(account != address(0));\r\n\r\n_totalSupply = _totalSupply.sub(value);\r\n_balances[account] = _balances[account].sub(value);\r\nemit Transfer(account, address(0), value);\r\n}\r\n\r\n/**\r\n* @dev Approve an address to spend another addresses' tokens.\r\n* @param owner The address that owns the tokens.\r\n* @param spender The address that will spend the tokens.\r\n* @param value The number of tokens that can be spent.\r\n*/\r\nfunction _approve(address owner, address spender, uint256 value) internal {\r\nrequire(spender != address(0));\r\nrequire(owner != address(0));\r\n\r\n_allowed[owner][spender] = value;\r\nemit Approval(owner, spender, value);\r\n}\r\n\r\n/**\r\n* @dev Internal function that burns an amount of the token of a given\r\n* account, deducting from the sender's allowance for said account. Uses the\r\n* internal burn function.\r\n* Emits an Approval event (reflecting the reduced allowance).\r\n* @param account The account whose tokens will be burnt.\r\n* @param value The amount that will be burnt.\r\n*/\r\nfunction _burnFrom(address account, uint256 value) internal {\r\n_burn(account, value);\r\n_approve(account, msg.sender, _allowed[account][msg.sender].sub(value));\r\n}\r\n}\r\n\r\n\r\n\r\n/**\r\n* @title Ownable\r\n* @dev The Ownable contract has an owner address, and provides basic authorization control\r\n* functions, this simplifies the implementation of \"user permissions\".\r\n*/\r\ncontract Ownable {\r\naddress private _owner;\r\n\r\nevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n/**\r\n* @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n* account.\r\n*/\r\nconstructor () internal {\r\n_owner = msg.sender;\r\nemit OwnershipTransferred(address(0), _owner);\r\n}\r\n\r\n/**\r\n* @return the address of the owner.\r\n*/\r\nfunction owner() public view returns (address) {\r\nreturn _owner;\r\n}\r\n\r\n/**\r\n* @dev Throws if called by any account other than the owner.\r\n*/\r\nmodifier onlyOwner() {\r\nrequire(isOwner());\r\n_;\r\n}\r\n\r\n/**\r\n* @return true if `msg.sender` is the owner of the contract.\r\n*/\r\nfunction isOwner() public view returns (bool) {\r\nreturn msg.sender == _owner;\r\n}\r\n\r\n/**\r\n* @dev Allows the current owner to relinquish control of the contract.\r\n* It will not be possible to call the functions with the `onlyOwner`\r\n* modifier anymore.\r\n* @notice Renouncing ownership will leave the contract without an owner,\r\n* thereby removing any functionality that is only available to the owner.\r\n*/\r\nfunction renounceOwnership() public onlyOwner {\r\nemit OwnershipTransferred(_owner, address(0));\r\n_owner = address(0);\r\n}\r\n\r\n/**\r\n* @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n* @param newOwner The address to transfer ownership to.\r\n*/\r\nfunction transferOwnership(address newOwner) public onlyOwner {\r\n_transferOwnership(newOwner);\r\n}\r\n\r\n/**\r\n* @dev Transfers control of the contract to a newOwner.\r\n* @param newOwner The address to transfer ownership to.\r\n*/\r\nfunction _transferOwnership(address newOwner) internal {\r\nrequire(newOwner != address(0));\r\nemit OwnershipTransferred(_owner, newOwner);\r\n_owner = newOwner;\r\n}\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n* @title ERC20Detailed token\r\n* @dev The decimals are only for visualization purposes.\r\n* All the operations are done using the smallest and indivisible token unit,\r\n* just as on Ethereum all the operations are done in wei.\r\n*/\r\ncontract ERC20Detailed is IERC20 {\r\nstring private _name;\r\nstring private _symbol;\r\nuint8 private _decimals;\r\n\r\nconstructor (string memory name, string memory symbol, uint8 decimals) public {\r\n_name = name;\r\n_symbol = symbol;\r\n_decimals = decimals;\r\n}\r\n\r\n/**\r\n* @return the name of the token.\r\n*/\r\nfunction name() public view returns (string memory) {\r\nreturn _name;\r\n}\r\n\r\n/**\r\n* @return the symbol of the token.\r\n*/\r\nfunction symbol() public view returns (string memory) {\r\nreturn _symbol;\r\n}\r\n\r\n/**\r\n* @return the number of decimals of the token.\r\n*/\r\nfunction decimals() public view returns (uint8) {\r\nreturn _decimals;\r\n}\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n* @title ERC20Mintable\r\n* @dev ERC20 minting logic\r\n*/\r\ncontract ERC20Mintable is ERC20, MinterRole {\r\n/**\r\n* @dev Function to mint tokens\r\n* @param to The address that will receive the minted tokens.\r\n* @param value The amount of tokens to mint.\r\n* @return A boolean that indicates if the operation was successful.\r\n*/\r\nfunction mint(address to, uint256 value) public onlyMinter returns (bool) {\r\n_mint(to, value);\r\nreturn true;\r\n}\r\n}\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n* @title Capped token\r\n* @dev Mintable token with a token cap.\r\n*/\r\ncontract ERC20Capped is ERC20Mintable {\r\nuint256 private _cap;\r\n\r\nconstructor (uint256 cap) public {\r\nrequire(cap > 0);\r\n_cap = cap;\r\n}\r\n\r\n/**\r\n* @return the cap for the token minting.\r\n*/\r\nfunction cap() public view returns (uint256) {\r\nreturn _cap;\r\n}\r\n\r\nfunction _mint(address account, uint256 value) internal {\r\nrequire(totalSupply().add(value) <= _cap);\r\nsuper._mint(account, value);\r\n}\r\n}\r\n\r\n\r\ncontract PictosisGenesisToken is ERC20, ERC20Detailed, ERC20Mintable, ERC20Capped {\r\naddress public exchangeContract;\r\n\r\nconstructor()\r\nERC20Capped(125000000000000000000000000)\r\nERC20Mintable()\r\nERC20Detailed(\"Pictosis Genesis Token\", \"PICTO-G\", 18)\r\nERC20()\r\npublic\r\n{\r\n}\r\n\r\nfunction burnFrom(address from, uint256 value) public onlyMinter {\r\n_burnFrom(from, value);\r\n}\r\n\r\nfunction setExchangeContract(address _exchangeContract) public onlyMinter {\r\nexchangeContract = _exchangeContract;\r\n}\r\n\r\nfunction completeExchange(address from) public {\r\nrequire(msg.sender == exchangeContract && exchangeContract != address(0), \"Only the exchange contract can invoke this function\");\r\n_burnFrom(from, balanceOf(from));\r\n}\r\n\r\nfunction transfer(address to, uint256 value) public returns (bool) {\r\nrevert(\"Token can only be exchanged for PICTO tokens in the exchange contract\");\r\n}\r\n\r\nuint256 constant D160 = 0x0010000000000000000000000000000000000000000;\r\n\r\n// data is an array of uint256s. Each uint256 represents a transfer.\r\n// The 160 LSB is the destination of the address that wants to be sent\r\n// The 96 MSB is the amount of tokens that wants to be sent.\r\n// i.e. assume we want to mint 1200 tokens for address 0xABCDEFAABBCCDDEEFF1122334455667788990011\r\n// 1200 in hex: 0x0000410d586a20a4c00000. Concatenate this value and the address\r\n// [\"0x0000410d586a20a4c00000ABCDEFAABBCCDDEEFF1122334455667788990011\"]\r\nfunction multiMint(uint256[] memory data) public onlyMinter {\r\nfor (uint256 i = 0; i < data.length; i++) {\r\naddress addr = address(data[i] & (D160 - 1));\r\nuint256 amount = data[i] / D160;\r\n_mint(addr, amount);\r\n}\r\n}\r\n\r\n/// @notice This method can be used by the minter to extract mistakenly\r\n/// sent tokens to this contract.\r\n/// @param _token The address of the token contract that you want to recover\r\n/// set to 0x0000...0000 in case you want to extract ether.\r\nfunction claimTokens(address _token) public onlyMinter {\r\nif (_token == address(0)) {\r\nmsg.sender.transfer(address(this).balance);\r\nreturn;\r\n}\r\n\r\nERC20 token = ERC20(_token);\r\nuint256 balance = token.balanceOf(address(this));\r\ntoken.transfer(msg.sender, balance);\r\nemit ClaimedTokens(_token, msg.sender, balance);\r\n}\r\n\r\nevent ClaimedTokens(address indexed _token, address indexed _sender, uint256 _amount);\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n* @title Arrays\r\n* @dev Utility library of inline array functions\r\n*/\r\nlibrary Arrays {\r\n/**\r\n* @dev Upper bound search function which is kind of binary search algorithm. It searches sorted\r\n* array to find index of the element value. If element is found then returns its index otherwise\r\n* it returns index of first element which is greater than searched value. If searched element is\r\n* bigger than any array element function then returns first index after last element (i.e. all\r\n* values inside the array are smaller than the target). Complexity O(log n).\r\n* @param array The array sorted in ascending order.\r\n* @param element The element's value to be found.\r\n* @return The calculated index value. Returns 0 for empty array.\r\n*/\r\nfunction findUpperBound(uint256[] storage array, uint256 element) internal view returns (uint256) {\r\nif (array.length == 0) {\r\nreturn 0;\r\n}\r\n\r\nuint256 low = 0;\r\nuint256 high = array.length;\r\n\r\nwhile (low < high) {\r\nuint256 mid = Math.average(low, high);\r\n\r\n// Note that mid will always be strictly less than high (i.e. it will be a valid array index)\r\n// because Math.average rounds down (it does integer division with truncation).\r\nif (array[mid] > element) {\r\nhigh = mid;\r\n} else {\r\nlow = mid + 1;\r\n}\r\n}\r\n\r\n// At this point `low` is the exclusive upper bound. We will return the inclusive upper bound.\r\nif (low > 0 && array[low - 1] == element) {\r\nreturn low - 1;\r\n} else {\r\nreturn low;\r\n}\r\n}\r\n}\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n* @title Counters\r\n* @author Matt Condon (@shrugs)\r\n* @dev Provides counters that can only be incremented or decremented by one. This can be used e.g. to track the number\r\n* of elements in a mapping, issuing ERC721 ids, or counting request ids\r\n*\r\n* Include with `using Counters for Counters.Counter;`\r\n* Since it is not possible to overflow a 256 bit integer with increments of one, `increment` can skip the SafeMath\r\n* overflow check, thereby saving gas. This does assume however correct usage, in that the underlying `_value` is never\r\n* directly accessed.\r\n*/\r\nlibrary Counters {\r\nusing SafeMath for uint256;\r\n\r\nstruct Counter {\r\n// This variable should never be directly accessed by users of the library: interactions must be restricted to\r\n// the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\r\n// this feature: see https://github.com/ethereum/solidity/issues/4637\r\nuint256 _value; // default: 0\r\n}\r\n\r\nfunction current(Counter storage counter) internal view returns (uint256) {\r\nreturn counter._value;\r\n}\r\n\r\nfunction increment(Counter storage counter) internal {\r\ncounter._value += 1;\r\n}\r\n\r\nfunction decrement(Counter storage counter) internal {\r\ncounter._value = counter._value.sub(1);\r\n}\r\n}\r\n\r\n\r\n\r\n/**\r\n* @title ERC20 token with snapshots.\r\n* @dev Inspired by Jordi Baylina's MiniMeToken to record historical balances:\r\n* https://github.com/Giveth/minime/blob/ea04d950eea153a04c51fa510b068b9dded390cb/contracts/MiniMeToken.sol\r\n* When a snapshot is made, the balances and totalSupply at the time of the snapshot are recorded for later\r\n* access.\r\n*\r\n* To make a snapshot, call the `snapshot` function, which will emit the `Snapshot` event and return a snapshot id.\r\n* To get the total supply from a snapshot, call the function `totalSupplyAt` with the snapshot id.\r\n* To get the balance of an account from a snapshot, call the `balanceOfAt` function with the snapshot id and the\r\n* account address.\r\n* @author Validity Labs AG <info@validitylabs.org>\r\n*/\r\ncontract ERC20Snapshot is ERC20 {\r\nusing SafeMath for uint256;\r\nusing Arrays for uint256[];\r\nusing Counters for Counters.Counter;\r\n\r\n// Snapshotted values have arrays of ids and the value corresponding to that id. These could be an array of a\r\n// Snapshot struct, but that would impede usage of functions that work on an array.\r\nstruct Snapshots {\r\nuint256[] ids;\r\nuint256[] values;\r\n}\r\n\r\nmapping (address => Snapshots) private _accountBalanceSnapshots;\r\nSnapshots private _totalSupplySnaphots;\r\n\r\n// Snapshot ids increase monotonically, with the first value being 1. An id of 0 is invalid.\r\nCounters.Counter private _currentSnapshotId;\r\n\r\nevent Snapshot(uint256 id);\r\n\r\n// Creates a new snapshot id. Balances are only stored in snapshots on demand: unless a snapshot was taken, a\r\n// balance change will not be recorded. This means the extra added cost of storing snapshotted balances is only paid\r\n// when required, but is also flexible enough that it allows for e.g. daily snapshots.\r\nfunction snapshot() public returns (uint256) {\r\n_currentSnapshotId.increment();\r\n\r\nuint256 currentId = _currentSnapshotId.current();\r\nemit Snapshot(currentId);\r\nreturn currentId;\r\n}\r\n\r\nfunction balanceOfAt(address account, uint256 snapshotId) public view returns (uint256) {\r\n(bool snapshotted, uint256 value) = _valueAt(snapshotId, _accountBalanceSnapshots[account]);\r\n\r\nreturn snapshotted ? value : balanceOf(account);\r\n}\r\n\r\nfunction totalSupplyAt(uint256 snapshotId) public view returns(uint256) {\r\n(bool snapshotted, uint256 value) = _valueAt(snapshotId, _totalSupplySnaphots);\r\n\r\nreturn snapshotted ? value : totalSupply();\r\n}\r\n\r\n// _transfer, _mint and _burn are the only functions where the balances are modified, so it is there that the\r\n// snapshots are updated. Note that the update happens _before_ the balance change, with the pre-modified value.\r\n// The same is true for the total supply and _mint and _burn.\r\nfunction _transfer(address from, address to, uint256 value) internal {\r\n_updateAccountSnapshot(from);\r\n_updateAccountSnapshot(to);\r\n\r\nsuper._transfer(from, to, value);\r\n}\r\n\r\nfunction _mint(address account, uint256 value) internal {\r\n_updateAccountSnapshot(account);\r\n_updateTotalSupplySnapshot();\r\n\r\nsuper._mint(account, value);\r\n}\r\n\r\nfunction _burn(address account, uint256 value) internal {\r\n_updateAccountSnapshot(account);\r\n_updateTotalSupplySnapshot();\r\n\r\nsuper._burn(account, value);\r\n}\r\n\r\n// When a valid snapshot is queried, there are three possibilities:\r\n// a) The queried value was not modified after the snapshot was taken. Therefore, a snapshot entry was never\r\n// created for this id, and all stored snapshot ids are smaller than the requested one. The value that corresponds\r\n// to this id is the current one.\r\n// b) The queried value was modified after the snapshot was taken. Therefore, there will be an entry with the\r\n// requested id, and its value is the one to return.\r\n// c) More snapshots were created after the requested one, and the queried value was later modified. There will be\r\n// no entry for the requested id: the value that corresponds to it is that of the smallest snapshot id that is\r\n// larger than the requested one.\r\n//\r\n// In summary, we need to find an element in an array, returning the index of the smallest value that is larger if\r\n// it is not found, unless said value doesn't exist (e.g. when all values are smaller). Arrays.findUpperBound does\r\n// exactly this.\r\nfunction _valueAt(uint256 snapshotId, Snapshots storage snapshots)\r\nprivate view returns (bool, uint256)\r\n{\r\nrequire(snapshotId > 0);\r\nrequire(snapshotId <= _currentSnapshotId.current());\r\n\r\nuint256 index = snapshots.ids.findUpperBound(snapshotId);\r\n\r\nif (index == snapshots.ids.length) {\r\nreturn (false, 0);\r\n} else {\r\nreturn (true, snapshots.values[index]);\r\n}\r\n}\r\n\r\nfunction _updateAccountSnapshot(address account) private {\r\n_updateSnapshot(_accountBalanceSnapshots[account], balanceOf(account));\r\n}\r\n\r\nfunction _updateTotalSupplySnapshot() private {\r\n_updateSnapshot(_totalSupplySnaphots, totalSupply());\r\n}\r\n\r\nfunction _updateSnapshot(Snapshots storage snapshots, uint256 currentValue) private {\r\nuint256 currentId = _currentSnapshotId.current();\r\nif (_lastSnapshotId(snapshots.ids) < currentId) {\r\nsnapshots.ids.push(currentId);\r\nsnapshots.values.push(currentValue);\r\n}\r\n}\r\n\r\nfunction _lastSnapshotId(uint256[] storage ids) private view returns (uint256) {\r\nif (ids.length == 0) {\r\nreturn 0;\r\n} else {\r\nreturn ids[ids.length - 1];\r\n}\r\n}\r\n}\r\n\r\n\r\n\r\n\r\ncontract PictosisToken is ERC20, ERC20Detailed, ERC20Mintable, ERC20Capped, ERC20Snapshot, Ownable {\r\nuint transfersEnabledDate;\r\n\r\nmodifier onlyTransfersEnabled() {\r\nrequire(block.timestamp >= transfersEnabledDate, \"Transfers disabled\");\r\n_;\r\n}\r\n\r\nconstructor(uint _enableTransfersDate, uint _cap)\r\nERC20Capped(_cap)\r\nERC20Mintable()\r\nERC20Detailed(\"Pictosis Token\", \"PICTO\", 18)\r\nERC20()\r\nOwnable()\r\npublic\r\n{\r\ntransfersEnabledDate = _enableTransfersDate;\r\n}\r\n\r\nfunction areTransfersEnabled() public view returns(bool) {\r\nreturn block.timestamp >= transfersEnabledDate;\r\n}\r\n\r\nfunction transfer(\r\naddress to,\r\nuint256 value\r\n)\r\npublic\r\nonlyTransfersEnabled\r\nreturns (bool)\r\n{\r\nreturn super.transfer(to, value);\r\n}\r\n\r\nfunction transferFrom(\r\naddress from,\r\naddress to,\r\nuint256 value\r\n)\r\npublic\r\nonlyTransfersEnabled\r\nreturns (bool)\r\n{\r\nreturn super.transferFrom(from, to, value);\r\n}\r\n\r\n/// @notice `msg.sender` approves `_spender` to send `_amount` tokens on\r\n/// its behalf, and then a function is triggered in the contract that is\r\n/// being approved, `_spender`. This allows users to use their tokens to\r\n/// interact with contracts in one function call instead of two\r\n/// @param _spender The address of the contract able to transfer the tokens\r\n/// @param _amount The amount of tokens to be approved for transfer\r\n/// @return True if the function call was successful\r\nfunction approveAndCall(\r\naddress _spender,\r\nuint256 _amount,\r\nbytes memory _extraData\r\n)\r\npublic\r\nreturns (bool success)\r\n{\r\nrequire(approve(_spender, _amount), \"Couldn't approve spender\");\r\n\r\nApproveAndCallFallBack(_spender).receiveApproval(msg.sender, _amount, address(this), _extraData);\r\n\r\nreturn true;\r\n}\r\n}\r\n\r\ncontract PictosisGenesisExchanger is Ownable {\r\nusing SafeMath for uint256;\r\n\r\nmapping (address => uint256) public collected;\r\nuint256 public totalCollected;\r\n\r\nPictosisGenesisToken public genesis;\r\nPictosisToken public picto;\r\n\r\nconstructor(address _genesis, address _picto) public {\r\ngenesis = PictosisGenesisToken(_genesis);\r\npicto = PictosisToken(_picto);\r\n}\r\n\r\n/// @notice Can collect tokens;\r\nfunction canCollect() public view returns(bool) {\r\nreturn picto.areTransfersEnabled();\r\n}\r\n\r\n/// @notice This method should be called by the genesis holders to collect their picto token. Requires approval\r\nfunction collect() public {\r\nrequire(picto.areTransfersEnabled(), \"Cannot collect tokens yet\");\r\n\r\nuint balance = genesis.balanceOf(msg.sender);\r\nuint256 amountToSend = balance.sub(collected[msg.sender]);\r\n\r\nrequire(balance >= collected[msg.sender], \"Balance must be greater than collected amount\");\r\nrequire(amountToSend > 0, \"No tokens available or already exchanged\");\r\nrequire(picto.balanceOf(address(this)) >= amountToSend, \"Exchanger does not have funds available\");\r\n\r\ntotalCollected = totalCollected.add(amountToSend);\r\ncollected[msg.sender] = collected[msg.sender].add(amountToSend);\r\n\r\nrequire(picto.transfer(msg.sender, amountToSend), \"Transfer failure\");\r\n\r\nemit TokensCollected(msg.sender, amountToSend);\r\n}\r\n\r\n/// @notice This method can be used by the minter to extract mistakenly\r\n/// sent tokens to this contract.\r\n/// @param _token The address of the token contract that you want to recover\r\n/// set to 0x0000...0000 in case you want to extract ether.\r\nfunction claimTokens(address _token) public onlyOwner {\r\nif (_token == address(0)) {\r\nmsg.sender.transfer(address(this).balance);\r\nreturn;\r\n}\r\n\r\nERC20 token = ERC20(_token);\r\nuint256 balance = token.balanceOf(address(this));\r\n\r\nif(_token == address(picto)){\r\nif(balance > genesis.totalSupply()){\r\nbalance = balance.sub(genesis.totalSupply());\r\n}\r\nrequire(balance >= genesis.totalSupply(), \"Cannot withdraw PICTO until everyone exchanges the tokens\");\r\n}\r\n\r\ntoken.transfer(msg.sender, balance);\r\nemit ClaimedTokens(_token, msg.sender, balance);\r\n}\r\n\r\nevent ClaimedTokens(address indexed _token, address indexed _controller, uint256 _amount);\r\nevent TokensCollected(address indexed _holder, uint256 _amount);\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"collected\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"genesis\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"canCollect\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"claimTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"picto\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalCollected\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"collect\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_genesis\",\"type\":\"address\"},{\"name\":\"_picto\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_token\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_controller\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"ClaimedTokens\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_holder\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"TokensCollected\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"PictosisGenesisExchanger","CompilerVersion":"v0.5.9+commit.e560f70d","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"0000000000000000000000009555b1f05a3b6ffbfe7332d23ac0585491fbc03c00000000000000000000000074cf8b4e3737229b46a565a1d2bfc4be503a79bc","Library":"","SwarmSource":"bzzr://53692e49723352a2a88cbcd1d334fdaa2a2c36b6c8eb07aa8ee5d4f29fa55a52"}]}