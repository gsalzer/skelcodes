{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity >=0.4.22 <0.6.0;\r\n//import \"github.com/oraclize/ethereum-api/oraclizeAPI.sol\";\r\n\r\ncontract LongHuContract {\r\n  uint  maxProfit;//最高奖池\r\n  uint  maxmoneypercent;\r\n  uint public contractBalance;\r\n  //uint  oraclizeFee;\r\n  //uint  oraclizeGasLimit;\r\n  uint minBet;\r\n  uint onoff;//游戏启用或关闭\r\n  address private owner;\r\n  uint private orderId;\r\n  uint private randonce;\r\n\r\n  event LogNewOraclizeQuery(string description,bytes32 queryId);\r\n  event LogNewRandomNumber(string result,bytes32 queryId);\r\n  event LogSendBonus(uint id,bytes32 lableId,uint playId,uint content,uint singleMoney,uint mutilple,address user,uint betTime,uint status,uint winMoney);\r\n  event LogBet(bytes32 queryId);\r\n\r\n  mapping (address => bytes32[]) playerLableList;////玩家下注批次\r\n  mapping (bytes32 => mapping (uint => uint[7])) betList;//批次，注单映射\r\n  mapping (bytes32 => uint) lableCount;//批次，注单数\r\n  mapping (bytes32 => uint) lableTime;//批次，投注时间\r\n  mapping (bytes32 => uint) lableStatus;//批次，状态 0 未结算，1 已撤单，2 已结算 3 已派奖\r\n  mapping (bytes32 => uint[4]) openNumberList;//批次开奖号码映射\r\n  mapping (bytes32 => string) openNumberStr;//批次开奖号码映射\r\n  mapping (bytes32 => address payable) lableUser;\r\n\r\n  bytes tempNum ; //temporarily hold the string part until a space is recieved\r\n  uint[] numbers;\r\n\r\n  constructor() public {\r\n    owner = msg.sender;\r\n    orderId = 0;\r\n    onoff=1;\r\n    //minBet=1500000000000000;//最小金额要比手续费大\r\n    //oraclizeFee=1200000000000000;\r\n    maxmoneypercent=80;\r\n    //oraclizeGasLimit=200000;\r\n    contractBalance = address(this).balance;\r\n    maxProfit=(address(this).balance * maxmoneypercent)/100;\r\n    //oraclize_setCustomGasPrice(3000000000);\r\n    randonce = 0;\r\n  }\r\n\r\n  modifier onlyAdmin() {\r\n      require(msg.sender == owner);\r\n      _;\r\n  }\r\n  //modifier onlyOraclize {\r\n  //    require (msg.sender == oraclize_cbAddress());\r\n  //    _;\r\n // }\r\n\r\n  function setGameOnoff(uint _on0ff) public onlyAdmin{\r\n    onoff=_on0ff;\r\n  }\r\n\r\n  function getPlayRate(uint playId,uint level) internal pure returns (uint){\r\n      uint result = 0;\r\n      if(playId == 1 || playId == 3){\r\n        result = 19;//10bei\r\n      }else if(playId == 2){\r\n        result = 9;\r\n      }\r\n      return result;\r\n    }\r\n\r\n    function doBet(uint[] memory playid,uint[] memory betMoney,uint[] memory betContent,uint mutiply) public payable returns (bytes32 queryId) {\r\n      require(onoff==1);\r\n      require(playid.length > 0);\r\n      require(mutiply > 0);\r\n      require(msg.value >= minBet);\r\n\r\n      checkBet(playid,betMoney,betContent,mutiply,msg.value);\r\n\r\n      /* uint total = 0; */\r\n      bytes32 queryId;\r\n      queryId = keccak256(abi.encodePacked(blockhash(block.number-1),now,randonce));\r\n      //  uint oraGasLimit = oraclizeGasLimit;\r\n      //  if(playid.length > 1 && playid.length <= 3){\r\n      //      oraGasLimit = 600000;\r\n      //  }else{\r\n      //      oraGasLimit = 1000000;\r\n      //  }\r\n        emit LogNewOraclizeQuery(\"Oraclize query was sent, standing by for the answer..\",queryId);\r\n      //  queryId = oraclize_query(\"URL\", \"json(https://api.random.org/json-rpc/1/invoke).result.random.data\", '\\n{\"jsonrpc\":\"2.0\",\"method\":\"generateIntegers\",\"params\":{\"apiKey\":\"8817de90-6e86-4d0d-87ec-3fd9b437f711\",\"n\":4,\"min\":1,\"max\":52,\"replacement\":false,\"base\":10},\"id\":1}',oraGasLimit);\r\n      /* } */\r\n\r\n       uint[7] memory tmp ;\r\n       uint totalspand = 0;\r\n      for(uint i=0;i<playid.length;i++){\r\n        orderId++;\r\n        tmp[0] =orderId;\r\n        tmp[1] =playid[i];\r\n        tmp[2] =betContent[i];\r\n        tmp[3] =betMoney[i]*mutiply;\r\n        totalspand +=betMoney[i]*mutiply;\r\n        tmp[4] =now;\r\n        tmp[5] =0;\r\n        tmp[6] =0;\r\n        betList[queryId][i] =tmp;\r\n      }\r\n      require(msg.value >= totalspand);\r\n\r\n      lableTime[queryId] = now;\r\n      lableCount[queryId] = playid.length;\r\n      lableUser[queryId] = msg.sender;\r\n      uint[4] memory codes = [uint(0),0,0,0];\r\n      openNumberList[queryId] = codes;\r\n      openNumberStr[queryId] =\"0,0,0,0\";\r\n      lableStatus[queryId] = 0;\r\n\r\n      uint index=playerLableList[msg.sender].length++;\r\n      playerLableList[msg.sender][index]=queryId;//index:id\r\n      emit LogBet(queryId);\r\n      opencode(queryId);\r\n      return queryId;\r\n    }\r\n\r\n    function opencode(bytes32 queryId) private {\r\n      if (lableCount[queryId] < 1) revert();\r\n      uint[4] memory codes = [uint(0),0,0,0];//开奖号码\r\n\r\n      bytes32 code0hash = keccak256(abi.encodePacked(blockhash(block.number-1), now,msg.sender,randonce));\r\n      randonce  = randonce + uint(code0hash)%1000;\r\n      //uint code0int = uint(code0hash) % 52 + 1;\r\n      codes[0] = uint(code0hash) % 52 + 1;\r\n      string memory code0 =uint2str(uint(code0hash) % 52 + 1);\r\n\r\n      bytes32 code1hash = keccak256(abi.encodePacked(blockhash(block.number-1), now,msg.sender,randonce));\r\n      randonce  = randonce + uint(code1hash)%1000;\r\n      //uint code1int = uint(code1hash) % 52 + 1;\r\n      codes[1] = uint(code1hash) % 52 + 1;\r\n      string memory code1=uint2str(uint(code1hash) % 52 + 1);\r\n\r\n      bytes32 code2hash = keccak256(abi.encodePacked(blockhash(block.number-1), now,msg.sender,randonce));\r\n      randonce  = randonce + uint(code2hash)%1000;\r\n      //uint code2int = uint(code2hash) % 52 + 1;\r\n      codes[2] = uint(code2hash) % 52 + 1;\r\n      string memory code2=uint2str(uint(code2hash) % 52 + 1);\r\n\r\n      bytes32 code3hash = keccak256(abi.encodePacked(blockhash(block.number-1), now,msg.sender,randonce));\r\n      randonce  = randonce + uint(code3hash)%1000;\r\n      //uint code3int = uint(code3hash) % 52 + 1;\r\n      codes[3] = uint(code3hash) % 52 + 1;\r\n      string memory code3=uint2str(uint(code3hash) % 52 + 1);\r\n\r\n      //string memory code0 =uint2str(code0int);\r\n      //string memory code1=uint2str(code1int);\r\n      //string memory code2=uint2str(code2int);\r\n      //string memory code3=uint2str(code3int);\r\n      //codes[0] = code0int;\r\n      //codes[1] = code1int;\r\n      //codes[2] = code2int;\r\n      //codes[3] = code3int;\r\n      openNumberList[queryId] = codes;\r\n      string memory codenum = \"\";\r\n      codenum = strConcat(code0,\",\",code1,\",\",code2);\r\n      openNumberStr[queryId] = strConcat(codenum,\",\",code3);\r\n      //结算，派奖\r\n      doCheckBounds(queryId);\r\n    }\r\n\r\n    function checkBet(uint[] memory playid,uint[] memory betMoney,uint[] memory betContent,uint mutiply,uint betTotal) internal{\r\n        uint totalMoney = 0;\r\n      uint totalWin1 = 0;\r\n      uint totalWin2 = 0;\r\n      uint rate;\r\n      uint i;\r\n      for(i=0;i<playid.length;i++){\r\n        if(playid[i] >=1 && playid[i]<= 3){\r\n          totalMoney += betMoney[i] * mutiply;\r\n        }else{\r\n          revert();\r\n        }\r\n        if(playid[i] ==1 || playid[i] ==3){//龙虎\r\n          rate = getPlayRate(playid[i],0);\r\n          totalWin1+=betMoney[i] * mutiply *rate/10;\r\n          totalWin2+=betMoney[i] * mutiply *rate/10;\r\n        }else if(playid[i] ==2){//和\r\n          rate = getPlayRate(playid[i],0);\r\n          totalWin2+=betMoney[i] * mutiply *rate;\r\n        }\r\n      }\r\n      uint maxWin=totalWin1;\r\n      if(totalWin2 > maxWin){\r\n        maxWin=totalWin2;\r\n      }\r\n      require(betTotal >= totalMoney);\r\n\r\n      require(maxWin < maxProfit);\r\n    }\r\n    /*\r\n    function __callback(bytes32 queryId, string memory result) public onlyOraclize {\r\n        if (lableCount[queryId] < 1) revert();\r\n      if (msg.sender != oraclize_cbAddress()) revert();\r\n        emit LogNewRandomNumber(result,queryId);\r\n        bytes memory tmp = bytes(result);\r\n        uint[4] memory codes = [uint(0),0,0,0];\r\n        uint [] memory codess ;\r\n        codess = splitStr(result,\",\");\r\n        uint k = 0;\r\n        for(uint i = 0;i<codess.length;i++){\r\n            if(k < codes.length){\r\n                     codes[k] = codess[i];\r\n                     k++;\r\n            }\r\n        }\r\n\r\n        string memory code0=uint2str(codes[0]);\r\n        string memory code1=uint2str(codes[1]);\r\n        string memory code2=uint2str(codes[2]);\r\n        string memory code3=uint2str(codes[3]);\r\n        openNumberList[queryId] = codes;\r\n        string memory codenum = \"\";\r\n        codenum = strConcat(code0,\",\",code1,\",\",code2);\r\n        openNumberStr[queryId] = strConcat(codenum,\",\",code3);\r\n        doCheckBounds(queryId);\r\n    }\r\n    */\r\n    function doCancel(bytes32 queryId) internal {\r\n      uint sta = lableStatus[queryId];\r\n      require(sta == 0);\r\n      uint[4] memory codes = openNumberList[queryId];\r\n      require(codes[0] == 0 || codes[1] == 0 ||codes[2] == 0 ||codes[3] == 0);\r\n\r\n      uint totalBet = 0;\r\n      uint len = lableCount[queryId];\r\n\r\n      address payable to = lableUser[queryId];\r\n      for(uint aa = 0 ; aa<len; aa++){\r\n        //未结算\r\n        if(betList[queryId][aa][5] == 0){\r\n          totalBet+=betList[queryId][aa][3];\r\n        }\r\n      }\r\n\r\n      if(totalBet > 0){\r\n        to.transfer(totalBet);\r\n      }\r\n      contractBalance=address(this).balance;\r\n      maxProfit=(address(this).balance * maxmoneypercent)/100;\r\n      lableStatus[queryId] = 1;\r\n    }\r\n\r\n    function doSendBounds(bytes32 queryId) public payable {\r\n      uint sta = lableStatus[queryId];\r\n      require(sta == 2);\r\n\r\n      uint totalWin = 0;\r\n      uint len = lableCount[queryId];\r\n\r\n      address payable to = lableUser[queryId];\r\n      for(uint aa = 0 ; aa<len; aa++){\r\n        //中奖\r\n        if(betList[queryId][aa][5] == 2){\r\n          totalWin+=betList[queryId][aa][6];\r\n        }\r\n      }\r\n\r\n      if(totalWin > 0){\r\n          to.transfer(totalWin);//转账\r\n      }\r\n      lableStatus[queryId] = 3;\r\n      contractBalance=address(this).balance;\r\n      maxProfit=(address(this).balance * maxmoneypercent)/100;\r\n    }\r\n\r\n    //中奖判断\r\n    function checkWinMoney(uint[7] storage betinfo,uint[4] memory codes) internal {\r\n      uint rates;\r\n      uint code0 = codes[0]%13==0?13:codes[0]%13;\r\n      uint code1 = codes[1]%13==0?13:codes[1]%13;\r\n      uint code2 = codes[2]%13==0?13:codes[2]%13;\r\n      uint code3 = codes[3]%13==0?13:codes[3]%13;\r\n      uint  onecount = code0 + code2;\r\n      uint  twocount = code1 + code3;\r\n      onecount = onecount%10;\r\n      twocount = twocount%10;\r\n      if(betinfo[1] ==1){//long\r\n          if(onecount > twocount){\r\n              betinfo[5]=2;\r\n              rates = getPlayRate(betinfo[1],0);\r\n              betinfo[6]=betinfo[3]*rates/10;\r\n          }else{\r\n             // if(onecount == twocount){//和\r\n             //     betinfo[5]=2;\r\n             //     rates = 1;\r\n             //     betinfo[6]=betinfo[3]*rates;\r\n             // }else{\r\n                  betinfo[5]=1;\r\n             // }\r\n          }\r\n      }else if(betinfo[1] == 2){//和\r\n          if(onecount == twocount){\r\n            betinfo[5]=2;\r\n            rates = getPlayRate(betinfo[1],0);\r\n            betinfo[6]=betinfo[3]*rates;\r\n          }else{\r\n            betinfo[5]=1;\r\n          }\r\n\r\n        }else if(betinfo[1] == 3){//虎\r\n          betinfo[5]=1;\r\n          if(onecount < twocount ){\r\n            betinfo[5]=2;\r\n            rates = getPlayRate(betinfo[1],0);\r\n            betinfo[6]=betinfo[3]*rates/10;\r\n          }else{\r\n              //if(onecount == twocount){//和\r\n              //    betinfo[5]=2;\r\n              //    rates = 1;\r\n              //    betinfo[6]=betinfo[3]*rates;\r\n             // }else{\r\n                  betinfo[5]=1;\r\n             // }\r\n          }\r\n        }\r\n\r\n    }\r\n\r\n    function getLastBet() public view returns(string memory opennum,uint[7][] memory result){\r\n      uint len=playerLableList[msg.sender].length;\r\n      require(len>0);\r\n\r\n      uint i=len-1;\r\n      bytes32 lastLable = playerLableList[msg.sender][i];\r\n      uint max = lableCount[lastLable];\r\n      if(max > 50){\r\n          max = 50;\r\n      }\r\n      uint[7][] memory result = new uint[7][](max) ;\r\n      string memory opennum = \"\";\r\n      for(uint a=0;a<max;a++){\r\n         string memory ttmp =openNumberStr[lastLable];\r\n         if(a==0){\r\n           opennum =ttmp;\r\n         }else{\r\n           opennum = strConcat(opennum,\";\",ttmp);\r\n         }\r\n\r\n         result[a] = betList[lastLable][a];\r\n         if(lableStatus[lastLable] == 1){\r\n           result[a][5]=3;\r\n         }\r\n\r\n      }\r\n\r\n      return (opennum,result);\r\n    }\r\n\r\n    function getLableRecords(bytes32 lable) public view returns(string memory opennum,uint[7][] memory result){\r\n      uint max = lableCount[lable];\r\n      if(max > 50){\r\n          max = 50;\r\n      }\r\n      uint[7][] memory result = new uint[7][](max) ;\r\n      string memory opennum=\"\";\r\n\r\n      for(uint a=0;a<max;a++){\r\n         result[a] = betList[lable][a];\r\n         if(lableStatus[lable] == 1){\r\n           result[a][5]=3;\r\n         }\r\n         string memory ttmp =openNumberStr[lable];\r\n         if(a==0){\r\n           opennum =ttmp;\r\n         }else{\r\n           opennum = strConcat(opennum,\";\",ttmp);\r\n         }\r\n      }\r\n\r\n      return (opennum,result);\r\n    }\r\n\r\n    function getAllRecords() public view returns(string  memory opennum,uint[7][] memory result){\r\n        uint len=playerLableList[msg.sender].length;\r\n        require(len>0);\r\n\r\n        uint max;\r\n        bytes32 lastLable ;\r\n        uint ss;\r\n\r\n        for(uint i1=0;i1<len;i1++){\r\n            ss = len-i1-1;\r\n            lastLable = playerLableList[msg.sender][ss];\r\n            max += lableCount[lastLable];\r\n            if(100 < max){\r\n              max = 100;\r\n              break;\r\n            }\r\n        }\r\n\r\n        uint[7][] memory result = new uint[7][](max) ;\r\n        bytes32[] memory resultlable = new bytes32[](max) ;\r\n        string memory opennum=\"\";\r\n\r\n        bool flag=false;\r\n        uint betnums;\r\n        uint j=0;\r\n\r\n        for(uint ii=0;ii<len;ii++){\r\n            ss = len-ii-1;\r\n            lastLable = playerLableList[msg.sender][ss];\r\n            betnums = lableCount[lastLable];\r\n            for(uint k= 0; k<betnums; k++){\r\n              if(j<max){\r\n                  resultlable[j] = lastLable;\r\n              \t string memory ttmp =openNumberStr[lastLable];\r\n                 if(j==0){\r\n                   opennum =ttmp;\r\n                 }else{\r\n                   opennum = strConcat(opennum,\";\",ttmp);\r\n                 }\r\n                  result[j] = betList[lastLable][k];\r\n                  if(lableStatus[lastLable] == 1){\r\n                    result[j][5]=3;\r\n                  }else if(lableStatus[lastLable] == 2){\r\n                    if(result[j][5]==2){\r\n                      result[j][5]=4;\r\n                    }\r\n                  }else if(lableStatus[lastLable] == 3){\r\n                    if(result[j][5]==2){\r\n                      result[j][5]=5;\r\n                    }\r\n                  }\r\n                  j++;\r\n              }else{\r\n                flag = true;\r\n                break;\r\n              }\r\n            }\r\n            if(flag){\r\n                break;\r\n            }\r\n        }\r\n        return (opennum,result);\r\n    }\r\n\r\n  //function setoraclegasprice(uint newGas) public onlyAdmin(){\r\n  //  oraclize_setCustomGasPrice(newGas * 1 wei);\r\n  //}\r\n  //function setoraclelimitgas(uint _oraclizeGasLimit) public onlyAdmin(){\r\n  //  oraclizeGasLimit=(_oraclizeGasLimit);\r\n  //}\r\n\r\n  function senttest() public payable onlyAdmin{\r\n      contractBalance=address(this).balance;\r\n      maxProfit=(address(this).balance*maxmoneypercent)/100;\r\n  }\r\n\r\n  function withdraw(uint _amount , address payable desaccount) public onlyAdmin{\r\n      desaccount.transfer(_amount);\r\n      contractBalance=address(this).balance;\r\n      maxProfit=(address(this).balance * maxmoneypercent)/100;\r\n  }\r\n\r\n  function deposit() public payable onlyAdmin returns(uint8 ret){\r\n      contractBalance=address(this).balance;\r\n      maxProfit=(address(this).balance * maxmoneypercent)/100;\r\n      ret = 1;\r\n  }\r\n\r\n  function getDatas() public view returns(\r\n    uint _maxProfit,\r\n    uint _minBet,\r\n    uint _contractbalance,\r\n    uint _onoff,\r\n    address _owner,\r\n    uint _oraclizeFee\r\n    ){\r\n        _maxProfit=maxProfit;\r\n        _minBet=minBet;\r\n        _contractbalance=contractBalance;\r\n        _onoff=onoff;\r\n        _owner=owner;\r\n       // _oraclizeFee=oraclizeFee;\r\n    }\r\n\r\n    function getLableList() public view returns(string memory opennum,bytes32[] memory lablelist,uint[] memory labletime,uint[] memory lablestatus,uint){\r\n      uint len=playerLableList[msg.sender].length;\r\n      require(len>0);\r\n\r\n      uint max=50;\r\n      if(len < 50){\r\n          max = len;\r\n      }\r\n\r\n      bytes32[] memory lablelist = new bytes32[](max) ;\r\n      uint[] memory labletime = new uint[](max) ;\r\n      uint[] memory lablestatus = new uint[](max) ;\r\n      string memory opennum=\"\";\r\n\r\n      bytes32 lastLable ;\r\n      for(uint i=0;i<max;i++){\r\n          lastLable = playerLableList[msg.sender][max-i-1];\r\n          lablelist[i]=lastLable;\r\n          labletime[i]=lableTime[lastLable];\r\n          lablestatus[i]=lableStatus[lastLable];\r\n          string memory ttmp =openNumberStr[lastLable];\r\n         if(i==0){\r\n           opennum =ttmp;\r\n         }else{\r\n           opennum = strConcat(opennum,\";\",ttmp);\r\n         }\r\n      }\r\n\r\n      return (opennum,lablelist,labletime,lablestatus,now);\r\n    }\r\n\r\n    function doCheckBounds(bytes32 queryId) internal{\r\n        uint sta = lableStatus[queryId];\r\n        require(sta == 0 || sta == 2);\r\n        uint[4] memory codes = openNumberList[queryId];\r\n        require(codes[0] > 0);\r\n\r\n        uint len = lableCount[queryId];\r\n\r\n        uint totalWin;\r\n        address payable to = lableUser[queryId];\r\n        for(uint aa = 0 ; aa<len; aa++){\r\n          if(sta == 0){\r\n           if(betList[queryId][aa][5] == 0){\r\n             checkWinMoney(betList[queryId][aa],codes);\r\n             totalWin+=betList[queryId][aa][6];\r\n           }\r\n          }else if(sta == 2){\r\n              totalWin+=betList[queryId][aa][6];\r\n          }\r\n        }\r\n\r\n        lableStatus[queryId] = 2;\r\n\r\n        if(totalWin > 0){\r\n          if(totalWin < address(this).balance){\r\n            to.transfer(totalWin);\r\n            lableStatus[queryId] = 3;\r\n          }else{\r\n              emit LogNewOraclizeQuery(\"sent bouns fail.\",queryId);\r\n          }\r\n        }else{\r\n          lableStatus[queryId] = 3;\r\n        }\r\n        contractBalance=address(this).balance;\r\n        maxProfit=(address(this).balance * maxmoneypercent)/100;\r\n    }\r\n\r\n    function getOpenNum(bytes32 queryId) public view returns(string memory result){\r\n        result = openNumberStr[queryId];\r\n        //return openNumberStr[queryId];\r\n    }\r\n\r\n    function doCheckSendBounds() public payable{\r\n        uint len=playerLableList[msg.sender].length;\r\n\r\n      uint max=50;\r\n      if(len < 50){\r\n          max = len;\r\n      }\r\n\r\n      uint sta;\r\n      bytes32 lastLable ;\r\n      for(uint i=0;i<max;i++){\r\n          lastLable = playerLableList[msg.sender][max-i-1];\r\n          sta = lableStatus[lastLable];\r\n          if(sta == 0 || sta==2){\r\n            doCheckBounds(lastLable);\r\n          }\r\n      }\r\n    }\r\n\r\n    function doCancelAll() public payable{\r\n        uint len=playerLableList[msg.sender].length;\r\n\r\n      uint max=50;\r\n      if(len < 50){\r\n          max = len;\r\n      }\r\n\r\n      uint sta;\r\n      uint bettime;\r\n      bytes32 lastLable ;\r\n      for(uint i=0;i<max;i++){\r\n          lastLable = playerLableList[msg.sender][max-i-1];\r\n          sta = lableStatus[lastLable];\r\n          bettime = lableTime[lastLable];\r\n          if(sta == 0 && (now - bettime)>600){\r\n            doCancel(lastLable);\r\n          }\r\n      }\r\n    }\r\n\r\n    function splitStr(string memory str, string memory delimiter) internal returns (uint [] memory){ //delimiter can be any character that separates the integers\r\n     bytes memory b = bytes(str); //cast the string to bytes to iterate\r\n     bytes memory delm = bytes(delimiter);\r\n     delete(numbers);\r\n     delete(tempNum);\r\n     for(uint i; i<b.length ; i++){\r\n     if(b[i] != delm[0]) { //check if a not space\r\n       tempNum.push(b[i]);\r\n      }\r\n      else {\r\n       numbers.push(parseInt(string(tempNum))); //push the int value converted from string to numbers array\r\n       tempNum = \"\"; //reset the tempNum to catch the net number\r\n      }\r\n     }\r\n     if(b[b.length-1] != delm[0]) {\r\n      numbers.push(parseInt(string(tempNum)));\r\n     }\r\n     return numbers;\r\n    }\r\n\r\n    function uint2str(uint _i) internal pure returns (string memory _uintAsString) {\r\n        if (_i == 0) {\r\n            return \"0\";\r\n        }\r\n        uint j = _i;\r\n        uint len;\r\n        while (j != 0) {\r\n            len++;\r\n            j /= 10;\r\n        }\r\n        bytes memory bstr = new bytes(len);\r\n        uint k = len - 1;\r\n        while (_i != 0) {\r\n            bstr[k--] = byte(uint8(48 + _i % 10));\r\n            _i /= 10;\r\n        }\r\n     return string(bstr);\r\n    }\r\n\r\n    function strConcat(string memory _a, string memory _b) internal pure returns (string memory _concatenatedString) {\r\n        return strConcat(_a, _b, \"\", \"\", \"\");\r\n    }\r\n\r\n    function strConcat(string memory _a, string memory _b, string memory _c) internal pure returns (string memory _concatenatedString) {\r\n        return strConcat(_a, _b, _c, \"\", \"\");\r\n    }\r\n\r\n    function strConcat(string memory _a, string memory _b, string memory _c, string memory _d) internal pure returns (string memory _concatenatedString) {\r\n        return strConcat(_a, _b, _c, _d, \"\");\r\n    }\r\n\r\n    function strConcat(string memory _a, string memory _b, string memory _c, string memory _d, string memory _e) internal pure returns (string memory _concatenatedString) {\r\n        bytes memory _ba = bytes(_a);\r\n        bytes memory _bb = bytes(_b);\r\n        bytes memory _bc = bytes(_c);\r\n        bytes memory _bd = bytes(_d);\r\n        bytes memory _be = bytes(_e);\r\n        string memory abcde = new string(_ba.length + _bb.length + _bc.length + _bd.length + _be.length);\r\n        bytes memory babcde = bytes(abcde);\r\n        uint k = 0;\r\n        uint i = 0;\r\n        for (i = 0; i < _ba.length; i++) {\r\n            babcde[k++] = _ba[i];\r\n        }\r\n        for (i = 0; i < _bb.length; i++) {\r\n            babcde[k++] = _bb[i];\r\n        }\r\n        for (i = 0; i < _bc.length; i++) {\r\n            babcde[k++] = _bc[i];\r\n        }\r\n        for (i = 0; i < _bd.length; i++) {\r\n            babcde[k++] = _bd[i];\r\n        }\r\n        for (i = 0; i < _be.length; i++) {\r\n            babcde[k++] = _be[i];\r\n        }\r\n        return string(babcde);\r\n    }\r\n\r\n    function safeParseInt(string memory _a) internal pure returns (uint _parsedInt) {\r\n        return safeParseInt(_a, 0);\r\n    }\r\n\r\n    function safeParseInt(string memory _a, uint _b) internal pure returns (uint _parsedInt) {\r\n        bytes memory bresult = bytes(_a);\r\n        uint mint = 0;\r\n        bool decimals = false;\r\n        for (uint i = 0; i < bresult.length; i++) {\r\n            if ((uint(uint8(bresult[i])) >= 48) && (uint(uint8(bresult[i])) <= 57)) {\r\n                if (decimals) {\r\n                   if (_b == 0) break;\r\n                    else _b--;\r\n                }\r\n                mint *= 10;\r\n                mint += uint(uint8(bresult[i])) - 48;\r\n            } else if (uint(uint8(bresult[i])) == 46) {\r\n                require(!decimals, 'More than one decimal encountered in string!');\r\n                decimals = true;\r\n            } else {\r\n                revert(\"Non-numeral character encountered in string!\");\r\n            }\r\n        }\r\n        if (_b > 0) {\r\n            mint *= 10 ** _b;\r\n        }\r\n        return mint;\r\n    }\r\n\r\n    function parseInt(string memory _a) internal pure returns (uint _parsedInt) {\r\n        return parseInt(_a, 0);\r\n    }\r\n\r\n    function parseInt(string memory _a, uint _b) internal pure returns (uint _parsedInt) {\r\n        bytes memory bresult = bytes(_a);\r\n        uint mint = 0;\r\n        bool decimals = false;\r\n        for (uint i = 0; i < bresult.length; i++) {\r\n            if ((uint(uint8(bresult[i])) >= 48) && (uint(uint8(bresult[i])) <= 57)) {\r\n                if (decimals) {\r\n                   if (_b == 0) {\r\n                       break;\r\n                   } else {\r\n                       _b--;\r\n                   }\r\n                }\r\n                mint *= 10;\r\n                mint += uint(uint8(bresult[i])) - 48;\r\n            } else if (uint(uint8(bresult[i])) == 46) {\r\n                decimals = true;\r\n            }\r\n        }\r\n        if (_b > 0) {\r\n            mint *= 10 ** _b;\r\n        }\r\n        return mint;\r\n    }\r\n\r\n\r\n    function setRandomSeed(uint _randomSeed) public payable onlyAdmin{\r\n      randonce = _randomSeed;\r\n    }\r\n\r\n    function getRandomSeed() public view onlyAdmin returns(uint _randonce) {\r\n      _randonce = randonce;\r\n    }\r\n\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"desaccount\",\"type\":\"address\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"queryId\",\"type\":\"bytes32\"}],\"name\":\"getOpenNum\",\"outputs\":[{\"name\":\"result\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"lable\",\"type\":\"bytes32\"}],\"name\":\"getLableRecords\",\"outputs\":[{\"name\":\"opennum\",\"type\":\"string\"},{\"name\":\"result\",\"type\":\"uint256[7][]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getLableList\",\"outputs\":[{\"name\":\"opennum\",\"type\":\"string\"},{\"name\":\"lablelist\",\"type\":\"bytes32[]\"},{\"name\":\"labletime\",\"type\":\"uint256[]\"},{\"name\":\"lablestatus\",\"type\":\"uint256[]\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_randomSeed\",\"type\":\"uint256\"}],\"name\":\"setRandomSeed\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"doCancelAll\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getDatas\",\"outputs\":[{\"name\":\"_maxProfit\",\"type\":\"uint256\"},{\"name\":\"_minBet\",\"type\":\"uint256\"},{\"name\":\"_contractbalance\",\"type\":\"uint256\"},{\"name\":\"_onoff\",\"type\":\"uint256\"},{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_oraclizeFee\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_on0ff\",\"type\":\"uint256\"}],\"name\":\"setGameOnoff\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"contractBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getRandomSeed\",\"outputs\":[{\"name\":\"_randonce\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"doCheckSendBounds\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAllRecords\",\"outputs\":[{\"name\":\"opennum\",\"type\":\"string\"},{\"name\":\"result\",\"type\":\"uint256[7][]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"queryId\",\"type\":\"bytes32\"}],\"name\":\"doSendBounds\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getLastBet\",\"outputs\":[{\"name\":\"opennum\",\"type\":\"string\"},{\"name\":\"result\",\"type\":\"uint256[7][]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"deposit\",\"outputs\":[{\"name\":\"ret\",\"type\":\"uint8\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"playid\",\"type\":\"uint256[]\"},{\"name\":\"betMoney\",\"type\":\"uint256[]\"},{\"name\":\"betContent\",\"type\":\"uint256[]\"},{\"name\":\"mutiply\",\"type\":\"uint256\"}],\"name\":\"doBet\",\"outputs\":[{\"name\":\"queryId\",\"type\":\"bytes32\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"senttest\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"description\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"queryId\",\"type\":\"bytes32\"}],\"name\":\"LogNewOraclizeQuery\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"result\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"queryId\",\"type\":\"bytes32\"}],\"name\":\"LogNewRandomNumber\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"lableId\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"playId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"content\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"singleMoney\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"mutilple\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"betTime\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"status\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"winMoney\",\"type\":\"uint256\"}],\"name\":\"LogSendBonus\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"queryId\",\"type\":\"bytes32\"}],\"name\":\"LogBet\",\"type\":\"event\"}]","ContractName":"LongHuContract","CompilerVersion":"v0.5.5+commit.47a71e8f","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://067ab038fe3843ee0b9c616572448ed0079ac1ef19cc87a87935ada60d358843"}]}