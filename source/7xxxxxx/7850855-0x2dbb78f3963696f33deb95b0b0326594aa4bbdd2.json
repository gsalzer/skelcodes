{"status":"1","message":"OK","result":[{"SourceCode":"{\"PLincGamesHub.sol\":{\"content\":\"pragma solidity 0.5.8;\\r\\n\\r\\nimport \\\"./SafeMath.sol\\\";\\r\\n\\r\\ncontract PLincGamesHub {\\r\\n    \\r\\n    using SafeMath for uint256;\\r\\n    \\r\\n    constructor(address plicHubAddress)\\r\\n        public\\r\\n    {\\r\\n       plincHub = IPLincHub(plicHubAddress);\\r\\n       \\r\\n       plincHub.setAuto(9);\\r\\n    }\\r\\n    \\r\\n    function()\\r\\n        external\\r\\n        payable\\r\\n    {}\\r\\n    \\r\\n    address manager = address(0x1EB2acB92624DA2e601EEb77e2508b32E49012ef);\\r\\n    \\r\\n    event AddGame(address game);\\r\\n    event RemoveGame(address game);\\r\\n\\r\\n    modifier onlyManager()\\r\\n    {\\r\\n        require(msg.sender == manager);\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    function addGame(address gameAddress)\\r\\n        external\\r\\n        onlyManager\\r\\n        isUnregisteredGame(gameAddress)\\r\\n    {\\r\\n        games[gameAddress] = Game(true, 0, 0);\\r\\n        numberOfGames++;\\r\\n        \\r\\n        emit AddGame(gameAddress);\\r\\n    }\\r\\n    \\r\\n    function removeGame(address gameAddress)\\r\\n        external\\r\\n        onlyManager\\r\\n        isRegisteredGame(gameAddress)\\r\\n    {\\r\\n        games[gameAddress].registered = false;\\r\\n        numberOfGames--;\\r\\n        \\r\\n        emit RemoveGame(gameAddress);\\r\\n    }\\r\\n    \\r\\n    //\\r\\n    //Players\\r\\n    //\\r\\n    \\r\\n    struct Player {\\r\\n        uint256 balance;\\r\\n        string name;\\r\\n        uint256 fundingBalance;\\r\\n    }\\r\\n    \\r\\n    mapping(address =\\u003e Player) public players;\\r\\n    mapping(string =\\u003e bool) public names;\\r\\n    uint256 public totalPlayerBalances;\\r\\n    uint256 public totalFundingBalances;\\r\\n    \\r\\n    event RegisterName(address indexed player, string indexed name);\\r\\n    event Withdraw(address indexed player, uint256 amount);\\r\\n    event Fund(address indexed funder, uint256 amount);\\r\\n    event WithdrawFunding(address indexed player, uint256 amount);\\r\\n\\t\\r\\n\\tfunction fund()\\r\\n\\t    external\\r\\n\\t    payable\\r\\n\\t    withdrawPiggyBank\\r\\n\\t{\\r\\n\\t    players[msg.sender].fundingBalance = players[msg.sender].fundingBalance.add(msg.value);\\r\\n\\t    \\r\\n\\t    totalFundingBalances += msg.value;\\r\\n\\t    \\r\\n\\t    emit Fund(msg.sender, msg.value);\\r\\n\\t}\\r\\n\\t\\r\\n\\tfunction playGame(bytes calldata data)\\r\\n\\t    external\\r\\n\\t    payable\\r\\n\\t    withdrawPiggyBank\\r\\n\\t{\\r\\n\\t    (address gameAddress, bytes memory gameData) = abi.decode(data, (address, bytes));\\r\\n\\t    \\r\\n\\t    require(games[gameAddress].registered);\\r\\n\\t    \\r\\n\\t    games[gameAddress].amountGiven += msg.value;\\r\\n\\t    \\r\\n\\t    IHubGame(gameAddress).play(msg.sender, msg.value, gameData);\\r\\n\\t    \\r\\n\\t    buyBondsInternally(msg.value / plincDivisor);\\r\\n\\t}\\r\\n\\t\\r\\n\\tfunction withdrawBalance()\\r\\n\\t    external\\r\\n\\t    withdrawPiggyBank\\r\\n\\t{\\r\\n\\t    uint256 amount = players[msg.sender].balance;\\r\\n\\t    \\r\\n\\t    players[msg.sender].balance = 0;\\r\\n\\t    \\r\\n\\t    totalPlayerBalances -= amount;\\r\\n\\t   \\r\\n\\t    msg.sender.transfer(amount);\\r\\n\\t    \\r\\n\\t    emit Withdraw(msg.sender, amount);\\r\\n\\t}\\r\\n\\t\\r\\n\\tfunction withdrawBalancePartial(uint256 howMuch)\\r\\n\\t    external\\r\\n\\t    withdrawPiggyBank\\r\\n\\t{\\r\\n\\t    players[msg.sender].balance = players[msg.sender].balance.sub(howMuch);\\r\\n\\t    \\r\\n\\t    totalPlayerBalances -= howMuch;\\r\\n\\t   \\r\\n\\t    msg.sender.transfer(howMuch);\\r\\n\\t    \\r\\n\\t    emit Withdraw(msg.sender, howMuch);\\r\\n\\t}\\r\\n\\t\\r\\n\\tfunction withdrawFundingBalance()\\r\\n\\t    external\\r\\n\\t    withdrawPiggyBank\\r\\n\\t{\\r\\n\\t    uint256 amount = players[msg.sender].fundingBalance;\\r\\n\\t    \\r\\n\\t    players[msg.sender].fundingBalance = 0;\\r\\n\\t    \\r\\n\\t    totalFundingBalances -= amount;\\r\\n\\t   \\r\\n\\t    msg.sender.transfer(amount);\\r\\n\\t    \\r\\n\\t    emit WithdrawFunding(msg.sender, amount);\\r\\n\\t}\\r\\n\\t\\r\\n\\tfunction withdrawFundingBalancePartial(uint256 howMuch)\\r\\n\\t    external\\r\\n\\t    withdrawPiggyBank\\r\\n\\t{\\r\\n\\t    players[msg.sender].fundingBalance = players[msg.sender].fundingBalance.sub(howMuch);\\r\\n\\t    \\r\\n\\t    totalFundingBalances -= howMuch;\\r\\n\\t   \\r\\n\\t    msg.sender.transfer(howMuch);\\r\\n\\t    \\r\\n\\t    emit WithdrawFunding(msg.sender, howMuch);\\r\\n\\t}\\r\\n\\t\\r\\n\\tfunction registerName(string calldata newName)\\r\\n\\t    external\\r\\n\\t    payable\\r\\n\\t    withdrawPiggyBank\\r\\n\\t{\\r\\n\\t    require(msg.value \\u003e= 0.01 ether);\\r\\n\\t    require(bytes(newName).length \\u003e 0 \\u0026\\u0026 bytes(newName).length \\u003c= 32);\\r\\n\\t    require(!names[newName]);\\r\\n\\t    \\r\\n\\t    players[msg.sender].name = newName;\\r\\n\\t    names[newName] = true;\\r\\n\\t    \\r\\n\\t    emit RegisterName(msg.sender, newName);\\r\\n\\t}\\r\\n\\t\\r\\n\\t//\\r\\n\\t//Games\\r\\n\\t//\\r\\n\\t\\r\\n\\tstruct Game {\\r\\n        bool registered;\\r\\n        uint256 amountGiven;\\r\\n        uint256 amountTaken;\\r\\n    }\\r\\n    \\r\\n    mapping(address =\\u003e Game) public games;\\r\\n    uint256 public numberOfGames;\\r\\n\\t\\r\\n\\tmodifier isRegisteredGame(address gameAddress)\\r\\n    {\\r\\n        require(games[gameAddress].registered);\\r\\n        _;\\r\\n    }\\r\\n    \\r\\n    modifier isUnregisteredGame(address gameAddress)\\r\\n    {\\r\\n        require(!games[gameAddress].registered);\\r\\n        _;\\r\\n    }\\r\\n\\t\\r\\n\\tfunction addPlayerBalance(address playerAddress, uint256 value)\\r\\n\\t    external\\r\\n\\t    isRegisteredGame(msg.sender)\\r\\n\\t{\\r\\n\\t    players[playerAddress].balance = players[playerAddress].balance.add(value);\\r\\n\\t    games[msg.sender].amountTaken += value;\\r\\n\\t    \\r\\n\\t    totalPlayerBalances += value;\\r\\n\\t}\\r\\n\\t\\r\\n\\tfunction subPlayerBalance(address playerAddress, uint256 value)\\r\\n\\t    external\\r\\n\\t    isRegisteredGame(msg.sender)\\r\\n\\t{\\r\\n\\t    players[playerAddress].balance = players[playerAddress].balance.sub(value);\\r\\n\\t    games[msg.sender].amountGiven += value;\\r\\n\\t    \\r\\n\\t    totalPlayerBalances -= value;\\r\\n\\t}\\r\\n\\t\\r\\n\\t//\\r\\n\\t//PLincHub integration\\r\\n\\t//\\r\\n\\t\\r\\n\\tIPLincHub public plincHub;\\r\\n\\tuint256 plincDivisor = 1;\\r\\n\\t\\r\\n\\tmodifier withdrawPiggyBank\\r\\n    {\\r\\n\\t    if(plincHub.piggyBank(address(this)) \\u003e 0) {\\r\\n\\t        plincHub.piggyToWallet();\\r\\n\\t    }\\r\\n\\t    _;\\r\\n    }\\r\\n\\t\\r\\n\\tfunction setAuto(uint256 percentage)\\r\\n        external\\r\\n        onlyManager\\r\\n    {\\r\\n        plincHub.setAuto(percentage);\\r\\n    }\\r\\n    \\r\\n    function setPLincDivisor(uint256 value)\\r\\n        external\\r\\n        onlyManager\\r\\n    {\\r\\n        plincDivisor = value;\\r\\n    }\\r\\n    \\r\\n    function buyBonds(uint256 value)\\r\\n        external\\r\\n        onlyManager\\r\\n    {\\r\\n        buyBondsInternally(value);\\r\\n    }\\r\\n    \\r\\n    function fillBonds()\\r\\n        external\\r\\n        onlyManager\\r\\n    {\\r\\n        plincHub.fillBonds(address(this));\\r\\n    }\\r\\n    \\r\\n    function fetchBonds()\\r\\n        external\\r\\n        onlyManager\\r\\n    {\\r\\n        plincHub.fetchDivs(address(this));\\r\\n    }\\r\\n    \\r\\n    function piggyToWallet()\\r\\n        external\\r\\n    {\\r\\n        plincHub.piggyToWallet();\\r\\n    }\\r\\n    \\r\\n    function vaultToWallet()\\r\\n        external\\r\\n    {\\r\\n        plincHub.vaultToWallet();\\r\\n    }\\r\\n    \\r\\n    function bondsOutstanding()\\r\\n        external\\r\\n        view\\r\\n        returns (uint256)\\r\\n    {\\r\\n       return plincHub.bondsOutstanding(address(this));\\r\\n    }\\r\\n    \\r\\n    function buyBondsInternally(uint256 value)\\r\\n        private\\r\\n    {\\r\\n        plincHub.buyBonds.value(value)(manager);\\r\\n    }\\r\\n}\\r\\n\\r\\ninterface IHubGame {\\r\\n    function play(address playerAddress, uint256 value, bytes calldata gameData) external;\\r\\n}\\r\\n\\r\\ninterface IPLincHub {\\r\\n    function setAuto(uint256 percentage) external;\\r\\n    function buyBonds(address referral) external payable;\\r\\n    function piggyToWallet() external;\\r\\n    function vaultToWallet() external;\\r\\n    function fillBonds(address player) external;\\r\\n    function fetchDivs(address player) external;\\r\\n    function piggyBank(address player) external view returns (uint256);\\r\\n    function bondsOutstanding(address player) external view returns (uint256);\\r\\n}\"},\"PLincSlots.sol\":{\"content\":\"pragma solidity 0.5.8;\\r\\n\\r\\nimport \\\"./SafeMath.sol\\\";\\r\\n\\r\\ncontract PLincSlots {\\r\\n    \\r\\n    using SafeMath for uint256;\\r\\n    \\r\\n    struct Spin {\\r\\n        uint256 value;\\r\\n        uint256 startBlock;\\r\\n        uint256 multiplier;\\r\\n        bool open;\\r\\n    }\\r\\n    \\r\\n    mapping(address =\\u003e Spin) public playerSpin;\\r\\n    \\r\\n    uint256 public totalSpins;\\r\\n    \\r\\n    address private hubAddress;\\r\\n    IGamesHub private hubContract;\\r\\n    \\r\\n    uint256 public maxBet;\\r\\n    uint256 public maxMultiplier;\\r\\n    \\r\\n    event Win(address indexed player, uint256 amount, uint256 reel1, uint256 reel2, uint256 reel3);\\r\\n    event Loss(address indexed player, uint256 amount);\\r\\n    \\r\\n    constructor(address gameHubAddress)\\r\\n        public\\r\\n    {\\r\\n        hubAddress = gameHubAddress;\\r\\n        hubContract = IGamesHub(gameHubAddress);\\r\\n        \\r\\n        maxBet = 0.1 ether;\\r\\n        maxMultiplier = 20;\\r\\n    }\\r\\n    \\r\\n    modifier onlyHub(address sender)\\r\\n    {\\r\\n        require(sender == hubAddress);\\r\\n        _;\\r\\n    }\\r\\n    \\r\\n    modifier onlyDev()\\r\\n    {\\r\\n        require(msg.sender == address(0x1EB2acB92624DA2e601EEb77e2508b32E49012ef));\\r\\n        _;\\r\\n    }\\r\\n    \\r\\n    function play(address playerAddress, uint256 value, bytes calldata gameData)\\r\\n        external\\r\\n        onlyHub(msg.sender)\\r\\n    {\\r\\n        require(value \\u003c= maxBet);\\r\\n        \\r\\n        playInternal(playerAddress, value);\\r\\n    }\\r\\n    \\r\\n    function playWithBalance(uint256 value)\\r\\n        external\\r\\n    {   \\r\\n        hubContract.subPlayerBalance(msg.sender, value);\\r\\n        playInternal(msg.sender, value);\\r\\n    }\\r\\n    \\r\\n    function resolveSpin()\\r\\n        external\\r\\n    {\\r\\n        Spin storage spin = getCurrentPlayerSpin(msg.sender);\\r\\n        require(spin.open);\\r\\n        \\r\\n        resolveInternal(msg.sender, spin);\\r\\n    }\\r\\n    \\r\\n    function setMaxBet(uint256 newMaxBet)\\r\\n        external\\r\\n        onlyDev\\r\\n    {\\r\\n        require(newMaxBet \\u003e 0);\\r\\n        \\r\\n        maxBet = newMaxBet;\\r\\n    }\\r\\n    \\r\\n    function setMaxMultiplier(uint256 newMaxMultiplier)\\r\\n        external\\r\\n        onlyDev\\r\\n    {\\r\\n        require(newMaxMultiplier \\u003e= 20);\\r\\n        \\r\\n        maxMultiplier = newMaxMultiplier;\\r\\n    }\\r\\n    \\r\\n    function hasActiveSpin()\\r\\n        external\\r\\n        view\\r\\n        returns (bool)\\r\\n    {\\r\\n        return getCurrentPlayerSpin(msg.sender).open \\r\\n        \\u0026\\u0026 block.number - 256 \\u003c= getCurrentPlayerSpin(msg.sender).startBlock;\\r\\n    }\\r\\n    \\r\\n    function mySpin()\\r\\n        external\\r\\n        view\\r\\n        returns(uint256 reel1, uint256 reel2, uint256 reel3)\\r\\n    {\\r\\n        Spin storage spin = getCurrentPlayerSpin(msg.sender);\\r\\n        \\r\\n        require(block.number - 256 \\u003c= spin.startBlock);\\r\\n        \\r\\n        reel1 = reel2 = reel3 = 42;\\r\\n        \\r\\n        bytes20 senderXORcontract = bytes20(msg.sender) ^ bytes20(address(this));\\r\\n        \\r\\n        if(block.number \\u003e spin.startBlock) {\\r\\n            reel1 = uint256(blockhash(spin.startBlock) ^ senderXORcontract) % 5;\\r\\n        }\\r\\n        \\r\\n        if(block.number \\u003e spin.startBlock + 1) {\\r\\n            reel2 = uint256(blockhash(spin.startBlock + 1) ^ senderXORcontract) % 5;\\r\\n        }\\r\\n        \\r\\n        if(block.number \\u003e spin.startBlock + 2) {\\r\\n            reel3 = uint256(blockhash(spin.startBlock + 2) ^ senderXORcontract) % 5;\\r\\n        }\\r\\n    }\\r\\n    \\r\\n    function getCurrentPlayerSpin(address playerAddress)\\r\\n        private\\r\\n        view\\r\\n        returns (Spin storage)\\r\\n    {\\r\\n        return playerSpin[playerAddress];\\r\\n    }\\r\\n    \\r\\n    function playInternal(address playerAddress, uint256 value)\\r\\n        private\\r\\n    {\\r\\n        Spin storage spin = getCurrentPlayerSpin(playerAddress);\\r\\n        \\r\\n        if(spin.open) {\\r\\n            resolveInternal(playerAddress, spin);\\r\\n        }\\r\\n        \\r\\n        playerSpin[playerAddress] = Spin(value, block.number, 0, true);\\r\\n        \\r\\n        totalSpins++;\\r\\n    }\\r\\n    \\r\\n    function resolveInternal(address playerAddress, Spin storage spin)\\r\\n        private\\r\\n    {\\r\\n        require(block.number \\u003e spin.startBlock + 2);\\r\\n        \\r\\n        spin.open = false;\\r\\n        \\r\\n        if(block.number - 256 \\u003e spin.startBlock) {\\r\\n            emit Loss(playerAddress, spin.value);\\r\\n            return;\\r\\n        }\\r\\n        \\r\\n        bytes20 senderXORcontract = bytes20(playerAddress) ^ bytes20(address(this));\\r\\n        \\r\\n        uint256 reel1 = uint256(blockhash(spin.startBlock) ^ senderXORcontract) % 5;\\r\\n        uint256 reel2 = uint256(blockhash(spin.startBlock + 1) ^ senderXORcontract) % 5;\\r\\n        uint256 reel3 = uint256(blockhash(spin.startBlock + 2) ^ senderXORcontract) % 5;\\r\\n        \\r\\n        if(reel1 + reel2 + reel3 == 0) {\\r\\n            spin.multiplier = maxMultiplier;\\r\\n        } else if(reel1 == reel2 \\u0026\\u0026 reel1 == reel3) {\\r\\n            spin.multiplier = 7;\\r\\n        } else if(reel1 + reel2 == 0 || reel1 + reel3 == 0 || reel2 + reel3 == 0) {\\r\\n            spin.multiplier = 2;\\r\\n        } else if(reel1 == 0 || reel2 == 0 || reel3 == 0) {\\r\\n            spin.multiplier = 1;\\r\\n        }\\r\\n        \\r\\n        if(spin.multiplier \\u003e 0) {\\r\\n            uint256 amountWon = spin.value.mul(spin.multiplier);\\r\\n            hubContract.addPlayerBalance(playerAddress, amountWon);\\r\\n            \\r\\n            emit Win(playerAddress, amountWon, reel1, reel2, reel3);\\r\\n        } else {\\r\\n            emit Loss(playerAddress, spin.value);\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\\r\\ninterface IGamesHub {\\r\\n    function addPlayerBalance(address playerAddress, uint256 value) external;\\r\\n    function subPlayerBalance(address playerAddress, uint256 value) external;\\r\\n}\\r\\n\"},\"SafeMath.sol\":{\"content\":\"pragma solidity 0.5.8;\\r\\n\\r\\nlibrary SafeMath {\\r\\n    \\r\\n    function mul(uint256 a, uint256 b) \\r\\n        internal \\r\\n        pure \\r\\n        returns (uint256 c) \\r\\n    {\\r\\n        if (a == 0) {\\r\\n            return 0;\\r\\n        }\\r\\n        c = a * b;\\r\\n        require(c / a == b, \\\"SafeMath mul failed\\\");\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    function sub(uint256 a, uint256 b)\\r\\n        internal\\r\\n        pure\\r\\n        returns (uint256) \\r\\n    {\\r\\n        require(b \\u003c= a, \\\"SafeMath sub failed\\\");\\r\\n        return a - b;\\r\\n    }\\r\\n    \\r\\n    function add(uint256 a, uint256 b)\\r\\n        internal\\r\\n        pure\\r\\n        returns (uint256 c) \\r\\n    {\\r\\n        c = a + b;\\r\\n        require(c \\u003e= a, \\\"SafeMath add failed\\\");\\r\\n        return c;\\r\\n    }\\r\\n}\"}}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"newMaxMultiplier\",\"type\":\"uint256\"}],\"name\":\"setMaxMultiplier\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxMultiplier\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"hasActiveSpin\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"playWithBalance\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxBet\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"playerSpin\",\"outputs\":[{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"startBlock\",\"type\":\"uint256\"},{\"name\":\"multiplier\",\"type\":\"uint256\"},{\"name\":\"open\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newMaxBet\",\"type\":\"uint256\"}],\"name\":\"setMaxBet\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"playerAddress\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"gameData\",\"type\":\"bytes\"}],\"name\":\"play\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"resolveSpin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSpins\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"mySpin\",\"outputs\":[{\"name\":\"reel1\",\"type\":\"uint256\"},{\"name\":\"reel2\",\"type\":\"uint256\"},{\"name\":\"reel3\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"gameHubAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"player\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"reel1\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"reel2\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"reel3\",\"type\":\"uint256\"}],\"name\":\"Win\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"player\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Loss\",\"type\":\"event\"}]","ContractName":"PLincSlots","CompilerVersion":"v0.5.8+commit.23d335f2","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000399529c2a759de7d84fa8faa4642ce7d5ca911e1","Library":"","SwarmSource":"bzzr://662ec85674ebd68614942044765c25cba35501510b507d3dba1be67c494f5d37"}]}