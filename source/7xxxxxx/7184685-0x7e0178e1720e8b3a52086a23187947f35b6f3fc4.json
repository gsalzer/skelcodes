{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.0;\r\n\r\ninterface ConflictResolutionInterface {\r\n    function minHouseStake(uint activeGames) external view returns(uint);\r\n\r\n    function maxBalance() external view returns(int);\r\n\r\n    function conflictEndFine() external pure returns(int);\r\n\r\n    function isValidBet(uint8 _gameType, uint _betNum, uint _betValue) external view returns(bool);\r\n\r\n    function endGameConflict(\r\n        uint8 _gameType,\r\n        uint _betNum,\r\n        uint _betValue,\r\n        int _balance,\r\n        uint _stake,\r\n        bytes32 _serverSeed,\r\n        bytes32 _userSeed\r\n    )\r\n        external\r\n        view\r\n        returns(int);\r\n\r\n    function serverForceGameEnd(\r\n        uint8 gameType,\r\n        uint _betNum,\r\n        uint _betValue,\r\n        int _balance,\r\n        uint _stake,\r\n        bytes32 _serverSeed,\r\n        bytes32 _userSeed,\r\n        uint _endInitiatedTime\r\n    )\r\n        external\r\n        view\r\n        returns(int);\r\n\r\n    function userForceGameEnd(\r\n        uint8 _gameType,\r\n        uint _betNum,\r\n        uint _betValue,\r\n        int _balance,\r\n        uint _stake,\r\n        uint _endInitiatedTime\r\n    )\r\n        external\r\n        view\r\n        returns(int);\r\n}\r\n\r\nlibrary MathUtil {\r\n    /**\r\n     * @dev Returns the absolute value of _val.\r\n     * @param _val value\r\n     * @return The absolute value of _val.\r\n     */\r\n    function abs(int _val) internal pure returns(uint) {\r\n        if (_val < 0) {\r\n            return uint(-_val);\r\n        } else {\r\n            return uint(_val);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Calculate maximum.\r\n     */\r\n    function max(uint _val1, uint _val2) internal pure returns(uint) {\r\n        return _val1 >= _val2 ? _val1 : _val2;\r\n    }\r\n\r\n    /**\r\n     * @dev Calculate minimum.\r\n     */\r\n    function min(uint _val1, uint _val2) internal pure returns(uint) {\r\n        return _val1 <= _val2 ? _val1 : _val2;\r\n    }\r\n}\r\n\r\ncontract Ownable {\r\n    address payable public owner;\r\n    address payable public pendingOwner;\r\n\r\n    event LogOwnerShipTransferred(address indexed previousOwner, address indexed newOwner);\r\n    event LogOwnerShipTransferInitiated(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Modifier, which throws if called by other account than owner.\r\n     */\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier throws if called by any account other than the pendingOwner.\r\n     */\r\n    modifier onlyPendingOwner() {\r\n        require(msg.sender == pendingOwner);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Set contract creator as initial owner\r\n     */\r\n    constructor() public {\r\n        owner = msg.sender;\r\n        pendingOwner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to set the pendingOwner address.\r\n     * @param _newOwner The address to transfer ownership to.\r\n     */\r\n    function transferOwnership(address payable _newOwner) public onlyOwner {\r\n        pendingOwner = _newOwner;\r\n        emit LogOwnerShipTransferInitiated(owner, _newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev PendingOwner can accept ownership.\r\n     */\r\n    function claimOwnership() public onlyPendingOwner {\r\n        owner = pendingOwner;\r\n        pendingOwner = address(0);\r\n        emit LogOwnerShipTransferred(owner, pendingOwner);\r\n    }\r\n}\r\n\r\ncontract Activatable is Ownable {\r\n    bool public activated = false;\r\n\r\n    /// @dev Event is fired if activated.\r\n    event LogActive();\r\n\r\n    /// @dev Modifier, which only allows function execution if activated.\r\n    modifier onlyActivated() {\r\n        require(activated);\r\n        _;\r\n    }\r\n\r\n    /// @dev Modifier, which only allows function execution if not activated.\r\n    modifier onlyNotActivated() {\r\n        require(!activated);\r\n        _;\r\n    }\r\n\r\n    /// @dev activate contract, can be only called once by the contract owner.\r\n    function activate() public onlyOwner onlyNotActivated {\r\n        activated = true;\r\n        emit LogActive();\r\n    }\r\n}\r\n\r\ncontract ConflictResolutionManager is Ownable {\r\n    /// @dev Conflict resolution contract.\r\n    ConflictResolutionInterface public conflictRes;\r\n\r\n    /// @dev New Conflict resolution contract.\r\n    address public newConflictRes = address(0);\r\n\r\n    /// @dev Time update of new conflict resolution contract was initiated.\r\n    uint public updateTime = 0;\r\n\r\n    /// @dev Min time before new conflict res contract can be activated after initiating update.\r\n    uint public constant MIN_TIMEOUT = 3 days;\r\n\r\n    /// @dev Min time before new conflict res contract can be activated after initiating update.\r\n    uint public constant MAX_TIMEOUT = 6 days;\r\n\r\n    /// @dev Update of conflict resolution contract was initiated.\r\n    event LogUpdatingConflictResolution(address newConflictResolutionAddress);\r\n\r\n    /// @dev New conflict resolution contract is active.\r\n    event LogUpdatedConflictResolution(address newConflictResolutionAddress);\r\n\r\n    /**\r\n     * @dev Constructor\r\n     * @param _conflictResAddress conflict resolution contract address.\r\n     */\r\n    constructor(address _conflictResAddress) public {\r\n        conflictRes = ConflictResolutionInterface(_conflictResAddress);\r\n    }\r\n\r\n    /**\r\n     * @dev Initiate conflict resolution contract update.\r\n     * @param _newConflictResAddress New conflict resolution contract address.\r\n     */\r\n    function updateConflictResolution(address _newConflictResAddress) public onlyOwner {\r\n        newConflictRes = _newConflictResAddress;\r\n        updateTime = block.timestamp;\r\n\r\n        emit LogUpdatingConflictResolution(_newConflictResAddress);\r\n    }\r\n\r\n    /**\r\n     * @dev Active new conflict resolution contract.\r\n     */\r\n    function activateConflictResolution() public onlyOwner {\r\n        require(newConflictRes != address(0));\r\n        require(updateTime != 0);\r\n        require(updateTime + MIN_TIMEOUT <= block.timestamp && block.timestamp <= updateTime + MAX_TIMEOUT);\r\n\r\n        conflictRes = ConflictResolutionInterface(newConflictRes);\r\n        newConflictRes = address(0);\r\n        updateTime = 0;\r\n\r\n        emit LogUpdatedConflictResolution(newConflictRes);\r\n    }\r\n}\r\n\r\ncontract Pausable is Activatable {\r\n    using SafeMath for uint;\r\n\r\n    /// @dev Is contract paused. Initial it is paused.\r\n    bool public paused = true;\r\n\r\n    /// @dev Time pause was called\r\n    uint public timePaused = block.timestamp;\r\n\r\n    /// @dev Modifier, which only allows function execution if not paused.\r\n    modifier onlyNotPaused() {\r\n        require(!paused, \"paused\");\r\n        _;\r\n    }\r\n\r\n    /// @dev Modifier, which only allows function execution if paused.\r\n    modifier onlyPaused() {\r\n        require(paused);\r\n        _;\r\n    }\r\n\r\n    /// @dev Modifier, which only allows function execution if paused longer than timeSpan.\r\n    modifier onlyPausedSince(uint timeSpan) {\r\n        require(paused && (timePaused.add(timeSpan) <= block.timestamp));\r\n        _;\r\n    }\r\n\r\n    /// @dev Event is fired if paused.\r\n    event LogPause();\r\n\r\n    /// @dev Event is fired if pause is ended.\r\n    event LogUnpause();\r\n\r\n    /**\r\n     * @dev Pause contract. No new game sessions can be created.\r\n     */\r\n    function pause() public onlyOwner onlyNotPaused {\r\n        paused = true;\r\n        timePaused = block.timestamp;\r\n        emit LogPause();\r\n    }\r\n\r\n    /**\r\n     * @dev Unpause contract. Initial contract is paused and can only be unpaused after activating it.\r\n     */\r\n    function unpause() public onlyOwner onlyPaused onlyActivated {\r\n        paused = false;\r\n        timePaused = 0;\r\n        emit LogUnpause();\r\n    }\r\n}\r\n\r\ncontract Destroyable is Pausable {\r\n    /// @dev After pausing the contract for 20 days owner can selfdestruct it.\r\n    uint public constant TIMEOUT_DESTROY = 20 days;\r\n\r\n    /**\r\n     * @dev Destroy contract and transfer ether to owner.\r\n     */\r\n    function destroy() public onlyOwner onlyPausedSince(TIMEOUT_DESTROY) {\r\n        selfdestruct(owner);\r\n    }\r\n}\r\n\r\ncontract GameChannelBase is Destroyable, ConflictResolutionManager {\r\n    using SafeCast for int;\r\n    using SafeCast for uint;\r\n    using SafeMath for int;\r\n    using SafeMath for uint;\r\n\r\n\r\n    /// @dev Different game session states.\r\n    enum GameStatus {\r\n        ENDED, ///< @dev Game session is ended.\r\n        ACTIVE, ///< @dev Game session is active.\r\n        USER_INITIATED_END, ///< @dev User initiated non regular end.\r\n        SERVER_INITIATED_END ///< @dev Server initiated non regular end.\r\n    }\r\n\r\n    /// @dev Reason game session ended.\r\n    enum ReasonEnded {\r\n        REGULAR_ENDED, ///< @dev Game session is regularly ended.\r\n        SERVER_FORCED_END, ///< @dev User did not respond. Server forced end.\r\n        USER_FORCED_END, ///< @dev Server did not respond. User forced end.\r\n        CONFLICT_ENDED ///< @dev Server or user raised conflict ans pushed game state, opponent pushed same game state.\r\n    }\r\n\r\n    struct Game {\r\n        /// @dev Game session status.\r\n        GameStatus status;\r\n\r\n        /// @dev User's stake.\r\n        uint128 stake;\r\n\r\n        /// @dev Last game round info if not regularly ended.\r\n        /// If game session is ended normally this data is not used.\r\n        uint8 gameType;\r\n        uint32 roundId;\r\n        uint betNum;\r\n        uint betValue;\r\n        int balance;\r\n        bytes32 userSeed;\r\n        bytes32 serverSeed;\r\n        uint endInitiatedTime;\r\n    }\r\n\r\n    /// @dev Minimal time span between profit transfer.\r\n    uint public constant MIN_TRANSFER_TIMESPAN = 1 days;\r\n\r\n    /// @dev Maximal time span between profit transfer.\r\n    uint public constant MAX_TRANSFER_TIMSPAN = 6 * 30 days;\r\n\r\n    bytes32 public constant EIP712DOMAIN_TYPEHASH = keccak256(\r\n        \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\r\n    );\r\n\r\n    bytes32 public constant BET_TYPEHASH = keccak256(\r\n        \"Bet(uint32 roundId,uint8 gameType,uint256 number,uint256 value,int256 balance,bytes32 serverHash,bytes32 userHash,uint256 gameId)\"\r\n    );\r\n\r\n    bytes32 public DOMAIN_SEPERATOR;\r\n\r\n    /// @dev Current active game sessions.\r\n    uint public activeGames = 0;\r\n\r\n    /// @dev Game session id counter. Points to next free game session slot. So gameIdCntr -1 is the\r\n    // number of game sessions created.\r\n    uint public gameIdCntr = 1;\r\n\r\n    /// @dev Only this address can accept and end games.\r\n    address public serverAddress;\r\n\r\n    /// @dev Address to transfer profit to.\r\n    address payable public houseAddress;\r\n\r\n    /// @dev Current house stake.\r\n    uint public houseStake = 0;\r\n\r\n    /// @dev House profit since last profit transfer.\r\n    int public houseProfit = 0;\r\n\r\n    /// @dev Min value user needs to deposit for creating game session.\r\n    uint128 public minStake;\r\n\r\n    /// @dev Max value user can deposit for creating game session.\r\n    uint128 public maxStake;\r\n\r\n    /// @dev Timeout until next profit transfer is allowed.\r\n    uint public profitTransferTimeSpan = 14 days;\r\n\r\n    /// @dev Last time profit transferred to house.\r\n    uint public lastProfitTransferTimestamp;\r\n\r\n    /// @dev Maps gameId to game struct.\r\n    mapping (uint => Game) public gameIdGame;\r\n\r\n    /// @dev Maps user address to current user game id.\r\n    mapping (address => uint) public userGameId;\r\n\r\n    /// @dev Maps user address to pending returns.\r\n    mapping (address => uint) public pendingReturns;\r\n\r\n    /// @dev Modifier, which only allows to execute if house stake is high enough.\r\n    modifier onlyValidHouseStake(uint _activeGames) {\r\n        uint minHouseStake = conflictRes.minHouseStake(_activeGames);\r\n        require(houseStake >= minHouseStake, \"inv houseStake\");\r\n        _;\r\n    }\r\n\r\n    /// @dev Modifier to check if value send fulfills user stake requirements.\r\n    modifier onlyValidValue() {\r\n        require(minStake <= msg.value && msg.value <= maxStake, \"inv stake\");\r\n        _;\r\n    }\r\n\r\n    /// @dev Modifier, which only allows server to call function.\r\n    modifier onlyServer() {\r\n        require(msg.sender == serverAddress);\r\n        _;\r\n    }\r\n\r\n    /// @dev Modifier, which only allows to set valid transfer timeouts.\r\n    modifier onlyValidTransferTimeSpan(uint transferTimeout) {\r\n        require(transferTimeout >= MIN_TRANSFER_TIMESPAN\r\n                && transferTimeout <= MAX_TRANSFER_TIMSPAN);\r\n        _;\r\n    }\r\n\r\n    /// @dev This event is fired when user creates game session.\r\n    event LogGameCreated(address indexed user, uint indexed gameId, uint128 stake, bytes32 indexed serverEndHash, bytes32 userEndHash);\r\n\r\n    /// @dev This event is fired when user requests conflict end.\r\n    event LogUserRequestedEnd(address indexed user, uint indexed gameId);\r\n\r\n    /// @dev This event is fired when server requests conflict end.\r\n    event LogServerRequestedEnd(address indexed user, uint indexed gameId);\r\n\r\n    /// @dev This event is fired when game session is ended.\r\n    event LogGameEnded(address indexed user, uint indexed gameId, uint32 roundId, int balance, ReasonEnded reason);\r\n\r\n    /// @dev this event is fired when owner modifies user's stake limits.\r\n    event LogStakeLimitsModified(uint minStake, uint maxStake);\r\n\r\n    /**\r\n     * @dev Contract constructor.\r\n     * @param _serverAddress Server address.\r\n     * @param _minStake Min value user needs to deposit to create game session.\r\n     * @param _maxStake Max value user can deposit to create game session.\r\n     * @param _conflictResAddress Conflict resolution contract address.\r\n     * @param _houseAddress House address to move profit to.\r\n     * @param _chainId Chain id for signature domain.\r\n     */\r\n    constructor(\r\n        address _serverAddress,\r\n        uint128 _minStake,\r\n        uint128 _maxStake,\r\n        address _conflictResAddress,\r\n        address payable _houseAddress,\r\n        uint _chainId\r\n    )\r\n        public\r\n        ConflictResolutionManager(_conflictResAddress)\r\n    {\r\n        require(_minStake > 0 && _minStake <= _maxStake);\r\n\r\n        serverAddress = _serverAddress;\r\n        houseAddress = _houseAddress;\r\n        lastProfitTransferTimestamp = block.timestamp;\r\n        minStake = _minStake;\r\n        maxStake = _maxStake;\r\n\r\n        DOMAIN_SEPERATOR =  keccak256(abi.encode(\r\n            EIP712DOMAIN_TYPEHASH,\r\n            keccak256(\"Dicether\"),\r\n            keccak256(\"2\"),\r\n            _chainId,\r\n            address(this)\r\n        ));\r\n    }\r\n\r\n    /**\r\n     * @dev Set gameIdCntr. Can be only set before activating contract.\r\n     */\r\n    function setGameIdCntr(uint _gameIdCntr) public onlyOwner onlyNotActivated {\r\n        require(gameIdCntr > 0);\r\n        gameIdCntr = _gameIdCntr;\r\n    }\r\n\r\n    /**\r\n     * @notice Withdraw pending returns.\r\n     */\r\n    function withdraw() public {\r\n        uint toTransfer = pendingReturns[msg.sender];\r\n        require(toTransfer > 0);\r\n\r\n        pendingReturns[msg.sender] = 0;\r\n        msg.sender.transfer(toTransfer);\r\n    }\r\n\r\n    /**\r\n     * @notice Transfer house profit to houseAddress.\r\n     */\r\n    function transferProfitToHouse() public {\r\n        require(lastProfitTransferTimestamp.add(profitTransferTimeSpan) <= block.timestamp);\r\n\r\n        // update last transfer timestamp\r\n        lastProfitTransferTimestamp = block.timestamp;\r\n\r\n        if (houseProfit <= 0) {\r\n            // no profit to transfer\r\n            return;\r\n        }\r\n\r\n        uint toTransfer = houseProfit.castToUint();\r\n\r\n        houseProfit = 0;\r\n        houseStake = houseStake.sub(toTransfer);\r\n\r\n        houseAddress.transfer(toTransfer);\r\n    }\r\n\r\n    /**\r\n     * @dev Set profit transfer time span.\r\n     */\r\n    function setProfitTransferTimeSpan(uint _profitTransferTimeSpan)\r\n        public\r\n        onlyOwner\r\n        onlyValidTransferTimeSpan(_profitTransferTimeSpan)\r\n    {\r\n        profitTransferTimeSpan = _profitTransferTimeSpan;\r\n    }\r\n\r\n    /**\r\n     * @dev Increase house stake by msg.value\r\n     */\r\n    function addHouseStake() public payable onlyOwner {\r\n        houseStake = houseStake.add(msg.value);\r\n    }\r\n\r\n    /**\r\n     * @dev Withdraw house stake.\r\n     */\r\n    function withdrawHouseStake(uint value) public onlyOwner {\r\n        uint minHouseStake = conflictRes.minHouseStake(activeGames);\r\n\r\n        require(value <= houseStake && houseStake.sub(value) >= minHouseStake);\r\n        require(houseProfit <= 0 || houseProfit.castToUint() <= houseStake.sub(value));\r\n\r\n        houseStake = houseStake.sub(value);\r\n        owner.transfer(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Withdraw house stake and profit.\r\n     */\r\n    function withdrawAll() public onlyOwner onlyPausedSince(3 days) {\r\n        houseProfit = 0;\r\n        uint toTransfer = houseStake;\r\n        houseStake = 0;\r\n        owner.transfer(toTransfer);\r\n    }\r\n\r\n    /**\r\n     * @dev Set new house address.\r\n     * @param _houseAddress New house address.\r\n     */\r\n    function setHouseAddress(address payable _houseAddress) public onlyOwner {\r\n        houseAddress = _houseAddress;\r\n    }\r\n\r\n    /**\r\n     * @dev Set stake min and max value.\r\n     * @param _minStake Min stake.\r\n     * @param _maxStake Max stake.\r\n     */\r\n    function setStakeRequirements(uint128 _minStake, uint128 _maxStake) public onlyOwner {\r\n        require(_minStake > 0 && _minStake <= _maxStake);\r\n        minStake = _minStake;\r\n        maxStake = _maxStake;\r\n        emit LogStakeLimitsModified(minStake, maxStake);\r\n    }\r\n\r\n    /**\r\n     * @dev Close game session.\r\n     * @param _game Game session data.\r\n     * @param _gameId Id of game session.\r\n     * @param _userAddress User's address of game session.\r\n     * @param _reason Reason for closing game session.\r\n     * @param _balance Game session balance.\r\n     */\r\n    function closeGame(\r\n        Game storage _game,\r\n        uint _gameId,\r\n        uint32 _roundId,\r\n        address payable _userAddress,\r\n        ReasonEnded _reason,\r\n        int _balance\r\n    )\r\n        internal\r\n    {\r\n        _game.status = GameStatus.ENDED;\r\n\r\n        activeGames = activeGames.sub(1);\r\n\r\n        payOut(_userAddress, _game.stake, _balance);\r\n\r\n        emit LogGameEnded(_userAddress, _gameId, _roundId, _balance, _reason);\r\n    }\r\n\r\n    /**\r\n     * @dev End game by paying out user and server.\r\n     * @param _userAddress User's address.\r\n     * @param _stake User's stake.\r\n     * @param _balance User's balance.\r\n     */\r\n    function payOut(address payable _userAddress, uint128 _stake, int _balance) internal {\r\n        int stakeInt = _stake;\r\n        int houseStakeInt = houseStake.castToInt();\r\n\r\n        assert(_balance <= conflictRes.maxBalance());\r\n        assert((stakeInt.add(_balance)) >= 0);\r\n\r\n        if (_balance > 0 && houseStakeInt < _balance) {\r\n            // Should never happen!\r\n            // House is bankrupt.\r\n            // Payout left money.\r\n            _balance = houseStakeInt;\r\n        }\r\n\r\n        houseProfit = houseProfit.sub(_balance);\r\n\r\n        int newHouseStake = houseStakeInt.sub(_balance);\r\n        houseStake = newHouseStake.castToUint();\r\n\r\n        uint valueUser = stakeInt.add(_balance).castToUint();\r\n        pendingReturns[_userAddress] += valueUser;\r\n        if (pendingReturns[_userAddress] > 0) {\r\n            safeSend(_userAddress);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Send value of pendingReturns[_address] to _address.\r\n     * @param _address Address to send value to.\r\n     */\r\n    function safeSend(address payable _address) internal {\r\n        uint valueToSend = pendingReturns[_address];\r\n        assert(valueToSend > 0);\r\n\r\n        pendingReturns[_address] = 0;\r\n        if (_address.send(valueToSend) == false) {\r\n            pendingReturns[_address] = valueToSend;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Verify signature of given data. Throws on verification failure.\r\n     * @param _sig Signature of given data in the form of rsv.\r\n     * @param _address Address of signature signer.\r\n     */\r\n    function verifySig(\r\n        uint32 _roundId,\r\n        uint8 _gameType,\r\n        uint _num,\r\n        uint _value,\r\n        int _balance,\r\n        bytes32 _serverHash,\r\n        bytes32 _userHash,\r\n        uint _gameId,\r\n        address _contractAddress,\r\n        bytes memory _sig,\r\n        address _address\r\n    )\r\n        internal\r\n        view\r\n    {\r\n        // check if this is the correct contract\r\n        address contractAddress = address(this);\r\n        require(_contractAddress == contractAddress, \"inv contractAddress\");\r\n\r\n        bytes32 roundHash = calcHash(\r\n                _roundId,\r\n                _gameType,\r\n                _num,\r\n                _value,\r\n                _balance,\r\n                _serverHash,\r\n                _userHash,\r\n                _gameId\r\n        );\r\n\r\n        verify(\r\n                roundHash,\r\n                _sig,\r\n                _address\r\n        );\r\n    }\r\n\r\n     /**\r\n     * @dev Check if _sig is valid signature of _hash. Throws if invalid signature.\r\n     * @param _hash Hash to check signature of.\r\n     * @param _sig Signature of _hash.\r\n     * @param _address Address of signer.\r\n     */\r\n    function verify(\r\n        bytes32 _hash,\r\n        bytes memory _sig,\r\n        address _address\r\n    )\r\n        internal\r\n        pure\r\n    {\r\n        (bytes32 r, bytes32 s, uint8 v) = signatureSplit(_sig);\r\n        address addressRecover = ecrecover(_hash, v, r, s);\r\n        require(addressRecover == _address, \"inv sig\");\r\n    }\r\n\r\n    /**\r\n     * @dev Calculate typed hash of given data (compare eth_signTypedData).\r\n     * @return Hash of given data.\r\n     */\r\n    function calcHash(\r\n        uint32 _roundId,\r\n        uint8 _gameType,\r\n        uint _num,\r\n        uint _value,\r\n        int _balance,\r\n        bytes32 _serverHash,\r\n        bytes32 _userHash,\r\n        uint _gameId\r\n    )\r\n        private\r\n        view\r\n        returns(bytes32)\r\n    {\r\n        bytes32 betHash = keccak256(abi.encode(\r\n            BET_TYPEHASH,\r\n            _roundId,\r\n            _gameType,\r\n            _num,\r\n            _value,\r\n            _balance,\r\n            _serverHash,\r\n            _userHash,\r\n            _gameId\r\n        ));\r\n\r\n        return keccak256(abi.encodePacked(\r\n            \"\\x19\\x01\",\r\n            DOMAIN_SEPERATOR,\r\n            betHash\r\n        ));\r\n    }\r\n\r\n    /**\r\n     * @dev Split the given signature of the form rsv in r s v. v is incremented with 27 if\r\n     * it is below 2.\r\n     * @param _signature Signature to split.\r\n     * @return r s v\r\n     */\r\n    function signatureSplit(bytes memory _signature)\r\n        private\r\n        pure\r\n        returns (bytes32 r, bytes32 s, uint8 v)\r\n    {\r\n        require(_signature.length == 65, \"inv sig\");\r\n\r\n        assembly {\r\n            r := mload(add(_signature, 32))\r\n            s := mload(add(_signature, 64))\r\n            v := and(mload(add(_signature, 65)), 0xff)\r\n        }\r\n        if (v < 2) {\r\n            v = v + 27;\r\n        }\r\n    }\r\n}\r\n\r\ncontract GameChannelConflict is GameChannelBase {\r\n    using SafeCast for int;\r\n    using SafeCast for uint;\r\n    using SafeMath for int;\r\n    using SafeMath for uint;\r\n\r\n    /**\r\n     * @dev Contract constructor.\r\n     * @param _serverAddress Server address.\r\n     * @param _minStake Min value user needs to deposit to create game session.\r\n     * @param _maxStake Max value user can deposit to create game session.\r\n     * @param _conflictResAddress Conflict resolution contract address\r\n     * @param _houseAddress House address to move profit to\r\n     * @param _chainId Chain id for signature domain.\r\n     */\r\n    constructor(\r\n        address _serverAddress,\r\n        uint128 _minStake,\r\n        uint128 _maxStake,\r\n        address _conflictResAddress,\r\n        address payable _houseAddress,\r\n        uint _chainId\r\n    )\r\n        public\r\n        GameChannelBase(_serverAddress, _minStake, _maxStake, _conflictResAddress, _houseAddress, _chainId)\r\n    {\r\n        // nothing to do\r\n    }\r\n\r\n    /**\r\n     * @dev Used by server if user does not end game session.\r\n     * @param _roundId Round id of bet.\r\n     * @param _gameType Game type of bet.\r\n     * @param _num Number of bet.\r\n     * @param _value Value of bet.\r\n     * @param _balance Balance before this bet.\r\n     * @param _serverHash Hash of server seed for this bet.\r\n     * @param _userHash Hash of user seed for this bet.\r\n     * @param _gameId Game session id.\r\n     * @param _contractAddress Address of this contract.\r\n     * @param _userSig User signature of this bet.\r\n     * @param _userAddress Address of user.\r\n     * @param _serverSeed Server seed for this bet.\r\n     * @param _userSeed User seed for this bet.\r\n     */\r\n    function serverEndGameConflict(\r\n        uint32 _roundId,\r\n        uint8 _gameType,\r\n        uint _num,\r\n        uint _value,\r\n        int _balance,\r\n        bytes32 _serverHash,\r\n        bytes32 _userHash,\r\n        uint _gameId,\r\n        address _contractAddress,\r\n        bytes memory _userSig,\r\n        address payable _userAddress,\r\n        bytes32 _serverSeed,\r\n        bytes32 _userSeed\r\n    )\r\n        public\r\n        onlyServer\r\n    {\r\n        verifySig(\r\n                _roundId,\r\n                _gameType,\r\n                _num,\r\n                _value,\r\n                _balance,\r\n                _serverHash,\r\n                _userHash,\r\n                _gameId,\r\n                _contractAddress,\r\n                _userSig,\r\n                _userAddress\r\n        );\r\n\r\n        serverEndGameConflictImpl(\r\n                _roundId,\r\n                _gameType,\r\n                _num,\r\n                _value,\r\n                _balance,\r\n                _serverHash,\r\n                _userHash,\r\n                _serverSeed,\r\n                _userSeed,\r\n                _gameId,\r\n                _userAddress\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Can be used by user if server does not answer to the end game session request.\r\n     * @param _roundId Round id of bet.\r\n     * @param _gameType Game type of bet.\r\n     * @param _num Number of bet.\r\n     * @param _value Value of bet.\r\n     * @param _balance Balance before this bet.\r\n     * @param _serverHash Hash of server seed for this bet.\r\n     * @param _userHash Hash of user seed for this bet.\r\n     * @param _gameId Game session id.\r\n     * @param _contractAddress Address of this contract.\r\n     * @param _serverSig Server signature of this bet.\r\n     * @param _userSeed User seed for this bet.\r\n     */\r\n    function userEndGameConflict(\r\n        uint32 _roundId,\r\n        uint8 _gameType,\r\n        uint _num,\r\n        uint _value,\r\n        int _balance,\r\n        bytes32 _serverHash,\r\n        bytes32 _userHash,\r\n        uint _gameId,\r\n        address _contractAddress,\r\n        bytes memory _serverSig,\r\n        bytes32 _userSeed\r\n    )\r\n        public\r\n    {\r\n        verifySig(\r\n            _roundId,\r\n            _gameType,\r\n            _num,\r\n            _value,\r\n            _balance,\r\n            _serverHash,\r\n            _userHash,\r\n            _gameId,\r\n            _contractAddress,\r\n            _serverSig,\r\n            serverAddress\r\n        );\r\n\r\n        userEndGameConflictImpl(\r\n            _roundId,\r\n            _gameType,\r\n            _num,\r\n            _value,\r\n            _balance,\r\n            _userHash,\r\n            _userSeed,\r\n            _gameId,\r\n            msg.sender\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Cancel active game without playing. Useful if server stops responding before\r\n     * one game is played.\r\n     * @param _gameId Game session id.\r\n     */\r\n    function userCancelActiveGame(uint _gameId) public {\r\n        address payable userAddress = msg.sender;\r\n        uint gameId = userGameId[userAddress];\r\n        Game storage game = gameIdGame[gameId];\r\n\r\n        require(gameId == _gameId, \"inv gameId\");\r\n\r\n        if (game.status == GameStatus.ACTIVE) {\r\n            game.endInitiatedTime = block.timestamp;\r\n            game.status = GameStatus.USER_INITIATED_END;\r\n\r\n            emit LogUserRequestedEnd(msg.sender, gameId);\r\n        } else if (game.status == GameStatus.SERVER_INITIATED_END && game.roundId == 0) {\r\n            cancelActiveGame(game, gameId, userAddress);\r\n        } else {\r\n            revert();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Cancel active game without playing. Useful if user starts game session and\r\n     * does not play.\r\n     * @param _userAddress Users' address.\r\n     * @param _gameId Game session id.\r\n     */\r\n    function serverCancelActiveGame(address payable _userAddress, uint _gameId) public onlyServer {\r\n        uint gameId = userGameId[_userAddress];\r\n        Game storage game = gameIdGame[gameId];\r\n\r\n        require(gameId == _gameId, \"inv gameId\");\r\n\r\n        if (game.status == GameStatus.ACTIVE) {\r\n            game.endInitiatedTime = block.timestamp;\r\n            game.status = GameStatus.SERVER_INITIATED_END;\r\n\r\n            emit LogServerRequestedEnd(msg.sender, gameId);\r\n        } else if (game.status == GameStatus.USER_INITIATED_END && game.roundId == 0) {\r\n            cancelActiveGame(game, gameId, _userAddress);\r\n        } else {\r\n            revert();\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Force end of game if user does not respond. Only possible after a certain period of time\r\n    * to give the user a chance to respond.\r\n    * @param _userAddress User's address.\r\n    */\r\n    function serverForceGameEnd(address payable _userAddress, uint _gameId) public onlyServer {\r\n        uint gameId = userGameId[_userAddress];\r\n        Game storage game = gameIdGame[gameId];\r\n\r\n        require(gameId == _gameId, \"inv gameId\");\r\n        require(game.status == GameStatus.SERVER_INITIATED_END, \"inv status\");\r\n\r\n        // theoretically we have enough data to calculate winner\r\n        // but as user did not respond assume he has lost.\r\n        int newBalance = conflictRes.serverForceGameEnd(\r\n            game.gameType,\r\n            game.betNum,\r\n            game.betValue,\r\n            game.balance,\r\n            game.stake,\r\n            game.serverSeed,\r\n            game.userSeed,\r\n            game.endInitiatedTime\r\n        );\r\n\r\n        closeGame(game, gameId, game.roundId, _userAddress, ReasonEnded.SERVER_FORCED_END, newBalance);\r\n    }\r\n\r\n    /**\r\n    * @notice Force end of game if server does not respond. Only possible after a certain period of time\r\n    * to give the server a chance to respond.\r\n    */\r\n    function userForceGameEnd(uint _gameId) public {\r\n        address payable userAddress = msg.sender;\r\n        uint gameId = userGameId[userAddress];\r\n        Game storage game = gameIdGame[gameId];\r\n\r\n        require(gameId == _gameId, \"inv gameId\");\r\n        require(game.status == GameStatus.USER_INITIATED_END, \"inv status\");\r\n\r\n        int newBalance = conflictRes.userForceGameEnd(\r\n            game.gameType,\r\n            game.betNum,\r\n            game.betValue,\r\n            game.balance,\r\n            game.stake,\r\n            game.endInitiatedTime\r\n        );\r\n\r\n        closeGame(game, gameId, game.roundId, userAddress, ReasonEnded.USER_FORCED_END, newBalance);\r\n    }\r\n\r\n    /**\r\n     * @dev Conflict handling implementation. Stores game data and timestamp if game\r\n     * is active. If server has already marked conflict for game session the conflict\r\n     * resolution contract is used (compare conflictRes).\r\n     * @param _roundId Round id of bet.\r\n     * @param _gameType Game type of bet.\r\n     * @param _num Number of bet.\r\n     * @param _value Value of bet.\r\n     * @param _balance Balance before this bet.\r\n     * @param _userHash Hash of user's seed for this bet.\r\n     * @param _userSeed User's seed for this bet.\r\n     * @param _gameId game Game session id.\r\n     * @param _userAddress User's address.\r\n     */\r\n    function userEndGameConflictImpl(\r\n        uint32 _roundId,\r\n        uint8 _gameType,\r\n        uint _num,\r\n        uint _value,\r\n        int _balance,\r\n        bytes32 _userHash,\r\n        bytes32 _userSeed,\r\n        uint _gameId,\r\n        address payable _userAddress\r\n    )\r\n        private\r\n    {\r\n        uint gameId = userGameId[_userAddress];\r\n        Game storage game = gameIdGame[gameId];\r\n        int maxBalance = conflictRes.maxBalance();\r\n        int gameStake = game.stake;\r\n\r\n        require(gameId == _gameId, \"inv gameId\");\r\n        require(_roundId > 0, \"inv roundId\");\r\n        require(keccak256(abi.encodePacked(_userSeed)) == _userHash, \"inv userSeed\");\r\n        require(-gameStake <= _balance && _balance <= maxBalance, \"inv balance\"); // game.stake save to cast as uint128\r\n        require(conflictRes.isValidBet(_gameType, _num, _value), \"inv bet\");\r\n        require(gameStake.add(_balance).sub(_value.castToInt()) >= 0, \"value too high\"); // game.stake save to cast as uint128\r\n\r\n        if (game.status == GameStatus.SERVER_INITIATED_END && game.roundId == _roundId) {\r\n            game.userSeed = _userSeed;\r\n            endGameConflict(game, gameId, _userAddress);\r\n        } else if (game.status == GameStatus.ACTIVE\r\n                || (game.status == GameStatus.SERVER_INITIATED_END && game.roundId < _roundId)) {\r\n            game.status = GameStatus.USER_INITIATED_END;\r\n            game.endInitiatedTime = block.timestamp;\r\n            game.roundId = _roundId;\r\n            game.gameType = _gameType;\r\n            game.betNum = _num;\r\n            game.betValue = _value;\r\n            game.balance = _balance;\r\n            game.userSeed = _userSeed;\r\n            game.serverSeed = bytes32(0);\r\n\r\n            emit LogUserRequestedEnd(msg.sender, gameId);\r\n        } else {\r\n            revert(\"inv state\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Conflict handling implementation. Stores game data and timestamp if game\r\n     * is active. If user has already marked conflict for game session the conflict\r\n     * resolution contract is used (compare conflictRes).\r\n     * @param _roundId Round id of bet.\r\n     * @param _gameType Game type of bet.\r\n     * @param _num Number of bet.\r\n     * @param _value Value of bet.\r\n     * @param _balance Balance before this bet.\r\n     * @param _serverHash Hash of server's seed for this bet.\r\n     * @param _userHash Hash of user's seed for this bet.\r\n     * @param _serverSeed Server's seed for this bet.\r\n     * @param _userSeed User's seed for this bet.\r\n     * @param _userAddress User's address.\r\n     */\r\n    function serverEndGameConflictImpl(\r\n        uint32 _roundId,\r\n        uint8 _gameType,\r\n        uint _num,\r\n        uint _value,\r\n        int _balance,\r\n        bytes32 _serverHash,\r\n        bytes32 _userHash,\r\n        bytes32 _serverSeed,\r\n        bytes32 _userSeed,\r\n        uint _gameId,\r\n        address payable _userAddress\r\n    )\r\n        private\r\n    {\r\n        uint gameId = userGameId[_userAddress];\r\n        Game storage game = gameIdGame[gameId];\r\n        int maxBalance = conflictRes.maxBalance();\r\n        int gameStake = game.stake;\r\n\r\n        require(gameId == _gameId, \"inv gameId\");\r\n        require(_roundId > 0, \"inv roundId\");\r\n        require(keccak256(abi.encodePacked(_serverSeed)) == _serverHash, \"inv serverSeed\");\r\n        require(keccak256(abi.encodePacked(_userSeed)) == _userHash, \"inv userSeed\");\r\n        require(-gameStake <= _balance && _balance <= maxBalance, \"inv balance\"); // game.stake save to cast as uint128\r\n        require(conflictRes.isValidBet(_gameType, _num, _value), \"inv bet\");\r\n        require(gameStake.add(_balance).sub(_value.castToInt()) >= 0, \"too high value\"); // game.stake save to cast as uin128\r\n\r\n        if (game.status == GameStatus.USER_INITIATED_END && game.roundId == _roundId) {\r\n            game.serverSeed = _serverSeed;\r\n            endGameConflict(game, gameId, _userAddress);\r\n        } else if (game.status == GameStatus.ACTIVE\r\n                || (game.status == GameStatus.USER_INITIATED_END && game.roundId < _roundId)) {\r\n            game.status = GameStatus.SERVER_INITIATED_END;\r\n            game.endInitiatedTime = block.timestamp;\r\n            game.roundId = _roundId;\r\n            game.gameType = _gameType;\r\n            game.betNum = _num;\r\n            game.betValue = _value;\r\n            game.balance = _balance;\r\n            game.serverSeed = _serverSeed;\r\n            game.userSeed = _userSeed;\r\n\r\n            emit LogServerRequestedEnd(_userAddress, gameId);\r\n        } else {\r\n            revert(\"inv state\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev End conflicting game without placed bets.\r\n     * @param _game Game session data.\r\n     * @param _gameId Game session id.\r\n     * @param _userAddress User's address.\r\n     */\r\n    function cancelActiveGame(Game storage _game, uint _gameId, address payable _userAddress) private {\r\n        // user need to pay a fee when conflict ended.\r\n        // this ensures a malicious, rich user can not just generate game sessions and then wait\r\n        // for us to end the game session and then confirm the session status, so\r\n        // we would have to pay a high gas fee without profit.\r\n        int newBalance = -conflictRes.conflictEndFine();\r\n\r\n        // do not allow balance below user stake\r\n        int stake = _game.stake;\r\n        if (newBalance < -stake) {\r\n            newBalance = -stake;\r\n        }\r\n        closeGame(_game, _gameId, 0, _userAddress, ReasonEnded.CONFLICT_ENDED, newBalance);\r\n    }\r\n\r\n    /**\r\n     * @dev End conflicting game.\r\n     * @param _game Game session data.\r\n     * @param _gameId Game session id.\r\n     * @param _userAddress User's address.\r\n     */\r\n    function endGameConflict(Game storage _game, uint _gameId, address payable _userAddress) private {\r\n        int newBalance = conflictRes.endGameConflict(\r\n            _game.gameType,\r\n            _game.betNum,\r\n            _game.betValue,\r\n            _game.balance,\r\n            _game.stake,\r\n            _game.serverSeed,\r\n            _game.userSeed\r\n        );\r\n\r\n        closeGame(_game, _gameId, _game.roundId, _userAddress, ReasonEnded.CONFLICT_ENDED, newBalance);\r\n    }\r\n}\r\n\r\ncontract GameChannel is GameChannelConflict {\r\n    /**\r\n     * @dev contract constructor\r\n     * @param _serverAddress Server address.\r\n     * @param _minStake Min value user needs to deposit to create game session.\r\n     * @param _maxStake Max value user can deposit to create game session.\r\n     * @param _conflictResAddress Conflict resolution contract address.\r\n     * @param _houseAddress House address to move profit to.\r\n     * @param _chainId Chain id for signature domain.\r\n     */\r\n    constructor(\r\n        address _serverAddress,\r\n        uint128 _minStake,\r\n        uint128 _maxStake,\r\n        address _conflictResAddress,\r\n        address payable _houseAddress,\r\n        uint _chainId\r\n    )\r\n        public\r\n        GameChannelConflict(_serverAddress, _minStake, _maxStake, _conflictResAddress, _houseAddress, _chainId)\r\n    {\r\n        // nothing to do\r\n    }\r\n\r\n    /**\r\n     * @notice Create games session request. msg.value needs to be valid stake value.\r\n     * @param _userEndHash Last entry of users' hash chain.\r\n     * @param _previousGameId User's previous game id, initial 0.\r\n     * @param _createBefore Game can be only created before this timestamp.\r\n     * @param _serverEndHash Last entry of server's hash chain.\r\n     * @param _serverSig Server signature. See verifyCreateSig\r\n     */\r\n    function createGame(\r\n        bytes32 _userEndHash,\r\n        uint _previousGameId,\r\n        uint _createBefore,\r\n        bytes32 _serverEndHash,\r\n        bytes memory _serverSig\r\n    )\r\n        public\r\n        payable\r\n        onlyValidValue\r\n        onlyValidHouseStake(activeGames + 1)\r\n        onlyNotPaused\r\n    {\r\n        uint previousGameId = userGameId[msg.sender];\r\n        Game storage game = gameIdGame[previousGameId];\r\n\r\n        require(game.status == GameStatus.ENDED, \"prev game not ended\");\r\n        require(previousGameId == _previousGameId, \"inv gamePrevGameId\");\r\n        require(block.timestamp < _createBefore, \"expired\");\r\n\r\n        verifyCreateSig(msg.sender, _previousGameId, _createBefore, _serverEndHash, _serverSig);\r\n\r\n        uint gameId = gameIdCntr++;\r\n        userGameId[msg.sender] = gameId;\r\n        Game storage newGame = gameIdGame[gameId];\r\n\r\n        newGame.stake = uint128(msg.value); // It's safe to cast msg.value as it is limited, see onlyValidValue\r\n        newGame.status = GameStatus.ACTIVE;\r\n\r\n        activeGames = activeGames.add(1);\r\n\r\n        // It's safe to cast msg.value as it is limited, see onlyValidValue\r\n        emit LogGameCreated(msg.sender, gameId, uint128(msg.value), _serverEndHash,  _userEndHash);\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev Regular end game session. Used if user and house have both\r\n     * accepted current game session state.\r\n     * The game session with gameId _gameId is closed\r\n     * and the user paid out. This functions is called by the server after\r\n     * the user requested the termination of the current game session.\r\n     * @param _roundId Round id of bet.\r\n     * @param _balance Current balance.\r\n     * @param _serverHash Hash of server's seed for this bet.\r\n     * @param _userHash Hash of user's seed for this bet.\r\n     * @param _gameId Game session id.\r\n     * @param _contractAddress Address of this contract.\r\n     * @param _userAddress Address of user.\r\n     * @param _userSig User's signature of this bet.\r\n     */\r\n    function serverEndGame(\r\n        uint32 _roundId,\r\n        int _balance,\r\n        bytes32 _serverHash,\r\n        bytes32 _userHash,\r\n        uint _gameId,\r\n        address _contractAddress,\r\n        address payable _userAddress,\r\n        bytes memory _userSig\r\n    )\r\n        public\r\n        onlyServer\r\n    {\r\n        verifySig(\r\n                _roundId,\r\n                0,\r\n                0,\r\n                0,\r\n                _balance,\r\n                _serverHash,\r\n                _userHash,\r\n                _gameId,\r\n                _contractAddress,\r\n                _userSig,\r\n                _userAddress\r\n        );\r\n\r\n        regularEndGame(_userAddress, _roundId, _balance, _gameId, _contractAddress);\r\n    }\r\n\r\n    /**\r\n     * @notice Regular end game session. Normally not needed as server ends game (@see serverEndGame).\r\n     * Can be used by user if server does not end game session.\r\n     * @param _roundId Round id of bet.\r\n     * @param _balance Current balance.\r\n     * @param _serverHash Hash of server's seed for this bet.\r\n     * @param _userHash Hash of user's seed for this bet.\r\n     * @param _gameId Game session id.\r\n     * @param _contractAddress Address of this contract.\r\n     * @param _serverSig Server's signature of this bet.\r\n     */\r\n    function userEndGame(\r\n        uint32 _roundId,\r\n        int _balance,\r\n        bytes32 _serverHash,\r\n        bytes32 _userHash,\r\n        uint _gameId,\r\n        address _contractAddress,\r\n        bytes memory _serverSig\r\n    )\r\n        public\r\n    {\r\n        verifySig(\r\n                _roundId,\r\n                0,\r\n                0,\r\n                0,\r\n                _balance,\r\n                _serverHash,\r\n                _userHash,\r\n                _gameId,\r\n                _contractAddress,\r\n                _serverSig,\r\n                serverAddress\r\n        );\r\n\r\n        regularEndGame(msg.sender, _roundId, _balance, _gameId, _contractAddress);\r\n    }\r\n\r\n    /**\r\n     * @dev Verify server signature.\r\n     * @param _userAddress User's address.\r\n     * @param _previousGameId User's previous game id, initial 0.\r\n     * @param _createBefore Game can be only created before this timestamp.\r\n     * @param _serverEndHash Last entry of server's hash chain.\r\n     * @param _serverSig Server signature.\r\n     */\r\n    function verifyCreateSig(\r\n        address _userAddress,\r\n        uint _previousGameId,\r\n        uint _createBefore,\r\n        bytes32 _serverEndHash,\r\n        bytes memory _serverSig\r\n    )\r\n        private view\r\n    {\r\n        address contractAddress = address(this);\r\n        bytes32 hash = keccak256(abi.encodePacked(\r\n            contractAddress, _userAddress, _previousGameId, _createBefore, _serverEndHash\r\n        ));\r\n\r\n        verify(hash, _serverSig, serverAddress);\r\n    }\r\n\r\n    /**\r\n     * @dev Regular end game session implementation. Used if user and house have both\r\n     * accepted current game session state. The game session with gameId _gameId is closed\r\n     * and the user paid out.\r\n     * @param _userAddress Address of user.\r\n     * @param _balance Current balance.\r\n     * @param _gameId Game session id.\r\n     * @param _contractAddress Address of this contract.\r\n     */\r\n    function regularEndGame(\r\n        address payable _userAddress,\r\n        uint32 _roundId,\r\n        int _balance,\r\n        uint _gameId,\r\n        address _contractAddress\r\n    )\r\n        private\r\n    {\r\n        uint gameId = userGameId[_userAddress];\r\n        Game storage game = gameIdGame[gameId];\r\n        int maxBalance = conflictRes.maxBalance();\r\n        int gameStake = game.stake;\r\n\r\n        require(_gameId == gameId, \"inv gameId\");\r\n        require(_roundId > 0, \"inv roundId\");\r\n        // save to cast as game.stake hash fixed range\r\n        require(-gameStake <= _balance && _balance <= maxBalance, \"inv balance\");\r\n        require(game.status == GameStatus.ACTIVE, \"inv status\");\r\n\r\n        assert(_contractAddress == address(this));\r\n\r\n        closeGame(game, gameId, _roundId, _userAddress, ReasonEnded.REGULAR_ENDED, _balance);\r\n    }\r\n}\r\n\r\nlibrary SafeCast {\r\n    /**\r\n     * Cast unsigned a to signed a.\r\n     */\r\n    function castToInt(uint a) internal pure returns(int) {\r\n        assert(a < (1 << 255));\r\n        return int(a);\r\n    }\r\n\r\n    /**\r\n     * Cast signed a to unsigned a.\r\n     */\r\n    function castToUint(int a) internal pure returns(uint) {\r\n        assert(a >= 0);\r\n        return uint(a);\r\n    }\r\n}\r\n\r\nlibrary SafeMath {\r\n\r\n    /**\r\n    * @dev Multiplies two unsigned integers, throws on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Multiplies two signed integers, throws on overflow.\r\n    */\r\n    function mul(int256 a, int256 b) internal pure returns (int256) {\r\n        // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        int256 c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two unsigned integers, truncating the quotient.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        // uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return a / b;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two signed integers, truncating the quotient.\r\n    */\r\n    function div(int256 a, int256 b) internal pure returns (int256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        // Overflow only happens when the smallest negative int is multiplied by -1.\r\n        int256 INT256_MIN = int256((uint256(1) << 255));\r\n        assert(a != INT256_MIN || b != - 1);\r\n        return a / b;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two unsigned integers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two signed integers, throws on overflow.\r\n    */\r\n    function sub(int256 a, int256 b) internal pure returns (int256) {\r\n        int256 c = a - b;\r\n        assert((b >= 0 && c <= a) || (b < 0 && c > a));\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two unsigned integers, throws on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two signed integers, throws on overflow.\r\n    */\r\n    function add(int256 a, int256 b) internal pure returns (int256) {\r\n        int256 c = a + b;\r\n        assert((b >= 0 && c >= a) || (b < 0 && c < a));\r\n        return c;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"DOMAIN_SEPERATOR\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"activate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"activated\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MIN_TRANSFER_TIMESPAN\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"userGameId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"pendingReturns\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_gameIdCntr\",\"type\":\"uint256\"}],\"name\":\"setGameIdCntr\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"profitTransferTimeSpan\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minStake\",\"outputs\":[{\"name\":\"\",\"type\":\"uint128\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_roundId\",\"type\":\"uint32\"},{\"name\":\"_balance\",\"type\":\"int256\"},{\"name\":\"_serverHash\",\"type\":\"bytes32\"},{\"name\":\"_userHash\",\"type\":\"bytes32\"},{\"name\":\"_gameId\",\"type\":\"uint256\"},{\"name\":\"_contractAddress\",\"type\":\"address\"},{\"name\":\"_userAddress\",\"type\":\"address\"},{\"name\":\"_userSig\",\"type\":\"bytes\"}],\"name\":\"serverEndGame\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastProfitTransferTimestamp\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"BET_TYPEHASH\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claimOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"addHouseStake\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MIN_TIMEOUT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"timePaused\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"conflictRes\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"withdrawHouseStake\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"destroy\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"gameIdGame\",\"outputs\":[{\"name\":\"status\",\"type\":\"uint8\"},{\"name\":\"stake\",\"type\":\"uint128\"},{\"name\":\"gameType\",\"type\":\"uint8\"},{\"name\":\"roundId\",\"type\":\"uint32\"},{\"name\":\"betNum\",\"type\":\"uint256\"},{\"name\":\"betValue\",\"type\":\"uint256\"},{\"name\":\"balance\",\"type\":\"int256\"},{\"name\":\"userSeed\",\"type\":\"bytes32\"},{\"name\":\"serverSeed\",\"type\":\"bytes32\"},{\"name\":\"endInitiatedTime\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawAll\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_roundId\",\"type\":\"uint32\"},{\"name\":\"_gameType\",\"type\":\"uint8\"},{\"name\":\"_num\",\"type\":\"uint256\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_balance\",\"type\":\"int256\"},{\"name\":\"_serverHash\",\"type\":\"bytes32\"},{\"name\":\"_userHash\",\"type\":\"bytes32\"},{\"name\":\"_gameId\",\"type\":\"uint256\"},{\"name\":\"_contractAddress\",\"type\":\"address\"},{\"name\":\"_serverSig\",\"type\":\"bytes\"},{\"name\":\"_userSeed\",\"type\":\"bytes32\"}],\"name\":\"userEndGameConflict\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"houseProfit\",\"outputs\":[{\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_roundId\",\"type\":\"uint32\"},{\"name\":\"_gameType\",\"type\":\"uint8\"},{\"name\":\"_num\",\"type\":\"uint256\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_balance\",\"type\":\"int256\"},{\"name\":\"_serverHash\",\"type\":\"bytes32\"},{\"name\":\"_userHash\",\"type\":\"bytes32\"},{\"name\":\"_gameId\",\"type\":\"uint256\"},{\"name\":\"_contractAddress\",\"type\":\"address\"},{\"name\":\"_userSig\",\"type\":\"bytes\"},{\"name\":\"_userAddress\",\"type\":\"address\"},{\"name\":\"_serverSeed\",\"type\":\"bytes32\"},{\"name\":\"_userSeed\",\"type\":\"bytes32\"}],\"name\":\"serverEndGameConflict\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_TRANSFER_TIMSPAN\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_gameId\",\"type\":\"uint256\"}],\"name\":\"userCancelActiveGame\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_profitTransferTimeSpan\",\"type\":\"uint256\"}],\"name\":\"setProfitTransferTimeSpan\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"activateConflictResolution\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"newConflictRes\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_userAddress\",\"type\":\"address\"},{\"name\":\"_gameId\",\"type\":\"uint256\"}],\"name\":\"serverCancelActiveGame\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_userEndHash\",\"type\":\"bytes32\"},{\"name\":\"_previousGameId\",\"type\":\"uint256\"},{\"name\":\"_createBefore\",\"type\":\"uint256\"},{\"name\":\"_serverEndHash\",\"type\":\"bytes32\"},{\"name\":\"_serverSig\",\"type\":\"bytes\"}],\"name\":\"createGame\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_gameId\",\"type\":\"uint256\"}],\"name\":\"userForceGameEnd\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TIMEOUT_DESTROY\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"EIP712DOMAIN_TYPEHASH\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"houseStake\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newConflictResAddress\",\"type\":\"address\"}],\"name\":\"updateConflictResolution\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_userAddress\",\"type\":\"address\"},{\"name\":\"_gameId\",\"type\":\"uint256\"}],\"name\":\"serverForceGameEnd\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_minStake\",\"type\":\"uint128\"},{\"name\":\"_maxStake\",\"type\":\"uint128\"}],\"name\":\"setStakeRequirements\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"houseAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"serverAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"updateTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_TIMEOUT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pendingOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"activeGames\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_roundId\",\"type\":\"uint32\"},{\"name\":\"_balance\",\"type\":\"int256\"},{\"name\":\"_serverHash\",\"type\":\"bytes32\"},{\"name\":\"_userHash\",\"type\":\"bytes32\"},{\"name\":\"_gameId\",\"type\":\"uint256\"},{\"name\":\"_contractAddress\",\"type\":\"address\"},{\"name\":\"_serverSig\",\"type\":\"bytes\"}],\"name\":\"userEndGame\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxStake\",\"outputs\":[{\"name\":\"\",\"type\":\"uint128\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_houseAddress\",\"type\":\"address\"}],\"name\":\"setHouseAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"gameIdCntr\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"transferProfitToHouse\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_serverAddress\",\"type\":\"address\"},{\"name\":\"_minStake\",\"type\":\"uint128\"},{\"name\":\"_maxStake\",\"type\":\"uint128\"},{\"name\":\"_conflictResAddress\",\"type\":\"address\"},{\"name\":\"_houseAddress\",\"type\":\"address\"},{\"name\":\"_chainId\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"gameId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"stake\",\"type\":\"uint128\"},{\"indexed\":true,\"name\":\"serverEndHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"userEndHash\",\"type\":\"bytes32\"}],\"name\":\"LogGameCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"gameId\",\"type\":\"uint256\"}],\"name\":\"LogUserRequestedEnd\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"gameId\",\"type\":\"uint256\"}],\"name\":\"LogServerRequestedEnd\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"gameId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"roundId\",\"type\":\"uint32\"},{\"indexed\":false,\"name\":\"balance\",\"type\":\"int256\"},{\"indexed\":false,\"name\":\"reason\",\"type\":\"uint8\"}],\"name\":\"LogGameEnded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"minStake\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"maxStake\",\"type\":\"uint256\"}],\"name\":\"LogStakeLimitsModified\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newConflictResolutionAddress\",\"type\":\"address\"}],\"name\":\"LogUpdatingConflictResolution\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newConflictResolutionAddress\",\"type\":\"address\"}],\"name\":\"LogUpdatedConflictResolution\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"LogPause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"LogUnpause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"LogActive\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"LogOwnerShipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"LogOwnerShipTransferInitiated\",\"type\":\"event\"}]","ContractName":"GameChannel","CompilerVersion":"v0.5.0+commit.1d4f565a","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000cef260a5fed7a896bbe07b933b3a5c17aec094d8000000000000000000000000000000000000000000000000002386f26fc10000000000000000000000000000000000000000000000000001a055690d9db8000000000000000000000000000045a0b6eef5857ecb504da583d549c620fe35301600000000000000000000000071be1ace87248f3950bdfc4c89b4b3eed059f6f30000000000000000000000000000000000000000000000000000000000000001","Library":"","SwarmSource":"bzzr://2962893aac580bbd54efca1473f7c82957764476c99a6a8af781c563e454f7f2"}]}