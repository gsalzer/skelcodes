{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.23;\r\n\r\n/**\r\n * @title Access Control List (Lightweight version)\r\n *\r\n * @dev Access control smart contract provides an API to check\r\n *      if specific operation is permitted globally and\r\n *      if particular user has a permission to execute it.\r\n * @dev This smart contract is designed to be inherited by other\r\n *      smart contracts which require access control management capabilities.\r\n *\r\n * @author Basil Gorin\r\n */\r\ncontract AccessControlLight {\r\n  /// @notice Role manager is responsible for assigning the roles\r\n  /// @dev Role ROLE_ROLE_MANAGER allows modifying operator roles\r\n  uint256 private constant ROLE_ROLE_MANAGER = 0x10000000;\r\n\r\n  /// @notice Feature manager is responsible for enabling/disabling\r\n  ///      global features of the smart contract\r\n  /// @dev Role ROLE_FEATURE_MANAGER allows modifying global features\r\n  uint256 private constant ROLE_FEATURE_MANAGER = 0x20000000;\r\n\r\n  /// @dev Bitmask representing all the possible permissions (super admin role)\r\n  uint256 private constant FULL_PRIVILEGES_MASK = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\r\n\r\n  /// @dev A bitmask of globally enabled features\r\n  uint256 public features;\r\n\r\n  /// @notice Privileged addresses with defined roles/permissions\r\n  /// @notice In the context of ERC20/ERC721 tokens these can be permissions to\r\n  ///      allow minting tokens, transferring on behalf and so on\r\n  /// @dev Maps an address to the permissions bitmask (role), where each bit\r\n  ///      represents a permission\r\n  /// @dev Bitmask 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\r\n  ///      represents all possible permissions\r\n  mapping(address => uint256) public userRoles;\r\n\r\n  /// @dev Fired in updateFeatures()\r\n  event FeaturesUpdated(address indexed _by, uint256 _requested, uint256 _actual);\r\n\r\n  /// @dev Fired in updateRole()\r\n  event RoleUpdated(address indexed _by, address indexed _to, uint256 _requested, uint256 _actual);\r\n\r\n  /**\r\n   * @dev Creates an access control instance,\r\n   *      setting contract creator to have full privileges\r\n   */\r\n  constructor() public {\r\n    // contract creator has full privileges\r\n    userRoles[msg.sender] = FULL_PRIVILEGES_MASK;\r\n  }\r\n\r\n  /**\r\n   * @dev Updates set of the globally enabled features (`features`),\r\n   *      taking into account sender's permissions.=\r\n   * @dev Requires transaction sender to have `ROLE_FEATURE_MANAGER` permission.\r\n   * @param mask bitmask representing a set of features to enable/disable\r\n   */\r\n  function updateFeatures(uint256 mask) public {\r\n    // caller must have a permission to update global features\r\n    require(isSenderInRole(ROLE_FEATURE_MANAGER));\r\n\r\n    // evaluate new features set and assign them\r\n    features = evaluateBy(msg.sender, features, mask);\r\n\r\n    // fire an event\r\n    emit FeaturesUpdated(msg.sender, mask, features);\r\n  }\r\n\r\n  /**\r\n   * @dev Updates set of permissions (role) for a given operator,\r\n   *      taking into account sender's permissions.\r\n   * @dev Setting role to zero is equivalent to removing an operator.\r\n   * @dev Setting role to `FULL_PRIVILEGES_MASK` is equivalent to\r\n   *      copying senders permissions (role) to an operator.\r\n   * @dev Requires transaction sender to have `ROLE_ROLE_MANAGER` permission.\r\n   * @param operator address of an operator to alter permissions for\r\n   * @param role bitmask representing a set of permissions to\r\n   *      enable/disable for an operator specified\r\n   */\r\n  function updateRole(address operator, uint256 role) public {\r\n    // caller must have a permission to update user roles\r\n    require(isSenderInRole(ROLE_ROLE_MANAGER));\r\n\r\n    // evaluate the role and reassign it\r\n    userRoles[operator] = evaluateBy(msg.sender, userRoles[operator], role);\r\n\r\n    // fire an event\r\n    emit RoleUpdated(msg.sender, operator, role, userRoles[operator]);\r\n  }\r\n\r\n  /**\r\n   * @dev Based on the actual role provided (set of permissions), operator address,\r\n   *      and role required (set of permissions), calculate the resulting\r\n   *      set of permissions (role).\r\n   * @dev If operator is super admin and has full permissions (FULL_PRIVILEGES_MASK),\r\n   *      the function will always return `required` regardless of the `actual`.\r\n   * @dev In contrast, if operator has no permissions at all (zero mask),\r\n   *      the function will always return `actual` regardless of the `required`.\r\n   * @param operator address of the contract operator to use permissions of\r\n   * @param actual input set of permissions to modify\r\n   * @param required desired set of permissions operator would like to have\r\n   * @return resulting set of permissions this operator can set\r\n   */\r\n  function evaluateBy(address operator, uint256 actual, uint256 required) public constant returns(uint256) {\r\n    // read operator's permissions\r\n    uint256 p = userRoles[operator];\r\n\r\n    // taking into account operator's permissions,\r\n    // 1) enable permissions requested on the `current`\r\n    actual |= p & required;\r\n    // 2) disable permissions requested on the `current`\r\n    actual &= FULL_PRIVILEGES_MASK ^ (p & (FULL_PRIVILEGES_MASK ^ required));\r\n\r\n    // return calculated result (actual is not modified)\r\n    return actual;\r\n  }\r\n\r\n  /**\r\n   * @dev Checks if requested set of features is enabled globally on the contract\r\n   * @param required set of features to check\r\n   * @return true if all the features requested are enabled, false otherwise\r\n   */\r\n  function isFeatureEnabled(uint256 required) public constant returns(bool) {\r\n    // delegate call to `__hasRole`, passing `features` property\r\n    return __hasRole(features, required);\r\n  }\r\n\r\n  /**\r\n   * @dev Checks if transaction sender `msg.sender` has all the permissions (role) required\r\n   * @param required set of permissions (role) to check\r\n   * @return true if all the permissions requested are enabled, false otherwise\r\n   */\r\n  function isSenderInRole(uint256 required) public constant returns(bool) {\r\n    // delegate call to `isOperatorInRole`, passing transaction sender\r\n    return isOperatorInRole(msg.sender, required);\r\n  }\r\n\r\n  /**\r\n   * @dev Checks if operator `operator` has all the permissions (role) required\r\n   * @param required set of permissions (role) to check\r\n   * @return true if all the permissions requested are enabled, false otherwise\r\n   */\r\n  function isOperatorInRole(address operator, uint256 required) public constant returns(bool) {\r\n    // delegate call to `__hasRole`, passing operator's permissions (role)\r\n    return __hasRole(userRoles[operator], required);\r\n  }\r\n\r\n  /// @dev Checks if role `actual` contains all the permissions required `required`\r\n  function __hasRole(uint256 actual, uint256 required) internal pure returns(bool) {\r\n    // check the bitmask for the role required and return the result\r\n    return actual & required == required;\r\n  }\r\n}\r\n\r\n/**\r\n * @title Address Utils\r\n *\r\n * @dev Utility library of inline functions on addresses\r\n */\r\nlibrary AddressUtils {\r\n\r\n  /**\r\n   * @notice Checks if the target address is a contract\r\n   * @dev This function will return false if invoked during the constructor of a contract,\r\n   *      as the code is not actually created until after the constructor finishes.\r\n   * @param addr address to check\r\n   * @return whether the target address is a contract\r\n   */\r\n  function isContract(address addr) internal view returns (bool) {\r\n    // a variable to load `extcodesize` to\r\n    uint256 size = 0;\r\n\r\n    // XXX Currently there is no better way to check if there is a contract in an address\r\n    // than to check the size of the code at that address.\r\n    // See https://ethereum.stackexchange.com/a/14016/36603 for more details about how this works.\r\n    // TODO: Check this again before the Serenity release, because all addresses will be contracts.\r\n    // solium-disable-next-line security/no-inline-assembly\r\n    assembly {\r\n      // retrieve the size of the code at address `addr`\r\n      size := extcodesize(addr)\r\n    }\r\n\r\n    // positive size indicates a smart contract address\r\n    return size > 0;\r\n  }\r\n\r\n}\r\n\r\n/**\r\n * @title ERC20 token receiver interface\r\n *\r\n * @dev Interface for any contract that wants to support safe transfers\r\n *      from ERC20 token smart contracts.\r\n * @dev Inspired by ERC721 and ERC223 token standards\r\n *\r\n * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\r\n * @dev See https://github.com/ethereum/EIPs/issues/223\r\n *\r\n * @author Basil Gorin\r\n */\r\ninterface ERC20Receiver {\r\n  /**\r\n   * @notice Handle the receipt of a ERC20 token(s)\r\n   * @dev The ERC20 smart contract calls this function on the recipient\r\n   *      after a successful transfer (`safeTransferFrom`).\r\n   *      This function MAY throw to revert and reject the transfer.\r\n   *      Return of other than the magic value MUST result in the transaction being reverted.\r\n   * @notice The contract address is always the message sender.\r\n   *      A wallet/broker/auction application MUST implement the wallet interface\r\n   *      if it will accept safe transfers.\r\n   * @param _operator The address which called `safeTransferFrom` function\r\n   * @param _from The address which previously owned the token\r\n   * @param _value amount of tokens which is being transferred\r\n   * @param _data additional data with no specified format\r\n   * @return `bytes4(keccak256(\"onERC20Received(address,address,uint256,bytes)\"))` unless throwing\r\n   */\r\n  function onERC20Received(address _operator, address _from, uint256 _value, bytes _data) external returns(bytes4);\r\n}\r\n\r\n/**\r\n * @title Gold Smart Contract\r\n *\r\n * @notice Gold is a transferable fungible entity (ERC20 token)\r\n *      used to \"pay\" for in game services like gem upgrades, etc.\r\n * @notice Gold is a part of Gold/Silver system, which allows to\r\n *      upgrade gems (level, grade, etc.)\r\n *\r\n * @dev Gold is mintable and burnable entity,\r\n *      meaning it can be created or destroyed by the authorized addresses\r\n * @dev An address authorized can mint/burn its own tokens (own balance) as well\r\n *      as tokens owned by another address (additional permission level required)\r\n *\r\n * @author Basil Gorin\r\n */\r\ncontract GoldERC20 is AccessControlLight {\r\n  /**\r\n   * @dev Smart contract version\r\n   * @dev Should be incremented manually in this source code\r\n   *      each time smart contact source code is changed and deployed\r\n   * @dev To distinguish from other tokens must be multiple of 0x100\r\n   */\r\n  uint32 public constant TOKEN_VERSION = 0x300;\r\n\r\n  /**\r\n   * @notice ERC20 symbol of that token (short name)\r\n   */\r\n  string public constant symbol = \"GLD\";\r\n\r\n  /**\r\n   * @notice ERC20 name of the token (long name)\r\n   */\r\n  string public constant name = \"GOLD - CryptoMiner World\";\r\n\r\n  /**\r\n   * @notice ERC20 decimals (number of digits to draw after the dot\r\n   *    in the UI applications (like MetaMask, other wallets and so on)\r\n   */\r\n  uint8 public constant decimals = 3;\r\n\r\n  /**\r\n   * @notice Based on the value of decimals above, one token unit\r\n   *      represents native number of tokens which is displayed\r\n   *      in the UI applications as one (1 or 1.0, 1.00, etc.)\r\n   */\r\n  uint256 public constant ONE_UNIT = uint256(10) ** decimals;\r\n\r\n  /**\r\n   * @notice A record of all the players token balances\r\n   * @dev This mapping keeps record of all token owners\r\n   */\r\n  mapping(address => uint256) private tokenBalances;\r\n\r\n  /**\r\n   * @notice Total amount of tokens tracked by this smart contract\r\n   * @dev Equal to sum of all token balances `tokenBalances`\r\n   */\r\n  uint256 private tokensTotal;\r\n\r\n  /**\r\n   * @notice A record of all the allowances to spend tokens on behalf\r\n   * @dev Maps token owner address to an address approved to spend\r\n   *      some tokens on behalf, maps approved address to that amount\r\n   */\r\n  mapping(address => mapping(address => uint256)) private transferAllowances;\r\n\r\n  /**\r\n   * @notice Enables ERC20 transfers of the tokens\r\n   *      (transfer by the token owner himself)\r\n   * @dev Feature FEATURE_TRANSFERS must be enabled to\r\n   *      call `transfer()` function\r\n   */\r\n  uint32 public constant FEATURE_TRANSFERS = 0x00000001;\r\n\r\n  /**\r\n   * @notice Enables ERC20 transfers on behalf\r\n   *      (transfer by someone else on behalf of token owner)\r\n   * @dev Feature FEATURE_TRANSFERS_ON_BEHALF must be enabled to\r\n   *      call `transferFrom()` function\r\n   * @dev Token owner must call `approve()` first to authorize\r\n   *      the transfer on behalf\r\n   */\r\n  uint32 public constant FEATURE_TRANSFERS_ON_BEHALF = 0x00000002;\r\n\r\n  /**\r\n   * @notice Token creator is responsible for creating (minting)\r\n   *      tokens to some player address\r\n   * @dev Role ROLE_TOKEN_CREATOR allows minting tokens\r\n   *      (calling `mint` and `mintTo` functions)\r\n   */\r\n  uint32 public constant ROLE_TOKEN_CREATOR = 0x00000001;\r\n\r\n  /**\r\n   * @notice Token destroyer is responsible for destroying (burning)\r\n   *      tokens owned by some player address\r\n   * @dev Role ROLE_TOKEN_DESTROYER allows burning tokens\r\n   *      (calling `burn` and `burnFrom` functions)\r\n   */\r\n  uint32 public constant ROLE_TOKEN_DESTROYER = 0x00000002;\r\n\r\n  /**\r\n   * @dev Magic value to be returned by ERC20Receiver upon successful reception of token(s)\r\n   * @dev Equal to `bytes4(keccak256(\"onERC20Received(address,address,uint256,bytes)\"))`,\r\n   *      which can be also obtained as `ERC20Receiver(0).onERC20Received.selector`\r\n   */\r\n  bytes4 private constant ERC20_RECEIVED = 0x4fc35859;\r\n\r\n  /**\r\n   * @dev Fired in transfer() and transferFrom() functions\r\n   * @param _from an address which performed the transfer\r\n   * @param _to an address tokens were sent to\r\n   * @param _value number of tokens transferred\r\n   */\r\n  event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n\r\n  /**\r\n   * @dev Fired in approve() function\r\n   * @param _owner an address which granted a permission to transfer\r\n   *      tokens on its behalf\r\n   * @param _spender an address which received a permission to transfer\r\n   *      tokens on behalf of the owner `_owner`\r\n   */\r\n  event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n\r\n  /**\r\n   * @dev Fired in mint() function\r\n   * @param _by an address which minted some tokens (transaction sender)\r\n   * @param _to an address the tokens were minted to\r\n   * @param _value an amount of tokens minted\r\n   */\r\n  event Minted(address indexed _by, address indexed _to, uint256 _value);\r\n\r\n  /**\r\n   * @dev Fired in burn() function\r\n   * @param _by an address which burned some tokens (transaction sender)\r\n   * @param _from an address the tokens were burnt from\r\n   * @param _value an amount of tokens burnt\r\n   */\r\n  event Burnt(address indexed _by, address indexed _from, uint256 _value);\r\n\r\n  /**\r\n   * @notice Total number of tokens tracked by this smart contract\r\n   * @dev Equal to sum of all token balances\r\n   * @return total number of tokens\r\n   */\r\n  function totalSupply() public constant returns (uint256) {\r\n    // read total tokens value and return\r\n    return tokensTotal;\r\n  }\r\n\r\n  /**\r\n   * @notice Gets the balance of particular address\r\n   * @dev Gets the balance of the specified address\r\n   * @param _owner the address to query the the balance for\r\n   * @return an amount of tokens owned by the address specified\r\n   */\r\n  function balanceOf(address _owner) public constant returns (uint256) {\r\n    // read the balance from storage and return\r\n    return tokenBalances[_owner];\r\n  }\r\n\r\n  /**\r\n   * @dev A function to check an amount of tokens owner approved\r\n   *      to transfer on its behalf by some other address called \"spender\"\r\n   * @param _owner an address which approves transferring some tokens on its behalf\r\n   * @param _spender an address approved to transfer some tokens on behalf\r\n   * @return an amount of tokens approved address `_spender` can transfer on behalf\r\n   *      of token owner `_owner`\r\n   */\r\n  function allowance(address _owner, address _spender) public constant returns (uint256) {\r\n    // read the value from storage and return\r\n    return transferAllowances[_owner][_spender];\r\n  }\r\n\r\n  /**\r\n   * @notice Transfers some tokens to an address `_to`\r\n   * @dev Called by token owner (an address which has a\r\n   *      positive token balance tracked by this smart contract)\r\n   * @dev Throws on any error like\r\n   *      * incorrect `_value` (zero) or\r\n   *      * insufficient token balance or\r\n   *      * incorrect `_to` address:\r\n   *          * zero address or\r\n   *          * self address or\r\n   *          * smart contract which doesn't support ERC20\r\n   * @param _to an address to transfer tokens to,\r\n   *      must be either an external address or a smart contract,\r\n   *      compliant with the ERC20 standard\r\n   * @param _value amount of tokens to be transferred, must\r\n   *      be greater than zero\r\n   * @return true on success, throws otherwise\r\n   */\r\n  function transfer(address _to, uint256 _value) public returns (bool) {\r\n    // just delegate call to `transferFrom`,\r\n    // `FEATURE_TRANSFERS` is verified inside it\r\n    return transferFrom(msg.sender, _to, _value);\r\n  }\r\n\r\n  /**\r\n   * @notice Transfers some tokens on behalf of address `_from' (token owner)\r\n   *      to some other address `_to`\r\n   * @dev Called by token owner on his own or approved address,\r\n   *      an address approved earlier by token owner to\r\n   *      transfer some amount of tokens on its behalf\r\n   * @dev Throws on any error like\r\n   *      * incorrect `_value` (zero) or\r\n   *      * insufficient token balance or\r\n   *      * incorrect `_to` address:\r\n   *          * zero address or\r\n   *          * same as `_from` address (self transfer)\r\n   *          * smart contract which doesn't support ERC20\r\n   * @param _from token owner which approved caller (transaction sender)\r\n   *      to transfer `_value` of tokens on its behalf\r\n   * @param _to an address to transfer tokens to,\r\n   *      must be either an external address or a smart contract,\r\n   *      compliant with the ERC20 standard\r\n   * @param _value amount of tokens to be transferred, must\r\n   *      be greater than zero\r\n   * @return true on success, throws otherwise\r\n   */\r\n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\r\n    // just delegate call to `safeTransferFrom`, passing empty `_data`,\r\n    // `FEATURE_TRANSFERS` is verified inside it\r\n    safeTransferFrom(_from, _to, _value, \"\");\r\n\r\n    // `safeTransferFrom` throws of any error, so\r\n    // if we're here - it means operation successful,\r\n    // just return true\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @notice Transfers some tokens on behalf of address `_from' (token owner)\r\n   *      to some other address `_to`\r\n   * @dev Inspired by ERC721 safeTransferFrom, this function allows to\r\n   *      send arbitrary data to the receiver on successful token transfer\r\n   * @dev Called by token owner on his own or approved address,\r\n   *      an address approved earlier by token owner to\r\n   *      transfer some amount of tokens on its behalf\r\n   * @dev Throws on any error like\r\n   *      * incorrect `_value` (zero) or\r\n   *      * insufficient token balance or\r\n   *      * incorrect `_to` address:\r\n   *          * zero address or\r\n   *          * same as `_from` address (self transfer)\r\n   *          * smart contract which doesn't support ERC20Receiver interface\r\n   * @param _from token owner which approved caller (transaction sender)\r\n   *      to transfer `_value` of tokens on its behalf\r\n   * @param _to an address to transfer tokens to,\r\n   *      must be either an external address or a smart contract,\r\n   *      compliant with the ERC20 standard\r\n   * @param _value amount of tokens to be transferred, must\r\n   *      be greater than zero\r\n   * @param _data [optional] additional data with no specified format,\r\n   *      sent in onERC20Received call to `_to` in case if its a smart contract\r\n   * @return true on success, throws otherwise\r\n   */\r\n  function safeTransferFrom(address _from, address _to, uint256 _value, bytes _data) public {\r\n    // first delegate call to `unsafeTransferFrom`\r\n    // to perform the unsafe token(s) transfer\r\n    unsafeTransferFrom(_from, _to, _value);\r\n\r\n    // after the successful transfer – check if receiver supports\r\n    // ERC20Receiver and execute a callback handler `onERC20Received`,\r\n    // reverting whole transaction on any error:\r\n    // check if receiver `_to` supports ERC20Receiver interface\r\n    if (AddressUtils.isContract(_to)) {\r\n      // if `_to` is a contract – execute onERC20Received\r\n      bytes4 response = ERC20Receiver(_to).onERC20Received(msg.sender, _from, _value, _data);\r\n\r\n      // expected response is ERC20_RECEIVED\r\n      require(response == ERC20_RECEIVED);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @notice Transfers some tokens on behalf of address `_from' (token owner)\r\n   *      to some other address `_to`\r\n   * @dev In contrast to `safeTransferFrom` doesn't check recipient\r\n   *      smart contract to support ERC20 tokens (ERC20Receiver)\r\n   * @dev Designed to be used by developers when the receiver is known\r\n   *      to support ERC20 tokens but doesn't implement ERC20Receiver interface\r\n   * @dev Called by token owner on his own or approved address,\r\n   *      an address approved earlier by token owner to\r\n   *      transfer some amount of tokens on its behalf\r\n   * @dev Throws on any error like\r\n   *      * incorrect `_value` (zero) or\r\n   *      * insufficient token balance or\r\n   *      * incorrect `_to` address:\r\n   *          * zero address or\r\n   *          * same as `_from` address (self transfer)\r\n   * @param _from token owner which approved caller (transaction sender)\r\n   *      to transfer `_value` of tokens on its behalf\r\n   * @param _to an address to transfer tokens to,\r\n   *      must be either an external address or a smart contract,\r\n   *      compliant with the ERC20 standard\r\n   * @param _value amount of tokens to be transferred, must\r\n   *      be greater than zero\r\n   * @return true on success, throws otherwise\r\n   */\r\n  function unsafeTransferFrom(address _from, address _to, uint256 _value) public {\r\n    // if `_from` is equal to sender, require transfers feature to be enabled\r\n    // otherwise require transfers on behalf feature to be enabled\r\n    require(_from == msg.sender && isFeatureEnabled(FEATURE_TRANSFERS)\r\n         || _from != msg.sender && isFeatureEnabled(FEATURE_TRANSFERS_ON_BEHALF));\r\n\r\n    // non-zero to address check\r\n    require(_to != address(0));\r\n\r\n    // sender and recipient cannot be the same\r\n    require(_from != _to);\r\n\r\n    // zero value transfer check\r\n    require(_value != 0);\r\n\r\n    // by design of mint() -\r\n    // - no need to make arithmetic overflow check on the _value\r\n\r\n    // in case of transfer on behalf\r\n    if(_from != msg.sender) {\r\n      // verify sender has an allowance to transfer amount of tokens requested\r\n      require(transferAllowances[_from][msg.sender] >= _value);\r\n\r\n      // decrease the amount of tokens allowed to transfer\r\n      transferAllowances[_from][msg.sender] -= _value;\r\n    }\r\n\r\n    // verify sender has enough tokens to transfer on behalf\r\n    require(tokenBalances[_from] >= _value);\r\n\r\n    // perform the transfer:\r\n    // decrease token owner (sender) balance\r\n    tokenBalances[_from] -= _value;\r\n\r\n    // increase `_to` address (receiver) balance\r\n    tokenBalances[_to] += _value;\r\n\r\n    // emit an ERC20 transfer event\r\n    emit Transfer(_from, _to, _value);\r\n  }\r\n\r\n  /**\r\n   * @notice Approves address called \"spender\" to transfer some amount\r\n   *      of tokens on behalf of the owner\r\n   * @dev Caller must not necessarily own any tokens to grant the permission\r\n   * @param _spender an address approved by the caller (token owner)\r\n   *      to spend some tokens on its behalf\r\n   * @param _value an amount of tokens spender `_spender` is allowed to\r\n   *      transfer on behalf of the token owner\r\n   * @return true on success, throws otherwise\r\n   */\r\n  function approve(address _spender, uint256 _value) public returns (bool) {\r\n    // perform an operation: write value requested into the storage\r\n    transferAllowances[msg.sender][_spender] = _value;\r\n\r\n    // emit an event\r\n    emit Approval(msg.sender, _spender, _value);\r\n\r\n    // operation successful, return true\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Mints (creates) some tokens to address specified\r\n   * @dev The value passed is treated as number of units (see `ONE_UNIT`)\r\n   *      to achieve natural impression on token quantity\r\n   * @dev Requires sender to have `ROLE_TOKEN_CREATOR` permission\r\n   * @param _to an address to mint tokens to\r\n   * @param _value an amount of tokens to mint (create)\r\n   */\r\n  function mint(address _to, uint256 _value) public {\r\n    // calculate native value, taking into account `decimals`\r\n    uint256 value = _value * ONE_UNIT;\r\n\r\n    // arithmetic overflow and non-zero value check\r\n    require(value > _value);\r\n\r\n    // delegate call to native `mintNative`\r\n    mintNative(_to, value);\r\n  }\r\n\r\n  /**\r\n   * @dev Mints (creates) some tokens to address specified\r\n   * @dev The value specified is treated as is without taking\r\n   *      into account what `decimals` value is\r\n   * @dev Requires sender to have `ROLE_TOKEN_CREATOR` permission\r\n   * @param _to an address to mint tokens to\r\n   * @param _value an amount of tokens to mint (create)\r\n   */\r\n  function mintNative(address _to, uint256 _value) public {\r\n    // check if caller has sufficient permissions to mint tokens\r\n    require(isSenderInRole(ROLE_TOKEN_CREATOR));\r\n\r\n    // non-zero recipient address check\r\n    require(_to != address(0));\r\n\r\n    // non-zero _value and arithmetic overflow check on the total supply\r\n    // this check automatically secures arithmetic overflow on the individual balance\r\n    require(tokensTotal + _value > tokensTotal);\r\n\r\n    // increase `_to` address balance\r\n    tokenBalances[_to] += _value;\r\n\r\n    // increase total amount of tokens value\r\n    tokensTotal += _value;\r\n\r\n    // fire ERC20 compliant transfer event\r\n    emit Transfer(address(0), _to, _value);\r\n\r\n    // fire a mint event\r\n    emit Minted(msg.sender, _to, _value);\r\n  }\r\n\r\n  /**\r\n   * @dev Burns (destroys) some tokens from the address specified\r\n   * @dev The value passed is treated as number of units (see `ONE_UNIT`)\r\n   *      to achieve natural impression on token quantity\r\n   * @dev Requires sender to have `ROLE_TOKEN_DESTROYER` permission\r\n   * @param _from an address to burn some tokens from\r\n   * @param _value an amount of tokens to burn (destroy)\r\n   */\r\n  function burn(address _from, uint256 _value) public {\r\n    // calculate native value, taking into account `decimals`\r\n    uint256 value = _value * ONE_UNIT;\r\n\r\n    // arithmetic overflow and non-zero value check\r\n    require(value > _value);\r\n\r\n    // delegate call to native `burnNative`\r\n    burnNative(_from, value);\r\n  }\r\n\r\n  /**\r\n   * @dev Burns (destroys) some tokens from the address specified\r\n   * @dev The value specified is treated as is without taking\r\n   *      into account what `decimals` value is\r\n   * @dev Requires sender to have `ROLE_TOKEN_DESTROYER` permission\r\n   * @param _from an address to burn some tokens from\r\n   * @param _value an amount of tokens to burn (destroy)\r\n   */\r\n  function burnNative(address _from, uint256 _value) public {\r\n    // check if caller has sufficient permissions to burn tokens\r\n    require(isSenderInRole(ROLE_TOKEN_DESTROYER));\r\n\r\n    // non-zero burn value check\r\n    require(_value != 0);\r\n\r\n    // verify `_from` address has enough tokens to destroy\r\n    // (basically this is a arithmetic overflow check)\r\n    require(tokenBalances[_from] >= _value);\r\n\r\n    // decrease `_from` address balance\r\n    tokenBalances[_from] -= _value;\r\n\r\n    // decrease total amount of tokens value\r\n    tokensTotal -= _value;\r\n\r\n    // fire ERC20 compliant transfer event\r\n    emit Transfer(_from, address(0), _value);\r\n\r\n    // fire a burn event\r\n    emit Burnt(msg.sender, _from, _value);\r\n  }\r\n\r\n}\r\n\r\n\r\n/**\r\n * @title Silver Smart Contract\r\n *\r\n * @notice Silver is a transferable fungible entity (ERC20 token)\r\n *      used to \"pay\" for in game services like gem upgrades, etc.\r\n * @notice Silver is a part of Gold/Silver system, which allows to\r\n *      upgrade gems (level, grade, etc.)\r\n *\r\n * @dev Silver is mintable and burnable entity,\r\n *      meaning it can be created or destroyed by the authorized addresses\r\n * @dev An address authorized can mint/burn its own tokens (own balance) as well\r\n *      as tokens owned by another address (additional permission level required)\r\n *\r\n * @author Basil Gorin\r\n */\r\ncontract SilverERC20 is GoldERC20 {\r\n  /**\r\n   * @dev Smart contract version\r\n   * @dev Should be incremented manually in this source code\r\n   *      each time smart contact source code is changed\r\n   * @dev To distinguish from other tokens must be multiple of 0x10\r\n   */\r\n  uint32 public constant TOKEN_VERSION = 0x30;\r\n\r\n  /**\r\n   * @notice ERC20 symbol of that token (short name)\r\n   */\r\n  string public constant symbol = \"SLV\";\r\n\r\n  /**\r\n   * @notice ERC20 name of the token (long name)\r\n   */\r\n  string public constant name = \"SILVER - CryptoMiner World\";\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"features\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TOKEN_VERSION\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"burnNative\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"unsafeTransferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"mintNative\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"required\",\"type\":\"uint256\"}],\"name\":\"isFeatureEnabled\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"userRoles\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ROLE_TOKEN_CREATOR\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"FEATURE_TRANSFERS_ON_BEHALF\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"operator\",\"type\":\"address\"},{\"name\":\"role\",\"type\":\"uint256\"}],\"name\":\"updateRole\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"FEATURE_TRANSFERS\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"operator\",\"type\":\"address\"},{\"name\":\"required\",\"type\":\"uint256\"}],\"name\":\"isOperatorInRole\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"mask\",\"type\":\"uint256\"}],\"name\":\"updateFeatures\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ROLE_TOKEN_DESTROYER\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ONE_UNIT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"operator\",\"type\":\"address\"},{\"name\":\"actual\",\"type\":\"uint256\"},{\"name\":\"required\",\"type\":\"uint256\"}],\"name\":\"evaluateBy\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"required\",\"type\":\"uint256\"}],\"name\":\"isSenderInRole\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_by\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Minted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_by\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Burnt\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_by\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_requested\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_actual\",\"type\":\"uint256\"}],\"name\":\"FeaturesUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_by\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_requested\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_actual\",\"type\":\"uint256\"}],\"name\":\"RoleUpdated\",\"type\":\"event\"}]","ContractName":"SilverERC20","CompilerVersion":"v0.4.23+commit.124ca40d","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://424cd2cfceadcaea76998551c19a706208c4b7045a0330f928f447e58382b234"}]}