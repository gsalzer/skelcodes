{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.0;\r\n\r\n/**\r\n  * @title DSMath\r\n  * @author MakerDAO\r\n  * @notice Safe math contracts from Maker.\r\n  */\r\ncontract DSMath {\r\n    function add(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x + y) >= x);\r\n    }\r\n    function sub(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x - y) <= x);\r\n    }\r\n    function mul(uint x, uint y) internal pure returns (uint z) {\r\n        require(y == 0 || (z = x * y) / y == x);\r\n    }\r\n\r\n    function min(uint x, uint y) internal pure returns (uint z) {\r\n        return x <= y ? x : y;\r\n    }\r\n    function max(uint x, uint y) internal pure returns (uint z) {\r\n        return x >= y ? x : y;\r\n    }\r\n    function imin(int x, int y) internal pure returns (int z) {\r\n        return x <= y ? x : y;\r\n    }\r\n    function imax(int x, int y) internal pure returns (int z) {\r\n        return x >= y ? x : y;\r\n    }\r\n\r\n    uint constant WAD = 10 ** 18;\r\n    uint constant RAY = 10 ** 27;\r\n\r\n    function wmul(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, y), WAD / 2) / WAD;\r\n    }\r\n    function rmul(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, y), RAY / 2) / RAY;\r\n    }\r\n    function wdiv(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, WAD), y / 2) / y;\r\n    }\r\n    function rdiv(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, RAY), y / 2) / y;\r\n    }\r\n\r\n    // This famous algorithm is called \"exponentiation by squaring\"\r\n    // and calculates x^n with x as fixed-point and n as regular unsigned.\r\n    //\r\n    // It's O(log n), instead of O(n) for naive repeated multiplication.\r\n    //\r\n    // These facts are why it works:\r\n    //\r\n    //  If n is even, then x^n = (x^2)^(n/2).\r\n    //  If n is odd,  then x^n = x * x^(n-1),\r\n    //   and applying the equation for even x gives\r\n    //    x^n = x * (x^2)^((n-1) / 2).\r\n    //\r\n    //  Also, EVM division is flooring and\r\n    //    floor[(n-1) / 2] = floor[n / 2].\r\n    //\r\n    function rpow(uint x, uint n) internal pure returns (uint z) {\r\n        z = n % 2 != 0 ? x : RAY;\r\n\r\n        for (n /= 2; n != 0; n /= 2) {\r\n            x = rmul(x, x);\r\n\r\n            if (n % 2 != 0) {\r\n                z = rmul(z, x);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n  * @title Owned\r\n  * @author Gavin Wood?\r\n  * @notice Primitive owner properties, modifiers and methods for a single\r\n  *     to own a particular contract.\r\n  */\r\ncontract Owned {\r\n    address public owner = msg.sender;\r\n\r\n    modifier isOwner {\r\n        assert(msg.sender == owner); _;\r\n    }\r\n\r\n    function changeOwner(address account) external isOwner {\r\n        owner = account;\r\n    }\r\n}\r\n\r\n/**\r\n  * @title Pausable\r\n  * @author MakerDAO?\r\n  * @notice Primitive events, methods, properties for a contract which can be\r\n        paused by a single owner.\r\n  */\r\ncontract Pausable is Owned {\r\n    event Pause();\r\n    event Unpause();\r\n\r\n    bool public paused;\r\n\r\n    modifier pausable {\r\n        assert(!paused); _;\r\n    }\r\n\r\n    function pause() external isOwner {\r\n        paused = true;\r\n\r\n        emit Pause();\r\n    }\r\n\r\n    function unpause() external isOwner {\r\n        paused = false;\r\n\r\n        emit Unpause();\r\n    }\r\n}\r\n\r\n/**\r\n  * @title BurnerAccount\r\n  * @author UnityCoin Team\r\n  * @notice Primitive events, methods, properties for a contract which has a\r\n          special burner account that is Owned by a single account.\r\n  */\r\ncontract BurnerAccount is Owned {\r\n    address public burner;\r\n\r\n    modifier isOwnerOrBurner {\r\n        assert(msg.sender == burner || msg.sender == owner); _;\r\n    }\r\n\r\n    function changeBurner(address account) external isOwner {\r\n        burner = account;\r\n    }\r\n}\r\n\r\n/**\r\n  * @title IntervalBased\r\n  * @author UnityCoin Team\r\n  * @notice Primitive events, methods, properties for a contract which has a\r\n  *        interval system, that can be changed in-flight.\r\n  *\r\n  *        Here we create a system in which any valid unixtimestamp can reduce\r\n  *        down to a specific interval number, based on a start time, duration\r\n  *        and offset.\r\n  *\r\n  *        Interval Derivation\r\n  *        number = offset + ((timestamp - start time) / intervalDuration)\r\n  *\r\n  *        Note, when your changing the interval params in flight, we must\r\n  *        set the offset to the most current interval number, as to not\r\n  *        disrupt previously used interval numbers / mechanics\r\n  */\r\ncontract IntervalBased is DSMath {\r\n    // the start interval\r\n    uint256 public intervalStartTimestamp;\r\n\r\n    // interval duration (e.g. 1 days)\r\n    uint256 public intervalDuration;\r\n\r\n    // the max amount of intervals that can be processed for interest claim\r\n    uint256 public intervalMaximum;\r\n\r\n    // interval offset\r\n    uint256 public intervalOffset;\r\n\r\n    function changeDuration(uint256 duration) internal {\r\n      // protect againt unecessary change of offset and starttimestamp\r\n      if (duration == intervalDuration) { return; }\r\n\r\n      // offset all previous intervals\r\n      intervalOffset = intervalNumber(block.timestamp);\r\n\r\n      // set new duration\r\n      intervalDuration = duration;\r\n\r\n      // restart timestamp to current\r\n      intervalStartTimestamp = block.timestamp;\r\n    }\r\n\r\n    // get the interval number from start position\r\n    // every timestamp should have an interval past the start timestamp..\r\n    function intervalNumber(uint256 timestamp) public view returns(uint256 number) {\r\n        return add(intervalOffset, sub(timestamp, intervalStartTimestamp) / intervalDuration);\r\n    }\r\n}\r\n\r\n/**\r\n  * @title ERC20Events\r\n  * @author EIP20 Authors\r\n  * @notice Primitive events for the ERC20 event specification.\r\n  */\r\ncontract ERC20Events {\r\n    event Transfer(address indexed from, address indexed to, uint256 tokens);\r\n    event Approval(address indexed tokenOwner, address indexed spender, uint256 tokens);\r\n}\r\n\r\n/**\r\n  * @title ERC20\r\n  * @author EIP/ERC20 Authors\r\n  * @author BokkyPooBah / Bok Consulting Pty Ltd 2018.\r\n  * @notice The ERC20 standard contract interface.\r\n  */\r\ncontract ERC20 is ERC20Events {\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address tokenOwner) public view returns (uint);\r\n    function allowance(address tokenOwner, address spender) external view returns (uint);\r\n\r\n    function approve(address spender, uint amount) public returns (bool);\r\n    function transfer(address to, uint amount) external returns (bool);\r\n    function transferFrom(\r\n        address from, address to, uint amount\r\n    ) public returns (bool);\r\n}\r\n\r\n/**\r\n  * @title ERC20Token\r\n  * @author BokkyPooBah / Bok Consulting Pty Ltd 2018.\r\n  * @author UnityCoin Team\r\n  * @author MakerDAO\r\n  * @notice An ERC20 Token implimentation based roughly off of MakerDAO's\r\n  *       version DSToken.\r\n  */\r\ncontract ERC20Token is DSMath, ERC20 {\r\n    // Standard EIP20 Name, Symbol, Decimals\r\n    string public symbol = \"USDC\";\r\n    string public name = \"UnityCoinTest\";\r\n    string public version = \"1.0.0\";\r\n    uint8 public decimals = 18;\r\n\r\n    // Balances for each account\r\n    mapping(address => uint256) balances;\r\n\r\n    // Owner of account approves the transfer of an amount to another account\r\n    mapping(address => mapping (address => uint256)) approvals;\r\n\r\n    // Standard EIP20: BalanceOf, Transfer, TransferFrom, Allow, Allowance methods..\r\n    // Get the token balance for account `tokenOwner`\r\n    function balanceOf(address tokenOwner) public view returns (uint balance) {\r\n        return balances[tokenOwner];\r\n    }\r\n\r\n    // Transfer the balance from owner's account to another account\r\n    function transfer(address to, uint256 tokens) external returns (bool success) {\r\n        return transferFrom(msg.sender, to, tokens);\r\n    }\r\n\r\n    // Send `tokens` amount of tokens from address `from` to address `to`\r\n    // The transferFrom method is used for a withdraw workflow, allowing contracts to send\r\n    // tokens on your behalf, for example to \"deposit\" to a contract address and/or to charge\r\n    // fees in sub-currencies; the command should fail unless the from account has\r\n    // deliberately authorized the sender of the message via some mechanism; we propose\r\n    // these standardized APIs for approval:\r\n    function transferFrom(address from, address to, uint256 tokens) public returns (bool success) {\r\n        if (from != msg.sender) {\r\n            approvals[from][msg.sender] = sub(approvals[from][msg.sender], tokens);\r\n        }\r\n\r\n        balances[from] = sub(balances[from], tokens);\r\n        balances[to] = add(balances[to], tokens);\r\n\r\n        emit Transfer(from, to, tokens);\r\n        return true;\r\n    }\r\n\r\n    // Allow `spender` to withdraw from your account, multiple times, up to the `tokens` amount.\r\n    // If this function is called again it overwrites the current allowance with _value.\r\n    function approve(address spender, uint256 tokens) public returns (bool success) {\r\n        approvals[msg.sender][spender] = tokens;\r\n\r\n        emit Approval(msg.sender, spender, tokens);\r\n        return true;\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Returns the amount of tokens approved by the owner that can be\r\n    // transferred to the spender's account\r\n    // ------------------------------------------------------------------------\r\n    function allowance(address tokenOwner, address spender) external view returns (uint remaining) {\r\n        return approvals[tokenOwner][spender];\r\n    }\r\n}\r\n\r\n/**\r\n  * @title InterestRateBased\r\n  * @author UnityCoin Team\r\n  * @notice A compount interest module which allows for the recording of balance\r\n  *       events and interest rate changes.\r\n  *\r\n  *       Compound Interest Aglo:\r\n  *       compound interest owed = (principle * ( 1 + Rate / 100 ) * N) – principle;\r\n  *\r\n  *       This module uses the interval system IntervalBased.\r\n  *       The module is time based and thus we accept that miners can manipulate\r\n  *       time.\r\n  *\r\n  *       Rate's are specified (as per DSMath imp.) in 10 pow 27 always.\r\n  *       Rates are recorded in an array `interestRates` and thus are indexed.\r\n  *\r\n  *       Everytime a balance is recorded, we also make sure to set an updatable\r\n  *       pointer to the most recent InterestRate index `intervalToInterestIndex`.\r\n  *\r\n  *       This module provides a way to calculate compound interest owed,\r\n  *       given the interest rates and balance records are recoded properly.\r\n  */\r\ncontract InterestRateBased is IntervalBased {\r\n    // Interest Rate Record\r\n    struct InterestRate {\r\n        uint256 interval;\r\n        uint256 rate; // >= 10 ** 27\r\n    }\r\n\r\n    // Interval to interest rate\r\n    InterestRate[] public interestRates;\r\n\r\n    // uint256(interval) => uint256(interest index)\r\n    mapping(uint256 => uint256) public intervalToInterestIndex;\r\n\r\n    // Balance Records\r\n    struct BalanceRecord {\r\n        uint256 interval;\r\n        uint256 intervalOffset;\r\n        uint256 balance;\r\n    }\r\n\r\n    // address(token holder) => uint256(interval) => BalanceChange\r\n    mapping(address => BalanceRecord[]) public balanceRecords;\r\n\r\n    // address(tokenOwner) => uint256(balance index)\r\n    mapping(address => uint256) public lastClaimedBalanceIndex;\r\n\r\n    // include balance of method, is ERC20 compliant for tokens\r\n    function balanceOf(address tokenOwner) public view returns (uint);\r\n\r\n    // VIEW: get current interest rate\r\n    function latestInterestRate() external view returns (uint256 rateAsRay, uint256 asOfInterval) {\r\n        uint256 latestRateIndex = interestRates.length > 0 ? sub(interestRates.length, 1) : 0;\r\n\r\n        return (interestRates[latestRateIndex].rate, interestRates[latestRateIndex].interval);\r\n    }\r\n\r\n    // getters\r\n    function numInterestRates() public view returns (uint256) {\r\n      return interestRates.length;\r\n    }\r\n\r\n    // getters\r\n    function numBalanceRecords(address tokenOwner) public view returns (uint256) {\r\n      return balanceRecords[tokenOwner].length;\r\n    }\r\n\r\n    // interest owed\r\n    function interestOwed(address tokenOwner)\r\n        public\r\n        view\r\n        returns (uint256 amountOwed, uint256 balanceIndex, uint256 interval) {\r\n\r\n        // check for no balance records..\r\n        if (balanceRecords[tokenOwner].length == 0) {\r\n          return (0, 0, 0);\r\n        }\r\n\r\n        // balance index\r\n        amountOwed = 0;\r\n        balanceIndex = lastClaimedBalanceIndex[tokenOwner];\r\n        interval = balanceRecords[tokenOwner][balanceIndex].intervalOffset;\r\n\r\n        // current principle and interest rate\r\n        uint256 principle = 0; // current principle value\r\n        uint256 interestRate = 0; // current interest rate\r\n\r\n        // interval markers and interval offset\r\n        uint256 nextBalanceInterval = interval; // set to starting interval for setup\r\n        uint256 nextInterestInterval = interval; // set to starting interval for setup\r\n\r\n        // enforce interval maximum, last claim offset difference with max\r\n        assert(sub(intervalNumber(block.timestamp), intervalOffset) < intervalMaximum);\r\n\r\n        // this for loop should only hit either interest or balance change records, and in theory process only\r\n        // what is required to calculate compound interest with general computaitonal efficiency\r\n        // yes, maybe in the future adding a MIN here would be good..\r\n        while (interval < intervalNumber(block.timestamp)) {\r\n\r\n            // set interest rates for given interval\r\n            if (interval == nextInterestInterval) {\r\n                uint256 interestIndex = intervalToInterestIndex[interval];\r\n\r\n                // set rate with current interval\r\n                interestRate = interestRates[interestIndex].rate;\r\n\r\n                // check if look ahead next index is greater than rates length, if so, go to max interval, otherwise next up\r\n                nextInterestInterval = add(interestIndex, 1) >= interestRates.length\r\n                    ? intervalNumber(block.timestamp)\r\n                    : interestRates[add(interestIndex, 1)].interval;\r\n            }\r\n\r\n            // setup principle with whats on record at given interval\r\n            if (interval == nextBalanceInterval) {\r\n                // get current principle at current balance index, add with amount previously owed in interest\r\n                principle = add(balanceRecords[tokenOwner][balanceIndex].balance, amountOwed);\r\n\r\n                // increase balance index ahead now that we have the balance\r\n                balanceIndex = add(balanceIndex, 1);\r\n\r\n                // check if the new blance index exceeds, set next interval to limit or next interval on record\r\n                nextBalanceInterval = balanceIndex >= balanceRecords[tokenOwner].length\r\n                    ? intervalNumber(block.timestamp)\r\n                    : balanceRecords[tokenOwner][balanceIndex].interval;\r\n            }\r\n\r\n            // apply compound interest to principle, subtract original principle, add to amount owed\r\n            amountOwed = add(amountOwed, sub(wmul(principle,\r\n                rpow(interestRate,\r\n                    sub(min(nextBalanceInterval, nextInterestInterval), interval)) / 10 ** 9),\r\n                        principle));\r\n\r\n            // set interval to next nearest major balance or interest (or both) change\r\n            interval = min(nextBalanceInterval, nextInterestInterval);\r\n        }\r\n\r\n        // return amount owed, adjusted balance index, and the last interval set / used\r\n        return (amountOwed, (balanceIndex > 0 ? sub(balanceIndex, 1) : 0), interval);\r\n    }\r\n\r\n    // record users balance (max 2 writes additional per person per transfer)\r\n    function recordBalance(address tokenOwner) internal {\r\n        // todays current interval id\r\n        uint256 todaysInterval = intervalNumber(block.timestamp);\r\n\r\n        // last balance index\r\n        uint256 latestBalanceIndex = balanceRecords[tokenOwner].length > 0\r\n            ? sub(balanceRecords[tokenOwner].length, 1) : 0;\r\n\r\n        // always update the current record (i.e. todays interval)\r\n        // record balance record (if latest record is for today, add to it, otherwise add a record)\r\n        if (balanceRecords[tokenOwner].length > 0\r\n            && balanceRecords[tokenOwner][latestBalanceIndex].interval == todaysInterval) {\r\n            balanceRecords[tokenOwner][latestBalanceIndex].balance = balanceOf(tokenOwner);\r\n        } else {\r\n            balanceRecords[tokenOwner].push(BalanceRecord({\r\n                interval: todaysInterval,\r\n                intervalOffset: todaysInterval,\r\n                balance: balanceOf(tokenOwner)\r\n            }));\r\n        }\r\n\r\n        // if no interval to interest mapping exists, map it (should always be at least a length of one)\r\n        if (intervalToInterestIndex[todaysInterval] <= 0) {\r\n            intervalToInterestIndex[todaysInterval] = sub(interestRates.length, 1); }\r\n    }\r\n\r\n    // record a new intrest rate change\r\n    function recordInterestRate(uint256 rate) internal {\r\n        // min number precision for rate.. might need to add a max here.\r\n        assert(rate >= RAY);\r\n\r\n        // todays current interval id\r\n        uint256 todaysInterval = intervalNumber(block.timestamp);\r\n\r\n        // last balance index\r\n        uint256 latestRateIndex = interestRates.length > 0\r\n            ? sub(interestRates.length, 1) : 0;\r\n\r\n        // always update todays interval\r\n        // record balance record (if latest record is for today, add to it, otherwise add a record)\r\n        if (interestRates.length > 0\r\n            && interestRates[latestRateIndex].interval == todaysInterval) {\r\n            interestRates[latestRateIndex].rate = rate;\r\n        } else {\r\n            interestRates.push(InterestRate({\r\n                interval: todaysInterval,\r\n                rate: rate\r\n            }));\r\n        }\r\n\r\n        // map the interval to interest index always\r\n        intervalToInterestIndex[todaysInterval] = sub(interestRates.length, 1);\r\n    }\r\n}\r\n\r\n/**\r\n  * @title PausableCompoundInterestERC20\r\n  * @author UnityCoin Team\r\n  * @notice An implimentation of a mintable, pausable, burnable, compound interest based\r\n  *       ERC20 token.\r\n  *\r\n  *       The token has a few *special* properties.\r\n  *         - a special burner account (which can burn tokens in its account)\r\n  *         - a special supply tracking pool account / mechanism\r\n  *         - a special interest pool account which interest payments are drawn from\r\n  *         - you cannot transfer from / to any pool (supply or interest)\r\n  *         - you cannot claim interest on the interest pool account\r\n  *         - by all accounts the interest and supply accounts dont really exist\r\n  *           and are used for internal accounting purposes.\r\n  *\r\n  *       Minting / burning / pausing style is based roughly on DSToken from maker.\r\n  *\r\n  *       Whenever we burn, mint, change rates we update the supply pool,\r\n  *       which intern updates the totalSupply return.\r\n  *\r\n  *       The TotalSupply of this token should be as follows:\r\n  *       total supply = supply issued + total interest accued up to current interval\r\n  *\r\n  *       The special `burner` account can only burn tokens sent to it's account.\r\n  *       You can think of it as a HOT burn account.\r\n  *       The provider can ultimatly burn any account.\r\n  */\r\ncontract PausableCompoundInterestERC20 is Pausable, BurnerAccount, InterestRateBased, ERC20Token {\r\n    // Non EIP20 Standard Constants, Variables and Events\r\n    event Mint(address indexed to, uint256 tokens);\r\n    event Burn(uint256 tokens);\r\n    event InterestRateChange(uint256 intervalDuration, uint256 intervalExpiry, uint256 indexed interestRateIndex);\r\n    event InterestClaimed(address indexed tokenOwner, uint256 amountOwed);\r\n\r\n    // the interest pool account address, that wont be included in total supply\r\n    // hex generated with linux system entropy + dice + keys (private key thrown out)\r\n    address public constant interestPool = address(0xd365131390302b58A61E265744288097Bd53532e);\r\n\r\n    // this is the based supply pool address, which is used to calculate total supply with interest accured\r\n    // hex generated with linux system entropy + dice + keys (private key thrown out)\r\n    address public constant supplyPool = address(0x85c05851ef3175aeFBC74EcA16F174E22b5acF28);\r\n\r\n    // is not a pool account\r\n    modifier isNotPool(address tokenOwner) {\r\n        assert(tokenOwner != supplyPool && tokenOwner != interestPool); _;\r\n    }\r\n\r\n    // total supply with amount owed\r\n    function totalSupply() external view returns (uint256 supplyWithAccruedInterest) {\r\n        (uint256 amountOwed,,) = interestOwed(supplyPool);\r\n\r\n        return add(balanceOf(supplyPool), amountOwed);\r\n    }\r\n\r\n    // Dai/Maker style minting\r\n    function mint(address to, uint256 amount) public isOwner pausable isNotPool(to) {\r\n        // any time the supply pool changes, we need to update it's interest owed\r\n        claimInterestOwed(supplyPool);\r\n\r\n        balances[supplyPool] = add(balances[supplyPool], amount);\r\n        balances[to] = add(balances[to], amount);\r\n\r\n        recordBalance(supplyPool);\r\n        recordBalance(to);\r\n\r\n        emit Mint(to, amount);\r\n    }\r\n\r\n    // the burner can only burn tokens in the burn account\r\n    function burn(address account) external isOwnerOrBurner pausable isNotPool(account) {\r\n        // target burn address\r\n        address target = msg.sender == burner ? burner : account;\r\n\r\n        // any time the supply pool changes, we need to update it's interest owed\r\n        claimInterestOwed(supplyPool);\r\n\r\n        emit Burn(balances[target]);\r\n\r\n        balances[supplyPool] = sub(balances[supplyPool], balances[target]);\r\n        balances[target] = 0;\r\n\r\n        // technially the burner account can claim interest, not that it should matter\r\n        recordBalance(supplyPool);\r\n        recordBalance(target);\r\n    }\r\n\r\n    // change interest rates\r\n    function changeInterestRate(\r\n        uint256 duration,\r\n        uint256 maximum,\r\n        uint256 interestRate,\r\n        uint256 increasePool,\r\n        uint256 decreasePool) public isOwner pausable {\r\n        // claim up supply pool amount\r\n        if (interestRates.length > 0) {\r\n          claimInterestOwed(supplyPool); }\r\n\r\n        // set duration and maximum\r\n        changeDuration(duration);\r\n\r\n        // set interval maximum\r\n        intervalMaximum = maximum;\r\n\r\n        // record interest rate..\r\n        recordInterestRate(interestRate);\r\n\r\n        // set interest pool, no balance needs to be recorded here as this is the interest pool\r\n        balances[interestPool] = sub(add(balances[interestPool], increasePool),\r\n          decreasePool);\r\n    }\r\n\r\n    // hard token set for interest pool\r\n    function setInterestPool(uint256 tokens) external isOwner pausable {\r\n        balances[interestPool] = tokens;\r\n        // no need to record balance as this is the interest pool account..\r\n    }\r\n\r\n    // claim interest owed\r\n    function claimInterestOwed(address tokenOwner) public pausable {\r\n        // cant claim interest on the interest pool\r\n        assert(tokenOwner != interestPool);\r\n\r\n        // calculate interest balances and new record indexes\r\n        (uint256 amountOwed, uint256 balanceIndex, uint256 interval) = interestOwed(tokenOwner);\r\n\r\n        // set last balance index used (it's always one ahead so subtract one)\r\n        lastClaimedBalanceIndex[tokenOwner] = balanceIndex;\r\n\r\n        // set interval offset\r\n        if (balanceRecords[tokenOwner].length > 0) {\r\n          balanceRecords[tokenOwner][balanceIndex].intervalOffset = interval;\r\n        }\r\n\r\n        // increase the balance of the account, reduce interest pool\r\n        if (tokenOwner != supplyPool) {\r\n          balances[interestPool] = sub(balances[interestPool], amountOwed);\r\n        }\r\n\r\n        // set new token owner balance, record balance event\r\n        balances[tokenOwner] = add(balances[tokenOwner], amountOwed);\r\n        recordBalance(tokenOwner);\r\n\r\n        // fire the interest claimed event\r\n        emit InterestClaimed(tokenOwner, amountOwed);\r\n    }\r\n\r\n    function transferFrom(address from, address to, uint256 tokens) public pausable isNotPool(from) isNotPool(to) returns (bool success) {\r\n        super.transferFrom(from, to, tokens);\r\n\r\n        recordBalance(from);\r\n        recordBalance(to);\r\n\r\n        return true;\r\n    }\r\n\r\n    // Allow `spender` to withdraw from your account, multiple times, up to the `tokens` amount.\r\n    // If this function is called again it overwrites the current allowance with _value.\r\n    function approve(address spender, uint256 tokens) public pausable isNotPool(spender) returns (bool success) {\r\n        return super.approve(spender, tokens);\r\n    }\r\n}\r\n\r\n/**\r\n  * @title SignableCompoundInterestERC20\r\n  * @author UnityCoin Team\r\n  * @notice A meta-transaction enabled version of the PausableCompoundInterestERC20\r\n  *       this allows you to do a signed transfer or claim using EIP712 signature format.\r\n  *\r\n  *       We also impliment a constructor here.\r\n  *\r\n  *       A sender can essentially build EIP712 Claim to specific funds, whereby\r\n  *       someone else (the `feeRecipient`) can recieve a pre-specified fee for\r\n  *       sending the transaction on-behalf of the sender.\r\n  *\r\n  *       At anytime the sender can invalide the transfer / claim release hash of\r\n  *       a claim / transfer they have signed.\r\n  *\r\n  *       Written claims also have nonce's to make them unique, and expiries\r\n  *       to remove the change of holding attacks.\r\n  */\r\ncontract SignableCompoundInterestERC20 is PausableCompoundInterestERC20 {\r\n    // EIP712 Hashes and Seporators\r\n    bytes32 constant public EIP712_DOMAIN_TYPEHASH = keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract,bytes32 salt)\");\r\n    bytes32 constant public SIGNEDTRANSFER_TYPEHASH = keccak256(\"SignedTransfer(address to,uint256 tokens,address feeRecipient,uint256 fee,uint256 expiry,bytes32 nonce)\");\r\n    bytes32 constant public SIGNEDINTERESTCLAIM_TYPEHASH = keccak256(\"SignedInterestClaim(address feeRecipient,uint256 fee,uint256 expiry,bytes32 nonce)\");\r\n    bytes32 public DOMAIN_SEPARATOR = keccak256(abi.encode(\r\n        EIP712_DOMAIN_TYPEHASH, // EIP712\r\n        keccak256(\"UnityCoin\"), // app name\r\n        keccak256(\"1\"), // app version\r\n        uint256(1), // chain id\r\n        address(this), // verifying contract\r\n        bytes32(0x111857f4a3edcb7462eabc03bfe733db1e3f6cdc2b7971ee739626c98268ae12) // salt\r\n    ));\r\n\r\n    // address(tokenOwner signer) => bytes32(releaseHash) => bool(was release hash used)\r\n    mapping(address => mapping(bytes32 => bool)) public releaseHashes;\r\n\r\n    event SignedTransfer(address indexed from, address indexed to, uint256 tokens, bytes32 releaseHash);\r\n    event SignedInterestClaim(address indexed from, bytes32 releaseHash);\r\n\r\n    // constructor for the entire token\r\n    constructor(\r\n        address tokenOwner, // main token controller\r\n        address tokenBurner, // burner account\r\n\r\n        uint256 initialSupply, // total supply amount\r\n\r\n        uint256 interestIntervalStartTimestamp, // start time\r\n        uint256 interestIntervalDurationSeconds, // interval duration\r\n        uint256 interestIntervalMaximum, // interest expiry\r\n        uint256 interestPoolSize, // total interest pool size\r\n        uint256 interestRate) public {\r\n        // setup the burner account\r\n        burner = tokenBurner;\r\n\r\n        // setup the interest mechnics\r\n        intervalStartTimestamp = interestIntervalStartTimestamp;\r\n\r\n        // set duration\r\n        intervalDuration = interestIntervalDurationSeconds;\r\n\r\n        // set interest rates\r\n        changeInterestRate(interestIntervalDurationSeconds,\r\n            interestIntervalMaximum,\r\n            interestRate, interestPoolSize, 0);\r\n\r\n        // mint to the token owner the initial supply\r\n        mint(tokenOwner, initialSupply);\r\n\r\n        // set the provider\r\n        owner = tokenOwner;\r\n    }\r\n\r\n    // allow someone else to pay the gas fee for this token, by taking a fee within the token itself.\r\n    function signedTransfer(address to,\r\n        uint256 tokens,\r\n        address feeRecipient,\r\n        uint256 fee,\r\n        uint256 expiry,\r\n        bytes32 nonce,\r\n        uint8 v, bytes32 r, bytes32 s) external returns (bool success) {\r\n        bytes32 releaseHash = keccak256(abi.encodePacked(\r\n           \"\\x19\\x01\",\r\n           DOMAIN_SEPARATOR,\r\n           keccak256(abi.encode(SIGNEDTRANSFER_TYPEHASH, to, tokens, feeRecipient, fee, expiry, nonce))\r\n        ));\r\n        address from = ecrecover(releaseHash, v, r, s);\r\n\r\n        // check expiry, release hash and balances\r\n        assert(block.timestamp < expiry);\r\n        assert(releaseHashes[from][releaseHash] == false);\r\n\r\n        // waste out release hash\r\n        releaseHashes[from][releaseHash] = true;\r\n\r\n        // allow funds to be transfered.\r\n        approvals[from][msg.sender] = add(tokens, fee);\r\n\r\n        // transfer funds\r\n        transferFrom(from, to, tokens);\r\n        transferFrom(from, feeRecipient, fee);\r\n\r\n        emit SignedTransfer(from, to, tokens, releaseHash);\r\n\r\n        return true;\r\n    }\r\n\r\n    // allow someone else to fire the claim interest owed method, and get paid a fee in the token to do so\r\n    function signedInterestClaim(\r\n        address feeRecipient,\r\n        uint256 fee,\r\n        uint256 expiry,\r\n        bytes32 nonce,\r\n        uint8 v, bytes32 r, bytes32 s) external returns (bool success) {\r\n        bytes32 releaseHash = keccak256(abi.encodePacked(\r\n           \"\\x19\\x01\",\r\n           DOMAIN_SEPARATOR,\r\n           keccak256(abi.encode(SIGNEDINTERESTCLAIM_TYPEHASH, feeRecipient, fee, expiry, nonce))\r\n        ));\r\n        address from = ecrecover(releaseHash, v, r, s);\r\n\r\n        // check expiry, release hash and balances\r\n        assert(block.timestamp < expiry);\r\n        assert(releaseHashes[from][releaseHash] == false);\r\n\r\n        // waste out release hash\r\n        releaseHashes[from][releaseHash] = true;\r\n\r\n        // claim interest owed\r\n        claimInterestOwed(from);\r\n\r\n        // allow funds to be transfered.\r\n        approvals[from][msg.sender] = fee;\r\n\r\n        // transfer funds\r\n        transferFrom(from, feeRecipient, fee);\r\n\r\n        emit SignedInterestClaim(from, releaseHash);\r\n\r\n        return true;\r\n    }\r\n\r\n    // this allows a token user to invalidate approved release hashes at anytime..\r\n    function invalidateHash(bytes32 releaseHash) external pausable {\r\n      releaseHashes[msg.sender][releaseHash] = true;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"supplyPool\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"intervalOffset\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"numInterestRates\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"supplyWithAccruedInterest\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"intervalNumber\",\"outputs\":[{\"name\":\"number\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"intervalToInterestIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"lastClaimedBalanceIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"burner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"intervalDuration\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenOwner\",\"type\":\"address\"}],\"name\":\"numBalanceRecords\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"DOMAIN_SEPARATOR\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"releaseHash\",\"type\":\"bytes32\"}],\"name\":\"invalidateHash\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenOwner\",\"type\":\"address\"}],\"name\":\"claimInterestOwed\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"interestPool\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"setInterestPool\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenOwner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"changeBurner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"SIGNEDINTERESTCLAIM_TYPEHASH\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"duration\",\"type\":\"uint256\"},{\"name\":\"maximum\",\"type\":\"uint256\"},{\"name\":\"interestRate\",\"type\":\"uint256\"},{\"name\":\"increasePool\",\"type\":\"uint256\"},{\"name\":\"decreasePool\",\"type\":\"uint256\"}],\"name\":\"changeInterestRate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"burn\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"tokens\",\"type\":\"uint256\"},{\"name\":\"feeRecipient\",\"type\":\"address\"},{\"name\":\"fee\",\"type\":\"uint256\"},{\"name\":\"expiry\",\"type\":\"uint256\"},{\"name\":\"nonce\",\"type\":\"bytes32\"},{\"name\":\"v\",\"type\":\"uint8\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"signedTransfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"intervalStartTimestamp\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"interestRates\",\"outputs\":[{\"name\":\"interval\",\"type\":\"uint256\"},{\"name\":\"rate\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"releaseHashes\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"intervalMaximum\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"latestInterestRate\",\"outputs\":[{\"name\":\"rateAsRay\",\"type\":\"uint256\"},{\"name\":\"asOfInterval\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"EIP712_DOMAIN_TYPEHASH\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"balanceRecords\",\"outputs\":[{\"name\":\"interval\",\"type\":\"uint256\"},{\"name\":\"intervalOffset\",\"type\":\"uint256\"},{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenOwner\",\"type\":\"address\"},{\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"feeRecipient\",\"type\":\"address\"},{\"name\":\"fee\",\"type\":\"uint256\"},{\"name\":\"expiry\",\"type\":\"uint256\"},{\"name\":\"nonce\",\"type\":\"bytes32\"},{\"name\":\"v\",\"type\":\"uint8\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"signedInterestClaim\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"SIGNEDTRANSFER_TYPEHASH\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenOwner\",\"type\":\"address\"}],\"name\":\"interestOwed\",\"outputs\":[{\"name\":\"amountOwed\",\"type\":\"uint256\"},{\"name\":\"balanceIndex\",\"type\":\"uint256\"},{\"name\":\"interval\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"tokenOwner\",\"type\":\"address\"},{\"name\":\"tokenBurner\",\"type\":\"address\"},{\"name\":\"initialSupply\",\"type\":\"uint256\"},{\"name\":\"interestIntervalStartTimestamp\",\"type\":\"uint256\"},{\"name\":\"interestIntervalDurationSeconds\",\"type\":\"uint256\"},{\"name\":\"interestIntervalMaximum\",\"type\":\"uint256\"},{\"name\":\"interestPoolSize\",\"type\":\"uint256\"},{\"name\":\"interestRate\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"releaseHash\",\"type\":\"bytes32\"}],\"name\":\"SignedTransfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"releaseHash\",\"type\":\"bytes32\"}],\"name\":\"SignedInterestClaim\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"Mint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"Burn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"intervalDuration\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"intervalExpiry\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"interestRateIndex\",\"type\":\"uint256\"}],\"name\":\"InterestRateChange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"tokenOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amountOwed\",\"type\":\"uint256\"}],\"name\":\"InterestClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"tokenOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpause\",\"type\":\"event\"}]","ContractName":"SignableCompoundInterestERC20","CompilerVersion":"v0.5.1+commit.c8a2cb62","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000ccd0241db33694fc6007226c43021be4b22dc7790000000000000000000000009dce8d0d56a73c39f53edfedfd8301e9a1eddd6a0000000000000000000000000000000000000000033b2e3c9fd0803ce8000000000000000000000000000000000000000000000000000000000000005ce482f000000000000000000000000000000000000000000000000000000000000151800000000000000000000000000000000000000000000000000000000000000447000000000000000000000000000000000000000000108b2a2c280290940000000000000000000000000000000000000000000000033b39b9ce982fe6f5121c00","Library":"","SwarmSource":"bzzr://d6f256991a7369e0b953cbb88af1c3b3ff8451c5be9ffaaefef14a9d2cbe377b"}]}