{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.0;\r\n\r\ncontract Test {\r\n    \r\n    uint8 constant N = 16;\r\n    \r\n    struct Bet {\r\n        uint256 blockNumber;\r\n        uint256 amount;\r\n        bytes16 bet;\r\n        uint128 id;\r\n        address payable gambler;\r\n    }\r\n    \r\n    struct Payout {\r\n        uint256 amount;\r\n        bytes32 blockHash;\r\n        uint128 id;\r\n        address payable gambler;\r\n    }\r\n    \r\n    Bet[] betArray;\r\n    \r\n    address payable private owner;\r\n\r\n    event Result (\r\n        uint256 amount,\r\n        bytes32 blockHash,\r\n        uint128 indexed id,\r\n        address payable indexed gambler\r\n    );\r\n    \r\n    uint256 constant MIN_BET = 0.01 ether;\r\n    uint256 constant MAX_BET = 100 ether;\r\n    uint256 constant PRECISION = 1 ether;\r\n    \r\n    constructor() public payable {\r\n        owner = msg.sender;\r\n    }\r\n    \r\n    function() external payable { }\r\n    \r\n    modifier onlyOwner {\r\n         require(msg.sender == owner);\r\n         _;\r\n     }\r\n    \r\n    function placeBet(bytes16 bet, uint128 id) external payable {\r\n        require(msg.value >= MIN_BET, \"Bet amount should be greater or equal than minimal amount\");\r\n        require(msg.value <= MAX_BET, \"Bet amount should be lesser or equal than maximal amount\");\r\n        require(id != 0, \"Id should not be 0\");\r\n        \r\n        betArray.push(Bet(block.number, msg.value, bet, id, msg.sender));\r\n    }\r\n    \r\n    function settleBets() external {\r\n        if (betArray.length == 0)\r\n            return;\r\n\r\n        Payout[] memory payouts = new Payout[](betArray.length);\r\n        Bet[] memory missedBets = new Bet[](betArray.length);\r\n        uint256 totalPayout;\r\n        uint i = betArray.length;\r\n        do {\r\n            i--;\r\n            if(betArray[i].blockNumber >= block.number)\r\n                missedBets[i] = betArray[i];\r\n            else {\r\n                bytes32 blockHash = blockhash(betArray[i].blockNumber);\r\n                uint256 coefficient = PRECISION;\r\n                uint8 markedCount;\r\n                uint8 matchesCount;\r\n                uint256 divider = 1;\r\n                for (uint8 j = 0; j < N; j++) {\r\n                    if (betArray[i].bet[j] == 0xFF)\r\n                        continue;\r\n                    markedCount++;\r\n                    byte field;\r\n                    if (j % 2 == 0)\r\n                        field = blockHash[24 + j / 2] >> 4;\r\n                    else\r\n                        field = blockHash[24 + j / 2] & 0x0F;\r\n                    if (betArray[i].bet[j] < 0x10) {\r\n                        if (field == betArray[i].bet[j])\r\n                            matchesCount++;\r\n                        else\r\n                            divider *= 15 + N;\r\n                        continue;\r\n                    }\r\n                    if (betArray[i].bet[j] == 0x10) {\r\n                        if (field > 0x09 && field < 0x10) {\r\n                            matchesCount++;\r\n                            divider *= 6;\r\n                        } else\r\n                            divider *= 10 + N;\r\n                        continue;\r\n                    }\r\n                    if (betArray[i].bet[j] == 0x11) {\r\n                        if (field < 0x0A) {\r\n                            matchesCount++;\r\n                            divider *= 10;\r\n                        } else\r\n                            divider *= 6 + N;\r\n                        continue;\r\n                    }\r\n                    if (betArray[i].bet[j] == 0x12) {\r\n                        if (field < 0x0A && field & 0x01 == 0x01) {\r\n                            matchesCount++;\r\n                            divider *= 5;\r\n                        } else\r\n                            divider *= 11 + N;\r\n                        continue;\r\n                    }\r\n                    if (betArray[i].bet[j] == 0x13) {\r\n                        if (field < 0x0A && field & 0x01 == 0x0) {\r\n                            matchesCount++;\r\n                            divider *= 5;\r\n                        } else\r\n                            divider *= 11 + N;\r\n                        continue;\r\n                    }\r\n                }\r\n            \r\n                if (matchesCount == 0)\r\n                    coefficient = 0;\r\n                else {\r\n                    uint256 missedCount = markedCount - matchesCount;\r\n                    divider *= missedCount ** missedCount;\r\n                    coefficient = coefficient * 16**uint256(markedCount) / divider;\r\n                }\r\n                \r\n                uint payoutAmount = betArray[i].amount * coefficient / PRECISION;\r\n                if (payoutAmount == 0 && matchesCount > 0)\r\n                    payoutAmount = matchesCount;\r\n                payouts[i] = Payout(payoutAmount, blockHash, betArray[i].id, betArray[i].gambler);\r\n                totalPayout += payoutAmount;\r\n            }\r\n            betArray.pop();\r\n        } while (i > 0);\r\n        \r\n        i = missedBets.length;\r\n        do {\r\n            i--;\r\n            if (missedBets[i].id != 0)\r\n                betArray.push(missedBets[i]);\r\n        } while (i > 0);\r\n        \r\n        uint balance = address(this).balance;\r\n        for (i = 0; i < payouts.length; i++) {\r\n            if (payouts[i].id > 0) {\r\n                if (totalPayout > balance)\r\n                    emit Result(balance * payouts[i].amount * PRECISION / totalPayout / PRECISION, payouts[i].blockHash, payouts[i].id, payouts[i].gambler);\r\n                else\r\n                    emit Result(payouts[i].amount, payouts[i].blockHash, payouts[i].id, payouts[i].gambler);\r\n            }\r\n        }\r\n        for (i = 0; i < payouts.length; i++) {\r\n            if (payouts[i].amount > 0) {\r\n                if (totalPayout > balance)\r\n                    payouts[i].gambler.transfer(balance * payouts[i].amount * PRECISION / totalPayout / PRECISION);\r\n                else\r\n                    payouts[i].gambler.transfer(payouts[i].amount);\r\n            }\r\n        }\r\n    }\r\n    \r\n    function withdraw() external onlyOwner {\r\n        owner.transfer(address(this).balance);\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"bet\",\"type\":\"bytes16\"},{\"name\":\"id\",\"type\":\"uint128\"}],\"name\":\"placeBet\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"settleBets\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"blockHash\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"id\",\"type\":\"uint128\"},{\"indexed\":true,\"name\":\"gambler\",\"type\":\"address\"}],\"name\":\"Result\",\"type\":\"event\"}]","ContractName":"Test","CompilerVersion":"v0.5.1+commit.c8a2cb62","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://968db9419b02c571c82a28f093ee26e90d4785f094bd5b4b6a2ee7598463a30b"}]}