{"status":"1","message":"OK","result":[{"SourceCode":"// File: openzeppelin-solidity/contracts/math/SafeMath.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\r\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (_a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    c = _a * _b;\r\n    assert(c / _a == _b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    // assert(_b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = _a / _b;\r\n    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\r\n    return _a / _b;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    assert(_b <= _a);\r\n    return _a - _b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\r\n    c = _a + _b;\r\n    assert(c >= _a);\r\n    return c;\r\n  }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipRenounced(address indexed previousOwner);\r\n  event OwnershipTransferred(\r\n    address indexed previousOwner,\r\n    address indexed newOwner\r\n  );\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  constructor() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to relinquish control of the contract.\r\n   * @notice Renouncing to ownership will leave the contract without an owner.\r\n   * It will not be possible to call the functions with the `onlyOwner`\r\n   * modifier anymore.\r\n   */\r\n  function renounceOwnership() public onlyOwner {\r\n    emit OwnershipRenounced(owner);\r\n    owner = address(0);\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address _newOwner) public onlyOwner {\r\n    _transferOwnership(_newOwner);\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function _transferOwnership(address _newOwner) internal {\r\n    require(_newOwner != address(0));\r\n    emit OwnershipTransferred(owner, _newOwner);\r\n    owner = _newOwner;\r\n  }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/ownership/Claimable.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\n\r\n/**\r\n * @title Claimable\r\n * @dev Extension for the Ownable contract, where the ownership needs to be claimed.\r\n * This allows the new owner to accept the transfer.\r\n */\r\ncontract Claimable is Ownable {\r\n  address public pendingOwner;\r\n\r\n  /**\r\n   * @dev Modifier throws if called by any account other than the pendingOwner.\r\n   */\r\n  modifier onlyPendingOwner() {\r\n    require(msg.sender == pendingOwner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to set the pendingOwner address.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    pendingOwner = newOwner;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the pendingOwner address to finalize the transfer.\r\n   */\r\n  function claimOwnership() public onlyPendingOwner {\r\n    emit OwnershipTransferred(owner, pendingOwner);\r\n    owner = pendingOwner;\r\n    pendingOwner = address(0);\r\n  }\r\n}\r\n\r\n// File: contracts/Broker.sol\r\n\r\npragma solidity 0.4.25;\r\n\r\n\r\n\r\n/// @title The Broker + Vault contract for Switcheo Exchange\r\n/// @author Switcheo Network\r\n/// @notice This contract faciliates Ethereum and ERC-20 trades\r\n/// between users. Users can trade with each other by making\r\n/// and taking offers without giving up custody of their tokens.\r\n/// Users should first deposit tokens, then communicate off-chain\r\n/// with the exchange coordinator, in order to place orders\r\n/// (make / take offers). This allows trades to be confirmed\r\n/// immediately by the coordinator, and settled on-chain through\r\n/// this contract at a later time.\r\ncontract Broker is Claimable {\r\n    using SafeMath for uint256;\r\n\r\n    struct Offer {\r\n        address maker;\r\n        address offerAsset;\r\n        address wantAsset;\r\n        uint64 nonce;\r\n        uint256 offerAmount;\r\n        uint256 wantAmount;\r\n        uint256 availableAmount; // the remaining offer amount\r\n    }\r\n\r\n    struct AnnouncedWithdrawal {\r\n        uint256 amount;\r\n        uint256 canWithdrawAt;\r\n    }\r\n\r\n    // Exchange states\r\n    enum State { Active, Inactive }\r\n    State public state;\r\n\r\n    // The maximum announce delay in seconds\r\n    // (7 days * 24 hours * 60 mins * 60 seconds)\r\n    uint32 constant maxAnnounceDelay = 604800;\r\n    // Ether token \"address\" is set as the constant 0x00\r\n    address constant etherAddr = address(0);\r\n\r\n    // deposits\r\n    uint8 constant ReasonDeposit = 0x01;\r\n    // making an offer\r\n    uint8 constant ReasonMakerGive = 0x02;\r\n    uint8 constant ReasonMakerFeeGive = 0x10;\r\n    uint8 constant ReasonMakerFeeReceive = 0x11;\r\n    // filling an offer\r\n    uint8 constant ReasonFillerGive = 0x03;\r\n    uint8 constant ReasonFillerFeeGive = 0x04;\r\n    uint8 constant ReasonFillerReceive = 0x05;\r\n    uint8 constant ReasonMakerReceive = 0x06;\r\n    uint8 constant ReasonFillerFeeReceive = 0x07;\r\n    // cancelling an offer\r\n    uint8 constant ReasonCancel = 0x08;\r\n    uint8 constant ReasonCancelFeeGive = 0x12;\r\n    uint8 constant ReasonCancelFeeReceive = 0x13;\r\n    // withdrawals\r\n    uint8 constant ReasonWithdraw = 0x09;\r\n    uint8 constant ReasonWithdrawFeeGive = 0x14;\r\n    uint8 constant ReasonWithdrawFeeReceive = 0x15;\r\n\r\n    // The coordinator sends trades (balance transitions) to the exchange\r\n    address public coordinator;\r\n    // The operator receives fees\r\n    address public operator;\r\n    // The time required to wait after a cancellation is announced\r\n    // to let the operator detect it in non-byzantine conditions\r\n    uint32 public cancelAnnounceDelay;\r\n    // The time required to wait after a withdrawal is announced\r\n    // to let the operator detect it in non-byzantine conditions\r\n    uint32 public withdrawAnnounceDelay;\r\n\r\n    // User balances by: userAddress => assetHash => balance\r\n    mapping(address => mapping(address => uint256)) public balances;\r\n    // Offers by the creation transaction hash: transactionHash => offer\r\n    mapping(bytes32 => Offer) public offers;\r\n    // A record of which hashes have been used before\r\n    mapping(bytes32 => bool) public usedHashes;\r\n    // Set of whitelisted spender addresses allowed by the owner\r\n    mapping(address => bool) public whitelistedSpenders;\r\n    // Spenders which have been approved by individual user as: userAddress => spenderAddress => true\r\n    mapping(address => mapping(address => bool)) public approvedSpenders;\r\n    // Announced withdrawals by: userAddress => assetHash => data\r\n    mapping(address => mapping(address => AnnouncedWithdrawal)) public announcedWithdrawals;\r\n    // Announced cancellations by: offerHash => data\r\n    mapping(bytes32 => uint256) public announcedCancellations;\r\n\r\n    // Emitted when new offers made\r\n    event Make(address indexed maker, bytes32 indexed offerHash);\r\n    // Emitted when offers are filled\r\n    event Fill(address indexed filler, bytes32 indexed offerHash, uint256 amountFilled, uint256 amountTaken, address indexed maker);\r\n    // Emitted when offers are cancelled\r\n    event Cancel(address indexed maker, bytes32 indexed offerHash);\r\n    // Emitted on any balance state transition (+ve)\r\n    event BalanceIncrease(address indexed user, address indexed token, uint256 amount, uint8 indexed reason);\r\n    // Emitted on any balance state transition (-ve)\r\n    event BalanceDecrease(address indexed user, address indexed token, uint256 amount, uint8 indexed reason);\r\n    // Emitted when a withdrawal is annnounced\r\n    event WithdrawAnnounce(address indexed user, address indexed token, uint256 amount, uint256 canWithdrawAt);\r\n    // Emitted when a cancellation is annnounced\r\n    event CancelAnnounce(address indexed user, bytes32 indexed offerHash, uint256 canCancelAt);\r\n    // Emitted when a user approved a spender\r\n    event SpenderApprove(address indexed user, address indexed spender);\r\n    // Emitted when a user rescinds approval for a spender\r\n    event SpenderRescind(address indexed user, address indexed spender);\r\n\r\n    /// @notice Initializes the Broker contract\r\n    /// @dev The coordinator and operator is initialized\r\n    /// to be the address of the sender. The Broker is immediately\r\n    /// put into an active state, with maximum exit delays set.\r\n    constructor()\r\n        public\r\n    {\r\n        coordinator = msg.sender;\r\n        operator = msg.sender;\r\n        cancelAnnounceDelay = maxAnnounceDelay;\r\n        withdrawAnnounceDelay = maxAnnounceDelay;\r\n        state = State.Active;\r\n    }\r\n\r\n    modifier onlyCoordinator() {\r\n        require(\r\n            msg.sender == coordinator,\r\n            \"Invalid sender\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier onlyActiveState() {\r\n        require(\r\n            state == State.Active,\r\n            \"Invalid state\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier onlyInactiveState() {\r\n        require(\r\n            state == State.Inactive,\r\n            \"Invalid state\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier notMoreThanMaxDelay(uint32 _delay) {\r\n        require(\r\n            _delay <= maxAnnounceDelay,\r\n            \"Invalid delay\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier unusedReasonCode(uint8 _reasonCode) {\r\n        require(\r\n            _reasonCode > ReasonWithdrawFeeReceive,\r\n            \"Invalid reason code\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    /// @notice Sets the Broker contract state\r\n    /// @dev There are only two states - Active & Inactive.\r\n    ///\r\n    /// The Active state is the normal operating state for the contract -\r\n    /// deposits, trading and withdrawals can be carried out.\r\n    ///\r\n    /// In the Inactive state, the coordinator can invoke additional\r\n    /// emergency methods such as emergencyCancel and emergencyWithdraw,\r\n    /// without the cooperation of users. However, deposits and trading\r\n    /// methods cannot be invoked at that time. This state is meant\r\n    /// primarily to terminate and upgrade the contract, or to be used\r\n    /// in the event that the contract is considered no longer viable\r\n    /// to continue operation, and held tokens should be immediately\r\n    /// withdrawn to their respective owners.\r\n    /// @param _state The state to transition the contract into\r\n    function setState(State _state) external onlyOwner { state = _state; }\r\n\r\n    /// @notice Sets the coordinator address.\r\n    /// @dev All standard operations (except `depositEther`)\r\n    /// must be invoked by the coordinator.\r\n    /// @param _coordinator The address to set as the coordinator\r\n    function setCoordinator(address _coordinator) external onlyOwner {\r\n        _validateAddress(_coordinator);\r\n        coordinator = _coordinator;\r\n    }\r\n\r\n    /// @notice Sets the operator address.\r\n    /// @dev All fees are paid to the operator.\r\n    /// @param _operator The address to set as the operator\r\n    function setOperator(address _operator) external onlyOwner {\r\n        _validateAddress(operator);\r\n        operator = _operator;\r\n    }\r\n\r\n    /// @notice Sets the delay between when a cancel\r\n    /// intention must be announced, and when the cancellation\r\n    /// can actually be executed on-chain\r\n    /// @dev This delay exists so that the coordinator has time to\r\n    /// respond when a user is attempting to bypass it and cancel\r\n    /// offers directly on-chain.\r\n    /// Note that this is an direct on-chain cancellation\r\n    /// is an atypical operation - see `slowCancel`\r\n    /// for more details.\r\n    /// @param _delay The delay in seconds\r\n    function setCancelAnnounceDelay(uint32 _delay)\r\n        external\r\n        onlyOwner\r\n        notMoreThanMaxDelay(_delay)\r\n    {\r\n        cancelAnnounceDelay = _delay;\r\n    }\r\n\r\n    /// @notice Sets the delay (in seconds) between when a withdrawal\r\n    /// intention must be announced, and when the withdrawal\r\n    /// can actually be executed on-chain.\r\n    /// @dev This delay exists so that the coordinator has time to\r\n    /// respond when a user is attempting to bypass it and cancel\r\n    /// offers directly on-chain. See `announceWithdraw` and\r\n    /// `slowWithdraw` for more details.\r\n    /// @param _delay The delay in seconds\r\n    function setWithdrawAnnounceDelay(uint32 _delay)\r\n        external\r\n        onlyOwner\r\n        notMoreThanMaxDelay(_delay)\r\n    {\r\n        withdrawAnnounceDelay = _delay;\r\n    }\r\n\r\n    /// @notice Adds an address to the set of allowed spenders.\r\n    /// @dev Spenders are meant to be additional EVM contracts that\r\n    /// will allow adding or upgrading of trading functionality, without\r\n    /// having to cancel all offers and withdraw all tokens for all users.\r\n    /// This whitelist ensures that all approved spenders are contracts\r\n    /// that have been verified by the owner. Note that each user also\r\n    /// has to invoke `approveSpender` to actually allow the `_spender`\r\n    /// to spend his/her balance, so that they can examine / verify\r\n    /// the new spender contract first.\r\n    /// @param _spender The address to add as a whitelisted spender\r\n    function addSpender(address _spender)\r\n        external\r\n        onlyOwner\r\n    {\r\n        _validateAddress(_spender);\r\n        whitelistedSpenders[_spender] = true;\r\n    }\r\n\r\n    /// @notice Removes an address from the set of allowed spenders.\r\n    /// @dev Note that removing a spender from the whitelist will not\r\n    /// prevent already approved spenders from spending a user's balance.\r\n    /// This is to ensure that the spender contracts can be certain that once\r\n    /// an approval is done, the owner cannot rescient spending priviledges,\r\n    /// and cause tokens to be withheld or locked in the spender contract.\r\n    /// Users must instead manually rescind approvals using `rescindApproval`\r\n    /// after the `_spender` has been removed from the whitelist.\r\n    /// @param _spender The address to remove as a whitelisted spender\r\n    function removeSpender(address _spender)\r\n        external\r\n        onlyOwner\r\n    {\r\n        _validateAddress(_spender);\r\n        delete whitelistedSpenders[_spender];\r\n    }\r\n\r\n    /// @notice Deposits Ethereum tokens under the `msg.sender`'s balance\r\n    /// @dev Allows sending ETH to the contract, and increasing\r\n    /// the user's contract balance by the amount sent in.\r\n    /// This operation is only usable in an Active state to prevent\r\n    /// a terminated contract from receiving tokens.\r\n    function depositEther()\r\n        external\r\n        payable\r\n        onlyActiveState\r\n    {\r\n        require(\r\n            msg.value > 0,\r\n            'Invalid value'\r\n        );\r\n        balances[msg.sender][etherAddr] = balances[msg.sender][etherAddr].add(msg.value);\r\n        emit BalanceIncrease(msg.sender, etherAddr, msg.value, ReasonDeposit);\r\n    }\r\n\r\n    /// @notice Deposits ERC20 tokens under the `_user`'s balance\r\n    /// @dev Allows sending ERC20 tokens to the contract, and increasing\r\n    /// the user's contract balance by the amount sent in. This operation\r\n    /// can only be used after an ERC20 `approve` operation for a\r\n    /// sufficient amount has been carried out.\r\n    ///\r\n    /// Note that this operation does not require user signatures as\r\n    /// a valid ERC20 `approve` call is considered as intent to deposit\r\n    /// the tokens. This is as there is no other ERC20 methods that this\r\n    /// contract can call.\r\n    ///\r\n    /// This operation can only be called by the coordinator,\r\n    /// and should be autoamtically done so whenever an `approve` event\r\n    /// from a ERC20 token (that the coordinator deems valid)\r\n    /// approving this contract to spend tokens on behalf of a user is seen.\r\n    ///\r\n    /// This operation is only usable in an Active state to prevent\r\n    /// a terminated contract from receiving tokens.\r\n    /// @param _user The address of the user that is depositing tokens\r\n    /// @param _token The address of the ERC20 token to deposit\r\n    /// @param _amount The (approved) amount to deposit\r\n    function depositERC20(\r\n        address _user,\r\n        address _token,\r\n        uint256 _amount\r\n    )\r\n        external\r\n        onlyCoordinator\r\n        onlyActiveState\r\n    {\r\n        require(\r\n            _amount > 0,\r\n            'Invalid value'\r\n        );\r\n        balances[_user][_token] = balances[_user][_token].add(_amount);\r\n\r\n        _validateIsContract(_token);\r\n        require(\r\n            _token.call(\r\n                bytes4(keccak256(\"transferFrom(address,address,uint256)\")),\r\n                _user,\r\n                address(this),\r\n                _amount\r\n            ),\r\n            \"transferFrom call failed\"\r\n        );\r\n        require(\r\n            _getSanitizedReturnValue(),\r\n            \"transferFrom failed.\"\r\n        );\r\n\r\n        emit BalanceIncrease(_user, _token, _amount, ReasonDeposit);\r\n    }\r\n\r\n    /// @notice Withdraws `_amount` worth of `_token`s to the `_withdrawer`\r\n    /// @dev This is the standard withdraw operation. Tokens can only be\r\n    /// withdrawn directly to the token balance owner's address.\r\n    /// Fees can be paid to cover network costs, as the operation must\r\n    /// be invoked by the coordinator. The hash of all parameters, prefixed\r\n    /// with the operation name \"withdraw\" must be signed by the withdrawer\r\n    /// to validate the withdrawal request. A nonce that is issued by the\r\n    /// coordinator is used to prevent replay attacks.\r\n    /// See `slowWithdraw` for withdrawing without requiring the coordinator's\r\n    /// involvement.\r\n    /// @param _withdrawer The address of the user that is withdrawing tokens\r\n    /// @param _token The address of the token to withdraw\r\n    /// @param _amount The number of tokens to withdraw\r\n    /// @param _feeAsset The address of the token to use for fee payment\r\n    /// @param _feeAmount The amount of tokens to pay as fees to the operator\r\n    /// @param _nonce The nonce to prevent replay attacks\r\n    /// @param _v The `v` component of the `_withdrawer`'s signature\r\n    /// @param _r The `r` component of the `_withdrawer`'s signature\r\n    /// @param _s The `s` component of the `_withdrawer`'s signature\r\n    function withdraw(\r\n        address _withdrawer,\r\n        address _token,\r\n        uint256 _amount,\r\n        address _feeAsset,\r\n        uint256 _feeAmount,\r\n        uint64 _nonce,\r\n        uint8 _v,\r\n        bytes32 _r,\r\n        bytes32 _s\r\n    )\r\n        external\r\n        onlyCoordinator\r\n    {\r\n        bytes32 msgHash = keccak256(abi.encodePacked(\r\n            \"withdraw\",\r\n            _withdrawer,\r\n            _token,\r\n            _amount,\r\n            _feeAsset,\r\n            _feeAmount,\r\n            _nonce\r\n        ));\r\n\r\n        require(\r\n            _recoverAddress(msgHash, _v, _r, _s) == _withdrawer,\r\n            \"Invalid signature\"\r\n        );\r\n\r\n        _validateAndAddHash(msgHash);\r\n\r\n        _withdraw(_withdrawer, _token, _amount, _feeAsset, _feeAmount);\r\n    }\r\n\r\n    /// @notice Announces intent to withdraw tokens using `slowWithdraw`\r\n    /// @dev Allows a user to invoke `slowWithdraw` after a minimum of\r\n    /// `withdrawAnnounceDelay` seconds has passed.\r\n    /// This announcement and delay is necessary so that the operator has time\r\n    /// to respond if a user attempts to invoke a `slowWithdraw` even though\r\n    /// the exchange is operating normally. In that case, the coordinator would respond\r\n    /// by not allowing the announced amount of tokens to be used in future trades\r\n    /// the moment a `WithdrawAnnounce` is seen.\r\n    /// @param _token The address of the token to withdraw after the required exit delay\r\n    /// @param _amount The number of tokens to withdraw after the required exit delay\r\n    function announceWithdraw(\r\n        address _token,\r\n        uint256 _amount\r\n    )\r\n        external\r\n    {\r\n        require(\r\n            _amount <= balances[msg.sender][_token],\r\n            \"Amount too high\"\r\n        );\r\n\r\n        AnnouncedWithdrawal storage announcement = announcedWithdrawals[msg.sender][_token];\r\n        uint256 canWithdrawAt = now + withdrawAnnounceDelay;\r\n\r\n        announcement.canWithdrawAt = canWithdrawAt;\r\n        announcement.amount = _amount;\r\n\r\n        emit WithdrawAnnounce(msg.sender, _token, _amount, canWithdrawAt);\r\n    }\r\n\r\n    /// @notice Withdraw tokens without requiring the coordinator\r\n    /// @dev This operation is meant to be used if the operator becomes \"byzantine\",\r\n    /// so that users can still exit tokens locked in this contract.\r\n    /// The `announceWithdraw` operation has to be invoked first, and a minimum time of\r\n    /// `withdrawAnnounceDelay` seconds have to pass, before this operation can be carried out.\r\n    /// Note that this direct on-chain withdrawal is an atypical operation, and\r\n    /// the normal `withdraw` operation should be used in non-byzantine states.\r\n    /// @param _withdrawer The address of the user that is withdrawing tokens\r\n    /// @param _token The address of the token to withdraw\r\n    /// @param _amount The number of tokens to withdraw\r\n    function slowWithdraw(\r\n        address _withdrawer,\r\n        address _token,\r\n        uint256 _amount\r\n    )\r\n        external\r\n    {\r\n        AnnouncedWithdrawal memory announcement = announcedWithdrawals[_withdrawer][_token];\r\n\r\n        require(\r\n            announcement.canWithdrawAt != 0 && announcement.canWithdrawAt <= now,\r\n            \"Insufficient delay\"\r\n        );\r\n\r\n        require(\r\n            announcement.amount == _amount,\r\n            \"Invalid amount\"\r\n        );\r\n\r\n        delete announcedWithdrawals[_withdrawer][_token];\r\n\r\n        _withdraw(_withdrawer, _token, _amount, etherAddr, 0);\r\n    }\r\n\r\n    /// @notice Withdraws tokens to the owner without requiring the owner's signature\r\n    /// @dev Can only be invoked in an Inactive state by the coordinator.\r\n    /// This operation is meant to be used in emergencies only.\r\n    /// @param _withdrawer The address of the user that should have tokens withdrawn\r\n    /// @param _token The address of the token to withdraw\r\n    /// @param _amount The number of tokens to withdraw\r\n    function emergencyWithdraw(\r\n        address _withdrawer,\r\n        address _token,\r\n        uint256 _amount\r\n    )\r\n        external\r\n        onlyCoordinator\r\n        onlyInactiveState\r\n    {\r\n        _withdraw(_withdrawer, _token, _amount, etherAddr, 0);\r\n    }\r\n\r\n    /// @notice Makes an offer which can be filled by other users.\r\n    /// @dev Makes an offer for `_offerAmount` of `offerAsset` tokens\r\n    /// for `wantAmount` of `wantAsset` tokens, that can be filled later\r\n    /// by one or more counterparties using `fillOffer` or `fillOffers`.\r\n    /// The offer can be later cancelled using `cancel` or `slowCancel` as long\r\n    /// as it has not completely been filled.\r\n    /// A fee of `_feeAmount` of `_feeAsset` tokens can be paid to the operator\r\n    /// to cover orderbook maintenance and network costs.\r\n    /// The hash of all parameters, prefixed with the operation name \"makeOffer\"\r\n    /// must be signed by the `_maker` to validate the offer request.\r\n    /// A nonce that is issued by the coordinator is used to prevent replay attacks.\r\n    /// This operation can only be invoked by the coordinator in an Active state.\r\n    /// @param _maker The address of the user that is making the offer\r\n    /// @param _offerAsset The address of the token being offered\r\n    /// @param _wantAsset The address of the token asked in return\r\n    /// @param _offerAmount The number of tokens being offered\r\n    /// @param _wantAmount The number of tokens asked for in return\r\n    /// @param _feeAsset The address of the token to use for fee payment\r\n    /// @param _feeAmount The amount of tokens to pay as fees to the operator\r\n    /// @param _nonce The nonce to prevent replay attacks\r\n    /// @param _v The `v` component of the `_maker`'s signature\r\n    /// @param _r The `r` component of the `_maker`'s signature\r\n    /// @param _s The `s` component of the `_maker`'s signature\r\n    function makeOffer(\r\n        address _maker,\r\n        address _offerAsset,\r\n        address _wantAsset,\r\n        uint256 _offerAmount,\r\n        uint256 _wantAmount,\r\n        address _feeAsset,\r\n        uint256 _feeAmount,\r\n        uint64 _nonce,\r\n        uint8 _v,\r\n        bytes32 _r,\r\n        bytes32 _s\r\n    )\r\n        external\r\n        onlyCoordinator\r\n        onlyActiveState\r\n    {\r\n        require(\r\n            _offerAmount > 0 && _wantAmount > 0,\r\n            \"Invalid amounts\"\r\n        );\r\n\r\n        require(\r\n            _offerAsset != _wantAsset,\r\n            \"Invalid assets\"\r\n        );\r\n\r\n        bytes32 offerHash = keccak256(abi.encodePacked(\r\n            \"makeOffer\",\r\n            _maker,\r\n            _offerAsset,\r\n            _wantAsset,\r\n            _offerAmount,\r\n            _wantAmount,\r\n            _feeAsset,\r\n            _feeAmount,\r\n            _nonce\r\n        ));\r\n\r\n        require(\r\n            _recoverAddress(offerHash, _v, _r, _s) == _maker,\r\n            \"Invalid signature\"\r\n        );\r\n\r\n        _validateAndAddHash(offerHash);\r\n\r\n        // Reduce maker's balance\r\n        _decreaseBalanceAndPayFees(\r\n            _maker,\r\n            _offerAsset,\r\n            _offerAmount,\r\n            _feeAsset,\r\n            _feeAmount,\r\n            ReasonMakerGive,\r\n            ReasonMakerFeeGive,\r\n            ReasonMakerFeeReceive\r\n        );\r\n\r\n        // Store the offer\r\n        Offer storage offer = offers[offerHash];\r\n        offer.maker = _maker;\r\n        offer.offerAsset = _offerAsset;\r\n        offer.wantAsset = _wantAsset;\r\n        offer.offerAmount = _offerAmount;\r\n        offer.wantAmount = _wantAmount;\r\n        offer.availableAmount = _offerAmount;\r\n        offer.nonce = _nonce;\r\n\r\n        emit Make(_maker, offerHash);\r\n    }\r\n\r\n    /// @notice Fills a offer that has been previously made using `makeOffer`.\r\n    /// @dev Fill an offer with `_offerHash` by giving `_amountToTake` of\r\n    /// the offers' `wantAsset` tokens.\r\n    /// A fee of `_feeAmount` of `_feeAsset` tokens can be paid to the operator\r\n    /// to cover orderbook maintenance and network costs.\r\n    /// The hash of all parameters, prefixed with the operation name \"fillOffer\"\r\n    /// must be signed by the `_filler` to validate the fill request.\r\n    /// A nonce that is issued by the coordinator is used to prevent replay attacks.\r\n    /// This operation can only be invoked by the coordinator in an Active state.\r\n    /// @param _filler The address of the user that is filling the offer\r\n    /// @param _offerHash The hash of the offer to fill\r\n    /// @param _amountToTake The number of tokens to take from the offer\r\n    /// @param _feeAsset The address of the token to use for fee payment\r\n    /// @param _feeAmount The amount of tokens to pay as fees to the operator\r\n    /// @param _nonce The nonce to prevent replay attacks\r\n    /// @param _v The `v` component of the `_filler`'s signature\r\n    /// @param _r The `r` component of the `_filler`'s signature\r\n    /// @param _s The `s` component of the `_filler`'s signature\r\n    function fillOffer(\r\n        address _filler,\r\n        bytes32 _offerHash,\r\n        uint256 _amountToTake,\r\n        address _feeAsset,\r\n        uint256 _feeAmount,\r\n        uint64 _nonce,\r\n        uint8 _v,\r\n        bytes32 _r,\r\n        bytes32 _s\r\n    )\r\n        external\r\n        onlyCoordinator\r\n        onlyActiveState\r\n    {\r\n        bytes32 msgHash = keccak256(\r\n            abi.encodePacked(\r\n                \"fillOffer\",\r\n                _filler,\r\n                _offerHash,\r\n                _amountToTake,\r\n                _feeAsset,\r\n                _feeAmount,\r\n                _nonce\r\n            )\r\n        );\r\n\r\n        require(\r\n            _recoverAddress(msgHash, _v, _r, _s) == _filler,\r\n            \"Invalid signature\"\r\n        );\r\n\r\n        _validateAndAddHash(msgHash);\r\n\r\n        _fill(_filler, _offerHash, _amountToTake, _feeAsset, _feeAmount);\r\n    }\r\n\r\n    /// @notice Fills multiple offers that have been previously made using `makeOffer`.\r\n    /// @dev Fills multiple offers with hashes in `_offerHashes` for amounts in\r\n    /// `_amountsToTake`. This method allows conserving of the base gas cost.\r\n    /// A fee of `_feeAmount` of `_feeAsset`  tokens can be paid to the operator\r\n    /// to cover orderbook maintenance and network costs.\r\n    /// The hash of all parameters, prefixed with the operation name \"fillOffers\"\r\n    /// must be signed by the maker to validate the fill request.\r\n    /// A nonce that is issued by the coordinator is used to prevent replay attacks.\r\n    /// This operation can only be invoked by the coordinator in an Active state.\r\n    /// @param _filler The address of the user that is filling the offer\r\n    /// @param _offerHashes The hashes of the offers to fill\r\n    /// @param _amountsToTake The number of tokens to take for each offer\r\n    /// (each index corresponds to the entry with the same index in _offerHashes)\r\n    /// @param _feeAsset The address of the token to use for fee payment\r\n    /// @param _feeAmount The amount of tokens to pay as fees to the operator\r\n    /// @param _nonce The nonce to prevent replay attacks\r\n    /// @param _v The `v` component of the `_filler`'s signature\r\n    /// @param _r The `r` component of the `_filler`'s signature\r\n    /// @param _s The `s` component of the `_filler`'s signature\r\n    function fillOffers(\r\n        address _filler,\r\n        bytes32[] _offerHashes,\r\n        uint256[] _amountsToTake,\r\n        address _feeAsset,\r\n        uint256 _feeAmount,\r\n        uint64 _nonce,\r\n        uint8 _v,\r\n        bytes32 _r,\r\n        bytes32 _s\r\n    )\r\n        external\r\n        onlyCoordinator\r\n        onlyActiveState\r\n    {\r\n        require(\r\n            _offerHashes.length > 0,\r\n            'Invalid input'\r\n        );\r\n        require(\r\n            _offerHashes.length == _amountsToTake.length,\r\n            'Invalid inputs'\r\n        );\r\n\r\n        bytes32 msgHash = keccak256(\r\n            abi.encodePacked(\r\n                \"fillOffers\",\r\n                _filler,\r\n                _offerHashes,\r\n                _amountsToTake,\r\n                _feeAsset,\r\n                _feeAmount,\r\n                _nonce\r\n            )\r\n        );\r\n\r\n        require(\r\n            _recoverAddress(msgHash, _v, _r, _s) == _filler,\r\n            \"Invalid signature\"\r\n        );\r\n\r\n        _validateAndAddHash(msgHash);\r\n\r\n        for (uint32 i = 0; i < _offerHashes.length; i++) {\r\n            _fill(_filler, _offerHashes[i], _amountsToTake[i], etherAddr, 0);\r\n        }\r\n\r\n        _paySeparateFees(\r\n            _filler,\r\n            _feeAsset,\r\n            _feeAmount,\r\n            ReasonFillerFeeGive,\r\n            ReasonFillerFeeReceive\r\n        );\r\n    }\r\n\r\n    /// @notice Cancels an offer that was preivously made using `makeOffer`.\r\n    /// @dev Cancels the offer with `_offerHash`. An `_expectedAvailableAmount`\r\n    /// is provided to allow the coordinator to ensure that the offer is not accidentally\r\n    /// cancelled ahead of time (where there is a pending fill that has not been settled).\r\n    /// The hash of the _offerHash, _feeAsset, `_feeAmount` prefixed with the\r\n    /// operation name \"cancel\" must be signed by the offer maker to validate\r\n    /// the cancellation request. Only the coordinator can invoke this operation.\r\n    /// See `slowCancel` for cancellation without requiring the coordinator's\r\n    /// involvement.\r\n    /// @param _offerHash The hash of the offer to cancel\r\n    /// @param _expectedAvailableAmount The number of tokens that should be present when cancelling\r\n    /// @param _feeAsset The address of the token to use for fee payment\r\n    /// @param _feeAmount The amount of tokens to pay as fees to the operator\r\n    /// @param _v The `v` component of the offer maker's signature\r\n    /// @param _r The `r` component of the offer maker's signature\r\n    /// @param _s The `s` component of the offer maker's signature\r\n    function cancel(\r\n        bytes32 _offerHash,\r\n        uint256 _expectedAvailableAmount,\r\n        address _feeAsset,\r\n        uint256 _feeAmount,\r\n        uint8 _v,\r\n        bytes32 _r,\r\n        bytes32 _s\r\n    )\r\n        external\r\n        onlyCoordinator\r\n    {\r\n        require(\r\n            _recoverAddress(keccak256(abi.encodePacked(\r\n                \"cancel\",\r\n                _offerHash,\r\n                _feeAsset,\r\n                _feeAmount\r\n            )), _v, _r, _s) == offers[_offerHash].maker,\r\n            \"Invalid signature\"\r\n        );\r\n\r\n        _cancel(_offerHash, _expectedAvailableAmount, _feeAsset, _feeAmount);\r\n    }\r\n\r\n    /// @notice Announces intent to cancel tokens using `slowCancel`\r\n    /// @dev Allows a user to invoke `slowCancel` after a minimum of\r\n    /// `cancelAnnounceDelay` seconds has passed.\r\n    /// This announcement and delay is necessary so that the operator has time\r\n    /// to respond if a user attempts to invoke a `slowCancel` even though\r\n    /// the exchange is operating normally.\r\n    /// In that case, the coordinator would simply stop matching the offer to\r\n    /// viable counterparties the moment the `CancelAnnounce` is seen.\r\n    /// @param _offerHash The hash of the offer that will be cancelled\r\n    function announceCancel(bytes32 _offerHash)\r\n        external\r\n    {\r\n        Offer memory offer = offers[_offerHash];\r\n\r\n        require(\r\n            offer.maker == msg.sender,\r\n            \"Invalid sender\"\r\n        );\r\n\r\n        require(\r\n            offer.availableAmount > 0,\r\n            \"Offer already cancelled\"\r\n        );\r\n\r\n        uint256 canCancelAt = now + cancelAnnounceDelay;\r\n        announcedCancellations[_offerHash] = canCancelAt;\r\n\r\n        emit CancelAnnounce(offer.maker, _offerHash, canCancelAt);\r\n    }\r\n\r\n    /// @notice Cancel an offer without requiring the coordinator\r\n    /// @dev This operation is meant to be used if the operator becomes \"byzantine\",\r\n    /// so that users can still cancel offers in this contract, and withdraw tokens\r\n    /// using `slowWithdraw`.\r\n    /// The `announceCancel` operation has to be invoked first, and a minimum time of\r\n    /// `cancelAnnounceDelay` seconds have to pass, before this operation can be carried out.\r\n    /// Note that this direct on-chain cancellation is an atypical operation, and\r\n    /// the normal `cancel` operation should be used in non-byzantine states.\r\n    /// @param _offerHash The hash of the offer to cancel\r\n    function slowCancel(bytes32 _offerHash)\r\n        external\r\n    {\r\n        require(\r\n            announcedCancellations[_offerHash] != 0 && announcedCancellations[_offerHash] <= now,\r\n            \"Insufficient delay\"\r\n        );\r\n\r\n        delete announcedCancellations[_offerHash];\r\n\r\n        Offer memory offer = offers[_offerHash];\r\n        _cancel(_offerHash, offer.availableAmount, etherAddr, 0);\r\n    }\r\n\r\n    /// @notice Cancels an offer immediately once cancellation intent\r\n    /// has been announced.\r\n    /// @dev Can only be invoked by the coordinator. This allows\r\n    /// the coordinator to quickly remove offers that it has already\r\n    /// acknowledged, and move its offer book into a consistent state.\r\n    function fastCancel(bytes32 _offerHash, uint256 _expectedAvailableAmount)\r\n        external\r\n        onlyCoordinator\r\n    {\r\n        require(\r\n            announcedCancellations[_offerHash] != 0,\r\n            \"Missing annoncement\"\r\n        );\r\n\r\n        delete announcedCancellations[_offerHash];\r\n\r\n        _cancel(_offerHash, _expectedAvailableAmount, etherAddr, 0);\r\n    }\r\n\r\n    /// @notice Cancels an offer without requiring the owner's signature,\r\n    /// so that the tokens can be withdrawn using `emergencyWithdraw`.\r\n    /// @dev Can only be invoked in an Inactive state by the coordinator.\r\n    /// This operation is meant to be used in emergencies only.\r\n    function emergencyCancel(bytes32 _offerHash, uint256 _expectedAvailableAmount)\r\n        external\r\n        onlyCoordinator\r\n        onlyInactiveState\r\n    {\r\n        _cancel(_offerHash, _expectedAvailableAmount, etherAddr, 0);\r\n    }\r\n\r\n    /// @notice Approve an address for spending any amount of\r\n    /// any token from the `msg.sender`'s balances\r\n    /// @dev Analogous to ERC-20 `approve`, with the following differences:\r\n    ///     - `_spender` must be whitelisted by owner\r\n    ///     - approval can be rescinded at a later time by the user\r\n    ///       iff it has been removed from the whitelist\r\n    ///     - spending amount is unlimited\r\n    /// @param _spender The address to approve spending\r\n    function approveSpender(address _spender)\r\n        external\r\n    {\r\n        require(\r\n            whitelistedSpenders[_spender],\r\n            \"Spender is not whitelisted\"\r\n        );\r\n\r\n        approvedSpenders[msg.sender][_spender] = true;\r\n        emit SpenderApprove(msg.sender, _spender);\r\n    }\r\n\r\n    /// @notice Rescinds a previous approval for spending the `msg.sender`'s contract balance.\r\n    /// @dev Rescinds approval for a spender, after it has been removed from\r\n    /// the `whitelistedSpenders` set. This allows an approval to be removed\r\n    /// if both the owner and user agrees that the previously approved spender\r\n    /// contract should no longer be used.\r\n    /// @param _spender The address to rescind spending approval\r\n    function rescindApproval(address _spender)\r\n        external\r\n    {\r\n        require(\r\n            approvedSpenders[msg.sender][_spender],\r\n            \"Spender has not been approved\"\r\n        );\r\n\r\n        require(\r\n            whitelistedSpenders[_spender] != true,\r\n            \"Spender must be removed from the whitelist\"\r\n        );\r\n\r\n        delete approvedSpenders[msg.sender][_spender];\r\n        emit SpenderRescind(msg.sender, _spender);\r\n    }\r\n\r\n    /// @notice Transfers tokens from one address to another\r\n    /// @dev Analogous to ERC-20 `transferFrom`, with the following differences:\r\n    ///     - the address of the token to transfer must be specified\r\n    ///     - any amount of token can be transferred, as long as it is less or equal\r\n    ///       to `_from`'s balance\r\n    ///     - reason codes can be attached and they must not use reasons specified in\r\n    ///       this contract\r\n    /// @param _from The address to transfer tokens from\r\n    /// @param _to The address to transfer tokens to\r\n    /// @param _amount The number of tokens to transfer\r\n    /// @param _token The address of the token to transfer\r\n    /// @param _decreaseReason A reason code to emit in the `BalanceDecrease` event\r\n    /// @param _increaseReason A reason code to emit in the `BalanceIncrease` event\r\n    function spendFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _amount,\r\n        address _token,\r\n        uint8 _decreaseReason,\r\n        uint8 _increaseReason\r\n    )\r\n        external\r\n        unusedReasonCode(_decreaseReason)\r\n        unusedReasonCode(_increaseReason)\r\n    {\r\n        require(\r\n            approvedSpenders[_from][msg.sender],\r\n            \"Spender has not been approved\"\r\n        );\r\n\r\n        _validateAddress(_to);\r\n\r\n        balances[_from][_token] = balances[_from][_token].sub(_amount);\r\n        emit BalanceDecrease(_from, _token, _amount, _decreaseReason);\r\n\r\n        balances[_to][_token] = balances[_to][_token].add(_amount);\r\n        emit BalanceIncrease(_to, _token, _amount, _increaseReason);\r\n    }\r\n\r\n    /// @dev Overrides ability to renounce ownership as this contract is\r\n    /// meant to always have an owner.\r\n    function renounceOwnership() public { require(false, \"Cannot have no owner\"); }\r\n\r\n    /// @dev The actual withdraw logic that is used internally by multiple operations.\r\n    function _withdraw(\r\n        address _withdrawer,\r\n        address _token,\r\n        uint256 _amount,\r\n        address _feeAsset,\r\n        uint256 _feeAmount\r\n    )\r\n        private\r\n    {\r\n        // SafeMath.sub checks that balance is sufficient already\r\n        _decreaseBalanceAndPayFees(\r\n            _withdrawer,\r\n            _token,\r\n            _amount,\r\n            _feeAsset,\r\n            _feeAmount,\r\n            ReasonWithdraw,\r\n            ReasonWithdrawFeeGive,\r\n            ReasonWithdrawFeeReceive\r\n        );\r\n\r\n        if (_token == etherAddr) // ether\r\n        {\r\n            _withdrawer.transfer(_amount);\r\n        }\r\n        else\r\n        {\r\n            _validateIsContract(_token);\r\n            require(\r\n                _token.call(\r\n                    bytes4(keccak256(\"transfer(address,uint256)\")), _withdrawer, _amount\r\n                ),\r\n                \"transfer call failed\"\r\n            );\r\n            require(\r\n                _getSanitizedReturnValue(),\r\n                \"transfer failed\"\r\n            );\r\n        }\r\n    }\r\n\r\n    /// @dev The actual fill logic that is used internally by multiple operations.\r\n    function _fill(\r\n        address _filler,\r\n        bytes32 _offerHash,\r\n        uint256 _amountToTake,\r\n        address _feeAsset,\r\n        uint256 _feeAmount\r\n    )\r\n        private\r\n    {\r\n        require(\r\n            _amountToTake > 0,\r\n            \"Invalid input\"\r\n        );\r\n\r\n        Offer storage offer = offers[_offerHash];\r\n        require(\r\n            offer.maker != _filler,\r\n            \"Invalid filler\"\r\n        );\r\n\r\n        require(\r\n            offer.availableAmount != 0,\r\n            \"Offer already filled\"\r\n        );\r\n\r\n        uint256 amountToFill = (_amountToTake.mul(offer.wantAmount)).div(offer.offerAmount);\r\n\r\n        // transfer amountToFill in fillAsset from filler to maker\r\n        balances[_filler][offer.wantAsset] = balances[_filler][offer.wantAsset].sub(amountToFill);\r\n        emit BalanceDecrease(_filler, offer.wantAsset, amountToFill, ReasonFillerGive);\r\n\r\n        balances[offer.maker][offer.wantAsset] = balances[offer.maker][offer.wantAsset].add(amountToFill);\r\n        emit BalanceIncrease(offer.maker, offer.wantAsset, amountToFill, ReasonMakerReceive);\r\n\r\n        // deduct amountToTake in takeAsset from offer\r\n        offer.availableAmount = offer.availableAmount.sub(_amountToTake);\r\n        _increaseBalanceAndPayFees(\r\n            _filler,\r\n            offer.offerAsset,\r\n            _amountToTake,\r\n            _feeAsset,\r\n            _feeAmount,\r\n            ReasonFillerReceive,\r\n            ReasonFillerFeeGive,\r\n            ReasonFillerFeeReceive\r\n        );\r\n        emit Fill(_filler, _offerHash, amountToFill, _amountToTake, offer.maker);\r\n\r\n        if (offer.availableAmount == 0)\r\n        {\r\n            delete offers[_offerHash];\r\n        }\r\n    }\r\n\r\n    /// @dev The actual cancellation logic that is used internally by multiple operations.\r\n    function _cancel(\r\n        bytes32 _offerHash,\r\n        uint256 _expectedAvailableAmount,\r\n        address _feeAsset,\r\n        uint256 _feeAmount\r\n    )\r\n        private\r\n    {\r\n        Offer memory offer = offers[_offerHash];\r\n\r\n        require(\r\n            offer.availableAmount > 0,\r\n            \"Offer already cancelled\"\r\n        );\r\n\r\n        require(\r\n            offer.availableAmount == _expectedAvailableAmount,\r\n            \"Invalid input\"\r\n        );\r\n\r\n        delete offers[_offerHash];\r\n\r\n        _increaseBalanceAndPayFees(\r\n            offer.maker,\r\n            offer.offerAsset,\r\n            offer.availableAmount,\r\n            _feeAsset,\r\n            _feeAmount,\r\n            ReasonCancel,\r\n            ReasonCancelFeeGive,\r\n            ReasonCancelFeeReceive\r\n        );\r\n\r\n        emit Cancel(offer.maker, _offerHash);\r\n    }\r\n\r\n    /// @dev Performs an `ecrecover` operation for signed message hashes\r\n    /// in accordance to EIP-191.\r\n    function _recoverAddress(bytes32 _hash, uint8 _v, bytes32 _r, bytes32 _s)\r\n        private\r\n        pure\r\n        returns (address)\r\n    {\r\n        bytes memory prefix = \"\\x19Ethereum Signed Message:\\n32\";\r\n        bytes32 prefixedHash = keccak256(abi.encodePacked(prefix, _hash));\r\n        return ecrecover(prefixedHash, _v, _r, _s);\r\n    }\r\n\r\n    /// @dev Decreases a user's balance while adding a cut from the decrement\r\n    /// to be paid as fees to the operator. Reason codes should be provided\r\n    /// to be emitted with events for tracking.\r\n    function _decreaseBalanceAndPayFees(\r\n        address _user,\r\n        address _token,\r\n        uint256 _amount,\r\n        address _feeAsset,\r\n        uint256 _feeAmount,\r\n        uint8 _reason,\r\n        uint8 _feeGiveReason,\r\n        uint8 _feeReceiveReason\r\n    )\r\n        private\r\n    {\r\n        uint256 totalAmount = _amount;\r\n\r\n        if (_feeAsset == _token) {\r\n            totalAmount = _amount.add(_feeAmount);\r\n        }\r\n\r\n        balances[_user][_token] = balances[_user][_token].sub(totalAmount);\r\n        emit BalanceDecrease(_user, _token, totalAmount, _reason);\r\n\r\n        _payFees(_user, _token, _feeAsset, _feeAmount, _feeGiveReason, _feeReceiveReason);\r\n    }\r\n\r\n    /// @dev Increases a user's balance while deducting a cut from the increment\r\n    /// to be paid as fees to the operator. Reason codes should be provided\r\n    /// to be emitted with events for tracking.\r\n    function _increaseBalanceAndPayFees(\r\n        address _user,\r\n        address _token,\r\n        uint256 _amount,\r\n        address _feeAsset,\r\n        uint256 _feeAmount,\r\n        uint8 _reason,\r\n        uint8 _feeGiveReason,\r\n        uint8 _feeReceiveReason\r\n    )\r\n        private\r\n    {\r\n        uint256 totalAmount = _amount;\r\n\r\n        if (_feeAsset == _token) {\r\n            totalAmount = _amount.sub(_feeAmount);\r\n        }\r\n\r\n        balances[_user][_token] = balances[_user][_token].add(totalAmount);\r\n        emit BalanceIncrease(_user, _token, totalAmount, _reason);\r\n\r\n        _payFees(_user, _token, _feeAsset, _feeAmount, _feeGiveReason, _feeReceiveReason);\r\n    }\r\n\r\n    /// @dev Pays fees to the operator, attaching the specified reason codes\r\n    /// to the emitted event, only deducting from the `_user` balance if the\r\n    /// `_token` does not match `_feeAsset`.\r\n    /// IMPORTANT: In the event that the `_token` matches `_feeAsset`,\r\n    /// there should a reduction in balance increment carried out separately,\r\n    /// to ensure balance consistency.\r\n    function _payFees(\r\n        address _user,\r\n        address _token,\r\n        address _feeAsset,\r\n        uint256 _feeAmount,\r\n        uint8 _feeGiveReason,\r\n        uint8 _feeReceiveReason\r\n    )\r\n        private\r\n    {\r\n        if (_feeAmount == 0) {\r\n            return;\r\n        }\r\n\r\n        // if the feeAsset does not match the token then the feeAmount needs to be separately deducted\r\n        if (_feeAsset != _token) {\r\n            balances[_user][_feeAsset] = balances[_user][_feeAsset].sub(_feeAmount);\r\n            emit BalanceDecrease(_user, _feeAsset, _feeAmount, _feeGiveReason);\r\n        }\r\n\r\n        balances[operator][_feeAsset] = balances[operator][_feeAsset].add(_feeAmount);\r\n        emit BalanceIncrease(operator, _feeAsset, _feeAmount, _feeReceiveReason);\r\n    }\r\n\r\n    /// @dev Pays fees to the operator, attaching the specified reason codes to the emitted event.\r\n    function _paySeparateFees(\r\n        address _user,\r\n        address _feeAsset,\r\n        uint256 _feeAmount,\r\n        uint8 _feeGiveReason,\r\n        uint8 _feeReceiveReason\r\n    )\r\n        private\r\n    {\r\n        if (_feeAmount == 0) {\r\n            return;\r\n        }\r\n\r\n        balances[_user][_feeAsset] = balances[_user][_feeAsset].sub(_feeAmount);\r\n        emit BalanceDecrease(_user, _feeAsset, _feeAmount, _feeGiveReason);\r\n\r\n        balances[operator][_feeAsset] = balances[operator][_feeAsset].add(_feeAmount);\r\n        emit BalanceIncrease(operator, _feeAsset, _feeAmount, _feeReceiveReason);\r\n    }\r\n\r\n    /// @dev Ensures that the address is a valid user address.\r\n    function _validateAddress(address _address)\r\n        private\r\n        pure\r\n    {\r\n        require(\r\n            _address != address(0),\r\n            'Invalid address'\r\n        );\r\n    }\r\n\r\n    /// @dev Ensures a hash hasn't been already used, which would mean\r\n    /// a repeated set of arguments and nonce was used. This prevents\r\n    /// replay attacks.\r\n    function _validateAndAddHash(bytes32 _hash)\r\n        private\r\n    {\r\n        require(\r\n            usedHashes[_hash] != true,\r\n            \"hash already used\"\r\n        );\r\n\r\n        usedHashes[_hash] = true;\r\n    }\r\n\r\n    /// @dev Ensure that the address is a deployed contract\r\n    function _validateIsContract(address addr) private view {\r\n        assembly {\r\n            if iszero(extcodesize(addr)) { revert(0, 0) }\r\n        }\r\n    }\r\n\r\n    /// @dev Fix for ERC-20 tokens that do not have proper return type\r\n    /// See: https://github.com/ethereum/solidity/issues/4116\r\n    /// https://medium.com/loopring-protocol/an-incompatibility-in-smart-contract-threatening-dapp-ecosystem-72b8ca5db4da\r\n    /// https://github.com/sec-bit/badERC20Fix/blob/master/badERC20Fix.sol\r\n    function _getSanitizedReturnValue()\r\n        private\r\n        pure\r\n        returns (bool)\r\n    {\r\n        uint256 result = 0;\r\n        assembly {\r\n            switch returndatasize\r\n            case 0 {    // this is an non-standard ERC-20 token\r\n                result := 1 // assume success on no revert\r\n            }\r\n            case 32 {   // this is a standard ERC-20 token\r\n                returndatacopy(0, 0, 32)\r\n                result := mload(0)\r\n            }\r\n            default {   // this is not an ERC-20 token\r\n                revert(0, 0) // revert for safety\r\n            }\r\n        }\r\n        return result != 0;\r\n    }\r\n}\r\n\r\n// File: contracts/AirDropper.sol\r\n\r\npragma solidity 0.4.25;\r\n\r\n\r\n\r\n/// @title The AirDropper contract to send ether to users\r\n/// @author Switcheo Network\r\ncontract AirDropper {\r\n    using SafeMath for uint256;\r\n\r\n    // The Switcheo Broker contract\r\n    Broker public broker;\r\n\r\n    // A record of which hashes have been used before\r\n    mapping(bytes32 => bool) public usedHashes;\r\n\r\n    // Emitted when ether is sent\r\n    event SendEther(bytes32 indexed id, address indexed receiver, uint256 amount);\r\n\r\n    /// @notice Initializes the AirDropper contract\r\n    /// @dev The broker is initialized to the Switcheo Broker\r\n    constructor(address brokerAddress)\r\n        public\r\n    {\r\n        broker = Broker(brokerAddress);\r\n    }\r\n\r\n    modifier onlyCoordinator() {\r\n        require(\r\n            msg.sender == address(broker.coordinator()),\r\n            \"Invalid sender\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    /// @notice The payable method to allow this contract to receive ether\r\n    function depositEther() external payable {}\r\n\r\n    /// @notice Sends ether to a receiving address.\r\n    /// @param _id The unique identifier to prevent double spends\r\n    /// @param _receiver The address of the receiver\r\n    /// @param _amount The amount of ether to send\r\n    function sendEther(\r\n        bytes32 _id,\r\n        address _receiver,\r\n        uint256 _amount\r\n    )\r\n        external\r\n        onlyCoordinator\r\n    {\r\n        _validateAndAddHash(_id);\r\n        _receiver.transfer(_amount);\r\n        emit SendEther(_id, _receiver, _amount);\r\n    }\r\n\r\n    /// @dev Ensures a hash hasn't been already used.\r\n    /// This prevents replay attacks.\r\n    function _validateAndAddHash(bytes32 _hash)\r\n        private\r\n    {\r\n        require(\r\n            usedHashes[_hash] != true,\r\n            \"hash already used\"\r\n        );\r\n\r\n        usedHashes[_hash] = true;\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[],\"name\":\"depositEther\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"broker\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"usedHashes\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_id\",\"type\":\"bytes32\"},{\"name\":\"_receiver\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"sendEther\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"brokerAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"id\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"SendEther\",\"type\":\"event\"}]","ContractName":"AirDropper","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000ba3ed686cc32ffa8664628b1e96d8022e40543de","Library":"","SwarmSource":"bzzr://8bb7fa69947f054730f07f6d0e93d61837f877bbf29e92d221dc01871f5525a5"}]}