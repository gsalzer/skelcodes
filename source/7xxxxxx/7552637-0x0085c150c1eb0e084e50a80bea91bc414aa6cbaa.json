{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.5.7;\r\n// produced by the Solididy File Flattener (c) David Appleton 2018\r\n// contact : dave@akomba.com\r\n// released under Apache 2.0 licence\r\n// input  /Users/rmanzoku/src/github.com/doublejumptokyo/mch-experimental/contracts/MetaMarking.sol\r\n// flattened :  Friday, 12-Apr-19 07:50:40 UTC\r\nlibrary ECDSA {\r\n    /**\r\n     * @dev Recover signer address from a message by using their signature\r\n     * @param hash bytes32 message, the hash is the signed message. What is recovered is the signer address.\r\n     * @param signature bytes signature, the signature is generated using web3.eth.sign()\r\n     */\r\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\r\n        // Check the signature length\r\n        if (signature.length != 65) {\r\n            return (address(0));\r\n        }\r\n\r\n        // Divide the signature in r, s and v variables\r\n        bytes32 r;\r\n        bytes32 s;\r\n        uint8 v;\r\n\r\n        // ecrecover takes the signature parameters, and the only way to get them\r\n        // currently is to use assembly.\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n            r := mload(add(signature, 0x20))\r\n            s := mload(add(signature, 0x40))\r\n            v := byte(0, mload(add(signature, 0x60)))\r\n        }\r\n\r\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\r\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\r\n        // the valid range for s in (281): 0 < s < secp256k1n ÷ 2 + 1, and for v in (282): v ∈ {27, 28}. Most\r\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\r\n        //\r\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\r\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\r\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\r\n        // these malleable signatures as well.\r\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\r\n            return address(0);\r\n        }\r\n\r\n        if (v != 27 && v != 28) {\r\n            return address(0);\r\n        }\r\n\r\n        // If the signature is valid (and not malleable), return the signer address\r\n        return ecrecover(hash, v, r, s);\r\n    }\r\n\r\n    /**\r\n     * toEthSignedMessageHash\r\n     * @dev prefix a bytes32 value with \"\\x19Ethereum Signed Message:\"\r\n     * and hash the result\r\n     */\r\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\r\n        // 32 is the length in bytes of hash,\r\n        // enforced by the type signature above\r\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\r\n    }\r\n}\r\n\r\nlibrary Roles {\r\n    struct Role {\r\n        mapping (address => bool) bearer;\r\n    }\r\n\r\n    /**\r\n     * @dev give an account access to this role\r\n     */\r\n    function add(Role storage role, address account) internal {\r\n        require(account != address(0));\r\n        require(!has(role, account));\r\n\r\n        role.bearer[account] = true;\r\n    }\r\n\r\n    /**\r\n     * @dev remove an account's access to this role\r\n     */\r\n    function remove(Role storage role, address account) internal {\r\n        require(account != address(0));\r\n        require(has(role, account));\r\n\r\n        role.bearer[account] = false;\r\n    }\r\n\r\n    /**\r\n     * @dev check if an account has this role\r\n     * @return bool\r\n     */\r\n    function has(Role storage role, address account) internal view returns (bool) {\r\n        require(account != address(0));\r\n        return role.bearer[account];\r\n    }\r\n}\r\n\r\ncontract OperatorRole {\r\n    using Roles for Roles.Role;\r\n\r\n    event OperatorAdded(address indexed account);\r\n    event OperatorRemoved(address indexed account);\r\n\r\n    Roles.Role private operators;\r\n\r\n    constructor() public {\r\n        operators.add(msg.sender);\r\n    }\r\n\r\n    modifier onlyOperator() {\r\n        require(isOperator(msg.sender));\r\n        _;\r\n    }\r\n    \r\n    function isOperator(address account) public view returns (bool) {\r\n        return operators.has(account);\r\n    }\r\n\r\n    function addOperator(address account) public onlyOperator() {\r\n        operators.add(account);\r\n        emit OperatorAdded(account);\r\n    }\r\n\r\n    function removeOperator(address account) public onlyOperator() {\r\n        operators.remove(account);\r\n        emit OperatorRemoved(account);\r\n    }\r\n\r\n}\r\ncontract MCHMetaMarking is OperatorRole {\r\n\r\n  mapping(address => uint256) public nonces;\r\n\r\n  struct Mark {\r\n    bool isExist;\r\n    int64 markAt;\r\n    uint32 uid;\r\n    int64 primeUntil;\r\n    uint8 landType;\r\n  }\r\n\r\n  event Marking(\r\n             address indexed from,\r\n             int64 markAt,\r\n             uint32 uid,\r\n             int64 primeUntil,\r\n             uint8 landType\r\n             );\r\n\r\n  mapping(uint8 => address[]) public addressesByLandType;\r\n  mapping(address => Mark) public latestMarkByAddress;\r\n\r\n  constructor() public {\r\n    addOperator(address(0x51C36baAa8b0e6CF45e2E1A77E84E3c0D1713F97));\r\n  }\r\n\r\n  function encodeData(address _from, int64 _markAt, uint32 _uid, int64 _primeUntil,\r\n                      uint8 _landType, uint256 _nonce, address _relayer) public view returns (bytes32) {\r\n    return keccak256(abi.encode(\r\n                                      address(this),\r\n                                      _from,\r\n                                      _markAt,\r\n                                      _uid,\r\n                                      _primeUntil,\r\n                                      _landType,\r\n                                      _nonce,\r\n                                      _relayer\r\n                                      )\r\n                     );\r\n  }\r\n\r\n  function ethSignedMessageHash(bytes32 _data) public pure returns (bytes32) {\r\n    return ECDSA.toEthSignedMessageHash(_data);\r\n  }\r\n\r\n  function recover(bytes32 _data, bytes memory _sig) public pure returns (address) {\r\n    bytes32 data = ECDSA.toEthSignedMessageHash(_data);\r\n    return ECDSA.recover(data, _sig);\r\n  }\r\n\r\n  function executeMarkMetaTx(address _from, int64 _markAt, uint32 _uid, int64 _primeUntil,\r\n                             uint8 _landType, uint256 _nonce, bytes calldata _sig) external onlyOperator() {\r\n    require(nonces[_from]+1 == _nonce, \"nonces[_from]+1 != _nonce\");\r\n    bytes32 encodedData = encodeData(_from, _markAt, _uid, _primeUntil, _landType, _nonce, msg.sender);\r\n    address signer = recover(encodedData, _sig);\r\n    require(signer == _from, \"signer != _from\");\r\n\r\n    _mark(_from, _markAt, _uid, _primeUntil, _landType);\r\n    nonces[_from]++;\r\n  }\r\n\r\n  function forceMark(address _user, int64 _markAt, uint32 _uid, int64 _primeUntil, uint8 _landType) external onlyOperator() {\r\n    _mark(_user, _markAt, _uid, _primeUntil, _landType);\r\n  }\r\n\r\n  function _mark(address _user, int64 _markAt, uint32 _uid, int64 _primeUntil, uint8 _landType) private {\r\n\r\n    if (!latestMarkByAddress[_user].isExist) {\r\n      latestMarkByAddress[_user] = Mark(\r\n                                        true,\r\n                                        _markAt,\r\n                                        _uid,\r\n                                        _primeUntil,\r\n                                        _landType\r\n                                        );\r\n      addressesByLandType[_landType].push(_user);\r\n      return;\r\n    }\r\n\r\n    uint8 currentLandType = latestMarkByAddress[_user].landType;\r\n    if (currentLandType != _landType) {\r\n      uint256 i;\r\n      for (i = 0; i < addressesByLandType[_landType].length; i++) {\r\n\tif (addressesByLandType[_landType][i] != _user) {\r\n\t  break;\r\n\t}\r\n      }\r\n\r\n      delete addressesByLandType[currentLandType][i];\r\n      addressesByLandType[_landType].push(_user);\r\n    }\r\n\r\n    latestMarkByAddress[_user].markAt = _markAt;\r\n    latestMarkByAddress[_user].uid = _uid;\r\n    latestMarkByAddress[_user].primeUntil = _primeUntil;\r\n    latestMarkByAddress[_user].landType = _landType;\r\n\r\n    emit Marking(_user, _markAt, _uid, _primeUntil, _landType);\r\n  }\r\n\r\n  function getAddressesByLandType(uint8 _landType, int64 _validSince) public view returns (address[] memory){\r\n    if (addressesByLandType[_landType].length == 0) {\r\n      return new address[](0);\r\n    }\r\n\r\n    uint256 cnt;\r\n    for (uint256 i = 0; i < addressesByLandType[_landType].length; i++) {\r\n      address addr = addressesByLandType[_landType][i];\r\n      if (addr == address(0x0)) {\r\n        continue;\r\n      }\r\n\r\n      if (latestMarkByAddress[addr].markAt >= _validSince) {\r\n        cnt++;\r\n      }\r\n    }\r\n\r\n    address[] memory ret = new address[](cnt);\r\n    uint256 idx = 0;\r\n    for (uint256 i = 0; i < addressesByLandType[_landType].length; i++) {\r\n      address addr = addressesByLandType[_landType][i];\r\n      if (addr == address(0x0)) {\r\n        continue;\r\n      }\r\n\r\n      if (latestMarkByAddress[addr].markAt >= _validSince) {\r\n        ret[idx] = addr;\r\n        idx++;\r\n      }\r\n    }\r\n\r\n    return ret;\r\n  }\r\n\r\n  function meta_nonce(address _from) external view returns (uint256 nonce) {\r\n    return nonces[_from];\r\n  }\r\n\r\n  function kill() external onlyOperator() {\r\n    selfdestruct(msg.sender);\r\n  }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"}],\"name\":\"meta_nonce\",\"outputs\":[{\"name\":\"nonce\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_data\",\"type\":\"bytes32\"},{\"name\":\"_sig\",\"type\":\"bytes\"}],\"name\":\"recover\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_data\",\"type\":\"bytes32\"}],\"name\":\"ethSignedMessageHash\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"kill\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_user\",\"type\":\"address\"},{\"name\":\"_markAt\",\"type\":\"int64\"},{\"name\":\"_uid\",\"type\":\"uint32\"},{\"name\":\"_primeUntil\",\"type\":\"int64\"},{\"name\":\"_landType\",\"type\":\"uint8\"}],\"name\":\"forceMark\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isOperator\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint8\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"addressesByLandType\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"nonces\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"addOperator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"removeOperator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_landType\",\"type\":\"uint8\"},{\"name\":\"_validSince\",\"type\":\"int64\"}],\"name\":\"getAddressesByLandType\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_markAt\",\"type\":\"int64\"},{\"name\":\"_uid\",\"type\":\"uint32\"},{\"name\":\"_primeUntil\",\"type\":\"int64\"},{\"name\":\"_landType\",\"type\":\"uint8\"},{\"name\":\"_nonce\",\"type\":\"uint256\"},{\"name\":\"_sig\",\"type\":\"bytes\"}],\"name\":\"executeMarkMetaTx\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_markAt\",\"type\":\"int64\"},{\"name\":\"_uid\",\"type\":\"uint32\"},{\"name\":\"_primeUntil\",\"type\":\"int64\"},{\"name\":\"_landType\",\"type\":\"uint8\"},{\"name\":\"_nonce\",\"type\":\"uint256\"},{\"name\":\"_relayer\",\"type\":\"address\"}],\"name\":\"encodeData\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"latestMarkByAddress\",\"outputs\":[{\"name\":\"isExist\",\"type\":\"bool\"},{\"name\":\"markAt\",\"type\":\"int64\"},{\"name\":\"uid\",\"type\":\"uint32\"},{\"name\":\"primeUntil\",\"type\":\"int64\"},{\"name\":\"landType\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"markAt\",\"type\":\"int64\"},{\"indexed\":false,\"name\":\"uid\",\"type\":\"uint32\"},{\"indexed\":false,\"name\":\"primeUntil\",\"type\":\"int64\"},{\"indexed\":false,\"name\":\"landType\",\"type\":\"uint8\"}],\"name\":\"Marking\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"OperatorAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"OperatorRemoved\",\"type\":\"event\"}]","ContractName":"MCHMetaMarking","CompilerVersion":"v0.5.7+commit.6da8b019","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://0e057f849852b3fbf011527276880fccccaaa8050181d8c947cac15b50a53744"}]}