{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\ncontract ERC165Interface {\r\n    /**\r\n     * @notice Query if a contract implements an interface\r\n     * @param interfaceID The interface identifier, as specified in ERC-165\r\n     * @dev Interface identification is specified in ERC-165. This function\r\n     *  uses less than 30,000 gas.\r\n     * @return `true` if the contract implements `interfaceID` and\r\n     *  `interfaceID` is not 0xffffffff, `false` otherwise\r\n     */\r\n    function supportsInterface(bytes4 interfaceID) external view returns (bool);\r\n}\r\n\r\ncontract ERC165 is ERC165Interface {\r\n    /**\r\n     * @dev a mapping of interface id to whether or not it's supported\r\n     */\r\n    mapping(bytes4 => bool) private _supportedInterfaces;\r\n\r\n    /**\r\n     * @dev implement supportsInterface(bytes4) using a lookup table\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool) {\r\n        return _supportedInterfaces[interfaceId];\r\n    }\r\n\r\n    /**\r\n     * @dev internal method for registering an interface\r\n     */\r\n    function _registerInterface(bytes4 interfaceId) internal {\r\n        require(interfaceId != 0xffffffff);\r\n        _supportedInterfaces[interfaceId] = true;\r\n    }\r\n}\r\n\r\n// Every ERC-721 compliant contract must implement the ERC721 and ERC165 interfaces.\r\n/** \r\n * @title ERC-721 Non-Fungible Token Standard\r\n * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\r\n * Note: the ERC-165 identifier for this interface is 0x80ac58cd.\r\n */\r\ncontract ERC721Basic is ERC165 {\r\n    // Below is MUST\r\n\r\n    /**\r\n     * @dev This emits when ownership of any NFT changes by any mechanism.\r\n     *  This event emits when NFTs are created (`from` == 0) and destroyed\r\n     *  (`to` == 0). Exception: during contract creation, any number of NFTs\r\n     *  may be created and assigned without emitting Transfer. At the time of\r\n     *  any transfer, the approved address for that NFT (if any) is reset to none.\r\n     */\r\n    event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);\r\n\r\n    /**\r\n     * @dev This emits when the approved address for an NFT is changed or\r\n     *  reaffirmed. The zero address indicates there is no approved address.\r\n     *  When a Transfer event emits, this also indicates that the approved\r\n     *  address for that NFT (if any) is reset to none.\r\n     */\r\n    event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);\r\n\r\n    /**\r\n     * @dev This emits when an operator is enabled or disabled for an owner.\r\n     *  The operator can manage all NFTs of the owner.\r\n     */\r\n    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\r\n\r\n    /**\r\n     * @notice Count all NFTs assigned to an owner\r\n     * @dev NFTs assigned to the zero address are considered invalid, and this\r\n     *  function throws for queries about the zero address.\r\n     * @param _owner An address for whom to query the balance\r\n     * @return The number of NFTs owned by `_owner`, possibly zero\r\n     */\r\n    function balanceOf(address _owner) public view returns (uint256);\r\n\r\n    /**\r\n     * @notice Find the owner of an NFT\r\n     * @dev NFTs assigned to zero address are considered invalid, and queries\r\n     *  about them do throw.\r\n     * @param _tokenId The identifier for an NFT\r\n     * @return The address of the owner of the NFT\r\n     */\r\n    function ownerOf(uint256 _tokenId) public view returns (address);\r\n\r\n    /**\r\n     * @notice Transfers the ownership of an NFT from one address to another address\r\n     * @dev Throws unless `msg.sender` is the current owner, an authorized\r\n     *  operator, or the approved address for this NFT. Throws if `_from` is\r\n     *  not the current owner. Throws if `_to` is the zero address. Throws if\r\n     *  `_tokenId` is not a valid NFT. When transfer is complete, this function\r\n     *  checks if `_to` is a smart contract (code size > 0). If so, it calls\r\n     *  `onERC721Received` on `_to` and throws if the return value is not\r\n     *  `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`.\r\n     * @param _from The current owner of the NFT\r\n     * @param _to The new owner\r\n     * @param _tokenId The NFT to transfer\r\n     * @param data Additional data with no specified format, sent in call to `_to`\r\n     */\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes data) public;\r\n\r\n    /**\r\n     * @notice Transfers the ownership of an NFT from one address to another address\r\n     * @dev This works identically to the other function with an extra data parameter,\r\n     *  except this function just sets data to \"\".\r\n     * @param _from The current owner of the NFT\r\n     * @param _to The new owner\r\n     * @param _tokenId The NFT to transfer\r\n     */\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId) public;\r\n\r\n    /**\r\n     * @notice Transfer ownership of an NFT -- THE CALLER IS RESPONSIBLE\r\n     *  TO CONFIRM THAT `_to` IS CAPABLE OF RECEIVING NFTS OR ELSE\r\n     *  THEY MAY BE PERMANENTLY LOST\r\n     * @dev Throws unless `msg.sender` is the current owner, an authorized\r\n     *  operator, or the approved address for this NFT. Throws if `_from` is\r\n     *  not the current owner. Throws if `_to` is the zero address. Throws if\r\n     *  `_tokenId` is not a valid NFT.\r\n     * @param _from The current owner of the NFT\r\n     * @param _to The new owner\r\n     * @param _tokenId The NFT to transfer\r\n     */\r\n    function transferFrom(address _from, address _to, uint256 _tokenId) public;\r\n\r\n    /**\r\n     * @notice Change or reaffirm the approved address for an NFT\r\n     * @dev The zero address indicates there is no approved address.\r\n     *  Throws unless `msg.sender` is the current NFT owner, or an authorized\r\n     *  operator of the current owner.\r\n     * @param _approved The new approved NFT controller\r\n     * @param _tokenId The NFT to approve\r\n     */\r\n    function approve(address _approved, uint256 _tokenId) external;\r\n\r\n    /**\r\n     * @notice Enable or disable approval for a third party (\"operator\") to manage\r\n     *  all of `msg.sender`'s assets\r\n     * @dev Emits the ApprovalForAll event. The contract MUST allow\r\n     *  multiple operators per owner.\r\n     * @param _operator Address to add to the set of authorized operators\r\n     * @param _approved True if the operator is approved, false to revoke approval\r\n     */\r\n    function setApprovalForAll(address _operator, bool _approved) external;\r\n\r\n    /**\r\n     * @notice Get the approved address for a single NFT\r\n     * @dev Throws if `_tokenId` is not a valid NFT.\r\n     * @param _tokenId The NFT to find the approved address for\r\n     * @return The approved address for this NFT, or the zero address if there is none\r\n     */\r\n    function getApproved(uint256 _tokenId) public view returns (address);\r\n\r\n    /**\r\n     * @notice Query if an address is an authorized operator for another address\r\n     * @param _owner The address that owns the NFTs\r\n     * @param _operator The address that acts on behalf of the owner\r\n     * @return True if `_operator` is an approved operator for `_owner`, false otherwise\r\n     */\r\n    function isApprovedForAll(address _owner, address _operator) public view returns (bool);\r\n\r\n    // Below is OPTIONAL\r\n\r\n    // ERC721Metadata\r\n    // The metadata extension is OPTIONAL for ERC-721 smart contracts (see \"caveats\", below). This allows your smart contract to be interrogated for its name and for details about the assets which your NFTs represent.\r\n    \r\n    /**\r\n     * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\r\n     * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\r\n     *  Note: the ERC-165 identifier for this interface is 0x5b5e139f.\r\n     */\r\n\r\n    /// @notice A descriptive name for a collection of NFTs in this contract\r\n    function name() external view returns (string _name);\r\n\r\n    /// @notice An abbreviated name for NFTs in this contract\r\n    function symbol() external view returns (string _symbol);\r\n\r\n    /**\r\n     * @notice A distinct Uniform Resource Identifier (URI) for a given asset.\r\n     * @dev Throws if `_tokenId` is not a valid NFT. URIs are defined in RFC\r\n     *  3986. The URI may point to a JSON file that conforms to the \"ERC721\r\n     *  Metadata JSON Schema\".\r\n     */\r\n    function tokenURI(uint256 _tokenId) external view returns (string);\r\n\r\n    // ERC721Enumerable\r\n    // The enumeration extension is OPTIONAL for ERC-721 smart contracts (see \"caveats\", below). This allows your contract to publish its full list of NFTs and make them discoverable.\r\n\r\n    /**\r\n     * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\r\n     * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\r\n     *  Note: the ERC-165 identifier for this interface is 0x780e9d63.\r\n     */\r\n\r\n    /**\r\n     * @notice Count NFTs tracked by this contract\r\n     * @return A count of valid NFTs tracked by this contract, where each one of\r\n     *  them has an assigned and queryable owner not equal to the zero address\r\n     */\r\n    function totalSupply() public view returns (uint256);\r\n}\r\n\r\n/**\r\n * @notice This is MUST to be implemented.\r\n *  A wallet/broker/auction application MUST implement the wallet interface if it will accept safe transfers.\r\n * @dev Note: the ERC-165 identifier for this interface is 0x150b7a02.\r\n */\r\ncontract ERC721TokenReceiver {\r\n    /**\r\n     * @notice Handle the receipt of an NFT\r\n     * @dev The ERC721 smart contract calls this function on the recipient\r\n     *  after a `transfer`. This function MAY throw to revert and reject the\r\n     *  transfer. Return of other than the magic value MUST result in the\r\n     *  transaction being reverted.\r\n     *  Note: the contract address is always the message sender.\r\n     * @param _operator The address which called `safeTransferFrom` function\r\n     * @param _from The address which previously owned the token\r\n     * @param _tokenId The NFT identifier which is being transferred\r\n     * @param _data Additional data with no specified format\r\n     * @return `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\r\n     *  unless throwing\r\n     */\r\n    function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes _data) public returns (bytes4);\r\n}\r\n\r\ncontract ERC721Holder is ERC721TokenReceiver {\r\n    function onERC721Received(address, address, uint256, bytes) public returns (bytes4) {\r\n        return this.onERC721Received.selector;\r\n    }\r\n}\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n    * @dev Multiplies two numbers, reverts on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, reverts on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\r\n    * reverts when dividing by zero.\r\n    */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n/**\r\n * @title Base auction contract of the Dyverse\r\n * @author VREX Lab Co., Ltd\r\n * @dev Contains necessary functions and variables for the auction.\r\n *  Inherits `ERC721Holder` contract which is the implementation of the `ERC721TokenReceiver`.\r\n *  This is to accept safe transfers.\r\n */\r\ncontract AuctionBase is ERC721Holder {\r\n    using SafeMath for uint256;\r\n\r\n    // Represents an auction on an NFT\r\n    struct Auction {\r\n        // Current owner of NFT\r\n        address seller;\r\n        // Price (in wei) of NFT\r\n        uint128 price;\r\n        // Time when the auction started\r\n        // NOTE: 0 if this auction has been concluded\r\n        uint64 startedAt;\r\n    }\r\n\r\n    // Reference to contract tracking NFT ownership\r\n    ERC721Basic public nonFungibleContract;\r\n\r\n    // The amount owner takes from the sale, (in basis points, which are 1/100 of a percent).\r\n    uint256 public ownerCut;\r\n\r\n    // Maps token ID to it's corresponding auction.\r\n    mapping (uint256 => Auction) tokenIdToAuction;\r\n\r\n    event AuctionCreated(uint256 tokenId, uint256 price);\r\n    event AuctionSuccessful(uint256 tokenId, uint256 totalPrice, address bidder);\r\n    event AuctionCanceled(uint256 tokenId);\r\n\r\n    /// @dev Disables sending funds to this contract.\r\n    function() external {}\r\n\r\n    /// @dev A modifier to check if the given value can fit in 64-bits.\r\n    modifier canBeStoredWith64Bits(uint256 _value) {\r\n        require(_value <= (2**64 - 1));\r\n        _;\r\n    }\r\n\r\n    /// @dev A modifier to check if the given value can fit in 128-bits.\r\n    modifier canBeStoredWith128Bits(uint256 _value) {\r\n        require(_value <= (2**128 - 1));\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the claimant owns the token.\r\n     * @param _claimant An address which to query the ownership of the token.\r\n     * @param _tokenId ID of the token to query the owner of.\r\n     */\r\n    function _owns(address _claimant, uint256 _tokenId) internal view returns (bool) {\r\n        return (nonFungibleContract.ownerOf(_tokenId) == _claimant);\r\n    }\r\n\r\n    /**\r\n     * @dev Escrows the NFT. Grants the ownership of the NFT to this contract safely.\r\n     *  Throws if the escrow fails.\r\n     * @param _owner Current owner of the token.\r\n     * @param _tokenId ID of the token to escrow.\r\n     */\r\n    function _escrow(address _owner, uint256 _tokenId) internal {\r\n        nonFungibleContract.safeTransferFrom(_owner, this, _tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers an NFT owned by this contract to another address safely.\r\n     * @param _receiver The receiving address of NFT.\r\n     * @param _tokenId ID of the token to transfer.\r\n     */\r\n    function _transfer(address _receiver, uint256 _tokenId) internal {\r\n        nonFungibleContract.safeTransferFrom(this, _receiver, _tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Adds an auction to the list of open auctions. \r\n     * @param _tokenId ID of the token to be put on auction.\r\n     * @param _auction Auction information of this token to open.\r\n     */\r\n    function _addAuction(uint256 _tokenId, Auction _auction) internal {\r\n        tokenIdToAuction[_tokenId] = _auction;\r\n\r\n        emit AuctionCreated(\r\n            uint256(_tokenId),\r\n            uint256(_auction.price)\r\n        );\r\n    }\r\n\r\n    /// @dev Cancels the auction which the _seller wants.\r\n    function _cancelAuction(uint256 _tokenId, address _seller) internal {\r\n        _removeAuction(_tokenId);\r\n        _transfer(_seller, _tokenId);\r\n        emit AuctionCanceled(_tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Computes the price and sends it to the seller.\r\n     *  Note that this does NOT transfer the ownership of the token.\r\n     */\r\n    function _bid(uint256 _tokenId, uint256 _bidAmount)\r\n        internal\r\n        returns (uint256)\r\n    {\r\n        // Gets a reference of the token from auction storage.\r\n        Auction storage auction = tokenIdToAuction[_tokenId];\r\n\r\n        // Checks that this auction is currently open\r\n        require(_isOnAuction(auction));\r\n\r\n        // Checks that the bid is greater than or equal to the current token price.\r\n        uint256 price = _currentPrice(auction);\r\n        require(_bidAmount >= price);\r\n\r\n        // Gets a reference of the seller before the auction gets deleted.\r\n        address seller = auction.seller;\r\n\r\n        // Removes the auction before sending the proceeds to the sender\r\n        _removeAuction(_tokenId);\r\n\r\n        // Transfers proceeds to the seller.\r\n        if (price > 0) {\r\n            uint256 auctioneerCut = _computeCut(price);\r\n            uint256 sellerProceeds = price.sub(auctioneerCut);\r\n\r\n            seller.transfer(sellerProceeds);\r\n        }\r\n\r\n        // Computes the excess funds included with the bid and transfers it back to bidder. \r\n        uint256 bidExcess = _bidAmount - price;\r\n\r\n        // Returns the exceeded funds.\r\n        msg.sender.transfer(bidExcess);\r\n\r\n        // Emits the AuctionSuccessful event.\r\n        emit AuctionSuccessful(_tokenId, price, msg.sender);\r\n\r\n        return price;\r\n    }\r\n\r\n    /**\r\n     * @dev Removes an auction from the list of open auctions.\r\n     * @param _tokenId ID of the NFT on auction to be removed.\r\n     */\r\n    function _removeAuction(uint256 _tokenId) internal {\r\n        delete tokenIdToAuction[_tokenId];\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the NFT is on auction.\r\n     * @param _auction An auction to check if it exists.\r\n     */\r\n    function _isOnAuction(Auction storage _auction) internal view returns (bool) {\r\n        return (_auction.startedAt > 0);\r\n    }\r\n\r\n    /// @dev Returns the current price of an NFT on auction.\r\n    function _currentPrice(Auction storage _auction)\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return _auction.price;\r\n    }\r\n\r\n    /**\r\n     * @dev Computes the owner's receiving amount from the sale.\r\n     * @param _price Sale price of the NFT.\r\n     */\r\n    function _computeCut(uint256 _price) internal view returns (uint256) {\r\n        return _price * ownerCut / 10000;\r\n    }\r\n}\r\n\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n\r\n  constructor() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    require(newOwner != address(0));\r\n    emit OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n}\r\n\r\ncontract Pausable is Ownable {\r\n  event Pause();\r\n  event Unpause();\r\n\r\n  bool public paused = false;\r\n\r\n  modifier whenNotPaused() {\r\n    require(!paused);\r\n    _;\r\n  }\r\n\r\n  modifier whenPaused() {\r\n    require(paused);\r\n    _;\r\n  }\r\n\r\n  function pause() onlyOwner whenNotPaused public {\r\n    paused = true;\r\n    emit Pause();\r\n  }\r\n\r\n  function unpause() onlyOwner whenPaused public {\r\n    paused = false;\r\n    emit Unpause();\r\n  }\r\n}\r\n\r\n/**\r\n * @title Auction for NFT.\r\n * @author VREX Lab Co., Ltd\r\n */\r\ncontract Auction is Pausable, AuctionBase {\r\n\r\n    /**\r\n     * @dev Removes all Ether from the contract to the NFT contract.\r\n     */\r\n    function withdrawBalance() external {\r\n        address nftAddress = address(nonFungibleContract);\r\n\r\n        require(\r\n            msg.sender == owner ||\r\n            msg.sender == nftAddress\r\n        );\r\n        nftAddress.transfer(address(this).balance);\r\n    }\r\n\r\n    /**\r\n     * @dev Creates and begins a new auction.\r\n     * @param _tokenId ID of the token to creat an auction, caller must be it's owner.\r\n     * @param _price Price of the token (in wei).\r\n     * @param _seller Seller of this token.\r\n     */\r\n    function createAuction(\r\n        uint256 _tokenId,\r\n        uint256 _price,\r\n        address _seller\r\n    )\r\n        external\r\n        whenNotPaused\r\n        canBeStoredWith128Bits(_price)\r\n    {\r\n        require(_owns(msg.sender, _tokenId));\r\n        _escrow(msg.sender, _tokenId);\r\n        Auction memory auction = Auction(\r\n            _seller,\r\n            uint128(_price),\r\n            uint64(now)\r\n        );\r\n        _addAuction(_tokenId, auction);\r\n    }\r\n\r\n    /**\r\n     * @dev Bids on an open auction, completing the auction and transferring\r\n     *  ownership of the NFT if enough Ether is supplied.\r\n     * @param _tokenId - ID of token to bid on.\r\n     */\r\n    function bid(uint256 _tokenId)\r\n        external\r\n        payable\r\n        whenNotPaused\r\n    {\r\n        _bid(_tokenId, msg.value);\r\n        _transfer(msg.sender, _tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Cancels an auction and returns the NFT to the current owner.\r\n     * @param _tokenId ID of the token on auction to cancel.\r\n     * @param _seller The seller's address.\r\n     */\r\n    function cancelAuction(uint256 _tokenId, address _seller)\r\n        external\r\n    {\r\n        // Requires that this function should only be called from the\r\n        // `cancelSaleAuction()` of NFT ownership contract. This function gets\r\n        // the _seller directly from it's arguments, so if this check doesn't\r\n        // exist, then anyone can cancel the auction! OMG!\r\n        require(msg.sender == address(nonFungibleContract));\r\n        Auction storage auction = tokenIdToAuction[_tokenId];\r\n        require(_isOnAuction(auction));\r\n        address seller = auction.seller;\r\n        require(_seller == seller);\r\n        _cancelAuction(_tokenId, seller);\r\n    }\r\n\r\n    /**\r\n     * @dev Cancels an auction when the contract is paused.\r\n     * Only the owner may do this, and NFTs are returned to the seller. \r\n     * @param _tokenId ID of the token on auction to cancel.\r\n     */\r\n    function cancelAuctionWhenPaused(uint256 _tokenId)\r\n        external\r\n        whenPaused\r\n        onlyOwner\r\n    {\r\n        Auction storage auction = tokenIdToAuction[_tokenId];\r\n        require(_isOnAuction(auction));\r\n        _cancelAuction(_tokenId, auction.seller);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the auction information for an NFT\r\n     * @param _tokenId ID of the NFT on auction\r\n     */\r\n    function getAuction(uint256 _tokenId)\r\n        external\r\n        view\r\n        returns\r\n    (\r\n        address seller,\r\n        uint256 price,\r\n        uint256 startedAt\r\n    ) {\r\n        Auction storage auction = tokenIdToAuction[_tokenId];\r\n        require(_isOnAuction(auction));\r\n        return (\r\n            auction.seller,\r\n            auction.price,\r\n            auction.startedAt\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the current price of the token on auction.\r\n     * @param _tokenId ID of the token\r\n     */\r\n    function getCurrentPrice(uint256 _tokenId)\r\n        external\r\n        view\r\n        returns (uint256)\r\n    {\r\n        Auction storage auction = tokenIdToAuction[_tokenId];\r\n        require(_isOnAuction(auction));\r\n        return _currentPrice(auction);\r\n    }\r\n}\r\n\r\n/**\r\n * @title  Auction for synthesizing\r\n * @author VREX Lab Co., Ltd\r\n * @notice Reset fallback function to prevent accidental fund sending to this contract.\r\n */\r\ncontract SynthesizingAuction is Auction {\r\n\r\n    /**\r\n     * @dev Sanity check that allows us to ensure that we are pointing to the\r\n     *  right auction in our `setSynthesizingAuctionAddress()` call.\r\n     */\r\n    bool public isSynthesizingAuction = true;\r\n\r\n    /**\r\n     * @dev Creates a reference to the NFT ownership contract and checks the owner cut is valid\r\n     * @param _nftAddress Address of a deployed NFT interface contract\r\n     * @param _cut Percent cut which the owner takes on each auction, between 0-10,000.\r\n     */\r\n    constructor(address _nftAddress, uint256 _cut) public {\r\n        require(_cut <= 10000);\r\n        ownerCut = _cut;\r\n\r\n        ERC721Basic candidateContract = ERC721Basic(_nftAddress);\r\n        nonFungibleContract = candidateContract;\r\n    }\r\n\r\n    /**\r\n     * @dev Creates and begins a new auction. Since this function is wrapped,\r\n     *  requires the caller to be KydyCore contract.\r\n     * @param _tokenId ID of token to auction, sender must be it's owner.\r\n     * @param _price Price of the token (in wei).\r\n     * @param _seller Seller of this token.\r\n     */\r\n    function createAuction(\r\n        uint256 _tokenId,\r\n        uint256 _price,\r\n        address _seller\r\n    )\r\n        external\r\n        canBeStoredWith128Bits(_price)\r\n    {\r\n        require(msg.sender == address(nonFungibleContract));\r\n        _escrow(_seller, _tokenId);\r\n        Auction memory auction = Auction(\r\n            _seller,\r\n            uint128(_price),\r\n            uint64(now)\r\n        );\r\n        _addAuction(_tokenId, auction);\r\n    }\r\n\r\n    /**\r\n     * @dev Places a bid for synthesizing. Requires the caller\r\n     *  is the KydyCore contract because all bid functions\r\n     *  should be wrapped. Also returns the Kydy to the\r\n     *  seller rather than the bidder.\r\n     */\r\n    function bid(uint256 _tokenId)\r\n        external\r\n        payable\r\n    {\r\n        require(msg.sender == address(nonFungibleContract));\r\n        address seller = tokenIdToAuction[_tokenId].seller;\r\n        // _bid() checks that the token ID is valid and will throw if bid fails\r\n        _bid(_tokenId, msg.value);\r\n        // Transfers the Kydy back to the seller, and the bidder will get\r\n        // the baby Kydy.\r\n        _transfer(seller, _tokenId);\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC721Received\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes4\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"bid\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_seller\",\"type\":\"address\"}],\"name\":\"cancelAuction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_price\",\"type\":\"uint256\"},{\"name\":\"_seller\",\"type\":\"address\"}],\"name\":\"createAuction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawBalance\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getAuction\",\"outputs\":[{\"name\":\"seller\",\"type\":\"address\"},{\"name\":\"price\",\"type\":\"uint256\"},{\"name\":\"startedAt\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ownerCut\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"cancelAuctionWhenPaused\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isSynthesizingAuction\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getCurrentPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nonFungibleContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_nftAddress\",\"type\":\"address\"},{\"name\":\"_cut\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"AuctionCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"totalPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"bidder\",\"type\":\"address\"}],\"name\":\"AuctionSuccessful\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"AuctionCanceled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"SynthesizingAuction","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000d90f5ebc01914bbd357b754956aafb199f4d162400000000000000000000000000000000000000000000000000000000000001f4","Library":"","SwarmSource":"bzzr://c21c651559ea1d568d501f4177d53b24d579ae5363e28ae8c240938a05146a82"}]}