{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.0;\r\n\r\n// File: openzeppelin-solidity/contracts/math/SafeMath.sol\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Unsigned math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n    * @dev Multiplies two unsigned integers, reverts on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two unsigned integers, reverts on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\r\n    * reverts when dividing by zero.\r\n    */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n     * account.\r\n     */\r\n    constructor () internal {\r\n        _owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), _owner);\r\n    }\r\n\r\n    /**\r\n     * @return the address of the owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner());\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @return true if `msg.sender` is the owner of the contract.\r\n     */\r\n    function isOwner() public view returns (bool) {\r\n        return msg.sender == _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to relinquish control of the contract.\r\n     * @notice Renouncing to ownership will leave the contract without an owner.\r\n     * It will not be possible to call the functions with the `onlyOwner`\r\n     * modifier anymore.\r\n     */\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0));\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC20/IERC20.sol\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ninterface IERC20 {\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n\r\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address who) external view returns (uint256);\r\n\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC20/ERC20.sol\r\n\r\n/**\r\n * @title Standard ERC20 token\r\n *\r\n * @dev Implementation of the basic standard token.\r\n * https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md\r\n * Originally based on code by FirstBlood:\r\n * https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\r\n *\r\n * This implementation emits additional Approval events, allowing applications to reconstruct the allowance status for\r\n * all accounts just by listening to said events. Note that this isn't required by the specification, and other\r\n * compliant implementations may not do it.\r\n */\r\ncontract ERC20 is IERC20 {\r\n    using SafeMath for uint256;\r\n\r\n    mapping (address => uint256) private _balances;\r\n\r\n    mapping (address => mapping (address => uint256)) private _allowed;\r\n\r\n    uint256 private _totalSupply;\r\n\r\n    /**\r\n    * @dev Total number of tokens in existence\r\n    */\r\n    function totalSupply() public view returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    /**\r\n    * @dev Gets the balance of the specified address.\r\n    * @param owner The address to query the balance of.\r\n    * @return An uint256 representing the amount owned by the passed address.\r\n    */\r\n    function balanceOf(address owner) public view returns (uint256) {\r\n        return _balances[owner];\r\n    }\r\n\r\n    /**\r\n     * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n     * @param owner address The address which owns the funds.\r\n     * @param spender address The address which will spend the funds.\r\n     * @return A uint256 specifying the amount of tokens still available for the spender.\r\n     */\r\n    function allowance(address owner, address spender) public view returns (uint256) {\r\n        return _allowed[owner][spender];\r\n    }\r\n\r\n    /**\r\n    * @dev Transfer token for a specified address\r\n    * @param to The address to transfer to.\r\n    * @param value The amount to be transferred.\r\n    */\r\n    function transfer(address to, uint256 value) public returns (bool) {\r\n        _transfer(msg.sender, to, value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n     * Beware that changing an allowance with this method brings the risk that someone may use both the old\r\n     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\r\n     * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     * @param spender The address which will spend the funds.\r\n     * @param value The amount of tokens to be spent.\r\n     */\r\n    function approve(address spender, uint256 value) public returns (bool) {\r\n        require(spender != address(0));\r\n\r\n        _allowed[msg.sender][spender] = value;\r\n        emit Approval(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Transfer tokens from one address to another.\r\n     * Note that while this function emits an Approval event, this is not required as per the specification,\r\n     * and other compliant implementations may not emit the event.\r\n     * @param from address The address which you want to send tokens from\r\n     * @param to address The address which you want to transfer to\r\n     * @param value uint256 the amount of tokens to be transferred\r\n     */\r\n    function transferFrom(address from, address to, uint256 value) public returns (bool) {\r\n        _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);\r\n        _transfer(from, to, value);\r\n        emit Approval(from, msg.sender, _allowed[from][msg.sender]);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Increase the amount of tokens that an owner allowed to a spender.\r\n     * approve should be called when allowed_[_spender] == 0. To increment\r\n     * allowed value is better to use this function to avoid 2 calls (and wait until\r\n     * the first transaction is mined)\r\n     * From MonolithDAO Token.sol\r\n     * Emits an Approval event.\r\n     * @param spender The address which will spend the funds.\r\n     * @param addedValue The amount of tokens to increase the allowance by.\r\n     */\r\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\r\n        require(spender != address(0));\r\n\r\n        _allowed[msg.sender][spender] = _allowed[msg.sender][spender].add(addedValue);\r\n        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Decrease the amount of tokens that an owner allowed to a spender.\r\n     * approve should be called when allowed_[_spender] == 0. To decrement\r\n     * allowed value is better to use this function to avoid 2 calls (and wait until\r\n     * the first transaction is mined)\r\n     * From MonolithDAO Token.sol\r\n     * Emits an Approval event.\r\n     * @param spender The address which will spend the funds.\r\n     * @param subtractedValue The amount of tokens to decrease the allowance by.\r\n     */\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\r\n        require(spender != address(0));\r\n\r\n        _allowed[msg.sender][spender] = _allowed[msg.sender][spender].sub(subtractedValue);\r\n        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev Transfer token for a specified addresses\r\n    * @param from The address to transfer from.\r\n    * @param to The address to transfer to.\r\n    * @param value The amount to be transferred.\r\n    */\r\n    function _transfer(address from, address to, uint256 value) internal {\r\n        require(to != address(0));\r\n\r\n        _balances[from] = _balances[from].sub(value);\r\n        _balances[to] = _balances[to].add(value);\r\n        emit Transfer(from, to, value);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function that mints an amount of the token and assigns it to\r\n     * an account. This encapsulates the modification of balances such that the\r\n     * proper events are emitted.\r\n     * @param account The account that will receive the created tokens.\r\n     * @param value The amount that will be created.\r\n     */\r\n    function _mint(address account, uint256 value) internal {\r\n        require(account != address(0));\r\n\r\n        _totalSupply = _totalSupply.add(value);\r\n        _balances[account] = _balances[account].add(value);\r\n        emit Transfer(address(0), account, value);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function that burns an amount of the token of a given\r\n     * account.\r\n     * @param account The account whose tokens will be burnt.\r\n     * @param value The amount that will be burnt.\r\n     */\r\n    function _burn(address account, uint256 value) internal {\r\n        require(account != address(0));\r\n\r\n        _totalSupply = _totalSupply.sub(value);\r\n        _balances[account] = _balances[account].sub(value);\r\n        emit Transfer(account, address(0), value);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function that burns an amount of the token of a given\r\n     * account, deducting from the sender's allowance for said account. Uses the\r\n     * internal burn function.\r\n     * Emits an Approval event (reflecting the reduced allowance).\r\n     * @param account The account whose tokens will be burnt.\r\n     * @param value The amount that will be burnt.\r\n     */\r\n    function _burnFrom(address account, uint256 value) internal {\r\n        _allowed[account][msg.sender] = _allowed[account][msg.sender].sub(value);\r\n        _burn(account, value);\r\n        emit Approval(account, msg.sender, _allowed[account][msg.sender]);\r\n    }\r\n}\r\n\r\n// File: contracts/assettoken/library/AssetTokenL.sol\r\n\r\n/*\r\n    Copyright 2018, CONDA\r\n\r\n    This program is free software: you can redistribute it and/or modify\r\n    it under the terms of the GNU General Public License as published by\r\n    the Free Software Foundation, either version 3 of the License, or\r\n    (at your option) any later version.\r\n\r\n    This program is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n    GNU General Public License for more details.\r\n\r\n    You should have received a copy of the GNU General Public License\r\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n*/\r\n\r\n\r\n\r\n/** @title AssetTokenL library. */\r\nlibrary AssetTokenL {\r\n    using SafeMath for uint256;\r\n\r\n///////////////////\r\n// Struct Parameters (passed as parameter to library)\r\n///////////////////\r\n\r\n    struct Supply {\r\n        // `balances` is the map that tracks the balance of each address, in this\r\n        // contract when the balance changes. TransfersAndMints-index when the change\r\n        // occurred is also included\r\n        mapping (address => Checkpoint[]) balances;\r\n\r\n        // Tracks the history of the `totalSupply` of the token\r\n        Checkpoint[] totalSupplyHistory;\r\n\r\n        // `allowed` tracks any extra transfer rights as in all ERC20 tokens\r\n        mapping (address => mapping (address => uint256)) allowed;\r\n\r\n        // Minting cap max amount of tokens\r\n        uint256 cap;\r\n\r\n        // When successfully funded\r\n        uint256 goal;\r\n\r\n        //crowdsale start\r\n        uint256 startTime;\r\n\r\n        //crowdsale end\r\n        uint256 endTime;\r\n\r\n        //crowdsale dividends\r\n        Dividend[] dividends;\r\n\r\n        //counter per address how much was claimed in continuous way\r\n        //note: counter also increases when recycled and tried to claim in continous way\r\n        mapping (address => uint256) dividendsClaimed;\r\n\r\n        uint256 tokenActionIndex; //only modify within library\r\n    }\r\n\r\n    struct Availability {\r\n        // Flag that determines if the token is yet alive.\r\n        // Meta data cannot be changed anymore (except capitalControl)\r\n        bool tokenAlive;\r\n\r\n        // Flag that determines if the token is transferable or not.\r\n        bool transfersEnabled;\r\n\r\n        // Flag that minting is finished\r\n        bool mintingPhaseFinished;\r\n\r\n        // Flag that minting is paused\r\n        bool mintingPaused;\r\n    }\r\n\r\n    struct Roles {\r\n        // role that can pause/resume\r\n        address pauseControl;\r\n\r\n        // role that can rescue accidentally sent tokens\r\n        address tokenRescueControl;\r\n\r\n        // role that can mint during crowdsale (usually controller)\r\n        address mintControl;\r\n    }\r\n\r\n///////////////////\r\n// Structs (saved to blockchain)\r\n///////////////////\r\n\r\n    /// @dev `Dividend` is the structure that saves the status of a dividend distribution\r\n    struct Dividend {\r\n        uint256 currentTokenActionIndex;\r\n        uint256 timestamp;\r\n        DividendType dividendType;\r\n        address dividendToken;\r\n        uint256 amount;\r\n        uint256 claimedAmount;\r\n        uint256 totalSupply;\r\n        bool recycled;\r\n        mapping (address => bool) claimed;\r\n    }\r\n\r\n    /// @dev Dividends can be of those types.\r\n    enum DividendType { Ether, ERC20 }\r\n\r\n    /** @dev Checkpoint` is the structure that attaches a history index to a given value\r\n      * @notice That uint128 is used instead of uint/uint256. That's to save space. Should be big enough (feedback from audit)\r\n      */\r\n    struct Checkpoint {\r\n\r\n        // `currentTokenActionIndex` is the index when the value was generated. It's uint128 to save storage space\r\n        uint128 currentTokenActionIndex;\r\n\r\n        // `value` is the amount of tokens at a specific index. It's uint128 to save storage space\r\n        uint128 value;\r\n    }\r\n\r\n///////////////////\r\n// Functions\r\n///////////////////\r\n\r\n    /// @dev This is the actual transfer function in the token contract, it can\r\n    ///  only be called by other functions in this contract. Check for availability must be done before.\r\n    /// @param _from The address holding the tokens being transferred\r\n    /// @param _to The address of the recipient\r\n    /// @param _amount The amount of tokens to be transferred\r\n    /// @return True if the transfer was successful\r\n    function doTransfer(Supply storage _self, Availability storage /*_availability*/, address _from, address _to, uint256 _amount) public {\r\n        // Do not allow transfer to 0x0 or the token contract itself\r\n        require(_to != address(0), \"addr0\");\r\n        require(_to != address(this), \"target self\");\r\n\r\n        // If the amount being transfered is more than the balance of the\r\n        //  account the transfer throws\r\n        uint256 previousBalanceFrom = balanceOfNow(_self, _from);\r\n        require(previousBalanceFrom >= _amount, \"not enough\");\r\n\r\n        // First update the balance array with the new value for the address\r\n        //  sending the tokens\r\n        updateValueAtNow(_self, _self.balances[_from], previousBalanceFrom.sub(_amount));\r\n\r\n        // Then update the balance array with the new value for the address\r\n        //  receiving the tokens\r\n        uint256 previousBalanceTo = balanceOfNow(_self, _to);\r\n        \r\n        updateValueAtNow(_self, _self.balances[_to], previousBalanceTo.add(_amount));\r\n\r\n        //info: don't move this line inside updateValueAtNow (because transfer is 2 actions)\r\n        increaseTokenActionIndex(_self);\r\n\r\n        // An event to make the transfer easy to find on the blockchain\r\n        emit Transfer(_from, _to, _amount);\r\n    }\r\n\r\n    function increaseTokenActionIndex(Supply storage _self) private {\r\n        _self.tokenActionIndex = _self.tokenActionIndex.add(1);\r\n\r\n        emit TokenActionIndexIncreased(_self.tokenActionIndex, block.number);\r\n    }\r\n\r\n    /// @notice `msg.sender` approves `_spender` to spend `_amount` of his tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @param _amount The amount of tokens to be approved for transfer\r\n    /// @return True if the approval was successful\r\n    function approve(Supply storage _self, address _spender, uint256 _amount) public returns (bool success) {\r\n        // To change the approve amount you first have to reduce the addresses`\r\n        //  allowance to zero by calling `approve(_spender,0)` if it is not\r\n        //  already 0 to mitigate the race condition described here:\r\n        //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n        require((_amount == 0) || (_self.allowed[msg.sender][_spender] == 0), \"amount\");\r\n\r\n        _self.allowed[msg.sender][_spender] = _amount;\r\n        emit Approval(msg.sender, _spender, _amount);\r\n        return true;\r\n    }\r\n\r\n    /// @notice Increase the amount of tokens that an owner allowed to a spender.\r\n    /// @dev approve should be called when allowed[_spender] == 0. To increment\r\n    ///  allowed value is better to use this function to avoid 2 calls (and wait until\r\n    ///  the first transaction is mined)\r\n    ///  From MonolithDAO Token.sol\r\n    /// @param _spender The address which will spend the funds.\r\n    /// @param _addedValue The amount of tokens to increase the allowance by.\r\n    /// @return True if the approval was successful\r\n    function increaseApproval(Supply storage _self, address _spender, uint256 _addedValue) public returns (bool) {\r\n        _self.allowed[msg.sender][_spender] = _self.allowed[msg.sender][_spender].add(_addedValue);\r\n        emit Approval(msg.sender, _spender, _self.allowed[msg.sender][_spender]);\r\n        return true;\r\n    }\r\n\r\n    /// @notice Decrease the amount of tokens that an owner allowed to a spender.\r\n    /// @dev approve should be called when allowed[_spender] == 0. To decrement\r\n    ///  allowed value is better to use this function to avoid 2 calls (and wait until\r\n    ///  the first transaction is mined)\r\n    ///  From MonolithDAO Token.sol\r\n    /// @param _spender The address which will spend the funds.\r\n    /// @param _subtractedValue The amount of tokens to decrease the allowance by.\r\n    /// @return True if the approval was successful\r\n    function decreaseApproval(Supply storage _self, address _spender, uint256 _subtractedValue) public returns (bool) {\r\n        uint256 oldValue = _self.allowed[msg.sender][_spender];\r\n        if (_subtractedValue > oldValue) {\r\n            _self.allowed[msg.sender][_spender] = 0;\r\n        } else {\r\n            _self.allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\r\n        }\r\n        emit Approval(msg.sender, _spender, _self.allowed[msg.sender][_spender]);\r\n        return true;\r\n    }\r\n\r\n    /// @notice Send `_amount` tokens to `_to` from `_from` if it is approved by `_from`\r\n    /// @param _from The address holding the tokens being transferred\r\n    /// @param _to The address of the recipient\r\n    /// @param _amount The amount of tokens to be transferred\r\n    /// @return True if the transfer was successful\r\n    function transferFrom(Supply storage _supply, Availability storage _availability, address _from, address _to, uint256 _amount) \r\n    public \r\n    returns (bool success) \r\n    {\r\n        // The standard ERC 20 transferFrom functionality\r\n        require(_supply.allowed[_from][msg.sender] >= _amount, \"allowance\");\r\n        _supply.allowed[_from][msg.sender] = _supply.allowed[_from][msg.sender].sub(_amount);\r\n\r\n        doTransfer(_supply, _availability, _from, _to, _amount);\r\n        return true;\r\n    }\r\n\r\n    /// @notice Send `_amount` tokens to `_to` from `_from` WITHOUT approval. UseCase: notar transfers from lost wallet\r\n    /// @param _from The address holding the tokens being transferred\r\n    /// @param _to The address of the recipient\r\n    /// @param _amount The amount of tokens to be transferred\r\n    /// @param _fullAmountRequired Full amount required (causes revert if not).\r\n    /// @return True if the transfer was successful\r\n    function enforcedTransferFrom(\r\n        Supply storage _self, \r\n        Availability storage _availability, \r\n        address _from, \r\n        address _to, \r\n        uint256 _amount, \r\n        bool _fullAmountRequired) \r\n    public \r\n    returns (bool success) \r\n    {\r\n        if(_fullAmountRequired && _amount != balanceOfNow(_self, _from))\r\n        {\r\n            revert(\"Only full amount in case of lost wallet is allowed\");\r\n        }\r\n\r\n        doTransfer(_self, _availability, _from, _to, _amount);\r\n\r\n        emit SelfApprovedTransfer(msg.sender, _from, _to, _amount);\r\n\r\n        return true;\r\n    }\r\n\r\n////////////////\r\n// Miniting \r\n////////////////\r\n\r\n    /// @notice Function to mint tokens\r\n    /// @param _to The address that will receive the minted tokens.\r\n    /// @param _amount The amount of tokens to mint.\r\n    /// @return A boolean that indicates if the operation was successful.\r\n    function mint(Supply storage _self, address _to, uint256 _amount) public returns (bool) {\r\n        uint256 curTotalSupply = totalSupplyNow(_self);\r\n        uint256 previousBalanceTo = balanceOfNow(_self, _to);\r\n\r\n        // Check cap\r\n        require(curTotalSupply.add(_amount) <= _self.cap, \"cap\"); //leave inside library to never go over cap\r\n\r\n        // Check timeframe\r\n        require(_self.startTime <= now, \"too soon\");\r\n        require(_self.endTime >= now, \"too late\");\r\n\r\n        updateValueAtNow(_self, _self.totalSupplyHistory, curTotalSupply.add(_amount));\r\n        updateValueAtNow(_self, _self.balances[_to], previousBalanceTo.add(_amount));\r\n\r\n        //info: don't move this line inside updateValueAtNow (because transfer is 2 actions)\r\n        increaseTokenActionIndex(_self);\r\n\r\n        emit MintDetailed(msg.sender, _to, _amount);\r\n        emit Transfer(address(0), _to, _amount);\r\n\r\n        return true;\r\n    }\r\n\r\n////////////////\r\n// Query balance and totalSupply in History\r\n////////////////\r\n\r\n    /// @dev Queries the balance of `_owner` at `_specificTransfersAndMintsIndex`\r\n    /// @param _owner The address from which the balance will be retrieved\r\n    /// @param _specificTransfersAndMintsIndex The balance at index\r\n    /// @return The balance at `_specificTransfersAndMintsIndex`\r\n    function balanceOfAt(Supply storage _self, address _owner, uint256 _specificTransfersAndMintsIndex) public view returns (uint256) {\r\n        return getValueAt(_self.balances[_owner], _specificTransfersAndMintsIndex);\r\n    }\r\n\r\n    function balanceOfNow(Supply storage _self, address _owner) public view returns (uint256) {\r\n        return getValueAt(_self.balances[_owner], _self.tokenActionIndex);\r\n    }\r\n\r\n    /// @dev Total amount of tokens at `_specificTransfersAndMintsIndex`.\r\n    /// @param _specificTransfersAndMintsIndex The totalSupply at index\r\n    /// @return The total amount of tokens at `_specificTransfersAndMintsIndex`\r\n    function totalSupplyAt(Supply storage _self, uint256 _specificTransfersAndMintsIndex) public view returns(uint256) {\r\n        return getValueAt(_self.totalSupplyHistory, _specificTransfersAndMintsIndex);\r\n    }\r\n\r\n    function totalSupplyNow(Supply storage _self) public view returns(uint256) {\r\n        return getValueAt(_self.totalSupplyHistory, _self.tokenActionIndex);\r\n    }\r\n\r\n////////////////\r\n// Internal helper functions to query and set a value in a snapshot array\r\n////////////////\r\n\r\n    /// @dev `getValueAt` retrieves the number of tokens at a given index\r\n    /// @param checkpoints The history of values being queried\r\n    /// @param _specificTransfersAndMintsIndex The index to retrieve the history checkpoint value at\r\n    /// @return The number of tokens being queried\r\n    function getValueAt(Checkpoint[] storage checkpoints, uint256 _specificTransfersAndMintsIndex) private view returns (uint256) { \r\n        \r\n        //  requested before a check point was ever created for this token\r\n        if (checkpoints.length == 0 || checkpoints[0].currentTokenActionIndex > _specificTransfersAndMintsIndex) {\r\n            return 0;\r\n        }\r\n\r\n        // Shortcut for the actual value\r\n        if (_specificTransfersAndMintsIndex >= checkpoints[checkpoints.length-1].currentTokenActionIndex) {\r\n            return checkpoints[checkpoints.length-1].value;\r\n        }\r\n\r\n        // Binary search of the value in the array\r\n        uint256 min = 0;\r\n        uint256 max = checkpoints.length-1;\r\n        while (max > min) {\r\n            uint256 mid = (max + min + 1)/2;\r\n            if (checkpoints[mid].currentTokenActionIndex<=_specificTransfersAndMintsIndex) {\r\n                min = mid;\r\n            } else {\r\n                max = mid-1;\r\n            }\r\n        }\r\n        return checkpoints[min].value;\r\n    }\r\n\r\n    /// @dev `updateValueAtNow` used to update the `balances` map and the `totalSupplyHistory`\r\n    /// @param checkpoints The history of data being updated\r\n    /// @param _value The new number of tokens\r\n    function updateValueAtNow(Supply storage _self, Checkpoint[] storage checkpoints, uint256 _value) private {\r\n        require(_value == uint128(_value), \"invalid cast1\");\r\n        require(_self.tokenActionIndex == uint128(_self.tokenActionIndex), \"invalid cast2\");\r\n\r\n        checkpoints.push(Checkpoint(\r\n            uint128(_self.tokenActionIndex),\r\n            uint128(_value)\r\n        ));\r\n    }\r\n\r\n    /// @dev Function to stop minting new tokens.\r\n    /// @return True if the operation was successful.\r\n    function finishMinting(Availability storage _self) public returns (bool) {\r\n        if(_self.mintingPhaseFinished) {\r\n            return false;\r\n        }\r\n\r\n        _self.mintingPhaseFinished = true;\r\n        emit MintFinished(msg.sender);\r\n        return true;\r\n    }\r\n\r\n    /// @notice Reopening crowdsale means minting is again possible. UseCase: notary approves and does that.\r\n    /// @return True if the operation was successful.\r\n    function reopenCrowdsale(Availability storage _self) public returns (bool) {\r\n        if(_self.mintingPhaseFinished == false) {\r\n            return false;\r\n        }\r\n\r\n        _self.mintingPhaseFinished = false;\r\n        emit Reopened(msg.sender);\r\n        return true;\r\n    }\r\n\r\n    /// @notice Set roles/operators.\r\n    /// @param _pauseControl pause control.\r\n    /// @param _tokenRescueControl token rescue control (accidentally assigned tokens).\r\n    function setRoles(Roles storage _self, address _pauseControl, address _tokenRescueControl) public {\r\n        require(_pauseControl != address(0), \"addr0\");\r\n        require(_tokenRescueControl != address(0), \"addr0\");\r\n        \r\n        _self.pauseControl = _pauseControl;\r\n        _self.tokenRescueControl = _tokenRescueControl;\r\n\r\n        emit RolesChanged(msg.sender, _pauseControl, _tokenRescueControl);\r\n    }\r\n\r\n    /// @notice Set mint control.\r\n    function setMintControl(Roles storage _self, address _mintControl) public {\r\n        require(_mintControl != address(0), \"addr0\");\r\n\r\n        _self.mintControl = _mintControl;\r\n\r\n        emit MintControlChanged(msg.sender, _mintControl);\r\n    }\r\n\r\n    /// @notice Set token alive which can be seen as not in draft state anymore.\r\n    function setTokenAlive(Availability storage _self) public {\r\n        _self.tokenAlive = true;\r\n    }\r\n\r\n////////////////\r\n// Pausing token for unforeseen reasons\r\n////////////////\r\n\r\n    /// @notice pause transfer.\r\n    /// @param _transfersEnabled True if transfers are allowed.\r\n    function pauseTransfer(Availability storage _self, bool _transfersEnabled) public\r\n    {\r\n        _self.transfersEnabled = _transfersEnabled;\r\n\r\n        if(_transfersEnabled) {\r\n            emit TransferResumed(msg.sender);\r\n        } else {\r\n            emit TransferPaused(msg.sender);\r\n        }\r\n    }\r\n\r\n    /// @notice calling this can enable/disable capital increase/decrease flag\r\n    /// @param _mintingEnabled True if minting is allowed\r\n    function pauseCapitalIncreaseOrDecrease(Availability storage _self, bool _mintingEnabled) public\r\n    {\r\n        _self.mintingPaused = (_mintingEnabled == false);\r\n\r\n        if(_mintingEnabled) {\r\n            emit MintingResumed(msg.sender);\r\n        } else {\r\n            emit MintingPaused(msg.sender);\r\n        }\r\n    }\r\n\r\n    /// @notice Receives ether to be distriubted to all token owners\r\n    function depositDividend(Supply storage _self, uint256 msgValue)\r\n    public \r\n    {\r\n        require(msgValue > 0, \"amount0\");\r\n\r\n        // gets the current number of total token distributed\r\n        uint256 currentSupply = totalSupplyNow(_self);\r\n\r\n        // a deposit without investment would end up in unclaimable deposit for token holders\r\n        require(currentSupply > 0, \"0investors\");\r\n\r\n        // creates a new index for the dividends\r\n        uint256 dividendIndex = _self.dividends.length;\r\n\r\n        // Stores the current meta data for the dividend payout\r\n        _self.dividends.push(\r\n            Dividend(\r\n                _self.tokenActionIndex, // current index used for claiming\r\n                block.timestamp, // Timestamp of the distribution\r\n                DividendType.Ether, // Type of dividends\r\n                address(0),\r\n                msgValue, // Total amount that has been distributed\r\n                0, // amount that has been claimed\r\n                currentSupply, // Total supply now\r\n                false // Already recylced\r\n            )\r\n        );\r\n        emit DividendDeposited(msg.sender, _self.tokenActionIndex, msgValue, currentSupply, dividendIndex);\r\n    }\r\n\r\n    /// @notice Receives ERC20 to be distriubted to all token owners\r\n    function depositERC20Dividend(Supply storage _self, address _dividendToken, uint256 _amount, address baseCurrency)\r\n    public\r\n    {\r\n        require(_amount > 0, \"amount0\");\r\n        require(_dividendToken == baseCurrency, \"not baseCurrency\");\r\n\r\n        // gets the current number of total token distributed\r\n        uint256 currentSupply = totalSupplyNow(_self);\r\n\r\n        // a deposit without investment would end up in unclaimable deposit for token holders\r\n        require(currentSupply > 0, \"0investors\");\r\n\r\n        // creates a new index for the dividends\r\n        uint256 dividendIndex = _self.dividends.length;\r\n\r\n        // Stores the current meta data for the dividend payout\r\n        _self.dividends.push(\r\n            Dividend(\r\n                _self.tokenActionIndex, // index that counts up on transfers and mints\r\n                block.timestamp, // Timestamp of the distribution\r\n                DividendType.ERC20, \r\n                _dividendToken, \r\n                _amount, // Total amount that has been distributed\r\n                0, // amount that has been claimed\r\n                currentSupply, // Total supply now\r\n                false // Already recylced\r\n            )\r\n        );\r\n\r\n        // it shouldn't return anything but according to ERC20 standard it could if badly implemented\r\n        // IMPORTANT: potentially a call with reentrance -> do at the end\r\n        require(ERC20(_dividendToken).transferFrom(msg.sender, address(this), _amount), \"transferFrom\");\r\n\r\n        emit DividendDeposited(msg.sender, _self.tokenActionIndex, _amount, currentSupply, dividendIndex);\r\n    }\r\n\r\n    /// @notice Function to claim dividends for msg.sender\r\n    /// @dev dividendsClaimed should not be handled here.\r\n    function claimDividend(Supply storage _self, uint256 _dividendIndex) public {\r\n        // Loads the details for the specific Dividend payment\r\n        Dividend storage dividend = _self.dividends[_dividendIndex];\r\n\r\n        // Devidends should not have been claimed already\r\n        require(dividend.claimed[msg.sender] == false, \"claimed\");\r\n\r\n         // Devidends should not have been recycled already\r\n        require(dividend.recycled == false, \"recycled\");\r\n\r\n        // get the token balance at the time of the dividend distribution\r\n        uint256 balance = balanceOfAt(_self, msg.sender, dividend.currentTokenActionIndex.sub(1));\r\n\r\n        // calculates the amount of dividends that can be claimed\r\n        uint256 claim = balance.mul(dividend.amount).div(dividend.totalSupply);\r\n\r\n        // flag that dividends have been claimed\r\n        dividend.claimed[msg.sender] = true;\r\n        dividend.claimedAmount = SafeMath.add(dividend.claimedAmount, claim);\r\n\r\n        claimThis(dividend.dividendType, _dividendIndex, msg.sender, claim, dividend.dividendToken);\r\n    }\r\n\r\n    /// @notice Claim all dividends.\r\n    /// @dev dividendsClaimed counter should only increase when claimed in hole-free way.\r\n    function claimDividendAll(Supply storage _self) public {\r\n        claimLoopInternal(_self, _self.dividendsClaimed[msg.sender], (_self.dividends.length-1));\r\n    }\r\n\r\n    /// @notice Claim dividends in batches. In case claimDividendAll runs out of gas.\r\n    /// @dev dividendsClaimed counter should only increase when claimed in hole-free way.\r\n    /// @param _startIndex start index (inclusive number).\r\n    /// @param _endIndex end index (inclusive number).\r\n    function claimInBatches(Supply storage _self, uint256 _startIndex, uint256 _endIndex) public {\r\n        claimLoopInternal(_self, _startIndex, _endIndex);\r\n    }\r\n\r\n    /// @notice Claim loop of batch claim and claim all.\r\n    /// @dev dividendsClaimed counter should only increase when claimed in hole-free way.\r\n    /// @param _startIndex start index (inclusive number).\r\n    /// @param _endIndex end index (inclusive number).\r\n    function claimLoopInternal(Supply storage _self, uint256 _startIndex, uint256 _endIndex) private {\r\n        require(_startIndex <= _endIndex, \"start after end\");\r\n\r\n        //early exit if already claimed\r\n        require(_self.dividendsClaimed[msg.sender] < _self.dividends.length, \"all claimed\");\r\n\r\n        uint256 dividendsClaimedTemp = _self.dividendsClaimed[msg.sender];\r\n\r\n        // Cycle through all dividend distributions and make the payout\r\n        for (uint256 i = _startIndex; i <= _endIndex; i++) {\r\n            if (_self.dividends[i].recycled == true) {\r\n                //recycled and tried to claim in continuous way internally counts as claimed\r\n                dividendsClaimedTemp = SafeMath.add(i, 1);\r\n            }\r\n            else if (_self.dividends[i].claimed[msg.sender] == false) {\r\n                dividendsClaimedTemp = SafeMath.add(i, 1);\r\n                claimDividend(_self, i);\r\n            }\r\n        }\r\n\r\n        // This is done after the loop to reduce writes.\r\n        // Remembers what has been claimed after hole-free claiming procedure.\r\n        // IMPORTANT: do only if batch claim docks on previous claim to avoid unexpected claim all behaviour.\r\n        if(_startIndex <= _self.dividendsClaimed[msg.sender]) {\r\n            _self.dividendsClaimed[msg.sender] = dividendsClaimedTemp;\r\n        }\r\n    }\r\n\r\n    /// @notice Dividends which have not been claimed can be claimed by owner after timelock (to avoid loss)\r\n    /// @param _dividendIndex index of dividend to recycle.\r\n    /// @param _recycleLockedTimespan timespan required until possible.\r\n    /// @param _currentSupply current supply.\r\n    function recycleDividend(Supply storage _self, uint256 _dividendIndex, uint256 _recycleLockedTimespan, uint256 _currentSupply) public {\r\n        // Get the dividend distribution\r\n        Dividend storage dividend = _self.dividends[_dividendIndex];\r\n\r\n        // should not have been recycled already\r\n        require(dividend.recycled == false, \"recycled\");\r\n\r\n        // The recycle time has to be over\r\n        require(dividend.timestamp < SafeMath.sub(block.timestamp, _recycleLockedTimespan), \"timeUp\");\r\n\r\n        // Devidends should not have been claimed already\r\n        require(dividend.claimed[msg.sender] == false, \"claimed\");\r\n\r\n        //\r\n        //refund\r\n        //\r\n\r\n        // The amount, which has not been claimed is distributed to token owner\r\n        _self.dividends[_dividendIndex].recycled = true;\r\n\r\n        // calculates the amount of dividends that can be claimed\r\n        uint256 claim = SafeMath.sub(dividend.amount, dividend.claimedAmount);\r\n\r\n        // flag that dividends have been claimed\r\n        dividend.claimed[msg.sender] = true;\r\n        dividend.claimedAmount = SafeMath.add(dividend.claimedAmount, claim);\r\n\r\n        claimThis(dividend.dividendType, _dividendIndex, msg.sender, claim, dividend.dividendToken);\r\n\r\n        emit DividendRecycled(msg.sender, _self.tokenActionIndex, claim, _currentSupply, _dividendIndex);\r\n    }\r\n\r\n    /// @dev the core claim function of single dividend.\r\n    function claimThis(DividendType _dividendType, uint256 _dividendIndex, address payable _beneficiary, uint256 _claim, address _dividendToken) \r\n    private \r\n    {\r\n        // transfer the dividends to the token holder\r\n        if (_claim > 0) {\r\n            if (_dividendType == DividendType.Ether) { \r\n                _beneficiary.transfer(_claim);\r\n            } \r\n            else if (_dividendType == DividendType.ERC20) { \r\n                require(ERC20(_dividendToken).transfer(_beneficiary, _claim), \"transfer\");\r\n            }\r\n            else {\r\n                revert(\"unknown type\");\r\n            }\r\n\r\n            emit DividendClaimed(_beneficiary, _dividendIndex, _claim);\r\n        }\r\n    }\r\n\r\n    /// @notice If this contract gets a balance in some other ERC20 contract - or even iself - then we can rescue it.\r\n    /// @param _foreignTokenAddress token where contract has balance.\r\n    /// @param _to the beneficiary.\r\n    function rescueToken(Availability storage _self, address _foreignTokenAddress, address _to) public\r\n    {\r\n        require(_self.mintingPhaseFinished, \"unfinished\");\r\n        ERC20(_foreignTokenAddress).transfer(_to, ERC20(_foreignTokenAddress).balanceOf(address(this)));\r\n    }\r\n\r\n///////////////////\r\n// Events (must be redundant in calling contract to work!)\r\n///////////////////\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event SelfApprovedTransfer(address indexed initiator, address indexed from, address indexed to, uint256 value);\r\n    event MintDetailed(address indexed initiator, address indexed to, uint256 amount);\r\n    event MintFinished(address indexed initiator);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n    event TransferPaused(address indexed initiator);\r\n    event TransferResumed(address indexed initiator);\r\n    event MintingPaused(address indexed initiator);\r\n    event MintingResumed(address indexed initiator);\r\n    event Reopened(address indexed initiator);\r\n    event DividendDeposited(address indexed depositor, uint256 transferAndMintIndex, uint256 amount, uint256 totalSupply, uint256 dividendIndex);\r\n    event DividendClaimed(address indexed claimer, uint256 dividendIndex, uint256 claim);\r\n    event DividendRecycled(address indexed recycler, uint256 transferAndMintIndex, uint256 amount, uint256 totalSupply, uint256 dividendIndex);\r\n    event RolesChanged(address indexed initiator, address pauseControl, address tokenRescueControl);\r\n    event MintControlChanged(address indexed initiator, address mintControl);\r\n    event TokenActionIndexIncreased(uint256 tokenActionIndex, uint256 blocknumber);\r\n}\r\n\r\n// File: contracts/assettoken/interface/IBasicAssetToken.sol\r\n\r\ninterface IBasicAssetToken {\r\n    //AssetToken specific\r\n    function getLimits() external view returns (uint256, uint256, uint256, uint256);\r\n    function isTokenAlive() external view returns (bool);\r\n    function setMetaData(\r\n        string calldata _name, \r\n        string calldata _symbol, \r\n        address _tokenBaseCurrency, \r\n        uint256 _cap, \r\n        uint256 _goal, \r\n        uint256 _startTime, \r\n        uint256 _endTime) \r\n        external;\r\n\r\n    //Mintable\r\n    function mint(address _to, uint256 _amount) external returns (bool);\r\n    function finishMinting() external returns (bool);\r\n\r\n    //ERC20\r\n    function balanceOf(address _owner) external view returns (uint256 balance);\r\n    function approve(address _spender, uint256 _amount) external returns (bool success);\r\n    function allowance(address _owner, address _spender) external view returns (uint256 remaining);\r\n    function totalSupply() external view returns (uint256);\r\n    function increaseApproval(address _spender, uint256 _addedValue) external returns (bool);\r\n    function decreaseApproval(address _spender, uint256 _subtractedValue) external returns (bool);\r\n    function transfer(address _to, uint256 _amount) external returns (bool success);\r\n    function transferFrom(address _from, address _to, uint256 _amount) external returns (bool success);\r\n}\r\n\r\n// File: contracts/assettoken/abstract/IBasicAssetTokenFull.sol\r\n\r\ncontract IBasicAssetTokenFull is IBasicAssetToken {\r\n    function checkCanSetMetadata() internal returns (bool);\r\n\r\n    function getCap() public view returns (uint256);\r\n    function getGoal() public view returns (uint256);\r\n    function getStart() public view returns (uint256);\r\n    function getEnd() public view returns (uint256);\r\n    function getLimits() public view returns (uint256, uint256, uint256, uint256);\r\n    function setMetaData(\r\n        string calldata _name, \r\n        string calldata _symbol, \r\n        address _tokenBaseCurrency, \r\n        uint256 _cap, \r\n        uint256 _goal, \r\n        uint256 _startTime, \r\n        uint256 _endTime) \r\n        external;\r\n    \r\n    function getTokenRescueControl() public view returns (address);\r\n    function getPauseControl() public view returns (address);\r\n    function isTransfersPaused() public view returns (bool);\r\n\r\n    function setMintControl(address _mintControl) public;\r\n    function setRoles(address _pauseControl, address _tokenRescueControl) public;\r\n\r\n    function setTokenAlive() public;\r\n    function isTokenAlive() public view returns (bool);\r\n\r\n    function balanceOf(address _owner) public view returns (uint256 balance);\r\n\r\n    function approve(address _spender, uint256 _amount) public returns (bool success);\r\n\r\n    function allowance(address _owner, address _spender) public view returns (uint256 remaining);\r\n\r\n    function totalSupply() public view returns (uint256);\r\n\r\n    function increaseApproval(address _spender, uint256 _addedValue) public returns (bool);\r\n\r\n    function decreaseApproval(address _spender, uint256 _subtractedValue) public returns (bool);\r\n\r\n    function finishMinting() public returns (bool);\r\n\r\n    function rescueToken(address _foreignTokenAddress, address _to) public;\r\n\r\n    function balanceOfAt(address _owner, uint256 _specificTransfersAndMintsIndex) public view returns (uint256);\r\n\r\n    function totalSupplyAt(uint256 _specificTransfersAndMintsIndex) public view returns(uint256);\r\n\r\n    function enableTransfers(bool _transfersEnabled) public;\r\n\r\n    function pauseTransfer(bool _transfersEnabled) public;\r\n\r\n    function pauseCapitalIncreaseOrDecrease(bool _mintingEnabled) public;    \r\n\r\n    function isMintingPaused() public view returns (bool);\r\n\r\n    function mint(address _to, uint256 _amount) public returns (bool);\r\n\r\n    function transfer(address _to, uint256 _amount) public returns (bool success);\r\n\r\n    function transferFrom(address _from, address _to, uint256 _amount) public returns (bool success);\r\n\r\n    function enableTransferInternal(bool _transfersEnabled) internal;\r\n\r\n    function reopenCrowdsaleInternal() internal returns (bool);\r\n\r\n    function transferFromInternal(address _from, address _to, uint256 _amount) internal returns (bool success);\r\n    function enforcedTransferFromInternal(address _from, address _to, uint256 _value, bool _fullAmountRequired) internal returns (bool);\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event MintDetailed(address indexed initiator, address indexed to, uint256 amount);\r\n    event MintFinished(address indexed initiator);\r\n    event TransferPaused(address indexed initiator);\r\n    event TransferResumed(address indexed initiator);\r\n    event Reopened(address indexed initiator);\r\n    event MetaDataChanged(address indexed initiator, string name, string symbol, address baseCurrency, uint256 cap, uint256 goal);\r\n    event RolesChanged(address indexed initiator, address _pauseControl, address _tokenRescueControl);\r\n    event MintControlChanged(address indexed initiator, address mintControl);\r\n}\r\n\r\n// File: contracts/assettoken/BasicAssetToken.sol\r\n\r\n/*\r\n    Copyright 2018, CONDA\r\n\r\n    This program is free software: you can redistribute it and/or modify\r\n    it under the terms of the GNU General Public License as published by\r\n    the Free Software Foundation, either version 3 of the License, or\r\n    (at your option) any later version.\r\n\r\n    This program is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n    GNU General Public License for more details.\r\n\r\n    You should have received a copy of the GNU General Public License\r\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n*/\r\n\r\n\r\n\r\n\r\n\r\n/** @title Basic AssetToken. This contract includes the basic AssetToken features */\r\ncontract BasicAssetToken is IBasicAssetTokenFull, Ownable {\r\n\r\n    using SafeMath for uint256;\r\n    using AssetTokenL for AssetTokenL.Supply;\r\n    using AssetTokenL for AssetTokenL.Availability;\r\n    using AssetTokenL for AssetTokenL.Roles;\r\n\r\n///////////////////\r\n// Variables\r\n///////////////////\r\n\r\n    string private _name;\r\n    string private _symbol;\r\n\r\n    // The token's name\r\n    function name() public view returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    // Fixed number of 0 decimals like real world equity\r\n    function decimals() public pure returns (uint8) {\r\n        return 0;\r\n    }\r\n\r\n    // An identifier\r\n    function symbol() public view returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    // 1000 is version 1\r\n    uint16 public constant version = 2000;\r\n\r\n    // Defines the baseCurrency of the token\r\n    address public baseCurrency;\r\n\r\n    // Supply: balance, checkpoints etc.\r\n    AssetTokenL.Supply supply;\r\n\r\n    // Availability: what's paused\r\n    AssetTokenL.Availability availability;\r\n\r\n    // Roles: who is entitled\r\n    AssetTokenL.Roles roles;\r\n\r\n///////////////////\r\n// Simple state getters\r\n///////////////////\r\n\r\n    function isMintingPaused() public view returns (bool) {\r\n        return availability.mintingPaused;\r\n    }\r\n\r\n    function isMintingPhaseFinished() public view returns (bool) {\r\n        return availability.mintingPhaseFinished;\r\n    }\r\n\r\n    function getPauseControl() public view returns (address) {\r\n        return roles.pauseControl;\r\n    }\r\n\r\n    function getTokenRescueControl() public view returns (address) {\r\n        return roles.tokenRescueControl;\r\n    }\r\n\r\n    function getMintControl() public view returns (address) {\r\n        return roles.mintControl;\r\n    }\r\n\r\n    function isTransfersPaused() public view returns (bool) {\r\n        return !availability.transfersEnabled;\r\n    }\r\n\r\n    function isTokenAlive() public view returns (bool) {\r\n        return availability.tokenAlive;\r\n    }\r\n\r\n    function getCap() public view returns (uint256) {\r\n        return supply.cap;\r\n    }\r\n\r\n    function getGoal() public view returns (uint256) {\r\n        return supply.goal;\r\n    }\r\n\r\n    function getStart() public view returns (uint256) {\r\n        return supply.startTime;\r\n    }\r\n\r\n    function getEnd() public view returns (uint256) {\r\n        return supply.endTime;\r\n    }\r\n\r\n    function getLimits() public view returns (uint256, uint256, uint256, uint256) {\r\n        return (supply.cap, supply.goal, supply.startTime, supply.endTime);\r\n    }\r\n\r\n    function getCurrentHistoryIndex() public view returns (uint256) {\r\n        return supply.tokenActionIndex;\r\n    }\r\n\r\n///////////////////\r\n// Events\r\n///////////////////\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event MintDetailed(address indexed initiator, address indexed to, uint256 amount);\r\n    event MintFinished(address indexed initiator);\r\n    event TransferPaused(address indexed initiator);\r\n    event TransferResumed(address indexed initiator);\r\n    event MintingPaused(address indexed initiator);\r\n    event MintingResumed(address indexed initiator);\r\n    event Reopened(address indexed initiator);\r\n    event MetaDataChanged(address indexed initiator, string name, string symbol, address baseCurrency, uint256 cap, uint256 goal);\r\n    event RolesChanged(address indexed initiator, address pauseControl, address tokenRescueControl);\r\n    event MintControlChanged(address indexed initiator, address mintControl);\r\n    event TokenActionIndexIncreased(uint256 tokenActionIndex, uint256 blocknumber);\r\n\r\n///////////////////\r\n// Modifiers\r\n///////////////////\r\n    modifier onlyPauseControl() {\r\n        require(msg.sender == roles.pauseControl, \"pauseCtrl\");\r\n        _;\r\n    }\r\n\r\n    //can be overwritten in inherited contracts...\r\n    function _canDoAnytime() internal view returns (bool) {\r\n        return false;\r\n    }\r\n\r\n    modifier onlyOwnerOrOverruled() {\r\n        if(_canDoAnytime() == false) { \r\n            require(isOwner(), \"only owner\");\r\n        }\r\n        _;\r\n    }\r\n\r\n    modifier canMint() {\r\n        if(_canDoAnytime() == false) { \r\n            require(canMintLogic(), \"canMint\");\r\n        }\r\n        _;\r\n    }\r\n\r\n    function canMintLogic() private view returns (bool) {\r\n        return msg.sender == roles.mintControl && availability.tokenAlive && !availability.mintingPhaseFinished && !availability.mintingPaused;\r\n    }\r\n\r\n    //can be overwritten in inherited contracts...\r\n    function checkCanSetMetadata() internal returns (bool) {\r\n        if(_canDoAnytime() == false) {\r\n            require(isOwner(), \"owner only\");\r\n            require(!availability.tokenAlive, \"alive\");\r\n            require(!availability.mintingPhaseFinished, \"finished\");\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    modifier canSetMetadata() {\r\n        checkCanSetMetadata();\r\n        _;\r\n    }\r\n\r\n    modifier onlyTokenAlive() {\r\n        require(availability.tokenAlive, \"not alive\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyTokenRescueControl() {\r\n        require(msg.sender == roles.tokenRescueControl, \"rescueCtrl\");\r\n        _;\r\n    }\r\n\r\n    modifier canTransfer() {\r\n        require(availability.transfersEnabled, \"paused\");\r\n        _;\r\n    }\r\n\r\n///////////////////\r\n// Set / Get Metadata\r\n///////////////////\r\n\r\n    /// @notice Change the token's metadata.\r\n    /// @dev Time is via block.timestamp (check crowdsale contract)\r\n    /// @param _nameParam The name of the token.\r\n    /// @param _symbolParam The symbol of the token.\r\n    /// @param _tokenBaseCurrency The base currency.\r\n    /// @param _cap The max amount of tokens that can be minted.\r\n    /// @param _goal The goal of tokens that should be sold.\r\n    /// @param _startTime Time when crowdsale should start.\r\n    /// @param _endTime Time when crowdsale should end.\r\n    function setMetaData(\r\n        string calldata _nameParam, \r\n        string calldata _symbolParam, \r\n        address _tokenBaseCurrency, \r\n        uint256 _cap, \r\n        uint256 _goal, \r\n        uint256 _startTime, \r\n        uint256 _endTime) \r\n        external \r\n    canSetMetadata \r\n    {\r\n        require(_cap >= _goal, \"cap higher goal\");\r\n\r\n        _name = _nameParam;\r\n        _symbol = _symbolParam;\r\n\r\n        baseCurrency = _tokenBaseCurrency;\r\n        supply.cap = _cap;\r\n        supply.goal = _goal;\r\n        supply.startTime = _startTime;\r\n        supply.endTime = _endTime;\r\n\r\n        emit MetaDataChanged(msg.sender, _nameParam, _symbolParam, _tokenBaseCurrency, _cap, _goal);\r\n    }\r\n\r\n    /// @notice Set mint control role. Usually this is CONDA's controller.\r\n    /// @param _mintControl Contract address or wallet that should be allowed to mint.\r\n    function setMintControl(address _mintControl) public canSetMetadata { //ERROR: what on UPGRADE\r\n        roles.setMintControl(_mintControl);\r\n    }\r\n\r\n    /// @notice Set roles.\r\n    /// @param _pauseControl address that is allowed to pause.\r\n    /// @param _tokenRescueControl address that is allowed rescue tokens.\r\n    function setRoles(address _pauseControl, address _tokenRescueControl) public \r\n    canSetMetadata\r\n    {\r\n        roles.setRoles(_pauseControl, _tokenRescueControl);\r\n    }\r\n\r\n    function setTokenAlive() public \r\n    onlyOwnerOrOverruled\r\n    {\r\n        availability.setTokenAlive();\r\n    }\r\n\r\n///////////////////\r\n// ERC20 Methods\r\n///////////////////\r\n\r\n    /// @notice Send `_amount` tokens to `_to` from `msg.sender`\r\n    /// @param _to The address of the recipient\r\n    /// @param _amount The amount of tokens to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transfer(address _to, uint256 _amount) public canTransfer returns (bool success) {\r\n        supply.doTransfer(availability, msg.sender, _to, _amount);\r\n        return true;\r\n    }\r\n\r\n    /// @notice Send `_amount` tokens to `_to` from `_from` on the condition (requires allowance/approval)\r\n    /// @param _from The address holding the tokens being transferred\r\n    /// @param _to The address of the recipient\r\n    /// @param _amount The amount of tokens to be transferred\r\n    /// @return True if the transfer was successful\r\n    function transferFrom(address _from, address _to, uint256 _amount) public returns (bool success) {\r\n        return transferFromInternal(_from, _to, _amount);\r\n    }\r\n\r\n    /// @notice Send `_amount` tokens to `_to` from `_from` on the condition (requires allowance/approval)\r\n    /// @dev modifiers in this internal method because also used by features.\r\n    /// @param _from The address holding the tokens being transferred\r\n    /// @param _to The address of the recipient\r\n    /// @param _amount The amount of tokens to be transferred\r\n    /// @return True if the transfer was successful\r\n    function transferFromInternal(address _from, address _to, uint256 _amount) internal canTransfer returns (bool success) {\r\n        return supply.transferFrom(availability, _from, _to, _amount);\r\n    }\r\n\r\n    /// @notice balance of `_owner` for this token\r\n    /// @param _owner The address that's balance is being requested\r\n    /// @return The balance of `_owner` now (at the current index)\r\n    function balanceOf(address _owner) public view returns (uint256 balance) {\r\n        return supply.balanceOfNow(_owner);\r\n    }\r\n\r\n    /// @notice `msg.sender` approves `_spender` to spend `_amount` of his tokens\r\n    /// @dev This is a modified version of the ERC20 approve function to be a bit safer\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @param _amount The amount of tokens to be approved for transfer\r\n    /// @return True if the approval was successful\r\n    function approve(address _spender, uint256 _amount) public returns (bool success) {\r\n        return supply.approve(_spender, _amount);\r\n    }\r\n\r\n    /// @notice This method can check how much is approved by `_owner` for `_spender`\r\n    /// @dev This function makes it easy to read the `allowed[]` map\r\n    /// @param _owner The address of the account that owns the token\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @return Amount of remaining tokens of _owner that _spender is allowed to spend\r\n    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {\r\n        return supply.allowed[_owner][_spender];\r\n    }\r\n\r\n    /// @notice This function makes it easy to get the total number of tokens\r\n    /// @return The total number of tokens now (at current index)\r\n    function totalSupply() public view returns (uint256) {\r\n        return supply.totalSupplyNow();\r\n    }\r\n\r\n\r\n    /// @notice Increase the amount of tokens that an owner allowed to a spender.\r\n    /// @dev approve should be called when allowed[_spender] == 0. To increment\r\n    /// allowed value is better to use this function to avoid 2 calls (and wait until\r\n    /// the first transaction is mined)\r\n    /// From MonolithDAO Token.sol\r\n    /// @param _spender The address which will spend the funds.\r\n    /// @param _addedValue The amount of tokens to increase the allowance by.\r\n    function increaseApproval(address _spender, uint256 _addedValue) public returns (bool) {\r\n        return supply.increaseApproval(_spender, _addedValue);\r\n    }\r\n\r\n    /// @dev Decrease the amount of tokens that an owner allowed to a spender.\r\n    /// approve should be called when allowed[_spender] == 0. To decrement\r\n    /// allowed value is better to use this function to avoid 2 calls (and wait until\r\n    /// the first transaction is mined)\r\n    /// From MonolithDAO Token.sol\r\n    /// @param _spender The address which will spend the funds.\r\n    /// @param _subtractedValue The amount of tokens to decrease the allowance by.\r\n    function decreaseApproval(address _spender, uint256 _subtractedValue) public returns (bool) {\r\n        return supply.decreaseApproval(_spender, _subtractedValue);\r\n    }\r\n\r\n////////////////\r\n// Miniting \r\n////////////////\r\n\r\n    /// @dev Can rescue tokens accidentally assigned to this contract\r\n    /// @param _to The beneficiary who receives increased balance.\r\n    /// @param _amount The amount of balance increase.\r\n    function mint(address _to, uint256 _amount) public canMint returns (bool) {\r\n        return supply.mint(_to, _amount);\r\n    }\r\n\r\n    /// @notice Function to stop minting new tokens\r\n    /// @return True if the operation was successful.\r\n    function finishMinting() public onlyOwnerOrOverruled returns (bool) {\r\n        return availability.finishMinting();\r\n    }\r\n\r\n////////////////\r\n// Rescue Tokens \r\n////////////////\r\n\r\n    /// @dev Can rescue tokens accidentally assigned to this contract\r\n    /// @param _foreignTokenAddress The address from which the balance will be retrieved\r\n    /// @param _to beneficiary\r\n    function rescueToken(address _foreignTokenAddress, address _to)\r\n    public\r\n    onlyTokenRescueControl\r\n    {\r\n        availability.rescueToken(_foreignTokenAddress, _to);\r\n    }\r\n\r\n////////////////\r\n// Query balance and totalSupply in History\r\n////////////////\r\n\r\n    /// @notice Someone's token balance of this token\r\n    /// @dev Queries the balance of `_owner` at `_specificTransfersAndMintsIndex`\r\n    /// @param _owner The address from which the balance will be retrieved\r\n    /// @param _specificTransfersAndMintsIndex The balance at index\r\n    /// @return The balance at `_specificTransfersAndMintsIndex`\r\n    function balanceOfAt(address _owner, uint256 _specificTransfersAndMintsIndex) public view returns (uint256) {\r\n        return supply.balanceOfAt(_owner, _specificTransfersAndMintsIndex);\r\n    }\r\n\r\n    /// @notice Total amount of tokens at `_specificTransfersAndMintsIndex`.\r\n    /// @param _specificTransfersAndMintsIndex The totalSupply at index\r\n    /// @return The total amount of tokens at `_specificTransfersAndMintsIndex`\r\n    function totalSupplyAt(uint256 _specificTransfersAndMintsIndex) public view returns(uint256) {\r\n        return supply.totalSupplyAt(_specificTransfersAndMintsIndex);\r\n    }\r\n\r\n////////////////\r\n// Enable tokens transfers\r\n////////////////\r\n\r\n    /// @dev this function is not public and can be overwritten\r\n    function enableTransferInternal(bool _transfersEnabled) internal {\r\n        availability.pauseTransfer(_transfersEnabled);\r\n    }\r\n\r\n    /// @notice Enables token holders to transfer their tokens freely if true\r\n    /// @param _transfersEnabled True if transfers are allowed\r\n    function enableTransfers(bool _transfersEnabled) public \r\n    onlyOwnerOrOverruled \r\n    {\r\n        enableTransferInternal(_transfersEnabled);\r\n    }\r\n\r\n////////////////\r\n// Pausing token for unforeseen reasons\r\n////////////////\r\n\r\n    /// @dev `pauseTransfer` is an alias for `enableTransfers` using the pauseControl modifier\r\n    /// @param _transfersEnabled False if transfers are allowed\r\n    function pauseTransfer(bool _transfersEnabled) public\r\n    onlyPauseControl\r\n    {\r\n        enableTransferInternal(_transfersEnabled);\r\n    }\r\n\r\n    /// @dev `pauseCapitalIncreaseOrDecrease` can pause mint\r\n    /// @param _mintingEnabled False if minting is allowed\r\n    function pauseCapitalIncreaseOrDecrease(bool _mintingEnabled) public\r\n    onlyPauseControl\r\n    {\r\n        availability.pauseCapitalIncreaseOrDecrease(_mintingEnabled);\r\n    }\r\n\r\n    /// @dev capitalControl (if exists) can reopen the crowdsale.\r\n    /// this function is not public and can be overwritten\r\n    function reopenCrowdsaleInternal() internal returns (bool) {\r\n        return availability.reopenCrowdsale();\r\n    }\r\n\r\n    /// @dev capitalControl (if exists) can enforce a transferFrom e.g. in case of lost wallet.\r\n    /// this function is not public and can be overwritten\r\n    function enforcedTransferFromInternal(address _from, address _to, uint256 _value, bool _fullAmountRequired) internal returns (bool) {\r\n        return supply.enforcedTransferFrom(availability, _from, _to, _value, _fullAmountRequired);\r\n    }\r\n}\r\n\r\n// File: contracts/assettoken/interfaces/ICRWDController.sol\r\n\r\ninterface ICRWDController {\r\n    function transferParticipantsVerification(address _underlyingCurrency, address _from, address _to, uint256 _amount) external returns (bool); //from AssetToken\r\n}\r\n\r\n// File: contracts/assettoken/interfaces/IGlobalIndex.sol\r\n\r\ninterface IGlobalIndex {\r\n    function getControllerAddress() external view returns (address);\r\n    function setControllerAddress(address _newControllerAddress) external;\r\n}\r\n\r\n// File: contracts/assettoken/abstract/ICRWDAssetToken.sol\r\n\r\ncontract ICRWDAssetToken is IBasicAssetTokenFull {\r\n    function setGlobalIndexAddress(address _globalIndexAddress) public;\r\n}\r\n\r\n// File: contracts/assettoken/CRWDAssetToken.sol\r\n\r\n/*\r\n    Copyright 2018, CONDA\r\n\r\n    This program is free software: you can redistribute it and/or modify\r\n    it under the terms of the GNU General Public License as published by\r\n    the Free Software Foundation, either version 3 of the License, or\r\n    (at your option) any later version.\r\n\r\n    This program is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n    GNU General Public License for more details.\r\n\r\n    You should have received a copy of the GNU General Public License\r\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n*/\r\n\r\n\r\n\r\n\r\n\r\n\r\n/** @title CRWD AssetToken. This contract inherits basic functionality and extends calls to controller. */\r\ncontract CRWDAssetToken is BasicAssetToken, ICRWDAssetToken {\r\n\r\n    using SafeMath for uint256;\r\n\r\n    IGlobalIndex public globalIndex;\r\n\r\n    function getControllerAddress() public view returns (address) {\r\n        return globalIndex.getControllerAddress();\r\n    }\r\n\r\n    /** @dev ERC20 transfer function overlay to transfer tokens and call controller.\r\n      * @param _to The recipient address.\r\n      * @param _amount The amount.\r\n      * @return A boolean that indicates if the operation was successful.\r\n      */\r\n    function transfer(address _to, uint256 _amount) public returns (bool success) {\r\n        ICRWDController(getControllerAddress()).transferParticipantsVerification(baseCurrency, msg.sender, _to, _amount);\r\n        return super.transfer(_to, _amount);\r\n    }\r\n\r\n    /** @dev ERC20 transferFrom function overlay to transfer tokens and call controller.\r\n      * @param _from The sender address (requires approval).\r\n      * @param _to The recipient address.\r\n      * @param _amount The amount.\r\n      * @return A boolean that indicates if the operation was successful.\r\n      */\r\n    function transferFrom(address _from, address _to, uint256 _amount) public returns (bool success) {\r\n        ICRWDController(getControllerAddress()).transferParticipantsVerification(baseCurrency, _from, _to, _amount);\r\n        return super.transferFrom(_from, _to, _amount);\r\n    }\r\n\r\n    /** @dev Mint function overlay to mint/create tokens.\r\n      * @param _to The address that will receive the minted tokens.\r\n      * @param _amount The amount of tokens to mint.\r\n      * @return A boolean that indicates if the operation was successful.\r\n      */\r\n    function mint(address _to, uint256 _amount) public canMint returns (bool) {\r\n        return super.mint(_to,_amount);\r\n    }\r\n\r\n    /** @dev Set address of GlobalIndex.\r\n      * @param _globalIndexAddress Address to be used for current destination e.g. controller lookup.\r\n      */\r\n    function setGlobalIndexAddress(address _globalIndexAddress) public onlyOwner {\r\n        globalIndex = IGlobalIndex(_globalIndexAddress);\r\n    }\r\n}\r\n\r\n// File: contracts/assettoken/feature/FeatureCapitalControl.sol\r\n\r\n/*\r\n    Copyright 2018, CONDA\r\n\r\n    This program is free software: you can redistribute it and/or modify\r\n    it under the terms of the GNU General Public License as published by\r\n    the Free Software Foundation, either version 3 of the License, or\r\n    (at your option) any later version.\r\n\r\n    This program is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n    GNU General Public License for more details.\r\n\r\n    You should have received a copy of the GNU General Public License\r\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n*/\r\n\r\n\r\n/** @title FeatureCapitalControl. */\r\ncontract FeatureCapitalControl is ICRWDAssetToken {\r\n    \r\n////////////////\r\n// Variables\r\n////////////////\r\n\r\n    //if set can mint after finished. E.g. a notary.\r\n    address public capitalControl;\r\n\r\n////////////////\r\n// Constructor\r\n////////////////\r\n\r\n    constructor(address _capitalControl) public {\r\n        capitalControl = _capitalControl;\r\n        enableTransferInternal(false); //disable transfer as default\r\n    }\r\n\r\n////////////////\r\n// Modifiers\r\n////////////////\r\n\r\n    //override: skip certain modifier checks as capitalControl\r\n    function _canDoAnytime() internal view returns (bool) {\r\n        return msg.sender == capitalControl;\r\n    }\r\n\r\n    modifier onlyCapitalControl() {\r\n        require(msg.sender == capitalControl, \"permission\");\r\n        _;\r\n    }\r\n\r\n////////////////\r\n// Functions\r\n////////////////\r\n\r\n    /// @notice set capitalControl\r\n    /// @dev this looks unprotected but has a checkCanSetMetadata check.\r\n    ///  depending on inheritance this can be done \r\n    ///  before alive and any time by capitalControl\r\n    function setCapitalControl(address _capitalControl) public {\r\n        require(checkCanSetMetadata(), \"forbidden\");\r\n\r\n        capitalControl = _capitalControl;\r\n    }\r\n\r\n    /// @notice as capital control I can pass my ownership to a new address (e.g. private key leaked).\r\n    /// @param _capitalControl new capitalControl address\r\n    function updateCapitalControl(address _capitalControl) public onlyCapitalControl {\r\n        capitalControl = _capitalControl;\r\n    }\r\n\r\n////////////////\r\n// Reopen crowdsale (by capitalControl e.g. notary)\r\n////////////////\r\n\r\n    /// @notice capitalControl can reopen the crowdsale.\r\n    function reopenCrowdsale() public onlyCapitalControl returns (bool) {        \r\n        return reopenCrowdsaleInternal();\r\n    }\r\n}\r\n\r\n// File: contracts/assettoken/feature/FeatureCapitalControlWithForcedTransferFrom.sol\r\n\r\n/*\r\n    Copyright 2018, CONDA\r\n\r\n    This program is free software: you can redistribute it and/or modify\r\n    it under the terms of the GNU General Public License as published by\r\n    the Free Software Foundation, either version 3 of the License, or\r\n    (at your option) any later version.\r\n\r\n    This program is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n    GNU General Public License for more details.\r\n\r\n    You should have received a copy of the GNU General Public License\r\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n*/\r\n\r\n\r\n\r\n/** @title FeatureCapitalControlWithForcedTransferFrom. */\r\ncontract FeatureCapitalControlWithForcedTransferFrom is FeatureCapitalControl {\r\n\r\n///////////////////\r\n// Constructor\r\n///////////////////\r\n\r\n    constructor(address _capitalControl) FeatureCapitalControl(_capitalControl) public { }\r\n\r\n///////////////////\r\n// Events\r\n///////////////////\r\n\r\n    event SelfApprovedTransfer(address indexed initiator, address indexed from, address indexed to, uint256 value);\r\n\r\n\r\n///////////////////\r\n// Overrides\r\n///////////////////\r\n\r\n    //override: transferFrom that has special self-approve behaviour when executed as capitalControl\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool)\r\n    {\r\n        if (msg.sender == capitalControl) {\r\n            return enforcedTransferFromInternal(_from, _to, _value, true);\r\n        } else {\r\n            return transferFromInternal(_from, _to, _value);\r\n        }\r\n    }\r\n\r\n}\r\n\r\n// File: contracts/assettoken/STOs/AssetTokenT001.sol\r\n\r\n/** @title AssetTokenT001 Token. A CRWDAssetToken with CapitalControl and LostWallet feature */\r\ncontract AssetTokenT001 is CRWDAssetToken, FeatureCapitalControlWithForcedTransferFrom\r\n{    \r\n    constructor(address _capitalControl) FeatureCapitalControlWithForcedTransferFrom(_capitalControl) public {}\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"isTokenAlive\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getMintControl\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getPauseControl\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_transfersEnabled\",\"type\":\"bool\"}],\"name\":\"pauseTransfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTokenRescueControl\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"setTokenAlive\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isMintingPaused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_foreignTokenAddress\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"rescueToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_capitalControl\",\"type\":\"address\"}],\"name\":\"setCapitalControl\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_specificTransfersAndMintsIndex\",\"type\":\"uint256\"}],\"name\":\"balanceOfAt\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_capitalControl\",\"type\":\"address\"}],\"name\":\"updateCapitalControl\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseApproval\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getLimits\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_mintingEnabled\",\"type\":\"bool\"}],\"name\":\"pauseCapitalIncreaseOrDecrease\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finishMinting\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"reopenCrowdsale\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"baseCurrency\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_specificTransfersAndMintsIndex\",\"type\":\"uint256\"}],\"name\":\"totalSupplyAt\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getEnd\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"capitalControl\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isTransfersPaused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getGoal\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_mintControl\",\"type\":\"address\"}],\"name\":\"setMintControl\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCurrentHistoryIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_globalIndexAddress\",\"type\":\"address\"}],\"name\":\"setGlobalIndexAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getStart\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getControllerAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isMintingPhaseFinished\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseApproval\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"globalIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_nameParam\",\"type\":\"string\"},{\"name\":\"_symbolParam\",\"type\":\"string\"},{\"name\":\"_tokenBaseCurrency\",\"type\":\"address\"},{\"name\":\"_cap\",\"type\":\"uint256\"},{\"name\":\"_goal\",\"type\":\"uint256\"},{\"name\":\"_startTime\",\"type\":\"uint256\"},{\"name\":\"_endTime\",\"type\":\"uint256\"}],\"name\":\"setMetaData\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_transfersEnabled\",\"type\":\"bool\"}],\"name\":\"enableTransfers\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_pauseControl\",\"type\":\"address\"},{\"name\":\"_tokenRescueControl\",\"type\":\"address\"}],\"name\":\"setRoles\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_capitalControl\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"initiator\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"SelfApprovedTransfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"initiator\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"MintDetailed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"initiator\",\"type\":\"address\"}],\"name\":\"MintFinished\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"initiator\",\"type\":\"address\"}],\"name\":\"TransferPaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"initiator\",\"type\":\"address\"}],\"name\":\"TransferResumed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"initiator\",\"type\":\"address\"}],\"name\":\"MintingPaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"initiator\",\"type\":\"address\"}],\"name\":\"MintingResumed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"initiator\",\"type\":\"address\"}],\"name\":\"Reopened\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"initiator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"name\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"symbol\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"baseCurrency\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"cap\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"goal\",\"type\":\"uint256\"}],\"name\":\"MetaDataChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"initiator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"pauseControl\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokenRescueControl\",\"type\":\"address\"}],\"name\":\"RolesChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"initiator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"mintControl\",\"type\":\"address\"}],\"name\":\"MintControlChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"tokenActionIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"blocknumber\",\"type\":\"uint256\"}],\"name\":\"TokenActionIndexIncreased\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"AssetTokenT001","CompilerVersion":"v0.5.0+commit.1d4f565a","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000e6ebd65650bbfe8ab975a5290b668a59e2a691db","Library":"AssetTokenL:A25215718889F874cA9a3b17E5470b35Ae2AfDBa","SwarmSource":"bzzr://f06263a1a0e444129695c7f886d12245e1726c47a4f7c5d589a45412571707c8"}]}