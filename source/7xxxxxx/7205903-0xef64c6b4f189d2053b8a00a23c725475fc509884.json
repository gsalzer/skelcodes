{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.0;\r\n\r\n/// https://eips.ethereum.org/EIPS/eip-165\r\ninterface ERC165 {\r\n  /// @notice Query if a contract implements an interface\r\n  /// @param interfaceID The interface identifier, as specified in ERC-165\r\n  /// @dev Interface identification is specified in ERC-165. This function\r\n  ///  uses less than 30,000 gas.\r\n  /// @return `true` if the contract implements `interfaceID` and\r\n  ///  `interfaceID` is not 0xffffffff, `false` otherwise\r\n  function supportsInterface(bytes4 interfaceID) external view returns (bool);\r\n}\r\n\r\n/// https://eips.ethereum.org/EIPS/eip-900\r\n/// @notice Interface with external methods\r\ninterface ISimpleStaking {\r\n\r\n  event Staked(address indexed user, uint256 amount, uint256 total, bytes data);\r\n  event Unstaked(address indexed user, uint256 amount, uint256 total, bytes data);\r\n\r\n  function stake(uint256 amount, bytes calldata data) external;\r\n  function stakeFor(address user, uint256 amount, bytes calldata data) external;\r\n  function unstake(uint256 amount, bytes calldata data) external;\r\n  function totalStakedFor(address addr) external view returns (uint256);\r\n  function totalStaked() external view returns (uint256);\r\n  function token() external view returns (address);\r\n  function supportsHistory() external pure returns (bool);\r\n\r\n  // optional. Commented out until we have valid reason to implement these methods\r\n  // function lastStakedFor(address addr) public view returns (uint256);\r\n  // function totalStakedForAt(address addr, uint256 blockNumber) public view returns (uint256);\r\n  // function totalStakedAt(uint256 blockNumber) public view returns (uint256);\r\n}\r\n\r\n/**\r\n * @title SafeMath\r\n * Courtesy of https://github.com/OpenZeppelin/openzeppelin-solidity/blob/9be0f100c48e4726bee73829fbb10f7d85b6ef54/contracts/math/SafeMath.sol\r\n * @dev Math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, reverts on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    uint256 c = a * b;\r\n    require(c / a == b);\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b > 0); // Solidity only automatically asserts when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b <= a);\r\n    uint256 c = a - b;\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, reverts on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    require(c >= a);\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\r\n  * reverts when dividing by zero.\r\n  */\r\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b != 0);\r\n    return a % b;\r\n  }\r\n}\r\n\r\ncontract ERC20 {\r\n\r\n  /// @return The total amount of tokens\r\n  function totalSupply() public view returns (uint256 supply);\r\n\r\n  /// @param _owner The address from which the balance will be retrieved\r\n  /// @return The balance\r\n  function balanceOf(address _owner) public view returns (uint256 balance);\r\n\r\n  /// @notice send `_value` token to `_to` from `msg.sender`\r\n  /// @param _to The address of the recipient\r\n  /// @param _value The amount of token to be transferred\r\n  /// @return Whether the transfer was successful or not\r\n  function transfer(address _to, uint256 _value) public returns (bool success);\r\n\r\n  /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n  /// @param _from The address of the sender\r\n  /// @param _to The address of the recipient\r\n  /// @param _value The amount of token to be transferred\r\n  /// @return Whether the transfer was successful or not\r\n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\r\n\r\n  /// @notice `msg.sender` approves `_spender` to spend `_value` tokens\r\n  /// @param _spender The address of the account able to transfer the tokens\r\n  /// @param _value The amount of tokens to be approved for transfer\r\n  /// @return Whether the approval was successful or not\r\n  function approve(address _spender, uint256 _value) public returns (bool success);\r\n\r\n  /// @param _owner The address of the account owning tokens\r\n  /// @param _spender The address of the account able to transfer the tokens\r\n  /// @return Amount of remaining tokens allowed to spent\r\n  function allowance(address _owner, address _spender) public view returns (uint256 remaining);\r\n\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\n/**\r\n* Smart contract to stake ERC20 and optionally lock it in for a period of time.\r\n* Users can add stake any time as long as the emergency status is false\r\n* Maximum locked-in time is 365 days from now.\r\n*\r\n* It also keeps track of the effective start time which is recorded on the very\r\n* first stake. Think of it as the \"member since\" attribute.\r\n* If user unstakes (full or partial) at any point, the effective start time is reset.\r\n*\r\n*/\r\ncontract TimeLockedStaking is ERC165, ISimpleStaking {\r\n  using SafeMath for uint256;\r\n\r\n  struct StakeRecord {\r\n    uint256 amount;\r\n    uint256 unlockedAt;\r\n  }\r\n\r\n  struct StakeInfo {\r\n    /// total tokens this user stakes.\r\n    uint256 totalAmount;\r\n    /// \"member since\" in unix timestamp. Reset when user unstakes.\r\n    uint256 effectiveAt;\r\n    /// storing staking data for unstaking later.\r\n    /// recordId i.e. key of mapping is the keccak256 of the 'data' parameter in the stake method.\r\n    mapping (bytes32 => StakeRecord) stakeRecords;\r\n  }\r\n\r\n  /// @dev When emergency is true,\r\n  /// block staking action and\r\n  /// allow to unstake without verifying the record.unlockedAt\r\n  bool public emergency;\r\n\r\n  /// @dev Owner of this contract, who can activate the emergency.\r\n  address public owner;\r\n\r\n  /// @dev Address of the ERC20 token contract used for staking.\r\n  ERC20 internal erc20Token;\r\n\r\n  /// @dev https://solidity.readthedocs.io/en/v0.4.25/style-guide.html#avoiding-naming-collisions\r\n  uint256 internal totalStaked_ = 0;\r\n\r\n  /// Keep track of all stakers\r\n  mapping (address => StakeInfo) public stakers;\r\n\r\n  modifier greaterThanZero(uint256 num) {\r\n    require(num > 0, \"Must be greater than 0.\");\r\n    _;\r\n  }\r\n\r\n  /// @dev Better to manually validate these params after deployment.\r\n  /// @param token_ ERC0 token's address. Required.\r\n  /// @param owner_ Who can set emergency status. Default: msg.sender.\r\n  constructor(address token_, address owner_) public {\r\n    erc20Token = ERC20(token_);\r\n    owner = owner_;\r\n    emergency = false;\r\n  }\r\n\r\n  /// @dev Implement ERC165\r\n  /// With three or more supported interfaces (including ERC165 itself as a required supported interface),\r\n  /// the mapping approach (in every case) costs less gas than the pure approach (at worst case).\r\n  function supportsInterface(bytes4 interfaceID) external view returns (bool) {\r\n    return\r\n      interfaceID == this.supportsInterface.selector ||\r\n      interfaceID == this.stake.selector ^ this.stakeFor.selector ^ this.unstake.selector ^ this.totalStakedFor.selector ^ this.totalStaked.selector ^ this.token.selector ^ this.supportsHistory.selector;\r\n  }\r\n\r\n  /// @dev msg.sender stakes for him/her self.\r\n  /// @param amount Number of ERC20 to be staked. Amount must be > 0.\r\n  /// @param data Used for signaling the unlocked time.\r\n  function stake(uint256 amount, bytes calldata data) external {\r\n    registerStake(msg.sender, amount, data);\r\n  }\r\n\r\n  /// @dev msg.sender stakes for someone else.\r\n  /// @param amount Number of ERC20 to be staked. Must be > 0.\r\n  /// @param data Used for signaling the unlocked time.\r\n  function stakeFor(address user, uint256 amount, bytes calldata data) external {\r\n    registerStake(user, amount, data);\r\n  }\r\n\r\n  /// @dev msg.sender can unstake full amount or partial if unlockedAt =< now\r\n  /// @notice as a result, the \"member since\" attribute is reset.\r\n  /// @param amount Number of ERC20 to be unstaked. Must be > 0 and =< staked amount.\r\n  /// @param data The payload that was used when staking.\r\n  function unstake(uint256 amount, bytes calldata data)\r\n    external\r\n    greaterThanZero(stakers[msg.sender].effectiveAt) // must be a member\r\n    greaterThanZero(amount)\r\n  {\r\n    address user = msg.sender;\r\n\r\n    bytes32 recordId = keccak256(data);\r\n\r\n    StakeRecord storage record = stakers[user].stakeRecords[recordId];\r\n\r\n    require(amount <= record.amount, \"Amount must be equal or smaller than the record.\");\r\n\r\n    // Validate unlockedAt if there's no emergency.\r\n    // Otherwise, ignore the lockdown period.\r\n    if (!emergency) {\r\n      require(block.timestamp >= record.unlockedAt, \"This stake is still locked.\");\r\n    }\r\n\r\n    record.amount = record.amount.sub(amount);\r\n\r\n    stakers[user].totalAmount = stakers[user].totalAmount.sub(amount);\r\n    stakers[user].effectiveAt = block.timestamp;\r\n\r\n    totalStaked_ = totalStaked_.sub(amount);\r\n\r\n    require(erc20Token.transfer(user, amount), \"Transfer failed.\");\r\n    emit Unstaked(user, amount, stakers[user].totalAmount, data);\r\n  }\r\n\r\n  /// @return The staked amount of an address.\r\n  function totalStakedFor(address addr) external view returns (uint256) {\r\n    return stakers[addr].totalAmount;\r\n  }\r\n\r\n  /// @return Total number of tokens this smart contract hold.\r\n  function totalStaked() external view returns (uint256) {\r\n    return totalStaked_;\r\n  }\r\n\r\n  /// @return Address of the ERC20 used for staking.\r\n  function token() external view returns (address) {\r\n    return address(erc20Token);\r\n  }\r\n\r\n  /// @dev This smart contract does not store staking activities on chain.\r\n  /// @return false History is processed off-chain via event logs.\r\n  function supportsHistory() external pure returns (bool) {\r\n    return false;\r\n  }\r\n\r\n\r\n  /// Escape hatch\r\n  function setEmergency(bool status) external {\r\n    require(msg.sender == owner, \"msg.sender must be owner.\");\r\n    emergency = status;\r\n  }\r\n\r\n  /// Helpers\r\n  ///\r\n\r\n  function max(uint256 a, uint256 b) public pure returns (uint256) {\r\n    return a > b ? a : b;\r\n  }\r\n\r\n  function min(uint256 a, uint256 b) public pure returns (uint256) {\r\n    return a > b ? b : a;\r\n  }\r\n\r\n  function getStakeRecordUnlockedAt(address user, bytes memory data) public view returns (uint256) {\r\n    return stakers[user].stakeRecords[keccak256(data)].unlockedAt;\r\n  }\r\n\r\n  function getStakeRecordAmount(address user, bytes memory data) public view returns (uint256) {\r\n    return stakers[user].stakeRecords[keccak256(data)].amount;\r\n  }\r\n\r\n  /// @dev Get the unlockedAt in the data field.\r\n  /// Maximum of 365 days from now.\r\n  /// Minimum of 1. Default value if data.length < 32.\r\n  /// @param data The left-most 256 bits are unix timestamp in seconds.\r\n  /// @return The unlockedAt in the data. Range [1, 365 days from now].\r\n  function getUnlockedAtSignal(bytes memory data) public view returns (uint256) {\r\n    uint256 unlockedAt;\r\n\r\n    if (data.length >= 32) {\r\n      assembly {\r\n        let d := add(data, 32) // first 32 bytes are the padded length of data\r\n        unlockedAt := mload(d)\r\n      }\r\n    }\r\n\r\n    // Maximum 365 days from now\r\n    uint256 oneYearFromNow = block.timestamp + 365 days;\r\n    uint256 capped = min(unlockedAt, oneYearFromNow);\r\n\r\n    return max(1, capped);\r\n  }\r\n\r\n  /// @dev Register a stake by updating the StakeInfo struct\r\n  function registerStake(address user, uint256 amount, bytes memory data) private greaterThanZero(amount) {\r\n    require(!emergency, \"Cannot stake due to emergency.\");\r\n    require(erc20Token.transferFrom(msg.sender, address(this), amount), \"Transfer failed.\");\r\n\r\n    StakeInfo storage info = stakers[user];\r\n\r\n    // Update effective at\r\n    info.effectiveAt = info.effectiveAt == 0 ? block.timestamp : info.effectiveAt;\r\n\r\n    // Update stake record\r\n    bytes32 recordId = keccak256(data);\r\n    StakeRecord storage record = info.stakeRecords[recordId];\r\n    record.amount = amount.add(record.amount);\r\n    record.unlockedAt = record.unlockedAt == 0 ? getUnlockedAtSignal(data) : record.unlockedAt;\r\n\r\n    // Update total amounts\r\n    info.totalAmount = amount.add(info.totalAmount);\r\n    totalStaked_ = totalStaked_.add(amount);\r\n\r\n    emit Staked(user, amount, stakers[user].totalAmount, data);\r\n  }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"interfaceID\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"setEmergency\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"stake\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"user\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"stakeFor\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"getUnlockedAtSignal\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"totalStakedFor\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"a\",\"type\":\"uint256\"},{\"name\":\"b\",\"type\":\"uint256\"}],\"name\":\"max\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"supportsHistory\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"a\",\"type\":\"uint256\"},{\"name\":\"b\",\"type\":\"uint256\"}],\"name\":\"min\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalStaked\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"stakers\",\"outputs\":[{\"name\":\"totalAmount\",\"type\":\"uint256\"},{\"name\":\"effectiveAt\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"user\",\"type\":\"address\"},{\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"getStakeRecordUnlockedAt\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"unstake\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"emergency\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"user\",\"type\":\"address\"},{\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"getStakeRecordAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"token_\",\"type\":\"address\"},{\"name\":\"owner_\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"total\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"Staked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"total\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"Unstaked\",\"type\":\"event\"}]","ContractName":"TimeLockedStaking","CompilerVersion":"v0.5.0+commit.1d4f565a","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000cb94be6f13a1182e4a4b6140cb7bf2025d28e41b0000000000000000000000000ed8c3d25849fe3fe918a8863a04e71036cbc501","Library":"SafeMath:be56176871dDfaA012De0cF2dDC689d026D13D21","SwarmSource":"bzzr://5762661b761eb975883621464a2ba04b08dcd41c7205e67914041196806ac30b"}]}