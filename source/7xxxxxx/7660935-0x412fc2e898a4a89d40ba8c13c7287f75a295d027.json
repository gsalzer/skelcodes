{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.4;\r\n\r\ncontract NiftyWallet {\r\n    \r\n    /**\r\n     * The Nifty Wallet - the niftiest wallet around!\r\n     * Author - Duncan Cock Foster. duncan@niftygateway.com \r\n     */ \r\n\r\n    /**\r\n     * Constants \r\n     * The address of the master contract, and the account ID for this wallet\r\n     * Account ID is used to retrieve the signing private key for this wallet\r\n     */ \r\n\r\n    address masterContractAdd = 0x4CADB4bAd0e2a49CC5D6CE26D8628C8f451dA346;\r\n    uint userAccountID = 0;\r\n    uint walletTxCount = 0;\r\n\r\n    /**\r\n    / Events\r\n    */\r\n\r\n    event Execution(address indexed destinationAddress, uint value, bytes txData);\r\n    event ExecutionFailure(address indexed destinationAddress, uint value, bytes txData);\r\n    event Deposit(address indexed sender, uint value);\r\n\r\n    /**\r\n    * @dev returns signing private key that controls this wallet\r\n    */\r\n\r\n    function returnUserAccountAddress() public view returns(address) {\r\n        MasterContract m_c_instance = MasterContract(masterContractAdd);\r\n        return (m_c_instance.returnUserControlAddress(userAccountID));\r\n    }\r\n    \r\n    function returnWalletTxCount() public view returns(uint) {\r\n        return(walletTxCount);\r\n    }\r\n    \r\n    /**\r\n     * Modifier to check msg.sender\r\n     */\r\n     \r\n    modifier onlyValidSender() {\r\n        MasterContract m_c_instance = MasterContract(masterContractAdd);\r\n        require(m_c_instance.returnIsValidSendingKey(msg.sender) == true);\r\n        _;\r\n      }\r\n\r\n    /** \r\n     * Fall back function - get paid and static calls\r\n     */ \r\n\r\n    function()\r\n        payable\r\n        external\r\n    {\r\n        if (msg.value > 0)\r\n            emit Deposit(msg.sender, msg.value);\r\n        else if (msg.data.length > 0) {\r\n            //static call \r\n            MasterContract m_c_instance = MasterContract(masterContractAdd);\r\n            address loc =  (m_c_instance.returnStaticContractAddress());\r\n                assembly {\r\n                    calldatacopy(0, 0, calldatasize())\r\n                    let result := staticcall(gas, loc, 0, calldatasize(), 0, 0)\r\n                    returndatacopy(0, 0, returndatasize())\r\n                    switch result \r\n                    case 0 {revert(0, returndatasize())} \r\n                    default {return (0, returndatasize())}\r\n                }\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * @dev function to call any on chain transaction\r\n     * @dev verifies that the transaction data has been signed by the wallets controlling private key\r\n     * @dev and that the transaction has been sent from an approved sending wallet\r\n     * @param  _signedData bytes - signature of txData + wallet address\r\n     * @param destination address - destination for this transaction\r\n     * @param value uint - value of this transaction\r\n     * @param data bytes - transaction data \r\n     */ \r\n\r\n    function callTx(bytes memory _signedData,\r\n                     address destination,\r\n                     uint value,\r\n                     bytes memory data)\r\n    public onlyValidSender returns (bool) {\r\n        address userSigningAddress = returnUserAccountAddress();\r\n        MasterContract m_c_instance = MasterContract(masterContractAdd);\r\n        bytes32 dataHash = m_c_instance.returnTxMessageToSign(data, destination, value, walletTxCount);\r\n        address recoveredAddress = m_c_instance.recover(dataHash, _signedData);\r\n        if (recoveredAddress==userSigningAddress) {\r\n            if (external_call(destination, value, data.length, data)) {\r\n                emit Execution(destination, value, data);\r\n                walletTxCount = walletTxCount + 1;\r\n            } else {\r\n                emit ExecutionFailure(destination, value, data);\r\n                walletTxCount = walletTxCount +1;\r\n            }\r\n            return(true);\r\n        } else {\r\n            revert();\r\n        }\r\n    }\r\n    \r\n    /** External call function \r\n     * Taken from Gnosis Mutli Sig wallet\r\n     * https://github.com/gnosis/MultiSigWallet/blob/master/contracts/MultiSigWallet.sol\r\n     */ \r\n\r\n    // call has been separated into its own function in order to take advantage\r\n    // of the Solidity's code generator to produce a loop that copies tx.data into memory.\r\n    function external_call(address destination, uint value, uint dataLength, bytes memory data) private returns (bool) {\r\n        bool result;\r\n        assembly {\r\n            let x := mload(0x40)   // \"Allocate\" memory for output (0x40 is where \"free memory\" pointer is stored by convention)\r\n            let d := add(data, 32) // First 32 bytes are the padded length of data, so exclude that\r\n            result := call(\r\n                sub(gas, 34710),   // 34710 is the value that solidity is currently emitting\r\n                                   // It includes callGas (700) + callVeryLow (3, to pay for SUB) + callValueTransferGas (9000) +\r\n                                   // callNewAccountGas (25000, in case the destination address does not exist and needs creating)\r\n                destination,\r\n                value,\r\n                d,\r\n                dataLength,        // Size of the input (in bytes) - this is what fixes the padding problem\r\n                x,\r\n                0                  // Output is ignored, therefore the output size is zero\r\n            )\r\n        }\r\n        return result;\r\n    }\r\n\r\n}\r\n\r\ncontract MasterContract {\r\n    function returnUserControlAddress(uint account_id) public view returns (address);\r\n    function returnIsValidSendingKey(address sending_key) public view returns (bool);\r\n    function returnStaticContractAddress() public view returns (address);\r\n    function recover(bytes32 hash, bytes memory sig) public pure returns (address);\r\n    function returnTxMessageToSign(bytes memory txData, address des_add, uint value, uint tx_count)\r\n    public view returns(bytes32);\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"returnUserAccountAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"returnWalletTxCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_signedData\",\"type\":\"bytes\"},{\"name\":\"destination\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"callTx\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"destinationAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"txData\",\"type\":\"bytes\"}],\"name\":\"Execution\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"destinationAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"txData\",\"type\":\"bytes\"}],\"name\":\"ExecutionFailure\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"}]","ContractName":"NiftyWallet","CompilerVersion":"v0.5.4+commit.9549d8ff","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://36e99defe539766cc429067119c27376282be6065540aea21fd30a058716b011"}]}