{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\n/**\r\n * @title MultiSig\r\n * @dev Simple MultiSig using off-chain signing.\r\n * @author Julien Niset - <julien@argent.im>\r\n */\r\ncontract MultiSigWallet {\r\n\r\n    uint constant public MAX_OWNER_COUNT = 10;\r\n\r\n    // Incrementing counter to prevent replay attacks\r\n    uint256 public nonce;   \r\n    // The threshold           \r\n    uint256 public threshold; \r\n    // The number of owners\r\n    uint256 public ownersCount;\r\n    // Mapping to check if an address is an owner\r\n    mapping (address => bool) public isOwner; \r\n\r\n    // Events\r\n    event OwnerAdded(address indexed owner);\r\n    event OwnerRemoved(address indexed owner);\r\n    event ThresholdChanged(uint256 indexed newThreshold);\r\n    event Executed(address indexed destination, uint256 indexed value, bytes data);\r\n    event Received(uint256 indexed value, address indexed from);\r\n\r\n    /**\r\n     * @dev Throws is the calling account is not the multisig.\r\n     */\r\n    modifier onlyWallet() {\r\n        require(msg.sender == address(this), \"MSW: Calling account is not wallet\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Constructor.\r\n     * @param _threshold The threshold of the multisig.\r\n     * @param _owners The owners of the multisig.\r\n     */\r\n    constructor(uint256 _threshold, address[] _owners) public {\r\n        require(_owners.length > 0 && _owners.length <= MAX_OWNER_COUNT, \"MSW: Not enough or too many owners\");\r\n        require(_threshold > 0 && _threshold <= _owners.length, \"MSW: Invalid threshold\");\r\n        ownersCount = _owners.length;\r\n        threshold = _threshold;\r\n        for(uint256 i = 0; i < _owners.length; i++) {\r\n            isOwner[_owners[i]] = true;\r\n            emit OwnerAdded(_owners[i]);\r\n        }\r\n        emit ThresholdChanged(_threshold);\r\n    }\r\n\r\n    /**\r\n     * @dev Only entry point of the multisig. The method will execute any transaction provided that it \r\n     * receieved enough signatures from the wallet owners.  \r\n     * @param _to The destination address for the transaction to execute.\r\n     * @param _value The value parameter for the transaction to execute.\r\n     * @param _data The data parameter for the transaction to execute.\r\n     * @param _signatures Concatenated signatures ordered based on increasing signer's address.\r\n     */\r\n    function execute(address _to, uint _value, bytes _data, bytes _signatures) public {\r\n        uint8 v;\r\n        bytes32 r;\r\n        bytes32 s;\r\n        uint256 count = _signatures.length / 65;\r\n        require(count >= threshold, \"MSW: Not enough signatures\");\r\n        bytes32 txHash = keccak256(abi.encodePacked(byte(0x19), byte(0), address(this), _to, _value, _data, nonce));\r\n        nonce += 1;\r\n        uint256 valid;\r\n        address lastSigner = 0;\r\n        for(uint256 i = 0; i < count; i++) {\r\n            (v,r,s) = splitSignature(_signatures, i);\r\n            address recovered = ecrecover(keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\",txHash)), v, r, s);\r\n            require(recovered > lastSigner, \"MSW: Badly ordered signatures\"); // make sure signers are different\r\n            lastSigner = recovered;\r\n            if(isOwner[recovered]) {\r\n                valid += 1;\r\n                if(valid >= threshold) {\r\n                    require(_to.call.value(_value)(_data), \"MSW: External call failed\");\r\n                    emit Executed(_to, _value, _data);\r\n                    return;\r\n                }\r\n            }\r\n        }\r\n        // If we reach that point then the transaction is not executed\r\n        revert(\"MSW: Not enough valid signatures\");\r\n    }\r\n\r\n    /**\r\n     * @dev Adds an owner to the multisig. This method can only be called by the multisig itself \r\n     * (i.e. it must go through the execute method and be confirmed by the owners).\r\n     * @param _owner The address of the new owner.\r\n     */\r\n    function addOwner(address _owner) public onlyWallet {\r\n        require(ownersCount < MAX_OWNER_COUNT, \"MSW: MAX_OWNER_COUNT reached\");\r\n        require(isOwner[_owner] == false, \"MSW: Already owner\");\r\n        ownersCount += 1;\r\n        isOwner[_owner] = true;\r\n        emit OwnerAdded(_owner);\r\n    }\r\n\r\n    /**\r\n     * @dev Removes an owner from the multisig. This method can only be called by the multisig itself \r\n     * (i.e. it must go through the execute method and be confirmed by the owners).\r\n     * @param _owner The address of the removed owner.\r\n     */\r\n    function removeOwner(address _owner) public onlyWallet {\r\n        require(ownersCount > threshold, \"MSW: Too few owners left\");\r\n        require(isOwner[_owner] == true, \"MSW: Not an owner\");\r\n        ownersCount -= 1;\r\n        delete isOwner[_owner];\r\n        emit OwnerRemoved(_owner);\r\n    }\r\n\r\n    /**\r\n     * @dev Changes the threshold of the multisig. This method can only be called by the multisig itself \r\n     * (i.e. it must go through the execute method and be confirmed by the owners).\r\n     * @param _newThreshold The new threshold.\r\n     */\r\n    function changeThreshold(uint256 _newThreshold) public onlyWallet {\r\n        require(_newThreshold > 0 && _newThreshold <= ownersCount, \"MSW: Invalid new threshold\");\r\n        threshold = _newThreshold;\r\n        emit ThresholdChanged(_newThreshold);\r\n    }\r\n\r\n    /**\r\n     * @dev Makes it possible for the multisig to receive ETH.\r\n     */\r\n    function () external payable {\r\n        emit Received(msg.value, msg.sender);        \r\n    }\r\n\r\n        /**\r\n     * @dev Parses the signatures and extract (r, s, v) for a signature at a given index.\r\n     * A signature is {bytes32 r}{bytes32 s}{uint8 v} in compact form and signatures are concatenated.\r\n     * @param _signatures concatenated signatures\r\n     * @param _index which signature to read (0, 1, 2, ...)\r\n     */\r\n    function splitSignature(bytes _signatures, uint256 _index) internal pure returns (uint8 v, bytes32 r, bytes32 s) {\r\n        // we jump 32 (0x20) as the first slot of bytes contains the length\r\n        // we jump 65 (0x41) per signature\r\n        // for v we load 32 bytes ending with v (the first 31 come from s) tehn apply a mask\r\n        assembly {\r\n            r := mload(add(_signatures, add(0x20,mul(0x41,_index))))\r\n            s := mload(add(_signatures, add(0x40,mul(0x41,_index))))\r\n            v := and(mload(add(_signatures, add(0x41,mul(0x41,_index)))), 0xff)\r\n        }\r\n        require(v == 27 || v == 28, \"MSW: Invalid v\"); \r\n    }\r\n\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"removeOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"threshold\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newThreshold\",\"type\":\"uint256\"}],\"name\":\"changeThreshold\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"addOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nonce\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ownersCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_OWNER_COUNT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"},{\"name\":\"_signatures\",\"type\":\"bytes\"}],\"name\":\"execute\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_threshold\",\"type\":\"uint256\"},{\"name\":\"_owners\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OwnerAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OwnerRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"newThreshold\",\"type\":\"uint256\"}],\"name\":\"ThresholdChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"destination\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"Executed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"}],\"name\":\"Received\",\"type\":\"event\"}]","ContractName":"MultiSigWallet","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"999","ConstructorArguments":"0000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000030000000000000000000000001c385bbb6bd2edb66fb5b752532b3e9ef705d25d00000000000000000000000036b300079b70822dfcd73911fc7d932f45cfb9160000000000000000000000004a804ddb1a75de64d0101d8c53f75cdcf654ff24","Library":"","SwarmSource":"bzzr://d9d09d499f1c3ba7cb8c04c07a292c5ca1b87c12de2120045d0d35a6f86db919"}]}