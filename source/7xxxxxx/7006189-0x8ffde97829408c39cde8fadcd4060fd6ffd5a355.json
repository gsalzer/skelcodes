{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.2;\r\n// This is basically a shared account in which any transactions done must be signed by multiple parties. Hence, multi-signature wallet.\r\ncontract SimpleMultiSigWallet {\r\n    struct Proposal {\r\n        uint256 amount;\r\n        address payable to;\r\n        uint8 votes;\r\n        bytes data;\r\n        mapping (address => bool) voted;\r\n    }\r\n    \r\n    mapping (bytes32 => Proposal) internal proposals;\r\n    mapping (address => uint8) public voteCount;\r\n    \r\n    uint8 constant public maximumVotes = 2; \r\n    constructor() public{\r\n        voteCount[0x8c070C3c66F62E34bAe561951450f15f3256f67c] = 1; // ARitz Cracker\r\n        voteCount[0x7ac74Fcc1a71b106F12c55ee8F802C9F672Ce40C] = 1; // Sumpunk\r\n    }\r\n    \r\n    function proposeTransaction(address payable to, uint256 amount, bytes memory data) public{\r\n        require(voteCount[msg.sender] != 0, \"You cannot vote\");\r\n        bytes32 hash = keccak256(abi.encodePacked(to, amount, data));\r\n        require(!proposals[hash].voted[msg.sender], \"Already voted\");\r\n        if (proposals[hash].votes == 0){\r\n            proposals[hash].amount = amount;\r\n            proposals[hash].to = to;\r\n            proposals[hash].data = data;\r\n            proposals[hash].votes = voteCount[msg.sender];\r\n            proposals[hash].voted[msg.sender] = true;\r\n        }else{\r\n            proposals[hash].votes += voteCount[msg.sender];\r\n            proposals[hash].voted[msg.sender] = true;\r\n            if (proposals[hash].votes >= maximumVotes){\r\n                if (proposals[hash].data.length == 0){\r\n                    proposals[hash].to.transfer(proposals[hash].amount);\r\n                }else{\r\n\t\t\t\t\tbool success;\r\n\t\t\t\t\tbytes memory returnData;\r\n\t\t\t\t\t(success, returnData) = proposals[hash].to.call.value(proposals[hash].amount)(proposals[hash].data);\r\n\t\t\t\t\trequire(success);\r\n                }\r\n                delete proposals[hash];\r\n            }\r\n        }\r\n    }\r\n    \r\n    // Yes we will take your free ERC223 tokens, thank you very much\r\n    function tokenFallback(address from, uint value, bytes memory data) public{\r\n        \r\n    }\r\n    \r\n    function() external payable{\r\n        // Accept free ETH\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"voteCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"proposeTransaction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"tokenFallback\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maximumVotes\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"}]","ContractName":"SimpleMultiSigWallet","CompilerVersion":"v0.5.2+commit.1df8f40c","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://a7ce055b075281e9e646a4326a7824a8c2e924a7beb6fcc710adeaa48719baa3"}]}