{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.0;\r\n\r\n\r\nlibrary SafeMath {\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"Assertion Failed\");\r\n        return c;\r\n    }\r\n}\r\n\r\n\r\ncontract IERC20 {\r\n    function balanceOf(address who) public view returns (uint256);\r\n    function allowance(address _owner, address _spender) public view returns (uint256);\r\n    function transfer(address to, uint256 value) public returns (bool);\r\n    function approve(address spender, uint256 value) public returns (bool);\r\n    function transferFrom(address from, address to, uint256 value) public returns (bool);\r\n}\r\n\r\n\r\ncontract KyberInterface {\r\n    function trade(\r\n        address src,\r\n        uint srcAmount,\r\n        address dest,\r\n        address destAddress,\r\n        uint maxDestAmount,\r\n        uint minConversionRate,\r\n        address walletId\r\n        ) public payable returns (uint);\r\n\r\n    function getExpectedRate(\r\n        address src,\r\n        address dest,\r\n        uint srcQty\r\n        ) public view returns (uint, uint);\r\n}\r\n\r\n\r\ncontract Helper {\r\n\r\n    using SafeMath for uint;\r\n    using SafeMath for uint256;\r\n\r\n    /**\r\n     * @dev get ethereum address for trade\r\n     */\r\n    function getAddressETH() public pure returns (address eth) {\r\n        eth = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\r\n    }\r\n\r\n    /**\r\n     * @dev get kyber proxy address\r\n     */\r\n    function getAddressKyber() public pure returns (address kyber) {\r\n        kyber = 0x818E6FECD516Ecc3849DAf6845e3EC868087B755;\r\n    }\r\n\r\n    /**\r\n     * @dev get admin address\r\n     */\r\n    function getAddressAdmin() public pure returns (address admin) {\r\n        admin = 0x7284a8451d9a0e7Dc62B3a71C0593eA2eC5c5638;\r\n    }\r\n\r\n    /**\r\n     * @dev get fees to trade // 200 => 0.2%\r\n     */\r\n    function getUintFees() public pure returns (uint fees) {\r\n        fees = 200;\r\n    }\r\n\r\n    /**\r\n     * @dev gets ETH & token balance\r\n     * @param src is the token being sold\r\n     * @return ethBal - if not erc20, eth balance\r\n     * @return tknBal - if not eth, erc20 balance\r\n     */\r\n    function getBal(address src, address _owner) public view returns (uint, uint) {\r\n        uint tknBal;\r\n        if (src != getAddressETH()) {\r\n            tknBal = IERC20(src).balanceOf(address(_owner));\r\n        }\r\n        return (address(_owner).balance, tknBal);\r\n    }\r\n\r\n    /**\r\n     * @dev getting rates from Kyber\r\n     * @param src is the token being sold\r\n     * @param dest is the token being bought\r\n     * @param srcAmt is the amount of token being sold\r\n     * @return expectedRate - the current rate\r\n     * @return slippageRate - rate with 3% slippage\r\n     */\r\n    function getExpectedRate(\r\n        address src,\r\n        address dest,\r\n        uint srcAmt\r\n    ) public view returns (\r\n        uint expectedRate,\r\n        uint slippageRate\r\n    ) \r\n    {\r\n        (expectedRate,) = KyberInterface(getAddressKyber()).getExpectedRate(src, dest, srcAmt);\r\n        slippageRate = (expectedRate / 100) * 99; // changing slippage rate upto 99%\r\n    }\r\n\r\n    /**\r\n     * @dev fetching token from the trader if ERC20\r\n     * @param trader is the trader\r\n     * @param src is the token which is being sold\r\n     * @param srcAmt is the amount of token being sold\r\n     */\r\n    function getToken(address trader, address src, uint srcAmt) internal returns (uint ethQty) {\r\n        if (src == getAddressETH()) {\r\n            require(msg.value == srcAmt, \"not-enough-src\");\r\n            ethQty = srcAmt;\r\n        } else {\r\n            manageApproval(src, srcAmt);\r\n            IERC20(src).transferFrom(trader, address(this), srcAmt);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev setting allowance to kyber for the \"user proxy\" if required\r\n     * @param token is the token address\r\n     */\r\n    function setApproval(address token) internal returns (uint) {\r\n        IERC20(token).approve(getAddressKyber(), 2**255);\r\n    }\r\n\r\n    /**\r\n     * @dev configuring token approval with user proxy\r\n     * @param token is the token\r\n     */\r\n    function manageApproval(address token, uint srcAmt) internal returns (uint) {\r\n        uint tokenAllowance = IERC20(token).allowance(address(this), getAddressKyber());\r\n        if (srcAmt > tokenAllowance) {\r\n            setApproval(token);\r\n        }\r\n    }\r\n    \r\n}\r\n\r\n\r\ncontract Swap is Helper {\r\n\r\n    /**\r\n     * @param what 0 for BUY & 1 for SELL\r\n     */\r\n    event LogTrade(\r\n        uint what, // 0 for BUY & 1 for SELL\r\n        address src,\r\n        uint srcAmt,\r\n        address dest,\r\n        uint destAmt,\r\n        address beneficiary,\r\n        uint minConversionRate,\r\n        address affiliate\r\n    );\r\n\r\n    /**\r\n     * @dev buying token where destAmt is fixed\r\n     * @param src - token to sell\r\n     * @param dest - token to buy\r\n     * @param srcAmt - token amount to sell\r\n     * @param maxDestAmt is the max amount of token to be bought\r\n     */\r\n    function buy(\r\n        address src,\r\n        address dest,\r\n        uint srcAmt,\r\n        uint maxDestAmt,\r\n        uint slippageRate\r\n    ) public payable returns (uint destAmt)\r\n    {\r\n        uint ethQty = getToken(msg.sender, src, srcAmt);\r\n\r\n        destAmt = KyberInterface(getAddressKyber()).trade.value(ethQty)(\r\n            src,\r\n            srcAmt,\r\n            dest,\r\n            msg.sender,\r\n            maxDestAmt,\r\n            slippageRate,\r\n            getAddressAdmin()\r\n        );\r\n\r\n        // maxDestAmt usecase implementated on user proxy\r\n        if (address(this).balance > 0) {\r\n            msg.sender.transfer(address(this).balance);\r\n        } else if (src != getAddressETH()) {\r\n            IERC20 srcTkn = IERC20(src);\r\n            uint srcBal = srcTkn.balanceOf(address(this));\r\n            if (srcBal > 0) {\r\n                srcTkn.transfer(msg.sender, srcBal);\r\n            }\r\n        }\r\n\r\n        emit LogTrade(\r\n            0,\r\n            src,\r\n            srcAmt,\r\n            dest,\r\n            destAmt,\r\n            msg.sender,\r\n            slippageRate,\r\n            getAddressAdmin()\r\n        );\r\n\r\n    }\r\n\r\n    /**\r\n     * @dev selling token where srcAmt is fixed\r\n     * @param src - token to sell\r\n     * @param dest - token to buy\r\n     * @param srcAmt - token amount to sell\r\n     */\r\n    function sell(\r\n        address src,\r\n        address dest,\r\n        uint srcAmt,\r\n        uint slippageRate\r\n    ) public payable returns (uint destAmt)\r\n    {\r\n        uint ethQty = getToken(msg.sender, src, srcAmt);\r\n\r\n        destAmt = KyberInterface(getAddressKyber()).trade.value(ethQty)(\r\n            src,\r\n            srcAmt,\r\n            dest,\r\n            msg.sender,\r\n            2**255,\r\n            slippageRate,\r\n            getAddressAdmin()\r\n        );\r\n\r\n        emit LogTrade(\r\n            1,\r\n            src,\r\n            srcAmt,\r\n            dest,\r\n            destAmt,\r\n            msg.sender,\r\n            slippageRate,\r\n            getAddressAdmin()\r\n        );\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\ncontract InstaTrade is Swap {\r\n\r\n    uint public version;\r\n    \r\n    /**\r\n     * @dev setting up variables on deployment\r\n     * 1...2...3 versioning in each subsequent deployments\r\n     */\r\n    constructor(uint _version) public {\r\n        version = _version;\r\n    }\r\n\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"src\",\"type\":\"address\"},{\"name\":\"dest\",\"type\":\"address\"},{\"name\":\"srcAmt\",\"type\":\"uint256\"},{\"name\":\"slippageRate\",\"type\":\"uint256\"}],\"name\":\"sell\",\"outputs\":[{\"name\":\"destAmt\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"src\",\"type\":\"address\"},{\"name\":\"dest\",\"type\":\"address\"},{\"name\":\"srcAmt\",\"type\":\"uint256\"},{\"name\":\"maxDestAmt\",\"type\":\"uint256\"},{\"name\":\"slippageRate\",\"type\":\"uint256\"}],\"name\":\"buy\",\"outputs\":[{\"name\":\"destAmt\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"src\",\"type\":\"address\"},{\"name\":\"dest\",\"type\":\"address\"},{\"name\":\"srcAmt\",\"type\":\"uint256\"}],\"name\":\"getExpectedRate\",\"outputs\":[{\"name\":\"expectedRate\",\"type\":\"uint256\"},{\"name\":\"slippageRate\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAddressKyber\",\"outputs\":[{\"name\":\"kyber\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAddressETH\",\"outputs\":[{\"name\":\"eth\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAddressAdmin\",\"outputs\":[{\"name\":\"admin\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getUintFees\",\"outputs\":[{\"name\":\"fees\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"src\",\"type\":\"address\"},{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"getBal\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_version\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"what\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"src\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"srcAmt\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"dest\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"destAmt\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"minConversionRate\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"affiliate\",\"type\":\"address\"}],\"name\":\"LogTrade\",\"type\":\"event\"}]","ContractName":"InstaTrade","CompilerVersion":"v0.5.0+commit.1d4f565a","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"0000000000000000000000000000000000000000000000000000000000000001","Library":"","SwarmSource":"bzzr://a2772edf78792bd4eccfe303fef7294b17e38840d8b98512172e5f4f238f5623"}]}