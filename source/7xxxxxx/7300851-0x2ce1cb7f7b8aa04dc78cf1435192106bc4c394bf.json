{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.0;\r\n\r\ncontract CryptoTycoonsVIPLib{\r\n    \r\n    address payable public owner;\r\n    \r\n    // Accumulated jackpot fund.\r\n    uint128 public jackpotSize;\r\n    uint128 public rankingRewardSize;\r\n    \r\n    mapping (address => uint) userExpPool;\r\n    mapping (address => bool) public callerMap;\r\n\r\n    event RankingRewardPayment(address indexed beneficiary, uint amount);\r\n\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner, \"OnlyOwner methods called by non-owner.\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyCaller {\r\n        bool isCaller = callerMap[msg.sender];\r\n        require(isCaller, \"onlyCaller methods called by non-caller.\");\r\n        _;\r\n    }\r\n\r\n    constructor() public{\r\n        owner = msg.sender;\r\n        callerMap[owner] = true;\r\n    }\r\n\r\n    // Fallback function deliberately left empty. It's primary use case\r\n    // is to top up the bank roll.\r\n    function () external payable {\r\n    }\r\n\r\n    function kill() external onlyOwner {\r\n        selfdestruct(owner);\r\n    }\r\n\r\n    function addCaller(address caller) public onlyOwner{\r\n        bool isCaller = callerMap[caller];\r\n        if (isCaller == false){\r\n            callerMap[caller] = true;\r\n        }\r\n    }\r\n\r\n    function deleteCaller(address caller) external onlyOwner {\r\n        bool isCaller = callerMap[caller];\r\n        if (isCaller == true) {\r\n            callerMap[caller] = false;\r\n        }\r\n    }\r\n\r\n    function addUserExp(address addr, uint256 amount) public onlyCaller{\r\n        uint exp = userExpPool[addr];\r\n        exp = exp + amount;\r\n        userExpPool[addr] = exp;\r\n    }\r\n\r\n    function getUserExp(address addr) public view returns(uint256 exp){\r\n        return userExpPool[addr];\r\n    }\r\n\r\n    function getVIPLevel(address user) public view returns (uint256 level) {\r\n        uint exp = userExpPool[user];\r\n\r\n        if(exp >= 25 ether && exp < 125 ether){\r\n            level = 1;\r\n        } else if(exp >= 125 ether && exp < 250 ether){\r\n            level = 2;\r\n        } else if(exp >= 250 ether && exp < 1250 ether){\r\n            level = 3;\r\n        } else if(exp >= 1250 ether && exp < 2500 ether){\r\n            level = 4;\r\n        } else if(exp >= 2500 ether && exp < 12500 ether){\r\n            level = 5;\r\n        } else if(exp >= 12500 ether && exp < 25000 ether){\r\n            level = 6;\r\n        } else if(exp >= 25000 ether && exp < 125000 ether){\r\n            level = 7;\r\n        } else if(exp >= 125000 ether && exp < 250000 ether){\r\n            level = 8;\r\n        } else if(exp >= 250000 ether && exp < 1250000 ether){\r\n            level = 9;\r\n        } else if(exp >= 1250000 ether){\r\n            level = 10;\r\n        } else{\r\n            level = 0;\r\n        }\r\n\r\n        return level;\r\n    }\r\n\r\n    function getVIPBounusRate(address user) public view returns (uint256 rate){\r\n        uint level = getVIPLevel(user);\r\n        return level;\r\n    }\r\n\r\n    // This function is used to bump up the jackpot fund. Cannot be used to lower it.\r\n    function increaseJackpot(uint increaseAmount) external onlyCaller {\r\n        require (increaseAmount <= address(this).balance, \"Increase amount larger than balance.\");\r\n        require (jackpotSize + increaseAmount <= address(this).balance, \"Not enough funds.\");\r\n        jackpotSize += uint128(increaseAmount);\r\n    }\r\n\r\n    function payJackpotReward(address payable to) external onlyCaller{\r\n        to.transfer(jackpotSize);\r\n        jackpotSize = 0;\r\n    }\r\n\r\n    function getJackpotSize() external view returns (uint256){\r\n        return jackpotSize;\r\n    }\r\n\r\n    function increaseRankingReward(uint amount) public onlyCaller{\r\n        require (amount <= address(this).balance, \"Increase amount larger than balance.\");\r\n        require (rankingRewardSize + amount <= address(this).balance, \"Not enough funds.\");\r\n        rankingRewardSize += uint128(amount);\r\n    }\r\n\r\n    function payRankingReward(address payable to) external onlyCaller {\r\n        uint128 prize = rankingRewardSize / 2;\r\n        rankingRewardSize = rankingRewardSize - prize;\r\n        if(to.send(prize)){\r\n            emit RankingRewardPayment(to, prize);\r\n        }\r\n    }\r\n\r\n    function getRankingRewardSize() external view returns (uint128){\r\n        return rankingRewardSize;\r\n    }\r\n}\r\n\r\ncontract HalfRouletteEvents {\r\n    event Commit(uint commit); // 배팅\r\n    event Payment(address indexed gambler, uint amount, uint8 betMask, uint8 l, uint8 r, uint betAmount); // 결과 처리\r\n    event Refund(address indexed gambler, uint amount); // 결과 처리\r\n    event JackpotPayment(address indexed gambler, uint amount); // 잭팟\r\n    event VIPBenefit(address indexed gambler, uint amount); // VIP 보상\r\n    event InviterBenefit(address indexed inviter, address gambler, uint amount, uint betAmount); // 초대자 보상\r\n}\r\n\r\ncontract CryptoTycoonsDApp {\r\n    address payable public owner; // 게시자\r\n    address payable nextOwner;\r\n    address secretSigner;\r\n\r\n    mapping(address => bool) public croupierMap; // 하우스 운영\r\n\r\n    address payable public VIPLibraryAddress; // vip pool address\r\n\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner, \"OnlyOwner methods called by non-owner.\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyCroupier {\r\n        bool isCroupier = croupierMap[msg.sender];\r\n        require(isCroupier, \"OnlyCroupier methods called by non-croupier.\");\r\n        _;\r\n    }\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n        croupierMap[msg.sender] = true;\r\n        secretSigner = msg.sender;\r\n    }\r\n\r\n    function () external payable {}\r\n\r\n    function approveNextOwner(address payable _nextOwner) external onlyOwner {\r\n        require(_nextOwner != owner, \"Cannot approve current owner.\");\r\n        nextOwner = _nextOwner;\r\n    }\r\n\r\n    function acceptNextOwner() external {\r\n        require(msg.sender == nextOwner, \"Can only accept preapproved new owner.\");\r\n        owner = nextOwner;\r\n    }\r\n\r\n    function setSecretSigner(address newSecretSigner) external onlyOwner {\r\n        secretSigner = newSecretSigner;\r\n    }\r\n\r\n    function addCroupier(address newCroupier) external onlyOwner {\r\n        bool isCroupier = croupierMap[newCroupier];\r\n        if (isCroupier == false) {\r\n            croupierMap[newCroupier] = true;\r\n        }\r\n    }\r\n\r\n    function deleteCroupier(address newCroupier) external onlyOwner {\r\n        bool isCroupier = croupierMap[newCroupier];\r\n        if (isCroupier == true) {\r\n            croupierMap[newCroupier] = false;\r\n        }\r\n    }\r\n\r\n    function setVIPLibraryAddress(address payable addr) external onlyOwner {\r\n        VIPLibraryAddress = addr;\r\n    }\r\n\r\n    function getMyAccuAmount() external view returns (uint) {\r\n        CryptoTycoonsVIPLib vipLib = CryptoTycoonsVIPLib(VIPLibraryAddress);\r\n        return vipLib.getUserExp(msg.sender);\r\n    }\r\n\r\n    function getJackpotSize() external view returns (uint) {\r\n        CryptoTycoonsVIPLib vipLib = CryptoTycoonsVIPLib(VIPLibraryAddress);\r\n        return vipLib.getJackpotSize();\r\n    }\r\n\r\n    function getRankingRewardSize() external view returns (uint128) {\r\n        CryptoTycoonsVIPLib vipLib = CryptoTycoonsVIPLib(VIPLibraryAddress);\r\n        return vipLib.getRankingRewardSize();\r\n    }\r\n\r\n}\r\n\r\ncontract HalfRouletteStruct {\r\n    struct Bet {\r\n        uint amount; // 배팅 금액\r\n        uint8 betMask; // 배팅 정보\r\n        uint40 placeBlockNumber; // Block number of placeBet tx.\r\n        address payable gambler; // Address of a gambler, used to pay out winning bets.\r\n    }\r\n}\r\n\r\ncontract HalfRouletteConstant {\r\n    //    constant\r\n    // EVM BLOCKHASH opcode can query no further than 256 blocks into the\r\n    // past. Given that settleBet uses block hash of placeBet as one of\r\n    // complementary entropy sources, we cannot process bets older than this\r\n    // threshold. On rare occasions AceDice croupier may fail to invoke\r\n    // settleBet in this timespan due to technical issues or extreme Ethereum\r\n    // congestion; such bets can be refunded via invoking refundBet.\r\n    uint constant BET_EXPIRATION_BLOCKS = 250;\r\n\r\n    uint constant HOUSE_EDGE_PERCENT = 1; // amount * 0.01\r\n    uint constant HOUSE_EDGE_MINIMUM_AMOUNT = 0.0004 ether; // 최소 houseEdge\r\n\r\n    uint constant RANK_FUNDS_PERCENT = 7; // amount * 0.01 * 0.07\r\n    uint constant INVITER_BENEFIT_PERCENT = 7; // amount * 0.01 * 0.07\r\n\r\n    uint constant MIN_BET = 0.01 ether; // 최소 배팅 금액\r\n    uint constant MAX_BET = 300000 ether; // 최대 배팅 금액\r\n    uint constant MIN_JACKPOT_BET = 0.1 ether;\r\n    uint constant JACKPOT_FEE = 0.001 ether;\r\n\r\n    uint constant BASE_WIN_RATE = 100000;\r\n}\r\n\r\ncontract HalfRoulettePure is HalfRouletteConstant {\r\n\r\n    function verifyBetMask(uint betMask) public pure {\r\n        bool verify;\r\n        assembly {\r\n            switch betMask\r\n            case 1 /* ODD */{verify := 1}\r\n            case 2 /* EVEN */{verify := 1}\r\n            case 4 /* LEFT */{verify := 1}\r\n            case 8 /* RIGHT */{verify := 1}\r\n            case 5 /* ODD | LEFT */{verify := 1}\r\n            case 9 /* ODD | RIGHT */{verify := 1}\r\n            case 6 /* EVEN | LEFT */{verify := 1}\r\n            case 10 /* EVEN | RIGHT */{verify := 1}\r\n            case 16 /* EQUAL */{verify := 1}\r\n        }\r\n        require(verify, \"invalid betMask\");\r\n    }\r\n\r\n    function getRecoverSigner(uint40 commitLastBlock, uint commit, uint8 v, bytes32 r, bytes32 s) public pure returns (address) {\r\n        bytes memory prefix = \"\\x19Ethereum Signed Message:\\n32\";\r\n        bytes memory message = abi.encodePacked(commitLastBlock, commit);\r\n        bytes32 messageHash = keccak256(abi.encodePacked(prefix, keccak256(message)));\r\n        return ecrecover(messageHash, v, r, s);\r\n    }\r\n\r\n    function getWinRate(uint betMask) public pure returns (uint rate) {\r\n        // assembly 안에서는 constant 사용 불가\r\n        uint ODD_EVEN_RATE = 50000;\r\n        uint LEFT_RIGHT_RATE = 45833;\r\n        uint MIX_ODD_RATE = 25000;\r\n        uint MIX_EVEN_RATE = 20833;\r\n        uint EQUAL_RATE = 8333;\r\n        assembly {\r\n            switch betMask\r\n            case 1 /* ODD */{rate := ODD_EVEN_RATE}\r\n            case 2 /* EVEN */{rate := ODD_EVEN_RATE}\r\n            case 4 /* LEFT */{rate := LEFT_RIGHT_RATE}\r\n            case 8 /* RIGHT */{rate := LEFT_RIGHT_RATE}\r\n            case 5 /* ODD | LEFT */{rate := MIX_ODD_RATE}\r\n            case 9 /* ODD | RIGHT */{rate := MIX_ODD_RATE}\r\n            case 6 /* EVEN | LEFT */{rate := MIX_EVEN_RATE}\r\n            case 10 /* EVEN | RIGHT */{rate := MIX_EVEN_RATE}\r\n            case 16 /* EQUAL */{rate := EQUAL_RATE}\r\n        }\r\n    }\r\n\r\n    function calcHouseEdge(uint amount) public pure returns (uint houseEdge) {\r\n        // 0.02\r\n        houseEdge = amount * HOUSE_EDGE_PERCENT / 100;\r\n        if (houseEdge < HOUSE_EDGE_MINIMUM_AMOUNT) {\r\n            houseEdge = HOUSE_EDGE_MINIMUM_AMOUNT;\r\n        }\r\n    }\r\n\r\n    function calcJackpotFee(uint amount) public pure returns (uint jackpotFee) {\r\n        // 0.001\r\n        if (amount >= MIN_JACKPOT_BET) {\r\n            jackpotFee = JACKPOT_FEE;\r\n        }\r\n    }\r\n\r\n    function calcRankFundsFee(uint amount) public pure returns (uint rankFundsFee) {\r\n        // 0.01 * 0.07\r\n        rankFundsFee = amount * RANK_FUNDS_PERCENT / 10000;\r\n    }\r\n\r\n    function calcInviterBenefit(uint amount) public pure returns (uint invitationFee) {\r\n        // 0.01 * 0.07\r\n        invitationFee = amount * INVITER_BENEFIT_PERCENT / 10000;\r\n    }\r\n\r\n    function getWinAmount(uint betMask, uint amount) public pure returns (uint) {\r\n        uint houseEdge = calcHouseEdge(amount);\r\n        uint jackpotFee = calcJackpotFee(amount);\r\n        uint betAmount = amount - houseEdge - jackpotFee;\r\n        uint rate = getWinRate(betMask);\r\n        return betAmount * BASE_WIN_RATE / rate;\r\n    }\r\n\r\n    function calcBetResult(uint betMask, bytes32 entropy) public pure returns (bool isWin, uint l, uint r)  {\r\n        uint v = uint(entropy);\r\n        l = (v % 12) + 1;\r\n        r = ((v >> 4) % 12) + 1;\r\n        uint mask = getResultMask(l, r);\r\n        isWin = (betMask & mask) == betMask;\r\n    }\r\n\r\n    function getResultMask(uint l, uint r) public pure returns (uint mask) {\r\n        uint v1 = (l + r) % 2;\r\n        if (v1 == 0) {\r\n            mask = mask | 2;\r\n        } else {\r\n            mask = mask | 1;\r\n        }\r\n        if (l == r) {\r\n            mask = mask | 16;\r\n        } else if (l > r) {\r\n            mask = mask | 4;\r\n        } else {\r\n            mask = mask | 8;\r\n        }\r\n        return mask;\r\n    }\r\n\r\n    function isJackpot(bytes32 entropy, uint amount) public pure returns (bool jackpot) {\r\n        return amount >= MIN_JACKPOT_BET && (uint(entropy) % 1000) == 0;\r\n    }\r\n\r\n    function verifyCommit(address signer, uint40 commitLastBlock, uint commit, uint8 v, bytes32 r, bytes32 s) internal pure {\r\n        address recoverSigner = getRecoverSigner(commitLastBlock, commit, v, r, s);\r\n        require(recoverSigner == signer, \"failed different signer\");\r\n    }\r\n\r\n    function startOfDay(uint timestamp) internal pure returns (uint64) {\r\n        return uint64(timestamp - (timestamp % 1 days));\r\n    }\r\n\r\n}\r\n\r\ncontract HalfRoulette is CryptoTycoonsDApp, HalfRouletteEvents, HalfRouletteStruct, HalfRouletteConstant, HalfRoulettePure {\r\n    uint128 public lockedInBets;\r\n\r\n    // Adjustable max bet profit. Used to cap bets against dynamic odds.\r\n    uint public maxProfit = 10 ether;\r\n\r\n    // global variable\r\n    mapping(uint => Bet) public bets;\r\n    mapping(address => address payable) public inviterMap;\r\n\r\n    function () external payable {}\r\n\r\n    function kill() external onlyOwner {\r\n        require(lockedInBets == 0, \"All bets should be processed (settled or refunded) before self-destruct.\");\r\n        selfdestruct(address(owner));\r\n    }\r\n\r\n    function setMaxProfit(uint _maxProfit) external onlyOwner {\r\n        require(_maxProfit < MAX_BET, \"maxProfit should be a sane number.\");\r\n        maxProfit = _maxProfit;\r\n    }\r\n\r\n    function placeBet(uint8 betMask, uint commitLastBlock, uint commit, uint8 v, bytes32 r, bytes32 s) public payable {\r\n        Bet storage bet = bets[commit];\r\n        require(bet.gambler == address(0), \"Bet should be in a 'clean' state.\");\r\n\r\n        // amount checked\r\n        uint amount = msg.value;\r\n        require(amount >= MIN_BET, 'failed amount >= MIN_BET');\r\n        require(amount <= MAX_BET, \"failed amount <= MAX_BET\");\r\n        // allow bet check\r\n        verifyBetMask(betMask);\r\n        // rand seed check\r\n        verifyCommit(secretSigner, uint40(commitLastBlock), commit, v, r, s);\r\n\r\n        // house balance check\r\n        uint winAmount = getWinAmount(betMask, amount);\r\n        require(winAmount <= amount + maxProfit, \"maxProfit limit violation.\");\r\n        lockedInBets += uint128(winAmount);\r\n        require(lockedInBets <= address(this).balance, \"Cannot afford to lose this bet.\");\r\n\r\n        // save\r\n        emit Commit(commit);\r\n        bet.gambler = msg.sender;\r\n        bet.amount = amount;\r\n        bet.betMask = betMask;\r\n        bet.placeBlockNumber = uint40(block.number);\r\n    }\r\n\r\n    function placeBetWithInviter(uint8 betMask, uint commitLastBlock, uint commit, uint8 v, bytes32 r, bytes32 s, address payable inviter) external payable {\r\n        require(inviter != address(0), \"inviter != address (0)\");\r\n        address preInviter = inviterMap[msg.sender];\r\n        if (preInviter == address(0)) {\r\n            inviterMap[msg.sender] = inviter;\r\n        }\r\n        placeBet(betMask, commitLastBlock, commit, v, r, s);\r\n    }\r\n\r\n    function settleBet(uint reveal, bytes32 blockHash) external onlyCroupier {\r\n        uint commit = uint(keccak256(abi.encodePacked(reveal)));\r\n\r\n        Bet storage bet = bets[commit];\r\n        uint placeBlockNumber = bet.placeBlockNumber;\r\n\r\n        // Check that bet has not expired yet (see comment to BET_EXPIRATION_BLOCKS).\r\n        require(block.number > placeBlockNumber, \"settleBet in the same block as placeBet, or before.\");\r\n        require(block.number <= placeBlockNumber + BET_EXPIRATION_BLOCKS, \"Blockhash can't be queried by EVM.\");\r\n        require(blockhash(placeBlockNumber) == blockHash);\r\n\r\n        // Settle bet using reveal and blockHash as entropy sources.\r\n        settleBetCommon(bet, reveal, blockHash);\r\n    }\r\n\r\n    function processVIPBenefit(address gambler, uint amount) internal returns (uint benefitAmount) {\r\n        CryptoTycoonsVIPLib vipLib = CryptoTycoonsVIPLib(VIPLibraryAddress);\r\n        uint rate = vipLib.getVIPBounusRate(gambler);\r\n        if (rate > 0) {\r\n            benefitAmount = amount * rate / 10000;\r\n            emit VIPBenefit(gambler, benefitAmount);\r\n        }\r\n        vipLib.addUserExp(gambler, amount);\r\n    }\r\n\r\n    function processJackpot(address payable gambler, bytes32 entropy, uint amount) internal returns (uint benefitAmount) {\r\n        if (isJackpot(entropy, amount)) {\r\n            CryptoTycoonsVIPLib vipLib = CryptoTycoonsVIPLib(VIPLibraryAddress);\r\n            uint jackpotSize = vipLib.getJackpotSize();\r\n            vipLib.payJackpotReward(gambler);\r\n            benefitAmount = jackpotSize;\r\n            emit JackpotPayment(gambler, benefitAmount);\r\n        }\r\n    }\r\n\r\n    function processRoulette(address gambler, uint betMask, bytes32 entropy, uint amount) internal returns (uint benefitAmount) {\r\n        uint winAmount = getWinAmount(betMask, amount);\r\n        lockedInBets -= uint128(winAmount);\r\n\r\n        (bool isWin, uint l, uint r) = calcBetResult(betMask, entropy);\r\n        benefitAmount = isWin ? winAmount : 0;\r\n\r\n        emit Payment(gambler, benefitAmount, uint8(betMask), uint8(l), uint8(r), amount);\r\n    }\r\n\r\n    function processInviterBenefit(address gambler, uint betAmount) internal {\r\n        address payable inviter = inviterMap[gambler];\r\n        if (inviter != address(0)) {\r\n            uint inviterBenefit = calcInviterBenefit(betAmount);\r\n            if (inviter.send(inviterBenefit)) {\r\n                emit InviterBenefit(inviter, gambler, inviterBenefit, betAmount);\r\n            }\r\n        }\r\n    }\r\n\r\n    function transferCryptoTycoonsFee(uint amount) internal {\r\n        uint jackpotFee = calcJackpotFee(amount);\r\n        uint rankFundFee = calcRankFundsFee(amount);\r\n\r\n        CryptoTycoonsVIPLib vipLib = CryptoTycoonsVIPLib(VIPLibraryAddress);\r\n        VIPLibraryAddress.transfer(rankFundFee + jackpotFee);\r\n        vipLib.increaseRankingReward(rankFundFee);\r\n        if (jackpotFee > 0) {\r\n            vipLib.increaseJackpot(jackpotFee);\r\n        }\r\n    }\r\n\r\n    function settleBetCommon(Bet storage bet, uint reveal, bytes32 entropyBlockHash) internal {\r\n        uint amount = bet.amount;\r\n\r\n        // Check that bet is in 'active' state.\r\n        require(amount != 0, \"Bet should be in an 'active' state\");\r\n        bet.amount = 0;\r\n\r\n        // The RNG - combine \"reveal\" and blockhash of placeBet using Keccak256. Miners\r\n        // are not aware of \"reveal\" and cannot deduce it from \"commit\" (as Keccak256\r\n        // preimage is intractable), and house is unable to alter the \"reveal\" after\r\n        // placeBet have been mined (as Keccak256 collision finding is also intractable).\r\n        bytes32 entropy = keccak256(abi.encodePacked(reveal, entropyBlockHash));\r\n\r\n        transferCryptoTycoonsFee(amount);\r\n\r\n        uint payout = 0;\r\n        payout += processVIPBenefit(bet.gambler, amount);\r\n        payout += processRoulette(bet.gambler, bet.betMask, entropy, amount);\r\n        processJackpot(bet.gambler, entropy, amount);\r\n        processInviterBenefit(bet.gambler, amount);\r\n\r\n        bet.gambler.transfer(payout);\r\n    }\r\n\r\n    // Refund transaction - return the bet amount of a roll that was not processed in a due timeframe.\r\n    // Processing such blocks is not possible due to EVM limitations (see BET_EXPIRATION_BLOCKS comment above for details).\r\n    // In case you ever find yourself in a situation like this, just contact the {} support, however nothing precludes you from invoking this method yourself.\r\n    function refundBet(uint commit) external {\r\n        // Check that bet is in 'active' state.\r\n        Bet storage bet = bets[commit];\r\n        uint amount = bet.amount;\r\n\r\n        require(amount != 0, \"Bet should be in an 'active' state\");\r\n\r\n        // Check that bet has already expired.\r\n        require(block.number > bet.placeBlockNumber + BET_EXPIRATION_BLOCKS, \"Blockhash can't be queried by EVM.\");\r\n\r\n        // Move bet into 'processed' state, release funds.\r\n        bet.amount = 0;\r\n\r\n        uint winAmount = getWinAmount(bet.betMask, amount);\r\n        lockedInBets -= uint128(winAmount);\r\n\r\n        // Send the refund.\r\n        bet.gambler.transfer(amount);\r\n\r\n        emit Refund(bet.gambler, amount);\r\n    }\r\n\r\n    // Funds withdrawal to cover costs of HalfRoulette operation.\r\n    function withdrawFunds(address payable beneficiary, uint withdrawAmount) external onlyOwner {\r\n        require(withdrawAmount <= address(this).balance, \"Increase amount larger than balance.\");\r\n        require(lockedInBets + withdrawAmount <= address(this).balance, \"Not enough funds.\");\r\n        beneficiary.transfer(withdrawAmount);\r\n    }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"l\",\"type\":\"uint256\"},{\"name\":\"r\",\"type\":\"uint256\"}],\"name\":\"getResultMask\",\"outputs\":[{\"name\":\"mask\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"betMask\",\"type\":\"uint8\"},{\"name\":\"commitLastBlock\",\"type\":\"uint256\"},{\"name\":\"commit\",\"type\":\"uint256\"},{\"name\":\"v\",\"type\":\"uint8\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"},{\"name\":\"inviter\",\"type\":\"address\"}],\"name\":\"placeBetWithInviter\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"calcRankFundsFee\",\"outputs\":[{\"name\":\"rankFundsFee\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"bets\",\"outputs\":[{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"betMask\",\"type\":\"uint8\"},{\"name\":\"placeBlockNumber\",\"type\":\"uint40\"},{\"name\":\"gambler\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"betMask\",\"type\":\"uint256\"}],\"name\":\"verifyBetMask\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"setVIPLibraryAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"kill\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newCroupier\",\"type\":\"address\"}],\"name\":\"addCroupier\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"calcHouseEdge\",\"outputs\":[{\"name\":\"houseEdge\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getRankingRewardSize\",\"outputs\":[{\"name\":\"\",\"type\":\"uint128\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"betMask\",\"type\":\"uint256\"},{\"name\":\"entropy\",\"type\":\"bytes32\"}],\"name\":\"calcBetResult\",\"outputs\":[{\"name\":\"isWin\",\"type\":\"bool\"},{\"name\":\"l\",\"type\":\"uint256\"},{\"name\":\"r\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"betMask\",\"type\":\"uint256\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"getWinAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"commitLastBlock\",\"type\":\"uint40\"},{\"name\":\"commit\",\"type\":\"uint256\"},{\"name\":\"v\",\"type\":\"uint8\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"getRecoverSigner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"inviterMap\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"croupierMap\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"calcJackpotFee\",\"outputs\":[{\"name\":\"jackpotFee\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"betMask\",\"type\":\"uint256\"}],\"name\":\"getWinRate\",\"outputs\":[{\"name\":\"rate\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getMyAccuAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"VIPLibraryAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxProfit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"beneficiary\",\"type\":\"address\"},{\"name\":\"withdrawAmount\",\"type\":\"uint256\"}],\"name\":\"withdrawFunds\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"reveal\",\"type\":\"uint256\"},{\"name\":\"blockHash\",\"type\":\"bytes32\"}],\"name\":\"settleBet\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptNextOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newCroupier\",\"type\":\"address\"}],\"name\":\"deleteCroupier\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_nextOwner\",\"type\":\"address\"}],\"name\":\"approveNextOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newSecretSigner\",\"type\":\"address\"}],\"name\":\"setSecretSigner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lockedInBets\",\"outputs\":[{\"name\":\"\",\"type\":\"uint128\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"commit\",\"type\":\"uint256\"}],\"name\":\"refundBet\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"betMask\",\"type\":\"uint8\"},{\"name\":\"commitLastBlock\",\"type\":\"uint256\"},{\"name\":\"commit\",\"type\":\"uint256\"},{\"name\":\"v\",\"type\":\"uint8\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"placeBet\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getJackpotSize\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"calcInviterBenefit\",\"outputs\":[{\"name\":\"invitationFee\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_maxProfit\",\"type\":\"uint256\"}],\"name\":\"setMaxProfit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"entropy\",\"type\":\"bytes32\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"isJackpot\",\"outputs\":[{\"name\":\"jackpot\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"commit\",\"type\":\"uint256\"}],\"name\":\"Commit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"gambler\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"betMask\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"l\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"r\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"betAmount\",\"type\":\"uint256\"}],\"name\":\"Payment\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"gambler\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Refund\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"gambler\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"JackpotPayment\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"gambler\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"VIPBenefit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"inviter\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"gambler\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"betAmount\",\"type\":\"uint256\"}],\"name\":\"InviterBenefit\",\"type\":\"event\"}]","ContractName":"HalfRoulette","CompilerVersion":"v0.5.2+commit.1df8f40c","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://f175de35023fe4dd1281cbe328fc82d4b5534e115cc845918711f5e248a24579"}]}