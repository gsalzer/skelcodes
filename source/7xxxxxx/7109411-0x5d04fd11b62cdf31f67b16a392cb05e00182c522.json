{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.4;\r\n  //ENG::This code is a part of game on www.fgames.io\r\n  //ENG::If you found any bug or have an idea, contact us on code@fgames.io\r\n  //RUS::Этот код является частью игры на сайте www.fgames.io\r\n  //RUS::Если вы нашли баги или есть идеи, пишите нам code@fgames.io\r\ncontract playFive {\r\n  //ENG::Declare variable we use\r\n  //RUS::Декларируем переменные\r\n  address private creator;\r\n  string private message;\r\n  string private message_details;\r\n  string private referal;\r\n  uint private totalBalance; \r\n  uint public totalwin;\r\n  \r\n  //ENG::Сonstructor\r\n  //Конструктор\r\n  /*\r\n  constructor() public {\r\n\r\n    creator = tx.origin;   \r\n    message = 'initiated';\r\n  }\r\n  */\r\n\r\n\r\n  \r\n\r\n\r\n  //ENG::Function that show Creator adress\r\n  //RUS::Функция которая отобразит адресс создателя контракта\r\n  function getCreator() public constant returns(address) {\r\n    return creator;\r\n  }\r\n\r\n  //ENG::Function that show SmarrtContract Balance\r\n  //Функция которая отобразит Баланс СмартКонтракта\r\n  function getTotalBalance() public constant returns(uint) {\r\n    return address(this).balance;\r\n  }  \r\n  \r\n\r\n//ENG::One of the best way to compare two strings converted to bytes\r\n//ENG::Function will check length and if bytes length is same then calculate hash of strings and compare it, (a1)\r\n//ENG::if strings the same, return true, otherwise return false (a2)\r\n//RUS::Один из лучших вариантов сравнения стринг переменных сконвертированные а байты\r\n//RUS::Сначала функция сравнивает длинну байткода и послк их хэш (a1)\r\n//RUS::Если хэш одинаковый, то возвращает true, иначе - false (a2)\r\n\r\nfunction hashCompareWithLengthCheck(string a, string b) internal pure returns (bool) {\r\n    if(bytes(a).length != bytes(b).length) { //(a1)\r\n        return false;\r\n    } else {\r\n        return keccak256(abi.encodePacked(a)) == keccak256(abi.encodePacked(b)); //(a2)\r\n    }\r\n}\r\n\r\n//ENG::Function that calculate Wining points\r\n//ENG::After we get our *play ticket* adress, we take last 5 chars of it and game is on\r\n//ENG::sendTXTpsTX - main game function, send to this function *play ticket* code and player entered symbols \r\n//ENG::function starting setted initiated results to nothing (b1)\r\n//ENG::Then converting strings to bytes, so we can run throung each symbol (b2)\r\n//ENG::Also we set initial winpoint to 0 (b3)\r\n//ENG::Then we run throught each symbol in *play ticket* and compare it with player entered symbols\r\n//ENG::player entered symbols maximum length also is five\r\n//ENG::if function found a match using *hashCompareWithLengthCheck* function, then\r\n//ENG::function add to event message details, that shows whats symbols are found whith player entered symbols (b4)\r\n//ENG::replace used symbols in *player ticket* and entered symbols on X and Y so they no more used in game process (b5)\r\n//ENG::and increase winpoit by 1 (b6)\r\n//ENG::after function complete, it return winpoint from 0 - 5 (b7)\r\n//RUS::Функция которая высчитывает количество очков\r\n//RUS::После получения адреса *билета*, мы берем его последнии 5 символов и игра началась\r\n//RUS::sendTXTpsTX - главная функция игры, шлёт этой функции символы билета и символы введеные игроком\r\n//RUS::Функция сначало обнуляет детали переменной результата (b1)\r\n//RUS::После конвертирует *билет* и символы игрока в байты, чтобы можно было пройти по символам (b2)\r\n//RUS::Также ставим начальное количество очков на 0 (b3)\r\n//RUS::Далее мы проверяем совпадают ли символы *билета* с символами которые ввел игрок\r\n//RUS::Максимальная длинна символов которые вводит игрок, тоже 5.\r\n//RUS::Если функция находит совпадение с помощью функции *hashCompareWithLengthCheck*, то\r\n//RUS::Функция добавляет к эвэнту детальное сообщение о том, какие символы были найдены (b4)\r\n//RUS::Заменяет найденные символы в *билете* и *ключе* на X и Y и они более не участвуют в игре (b5)\r\n//RUS::Увеличивает количество баллов winpoint на 1 (b6)\r\n//RUS::По звыершению, возвращает значение winpoint от 0 до 5 (b7)\r\nfunction check_result(string ticket, string check) public  returns (uint) {\r\n  message_details = \"\"; //(b1)\r\n    bytes memory ticketBytes = bytes(ticket); //(b2)\r\n    bytes memory checkBytes = bytes(check);   //(b2) \r\n    uint winpoint = 0; //(b3)\r\n\r\n\r\n    for (uint i=0; i < 5; i++){\r\n\r\n      for (uint j=0; j < 5; j++){\r\n\r\n        if(hashCompareWithLengthCheck(string(abi.encodePacked(ticketBytes[j])),string(abi.encodePacked(checkBytes[i]))))\r\n        {\r\n          message_details = string(abi.encodePacked(message_details,'*',ticketBytes[j],'**',checkBytes[i])); //(b4)\r\n          ticketBytes[j] =\"X\"; //(b5)\r\n          checkBytes[i] = \"Y\"; //(b5)\r\n\r\n          winpoint = winpoint+1; //(b6)         \r\n        }\r\n       \r\n      }\r\n\r\n    }    \r\n    return uint(winpoint); //(b7)\r\n  }\r\n\r\n//ENG::Function destroy this smartContract\r\n//ENG::Thats needed in case if we create new game, to take founds from it and add to new game \r\n//ENG::Or also it need if we see that current game not so actual, and we need to transfer founds to a new game, that more popular\r\n//ENG::Or in case if we found any critical bug, to take founds in safe place, while fixing bugs.\r\n//RUS::Функция для уничтожения смарт контракта\r\n//RUS::Это необходимо, чтобы при создании новых игр, можно было разделить Баланс текущей игры с новой игрой\r\n//RUS::Или если при создании новых игр, эта потеряет свою актуальность\r\n//RUS::Либо при обнаружении критических багое, перевести средства в безопастное место на время исправления ошибок\r\n  function resetGame () public {\r\n    if (msg.sender == creator) { \r\n      selfdestruct(0xdC3df52BB1D116471F18B4931895d91eEefdC2B3); \r\n      return;\r\n    }\r\n  }\r\n\r\n//ENG::Function to substring provided string from provided start position until end position\r\n//ENG::It's need to tak last 5 characters from *ticket* adress\r\n//RUS::Функция для обрезания заданной строки с заданной позиции до заданной конечной позиции\r\n//RUS::Это надо, чтобы получить последние 5 символов с адресса *билета*\r\nfunction substring(string str, uint startIndex, uint endIndex) public pure returns (string) {\r\n    bytes memory strBytes = bytes(str);\r\n    bytes memory result = new bytes(endIndex-startIndex);\r\n    for(uint i = startIndex; i < endIndex; i++) {\r\n        result[i-startIndex] = strBytes[i];\r\n    }\r\n    return string(result);\r\n  }\r\n\r\n//ENG::Also very useful function, to make all symbols in string to lowercase\r\n//ENG::That need in case to lowercase *TICKET* adress and Player provided symbols\r\n//ENG::Because adress can be 0xasdf...FFDDEE123 and player can provide ACfE4. but we all convert to one format. lowercase\r\n//RUS::Тоже очень полезная функция, чтобы перевести все символы в нижний регистр\r\n//RUS::Это надо, чтобы привести в единый формат все такие переменные как *Билет* и *Ключ*\r\n//RUS::Так как адресс билета может быть 0xasdf...FFDDEE123, а также игрок может ввести ACfE4.\r\n\tfunction _toLower(string str) internal pure returns (string) {\r\n\t\tbytes memory bStr = bytes(str);\r\n\t\tbytes memory bLower = new bytes(bStr.length);\r\n\t\tfor (uint i = 0; i < bStr.length; i++) {\r\n\t\t\t// Uppercase character...\r\n\t\t\tif ((bStr[i] >= 65) && (bStr[i] <= 90)) {\r\n\t\t\t\t// So we add 32 to make it lowercase\r\n\t\t\t\tbLower[i] = bytes1(int(bStr[i]) + 32);\r\n\t\t\t} else {\r\n\t\t\t\tbLower[i] = bStr[i];\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn string(bLower);\r\n\t}\r\n\r\n  //ENG::Standart Function to receive founds\r\n  //RUS::Стандартная функция для приёма средств\r\n  function () payable public {\r\n    //RECEIVED    \r\n  }\r\n\r\n  //ENG::Converts adress type into string\r\n  //ENG::Used to convert *TICKET* adress into string\r\n  //RUS::Конвертирует переменную типа adress в строку string\r\n  //RUS::Используется для конвертации адреса *билета* в строку string\r\n  \r\nfunction addressToString(address _addr) public pure returns(string) {\r\n    bytes32 value = bytes32(uint256(_addr));\r\n    bytes memory alphabet = \"0123456789abcdef\";\r\n\r\n    bytes memory str = new bytes(42);\r\n    str[0] = '0';\r\n    str[1] = 'x';\r\n    for (uint i = 0; i < 20; i++) {\r\n        str[2+i*2] = alphabet[uint(value[i + 12] >> 4)];\r\n        str[3+i*2] = alphabet[uint(value[i + 12] & 0x0f)];\r\n    }\r\n    return string(str);\r\n}\r\n\r\n\r\n  //ENG::Get last blockhash symbols and converts into string\r\n  //ENG::Used to convert *TICKET* hash into string\r\n  //RUS::Получаемонвертирует переменную типа adress в строку string\r\n  //RUS::Используется для конвертации адреса *билета* в строку string\r\n\r\nfunction blockhashToString(bytes32 _blockhash_to_decode) public pure returns(string) {\r\n    bytes32 value = _blockhash_to_decode;\r\n    bytes memory alphabet = \"0123456789abcdef\";\r\n\r\n    bytes memory str = new bytes(42);\r\n    str[0] = '0';\r\n    str[1] = 'x';\r\n    for (uint i = 0; i < 20; i++) {\r\n        str[2+i*2] = alphabet[uint(value[i + 12] >> 4)];\r\n        str[3+i*2] = alphabet[uint(value[i + 12] & 0x0f)];\r\n    }\r\n    return string(str);\r\n}\r\n\r\n  //ENG::Converts uint type into STRING to show data in human readable format\r\n  //RUS::Конвертирует переменную uint в строку string чтобы отобразить данные в понятном для человека формате\r\nfunction uint2str(uint i) internal pure returns (string){\r\n    if (i == 0) return \"0\";\r\n    uint j = i;\r\n    uint length;\r\n    while (j != 0){\r\n        length++;\r\n        j /= 10;\r\n    }\r\n    bytes memory bstr = new bytes(length);\r\n    uint k = length - 1;\r\n    while (i != 0){\r\n        bstr[k--] = byte(48 + i % 10);\r\n        i /= 10;\r\n    }\r\n    return string(bstr);\r\n}\r\n\r\n\r\n//ENG::This simple function, clone existing contract into new contract, to gain TOTALLY UNICALLY random string of *TICKET*\r\n//RUS::Эта простая функция клонирует текущий контракт в новый контракт, чтобы получить 100% уникальную переменную *БИЛЕТА*\r\n\r\nfunction isContract(address _addr) private view returns (bool OKisContract){\r\n  uint32 size;\r\n  assembly {\r\n    size := extcodesize(_addr)\r\n  }\r\n  return (size > 0);\r\n}\r\n\r\n\r\n\r\n  //ENG::Event which will be visible in transaction logs in etherscan, and will have result data, whats will be parsed and showed on website\r\n  //RUS::Эвент который будет виден а логах транзакции, и отобразит строку с полезными данными для анализа и после вывода их на сайте\r\n  event ok_statusGame(address u_address, string u_key, uint u_bet, uint u_blocknum, string u_ref, string u_blockhash, uint winpoint,uint totalwin);\r\n\r\n  struct EntityStruct {\r\n    address u_address;\r\n    string u_key;\r\n    uint u_bet;\r\n    uint u_blocknum;\r\n    string u_ref;\r\n    uint listPointer;\r\n  }\r\n\r\n  mapping(address => EntityStruct) public entityStructs;\r\n  address[] public entityList;\r\n\r\n  function isEntity(address entityAddress) public constant returns(bool isIndeed) {\r\n    if(entityList.length == 0) return false;\r\n    return (entityList[entityStructs[entityAddress].listPointer] == entityAddress);\r\n  }\r\n\r\n\r\n\r\n\r\n//ENG::Main function whats called from a website.\r\n//ENG::To provide best service. performance and support we take DevFee 13.3% of transaction (c1)\r\n//ENG::Using of *blockhash* function to get HASH of block in which previous player transaction was maded (c2)\r\n//ENG::to generate TOTALLY random symbols which nobody can know until block is mined (c2)\r\n//ENG::Used check_result function we get winpoint value (c3)\r\n//ENG::If winpoint value is 0 or 1 point - player wins 0 ETH (c4)\r\n//ENG::if winpoint value is 2 then player wins 165% from (BET - 13.3%) (c5)\r\n//ENG::if winpoint value is 3 then player wins 315% from (BET - 13.3%) (c6)\r\n//ENG::if winpoint value is 4 then player wins 515% from (BET - 13.3%) (c7)\r\n//ENG::if winpoint value is 5 then player wins 3333% from (BET - 13.3%) (c8)\r\n//ENG::If win amount is greater the smartcontract have, then player got 90% of smart contract balance (c9)\r\n//ENG::On Website before place bet, player will see smartcontract current balance (maximum to wim)\r\n//ENG::when win amount was calculated it automatically sends to player adress (c10)\r\n//ENG::After all steps completed, SmartContract will generate message for EVENT,\r\n//ENG::EVENT Message will have description of current game, and will have those fields which will be displayed on website:\r\n//ENG::Player Address/ Player provided symbols / Player BET / Block Number Transaction played / Partner id / Little ticket / Player score / Player Win amount / \r\n//ENG::Полный адресс *игрока* / Символы введенные игроком / Ставку / Номер блока в котором играли / Ид партнёра / Укороченный билет / Очки игрока / Суммы выйгрыша / \r\n//RUS::Главная функция которая вызывается непосредственно с сайта.\r\n//RUS::Чтобы обеспечивать качественный сервис, развивать и создавать новые игры, мы берем комиссию 13,3% от размера ставки (c1)\r\n//RUS::Используем функцию *blockhash* для добычи хеша блока в котором была сделана транзакция предыдущего игрока, (c2)\r\n//RUS::Для того, чтобы добится 100% УНИКАЛЬНОГО *билета* (c2)\r\n//RUS::Используем check_result функцию чтобы узнать значение winpoint (c3)\r\n//RUS::Если значение winpoint 0 или 1 - выйгрыш игрока 0 ETH (c4)\r\n//RUS::Если значение winpoint 2 - выйгрыш игрока 165% от (СТАВКА - 13.3%) (c5)\r\n//RUS::Если значение winpoint 3 - выйгрыш игрока 315% от (СТАВКА - 13.3%) (c6)\r\n//RUS::Если значение winpoint 4 - выйгрыш игрока 515% от (СТАВКА - 13.3%) (c7)\r\n//RUS::Если значение winpoint 5 - выйгрыш игрока 3333% от (СТАВКА - 13.3%) (c8)\r\n//RUS::Если сумма выйгрыша больше баланса смарт контракта, то игрок получает 90% от баланса смарт контракта (c9)\r\n//RUS::На сайте игрок заранее видет баланс смарт контракта на текущий момент (максимальный выйгрыш)\r\n//RUS::После вычисления суммы выйгрыша, выйгрышь автоматом перечисляется на адресс игрока (c10)\r\n//RUS::После завершения всех шагов, смарт контракт генерирует сообщение для ЭВЕНТА\r\n//RUS::Сообщение ЭВЕНТА хранит в себе ключевые показатели сыграной игры, и красиво в понятной форме будут отображены на сайте\r\n//RUS::Что содержит сообщение ЭВЕНТА:\r\n//RUS::Полный адресс *игрока* / Символы введенные игроком / Ставку / Номер блока / Ид партнёра / Укороченный билет / Очки игрока / Суммы выйгрыша / \r\n\r\n\r\n  function PlayFiveChain(string _u_key, string _u_ref ) public payable returns(bool success) {\r\n    \r\n    //ENG::AntiRobot Captcha\r\n    //RUS::Капча против ботов \r\n    require(tx.origin == msg.sender);\r\n    if(isContract(msg.sender))\r\n    {\r\n      return;\r\n    }    \r\n\r\n    if(!isEntity(address(this))) \r\n    {\r\n      //ENG:need to fill array at first init\r\n      //RUS:необходимо для начального заполнения массива\r\n      \r\n      entityStructs[address(this)].u_address = msg.sender;\r\n      entityStructs[address(this)].u_key = _u_key;\r\n      entityStructs[address(this)].u_bet = msg.value;      \r\n      entityStructs[address(this)].u_blocknum = block.number;\r\n      entityStructs[address(this)].u_ref = _u_ref;                        \r\n      entityStructs[address(this)].listPointer = entityList.push(address(this)) - 1;\r\n      return true;\r\n    }\r\n    else\r\n    {\r\n      address(0xdC3df52BB1D116471F18B4931895d91eEefdC2B3).transfer((msg.value/1000)*133); //(c1)          \r\n      string memory calculate_userhash = substring(blockhashToString(blockhash(entityStructs[address(this)].u_blocknum)),37,42); //(c2)\r\n      string memory calculate_userhash_to_log = substring(blockhashToString(blockhash(entityStructs[address(this)].u_blocknum)),37,42);//(c2)\r\n      uint winpoint = check_result(calculate_userhash,_toLower(entityStructs[address(this)].u_key));//(c3)\r\n      \r\n\r\n    if(winpoint == 0)\r\n    {\r\n      totalwin = 0; //(c4)\r\n    }\r\n    if(winpoint == 1)\r\n    {\r\n      totalwin = 0; //(c4)\r\n    }\r\n    if(winpoint == 2)\r\n    {\r\n      totalwin = ((entityStructs[address(this)].u_bet - (entityStructs[address(this)].u_bet/1000)*133)/100)*165; //(c5)\r\n    }\r\n    if(winpoint == 3)\r\n    {\r\n      totalwin = ((entityStructs[address(this)].u_bet - (entityStructs[address(this)].u_bet/1000)*133)/100)*315; //(c6)\r\n    }            \r\n    if(winpoint == 4)\r\n    {\r\n      totalwin = ((entityStructs[address(this)].u_bet - (entityStructs[address(this)].u_bet/1000)*133)/100)*515; //(c7)\r\n    }\r\n    if(winpoint == 5)\r\n    {\r\n      totalwin = ((entityStructs[address(this)].u_bet - (entityStructs[address(this)].u_bet/1000)*133)/100)*3333; //(c8)\r\n    } \r\n\r\n    if(totalwin > 0)    \r\n    {\r\n      if(totalwin > address(this).balance)\r\n      {\r\n        totalwin = ((address(this).balance/100)*90); //(c9)\r\n      }\r\n      address(entityStructs[address(this)].u_address).transfer(totalwin); //(c10)         \r\n    }\r\n\r\n\r\n      \r\n      emit ok_statusGame(entityStructs[address(this)].u_address, entityStructs[address(this)].u_key, entityStructs[address(this)].u_bet, entityStructs[address(this)].u_blocknum, entityStructs[address(this)].u_ref, calculate_userhash_to_log,winpoint,totalwin);      \r\n      \r\n      //ENG:: Filling array with current player values\r\n      //ENG:: In Next time when contract called will be processed previous player data to calculate prize\r\n      //RUS:: Заполняем массив данными текущего игрока\r\n      //RUS:: При следующем вызове контракта будут использоватся данные предыдущего игрока для вычисления выйгрыша\r\n      entityStructs[address(this)].u_address = msg.sender;\r\n      entityStructs[address(this)].u_key = _u_key;\r\n      entityStructs[address(this)].u_bet = msg.value;      \r\n      entityStructs[address(this)].u_blocknum = block.number;\r\n      entityStructs[address(this)].u_ref = _u_ref;                        \r\n    }\r\n    return;\r\n  }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"getCreator\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTotalBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"entityAddress\",\"type\":\"address\"}],\"name\":\"isEntity\",\"outputs\":[{\"name\":\"isIndeed\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"str\",\"type\":\"string\"},{\"name\":\"startIndex\",\"type\":\"uint256\"},{\"name\":\"endIndex\",\"type\":\"uint256\"}],\"name\":\"substring\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"ticket\",\"type\":\"string\"},{\"name\":\"check\",\"type\":\"string\"}],\"name\":\"check_result\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"entityList\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"entityStructs\",\"outputs\":[{\"name\":\"u_address\",\"type\":\"address\"},{\"name\":\"u_key\",\"type\":\"string\"},{\"name\":\"u_bet\",\"type\":\"uint256\"},{\"name\":\"u_blocknum\",\"type\":\"uint256\"},{\"name\":\"u_ref\",\"type\":\"string\"},{\"name\":\"listPointer\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"addressToString\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_u_key\",\"type\":\"string\"},{\"name\":\"_u_ref\",\"type\":\"string\"}],\"name\":\"PlayFiveChain\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_blockhash_to_decode\",\"type\":\"bytes32\"}],\"name\":\"blockhashToString\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"resetGame\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalwin\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"u_address\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"u_key\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"u_bet\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"u_blocknum\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"u_ref\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"u_blockhash\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"winpoint\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"totalwin\",\"type\":\"uint256\"}],\"name\":\"ok_statusGame\",\"type\":\"event\"}]","ContractName":"playFive","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://ecd4094ed1f4c0a8e67afd5720c5e8863e3e7072e1be140d61e4622412e8693c"}]}