{"status":"1","message":"OK","result":[{"SourceCode":"{\"AdminManaged.sol\":{\"content\":\"pragma solidity \\u003e=0.5.3 \\u003c 0.6.0;\\r\\nimport { Roles } from \\\"./Roles.sol\\\";\\r\\n\\r\\ncontract AdminManaged{\\r\\n    using Roles for Roles.Role;\\r\\n\\r\\n    Roles.Role internal admins_;\\r\\n\\r\\n    constructor(address _firstAdmin) public {\\r\\n        admins_.add(_firstAdmin);\\r\\n    }\\r\\n\\r\\n    modifier onlyAdmin() {\\r\\n        require(admins_.has(msg.sender), \\\"User not authorised\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /// @dev    Used to add an admin \\r\\n    /// @param _newAdmin        :address The address of the new admin\\r\\n    function addAdmin(address _newAdmin) external onlyAdmin {\\r\\n        admins_.add(_newAdmin);\\r\\n        require(admins_.has(_newAdmin), \\\"User not added as admin\\\");\\r\\n    }\\r\\n\\r\\n    /// @dev    Used to remove admins\\r\\n    /// @param _oldAdmin        :address The address of the previous admin\\r\\n    function removeAdmin(address _oldAdmin) external onlyAdmin {\\r\\n        admins_.remove(_oldAdmin);\\r\\n        require(!admins_.has(_oldAdmin), \\\"User not removed as admin\\\");\\r\\n    }\\r\\n\\r\\n    /// @dev    Checking admin rights\\r\\n    /// @param _account         :address in question \\r\\n    /// @return bool            \\r\\n    function isAdmin(address _account) external view returns(bool) {\\r\\n        return admins_.has(_account);\\r\\n    }\\r\\n\\r\\n}\"},\"BaseFactory.sol\":{\"content\":\"pragma solidity \\u003e=0.5.3 \\u003c 0.6.0;\\r\\n\\r\\ncontract BaseFactory {\\r\\n    address internal admin_;\\r\\n    mapping(address =\\u003e bool) internal rootFactories_;\\r\\n\\r\\n    constructor(address _rootFactory) public {\\r\\n        rootFactories_[_rootFactory] = true;\\r\\n        admin_ = msg.sender;\\r\\n    }\\r\\n\\r\\n    modifier onlyAdmin() {\\r\\n        require(msg.sender == admin_, \\\"Not authorised\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier onlyRootFactory() {\\r\\n        require(rootFactories_[msg.sender], \\\"Not authorised\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    function addRootFactory(address _newRoot) external onlyAdmin() {\\r\\n        rootFactories_[_newRoot] = true;\\r\\n    }\\r\\n\\r\\n    function removeRootFactory(address _newRoot) external onlyAdmin() {\\r\\n        rootFactories_[_newRoot] = false;\\r\\n    }\\r\\n}\"},\"IERC20.sol\":{\"content\":\"pragma solidity \\u003e=0.5.3 \\u003c 0.6.0;\\r\\n\\r\\n/**\\r\\n * @title ERC20 interface\\r\\n * @dev see https://github.com/ethereum/EIPs/issues/20\\r\\n */\\r\\ninterface IERC20 {\\r\\n  function totalSupply() external view returns (uint256);\\r\\n\\r\\n  function balanceOf(address who) external view returns (uint256);\\r\\n\\r\\n  function allowance(address owner, address spender)\\r\\n    external view returns (uint256);\\r\\n\\r\\n  function transfer(address to, uint256 value) external returns (bool);\\r\\n\\r\\n  function approve(address spender, uint256 value)\\r\\n    external returns (bool);\\r\\n\\r\\n  function transferFrom(address from, address to, uint256 value)\\r\\n    external returns (bool);\\r\\n\\r\\n  event Transfer(\\r\\n    address indexed from,\\r\\n    address indexed to,\\r\\n    uint256 value\\r\\n  );\\r\\n\\r\\n  event Approval(\\r\\n    address indexed owner,\\r\\n    address indexed spender,\\r\\n    uint256 value\\r\\n  );\\r\\n}\\r\\n\"},\"IMembershipFactory.sol\":{\"content\":\"pragma solidity \\u003e=0.5.3 \\u003c 0.6.0;\\r\\n\\r\\ninterface IMembershipFactory{\\r\\n    // TODO: comments\\r\\n    function deployMembershipManager(address _communityManager) external returns (address);\\r\\n\\r\\n    function initialize(address _tokenManager, address _target) external;\\r\\n\\r\\n}\"},\"IMembershipManager.sol\":{\"content\":\"pragma solidity \\u003e=0.5.3 \\u003c 0.6.0;\\r\\n\\r\\n/// @author Ryan @ Protea \\r\\n/// @title IMembershipManager\\r\\ninterface IMembershipManager {\\r\\n    struct RegisteredUtility{\\r\\n        bool active;\\r\\n        mapping(uint256 =\\u003e uint256) lockedStakePool; // Total Stake withheld by the utility\\r\\n        mapping(uint256 =\\u003e mapping(address =\\u003e uint256)) contributions; // Traking individual token values sent in\\r\\n    }\\r\\n\\r\\n    struct Membership{\\r\\n        uint256 currentDate;\\r\\n        uint256 availableStake;\\r\\n        uint256 reputation;\\r\\n    }\\r\\n\\r\\n    event UtilityAdded(address issuer);\\r\\n    event UtilityRemoved(address issuer);\\r\\n    event ReputationRewardSet(address indexed issuer, uint8 id, uint256 amount);\\r\\n\\r\\n    event StakeLocked(address indexed member, address indexed utility, uint256 tokenAmount);\\r\\n    event StakeUnlocked(address indexed member, address indexed utility, uint256 tokenAmount);\\r\\n\\r\\n    event MembershipStaked(address indexed member, uint256 tokensStaked);\\r\\n   \\r\\n    function initialize(address _tokenManager) external returns(bool);\\r\\n\\r\\n    function addUtility(address _utility) external;\\r\\n\\r\\n    function removeUtility(address _utility) external;\\r\\n\\r\\n    function addAdmin(address _newAdmin) external;\\r\\n\\r\\n    function addSystemAdmin(address _newAdmin) external;\\r\\n\\r\\n    function removeAdmin(address _newAdmin) external;\\r\\n\\r\\n    function removeSystemAdmin(address _newAdmin) external;\\r\\n\\r\\n    function setReputationRewardEvent(address _utility, uint8 _id, uint256 _rewardAmount) external;\\r\\n\\r\\n    function issueReputationReward(address _member, uint8 _rewardId) external returns (bool);\\r\\n  \\r\\n    function stakeMembership(uint256 _daiValue, address _member) external returns(bool);\\r\\n\\r\\n    function manualTransfer(uint256 _tokenAmount, uint256 _index, address _member) external returns (bool);\\r\\n\\r\\n    function withdrawMembership(uint256 _daiValue, address _member) external returns(bool);\\r\\n\\r\\n    function lockCommitment(address _member, uint256 _index, uint256 _daiValue) external returns (bool);\\r\\n\\r\\n    function unlockCommitment(address _member, uint256 _index, uint8 _reputationEvent) external returns (bool);\\r\\n\\r\\n    function reputationOf(address _account) external view returns(uint256);\\r\\n\\r\\n    function getMembershipStatus(address _member) external view returns(uint256, uint256, uint256);\\r\\n\\r\\n    function getUtilityStake(address _utility, uint256 _index) external view returns(uint256);\\r\\n    \\r\\n    function getMemberUtilityStake(address _utility, address _member, uint256 _index) external view returns(uint256);\\r\\n\\r\\n    function getReputationRewardEvent(address _utility, uint8 _id) external view returns(uint256);\\r\\n\\r\\n    function tokenManager() external view returns(address);\\r\\n}\"},\"ITokenManager.sol\":{\"content\":\"pragma solidity \\u003e=0.5.3 \\u003c 0.6.0;\\r\\n\\r\\n/// @author Ryan @ Protea \\r\\n/// @title ERC20 compliant interface for Token Manager  \\r\\ninterface ITokenManager {\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n    event Transfer(address indexed from, address indexed to, uint value);\\r\\n\\r\\n    /// @dev                Transfer ownership token from msg.sender to a specified address\\r\\n    /// @param _to          :address The address to transfer to.\\r\\n    /// @param _value       :uint256 The amount to be transferred.\\r\\n    function transfer(address _to, uint256 _value) external returns (bool);\\r\\n\\r\\n    /// @dev                Transfer tokens from one address to another\\r\\n    /// @param _from        :address The address which you want to send tokens from\\r\\n    /// @param _to          :address The address which you want to transfer to\\r\\n    /// @param _value       :uint256 the amount of tokens to be transferred\\r\\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);\\r\\n\\r\\n    /// @dev                This function returns the amount of tokens one can receive for a specified amount of collateral token\\r\\n    ///                     Including Protea \\u0026 Community contributions\\r\\n    /// @param  _colateralTokenOffered  :uint256 Amount of reserve token offered for purchase\\r\\n    function colateralToTokenBuying(uint256 _colateralTokenOffered) external view returns(uint256);\\r\\n\\r\\n    /// @dev                 This function returns the amount of tokens needed to be burnt to withdraw a specified amount of reserve token\\r\\n    ///                                 Including Protea \\u0026 Community contributions\\r\\n    /// @param  _collateralTokenNeeded  :uint256 Amount of dai to be withdraw\\r\\n    function colateralToTokenSelling(uint256 _collateralTokenNeeded) external view returns(uint256);\\r\\n\\r\\n    /// @dev               Returns the required collateral amount for a volume of bonding curve tokens\\r\\n    /// @return            Required collateral corrected for decimals\\r\\n    function priceToMint(uint256 _numTokens) external view returns(uint256);\\r\\n\\r\\n    /// @dev                Returns the required collateral amount for a volume of bonding curve tokens\\r\\n    /// @return             Potential return collateral corrected for decimals\\r\\n    function rewardForBurn(uint256 _numTokens) external view returns(uint256);\\r\\n\\r\\n    /// @dev                Selling tokens back to the bonding curve for collateral\\r\\n    /// @param _numTokens   The number of tokens that you want to burn\\r\\n    function burn(uint256 _numTokens) external returns(bool);\\r\\n\\r\\n    /// @dev                Mint new tokens with ether\\r\\n    /// @param _to          :address Address to mint tokens to\\r\\n    /// @param _numTokens   :uint256 The number of tokens you want to mint\\r\\n    /// @dev                We have modified the minting function to divert a portion of the purchase tokens\\r\\n    function mint(address _to, uint256 _numTokens) external returns(bool);\\r\\n\\r\\n    /// @dev                Gets the value of the current allowance specifed for that account\\r\\n    /// @param _owner       :address The account sending the funds.\\r\\n    /// @param _spender     :address The account that will receive the funds.\\r\\n    /// @return             An uint256 representing the amount owned by the passed address.\\r\\n    function allowance(address _owner, address _spender) external view returns (uint256);\\r\\n    \\r\\n    /// @dev                Gets the balance of the specified address.\\r\\n    /// @param _spender     :address The account that will receive the funds.\\r\\n    /// @param _value       :uint256 The value of funds accessed.\\r\\n    /// @return             :boolean Indicating the action was successful.\\r\\n    function approve(address _spender, uint256 _value) external returns (bool success);\\r\\n    \\r\\n    /// @dev                Gets the balance of the specified address.\\r\\n    /// @param _owner       :address The address to query the the balance of.\\r\\n    /// @return             An uint256 representing the amount owned by the passed address.\\r\\n    function balanceOf(address _owner) external view returns (uint256);\\r\\n\\r\\n    /// @dev                Total number of tokens in existence\\r\\n    /// @return             A uint256 representing the total supply of tokens in this market\\r\\n    function totalSupply() external view returns (uint256);\\r\\n\\r\\n}\"},\"MembershipManagerV1.sol\":{\"content\":\"pragma solidity \\u003e=0.5.3 \\u003c 0.6.0;\\r\\n\\r\\nimport { IERC20 } from \\\"./IERC20.sol\\\";\\r\\nimport { SafeMath } from \\\"./SafeMath.sol\\\";\\r\\nimport { Roles } from \\\"./Roles.sol\\\";\\r\\nimport { ITokenManager } from \\\"./ITokenManager.sol\\\";\\r\\nimport { AdminManaged } from \\\"./AdminManaged.sol\\\";\\r\\n\\r\\n// Use Library for Roles: https://openzeppelin.org/api/docs/learn-about-access-control.html\\r\\n\\r\\n/// @author Ryan @ Protea\\r\\n/// @title V1 Membership Manager\\r\\ncontract MembershipManagerV1 is AdminManaged {\\r\\n    using SafeMath for uint256;\\r\\n    using Roles for Roles.Role;\\r\\n\\r\\n    address internal tokenManager_;\\r\\n    uint8 internal membershipTypeTotal_;\\r\\n\\r\\n    bool internal disabled = false;\\r\\n\\r\\n    Roles.Role internal systemAdmins_;\\r\\n\\r\\n    mapping(address =\\u003e RegisteredUtility) internal registeredUtility_;\\r\\n    mapping(address =\\u003e mapping (uint8 =\\u003e uint256)) internal reputationRewards_;\\r\\n\\r\\n    mapping(address =\\u003e Membership) internal membershipState_;\\r\\n\\r\\n    struct RegisteredUtility{\\r\\n        bool active;\\r\\n        mapping(uint256 =\\u003e uint256) lockedStakePool; // Total Stake withheld by the utility\\r\\n        mapping(uint256 =\\u003e mapping(address =\\u003e uint256)) contributions; // Traking individual token values sent in\\r\\n    }\\r\\n\\r\\n    struct Membership{\\r\\n        uint256 currentDate;\\r\\n        uint256 availableStake;\\r\\n        uint256 reputation;\\r\\n    }\\r\\n\\r\\n    event UtilityAdded(address issuer);\\r\\n    event UtilityRemoved(address issuer);\\r\\n    event ReputationRewardSet(address indexed issuer, uint8 id, uint256 amount);\\r\\n\\r\\n    event StakeLocked(address indexed member, address indexed utility, uint256 tokenAmount);\\r\\n    event StakeUnlocked(address indexed member, address indexed utility, uint256 tokenAmount);\\r\\n\\r\\n    event MembershipStaked(address indexed member, uint256 tokensStaked);\\r\\n    event MembershipWithdrawn(address indexed member, uint256 tokensWithdrawn);\\r\\n\\r\\n    /// @param _communityManager    The first admin and publisher of the community\\r\\n    constructor(address _communityManager)\\r\\n        public\\r\\n        AdminManaged(_communityManager)\\r\\n    {\\r\\n        systemAdmins_.add(_communityManager);\\r\\n        systemAdmins_.add(msg.sender); // This allows the deployer to set the membership manager\\r\\n        admins_.add(msg.sender);\\r\\n    }\\r\\n\\r\\n    modifier onlySystemAdmin() {\\r\\n        require(systemAdmins_.has(msg.sender), \\\"User not authorised\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier onlyUtility(address _utilityAddress){\\r\\n        require(registeredUtility_[_utilityAddress].active, \\\"Address is not a registered utility\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier notDisabled() {\\r\\n        require(disabled == false, \\\"Membership manager locked for migration\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /// @dev    Used to initalise the contract after the token manager is deployed\\r\\n    /// @param _tokenManager    :address The address of the new token manager\\r\\n    /// @return bool            Returns a bool for requires to validate\\r\\n    function initialize(address _tokenManager) external onlySystemAdmin returns(bool) {\\r\\n        require(tokenManager_ == address(0), \\\"Contracts initalised\\\");\\r\\n        tokenManager_ = _tokenManager;\\r\\n        systemAdmins_.remove(msg.sender);\\r\\n        admins_.remove(msg.sender);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /// @dev    Used to lock all incomming token functions \\u0026 reputation for migrating to a new manager\\r\\n    /// @return bool            Returns a bool for requires to validate\\r\\n    function disableForMigration() external onlySystemAdmin returns(bool) {\\r\\n        disabled = true;\\r\\n        return disabled;\\r\\n    }\\r\\n\\r\\n\\r\\n    /// @dev    Used to register a utility for access to the membership manager\\r\\n    /// @param _utility         :address The utility in question\\r\\n    // Rough gas usage 44,950\\r\\n    function addUtility(address _utility) external onlyAdmin{\\r\\n        registeredUtility_[_utility].active = true;\\r\\n        emit UtilityAdded(_utility);\\r\\n    }\\r\\n\\r\\n    /// @dev    Used to remove a utility\\u0027s access from the membership manager\\r\\n    /// @param _utility         :address The utility in question\\r\\n    function removeUtility(address _utility) external onlyAdmin {\\r\\n        registeredUtility_[_utility].active = false;\\r\\n        emit UtilityRemoved(_utility);\\r\\n    }\\r\\n\\r\\n    /// @dev    Used to add an admin\\r\\n    /// @param _newAdmin        :address The address of the new admin\\r\\n    function addAdmin(address _newAdmin) external onlyAdmin {\\r\\n        admins_.add(_newAdmin);\\r\\n    }\\r\\n\\r\\n    /// @dev    Used to add a system admin\\r\\n    /// @param _newAdmin        :address The address of the new admin\\r\\n    function addSystemAdmin(address _newAdmin) external onlySystemAdmin {\\r\\n        systemAdmins_.add(_newAdmin);\\r\\n    }\\r\\n\\r\\n    /// @dev    Used to remove admins\\r\\n    /// @param _oldAdmin        :address The address of the previous admin\\r\\n    function removeAdmin(address _oldAdmin) external onlyAdmin {\\r\\n        admins_.remove(_oldAdmin);\\r\\n    }\\r\\n\\r\\n    /// @dev    Used to remove system admins\\r\\n    /// @param _oldAdmin        :address The address of the previous admin\\r\\n    function removeSystemAdmin(address _oldAdmin) external onlySystemAdmin {\\r\\n        systemAdmins_.remove(_oldAdmin);\\r\\n    }\\r\\n\\r\\n    /// @dev    Registers a reputation incrementing event for a utility to use\\r\\n    /// @param _utility         :address    The utility in question\\r\\n    /// @param _id              :uint8      The registered reputation increment\\r\\n    /// @param _rewardAmount    :uint256    The amount that the event adds to a users reputation\\r\\n    // Rough gas usage 45,824\\r\\n    function setReputationRewardEvent(address _utility, uint8 _id, uint256 _rewardAmount) external onlySystemAdmin{\\r\\n        reputationRewards_[_utility][_id] = _rewardAmount;\\r\\n        emit ReputationRewardSet(_utility, _id, _rewardAmount);\\r\\n    }\\r\\n\\r\\n    /// @dev    Used by utilities to increment a users reputation values\\r\\n    /// @param _member          :address    The member address\\r\\n    /// @param _rewardId        :uint8      The registered reputation increment\\r\\n    /// @return bool            Returns a bool for requires to validate\\r\\n    function issueReputationReward(address _member, uint8 _rewardId) public notDisabled() onlyUtility(msg.sender) returns (bool) {\\r\\n        membershipState_[_member].reputation = membershipState_[_member].reputation.add(reputationRewards_[msg.sender][_rewardId]);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /// @dev    Used to inject tokens for utility access into a users membership account\\r\\n    /// @param _daiValue        :uint256    The value in DAI of tokens to extract\\r\\n    /// @param _member          :address    The member address\\r\\n    /// @return bool            Returns a bool for requires to validate\\r\\n    // Rough gas usage 102,245\\r\\n    function stakeMembership(uint256 _daiValue, address _member) external notDisabled() returns(bool) {\\r\\n        uint256 requiredTokens = ITokenManager(tokenManager_).colateralToTokenSelling(_daiValue);\\r\\n        require(ITokenManager(tokenManager_).transferFrom(_member, address(this), requiredTokens), \\\"Transfer was not complete\\\");\\r\\n        if(membershipState_[_member].currentDate == 0){\\r\\n            membershipState_[_member].currentDate = now;\\r\\n        }\\r\\n        membershipState_[_member].availableStake = membershipState_[_member].availableStake.add(requiredTokens);\\r\\n\\r\\n        emit MembershipStaked(_member, requiredTokens);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /// @dev    Used to manually send tokens sitting in a utility pool, either unclaimed or requiring distribution by the utility\\r\\n    /// @param _tokenAmount     :uint256    The amount of community tokens to send\\r\\n    /// @param _index           :uint256    The utility activity index\\r\\n    /// @param _member          :address    The member address\\r\\n    /// @return bool            Returns a bool for requires to validate\\r\\n    function manualTransfer(uint256 _tokenAmount, uint256 _index, address _member) external onlyUtility(msg.sender) returns (bool) {\\r\\n        require(registeredUtility_[msg.sender].lockedStakePool[_index] \\u003e= _tokenAmount, \\\"Insufficient tokens available\\\");\\r\\n\\r\\n        registeredUtility_[msg.sender].lockedStakePool[_index] = registeredUtility_[msg.sender].lockedStakePool[_index].sub(_tokenAmount);\\r\\n        membershipState_[_member].availableStake = membershipState_[_member].availableStake.add(_tokenAmount);\\r\\n\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /// @dev    Used to extract tokens from the membership manager to the users account\\r\\n    /// @param _daiValue        :uint256    The value in DAI of tokens to extract\\r\\n    /// @param _member          :address    The member address\\r\\n    /// @return bool            Returns a bool for requires to validate\\r\\n    function withdrawMembership(uint256 _daiValue, address _member) external returns(bool) {\\r\\n        uint256 withdrawAmount = ITokenManager(tokenManager_).colateralToTokenSelling(_daiValue);\\r\\n        require(membershipState_[_member].availableStake \\u003e= withdrawAmount, \\\"Not enough stake to fulfil request\\\");\\r\\n        membershipState_[_member].availableStake = membershipState_[_member].availableStake.sub(withdrawAmount);\\r\\n        require(ITokenManager(tokenManager_).transfer(_member, withdrawAmount), \\\"Transfer was not complete\\\");\\r\\n        emit MembershipWithdrawn(_member, withdrawAmount);\\r\\n    }\\r\\n\\r\\n    /// @dev    Used to lock up tokens for access to a utilities features\\r\\n    /// @param _member          :address    The member address\\r\\n    /// @param _index           :uint256    The utility activity index\\r\\n    /// @param _daiValue        :uint256    The value in DAI of tokens needed to use the utility\\r\\n    /// @return bool            Returns a bool for requires to validate\\r\\n    function lockCommitment(address _member, uint256 _index, uint256 _daiValue) external notDisabled() onlyUtility(msg.sender) returns (bool) {\\r\\n        uint256 requiredTokens = ITokenManager(tokenManager_).colateralToTokenSelling(_daiValue);\\r\\n        require(membershipState_[_member].availableStake \\u003e= requiredTokens, \\\"Not enough available commitment\\\");\\r\\n        require(msg.sender != _member, \\\"Address invalid\\\");\\r\\n\\r\\n        membershipState_[_member].availableStake = membershipState_[_member].availableStake.sub(requiredTokens);\\r\\n\\r\\n        registeredUtility_[msg.sender].contributions[_index][_member] = registeredUtility_[msg.sender].contributions[_index][_member].add(requiredTokens);\\r\\n        registeredUtility_[msg.sender].lockedStakePool[_index] = registeredUtility_[msg.sender].lockedStakePool[_index].add(requiredTokens);\\r\\n\\r\\n        emit StakeLocked(_member, msg.sender, requiredTokens);\\r\\n\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /// @dev    Used to return stake to a user having previously been locked up in a utility for use\\r\\n    /// @param _member          :address    The member address\\r\\n    /// @param _index           :uint256    The utility activity index\\r\\n    /// @return bool            Returns a bool for requires to validate\\r\\n    function unlockCommitment(address _member, uint256 _index, uint8 _reputationEvent) external onlyUtility(msg.sender) returns (bool) {\\r\\n        uint256 returnAmount = registeredUtility_[msg.sender].contributions[_index][_member];\\r\\n\\r\\n        require(registeredUtility_[msg.sender].lockedStakePool[_index] \\u003e= returnAmount, \\\"Insufficient tokens available\\\");\\r\\n        registeredUtility_[msg.sender].contributions[_index][_member] = 0;\\r\\n        registeredUtility_[msg.sender].lockedStakePool[_index] = registeredUtility_[msg.sender].lockedStakePool[_index].sub(returnAmount);\\r\\n\\r\\n        membershipState_[_member].availableStake = membershipState_[_member].availableStake.add(returnAmount);\\r\\n        require(issueReputationReward(_member, _reputationEvent), \\\"Reputation not increased\\\");\\r\\n        emit StakeUnlocked(_member, msg.sender, returnAmount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /// @dev    Returns the details on a members contributions, reputation and date data\\r\\n    /// @param _member          :address    The member address\\r\\n    /// @return (uint256, uint256, uint256)     The date field, reputation and current available stake\\r\\n    function getMembershipStatus(address _member)\\r\\n        public\\r\\n        view\\r\\n        returns(uint256, uint256, uint256)\\r\\n    {\\r\\n        return (\\r\\n            membershipState_[_member].currentDate,\\r\\n            membershipState_[_member].reputation,\\r\\n            membershipState_[_member].availableStake\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /// @dev    Checks if an address is a registered or active utility\\r\\n    /// @param _utility         :address    Address to check if is a registered utility\\r\\n    /// @return bool            Bool stating if valid\\r\\n    function isRegistered(address _utility) external view returns(bool) {\\r\\n        return registeredUtility_[_utility].active;\\r\\n    }\\r\\n\\r\\n    /// @dev    Used to see the total amount of contributions sitting in a utility\\u0027s activity\\r\\n    /// @param _utility         :address    The utility in question\\r\\n    /// @param _index           :uint256    The utility activity index\\r\\n    /// @return uint256         Total active contributions locked up but the activity\\r\\n    function getUtilityStake(address _utility, uint256 _index) external view returns(uint256) {\\r\\n        return registeredUtility_[_utility].lockedStakePool[_index];\\r\\n    }\\r\\n\\r\\n    /// @dev    Used to track the contribution of tokens a user has sent to the utility\\u0027s activity\\r\\n    /// @param _utility         :address    The utility in question\\r\\n    /// @param _member          :address    The member contributing\\r\\n    /// @param _index           :uint256    The utility activity index\\r\\n    /// @return uint256         Current contribution for that member on the utility activty\\r\\n    function getMemberUtilityStake(address _utility, address _member, uint256 _index) external view returns(uint256) {\\r\\n        return registeredUtility_[_utility].contributions[_index][_member];\\r\\n    }\\r\\n\\r\\n    /// @dev    Used to check the current reward amount for the utilities reputation increasing event\\r\\n    /// @param _utility         :address    The utility in question\\r\\n    /// @param _id              :uint8      The registered reputation increment\\r\\n    /// @return uint256         The amount that the event adds to a users reputation\\r\\n    function getReputationRewardEvent(address _utility, uint8 _id) external view returns(uint256){\\r\\n        return reputationRewards_[_utility][_id];\\r\\n    }\\r\\n\\r\\n    /// @dev    Used to return the registered token manager, works like an initialisation check\\r\\n    /// @return                 :address Token manager address\\r\\n    function tokenManager() external view returns(address) {\\r\\n        return tokenManager_;\\r\\n    }\\r\\n\\r\\n}\"},\"MembershipManagerV1Factory.sol\":{\"content\":\"pragma solidity \\u003e=0.5.3 \\u003c 0.6.0;\\r\\n\\r\\nimport { MembershipManagerV1 } from \\\"./MembershipManagerV1.sol\\\";\\r\\nimport { IMembershipManager } from \\\"./IMembershipManager.sol\\\";\\r\\nimport { BaseFactory } from \\\"./BaseFactory.sol\\\";\\r\\nimport { IMembershipFactory } from \\\"./IMembershipFactory.sol\\\";\\r\\n\\r\\ncontract MembershipManagerV1Factory is BaseFactory, IMembershipFactory {\\r\\n    constructor(address _rootFactory) public BaseFactory(_rootFactory) {\\r\\n\\r\\n    }\\r\\n    function deployMembershipManager(address _communityManager) external onlyRootFactory() returns (address) {\\r\\n        return address(new MembershipManagerV1(_communityManager));\\r\\n    }\\r\\n\\r\\n    function initialize(address _tokenManager, address _target) external onlyRootFactory(){\\r\\n        IMembershipManager(_target).initialize(_tokenManager);\\r\\n    }\\r\\n}\"},\"Roles.sol\":{\"content\":\"pragma solidity \\u003e=0.5.3 \\u003c 0.6.0;\\r\\n\\r\\n/**\\r\\n * @title Roles\\r\\n * @dev Library for managing addresses assigned to a Role.\\r\\n */\\r\\nlibrary Roles {\\r\\n    struct Role {\\r\\n        mapping (address =\\u003e bool) bearer;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev give an account access to this role\\r\\n     */\\r\\n    function add(Role storage role, address account) internal {\\r\\n        require(account != address(0));\\r\\n        require(!has(role, account));\\r\\n\\r\\n        role.bearer[account] = true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev remove an account\\u0027s access to this role\\r\\n     */\\r\\n    function remove(Role storage role, address account) internal {\\r\\n        require(account != address(0));\\r\\n        require(has(role, account));\\r\\n\\r\\n        role.bearer[account] = false;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev check if an account has this role\\r\\n     * @return bool\\r\\n     */\\r\\n    function has(Role storage role, address account)\\r\\n      internal\\r\\n      view\\r\\n      returns (bool)\\r\\n    {\\r\\n        require(account != address(0));\\r\\n        return role.bearer[account];\\r\\n    }\\r\\n}\\r\\n\"},\"SafeMath.sol\":{\"content\":\"pragma solidity \\u003e=0.5.3 \\u003c 0.6.0;\\r\\n\\r\\n/**\\r\\n * @title SafeMath\\r\\n * @dev Math operations with safety checks that revert on error\\r\\n */\\r\\nlibrary SafeMath {\\r\\n\\r\\n  /**\\r\\n  * @dev Multiplies two numbers, reverts on overflow.\\r\\n  */\\r\\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n    // Gas optimization: this is cheaper than requiring \\u0027a\\u0027 not being zero, but the\\r\\n    // benefit is lost if \\u0027b\\u0027 is also tested.\\r\\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\\r\\n    if (a == 0) {\\r\\n      return 0;\\r\\n    }\\r\\n\\r\\n    uint256 c = a * b;\\r\\n    require(c / a == b);\\r\\n\\r\\n    return c;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n  * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\\r\\n  */\\r\\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n    require(b \\u003e 0); // Solidity only automatically asserts when dividing by 0\\r\\n    uint256 c = a / b;\\r\\n    // assert(a == b * c + a % b); // There is no case in which this doesn\\u0027t hold\\r\\n\\r\\n    return c;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n  * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\\r\\n  */\\r\\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n    require(b \\u003c= a);\\r\\n    uint256 c = a - b;\\r\\n\\r\\n    return c;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n  * @dev Adds two numbers, reverts on overflow.\\r\\n  */\\r\\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n    uint256 c = a + b;\\r\\n    require(c \\u003e= a);\\r\\n\\r\\n    return c;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n  * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\\r\\n  * reverts when dividing by zero.\\r\\n  */\\r\\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n    require(b != 0);\\r\\n    return a % b;\\r\\n  }\\r\\n}\\r\\n\"}}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_tokenManager\",\"type\":\"address\"},{\"name\":\"_target\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newRoot\",\"type\":\"address\"}],\"name\":\"removeRootFactory\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_communityManager\",\"type\":\"address\"}],\"name\":\"deployMembershipManager\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newRoot\",\"type\":\"address\"}],\"name\":\"addRootFactory\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_rootFactory\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"}]","ContractName":"MembershipManagerV1Factory","CompilerVersion":"v0.5.4+commit.9549d8ff","OptimizationUsed":"1","Runs":"999","ConstructorArguments":"000000000000000000000000c5af5f868eff2f7cc49d7be5362c505bd5bec06a","Library":"","SwarmSource":"bzzr://c56811412cf818b6cf141b1466aaa52111e0202a936e8dfa69c6525b14520c1a"}]}