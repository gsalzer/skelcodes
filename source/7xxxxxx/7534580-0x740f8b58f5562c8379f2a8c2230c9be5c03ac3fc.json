{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.24;\r\n\r\ncontract DSAuthority {\r\n    function canCall(address src, address dst, bytes4 sig) public view returns (bool);\r\n}\r\n\r\n\r\ncontract DSAuthEvents {\r\n    event LogSetAuthority (address indexed authority);\r\n    event LogSetOwner     (address indexed owner);\r\n}\r\n\r\n\r\ncontract DSAuth is DSAuthEvents {\r\n    DSAuthority  public  authority;\r\n    address      public  owner;\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n        emit LogSetOwner(msg.sender);\r\n    }\r\n\r\n    function setOwner(address owner_)\r\n        public\r\n        auth\r\n    {\r\n        owner = owner_;\r\n        emit LogSetOwner(owner);\r\n    }\r\n\r\n    function setAuthority(DSAuthority authority_)\r\n        public\r\n        auth\r\n    {\r\n        authority = authority_;\r\n        emit LogSetAuthority(authority);\r\n    }\r\n\r\n    modifier auth {\r\n        require(isAuthorized(msg.sender, msg.sig), \"DSAuth::_ SENDER_NOT_AUTHORIZED\");\r\n        _;\r\n    }\r\n\r\n    function isAuthorized(address src, bytes4 sig) internal view returns (bool) {\r\n        if (src == address(this)) {\r\n            return true;\r\n        } else if (src == owner) {\r\n            return true;\r\n        } else if (authority == DSAuthority(0)) {\r\n            return false;\r\n        } else {\r\n            return authority.canCall(src, this, sig);\r\n        }\r\n    }\r\n}\r\n\r\n\r\ncontract Proxy {\r\n\r\n    // masterCopy always needs to be first declared variable, to ensure that it is at the same location in the contracts to which calls are delegated.\r\n    address masterCopy;\r\n\r\n    /// @dev Constructor function sets address of master copy contract.\r\n    /// @param _masterCopy Master copy address.\r\n    constructor(address _masterCopy)\r\n        public\r\n    {\r\n        require(_masterCopy != 0, \"Invalid master copy address provided\");\r\n        masterCopy = _masterCopy;\r\n    }\r\n\r\n    /// @dev Fallback function forwards all transactions and returns all received return data.\r\n    function ()\r\n        external\r\n        payable\r\n    {\r\n        // solium-disable-next-line security/no-inline-assembly\r\n        assembly {\r\n            let masterCopy := and(sload(0), 0xffffffffffffffffffffffffffffffffffffffff)\r\n            calldatacopy(0, 0, calldatasize())\r\n            let success := delegatecall(gas, masterCopy, 0, calldatasize(), 0, 0)\r\n            returndatacopy(0, 0, returndatasize())\r\n            if eq(success, 0) { revert(0, returndatasize()) }\r\n            return(0, returndatasize())\r\n        }\r\n    }\r\n\r\n    function implementation()\r\n        public\r\n        view\r\n        returns (address)\r\n    {\r\n        return masterCopy;\r\n    }\r\n\r\n    function proxyType()\r\n        public\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return 2;\r\n    }\r\n}\r\n\r\n\r\ncontract ErrorUtils {\r\n\r\n    event LogError(string methodSig, string errMsg);\r\n    event LogErrorWithHintBytes32(bytes32 indexed bytes32Value, string methodSig, string errMsg);\r\n    event LogErrorWithHintAddress(address indexed addressValue, string methodSig, string errMsg);\r\n\r\n}\r\n\r\n\r\ncontract DSMath {\r\n    function add(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x + y) >= x);\r\n    }\r\n    function sub(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x - y) <= x);\r\n    }\r\n    function mul(uint x, uint y) internal pure returns (uint z) {\r\n        require(y == 0 || (z = x * y) / y == x);\r\n    }\r\n\r\n    // custom : not in original DSMath, putting it here for consistency, copied from SafeMath\r\n    function div(uint x, uint y) internal pure returns (uint z) {\r\n        z = x / y;\r\n    }\r\n\r\n    function min(uint x, uint y) internal pure returns (uint z) {\r\n        return x <= y ? x : y;\r\n    }\r\n    function max(uint x, uint y) internal pure returns (uint z) {\r\n        return x >= y ? x : y;\r\n    }\r\n    function imin(int x, int y) internal pure returns (int z) {\r\n        return x <= y ? x : y;\r\n    }\r\n    function imax(int x, int y) internal pure returns (int z) {\r\n        return x >= y ? x : y;\r\n    }\r\n\r\n    uint constant WAD = 10 ** 18;\r\n    uint constant RAY = 10 ** 27;\r\n\r\n    function wmul(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, y), WAD / 2) / WAD;\r\n    }\r\n    function rmul(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, y), RAY / 2) / RAY;\r\n    }\r\n    function wdiv(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, WAD), y / 2) / y;\r\n    }\r\n    function rdiv(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, RAY), y / 2) / y;\r\n    }\r\n\r\n    // This famous algorithm is called \"exponentiation by squaring\"\r\n    // and calculates x^n with x as fixed-point and n as regular unsigned.\r\n    //\r\n    // It's O(log n), instead of O(n) for naive repeated multiplication.\r\n    //\r\n    // These facts are why it works:\r\n    //\r\n    //  If n is even, then x^n = (x^2)^(n/2).\r\n    //  If n is odd,  then x^n = x * x^(n-1),\r\n    //   and applying the equation for even x gives\r\n    //    x^n = x * (x^2)^((n-1) / 2).\r\n    //\r\n    //  Also, EVM division is flooring and\r\n    //    floor[(n-1) / 2] = floor[n / 2].\r\n    //\r\n    function rpow(uint x, uint n) internal pure returns (uint z) {\r\n        z = n % 2 != 0 ? x : RAY;\r\n\r\n        for (n /= 2; n != 0; n /= 2) {\r\n            x = rmul(x, x);\r\n\r\n            if (n % 2 != 0) {\r\n                z = rmul(z, x);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n\r\ncontract SelfAuthorized {\r\n    modifier authorized() {\r\n        require(msg.sender == address(this), \"Method can only be called from this contract\");\r\n        _;\r\n    }\r\n}\r\n\r\n\r\ncontract DSNote {\r\n    event LogNote(\r\n        bytes4   indexed  sig,\r\n        address  indexed  guy,\r\n        bytes32  indexed  foo,\r\n        bytes32  indexed  bar,\r\n        uint              wad,\r\n        bytes             fax\r\n    ) anonymous;\r\n\r\n    modifier note {\r\n        bytes32 foo;\r\n        bytes32 bar;\r\n\r\n        assembly {\r\n            foo := calldataload(4)\r\n            bar := calldataload(36)\r\n        }\r\n\r\n        emit LogNote(msg.sig, msg.sender, foo, bar, msg.value, msg.data);\r\n\r\n        _;\r\n    }\r\n}\r\n\r\n\r\ncontract Utils {\r\n\r\n    modifier addressValid(address _address) {\r\n        require(_address != address(0), \"Utils::_ INVALID_ADDRESS\");\r\n        _;\r\n    }\r\n\r\n}\r\n\r\n\r\ncontract WETH9 {\r\n    string public name     = \"Wrapped Ether\";\r\n    string public symbol   = \"WETH\";\r\n    uint8  public decimals = 18;\r\n\r\n    event  Approval(address indexed _owner, address indexed _spender, uint _value);\r\n    event  Transfer(address indexed _from, address indexed _to, uint _value);\r\n    event  Deposit(address indexed _owner, uint _value);\r\n    event  Withdrawal(address indexed _owner, uint _value);\r\n\r\n    mapping (address => uint)                       public  balanceOf;\r\n    mapping (address => mapping (address => uint))  public  allowance;\r\n\r\n    function() public payable {\r\n        deposit();\r\n    }\r\n\r\n    function deposit() public payable {\r\n        balanceOf[msg.sender] += msg.value;\r\n        Deposit(msg.sender, msg.value);\r\n    }\r\n\r\n    function withdraw(uint wad) public {\r\n        require(balanceOf[msg.sender] >= wad);\r\n        balanceOf[msg.sender] -= wad;\r\n        msg.sender.transfer(wad);\r\n        Withdrawal(msg.sender, wad);\r\n    }\r\n\r\n    function totalSupply() public view returns (uint) {\r\n        return this.balance;\r\n    }\r\n\r\n    function approve(address guy, uint wad) public returns (bool) {\r\n        allowance[msg.sender][guy] = wad;\r\n        Approval(msg.sender, guy, wad);\r\n        return true;\r\n    }\r\n\r\n    function transfer(address dst, uint wad) public returns (bool) {\r\n        return transferFrom(msg.sender, dst, wad);\r\n    }\r\n\r\n    function transferFrom(address src, address dst, uint wad)\r\n        public\r\n        returns (bool)\r\n    {\r\n        require(balanceOf[src] >= wad);\r\n\r\n        if (src != msg.sender && allowance[src][msg.sender] != uint(-1)) {\r\n            require(allowance[src][msg.sender] >= wad);\r\n            allowance[src][msg.sender] -= wad;\r\n        }\r\n\r\n        balanceOf[src] -= wad;\r\n        balanceOf[dst] += wad;\r\n\r\n        Transfer(src, dst, wad);\r\n\r\n        return true;\r\n    }\r\n}\r\n\r\n\r\ncontract DateTime {\r\n    /*\r\n        *  Date and Time utilities for ethereum contracts\r\n        *\r\n        */\r\n    struct _DateTime {\r\n        uint16 year;\r\n        uint8 month;\r\n        uint8 day;\r\n        uint8 hour;\r\n        uint8 minute;\r\n        uint8 second;\r\n        uint8 weekday;\r\n    }\r\n\r\n    uint constant DAY_IN_SECONDS = 86400;\r\n    uint constant YEAR_IN_SECONDS = 31536000;\r\n    uint constant LEAP_YEAR_IN_SECONDS = 31622400;\r\n\r\n    uint constant HOUR_IN_SECONDS = 3600;\r\n    uint constant MINUTE_IN_SECONDS = 60;\r\n\r\n    uint16 constant ORIGIN_YEAR = 1970;\r\n\r\n    function isLeapYear(uint16 year) public pure returns (bool) {\r\n        if (year % 4 != 0) {\r\n            return false;\r\n        }\r\n        if (year % 100 != 0) {\r\n            return true;\r\n        }\r\n        if (year % 400 != 0) {\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    function leapYearsBefore(uint year) public pure returns (uint) {\r\n        year -= 1;\r\n        return year / 4 - year / 100 + year / 400;\r\n    }\r\n\r\n    function getDaysInMonth(uint8 month, uint16 year) public pure returns (uint8) {\r\n        if (month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12) {\r\n            return 31;\r\n        }\r\n        else if (month == 4 || month == 6 || month == 9 || month == 11) {\r\n            return 30;\r\n        }\r\n        else if (isLeapYear(year)) {\r\n            return 29;\r\n        }\r\n        else {\r\n            return 28;\r\n        }\r\n    }\r\n\r\n    function parseTimestamp(uint timestamp) internal pure returns (_DateTime dt) {\r\n        uint secondsAccountedFor = 0;\r\n        uint buf;\r\n        uint8 i;\r\n\r\n        // Year\r\n        dt.year = getYear(timestamp);\r\n        buf = leapYearsBefore(dt.year) - leapYearsBefore(ORIGIN_YEAR);\r\n\r\n        secondsAccountedFor += LEAP_YEAR_IN_SECONDS * buf;\r\n        secondsAccountedFor += YEAR_IN_SECONDS * (dt.year - ORIGIN_YEAR - buf);\r\n\r\n        // Month\r\n        uint secondsInMonth;\r\n        for (i = 1; i <= 12; i++) {\r\n            secondsInMonth = DAY_IN_SECONDS * getDaysInMonth(i, dt.year);\r\n            if (secondsInMonth + secondsAccountedFor > timestamp) {\r\n                dt.month = i;\r\n                break;\r\n            }\r\n            secondsAccountedFor += secondsInMonth;\r\n        }\r\n\r\n        // Day\r\n        for (i = 1; i <= getDaysInMonth(dt.month, dt.year); i++) {\r\n            if (DAY_IN_SECONDS + secondsAccountedFor > timestamp) {\r\n                dt.day = i;\r\n                break;\r\n            }\r\n            secondsAccountedFor += DAY_IN_SECONDS;\r\n        }\r\n\r\n        // Hour\r\n        dt.hour = getHour(timestamp);\r\n\r\n        // Minute\r\n        dt.minute = getMinute(timestamp);\r\n\r\n        // Second\r\n        dt.second = getSecond(timestamp);\r\n\r\n        // Day of week.\r\n        dt.weekday = getWeekday(timestamp);\r\n    }\r\n\r\n    function getYear(uint timestamp) public pure returns (uint16) {\r\n        uint secondsAccountedFor = 0;\r\n        uint16 year;\r\n        uint numLeapYears;\r\n\r\n        // Year\r\n        year = uint16(ORIGIN_YEAR + timestamp / YEAR_IN_SECONDS);\r\n        numLeapYears = leapYearsBefore(year) - leapYearsBefore(ORIGIN_YEAR);\r\n\r\n        secondsAccountedFor += LEAP_YEAR_IN_SECONDS * numLeapYears;\r\n        secondsAccountedFor += YEAR_IN_SECONDS * (year - ORIGIN_YEAR - numLeapYears);\r\n\r\n        while (secondsAccountedFor > timestamp) {\r\n            if (isLeapYear(uint16(year - 1))) {\r\n                secondsAccountedFor -= LEAP_YEAR_IN_SECONDS;\r\n            }\r\n            else {\r\n                secondsAccountedFor -= YEAR_IN_SECONDS;\r\n            }\r\n            year -= 1;\r\n        }\r\n        return year;\r\n    }\r\n\r\n    function getMonth(uint timestamp) public pure returns (uint8) {\r\n        return parseTimestamp(timestamp).month;\r\n    }\r\n\r\n    function getDay(uint timestamp) public pure returns (uint8) {\r\n        return parseTimestamp(timestamp).day;\r\n    }\r\n\r\n    function getHour(uint timestamp) public pure returns (uint8) {\r\n        return uint8((timestamp / 60 / 60) % 24);\r\n    }\r\n\r\n    function getMinute(uint timestamp) public pure returns (uint8) {\r\n        return uint8((timestamp / 60) % 60);\r\n    }\r\n\r\n    function getSecond(uint timestamp) public pure returns (uint8) {\r\n        return uint8(timestamp % 60);\r\n    }\r\n\r\n    function getWeekday(uint timestamp) public pure returns (uint8) {\r\n        return uint8((timestamp / DAY_IN_SECONDS + 4) % 7);\r\n    }\r\n\r\n    function toTimestamp(uint16 year, uint8 month, uint8 day) public pure returns (uint timestamp) {\r\n        return toTimestamp(year, month, day, 0, 0, 0);\r\n    }\r\n\r\n    function toTimestamp(uint16 year, uint8 month, uint8 day, uint8 hour) public pure returns (uint timestamp) {\r\n        return toTimestamp(year, month, day, hour, 0, 0);\r\n    }\r\n\r\n    function toTimestamp(uint16 year, uint8 month, uint8 day, uint8 hour, uint8 minute) public pure returns (uint timestamp) {\r\n        return toTimestamp(year, month, day, hour, minute, 0);\r\n    }\r\n\r\n    function toTimestamp(uint16 year, uint8 month, uint8 day, uint8 hour, uint8 minute, uint8 second) public pure returns (uint timestamp) {\r\n        uint16 i;\r\n\r\n        // Year\r\n        for (i = ORIGIN_YEAR; i < year; i++) {\r\n            if (isLeapYear(i)) {\r\n                timestamp += LEAP_YEAR_IN_SECONDS;\r\n            }\r\n            else {\r\n                timestamp += YEAR_IN_SECONDS;\r\n            }\r\n        }\r\n\r\n        // Month\r\n        uint8[12] memory monthDayCounts;\r\n        monthDayCounts[0] = 31;\r\n        if (isLeapYear(year)) {\r\n            monthDayCounts[1] = 29;\r\n        }\r\n        else {\r\n            monthDayCounts[1] = 28;\r\n        }\r\n        monthDayCounts[2] = 31;\r\n        monthDayCounts[3] = 30;\r\n        monthDayCounts[4] = 31;\r\n        monthDayCounts[5] = 30;\r\n        monthDayCounts[6] = 31;\r\n        monthDayCounts[7] = 31;\r\n        monthDayCounts[8] = 30;\r\n        monthDayCounts[9] = 31;\r\n        monthDayCounts[10] = 30;\r\n        monthDayCounts[11] = 31;\r\n\r\n        for (i = 1; i < month; i++) {\r\n            timestamp += DAY_IN_SECONDS * monthDayCounts[i - 1];\r\n        }\r\n\r\n        // Day\r\n        timestamp += DAY_IN_SECONDS * (day - 1);\r\n\r\n        // Hour\r\n        timestamp += HOUR_IN_SECONDS * (hour);\r\n\r\n        // Minute\r\n        timestamp += MINUTE_IN_SECONDS * (minute);\r\n\r\n        // Second\r\n        timestamp += second;\r\n\r\n        return timestamp;\r\n    }\r\n}\r\n\r\n\r\ninterface ERC20 {\r\n\r\n    function name() external view returns(string);\r\n    function symbol() external view returns(string);\r\n    function decimals() external view returns(uint8);\r\n    function totalSupply() external view returns (uint);\r\n\r\n    function balanceOf(address tokenOwner) external view returns (uint balance);\r\n    function allowance(address tokenOwner, address spender) external view returns (uint remaining);\r\n    function transfer(address to, uint tokens) external returns (bool success);\r\n    function approve(address spender, uint tokens) external returns (bool success);\r\n    function transferFrom(address from, address to, uint tokens) external returns (bool success);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint tokens);\r\n    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\r\n}\r\n\r\n\r\ncontract MasterCopy is SelfAuthorized {\r\n  // masterCopy always needs to be first declared variable, to ensure that it is at the same location as in the Proxy contract.\r\n  // It should also always be ensured that the address is stored alone (uses a full word)\r\n    address masterCopy;\r\n\r\n  /// @dev Allows to upgrade the contract. This can only be done via a Safe transaction.\r\n  /// @param _masterCopy New contract address.\r\n    function changeMasterCopy(address _masterCopy)\r\n        public\r\n        authorized\r\n    {\r\n        // Master copy address cannot be null.\r\n        require(_masterCopy != 0, \"Invalid master copy address provided\");\r\n        masterCopy = _masterCopy;\r\n    }\r\n}\r\n\r\n\r\ncontract Config is DSNote, DSAuth, Utils {\r\n\r\n    WETH9 public weth9;\r\n    mapping (address => bool) public isAccountHandler;\r\n    mapping (address => bool) public isAdmin;\r\n    address[] public admins;\r\n    bool public disableAdminControl = false;\r\n    \r\n    event LogAdminAdded(address indexed _admin, address _by);\r\n    event LogAdminRemoved(address indexed _admin, address _by);\r\n\r\n    constructor() public {\r\n        admins.push(msg.sender);\r\n        isAdmin[msg.sender] = true;\r\n    }\r\n\r\n    modifier onlyAdmin(){\r\n        require(isAdmin[msg.sender], \"Config::_ SENDER_NOT_AUTHORIZED\");\r\n        _;\r\n    }\r\n\r\n    function setWETH9\r\n    (\r\n        address _weth9\r\n    ) \r\n        public\r\n        auth\r\n        note\r\n        addressValid(_weth9) \r\n    {\r\n        weth9 = WETH9(_weth9);\r\n    }\r\n\r\n    function setAccountHandler\r\n    (\r\n        address _accountHandler,\r\n        bool _isAccountHandler\r\n    )\r\n        public\r\n        auth\r\n        note\r\n        addressValid(_accountHandler)\r\n    {\r\n        isAccountHandler[_accountHandler] = _isAccountHandler;\r\n    }\r\n\r\n    function toggleAdminsControl() \r\n        public\r\n        auth\r\n        note\r\n    {\r\n        disableAdminControl = !disableAdminControl;\r\n    }\r\n\r\n    function isAdminValid(address _admin)\r\n        public\r\n        view\r\n        returns (bool)\r\n    {\r\n        if(disableAdminControl) {\r\n            return true;\r\n        } else {\r\n            return isAdmin[_admin];\r\n        }\r\n    }\r\n\r\n    function getAllAdmins()\r\n        public\r\n        view\r\n        returns(address[])\r\n    {\r\n        return admins;\r\n    }\r\n\r\n    function addAdmin\r\n    (\r\n        address _admin\r\n    )\r\n        external\r\n        note\r\n        onlyAdmin\r\n        addressValid(_admin)\r\n    {   \r\n        require(!isAdmin[_admin], \"Config::addAdmin ADMIN_ALREADY_EXISTS\");\r\n\r\n        admins.push(_admin);\r\n        isAdmin[_admin] = true;\r\n\r\n        emit LogAdminAdded(_admin, msg.sender);\r\n    }\r\n\r\n    function removeAdmin\r\n    (\r\n        address _admin\r\n    ) \r\n        external\r\n        note\r\n        onlyAdmin\r\n        addressValid(_admin)\r\n    {   \r\n        require(isAdmin[_admin], \"Config::removeAdmin ADMIN_DOES_NOT_EXIST\");\r\n        require(msg.sender != _admin, \"Config::removeAdmin ADMIN_NOT_AUTHORIZED\");\r\n\r\n        isAdmin[_admin] = false;\r\n\r\n        for (uint i = 0; i < admins.length - 1; i++) {\r\n            if (admins[i] == _admin) {\r\n                admins[i] = admins[admins.length - 1];\r\n                admins.length -= 1;\r\n                break;\r\n            }\r\n        }\r\n\r\n        emit LogAdminRemoved(_admin, msg.sender);\r\n    }\r\n}\r\n\r\n\r\nlibrary ECRecovery {\r\n\r\n    function recover(bytes32 _hash, bytes _sig)\r\n        internal\r\n        pure\r\n    returns (address)\r\n    {\r\n        bytes32 r;\r\n        bytes32 s;\r\n        uint8 v;\r\n\r\n        if (_sig.length != 65) {\r\n            return (address(0));\r\n        }\r\n\r\n        assembly {\r\n            r := mload(add(_sig, 32))\r\n            s := mload(add(_sig, 64))\r\n            v := byte(0, mload(add(_sig, 96)))\r\n        }\r\n\r\n        if (v < 27) {\r\n            v += 27;\r\n        }\r\n\r\n        if (v != 27 && v != 28) {\r\n            return (address(0));\r\n        } else {\r\n            return ecrecover(_hash, v, r, s);\r\n        }\r\n    }\r\n\r\n    function toEthSignedMessageHash(bytes32 _hash)\r\n        internal\r\n        pure\r\n    returns (bytes32)\r\n    {\r\n        return keccak256(\r\n            abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", _hash)\r\n        );\r\n    }\r\n}\r\n\r\n\r\ncontract Utils2 {\r\n    using ECRecovery for bytes32;\r\n    \r\n    function _recoverSigner(bytes32 _hash, bytes _signature) \r\n        internal\r\n        pure\r\n        returns(address _signer)\r\n    {\r\n        return _hash.toEthSignedMessageHash().recover(_signature);\r\n    }\r\n\r\n}\r\n\r\n\r\ncontract DSThing is DSNote, DSAuth, DSMath {\r\n\r\n    function S(string s) internal pure returns (bytes4) {\r\n        return bytes4(keccak256(s));\r\n    }\r\n\r\n}\r\n\r\n\r\ncontract DSStop is DSNote, DSAuth {\r\n\r\n    bool public stopped = false;\r\n\r\n    modifier whenNotStopped {\r\n        require(!stopped, \"DSStop::_ FEATURE_STOPPED\");\r\n        _;\r\n    }\r\n\r\n    modifier whenStopped {\r\n        require(stopped, \"DSStop::_ FEATURE_NOT_STOPPED\");\r\n        _;\r\n    }\r\n\r\n    function stop() public auth note {\r\n        stopped = true;\r\n    }\r\n    function start() public auth note {\r\n        stopped = false;\r\n    }\r\n\r\n}\r\n\r\n\r\ncontract Account is MasterCopy, DSNote, Utils, Utils2, ErrorUtils {\r\n\r\n    address[] public users;\r\n    mapping (address => bool) public isUser;\r\n    mapping (bytes32 => bool) public actionCompleted;\r\n\r\n    WETH9 public weth9;\r\n    Config public config;\r\n    bool public isInitialized = false;\r\n\r\n    event LogTransferBySystem(address indexed token, address indexed to, uint value, address by);\r\n    event LogTransferByUser(address indexed token, address indexed to, uint value, address by);\r\n    event LogUserAdded(address indexed user, address by);\r\n    event LogUserRemoved(address indexed user, address by);\r\n    event LogImplChanged(address indexed newImpl, address indexed oldImpl);\r\n\r\n    modifier initialized() {\r\n        require(isInitialized, \"Account::_ ACCOUNT_NOT_INITIALIZED\");\r\n        _;\r\n    }\r\n\r\n    modifier notInitialized() {\r\n        require(!isInitialized, \"Account::_ ACCOUNT_ALREADY_INITIALIZED\");\r\n        _;\r\n    }\r\n\r\n    modifier userExists(address _user) {\r\n        require(isUser[_user], \"Account::_ INVALID_USER\");\r\n        _;\r\n    }\r\n\r\n    modifier userDoesNotExist(address _user) {\r\n        require(!isUser[_user], \"Account::_ USER_DOES_NOT_EXISTS\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyAdmin() {\r\n        require(config.isAdminValid(msg.sender), \"Account::_ INVALID_ADMIN_ACCOUNT\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyHandler(){\r\n        require(config.isAccountHandler(msg.sender), \"Account::_ INVALID_ACC_HANDLER\");\r\n        _;\r\n    }\r\n\r\n    function init(address _user, address _config)\r\n        public \r\n        notInitialized\r\n    {\r\n        users.push(_user);\r\n        isUser[_user] = true;\r\n        config = Config(_config);\r\n        weth9 = config.weth9();\r\n        isInitialized = true;\r\n    }\r\n    \r\n    function getAllUsers() public view returns (address[]) {\r\n        return users;\r\n    }\r\n\r\n    function balanceFor(address _token) public view returns (uint _balance){\r\n        _balance = ERC20(_token).balanceOf(this);\r\n    }\r\n    \r\n    function transferBySystem\r\n    (   \r\n        address _token,\r\n        address _to,\r\n        uint _value\r\n    ) \r\n        external \r\n        onlyHandler\r\n        note \r\n        initialized\r\n    {\r\n        require(ERC20(_token).balanceOf(this) >= _value, \"Account::transferBySystem INSUFFICIENT_BALANCE_IN_ACCOUNT\");\r\n        ERC20(_token).transfer(_to, _value);\r\n\r\n        emit LogTransferBySystem(_token, _to, _value, msg.sender);\r\n    }\r\n    \r\n    function transferByUser\r\n    (   \r\n        address _token,\r\n        address _to,\r\n        uint _value,\r\n        uint _salt,\r\n        bytes _signature\r\n    )\r\n        external\r\n        addressValid(_to)\r\n        note\r\n        initialized\r\n        onlyAdmin\r\n    {\r\n        bytes32 actionHash = _getTransferActionHash(_token, _to, _value, _salt);\r\n\r\n        if(actionCompleted[actionHash]) {\r\n            emit LogError(\"Account::transferByUser\", \"ACTION_ALREADY_PERFORMED\");\r\n            return;\r\n        }\r\n\r\n        if(ERC20(_token).balanceOf(this) < _value){\r\n            emit LogError(\"Account::transferByUser\", \"INSUFFICIENT_BALANCE_IN_ACCOUNT\");\r\n            return;\r\n        }\r\n\r\n        address signer = _recoverSigner(actionHash, _signature);\r\n\r\n        if(!isUser[signer]) {\r\n            emit LogError(\"Account::transferByUser\", \"SIGNER_NOT_AUTHORIZED_WITH_ACCOUNT\");\r\n            return;\r\n        }\r\n\r\n        actionCompleted[actionHash] = true;\r\n        \r\n        if (_token == address(weth9)) {\r\n            weth9.withdraw(_value);\r\n            _to.transfer(_value);\r\n        } else {\r\n            require(ERC20(_token).transfer(_to, _value), \"Account::transferByUser TOKEN_TRANSFER_FAILED\");\r\n        }\r\n\r\n        emit LogTransferByUser(_token, _to, _value, signer);\r\n    }\r\n\r\n    function addUser\r\n    (\r\n        address _user,\r\n        uint _salt,\r\n        bytes _signature\r\n    )\r\n        external \r\n        note \r\n        addressValid(_user)\r\n        userDoesNotExist(_user)\r\n        initialized\r\n        onlyAdmin\r\n    {   \r\n        bytes32 actionHash = _getUserActionHash(_user, \"ADD_USER\", _salt);\r\n        if(actionCompleted[actionHash])\r\n        {\r\n            emit LogError(\"Account::addUser\", \"ACTION_ALREADY_PERFORMED\");\r\n            return;\r\n        }\r\n\r\n        address signer = _recoverSigner(actionHash, _signature);\r\n\r\n        if(!isUser[signer]) {\r\n            emit LogError(\"Account::addUser\", \"SIGNER_NOT_AUTHORIZED_WITH_ACCOUNT\");\r\n            return;\r\n        }\r\n\r\n        actionCompleted[actionHash] = true;\r\n\r\n        users.push(_user);\r\n        isUser[_user] = true;\r\n\r\n        emit LogUserAdded(_user, signer);\r\n    }\r\n\r\n    function removeUser\r\n    (\r\n        address _user,\r\n        uint _salt,\r\n        bytes _signature\r\n    ) \r\n        external\r\n        note\r\n        userExists(_user) \r\n        initialized\r\n        onlyAdmin\r\n    {   \r\n        bytes32 actionHash = _getUserActionHash(_user, \"REMOVE_USER\", _salt);\r\n\r\n        if(actionCompleted[actionHash]) {\r\n            emit LogError(\"Account::removeUser\", \"ACTION_ALREADY_PERFORMED\");\r\n            return;\r\n        }\r\n\r\n        address signer = _recoverSigner(actionHash, _signature);\r\n        \r\n        if(users.length == 1){\r\n            emit LogError(\"Account::removeUser\",  \"ACC_SHOULD_HAVE_ATLEAST_ONE_USER\");\r\n            return;\r\n        }\r\n        \r\n        if(!isUser[signer]){\r\n            emit LogError(\"Account::removeUser\", \"SIGNER_NOT_AUTHORIZED_WITH_ACCOUNT\");\r\n            return;\r\n        }\r\n        \r\n        actionCompleted[actionHash] = true;\r\n\r\n        // should delete value from isUser map? delete isUser[_user]?\r\n        isUser[_user] = false;\r\n        for (uint i = 0; i < users.length - 1; i++) {\r\n            if (users[i] == _user) {\r\n                users[i] = users[users.length - 1];\r\n                users.length -= 1;\r\n                break;\r\n            }\r\n        }\r\n\r\n        emit LogUserRemoved(_user, signer);\r\n    }\r\n\r\n    function _getTransferActionHash\r\n    ( \r\n        address _token,\r\n        address _to,\r\n        uint _value,\r\n        uint _salt\r\n    ) \r\n        internal\r\n        view\r\n        returns (bytes32)\r\n    {\r\n        return keccak256(\r\n            abi.encodePacked(\r\n                address(this),\r\n                _token,\r\n                _to,\r\n                _value,\r\n                _salt\r\n            )\r\n        );\r\n    }\r\n\r\n    function _getUserActionHash\r\n    ( \r\n        address _user,\r\n        string _action,\r\n        uint _salt\r\n    ) \r\n        internal\r\n        view\r\n        returns (bytes32)\r\n    {\r\n        return keccak256(\r\n            abi.encodePacked(\r\n                address(this),\r\n                _user,\r\n                _action,\r\n                _salt\r\n            )\r\n        );\r\n    }\r\n\r\n    // to directly send ether to contract\r\n    function() external payable {\r\n        require(msg.data.length == 0 && msg.value > 0, \"Account::fallback INVALID_ETHER_TRANSFER\");\r\n\r\n        if(msg.sender != address(weth9)){\r\n            weth9.deposit.value(msg.value)();\r\n        }\r\n    }\r\n\r\n    function changeImpl\r\n    (\r\n        address _to,\r\n        uint _salt,\r\n        bytes _signature\r\n    )\r\n        external \r\n        note \r\n        addressValid(_to)\r\n        initialized\r\n        onlyAdmin\r\n    {   \r\n        bytes32 actionHash = _getUserActionHash(_to, \"CHANGE_ACCOUNT_IMPLEMENTATION\", _salt);\r\n        if(actionCompleted[actionHash])\r\n        {\r\n            emit LogError(\"Account::changeImpl\", \"ACTION_ALREADY_PERFORMED\");\r\n            return;\r\n        }\r\n\r\n        address signer = _recoverSigner(actionHash, _signature);\r\n\r\n        if(!isUser[signer]) {\r\n            emit LogError(\"Account::changeImpl\", \"SIGNER_NOT_AUTHORIZED_WITH_ACCOUNT\");\r\n            return;\r\n        }\r\n\r\n        actionCompleted[actionHash] = true;\r\n\r\n        address oldImpl = masterCopy;\r\n        this.changeMasterCopy(_to);\r\n        \r\n        emit LogImplChanged(_to, oldImpl);\r\n    }\r\n\r\n}\r\n\r\n\r\ncontract AccountFactory is DSStop, Utils {\r\n    Config public config;\r\n    mapping (address => bool) public isAccount;\r\n    mapping (address => address[]) public userToAccounts;\r\n    address[] public accounts;\r\n\r\n    address public accountMaster;\r\n\r\n    constructor\r\n    (\r\n        Config _config, \r\n        address _accountMaster\r\n    ) \r\n    public \r\n    {\r\n        config = _config;\r\n        accountMaster = _accountMaster;\r\n    }\r\n\r\n    event LogAccountCreated(address indexed user, address indexed account, address by);\r\n\r\n    modifier onlyAdmin() {\r\n        require(config.isAdminValid(msg.sender), \"AccountFactory::_ INVALID_ADMIN_ACCOUNT\");\r\n        _;\r\n    }\r\n\r\n    function setConfig(Config _config) external note auth addressValid(_config) {\r\n        config = _config;\r\n    }\r\n\r\n    function setAccountMaster(address _accountMaster) external note auth addressValid(_accountMaster) {\r\n        accountMaster = _accountMaster;\r\n    }\r\n\r\n    function newAccount(address _user)\r\n        public\r\n        note\r\n        onlyAdmin\r\n        addressValid(config)\r\n        addressValid(accountMaster)\r\n        whenNotStopped\r\n        returns \r\n        (\r\n            Account _account\r\n        ) \r\n    {\r\n        address proxy = new Proxy(accountMaster);\r\n        _account = Account(proxy);\r\n        _account.init(_user, config);\r\n\r\n        accounts.push(_account);\r\n        userToAccounts[_user].push(_account);\r\n        isAccount[_account] = true;\r\n\r\n        emit LogAccountCreated(_user, _account, msg.sender);\r\n    }\r\n    \r\n    function batchNewAccount(address[] _users) public note onlyAdmin {\r\n        for (uint i = 0; i < _users.length; i++) {\r\n            newAccount(_users[i]);\r\n        }\r\n    }\r\n\r\n    function getAllAccounts() public view returns (address[]) {\r\n        return accounts;\r\n    }\r\n\r\n    function getAccountsForUser(address _user) public view returns (address[]) {\r\n        return userToAccounts[_user];\r\n    }\r\n\r\n}\r\n\r\n\r\ncontract Escrow is DSNote, DSAuth {\r\n\r\n    event LogTransfer(address indexed token, address indexed to, uint value);\r\n    event LogTransferFromAccount(address indexed account, address indexed token, address indexed to, uint value);\r\n\r\n    function transfer\r\n    (\r\n        address _token,\r\n        address _to,\r\n        uint _value\r\n    )\r\n        public\r\n        note\r\n        auth\r\n    {\r\n        require(ERC20(_token).transfer(_to, _value), \"Escrow::transfer TOKEN_TRANSFER_FAILED\");\r\n        emit LogTransfer(_token, _to, _value);\r\n    }\r\n\r\n    function transferFromAccount\r\n    (\r\n        address _account,\r\n        address _token,\r\n        address _to,\r\n        uint _value\r\n    )\r\n        public\r\n        note\r\n        auth\r\n    {   \r\n        Account(_account).transferBySystem(_token, _to, _value);\r\n        emit LogTransferFromAccount(_account, _token, _to, _value);\r\n    }\r\n\r\n}\r\n\r\n// issue with deploying multiple instances of same type in truffle, hence the following two contracts\r\ncontract KernelEscrow is Escrow {\r\n\r\n}\r\n\r\ncontract ReserveEscrow is Escrow {\r\n    \r\n}\r\n\r\n\r\ncontract Reserve is DSStop, DSThing, Utils, Utils2, ErrorUtils {\r\n\r\n    Escrow public escrow;\r\n    AccountFactory public accountFactory;\r\n    DateTime public dateTime;\r\n    Config public config;\r\n    uint public deployTimestamp;\r\n\r\n    string constant public VERSION = \"1.0.0\";\r\n\r\n    uint public TIME_INTERVAL = 1 days;\r\n    //uint public TIME_INTERVAL = 1 hours;\r\n    \r\n    constructor\r\n    (\r\n        Escrow _escrow,\r\n        AccountFactory _accountFactory,\r\n        DateTime _dateTime,\r\n        Config _config\r\n    ) \r\n    public \r\n    {\r\n        escrow = _escrow;\r\n        accountFactory = _accountFactory;\r\n        dateTime = _dateTime;\r\n        config = _config;\r\n        deployTimestamp = now - (4 * TIME_INTERVAL);\r\n    }\r\n\r\n    function setEscrow(Escrow _escrow) \r\n        public \r\n        note \r\n        auth\r\n        addressValid(_escrow)\r\n    {\r\n        escrow = _escrow;\r\n    }\r\n\r\n    function setAccountFactory(AccountFactory _accountFactory) \r\n        public \r\n        note \r\n        auth\r\n        addressValid(_accountFactory)\r\n    {\r\n        accountFactory = _accountFactory;\r\n    }\r\n\r\n    function setDateTime(DateTime _dateTime) \r\n        public \r\n        note \r\n        auth\r\n        addressValid(_dateTime)\r\n    {\r\n        dateTime = _dateTime;\r\n    }\r\n\r\n    function setConfig(Config _config) \r\n        public \r\n        note \r\n        auth\r\n        addressValid(_config)\r\n    {\r\n        config = _config;\r\n    }\r\n\r\n    struct Order {\r\n        address account;\r\n        address token;\r\n        address byUser;\r\n        uint value;\r\n        uint duration;\r\n        uint expirationTimestamp;\r\n        uint salt;\r\n        uint createdTimestamp;\r\n        bytes32 orderHash;\r\n    }\r\n\r\n    bytes32[] public orders;\r\n    mapping (bytes32 => Order) public hashToOrder;\r\n    mapping (bytes32 => bool) public isOrder;\r\n    mapping (address => bytes32[]) public accountToOrders;\r\n    mapping (bytes32 => bool) public cancelledOrders;\r\n\r\n    // per day\r\n    mapping (uint => mapping(address => uint)) public deposits;\r\n    mapping (uint => mapping(address => uint)) public withdrawals;\r\n    mapping (uint => mapping(address => uint)) public profits;\r\n    mapping (uint => mapping(address => uint)) public losses;\r\n\r\n    mapping (uint => mapping(address => uint)) public reserves;\r\n    mapping (address => uint) public lastReserveRuns;\r\n\r\n    mapping (address => mapping(address => uint)) public surplus;\r\n\r\n    mapping (bytes32 => CumulativeRun) public orderToCumulative;\r\n\r\n    struct CumulativeRun {\r\n        uint timestamp;\r\n        uint value;\r\n    }\r\n\r\n    modifier onlyAdmin() {\r\n        require(config.isAdminValid(msg.sender), \"Reserve::_ INVALID_ADMIN_ACCOUNT\");\r\n        _;\r\n    }\r\n\r\n    event LogOrderCreated(\r\n        bytes32 indexed orderHash,\r\n        address indexed account,\r\n        address indexed token,\r\n        address byUser,\r\n        uint value,\r\n        uint expirationTimestamp\r\n    );\r\n\r\n    event LogOrderCancelled(\r\n        bytes32 indexed orderHash,\r\n        address indexed by\r\n    );\r\n\r\n    event LogReserveValuesUpdated(\r\n        address indexed token, \r\n        uint indexed updatedTill,\r\n        uint reserve,\r\n        uint profit,\r\n        uint loss\r\n    );\r\n\r\n    event LogOrderCumulativeUpdated(\r\n        bytes32 indexed orderHash,\r\n        uint updatedTill,\r\n        uint value\r\n    );\r\n\r\n    event LogRelease(\r\n        address indexed token,\r\n        address indexed to,\r\n        uint value,\r\n        address by\r\n    );\r\n\r\n    event LogLock(\r\n        address indexed token,\r\n        address indexed from,\r\n        uint value,\r\n        uint profit,\r\n        uint loss,\r\n        address by\r\n    );\r\n\r\n    event LogLockSurplus(\r\n        address indexed forToken, \r\n        address indexed token,\r\n        address from,\r\n        uint value\r\n    );\r\n\r\n    event LogTransferSurplus(\r\n        address indexed forToken,\r\n        address indexed token,\r\n        address to, \r\n        uint value\r\n    );\r\n    \r\n    function createOrder\r\n    (\r\n        address[3] _orderAddresses,\r\n        uint[3] _orderValues,\r\n        bytes _signature\r\n    ) \r\n        public\r\n        note\r\n        onlyAdmin\r\n        whenNotStopped\r\n    {\r\n        Order memory order = _composeOrder(_orderAddresses, _orderValues);\r\n        address signer = _recoverSigner(order.orderHash, _signature);\r\n\r\n        if(signer != order.byUser){\r\n            emit LogErrorWithHintBytes32(order.orderHash, \"Reserve::createOrder\", \"SIGNER_NOT_ORDER_CREATOR\");\r\n            return;\r\n        }\r\n        \r\n        if(isOrder[order.orderHash]){\r\n            emit LogErrorWithHintBytes32(order.orderHash, \"Reserve::createOrder\", \"ORDER_ALREADY_EXISTS\");\r\n            return;\r\n        }\r\n\r\n        if(!accountFactory.isAccount(order.account)){\r\n            emit LogErrorWithHintBytes32(order.orderHash, \"Reserve::createOrder\", \"INVALID_ORDER_ACCOUNT\");\r\n            return;\r\n        }\r\n\r\n        if(!Account(order.account).isUser(signer)){\r\n            emit LogErrorWithHintBytes32(order.orderHash, \"Reserve::createOrder\", \"SIGNER_NOT_AUTHORIZED_WITH_ACCOUNT\");\r\n            return;\r\n        }\r\n                \r\n        if(!_isOrderValid(order)) {\r\n            emit LogErrorWithHintBytes32(order.orderHash, \"Reserve::createOrder\", \"INVALID_ORDER_PARAMETERS\");\r\n            return;\r\n        }\r\n\r\n        if(ERC20(order.token).balanceOf(order.account) < order.value){\r\n            emit LogErrorWithHintBytes32(order.orderHash, \"Reserve::createOrder\", \"INSUFFICIENT_BALANCE_IN_ACCOUNT\");\r\n            return;\r\n        }\r\n\r\n        escrow.transferFromAccount(order.account, order.token, address(escrow), order.value);\r\n        \r\n        orders.push(order.orderHash);\r\n        hashToOrder[order.orderHash] = order;\r\n        isOrder[order.orderHash] = true;\r\n        accountToOrders[order.account].push(order.orderHash);\r\n\r\n        uint dateTimestamp = _getDateTimestamp(now);\r\n\r\n        deposits[dateTimestamp][order.token] = add(deposits[dateTimestamp][order.token], order.value);\r\n        \r\n        orderToCumulative[order.orderHash].timestamp = _getDateTimestamp(order.createdTimestamp);\r\n        orderToCumulative[order.orderHash].value = order.value;\r\n\r\n        emit LogOrderCreated(\r\n            order.orderHash,\r\n            order.account,\r\n            order.token,\r\n            order.byUser,\r\n            order.value,\r\n            order.expirationTimestamp\r\n        );\r\n    }\r\n\r\n    function cancelOrder\r\n    (\r\n        bytes32 _orderHash,\r\n        bytes _signature\r\n    )\r\n        external\r\n        note\r\n        onlyAdmin\r\n    {   \r\n        if(!isOrder[_orderHash]) {\r\n            emit LogErrorWithHintBytes32(_orderHash,\"Reserve::createOrder\", \"ORDER_DOES_NOT_EXIST\");\r\n            return;\r\n        }\r\n\r\n        if(cancelledOrders[_orderHash]){\r\n            emit LogErrorWithHintBytes32(_orderHash,\"Reserve::createOrder\", \"ORDER_ALREADY_CANCELLED\");\r\n            return;\r\n        }\r\n\r\n        Order memory order = hashToOrder[_orderHash];\r\n\r\n        bytes32 cancelOrderHash = _generateActionOrderHash(_orderHash, \"CANCEL_RESERVE_ORDER\");\r\n        address signer = _recoverSigner(cancelOrderHash, _signature);\r\n        \r\n        if(!Account(order.account).isUser(signer)){\r\n            emit LogErrorWithHintBytes32(_orderHash,\"Reserve::createOrder\", \"SIGNER_NOT_AUTHORIZED_WITH_ACCOUNT\");\r\n            return;\r\n        }\r\n        \r\n        doCancelOrder(order);\r\n    }\r\n    \r\n    function processOrder\r\n    (\r\n        bytes32 _orderHash\r\n    ) \r\n        external \r\n        note\r\n        onlyAdmin\r\n    {\r\n        if(!isOrder[_orderHash]) {\r\n            emit LogErrorWithHintBytes32(_orderHash,\"Reserve::processOrder\", \"ORDER_DOES_NOT_EXIST\");\r\n            return;\r\n        }\r\n\r\n        if(cancelledOrders[_orderHash]){\r\n            emit LogErrorWithHintBytes32(_orderHash,\"Reserve::processOrder\", \"ORDER_ALREADY_CANCELLED\");\r\n            return;\r\n        }\r\n\r\n        Order memory order = hashToOrder[_orderHash];\r\n\r\n        if(now > _getDateTimestamp(order.expirationTimestamp)) {\r\n            doCancelOrder(order);\r\n        } else {\r\n            emit LogErrorWithHintBytes32(order.orderHash, \"Reserve::processOrder\", \"ORDER_NOT_EXPIRED\");\r\n        }\r\n    }\r\n\r\n    function doCancelOrder(Order _order) \r\n        internal\r\n    {   \r\n        uint valueToTransfer = orderToCumulative[_order.orderHash].value;\r\n\r\n        if(ERC20(_order.token).balanceOf(escrow) < valueToTransfer){\r\n            emit LogErrorWithHintBytes32(_order.orderHash, \"Reserve::doCancel\", \"INSUFFICIENT_BALANCE_IN_ESCROW\");\r\n            return;\r\n        }\r\n\r\n        uint nowDateTimestamp = _getDateTimestamp(now);\r\n        cancelledOrders[_order.orderHash] = true;\r\n        withdrawals[nowDateTimestamp][_order.token] = add(withdrawals[nowDateTimestamp][_order.token], valueToTransfer);\r\n\r\n        escrow.transfer(_order.token, _order.account, valueToTransfer);\r\n        emit LogOrderCancelled(_order.orderHash, msg.sender);\r\n    }\r\n\r\n    function release(address _token, address _to, uint _value) \r\n        external\r\n        note\r\n        auth\r\n    {   \r\n        require(ERC20(_token).balanceOf(escrow) >= _value, \"Reserve::release INSUFFICIENT_BALANCE_IN_ESCROW\");\r\n        escrow.transfer(_token, _to, _value);\r\n        emit LogRelease(_token, _to, _value, msg.sender);\r\n    }\r\n\r\n    // _value includes profit/loss as well\r\n    function lock(address _token, address _from, uint _value, uint _profit, uint _loss)\r\n        external\r\n        note\r\n        auth\r\n    {   \r\n        require(!(_profit == 0 && _loss == 0), \"Reserve::lock INVALID_PROFIT_LOSS_VALUES\");\r\n        require(ERC20(_token).balanceOf(_from) >= _value, \"Reserve::lock INSUFFICIENT_BALANCE\");\r\n            \r\n        if(accountFactory.isAccount(_from)) {\r\n            escrow.transferFromAccount(_from, _token, address(escrow), _value);\r\n        } else {\r\n            Escrow(_from).transfer(_token, address(escrow), _value);\r\n        }\r\n        \r\n        uint dateTimestamp = _getDateTimestamp(now);\r\n\r\n        if (_profit > 0){\r\n            profits[dateTimestamp][_token] = add(profits[dateTimestamp][_token], _profit);\r\n        } else if (_loss > 0) {\r\n            losses[dateTimestamp][_token] = add(losses[dateTimestamp][_token], _loss);\r\n        }\r\n\r\n        emit LogLock(_token, _from, _value, _profit, _loss, msg.sender);\r\n    }\r\n\r\n    // to lock collateral if cannot be liquidated e.g. not enough reserves in kyber\r\n    function lockSurplus(address _from, address _forToken, address _token, uint _value) \r\n        external\r\n        note\r\n        auth\r\n    {\r\n        require(ERC20(_token).balanceOf(_from) >= _value, \"Reserve::lockSurplus INSUFFICIENT_BALANCE_IN_ESCROW\");\r\n\r\n        Escrow(_from).transfer(_token, address(escrow), _value);\r\n        surplus[_forToken][_token] = add(surplus[_forToken][_token], _value);\r\n\r\n        emit LogLockSurplus(_forToken, _token, _from, _value);\r\n    }\r\n\r\n    // to transfer surplus collateral out of the system to trade on other platforms and put back in terms of \r\n    // principal to reserve manually using an account or surplus escrow\r\n    // should work in tandem with lock method when transferring back principal\r\n    function transferSurplus(address _to, address _forToken, address _token, uint _value) \r\n        external\r\n        note\r\n        auth\r\n    {\r\n        require(ERC20(_token).balanceOf(escrow) >= _value, \"Reserve::transferSurplus INSUFFICIENT_BALANCE_IN_ESCROW\");\r\n        require(surplus[_forToken][_token] >= _value, \"Reserve::transferSurplus INSUFFICIENT_SURPLUS\");\r\n\r\n        surplus[_forToken][_token] = sub(surplus[_forToken][_token], _value);\r\n        escrow.transfer(_token, _to, _value);\r\n\r\n        emit LogTransferSurplus(_forToken, _token, _to, _value);\r\n    }\r\n\r\n    function updateReserveValues(address _token, uint _forDays)\r\n        public\r\n        note\r\n        onlyAdmin\r\n    {   \r\n        uint lastReserveRun = lastReserveRuns[_token];\r\n\r\n        if (lastReserveRun == 0) {\r\n            lastReserveRun = _getDateTimestamp(deployTimestamp) - TIME_INTERVAL;\r\n        }\r\n\r\n        uint nowDateTimestamp = _getDateTimestamp(now);\r\n        uint updatesLeft = ((nowDateTimestamp - TIME_INTERVAL) - lastReserveRun) / TIME_INTERVAL;\r\n\r\n        if(updatesLeft == 0) {\r\n            emit LogErrorWithHintAddress(_token, \"Reserve::updateReserveValues\", \"RESERVE_VALUES_UP_TO_DATE\");\r\n            return;\r\n        }\r\n\r\n        uint counter = updatesLeft;\r\n\r\n        if(updatesLeft > _forDays && _forDays > 0) {\r\n            counter = _forDays;\r\n        }\r\n\r\n        for (uint i = 0; i < counter; i++) {\r\n            reserves[lastReserveRun + TIME_INTERVAL][_token] = sub(\r\n                sub(\r\n                    add(\r\n                        add(\r\n                            reserves[lastReserveRun][_token],\r\n                            deposits[lastReserveRun + TIME_INTERVAL][_token]\r\n                        ),\r\n                        profits[lastReserveRun + TIME_INTERVAL][_token]\r\n                    ),\r\n                    losses[lastReserveRun + TIME_INTERVAL][_token]\r\n                ),\r\n                withdrawals[lastReserveRun + TIME_INTERVAL][_token]\r\n            );\r\n            lastReserveRuns[_token] = lastReserveRun + TIME_INTERVAL;\r\n            lastReserveRun = lastReserveRuns[_token];\r\n            \r\n            emit LogReserveValuesUpdated(\r\n                _token,\r\n                lastReserveRun,\r\n                reserves[lastReserveRun][_token],\r\n                profits[lastReserveRun][_token],\r\n                losses[lastReserveRun][_token]\r\n            );\r\n            \r\n        }\r\n    }\r\n\r\n    function updateOrderCumulativeValueBatch(bytes32[] _orderHashes, uint[] _forDays) \r\n        public\r\n        note\r\n        onlyAdmin\r\n    {   \r\n        if(_orderHashes.length != _forDays.length) {\r\n            emit LogError(\"Reserve::updateOrderCumulativeValueBatch\", \"ARGS_ARRAYLENGTH_MISMATCH\");\r\n            return;\r\n        }\r\n\r\n        for(uint i = 0; i < _orderHashes.length; i++) {\r\n            updateOrderCumulativeValue(_orderHashes[i], _forDays[i]);\r\n        }\r\n    }\r\n\r\n    function updateOrderCumulativeValue\r\n    (\r\n        bytes32 _orderHash, \r\n        uint _forDays\r\n    ) \r\n        public\r\n        note\r\n        onlyAdmin \r\n    {\r\n        if(!isOrder[_orderHash]) {\r\n            emit LogErrorWithHintBytes32(_orderHash, \"Reserve::updateOrderCumulativeValue\", \"ORDER_DOES_NOT_EXIST\");\r\n            return;\r\n        }\r\n\r\n        if(cancelledOrders[_orderHash]) {\r\n            emit LogErrorWithHintBytes32(_orderHash, \"Reserve::updateOrderCumulativeValue\", \"ORDER_ALREADY_CANCELLED\");\r\n            return;\r\n        }\r\n        \r\n        Order memory order = hashToOrder[_orderHash];\r\n        CumulativeRun storage cumulativeRun = orderToCumulative[_orderHash];\r\n        \r\n        uint profitsAccrued = 0;\r\n        uint lossesAccrued = 0;\r\n        uint cumulativeValue = 0;\r\n        uint counter = 0;\r\n\r\n        uint lastOrderRun = cumulativeRun.timestamp;\r\n        uint nowDateTimestamp = _getDateTimestamp(now);\r\n\r\n        uint updatesLeft = ((nowDateTimestamp - TIME_INTERVAL) - lastOrderRun) / TIME_INTERVAL;\r\n\r\n        if(updatesLeft == 0) {\r\n            emit LogErrorWithHintBytes32(_orderHash, \"Reserve::updateOrderCumulativeValue\", \"ORDER_VALUES_UP_TO_DATE\");\r\n            return;\r\n        }\r\n\r\n        counter = updatesLeft;\r\n\r\n        if(updatesLeft > _forDays && _forDays > 0) {\r\n            counter = _forDays;\r\n        }\r\n\r\n        for (uint i = 0; i < counter; i++){\r\n            cumulativeValue = cumulativeRun.value;\r\n            lastOrderRun = cumulativeRun.timestamp;\r\n\r\n            if(lastReserveRuns[order.token] < lastOrderRun) {\r\n                emit LogErrorWithHintBytes32(_orderHash, \"Reserve::updateOrderCumulativeValue\", \"RESERVE_VALUES_NOT_UPDATED\");\r\n                emit LogOrderCumulativeUpdated(_orderHash, cumulativeRun.timestamp, cumulativeRun.value);\r\n                return;\r\n            }\r\n\r\n            profitsAccrued = div(\r\n                mul(profits[lastOrderRun + TIME_INTERVAL][order.token], cumulativeValue),\r\n                reserves[lastOrderRun][order.token]\r\n            );\r\n                \r\n            lossesAccrued = div(\r\n                mul(losses[lastOrderRun + TIME_INTERVAL][order.token], cumulativeValue),\r\n                reserves[lastOrderRun][order.token]\r\n            );\r\n\r\n            cumulativeValue = sub(add(cumulativeValue, profitsAccrued), lossesAccrued);\r\n\r\n            cumulativeRun.timestamp = lastOrderRun + TIME_INTERVAL;\r\n            cumulativeRun.value = cumulativeValue;\r\n        }\r\n        \r\n        emit LogOrderCumulativeUpdated(_orderHash, cumulativeRun.timestamp, cumulativeRun.value);\r\n    }\r\n\r\n    function getAllOrders() \r\n        public\r\n        view \r\n        returns \r\n        (\r\n            bytes32[]\r\n        ) \r\n    {\r\n        return orders;\r\n    }\r\n\r\n    function getOrdersForAccount(address _account) \r\n        public\r\n        view \r\n        returns \r\n        (\r\n            bytes32[]\r\n        )\r\n    {\r\n        return accountToOrders[_account];\r\n    }\r\n\r\n    function getOrder(bytes32 _orderHash)\r\n        public \r\n        view \r\n        returns \r\n        (\r\n            address _account,\r\n            address _token,\r\n            address _byUser,\r\n            uint _value,\r\n            uint _expirationTimestamp,\r\n            uint _salt,\r\n            uint _createdTimestamp\r\n        )\r\n    {   \r\n        Order memory order = hashToOrder[_orderHash];\r\n        return (\r\n            order.account,\r\n            order.token,\r\n            order.byUser,\r\n            order.value,\r\n            order.expirationTimestamp,\r\n            order.salt,\r\n            order.createdTimestamp\r\n        );\r\n    }\r\n\r\n    function _isOrderValid(Order _order)\r\n        internal\r\n        view\r\n        returns (bool)\r\n    {\r\n        if(_order.account == address(0) || _order.byUser == address(0)\r\n         || _order.value <= 0\r\n         || _order.expirationTimestamp <= _order.createdTimestamp || _order.salt <= 0) {\r\n            return false;\r\n        }\r\n\r\n        if(isOrder[_order.orderHash]) {\r\n            return false;\r\n        }\r\n\r\n        if(cancelledOrders[_order.orderHash]) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    function _composeOrder(address[3] _orderAddresses, uint[3] _orderValues)\r\n        internal\r\n        view\r\n        returns (Order _order)\r\n    {\r\n        Order memory order = Order({\r\n            account: _orderAddresses[0],\r\n            token: _orderAddresses[1],\r\n            byUser: _orderAddresses[2],\r\n            value: _orderValues[0],\r\n            createdTimestamp: now,\r\n            duration: _orderValues[1],\r\n            expirationTimestamp: add(now, _orderValues[1]),\r\n            salt: _orderValues[2],\r\n            orderHash: bytes32(0)\r\n        });\r\n\r\n        order.orderHash = _generateCreateOrderHash(order);\r\n\r\n        return order;\r\n    }\r\n\r\n    function _generateCreateOrderHash(Order _order)\r\n        internal\r\n        pure //view\r\n        returns (bytes32 _orderHash)\r\n    {\r\n        return keccak256(\r\n            abi.encodePacked(\r\n //              address(this),\r\n                _order.account,\r\n                _order.token,\r\n                _order.value,\r\n                _order.duration,\r\n                _order.salt\r\n            )\r\n        );\r\n    }\r\n\r\n    function _generateActionOrderHash\r\n    (\r\n        bytes32 _orderHash,\r\n        string _action\r\n    )\r\n        internal\r\n        pure //view\r\n        returns (bytes32 _repayOrderHash)\r\n    {\r\n        return keccak256(\r\n            abi.encodePacked(\r\n//                address(this),\r\n                _orderHash,\r\n                _action\r\n            )\r\n        );\r\n    }\r\n\r\n    function _getDateTimestamp(uint _timestamp) \r\n        internal\r\n        view\r\n        returns (uint)\r\n    {\r\n        // 1 day\r\n        return dateTime.toTimestamp(dateTime.getYear(_timestamp), dateTime.getMonth(_timestamp), dateTime.getDay(_timestamp));\r\n        // 1 hour\r\n        //return dateTime.toTimestamp(dateTime.getYear(_timestamp), dateTime.getMonth(_timestamp), dateTime.getDay(_timestamp), dateTime.getHour(_timestamp));\r\n    } \r\n\r\n}\r\ninterface ExchangeConnector {\r\n\r\n    function tradeWithInputFixed\r\n    (   \r\n        Escrow _escrow,\r\n        address _srcToken,\r\n        address _destToken,\r\n        uint _srcTokenValue\r\n    )\r\n        external\r\n        returns (uint _destTokenValue, uint _srcTokenValueLeft);\r\n\r\n    function tradeWithOutputFixed\r\n    (   \r\n        Escrow _escrow,\r\n        address _srcToken,\r\n        address _destToken,\r\n        uint _srcTokenValue,\r\n        uint _maxDestTokenValue\r\n    )\r\n        external\r\n        returns (uint _destTokenValue, uint _srcTokenValueLeft);\r\n    \r\n\r\n    function getExpectedRate(address _srcToken, address _destToken, uint _srcTokenValue) \r\n        external\r\n        view\r\n        returns(uint _expectedRate, uint _slippageRate);\r\n    \r\n    function isTradeFeasible(address _srcToken, address _destToken, uint _srcTokenValue) \r\n        external\r\n        view\r\n        returns(bool);\r\n\r\n}\r\n\r\n\r\ncontract MKernel is DSStop, DSThing, Utils, Utils2, ErrorUtils {\r\n    \r\n    Escrow public escrow;\r\n    AccountFactory public accountFactory;\r\n    Reserve public reserve;\r\n    address public feeWallet;\r\n    Config public config;\r\n    \r\n    constructor\r\n    (\r\n        Escrow _escrow,\r\n        AccountFactory _accountFactory,\r\n        Reserve _reserve,\r\n        address _feeWallet,\r\n        Config _config\r\n    ) \r\n    public \r\n    {\r\n        escrow = _escrow;\r\n        accountFactory = _accountFactory;\r\n        reserve = _reserve;\r\n        feeWallet = _feeWallet;\r\n        config = _config;\r\n    }\r\n\r\n    function setEscrow(Escrow _escrow) \r\n        public \r\n        note \r\n        auth\r\n        addressValid(_escrow)\r\n    {\r\n        escrow = _escrow;\r\n    }\r\n\r\n    function setAccountFactory(AccountFactory _accountFactory)\r\n        public \r\n        note \r\n        auth\r\n        addressValid(_accountFactory)\r\n    {\r\n        accountFactory = _accountFactory;\r\n    }\r\n\r\n    function setReserve(Reserve _reserve)\r\n        public \r\n        note \r\n        auth\r\n        addressValid(_reserve)\r\n    {\r\n        reserve = _reserve;\r\n    }\r\n\r\n    function setConfig(Config _config)\r\n        public \r\n        note \r\n        auth\r\n        addressValid(_config)\r\n    {\r\n        config = _config;\r\n    }\r\n\r\n    function setFeeWallet(address _feeWallet)\r\n        public \r\n        note \r\n        auth\r\n        addressValid(_feeWallet)\r\n    {\r\n        feeWallet = _feeWallet;\r\n    }\r\n    \r\n    event LogOrderCreated(\r\n        bytes32 indexed orderHash,\r\n        uint tradeAmount,\r\n        uint expirationTimestamp\r\n    );\r\n\r\n    event LogOrderLiquidatedByUser(\r\n        bytes32 indexed orderHash\r\n    );\r\n\r\n    event LogOrderStoppedAtProfit(\r\n        bytes32 indexed orderHash\r\n    );\r\n\r\n    event LogOrderDefaulted(\r\n        bytes32 indexed orderHash,\r\n        string reason\r\n    );\r\n\r\n    event LogNoActionPerformed(\r\n        bytes32 indexed orderHash\r\n    );\r\n\r\n    event LogOrderSettlement(\r\n        bytes32 indexed orderHash,\r\n        uint valueRepaid,\r\n        uint reserveProfit,\r\n        uint reserveLoss,\r\n        uint collateralLeft,\r\n        uint userProfit,\r\n        uint fee\r\n    );\r\n\r\n    struct Order {\r\n        address account;\r\n        address byUser;\r\n        address principalToken; \r\n        address collateralToken;\r\n        Trade trade;\r\n        uint principalAmount;\r\n        uint collateralAmount;\r\n        uint premium;\r\n        uint expirationTimestamp;\r\n        uint duration;\r\n        uint salt;\r\n        uint fee;\r\n        uint createdTimestamp;\r\n        bytes32 orderHash;\r\n    }\r\n\r\n    struct Trade {\r\n        address tradeToken;\r\n        address closingToken;\r\n        address exchangeConnector; //stores initial and then just used to pass around params\r\n        uint stopProfit;\r\n        uint stopLoss;\r\n    }\r\n\r\n    bytes32[] public orders;\r\n    mapping (bytes32 => Order) public hashToOrder;\r\n    mapping (bytes32 => bool) public isOrder;\r\n    mapping (address => bytes32[]) public accountToOrders;\r\n\r\n    mapping (bytes32 => uint) public initialTradeAmount;\r\n    mapping (bytes32 => bool) public isLiquidated;\r\n    mapping (bytes32 => bool) public isDefaulted;\r\n\r\n    modifier onlyAdmin() {\r\n        require(config.isAdminValid(msg.sender), \"MKernel::_ INVALID_ADMIN_ACCOUNT\");\r\n        _;\r\n    }\r\n\r\n\r\n    function createOrder\r\n    (\r\n        address[6] _orderAddresses,\r\n        uint[8] _orderValues,\r\n        address _exchangeConnector,\r\n        bytes _signature\r\n    )    \r\n        external\r\n        note\r\n        onlyAdmin\r\n        whenNotStopped\r\n        addressValid(_exchangeConnector)\r\n    {\r\n        Order memory order = _composeOrder(_orderAddresses, _orderValues);\r\n        address signer = _recoverSigner(order.orderHash, _signature);\r\n        order.trade.exchangeConnector = _exchangeConnector;\r\n\r\n        if(signer != order.byUser) {\r\n            emit LogErrorWithHintBytes32(order.orderHash, \"MKernel::createOrder\",\"SIGNER_NOT_ORDER_CREATOR\");\r\n            return;\r\n        }\r\n\r\n        if(isOrder[order.orderHash]){\r\n            emit LogErrorWithHintBytes32(order.orderHash, \"MKernel::createOrder\",\"ORDER_ALREADY_EXISTS\");\r\n            return;\r\n        }\r\n\r\n        if(!accountFactory.isAccount(order.account)){\r\n            emit LogErrorWithHintBytes32(order.orderHash, \"MKernel::createOrder\",\"INVALID_ORDER_ACCOUNT\");\r\n            return;\r\n        }\r\n\r\n        if(!Account(order.account).isUser(signer)) {\r\n            emit LogErrorWithHintBytes32(order.orderHash, \"MKernel::createOrder\",\"SIGNER_NOT_AUTHORIZED_WITH_ACCOUNT\");\r\n            return;\r\n        }\r\n\r\n        if(!_isOrderValid(order)){\r\n            emit LogErrorWithHintBytes32(order.orderHash, \"MKernel::createOrder\",\"INVALID_ORDER_PARAMETERS\");\r\n            return;\r\n        }\r\n\r\n        if(ERC20(order.collateralToken).balanceOf(order.account) < order.collateralAmount){\r\n            emit LogErrorWithHintBytes32(order.orderHash, \"MKernel::createOrder\",\"INSUFFICIENT_COLLATERAL_IN_ACCOUNT\");\r\n            return;\r\n        }\r\n\r\n        if(ERC20(order.principalToken).balanceOf(reserve.escrow()) < order.principalAmount){\r\n            emit LogErrorWithHintBytes32(order.orderHash, \"MKernel::createOrder\",\"INSUFFICIENT_FUNDS_IN_RESERVE\");\r\n            return;\r\n        }\r\n\r\n        if(!_isTradeFeasible(order, order.principalToken, order.trade.tradeToken, order.principalAmount))\r\n        {\r\n            emit LogErrorWithHintBytes32(order.orderHash, \"MKernel::createOrder\",\"TRADE_NOT_FEASIBLE\");\r\n            return;\r\n        }        \r\n\r\n        \r\n        orders.push(order.orderHash);\r\n        hashToOrder[order.orderHash] = order;\r\n        isOrder[order.orderHash] = true;\r\n        accountToOrders[order.account].push(order.orderHash);\r\n\r\n        escrow.transferFromAccount(order.account, order.collateralToken, address(escrow), order.collateralAmount);\r\n        reserve.release(order.principalToken, address(escrow), order.principalAmount);\r\n    \r\n        (initialTradeAmount[order.orderHash],) = _tradeWithFixedInput(\r\n            order,\r\n            ERC20(order.principalToken),\r\n            ERC20(order.trade.tradeToken),\r\n            order.principalAmount\r\n        );\r\n\r\n        emit LogOrderCreated(\r\n            order.orderHash,\r\n            initialTradeAmount[order.orderHash],\r\n            order.expirationTimestamp\r\n        );\r\n        \r\n\r\n    }\r\n\r\n    function liquidateOrder\r\n    (\r\n        bytes32 _orderHash,\r\n        address _exchangeConnector,\r\n        bytes _signature\r\n    ) \r\n        external\r\n        note\r\n        onlyAdmin\r\n        addressValid(_exchangeConnector)\r\n    {\r\n        if(!isOrder[_orderHash]){\r\n            emit LogErrorWithHintBytes32(_orderHash, \"MKernel::liquidateOrder\",\"ORDER_DOES_NOT_EXIST\");\r\n            return;\r\n        }\r\n        \r\n        if(isLiquidated[_orderHash]){\r\n            emit LogErrorWithHintBytes32(_orderHash, \"MKernel::liquidateOrder\",\"ORDER_ALREADY_LIQUIDATED\");\r\n            return;\r\n        }\r\n\r\n        if(isDefaulted[_orderHash]){\r\n            emit LogErrorWithHintBytes32(_orderHash, \"MKernel::liquidateOrder\",\"ORDER_ALREADY_DEFAULTED\");\r\n            return;\r\n        }\r\n\r\n        bytes32 liquidateOrderHash = _generateLiquidateOrderHash(_orderHash);\r\n        address signer = _recoverSigner(liquidateOrderHash, _signature);\r\n\r\n        Order memory order = hashToOrder[_orderHash];\r\n        order.trade.exchangeConnector = _exchangeConnector;\r\n        \r\n        if(!Account(order.account).isUser(signer)){\r\n            emit LogErrorWithHintBytes32(_orderHash, \"MKernel::liquidateOrder\", \"SIGNER_NOT_AUTHORIZED_WITH_ACCOUNT\");\r\n            return;\r\n        }\r\n\r\n        if(ERC20(order.trade.tradeToken).balanceOf(address(escrow)) < initialTradeAmount[_orderHash]){\r\n            emit LogErrorWithHintBytes32(_orderHash, \"MKernel::liquidateOrder\", \"INSUFFICIENT_TRADE_BALANCE_IN_ESCROW\");\r\n            return;\r\n        }\r\n\r\n        if(ERC20(order.collateralToken).balanceOf(address(escrow)) < order.collateralAmount){\r\n            emit LogErrorWithHintBytes32(_orderHash, \"MKernel::liquidateOrder\", \"INSUFFICIENT_COLLATERAL_BALANCE_IN_ESCROW\");\r\n            return;\r\n        }\r\n\r\n        isLiquidated[order.orderHash] = true;\r\n        _performOrderLiquidation(order);\r\n\r\n        emit LogOrderLiquidatedByUser(_orderHash);\r\n    }\r\n\r\n    function processTradeForExpiry\r\n    (\r\n        bytes32 _orderHash,\r\n        address _exchangeConnector\r\n    )\r\n        external\r\n        note\r\n        onlyAdmin\r\n        addressValid(_exchangeConnector)\r\n    {\r\n        if(!isOrder[_orderHash]){\r\n            emit LogErrorWithHintBytes32(_orderHash, \"MKernel::processTradeForExpiry\",\"ORDER_DOES_NOT_EXIST\");\r\n            return;\r\n        }\r\n\r\n        if(isLiquidated[_orderHash]){\r\n            emit LogErrorWithHintBytes32(_orderHash, \"MKernel::processTradeForExpiry\",\"ORDER_ALREADY_LIQUIDATED\");\r\n            return;\r\n        }\r\n\r\n        if(isDefaulted[_orderHash]){\r\n            emit LogErrorWithHintBytes32(_orderHash, \"MKernel::processTradeForExpiry\",\"ORDER_ALREADY_DEFAULTED\");\r\n            return;\r\n        }\r\n        \r\n\r\n        Order memory order = hashToOrder[_orderHash];\r\n        order.trade.exchangeConnector = _exchangeConnector;\r\n\r\n        if(ERC20(order.trade.tradeToken).balanceOf(address(escrow)) < initialTradeAmount[_orderHash]){\r\n            emit LogErrorWithHintBytes32(_orderHash, \"MKernel::processTradeForExpiry\", \"INSUFFICIENT_TRADE_BALANCE_IN_ESCROW\");\r\n            return;\r\n        }\r\n\r\n        if(ERC20(order.collateralToken).balanceOf(address(escrow)) < order.collateralAmount){\r\n            emit LogErrorWithHintBytes32(_orderHash, \"MKernel::processTradeForExpiry\", \"INSUFFICIENT_COLLATERAL_BALANCE_IN_ESCROW\");\r\n            return;\r\n        }\r\n\r\n        if(now > order.expirationTimestamp) {\r\n            isDefaulted[order.orderHash] = true;\r\n            _performOrderLiquidation(order);\r\n            emit LogOrderDefaulted(order.orderHash, \"MKERNEL_DUE_DATE_PASSED\");\r\n            return;\r\n        }\r\n\r\n        emit LogErrorWithHintBytes32(order.orderHash, \"MKernel::processTradeForExpiry\", \"NO_ACTION_PERFORMED\");\r\n    }\r\n\r\n\r\n    function processTradeForStopLoss\r\n    (\r\n        bytes32 _orderHash,\r\n        address _exchangeConnector,\r\n        uint[2] _tokenPrices,\r\n        uint _bufferInPrincipal\r\n    )\r\n        external\r\n        note\r\n        onlyAdmin\r\n        addressValid(_exchangeConnector)\r\n    {   \r\n        if(!isOrder[_orderHash]){\r\n            emit LogErrorWithHintBytes32(_orderHash, \"MKernel::processTradeForStopLoss\",\"ORDER_DOES_NOT_EXIST\");\r\n            return;\r\n        }\r\n\r\n        if(isLiquidated[_orderHash]){\r\n            emit LogErrorWithHintBytes32(_orderHash, \"MKernel::processTradeForStopLoss\",\"ORDER_ALREADY_LIQUIDATED\");\r\n            return;\r\n        }\r\n\r\n        if(isDefaulted[_orderHash]){\r\n            emit LogErrorWithHintBytes32(_orderHash, \"MKernel::processTradeForStopLoss\",\"ORDER_ALREADY_DEFAULTED\");\r\n            return;\r\n        }\r\n\r\n        Order memory order = hashToOrder[_orderHash];\r\n        order.trade.exchangeConnector = _exchangeConnector;\r\n\r\n        if(ERC20(order.trade.tradeToken).balanceOf(address(escrow)) < initialTradeAmount[_orderHash]){\r\n            emit LogErrorWithHintBytes32(_orderHash, \"MKernel::processTradeForStopLoss\", \"INSUFFICIENT_TRADE_BALANCE_IN_ESCROW\");\r\n            return;\r\n        }\r\n\r\n        if(ERC20(order.collateralToken).balanceOf(address(escrow)) < order.collateralAmount){\r\n            emit LogErrorWithHintBytes32(_orderHash, \"MKernel::processTradeForStopLoss\", \"INSUFFICIENT_COLLATERAL_BALANCE_IN_ESCROW\");\r\n            return;\r\n        }\r\n\r\n        if(!_isPositionAboveStopLoss(order, _tokenPrices, _bufferInPrincipal)) {\r\n            isDefaulted[order.orderHash] = true;\r\n            _performOrderLiquidation(order);\r\n            emit LogOrderDefaulted(order.orderHash, \"MKERNEL_ORDER_UNSAFE\");\r\n            return;\r\n        }\r\n\r\n        emit LogErrorWithHintBytes32(order.orderHash, \"MKernel::processTradeForStopLoss\", \"NO_ACTION_PERFORMED\");\r\n    }\r\n\r\n    function processTradeForStopProfit\r\n    (\r\n        bytes32 _orderHash,\r\n        address _exchangeConnector,\r\n        uint[2] _tokenPrices,\r\n        uint _bufferInPrincipal\r\n    )\r\n        external\r\n        note\r\n        onlyAdmin\r\n        addressValid(_exchangeConnector)\r\n    {   \r\n        if(!isOrder[_orderHash]){\r\n            emit LogErrorWithHintBytes32(_orderHash, \"MKernel::processTradeForStopProfit\",\"ORDER_DOES_NOT_EXIST\");\r\n            return;\r\n        }\r\n\r\n        if(isLiquidated[_orderHash]){\r\n            emit LogErrorWithHintBytes32(_orderHash, \"MKernel::processTradeForStopProfit\",\"ORDER_ALREADY_LIQUIDATED\");\r\n            return;\r\n        }\r\n\r\n        if(isDefaulted[_orderHash]){\r\n            emit LogErrorWithHintBytes32(_orderHash, \"MKernel::processTradeForStopProfit\",\"ORDER_ALREADY_DEFAULTED\");\r\n            return;\r\n        }\r\n\r\n        Order memory order = hashToOrder[_orderHash];\r\n        order.trade.exchangeConnector = _exchangeConnector;\r\n\r\n        if(ERC20(order.trade.tradeToken).balanceOf(address(escrow)) < initialTradeAmount[_orderHash]){\r\n            emit LogErrorWithHintBytes32(_orderHash, \"MKernel::processTradeForStopProfit\", \"INSUFFICIENT_TRADE_BALANCE_IN_ESCROW\");\r\n            return;\r\n        }\r\n\r\n        if(ERC20(order.collateralToken).balanceOf(address(escrow)) < order.collateralAmount){\r\n            emit LogErrorWithHintBytes32(_orderHash, \"MKernel::processTradeForStopProfit\", \"INSUFFICIENT_COLLATERAL_BALANCE_IN_ESCROW\");\r\n            return;\r\n        }\r\n        \r\n        if(_isPositionAboveStopProfit(order, _tokenPrices, _bufferInPrincipal)) {\r\n            isLiquidated[order.orderHash] = true;\r\n            _performOrderLiquidation(order);\r\n            emit LogOrderStoppedAtProfit(order.orderHash);\r\n            return;\r\n        }\r\n\r\n        emit LogErrorWithHintBytes32(order.orderHash, \"MKernel::processTradeForStopProfit\", \"NO_ACTION_PERFORMED\");\r\n    }\r\n\r\n    function _performOrderLiquidation(Order _order) \r\n        internal\r\n    {   \r\n        uint tradeAmount = initialTradeAmount[_order.orderHash];\r\n        uint valueToRepay = add(_order.principalAmount, _order.premium);\r\n        uint valueToRepayWithFee = add(valueToRepay, _order.fee);\r\n    \r\n        uint principalFromTrade = 0;\r\n        uint principalFromCollateral = 0;\r\n        uint principalNeededFromCollateral = 0;\r\n        uint collateralLeft = 0;\r\n        uint userProfit = 0;\r\n        uint totalPrincipalAcquired = 0;\r\n        uint orderFee = 0;\r\n        \r\n\r\n        \r\n            (principalFromTrade,) = _tradeWithFixedInput(_order, _order.trade.tradeToken, _order.principalToken, tradeAmount);\r\n\r\n            if(principalFromTrade >= valueToRepayWithFee) {\r\n                userProfit = sub(principalFromTrade, valueToRepayWithFee);\r\n                orderFee = _order.fee;\r\n                _performSettlement(_order, valueToRepay, _order.premium, 0, _order.collateralAmount, userProfit, orderFee);\r\n            } else {\r\n\r\n                principalNeededFromCollateral = sub(valueToRepayWithFee, principalFromTrade);\r\n\r\n                if (_order.collateralToken == _order.principalToken) {\r\n                    principalFromCollateral = principalNeededFromCollateral;\r\n\r\n                    if(_order.collateralAmount >= principalNeededFromCollateral) {\r\n                        collateralLeft = sub(_order.collateralAmount, principalNeededFromCollateral);\r\n                    }\r\n\r\n                } else {\r\n                    (principalFromCollateral, collateralLeft) = _tradeWithFixedOutput(_order, _order.collateralToken, _order.principalToken, _order.collateralAmount, principalNeededFromCollateral);    \r\n                }\r\n\r\n                if(principalFromCollateral >= principalNeededFromCollateral) {\r\n                    orderFee = _order.fee;\r\n                    _performSettlement(_order, valueToRepay, _order.premium, 0, collateralLeft, 0, orderFee);\r\n                } else {\r\n                    totalPrincipalAcquired = add(principalFromTrade, principalFromCollateral);\r\n                    _performSettlementAfterAllPossibleLiquidations(_order, totalPrincipalAcquired);\r\n                }\r\n            }\r\n                       \r\n    }\r\n\r\n    function _tradeWithFixedInput(Order _order, address _srcToken, address _destToken, uint _srcTokenValue)\r\n        internal\r\n        returns (uint _destTokenValue, uint _srcTokenValueLeft)\r\n    {\r\n        ExchangeConnector exchangeConnector = ExchangeConnector(_order.trade.exchangeConnector);\r\n        return exchangeConnector.tradeWithInputFixed(\r\n                    escrow,\r\n                    _srcToken,\r\n                    _destToken,\r\n                    _srcTokenValue\r\n        );\r\n    }\r\n\r\n    function _tradeWithFixedOutput(Order _order, address _srcToken, address _destToken, uint _srcTokenValue, uint _maxDestTokenValue)\r\n        internal\r\n        returns (uint _destTokenValue, uint _srcTokenValueLeft)\r\n    {\r\n        ExchangeConnector exchangeConnector = ExchangeConnector(_order.trade.exchangeConnector);\r\n        return exchangeConnector.tradeWithOutputFixed(\r\n                    escrow,\r\n                    _srcToken,\r\n                    _destToken,\r\n                    _srcTokenValue,\r\n                    _maxDestTokenValue\r\n        );\r\n    }\r\n\r\n    function _isTradeFeasible(Order _order, address _srcToken, address _destToken, uint _srcTokenValue)\r\n        internal\r\n        view\r\n        returns (bool)\r\n    {   \r\n        ExchangeConnector exchangeConnector = ExchangeConnector(_order.trade.exchangeConnector);\r\n        return exchangeConnector.isTradeFeasible(_srcToken, _destToken, _srcTokenValue);\r\n    }\r\n\r\n    function _performSettlementAfterAllPossibleLiquidations\r\n    (\r\n        Order _order,\r\n        uint _totalPrincipalAcquired\r\n    )\r\n        internal\r\n    {\r\n        uint valueToRepay = add(_order.principalAmount, _order.premium);\r\n\r\n        if(_totalPrincipalAcquired >= valueToRepay) {\r\n            _performSettlement(_order, valueToRepay, _order.premium, 0, 0, 0, sub(_totalPrincipalAcquired, valueToRepay));\r\n        } else if((_totalPrincipalAcquired < valueToRepay) && (_totalPrincipalAcquired >= _order.principalAmount)) {\r\n            _performSettlement(_order, _totalPrincipalAcquired, sub(_totalPrincipalAcquired, _order.principalAmount), 0, 0, 0, 0);\r\n        } else {\r\n            _performSettlement(_order, _totalPrincipalAcquired, 0, sub(_order.principalAmount, _totalPrincipalAcquired), 0, 0, 0);\r\n        }\r\n\r\n    }\r\n\r\n    function _performSettlement\r\n    (\r\n        Order _order,\r\n        uint _valueRepaid,\r\n        uint _reserveProfit,\r\n        uint _reserveLoss,\r\n        uint _collateralLeft,\r\n        uint _userProfit,\r\n        uint _fee\r\n    ) \r\n        internal \r\n    {\r\n        uint closingFromPrincipal = 0;\r\n        uint userEarnings = _userProfit;\r\n\r\n        if(_fee > 0){\r\n            escrow.transfer(_order.principalToken, feeWallet, _fee);\r\n        }\r\n        \r\n        reserve.lock(_order.principalToken, escrow, _valueRepaid, _reserveProfit, _reserveLoss);\r\n        \r\n        if(_collateralLeft > 0) {\r\n            escrow.transfer(_order.collateralToken, _order.account, _collateralLeft);    \r\n        }\r\n\r\n        if(_userProfit > 0) {\r\n            if(_order.trade.closingToken == _order.principalToken || !_isTradeFeasible(_order, _order.principalToken, _order.trade.closingToken, _userProfit)) {\r\n                escrow.transfer(_order.principalToken, _order.account, _userProfit);\r\n            } else {\r\n                (closingFromPrincipal,) = _tradeWithFixedInput(_order, _order.principalToken, _order.trade.closingToken, _userProfit);\r\n                escrow.transfer(_order.trade.closingToken, _order.account, closingFromPrincipal);\r\n                userEarnings = closingFromPrincipal;\r\n            }\r\n        }\r\n\r\n        emit LogOrderSettlement(_order.orderHash, _valueRepaid, _reserveProfit, _reserveLoss, _collateralLeft, userEarnings, _fee);\r\n    }\r\n\r\n    function _isPositionAboveStopLoss(Order _order, uint[2] _tokenPrices, uint _bufferInPrincipal)\r\n        internal \r\n        view\r\n        returns (bool)\r\n    {\r\n        uint principalPerCollateral = _tokenPrices[0]; \r\n        uint principalPerTrade = _tokenPrices[1];\r\n        uint tradeAmount = initialTradeAmount[_order.orderHash];\r\n\r\n        uint valueToRepayWithFee = add(add(_order.principalAmount, _order.premium), _order.fee);\r\n        uint totalCollateralValueInPrincipal = div(mul(_order.collateralAmount, principalPerCollateral), WAD);\r\n        uint totalTradeValueInPrincipal = div(mul(tradeAmount, principalPerTrade), WAD);\r\n\r\n        uint bufferValue = div(mul(_order.principalAmount, _bufferInPrincipal), WAD);\r\n        uint minValueReq = div(mul(_order.trade.stopLoss, totalCollateralValueInPrincipal), WAD);\r\n\r\n        if(add(valueToRepayWithFee, bufferValue) >= totalTradeValueInPrincipal && \r\n            sub(add(valueToRepayWithFee, bufferValue), totalTradeValueInPrincipal) >= minValueReq) \r\n        {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    function _isPositionAboveStopProfit(Order _order, uint[2] _tokenPrices, uint _bufferInPrincipal)\r\n        internal \r\n        view\r\n        returns (bool)\r\n    {       \r\n        if(_order.trade.stopProfit == 0) {\r\n            return false;\r\n        } else {\r\n            uint principalPerTrade = _tokenPrices[1];\r\n            uint tradeAmount = initialTradeAmount[_order.orderHash];\r\n\r\n            uint valueToRepayWithFee = add(add(_order.principalAmount, _order.premium), _order.fee);\r\n            uint totalTradeValueInPrincipal = div(mul(tradeAmount, principalPerTrade), WAD);\r\n\r\n            uint stopProfitValue = div(mul(_order.principalAmount, _order.trade.stopProfit), WAD);\r\n            uint bufferValue = div(mul(_order.principalAmount, _bufferInPrincipal), WAD);\r\n\r\n            if(totalTradeValueInPrincipal >= add(add(valueToRepayWithFee, stopProfitValue), bufferValue)) {\r\n                return true;\r\n            }\r\n\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function _generateLiquidateOrderHash\r\n    (\r\n        bytes32 _orderHash\r\n    )\r\n        internal\r\n        view\r\n        returns (bytes32 _liquidateOrderHash)\r\n    {\r\n        return keccak256(\r\n            abi.encodePacked(\r\n                address(this),\r\n                _orderHash,\r\n                \"CANCEL_MKERNEL_ORDER\"\r\n            )\r\n        );\r\n    }\r\n\r\n    function _isOrderValid(Order _order)\r\n        internal\r\n        pure\r\n        returns (bool)\r\n    {\r\n        if(_order.account == address(0) || _order.byUser == address(0)\r\n         || _order.principalToken == address(0) || _order.collateralToken == address(0)\r\n         || _order.trade.closingToken == address(0)\r\n         || _order.trade.tradeToken == address(0)\r\n         || (_order.trade.tradeToken == _order.principalToken) || _order.trade.exchangeConnector == address(0)\r\n         || _order.principalAmount == 0 || _order.collateralAmount == 0\r\n         || _order.premium == 0\r\n         || _order.expirationTimestamp <= _order.createdTimestamp || _order.salt == 0) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    function _composeOrder\r\n    (\r\n        address[6] _orderAddresses,\r\n        uint[8] _orderValues\r\n    )\r\n        internal\r\n        view\r\n        returns (Order _order)\r\n    {   \r\n        Trade memory trade = _composeTrade(_orderAddresses[4], _orderAddresses[5], _orderValues[6], _orderValues[7]);\r\n\r\n        Order memory order = Order({\r\n            account: _orderAddresses[0],\r\n            byUser: _orderAddresses[1],\r\n            principalToken: _orderAddresses[2],\r\n            collateralToken: _orderAddresses[3],\r\n            principalAmount: _orderValues[0],\r\n            collateralAmount: _orderValues[1],\r\n            premium: _orderValues[2],\r\n            duration: _orderValues[3],\r\n            expirationTimestamp: add(now, _orderValues[3]),\r\n            salt: _orderValues[4],\r\n            fee: _orderValues[5],\r\n            createdTimestamp: now,\r\n            orderHash: bytes32(0),\r\n            trade: trade\r\n        });\r\n\r\n        order.orderHash = _generateOrderHash(order);\r\n    \r\n        return order;\r\n    }\r\n\r\n    function _composeTrade\r\n    (\r\n        address _tradeToken,\r\n        address _closingToken,\r\n        uint _stopProfit,\r\n        uint _stopLoss\r\n    )\r\n        internal \r\n        pure\r\n        returns (Trade _trade)\r\n    {\r\n        _trade = Trade({\r\n            tradeToken: _tradeToken,\r\n            closingToken: _closingToken,\r\n            stopProfit: _stopProfit,\r\n            stopLoss: _stopLoss,\r\n            exchangeConnector: address(0)\r\n        });\r\n    }\r\n\r\n    function _generateOrderHash(Order _order)\r\n        internal\r\n        view\r\n        returns (bytes32 _orderHash)\r\n    {\r\n        return keccak256(\r\n            abi.encodePacked(\r\n                address(this),\r\n                _generateOrderHash1(_order),\r\n                _generateOrderHash2(_order)\r\n            )\r\n        );\r\n    }\r\n\r\n    function _generateOrderHash1(Order _order)\r\n        internal\r\n        view\r\n        returns (bytes32 _orderHash1) \r\n    {\r\n        return keccak256(\r\n            abi.encodePacked(\r\n                address(this),\r\n                _order.account,\r\n                _order.principalToken,\r\n                _order.collateralToken,\r\n                _order.principalAmount,\r\n                _order.collateralAmount,\r\n                _order.premium,\r\n                _order.duration,\r\n                _order.salt,\r\n                _order.fee\r\n            )\r\n        );\r\n    }\r\n\r\n    function _generateOrderHash2(Order _order)\r\n        internal\r\n        view\r\n        returns (bytes32 _orderHash2)\r\n    {\r\n        return keccak256(\r\n            abi.encodePacked(\r\n                address(this),\r\n                _order.trade.tradeToken,\r\n                _order.trade.closingToken,\r\n                _order.trade.stopProfit,\r\n                _order.trade.stopLoss,\r\n                _order.salt\r\n            )\r\n        );\r\n    }\r\n\r\n    function getAllOrders()\r\n        public \r\n        view \r\n        returns \r\n        (\r\n            bytes32[]\r\n        )\r\n    {\r\n        return orders;\r\n    }\r\n\r\n    \r\n    function getOrder(bytes32 _orderHash)\r\n        public \r\n        view \r\n        returns \r\n        (\r\n            address _account,\r\n            address _byUser,\r\n            address _principalToken,\r\n            address _collateralToken,\r\n            uint _principalAmount,\r\n            uint _collateralAmount,\r\n            uint _premium,\r\n            uint _expirationTimestamp,\r\n            uint _salt,\r\n            uint _fee,\r\n            uint _createdTimestamp\r\n        )\r\n    {   \r\n        Order memory order = hashToOrder[_orderHash];\r\n        return (\r\n            order.account,\r\n            order.byUser,\r\n            order.principalToken,\r\n            order.collateralToken,\r\n            order.principalAmount,\r\n            order.collateralAmount,\r\n            order.premium,\r\n            order.expirationTimestamp,\r\n            order.salt,\r\n            order.fee,\r\n            order.createdTimestamp\r\n        );\r\n    }\r\n\r\n    function getTrade(bytes32 _orderHash)\r\n        public \r\n        view \r\n        returns \r\n        (\r\n            address _tradeToken,\r\n            address _closingToken,\r\n            address _initExchangeConnector,\r\n            uint _stopProfit,\r\n            uint _stopLoss\r\n        )\r\n    {   \r\n        Order memory order = hashToOrder[_orderHash];\r\n        return (\r\n            order.trade.tradeToken,\r\n            order.trade.closingToken,\r\n            order.trade.exchangeConnector,\r\n            order.trade.stopProfit,\r\n            order.trade.stopLoss\r\n        );\r\n    }\r\n\r\n    function getOrdersForAccount(address _account) \r\n        public\r\n        view \r\n        returns \r\n        (\r\n            bytes32[]\r\n        )\r\n    {\r\n        return accountToOrders[_account];\r\n    }\r\n\r\n}","ABI":"[{\"constant\":false,\"inputs\":[],\"name\":\"stop\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"owner_\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"initialTradeAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_config\",\"type\":\"address\"}],\"name\":\"setConfig\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"isDefaulted\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"getOrdersForAccount\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"isLiquidated\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_orderHash\",\"type\":\"bytes32\"},{\"name\":\"_exchangeConnector\",\"type\":\"address\"}],\"name\":\"processTradeForExpiry\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_orderHash\",\"type\":\"bytes32\"}],\"name\":\"getOrder\",\"outputs\":[{\"name\":\"_account\",\"type\":\"address\"},{\"name\":\"_byUser\",\"type\":\"address\"},{\"name\":\"_principalToken\",\"type\":\"address\"},{\"name\":\"_collateralToken\",\"type\":\"address\"},{\"name\":\"_principalAmount\",\"type\":\"uint256\"},{\"name\":\"_collateralAmount\",\"type\":\"uint256\"},{\"name\":\"_premium\",\"type\":\"uint256\"},{\"name\":\"_expirationTimestamp\",\"type\":\"uint256\"},{\"name\":\"_salt\",\"type\":\"uint256\"},{\"name\":\"_fee\",\"type\":\"uint256\"},{\"name\":\"_createdTimestamp\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_orderAddresses\",\"type\":\"address[6]\"},{\"name\":\"_orderValues\",\"type\":\"uint256[8]\"},{\"name\":\"_exchangeConnector\",\"type\":\"address\"},{\"name\":\"_signature\",\"type\":\"bytes\"}],\"name\":\"createOrder\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"accountFactory\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"accountToOrders\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"stopped\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"config\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_orderHash\",\"type\":\"bytes32\"},{\"name\":\"_exchangeConnector\",\"type\":\"address\"},{\"name\":\"_tokenPrices\",\"type\":\"uint256[2]\"},{\"name\":\"_bufferInPrincipal\",\"type\":\"uint256\"}],\"name\":\"processTradeForStopLoss\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"authority_\",\"type\":\"address\"}],\"name\":\"setAuthority\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAllOrders\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"isOrder\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_feeWallet\",\"type\":\"address\"}],\"name\":\"setFeeWallet\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_reserve\",\"type\":\"address\"}],\"name\":\"setReserve\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_orderHash\",\"type\":\"bytes32\"}],\"name\":\"getTrade\",\"outputs\":[{\"name\":\"_tradeToken\",\"type\":\"address\"},{\"name\":\"_closingToken\",\"type\":\"address\"},{\"name\":\"_initExchangeConnector\",\"type\":\"address\"},{\"name\":\"_stopProfit\",\"type\":\"uint256\"},{\"name\":\"_stopLoss\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"orders\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_accountFactory\",\"type\":\"address\"}],\"name\":\"setAccountFactory\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"start\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"authority\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_orderHash\",\"type\":\"bytes32\"},{\"name\":\"_exchangeConnector\",\"type\":\"address\"},{\"name\":\"_tokenPrices\",\"type\":\"uint256[2]\"},{\"name\":\"_bufferInPrincipal\",\"type\":\"uint256\"}],\"name\":\"processTradeForStopProfit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_escrow\",\"type\":\"address\"}],\"name\":\"setEscrow\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"hashToOrder\",\"outputs\":[{\"name\":\"account\",\"type\":\"address\"},{\"name\":\"byUser\",\"type\":\"address\"},{\"name\":\"principalToken\",\"type\":\"address\"},{\"name\":\"collateralToken\",\"type\":\"address\"},{\"components\":[{\"name\":\"tradeToken\",\"type\":\"address\"},{\"name\":\"closingToken\",\"type\":\"address\"},{\"name\":\"exchangeConnector\",\"type\":\"address\"},{\"name\":\"stopProfit\",\"type\":\"uint256\"},{\"name\":\"stopLoss\",\"type\":\"uint256\"}],\"name\":\"trade\",\"type\":\"tuple\"},{\"name\":\"principalAmount\",\"type\":\"uint256\"},{\"name\":\"collateralAmount\",\"type\":\"uint256\"},{\"name\":\"premium\",\"type\":\"uint256\"},{\"name\":\"expirationTimestamp\",\"type\":\"uint256\"},{\"name\":\"duration\",\"type\":\"uint256\"},{\"name\":\"salt\",\"type\":\"uint256\"},{\"name\":\"fee\",\"type\":\"uint256\"},{\"name\":\"createdTimestamp\",\"type\":\"uint256\"},{\"name\":\"orderHash\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"reserve\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"escrow\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_orderHash\",\"type\":\"bytes32\"},{\"name\":\"_exchangeConnector\",\"type\":\"address\"},{\"name\":\"_signature\",\"type\":\"bytes\"}],\"name\":\"liquidateOrder\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"feeWallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_escrow\",\"type\":\"address\"},{\"name\":\"_accountFactory\",\"type\":\"address\"},{\"name\":\"_reserve\",\"type\":\"address\"},{\"name\":\"_feeWallet\",\"type\":\"address\"},{\"name\":\"_config\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"orderHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"tradeAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"expirationTimestamp\",\"type\":\"uint256\"}],\"name\":\"LogOrderCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"orderHash\",\"type\":\"bytes32\"}],\"name\":\"LogOrderLiquidatedByUser\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"orderHash\",\"type\":\"bytes32\"}],\"name\":\"LogOrderStoppedAtProfit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"orderHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"reason\",\"type\":\"string\"}],\"name\":\"LogOrderDefaulted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"orderHash\",\"type\":\"bytes32\"}],\"name\":\"LogNoActionPerformed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"orderHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"valueRepaid\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"reserveProfit\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"reserveLoss\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"collateralLeft\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"userProfit\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"LogOrderSettlement\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"methodSig\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"errMsg\",\"type\":\"string\"}],\"name\":\"LogError\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"bytes32Value\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"methodSig\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"errMsg\",\"type\":\"string\"}],\"name\":\"LogErrorWithHintBytes32\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"addressValue\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"methodSig\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"errMsg\",\"type\":\"string\"}],\"name\":\"LogErrorWithHintAddress\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"authority\",\"type\":\"address\"}],\"name\":\"LogSetAuthority\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"LogSetOwner\",\"type\":\"event\"},{\"anonymous\":true,\"inputs\":[{\"indexed\":true,\"name\":\"sig\",\"type\":\"bytes4\"},{\"indexed\":true,\"name\":\"guy\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"foo\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"bar\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"wad\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"fax\",\"type\":\"bytes\"}],\"name\":\"LogNote\",\"type\":\"event\"}]","ContractName":"MKernel","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000af38668f4719ecf9452dc0300be3f6c83cbf37210000000000000000000000004e9d7f37eadc6fef64b5f5dccc4deb622466767700000000000000000000000064d14595152b430cf6940da15c6e39545c7c5b7e0000000000000000000000003e990e787a88cd4426fb3af9b90dd1d951e2cb87000000000000000000000000431f429035a1e3059d5c6a9a83208c6d3143d925","Library":"","SwarmSource":"bzzr://b978523cfaf0225ad9aaac828feaa290019983b18ae0961590f65ff683894812"}]}