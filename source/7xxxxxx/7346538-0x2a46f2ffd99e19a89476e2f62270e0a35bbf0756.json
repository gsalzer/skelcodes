{"status":"1","message":"OK","result":[{"SourceCode":"// File: REMIX_FILE_SYNC/openzeppelin-solidity/contracts/math/SafeMath.sol\r\n\r\npragma solidity ^0.4.21;\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return a / b;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n// File: REMIX_FILE_SYNC/ApprovedCreatorRegistryInterface.sol\r\n\r\npragma solidity ^0.4.22;\r\n\r\n\r\n/**\r\n * Interface to the digital media store external contract that is \r\n * responsible for storing the common digital media and collection data.\r\n * This allows for new token contracts to be deployed and continue to reference\r\n * the digital media and collection data.\r\n */\r\ncontract ApprovedCreatorRegistryInterface {\r\n\r\n    function getVersion() public pure returns (uint);\r\n    function typeOfContract() public pure returns (string);\r\n    function isOperatorApprovedForCustodialAccount(\r\n        address _operator,\r\n        address _custodialAddress) public view returns (bool);\r\n\r\n}\r\n\r\n// File: REMIX_FILE_SYNC/DigitalMediaStoreInterface.sol\r\n\r\npragma solidity 0.4.25;\r\n\r\n\r\n/**\r\n * Interface to the digital media store external contract that is \r\n * responsible for storing the common digital media and collection data.\r\n * This allows for new token contracts to be deployed and continue to reference\r\n * the digital media and collection data.\r\n */\r\ncontract DigitalMediaStoreInterface {\r\n\r\n    function getDigitalMediaStoreVersion() public pure returns (uint);\r\n\r\n    function getStartingDigitalMediaId() public view returns (uint256);\r\n\r\n    function registerTokenContractAddress() external;\r\n\r\n    /**\r\n     * Creates a new digital media object in storage\r\n     * @param  _creator address the address of the creator\r\n     * @param  _printIndex uint32 the current print index for the limited edition media\r\n     * @param  _totalSupply uint32 the total allowable prints for this media\r\n     * @param  _collectionId uint256 the collection id that this media belongs to\r\n     * @param  _metadataPath string the ipfs metadata path\r\n     * @return the id of the new digital media created\r\n     */\r\n    function createDigitalMedia(\r\n                address _creator, \r\n                uint32 _printIndex, \r\n                uint32 _totalSupply, \r\n                uint256 _collectionId, \r\n                string _metadataPath) external returns (uint);\r\n\r\n    /**\r\n     * Increments the current print index of the digital media object\r\n     * @param  _digitalMediaId uint256 the id of the digital media\r\n     * @param  _increment uint32 the amount to increment by\r\n     */\r\n    function incrementDigitalMediaPrintIndex(\r\n                uint256 _digitalMediaId, \r\n                uint32 _increment)  external;\r\n\r\n    /**\r\n     * Retrieves the digital media object by id\r\n     * @param  _digitalMediaId uint256 the address of the creator\r\n     */\r\n    function getDigitalMedia(uint256 _digitalMediaId) external view returns(\r\n                uint256 id,\r\n                uint32 totalSupply,\r\n                uint32 printIndex,\r\n                uint256 collectionId,\r\n                address creator,\r\n                string metadataPath);\r\n\r\n    /**\r\n     * Creates a new collection\r\n     * @param  _creator address the address of the creator\r\n     * @param  _metadataPath string the ipfs metadata path\r\n     * @return the id of the new collection created\r\n     */\r\n    function createCollection(address _creator, string _metadataPath) external returns (uint);\r\n\r\n    /**\r\n     * Retrieves a collection by id\r\n     * @param  _collectionId uint256\r\n     */\r\n    function getCollection(uint256 _collectionId) external view\r\n            returns(\r\n                uint256 id,\r\n                address creator,\r\n                string metadataPath);\r\n}\r\n\r\n// File: REMIX_FILE_SYNC/openzeppelin-solidity/contracts/ownership/Ownable.sol\r\n\r\npragma solidity ^0.4.21;\r\n\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  function Ownable() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    require(newOwner != address(0));\r\n    emit OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n\r\n}\r\n\r\n// File: REMIX_FILE_SYNC/openzeppelin-solidity/contracts/lifecycle/Pausable.sol\r\n\r\npragma solidity ^0.4.21;\r\n\r\n\r\n\r\n/**\r\n * @title Pausable\r\n * @dev Base contract which allows children to implement an emergency stop mechanism.\r\n */\r\ncontract Pausable is Ownable {\r\n  event Pause();\r\n  event Unpause();\r\n\r\n  bool public paused = false;\r\n\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is not paused.\r\n   */\r\n  modifier whenNotPaused() {\r\n    require(!paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is paused.\r\n   */\r\n  modifier whenPaused() {\r\n    require(paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to pause, triggers stopped state\r\n   */\r\n  function pause() onlyOwner whenNotPaused public {\r\n    paused = true;\r\n    emit Pause();\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to unpause, returns to normal state\r\n   */\r\n  function unpause() onlyOwner whenPaused public {\r\n    paused = false;\r\n    emit Unpause();\r\n  }\r\n}\r\n\r\n// File: REMIX_FILE_SYNC/MediaStoreVersionControl.sol\r\n\r\npragma solidity 0.4.25;\r\n\r\n\r\n\r\n/**\r\n * A special control class that is used to configure and manage a token contract's \r\n * different digital media store versions.\r\n *\r\n * Older versions of token contracts had the ability to increment the digital media's\r\n * print edition in the media store, which was necessary in the early stages to provide\r\n * upgradeability and flexibility.\r\n *\r\n * New verions will get rid of this ability now that token contract logic\r\n * is more stable and we've built in burn capabilities.  \r\n *\r\n * In order to support the older tokens, we need to be able to look up the appropriate digital\r\n * media store associated with a given digital media id on the latest token contract.\r\n */\r\ncontract MediaStoreVersionControl is Pausable {\r\n\r\n    // The single allowed creator for this digital media contract.\r\n    DigitalMediaStoreInterface public v1DigitalMediaStore;\r\n\r\n    // The current digitial media store, used for this tokens creation.\r\n    DigitalMediaStoreInterface public currentDigitalMediaStore;\r\n    uint256 public currentStartingDigitalMediaId;\r\n\r\n\r\n    /**\r\n     * Validates that the managers are initialized.\r\n     */\r\n    modifier managersInitialized() {\r\n        require(v1DigitalMediaStore != address(0));\r\n        require(currentDigitalMediaStore != address(0));\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * Sets a digital media store address upon construction.  \r\n     * Once set it's immutable, so that a token contract is always\r\n     * tied to one digital media store.\r\n     */\r\n    function setDigitalMediaStoreAddress(address _dmsAddress)  \r\n            internal {\r\n        DigitalMediaStoreInterface candidateDigitalMediaStore = DigitalMediaStoreInterface(_dmsAddress);\r\n        require(candidateDigitalMediaStore.getDigitalMediaStoreVersion() == 2, \"Incorrect version.\");\r\n        currentDigitalMediaStore = candidateDigitalMediaStore;\r\n        currentDigitalMediaStore.registerTokenContractAddress();\r\n        currentStartingDigitalMediaId = currentDigitalMediaStore.getStartingDigitalMediaId();\r\n    }\r\n\r\n    /**\r\n     * Publicly callable by the owner, but can only be set one time, so don't make \r\n     * a mistake when setting it.\r\n     *\r\n     * Will also check that the version on the other end of the contract is in fact correct.\r\n     */\r\n    function setV1DigitalMediaStoreAddress(address _dmsAddress) public onlyOwner {\r\n        require(address(v1DigitalMediaStore) == 0, \"V1 media store already set.\");\r\n        DigitalMediaStoreInterface candidateDigitalMediaStore = DigitalMediaStoreInterface(_dmsAddress);\r\n        require(candidateDigitalMediaStore.getDigitalMediaStoreVersion() == 1, \"Incorrect version.\");\r\n        v1DigitalMediaStore = candidateDigitalMediaStore;\r\n        v1DigitalMediaStore.registerTokenContractAddress();\r\n    }\r\n\r\n    /**\r\n     * Depending on the digital media id, determines whether to return the previous\r\n     * version of the digital media manager.\r\n     */\r\n    function _getDigitalMediaStore(uint256 _digitalMediaId) \r\n            internal \r\n            view\r\n            managersInitialized\r\n            returns (DigitalMediaStoreInterface) {\r\n        if (_digitalMediaId < currentStartingDigitalMediaId) {\r\n            return v1DigitalMediaStore;\r\n        } else {\r\n            return currentDigitalMediaStore;\r\n        }\r\n    }  \r\n}\r\n\r\n// File: REMIX_FILE_SYNC/DigitalMediaManager.sol\r\n\r\npragma solidity 0.4.25;\r\n\r\n\r\n\r\n\r\n/**\r\n * Manager that interfaces with the underlying digital media store contract.\r\n */\r\ncontract DigitalMediaManager is MediaStoreVersionControl {\r\n\r\n    struct DigitalMedia {\r\n        uint256 id;\r\n        uint32 totalSupply;\r\n        uint32 printIndex;\r\n        uint256 collectionId;\r\n        address creator;\r\n        string metadataPath;\r\n    }\r\n\r\n    struct DigitalMediaCollection {\r\n        uint256 id;\r\n        address creator;\r\n        string metadataPath;\r\n    }\r\n\r\n    ApprovedCreatorRegistryInterface public creatorRegistryStore;\r\n\r\n    // Set the creator registry address upon construction. Immutable.\r\n    function setCreatorRegistryStore(address _crsAddress) internal {\r\n        ApprovedCreatorRegistryInterface candidateCreatorRegistryStore = ApprovedCreatorRegistryInterface(_crsAddress);\r\n        require(candidateCreatorRegistryStore.getVersion() == 1);\r\n        // Simple check to make sure we are adding the registry contract indeed\r\n        // https://fravoll.github.io/solidity-patterns/string_equality_comparison.html\r\n        require(keccak256(candidateCreatorRegistryStore.typeOfContract()) == keccak256(\"approvedCreatorRegistry\"));\r\n        creatorRegistryStore = candidateCreatorRegistryStore;\r\n    }\r\n\r\n    /**\r\n     * Validates that the Registered store is initialized.\r\n     */\r\n    modifier registryInitialized() {\r\n        require(creatorRegistryStore != address(0));\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * Retrieves a collection object by id.\r\n     */\r\n    function _getCollection(uint256 _id) \r\n            internal \r\n            view \r\n            managersInitialized \r\n            returns(DigitalMediaCollection) {\r\n        uint256 id;\r\n        address creator;\r\n        string memory metadataPath;\r\n        (id, creator, metadataPath) = currentDigitalMediaStore.getCollection(_id);\r\n        DigitalMediaCollection memory collection = DigitalMediaCollection({\r\n            id: id,\r\n            creator: creator,\r\n            metadataPath: metadataPath\r\n        });\r\n        return collection;\r\n    }\r\n\r\n    /**\r\n     * Retrieves a digital media object by id.\r\n     */\r\n    function _getDigitalMedia(uint256 _id) \r\n            internal \r\n            view \r\n            managersInitialized \r\n            returns(DigitalMedia) {\r\n        uint256 id;\r\n        uint32 totalSupply;\r\n        uint32 printIndex;\r\n        uint256 collectionId;\r\n        address creator;\r\n        string memory metadataPath;\r\n        DigitalMediaStoreInterface _digitalMediaStore = _getDigitalMediaStore(_id);\r\n        (id, totalSupply, printIndex, collectionId, creator, metadataPath) = _digitalMediaStore.getDigitalMedia(_id);\r\n        DigitalMedia memory digitalMedia = DigitalMedia({\r\n            id: id,\r\n            creator: creator,\r\n            totalSupply: totalSupply,\r\n            printIndex: printIndex,\r\n            collectionId: collectionId,\r\n            metadataPath: metadataPath\r\n        });\r\n        return digitalMedia;\r\n    }\r\n\r\n    /**\r\n     * Increments the print index of a digital media object by some increment.\r\n     */\r\n    function _incrementDigitalMediaPrintIndex(DigitalMedia _dm, uint32 _increment) \r\n            internal \r\n            managersInitialized {\r\n        DigitalMediaStoreInterface _digitalMediaStore = _getDigitalMediaStore(_dm.id);\r\n        _digitalMediaStore.incrementDigitalMediaPrintIndex(_dm.id, _increment);\r\n    }\r\n\r\n    // Check if the token operator is approved for the owner address\r\n    function isOperatorApprovedForCustodialAccount(\r\n        address _operator, \r\n        address _owner) internal view registryInitialized returns(bool) {\r\n        return creatorRegistryStore.isOperatorApprovedForCustodialAccount(\r\n            _operator, _owner);\r\n    }\r\n}\r\n\r\n// File: REMIX_FILE_SYNC/SingleCreatorControl.sol\r\n\r\npragma solidity 0.4.25;\r\n\r\n\r\n/**\r\n * A special control class that's used to help enforce that a DigitalMedia contract\r\n * will service only a single creator's address.  This is used when deploying a \r\n * custom token contract owned and managed by a single creator.\r\n */\r\ncontract SingleCreatorControl {\r\n\r\n    // The single allowed creator for this digital media contract.\r\n    address public singleCreatorAddress;\r\n\r\n    // The single creator has changed.\r\n    event SingleCreatorChanged(\r\n        address indexed previousCreatorAddress, \r\n        address indexed newCreatorAddress);\r\n\r\n    /**\r\n     * Sets the single creator associated with this contract.  This function\r\n     * can only ever be called once, and should ideally be called at the point\r\n     * of constructing the smart contract.\r\n     */\r\n    function setSingleCreator(address _singleCreatorAddress) internal {\r\n        require(singleCreatorAddress == address(0), \"Single creator address already set.\");\r\n        singleCreatorAddress = _singleCreatorAddress;\r\n    }\r\n\r\n    /**\r\n     * Checks whether a given creator address matches the single creator address.\r\n     * Will always return true if a single creator address was never set.\r\n     */\r\n    function isAllowedSingleCreator(address _creatorAddress) internal view returns (bool) {\r\n        require(_creatorAddress != address(0), \"0x0 creator addresses are not allowed.\");\r\n        return singleCreatorAddress == address(0) || singleCreatorAddress == _creatorAddress;\r\n    }\r\n\r\n    /**\r\n     * A publicly accessible function that allows the current single creator\r\n     * assigned to this contract to change to another address.\r\n     */\r\n    function changeSingleCreator(address _newCreatorAddress) public {\r\n        require(_newCreatorAddress != address(0));\r\n        require(msg.sender == singleCreatorAddress, \"Not approved to change single creator.\");\r\n        singleCreatorAddress = _newCreatorAddress;\r\n        emit SingleCreatorChanged(singleCreatorAddress, _newCreatorAddress);\r\n    }\r\n}\r\n\r\n// File: REMIX_FILE_SYNC/openzeppelin-solidity/contracts/token/ERC721/ERC721Basic.sol\r\n\r\npragma solidity ^0.4.21;\r\n\r\n\r\n/**\r\n * @title ERC721 Non-Fungible Token Standard basic interface\r\n * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\r\n */\r\ncontract ERC721Basic {\r\n  event Transfer(address indexed _from, address indexed _to, uint256 _tokenId);\r\n  event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId);\r\n  event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\r\n\r\n  function balanceOf(address _owner) public view returns (uint256 _balance);\r\n  function ownerOf(uint256 _tokenId) public view returns (address _owner);\r\n  function exists(uint256 _tokenId) public view returns (bool _exists);\r\n\r\n  function approve(address _to, uint256 _tokenId) public;\r\n  function getApproved(uint256 _tokenId) public view returns (address _operator);\r\n\r\n  function setApprovalForAll(address _operator, bool _approved) public;\r\n  function isApprovedForAll(address _owner, address _operator) public view returns (bool);\r\n\r\n  function transferFrom(address _from, address _to, uint256 _tokenId) public;\r\n  function safeTransferFrom(address _from, address _to, uint256 _tokenId) public;\r\n  function safeTransferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _tokenId,\r\n    bytes _data\r\n  )\r\n    public;\r\n}\r\n\r\n// File: REMIX_FILE_SYNC/openzeppelin-solidity/contracts/token/ERC721/ERC721.sol\r\n\r\npragma solidity ^0.4.21;\r\n\r\n\r\n\r\n/**\r\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\r\n * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\r\n */\r\ncontract ERC721Enumerable is ERC721Basic {\r\n  function totalSupply() public view returns (uint256);\r\n  function tokenOfOwnerByIndex(address _owner, uint256 _index) public view returns (uint256 _tokenId);\r\n  function tokenByIndex(uint256 _index) public view returns (uint256);\r\n}\r\n\r\n\r\n/**\r\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\r\n * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\r\n */\r\ncontract ERC721Metadata is ERC721Basic {\r\n  function name() public view returns (string _name);\r\n  function symbol() public view returns (string _symbol);\r\n  function tokenURI(uint256 _tokenId) public view returns (string);\r\n}\r\n\r\n\r\n/**\r\n * @title ERC-721 Non-Fungible Token Standard, full implementation interface\r\n * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\r\n */\r\ncontract ERC721 is ERC721Basic, ERC721Enumerable, ERC721Metadata {\r\n}\r\n\r\n// File: REMIX_FILE_SYNC/openzeppelin-solidity/contracts/token/ERC721/ERC721Receiver.sol\r\n\r\npragma solidity ^0.4.21;\r\n\r\n\r\n/**\r\n * @title ERC721 token receiver interface\r\n * @dev Interface for any contract that wants to support safeTransfers\r\n *  from ERC721 asset contracts.\r\n */\r\ncontract ERC721Receiver {\r\n  /**\r\n   * @dev Magic value to be returned upon successful reception of an NFT\r\n   *  Equals to `bytes4(keccak256(\"onERC721Received(address,uint256,bytes)\"))`,\r\n   *  which can be also obtained as `ERC721Receiver(0).onERC721Received.selector`\r\n   */\r\n  bytes4 constant ERC721_RECEIVED = 0xf0b9e5ba;\r\n\r\n  /**\r\n   * @notice Handle the receipt of an NFT\r\n   * @dev The ERC721 smart contract calls this function on the recipient\r\n   *  after a `safetransfer`. This function MAY throw to revert and reject the\r\n   *  transfer. This function MUST use 50,000 gas or less. Return of other\r\n   *  than the magic value MUST result in the transaction being reverted.\r\n   *  Note: the contract address is always the message sender.\r\n   * @param _from The sending address\r\n   * @param _tokenId The NFT identifier which is being transfered\r\n   * @param _data Additional data with no specified format\r\n   * @return `bytes4(keccak256(\"onERC721Received(address,uint256,bytes)\"))`\r\n   */\r\n  function onERC721Received(address _from, uint256 _tokenId, bytes _data) public returns(bytes4);\r\n}\r\n\r\n// File: REMIX_FILE_SYNC/openzeppelin-solidity/contracts/AddressUtils.sol\r\n\r\npragma solidity ^0.4.21;\r\n\r\n\r\n/**\r\n * Utility library of inline functions on addresses\r\n */\r\nlibrary AddressUtils {\r\n\r\n  /**\r\n   * Returns whether the target address is a contract\r\n   * @dev This function will return false if invoked during the constructor of a contract,\r\n   *  as the code is not actually created until after the constructor finishes.\r\n   * @param addr address to check\r\n   * @return whether the target address is a contract\r\n   */\r\n  function isContract(address addr) internal view returns (bool) {\r\n    uint256 size;\r\n    // XXX Currently there is no better way to check if there is a contract in an address\r\n    // than to check the size of the code at that address.\r\n    // See https://ethereum.stackexchange.com/a/14016/36603\r\n    // for more details about how this works.\r\n    // TODO Check this again before the Serenity release, because all addresses will be\r\n    // contracts then.\r\n    assembly { size := extcodesize(addr) }  // solium-disable-line security/no-inline-assembly\r\n    return size > 0;\r\n  }\r\n\r\n}\r\n\r\n// File: REMIX_FILE_SYNC/openzeppelin-solidity/contracts/token/ERC721/ERC721BasicToken.sol\r\n\r\npragma solidity ^0.4.21;\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title ERC721 Non-Fungible Token Standard basic implementation\r\n * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\r\n */\r\ncontract ERC721BasicToken is ERC721Basic {\r\n  using SafeMath for uint256;\r\n  using AddressUtils for address;\r\n\r\n  // Equals to `bytes4(keccak256(\"onERC721Received(address,uint256,bytes)\"))`\r\n  // which can be also obtained as `ERC721Receiver(0).onERC721Received.selector`\r\n  bytes4 constant ERC721_RECEIVED = 0xf0b9e5ba;\r\n\r\n  // Mapping from token ID to owner\r\n  mapping (uint256 => address) internal tokenOwner;\r\n\r\n  // Mapping from token ID to approved address\r\n  mapping (uint256 => address) internal tokenApprovals;\r\n\r\n  // Mapping from owner to number of owned token\r\n  mapping (address => uint256) internal ownedTokensCount;\r\n\r\n  // Mapping from owner to operator approvals\r\n  mapping (address => mapping (address => bool)) internal operatorApprovals;\r\n\r\n  /**\r\n   * @dev Guarantees msg.sender is owner of the given token\r\n   * @param _tokenId uint256 ID of the token to validate its ownership belongs to msg.sender\r\n   */\r\n  modifier onlyOwnerOf(uint256 _tokenId) {\r\n    require(ownerOf(_tokenId) == msg.sender);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Checks msg.sender can transfer a token, by being owner, approved, or operator\r\n   * @param _tokenId uint256 ID of the token to validate\r\n   */\r\n  modifier canTransfer(uint256 _tokenId) {\r\n    require(isApprovedOrOwner(msg.sender, _tokenId));\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Gets the balance of the specified address\r\n   * @param _owner address to query the balance of\r\n   * @return uint256 representing the amount owned by the passed address\r\n   */\r\n  function balanceOf(address _owner) public view returns (uint256) {\r\n    require(_owner != address(0));\r\n    return ownedTokensCount[_owner];\r\n  }\r\n\r\n  /**\r\n   * @dev Gets the owner of the specified token ID\r\n   * @param _tokenId uint256 ID of the token to query the owner of\r\n   * @return owner address currently marked as the owner of the given token ID\r\n   */\r\n  function ownerOf(uint256 _tokenId) public view returns (address) {\r\n    address owner = tokenOwner[_tokenId];\r\n    require(owner != address(0));\r\n    return owner;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns whether the specified token exists\r\n   * @param _tokenId uint256 ID of the token to query the existance of\r\n   * @return whether the token exists\r\n   */\r\n  function exists(uint256 _tokenId) public view returns (bool) {\r\n    address owner = tokenOwner[_tokenId];\r\n    return owner != address(0);\r\n  }\r\n\r\n  /**\r\n   * @dev Approves another address to transfer the given token ID\r\n   * @dev The zero address indicates there is no approved address.\r\n   * @dev There can only be one approved address per token at a given time.\r\n   * @dev Can only be called by the token owner or an approved operator.\r\n   * @param _to address to be approved for the given token ID\r\n   * @param _tokenId uint256 ID of the token to be approved\r\n   */\r\n  function approve(address _to, uint256 _tokenId) public {\r\n    address owner = ownerOf(_tokenId);\r\n    require(_to != owner);\r\n    require(msg.sender == owner || isApprovedForAll(owner, msg.sender));\r\n\r\n    if (getApproved(_tokenId) != address(0) || _to != address(0)) {\r\n      tokenApprovals[_tokenId] = _to;\r\n      emit Approval(owner, _to, _tokenId);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Gets the approved address for a token ID, or zero if no address set\r\n   * @param _tokenId uint256 ID of the token to query the approval of\r\n   * @return address currently approved for a the given token ID\r\n   */\r\n  function getApproved(uint256 _tokenId) public view returns (address) {\r\n    return tokenApprovals[_tokenId];\r\n  }\r\n\r\n  /**\r\n   * @dev Sets or unsets the approval of a given operator\r\n   * @dev An operator is allowed to transfer all tokens of the sender on their behalf\r\n   * @param _to operator address to set the approval\r\n   * @param _approved representing the status of the approval to be set\r\n   */\r\n  function setApprovalForAll(address _to, bool _approved) public {\r\n    require(_to != msg.sender);\r\n    operatorApprovals[msg.sender][_to] = _approved;\r\n    emit ApprovalForAll(msg.sender, _to, _approved);\r\n  }\r\n\r\n  /**\r\n   * @dev Tells whether an operator is approved by a given owner\r\n   * @param _owner owner address which you want to query the approval of\r\n   * @param _operator operator address which you want to query the approval of\r\n   * @return bool whether the given operator is approved by the given owner\r\n   */\r\n  function isApprovedForAll(address _owner, address _operator) public view returns (bool) {\r\n    return operatorApprovals[_owner][_operator];\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers the ownership of a given token ID to another address\r\n   * @dev Usage of this method is discouraged, use `safeTransferFrom` whenever possible\r\n   * @dev Requires the msg sender to be the owner, approved, or operator\r\n   * @param _from current owner of the token\r\n   * @param _to address to receive the ownership of the given token ID\r\n   * @param _tokenId uint256 ID of the token to be transferred\r\n  */\r\n  function transferFrom(address _from, address _to, uint256 _tokenId) public canTransfer(_tokenId) {\r\n    require(_from != address(0));\r\n    require(_to != address(0));\r\n\r\n    clearApproval(_from, _tokenId);\r\n    removeTokenFrom(_from, _tokenId);\r\n    addTokenTo(_to, _tokenId);\r\n\r\n    emit Transfer(_from, _to, _tokenId);\r\n  }\r\n\r\n  /**\r\n   * @dev Safely transfers the ownership of a given token ID to another address\r\n   * @dev If the target address is a contract, it must implement `onERC721Received`,\r\n   *  which is called upon a safe transfer, and return the magic value\r\n   *  `bytes4(keccak256(\"onERC721Received(address,uint256,bytes)\"))`; otherwise,\r\n   *  the transfer is reverted.\r\n   * @dev Requires the msg sender to be the owner, approved, or operator\r\n   * @param _from current owner of the token\r\n   * @param _to address to receive the ownership of the given token ID\r\n   * @param _tokenId uint256 ID of the token to be transferred\r\n  */\r\n  function safeTransferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _tokenId\r\n  )\r\n    public\r\n    canTransfer(_tokenId)\r\n  {\r\n    // solium-disable-next-line arg-overflow\r\n    safeTransferFrom(_from, _to, _tokenId, \"\");\r\n  }\r\n\r\n  /**\r\n   * @dev Safely transfers the ownership of a given token ID to another address\r\n   * @dev If the target address is a contract, it must implement `onERC721Received`,\r\n   *  which is called upon a safe transfer, and return the magic value\r\n   *  `bytes4(keccak256(\"onERC721Received(address,uint256,bytes)\"))`; otherwise,\r\n   *  the transfer is reverted.\r\n   * @dev Requires the msg sender to be the owner, approved, or operator\r\n   * @param _from current owner of the token\r\n   * @param _to address to receive the ownership of the given token ID\r\n   * @param _tokenId uint256 ID of the token to be transferred\r\n   * @param _data bytes data to send along with a safe transfer check\r\n   */\r\n  function safeTransferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _tokenId,\r\n    bytes _data\r\n  )\r\n    public\r\n    canTransfer(_tokenId)\r\n  {\r\n    transferFrom(_from, _to, _tokenId);\r\n    // solium-disable-next-line arg-overflow\r\n    require(checkAndCallSafeTransfer(_from, _to, _tokenId, _data));\r\n  }\r\n\r\n  /**\r\n   * @dev Returns whether the given spender can transfer a given token ID\r\n   * @param _spender address of the spender to query\r\n   * @param _tokenId uint256 ID of the token to be transferred\r\n   * @return bool whether the msg.sender is approved for the given token ID,\r\n   *  is an operator of the owner, or is the owner of the token\r\n   */\r\n  function isApprovedOrOwner(address _spender, uint256 _tokenId) internal view returns (bool) {\r\n    address owner = ownerOf(_tokenId);\r\n    return _spender == owner || getApproved(_tokenId) == _spender || isApprovedForAll(owner, _spender);\r\n  }\r\n\r\n  /**\r\n   * @dev Internal function to mint a new token\r\n   * @dev Reverts if the given token ID already exists\r\n   * @param _to The address that will own the minted token\r\n   * @param _tokenId uint256 ID of the token to be minted by the msg.sender\r\n   */\r\n  function _mint(address _to, uint256 _tokenId) internal {\r\n    require(_to != address(0));\r\n    addTokenTo(_to, _tokenId);\r\n    emit Transfer(address(0), _to, _tokenId);\r\n  }\r\n\r\n  /**\r\n   * @dev Internal function to burn a specific token\r\n   * @dev Reverts if the token does not exist\r\n   * @param _tokenId uint256 ID of the token being burned by the msg.sender\r\n   */\r\n  function _burn(address _owner, uint256 _tokenId) internal {\r\n    clearApproval(_owner, _tokenId);\r\n    removeTokenFrom(_owner, _tokenId);\r\n    emit Transfer(_owner, address(0), _tokenId);\r\n  }\r\n\r\n  /**\r\n   * @dev Internal function to clear current approval of a given token ID\r\n   * @dev Reverts if the given address is not indeed the owner of the token\r\n   * @param _owner owner of the token\r\n   * @param _tokenId uint256 ID of the token to be transferred\r\n   */\r\n  function clearApproval(address _owner, uint256 _tokenId) internal {\r\n    require(ownerOf(_tokenId) == _owner);\r\n    if (tokenApprovals[_tokenId] != address(0)) {\r\n      tokenApprovals[_tokenId] = address(0);\r\n      emit Approval(_owner, address(0), _tokenId);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Internal function to add a token ID to the list of a given address\r\n   * @param _to address representing the new owner of the given token ID\r\n   * @param _tokenId uint256 ID of the token to be added to the tokens list of the given address\r\n   */\r\n  function addTokenTo(address _to, uint256 _tokenId) internal {\r\n    require(tokenOwner[_tokenId] == address(0));\r\n    tokenOwner[_tokenId] = _to;\r\n    ownedTokensCount[_to] = ownedTokensCount[_to].add(1);\r\n  }\r\n\r\n  /**\r\n   * @dev Internal function to remove a token ID from the list of a given address\r\n   * @param _from address representing the previous owner of the given token ID\r\n   * @param _tokenId uint256 ID of the token to be removed from the tokens list of the given address\r\n   */\r\n  function removeTokenFrom(address _from, uint256 _tokenId) internal {\r\n    require(ownerOf(_tokenId) == _from);\r\n    ownedTokensCount[_from] = ownedTokensCount[_from].sub(1);\r\n    tokenOwner[_tokenId] = address(0);\r\n  }\r\n\r\n  /**\r\n   * @dev Internal function to invoke `onERC721Received` on a target address\r\n   * @dev The call is not executed if the target address is not a contract\r\n   * @param _from address representing the previous owner of the given token ID\r\n   * @param _to target address that will receive the tokens\r\n   * @param _tokenId uint256 ID of the token to be transferred\r\n   * @param _data bytes optional data to send along with the call\r\n   * @return whether the call correctly returned the expected magic value\r\n   */\r\n  function checkAndCallSafeTransfer(\r\n    address _from,\r\n    address _to,\r\n    uint256 _tokenId,\r\n    bytes _data\r\n  )\r\n    internal\r\n    returns (bool)\r\n  {\r\n    if (!_to.isContract()) {\r\n      return true;\r\n    }\r\n    bytes4 retval = ERC721Receiver(_to).onERC721Received(_from, _tokenId, _data);\r\n    return (retval == ERC721_RECEIVED);\r\n  }\r\n}\r\n\r\n// File: REMIX_FILE_SYNC/openzeppelin-solidity/contracts/token/ERC721/ERC721Token.sol\r\n\r\npragma solidity ^0.4.21;\r\n\r\n\r\n\r\n\r\n/**\r\n * @title Full ERC721 Token\r\n * This implementation includes all the required and some optional functionality of the ERC721 standard\r\n * Moreover, it includes approve all functionality using operator terminology\r\n * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\r\n */\r\ncontract ERC721Token is ERC721, ERC721BasicToken {\r\n  // Token name\r\n  string internal name_;\r\n\r\n  // Token symbol\r\n  string internal symbol_;\r\n\r\n  // Mapping from owner to list of owned token IDs\r\n  mapping (address => uint256[]) internal ownedTokens;\r\n\r\n  // Mapping from token ID to index of the owner tokens list\r\n  mapping(uint256 => uint256) internal ownedTokensIndex;\r\n\r\n  // Array with all token ids, used for enumeration\r\n  uint256[] internal allTokens;\r\n\r\n  // Mapping from token id to position in the allTokens array\r\n  mapping(uint256 => uint256) internal allTokensIndex;\r\n\r\n  // Optional mapping for token URIs\r\n  mapping(uint256 => string) internal tokenURIs;\r\n\r\n  /**\r\n   * @dev Constructor function\r\n   */\r\n  function ERC721Token(string _name, string _symbol) public {\r\n    name_ = _name;\r\n    symbol_ = _symbol;\r\n  }\r\n\r\n  /**\r\n   * @dev Gets the token name\r\n   * @return string representing the token name\r\n   */\r\n  function name() public view returns (string) {\r\n    return name_;\r\n  }\r\n\r\n  /**\r\n   * @dev Gets the token symbol\r\n   * @return string representing the token symbol\r\n   */\r\n  function symbol() public view returns (string) {\r\n    return symbol_;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns an URI for a given token ID\r\n   * @dev Throws if the token ID does not exist. May return an empty string.\r\n   * @param _tokenId uint256 ID of the token to query\r\n   */\r\n  function tokenURI(uint256 _tokenId) public view returns (string) {\r\n    require(exists(_tokenId));\r\n    return tokenURIs[_tokenId];\r\n  }\r\n\r\n  /**\r\n   * @dev Gets the token ID at a given index of the tokens list of the requested owner\r\n   * @param _owner address owning the tokens list to be accessed\r\n   * @param _index uint256 representing the index to be accessed of the requested tokens list\r\n   * @return uint256 token ID at the given index of the tokens list owned by the requested address\r\n   */\r\n  function tokenOfOwnerByIndex(address _owner, uint256 _index) public view returns (uint256) {\r\n    require(_index < balanceOf(_owner));\r\n    return ownedTokens[_owner][_index];\r\n  }\r\n\r\n  /**\r\n   * @dev Gets the total amount of tokens stored by the contract\r\n   * @return uint256 representing the total amount of tokens\r\n   */\r\n  function totalSupply() public view returns (uint256) {\r\n    return allTokens.length;\r\n  }\r\n\r\n  /**\r\n   * @dev Gets the token ID at a given index of all the tokens in this contract\r\n   * @dev Reverts if the index is greater or equal to the total number of tokens\r\n   * @param _index uint256 representing the index to be accessed of the tokens list\r\n   * @return uint256 token ID at the given index of the tokens list\r\n   */\r\n  function tokenByIndex(uint256 _index) public view returns (uint256) {\r\n    require(_index < totalSupply());\r\n    return allTokens[_index];\r\n  }\r\n\r\n  /**\r\n   * @dev Internal function to set the token URI for a given token\r\n   * @dev Reverts if the token ID does not exist\r\n   * @param _tokenId uint256 ID of the token to set its URI\r\n   * @param _uri string URI to assign\r\n   */\r\n  function _setTokenURI(uint256 _tokenId, string _uri) internal {\r\n    require(exists(_tokenId));\r\n    tokenURIs[_tokenId] = _uri;\r\n  }\r\n\r\n  /**\r\n   * @dev Internal function to add a token ID to the list of a given address\r\n   * @param _to address representing the new owner of the given token ID\r\n   * @param _tokenId uint256 ID of the token to be added to the tokens list of the given address\r\n   */\r\n  function addTokenTo(address _to, uint256 _tokenId) internal {\r\n    super.addTokenTo(_to, _tokenId);\r\n    uint256 length = ownedTokens[_to].length;\r\n    ownedTokens[_to].push(_tokenId);\r\n    ownedTokensIndex[_tokenId] = length;\r\n  }\r\n\r\n  /**\r\n   * @dev Internal function to remove a token ID from the list of a given address\r\n   * @param _from address representing the previous owner of the given token ID\r\n   * @param _tokenId uint256 ID of the token to be removed from the tokens list of the given address\r\n   */\r\n  function removeTokenFrom(address _from, uint256 _tokenId) internal {\r\n    super.removeTokenFrom(_from, _tokenId);\r\n\r\n    uint256 tokenIndex = ownedTokensIndex[_tokenId];\r\n    uint256 lastTokenIndex = ownedTokens[_from].length.sub(1);\r\n    uint256 lastToken = ownedTokens[_from][lastTokenIndex];\r\n\r\n    ownedTokens[_from][tokenIndex] = lastToken;\r\n    ownedTokens[_from][lastTokenIndex] = 0;\r\n    // Note that this will handle single-element arrays. In that case, both tokenIndex and lastTokenIndex are going to\r\n    // be zero. Then we can make sure that we will remove _tokenId from the ownedTokens list since we are first swapping\r\n    // the lastToken to the first position, and then dropping the element placed in the last position of the list\r\n\r\n    ownedTokens[_from].length--;\r\n    ownedTokensIndex[_tokenId] = 0;\r\n    ownedTokensIndex[lastToken] = tokenIndex;\r\n  }\r\n\r\n  /**\r\n   * @dev Internal function to mint a new token\r\n   * @dev Reverts if the given token ID already exists\r\n   * @param _to address the beneficiary that will own the minted token\r\n   * @param _tokenId uint256 ID of the token to be minted by the msg.sender\r\n   */\r\n  function _mint(address _to, uint256 _tokenId) internal {\r\n    super._mint(_to, _tokenId);\r\n\r\n    allTokensIndex[_tokenId] = allTokens.length;\r\n    allTokens.push(_tokenId);\r\n  }\r\n\r\n  /**\r\n   * @dev Internal function to burn a specific token\r\n   * @dev Reverts if the token does not exist\r\n   * @param _owner owner of the token to burn\r\n   * @param _tokenId uint256 ID of the token being burned by the msg.sender\r\n   */\r\n  function _burn(address _owner, uint256 _tokenId) internal {\r\n    super._burn(_owner, _tokenId);\r\n\r\n    // Clear metadata (if any)\r\n    if (bytes(tokenURIs[_tokenId]).length != 0) {\r\n      delete tokenURIs[_tokenId];\r\n    }\r\n\r\n    // Reorg all tokens array\r\n    uint256 tokenIndex = allTokensIndex[_tokenId];\r\n    uint256 lastTokenIndex = allTokens.length.sub(1);\r\n    uint256 lastToken = allTokens[lastTokenIndex];\r\n\r\n    allTokens[tokenIndex] = lastToken;\r\n    allTokens[lastTokenIndex] = 0;\r\n\r\n    allTokens.length--;\r\n    allTokensIndex[_tokenId] = 0;\r\n    allTokensIndex[lastToken] = tokenIndex;\r\n  }\r\n\r\n}\r\n\r\n// File: REMIX_FILE_SYNC/ERC721Safe.sol\r\n\r\npragma solidity 0.4.25;\r\n\r\n// We have to specify what version of compiler this code will compile with\r\n\r\n\r\n\r\ncontract ERC721Safe is ERC721Token {\r\n    bytes4 constant internal InterfaceSignature_ERC165 =\r\n        bytes4(keccak256('supportsInterface(bytes4)'));\r\n\r\n    bytes4 constant internal InterfaceSignature_ERC721 =\r\n        bytes4(keccak256('name()')) ^\r\n        bytes4(keccak256('symbol()')) ^\r\n        bytes4(keccak256('totalSupply()')) ^\r\n        bytes4(keccak256('balanceOf(address)')) ^\r\n        bytes4(keccak256('ownerOf(uint256)')) ^\r\n        bytes4(keccak256('approve(address,uint256)')) ^\r\n        bytes4(keccak256('safeTransferFrom(address,address,uint256)'));\r\n\t\r\n   function supportsInterface(bytes4 _interfaceID) external view returns (bool);\r\n}\r\n\r\n// File: REMIX_FILE_SYNC/Memory.sol\r\n\r\npragma solidity 0.4.25;\r\n\r\n\r\nlibrary Memory {\r\n\r\n    // Size of a word, in bytes.\r\n    uint internal constant WORD_SIZE = 32;\r\n    // Size of the header of a 'bytes' array.\r\n    uint internal constant BYTES_HEADER_SIZE = 32;\r\n    // Address of the free memory pointer.\r\n    uint internal constant FREE_MEM_PTR = 0x40;\r\n\r\n    // Compares the 'len' bytes starting at address 'addr' in memory with the 'len'\r\n    // bytes starting at 'addr2'.\r\n    // Returns 'true' if the bytes are the same, otherwise 'false'.\r\n    function equals(uint addr, uint addr2, uint len) internal pure returns (bool equal) {\r\n        assembly {\r\n            equal := eq(keccak256(addr, len), keccak256(addr2, len))\r\n        }\r\n    }\r\n\r\n    // Compares the 'len' bytes starting at address 'addr' in memory with the bytes stored in\r\n    // 'bts'. It is allowed to set 'len' to a lower value then 'bts.length', in which case only\r\n    // the first 'len' bytes will be compared.\r\n    // Requires that 'bts.length >= len'\r\n    function equals(uint addr, uint len, bytes memory bts) internal pure returns (bool equal) {\r\n        require(bts.length >= len);\r\n        uint addr2;\r\n        assembly {\r\n            addr2 := add(bts, /*BYTES_HEADER_SIZE*/32)\r\n        }\r\n        return equals(addr, addr2, len);\r\n    }\r\n\r\n    // Allocates 'numBytes' bytes in memory. This will prevent the Solidity compiler\r\n    // from using this area of memory. It will also initialize the area by setting\r\n    // each byte to '0'.\r\n    function allocate(uint numBytes) internal pure returns (uint addr) {\r\n        // Take the current value of the free memory pointer, and update.\r\n        assembly {\r\n            addr := mload(/*FREE_MEM_PTR*/0x40)\r\n            mstore(/*FREE_MEM_PTR*/0x40, add(addr, numBytes))\r\n        }\r\n        uint words = (numBytes + WORD_SIZE - 1) / WORD_SIZE;\r\n        for (uint i = 0; i < words; i++) {\r\n            assembly {\r\n                mstore(add(addr, mul(i, /*WORD_SIZE*/32)), 0)\r\n            }\r\n        }\r\n    }\r\n\r\n    // Copy 'len' bytes from memory address 'src', to address 'dest'.\r\n    // This function does not check the or destination, it only copies\r\n    // the bytes.\r\n    function copy(uint src, uint dest, uint len) internal pure {\r\n        // Copy word-length chunks while possible\r\n        for (; len >= WORD_SIZE; len -= WORD_SIZE) {\r\n            assembly {\r\n                mstore(dest, mload(src))\r\n            }\r\n            dest += WORD_SIZE;\r\n            src += WORD_SIZE;\r\n        }\r\n\r\n        // Copy remaining bytes\r\n        uint mask = 256 ** (WORD_SIZE - len) - 1;\r\n        assembly {\r\n            let srcpart := and(mload(src), not(mask))\r\n            let destpart := and(mload(dest), mask)\r\n            mstore(dest, or(destpart, srcpart))\r\n        }\r\n    }\r\n\r\n    // Returns a memory pointer to the provided bytes array.\r\n    function ptr(bytes memory bts) internal pure returns (uint addr) {\r\n        assembly {\r\n            addr := bts\r\n        }\r\n    }\r\n\r\n    // Returns a memory pointer to the data portion of the provided bytes array.\r\n    function dataPtr(bytes memory bts) internal pure returns (uint addr) {\r\n        assembly {\r\n            addr := add(bts, /*BYTES_HEADER_SIZE*/32)\r\n        }\r\n    }\r\n\r\n    // This function does the same as 'dataPtr(bytes memory)', but will also return the\r\n    // length of the provided bytes array.\r\n    function fromBytes(bytes memory bts) internal pure returns (uint addr, uint len) {\r\n        len = bts.length;\r\n        assembly {\r\n            addr := add(bts, /*BYTES_HEADER_SIZE*/32)\r\n        }\r\n    }\r\n\r\n    // Creates a 'bytes memory' variable from the memory address 'addr', with the\r\n    // length 'len'. The function will allocate new memory for the bytes array, and\r\n    // the 'len bytes starting at 'addr' will be copied into that new memory.\r\n    function toBytes(uint addr, uint len) internal pure returns (bytes memory bts) {\r\n        bts = new bytes(len);\r\n        uint btsptr;\r\n        assembly {\r\n            btsptr := add(bts, /*BYTES_HEADER_SIZE*/32)\r\n        }\r\n        copy(addr, btsptr, len);\r\n    }\r\n\r\n    // Get the word stored at memory address 'addr' as a 'uint'.\r\n    function toUint(uint addr) internal pure returns (uint n) {\r\n        assembly {\r\n            n := mload(addr)\r\n        }\r\n    }\r\n\r\n    // Get the word stored at memory address 'addr' as a 'bytes32'.\r\n    function toBytes32(uint addr) internal pure returns (bytes32 bts) {\r\n        assembly {\r\n            bts := mload(addr)\r\n        }\r\n    }\r\n\r\n    /*\r\n    // Get the byte stored at memory address 'addr' as a 'byte'.\r\n    function toByte(uint addr, uint8 index) internal pure returns (byte b) {\r\n        require(index < WORD_SIZE);\r\n        uint8 n;\r\n        assembly {\r\n            n := byte(index, mload(addr))\r\n        }\r\n        b = byte(n);\r\n    }\r\n    */\r\n}\r\n\r\n// File: REMIX_FILE_SYNC/HelperUtils.sol\r\n\r\npragma solidity 0.4.25;\r\n\r\n\r\n/**\r\n * Internal helper functions\r\n */\r\ncontract HelperUtils {\r\n\r\n    // converts bytes32 to a string\r\n    // enable this when you use it. Saving gas for now\r\n    // function bytes32ToString(bytes32 x) private pure returns (string) {\r\n    //     bytes memory bytesString = new bytes(32);\r\n    //     uint charCount = 0;\r\n    //     for (uint j = 0; j < 32; j++) {\r\n    //         byte char = byte(bytes32(uint(x) * 2 ** (8 * j)));\r\n    //         if (char != 0) {\r\n    //             bytesString[charCount] = char;\r\n    //             charCount++;\r\n    //         }\r\n    //     }\r\n    //     bytes memory bytesStringTrimmed = new bytes(charCount);\r\n    //     for (j = 0; j < charCount; j++) {\r\n    //         bytesStringTrimmed[j] = bytesString[j];\r\n    //     }\r\n    //     return string(bytesStringTrimmed);\r\n    // } \r\n\r\n    /**\r\n     * Concatenates two strings\r\n     * @param  _a string\r\n     * @param  _b string\r\n     * @return string concatenation of two string\r\n     */\r\n    function strConcat(string _a, string _b) internal pure returns (string) {\r\n        bytes memory _ba = bytes(_a);\r\n        bytes memory _bb = bytes(_b);\r\n        string memory ab = new string(_ba.length + _bb.length);\r\n        bytes memory bab = bytes(ab);\r\n        uint k = 0;\r\n        for (uint i = 0; i < _ba.length; i++) bab[k++] = _ba[i];\r\n        for (i = 0; i < _bb.length; i++) bab[k++] = _bb[i];\r\n        return string(bab);\r\n    }\r\n}\r\n\r\n// File: REMIX_FILE_SYNC/DigitalMediaToken.sol\r\n\r\npragma solidity 0.4.25;\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * The DigitalMediaToken contract.  Fully implements the ERC721 contract\r\n * from OpenZeppelin without any modifications to it.\r\n * \r\n * This contract allows for the creation of:\r\n *  1. New Collections\r\n *  2. New DigitalMedia objects\r\n *  3. New DigitalMediaRelease objects\r\n * \r\n * The primary piece of logic is to ensure that an ERC721 token can \r\n * have a supply and print edition that is enforced by this contract.\r\n */\r\ncontract DigitalMediaToken is DigitalMediaManager, ERC721Safe, HelperUtils, SingleCreatorControl {\r\n\r\n    event DigitalMediaReleaseCreateEvent(\r\n        uint256 id, \r\n        address owner,\r\n        uint32 printEdition,\r\n        string tokenURI, \r\n        uint256 digitalMediaId);\r\n\r\n    // Event fired when a new digital media is created\r\n    event DigitalMediaCreateEvent(\r\n        uint256 id, \r\n        address storeContractAddress,\r\n        address creator, \r\n        uint32 totalSupply, \r\n        uint32 printIndex, \r\n        uint256 collectionId, \r\n        string metadataPath);\r\n\r\n    // Event fired when a digital media's collection is \r\n    event DigitalMediaCollectionCreateEvent(\r\n        uint256 id, \r\n        address storeContractAddress,\r\n        address creator, \r\n        string metadataPath);\r\n\r\n    // Event fired when a digital media is burned\r\n    event DigitalMediaBurnEvent(\r\n        uint256 id,\r\n        address caller,\r\n        address storeContractAddress);\r\n\r\n    // Event fired when burning a token\r\n    event DigitalMediaReleaseBurnEvent(\r\n        uint256 tokenId, \r\n        address owner);\r\n\r\n    event UpdateDigitalMediaPrintIndexEvent(\r\n        uint256 digitalMediaId,\r\n        uint32 printEdition);\r\n\r\n    // Event fired when a creator assigns a new creator address.\r\n    event ChangedCreator(\r\n        address creator,\r\n        address newCreator);\r\n\r\n    struct DigitalMediaRelease {\r\n        // The unique edition number of this digital media release\r\n        uint32 printEdition;\r\n\r\n        // Reference ID to the digital media metadata\r\n        uint256 digitalMediaId;\r\n    }\r\n\r\n    // Maps internal ERC721 token ID to digital media release object.\r\n    mapping (uint256 => DigitalMediaRelease) public tokenIdToDigitalMediaRelease;\r\n\r\n    // Maps a creator address to a new creator address.  Useful if a creator\r\n    // changes their address or the previous address gets compromised.\r\n    mapping (address => address) public approvedCreators;\r\n\r\n    // Token ID counter\r\n    uint256 internal tokenIdCounter = 0;\r\n\r\n    constructor (string _tokenName, string _tokenSymbol, uint256 _tokenIdStartingCounter) \r\n            public ERC721Token(_tokenName, _tokenSymbol) {\r\n        tokenIdCounter = _tokenIdStartingCounter;\r\n    }\r\n\r\n    /**\r\n     * Creates a new digital media object.\r\n     * @param  _creator address  the creator of this digital media\r\n     * @param  _totalSupply uint32 the total supply a creation could have\r\n     * @param  _collectionId uint256 the collectionId that it belongs to\r\n     * @param  _metadataPath string the path to the ipfs metadata\r\n     * @return uint the new digital media id\r\n     */\r\n    function _createDigitalMedia(\r\n          address _creator, uint32 _totalSupply, uint256 _collectionId, string _metadataPath) \r\n          internal \r\n          returns (uint) {\r\n\r\n        require(_validateCollection(_collectionId, _creator), \"Creator for collection not approved.\");\r\n\r\n        uint256 newDigitalMediaId = currentDigitalMediaStore.createDigitalMedia(\r\n            _creator,\r\n            0, \r\n            _totalSupply,\r\n            _collectionId,\r\n            _metadataPath);\r\n\r\n        emit DigitalMediaCreateEvent(\r\n            newDigitalMediaId,\r\n            address(currentDigitalMediaStore),\r\n            _creator,\r\n            _totalSupply,\r\n            0,\r\n            _collectionId,\r\n            _metadataPath);\r\n\r\n        return newDigitalMediaId;\r\n    }\r\n\r\n    /**\r\n     * Burns a token for a given tokenId and caller.\r\n     * @param  _tokenId the id of the token to burn.\r\n     * @param  _caller the address of the caller.\r\n     */\r\n    function _burnToken(uint256 _tokenId, address _caller) internal {\r\n        address owner = ownerOf(_tokenId);\r\n        require(_caller == owner || \r\n                getApproved(_tokenId) == _caller || \r\n                isApprovedForAll(owner, _caller),\r\n                \"Failed token burn.  Caller is not approved.\");\r\n        _burn(owner, _tokenId);\r\n        delete tokenIdToDigitalMediaRelease[_tokenId];\r\n        emit DigitalMediaReleaseBurnEvent(_tokenId, owner);\r\n    }\r\n\r\n    /**\r\n     * Burns a digital media.  Once this function succeeds, this digital media\r\n     * will no longer be able to mint any more tokens.  Existing tokens need to be \r\n     * burned individually though.\r\n     * @param  _digitalMediaId the id of the digital media to burn\r\n     * @param  _caller the address of the caller.\r\n     */\r\n    function _burnDigitalMedia(uint256 _digitalMediaId, address _caller) internal {\r\n        DigitalMedia memory _digitalMedia = _getDigitalMedia(_digitalMediaId);\r\n        require(_checkApprovedCreator(_digitalMedia.creator, _caller) || \r\n                isApprovedForAll(_digitalMedia.creator, _caller), \r\n                \"Failed digital media burn.  Caller not approved.\");\r\n\r\n        uint32 increment = _digitalMedia.totalSupply - _digitalMedia.printIndex;\r\n        _incrementDigitalMediaPrintIndex(_digitalMedia, increment);\r\n        address _burnDigitalMediaStoreAddress = address(_getDigitalMediaStore(_digitalMedia.id));\r\n        emit DigitalMediaBurnEvent(\r\n          _digitalMediaId, _caller, _burnDigitalMediaStoreAddress);\r\n    }\r\n\r\n    /**\r\n     * Creates a new collection\r\n     * @param  _creator address the creator of this collection\r\n     * @param  _metadataPath string the path to the collection ipfs metadata\r\n     * @return uint the new collection id\r\n     */\r\n    function _createCollection(\r\n          address _creator, string _metadataPath) \r\n          internal \r\n          returns (uint) {\r\n        uint256 newCollectionId = currentDigitalMediaStore.createCollection(\r\n            _creator,\r\n            _metadataPath);\r\n\r\n        emit DigitalMediaCollectionCreateEvent(\r\n            newCollectionId,\r\n            address(currentDigitalMediaStore),\r\n            _creator,\r\n            _metadataPath);\r\n\r\n        return newCollectionId;\r\n    }\r\n\r\n    /**\r\n     * Creates _count number of new digital media releases (i.e a token).  \r\n     * Bumps up the print index by _count.\r\n     * @param  _owner address the owner of the digital media object\r\n     * @param  _digitalMediaId uint256 the digital media id\r\n     */\r\n    function _createDigitalMediaReleases(\r\n        address _owner, uint256 _digitalMediaId, uint32 _count)\r\n        internal {\r\n\r\n        require(_count > 0, \"Failed print edition.  Creation count must be > 0.\");\r\n        require(_count < 10000, \"Cannot print more than 10K tokens at once\");\r\n        DigitalMedia memory _digitalMedia = _getDigitalMedia(_digitalMediaId);\r\n        uint32 currentPrintIndex = _digitalMedia.printIndex;\r\n        require(_checkApprovedCreator(_digitalMedia.creator, _owner), \"Creator not approved.\");\r\n        require(isAllowedSingleCreator(_owner), \"Creator must match single creator address.\");\r\n        require(_count + currentPrintIndex <= _digitalMedia.totalSupply, \"Total supply exceeded.\");\r\n        \r\n        string memory tokenURI = HelperUtils.strConcat(\"ipfs://ipfs/\", _digitalMedia.metadataPath);\r\n\r\n        for (uint32 i=0; i < _count; i++) {\r\n            uint32 newPrintEdition = currentPrintIndex + 1 + i;\r\n            DigitalMediaRelease memory _digitalMediaRelease = DigitalMediaRelease({\r\n                printEdition: newPrintEdition,\r\n                digitalMediaId: _digitalMediaId\r\n            });\r\n\r\n            uint256 newDigitalMediaReleaseId = _getNextTokenId();\r\n            tokenIdToDigitalMediaRelease[newDigitalMediaReleaseId] = _digitalMediaRelease;\r\n        \r\n            emit DigitalMediaReleaseCreateEvent(\r\n                newDigitalMediaReleaseId,\r\n                _owner,\r\n                newPrintEdition,\r\n                tokenURI,\r\n                _digitalMediaId\r\n            );\r\n\r\n            // This will assign ownership and also emit the Transfer event as per ERC721\r\n            _mint(_owner, newDigitalMediaReleaseId);\r\n            _setTokenURI(newDigitalMediaReleaseId, tokenURI);\r\n            tokenIdCounter = tokenIdCounter.add(1);\r\n\r\n        }\r\n        _incrementDigitalMediaPrintIndex(_digitalMedia, _count);\r\n        emit UpdateDigitalMediaPrintIndexEvent(_digitalMediaId, currentPrintIndex + _count);\r\n    }\r\n\r\n    /**\r\n     * Checks that a given caller is an approved creator and is allowed to mint or burn\r\n     * tokens.  If the creator was changed it will check against the updated creator.\r\n     * @param  _caller the calling address\r\n     * @return bool allowed or not\r\n     */\r\n    function _checkApprovedCreator(address _creator, address _caller) \r\n            internal \r\n            view \r\n            returns (bool) {\r\n        address approvedCreator = approvedCreators[_creator];\r\n        if (approvedCreator != address(0)) {\r\n            return approvedCreator == _caller;\r\n        } else {\r\n            return _creator == _caller;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Validates the an address is allowed to create a digital media on a\r\n     * given collection.  Collections are tied to addresses.\r\n     */\r\n    function _validateCollection(uint256 _collectionId, address _address) \r\n            private \r\n            view \r\n            returns (bool) {\r\n        if (_collectionId == 0 ) {\r\n            return true;\r\n        }\r\n\r\n        DigitalMediaCollection memory collection = _getCollection(_collectionId);\r\n        return _checkApprovedCreator(collection.creator, _address);\r\n    }\r\n\r\n    /**\r\n    * Generates a new token id.\r\n    */\r\n    function _getNextTokenId() private view returns (uint256) {\r\n        return tokenIdCounter.add(1); \r\n    }\r\n\r\n    /**\r\n     * Changes the creator that is approved to printing new tokens and creations.\r\n     * Either the _caller must be the _creator or the _caller must be the existing\r\n     * approvedCreator.\r\n     * @param _caller the address of the caller\r\n     * @param  _creator the address of the current creator\r\n     * @param  _newCreator the address of the new approved creator\r\n     */\r\n    function _changeCreator(address _caller, address _creator, address _newCreator) internal {\r\n        address approvedCreator = approvedCreators[_creator];\r\n        require(_caller != address(0) && _creator != address(0), \"Creator must be valid non 0x0 address.\");\r\n        require(_caller == _creator || _caller == approvedCreator, \"Unauthorized caller.\");\r\n        if (approvedCreator == address(0)) {\r\n            approvedCreators[_caller] = _newCreator;\r\n        } else {\r\n            require(_caller == approvedCreator, \"Unauthorized caller.\");\r\n            approvedCreators[_creator] = _newCreator;\r\n        }\r\n        emit ChangedCreator(_creator, _newCreator);\r\n    }\r\n\r\n    /**\r\n     * Introspection interface as per ERC-165 (https://github.com/ethereum/EIPs/issues/165).\r\n     */\r\n    function supportsInterface(bytes4 _interfaceID) external view returns (bool) {\r\n        return ((_interfaceID == InterfaceSignature_ERC165) || (_interfaceID == InterfaceSignature_ERC721));\r\n    }\r\n\r\n}\r\n\r\n// File: REMIX_FILE_SYNC/OBOControl.sol\r\n\r\npragma solidity 0.4.25;\r\n\r\n\r\n\r\ncontract OBOControl is Pausable {\r\n\t// List of approved on behalf of users.\r\n    mapping (address => bool) public approvedOBOs;\r\n\r\n\t/**\r\n     * Add a new approved on behalf of user address.\r\n     */\r\n    function addApprovedOBO(address _oboAddress) external onlyOwner {\r\n        approvedOBOs[_oboAddress] = true;\r\n    }\r\n\r\n    /**\r\n     * Removes an approved on bhealf of user address.\r\n     */\r\n    function removeApprovedOBO(address _oboAddress) external onlyOwner {\r\n        delete approvedOBOs[_oboAddress];\r\n    }\r\n\r\n    /**\r\n    * @dev Modifier to make the obo calls only callable by approved addressess\r\n    */\r\n    modifier isApprovedOBO() {\r\n        require(approvedOBOs[msg.sender] == true);\r\n        _;\r\n    }\r\n}\r\n\r\n// File: REMIX_FILE_SYNC/WithdrawFundsControl.sol\r\n\r\npragma solidity 0.4.25;\r\n\r\n\r\n\r\ncontract WithdrawFundsControl is Pausable {\r\n\r\n\t// List of approved on withdraw addresses\r\n    mapping (address => uint256) public approvedWithdrawAddresses;\r\n\r\n    // Full day wait period before an approved withdraw address becomes active\r\n    uint256 constant internal withdrawApprovalWaitPeriod = 60 * 60 * 24;\r\n\r\n    event WithdrawAddressAdded(address withdrawAddress);\r\n    event WithdrawAddressRemoved(address widthdrawAddress);\r\n\r\n\t/**\r\n     * Add a new approved on behalf of user address.\r\n     */\r\n    function addApprovedWithdrawAddress(address _withdrawAddress) external onlyOwner {\r\n        approvedWithdrawAddresses[_withdrawAddress] = now;\r\n        emit WithdrawAddressAdded(_withdrawAddress);\r\n    }\r\n\r\n    /**\r\n     * Removes an approved on bhealf of user address.\r\n     */\r\n    function removeApprovedWithdrawAddress(address _withdrawAddress) external onlyOwner {\r\n        delete approvedWithdrawAddresses[_withdrawAddress];\r\n        emit WithdrawAddressRemoved(_withdrawAddress);\r\n    }\r\n\r\n    /**\r\n     * Checks that a given withdraw address ia approved and is past it's required\r\n     * wait time.\r\n     */\r\n    function isApprovedWithdrawAddress(address _withdrawAddress) internal view returns (bool)  {\r\n        uint256 approvalTime = approvedWithdrawAddresses[_withdrawAddress];\r\n        require (approvalTime > 0);\r\n        return now - approvalTime > withdrawApprovalWaitPeriod;\r\n    }\r\n}\r\n\r\n// File: REMIX_FILE_SYNC/openzeppelin-solidity/contracts/token/ERC721/ERC721Holder.sol\r\n\r\npragma solidity ^0.4.21;\r\n\r\n\r\n\r\ncontract ERC721Holder is ERC721Receiver {\r\n  function onERC721Received(address, uint256, bytes) public returns(bytes4) {\r\n    return ERC721_RECEIVED;\r\n  }\r\n}\r\n\r\n// File: REMIX_FILE_SYNC/DigitalMediaSaleBase.sol\r\n\r\npragma solidity 0.4.25;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * Base class that manages the underlying functions of a Digital Media Sale,\r\n * most importantly the escrow of digital tokens.\r\n *\r\n * Manages ensuring that only approved addresses interact with this contract.\r\n *\r\n */\r\ncontract DigitalMediaSaleBase is ERC721Holder, Pausable, OBOControl, WithdrawFundsControl {\r\n    using SafeMath for uint256;\r\n\r\n     // Mapping of token contract address to bool indicated approval.\r\n    mapping (address => bool) public approvedTokenContracts;\r\n\r\n    /**\r\n     * Adds a new token contract address to be approved to be called.\r\n     */\r\n    function addApprovedTokenContract(address _tokenContractAddress) \r\n            public onlyOwner {\r\n        approvedTokenContracts[_tokenContractAddress] = true;\r\n    }\r\n\r\n    /**\r\n     * Remove an approved token contract address from the list of approved addresses.\r\n     */\r\n    function removeApprovedTokenContract(address _tokenContractAddress) \r\n            public onlyOwner {            \r\n        delete approvedTokenContracts[_tokenContractAddress];\r\n    }\r\n\r\n    /**\r\n     * Checks that a particular token contract address is a valid address.\r\n     */\r\n    function _isValidTokenContract(address _tokenContractAddress) \r\n            internal view returns (bool) {\r\n        return approvedTokenContracts[_tokenContractAddress];\r\n    }\r\n\r\n    /**\r\n     * Returns an ERC721 instance of a token contract address.  Throws otherwise.\r\n     * Only valid and approved token contracts are allowed to be interacted with.\r\n     */\r\n    function _getTokenContract(address _tokenContractAddress) internal view returns (ERC721Safe) {\r\n        require(_isValidTokenContract(_tokenContractAddress));\r\n        return ERC721Safe(_tokenContractAddress);\r\n    }\r\n\r\n    /**\r\n     * Checks with the ERC-721 token contract that the _claimant actually owns the token.\r\n     */\r\n    function _owns(address _claimant, uint256 _tokenId, address _tokenContractAddress) internal view returns (bool) {\r\n        ERC721Safe tokenContract = _getTokenContract(_tokenContractAddress);\r\n        return (tokenContract.ownerOf(_tokenId) == _claimant);\r\n    }\r\n\r\n    /**\r\n     * Checks with the ERC-721 token contract the owner of the a token\r\n     */\r\n    function _ownerOf(uint256 _tokenId, address _tokenContractAddress) internal view returns (address) {\r\n        ERC721Safe tokenContract = _getTokenContract(_tokenContractAddress);\r\n        return tokenContract.ownerOf(_tokenId);\r\n    }\r\n\r\n    /**\r\n     * Checks to ensure that the token owner has approved the escrow contract \r\n     */\r\n    function _approvedForEscrow(address _seller, uint256 _tokenId, address _tokenContractAddress) internal view returns (bool) {\r\n        ERC721Safe tokenContract = _getTokenContract(_tokenContractAddress);\r\n        return (tokenContract.isApprovedForAll(_seller, this) || \r\n                tokenContract.getApproved(_tokenId) == address(this));\r\n    }\r\n\r\n    /**\r\n     * Escrows an ERC-721 token from the seller to this contract.  Assumes that the escrow contract\r\n     * is already approved to make the transfer, otherwise it will fail.\r\n     */\r\n    function _escrow(address _seller, uint256 _tokenId, address _tokenContractAddress) internal {\r\n        // it will throw if transfer fails\r\n        ERC721Safe tokenContract = _getTokenContract(_tokenContractAddress);\r\n        tokenContract.safeTransferFrom(_seller, this, _tokenId);\r\n    }\r\n\r\n    /**\r\n     * Transfer an ERC-721 token from escrow to the buyer.  This is to be called after a purchase is\r\n     * completed.\r\n     */\r\n    function _transfer(address _receiver, uint256 _tokenId, address _tokenContractAddress) internal {\r\n        // it will throw if transfer fails\r\n        ERC721Safe tokenContract = _getTokenContract(_tokenContractAddress);\r\n        tokenContract.safeTransferFrom(this, _receiver, _tokenId);\r\n    }\r\n\r\n    /**\r\n     * Method to check whether this is an escrow contract\r\n     */\r\n    function isEscrowContract() public pure returns(bool) {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Withdraws all the funds to a specified non-zero address\r\n     */\r\n    function withdrawFunds(address _withdrawAddress) public onlyOwner {\r\n        require(isApprovedWithdrawAddress(_withdrawAddress));\r\n        _withdrawAddress.transfer(address(this).balance);\r\n    }\r\n}\r\n\r\n// File: REMIX_FILE_SYNC/DigitalMediaCore.sol\r\n\r\npragma solidity 0.4.25;\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * This is the main driver contract that is used to control and run the service. Funds \r\n * are managed through this function, underlying contracts are also updated through \r\n * this contract.\r\n *\r\n * This class also exposes a set of creation methods that are allowed to be created\r\n * by an approved token creator, on behalf of a particular address.  This is meant\r\n * to simply the creation flow for MakersToken users that aren't familiar with \r\n * the blockchain.  The ERC721 tokens that are created are still fully compliant, \r\n * although it is possible for a malicious token creator to mint unwanted tokens \r\n * on behalf of a creator.  Worst case, the creator can burn those tokens.\r\n */\r\ncontract DigitalMediaCore is DigitalMediaToken {\r\n    using SafeMath for uint32;\r\n\r\n    // List of approved token creators (on behalf of the owner)\r\n    mapping (address => bool) public approvedTokenCreators;\r\n\r\n    // Mapping from owner to operator accounts.\r\n    mapping (address => mapping (address => bool)) internal oboOperatorApprovals;\r\n\r\n    // Mapping of all disabled OBO operators.\r\n    mapping (address => bool) public disabledOboOperators;\r\n\r\n    // OboApproveAll Event\r\n    event OboApprovalForAll(\r\n        address _owner, \r\n        address _operator, \r\n        bool _approved);\r\n\r\n    // Fired when disbaling obo capability.\r\n    event OboDisabledForAll(address _operator);\r\n\r\n    constructor (\r\n        string _tokenName, \r\n        string _tokenSymbol, \r\n        uint256 _tokenIdStartingCounter, \r\n        address _dmsAddress,\r\n        address _crsAddress)\r\n            public DigitalMediaToken(\r\n                _tokenName, \r\n                _tokenSymbol,\r\n                _tokenIdStartingCounter) {\r\n        paused = true;\r\n        setDigitalMediaStoreAddress(_dmsAddress);\r\n        setCreatorRegistryStore(_crsAddress);\r\n    }\r\n\r\n    /**\r\n     * Retrieves a Digital Media object.\r\n     */\r\n    function getDigitalMedia(uint256 _id) \r\n            external \r\n            view \r\n            returns (\r\n            uint256 id,\r\n            uint32 totalSupply,\r\n            uint32 printIndex,\r\n            uint256 collectionId,\r\n            address creator,\r\n            string metadataPath) {\r\n\r\n        DigitalMedia memory digitalMedia = _getDigitalMedia(_id);\r\n        require(digitalMedia.creator != address(0), \"DigitalMedia not found.\");\r\n        id = _id;\r\n        totalSupply = digitalMedia.totalSupply;\r\n        printIndex = digitalMedia.printIndex;\r\n        collectionId = digitalMedia.collectionId;\r\n        creator = digitalMedia.creator;\r\n        metadataPath = digitalMedia.metadataPath;\r\n    }\r\n\r\n    /**\r\n     * Retrieves a collection.\r\n     */\r\n    function getCollection(uint256 _id) \r\n            external \r\n            view \r\n            returns (\r\n            uint256 id,\r\n            address creator,\r\n            string metadataPath) {\r\n        DigitalMediaCollection memory digitalMediaCollection = _getCollection(_id);\r\n        require(digitalMediaCollection.creator != address(0), \"Collection not found.\");\r\n        id = _id;\r\n        creator = digitalMediaCollection.creator;\r\n        metadataPath = digitalMediaCollection.metadataPath;\r\n    }\r\n\r\n    /**\r\n     * Retrieves a Digital Media Release (i.e a token)\r\n     */\r\n    function getDigitalMediaRelease(uint256 _id) \r\n            external \r\n            view \r\n            returns (\r\n            uint256 id,\r\n            uint32 printEdition,\r\n            uint256 digitalMediaId) {\r\n        require(exists(_id));\r\n        DigitalMediaRelease storage digitalMediaRelease = tokenIdToDigitalMediaRelease[_id];\r\n        id = _id;\r\n        printEdition = digitalMediaRelease.printEdition;\r\n        digitalMediaId = digitalMediaRelease.digitalMediaId;\r\n    }\r\n\r\n    /**\r\n     * Creates a new collection.\r\n     *\r\n     * No creations of any kind are allowed when the contract is paused.\r\n     */\r\n    function createCollection(string _metadataPath) \r\n            external \r\n            whenNotPaused {\r\n        _createCollection(msg.sender, _metadataPath);\r\n    }\r\n\r\n    /**\r\n     * Creates a new digital media object.\r\n     */\r\n    function createDigitalMedia(uint32 _totalSupply, uint256 _collectionId, string _metadataPath) \r\n            external \r\n            whenNotPaused {\r\n        _createDigitalMedia(msg.sender, _totalSupply, _collectionId, _metadataPath);\r\n    }\r\n\r\n    /**\r\n     * Creates a new digital media object and mints it's first digital media release token.\r\n     *\r\n     * No creations of any kind are allowed when the contract is paused.\r\n     */\r\n    function createDigitalMediaAndReleases(\r\n                uint32 _totalSupply,\r\n                uint256 _collectionId,\r\n                string _metadataPath,\r\n                uint32 _numReleases)\r\n            external \r\n            whenNotPaused {\r\n        uint256 digitalMediaId = _createDigitalMedia(msg.sender, _totalSupply, _collectionId, _metadataPath);\r\n        _createDigitalMediaReleases(msg.sender, digitalMediaId, _numReleases);\r\n    }\r\n\r\n    /**\r\n     * Creates a new collection, a new digital media object within it and mints a new\r\n     * digital media release token.\r\n     *\r\n     * No creations of any kind are allowed when the contract is paused.\r\n     */\r\n    function createDigitalMediaAndReleasesInNewCollection(\r\n                uint32 _totalSupply, \r\n                string _digitalMediaMetadataPath,\r\n                string _collectionMetadataPath,\r\n                uint32 _numReleases)\r\n            external \r\n            whenNotPaused {\r\n        uint256 collectionId = _createCollection(msg.sender, _collectionMetadataPath);\r\n        uint256 digitalMediaId = _createDigitalMedia(msg.sender, _totalSupply, collectionId, _digitalMediaMetadataPath);\r\n        _createDigitalMediaReleases(msg.sender, digitalMediaId, _numReleases);\r\n    }\r\n\r\n    /**\r\n     * Creates a new digital media release (token) for a given digital media id.\r\n     *\r\n     * No creations of any kind are allowed when the contract is paused.\r\n     */\r\n    function createDigitalMediaReleases(uint256 _digitalMediaId, uint32 _numReleases) \r\n            external \r\n            whenNotPaused {\r\n        _createDigitalMediaReleases(msg.sender, _digitalMediaId, _numReleases);\r\n    }\r\n\r\n    /**\r\n     * Deletes a token / digital media release. Doesn't modify the current print index\r\n     * and total to be printed. Although dangerous, the owner of a token should always \r\n     * be able to burn a token they own.\r\n     *\r\n     * Only the owner of the token or accounts approved by the owner can burn this token.\r\n     */\r\n    function burnToken(uint256 _tokenId) external {\r\n        _burnToken(_tokenId, msg.sender);\r\n    }\r\n\r\n    /* Support ERC721 burn method */\r\n    function burn(uint256 tokenId) public {\r\n        _burnToken(tokenId, msg.sender);\r\n    }\r\n\r\n    /**\r\n     * Ends the production run of a digital media.  Afterwards no more tokens\r\n     * will be allowed to be printed for this digital media.  Used when a creator\r\n     * makes a mistake and wishes to burn and recreate their digital media.\r\n     * \r\n     * When a contract is paused we do not allow new tokens to be created, \r\n     * so stopping the production of a token doesn't have much purpose.\r\n     */\r\n    function burnDigitalMedia(uint256 _digitalMediaId) external whenNotPaused {\r\n        _burnDigitalMedia(_digitalMediaId, msg.sender);\r\n    }\r\n\r\n    /**\r\n     * Resets the approval rights for a given tokenId.\r\n     */\r\n    function resetApproval(uint256 _tokenId) external {\r\n        clearApproval(msg.sender, _tokenId);\r\n    }\r\n\r\n    /**\r\n     * Changes the creator for the current sender, in the event we \r\n     * need to be able to mint new tokens from an existing digital media \r\n     * print production. When changing creator, the old creator will\r\n     * no longer be able to mint tokens.\r\n     *\r\n     * A creator may need to be changed:\r\n     * 1. If we want to allow a creator to take control over their token minting (i.e go decentralized)\r\n     * 2. If we want to re-issue private keys due to a compromise.  For this reason, we can call this function\r\n     * when the contract is paused.\r\n     * @param _creator the creator address\r\n     * @param _newCreator the new creator address\r\n     */\r\n    function changeCreator(address _creator, address _newCreator) external {\r\n        _changeCreator(msg.sender, _creator, _newCreator);\r\n    }\r\n\r\n    /**********************************************************************/\r\n    /**Calls that are allowed to be called by approved creator addresses **/ \r\n    /**********************************************************************/\r\n    \r\n    /**\r\n     * Add a new approved token creator.\r\n     *\r\n     * Only the owner of this contract can update approved Obo accounts.\r\n     */\r\n    function addApprovedTokenCreator(address _creatorAddress) external onlyOwner {\r\n        require(disabledOboOperators[_creatorAddress] != true, \"Address disabled.\");\r\n        approvedTokenCreators[_creatorAddress] = true;\r\n    }\r\n\r\n    /**\r\n     * Removes an approved token creator.\r\n     *\r\n     * Only the owner of this contract can update approved Obo accounts.\r\n     */\r\n    function removeApprovedTokenCreator(address _creatorAddress) external onlyOwner {\r\n        delete approvedTokenCreators[_creatorAddress];\r\n    }\r\n\r\n    /**\r\n    * @dev Modifier to make the approved creation calls only callable by approved token creators\r\n    */\r\n    modifier isApprovedCreator() {\r\n        require(\r\n            (approvedTokenCreators[msg.sender] == true && \r\n             disabledOboOperators[msg.sender] != true), \r\n            \"Unapproved OBO address.\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * Only the owner address can set a special obo approval list.\r\n     * When issuing OBO management accounts, we should give approvals through\r\n     * this method only so that we can very easily reset it's approval in\r\n     * the event of a disaster scenario.\r\n     *\r\n     * Only the owner themselves is allowed to give OboApproveAll access.\r\n     */\r\n    function setOboApprovalForAll(address _to, bool _approved) public {\r\n        require(_to != msg.sender, \"Approval address is same as approver.\");\r\n        require(approvedTokenCreators[_to], \"Unrecognized OBO address.\");\r\n        require(disabledOboOperators[_to] != true, \"Approval address is disabled.\");\r\n        oboOperatorApprovals[msg.sender][_to] = _approved;\r\n        emit OboApprovalForAll(msg.sender, _to, _approved);\r\n    }\r\n\r\n    /**\r\n     * Only called in a disaster scenario if the account has been compromised.  \r\n     * There's no turning back from this and the oboAddress will no longer be \r\n     * able to be given approval rights or perform obo functions.  \r\n     * \r\n     * Only the owner of this contract is allowed to disable an Obo address.\r\n     *\r\n     */\r\n    function disableOboAddress(address _oboAddress) public onlyOwner {\r\n        require(approvedTokenCreators[_oboAddress], \"Unrecognized OBO address.\");\r\n        disabledOboOperators[_oboAddress] = true;\r\n        delete approvedTokenCreators[_oboAddress];\r\n        emit OboDisabledForAll(_oboAddress);\r\n    }\r\n\r\n    /**\r\n     * Override the isApprovalForAll to check for a special oboApproval list.  Reason for this\r\n     * is that we can can easily remove obo operators if they every become compromised.\r\n     */\r\n    function isApprovedForAll(address _owner, address _operator) public view returns (bool) {\r\n        if (disabledOboOperators[_operator] == true) {\r\n            return false;\r\n        } else if (isOperatorApprovedForCustodialAccount(_operator, _owner) == true) {\r\n            return true;\r\n        } else if (oboOperatorApprovals[_owner][_operator]) {\r\n            return true;\r\n        } else {\r\n            return super.isApprovedForAll(_owner, _operator);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Creates a new digital media object and mints it's digital media release tokens.\r\n     * Called on behalf of the _owner. Pass count to mint `n` number of tokens.\r\n     *\r\n     * Only approved creators are allowed to create Obo.\r\n     *\r\n     * No creations of any kind are allowed when the contract is paused.\r\n     */\r\n    function oboCreateDigitalMediaAndReleases(\r\n                address _owner,\r\n                uint32 _totalSupply, \r\n                uint256 _collectionId, \r\n                string _metadataPath,\r\n                uint32 _numReleases)\r\n            external \r\n            whenNotPaused\r\n            isApprovedCreator {\r\n        uint256 digitalMediaId = _createDigitalMedia(_owner, _totalSupply, _collectionId, _metadataPath);\r\n        _createDigitalMediaReleases(_owner, digitalMediaId, _numReleases);\r\n    }\r\n\r\n    /**\r\n     * Creates a new collection, a new digital media object within it and mints a new\r\n     * digital media release token.\r\n     * Called on behalf of the _owner.\r\n     *\r\n     * Only approved creators are allowed to create Obo.\r\n     *\r\n     * No creations of any kind are allowed when the contract is paused.\r\n     */\r\n    function oboCreateDigitalMediaAndReleasesInNewCollection(\r\n                address _owner,\r\n                uint32 _totalSupply, \r\n                string _digitalMediaMetadataPath,\r\n                string _collectionMetadataPath,\r\n                uint32 _numReleases)\r\n            external \r\n            whenNotPaused\r\n            isApprovedCreator {\r\n        uint256 collectionId = _createCollection(_owner, _collectionMetadataPath);\r\n        uint256 digitalMediaId = _createDigitalMedia(_owner, _totalSupply, collectionId, _digitalMediaMetadataPath);\r\n        _createDigitalMediaReleases(_owner, digitalMediaId, _numReleases);\r\n    }\r\n\r\n    /**\r\n     * Creates multiple digital media releases (tokens) for a given digital media id.\r\n     * Called on behalf of the _owner.\r\n     *\r\n     * Only approved creators are allowed to create Obo.\r\n     *\r\n     * No creations of any kind are allowed when the contract is paused.\r\n     */\r\n    function oboCreateDigitalMediaReleases(\r\n                address _owner,\r\n                uint256 _digitalMediaId,\r\n                uint32 _numReleases) \r\n            external \r\n            whenNotPaused\r\n            isApprovedCreator {\r\n        _createDigitalMediaReleases(_owner, _digitalMediaId, _numReleases);\r\n    }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"currentStartingDigitalMediaId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_interfaceID\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_metadataPath\",\"type\":\"string\"}],\"name\":\"createCollection\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_totalSupply\",\"type\":\"uint32\"},{\"name\":\"_digitalMediaMetadataPath\",\"type\":\"string\"},{\"name\":\"_collectionMetadataPath\",\"type\":\"string\"},{\"name\":\"_numReleases\",\"type\":\"uint32\"}],\"name\":\"oboCreateDigitalMediaAndReleasesInNewCollection\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"singleCreatorAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentDigitalMediaStore\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_digitalMediaId\",\"type\":\"uint256\"}],\"name\":\"burnDigitalMedia\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"tokenOfOwnerByIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokenIdToDigitalMediaRelease\",\"outputs\":[{\"name\":\"printEdition\",\"type\":\"uint32\"},{\"name\":\"digitalMediaId\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_creatorAddress\",\"type\":\"address\"}],\"name\":\"removeApprovedTokenCreator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"exists\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"tokenByIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"approvedCreators\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"getDigitalMedia\",\"outputs\":[{\"name\":\"id\",\"type\":\"uint256\"},{\"name\":\"totalSupply\",\"type\":\"uint32\"},{\"name\":\"printIndex\",\"type\":\"uint32\"},{\"name\":\"collectionId\",\"type\":\"uint256\"},{\"name\":\"creator\",\"type\":\"address\"},{\"name\":\"metadataPath\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"getCollection\",\"outputs\":[{\"name\":\"id\",\"type\":\"uint256\"},{\"name\":\"creator\",\"type\":\"address\"},{\"name\":\"metadataPath\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_creator\",\"type\":\"address\"},{\"name\":\"_newCreator\",\"type\":\"address\"}],\"name\":\"changeCreator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_totalSupply\",\"type\":\"uint32\"},{\"name\":\"_collectionId\",\"type\":\"uint256\"},{\"name\":\"_metadataPath\",\"type\":\"string\"}],\"name\":\"createDigitalMedia\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_totalSupply\",\"type\":\"uint32\"},{\"name\":\"_collectionId\",\"type\":\"uint256\"},{\"name\":\"_metadataPath\",\"type\":\"string\"},{\"name\":\"_numReleases\",\"type\":\"uint32\"}],\"name\":\"oboCreateDigitalMediaAndReleases\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"setOboApprovalForAll\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"burnToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_digitalMediaId\",\"type\":\"uint256\"},{\"name\":\"_numReleases\",\"type\":\"uint32\"}],\"name\":\"createDigitalMediaReleases\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"getDigitalMediaRelease\",\"outputs\":[{\"name\":\"id\",\"type\":\"uint256\"},{\"name\":\"printEdition\",\"type\":\"uint32\"},{\"name\":\"digitalMediaId\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_totalSupply\",\"type\":\"uint32\"},{\"name\":\"_digitalMediaMetadataPath\",\"type\":\"string\"},{\"name\":\"_collectionMetadataPath\",\"type\":\"string\"},{\"name\":\"_numReleases\",\"type\":\"uint32\"}],\"name\":\"createDigitalMediaAndReleasesInNewCollection\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_dmsAddress\",\"type\":\"address\"}],\"name\":\"setV1DigitalMediaStoreAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_oboAddress\",\"type\":\"address\"}],\"name\":\"disableOboAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"v1DigitalMediaStore\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newCreatorAddress\",\"type\":\"address\"}],\"name\":\"changeSingleCreator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_digitalMediaId\",\"type\":\"uint256\"},{\"name\":\"_numReleases\",\"type\":\"uint32\"}],\"name\":\"oboCreateDigitalMediaReleases\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"creatorRegistryStore\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"resetApproval\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"approvedTokenCreators\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"disabledOboOperators\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_totalSupply\",\"type\":\"uint32\"},{\"name\":\"_collectionId\",\"type\":\"uint256\"},{\"name\":\"_metadataPath\",\"type\":\"string\"},{\"name\":\"_numReleases\",\"type\":\"uint32\"}],\"name\":\"createDigitalMediaAndReleases\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_creatorAddress\",\"type\":\"address\"}],\"name\":\"addApprovedTokenCreator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_tokenName\",\"type\":\"string\"},{\"name\":\"_tokenSymbol\",\"type\":\"string\"},{\"name\":\"_tokenIdStartingCounter\",\"type\":\"uint256\"},{\"name\":\"_dmsAddress\",\"type\":\"address\"},{\"name\":\"_crsAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_operator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"OboApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"OboDisabledForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"printEdition\",\"type\":\"uint32\"},{\"indexed\":false,\"name\":\"tokenURI\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"digitalMediaId\",\"type\":\"uint256\"}],\"name\":\"DigitalMediaReleaseCreateEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"storeContractAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"creator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"totalSupply\",\"type\":\"uint32\"},{\"indexed\":false,\"name\":\"printIndex\",\"type\":\"uint32\"},{\"indexed\":false,\"name\":\"collectionId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"metadataPath\",\"type\":\"string\"}],\"name\":\"DigitalMediaCreateEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"storeContractAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"creator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"metadataPath\",\"type\":\"string\"}],\"name\":\"DigitalMediaCollectionCreateEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"storeContractAddress\",\"type\":\"address\"}],\"name\":\"DigitalMediaBurnEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"DigitalMediaReleaseBurnEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"digitalMediaId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"printEdition\",\"type\":\"uint32\"}],\"name\":\"UpdateDigitalMediaPrintIndexEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"creator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newCreator\",\"type\":\"address\"}],\"name\":\"ChangedCreator\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousCreatorAddress\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newCreatorAddress\",\"type\":\"address\"}],\"name\":\"SingleCreatorChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_approved\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_operator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"DigitalMediaCore","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000e00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000e75479ba035175a251179919080bc7bd4e700f6e000000000000000000000000a6ec692942dc8c590693dc2a1cba5a7413de851f000000000000000000000000000000000000000000000000000000000000000d4d616b657273546f6b656e56320000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000044d4b543200000000000000000000000000000000000000000000000000000000","Library":"","SwarmSource":"bzzr://05b6a9bc6212f43a161375a16f4ef7010dc257764383f56d321350b5e4e03b4f"}]}