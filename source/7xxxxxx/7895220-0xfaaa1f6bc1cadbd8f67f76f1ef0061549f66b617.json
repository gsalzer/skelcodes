{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.25;\r\n\r\ncontract Math {\r\n\r\n    ////////////////////////\r\n    // Internal functions\r\n    ////////////////////////\r\n\r\n    // absolute difference: |v1 - v2|\r\n    function absDiff(uint256 v1, uint256 v2)\r\n        internal\r\n        pure\r\n        returns(uint256)\r\n    {\r\n        return v1 > v2 ? v1 - v2 : v2 - v1;\r\n    }\r\n\r\n    // divide v by d, round up if remainder is 0.5 or more\r\n    function divRound(uint256 v, uint256 d)\r\n        internal\r\n        pure\r\n        returns(uint256)\r\n    {\r\n        return add(v, d/2) / d;\r\n    }\r\n\r\n    // computes decimal decimalFraction 'frac' of 'amount' with maximum precision (multiplication first)\r\n    // both amount and decimalFraction must have 18 decimals precision, frac 10**18 represents a whole (100% of) amount\r\n    // mind loss of precision as decimal fractions do not have finite binary expansion\r\n    // do not use instead of division\r\n    function decimalFraction(uint256 amount, uint256 frac)\r\n        internal\r\n        pure\r\n        returns(uint256)\r\n    {\r\n        // it's like 1 ether is 100% proportion\r\n        return proportion(amount, frac, 10**18);\r\n    }\r\n\r\n    // computes part/total of amount with maximum precision (multiplication first)\r\n    // part and total must have the same units\r\n    function proportion(uint256 amount, uint256 part, uint256 total)\r\n        internal\r\n        pure\r\n        returns(uint256)\r\n    {\r\n        return divRound(mul(amount, part), total);\r\n    }\r\n\r\n    //\r\n    // Open Zeppelin Math library below\r\n    //\r\n\r\n    function mul(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        uint256 c = a * b;\r\n        assert(a == 0 || c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n\r\n    function min(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n    function max(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return a > b ? a : b;\r\n    }\r\n}\r\n\r\n/// @title uniquely identifies deployable (non-abstract) platform contract\r\n/// @notice cheap way of assigning implementations to knownInterfaces which represent system services\r\n///         unfortunatelly ERC165 does not include full public interface (ABI) and does not provide way to list implemented interfaces\r\n///         EIP820 still in the making\r\n/// @dev ids are generated as follows keccak256(\"neufund-platform:<contract name>\")\r\n///      ids roughly correspond to ABIs\r\ncontract IContractId {\r\n    /// @param id defined as above\r\n    /// @param version implementation version\r\n    function contractId() public pure returns (bytes32 id, uint256 version);\r\n}\r\n\r\n/// @title set terms of Platform (investor's network) of the ETO\r\ncontract PlatformTerms is Math, IContractId {\r\n\r\n    ////////////////////////\r\n    // Constants\r\n    ////////////////////////\r\n\r\n    // fraction of fee deduced on successful ETO (see Math.sol for fraction definition)\r\n    uint256 public constant PLATFORM_FEE_FRACTION = 3 * 10**16;\r\n    // fraction of tokens deduced on succesful ETO\r\n    uint256 public constant TOKEN_PARTICIPATION_FEE_FRACTION = 2 * 10**16;\r\n    // share of Neumark reward platform operator gets\r\n    // actually this is a divisor that splits Neumark reward in two parts\r\n    // the results of division belongs to platform operator, the remaining reward part belongs to investor\r\n    uint256 public constant PLATFORM_NEUMARK_SHARE = 2; // 50:50 division\r\n    // ICBM investors whitelisted by default\r\n    bool public constant IS_ICBM_INVESTOR_WHITELISTED = true;\r\n\r\n    // maximum ticket size Platform accepts in EUR ULPS\r\n    // no max ticket in general prospectus regulation\r\n    // uint256 public constant MAX_TICKET_EUR_ULPS = 10000000 * 10**18;\r\n\r\n    // token rate expires after\r\n    uint256 public constant TOKEN_RATE_EXPIRES_AFTER = 4 hours;\r\n\r\n    // time after which claimable tokens become recycleable in fee disbursal pool\r\n    uint256 public constant DEFAULT_DISBURSAL_RECYCLE_AFTER_DURATION = 4 * 365 days;\r\n\r\n    ////////////////////////\r\n    // Public Function\r\n    ////////////////////////\r\n\r\n    // calculates investor's and platform operator's neumarks from total reward\r\n    function calculateNeumarkDistribution(uint256 rewardNmk)\r\n        public\r\n        pure\r\n        returns (uint256 platformNmk, uint256 investorNmk)\r\n    {\r\n        // round down - platform may get 1 wei less than investor\r\n        platformNmk = rewardNmk / PLATFORM_NEUMARK_SHARE;\r\n        // rewardNmk > platformNmk always\r\n        return (platformNmk, rewardNmk - platformNmk);\r\n    }\r\n\r\n    function calculatePlatformTokenFee(uint256 tokenAmount)\r\n        public\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        // mind tokens having 0 precision\r\n        return proportion(tokenAmount, TOKEN_PARTICIPATION_FEE_FRACTION, 10**18);\r\n    }\r\n\r\n    function calculatePlatformFee(uint256 amount)\r\n        public\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return decimalFraction(amount, PLATFORM_FEE_FRACTION);\r\n    }\r\n\r\n    //\r\n    // Implements IContractId\r\n    //\r\n\r\n    function contractId() public pure returns (bytes32 id, uint256 version) {\r\n        return (0x95482babc4e32de6c4dc3910ee7ae62c8e427efde6bc4e9ce0d6d93e24c39323, 1);\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"calculatePlatformFee\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"IS_ICBM_INVESTOR_WHITELISTED\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"PLATFORM_NEUMARK_SHARE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TOKEN_PARTICIPATION_FEE_FRACTION\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"contractId\",\"outputs\":[{\"name\":\"id\",\"type\":\"bytes32\"},{\"name\":\"version\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"calculatePlatformTokenFee\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"PLATFORM_FEE_FRACTION\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"rewardNmk\",\"type\":\"uint256\"}],\"name\":\"calculateNeumarkDistribution\",\"outputs\":[{\"name\":\"platformNmk\",\"type\":\"uint256\"},{\"name\":\"investorNmk\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TOKEN_RATE_EXPIRES_AFTER\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"DEFAULT_DISBURSAL_RECYCLE_AFTER_DURATION\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"PlatformTerms","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://a1ed6c6fbec699704599b9e6d0035949fb141565e9c5ade54248e4a66230accd"}]}