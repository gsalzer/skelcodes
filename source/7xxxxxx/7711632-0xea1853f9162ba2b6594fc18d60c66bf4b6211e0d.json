{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\tfunction mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\t\tif (a == 0) {\r\n\t\t\treturn 0;\r\n\t\t}\r\n\t\tuint256 c = a * b;\r\n\t\tassert(c / a == b);\r\n\t\treturn c;\r\n\t}\r\n\r\n\tfunction div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\t\t// assert(b > 0); // Solidity automatically throws when dividing by 0\r\n\t\tuint256 c = a / b;\r\n\t\t// assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\t\treturn c;\r\n\t}\r\n\r\n\tfunction sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\t\tassert(b <= a);\r\n\t\treturn a - b;\r\n\t}\r\n\r\n\tfunction add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\t\tuint256 c = a + b;\r\n\t\tassert(c >= a);\r\n\t\treturn c;\r\n\t}\r\n}\r\n\r\n/**\r\n * @title SettingInterface\r\n */\r\ninterface SettingInterface {\r\n\tfunction uintSettings(bytes32 name) external constant returns (uint256);\r\n\tfunction boolSettings(bytes32 name) external constant returns (bool);\r\n\tfunction isActive() external constant returns (bool);\r\n\tfunction canBet(uint256 rewardValue, uint256 betValue, uint256 playerNumber, uint256 houseEdge) external constant returns (bool);\r\n\tfunction isExchangeAllowed(address playerAddress, uint256 tokenAmount) external constant returns (bool);\r\n\r\n\t/******************************************/\r\n\t/*          SPINWIN ONLY METHODS          */\r\n\t/******************************************/\r\n\tfunction spinwinSetUintSetting(bytes32 name, uint256 value) external;\r\n\tfunction spinwinIncrementUintSetting(bytes32 name) external;\r\n\tfunction spinwinSetBoolSetting(bytes32 name, bool value) external;\r\n\tfunction spinwinAddFunds(uint256 amount) external;\r\n\tfunction spinwinUpdateTokenToWeiExchangeRate() external;\r\n\tfunction spinwinRollDice(uint256 betValue) external;\r\n\tfunction spinwinUpdateWinMetric(uint256 playerProfit) external;\r\n\tfunction spinwinUpdateLoseMetric(uint256 betValue, uint256 tokenRewardValue) external;\r\n\tfunction spinwinUpdateLotteryContributionMetric(uint256 lotteryContribution) external;\r\n\tfunction spinwinUpdateExchangeMetric(uint256 exchangeAmount) external;\r\n\r\n\t/******************************************/\r\n\t/*      SPINLOTTERY ONLY METHODS          */\r\n\t/******************************************/\r\n\tfunction spinlotterySetUintSetting(bytes32 name, uint256 value) external;\r\n\tfunction spinlotteryIncrementUintSetting(bytes32 name) external;\r\n\tfunction spinlotterySetBoolSetting(bytes32 name, bool value) external;\r\n\tfunction spinlotteryUpdateTokenToWeiExchangeRate() external;\r\n\tfunction spinlotterySetMinBankroll(uint256 _minBankroll) external returns (bool);\r\n}\r\n\r\n/**\r\n * @title LotteryInterface\r\n */\r\ninterface LotteryInterface {\r\n\tfunction claimReward(address playerAddress, uint256 tokenAmount) external returns (bool);\r\n\tfunction calculateLotteryContributionPercentage() external constant returns (uint256);\r\n\tfunction getNumLottery() external constant returns (uint256);\r\n\tfunction isActive() external constant returns (bool);\r\n\tfunction getCurrentTicketMultiplierHonor() external constant returns (uint256);\r\n\tfunction getCurrentLotteryTargetBalance() external constant returns (uint256, uint256);\r\n}\r\n\r\n/**\r\n * @title SpinWinLibrary\r\n */\r\nlibrary SpinWinLibrary {\r\n\tusing SafeMath for uint256;\r\n\r\n\tuint256 constant public PERCENTAGE_DIVISOR = 10 ** 6;   // 1000000 = 100%\r\n\tuint256 constant public HOUSE_EDGE_DIVISOR = 1000;\r\n\tuint256 constant public CURRENCY_DIVISOR = 10**18;\r\n\tuint256 constant public TWO_DECIMALS = 100;\r\n\r\n\t/**\r\n\t * @dev Calculate winning ETH when player wins\r\n\t * @param betValue The amount of ETH for this bet\r\n\t * @param playerNumber The number that player chose\r\n\t * @param houseEdge The house edge for this bet\r\n\t * @return The amount of ETH to be sent to player if he/she wins\r\n\t */\r\n\tfunction calculateWinningReward(uint256 betValue, uint256 playerNumber, uint256 houseEdge) public pure returns (uint256) {\r\n\t\treturn ((betValue.mul(100-(playerNumber.sub(1)))).div(playerNumber.sub(1))).mul(houseEdge).div(HOUSE_EDGE_DIVISOR);\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Calculates token reward amount when player loses\r\n\t * @param settingAddress The GameSetting contract address\r\n\t * @param betValue The amount of ETH for this bet\r\n\t * @param playerNumber The number that player chose\r\n\t * @param houseEdge The house edge for this bet\r\n\t * @return The amount of token to be sent to player if he/she loses\r\n\t */\r\n\tfunction calculateTokenReward(address settingAddress, uint256 betValue, uint256 playerNumber, uint256 houseEdge) public constant returns (uint256) {\r\n\t\tuint256 weiLost = SettingInterface(settingAddress).uintSettings('totalWeiLostHonor').add(betValue.div(2));\r\n\t\tuint256 ratio = _getTokenRatio(weiLost);\r\n\r\n\t\t/*\r\n\t\t * Let base = betValue * ratio\r\n\t\t * We know that _ratio is in two decimals so we need to divide it by TWO_DECIMALS\r\n\t\t * base = (betValue * ratio)/TWO_DECIMALS\r\n\t\t */\r\n\t\tuint256 base = betValue.mul(ratio).div(TWO_DECIMALS);\r\n\r\n\t\t/*\r\n\t\t * edgeMod = base * (houseEdge% * (2 - houseEdge%) * spinEdgeModifier)\r\n\t\t */\r\n\t\tuint256 edgeMod = _calculateEdgeMod(settingAddress, base, houseEdge);\r\n\r\n\t\t/*\r\n\t\t * houseMod = base *  (((minBankrollHonor - replacedBank)/minBankrollHonor)*spinBankModifier) * edgeOn\r\n\t\t */\r\n\t\tuint256 houseMod = _calculateHouseMod(settingAddress, base, houseEdge);\r\n\r\n\t\t/*\r\n\t\t * numberMod =  base * ((1 + ((100 - playerNumber)/100))*spinNumberModifier) * edgeOn;\r\n\t\t */\r\n\t\tuint256 numberMod = _calculateNumberMod(settingAddress, base, playerNumber, houseEdge);\r\n\r\n\t\treturn edgeMod.add(houseMod).add(numberMod);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Generates random number between 1-divisor\r\n\t * @param settingAddress The GameSetting contract address\r\n\t * @param betBlockNumber The bet block number\r\n\t * @param extraData Data to be included in keccak256 for security purposes\r\n\t * @param divisor The upper bound of the random number\r\n\t * @return Return integer from 1-divisor\r\n\t */\r\n\tfunction generateRandomNumber(address settingAddress, uint256 betBlockNumber, uint256 extraData, uint256 divisor) public constant returns (uint256) {\r\n\t\tuint256 blockNumberDifference = block.number.sub(betBlockNumber);\r\n\t\tuint256 maxBlockSecurityCount = SettingInterface(settingAddress).uintSettings('maxBlockSecurityCount');\r\n\t\tuint256 blockSecurityCount = SettingInterface(settingAddress).uintSettings('blockSecurityCount');\r\n\t\tif (blockNumberDifference < SettingInterface(settingAddress).uintSettings('maxBlockSecurityCount').sub(blockSecurityCount)) {\r\n\t\t\tuint256 targetBlockNumber = betBlockNumber.add(blockSecurityCount);\r\n\t\t} else {\r\n\t\t\ttargetBlockNumber = betBlockNumber.add(maxBlockSecurityCount.mul(blockNumberDifference.div(maxBlockSecurityCount))).add(blockSecurityCount);\r\n\t\t}\r\n\t\tuint256 randomNumber = 0;\r\n\t\tfor (uint256 i = 1; i < blockSecurityCount; i++) {\r\n\t\t\trandomNumber = ((uint256(keccak256(abi.encodePacked(randomNumber, blockhash(targetBlockNumber.sub(i)), extraData)))%divisor).add(1));\r\n\t\t}\r\n\t\treturn randomNumber;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Calculate clear bet block reward\r\n\t * @param settingAddress The GameSetting contract address\r\n\t * @param lotteryAddress The lottery contract address\r\n\t * @return The num of blocks reward for clearing bet\r\n\t */\r\n\tfunction calculateClearBetBlocksReward(address settingAddress, address lotteryAddress) public constant returns (uint256) {\r\n\t\tuint256 weiLost = SettingInterface(settingAddress).uintSettings('totalWeiLostHonor');\r\n\r\n\t\t// Calculate 1 Wei to SPIN Rate\r\n\t\tuint256 weiToSpinRate = _getTokenRatio(weiLost); // in decimals\r\n\r\n\t\t/*\r\n\t\t * Calculate 1 SPIN to Wei Rate\r\n\t\t * Inverse of weiToSpinRate\r\n\t\t * so spinToWeiRate = 1 / weiToSpinRate\r\n\t\t * but weiToSpinRate is in decimals\r\n\t\t * spinToWeiRate = 1 / (weiToSpinRate / TWO_DECIMALS)\r\n\t\t * spinToWeiRate = TWO_DECIMALS / weiToSpinRate\r\n\t\t * Mult by CURRENCY_DIVISOR/CURRENCY_DIVISOR to account for the decimals\r\n\t\t * spinToWeiRate = (CURRENCY_DIVISOR/CURRENCY_DIVISOR) * (TWO_DECIMALS / weiToSpinRate)\r\n\t\t * Take out the division by CURRENCY_DIVISOR for now and include it in the later calculation\r\n\t\t * spinToWeiRate = (CURRENCY_DIVISOR * TWO_DECIMALS) / weiToSpinRate\r\n\t\t */\r\n\t\tuint256 spinToWeiRate = SettingInterface(settingAddress).uintSettings('spinToWeiRate');\r\n\t\tif (weiToSpinRate > 0) {\r\n\t\t\tspinToWeiRate = (CURRENCY_DIVISOR.mul(TWO_DECIMALS)).div(weiToSpinRate); // in decimals\r\n\t\t}\r\n\r\n\t\t// Calculate 1 Spin to Block Rate\r\n\t\tuint256 spinToBlockRate = LotteryInterface(lotteryAddress).getCurrentTicketMultiplierHonor(); // in decimals\r\n\r\n\t\t/*\r\n\t\t * Calculate 1 Block to Spin Rate\r\n\t\t * Inverse of spinToBlockRate\r\n\t\t * so blockToSpinRate = 1 / spinToBlockRate\r\n\t\t * but spinToBlockRate is in decimals\r\n\t\t * blockToSpinRate = 1 / (spinToBlockRate / TWO_DECIMALS)\r\n\t\t * blockToSpinRate = TWO_DECIMALS / spinToBlockRate\r\n\t\t * Mult by CURRENCY_DIVISOR/CURRENCY_DIVISOR to account for two decimals\r\n\t\t * blockToSpinRate = (CURRENCY_DIVISOR/CURRENCY_DIVISOR) * (TWO_DECIMALS / spinToBlockRate)\r\n\t\t * Take out the division by CURRENCY_DIVISOR for now and include it in the later calculation\r\n\t\t * blockToSpinRate = (CURRENCY_DIVISOR * TWO_DECIMALS) / spinToBlockRate\r\n\t\t */\r\n\t\tuint256 blockToSpinRate = SettingInterface(settingAddress).uintSettings('blockToSpinRate');\r\n\t\tif (spinToBlockRate > 0) {\r\n\t\t\tblockToSpinRate = (CURRENCY_DIVISOR.mul(TWO_DECIMALS)).div(spinToBlockRate); // in decimals\r\n\t\t}\r\n\r\n\t\t/*\r\n\t\t * Calculate block to wei Rate\r\n\t\t * blockToWeiRate = blockToSpinRate * spinToWeiRate\r\n\t\t * since blockToSpinRate and spinToWeiRate are in decimals (from prev calculation)\r\n\t\t * need to include the division by CURRENCY_DIVISOR\r\n\t\t * blockToWeiRate = (blockToSpinRate/CURRENCY_DIVISOR)  * (spinToWeiRate/CURRENCY_DIVISOR)\r\n\t\t * But since we need to account for decimals\r\n\t\t * Mult the math about with CURRENCY_DIVISOR/CURRENCY_DIVISOR\r\n\t\t * blockToWeiRate = (CURRENCY_DIVISOR/CURRENCY_DIVISOR) * (blockToSpinRate/CURRENCY_DIVISOR)  * (spinToWeiRate/CURRENCY_DIVISOR)\r\n\t\t * Take out one division by CURRENCY_DIVISOR for now and include it in the later calculation\r\n\t\t * blockToWeiRate = (blockToSpinRate * spinToWeiRate) / CURRENCY_DIVISOR\r\n\t\t */\r\n\t\tuint256 blockToWeiRate = (blockToSpinRate.mul(spinToWeiRate)).div(CURRENCY_DIVISOR); // in decimals\r\n\r\n\t\t// Calculate wei cost to clear a bet\r\n\t\tuint256 weiCost = SettingInterface(settingAddress).uintSettings('gasForClearingBet').mul(SettingInterface(settingAddress).uintSettings('gasPrice'));\r\n\r\n\t\t/*\r\n\t\t * numBlocks = weiCost / blockToWeiRate\r\n\t\t * But since blockToWeiRate is in decimals, need to divide by CURRENCY_DIVISOR\r\n\t\t * numBlocks = weiCost / (blockToWeiRate / CURRENCY_DIVISOR)\r\n\t\t * numBlocks = (weiCost * CURRENCY_DIVISOR)/blockToWeiRate\r\n\t\t */\r\n\t\tif (blockToWeiRate == 0) {\r\n\t\t\tblockToWeiRate = SettingInterface(settingAddress).uintSettings('blockToWeiRate');\r\n\t\t}\r\n\t\treturn (weiCost.mul(CURRENCY_DIVISOR)).div(blockToWeiRate);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Calculate how much we should contribute to the lottery\r\n\t * @param settingAddress The GameSetting contract address\r\n\t * @param lotteryAddress The lottery contract address\r\n\t * @param betValue The bet value\r\n\t * @return The lottery contribution amount\r\n\t */\r\n\tfunction calculateLotteryContribution(address settingAddress, address lotteryAddress, uint256 betValue) public constant returns (uint256) {\r\n\t\tuint256 lotteryContribution = (betValue.mul(LotteryInterface(lotteryAddress).calculateLotteryContributionPercentage())).div(TWO_DECIMALS);\r\n\r\n\t\t// Check if this contribution will make lottery balance > current lottery target X multiple\r\n\t\tuint256 currentLotteryTarget;\r\n\t\tuint256 currentLotteryBankroll;\r\n\t\t(currentLotteryTarget, currentLotteryBankroll) = LotteryInterface(lotteryAddress).getCurrentLotteryTargetBalance();\r\n\t\tuint256 lotteryTargetMultiplier = SettingInterface(settingAddress).uintSettings('lotteryTargetMultiplier');\r\n\t\tif (currentLotteryBankroll.add(lotteryContribution) > currentLotteryTarget.mul(lotteryTargetMultiplier).div(TWO_DECIMALS)) {\r\n\t\t\tlotteryContribution = (currentLotteryTarget.mul(lotteryTargetMultiplier).div(TWO_DECIMALS)).sub(currentLotteryBankroll);\r\n\t\t}\r\n\t\treturn lotteryContribution;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Calculate the exchange values\r\n\t * @param settingAddress The GameSetting contract address\r\n\t * @param tokenAmount The amount of token to be exchanged\r\n\t * @return The converted wei value\r\n\t * @return The amount of wei to be received\r\n\t * @return The amount of token to be refunded (if contractBalance < weiValue)\r\n\t * @return The amount of token to be burned\r\n\t */\r\n\tfunction calculateExchangeTokenValue(address settingAddress, uint256 tokenAmount) public constant returns (uint256, uint256, uint256, uint256) {\r\n\t\tuint256 tokenToWeiExchangeRateHonor = SettingInterface(settingAddress).uintSettings('tokenToWeiExchangeRateHonor');\r\n\t\t// From GameSetting.sol, we know that tokenToWeiExchangeRate is ETH in 36 decimals or WEI in 18 decimals\r\n\t\t// So we need to divide tokenToWeiExchangeRateHonor by CURRENCY_DIVISOR\r\n\t\tuint256 weiValue = (tokenToWeiExchangeRateHonor.mul(tokenAmount)).div(CURRENCY_DIVISOR).div(CURRENCY_DIVISOR);\r\n\t\tuint256 contractExchangeBalance = SettingInterface(settingAddress).uintSettings('contractBalance').sub(SettingInterface(settingAddress).uintSettings('tokenExchangeMinBankroll')); // This is the maximum exchange ETH value that we can send to the player\r\n\t\tif (contractExchangeBalance >= weiValue) {\r\n\t\t\tuint256 sendWei = weiValue;\r\n\t\t\tuint256 tokenRemainder = 0;\r\n\t\t\tuint256 burnToken = tokenAmount;\r\n\t\t} else {\r\n\t\t\tsendWei = contractExchangeBalance;\r\n\t\t\ttokenRemainder = (weiValue.sub(contractExchangeBalance)).mul(CURRENCY_DIVISOR).mul(CURRENCY_DIVISOR).div(tokenToWeiExchangeRateHonor);\r\n\t\t\tburnToken = tokenAmount.sub(tokenRemainder);\r\n\t\t}\r\n\t\treturn (weiValue, sendWei, tokenRemainder, burnToken);\r\n\t}\r\n\r\n\r\n\t/******************************************/\r\n\t/*           PRIVATE METHODS              */\r\n\t/******************************************/\r\n\r\n\t/**\r\n\t * @dev Gets token ratio based on weiLost\r\n\t * @param weiLost The wei lost value\r\n\t * @return Return token ratio (ratio is in two decimals, needs to be divided with TWO_DECIMALS in calculation)\r\n\t */\r\n\tfunction _getTokenRatio(uint256 weiLost) private pure returns (uint256) {\r\n\t\tuint256 ethLost = weiLost.div(CURRENCY_DIVISOR);\r\n\t\t/**\r\n\t\t * We value players who are early in the game, that's why we reward them with more SPIN\r\n\t\t */\r\n\t\tif (ethLost >= 0 && ethLost <= 10) {\r\n\t\t\t// Case 1: 0 ETH >= ethLost < 10 ETH\r\n\t\t\tuint256 start = 1;                                  // start: 0 ETH\r\n\t\t\tuint256 end = 10;                                   // end: 10 ETH\r\n\t\t\tuint256 startRatio = 199000 * TWO_DECIMALS;         // start ratio: 199,000\r\n\t\t\tuint256 endRatio = 1000 * TWO_DECIMALS;             // end ratio: 1,000\r\n\t\t} else if (ethLost > 10 && ethLost <= 1000) {\r\n\t\t\t// Case 2: 10 ETH >= ethLost < 1000 ETH\r\n\t\t\tstart = 10;                                         // start: 10 ETH\r\n\t\t\tend = 1000;                                         // end: 1,000 ETH\r\n\t\t\tstartRatio = 1000 * TWO_DECIMALS;                   // start ratio: 1,000\r\n\t\t\tendRatio = 100 * TWO_DECIMALS;                      // end ratio: 100\r\n\t\t} else if (ethLost > 1000 && ethLost <= 10000) {\r\n\t\t\t// Case 3: 1,000 ETH >= ethLost < 10,000 ETH\r\n\t\t\tstart = 1000;                                       // start: 1,000 ETH\r\n\t\t\tend = 10000;                                        // end: 10,000 ETH\r\n\t\t\tstartRatio = 100 * TWO_DECIMALS;                    // start ratio: 100\r\n\t\t\tendRatio = 20 * TWO_DECIMALS;                       // end ratio: 20\r\n\t\t} else if (ethLost > 10000 && ethLost <= 100000) {\r\n\t\t\t// Case 4: 10,000 ETH >= ethLost < 100,000 ETH\r\n\t\t\tstart = 10000;                                      // start: 10,000 ETH\r\n\t\t\tend = 100000;                                       // end: 100,000 ETH\r\n\t\t\tstartRatio = 20 * TWO_DECIMALS;                     // start ratio: 20\r\n\t\t\tendRatio = 10 * TWO_DECIMALS;                       // end ratio: 10\r\n\t\t} else if (ethLost > 100000 && ethLost <= 1000000) {\r\n\t\t\t// Case 5: 100,000 ETH >= ethLost < 1,000,000 ETH\r\n\t\t\tstart = 100000;                                     // start: 100,000 ETH\r\n\t\t\tend = 1000000;                                      // end: 1,000,000 ETH\r\n\t\t\tstartRatio = 10 * TWO_DECIMALS;                     // start ratio: 10\r\n\t\t\tendRatio = 2 * TWO_DECIMALS;                        // end ratio: 2\r\n\t\t} else if (ethLost > 1000000 && ethLost <= 10000000) {\r\n\t\t\t// Case 6: 1,000,000 ETH >= ethLost < 10,000,000 ETH\r\n\t\t\tstart = 1000000;                                    // start: 1,000,000 ETH\r\n\t\t\tend = 10000000;                                     // end: 10,000,000 ETH\r\n\t\t\tstartRatio = 2 * TWO_DECIMALS;                      // start ratio: 2\r\n\t\t\tendRatio = 40;                                      // end ratio: 0.4\r\n\t\t} else if (ethLost > 10000000 && ethLost <= 100000000) {\r\n\t\t\t// Case 7: 10,000,000 ETH >= ethLost < 100,000,000 ETH\r\n\t\t\tstart = 10000000;                                   // start: 10,000,000 ETH\r\n\t\t\tend = 100000000;                                    // end: 100,000,000 ETH\r\n\t\t\tstartRatio = 40;                                    // start ratio: 0.4\r\n\t\t\tendRatio = 20;                                      // end ratio: 0.2\r\n\t\t} else if (ethLost > 100000000 && ethLost <= 1000000000) {\r\n\t\t\t// Case 8: 100,000,000 ETH >= ethLost < 1,000,000,000 ETH\r\n\t\t\tstart = 100000000;                                  // start: 100,000,000 ETH\r\n\t\t\tend = 1000000000;                                   // end: 1,000,000,000 ETH\r\n\t\t\tstartRatio = 20;                                    // start ratio: 0.2\r\n\t\t\tendRatio = 10;                                      // end ratio: 0.1\r\n\t\t} else {\r\n\t\t\t// Case 9: ethLost >= 1,000,000,000 ETH\r\n\t\t\tuint256 ratio = 10; // ratio: 0.1\r\n\t\t}\r\n\r\n\t\t// Calculate the ratio if necessary\r\n\t\t// Also, prevent division by 0\r\n\t\tif (ratio == 0 && (end - start) > 0) {\r\n\t\t\t/*\r\n\t\t\t * To prevent negative value for calculating ethLost-start\r\n\t\t\t * if ethLost = 0, set ethLost = start\r\n\t\t\t */\r\n\t\t\tif (ethLost == 0) {\r\n\t\t\t\tethLost = start;\r\n\t\t\t}\r\n\t\t\t/*\r\n\t\t\t * ratio = ((startRatio - endRatio) * (1-((ethLost - start)/(end-start)))) + endRatio;\r\n\t\t\t * Let temp = (1-((ethLost - start)/(end-start)))\r\n\t\t\t * So, ratio = ((startRatio - endRatio) * temp) + endRatio;\r\n\t\t\t *\r\n\t\t\t * Mult by TWO_DECIMALS/TWO_DECIMALS to account for two decimals\r\n\t\t\t * temp = (TWO_DECIMALS * ((1-((ethLost - start)/(end-start)))))/TWO_DECIMALS\r\n\t\t\t * temp = (TWO_DECIMALS - ((TWO_DECIMALS*(ethLost-start))/(end-start)))/TWO_DECIMALS\r\n\t\t\t * Take out the TWO_DECIMALS for now and include it in the later calculation\r\n\t\t\t * temp = TWO_DECIMALS - ((TWO_DECIMALS*(ethLost-start))/(end-start))\r\n\t\t\t */\r\n\t\t\tuint256 temp = TWO_DECIMALS.sub(TWO_DECIMALS.mul(ethLost.sub(start)).div(end.sub(start)));\r\n\t\t\tratio = ((startRatio.sub(endRatio)).mul(temp).div(TWO_DECIMALS)).add(endRatio);\r\n\t\t}\r\n\t\treturn ratio;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Helper function to help calculates edge modifier for token reward\r\n\t */\r\n\tfunction _calculateEdgeMod(address settingAddress, uint256 base, uint256 houseEdge) private constant returns (uint256) {\r\n\t\t/*\r\n\t\t * edgeMod = base * (houseEdge% * (2 - houseEdge%) * spinEdgeModifier)\r\n\t\t * we know houseEdge is the inverse of houseEdge%\r\n\t\t * so 0 houseEdge is 100%, and 1000 houseEdge is 0%\r\n\t\t * Therefore, houseEdge% = (HOUSE_EDGE_DIVISOR - houseEdge)/HOUSE_EDGE_DIVISOR\r\n\t\t *\r\n\t\t * edgeMod = base * ( ((HOUSE_EDGE_DIVISOR - houseEdge)/HOUSE_EDGE_DIVISOR) * ( 2 - ((HOUSE_EDGE_DIVISOR - houseEdge)/HOUSE_EDGE_DIVISOR)) * spinEdgeModifier)\r\n\t\t * edgeMod = base * ( ((HOUSE_EDGE_DIVISOR - houseEdge)/HOUSE_EDGE_DIVISOR) * ( 2*(HOUSE_EDGE_DIVISOR/HOUSE_EDGE_DIVISOR) - ((HOUSE_EDGE_DIVISOR - houseEdge)/HOUSE_EDGE_DIVISOR)) * spinEdgeModifier)\r\n\t\t * edgeMod = base * ( ((HOUSE_EDGE_DIVISOR - houseEdge)/HOUSE_EDGE_DIVISOR) * ( (2*HOUSE_EDGE_DIVISOR - HOUSE_EDGE_DIVISOR + houseEdge)/HOUSE_EDGE_DIVISOR) * spinEdgeModifier)\r\n\t\t * edgeMod = base * ( ((HOUSE_EDGE_DIVISOR - houseEdge)/HOUSE_EDGE_DIVISOR) * ( (HOUSE_EDGE_DIVISOR + houseEdge)/HOUSE_EDGE_DIVISOR) * spinEdgeModifier)\r\n\t\t * spinEdgeModifier is also in two decimals, so we need to divide it by TWO_DECIMALS\r\n\t\t * edgeMod = base * ( ((HOUSE_EDGE_DIVISOR - houseEdge)/HOUSE_EDGE_DIVISOR) * ( (HOUSE_EDGE_DIVISOR + houseEdge)/HOUSE_EDGE_DIVISOR) * (spinEdgeModifier/TWO_DECIMALS))\r\n\t\t * We multiply first than divide\r\n\t\t * edgeMod = (((base * (HOUSE_EDGE_DIVISOR - houseEdge) * (HOUSE_EDGE_DIVISOR + houseEdge) * spinEdgeModifier)/HOUSE_EDGE_DIVISOR)/HOUSE_EDGE_DIVISOR)/TWO_DECIMALS\r\n\t\t */\r\n\t\treturn (base.mul(HOUSE_EDGE_DIVISOR.sub(houseEdge)).mul(HOUSE_EDGE_DIVISOR.add(houseEdge)).mul(SettingInterface(settingAddress).uintSettings('spinEdgeModifier'))).div(HOUSE_EDGE_DIVISOR).div(HOUSE_EDGE_DIVISOR).div(TWO_DECIMALS);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Helper function to help calculates house modifier for token reward\r\n\t */\r\n\tfunction _calculateHouseMod(address settingAddress, uint256 base, uint256 houseEdge) private constant returns (uint256) {\r\n\t\tuint256 replacedBank = (SettingInterface(settingAddress).uintSettings('contractBalanceHonor') >= SettingInterface(settingAddress).uintSettings('minBankrollHonor')) ? SettingInterface(settingAddress).uintSettings('minBankrollHonor') : SettingInterface(settingAddress).uintSettings('contractBalanceHonor');\r\n\r\n\t\t/*\r\n\t\t * we know houseEdge is the inverse of houseEdge%\r\n\t\t * so 0 houseEdge is 100%, and 1000 houseEdge is 0%\r\n\t\t */\r\n\t\tuint256 edgeOn = (houseEdge == 1000) ? 0 : 1;\r\n\r\n\t\t/*\r\n\t\t * this will cap the multiple at the spinEdgeModifier value. NOTE: the 2 - houseEdge% addition. This curves the edge.\r\n\t\t * houseMod = base *  (((minBankrollHonor - replacedBank)/minBankrollHonor)*spinBankModifier) * edgeOn\r\n\t\t * spinBankModifier is also in two decimals, so we need to divide it by TWO_DECIMALS\r\n\t\t * houseMod = base *  ( ((minBankrollHonor - replacedBank) / minBankrollHonor) * (spinBankModifier/TWO_DECIMALS) ) * edgeOn\r\n\t\t * We multiply first than divide\r\n\t\t * houseMod = ((base * (minBankrollHonor - replacedBank) * spinBankModifier * edgeOn)/minBankrollHonor)/TWO_DECIMALS\r\n\t\t */\r\n\t\tuint256 dividend = (base.mul(SettingInterface(settingAddress).uintSettings('minBankrollHonor').sub(replacedBank)).mul(SettingInterface(settingAddress).uintSettings('spinBankModifier')).mul(edgeOn));\r\n\t\treturn dividend.div(SettingInterface(settingAddress).uintSettings('minBankrollHonor')).div(TWO_DECIMALS);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Helper function to help calculates number modifier for token reward\r\n\t */\r\n\tfunction _calculateNumberMod(address settingAddress, uint256 base, uint256 playerNumber, uint256 houseEdge) private constant returns (uint256) {\r\n\t\t/*\r\n\t\t * we know houseEdge is the inverse of houseEdge%\r\n\t\t * so 0 houseEdge is 100%, and 1000 houseEdge is 0%\r\n\t\t */\r\n\t\tuint256 edgeOn = (houseEdge == 1000) ? 0 : 1;\r\n\r\n\t\t/*\r\n\t\t * numberMod = base * ((1 + (100 - playerNumber)/100)*spinNumberModifier) * edgeOn\r\n\t\t * Let temp2 = (1 + (100 - playerNumber)/100)\r\n\t\t * Mult by TWO_DECIMALS/TWO_DECIMALS to account for two decimals\r\n\t\t * temp2 = (TWO_DECIMALS * ((1+((100 - playerNumber)/100))))/TWO_DECIMALS\r\n\t\t * temp2 = (TWO_DECIMALS + ((TWO_DECIMALS*(100-playerNumber))/100))/TWO_DECIMALS\r\n\t\t * Take out the TWO_DECIMALS for now and include it in the later calculation\r\n\t\t * temp2 = TWO_DECIMALS + ((TWO_DECIMALS*(100-playerNumber))/100)\r\n\t\t *\r\n\t\t * numberMod = base * (temp2/TWO_DECIMALS)*spinNumberModifier * edgeOn\r\n\t\t * spinNumberModifier is also in two decimals, so we need to divide it by TWO_DECIMALS\r\n\t\t * numberMod = base * (((temp2/TWO_DECIMALS)*spinNumberModifier)/TWO_DECIMALS) * edgeOn\r\n\t\t * We multiply first then divide\r\n\t\t * numberMod = ((base * temp2 * spinNumberModifier*edgeOn)/TWO_DECIMALS)/TWO_DECIMALS\r\n\t\t */\r\n\t\tuint256 temp2 = TWO_DECIMALS.add(TWO_DECIMALS.mul(100 - playerNumber).div(100));\r\n\t\treturn (base.mul(temp2).mul(SettingInterface(settingAddress).uintSettings('spinNumberModifier')).mul(edgeOn)).div(TWO_DECIMALS).div(TWO_DECIMALS);\r\n\t}\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"settingAddress\",\"type\":\"address\"},{\"name\":\"betBlockNumber\",\"type\":\"uint256\"},{\"name\":\"extraData\",\"type\":\"uint256\"},{\"name\":\"divisor\",\"type\":\"uint256\"}],\"name\":\"generateRandomNumber\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"settingAddress\",\"type\":\"address\"},{\"name\":\"betValue\",\"type\":\"uint256\"},{\"name\":\"playerNumber\",\"type\":\"uint256\"},{\"name\":\"houseEdge\",\"type\":\"uint256\"}],\"name\":\"calculateTokenReward\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"betValue\",\"type\":\"uint256\"},{\"name\":\"playerNumber\",\"type\":\"uint256\"},{\"name\":\"houseEdge\",\"type\":\"uint256\"}],\"name\":\"calculateWinningReward\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"settingAddress\",\"type\":\"address\"},{\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"calculateExchangeTokenValue\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TWO_DECIMALS\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"PERCENTAGE_DIVISOR\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CURRENCY_DIVISOR\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"settingAddress\",\"type\":\"address\"},{\"name\":\"lotteryAddress\",\"type\":\"address\"}],\"name\":\"calculateClearBetBlocksReward\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"HOUSE_EDGE_DIVISOR\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"settingAddress\",\"type\":\"address\"},{\"name\":\"lotteryAddress\",\"type\":\"address\"},{\"name\":\"betValue\",\"type\":\"uint256\"}],\"name\":\"calculateLotteryContribution\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"SpinWinLibrary","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://182720582c538e43268dd58402edcfa1531199c8498fd436cb8667e63d0c1482"}]}