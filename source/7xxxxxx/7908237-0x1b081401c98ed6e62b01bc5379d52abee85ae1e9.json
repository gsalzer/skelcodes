{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.19;\n\n// Interface contract to be implemented by SyscoinToken\ncontract SyscoinTransactionProcessor {\n    function processTransaction(uint txHash, uint value, address destinationAddress, uint32 _assetGUID, address superblockSubmitterAddress) public returns (uint);\n    function burn(uint _value, uint32 _assetGUID, bytes syscoinWitnessProgram) payable public returns (bool success);\n}\n\n// Bitcoin transaction parsing library - modified for SYSCOIN\n\n// Copyright 2016 rain <https://keybase.io/rain>\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n// https://en.bitcoin.it/wiki/Protocol_documentation#tx\n//\n// Raw Bitcoin transaction structure:\n//\n// field     | size | type     | description\n// version   | 4    | int32    | transaction version number\n// n_tx_in   | 1-9  | var_int  | number of transaction inputs\n// tx_in     | 41+  | tx_in[]  | list of transaction inputs\n// n_tx_out  | 1-9  | var_int  | number of transaction outputs\n// tx_out    | 9+   | tx_out[] | list of transaction outputs\n// lock_time | 4    | uint32   | block number / timestamp at which tx locked\n//\n// Transaction input (tx_in) structure:\n//\n// field      | size | type     | description\n// previous   | 36   | outpoint | Previous output transaction reference\n// script_len | 1-9  | var_int  | Length of the signature script\n// sig_script | ?    | uchar[]  | Script for confirming transaction authorization\n// sequence   | 4    | uint32   | Sender transaction version\n//\n// OutPoint structure:\n//\n// field      | size | type     | description\n// hash       | 32   | char[32] | The hash of the referenced transaction\n// index      | 4    | uint32   | The index of this output in the referenced transaction\n//\n// Transaction output (tx_out) structure:\n//\n// field         | size | type     | description\n// value         | 8    | int64    | Transaction value (Satoshis)\n// pk_script_len | 1-9  | var_int  | Length of the public key script\n// pk_script     | ?    | uchar[]  | Public key as a Bitcoin script.\n//\n// Variable integers (var_int) can be encoded differently depending\n// on the represented value, to save space. Variable integers always\n// precede an array of a variable length data type (e.g. tx_in).\n//\n// Variable integer encodings as a function of represented value:\n//\n// value           | bytes  | format\n// <0xFD (253)     | 1      | uint8\n// <=0xFFFF (65535)| 3      | 0xFD followed by length as uint16\n// <=0xFFFF FFFF   | 5      | 0xFE followed by length as uint32\n// -               | 9      | 0xFF followed by length as uint64\n//\n// Public key scripts `pk_script` are set on the output and can\n// take a number of forms. The regular transaction script is\n// called 'pay-to-pubkey-hash' (P2PKH):\n//\n// OP_DUP OP_HASH160 <pubKeyHash> OP_EQUALVERIFY OP_CHECKSIG\n//\n// OP_x are Bitcoin script opcodes. The bytes representation (including\n// the 0x14 20-byte stack push) is:\n//\n// 0x76 0xA9 0x14 <pubKeyHash> 0x88 0xAC\n//\n// The <pubKeyHash> is the ripemd160 hash of the sha256 hash of\n// the public key, preceded by a network version byte. (21 bytes total)\n//\n// Network version bytes: 0x00 (mainnet); 0x6f (testnet); 0x34 (namecoin)\n//\n// The Bitcoin address is derived from the pubKeyHash. The binary form is the\n// pubKeyHash, plus a checksum at the end.  The checksum is the first 4 bytes\n// of the (32 byte) double sha256 of the pubKeyHash. (25 bytes total)\n// This is converted to base58 to form the publicly used Bitcoin address.\n// Mainnet P2PKH transaction scripts are to addresses beginning with '1'.\n//\n// P2SH ('pay to script hash') scripts only supply a script hash. The spender\n// must then provide the script that would allow them to redeem this output.\n// This allows for arbitrarily complex scripts to be funded using only a\n// hash of the script, and moves the onus on providing the script from\n// the spender to the redeemer.\n//\n// The P2SH script format is simple:\n//\n// OP_HASH160 <scriptHash> OP_EQUAL\n//\n// 0xA9 0x14 <scriptHash> 0x87\n//\n// The <scriptHash> is the ripemd160 hash of the sha256 hash of the\n// redeem script. The P2SH address is derived from the scriptHash.\n// Addresses are the scriptHash with a version prefix of 5, encoded as\n// Base58check. These addresses begin with a '3'.\n\n\n\n// parse a raw Syscoin transaction byte array\nlibrary SyscoinMessageLibrary {\n\n    uint constant p = 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f;  // secp256k1\n    uint constant q = (p + 1) / 4;\n\n    // Error codes\n    uint constant ERR_INVALID_HEADER = 10050;\n    uint constant ERR_COINBASE_INDEX = 10060; // coinbase tx index within Litecoin merkle isn't 0\n    uint constant ERR_NOT_MERGE_MINED = 10070; // trying to check AuxPoW on a block that wasn't merge mined\n    uint constant ERR_FOUND_TWICE = 10080; // 0xfabe6d6d found twice\n    uint constant ERR_NO_MERGE_HEADER = 10090; // 0xfabe6d6d not found\n    uint constant ERR_NOT_IN_FIRST_20 = 10100; // chain Merkle root isn't in the first 20 bytes of coinbase tx\n    uint constant ERR_CHAIN_MERKLE = 10110;\n    uint constant ERR_PARENT_MERKLE = 10120;\n    uint constant ERR_PROOF_OF_WORK = 10130;\n    uint constant ERR_INVALID_HEADER_HASH = 10140;\n    uint constant ERR_PROOF_OF_WORK_AUXPOW = 10150;\n    uint constant ERR_PARSE_TX_OUTPUT_LENGTH = 10160;\n    uint constant ERR_PARSE_TX_SYS = 10170;\n    enum Network { MAINNET, TESTNET, REGTEST }\n    uint32 constant SYSCOIN_TX_VERSION_ASSET_ALLOCATION_BURN = 0x7407;\n    uint32 constant SYSCOIN_TX_VERSION_BURN = 0x7401;\n    // AuxPoW block fields\n    struct AuxPoW {\n        uint blockHash;\n\n        uint txHash;\n\n        uint coinbaseMerkleRoot; // Merkle root of auxiliary block hash tree; stored in coinbase tx field\n        uint[] chainMerkleProof; // proves that a given Syscoin block hash belongs to a tree with the above root\n        uint syscoinHashIndex; // index of Syscoin block hash within block hash tree\n        uint coinbaseMerkleRootCode; // encodes whether or not the root was found properly\n\n        uint parentMerkleRoot; // Merkle root of transaction tree from parent Litecoin block header\n        uint[] parentMerkleProof; // proves that coinbase tx belongs to a tree with the above root\n        uint coinbaseTxIndex; // index of coinbase tx within Litecoin tx tree\n\n        uint parentNonce;\n    }\n\n    // Syscoin block header stored as a struct, mostly for readability purposes.\n    // BlockHeader structs can be obtained by parsing a block header's first 80 bytes\n    // with parseHeaderBytes.\n    struct BlockHeader {\n        uint32 bits;\n        uint blockHash;\n    }\n    // Convert a variable integer into something useful and return it and\n    // the index to after it.\n    function parseVarInt(bytes memory txBytes, uint pos) private pure returns (uint, uint) {\n        // the first byte tells us how big the integer is\n        uint8 ibit = uint8(txBytes[pos]);\n        pos += 1;  // skip ibit\n\n        if (ibit < 0xfd) {\n            return (ibit, pos);\n        } else if (ibit == 0xfd) {\n            return (getBytesLE(txBytes, pos, 16), pos + 2);\n        } else if (ibit == 0xfe) {\n            return (getBytesLE(txBytes, pos, 32), pos + 4);\n        } else if (ibit == 0xff) {\n            return (getBytesLE(txBytes, pos, 64), pos + 8);\n        }\n    }\n    // convert little endian bytes to uint\n    function getBytesLE(bytes memory data, uint pos, uint bits) internal pure returns (uint) {\n        if (bits == 8) {\n            return uint8(data[pos]);\n        } else if (bits == 16) {\n            return uint16(data[pos])\n                 + uint16(data[pos + 1]) * 2 ** 8;\n        } else if (bits == 32) {\n            return uint32(data[pos])\n                 + uint32(data[pos + 1]) * 2 ** 8\n                 + uint32(data[pos + 2]) * 2 ** 16\n                 + uint32(data[pos + 3]) * 2 ** 24;\n        } else if (bits == 64) {\n            return uint64(data[pos])\n                 + uint64(data[pos + 1]) * 2 ** 8\n                 + uint64(data[pos + 2]) * 2 ** 16\n                 + uint64(data[pos + 3]) * 2 ** 24\n                 + uint64(data[pos + 4]) * 2 ** 32\n                 + uint64(data[pos + 5]) * 2 ** 40\n                 + uint64(data[pos + 6]) * 2 ** 48\n                 + uint64(data[pos + 7]) * 2 ** 56;\n        }\n    }\n    \n\n    // @dev - Parses a syscoin tx\n    //\n    // @param txBytes - tx byte array\n    // Outputs\n    // @return output_value - amount sent to the lock address in satoshis\n    // @return destinationAddress - ethereum destination address\n\n\n    function parseTransaction(bytes memory txBytes) internal pure\n             returns (uint, uint, address, uint32)\n    {\n        \n        uint output_value;\n        uint32 assetGUID;\n        address destinationAddress;\n        uint32 version;\n        uint pos = 0;\n        version = bytesToUint32Flipped(txBytes, pos);\n        if(version != SYSCOIN_TX_VERSION_ASSET_ALLOCATION_BURN && version != SYSCOIN_TX_VERSION_BURN){\n            return (ERR_PARSE_TX_SYS, output_value, destinationAddress, assetGUID);\n        }\n        pos = skipInputs(txBytes, 4);\n            \n        (output_value, destinationAddress, assetGUID) = scanBurns(txBytes, version, pos);\n        return (0, output_value, destinationAddress, assetGUID);\n    }\n\n\n  \n    // skips witnesses and saves first script position/script length to extract pubkey of first witness scriptSig\n    function skipWitnesses(bytes memory txBytes, uint pos, uint n_inputs) private pure\n             returns (uint)\n    {\n        uint n_stack;\n        (n_stack, pos) = parseVarInt(txBytes, pos);\n        \n        uint script_len;\n        for (uint i = 0; i < n_inputs; i++) {\n            for (uint j = 0; j < n_stack; j++) {\n                (script_len, pos) = parseVarInt(txBytes, pos);\n                pos += script_len;\n            }\n        }\n\n        return n_stack;\n    }    \n\n    function skipInputs(bytes memory txBytes, uint pos) private pure\n             returns (uint)\n    {\n        uint n_inputs;\n        uint script_len;\n        (n_inputs, pos) = parseVarInt(txBytes, pos);\n        // if dummy 0x00 is present this is a witness transaction\n        if(n_inputs == 0x00){\n            (n_inputs, pos) = parseVarInt(txBytes, pos); // flag\n            assert(n_inputs != 0x00);\n            // after dummy/flag the real var int comes for txins\n            (n_inputs, pos) = parseVarInt(txBytes, pos);\n        }\n        require(n_inputs < 100);\n\n        for (uint i = 0; i < n_inputs; i++) {\n            pos += 36;  // skip outpoint\n            (script_len, pos) = parseVarInt(txBytes, pos);\n            pos += script_len + 4;  // skip sig_script, seq\n        }\n\n        return pos;\n    }\n             \n    // scan the burn outputs and return the value and script data of first burned output.\n    function scanBurns(bytes memory txBytes, uint32 version, uint pos) private pure\n             returns (uint, address, uint32)\n    {\n        uint script_len;\n        uint output_value;\n        uint32 assetGUID = 0;\n        address destinationAddress;\n        uint n_outputs;\n        (n_outputs, pos) = parseVarInt(txBytes, pos);\n        require(n_outputs < 10);\n        for (uint i = 0; i < n_outputs; i++) {\n            // output\n            if(version == SYSCOIN_TX_VERSION_BURN){\n                output_value = getBytesLE(txBytes, pos, 64);\n            }\n            pos += 8;\n            // varint\n            (script_len, pos) = parseVarInt(txBytes, pos);\n            if(!isOpReturn(txBytes, pos)){\n                // output script\n                pos += script_len;\n                output_value = 0;\n                continue;\n            }\n            // skip opreturn marker\n            pos += 1;\n            if(version == SYSCOIN_TX_VERSION_ASSET_ALLOCATION_BURN){\n                (output_value, destinationAddress, assetGUID) = scanAssetDetails(txBytes, pos);\n            }\n            else if(version == SYSCOIN_TX_VERSION_BURN){                \n                destinationAddress = scanSyscoinDetails(txBytes, pos);   \n            }\n            // only one opreturn data allowed per transaction\n            break;\n        }\n\n        return (output_value, destinationAddress, assetGUID);\n    }\n\n    function skipOutputs(bytes memory txBytes, uint pos) private pure\n             returns (uint)\n    {\n        uint n_outputs;\n        uint script_len;\n\n        (n_outputs, pos) = parseVarInt(txBytes, pos);\n\n        require(n_outputs < 10);\n\n        for (uint i = 0; i < n_outputs; i++) {\n            pos += 8;\n            (script_len, pos) = parseVarInt(txBytes, pos);\n            pos += script_len;\n        }\n\n        return pos;\n    }\n    // get final position of inputs, outputs and lock time\n    // this is a helper function to slice a byte array and hash the inputs, outputs and lock time\n    function getSlicePos(bytes memory txBytes, uint pos) private pure\n             returns (uint slicePos)\n    {\n        slicePos = skipInputs(txBytes, pos + 4);\n        slicePos = skipOutputs(txBytes, slicePos);\n        slicePos += 4; // skip lock time\n    }\n    // scan a Merkle branch.\n    // return array of values and the end position of the sibling hashes.\n    // takes a 'stop' argument which sets the maximum number of\n    // siblings to scan through. stop=0 => scan all.\n    function scanMerkleBranch(bytes memory txBytes, uint pos, uint stop) private pure\n             returns (uint[], uint)\n    {\n        uint n_siblings;\n        uint halt;\n\n        (n_siblings, pos) = parseVarInt(txBytes, pos);\n\n        if (stop == 0 || stop > n_siblings) {\n            halt = n_siblings;\n        } else {\n            halt = stop;\n        }\n\n        uint[] memory sibling_values = new uint[](halt);\n\n        for (uint i = 0; i < halt; i++) {\n            sibling_values[i] = flip32Bytes(sliceBytes32Int(txBytes, pos));\n            pos += 32;\n        }\n\n        return (sibling_values, pos);\n    }   \n    // Slice 20 contiguous bytes from bytes `data`, starting at `start`\n    function sliceBytes20(bytes memory data, uint start) private pure returns (bytes20) {\n        uint160 slice = 0;\n        // FIXME: With solc v0.4.24 and optimizations enabled\n        // using uint160 for index i will generate an error\n        // \"Error: VM Exception while processing transaction: Error: redPow(normalNum)\"\n        for (uint i = 0; i < 20; i++) {\n            slice += uint160(data[i + start]) << (8 * (19 - i));\n        }\n        return bytes20(slice);\n    }\n    // Slice 32 contiguous bytes from bytes `data`, starting at `start`\n    function sliceBytes32Int(bytes memory data, uint start) private pure returns (uint slice) {\n        for (uint i = 0; i < 32; i++) {\n            if (i + start < data.length) {\n                slice += uint(data[i + start]) << (8 * (31 - i));\n            }\n        }\n    }\n\n    // @dev returns a portion of a given byte array specified by its starting and ending points\n    // Should be private, made internal for testing\n    // Breaks underscore naming convention for parameters because it raises a compiler error\n    // if `offset` is changed to `_offset`.\n    //\n    // @param _rawBytes - array to be sliced\n    // @param offset - first byte of sliced array\n    // @param _endIndex - last byte of sliced array\n    function sliceArray(bytes memory _rawBytes, uint offset, uint _endIndex) internal view returns (bytes) {\n        uint len = _endIndex - offset;\n        bytes memory result = new bytes(len);\n        assembly {\n            // Call precompiled contract to copy data\n            if iszero(staticcall(gas, 0x04, add(add(_rawBytes, 0x20), offset), len, add(result, 0x20), len)) {\n                revert(0, 0)\n            }\n        }\n        return result;\n    }\n    \n    \n    // Returns true if the tx output is an OP_RETURN output\n    function isOpReturn(bytes memory txBytes, uint pos) private pure\n             returns (bool) {\n        // scriptPub format is\n        // 0x6a OP_RETURN\n        return \n            txBytes[pos] == byte(0x6a);\n    }\n    // Returns syscoin data parsed from the op_return data output from syscoin burn transaction\n    function scanSyscoinDetails(bytes memory txBytes, uint pos) private pure\n             returns (address) {      \n        uint8 op;\n        (op, pos) = getOpcode(txBytes, pos);\n        // ethereum addresses are 20 bytes (without the 0x)\n        require(op == 0x14);\n        return readEthereumAddress(txBytes, pos);\n    }    \n    // Returns asset data parsed from the op_return data output from syscoin asset burn transaction\n    function scanAssetDetails(bytes memory txBytes, uint pos) private pure\n             returns (uint, address, uint32) {\n                 \n        uint32 assetGUID;\n        address destinationAddress;\n        uint output_value;\n        uint8 op;\n        // vchAsset\n        (op, pos) = getOpcode(txBytes, pos);\n        // guid length should be 4 bytes\n        require(op == 0x04);\n        assetGUID = bytesToUint32(txBytes, pos);\n        pos += op;\n        // amount\n        (op, pos) = getOpcode(txBytes, pos);\n        require(op == 0x08);\n        output_value = bytesToUint64(txBytes, pos);\n        pos += op;\n         // destination address\n        (op, pos) = getOpcode(txBytes, pos);\n        // ethereum contracts are 20 bytes (without the 0x)\n        require(op == 0x14);\n        destinationAddress = readEthereumAddress(txBytes, pos);       \n        return (output_value, destinationAddress, assetGUID);\n    }         \n    // Read the ethereum address embedded in the tx output\n    function readEthereumAddress(bytes memory txBytes, uint pos) private pure\n             returns (address) {\n        uint256 data;\n        assembly {\n            data := mload(add(add(txBytes, 20), pos))\n        }\n        return address(uint160(data));\n    }\n\n    // Read next opcode from script\n    function getOpcode(bytes memory txBytes, uint pos) private pure\n             returns (uint8, uint)\n    {\n        require(pos < txBytes.length);\n        return (uint8(txBytes[pos]), pos + 1);\n    }\n\n    // @dev - convert an unsigned integer from little-endian to big-endian representation\n    //\n    // @param _input - little-endian value\n    // @return - input value in big-endian format\n    function flip32Bytes(uint _input) internal pure returns (uint result) {\n        assembly {\n            let pos := mload(0x40)\n            for { let i := 0 } lt(i, 32) { i := add(i, 1) } {\n                mstore8(add(pos, i), byte(sub(31, i), _input))\n            }\n            result := mload(pos)\n        }\n    }\n    // helpers for flip32Bytes\n    struct UintWrapper {\n        uint value;\n    }\n\n    function ptr(UintWrapper memory uw) private pure returns (uint addr) {\n        assembly {\n            addr := uw\n        }\n    }\n\n    function parseAuxPoW(bytes memory rawBytes, uint pos) internal view\n             returns (AuxPoW memory auxpow)\n    {\n        // we need to traverse the bytes with a pointer because some fields are of variable length\n        pos += 80; // skip non-AuxPoW header\n        uint slicePos;\n        (slicePos) = getSlicePos(rawBytes, pos);\n        auxpow.txHash = dblShaFlipMem(rawBytes, pos, slicePos - pos);\n        pos = slicePos;\n        // parent block hash, skip and manually hash below\n        pos += 32;\n        (auxpow.parentMerkleProof, pos) = scanMerkleBranch(rawBytes, pos, 0);\n        auxpow.coinbaseTxIndex = getBytesLE(rawBytes, pos, 32);\n        pos += 4;\n        (auxpow.chainMerkleProof, pos) = scanMerkleBranch(rawBytes, pos, 0);\n        auxpow.syscoinHashIndex = getBytesLE(rawBytes, pos, 32);\n        pos += 4;\n        // calculate block hash instead of reading it above, as some are LE and some are BE, we cannot know endianness and have to calculate from parent block header\n        auxpow.blockHash = dblShaFlipMem(rawBytes, pos, 80);\n        pos += 36; // skip parent version and prev block\n        auxpow.parentMerkleRoot = sliceBytes32Int(rawBytes, pos);\n        pos += 40; // skip root that was just read, parent block timestamp and bits\n        auxpow.parentNonce = getBytesLE(rawBytes, pos, 32);\n        uint coinbaseMerkleRootPosition;\n        (auxpow.coinbaseMerkleRoot, coinbaseMerkleRootPosition, auxpow.coinbaseMerkleRootCode) = findCoinbaseMerkleRoot(rawBytes);\n    }\n\n    // @dev - looks for {0xfa, 0xbe, 'm', 'm'} byte sequence\n    // returns the following 32 bytes if it appears once and only once,\n    // 0 otherwise\n    // also returns the position where the bytes first appear\n    function findCoinbaseMerkleRoot(bytes memory rawBytes) private pure\n             returns (uint, uint, uint)\n    {\n        uint position;\n        bool found = false;\n\n        for (uint i = 0; i < rawBytes.length; ++i) {\n            if (rawBytes[i] == 0xfa && rawBytes[i+1] == 0xbe && rawBytes[i+2] == 0x6d && rawBytes[i+3] == 0x6d) {\n                if (found) { // found twice\n                    return (0, position - 4, ERR_FOUND_TWICE);\n                } else {\n                    found = true;\n                    position = i + 4;\n                }\n            }\n        }\n\n        if (!found) { // no merge mining header\n            return (0, position - 4, ERR_NO_MERGE_HEADER);\n        } else {\n            return (sliceBytes32Int(rawBytes, position), position - 4, 1);\n        }\n    }\n\n    // @dev - Evaluate the merkle root\n    //\n    // Given an array of hashes it calculates the\n    // root of the merkle tree.\n    //\n    // @return root of merkle tree\n    function makeMerkle(bytes32[] hashes2) external pure returns (bytes32) {\n        bytes32[] memory hashes = hashes2;\n        uint length = hashes.length;\n        if (length == 1) return hashes[0];\n        require(length > 0);\n        uint i;\n        uint j;\n        uint k;\n        k = 0;\n        while (length > 1) {\n            k = 0;\n            for (i = 0; i < length; i += 2) {\n                j = i+1<length ? i+1 : length-1;\n                hashes[k] = bytes32(concatHash(uint(hashes[i]), uint(hashes[j])));\n                k += 1;\n            }\n            length = k;\n        }\n        return hashes[0];\n    }\n\n    // @dev - For a valid proof, returns the root of the Merkle tree.\n    //\n    // @param _txHash - transaction hash\n    // @param _txIndex - transaction's index within the block it's assumed to be in\n    // @param _siblings - transaction's Merkle siblings\n    // @return - Merkle tree root of the block the transaction belongs to if the proof is valid,\n    // garbage if it's invalid\n    function computeMerkle(uint _txHash, uint _txIndex, uint[] memory _siblings) internal pure returns (uint) {\n        uint resultHash = _txHash;\n        uint i = 0;\n        while (i < _siblings.length) {\n            uint proofHex = _siblings[i];\n\n            uint sideOfSiblings = _txIndex % 2;  // 0 means _siblings is on the right; 1 means left\n\n            uint left;\n            uint right;\n            if (sideOfSiblings == 1) {\n                left = proofHex;\n                right = resultHash;\n            } else if (sideOfSiblings == 0) {\n                left = resultHash;\n                right = proofHex;\n            }\n\n            resultHash = concatHash(left, right);\n\n            _txIndex /= 2;\n            i += 1;\n        }\n\n        return resultHash;\n    }\n\n    // @dev - calculates the Merkle root of a tree containing Litecoin transactions\n    // in order to prove that `ap`'s coinbase tx is in that Litecoin block.\n    //\n    // @param _ap - AuxPoW information\n    // @return - Merkle root of Litecoin block that the Syscoin block\n    // with this info was mined in if AuxPoW Merkle proof is correct,\n    // garbage otherwise\n    function computeParentMerkle(AuxPoW memory _ap) internal pure returns (uint) {\n        return flip32Bytes(computeMerkle(_ap.txHash,\n                                         _ap.coinbaseTxIndex,\n                                         _ap.parentMerkleProof));\n    }\n\n    // @dev - calculates the Merkle root of a tree containing auxiliary block hashes\n    // in order to prove that the Syscoin block identified by _blockHash\n    // was merge-mined in a Litecoin block.\n    //\n    // @param _blockHash - SHA-256 hash of a certain Syscoin block\n    // @param _ap - AuxPoW information corresponding to said block\n    // @return - Merkle root of auxiliary chain tree\n    // if AuxPoW Merkle proof is correct, garbage otherwise\n    function computeChainMerkle(uint _blockHash, AuxPoW memory _ap) internal pure returns (uint) {\n        return computeMerkle(_blockHash,\n                             _ap.syscoinHashIndex,\n                             _ap.chainMerkleProof);\n    }\n\n    // @dev - Helper function for Merkle root calculation.\n    // Given two sibling nodes in a Merkle tree, calculate their parent.\n    // Concatenates hashes `_tx1` and `_tx2`, then hashes the result.\n    //\n    // @param _tx1 - Merkle node (either root or internal node)\n    // @param _tx2 - Merkle node (either root or internal node), has to be `_tx1`'s sibling\n    // @return - `_tx1` and `_tx2`'s parent, i.e. the result of concatenating them,\n    // hashing that twice and flipping the bytes.\n    function concatHash(uint _tx1, uint _tx2) internal pure returns (uint) {\n        return flip32Bytes(uint(sha256(abi.encodePacked(sha256(abi.encodePacked(flip32Bytes(_tx1), flip32Bytes(_tx2)))))));\n    }\n\n    // @dev - checks if a merge-mined block's Merkle proofs are correct,\n    // i.e. Syscoin block hash is in coinbase Merkle tree\n    // and coinbase transaction is in parent Merkle tree.\n    //\n    // @param _blockHash - SHA-256 hash of the block whose Merkle proofs are being checked\n    // @param _ap - AuxPoW struct corresponding to the block\n    // @return 1 if block was merge-mined and coinbase index, chain Merkle root and Merkle proofs are correct,\n    // respective error code otherwise\n    function checkAuxPoW(uint _blockHash, AuxPoW memory _ap) internal pure returns (uint) {\n        if (_ap.coinbaseTxIndex != 0) {\n            return ERR_COINBASE_INDEX;\n        }\n\n        if (_ap.coinbaseMerkleRootCode != 1) {\n            return _ap.coinbaseMerkleRootCode;\n        }\n\n        if (computeChainMerkle(_blockHash, _ap) != _ap.coinbaseMerkleRoot) {\n            return ERR_CHAIN_MERKLE;\n        }\n\n        if (computeParentMerkle(_ap) != _ap.parentMerkleRoot) {\n            return ERR_PARENT_MERKLE;\n        }\n\n        return 1;\n    }\n\n    function sha256mem(bytes memory _rawBytes, uint offset, uint len) internal view returns (bytes32 result) {\n        assembly {\n            // Call sha256 precompiled contract (located in address 0x02) to copy data.\n            // Assign to ptr the next available memory position (stored in memory position 0x40).\n            let ptr := mload(0x40)\n            if iszero(staticcall(gas, 0x02, add(add(_rawBytes, 0x20), offset), len, ptr, 0x20)) {\n                revert(0, 0)\n            }\n            result := mload(ptr)\n        }\n    }\n\n    // @dev - Bitcoin-way of hashing\n    // @param _dataBytes - raw data to be hashed\n    // @return - result of applying SHA-256 twice to raw data and then flipping the bytes\n    function dblShaFlip(bytes _dataBytes) internal pure returns (uint) {\n        return flip32Bytes(uint(sha256(abi.encodePacked(sha256(abi.encodePacked(_dataBytes))))));\n    }\n\n    // @dev - Bitcoin-way of hashing\n    // @param _dataBytes - raw data to be hashed\n    // @return - result of applying SHA-256 twice to raw data and then flipping the bytes\n    function dblShaFlipMem(bytes memory _rawBytes, uint offset, uint len) internal view returns (uint) {\n        return flip32Bytes(uint(sha256(abi.encodePacked(sha256mem(_rawBytes, offset, len)))));\n    }\n\n    // @dev – Read a bytes32 from an offset in the byte array\n    function readBytes32(bytes memory data, uint offset) internal pure returns (bytes32) {\n        bytes32 result;\n        assembly {\n            result := mload(add(add(data, 0x20), offset))\n        }\n        return result;\n    }\n\n    // @dev – Read an uint32 from an offset in the byte array\n    function readUint32(bytes memory data, uint offset) internal pure returns (uint32) {\n        uint32 result;\n        assembly {\n            result := mload(add(add(data, 0x20), offset))\n            \n        }\n        return result;\n    }\n\n    // @dev - Bitcoin-way of computing the target from the 'bits' field of a block header\n    // based on http://www.righto.com/2014/02/bitcoin-mining-hard-way-algorithms.html//ref3\n    //\n    // @param _bits - difficulty in bits format\n    // @return - difficulty in target format\n    function targetFromBits(uint32 _bits) internal pure returns (uint) {\n        uint exp = _bits / 0x1000000;  // 2**24\n        uint mant = _bits & 0xffffff;\n        return mant * 256**(exp - 3);\n    }\n\n    uint constant SYSCOIN_DIFFICULTY_ONE = 0xFFFFF * 256**(0x1e - 3);\n\n    // @dev - Calculate syscoin difficulty from target\n    // https://en.bitcoin.it/wiki/Difficulty\n    // Min difficulty for bitcoin is 0x1d00ffff\n    // Min difficulty for syscoin is 0x1e0fffff\n    function targetToDiff(uint target) internal pure returns (uint) {\n        return SYSCOIN_DIFFICULTY_ONE / target;\n    }\n    \n\n    // 0x00 version\n    // 0x04 prev block hash\n    // 0x24 merkle root\n    // 0x44 timestamp\n    // 0x48 bits\n    // 0x4c nonce\n\n    // @dev - extract previous block field from a raw Syscoin block header\n    //\n    // @param _blockHeader - Syscoin block header bytes\n    // @param pos - where to start reading hash from\n    // @return - hash of block's parent in big endian format\n    function getHashPrevBlock(bytes memory _blockHeader) internal pure returns (uint) {\n        uint hashPrevBlock;\n        assembly {\n            hashPrevBlock := mload(add(add(_blockHeader, 32), 0x04))\n        }\n        return flip32Bytes(hashPrevBlock);\n    }\n\n    // @dev - extract Merkle root field from a raw Syscoin block header\n    //\n    // @param _blockHeader - Syscoin block header bytes\n    // @param pos - where to start reading root from\n    // @return - block's Merkle root in big endian format\n    function getHeaderMerkleRoot(bytes memory _blockHeader) public pure returns (uint) {\n        uint merkle;\n        assembly {\n            merkle := mload(add(add(_blockHeader, 32), 0x24))\n        }\n        return flip32Bytes(merkle);\n    }\n\n    // @dev - extract timestamp field from a raw Syscoin block header\n    //\n    // @param _blockHeader - Syscoin block header bytes\n    // @param pos - where to start reading bits from\n    // @return - block's timestamp in big-endian format\n    function getTimestamp(bytes memory _blockHeader) internal pure returns (uint32 time) {\n        return bytesToUint32Flipped(_blockHeader, 0x44);\n    }\n\n    // @dev - extract bits field from a raw Syscoin block header\n    //\n    // @param _blockHeader - Syscoin block header bytes\n    // @param pos - where to start reading bits from\n    // @return - block's difficulty in bits format, also big-endian\n    function getBits(bytes memory _blockHeader) internal pure returns (uint32 bits) {\n        return bytesToUint32Flipped(_blockHeader, 0x48);\n    }\n\n\n    // @dev - converts raw bytes representation of a Syscoin block header to struct representation\n    //\n    // @param _rawBytes - first 80 bytes of a block header\n    // @return - exact same header information in BlockHeader struct form\n    function parseHeaderBytes(bytes memory _rawBytes, uint pos) internal view returns (BlockHeader bh) {\n        bh.bits = getBits(_rawBytes);\n        bh.blockHash = dblShaFlipMem(_rawBytes, pos, 80);\n    }\n\n    uint32 constant VERSION_AUXPOW = (1 << 8);\n\n    // @dev - Converts a bytes of size 4 to uint32,\n    // e.g. for input [0x01, 0x02, 0x03 0x04] returns 0x01020304\n    function bytesToUint32Flipped(bytes memory input, uint pos) internal pure returns (uint32 result) {\n        result = uint32(input[pos]) + uint32(input[pos + 1])*(2**8) + uint32(input[pos + 2])*(2**16) + uint32(input[pos + 3])*(2**24);\n    }\n    function bytesToUint64(bytes memory input, uint pos) internal pure returns (uint64 result) {\n        result = uint64(input[pos+7]) + uint64(input[pos + 6])*(2**8) + uint64(input[pos + 5])*(2**16) + uint64(input[pos + 4])*(2**24) + uint64(input[pos + 3])*(2**32) + uint64(input[pos + 2])*(2**40) + uint64(input[pos + 1])*(2**48) + uint64(input[pos])*(2**56);\n    }\n     function bytesToUint32(bytes memory input, uint pos) internal pure returns (uint32 result) {\n        result = uint32(input[pos+3]) + uint32(input[pos + 2])*(2**8) + uint32(input[pos + 1])*(2**16) + uint32(input[pos])*(2**24);\n    }  \n    // @dev - checks version to determine if a block has merge mining information\n    function isMergeMined(bytes memory _rawBytes, uint pos) internal pure returns (bool) {\n        return bytesToUint32Flipped(_rawBytes, pos) & VERSION_AUXPOW != 0;\n    }\n\n    // @dev - Verify block header\n    // @param _blockHeaderBytes - array of bytes with the block header\n    // @param _pos - starting position of the block header\n\t// @param _proposedBlockHash - proposed block hash computing from block header bytes\n    // @return - [ErrorCode, IsMergeMined]\n    function verifyBlockHeader(bytes _blockHeaderBytes, uint _pos, uint _proposedBlockHash) external view returns (uint, bool) {\n        BlockHeader memory blockHeader = parseHeaderBytes(_blockHeaderBytes, _pos);\n        uint blockSha256Hash = blockHeader.blockHash;\n\t\t// must confirm that the header hash passed in and computing hash matches\n\t\tif(blockSha256Hash != _proposedBlockHash){\n\t\t\treturn (ERR_INVALID_HEADER_HASH, true);\n\t\t}\n        uint target = targetFromBits(blockHeader.bits);\n        if (_blockHeaderBytes.length > 80 && isMergeMined(_blockHeaderBytes, 0)) {\n            AuxPoW memory ap = parseAuxPoW(_blockHeaderBytes, _pos);\n            if (ap.blockHash > target) {\n\n                return (ERR_PROOF_OF_WORK_AUXPOW, true);\n            }\n            uint auxPoWCode = checkAuxPoW(blockSha256Hash, ap);\n            if (auxPoWCode != 1) {\n                return (auxPoWCode, true);\n            }\n            return (0, true);\n        } else {\n            if (_proposedBlockHash > target) {\n                return (ERR_PROOF_OF_WORK, false);\n            }\n            return (0, false);\n        }\n    }\n\n    // For verifying Syscoin difficulty\n    int64 constant TARGET_TIMESPAN =  int64(21600); \n    int64 constant TARGET_TIMESPAN_DIV_4 = TARGET_TIMESPAN / int64(4);\n    int64 constant TARGET_TIMESPAN_MUL_4 = TARGET_TIMESPAN * int64(4);\n    int64 constant TARGET_TIMESPAN_ADJUSTMENT =  int64(360);  // 6 hour\n    uint constant INITIAL_CHAIN_WORK =  0x100001; \n    uint constant POW_LIMIT = 0x00000fffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\n\n    // @dev - Calculate difficulty from compact representation (bits) found in block\n    function diffFromBits(uint32 bits) external pure returns (uint) {\n        return targetToDiff(targetFromBits(bits))*INITIAL_CHAIN_WORK;\n    }\n    \n    function difficultyAdjustmentInterval() external pure returns (int64) {\n        return TARGET_TIMESPAN_ADJUSTMENT;\n    }\n    // @param _actualTimespan - time elapsed from previous block creation til current block creation;\n    // i.e., how much time it took to mine the current block\n    // @param _bits - previous block header difficulty (in bits)\n    // @return - expected difficulty for the next block\n    function calculateDifficulty(int64 _actualTimespan, uint32 _bits) external pure returns (uint32 result) {\n       int64 actualTimespan = _actualTimespan;\n        // Limit adjustment step\n        if (_actualTimespan < TARGET_TIMESPAN_DIV_4) {\n            actualTimespan = TARGET_TIMESPAN_DIV_4;\n        } else if (_actualTimespan > TARGET_TIMESPAN_MUL_4) {\n            actualTimespan = TARGET_TIMESPAN_MUL_4;\n        }\n\n        // Retarget\n        uint bnNew = targetFromBits(_bits);\n        bnNew = bnNew * uint(actualTimespan);\n        bnNew = uint(bnNew) / uint(TARGET_TIMESPAN);\n\n        if (bnNew > POW_LIMIT) {\n            bnNew = POW_LIMIT;\n        }\n\n        return toCompactBits(bnNew);\n    }\n\n    // @dev - shift information to the right by a specified number of bits\n    //\n    // @param _val - value to be shifted\n    // @param _shift - number of bits to shift\n    // @return - `_val` shifted `_shift` bits to the right, i.e. divided by 2**`_shift`\n    function shiftRight(uint _val, uint _shift) private pure returns (uint) {\n        return _val / uint(2)**_shift;\n    }\n\n    // @dev - shift information to the left by a specified number of bits\n    //\n    // @param _val - value to be shifted\n    // @param _shift - number of bits to shift\n    // @return - `_val` shifted `_shift` bits to the left, i.e. multiplied by 2**`_shift`\n    function shiftLeft(uint _val, uint _shift) private pure returns (uint) {\n        return _val * uint(2)**_shift;\n    }\n\n    // @dev - get the number of bits required to represent a given integer value without losing information\n    //\n    // @param _val - unsigned integer value\n    // @return - given value's bit length\n    function bitLen(uint _val) private pure returns (uint length) {\n        uint int_type = _val;\n        while (int_type > 0) {\n            int_type = shiftRight(int_type, 1);\n            length += 1;\n        }\n    }\n\n    // @dev - Convert uint256 to compact encoding\n    // based on https://github.com/petertodd/python-bitcoinlib/blob/2a5dda45b557515fb12a0a18e5dd48d2f5cd13c2/bitcoin/core/serialize.py\n    // Analogous to arith_uint256::GetCompact from C++ implementation\n    //\n    // @param _val - difficulty in target format\n    // @return - difficulty in bits format\n    function toCompactBits(uint _val) private pure returns (uint32) {\n        uint nbytes = uint (shiftRight((bitLen(_val) + 7), 3));\n        uint32 compact = 0;\n        if (nbytes <= 3) {\n            compact = uint32 (shiftLeft((_val & 0xFFFFFF), 8 * (3 - nbytes)));\n        } else {\n            compact = uint32 (shiftRight(_val, 8 * (nbytes - 3)));\n            compact = uint32 (compact & 0xFFFFFF);\n        }\n\n        // If the sign bit (0x00800000) is set, divide the mantissa by 256 and\n        // increase the exponent to get an encoding without it set.\n        if ((compact & 0x00800000) > 0) {\n            compact = uint32(shiftRight(compact, 8));\n            nbytes += 1;\n        }\n\n        return compact | uint32(shiftLeft(nbytes, 24));\n    }\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"bits\",\"type\":\"uint32\"}],\"name\":\"diffFromBits\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_blockHeader\",\"type\":\"bytes\"}],\"name\":\"getHeaderMerkleRoot\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_blockHeaderBytes\",\"type\":\"bytes\"},{\"name\":\"_pos\",\"type\":\"uint256\"},{\"name\":\"_proposedBlockHash\",\"type\":\"uint256\"}],\"name\":\"verifyBlockHeader\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_actualTimespan\",\"type\":\"int64\"},{\"name\":\"_bits\",\"type\":\"uint32\"}],\"name\":\"calculateDifficulty\",\"outputs\":[{\"name\":\"result\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"difficultyAdjustmentInterval\",\"outputs\":[{\"name\":\"\",\"type\":\"int64\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"hashes2\",\"type\":\"bytes32[]\"}],\"name\":\"makeMerkle\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"}]","ContractName":"SyscoinMessageLibrary","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://22ed6517c30692bc56893be0d2280a04490caf9b925643abd3422cd784ad6857"}]}