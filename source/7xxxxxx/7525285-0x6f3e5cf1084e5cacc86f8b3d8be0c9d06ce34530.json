{"status":"1","message":"OK","result":[{"SourceCode":"// File: contracts\\math\\SafeMath.sol\r\n\r\npragma solidity 0.5.7;\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Unsigned math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n    * @dev Multiplies two unsigned integers, reverts on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two unsigned integers, reverts on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\r\n    * reverts when dividing by zero.\r\n    */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: contracts\\RedTokenAccessControl.sol\r\n\r\npragma solidity 0.5.7;\r\n\r\n/*\r\n * @title RedTokenAccessControl\r\n * @notice This contract defines organizational roles and permissions.\r\n */\r\ncontract RedTokenAccessControl {\r\n\r\n  event Paused();\r\n  event Unpaused();\r\n  event PausedUser(address indexed account);\r\n  event UnpausedUser(address indexed account);\r\n\r\n  /*\r\n   * @notice CEO's address\r\n   */\r\n  address public ceoAddress;\r\n\r\n  /*\r\n   * @notice CFO's address\r\n   */\r\n  address public cfoAddress;\r\n\r\n  /*\r\n   * @notice COO's address\r\n   */\r\n  address public cooAddress;\r\n\r\n  bool public paused = false;\r\n\r\n  /*\r\n   * @notice paused users status\r\n   */\r\n  mapping (address => bool) private pausedUsers;\r\n\r\n  /*\r\n   * @notice init constructor\r\n   */\r\n  constructor () internal {\r\n      ceoAddress = msg.sender;\r\n      cfoAddress = msg.sender;\r\n      cooAddress = msg.sender;\r\n  }\r\n\r\n  /*\r\n   * @dev Modifier to make a function only callable by the CEO\r\n   */\r\n  modifier onlyCEO() {\r\n    require(msg.sender == ceoAddress);\r\n    _;\r\n  }\r\n\r\n  /*\r\n   * @dev Modifier to make a function only callable by the CFO\r\n   */\r\n  modifier onlyCFO() {\r\n    require(msg.sender == cfoAddress);\r\n    _;\r\n  }\r\n\r\n  /*\r\n   * @dev Modifier to make a function only callable by the COO\r\n   */\r\n  modifier onlyCOO() {\r\n    require(msg.sender == cooAddress);\r\n    _;\r\n  }\r\n\r\n  /*\r\n   * @dev Modifier to make a function only callable by C-level execs\r\n   */\r\n  modifier onlyCLevel() {\r\n    require(\r\n      msg.sender == cooAddress ||\r\n      msg.sender == ceoAddress ||\r\n      msg.sender == cfoAddress\r\n    );\r\n    _;\r\n  }\r\n\r\n  /*\r\n   * @dev Modifier to make a function only callable by CEO or CFO\r\n   */\r\n  modifier onlyCEOOrCFO() {\r\n    require(\r\n      msg.sender == cfoAddress ||\r\n      msg.sender == ceoAddress\r\n    );\r\n    _;\r\n  }\r\n\r\n  /*\r\n   * @dev Modifier to make a function only callable by CEO or COO\r\n   */\r\n  modifier onlyCEOOrCOO() {\r\n    require(\r\n      msg.sender == cooAddress ||\r\n      msg.sender == ceoAddress\r\n    );\r\n    _;\r\n  }\r\n\r\n  /*\r\n   * @notice Sets a new CEO\r\n   * @param _newCEO - the address of the new CEO\r\n   */\r\n  function setCEO(address _newCEO) external onlyCEO {\r\n    require(_newCEO != address(0));\r\n    ceoAddress = _newCEO;\r\n  }\r\n\r\n  /*\r\n   * @notice Sets a new CFO\r\n   * @param _newCFO - the address of the new CFO\r\n   */\r\n  function setCFO(address _newCFO) external onlyCEO {\r\n    require(_newCFO != address(0));\r\n    cfoAddress = _newCFO;\r\n  }\r\n\r\n  /*\r\n   * @notice Sets a new COO\r\n   * @param _newCOO - the address of the new COO\r\n   */\r\n  function setCOO(address _newCOO) external onlyCEO {\r\n    require(_newCOO != address(0));\r\n    cooAddress = _newCOO;\r\n  }\r\n\r\n  /* Pausable functionality adapted from OpenZeppelin **/\r\n  /*\r\n   * @dev Modifier to make a function callable only when the contract is not paused.\r\n   */\r\n  modifier whenNotPaused() {\r\n    require(!paused);\r\n    _;\r\n  }\r\n\r\n  /*\r\n   * @dev Modifier to make a function callable only when the contract is paused.\r\n   */\r\n  modifier whenPaused() {\r\n    require(paused);\r\n    _;\r\n  }\r\n\r\n  /*\r\n   * @notice called by any C-LEVEL to pause, triggers stopped state\r\n   */\r\n  function pause() external onlyCLevel whenNotPaused {\r\n    paused = true;\r\n    emit Paused();\r\n  }\r\n\r\n  /*\r\n   * @notice called by any C-LEVEL to unpause, returns to normal state\r\n   */\r\n  function unpause() external onlyCLevel whenPaused {\r\n    paused = false;\r\n    emit Unpaused();\r\n  }\r\n\r\n  /* user Pausable functionality ref someting : openzeppelin/access/Roles.sol **/\r\n  /*\r\n   * @dev Modifier to make a function callable only when the user is not paused.\r\n   */\r\n  modifier whenNotPausedUser(address account) {\r\n    require(account != address(0));\r\n    require(!pausedUsers[account]);\r\n    _;\r\n  }\r\n\r\n  /*\r\n   * @dev Modifier to make a function callable only when the user is paused.\r\n   */\r\n  modifier whenPausedUser(address account) {\r\n    require(account != address(0));\r\n    require(pausedUsers[account]);\r\n    _;\r\n  }\r\n\r\n  /*\r\n    * @dev check if an account has this pausedUsers\r\n    * @return bool\r\n    */\r\n  function has(address account) internal view returns (bool) {\r\n      require(account != address(0));\r\n      return pausedUsers[account];\r\n  }\r\n  \r\n  /*\r\n   * @notice _addPauseUser\r\n   */\r\n  function _addPauseUser(address account) internal {\r\n      require(account != address(0));\r\n      require(!has(account));\r\n\r\n      pausedUsers[account] = true;\r\n\r\n      emit PausedUser(account);\r\n  }\r\n\r\n  /*\r\n   * @notice _unpausedUser\r\n   */\r\n  function _unpausedUser(address account) internal {\r\n      require(account != address(0));\r\n      require(has(account));\r\n\r\n      pausedUsers[account] = false;\r\n      emit UnpausedUser(account);\r\n  }\r\n\r\n  /*\r\n   * @notice isPausedUser\r\n   */\r\n  function isPausedUser(address account) external view returns (bool) {\r\n      return has(account);\r\n  }\r\n\r\n  /*\r\n   * @notice called by the COO to pauseUser, triggers stopped user state\r\n   */\r\n  function pauseUser(address account) external onlyCOO whenNotPausedUser(account) {\r\n    _addPauseUser(account);\r\n  }\r\n\r\n  /*\r\n   * @notice called by any C-LEVEL to unpauseUser, returns to user state\r\n   */\r\n  function unpauseUser(address account) external onlyCLevel whenPausedUser(account) {\r\n    _unpausedUser(account);\r\n  }\r\n}\r\n\r\n// File: contracts\\RedTokenBase.sol\r\n\r\npragma solidity 0.5.7;\r\n\r\n\r\n\r\n/*\r\n * @title RedTokenBase\r\n * @notice This contract defines the RedToken data structure and how to read from it / functions\r\n */\r\ncontract RedTokenBase is RedTokenAccessControl {\r\n  using SafeMath for uint256;\r\n\r\n  /*\r\n   * @notice Product defines a RedToken\r\n   */ \r\n  struct RedToken {\r\n    uint256 tokenId;\r\n    string rmsBondNo;\r\n    uint256 bondAmount;\r\n    uint256 listingAmount;\r\n    uint256 collectedAmount;\r\n    uint createdTime;\r\n    bool isValid;\r\n  }\r\n\r\n  /*\r\n   * @notice tokenId for share users by listingAmount\r\n   */\r\n  mapping (uint256 => mapping(address => uint256)) shareUsers;\r\n\r\n  /*\r\n   * @notice tokenid by share accounts in shareUsers list iterator.\r\n   */\r\n  mapping (uint256 => address []) shareUsersKeys;\r\n  \r\n  /*\r\n   * @notice All redTokens in existence.\r\n   * @dev The ID of each redToken is an index in this array.\r\n   */\r\n  RedToken[] redTokens;\r\n  \r\n  /*\r\n   * @notice Get a redToken RmsBondNo\r\n   * @param _tokenId the token id\r\n   */\r\n  function redTokenRmsBondNo(uint256 _tokenId) external view returns (string memory) {\r\n    return redTokens[_tokenId].rmsBondNo;\r\n  }\r\n\r\n  /*\r\n   * @notice Get a redToken BondAmount\r\n   * @param _tokenId the token id\r\n   */\r\n  function redTokenBondAmount(uint256 _tokenId) external view returns (uint256) {\r\n    return redTokens[_tokenId].bondAmount;\r\n  }\r\n\r\n  /*\r\n   * @notice Get a redToken ListingAmount\r\n   * @param _tokenId the token id\r\n   */\r\n  function redTokenListingAmount(uint256 _tokenId) external view returns (uint256) {\r\n    return redTokens[_tokenId].listingAmount;\r\n  }\r\n  \r\n  /*\r\n   * @notice Get a redToken CollectedAmount\r\n   * @param _tokenId the token id\r\n   */\r\n  function redTokenCollectedAmount(uint256 _tokenId) external view returns (uint256) {\r\n    return redTokens[_tokenId].collectedAmount;\r\n  }\r\n\r\n  /*\r\n   * @notice Get a redToken CreatedTime\r\n   * @param _tokenId the token id\r\n   */\r\n  function redTokenCreatedTime(uint256 _tokenId) external view returns (uint) {\r\n    return redTokens[_tokenId].createdTime;\r\n  }\r\n\r\n  /*\r\n   * @notice isValid a redToken\r\n   * @param _tokenId the token id\r\n   */\r\n  function isValidRedToken(uint256 _tokenId) public view returns (bool) {\r\n    return redTokens[_tokenId].isValid;\r\n  }\r\n\r\n  /*\r\n   * @notice info a redToken\r\n   * @param _tokenId the token id\r\n   */\r\n  function redTokenInfo(uint256 _tokenId)\r\n    external view returns (uint256, string memory, uint256, uint256, uint256, uint)\r\n  {\r\n    require(isValidRedToken(_tokenId));\r\n    RedToken memory _redToken = redTokens[_tokenId];\r\n\r\n    return (\r\n        _redToken.tokenId,\r\n        _redToken.rmsBondNo,\r\n        _redToken.bondAmount,\r\n        _redToken.listingAmount,\r\n        _redToken.collectedAmount,\r\n        _redToken.createdTime\r\n    );\r\n  }\r\n  \r\n  /*\r\n   * @notice info a token of share users\r\n   * @param _tokenId the token id\r\n   */\r\n  function redTokenInfoOfshareUsers(uint256 _tokenId) external view returns (address[] memory, uint256[] memory) {\r\n    require(isValidRedToken(_tokenId));\r\n\r\n    uint256 keySize = shareUsersKeys[_tokenId].length;\r\n\r\n    address[] memory addrs   = new address[](keySize);\r\n    uint256[] memory amounts = new uint256[](keySize);\r\n\r\n    for (uint index = 0; index < keySize; index++) {\r\n      addrs[index]   = shareUsersKeys[_tokenId][index];\r\n      amounts[index] = shareUsers[_tokenId][addrs[index]];\r\n    }\r\n    \r\n    return (addrs, amounts);\r\n  }\r\n}\r\n\r\n// File: contracts\\interfaces\\ERC721.sol\r\n\r\npragma solidity 0.5.7;\r\n\r\n/// @title ERC-721 Non-Fungible Token Standard\r\n/// @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\r\n///  Note: the ERC-165 identifier for this interface is 0x80ac58cd.\r\ninterface ERC721 {\r\n    /// @dev This emits when ownership of any NFT changes by any mechanism.\r\n    ///  This event emits when NFTs are created (`from` == 0) and destroyed\r\n    ///  (`to` == 0). Exception: during contract creation, any number of NFTs\r\n    ///  may be created and assigned without emitting Transfer. At the time of\r\n    ///  any transfer, the approved address for that NFT (if any) is reset to none.\r\n    event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);\r\n\r\n    /// @dev This emits when the approved address for an NFT is changed or\r\n    ///  reaffirmed. The zero address indicates there is no approved address.\r\n    ///  When a Transfer event emits, this also indicates that the approved\r\n    ///  address for that NFT (if any) is reset to none.\r\n    event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);\r\n\r\n    /// @dev This emits when an operator is enabled or disabled for an owner.\r\n    ///  The operator can manage all NFTs of the owner.\r\n    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\r\n\r\n    /// @notice Count all NFTs assigned to an owner\r\n    /// @dev NFTs assigned to the zero address are considered invalid, and this\r\n    ///  function throws for queries about the zero address.\r\n    /// @param _owner An address for whom to query the balance\r\n    /// @return The number of NFTs owned by `_owner`, possibly zero\r\n    function balanceOf(address _owner) external view returns (uint256);\r\n\r\n    /// @notice Find the owner of an NFT\r\n    /// @dev NFTs assigned to zero address are considered invalid, and queries\r\n    ///  about them do throw.\r\n    /// @param _tokenId The identifier for an NFT\r\n    /// @return The address of the owner of the NFT\r\n    function ownerOf(uint256 _tokenId) external view returns (address);\r\n\r\n    /// @notice Transfers the ownership of an NFT from one address to another address\r\n    /// @dev Throws unless `msg.sender` is the current owner, an authorized\r\n    ///  operator, or the approved address for this NFT. Throws if `_from` is\r\n    ///  not the current owner. Throws if `_to` is the zero address. Throws if\r\n    ///  `_tokenId` is not a valid NFT. When transfer is complete, this function\r\n    ///  checks if `_to` is a smart contract (code size > 0). If so, it calls\r\n    ///  `onERC721Received` on `_to` and throws if the return value is not\r\n    ///  `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`.\r\n    /// @param _from The current owner of the NFT\r\n    /// @param _to The new owner\r\n    /// @param _tokenId The NFT to transfer\r\n    /// @param data Additional data with no specified format, sent in call to `_to`\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes calldata data) external payable;\r\n\r\n    /// @notice Transfers the ownership of an NFT from one address to another address\r\n    /// @dev This works identically to the other function with an extra data parameter,\r\n    ///  except this function just sets data to \"\".\r\n    /// @param _from The current owner of the NFT\r\n    /// @param _to The new owner\r\n    /// @param _tokenId The NFT to transfer\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external payable;\r\n\r\n    /// @notice Transfer ownership of an NFT -- THE CALLER IS RESPONSIBLE\r\n    ///  TO CONFIRM THAT `_to` IS CAPABLE OF RECEIVING NFTS OR ELSE\r\n    ///  THEY MAY BE PERMANENTLY LOST\r\n    /// @dev Throws unless `msg.sender` is the current owner, an authorized\r\n    ///  operator, or the approved address for this NFT. Throws if `_from` is\r\n    ///  not the current owner. Throws if `_to` is the zero address. Throws if\r\n    ///  `_tokenId` is not a valid NFT.\r\n    /// @param _from The current owner of the NFT\r\n    /// @param _to The new owner\r\n    /// @param _tokenId The NFT to transfer\r\n    function transferFrom(address _from, address _to, uint256 _tokenId) external payable;\r\n\r\n    /// @notice Change or reaffirm the approved address for an NFT\r\n    /// @dev The zero address indicates there is no approved address.\r\n    ///  Throws unless `msg.sender` is the current NFT owner, or an authorized\r\n    ///  operator of the current owner.\r\n    /// @param _approved The new approved NFT controller\r\n    /// @param _tokenId The NFT to approve\r\n    function approve(address _approved, uint256 _tokenId) external payable;\r\n\r\n    /// @notice Enable or disable approval for a third party (\"operator\") to manage\r\n    ///  all of `msg.sender`'s assets\r\n    /// @dev Emits the ApprovalForAll event. The contract MUST allow\r\n    ///  multiple operators per owner.\r\n    /// @param _operator Address to add to the set of authorized operators\r\n    /// @param _approved True if the operator is approved, false to revoke approval\r\n    function setApprovalForAll(address _operator, bool _approved) external;\r\n\r\n    /// @notice Get the approved address for a single NFT\r\n    /// @dev Throws if `_tokenId` is not a valid NFT.\r\n    /// @param _tokenId The NFT to find the approved address for\r\n    /// @return The approved address for this NFT, or the zero address if there is none\r\n    function getApproved(uint256 _tokenId) external view returns (address);\r\n\r\n    /// @notice Query if an address is an authorized operator for another address\r\n    /// @param _owner The address that owns the NFTs\r\n    /// @param _operator The address that acts on behalf of the owner\r\n    /// @return True if `_operator` is an approved operator for `_owner`, false otherwise\r\n    function isApprovedForAll(address _owner, address _operator) external view returns (bool);\r\n}\r\n\r\n// File: contracts\\interfaces\\ERC721Metadata.sol\r\n\r\npragma solidity 0.5.7;\r\n\r\n/*\r\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\r\n * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\r\n *  Note: the ERC-165 identifier for this interface is 0x5b5e139f\r\n */\r\ninterface ERC721Metadata /* is ERC721 */ {\r\n    \r\n    /*\r\n     * @notice A descriptive name for a collection of NFTs in this contract\r\n     */\r\n    function name() external pure returns (string memory _name);\r\n\r\n    /*\r\n     * @notice An abbreviated name for NFTs in this contract\r\n     */ \r\n    function symbol() external pure returns (string memory _symbol);\r\n\r\n    /*\r\n     * @notice A distinct Uniform Resource Identifier (URI) for a given asset.\r\n     * @dev Throws if `_tokenId` is not a valid NFT. URIs are defined in RFC\r\n     *  3986. The URI may point to a JSON file that conforms to the \"ERC721\r\n     *  Metadata JSON Schema\".\r\n     */\r\n    function tokenURI(uint256 _tokenId) external view returns (string memory);\r\n}\r\n\r\n// File: contracts\\interfaces\\ERC721Enumerable.sol\r\n\r\npragma solidity 0.5.7;\r\n\r\n/*\r\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\r\n * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\r\n *  Note: the ERC-165 identifier for this interface is 0x780e9d63\r\n */\r\ninterface ERC721Enumerable /* is ERC721 */ {\r\n    /*\r\n     * @notice Count NFTs tracked by this contract\r\n     * @return A count of valid NFTs tracked by this contract, where each one of\r\n     *  them has an assigned and queryable owner not equal to the zero address\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /*\r\n     * @notice Enumerate valid NFTs\r\n     * @dev Throws if `_index` >= `totalSupply()`.\r\n     * @param _index A counter less than `totalSupply()`\r\n     * @return The token identifier for the `_index`th NFT,\r\n     *  (sort order not specified)\r\n     */\r\n    function tokenByIndex(uint256 _index) external view returns (uint256);\r\n\r\n    /*\r\n     * @notice Enumerate NFTs assigned to an owner\r\n     * @dev Throws if `_index` >= `balanceOf(_owner)` or if\r\n     *  `_owner` is the zero address, representing invalid NFTs.\r\n     * @param _owner An address where we are interested in NFTs owned by them\r\n     * @param _index A counter less than `balanceOf(_owner)`\r\n     * @return The token identifier for the `_index`th NFT assigned to `_owner`,\r\n     *   (sort order not specified)\r\n     */\r\n    function tokenOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256 _tokenId);\r\n}\r\n\r\n// File: contracts\\interfaces\\ERC165.sol\r\n\r\npragma solidity 0.5.7;\r\n\r\ninterface ERC165 {\r\n    /*\r\n     * @notice Query if a contract implements an interface\r\n     * @param interfaceID The interface identifier, as specified in ERC-165\r\n     * @dev Interface identification is specified in ERC-165. This function\r\n     *  uses less than 30,000 gas.\r\n     * @return `true` if the contract implements `interfaceID` and\r\n     *  `interfaceID` is not 0xffffffff, `false` otherwise\r\n     */\r\n    function supportsInterface(bytes4 interfaceID) external view returns (bool);\r\n}\r\n\r\n// File: contracts\\strings\\Strings.sol\r\n\r\npragma solidity 0.5.7;\r\n\r\nlibrary Strings {\r\n  // via https://github.com/oraclize/ethereum-api/blob/master/oraclizeAPI_0.5.sol\r\n  function strConcat(string memory _a, string memory _b, string memory _c, string memory _d, string memory _e) internal pure returns (string memory) {\r\n    bytes memory _ba = bytes(_a);\r\n    bytes memory _bb = bytes(_b);\r\n    bytes memory _bc = bytes(_c);\r\n    bytes memory _bd = bytes(_d);\r\n    bytes memory _be = bytes(_e);\r\n    string memory abcde = new string(_ba.length + _bb.length + _bc.length + _bd.length + _be.length);\r\n    bytes memory babcde = bytes(abcde);\r\n    uint k = 0;\r\n    for (uint i = 0; i < _ba.length; i++) babcde[k++] = _ba[i];\r\n    for (uint i = 0; i < _bb.length; i++) babcde[k++] = _bb[i];\r\n    for (uint i = 0; i < _bc.length; i++) babcde[k++] = _bc[i];\r\n    for (uint i = 0; i < _bd.length; i++) babcde[k++] = _bd[i];\r\n    for (uint i = 0; i < _be.length; i++) babcde[k++] = _be[i];\r\n    return string(babcde);\r\n  }\r\n\r\n  function strConcat(string memory _a, string memory _b, string memory _c, string memory _d) internal pure returns (string memory) {\r\n    return strConcat(_a, _b, _c, _d, \"\");\r\n  }\r\n\r\n  function strConcat(string memory _a, string memory _b, string memory _c) internal pure returns (string memory) {\r\n    return strConcat(_a, _b, _c, \"\", \"\");\r\n  }\r\n\r\n  function strConcat(string memory _a, string memory _b) internal pure returns (string memory) {\r\n    return strConcat(_a, _b, \"\", \"\", \"\");\r\n  }\r\n\r\n  function uint2str(uint i) internal pure returns (string memory) {\r\n    if (i == 0) return \"0\";\r\n    uint j = i;\r\n    uint len;\r\n    while (j != 0){\r\n        len++;\r\n        j /= 10;\r\n    }\r\n    bytes memory bstr = new bytes(len);\r\n    uint k = len - 1;\r\n    while (i != 0){\r\n        bstr[k--] = byte(uint8(48 + i % 10));\r\n        i /= 10;\r\n    }\r\n    return string(bstr);\r\n  }\r\n}\r\n\r\n// File: contracts\\interfaces\\ERC721TokenReceiver.sol\r\n\r\npragma solidity 0.5.7;\r\n\r\n/*\r\n * @dev Note: the ERC-165 identifier for this interface is 0xf0b9e5ba\r\n */\r\ninterface ERC721TokenReceiver {\r\n    /*\r\n     * @notice Handle the receipt of an NFT\r\n     * @dev The ERC721 smart contract calls this function on the recipient\r\n     *  after a `transfer`. This function MAY throw to revert and reject the\r\n     *  transfer. This function MUST use 50,000 gas or less. Return of other\r\n     *  than the magic value MUST result in the transaction being reverted.\r\n     *  Note: the contract address is always the message sender.\r\n     * @param _from The sending address\r\n     * @param _tokenId The NFT identifier which is being transfered\r\n     * @param _data Additional data with no specified format\r\n     * @return `bytes4(keccak256(\"onERC721Received(address,uint256,bytes)\"))`\r\n     *  unless throwing\r\n     */\r\n\tfunction onERC721Received(address _from, uint256 _tokenId, bytes calldata _data) external returns(bytes4);\r\n}\r\n\r\n// File: contracts\\RedTokenOwnership.sol\r\n\r\npragma solidity 0.5.7;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/*\r\n * @title RedTokenOwnership\r\n * @notice control by TokenBase.\r\n */\r\ncontract RedTokenOwnership is RedTokenBase, ERC721, ERC165, ERC721Metadata, ERC721Enumerable {\r\n  using SafeMath for uint256;\r\n\r\n  // Total amount of tokens\r\n  uint256 private totalTokens;\r\n\r\n  // Mapping from token ID to owner\r\n  mapping (uint256 => address) private tokenOwner;\r\n\r\n  // Mapping from owner to list of owned token IDs\r\n  mapping (address => uint256[]) internal ownedTokens;\r\n\r\n  // Mapping from token ID to index of the owner tokens list\r\n  mapping (uint256 => uint256) internal ownedTokensIndex;\r\n\r\n  // Mapping from token ID to approved address\r\n  mapping (uint256 => address) internal tokenApprovals;\r\n\r\n  // Mapping from owner address to operator address to approval\r\n  mapping (address => mapping (address => bool)) internal operatorApprovals;\r\n\r\n  /** events **/\r\n  event calculateShareUsers(uint256 tokenId, address owner, address from, address to, uint256 amount);\r\n  event CollectedAmountUpdate(uint256 tokenId, address owner, uint256 amount);\r\n\r\n  /** Constants **/\r\n  // Configure these for your own deployment\r\n  string internal constant NAME = \"RedToken\";\r\n  string internal constant SYMBOL = \"REDT\";\r\n  string internal tokenMetadataBaseURI = \"https://doc.reditus.co.kr/?docid=\";\r\n\r\n  /** structs **/\r\n  function supportsInterface(\r\n    bytes4 interfaceID) // solium-disable-line dotta/underscore-function-arguments\r\n    external view returns (bool)\r\n  {\r\n    return\r\n      interfaceID == this.supportsInterface.selector || // ERC165\r\n      interfaceID == 0x5b5e139f || // ERC721Metadata\r\n      interfaceID == 0x80ac58cd || // ERC-721\r\n      interfaceID == 0x780e9d63; // ERC721Enumerable\r\n  }\r\n\r\n  /*\r\n   * @notice Guarantees msg.sender is owner of the given token\r\n   * @param _tokenId uint256 ID of the token to validate its ownership belongs to msg.sender\r\n   */\r\n  modifier onlyOwnerOf(uint256 _tokenId) {\r\n    require(ownerOf(_tokenId) == msg.sender);\r\n    _;\r\n  }\r\n\r\n  /** external functions **/  \r\n  /*\r\n   * @notice token's name\r\n   */\r\n  function name() external pure returns (string memory) {\r\n    return NAME;\r\n  }\r\n\r\n  /*\r\n   * @notice symbols's name\r\n   */\r\n  function symbol() external pure returns (string memory) {\r\n    return SYMBOL;\r\n  }\r\n\r\n  /*\r\n   * @notice tokenURI\r\n   * @dev do not checked in array and used function isValidRedToken value is not important, only check in redTokens array\r\n   */\r\n  function tokenURI(uint256 _tokenId)\r\n    external\r\n    view\r\n    returns (string memory infoUrl)\r\n  {\r\n    if ( isValidRedToken(_tokenId) ){\r\n      return Strings.strConcat( tokenMetadataBaseURI, Strings.uint2str(_tokenId));\r\n    }else{\r\n      return Strings.strConcat( tokenMetadataBaseURI, Strings.uint2str(_tokenId));\r\n    }\r\n  }\r\n\r\n  /*\r\n   * @notice setTokenMetadataBaseURI\r\n   */\r\n  function setTokenMetadataBaseURI(string calldata _newBaseURI) external onlyCOO {\r\n    tokenMetadataBaseURI = _newBaseURI;\r\n  }\r\n\r\n  /*\r\n   * @notice Gets the total amount of tokens stored by the contract\r\n   * @return uint256 representing the total amount of tokens\r\n   */\r\n  function totalSupply() external view returns (uint256) {\r\n    return totalTokens;\r\n  }\r\n\r\n  /*\r\n   * @dev Gets the owner of the specified token ID\r\n   * @param _tokenId uint256 ID of the token to query the owner of\r\n   * @return owner address currently marked as the owner of the given token ID\r\n   */\r\n  function ownerOf(uint256 _tokenId) public view returns (address) {\r\n    address owner = tokenOwner[_tokenId];\r\n    require(owner != address(0));\r\n    return owner;\r\n  }\r\n\r\n  /*\r\n   * @notice Gets the balance of the specified address\r\n   * @param _owner address to query the balance of\r\n   * @return uint256 representing the amount owned by the passed address\r\n   */\r\n  function balanceOf(address _owner) public view returns (uint256) {\r\n    require(_owner != address(0));\r\n    return ownedTokens[_owner].length;\r\n  }\r\n\r\n  /*\r\n   * @notice Gets the list of tokens owned by a given address\r\n   * @param _owner address to query the tokens of\r\n   * @return uint256[] representing the list of tokens owned by the passed address\r\n   */\r\n  function tokensOf(address _owner) external view returns (uint256[] memory) {\r\n    require(_owner != address(0));\r\n    return ownedTokens[_owner];\r\n  }\r\n\r\n  /*\r\n  * @notice Enumerate valid NFTs\r\n  * @dev Our Licenses are kept in an array and each new License-token is just\r\n  * the next element in the array. This method is required for ERC721Enumerable\r\n  * which may support more complicated storage schemes. However, in our case the\r\n  * _index is the tokenId\r\n  * @param _index A counter less than `totalSupply()`\r\n  * @return The token identifier for the `_index`th NFT\r\n  */\r\n  function tokenByIndex(uint256 _index) external view returns (uint256) {\r\n    require(_index < totalTokens);\r\n    return _index;\r\n  }\r\n\r\n  /*\r\n   * @notice Enumerate NFTs assigned to an owner\r\n   * @dev Throws if `_index` >= `balanceOf(_owner)` or if\r\n   *  `_owner` is the zero address, representing invalid NFTs.\r\n   * @param _owner An address where we are interested in NFTs owned by them\r\n   * @param _index A counter less than `balanceOf(_owner)`\r\n   * @return The token identifier for the `_index`th NFT assigned to `_owner`,\r\n   */\r\n  function tokenOfOwnerByIndex(address _owner, uint256 _index)\r\n    external\r\n    view\r\n    returns (uint256 _tokenId)\r\n  {\r\n    require(_index < balanceOf(_owner));\r\n    return ownedTokens[_owner][_index];\r\n  }\r\n\r\n  /*\r\n   * @notice Gets the approved address to take ownership of a given token ID\r\n   * @param _tokenId uint256 ID of the token to query the approval of\r\n   * @return address currently approved to take ownership of the given token ID\r\n   */\r\n  function getApproved(uint256 _tokenId) public view returns (address) {\r\n    return tokenApprovals[_tokenId];\r\n  }\r\n\r\n  /*\r\n   * @notice Tells whether an operator is approved by a given owner\r\n   * @param _owner owner address which you want to query the approval of\r\n   * @param _operator operator address which you want to query the approval of\r\n   * @return bool whether the given operator is approved by the given owner\r\n   */\r\n  function isApprovedForAll(address _owner, address _operator) public view returns (bool)\r\n  {\r\n    return operatorApprovals[_owner][_operator];\r\n  }\r\n\r\n  /*\r\n   * @notice Approves another address to claim for the ownership of the given token ID\r\n   * @param _to address to be approved for the given token ID\r\n   * @param _tokenId uint256 ID of the token to be approved\r\n   */\r\n  function approve(address _to, uint256 _tokenId)\r\n    external\r\n    payable\r\n    whenNotPaused\r\n    whenNotPausedUser(msg.sender)\r\n    onlyOwnerOf(_tokenId)\r\n  {\r\n    require(_to != ownerOf(_tokenId));\r\n    if (getApproved(_tokenId) != address(0) || _to != address(0)) {\r\n      tokenApprovals[_tokenId] = _to;\r\n\r\n      emit Approval(ownerOf(_tokenId), _to, _tokenId);\r\n    }\r\n  }\r\n\r\n  /*\r\n   * @notice Enable or disable approval for a third party (\"operator\") to manage all your assets\r\n   * @dev Emits the ApprovalForAll event\r\n   * @param _to Address to add to the set of authorized operators.\r\n   * @param _approved True if the operators is approved, false to revoke approval\r\n   */\r\n  function setApprovalForAll(address _to, bool _approved)\r\n    external\r\n    whenNotPaused\r\n    whenNotPausedUser(msg.sender)\r\n  {\r\n    if(_approved) {\r\n      approveAll(_to);\r\n    } else {\r\n      disapproveAll(_to);\r\n    }\r\n  }\r\n\r\n  /*\r\n   * @notice Approves another address to claim for the ownership of any tokens owned by this account\r\n   * @param _to address to be approved for the given token ID\r\n   */\r\n  function approveAll(address _to)\r\n    internal\r\n    whenNotPaused\r\n    whenNotPausedUser(msg.sender)\r\n  {\r\n    require(_to != msg.sender);\r\n    require(_to != address(0));\r\n    operatorApprovals[msg.sender][_to] = true;\r\n\r\n    emit ApprovalForAll(msg.sender, _to, true);\r\n  }\r\n\r\n  /*\r\n   * @notice Removes approval for another address to claim for the ownership of any\r\n   *  tokens owned by this account.\r\n   * @dev Note that this only removes the operator approval and\r\n   *  does not clear any independent, specific approvals of token transfers to this address\r\n   * @param _to address to be disapproved for the given token ID\r\n   */\r\n  function disapproveAll(address _to)\r\n    internal\r\n    whenNotPaused\r\n    whenNotPausedUser(msg.sender)\r\n  {\r\n    require(_to != msg.sender);\r\n    delete operatorApprovals[msg.sender][_to];\r\n    \r\n    emit ApprovalForAll(msg.sender, _to, false);\r\n  }\r\n\r\n  /*\r\n   * @notice Tells whether the msg.sender is approved to transfer the given token ID or not\r\n   * Checks both for specific approval and operator approval\r\n   * @param _tokenId uint256 ID of the token to query the approval of\r\n   * @return bool whether transfer by msg.sender is approved for the given token ID or not\r\n   */\r\n  function isSenderApprovedFor(uint256 _tokenId) public view returns (bool) {\r\n    return\r\n      ownerOf(_tokenId) == msg.sender ||\r\n      getApproved(_tokenId) == msg.sender ||\r\n      isApprovedForAll(ownerOf(_tokenId), msg.sender);\r\n  }\r\n  \r\n  /*\r\n   * @notice Transfers the ownership of a given token ID to another address\r\n   * @param _to address to receive the ownership of the given token ID\r\n   * @param _tokenId uint256 ID of the token to be transferred\r\n   */\r\n  function transfer(address _to, uint256 _tokenId)\r\n    external\r\n    payable\r\n    whenNotPaused\r\n    whenNotPausedUser(msg.sender)\r\n    onlyOwnerOf(_tokenId)\r\n  {\r\n    _clearApprovalAndTransfer(msg.sender, _to, _tokenId);\r\n  }\r\n\r\n  /*\r\n   * @notice Transfer a token owned by another address, for which the calling address has\r\n   *  previously been granted transfer approval by the owner.\r\n   * @param _from The address that owns the token\r\n   * @param _to The address that will take ownership of the token. Can be any address, including the caller\r\n   * @param _tokenId The ID of the token to be transferred\r\n   */\r\n  function transferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _tokenId\r\n  )\r\n    external\r\n    payable\r\n    whenNotPaused\r\n    whenNotPausedUser(msg.sender)\r\n  {\r\n    require(isSenderApprovedFor(_tokenId));\r\n    _clearApprovalAndTransfer(_from, _to, _tokenId);\r\n  }\r\n  \r\n  /*\r\n   * @notice Transfers the ownership of an NFT from one address to another address\r\n   * @dev This works identically to the other function with an extra data parameter,\r\n   *  except this function just sets data to \"\"\r\n   * @param _from The current owner of the NFT\r\n   * @param _to The new owner\r\n   * @param _tokenId The NFT to transfer\r\n  */\r\n  function safeTransferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _tokenId\r\n  )\r\n    external\r\n    payable\r\n    whenNotPaused\r\n    whenNotPausedUser(msg.sender)\r\n  {\r\n    require(isSenderApprovedFor(_tokenId));\r\n    _safeTransferFrom(_from, _to, _tokenId, \"\");\r\n  }\r\n\r\n  /*\r\n   * @notice Transfers the ownership of an NFT from one address to another address\r\n   * @dev Throws unless `msg.sender` is the current owner, an authorized\r\n   * operator, or the approved address for this NFT. Throws if `_from` is\r\n   * not the current owner. Throws if `_to` is the zero address. Throws if\r\n   * `_tokenId` is not a valid NFT. When transfer is complete, this function\r\n   * checks if `_to` is a smart contract (code size > 0). If so, it calls\r\n   * `onERC721Received` on `_to` and throws if the return value is not\r\n   * `bytes4(keccak256(\"onERC721Received(address,uint256,bytes)\"))`.\r\n   * @param _from The current owner of the NFT\r\n   * @param _to The new owner\r\n   * @param _tokenId The NFT to transfer\r\n   * @param _data Additional data with no specified format, sent in call to `_to`\r\n   */\r\n  function safeTransferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _tokenId,\r\n    bytes calldata _data\r\n  )\r\n    external\r\n    payable\r\n    whenNotPaused\r\n    whenNotPausedUser(msg.sender)\r\n  {\r\n    require(isSenderApprovedFor(_tokenId));\r\n    _safeTransferFrom(_from, _to, _tokenId, _data);\r\n  }\r\n\r\n  /*\r\n   * @notice send amount shareUsers\r\n   */\r\n  function sendAmountShareUsers(\r\n    uint256 _tokenId, \r\n    address _to, \r\n    uint256 _amount\r\n  ) \r\n    external \r\n    onlyCOO\r\n    returns (bool) \r\n  {\r\n    require(_to != address(0));\r\n    return _calculateShareUsers(_tokenId, ownerOf(_tokenId), _to, _amount);\r\n  }\r\n\r\n  /*\r\n   * @notice send amount shareUsers\r\n   */\r\n  function sendAmountShareUsersFrom(\r\n    uint256 _tokenId, \r\n    address _from, \r\n    address _to, \r\n    uint256 _amount\r\n  ) \r\n    external \r\n    onlyCOO\r\n    returns (bool) \r\n  {\r\n    require(_to != address(0));\r\n    return _calculateShareUsers(_tokenId, _from, _to, _amount);\r\n  }\r\n\r\n  /*\r\n   * @notice update collectedAmount \r\n   */\r\n  function updateCollectedAmount(\r\n    uint256 _tokenId, \r\n    uint256 _amount\r\n  ) \r\n    external \r\n    onlyCOO \r\n    returns (bool) \r\n  {\r\n    require(isValidRedToken(_tokenId));\r\n    require(_amount > 0);\r\n        \r\n    redTokens[_tokenId].collectedAmount = redTokens[_tokenId].collectedAmount.add(_amount);\r\n    \r\n    emit CollectedAmountUpdate(_tokenId, ownerOf(_tokenId), _amount);\r\n    return true;\r\n  }\r\n\r\n  /*\r\n   * @notice createRedToken\r\n   */\r\n  function createRedToken(\r\n    address _user, \r\n    string calldata _rmsBondNo, \r\n    uint256 _bondAmount, \r\n    uint256 _listingAmount\r\n  ) \r\n    external \r\n    onlyCOO \r\n    returns (uint256) \r\n  {\r\n    return _createRedToken(_user,_rmsBondNo,_bondAmount,_listingAmount);\r\n  }\r\n\r\n  /*\r\n   * @notice burn amount a token by share users\r\n   */\r\n  function burnAmountByShareUser(\r\n    uint256 _tokenId, \r\n    address _from, \r\n    uint256 _amount\r\n  ) \r\n    external \r\n    onlyCOO \r\n    returns (bool) \r\n  {\r\n    return _calculateShareUsers(_tokenId, _from, address(0), _amount);\r\n  }\r\n  \r\n  /*\r\n   * @notice burn RedToken\r\n   */\r\n  function burn(\r\n    address _owner, \r\n    uint256 _tokenId\r\n  ) \r\n    external \r\n    onlyCOO \r\n    returns(bool) \r\n  {\r\n    require(_owner != address(0));\r\n    return _burn(_owner, _tokenId);\r\n  }\r\n\r\n  /** internal function **/\r\n  function isContract(address _addr) internal view returns (bool) {\r\n    uint size;\r\n    assembly { size := extcodesize(_addr) }\r\n    return size > 0;\r\n  }\r\n\r\n  /*\r\n   * @notice checked shareUser by shareUsersKeys\r\n   */\r\n  function isShareUser(\r\n    uint256 _tokenId, \r\n    address _from\r\n  ) \r\n    internal  \r\n    view \r\n    returns (bool) \r\n  {\r\n    bool chechedUser = false;\r\n    for (uint index = 0; index < shareUsersKeys[_tokenId].length; index++) {\r\n      if (  shareUsersKeys[_tokenId][index] == _from ){\r\n        chechedUser = true;\r\n        break;\r\n      }\r\n    }\r\n    return chechedUser;\r\n  }\r\n\r\n  /*\r\n   * @notice Transfers the ownership of an NFT from one address to another address\r\n   * @param _from The current owner of the NFT\r\n   * @param _to The new owner\r\n   * @param _tokenId The NFT to transfer\r\n   * @param _data Additional data with no specified format, sent in call to `_to`\r\n   */\r\n  function _safeTransferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _tokenId,\r\n    bytes memory _data\r\n  )\r\n    internal\r\n  {\r\n    _clearApprovalAndTransfer(_from, _to, _tokenId);\r\n\r\n    if (isContract(_to)) {\r\n      bytes4 tokenReceiverResponse = ERC721TokenReceiver(_to).onERC721Received.gas(50000)(\r\n        _from, _tokenId, _data\r\n      );\r\n      require(tokenReceiverResponse == bytes4(keccak256(\"onERC721Received(address,uint256,bytes)\")));\r\n    }\r\n  }\r\n\r\n  /*\r\n  * @notice Internal function to clear current approval and transfer the ownership of a given token ID\r\n  * @param _from address which you want to send tokens from\r\n  * @param _to address which you want to transfer the token to\r\n  * @param _tokenId uint256 ID of the token to be transferred\r\n  */\r\n  function _clearApprovalAndTransfer(\r\n    address _from, \r\n    address _to, \r\n    uint256 _tokenId\r\n  )\r\n    internal \r\n  {\r\n    require(_to != address(0));\r\n    require(_to != ownerOf(_tokenId));\r\n    require(ownerOf(_tokenId) == _from);\r\n    require(isValidRedToken(_tokenId));\r\n    \r\n    address owner = ownerOf(_tokenId);\r\n\r\n    _clearApproval(owner, _tokenId);\r\n    _removeToken(owner, _tokenId);\r\n    _addToken(_to, _tokenId);\r\n    _changeTokenShareUserByOwner(owner, _to, _tokenId);\r\n\r\n    emit Transfer(owner, _to, _tokenId);\r\n  }\r\n\r\n  /*\r\n   * @notice change token owner rate sending\r\n   * @param _from address which you want to change rate from\r\n   * @param _to address which you want to change rate the token to\r\n   * @param _tokenId uint256 ID of the token to be change rate\r\n   */\r\n  function _changeTokenShareUserByOwner(\r\n    address _from, \r\n    address _to, \r\n    uint256 _tokenId\r\n  ) \r\n    internal  \r\n  {\r\n    uint256 amount = shareUsers[_tokenId][_from];\r\n    delete shareUsers[_tokenId][_from];\r\n\r\n    shareUsers[_tokenId][_to] = shareUsers[_tokenId][_to].add(amount);\r\n\r\n    if ( !isShareUser(_tokenId, _to) ) {\r\n      shareUsersKeys[_tokenId].push(_to);\r\n    }\r\n  }\r\n\r\n  /*\r\n   * @notice remove shareUsers\r\n   */\r\n  function _calculateShareUsers(\r\n    uint256 _tokenId, \r\n    address _from, \r\n    address _to, \r\n    uint256 _amount\r\n  ) \r\n    internal\r\n    returns (bool) \r\n  {\r\n    require(_from != address(0));\r\n    require(_from != _to);\r\n    require(_amount > 0);\r\n    require(shareUsers[_tokenId][_from] >= _amount);\r\n    require(isValidRedToken(_tokenId));\r\n    \r\n    shareUsers[_tokenId][_from] = shareUsers[_tokenId][_from].sub(_amount);\r\n    shareUsers[_tokenId][_to] = shareUsers[_tokenId][_to].add(_amount);\r\n\r\n    if ( !isShareUser(_tokenId, _to) ) {\r\n      shareUsersKeys[_tokenId].push(_to);\r\n    }\r\n\r\n    emit calculateShareUsers(_tokenId, ownerOf(_tokenId), _from, _to, _amount);\r\n    return true;\r\n  }\r\n\r\n  /*\r\n  * @notice Internal function to clear current approval of a given token ID\r\n  * @param _tokenId uint256 ID of the token to be transferred\r\n  */\r\n  function _clearApproval(\r\n    address _owner,\r\n    uint256 _tokenId\r\n  ) \r\n    internal \r\n  {\r\n    require(ownerOf(_tokenId) == _owner);\r\n    \r\n    tokenApprovals[_tokenId] = address(0);\r\n\r\n    emit Approval(_owner, address(0), _tokenId);\r\n  }\r\n\r\n  function _createRedToken(\r\n    address _user, \r\n    string memory _rmsBondNo, \r\n    uint256 _bondAmount, \r\n    uint256 _listingAmount\r\n  ) \r\n    internal \r\n    returns (uint256)\r\n  {\r\n    require(_user != address(0));\r\n    require(bytes(_rmsBondNo).length > 0);\r\n    require(_bondAmount > 0);\r\n    require(_listingAmount > 0);\r\n\r\n    uint256 _newTokenId = redTokens.length;\r\n\r\n    RedToken memory _redToken = RedToken({\r\n      tokenId: _newTokenId,\r\n      rmsBondNo: _rmsBondNo,\r\n      bondAmount: _bondAmount,\r\n      listingAmount: _listingAmount,\r\n      collectedAmount: 0,\r\n      createdTime: now,\r\n      isValid:true\r\n    });\r\n\r\n    redTokens.push(_redToken) - 1;\r\n\r\n    shareUsers[_newTokenId][_user] = shareUsers[_newTokenId][_user].add(_listingAmount);\r\n    shareUsersKeys[_newTokenId].push(_user);\r\n\r\n    _addToken(_user, _newTokenId);\r\n\r\n    emit Transfer(address(0), _user, _newTokenId);\r\n\r\n    return _newTokenId;\r\n  }\r\n  \r\n  /*\r\n  * @notice Internal function to add a token ID to the list of a given address\r\n  * @param _to address representing the new owner of the given token ID\r\n  * @param _tokenId uint256 ID of the token to be added to the tokens list of the given address\r\n  */\r\n  function _addToken(\r\n    address _to, \r\n    uint256 _tokenId\r\n  ) \r\n    internal \r\n  {\r\n    require(tokenOwner[_tokenId] == address(0));\r\n\r\n    tokenOwner[_tokenId] = _to;\r\n    uint256 length = balanceOf(_to);\r\n    ownedTokens[_to].push(_tokenId);\r\n    ownedTokensIndex[_tokenId] = length;\r\n    totalTokens = totalTokens.add(1);\r\n  }\r\n\r\n  /*\r\n  * @notice Internal function to remove a token ID from the list of a given address\r\n  * @param _from address representing the previous owner of the given token ID\r\n  * @param _tokenId uint256 ID of the token to be removed from the tokens list of the given address\r\n  */\r\n  function _removeToken(\r\n    address _from, \r\n    uint256 _tokenId\r\n  ) \r\n    internal \r\n  {\r\n    require(ownerOf(_tokenId) == _from);\r\n\r\n    uint256 tokenIndex = ownedTokensIndex[_tokenId];\r\n    uint256 lastTokenIndex = balanceOf(_from).sub(1);\r\n    uint256 lastToken = ownedTokens[_from][lastTokenIndex];\r\n\r\n    tokenOwner[_tokenId] = address(0);\r\n    ownedTokens[_from][tokenIndex] = lastToken;\r\n    ownedTokens[_from][lastTokenIndex] = 0;\r\n    // Note that this will handle single-element arrays. In that case, both tokenIndex and lastTokenIndex are going to\r\n    // be zero. Then we can make sure that we will remove _tokenId from the ownedTokens list since we are first swapping\r\n    // the lastToken to the first position, and then dropping the element placed in the last position of the list\r\n\r\n    ownedTokens[_from].length--;\r\n    ownedTokensIndex[_tokenId] = 0;\r\n    ownedTokensIndex[lastToken] = tokenIndex;\r\n    totalTokens = totalTokens.sub(1);\r\n  }\r\n\r\n  /*\r\n   * @dev Internal function to burn a specific token\r\n   * @dev Reverts if the token does not exist\r\n   * @param _tokenId uint256 ID of the token being burned by the msg.sender\r\n   */\r\n  function _burn(\r\n    address _owner, \r\n    uint256 _tokenId\r\n  ) \r\n    internal \r\n    returns(bool) \r\n  {\r\n    require(ownerOf(_tokenId) == _owner);\r\n    _clearApproval(_owner, _tokenId);\r\n    _removeToken(_owner, _tokenId);\r\n\r\n    redTokens[_tokenId].isValid = false;\r\n\r\n    emit Transfer(_owner, address(0), _tokenId);\r\n    return true;\r\n  }\r\n}\r\n\r\n// File: contracts\\RedTokenCore.sol\r\n\r\npragma solidity 0.5.7;\r\n\r\n\r\n/*\r\n * @title RedTokenCore is the entry point of the contract\r\n * @notice RedTokenCore is the entry point and it controls the ability to set a new\r\n * contract address, in the case where an upgrade is required\r\n */\r\ncontract RedTokenCore is RedTokenOwnership{\r\n\r\n  constructor() public {\r\n    ceoAddress = msg.sender;\r\n    cooAddress = msg.sender;\r\n    cfoAddress = msg.sender;\r\n  }\r\n\r\n  function() external {\r\n    assert(false);\r\n  }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"interfaceID\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"cfoAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ceoAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newBaseURI\",\"type\":\"string\"}],\"name\":\"setTokenMetadataBaseURI\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newCEO\",\"type\":\"address\"}],\"name\":\"setCEO\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newCOO\",\"type\":\"address\"}],\"name\":\"setCOO\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"tokenOfOwnerByIndex\",\"outputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"sendAmountShareUsersFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isPausedUser\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"redTokenCreatedTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"sendAmountShareUsers\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newCFO\",\"type\":\"address\"}],\"name\":\"setCFO\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"isSenderApprovedFor\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"tokenByIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"tokensOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_user\",\"type\":\"address\"},{\"name\":\"_rmsBondNo\",\"type\":\"string\"},{\"name\":\"_bondAmount\",\"type\":\"uint256\"},{\"name\":\"_listingAmount\",\"type\":\"uint256\"}],\"name\":\"createRedToken\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"unpauseUser\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"isValidRedToken\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"redTokenBondAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"redTokenRmsBondNo\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"cooAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"redTokenListingAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"pauseUser\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"redTokenCollectedAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"burnAmountByShareUser\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"name\":\"infoUrl\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"redTokenInfoOfshareUsers\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"},{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"updateCollectedAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"redTokenInfo\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"string\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"calculateShareUsers\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"CollectedAmountUpdate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_approved\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_operator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"PausedUser\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"UnpausedUser\",\"type\":\"event\"}]","ContractName":"RedTokenCore","CompilerVersion":"v0.5.7+commit.6da8b019","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://e7f8f77f72300729dd2cf3325611b3a116af384248112dfac6f8a7f8738f5e6e"}]}