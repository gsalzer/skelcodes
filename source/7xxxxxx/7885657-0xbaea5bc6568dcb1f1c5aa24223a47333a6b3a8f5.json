{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.5;\r\n\r\n/*\r\n    This contract is open source under the MIT license\r\n    Ethfinex Inc - 2019\r\n\r\n/*\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Unsigned math operations with safety checks that revert on error.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Multiplies two unsigned integers, reverts on overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Adds two unsigned integers, reverts on overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\r\n     * reverts when dividing by zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n     * account.\r\n     */\r\n    constructor () internal {\r\n        _owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), _owner);\r\n    }\r\n\r\n    /**\r\n     * @return the address of the owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner());\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @return true if `msg.sender` is the owner of the contract.\r\n     */\r\n    function isOwner() public view returns (bool) {\r\n        return msg.sender == _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to relinquish control of the contract.\r\n     * It will not be possible to call the functions with the `onlyOwner`\r\n     * modifier anymore.\r\n     * @notice Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0));\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\n\r\ninterface Token {\r\n\r\n    function transfer(address _to, uint _value) external returns (bool);\r\n    function transferFrom(address _from, address _to, uint _value) external returns (bool);\r\n    function approve(address _spender, uint _value) external returns (bool);\r\n    function balanceOf(address _owner) external view returns (uint);\r\n    function allowance(address _owner, address _spender) external view returns (uint);\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint _value); // solhint-disable-line\r\n    event Approval(address indexed _owner, address indexed _spender, uint _value);\r\n}\r\n\r\ninterface TokenNoReturn {\r\n\r\n    function transfer(address _to, uint _value) external;\r\n    function transferFrom(address _from, address _to, uint _value) external;\r\n    function balanceOf(address _owner) external view returns (uint);\r\n}\r\n\r\ncontract TrustlessOTC is Ownable {\r\n    using SafeMath for uint256;\r\n\r\n    mapping(address => uint256) public balanceTracker;\r\n    mapping(address => uint256) public feeTracker;\r\n    mapping(address => uint[]) public tradeTracker;\r\n\r\n    mapping(address => bool) public noERC20Return;\r\n\r\n    event OfferCreated(uint indexed tradeID);\r\n    event OfferCancelled(uint indexed tradeID);\r\n    event OfferTaken(uint indexed tradeID);\r\n\r\n    uint256 public feeBasisPoints;\r\n\r\n    constructor (uint256 _feeBasisPoints) public {\r\n      feeBasisPoints = _feeBasisPoints;\r\n      noERC20Return[0xdAC17F958D2ee523a2206206994597C13D831ec7] = true;\r\n      noERC20Return[0xB97048628DB6B661D4C2aA833e95Dbe1A905B280] = true;\r\n      noERC20Return[0x4470BB87d77b963A013DB939BE332f927f2b992e] = true;\r\n      noERC20Return[0xd26114cd6EE289AccF82350c8d8487fedB8A0C07] = true;\r\n      noERC20Return[0xB8c77482e45F1F44dE1745F52C74426C631bDD52] = true;\r\n      noERC20Return[0xF433089366899D83a9f26A773D59ec7eCF30355e] = true;\r\n      noERC20Return[0xe3818504c1B32bF1557b16C238B2E01Fd3149C17] = true;\r\n      noERC20Return[0x81c9151de0C8bafCd325a57E3dB5a5dF1CEBf79c] = true;\r\n    }\r\n\r\n    struct TradeOffer {\r\n        address tokenFrom;\r\n        address tokenTo;\r\n        uint256 amountFrom;\r\n        uint256 amountTo;\r\n        address payable creator;\r\n        address optionalTaker;\r\n        bool active;\r\n        bool completed;\r\n        uint tradeID;\r\n    }\r\n\r\n    TradeOffer[] public offers;\r\n\r\n    function initiateTrade(\r\n        address _tokenFrom,\r\n        address _tokenTo,\r\n        uint256 _amountFrom,\r\n        uint256 _amountTo,\r\n        address _optionalTaker\r\n        ) public payable returns (uint newTradeID) {\r\n            if (_tokenFrom == address(0)) {\r\n                require(msg.value == _amountFrom);\r\n            } else {\r\n                require(msg.value == 0);\r\n                if(noERC20Return[_tokenFrom]) {\r\n                  TokenNoReturn(_tokenFrom).transferFrom(msg.sender, address(this), _amountFrom);\r\n                } else {\r\n                  Token(_tokenFrom).transferFrom(msg.sender, address(this), _amountFrom);\r\n                }\r\n            }\r\n            newTradeID = offers.length;\r\n            offers.length++;\r\n            TradeOffer storage o = offers[newTradeID];\r\n            balanceTracker[_tokenFrom] = balanceTracker[_tokenFrom].add(_amountFrom);\r\n            o.tokenFrom = _tokenFrom;\r\n            o.tokenTo = _tokenTo;\r\n            o.amountFrom = _amountFrom;\r\n            o.amountTo = _amountTo;\r\n            o.creator = msg.sender;\r\n            o.optionalTaker = _optionalTaker;\r\n            o.active = true;\r\n            o.tradeID = newTradeID;\r\n            tradeTracker[msg.sender].push(newTradeID);\r\n            emit OfferCreated(newTradeID);\r\n    }\r\n\r\n    function cancelTrade(uint tradeID) public returns (bool) {\r\n        TradeOffer storage o = offers[tradeID];\r\n        require(msg.sender == o.creator);\r\n        if (o.tokenFrom == address(0)) {\r\n          msg.sender.transfer(o.amountFrom);\r\n        } else {\r\n          if(noERC20Return[o.tokenFrom]) {\r\n            TokenNoReturn(o.tokenFrom).transfer(o.creator, o.amountFrom);\r\n          } else {\r\n            Token(o.tokenFrom).transfer(o.creator, o.amountFrom);\r\n          }\r\n        }\r\n        balanceTracker[o.tokenFrom] -= o.amountFrom;\r\n        o.active = false;\r\n        emit OfferCancelled(tradeID);\r\n        return true;\r\n    }\r\n\r\n    function take(uint tradeID) public payable returns (bool) {\r\n        TradeOffer storage o = offers[tradeID];\r\n        require(o.optionalTaker == msg.sender || o.optionalTaker == address(0));\r\n        require(o.active == true);\r\n        o.active = false;\r\n        balanceTracker[o.tokenFrom] = balanceTracker[o.tokenFrom].sub(o.amountFrom);\r\n        uint256 fee = o.amountFrom.mul(feeBasisPoints).div(10000);\r\n        feeTracker[o.tokenFrom] = feeTracker[o.tokenFrom].add(fee);\r\n        tradeTracker[msg.sender].push(tradeID);\r\n\r\n        if (o.tokenFrom == address(0)) {\r\n            msg.sender.transfer(o.amountFrom.sub(fee));\r\n        } else {\r\n          if(noERC20Return[o.tokenFrom]) {\r\n            TokenNoReturn(o.tokenFrom).transfer(msg.sender, o.amountFrom.sub(fee));\r\n          } else {\r\n            Token(o.tokenFrom).transfer(msg.sender, o.amountFrom.sub(fee));\r\n          }\r\n        }\r\n\r\n        if (o.tokenTo == address(0)) {\r\n            require(msg.value == o.amountTo);\r\n            o.creator.transfer(msg.value);\r\n        } else {\r\n            require(msg.value == 0);\r\n            if(noERC20Return[o.tokenTo]) {\r\n              TokenNoReturn(o.tokenTo).transferFrom(msg.sender, o.creator, o.amountTo);\r\n            } else {\r\n              Token(o.tokenTo).transferFrom(msg.sender, o.creator, o.amountTo);\r\n            }\r\n        }\r\n        o.completed = true;\r\n        emit OfferTaken(tradeID);\r\n        return true;\r\n    }\r\n\r\n    function getOfferDetails(uint tradeID) external view returns (\r\n        address _tokenFrom,\r\n        address _tokenTo,\r\n        uint256 _amountFrom,\r\n        uint256 _amountTo,\r\n        address _creator,\r\n        uint256 _fee,\r\n        bool _active,\r\n        bool _completed\r\n    ) {\r\n        TradeOffer storage o = offers[tradeID];\r\n        _tokenFrom = o.tokenFrom;\r\n        _tokenTo = o.tokenTo;\r\n        _amountFrom = o.amountFrom;\r\n        _amountTo = o.amountTo;\r\n        _creator = o.creator;\r\n        _fee = o.amountFrom.mul(feeBasisPoints).div(10000);\r\n        _active = o.active;\r\n        _completed = o.completed;\r\n    }\r\n\r\n    function getUserTrades(address user) external view returns (uint[] memory){\r\n      return tradeTracker[user];\r\n    }\r\n\r\n    function reclaimToken(Token _token) external onlyOwner {\r\n        uint256 balance = _token.balanceOf(address(this));\r\n        uint256 excess = balance.sub(balanceTracker[address(_token)]);\r\n        require(excess > 0);\r\n        if (address(_token) == address(0)) {\r\n            msg.sender.transfer(excess);\r\n        } else {\r\n            _token.transfer(owner(), excess);\r\n        }\r\n    }\r\n\r\n    function reclaimTokenNoReturn(TokenNoReturn _token) external onlyOwner {\r\n        uint256 balance = _token.balanceOf(address(this));\r\n        uint256 excess = balance.sub(balanceTracker[address(_token)]);\r\n        require(excess > 0);\r\n        if (address(_token) == address(0)) {\r\n            msg.sender.transfer(excess);\r\n        } else {\r\n            _token.transfer(owner(), excess);\r\n        }\r\n    }\r\n\r\n    function claimFees(Token _token) external onlyOwner {\r\n        uint256 feesToClaim = feeTracker[address(_token)];\r\n        feeTracker[address(_token)] = 0;\r\n        require(feesToClaim > 0);\r\n        if (address(_token) == address(0)) {\r\n            msg.sender.transfer(feesToClaim);\r\n        } else {\r\n            _token.transfer(owner(), feesToClaim);\r\n        }\r\n    }\r\n\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"tradeID\",\"type\":\"uint256\"}],\"name\":\"cancelTrade\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenFrom\",\"type\":\"address\"},{\"name\":\"_tokenTo\",\"type\":\"address\"},{\"name\":\"_amountFrom\",\"type\":\"uint256\"},{\"name\":\"_amountTo\",\"type\":\"uint256\"},{\"name\":\"_optionalTaker\",\"type\":\"address\"}],\"name\":\"initiateTrade\",\"outputs\":[{\"name\":\"newTradeID\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"noERC20Return\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"claimFees\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"reclaimToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tradeTracker\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tradeID\",\"type\":\"uint256\"}],\"name\":\"getOfferDetails\",\"outputs\":[{\"name\":\"_tokenFrom\",\"type\":\"address\"},{\"name\":\"_tokenTo\",\"type\":\"address\"},{\"name\":\"_amountFrom\",\"type\":\"uint256\"},{\"name\":\"_amountTo\",\"type\":\"uint256\"},{\"name\":\"_creator\",\"type\":\"address\"},{\"name\":\"_fee\",\"type\":\"uint256\"},{\"name\":\"_active\",\"type\":\"bool\"},{\"name\":\"_completed\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tradeID\",\"type\":\"uint256\"}],\"name\":\"take\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"feeTracker\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"offers\",\"outputs\":[{\"name\":\"tokenFrom\",\"type\":\"address\"},{\"name\":\"tokenTo\",\"type\":\"address\"},{\"name\":\"amountFrom\",\"type\":\"uint256\"},{\"name\":\"amountTo\",\"type\":\"uint256\"},{\"name\":\"creator\",\"type\":\"address\"},{\"name\":\"optionalTaker\",\"type\":\"address\"},{\"name\":\"active\",\"type\":\"bool\"},{\"name\":\"completed\",\"type\":\"bool\"},{\"name\":\"tradeID\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getUserTrades\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceTracker\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"feeBasisPoints\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"reclaimTokenNoReturn\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_feeBasisPoints\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"tradeID\",\"type\":\"uint256\"}],\"name\":\"OfferCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"tradeID\",\"type\":\"uint256\"}],\"name\":\"OfferCancelled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"tradeID\",\"type\":\"uint256\"}],\"name\":\"OfferTaken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"TrustlessOTC","CompilerVersion":"v0.5.5+commit.47a71e8f","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000000000000000000000000000000000000000000002","Library":"","SwarmSource":"bzzr://6f746ce8bac8fdc64a6bfb304404274f16f0fc7ed44a0477223a33ee930494ec"}]}