{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.25;\r\n\r\ncontract NTA3DEvents {\r\n\r\n    event onWithdraw\r\n    (\r\n        uint256 indexed playerID,\r\n        address playerAddress,\r\n        bytes32 playerName,\r\n        uint256 ethOut,\r\n        uint256 timeStamp\r\n    );\r\n\r\n    event onBuyKey\r\n    (\r\n        uint256 indexed playerID,\r\n        address indexed playerAddress,\r\n        bytes32 indexed playerName,\r\n        uint256 roundID,\r\n        uint256 ethIn,\r\n        uint256 keys,\r\n        uint256 timeStamp\r\n    );\r\n\r\n    event onBuyCard\r\n    (\r\n        uint256 indexed playerID,\r\n        address indexed playerAddress,\r\n        bytes32 indexed playerName,\r\n        uint256 cardID,\r\n        uint256 ethIn,\r\n        uint256 timeStamp\r\n    );\r\n\r\n    event onRoundEnd\r\n    (\r\n        address winnerAddr,\r\n        bytes32 winnerName,\r\n        uint256 roundID,\r\n        uint256 amountWon,\r\n        uint256 newPot,\r\n        uint256 timeStamp\r\n    );\r\n\r\n    event onDrop\r\n    (\r\n        address dropwinner,\r\n        bytes32 winnerName,\r\n        uint256 roundID,\r\n        uint256 droptype, //0:smalldrop 1:bigdop\r\n        uint256 win,\r\n        uint256 timeStamp\r\n    );\r\n\r\n}\r\n\r\ncontract NTA3D is NTA3DEvents {\r\n    using SafeMath for *;\r\n    using NameFilter for string;\r\n    using NTA3DKeysCalc for uint256;\r\n\r\n    string constant public name = \"No Tricks Allow 3D\";\r\n    string constant public symbol = \"NTA3D\";\r\n    bool activated_;\r\n    address admin;\r\n    uint256 constant private rndStarts = 12 hours; // ??need to be continue\r\n    uint256 constant private rndPerKey = 15 seconds; // every key increase seconds\r\n    uint256 constant private rndMax = 12 hours;  //max count down time;\r\n    uint256 constant private cardValidity = 1 hours; //stock cards validity\r\n    uint256 constant private cardPrice = 0.05 ether; //stock cards validity\r\n    uint256 constant private DIVIDE = 1000; // common divide tool\r\n\r\n    uint256 constant private smallDropTrigger = 50 ether;\r\n    uint256 constant private bigDropTrigger = 300000 * 1e18;\r\n    uint256 constant private keyPriceTrigger = 50000 * 1e18;\r\n    uint256 constant private keyPriceFirst = 0.0005 ether;\r\n    uint256 constant private oneOffInvest1 = 0.1 ether;//VIP 1\r\n    uint256 constant private oneOffInvest2 = 1 ether;// VIP 2\r\n\r\n    //uint256 public airDropTracker_ = 0;\r\n    uint256 public rID;    // round id number / total rounds that have happened\r\n    uint256 public pID;    // total players\r\n\r\n    //player map data\r\n    mapping (address => uint256) public pIDxAddr; // get pid by address\r\n    mapping (bytes32 => uint256) public pIDxName; // get name by pid\r\n    mapping (uint256 => NTAdatasets.Player) public pIDPlayer; // get player struct by pid\\\r\n    mapping (uint256 => mapping (uint256 => NTAdatasets.PlayerRound)) public pIDPlayerRound; // pid => rid => playeround\r\n\r\n    //stock cards\r\n    mapping (uint256 => NTAdatasets.Card) cIDCard; //get card by cID\r\n    address cardSeller;\r\n\r\n    //team map data\r\n    //address gameFundsAddr = 0xFD7A82437F7134a34654D7Cb8F79985Df72D7076;\r\n    address[11] partner;\r\n    address to06;\r\n    address to04;\r\n    address to20A;\r\n    address to20B;\r\n    mapping (address => uint256) private gameFunds; // game develeopment get 5% funds\r\n    //uint256 private teamFee;    // team Fee 5%\r\n\r\n    //round data\r\n    mapping (uint256 => NTAdatasets.Round) public rIDRound;   // round data\r\n\r\n    // team dividens\r\n    mapping (uint256 => NTAdatasets.Deposit) public deposit;\r\n    mapping (uint256 => NTAdatasets.PotSplit) public potSplit;\r\n\r\n    constructor() public {\r\n\r\n        //constructor\r\n        activated_ = false;\r\n        admin = msg.sender;\r\n        // Team allocation structures\r\n        // 0 = BISHOP\r\n        // 1 = ROOK\r\n                // BISHOP team: ==> |46% to all, 17% to winnerPot, 5% to develop funds, 5% to teamfee, 10% to cards,\r\n        //                  |7% to fisrt degree invatation\r\n        //                  |3% to second degree invatation, 2% to big airdrop, 5% to small airdrop\r\n        deposit[0] = NTAdatasets.Deposit(460, 170, 50, 50, 100, 100, 20, 50);\r\n        // ROOK team:   ==> |20% to all, 43% to winnerPot, 5% to develop funds, 5% to teamfee, 10% to cards,\r\n        //                  |7% to fisrt degree invatation\r\n        //                  |3% to second degree invatation, 2% to big airdrop, 5% to small airdrop\r\n        deposit[1] = NTAdatasets.Deposit(200, 430, 50, 50, 100, 100, 20, 50);\r\n\r\n        // potSplit:    ==> |20% to all, 45% to lastwinner, 5% to inviter 1st, 3% to inviter 2nd, 2% to inviter 3rd,\r\n        //                  |8% to key buyer 1st, 5% to key buyer 2nd, 2% to key buyer 3rd, 10% to next round\r\n        potSplit[0] = NTAdatasets.PotSplit(200, 450, 50, 30, 20, 80, 50, 20, 100);\r\n        potSplit[1] = NTAdatasets.PotSplit(200, 450, 50, 30, 20, 80, 50, 20, 100);\r\n    }\r\n\r\n//==============================================================================\r\n//\r\n//    safety checks\r\n//==============================================================================\r\n    //tested\r\n    modifier isActivated() {\r\n        require(activated_ == true, \"its not ready yet\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev prevents contracts from interacting with fomo3d\r\n     */\r\n    //tested\r\n    modifier isHuman() {\r\n        address _addr = msg.sender;\r\n        uint256 _codeLength;\r\n\r\n        assembly {_codeLength := extcodesize(_addr)}\r\n        require(_codeLength == 0, \"sorry humans only\");\r\n        _;\r\n    }\r\n    //tested\r\n    modifier isAdmin() {require(msg.sender == admin, \"its can only be call by admin\");_;}\r\n\r\n    /**\r\n     * @dev sets boundaries for incoming tx\r\n     */\r\n    //tested\r\n    modifier isWithinLimits(uint256 _eth) {\r\n        require(_eth >= 1000000000, \"pocket lint: not a valid currency\");\r\n        require(_eth <= 100000000000000000000000, \"no vitalik, no\");\r\n        _;\r\n    }\r\n\r\n//==============================================================================\r\n//\r\n//    admin functions\r\n//==============================================================================\r\n    //tested\r\n    function activeNTA() isAdmin() public {\r\n        activated_ = true;\r\n        partner[0] = 0xE27Aa5E7D8906779586CfB9DbA2935BDdd7c8210;\r\n        partner[1] = 0xD4638827Dc486cb59B5E5e47955059A160BaAE13;\r\n        partner[2] = 0xa088c667591e04cC78D6dfA3A392A132dc5A7f9d;\r\n        partner[3] = 0xed38deE26c751ff575d68D9Bf93C312e763f8F87;\r\n        partner[4] = 0x42A7B62f71b7778279DA2639ceb5DD6ee884f905;\r\n        partner[5] = 0xd471409F3eFE9Ca24b63855005B08D4548742a5b;\r\n        partner[6] = 0x41c9F005eD19C2B620152f5562D26029b32078B6;\r\n        partner[7] = 0x11b85bc860A6C38fa7fe6f54f18d350eF5f2787b;\r\n        partner[8] = 0x11a7c5E7887F2C34356925275882D4321a6B69A8;\r\n        partner[9] = 0xB5754c7bD005b6F25e1FDAA5f94b2b71e6eA260f;\r\n        partner[10] = 0x6fbC15cF6d0B05280E99f753E45B631815715E99;\r\n        to06 = 0x9B53CC857cD9DD5EbE6bc07Bde67D8CE4076345f;\r\n        to04 = 0x5835a72118c0C784203B8d39936A0875497B6eCa;\r\n        to20A = 0xEc2441D3113fC2376cd127344331c0F1b959Ce1C;\r\n        to20B = 0xd1Dac908c97c0a885e9B413a84ACcC0010C002d2;\r\n        //card\r\n        cardSeller = 0xeE4f032bdB0f9B51D6c7035d3DEFfc217D91225C;\r\n    }\r\n    //tested\r\n    function startFirstRound() isAdmin() isActivated() public {\r\n        //must not open before\r\n        require(rID == 0);\r\n        newRound(0);\r\n    }\r\n\r\n    function teamWithdraw() public\r\n    isHuman()\r\n    isActivated()\r\n    {\r\n        uint256 _temp;\r\n        address to = msg.sender;\r\n        require(gameFunds[to] != 0, \"you dont have funds\");\r\n        _temp = gameFunds[to];\r\n        gameFunds[to] = 0;\r\n        to.transfer(_temp);\r\n    }\r\n\r\n    function getTeamFee(address _addr)\r\n    public\r\n    view\r\n    returns(uint256) {\r\n        return gameFunds[_addr];\r\n    }\r\n\r\n    function getScore(address _addr)\r\n    public\r\n    view\r\n    isAdmin()\r\n    returns(uint256) {\r\n        uint256 _pID = pIDxAddr[_addr];\r\n        if(_pID == 0 ) return 0;\r\n        else return pIDPlayerRound[_pID][rID].score;\r\n    }\r\n\r\n    function setInviterCode(address _addr, uint256 _inv, uint256 _vip, string _nameString)\r\n    public\r\n    isAdmin() {\r\n        //this is for popularzing channel\r\n        bytes32 _name = _nameString.nameFilter();\r\n        uint256 temp = pIDxName[_name];\r\n        require(temp == 0, \"name already regist\");\r\n        uint256 _pID = pIDxAddr[_addr];\r\n        if(_pID == 0) {\r\n            pID++;\r\n            _pID = pID;\r\n            pIDxAddr[_addr] = _pID;\r\n            pIDPlayer[_pID].addr = _addr;\r\n            pIDPlayer[_pID].name = _name;\r\n            pIDxName[_name] = _pID;\r\n            pIDPlayer[_pID].inviter1 = _inv;\r\n            pIDPlayer[_pID].vip = _vip;\r\n        } else {\r\n            if(_inv != 0)\r\n                pIDPlayer[_pID].inviter1 = _inv;\r\n            pIDPlayer[_pID].name = _name;\r\n            pIDxName[_name] = _pID;\r\n            pIDPlayer[_pID].vip = _vip;\r\n        }\r\n    }\r\n\r\n//==============================================================================\r\n//\r\n//    player functions\r\n//==============================================================================\r\n    //emergency buy uses BISHOP team to buy keys\r\n    function()\r\n    isActivated()\r\n    isHuman()\r\n    isWithinLimits(msg.value)\r\n    public\r\n    payable\r\n    {\r\n        //fetch player\r\n        require(rID != 0, \"No round existed yet\");\r\n        uint256 _pID = managePID(0);\r\n        //buy key\r\n        buyCore(_pID, 0);\r\n    }\r\n\r\n    // buy with ID: inviter use pID to invate player to buy like \"www.NTA3D.io/?id=101\"\r\n    function buyXid(uint256 _team,uint256 _inviter)\r\n    isActivated()\r\n    isHuman()\r\n    isWithinLimits(msg.value)\r\n    public\r\n    payable\r\n    {\r\n        require(rID != 0, \"No round existed yet\");\r\n        uint256 _pID = managePID(_inviter);\r\n        if (_team < 0 || _team > 1 ) {\r\n            _team = 0;\r\n        }\r\n        buyCore(_pID, _team);\r\n    }\r\n\r\n    // buy with ID: inviter use pID to invate player to buy like \"www.NTA3D.io/?n=obama\"\r\n    function buyXname(uint256 _team,string _invName)\r\n    isActivated()\r\n    isHuman()\r\n    isWithinLimits(msg.value)\r\n    public\r\n    payable\r\n    {\r\n        require(rID != 0, \"No round existed yet\");\r\n        bytes32 _name = _invName.nameFilter();\r\n        uint256 _invPID = pIDxName[_name];\r\n        uint256 _pID = managePID(_invPID);\r\n        if (_team < 0 || _team > 1 ) {\r\n            _team = 0;\r\n        }\r\n        buyCore(_pID, _team);\r\n    }\r\n\r\n    function buyCardXname(uint256 _cID, string _invName)\r\n    isActivated()\r\n    isHuman()\r\n    isWithinLimits(msg.value)\r\n    public\r\n    payable {\r\n        uint256 _value = msg.value;\r\n        uint256 _now = now;\r\n        require(_cID < 20, \"only has 20 cards\");\r\n        require(_value == cardPrice, \"the card cost 0.05 ether\");\r\n        require(cIDCard[_cID].owner == 0 || (cIDCard[_cID].buyTime + cardValidity) < _now, \"card is in used\");\r\n        bytes32 _name = _invName.nameFilter();\r\n        uint256 _invPID = pIDxName[_name];\r\n        uint256 _pID = managePID(_invPID);\r\n        for (uint i = 0; i < 20; i++) {\r\n            require(_pID != cIDCard[i].owner, \"you already registed a card\");\r\n        }\r\n        gameFunds[cardSeller] = gameFunds[cardSeller].add(_value);\r\n        cIDCard[_cID].addr = msg.sender;\r\n        cIDCard[_cID].owner = _pID;\r\n        cIDCard[_cID].buyTime = _now;\r\n        cIDCard[_cID].earnings = 0;\r\n        emit onBuyCard(_pID, pIDPlayer[_pID].addr, pIDPlayer[_pID].name, _cID, _value, now);\r\n    }\r\n\r\n    function buyCardXid(uint256 _cID, uint256 _inviter)\r\n    isActivated()\r\n    isHuman()\r\n    isWithinLimits(msg.value)\r\n    public\r\n    payable {\r\n        uint256 _value = msg.value;\r\n        uint256 _now = now;\r\n        require(_cID < 20, \"only has 20 cards\");\r\n        require(_value == cardPrice, \"the card cost 0.05 ether\");\r\n        require(cIDCard[_cID].owner == 0 || (cIDCard[_cID].buyTime + cardValidity) < _now, \"card is in used\");\r\n        uint256 _pID = managePID(_inviter);\r\n        for (uint i = 0; i < 20; i++) {\r\n            require(_pID != cIDCard[i].owner, \"you already registed a card\");\r\n        }\r\n        gameFunds[cardSeller] = gameFunds[cardSeller].add(_value);\r\n        cIDCard[_cID].addr = msg.sender;\r\n        cIDCard[_cID].owner = _pID;\r\n        cIDCard[_cID].buyTime = _now;\r\n        cIDCard[_cID].earnings = 0;\r\n        emit onBuyCard(_pID, pIDPlayer[_pID].addr, pIDPlayer[_pID].name, _cID, _value, now);\r\n    }\r\n\r\n\r\n    // regist a name\r\n    function registNameXid(string _nameString, uint256 _inviter)\r\n    isActivated()\r\n    isHuman()\r\n    public {\r\n        bytes32 _name = _nameString.nameFilter();\r\n        uint256 temp = pIDxName[_name];\r\n        require(temp == 0, \"name already regist\");\r\n        uint256 _pID = managePID(_inviter);\r\n        pIDxName[_name] = _pID;\r\n        pIDPlayer[_pID].name = _name;\r\n    }\r\n\r\n    function registNameXname(string _nameString, string _inviterName)\r\n    isActivated()\r\n    isHuman()\r\n    public {\r\n        bytes32 _name = _nameString.nameFilter();\r\n        uint256 temp = pIDxName[_name];\r\n        require(temp == 0, \"name already regist\");\r\n        bytes32 _invName = _inviterName.nameFilter();\r\n        uint256 _invPID = pIDxName[_invName];\r\n        uint256 _pID = managePID(_invPID);\r\n        pIDxName[_name] = _pID;\r\n        pIDPlayer[_pID].name = _name;\r\n    }\r\n\r\n    function withdraw()\r\n    isActivated()\r\n    isHuman()\r\n    public {\r\n        // setup local rID\r\n        uint256 _rID = rID;\r\n        // grab time\r\n        uint256 _now = now;\r\n        uint256 _pID = pIDxAddr[msg.sender];\r\n        require(_pID != 0, \"cant find user\");\r\n        uint256 _eth = 0;\r\n        if (rIDRound[_rID].end < _now && rIDRound[_rID].ended == false) {\r\n            rIDRound[_rID].ended = true;\r\n            endRound();\r\n        }\r\n        // get their earnings\r\n        _eth = withdrawEarnings(_pID);\r\n        // gib moni\r\n        if (_eth > 0)\r\n            pIDPlayer[_pID].addr.transfer(_eth);\r\n        //emit\r\n        emit onWithdraw(_pID, pIDPlayer[_pID].addr, pIDPlayer[_pID].name, _eth, now);\r\n    }\r\n//==============================================================================\r\n//\r\n//    view functions\r\n//==============================================================================\r\n    /**\r\n     * return the price buyer will pay for next 1 individual key.\r\n     * @return price for next key bought (in wei format)\r\n     */\r\n     //tested\r\n    function getBuyPrice(uint256 _key)\r\n    public\r\n    view\r\n    returns(uint256) {\r\n        // setup local rID\r\n        uint256 _rID = rID;\r\n        // grab time\r\n        uint256 _now = now;\r\n        uint256 _keys = rIDRound[_rID].team1Keys + rIDRound[_rID].team2Keys;\r\n        // round is active\r\n        if (rIDRound[_rID].end >= _now || (rIDRound[_rID].end < _now && rIDRound[_rID].leadPID == 0))\r\n            return _keys.ethRec(_key * 1e18);\r\n        else\r\n            return keyPriceFirst;\r\n    }\r\n\r\n    /**\r\n     * @dev returns time left.  dont spam this, you'll ddos yourself from your node\r\n     * @return time left in seconds\r\n     */\r\n     //tested\r\n    function getTimeLeft()\r\n    public\r\n    view\r\n    returns(uint256) {\r\n        // setup local rID\r\n        uint256 _rID = rID;\r\n        // grab time\r\n        uint256 _now = now;\r\n\r\n        if (rIDRound[_rID].end >= _now)\r\n            return (rIDRound[_rID].end.sub(_now));\r\n        else\r\n            return 0;\r\n    }\r\n\r\n    //tested\r\n    function getPlayerVaults()\r\n    public\r\n    view\r\n    returns(uint256, uint256, uint256, uint256, uint256) {\r\n        // setup local rID\r\n        uint256 _rID = rID;\r\n        uint256 _now = now;\r\n        uint256 _pID = pIDxAddr[msg.sender];\r\n        if (_pID == 0)\r\n            return (0, 0, 0, 0, 0);\r\n        uint256 _last = pIDPlayer[_pID].lrnd;\r\n        uint256 _inv = pIDPlayerRound[_pID][_last].inv;\r\n        uint256 _invMask = pIDPlayerRound[_pID][_last].invMask;\r\n        // if round has ended.  but round end has not been run (so contract has not distributed winnings)\r\n        if (rIDRound[_rID].end < _now && rIDRound[_rID].ended == false && rIDRound[_rID].leadPID != 0) {\r\n            // if player is winner\r\n            if (rIDRound[_rID].leadPID == _pID)\r\n                return (\r\n                    (pIDPlayer[_pID].win).add((rIDRound[_rID].pot).mul(45) / 100),\r\n                    pIDPlayer[_pID].gen.add(calcUnMaskedEarnings(_pID, pIDPlayer[_pID].lrnd)),\r\n                    pIDPlayer[_pID].inv.add(_inv).sub0(_invMask),\r\n                    pIDPlayer[_pID].tim.add(calcTeamEarnings(_pID, pIDPlayer[_pID].lrnd)),\r\n                    pIDPlayer[_pID].crd\r\n                );\r\n            else\r\n                return (\r\n                    pIDPlayer[_pID].win,\r\n                    pIDPlayer[_pID].gen.add(calcUnMaskedEarnings(_pID, pIDPlayer[_pID].lrnd)),\r\n                    pIDPlayer[_pID].inv.add(_inv).sub0(_invMask),\r\n                    pIDPlayer[_pID].tim.add(calcTeamEarnings(_pID, pIDPlayer[_pID].lrnd)),\r\n                    pIDPlayer[_pID].crd\r\n                );\r\n        } else {\r\n             return (\r\n                    pIDPlayer[_pID].win,\r\n                    pIDPlayer[_pID].gen.add(calcUnMaskedEarnings(_pID, pIDPlayer[_pID].lrnd)),\r\n                    pIDPlayer[_pID].inv.add(_inv).sub0(_invMask),\r\n                    pIDPlayer[_pID].tim.add(calcTeamEarnings(_pID, pIDPlayer[_pID].lrnd)),\r\n                    pIDPlayer[_pID].crd\r\n                );\r\n        }\r\n    }\r\n\r\n    function getCurrentRoundInfo()\r\n    public\r\n    view\r\n    returns(uint256, uint256, uint256, uint256, uint256, uint256, uint256, address, bytes32, uint256, uint256, uint256) {\r\n        // setup local rID\r\n        uint256 _rID = rID;\r\n        return(_rID,\r\n            rIDRound[_rID].team1Keys + rIDRound[_rID].team2Keys,    //total key\r\n            rIDRound[_rID].eth,      //total eth\r\n            rIDRound[_rID].strt,     //start time\r\n            rIDRound[_rID].end,      //end time\r\n            rIDRound[_rID].pot,      //last winer pot\r\n            rIDRound[_rID].leadPID,  //current last player\r\n            pIDPlayer[rIDRound[_rID].leadPID].addr, //cureest last player address\r\n            pIDPlayer[rIDRound[_rID].leadPID].name, //cureest last player name\r\n            rIDRound[_rID].smallDrop,\r\n            rIDRound[_rID].bigDrop,\r\n            rIDRound[_rID].teamPot   //teampot\r\n            );\r\n    }\r\n\r\n    function getRankList()\r\n    public\r\n    view\r\n            //invitetop3   amout      keyTop3      key\r\n    returns (address[3], uint256[3], bytes32[3], address[3], uint256[3], bytes32[3]) {\r\n        uint256 _rID = rID;\r\n        address[3] memory inv;\r\n        address[3] memory key;\r\n        bytes32[3] memory invname;\r\n        uint256[3] memory invRef;\r\n        uint256[3] memory keyamt;\r\n        bytes32[3] memory keyname;\r\n        inv[0] = pIDPlayer[rIDRound[_rID].invTop3[0]].addr;\r\n        inv[1] = pIDPlayer[rIDRound[_rID].invTop3[1]].addr;\r\n        inv[2] = pIDPlayer[rIDRound[_rID].invTop3[2]].addr;\r\n        invRef[0] = pIDPlayerRound[rIDRound[_rID].invTop3[0]][_rID].inv;\r\n        invRef[1] = pIDPlayerRound[rIDRound[_rID].invTop3[1]][_rID].inv;\r\n        invRef[2] = pIDPlayerRound[rIDRound[_rID].invTop3[2]][_rID].inv;\r\n        invname[0] = pIDPlayer[rIDRound[_rID].invTop3[0]].name;\r\n        invname[1] = pIDPlayer[rIDRound[_rID].invTop3[1]].name;\r\n        invname[2] = pIDPlayer[rIDRound[_rID].invTop3[2]].name;\r\n\r\n        key[0] = pIDPlayer[rIDRound[_rID].keyTop3[0]].addr;\r\n        key[1] = pIDPlayer[rIDRound[_rID].keyTop3[1]].addr;\r\n        key[2] = pIDPlayer[rIDRound[_rID].keyTop3[2]].addr;\r\n        keyamt[0] = pIDPlayerRound[rIDRound[_rID].keyTop3[0]][_rID].team1Keys + pIDPlayerRound[rIDRound[_rID].keyTop3[0]][_rID].team2Keys;\r\n        keyamt[1] = pIDPlayerRound[rIDRound[_rID].keyTop3[1]][_rID].team1Keys + pIDPlayerRound[rIDRound[_rID].keyTop3[1]][_rID].team2Keys;\r\n        keyamt[2] = pIDPlayerRound[rIDRound[_rID].keyTop3[2]][_rID].team1Keys + pIDPlayerRound[rIDRound[_rID].keyTop3[2]][_rID].team2Keys;\r\n        keyname[0] = pIDPlayer[rIDRound[_rID].keyTop3[0]].name;\r\n        keyname[1] = pIDPlayer[rIDRound[_rID].keyTop3[1]].name;\r\n        keyname[2] = pIDPlayer[rIDRound[_rID].keyTop3[2]].name;\r\n\r\n        return (inv, invRef, invname, key, keyamt, keyname);\r\n    }\r\n\r\n    /**\r\n     * @dev returns player info based on address.  if no address is given, it will\r\n     * use msg.sender\r\n     * -functionhash- 0xee0b5d8b\r\n     * @param _addr address of the player you want to lookup\r\n     * @return player ID\r\n     * @return player name\r\n     * @return keys owned (current round)\r\n     * @return winnings vault\r\n     * @return general vault\r\n     * @return affiliate vault\r\n\t * @return player round eth\r\n     */\r\n    //tested\r\n    function getPlayerInfoByAddress(address _addr)\r\n        public\r\n        view\r\n        returns(uint256, bytes32, uint256, uint256, uint256)\r\n    {\r\n        // setup local rID\r\n        uint256 _rID = rID;\r\n\r\n        if (_addr == address(0))\r\n        {\r\n            _addr == msg.sender;\r\n        }\r\n        uint256 _pID = pIDxAddr[_addr];\r\n        if (_pID == 0)\r\n            return (0, 0x0, 0, 0, 0);\r\n        else\r\n            return\r\n            (\r\n            _pID,                               //0\r\n            pIDPlayer[_pID].name,                   //1\r\n            pIDPlayerRound[_pID][_rID].team1Keys + pIDPlayerRound[_pID][_rID].team2Keys,\r\n            pIDPlayerRound[_pID][_rID].eth,           //6\r\n            pIDPlayer[_pID].vip\r\n            );\r\n    }\r\n\r\n    function getCards(uint256 _id)\r\n    public\r\n    view\r\n    returns(uint256, address, bytes32, uint256, uint256) {\r\n        bytes32 _name = pIDPlayer[cIDCard[_id].owner].name;\r\n        return (\r\n            cIDCard[_id].owner,\r\n            cIDCard[_id].addr,\r\n            _name,\r\n            cIDCard[_id].buyTime,\r\n            cIDCard[_id].earnings\r\n        );\r\n    }\r\n//==============================================================================\r\n//\r\n//    private functions\r\n//==============================================================================\r\n\r\n    //tested\r\n    function managePID(uint256 _inviter) private returns(uint256) {\r\n        uint256 _pID = pIDxAddr[msg.sender];\r\n        if (_pID == 0) {\r\n            pID++;\r\n            pIDxAddr[msg.sender] = pID;\r\n            pIDPlayer[pID].addr = msg.sender;\r\n            pIDPlayer[pID].name = 0x0;\r\n            _pID = pID;\r\n        }\r\n            // handle direct and second hand inviter\r\n        if (pIDPlayer[_pID].inviter1 == 0 && pIDPlayer[_inviter].addr != address(0) && _pID != _inviter) {\r\n            pIDPlayer[_pID].inviter1 = _inviter;\r\n            uint256 _in = pIDPlayer[_inviter].inviter1;\r\n            if (_in != 0) {\r\n                    pIDPlayer[_pID].inviter2 = _in;\r\n                }\r\n            }\r\n        // oneoff invite get invitation link\r\n        if (msg.value >= oneOffInvest2) {\r\n            pIDPlayer[_pID].vip = 2;\r\n        } else if (msg.value >= oneOffInvest1) {\r\n            if (pIDPlayer[_pID].vip != 2)\r\n                pIDPlayer[_pID].vip = 1;\r\n        }\r\n        return _pID;\r\n    }\r\n\r\n    function buyCore(uint256 _pID, uint256 _team) private {\r\n        // setup local rID\r\n        uint256 _rID = rID;\r\n        // grab time\r\n        uint256 _now = now;\r\n\r\n        //update last round;\r\n        if (pIDPlayer[_pID].lrnd != _rID)\r\n            updateVault(_pID);\r\n        pIDPlayer[_pID].lrnd = _rID;\r\n        uint256 _inv1 = pIDPlayer[_pID].inviter1;\r\n        uint256 _inv2 = pIDPlayer[_pID].inviter2;\r\n\r\n        // round is active\r\n        if (rIDRound[_rID].end >= _now || (rIDRound[_rID].end < _now && rIDRound[_rID].leadPID == 0)) {\r\n            core(_rID, _pID, msg.value, _team);\r\n            if (_inv1 != 0)\r\n                doRankInv(_rID, _inv1, rIDRound[_rID].invTop3, pIDPlayerRound[_inv1][_rID].inv);\r\n            if (_inv2 != 0)\r\n                doRankInv(_rID, _inv2, rIDRound[_rID].invTop3, pIDPlayerRound[_inv2][_rID].inv);\r\n            doRankKey(_rID, _pID, rIDRound[_rID].keyTop3, pIDPlayerRound[_pID][_rID].team1Keys + pIDPlayerRound[_pID][_rID].team2Keys);\r\n            emit onBuyKey(\r\n                _pID,\r\n                pIDPlayer[_pID].addr,\r\n                pIDPlayer[_pID].name, _rID,\r\n                msg.value,\r\n                pIDPlayerRound[_pID][_rID].team1Keys + pIDPlayerRound[_pID][_rID].team2Keys,\r\n                now);\r\n        } else {\r\n            if (rIDRound[_rID].end < _now && rIDRound[_rID].ended == false) {\r\n                rIDRound[_rID].ended = true;\r\n                endRound();\r\n                //if you trigger the endround. whatever how much you pay ,you will fail to buykey\r\n                //and the eth will return to your gen.\r\n                pIDPlayer[_pID].gen = pIDPlayer[_pID].gen.add(msg.value);\r\n            }\r\n        }\r\n    }\r\n\r\n    function core(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _team) private {\r\n\r\n        NTAdatasets.Round storage _roundID = rIDRound[_rID];\r\n        NTAdatasets.Deposit storage _deposit = deposit[_team];\r\n        //NTAdatasets.PlayerRound storage _playerRound = pIDPlayerRound[_pID][_rID];\r\n        // calculate how many keys they can get\r\n        uint256 _keysAll = _roundID.team1Keys + _roundID.team2Keys;//(rIDRound[_rID].eth).keysRec(_eth);\r\n        uint256 _keys = _keysAll.keysRec(rIDRound[_rID].eth + _eth);\r\n        if (_keys >= 1000000000000000000) {\r\n            updateTimer(_keys, _rID);\r\n        }\r\n\r\n        uint256 _left = _eth;\r\n        //2% to bigDrop\r\n        uint256 _temp = _eth.mul(_deposit.bigDrop) / DIVIDE;\r\n        doBigDrop(_rID, _pID, _keys, _temp);\r\n        _left = _left.sub0(_temp);\r\n\r\n        //5% to smallDrop\r\n        _temp = _eth.mul(_deposit.smallDrop) / DIVIDE;\r\n        doSmallDrop(_rID, _pID, _eth, _temp);\r\n        _left = _left.sub0(_temp);\r\n\r\n        _roundID.eth = _roundID.eth.add(_eth);\r\n        pIDPlayerRound[_pID][_rID].eth = pIDPlayerRound[_pID][_rID].eth.add(_eth);\r\n        if (_team == 0) {\r\n            _roundID.team1Keys = _roundID.team1Keys.add(_keys);\r\n            pIDPlayerRound[_pID][_rID].team1Keys = pIDPlayerRound[_pID][_rID].team1Keys.add(_keys);\r\n        } else {\r\n            _roundID.team2Keys = _roundID.team2Keys.add(_keys);\r\n            pIDPlayerRound[_pID][_rID].team2Keys = pIDPlayerRound[_pID][_rID].team2Keys.add(_keys);\r\n        }\r\n\r\n\r\n        //X% to all\r\n        uint256 _all = _eth.mul(_deposit.allPlayer) / DIVIDE;\r\n        _roundID.playerPot = _roundID.playerPot.add(_all);\r\n        uint256 _dust = updateMasks(_rID, _pID, _all, _keys);\r\n        _roundID.pot = _roundID.pot.add(_dust);\r\n        _left = _left.sub0(_all);\r\n\r\n        //X% to winnerPot\r\n        _temp = _eth.mul(_deposit.pot) / DIVIDE;\r\n        _roundID.pot = _roundID.pot.add(_temp);\r\n        _left = _left.sub0(_temp);\r\n\r\n        //5% to develop funds\r\n        _temp = _eth.mul(_deposit.devfunds) / DIVIDE;\r\n        doDevelopFunds(_temp);\r\n        //gameFunds[gameFundsAddr] = gameFunds[gameFundsAddr].add(_temp);\r\n        _left = _left.sub0(_temp);\r\n\r\n        //5% to team fee\r\n        _temp = _eth.mul(_deposit.teamFee) / DIVIDE;\r\n        //gameFunds[partner1] = gameFunds[partner1].add(_temp.mul(50) / DIVIDE);\r\n        _dust = doPartnerShares(_temp);\r\n        _left = _left.sub0(_temp).add(_dust);\r\n\r\n        //10% to cards\r\n        _temp = _eth.mul(_deposit.cards) / DIVIDE;\r\n        _left = _left.sub0(_temp).add(distributeCards(_temp));\r\n        // if no cards ,the money will add into left\r\n\r\n        // 10% to invatation\r\n        _temp = _eth.mul(_deposit.inviter) / DIVIDE;\r\n        _dust = doInvite(_rID, _pID, _temp);\r\n        _left = _left.sub0(_temp).add(_dust);\r\n\r\n        //update round;\r\n        if (_keys >= 1000000000000000000) {\r\n            _roundID.leadPID = _pID;\r\n            _roundID.team = _team;\r\n        }\r\n\r\n\r\n        _roundID.smallDrop = _roundID.smallDrop.add(_left);\r\n    }\r\n\r\n    //tested\r\n    function doInvite(uint256 _rID, uint256 _pID, uint256 _value) private returns(uint256){\r\n        uint256 _score = msg.value;\r\n        uint256 _left = _value;\r\n        uint256 _inviter1 = pIDPlayer[_pID].inviter1;\r\n        uint256 _fee;\r\n        uint256 _inviter2 = pIDPlayer[_pID].inviter2;\r\n        if (_inviter1 != 0)\r\n            pIDPlayerRound[_inviter1][_rID].score = pIDPlayerRound[_inviter1][_rID].score.add(_score);\r\n        if (_inviter2 != 0)\r\n            pIDPlayerRound[_inviter2][_rID].score = pIDPlayerRound[_inviter2][_rID].score.add(_score);\r\n        //invitor\r\n        if (_inviter1 == 0 || pIDPlayer[_inviter1].vip == 0)\r\n            return _left;\r\n        if (pIDPlayer[_inviter1].vip == 1) {\r\n            _fee = _value.mul(70) / 100;\r\n            _inviter2 = pIDPlayer[_pID].inviter2;\r\n            _left = _left.sub0(_fee);\r\n            pIDPlayerRound[_inviter1][_rID].inv = pIDPlayerRound[_inviter1][_rID].inv.add(_fee);\r\n            if (_inviter2 == 0 || pIDPlayer[_inviter2].vip != 2)\r\n                return _left;\r\n            else {\r\n                _fee = _value.mul(30) / 100;\r\n                _left = _left.sub0(_fee);\r\n                pIDPlayerRound[_inviter2][_rID].inv = pIDPlayerRound[_inviter2][_rID].inv.add(_fee);\r\n                return _left;\r\n            }\r\n        } else if (pIDPlayer[_inviter1].vip == 2) {\r\n            _left = _left.sub0(_value);\r\n            pIDPlayerRound[_inviter1][_rID].inv = pIDPlayerRound[_inviter1][_rID].inv.add(_value);\r\n            return _left;\r\n        } else {\r\n            return _left;\r\n        }\r\n    }\r\n\r\n    function doRankInv(uint256 _rID, uint256 _pID, uint256[3] storage rank, uint256 _value) private {\r\n\r\n        if (_value >= pIDPlayerRound[rank[0]][_rID].inv && _value != 0) {\r\n            if (_pID != rank[0]) {\r\n            uint256 temp = rank[0];\r\n            rank[0] = _pID;\r\n            if (rank[1] == _pID) {\r\n                rank[1] = temp;\r\n            } else {\r\n                rank[2] = rank[1];\r\n                rank[1] = temp;\r\n            }\r\n            }\r\n        } else if (_value >= pIDPlayerRound[rank[1]][_rID].inv && _value != 0) {\r\n            if (_pID != rank[1]) {\r\n            rank[2] = rank[1];\r\n            rank[1] = _pID;\r\n            }\r\n        } else if (_value >= pIDPlayerRound[rank[2]][_rID].inv && _value != 0) {\r\n            rank[2] = _pID;\r\n        }\r\n    }\r\n\r\n    function doRankKey(uint256 _rID, uint256 _pID, uint256[3] storage rank, uint256 _value) private {\r\n\r\n        if (_value >= (pIDPlayerRound[rank[0]][_rID].team1Keys + pIDPlayerRound[rank[0]][_rID].team2Keys)) {\r\n            if (_pID != rank[0]) {\r\n            uint256 temp = rank[0];\r\n            rank[0] = _pID;\r\n            if (rank[1] == _pID) {\r\n                rank[1] = temp;\r\n            } else {\r\n                rank[2] = rank[1];\r\n                rank[1] = temp;\r\n            }\r\n            }\r\n        } else if (_value >= (pIDPlayerRound[rank[1]][_rID].team1Keys + pIDPlayerRound[rank[1]][_rID].team2Keys)) {\r\n            if (_pID != rank[1]){\r\n            rank[2] = rank[1];\r\n            rank[1] = _pID;\r\n            }\r\n        } else if (_value >= (pIDPlayerRound[rank[2]][_rID].team1Keys + pIDPlayerRound[rank[2]][_rID].team2Keys)) {\r\n            rank[2] = _pID;\r\n        }\r\n    }\r\n\r\n    //tested\r\n    function doSmallDrop(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _small) private {\r\n        // modulo current round eth, and add player eth to see if it can trigger the trigger;\r\n        uint256 _remain = rIDRound[_rID].eth % smallDropTrigger;\r\n        if ((_remain + _eth) >= smallDropTrigger) {\r\n            uint256 _reward = rIDRound[_rID].smallDrop;\r\n            rIDRound[_rID].smallDrop = 0;\r\n            pIDPlayer[_pID].win = pIDPlayer[_pID].win.add(_reward);\r\n            rIDRound[_rID].smallDrop = rIDRound[_rID].smallDrop.add(_small);\r\n            emit NTA3DEvents.onDrop(pIDPlayer[_pID].addr, pIDPlayer[_pID].name, _rID, 0, _reward, now);\r\n            //emit\r\n        } else {\r\n            rIDRound[_rID].smallDrop = rIDRound[_rID].smallDrop.add(_small);\r\n        }\r\n    }\r\n\r\n    //tested\r\n    function doBigDrop(uint256 _rID, uint256 _pID, uint256 _key, uint256 _big) private {\r\n        uint256 _keys = rIDRound[_rID].team1Keys + rIDRound[_rID].team2Keys;\r\n        uint256 _remain = _keys % bigDropTrigger;\r\n        if ((_remain + _key) >= bigDropTrigger) {\r\n            uint256 _reward = rIDRound[_rID].bigDrop;\r\n            rIDRound[_rID].bigDrop = 0;\r\n            pIDPlayer[_pID].win = pIDPlayer[_pID].win.add(_reward);\r\n            rIDRound[_rID].bigDrop = rIDRound[_rID].bigDrop.add(_big);\r\n            emit NTA3DEvents.onDrop(pIDPlayer[_pID].addr, pIDPlayer[_pID].name, _rID, 1, _reward, now);\r\n            //emit\r\n        } else {\r\n            rIDRound[_rID].bigDrop = rIDRound[_rID].bigDrop.add(_big);\r\n        }\r\n    }\r\n\r\n    function distributeCards(uint256 _eth) private returns(uint256){\r\n        uint256 _each = _eth / 20;\r\n        uint256 _remain = _eth;\r\n        for (uint i = 0; i < 20; i++) {\r\n            uint256 _pID = cIDCard[i].owner;\r\n            if (_pID != 0) {\r\n                pIDPlayer[_pID].crd = pIDPlayer[_pID].crd.add(_each);\r\n                cIDCard[i].earnings = cIDCard[i].earnings.add(_each);\r\n                _remain = _remain.sub0(_each);\r\n            }\r\n        }\r\n        return _remain;\r\n    }\r\n\r\n    function doPartnerShares(uint256 _eth) private returns(uint256) {\r\n        uint i;\r\n        uint256 _temp;\r\n        uint256 _left = _eth;\r\n        //first 10%\r\n        _temp = _eth.mul(10) / 100;\r\n        gameFunds[partner[0]] = gameFunds[partner[0]].add(_temp);\r\n        for(i = 1; i < 11; i++) {\r\n            _temp = _eth.mul(9) / 100;\r\n            gameFunds[partner[i]] = gameFunds[partner[i]].add(_temp);\r\n            _left = _left.sub0(_temp);\r\n        }\r\n        return _left;\r\n    }\r\n\r\n    function doDevelopFunds(uint256 _eth) private{\r\n        uint256 _temp;\r\n        _temp = _eth.mul(12) / 100;\r\n        gameFunds[to06] = gameFunds[to06].add(_temp);\r\n        _temp = _eth.mul(8) / 100;\r\n        gameFunds[to04] = gameFunds[to04].add(_temp);\r\n        _temp = _eth.mul(40) / 100;\r\n        gameFunds[to20A] = gameFunds[to20A].add(_temp);\r\n        _temp = _eth.mul(40) / 100;\r\n        gameFunds[to20B] = gameFunds[to20B].add(_temp);\r\n    }\r\n\r\n    function endRound() private {\r\n        NTAdatasets.Round storage _roundID = rIDRound[rID];\r\n        NTAdatasets.PotSplit storage _potSplit = potSplit[0];\r\n        uint256 _winPID = _roundID.leadPID;\r\n        uint256 _pot = _roundID.pot;\r\n        uint256 _left = _pot;\r\n\r\n        //the pot is too small endround will ignore the dividens\r\n        //new round will start at 0 eth\r\n        if(_pot < 10000000000000) {\r\n            emit onRoundEnd(pIDPlayer[_winPID].addr, pIDPlayer[_winPID].name, rID, _roundID.pot,0, now);\r\n            newRound(0);\r\n            return;\r\n        }\r\n\r\n        // potSplit:    ==> |20% to all, 45% to lastwinner, 5% to inviter 1st, 3% to inviter 2nd, 2% to inviter 3rd,\r\n        //                  |8% to key buyer 1st, 5% to key buyer 2nd, 2% to key buyer 3rd, 10% to next round\r\n\r\n        //20% to all\r\n        uint256 _all = _pot.mul(_potSplit.allPlayer) / DIVIDE;\r\n        _roundID.teamPot = _roundID.teamPot.add(_all);\r\n        _left = _left.sub0(_all);\r\n\r\n        //45% to lastwinner\r\n        uint256 _temp = _pot.mul(_potSplit.lastWinner) / DIVIDE;\r\n        pIDPlayer[_winPID].win = pIDPlayer[_winPID].win.add(_temp);\r\n        _left = _left.sub0(_temp);\r\n\r\n        //5% to inviter 1st, 3% to inviter 2nd, 2% to inviter 3rd\r\n        uint256 _inv1st = _pot.mul(_potSplit.inviter1st) / DIVIDE;\r\n        if (_roundID.invTop3[0] != 0) {\r\n            pIDPlayer[_roundID.invTop3[0]].win = pIDPlayer[_roundID.invTop3[0]].win.add(_inv1st);\r\n            _left = _left.sub0(_inv1st);\r\n        }\r\n\r\n        _inv1st = _pot.mul(_potSplit.inviter2nd) / DIVIDE;\r\n        if (_roundID.invTop3[1] != 0) {\r\n            pIDPlayer[_roundID.invTop3[1]].win = pIDPlayer[_roundID.invTop3[1]].win.add(_inv1st);\r\n            _left = _left.sub0(_inv1st);\r\n        }\r\n\r\n        _inv1st = _pot.mul(_potSplit.inviter3rd) / DIVIDE;\r\n        if (_roundID.invTop3[2] != 0) {\r\n            pIDPlayer[_roundID.invTop3[2]].win = pIDPlayer[_roundID.invTop3[2]].win.add(_inv1st);\r\n            _left = _left.sub0(_inv1st);\r\n        }\r\n\r\n         //8% to key buyer 1st, 5% to key buyer 2nd, 2% to key buyer 3rd\r\n        _inv1st = _pot.mul(_potSplit.key1st) / DIVIDE;\r\n        if (_roundID.keyTop3[0] != 0) {\r\n            pIDPlayer[_roundID.keyTop3[0]].win = pIDPlayer[_roundID.keyTop3[0]].win.add(_inv1st);\r\n            _left = _left.sub0(_inv1st);\r\n        }\r\n\r\n        _inv1st = _pot.mul(_potSplit.key2nd) / DIVIDE;\r\n        if (_roundID.keyTop3[1] != 0) {\r\n            pIDPlayer[_roundID.keyTop3[1]].win = pIDPlayer[_roundID.keyTop3[1]].win.add(_inv1st);\r\n            _left = _left.sub0(_inv1st);\r\n        }\r\n\r\n        _inv1st = _pot.mul(_potSplit.key3rd) / DIVIDE;\r\n        if (_roundID.keyTop3[2] != 0) {\r\n            pIDPlayer[_roundID.keyTop3[2]].win = pIDPlayer[_roundID.keyTop3[2]].win.add(_inv1st);\r\n            _left = _left.sub0(_inv1st);\r\n        }\r\n\r\n        //10% to next round\r\n        uint256 _newPot = _pot.mul(potSplit[0].next) / DIVIDE;\r\n        _left = _left.sub0(_newPot);\r\n        emit onRoundEnd(pIDPlayer[_winPID].addr, pIDPlayer[_winPID].name, rID, _roundID.pot, _newPot + _left, now);\r\n        //start new round\r\n        newRound(_newPot + _left);\r\n    }\r\n\r\n    //tested\r\n    function newRound(uint256 _eth) private {\r\n        if (rIDRound[rID].ended == true || rID == 0) {\r\n            rID++;\r\n            rIDRound[rID].strt = now;\r\n            rIDRound[rID].end = now.add(rndMax);\r\n            rIDRound[rID].pot = rIDRound[rID].pot.add(_eth);\r\n        }\r\n    }\r\n\r\n    function updateMasks(uint256 _rID, uint256 _pID, uint256 _all, uint256 _keys) private\r\n    returns(uint256) {\r\n        //calculate average share of each new eth in\r\n        uint256 _allKeys = rIDRound[_rID].team1Keys + rIDRound[_rID].team2Keys;\r\n        uint256 _unit = _all.mul(1000000000000000000) / _allKeys;\r\n        rIDRound[_rID].mask = rIDRound[_rID].mask.add(_unit);\r\n        //calculate this round player can get\r\n        uint256 _share = (_unit.mul(_keys)) / (1000000000000000000);\r\n        pIDPlayerRound[_pID][_rID].mask = pIDPlayerRound[_pID][_rID].mask.add((rIDRound[_rID].mask.mul(_keys) / (1000000000000000000)).sub(_share));\r\n        return(_all.sub(_unit.mul(_allKeys) / (1000000000000000000)));\r\n    }\r\n\r\n    function withdrawEarnings(uint256 _pID) private returns(uint256) {\r\n        updateVault(_pID);\r\n        uint256 earnings = (pIDPlayer[_pID].win).add(pIDPlayer[_pID].gen).add(pIDPlayer[_pID].inv).add(pIDPlayer[_pID].tim).add(pIDPlayer[_pID].crd);\r\n        if (earnings > 0) {\r\n            pIDPlayer[_pID].win = 0;\r\n            pIDPlayer[_pID].gen = 0;\r\n            pIDPlayer[_pID].inv = 0;\r\n            pIDPlayer[_pID].tim = 0;\r\n            pIDPlayer[_pID].crd = 0;\r\n        }\r\n        return earnings;\r\n    }\r\n\r\n    function updateVault(uint256 _pID) private {\r\n        uint256 _rID = pIDPlayer[_pID].lrnd;\r\n        updateGenVault(_pID, _rID);\r\n        updateInvVault(_pID, _rID);\r\n        uint256 _team = calcTeamEarnings(_pID, _rID);\r\n        //already calculate team reward,ended round key and mask dont needed\r\n        if(rIDRound[_rID].ended == true) {\r\n            pIDPlayerRound[_pID][_rID].team1Keys = 0;\r\n            pIDPlayerRound[_pID][_rID].team2Keys = 0;\r\n            pIDPlayerRound[_pID][_rID].mask = 0;\r\n        }\r\n        pIDPlayer[_pID].tim = pIDPlayer[_pID].tim.add(_team);\r\n    }\r\n\r\n    function updateGenVault(uint256 _pID, uint256 _rID) private {\r\n        uint256 _earnings = calcUnMaskedEarnings(_pID, _rID);\r\n        //put invitation reward to gen\r\n        if (_earnings > 0) {\r\n            // put in gen vault\r\n            pIDPlayer[_pID].gen = _earnings.add(pIDPlayer[_pID].gen);\r\n            // zero out their earnings by updating mask\r\n            pIDPlayerRound[_pID][_rID].mask = _earnings.add(pIDPlayerRound[_pID][_rID].mask);\r\n        }\r\n\r\n    }\r\n\r\n    function updateInvVault(uint256 _pID, uint256 _rID) private {\r\n        uint256 _inv = pIDPlayerRound[_pID][_rID].inv;\r\n        uint256 _invMask = pIDPlayerRound[_pID][_rID].invMask;\r\n        if (_inv > 0) {\r\n            pIDPlayer[_pID].inv = pIDPlayer[_pID].inv.add(_inv).sub0(_invMask);\r\n            pIDPlayerRound[_pID][_rID].invMask = pIDPlayerRound[_pID][_rID].invMask.add(_inv).sub0(_invMask);\r\n        }\r\n    }\r\n\r\n    //calculate valut not update\r\n    function calcUnMaskedEarnings(uint256 _pID, uint256 _rID) private view\r\n    returns (uint256)\r\n    {\r\n        uint256 _all = pIDPlayerRound[_pID][_rID].team1Keys + pIDPlayerRound[_pID][_rID].team2Keys;\r\n        return ((rIDRound[_rID].mask.mul(_all)) / (1000000000000000000)).sub(pIDPlayerRound[_pID][_rID].mask);\r\n    }\r\n\r\n    function calcTeamEarnings(uint256 _pID, uint256 _rID) private view\r\n    returns (uint256)\r\n    {\r\n        uint256 _key1 = pIDPlayerRound[_pID][_rID].team1Keys;\r\n        uint256 _key2 = pIDPlayerRound[_pID][_rID].team2Keys;\r\n        if (rIDRound[_rID].ended == false)\r\n            return 0;\r\n        else {\r\n            if (rIDRound[_rID].team == 0)\r\n                return rIDRound[_rID].teamPot.mul(_key1 / rIDRound[_rID].team1Keys);\r\n            else\r\n                return rIDRound[_rID].teamPot.mul(_key2 / rIDRound[_rID].team2Keys);\r\n        }\r\n    }\r\n    //tested\r\n    function updateTimer(uint256 _keys, uint256 _rID) private {\r\n        // grab time\r\n        uint256 _now = now;\r\n        // calculate new time\r\n        uint256 _newTime;\r\n        if (_now > rIDRound[_rID].end && rIDRound[_rID].leadPID == 0)\r\n            _newTime = (((_keys) / (1000000000000000000)).mul(rndPerKey)).add(_now);\r\n        else\r\n            _newTime = (((_keys) / (1000000000000000000)).mul(rndPerKey)).add(rIDRound[_rID].end);\r\n\r\n        // compare to max and set new end time\r\n        if (_newTime < (rndMax).add(_now))\r\n            rIDRound[_rID].end = _newTime;\r\n        else\r\n            rIDRound[_rID].end = rndMax.add(_now);\r\n    }\r\n\r\n\r\n}\r\n\r\nlibrary NTA3DKeysCalc {\r\n    using SafeMath for *;\r\n    uint256 constant private keyPriceTrigger = 50000 * 1e18;\r\n    uint256 constant private keyPriceFirst = 0.0005 ether;\r\n    uint256 constant private keyPriceAdd = 0.0001 ether;\r\n    /**\r\n     * @dev calculates number of keys received given X eth\r\n     * _curEth current amount of eth in contract\r\n     * _newEth eth being spent\r\n     * @return amount of ticket purchased\r\n     */\r\n    function keysRec(uint256 _curKeys, uint256 _allEth)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return(keys(_curKeys, _allEth));\r\n    }\r\n    function ethRec(uint256 _curKeys, uint256 _sellKeys)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return(eth(_sellKeys.add(_curKeys)).sub(eth(_curKeys)));\r\n    }\r\n    function keys(uint256 _keys, uint256 _eth)\r\n        internal\r\n        pure\r\n        returns(uint256)\r\n    {\r\n        uint256 _times = _keys / keyPriceTrigger;\r\n        uint i = 0;\r\n        uint256 eth1;\r\n        uint256 eth2;\r\n        uint256 price;\r\n        uint256 key2;\r\n        for(i = _times;i < i + 200; i++) {\r\n            if(eth(keyPriceTrigger * (i + 1)) >=  _eth) {\r\n                if(i == 0) eth1 = 0;\r\n                else eth1 = eth(keyPriceTrigger * i);\r\n                eth2 = _eth.sub(eth1);\r\n                price = i.mul(keyPriceAdd).add(keyPriceFirst);\r\n                key2 = (eth2 / price).mul(1e18);\r\n                return ((keyPriceTrigger * i + key2).sub0(_keys));\r\n                break;\r\n            }\r\n        }\r\n        //too large\r\n        require(false, \"too large eth in\");\r\n\r\n    }\r\n     //tested\r\n    function eth(uint256 _keys)\r\n        internal\r\n        pure\r\n        returns(uint256)\r\n    {\r\n        uint256 _times = _keys / keyPriceTrigger;//keyPriceTrigger;\r\n        uint256 _remain = _keys % keyPriceTrigger;//keyPriceTrigger;\r\n        uint256 _price = _times.mul(keyPriceAdd).add(keyPriceFirst);\r\n        if (_times == 0) {\r\n            return (keyPriceFirst.mul(_keys / 1e18));\r\n        } else {\r\n            uint256 _up = (_price.sub(keyPriceFirst)).mul(_remain / 1e18);\r\n            uint256 _down = (_keys / 1e18).mul(keyPriceFirst);\r\n            uint256 _add = (_times.mul(_times).sub(_times) / 2).mul(keyPriceAdd).mul(keyPriceTrigger / 1e18);\r\n            return (_up + _down + _add);\r\n        }\r\n    }\r\n}\r\n\r\nlibrary NTAdatasets {\r\n\r\n    struct Player {\r\n        address addr;   // player address\r\n        bytes32 name;   // player name\r\n        uint256 win;    // winnings vault\r\n        uint256 gen;    // general vault\r\n        uint256 inv;    // inviter vault\r\n        uint256 tim;     //team pot\r\n        uint256 crd;     //crd pot\r\n        uint256 lrnd;   // last round played\r\n        uint256 inviter1; // direct inviter\r\n        uint256 inviter2; // second hand inviter\r\n        uint256 vip; //0 no vip; 1 and 2\r\n    }\r\n\r\n    struct PlayerRound {\r\n        uint256 eth;    // eth player has added to round (used for eth limiter)\r\n        uint256 team1Keys;\r\n        uint256 team2Keys;\r\n        uint256 inv;\r\n        uint256 mask;\r\n        uint256 invMask;\r\n        uint256 score;\r\n    }\r\n\r\n    struct Round {\r\n        uint256 leadPID;   // pID of player in lead\r\n        uint256 end;    // time ends/ended\r\n        bool ended;     // has round end function been ran\r\n        uint256 strt;   // time round started\r\n        uint256 team1Keys;   // keys\r\n        uint256 team2Keys;   // keys\r\n        uint256 eth;    // total eth in\r\n        uint256 pot;    // eth win pot\r\n        uint256 team;\r\n        uint256 teamPot;\r\n        uint256 smallDrop;//50Eth airdrop\r\n        uint256 bigDrop; //300000 eth airdrop\r\n        uint256 playerPot;\r\n        uint256 mask;\r\n        uint256[3] invTop3;\r\n        uint256[3] keyTop3;\r\n    }\r\n\r\n    struct Card {\r\n        uint256 owner;  //pID of card owner\r\n        address addr;\r\n        uint256 buyTime; //validity time check\r\n        uint256 earnings;\r\n    }\r\n\r\n    struct Deposit {\r\n        uint256 allPlayer;  // all player this rounds by key\r\n        uint256 pot;        // last winner pot\r\n        uint256 devfunds;   // game development Pot\r\n        uint256 teamFee;    // team fee\r\n        uint256 cards;      // stock right cards\r\n        uint256 inviter;\r\n        uint256 bigDrop;\r\n        uint256 smallDrop;\r\n    }\r\n\r\n    struct PotSplit {\r\n        uint256 allPlayer;  // all player this rounds by key\r\n        uint256 lastWinner; // final player\r\n        uint256 inviter1st; // player who get 1st of invatation\r\n        uint256 inviter2nd;\r\n        uint256 inviter3rd;\r\n        uint256 key1st;     // player who get 1st key amount\r\n        uint256 key2nd;\r\n        uint256 key3rd;\r\n        uint256 next;        // next round\r\n    }\r\n}\r\n\r\nlibrary NameFilter {\r\n    function nameFilter(string _input)\r\n        internal\r\n        pure\r\n        returns(bytes32)\r\n    {\r\n        bytes memory _temp = bytes(_input);\r\n        uint256 _length = _temp.length;\r\n\r\n        //sorry limited to 32 characters\r\n        require (_length <= 32 && _length > 0, \"string must be between 1 and 32 characters\");\r\n        // make sure it doesnt start with or end with space\r\n        require(_temp[0] != 0x20 && _temp[_length-1] != 0x20, \"string cannot start or end with space\");\r\n        // make sure first two characters are not 0x\r\n        if (_temp[0] == 0x30)\r\n        {\r\n            require(_temp[1] != 0x78, \"string cannot start with 0x\");\r\n            require(_temp[1] != 0x58, \"string cannot start with 0X\");\r\n        }\r\n\r\n        // create a bool to track if we have a non number character\r\n        bool _hasNonNumber;\r\n\r\n        // convert & check\r\n        for (uint256 i = 0; i < _length; i++)\r\n        {\r\n            // if its uppercase A-Z\r\n            if (_temp[i] > 0x40 && _temp[i] < 0x5b)\r\n            {\r\n                // convert to lower case a-z\r\n                _temp[i] = byte(uint(_temp[i]) + 32);\r\n\r\n                // we have a non number\r\n                if (_hasNonNumber == false)\r\n                    _hasNonNumber = true;\r\n            } else {\r\n                require\r\n                (\r\n                    // require character is a space\r\n                    _temp[i] == 0x20 ||\r\n                    // OR lowercase a-z\r\n                    (_temp[i] > 0x60 && _temp[i] < 0x7b) ||\r\n                    // or 0-9\r\n                    (_temp[i] > 0x2f && _temp[i] < 0x3a),\r\n                    \"string contains invalid characters\"\r\n                );\r\n                // make sure theres not 2x spaces in a row\r\n                if (_temp[i] == 0x20)\r\n                    require( _temp[i+1] != 0x20, \"string cannot contain consecutive spaces\");\r\n\r\n                // see if we have a character other than a number\r\n                if (_hasNonNumber == false && (_temp[i] < 0x30 || _temp[i] > 0x39))\r\n                    _hasNonNumber = true;\r\n            }\r\n        }\r\n\r\n        require(_hasNonNumber == true, \"string cannot be only numbers\");\r\n\r\n        bytes32 _ret;\r\n        assembly {\r\n            _ret := mload(add(_temp, 32))\r\n        }\r\n        return (_ret);\r\n    }\r\n}\r\nlibrary SafeMath {\r\n    function mul(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n        returns (uint256 c)\r\n    {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        c = a * b;\r\n        require(c / a == b, \"SafeMath mul failed\");\r\n        return c;\r\n    }\r\n    function sub(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        require(b <= a, \"SafeMath sub failed\");\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two numbers, no throw\r\n    */\r\n    function sub0(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        if (a < b) {\r\n            return 0;\r\n        } else {\r\n            return a - b;\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, throws on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n        returns (uint256 c)\r\n    {\r\n        c = a + b;\r\n        require(c >= a, \"SafeMath add failed\");\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev gives square root of given x.\r\n     */\r\n    function sqrt(uint256 x)\r\n        internal\r\n        pure\r\n        returns (uint256 y)\r\n    {\r\n        uint256 z = ((add(x,1)) / 2);\r\n        y = x;\r\n        while (z < y)\r\n        {\r\n            y = z;\r\n            z = ((add((x / z),z)) / 2);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev gives square. multiplies x by x\r\n     */\r\n    function sq(uint256 x)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return (mul(x,x));\r\n    }\r\n\r\n    /**\r\n     * @dev x to the power of y\r\n     */\r\n    function pwr(uint256 x, uint256 y)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        if (x==0)\r\n            return (0);\r\n        else if (y==0)\r\n            return (1);\r\n        else\r\n        {\r\n            uint256 z = x;\r\n            for (uint256 i=1; i < y; i++)\r\n                z = mul(z,x);\r\n            return (z);\r\n        }\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"pIDxAddr\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"getCards\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"bytes32\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_key\",\"type\":\"uint256\"}],\"name\":\"getBuyPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_cID\",\"type\":\"uint256\"},{\"name\":\"_inviter\",\"type\":\"uint256\"}],\"name\":\"buyCardXid\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"potSplit\",\"outputs\":[{\"name\":\"allPlayer\",\"type\":\"uint256\"},{\"name\":\"lastWinner\",\"type\":\"uint256\"},{\"name\":\"inviter1st\",\"type\":\"uint256\"},{\"name\":\"inviter2nd\",\"type\":\"uint256\"},{\"name\":\"inviter3rd\",\"type\":\"uint256\"},{\"name\":\"key1st\",\"type\":\"uint256\"},{\"name\":\"key2nd\",\"type\":\"uint256\"},{\"name\":\"key3rd\",\"type\":\"uint256\"},{\"name\":\"next\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"startFirstRound\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getPlayerVaults\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"activeNTA\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_team\",\"type\":\"uint256\"},{\"name\":\"_invName\",\"type\":\"string\"}],\"name\":\"buyXname\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"},{\"name\":\"_inv\",\"type\":\"uint256\"},{\"name\":\"_vip\",\"type\":\"uint256\"},{\"name\":\"_nameString\",\"type\":\"string\"}],\"name\":\"setInviterCode\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"rIDRound\",\"outputs\":[{\"name\":\"leadPID\",\"type\":\"uint256\"},{\"name\":\"end\",\"type\":\"uint256\"},{\"name\":\"ended\",\"type\":\"bool\"},{\"name\":\"strt\",\"type\":\"uint256\"},{\"name\":\"team1Keys\",\"type\":\"uint256\"},{\"name\":\"team2Keys\",\"type\":\"uint256\"},{\"name\":\"eth\",\"type\":\"uint256\"},{\"name\":\"pot\",\"type\":\"uint256\"},{\"name\":\"team\",\"type\":\"uint256\"},{\"name\":\"teamPot\",\"type\":\"uint256\"},{\"name\":\"smallDrop\",\"type\":\"uint256\"},{\"name\":\"bigDrop\",\"type\":\"uint256\"},{\"name\":\"playerPot\",\"type\":\"uint256\"},{\"name\":\"mask\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pID\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCurrentRoundInfo\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"bytes32\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_cID\",\"type\":\"uint256\"},{\"name\":\"_invName\",\"type\":\"string\"}],\"name\":\"buyCardXname\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_team\",\"type\":\"uint256\"},{\"name\":\"_inviter\",\"type\":\"uint256\"}],\"name\":\"buyXid\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"pIDxName\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"pIDPlayer\",\"outputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"name\",\"type\":\"bytes32\"},{\"name\":\"win\",\"type\":\"uint256\"},{\"name\":\"gen\",\"type\":\"uint256\"},{\"name\":\"inv\",\"type\":\"uint256\"},{\"name\":\"tim\",\"type\":\"uint256\"},{\"name\":\"crd\",\"type\":\"uint256\"},{\"name\":\"lrnd\",\"type\":\"uint256\"},{\"name\":\"inviter1\",\"type\":\"uint256\"},{\"name\":\"inviter2\",\"type\":\"uint256\"},{\"name\":\"vip\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rID\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getRankList\",\"outputs\":[{\"name\":\"\",\"type\":\"address[3]\"},{\"name\":\"\",\"type\":\"uint256[3]\"},{\"name\":\"\",\"type\":\"bytes32[3]\"},{\"name\":\"\",\"type\":\"address[3]\"},{\"name\":\"\",\"type\":\"uint256[3]\"},{\"name\":\"\",\"type\":\"bytes32[3]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_nameString\",\"type\":\"string\"},{\"name\":\"_inviterName\",\"type\":\"string\"}],\"name\":\"registNameXname\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[{\"name\":\"allPlayer\",\"type\":\"uint256\"},{\"name\":\"pot\",\"type\":\"uint256\"},{\"name\":\"devfunds\",\"type\":\"uint256\"},{\"name\":\"teamFee\",\"type\":\"uint256\"},{\"name\":\"cards\",\"type\":\"uint256\"},{\"name\":\"inviter\",\"type\":\"uint256\"},{\"name\":\"bigDrop\",\"type\":\"uint256\"},{\"name\":\"smallDrop\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_nameString\",\"type\":\"string\"},{\"name\":\"_inviter\",\"type\":\"uint256\"}],\"name\":\"registNameXid\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"getTeamFee\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"pIDPlayerRound\",\"outputs\":[{\"name\":\"eth\",\"type\":\"uint256\"},{\"name\":\"team1Keys\",\"type\":\"uint256\"},{\"name\":\"team2Keys\",\"type\":\"uint256\"},{\"name\":\"inv\",\"type\":\"uint256\"},{\"name\":\"mask\",\"type\":\"uint256\"},{\"name\":\"invMask\",\"type\":\"uint256\"},{\"name\":\"score\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTimeLeft\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"teamWithdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"getScore\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"getPlayerInfoByAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"bytes32\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"playerID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"playerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"playerName\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"ethOut\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timeStamp\",\"type\":\"uint256\"}],\"name\":\"onWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"playerID\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"playerAddress\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"playerName\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"roundID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"ethIn\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"keys\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timeStamp\",\"type\":\"uint256\"}],\"name\":\"onBuyKey\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"playerID\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"playerAddress\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"playerName\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"cardID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"ethIn\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timeStamp\",\"type\":\"uint256\"}],\"name\":\"onBuyCard\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"winnerAddr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"winnerName\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"roundID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amountWon\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"newPot\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timeStamp\",\"type\":\"uint256\"}],\"name\":\"onRoundEnd\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"dropwinner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"winnerName\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"roundID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"droptype\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"win\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timeStamp\",\"type\":\"uint256\"}],\"name\":\"onDrop\",\"type\":\"event\"}]","ContractName":"NTA3D","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://5b52f3e9831b220a8f96d339880fc0b5df4cbef6d9b23fc7b93d50caaf8acde4"}]}