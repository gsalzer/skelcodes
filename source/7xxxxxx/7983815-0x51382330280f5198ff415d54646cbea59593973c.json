{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.5.7;\r\ncontract DCN {\r\n  event UserCreated(address indexed creator, uint64 user_id);\r\n  event UserTradeAddressUpdated(uint64 user_id);\r\n  event SessionUpdated(uint64 user_id, uint64 exchange_id);\r\n  event ExchangeDeposit(uint64 user_id, uint64 exchange_id, uint32 asset_id);\r\n  uint256 creator;\r\n  uint256 creator_recovery;\r\n  uint256 creator_recovery_proposed;\r\n  uint256 user_count;\r\n  uint256 exchange_count;\r\n  uint256 asset_count;\r\n  uint256 security_locked_features;\r\n  uint256 security_locked_features_proposed;\r\n  uint256 security_proposed_unlock_timestamp;\r\n  struct Exchange {\r\n    uint88 name;\r\n    uint8 locked;\r\n    address owner;\r\n    uint256 withdraw_address;\r\n    uint256 recovery_address;\r\n    uint256 recovery_address_proposed;\r\n    uint256[4294967296] balances;\r\n  }\r\n  struct Asset {\r\n    uint64 symbol;\r\n    uint192 unit_scale;\r\n    uint256 contract_address;\r\n  }\r\n  struct MarketState {\r\n    int64 quote_qty;\r\n    int64 base_qty;\r\n    uint64 fee_used;\r\n    uint64 fee_limit;\r\n    int64 min_quote_qty;\r\n    int64 min_base_qty;\r\n    uint64 long_max_price;\r\n    uint64 short_min_price;\r\n    uint64 limit_version;\r\n    int96 quote_shift;\r\n    int96 base_shift;\r\n  }\r\n  struct SessionBalance {\r\n    uint128 total_deposit;\r\n    uint64 unsettled_withdraw_total;\r\n    uint64 asset_balance;\r\n  }\r\n  struct ExchangeSession {\r\n    uint256 unlock_at;\r\n    uint256 trade_address;\r\n    SessionBalance[4294967296] balances;\r\n    MarketState[18446744073709551616] market_states;\r\n  }\r\n  struct User {\r\n    uint256 trade_address;\r\n    uint256 withdraw_address;\r\n    uint256 recovery_address;\r\n    uint256 recovery_address_proposed;\r\n    uint256[4294967296] balances;\r\n    ExchangeSession[4294967296] exchange_sessions;\r\n  }\r\n  User[18446744073709551616] users;\r\n  Asset[4294967296] assets;\r\n  Exchange[4294967296] exchanges;\r\n  \r\n  constructor() public  {\r\n    assembly {\r\n      sstore(creator_slot, caller)\r\n      sstore(creator_recovery_slot, caller)\r\n    }\r\n  }\r\n  \r\n  function get_security_state() public view \r\n  returns (uint256 locked_features, uint256 locked_features_proposed, uint256 proposed_unlock_timestamp) {\r\n    \r\n    uint256[3] memory return_value_mem;\r\n    assembly {\r\n      mstore(return_value_mem, sload(security_locked_features_slot))\r\n      mstore(add(return_value_mem, 32), sload(security_locked_features_proposed_slot))\r\n      mstore(add(return_value_mem, 64), sload(security_proposed_unlock_timestamp_slot))\r\n      return(return_value_mem, 96)\r\n    }\r\n  }\r\n  \r\n  function get_creator() public view \r\n  returns (address dcn_creator, address dcn_creator_recovery, address dcn_creator_recovery_proposed) {\r\n    \r\n    uint256[3] memory return_value_mem;\r\n    assembly {\r\n      mstore(return_value_mem, sload(creator_slot))\r\n      mstore(add(return_value_mem, 32), sload(creator_recovery_slot))\r\n      mstore(add(return_value_mem, 64), sload(creator_recovery_proposed_slot))\r\n      return(return_value_mem, 96)\r\n    }\r\n  }\r\n  \r\n  function get_asset(uint32 asset_id) public view \r\n  returns (string memory symbol, uint192 unit_scale, address contract_address) {\r\n    \r\n    uint256[5] memory return_value_mem;\r\n    assembly {\r\n      let asset_count := sload(asset_count_slot)\r\n      if iszero(lt(asset_id, asset_count)) {\r\n        mstore(32, 1)\r\n        revert(63, 1)\r\n      }\r\n      let asset_ptr := add(assets_slot, mul(2, asset_id))\r\n      let asset_0 := sload(asset_ptr)\r\n      let asset_1 := sload(add(asset_ptr, 1))\r\n      mstore(return_value_mem, 96)\r\n      mstore(add(return_value_mem, 96), 8)\r\n      mstore(add(return_value_mem, 128), asset_0)\r\n      mstore(add(return_value_mem, 32), and(asset_0, 0xffffffffffffffffffffffffffffffffffffffffffffffff))\r\n      mstore(add(return_value_mem, 64), asset_1)\r\n      return(return_value_mem, 136)\r\n    }\r\n  }\r\n  \r\n  function get_exchange(uint32 exchange_id) public view \r\n  returns (\r\n    string memory name, bool locked, address owner,\r\n    address withdraw_address, address recovery_address, address recovery_address_proposed\r\n  ) {\r\n    \r\n    uint256[8] memory return_value_mem;\r\n    assembly {\r\n      let exchange_count := sload(exchange_count_slot)\r\n      if iszero(lt(exchange_id, exchange_count)) {\r\n        mstore(32, 1)\r\n        revert(63, 1)\r\n      }\r\n      let exchange_ptr := add(exchanges_slot, mul(4294967300, exchange_id))\r\n      let exchange_0 := sload(exchange_ptr)\r\n      let exchange_1 := sload(add(exchange_ptr, 1))\r\n      let exchange_2 := sload(add(exchange_ptr, 2))\r\n      let exchange_3 := sload(add(exchange_ptr, 3))\r\n      mstore(return_value_mem, 192)\r\n      mstore(add(return_value_mem, 192), 11)\r\n      mstore(add(return_value_mem, 224), exchange_0)\r\n      mstore(add(return_value_mem, 32), and(div(exchange_0, 0x10000000000000000000000000000000000000000), 0xff))\r\n      mstore(add(return_value_mem, 64), and(exchange_0, 0xffffffffffffffffffffffffffffffffffffffff))\r\n      mstore(add(return_value_mem, 96), exchange_1)\r\n      mstore(add(return_value_mem, 128), exchange_2)\r\n      mstore(add(return_value_mem, 160), exchange_3)\r\n      return(return_value_mem, 236)\r\n    }\r\n  }\r\n  \r\n  function get_exchange_balance(uint32 exchange_id, uint32 asset_id) public view \r\n  returns (uint256 exchange_balance) {\r\n    \r\n    uint256[1] memory return_value_mem;\r\n    assembly {\r\n      let exchange_ptr := add(exchanges_slot, mul(4294967300, exchange_id))\r\n      let exchange_balance_ptr := add(add(exchange_ptr, 4), asset_id)\r\n      mstore(return_value_mem, sload(exchange_balance_ptr))\r\n      return(return_value_mem, 32)\r\n    }\r\n  }\r\n  \r\n  function get_exchange_count() public view \r\n  returns (uint32 count) {\r\n    \r\n    uint256[1] memory return_value_mem;\r\n    assembly {\r\n      mstore(return_value_mem, sload(exchange_count_slot))\r\n      return(return_value_mem, 32)\r\n    }\r\n  }\r\n  \r\n  function get_asset_count() public view \r\n  returns (uint32 count) {\r\n    \r\n    uint256[1] memory return_value_mem;\r\n    assembly {\r\n      mstore(return_value_mem, sload(asset_count_slot))\r\n      return(return_value_mem, 32)\r\n    }\r\n  }\r\n  \r\n  function get_user_count() public view \r\n  returns (uint32 count) {\r\n    \r\n    uint256[1] memory return_value_mem;\r\n    assembly {\r\n      mstore(return_value_mem, sload(user_count_slot))\r\n      return(return_value_mem, 32)\r\n    }\r\n  }\r\n  \r\n  function get_user(uint64 user_id) public view \r\n  returns (\r\n    address trade_address,\r\n    address withdraw_address, address recovery_address, address recovery_address_proposed\r\n  ) {\r\n    \r\n    uint256[4] memory return_value_mem;\r\n    assembly {\r\n      let user_count := sload(user_count_slot)\r\n      if iszero(lt(user_id, user_count)) {\r\n        mstore(32, 1)\r\n        revert(63, 1)\r\n      }\r\n      let user_ptr := add(users_slot, mul(237684487561239756867226304516, user_id))\r\n      mstore(return_value_mem, sload(add(user_ptr, 0)))\r\n      mstore(add(return_value_mem, 32), sload(add(user_ptr, 1)))\r\n      mstore(add(return_value_mem, 64), sload(add(user_ptr, 2)))\r\n      mstore(add(return_value_mem, 96), sload(add(user_ptr, 3)))\r\n      return(return_value_mem, 128)\r\n    }\r\n  }\r\n  \r\n  function get_balance(uint64 user_id, uint32 asset_id) public view \r\n  returns (uint256 return_balance) {\r\n    \r\n    uint256[1] memory return_value_mem;\r\n    assembly {\r\n      let user_ptr := add(users_slot, mul(237684487561239756867226304516, user_id))\r\n      let user_balance_ptr := add(add(user_ptr, 4), asset_id)\r\n      mstore(return_value_mem, sload(user_balance_ptr))\r\n      return(return_value_mem, 32)\r\n    }\r\n  }\r\n  \r\n  function get_session(uint64 user_id, uint32 exchange_id) public view \r\n  returns (uint256 unlock_at, address trade_address) {\r\n    \r\n    uint256[2] memory return_value_mem;\r\n    assembly {\r\n      let user_ptr := add(users_slot, mul(237684487561239756867226304516, user_id))\r\n      let session_ptr := add(add(user_ptr, 4294967300), mul(55340232225423622146, exchange_id))\r\n      mstore(return_value_mem, sload(add(session_ptr, 0)))\r\n      mstore(add(return_value_mem, 32), sload(add(session_ptr, 1)))\r\n      return(return_value_mem, 64)\r\n    }\r\n  }\r\n  \r\n  function get_session_balance(uint64 user_id, uint32 exchange_id, uint32 asset_id) public view \r\n  returns (uint128 total_deposit, uint64 unsettled_withdraw_total, uint64 asset_balance) {\r\n    \r\n    uint256[3] memory return_value_mem;\r\n    assembly {\r\n      let user_ptr := add(users_slot, mul(237684487561239756867226304516, user_id))\r\n      let session_ptr := add(add(user_ptr, 4294967300), mul(55340232225423622146, exchange_id))\r\n      let session_balance_ptr := add(add(session_ptr, 2), asset_id)\r\n      let session_balance_0 := sload(session_balance_ptr)\r\n      mstore(return_value_mem, and(div(session_balance_0, 0x100000000000000000000000000000000), 0xffffffffffffffffffffffffffffffff))\r\n      mstore(add(return_value_mem, 32), and(div(session_balance_0, 0x10000000000000000), 0xffffffffffffffff))\r\n      mstore(add(return_value_mem, 64), and(session_balance_0, 0xffffffffffffffff))\r\n      return(return_value_mem, 96)\r\n    }\r\n  }\r\n  \r\n  function get_market_state(\r\n    uint64 user_id, uint32 exchange_id,\r\n    uint32 quote_asset_id, uint32 base_asset_id\r\n  ) public view \r\n  returns (\r\n    int64 quote_qty, int64 base_qty, uint64 fee_used, uint64 fee_limit,\r\n    int64 min_quote_qty, int64 min_base_qty, uint64 long_max_price, uint64 short_min_price,\r\n    uint64 limit_version, int96 quote_shift, int96 base_shift\r\n  ) {\r\n    \r\n    uint256[11] memory return_value_mem;\r\n    assembly {\r\n      base_shift := base_asset_id\r\n      quote_shift := quote_asset_id\r\n      let user_ptr := add(users_slot, mul(237684487561239756867226304516, user_id))\r\n      let exchange_session_ptr := add(add(user_ptr, 4294967300), mul(55340232225423622146, exchange_id))\r\n      let exchange_state_ptr := add(add(exchange_session_ptr, 4294967298), mul(3, or(mul(quote_shift, 4294967296), base_shift)))\r\n      let state_data_0 := sload(exchange_state_ptr)\r\n      let state_data_1 := sload(add(exchange_state_ptr, 1))\r\n      let state_data_2 := sload(add(exchange_state_ptr, 2))\r\n      {\r\n        let tmp := and(div(state_data_0, 0x1000000000000000000000000000000000000000000000000), 0xffffffffffffffff)\r\n        tmp := signextend(7, tmp)\r\n        mstore(add(return_value_mem, 0), tmp)\r\n      }\r\n      {\r\n        let tmp := and(div(state_data_0, 0x100000000000000000000000000000000), 0xffffffffffffffff)\r\n        tmp := signextend(7, tmp)\r\n        mstore(add(return_value_mem, 32), tmp)\r\n      }\r\n      mstore(add(return_value_mem, 64), and(div(state_data_0, 0x10000000000000000), 0xffffffffffffffff))\r\n      mstore(add(return_value_mem, 96), and(state_data_0, 0xffffffffffffffff))\r\n      {\r\n        let tmp := and(div(state_data_1, 0x1000000000000000000000000000000000000000000000000), 0xffffffffffffffff)\r\n        tmp := signextend(7, tmp)\r\n        mstore(add(return_value_mem, 128), tmp)\r\n      }\r\n      {\r\n        let tmp := and(div(state_data_1, 0x100000000000000000000000000000000), 0xffffffffffffffff)\r\n        tmp := signextend(7, tmp)\r\n        mstore(add(return_value_mem, 160), tmp)\r\n      }\r\n      mstore(add(return_value_mem, 192), and(div(state_data_1, 0x10000000000000000), 0xffffffffffffffff))\r\n      mstore(add(return_value_mem, 224), and(state_data_1, 0xffffffffffffffff))\r\n      mstore(add(return_value_mem, 256), and(div(state_data_2, 0x1000000000000000000000000000000000000000000000000), 0xffffffffffffffff))\r\n      {\r\n        let tmp := and(div(state_data_2, 0x1000000000000000000000000), 0xffffffffffffffffffffffff)\r\n        tmp := signextend(11, tmp)\r\n        mstore(add(return_value_mem, 288), tmp)\r\n      }\r\n      {\r\n        let tmp := and(state_data_2, 0xffffffffffffffffffffffff)\r\n        tmp := signextend(11, tmp)\r\n        mstore(add(return_value_mem, 320), tmp)\r\n      }\r\n      return(return_value_mem, 352)\r\n    }\r\n  }\r\n  \r\n  function security_lock(uint256 lock_features) public  {\r\n    assembly {\r\n      {\r\n        let creator := sload(creator_slot)\r\n        if iszero(eq(caller, creator)) {\r\n          mstore(32, 1)\r\n          revert(63, 1)\r\n        }\r\n      }\r\n      let locked_features := sload(security_locked_features_slot)\r\n      sstore(security_locked_features_slot, or(locked_features, lock_features))\r\n      sstore(security_locked_features_proposed_slot, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\r\n    }\r\n  }\r\n  \r\n  function security_propose(uint256 proposed_locked_features) public  {\r\n    assembly {\r\n      {\r\n        let creator := sload(creator_slot)\r\n        if iszero(eq(caller, creator)) {\r\n          mstore(32, 1)\r\n          revert(63, 1)\r\n        }\r\n      }\r\n      let current_proposal := sload(security_locked_features_proposed_slot)\r\n      let proposed_differences := xor(current_proposal, proposed_locked_features)\r\n      let does_unlocks_features := and(proposed_differences, not(proposed_locked_features))\r\n      if does_unlocks_features {\r\n        sstore(security_proposed_unlock_timestamp_slot, add(timestamp, 172800))\r\n      }\r\n      sstore(security_locked_features_proposed_slot, proposed_locked_features)\r\n    }\r\n  }\r\n  \r\n  function security_set_proposed() public  {\r\n    assembly {\r\n      {\r\n        let creator := sload(creator_slot)\r\n        if iszero(eq(caller, creator)) {\r\n          mstore(32, 1)\r\n          revert(63, 1)\r\n        }\r\n      }\r\n      let unlock_timestamp := sload(security_proposed_unlock_timestamp_slot)\r\n      if gt(unlock_timestamp, timestamp) {\r\n        mstore(32, 2)\r\n        revert(63, 1)\r\n      }\r\n      sstore(security_locked_features_slot, sload(security_locked_features_proposed_slot))\r\n    }\r\n  }\r\n  \r\n  function creator_update(address new_creator) public  {\r\n    assembly {\r\n      let creator_recovery := sload(creator_recovery_slot)\r\n      if iszero(eq(caller, creator_recovery)) {\r\n        mstore(32, 1)\r\n        revert(63, 1)\r\n      }\r\n      sstore(creator_slot, new_creator)\r\n    }\r\n  }\r\n  \r\n  function creator_propose_recovery(address recovery) public  {\r\n    assembly {\r\n      let creator_recovery := sload(creator_recovery_slot)\r\n      if iszero(eq(caller, creator_recovery)) {\r\n        mstore(32, 1)\r\n        revert(63, 1)\r\n      }\r\n      sstore(creator_recovery_proposed_slot, recovery)\r\n    }\r\n  }\r\n  \r\n  function creator_set_recovery() public  {\r\n    assembly {\r\n      let creator_recovery_proposed := sload(creator_recovery_proposed_slot)\r\n      if or(iszero(eq(caller, creator_recovery_proposed)), iszero(caller)) {\r\n        mstore(32, 1)\r\n        revert(63, 1)\r\n      }\r\n      sstore(creator_recovery_slot, caller)\r\n      sstore(creator_recovery_proposed_slot, 0)\r\n    }\r\n  }\r\n  \r\n  function set_exchange_locked(uint32 exchange_id, bool locked) public  {\r\n    assembly {\r\n      {\r\n        let creator := sload(creator_slot)\r\n        if iszero(eq(caller, creator)) {\r\n          mstore(32, 1)\r\n          revert(63, 1)\r\n        }\r\n      }\r\n      {\r\n        let exchange_count := sload(exchange_count_slot)\r\n        if iszero(lt(exchange_id, exchange_count)) {\r\n          mstore(32, 2)\r\n          revert(63, 1)\r\n        }\r\n      }\r\n      let exchange_ptr := add(exchanges_slot, mul(4294967300, exchange_id))\r\n      let exchange_0 := sload(exchange_ptr)\r\n      sstore(exchange_ptr, or(and(0xffffffffffffffffffffff00ffffffffffffffffffffffffffffffffffffffff, exchange_0), \r\n        /* locked */ mul(locked, 0x10000000000000000000000000000000000000000)))\r\n    }\r\n  }\r\n  \r\n  function user_create() public \r\n  returns (uint64 user_id) {\r\n    \r\n    uint256[2] memory log_data_mem;\r\n    assembly {\r\n      {\r\n        let locked_features := sload(security_locked_features_slot)\r\n        if and(locked_features, 0x4) {\r\n          mstore(32, 0)\r\n          revert(63, 1)\r\n        }\r\n      }\r\n      user_id := sload(user_count_slot)\r\n      if iszero(lt(user_id, 18446744073709551616)) {\r\n        mstore(32, 1)\r\n        revert(63, 1)\r\n      }\r\n      sstore(user_count_slot, add(user_id, 1))\r\n      let user_ptr := add(users_slot, mul(237684487561239756867226304516, user_id))\r\n      sstore(add(user_ptr, 0), caller)\r\n      sstore(add(user_ptr, 1), caller)\r\n      sstore(add(user_ptr, 2), caller)\r\n      \r\n      /* Log event: UserCreated */\r\n      mstore(log_data_mem, user_id)\r\n      log2(log_data_mem, 32, /* UserCreated */ 0x49d7af0c8ce0d26f4490c17a316a59a7a5d28599a2208862554b648ebdf193f4, caller)\r\n    }\r\n  }\r\n  \r\n  function user_set_trade_address(uint64 user_id, address trade_address) public  {\r\n    \r\n    uint256[1] memory log_data_mem;\r\n    assembly {\r\n      let user_ptr := add(users_slot, mul(237684487561239756867226304516, user_id))\r\n      let recovery_address := sload(add(user_ptr, 2))\r\n      if iszero(eq(caller, recovery_address)) {\r\n        mstore(32, 1)\r\n        revert(63, 1)\r\n      }\r\n      sstore(add(user_ptr, 0), trade_address)\r\n      \r\n      /* Log event: UserTradeAddressUpdated */\r\n      mstore(log_data_mem, user_id)\r\n      log1(log_data_mem, 32, /* UserTradeAddressUpdated */ 0x0dcac7e45506b3812319ae528c780b9035570ee3b3557272431dce5b397d880a)\r\n    }\r\n  }\r\n  \r\n  function user_set_withdraw_address(uint64 user_id, address withdraw_address) public  {\r\n    assembly {\r\n      let user_ptr := add(users_slot, mul(237684487561239756867226304516, user_id))\r\n      let recovery_address := sload(add(user_ptr, 2))\r\n      if iszero(eq(caller, recovery_address)) {\r\n        mstore(32, 1)\r\n        revert(63, 1)\r\n      }\r\n      sstore(add(user_ptr, 1), withdraw_address)\r\n    }\r\n  }\r\n  \r\n  function user_propose_recovery_address(uint64 user_id, address proposed) public  {\r\n    assembly {\r\n      let user_ptr := add(users_slot, mul(237684487561239756867226304516, user_id))\r\n      let recovery_address := sload(add(user_ptr, 2))\r\n      if iszero(eq(caller, recovery_address)) {\r\n        mstore(32, 1)\r\n        revert(63, 1)\r\n      }\r\n      sstore(add(user_ptr, 3), proposed)\r\n    }\r\n  }\r\n  \r\n  function user_set_recovery_address(uint64 user_id) public  {\r\n    assembly {\r\n      let user_ptr := add(users_slot, mul(237684487561239756867226304516, user_id))\r\n      let proposed_ptr := add(user_ptr, 3)\r\n      let recovery_address_proposed := sload(proposed_ptr)\r\n      if iszero(eq(caller, recovery_address_proposed)) {\r\n        mstore(32, 1)\r\n        revert(63, 1)\r\n      }\r\n      sstore(proposed_ptr, 0)\r\n      sstore(add(user_ptr, 2), recovery_address_proposed)\r\n    }\r\n  }\r\n  \r\n  function exchange_set_owner(uint32 exchange_id, address new_owner) public  {\r\n    assembly {\r\n      let exchange_ptr := add(exchanges_slot, mul(4294967300, exchange_id))\r\n      let exchange_recovery := sload(add(exchange_ptr, 2))\r\n      if iszero(eq(caller, exchange_recovery)) {\r\n        mstore(32, 1)\r\n        revert(63, 1)\r\n      }\r\n      let exchange_0 := sload(exchange_ptr)\r\n      sstore(exchange_ptr, or(and(exchange_0, 0xffffffffffffffffffffffff0000000000000000000000000000000000000000), \r\n        /* owner */ new_owner))\r\n    }\r\n  }\r\n  \r\n  function exchange_set_withdraw(uint32 exchange_id, address new_withdraw) public  {\r\n    assembly {\r\n      let exchange_ptr := add(exchanges_slot, mul(4294967300, exchange_id))\r\n      let exchange_recovery := sload(add(exchange_ptr, 2))\r\n      if iszero(eq(caller, exchange_recovery)) {\r\n        mstore(32, 1)\r\n        revert(63, 1)\r\n      }\r\n      sstore(add(exchange_ptr, 1), new_withdraw)\r\n    }\r\n  }\r\n  \r\n  function exchange_propose_recovery(uint32 exchange_id, address proposed) public  {\r\n    assembly {\r\n      let exchange_ptr := add(exchanges_slot, mul(4294967300, exchange_id))\r\n      let exchange_recovery := sload(add(exchange_ptr, 2))\r\n      if iszero(eq(caller, exchange_recovery)) {\r\n        mstore(32, 1)\r\n        revert(63, 1)\r\n      }\r\n      sstore(add(exchange_ptr, 3), proposed)\r\n    }\r\n  }\r\n  \r\n  function exchange_set_recovery(uint32 exchange_id) public  {\r\n    assembly {\r\n      let exchange_ptr := add(exchanges_slot, mul(4294967300, exchange_id))\r\n      let exchange_recovery_proposed := sload(add(exchange_ptr, 3))\r\n      if or(iszero(eq(caller, exchange_recovery_proposed)), iszero(caller)) {\r\n        mstore(32, 1)\r\n        revert(63, 1)\r\n      }\r\n      sstore(add(exchange_ptr, 2), caller)\r\n    }\r\n  }\r\n  \r\n  function add_asset(string memory symbol, uint192 unit_scale, address contract_address) public \r\n  returns (uint64 asset_id) {\r\n    assembly {\r\n      {\r\n        let locked_features := sload(security_locked_features_slot)\r\n        if and(locked_features, 0x1) {\r\n          mstore(32, 0)\r\n          revert(63, 1)\r\n        }\r\n      }\r\n      {\r\n        let creator := sload(creator_slot)\r\n        if iszero(eq(caller, creator)) {\r\n          mstore(32, 1)\r\n          revert(63, 1)\r\n        }\r\n      }\r\n      asset_id := sload(asset_count_slot)\r\n      if iszero(lt(asset_id, 4294967296)) {\r\n        mstore(32, 2)\r\n        revert(63, 1)\r\n      }\r\n      let symbol_len := mload(symbol)\r\n      if iszero(eq(symbol_len, 8)) {\r\n        mstore(32, 3)\r\n        revert(63, 1)\r\n      }\r\n      if iszero(unit_scale) {\r\n        mstore(32, 4)\r\n        revert(63, 1)\r\n      }\r\n      if iszero(contract_address) {\r\n        mstore(32, 5)\r\n        revert(63, 1)\r\n      }\r\n      let asset_symbol := mload(add(symbol, 32))\r\n      let asset_data_0 := or(asset_symbol, \r\n        /* unit_scale */ unit_scale)\r\n      let asset_ptr := add(assets_slot, mul(2, asset_id))\r\n      sstore(asset_ptr, asset_data_0)\r\n      sstore(add(asset_ptr, 1), contract_address)\r\n      sstore(asset_count_slot, add(asset_id, 1))\r\n    }\r\n  }\r\n  \r\n  function add_exchange(string memory name, address addr) public \r\n  returns (uint64 exchange_id) {\r\n    assembly {\r\n      {\r\n        let locked_features := sload(security_locked_features_slot)\r\n        if and(locked_features, 0x2) {\r\n          mstore(32, 0)\r\n          revert(63, 1)\r\n        }\r\n      }\r\n      {\r\n        let creator := sload(creator_slot)\r\n        if iszero(eq(caller, creator)) {\r\n          mstore(32, 1)\r\n          revert(63, 1)\r\n        }\r\n      }\r\n      let name_len := mload(name)\r\n      if iszero(eq(name_len, 11)) {\r\n        mstore(32, 2)\r\n        revert(63, 1)\r\n      }\r\n      exchange_id := sload(exchange_count_slot)\r\n      if iszero(lt(exchange_id, 4294967296)) {\r\n        mstore(32, 3)\r\n        revert(63, 1)\r\n      }\r\n      let exchange_ptr := add(exchanges_slot, mul(4294967300, exchange_id))\r\n      let name_data := mload(add(name, 32))\r\n      let exchange_0 := or(name_data, \r\n        /* owner */ addr)\r\n      sstore(exchange_ptr, exchange_0)\r\n      sstore(add(exchange_ptr, 1), addr)\r\n      sstore(add(exchange_ptr, 2), addr)\r\n      sstore(exchange_count_slot, add(exchange_id, 1))\r\n    }\r\n  }\r\n  \r\n  function exchange_withdraw(uint32 exchange_id, uint32 asset_id,\r\n                             address destination, uint64 quantity) public  {\r\n    \r\n    uint256[3] memory transfer_in_mem;\r\n    \r\n    uint256[1] memory transfer_out_mem;\r\n    assembly {\r\n      let exchange_ptr := add(exchanges_slot, mul(4294967300, exchange_id))\r\n      let withdraw_address := sload(add(exchange_ptr, 1))\r\n      if iszero(eq(caller, withdraw_address)) {\r\n        mstore(32, 1)\r\n        revert(63, 1)\r\n      }\r\n      let exchange_balance_ptr := add(add(exchange_ptr, 4), asset_id)\r\n      let exchange_balance := sload(exchange_balance_ptr)\r\n      if gt(quantity, exchange_balance) {\r\n        mstore(32, 2)\r\n        revert(63, 1)\r\n      }\r\n      sstore(exchange_balance_ptr, sub(exchange_balance, quantity))\r\n      let asset_ptr := add(assets_slot, mul(2, asset_id))\r\n      let unit_scale := and(sload(asset_ptr), 0xffffffffffffffffffffffffffffffffffffffffffffffff)\r\n      let asset_address := sload(add(asset_ptr, 1))\r\n      let withdraw := mul(quantity, unit_scale)\r\n      mstore(transfer_in_mem, /* fn_hash(\"transfer(address,uint256)\") */ 0xa9059cbb00000000000000000000000000000000000000000000000000000000)\r\n      mstore(add(transfer_in_mem, 4), destination)\r\n      mstore(add(transfer_in_mem, 36), withdraw)\r\n      {\r\n        let success := call(gas, asset_address, 0, transfer_in_mem, 68, transfer_out_mem, 32)\r\n        if iszero(success) {\r\n          mstore(32, 3)\r\n          revert(63, 1)\r\n        }\r\n        switch returndatasize\r\n          case 0 {}\r\n          case 32 {\r\n            let result := mload(transfer_out_mem)\r\n            if iszero(result) {\r\n              mstore(32, 4)\r\n              revert(63, 1)\r\n            }\r\n          }\r\n          default {\r\n            mstore(32, 4)\r\n            revert(63, 1)\r\n          }\r\n      }\r\n    }\r\n  }\r\n  \r\n  function exchange_deposit(uint32 exchange_id, uint32 asset_id, uint64 quantity) public  {\r\n    \r\n    uint256[3] memory transfer_in_mem;\r\n    \r\n    uint256[1] memory transfer_out_mem;\r\n    assembly {\r\n      {\r\n        let locked_features := sload(security_locked_features_slot)\r\n        if and(locked_features, 0x8) {\r\n          mstore(32, 0)\r\n          revert(63, 1)\r\n        }\r\n      }\r\n      {\r\n        let exchange_count := sload(exchange_count_slot)\r\n        if iszero(lt(exchange_id, exchange_count)) {\r\n          mstore(32, 1)\r\n          revert(63, 1)\r\n        }\r\n      }\r\n      {\r\n        let asset_count := sload(asset_count_slot)\r\n        if iszero(lt(asset_id, asset_count)) {\r\n          mstore(32, 2)\r\n          revert(63, 1)\r\n        }\r\n      }\r\n      let exchange_balance_ptr := add(add(add(exchanges_slot, mul(4294967300, exchange_id)), 4), asset_id)\r\n      let exchange_balance := sload(exchange_balance_ptr)\r\n      let updated_balance := add(exchange_balance, quantity)\r\n      if gt(updated_balance, 0xFFFFFFFFFFFFFFFF) {\r\n        mstore(32, 3)\r\n        revert(63, 1)\r\n      }\r\n      let asset_ptr := add(assets_slot, mul(2, asset_id))\r\n      let unit_scale := and(sload(asset_ptr), 0xffffffffffffffffffffffffffffffffffffffffffffffff)\r\n      let asset_address := sload(add(asset_ptr, 1))\r\n      let deposit := mul(quantity, unit_scale)\r\n      sstore(exchange_balance_ptr, updated_balance)\r\n      mstore(transfer_in_mem, /* fn_hash(\"transferFrom(address,address,uint256)\") */ 0x23b872dd00000000000000000000000000000000000000000000000000000000)\r\n      mstore(add(transfer_in_mem, 4), caller)\r\n      mstore(add(transfer_in_mem, 36), address)\r\n      mstore(add(transfer_in_mem, 68), deposit)\r\n      {\r\n        let success := call(gas, asset_address, 0, transfer_in_mem, 100, transfer_out_mem, 32)\r\n        if iszero(success) {\r\n          mstore(32, 4)\r\n          revert(63, 1)\r\n        }\r\n        switch returndatasize\r\n          case 0 {}\r\n          case 32 {\r\n            let result := mload(transfer_out_mem)\r\n            if iszero(result) {\r\n              mstore(32, 5)\r\n              revert(63, 1)\r\n            }\r\n          }\r\n          default {\r\n            mstore(32, 5)\r\n            revert(63, 1)\r\n          }\r\n      }\r\n    }\r\n  }\r\n  \r\n  function user_deposit(uint64 user_id, uint32 asset_id, uint256 amount) public  {\r\n    \r\n    uint256[4] memory transfer_in_mem;\r\n    \r\n    uint256[1] memory transfer_out_mem;\r\n    assembly {\r\n      {\r\n        let locked_features := sload(security_locked_features_slot)\r\n        if and(locked_features, 0x10) {\r\n          mstore(32, 0)\r\n          revert(63, 1)\r\n        }\r\n      }\r\n      {\r\n        let user_count := sload(user_count_slot)\r\n        if iszero(lt(user_id, user_count)) {\r\n          mstore(32, 1)\r\n          revert(63, 1)\r\n        }\r\n      }\r\n      {\r\n        let asset_count := sload(asset_count_slot)\r\n        if iszero(lt(asset_id, asset_count)) {\r\n          mstore(32, 2)\r\n          revert(63, 1)\r\n        }\r\n      }\r\n      if iszero(amount) {\r\n        stop()\r\n      }\r\n      let balance_ptr := add(add(add(users_slot, mul(237684487561239756867226304516, user_id)), 4), asset_id)\r\n      let current_balance := sload(balance_ptr)\r\n      let proposed_balance := add(current_balance, amount)\r\n      if lt(proposed_balance, current_balance) {\r\n        mstore(32, 3)\r\n        revert(63, 1)\r\n      }\r\n      let asset_address := sload(add(add(assets_slot, mul(2, asset_id)), 1))\r\n      sstore(balance_ptr, proposed_balance)\r\n      mstore(transfer_in_mem, /* fn_hash(\"transferFrom(address,address,uint256)\") */ 0x23b872dd00000000000000000000000000000000000000000000000000000000)\r\n      mstore(add(transfer_in_mem, 4), caller)\r\n      mstore(add(transfer_in_mem, 36), address)\r\n      mstore(add(transfer_in_mem, 68), amount)\r\n      {\r\n        let success := call(gas, asset_address, 0, transfer_in_mem, 100, transfer_out_mem, 32)\r\n        if iszero(success) {\r\n          mstore(32, 4)\r\n          revert(63, 1)\r\n        }\r\n        switch returndatasize\r\n          case 0 {}\r\n          case 32 {\r\n            let result := mload(transfer_out_mem)\r\n            if iszero(result) {\r\n              mstore(32, 5)\r\n              revert(63, 1)\r\n            }\r\n          }\r\n          default {\r\n            mstore(32, 5)\r\n            revert(63, 1)\r\n          }\r\n      }\r\n    }\r\n  }\r\n  \r\n  function user_withdraw(uint64 user_id, uint32 asset_id, address destination, uint256 amount) public  {\r\n    \r\n    uint256[3] memory transfer_in_mem;\r\n    \r\n    uint256[1] memory transfer_out_mem;\r\n    assembly {\r\n      if iszero(amount) {\r\n        stop()\r\n      }\r\n      {\r\n        let user_count := sload(user_count_slot)\r\n        if iszero(lt(user_id, user_count)) {\r\n          mstore(32, 6)\r\n          revert(63, 1)\r\n        }\r\n      }\r\n      {\r\n        let asset_count := sload(asset_count_slot)\r\n        if iszero(lt(asset_id, asset_count)) {\r\n          mstore(32, 1)\r\n          revert(63, 1)\r\n        }\r\n      }\r\n      let user_ptr := add(users_slot, mul(237684487561239756867226304516, user_id))\r\n      let withdraw_address := sload(add(user_ptr, 1))\r\n      if iszero(eq(caller, withdraw_address)) {\r\n        mstore(32, 2)\r\n        revert(63, 1)\r\n      }\r\n      let balance_ptr := add(add(user_ptr, 4), asset_id)\r\n      let current_balance := sload(balance_ptr)\r\n      if lt(current_balance, amount) {\r\n        mstore(32, 3)\r\n        revert(63, 1)\r\n      }\r\n      sstore(balance_ptr, sub(current_balance, amount))\r\n      let asset_address := sload(add(add(assets_slot, mul(2, asset_id)), 1))\r\n      mstore(transfer_in_mem, /* fn_hash(\"transfer(address,uint256)\") */ 0xa9059cbb00000000000000000000000000000000000000000000000000000000)\r\n      mstore(add(transfer_in_mem, 4), destination)\r\n      mstore(add(transfer_in_mem, 36), amount)\r\n      {\r\n        let success := call(gas, asset_address, 0, transfer_in_mem, 68, transfer_out_mem, 32)\r\n        if iszero(success) {\r\n          mstore(32, 4)\r\n          revert(63, 1)\r\n        }\r\n        switch returndatasize\r\n          case 0 {}\r\n          case 32 {\r\n            let result := mload(transfer_out_mem)\r\n            if iszero(result) {\r\n              mstore(32, 5)\r\n              revert(63, 1)\r\n            }\r\n          }\r\n          default {\r\n            mstore(32, 5)\r\n            revert(63, 1)\r\n          }\r\n      }\r\n    }\r\n  }\r\n  \r\n  function user_session_set_unlock_at(uint64 user_id, uint32 exchange_id, uint256 unlock_at) public  {\r\n    \r\n    uint256[3] memory log_data_mem;\r\n    assembly {\r\n      {\r\n        let exchange_count := sload(exchange_count_slot)\r\n        if iszero(lt(exchange_id, exchange_count)) {\r\n          mstore(32, 1)\r\n          revert(63, 1)\r\n        }\r\n      }\r\n      let user_ptr := add(users_slot, mul(237684487561239756867226304516, user_id))\r\n      let trade_address := sload(add(user_ptr, 0))\r\n      if iszero(eq(caller, trade_address)) {\r\n        mstore(32, 2)\r\n        revert(63, 1)\r\n      }\r\n      {\r\n        let fails_min_time := lt(unlock_at, add(timestamp, 28800))\r\n        let fails_max_time := gt(unlock_at, add(timestamp, 1209600))\r\n        if or(fails_min_time, fails_max_time) {\r\n          mstore(32, 3)\r\n          revert(63, 1)\r\n        }\r\n      }\r\n      let session_ptr := add(add(user_ptr, 4294967300), mul(55340232225423622146, exchange_id))\r\n      let unlock_at_ptr := add(session_ptr, 0)\r\n      if lt(sload(unlock_at_ptr), timestamp) {\r\n        sstore(add(session_ptr, 1), caller)\r\n      }\r\n      sstore(unlock_at_ptr, unlock_at)\r\n      \r\n      /* Log event: SessionUpdated */\r\n      mstore(log_data_mem, user_id)\r\n      mstore(add(log_data_mem, 32), exchange_id)\r\n      log1(log_data_mem, 64, /* SessionUpdated */ 0x1b0c381a98d9352dd527280acefa9a69d2c111b6a9d3aa3063aac6c2ec7f3163)\r\n    }\r\n  }\r\n  \r\n  function user_market_reset(uint64 user_id, uint32 exchange_id,\r\n                             uint32 quote_asset_id, uint32 base_asset_id) public  {\r\n    assembly {\r\n      {\r\n        let locked_features := sload(security_locked_features_slot)\r\n        if and(locked_features, 0x400) {\r\n          mstore(32, 0)\r\n          revert(63, 1)\r\n        }\r\n      }\r\n      {\r\n        let exchange_count := sload(exchange_count_slot)\r\n        if iszero(lt(exchange_id, exchange_count)) {\r\n          mstore(32, 1)\r\n          revert(63, 1)\r\n        }\r\n      }\r\n      let user_ptr := add(users_slot, mul(237684487561239756867226304516, user_id))\r\n      let trade_address := sload(add(user_ptr, 0))\r\n      if iszero(eq(caller, trade_address)) {\r\n        mstore(32, 2)\r\n        revert(63, 1)\r\n      }\r\n      let session_ptr := add(add(user_ptr, 4294967300), mul(55340232225423622146, exchange_id))\r\n      let unlock_at := sload(add(session_ptr, 0))\r\n      if gt(unlock_at, timestamp) {\r\n        mstore(32, 3)\r\n        revert(63, 1)\r\n      }\r\n      let market_state_ptr := add(add(session_ptr, 4294967298), mul(3, or(mul(quote_asset_id, 4294967296), base_asset_id)))\r\n      sstore(market_state_ptr, 0)\r\n      sstore(add(market_state_ptr, 1), 0)\r\n      let market_state_2_ptr := add(market_state_ptr, 2)\r\n      let market_state_2 := sload(market_state_2_ptr)\r\n      let limit_version := add(and(div(market_state_2, 0x1000000000000000000000000000000000000000000000000), 0xffffffffffffffff), 1)\r\n      sstore(market_state_2_ptr, \r\n        /* limit_version */ mul(limit_version, 0x1000000000000000000000000000000000000000000000000))\r\n    }\r\n  }\r\n  \r\n  function transfer_to_session(uint64 user_id, uint32 exchange_id, uint32 asset_id, uint64 quantity) public  {\r\n    \r\n    uint256[4] memory log_data_mem;\r\n    assembly {\r\n      {\r\n        let locked_features := sload(security_locked_features_slot)\r\n        if and(locked_features, 0x20) {\r\n          mstore(32, 0)\r\n          revert(63, 1)\r\n        }\r\n      }\r\n      {\r\n        let exchange_count := sload(exchange_count_slot)\r\n        if iszero(lt(exchange_id, exchange_count)) {\r\n          mstore(32, 1)\r\n          revert(63, 1)\r\n        }\r\n      }\r\n      {\r\n        let asset_count := sload(asset_count_slot)\r\n        if iszero(lt(asset_id, asset_count)) {\r\n          mstore(32, 2)\r\n          revert(63, 1)\r\n        }\r\n      }\r\n      if iszero(quantity) {\r\n        stop()\r\n      }\r\n      let asset_ptr := add(assets_slot, mul(2, asset_id))\r\n      let unit_scale := and(sload(asset_ptr), 0xffffffffffffffffffffffffffffffffffffffffffffffff)\r\n      let scaled_quantity := mul(quantity, unit_scale)\r\n      let user_ptr := add(users_slot, mul(237684487561239756867226304516, user_id))\r\n      {\r\n        let withdraw_address := sload(add(user_ptr, 1))\r\n        if iszero(eq(caller, withdraw_address)) {\r\n          mstore(32, 3)\r\n          revert(63, 1)\r\n        }\r\n      }\r\n      let user_balance_ptr := add(add(user_ptr, 4), asset_id)\r\n      let user_balance := sload(user_balance_ptr)\r\n      if lt(user_balance, scaled_quantity) {\r\n        mstore(32, 4)\r\n        revert(63, 1)\r\n      }\r\n      let session_balance_ptr := add(add(add(add(user_ptr, 4294967300), mul(55340232225423622146, exchange_id)), 2), asset_id)\r\n      let session_balance_0 := sload(session_balance_ptr)\r\n      let updated_exchange_balance := add(and(session_balance_0, 0xffffffffffffffff), quantity)\r\n      if gt(updated_exchange_balance, 0xFFFFFFFFFFFFFFFF) {\r\n        mstore(32, 5)\r\n        revert(63, 1)\r\n      }\r\n      let updated_total_deposit := add(and(div(session_balance_0, 0x100000000000000000000000000000000), 0xffffffffffffffffffffffffffffffff), quantity)\r\n      sstore(user_balance_ptr, sub(user_balance, scaled_quantity))\r\n      sstore(session_balance_ptr, or(and(0xffffffffffffffff0000000000000000, session_balance_0), or(\r\n        /* total_deposit */ mul(updated_total_deposit, 0x100000000000000000000000000000000), \r\n        /* asset_balance */ updated_exchange_balance)))\r\n      \r\n      /* Log event: ExchangeDeposit */\r\n      mstore(log_data_mem, user_id)\r\n      mstore(add(log_data_mem, 32), exchange_id)\r\n      mstore(add(log_data_mem, 64), asset_id)\r\n      log1(log_data_mem, 96, /* ExchangeDeposit */ 0x7a2923ebfa019dc20de0ae2be0c8639b07e068b143e98ed7f7a74dc4d4f5ab45)\r\n    }\r\n  }\r\n  \r\n  function transfer_from_session(uint64 user_id, uint32 exchange_id, uint32 asset_id, uint64 quantity) public  {\r\n    \r\n    uint256[4] memory log_data_mem;\r\n    assembly {\r\n      if iszero(quantity) {\r\n        stop()\r\n      }\r\n      {\r\n        let exchange_count := sload(exchange_count_slot)\r\n        if iszero(lt(exchange_id, exchange_count)) {\r\n          mstore(32, 1)\r\n          revert(63, 1)\r\n        }\r\n      }\r\n      {\r\n        let asset_count := sload(asset_count_slot)\r\n        if iszero(lt(asset_id, asset_count)) {\r\n          mstore(32, 2)\r\n          revert(63, 1)\r\n        }\r\n      }\r\n      let user_ptr := add(users_slot, mul(237684487561239756867226304516, user_id))\r\n      {\r\n        let trade_address := sload(add(user_ptr, 0))\r\n        if iszero(eq(caller, trade_address)) {\r\n          mstore(32, 3)\r\n          revert(63, 1)\r\n        }\r\n      }\r\n      let session_ptr := add(add(user_ptr, 4294967300), mul(55340232225423622146, exchange_id))\r\n      {\r\n        let session_0 := sload(session_ptr)\r\n        let unlock_at := session_0\r\n        if gt(unlock_at, timestamp) {\r\n          mstore(32, 4)\r\n          revert(63, 1)\r\n        }\r\n      }\r\n      let session_balance_ptr := add(add(session_ptr, 2), asset_id)\r\n      let session_balance_0 := sload(session_balance_ptr)\r\n      let session_balance := and(session_balance_0, 0xffffffffffffffff)\r\n      if gt(quantity, session_balance) {\r\n        mstore(32, 5)\r\n        revert(63, 1)\r\n      }\r\n      let updated_exchange_balance := sub(session_balance, quantity)\r\n      let unsettled_withdraw_total := and(div(session_balance_0, 0x10000000000000000), 0xffffffffffffffff)\r\n      if lt(updated_exchange_balance, unsettled_withdraw_total) {\r\n        mstore(32, 6)\r\n        revert(63, 1)\r\n      }\r\n      sstore(session_balance_ptr, or(and(0xffffffffffffffffffffffffffffffffffffffffffffffff0000000000000000, session_balance_0), \r\n        /* asset_balance */ updated_exchange_balance))\r\n      let asset_ptr := add(assets_slot, mul(2, asset_id))\r\n      let unit_scale := and(sload(asset_ptr), 0xffffffffffffffffffffffffffffffffffffffffffffffff)\r\n      let scaled_quantity := mul(quantity, unit_scale)\r\n      let user_balance_ptr := add(add(user_ptr, 4), asset_id)\r\n      let user_balance := sload(user_balance_ptr)\r\n      let updated_user_balance := add(user_balance, scaled_quantity)\r\n      if lt(updated_user_balance, user_balance) {\r\n        mstore(32, 7)\r\n        revert(63, 1)\r\n      }\r\n      sstore(user_balance_ptr, updated_user_balance)\r\n    }\r\n  }\r\n  \r\n  function user_deposit_to_session(uint64 user_id, uint32 exchange_id, uint32 asset_id, uint64 quantity) public  {\r\n    \r\n    uint256[4] memory transfer_in_mem;\r\n    \r\n    uint256[1] memory transfer_out_mem;\r\n    \r\n    uint256[3] memory log_data_mem;\r\n    assembly {\r\n      {\r\n        let locked_features := sload(security_locked_features_slot)\r\n        if and(locked_features, 0x40) {\r\n          mstore(32, 0)\r\n          revert(63, 1)\r\n        }\r\n      }\r\n      {\r\n        let exchange_count := sload(exchange_count_slot)\r\n        if iszero(lt(exchange_id, exchange_count)) {\r\n          mstore(32, 1)\r\n          revert(63, 1)\r\n        }\r\n      }\r\n      {\r\n        let asset_count := sload(asset_count_slot)\r\n        if iszero(lt(asset_id, asset_count)) {\r\n          mstore(32, 2)\r\n          revert(63, 1)\r\n        }\r\n      }\r\n      if iszero(quantity) {\r\n        stop()\r\n      }\r\n      let session_balance_ptr := add(add(add(add(add(users_slot, mul(237684487561239756867226304516, user_id)), 4294967300), mul(55340232225423622146, exchange_id)), 2), asset_id)\r\n      let session_balance_0 := sload(session_balance_ptr)\r\n      let updated_exchange_balance := add(and(session_balance_0, 0xffffffffffffffff), quantity)\r\n      if gt(updated_exchange_balance, 0xFFFFFFFFFFFFFFFF) {\r\n        mstore(32, 3)\r\n        revert(63, 1)\r\n      }\r\n      let asset_ptr := add(assets_slot, mul(2, asset_id))\r\n      let unit_scale := and(sload(asset_ptr), 0xffffffffffffffffffffffffffffffffffffffffffffffff)\r\n      let asset_address := sload(add(asset_ptr, 1))\r\n      let scaled_quantity := mul(quantity, unit_scale)\r\n      let updated_total_deposit := add(and(div(session_balance_0, 0x100000000000000000000000000000000), 0xffffffffffffffffffffffffffffffff), quantity)\r\n      sstore(session_balance_ptr, or(and(0xffffffffffffffff0000000000000000, session_balance_0), or(\r\n        /* total_deposit */ mul(updated_total_deposit, 0x100000000000000000000000000000000), \r\n        /* asset_balance */ updated_exchange_balance)))\r\n      mstore(transfer_in_mem, /* fn_hash(\"transferFrom(address,address,uint256)\") */ 0x23b872dd00000000000000000000000000000000000000000000000000000000)\r\n      mstore(add(transfer_in_mem, 4), caller)\r\n      mstore(add(transfer_in_mem, 36), address)\r\n      mstore(add(transfer_in_mem, 68), scaled_quantity)\r\n      {\r\n        let success := call(gas, asset_address, 0, transfer_in_mem, 100, transfer_out_mem, 32)\r\n        if iszero(success) {\r\n          mstore(32, 4)\r\n          revert(63, 1)\r\n        }\r\n        switch returndatasize\r\n          case 0 {}\r\n          case 32 {\r\n            let result := mload(transfer_out_mem)\r\n            if iszero(result) {\r\n              mstore(32, 5)\r\n              revert(63, 1)\r\n            }\r\n          }\r\n          default {\r\n            mstore(32, 5)\r\n            revert(63, 1)\r\n          }\r\n      }\r\n      \r\n      /* Log event: ExchangeDeposit */\r\n      mstore(log_data_mem, user_id)\r\n      mstore(add(log_data_mem, 32), exchange_id)\r\n      mstore(add(log_data_mem, 64), asset_id)\r\n      log1(log_data_mem, 96, /* ExchangeDeposit */ 0x7a2923ebfa019dc20de0ae2be0c8639b07e068b143e98ed7f7a74dc4d4f5ab45)\r\n    }\r\n  }\r\n  struct UnsettledWithdrawHeader {\r\n    uint32 exchange_id;\r\n    uint32 asset_id;\r\n    uint32 user_count;\r\n  }\r\n  struct UnsettledWithdrawUser {\r\n    uint64 user_id;\r\n  }\r\n  \r\n  function recover_unsettled_withdraws(bytes memory data) public  {\r\n    assembly {\r\n      {\r\n        let locked_features := sload(security_locked_features_slot)\r\n        if and(locked_features, 0x800) {\r\n          mstore(32, 0)\r\n          revert(63, 1)\r\n        }\r\n      }\r\n      let data_len := mload(data)\r\n      let cursor := add(data, 32)\r\n      let cursor_end := add(cursor, data_len)\r\n      for {} lt(cursor, cursor_end) {} {\r\n        let unsettled_withdraw_header_0 := mload(cursor)\r\n        let exchange_id := and(div(unsettled_withdraw_header_0, 0x100000000000000000000000000000000000000000000000000000000), 0xffffffff)\r\n        let asset_id := and(div(unsettled_withdraw_header_0, 0x1000000000000000000000000000000000000000000000000), 0xffffffff)\r\n        let user_count := and(div(unsettled_withdraw_header_0, 0x10000000000000000000000000000000000000000), 0xffffffff)\r\n        let group_end := add(cursor, add(12, mul(user_count, 8)))\r\n        if gt(group_end, cursor_end) {\r\n          mstore(32, 1)\r\n          revert(63, 1)\r\n        }\r\n        let exchange_balance_ptr := add(add(add(exchanges_slot, mul(4294967300, exchange_id)), 4), asset_id)\r\n        let exchange_balance := sload(exchange_balance_ptr)\r\n        let start_exchange_balance := exchange_balance\r\n        for {} lt(cursor, group_end) {\r\n          cursor := add(cursor, 8)\r\n        } {\r\n          let user_id := and(div(mload(cursor), 0x1000000000000000000000000000000000000000000000000), 0xffffffffffffffff)\r\n          let session_balance_ptr := add(add(add(add(add(users_slot, mul(237684487561239756867226304516, user_id)), 4294967300), mul(55340232225423622146, exchange_id)), 2), asset_id)\r\n          let session_balance_0 := sload(session_balance_ptr)\r\n          let asset_balance := and(session_balance_0, 0xffffffffffffffff)\r\n          let unsettled_balance := and(div(session_balance_0, 0x10000000000000000), 0xffffffffffffffff)\r\n          let to_recover := unsettled_balance\r\n          if gt(to_recover, asset_balance) {\r\n            to_recover := asset_balance\r\n          }\r\n          if to_recover {\r\n            exchange_balance := add(exchange_balance, to_recover)\r\n            asset_balance := sub(asset_balance, to_recover)\r\n            unsettled_balance := sub(unsettled_balance, to_recover)\r\n            if gt(start_exchange_balance, exchange_balance) {\r\n              mstore(32, 2)\r\n              revert(63, 1)\r\n            }\r\n            sstore(session_balance_ptr, or(and(0xffffffffffffffffffffffffffffffff00000000000000000000000000000000, session_balance_0), or(\r\n              /* unsettled_withdraw_total */ mul(unsettled_balance, 0x10000000000000000), \r\n              /* asset_balance */ asset_balance)))\r\n          }\r\n        }\r\n        sstore(exchange_balance_ptr, exchange_balance)\r\n      }\r\n    }\r\n  }\r\n  struct ExchangeTransfersHeader {\r\n    uint32 exchange_id;\r\n  }\r\n  struct ExchangeTransferGroup {\r\n    uint32 asset_id;\r\n    uint8 allow_overdraft;\r\n    uint8 transfer_count;\r\n  }\r\n  struct ExchangeTransfer {\r\n    uint64 user_id;\r\n    uint64 quantity;\r\n  }\r\n  \r\n  function exchange_transfer_from(bytes memory data) public  {\r\n    assembly {\r\n      {\r\n        let locked_features := sload(security_locked_features_slot)\r\n        if and(locked_features, 0x80) {\r\n          mstore(32, 0)\r\n          revert(63, 1)\r\n        }\r\n      }\r\n      let data_len := mload(data)\r\n      let cursor := add(data, 32)\r\n      let cursor_end := add(cursor, data_len)\r\n      let header_0 := mload(cursor)\r\n      cursor := add(cursor, 4)\r\n      if gt(cursor, cursor_end) {\r\n        mstore(32, 1)\r\n        revert(63, 1)\r\n      }\r\n      let exchange_id := and(div(header_0, 0x100000000000000000000000000000000000000000000000000000000), 0xffffffff)\r\n      {\r\n        let exchange_count := sload(exchange_count_slot)\r\n        if iszero(lt(exchange_id, exchange_count)) {\r\n          mstore(32, 2)\r\n          revert(63, 1)\r\n        }\r\n      }\r\n      {\r\n        let exchange_data := sload(add(exchanges_slot, mul(4294967300, exchange_id)))\r\n        if iszero(eq(caller, and(exchange_data, 0xffffffffffffffffffffffffffffffffffffffff))) {\r\n          mstore(32, 3)\r\n          revert(63, 1)\r\n        }\r\n        if and(div(exchange_data, 0x10000000000000000000000000000000000000000), 0xff) {\r\n          mstore(32, 4)\r\n          revert(63, 1)\r\n        }\r\n      }\r\n      let asset_count := sload(asset_count_slot)\r\n      for {} lt(cursor, cursor_end) {} {\r\n        let group_0 := mload(cursor)\r\n        cursor := add(cursor, 6)\r\n        if gt(cursor, cursor_end) {\r\n          mstore(32, 5)\r\n          revert(63, 1)\r\n        }\r\n        let asset_id := and(div(group_0, 0x100000000000000000000000000000000000000000000000000000000), 0xffffffff)\r\n        if iszero(lt(asset_id, asset_count)) {\r\n          mstore(32, 6)\r\n          revert(63, 1)\r\n        }\r\n        let disallow_overdraft := iszero(and(div(group_0, 0x1000000000000000000000000000000000000000000000000000000), 0xff))\r\n        let cursor_group_end := add(cursor, mul(and(div(group_0, 0x10000000000000000000000000000000000000000000000000000), 0xff), 16))\r\n        if gt(cursor_group_end, cursor_end) {\r\n          mstore(32, 7)\r\n          revert(63, 1)\r\n        }\r\n        let exchange_balance_ptr := add(add(add(exchanges_slot, mul(4294967300, exchange_id)), 4), asset_id)\r\n        let exchange_balance_remaining := sload(exchange_balance_ptr)\r\n        let unit_scale := and(sload(add(assets_slot, mul(2, asset_id))), 0xffffffffffffffffffffffffffffffffffffffffffffffff)\r\n        for {} lt(cursor, cursor_group_end) {\r\n          cursor := add(cursor, 16)\r\n        } {\r\n          let transfer_0 := mload(cursor)\r\n          let user_ptr := add(users_slot, mul(237684487561239756867226304516, and(div(transfer_0, 0x1000000000000000000000000000000000000000000000000), 0xffffffffffffffff)))\r\n          let quantity := and(div(transfer_0, 0x100000000000000000000000000000000), 0xffffffffffffffff)\r\n          let exchange_balance_used := 0\r\n          let session_balance_ptr := add(add(add(add(user_ptr, 4294967300), mul(55340232225423622146, exchange_id)), 2), asset_id)\r\n          let session_balance_0 := sload(session_balance_ptr)\r\n          let session_balance := and(session_balance_0, 0xffffffffffffffff)\r\n          let session_balance_updated := sub(session_balance, quantity)\r\n          if gt(session_balance_updated, session_balance) {\r\n            if disallow_overdraft {\r\n              mstore(32, 8)\r\n              revert(63, 1)\r\n            }\r\n            exchange_balance_used := sub(quantity, session_balance)\r\n            session_balance_updated := 0\r\n            if gt(exchange_balance_used, exchange_balance_remaining) {\r\n              mstore(32, 9)\r\n              revert(63, 1)\r\n            }\r\n            exchange_balance_remaining := sub(exchange_balance_remaining, exchange_balance_used)\r\n          }\r\n          let quantity_scaled := mul(quantity, unit_scale)\r\n          let user_balance_ptr := add(add(user_ptr, 4), asset_id)\r\n          let user_balance := sload(user_balance_ptr)\r\n          let updated_user_balance := add(user_balance, quantity_scaled)\r\n          if gt(user_balance, updated_user_balance) {\r\n            mstore(32, 10)\r\n            revert(63, 1)\r\n          }\r\n          let unsettled_withdraw_total_updated := add(and(div(session_balance_0, 0x10000000000000000), 0xffffffffffffffff), exchange_balance_used)\r\n          if gt(unsettled_withdraw_total_updated, 0xFFFFFFFFFFFFFFFF) {\r\n            mstore(32, 11)\r\n            revert(63, 1)\r\n          }\r\n          sstore(session_balance_ptr, or(and(0xffffffffffffffffffffffffffffffff00000000000000000000000000000000, session_balance_0), or(\r\n            /* unsettled_withdraw_total */ mul(unsettled_withdraw_total_updated, 0x10000000000000000), \r\n            /* asset_balance */ session_balance_updated)))\r\n          sstore(user_balance_ptr, updated_user_balance)\r\n        }\r\n        sstore(exchange_balance_ptr, exchange_balance_remaining)\r\n      }\r\n    }\r\n  }\r\n  struct SetLimitsHeader {\r\n    uint32 exchange_id;\r\n  }\r\n  struct Signature {\r\n    uint256 sig_r;\r\n    uint256 sig_s;\r\n    uint8 sig_v;\r\n  }\r\n  struct UpdateLimit {\r\n    uint32 dcn_id;\r\n    uint64 user_id;\r\n    uint32 exchange_id;\r\n    uint32 quote_asset_id;\r\n    uint32 base_asset_id;\r\n    uint64 fee_limit;\r\n    int64 min_quote_qty;\r\n    int64 min_base_qty;\r\n    uint64 long_max_price;\r\n    uint64 short_min_price;\r\n    uint64 limit_version;\r\n    uint96 quote_shift;\r\n    uint96 base_shift;\r\n  }\r\n  struct SetLimitMemory {\r\n    uint256 user_id;\r\n    uint256 exchange_id;\r\n    uint256 quote_asset_id;\r\n    uint256 base_asset_id;\r\n    uint256 limit_version;\r\n    uint256 quote_shift;\r\n    uint256 base_shift;\r\n  }\r\n  \r\n  function exchange_set_limits(bytes memory data) public  {\r\n    \r\n    uint256[14] memory to_hash_mem;\r\n    uint256 cursor;\r\n    uint256 cursor_end;\r\n    uint256 exchange_id;\r\n    \r\n    uint256[224] memory set_limit_memory_space;\r\n    assembly {\r\n      {\r\n        let locked_features := sload(security_locked_features_slot)\r\n        if and(locked_features, 0x100) {\r\n          mstore(32, 0)\r\n          revert(63, 1)\r\n        }\r\n      }\r\n      let data_size := mload(data)\r\n      cursor := add(data, 32)\r\n      cursor_end := add(cursor, data_size)\r\n      let set_limits_header_0 := mload(cursor)\r\n      cursor := add(cursor, 4)\r\n      if gt(cursor, cursor_end) {\r\n        mstore(32, 1)\r\n        revert(63, 1)\r\n      }\r\n      exchange_id := and(div(set_limits_header_0, 0x100000000000000000000000000000000000000000000000000000000), 0xffffffff)\r\n      let exchange_0 := sload(add(exchanges_slot, mul(4294967300, exchange_id)))\r\n      let exchange_owner := and(exchange_0, 0xffffffffffffffffffffffffffffffffffffffff)\r\n      if iszero(eq(caller, exchange_owner)) {\r\n        mstore(32, 2)\r\n        revert(63, 1)\r\n      }\r\n      if and(div(exchange_0, 0x10000000000000000000000000000000000000000), 0xff) {\r\n        mstore(32, 3)\r\n        revert(63, 1)\r\n      }\r\n    }\r\n    while (true)\r\n    {\r\n        uint256 update_limit_0;\r\n        uint256 update_limit_1;\r\n        uint256 update_limit_2;\r\n        bytes32 limit_hash;\r\n        assembly {\r\n          if eq(cursor, cursor_end) {\r\n            return(0, 0)\r\n          }\r\n          update_limit_0 := mload(cursor)\r\n          update_limit_1 := mload(add(cursor, 32))\r\n          update_limit_2 := mload(add(cursor, 64))\r\n          cursor := add(cursor, 96)\r\n          if gt(cursor, cursor_end) {\r\n            mstore(32, 4)\r\n            revert(63, 1)\r\n          }\r\n          {\r\n            mstore(to_hash_mem, 0xbe6b685e53075dd48bdabc4949b848400d5a7e53705df48e04ace664c3946ad2)\r\n            let temp_var := 0\r\n            temp_var := and(div(update_limit_0, 0x100000000000000000000000000000000000000000000000000000000), 0xffffffff)\r\n            mstore(add(to_hash_mem, 32), temp_var)\r\n            temp_var := and(div(update_limit_0, 0x10000000000000000000000000000000000000000), 0xffffffffffffffff)\r\n            mstore(add(to_hash_mem, 64), temp_var)\r\n            mstore(add(set_limit_memory_space, 0), temp_var)\r\n            temp_var := and(div(update_limit_0, 0x100000000000000000000000000000000), 0xffffffff)\r\n            mstore(add(to_hash_mem, 96), temp_var)\r\n            temp_var := and(div(update_limit_0, 0x1000000000000000000000000), 0xffffffff)\r\n            mstore(add(to_hash_mem, 128), temp_var)\r\n            mstore(add(set_limit_memory_space, 64), temp_var)\r\n            temp_var := and(div(update_limit_0, 0x10000000000000000), 0xffffffff)\r\n            mstore(add(to_hash_mem, 160), temp_var)\r\n            mstore(add(set_limit_memory_space, 96), temp_var)\r\n            temp_var := and(update_limit_0, 0xffffffffffffffff)\r\n            mstore(add(to_hash_mem, 192), temp_var)\r\n            temp_var := and(div(update_limit_1, 0x1000000000000000000000000000000000000000000000000), 0xffffffffffffffff)\r\n            temp_var := signextend(7, temp_var)\r\n            mstore(add(to_hash_mem, 224), temp_var)\r\n            temp_var := and(div(update_limit_1, 0x100000000000000000000000000000000), 0xffffffffffffffff)\r\n            temp_var := signextend(7, temp_var)\r\n            mstore(add(to_hash_mem, 256), temp_var)\r\n            temp_var := and(div(update_limit_1, 0x10000000000000000), 0xffffffffffffffff)\r\n            mstore(add(to_hash_mem, 288), temp_var)\r\n            temp_var := and(update_limit_1, 0xffffffffffffffff)\r\n            mstore(add(to_hash_mem, 320), temp_var)\r\n            temp_var := and(div(update_limit_2, 0x1000000000000000000000000000000000000000000000000), 0xffffffffffffffff)\r\n            mstore(add(to_hash_mem, 352), temp_var)\r\n            mstore(add(set_limit_memory_space, 128), temp_var)\r\n            temp_var := and(div(update_limit_2, 0x1000000000000000000000000), 0xffffffffffffffffffffffff)\r\n            temp_var := signextend(11, temp_var)\r\n            mstore(add(to_hash_mem, 384), temp_var)\r\n            mstore(add(set_limit_memory_space, 160), temp_var)\r\n            temp_var := and(update_limit_2, 0xffffffffffffffffffffffff)\r\n            temp_var := signextend(11, temp_var)\r\n            mstore(add(to_hash_mem, 416), temp_var)\r\n            mstore(add(set_limit_memory_space, 192), temp_var)\r\n          }\r\n          limit_hash := keccak256(to_hash_mem, 448)\r\n          mstore(to_hash_mem, 0x1901000000000000000000000000000000000000000000000000000000000000)\r\n          mstore(add(to_hash_mem, 2), 0xe3d3073cc59e3a3126c17585a7e516a048e61a9a1c82144af982d1c194b18710)\r\n          mstore(add(to_hash_mem, 34), limit_hash)\r\n          limit_hash := keccak256(to_hash_mem, 66)\r\n        }\r\n        {\r\n          bytes32 sig_r;\r\n          bytes32 sig_s;\r\n          uint8 sig_v;\r\n          assembly {\r\n            sig_r := mload(cursor)\r\n            sig_s := mload(add(cursor, 32))\r\n            sig_v := and(div(mload(add(cursor, 64)), 0x100000000000000000000000000000000000000000000000000000000000000), 0xff)\r\n            cursor := add(cursor, 65)\r\n            if gt(cursor, cursor_end) {\r\n              mstore(32, 5)\r\n              revert(63, 1)\r\n            }\r\n          }\r\n          uint256 recovered_address = uint256(ecrecover(\r\n                     limit_hash,\r\n                  sig_v,\r\n                  sig_r,\r\n                  sig_s\r\n        ));\r\n          assembly {\r\n            let user_ptr := add(users_slot, mul(237684487561239756867226304516, mload(add(set_limit_memory_space, 0))))\r\n            let session_ptr := add(add(user_ptr, 4294967300), mul(55340232225423622146, exchange_id))\r\n            let trade_address := sload(add(session_ptr, 1))\r\n            if iszero(eq(recovered_address, trade_address)) {\r\n              mstore(32, 6)\r\n              revert(63, 1)\r\n            }\r\n          }\r\n        }\r\n        assembly {\r\n          {\r\n            if iszero(eq(mload(add(set_limit_memory_space, 32)), exchange_id)) {\r\n              mstore(32, 7)\r\n              revert(63, 1)\r\n            }\r\n          }\r\n          let user_ptr := add(users_slot, mul(237684487561239756867226304516, mload(add(set_limit_memory_space, 0))))\r\n          let session_ptr := add(add(user_ptr, 4294967300), mul(55340232225423622146, exchange_id))\r\n          let market_state_ptr := add(add(session_ptr, 4294967298), mul(3, or(mul(mload(add(set_limit_memory_space, 64)), 4294967296), mload(add(set_limit_memory_space, 96)))))\r\n          let market_state_0 := sload(market_state_ptr)\r\n          let market_state_1 := sload(add(market_state_ptr, 1))\r\n          let market_state_2 := sload(add(market_state_ptr, 2))\r\n          {\r\n            let current_limit_version := and(div(market_state_2, 0x1000000000000000000000000000000000000000000000000), 0xffffffffffffffff)\r\n            if iszero(gt(mload(add(set_limit_memory_space, 128)), current_limit_version)) {\r\n              mstore(32, 8)\r\n              revert(63, 1)\r\n            }\r\n          }\r\n          let quote_qty := and(div(market_state_0, 0x1000000000000000000000000000000000000000000000000), 0xffffffffffffffff)\r\n          quote_qty := signextend(7, quote_qty)\r\n          let base_qty := and(div(market_state_0, 0x100000000000000000000000000000000), 0xffffffffffffffff)\r\n          base_qty := signextend(7, base_qty)\r\n          {\r\n            let current_shift := and(div(market_state_2, 0x1000000000000000000000000), 0xffffffffffffffffffffffff)\r\n            current_shift := signextend(11, current_shift)\r\n            let new_shift := mload(add(set_limit_memory_space, 160))\r\n            quote_qty := add(quote_qty, sub(new_shift, current_shift))\r\n            if or(slt(quote_qty, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF8000000000000000), sgt(quote_qty, 0x7FFFFFFFFFFFFFFF)) {\r\n              mstore(32, 9)\r\n              revert(63, 1)\r\n            }\r\n          }\r\n          {\r\n            let current_shift := and(market_state_2, 0xffffffffffffffffffffffff)\r\n            current_shift := signextend(11, current_shift)\r\n            let new_shift := mload(add(set_limit_memory_space, 192))\r\n            base_qty := add(base_qty, sub(new_shift, current_shift))\r\n            if or(slt(base_qty, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF8000000000000000), sgt(base_qty, 0x7FFFFFFFFFFFFFFF)) {\r\n              mstore(32, 10)\r\n              revert(63, 1)\r\n            }\r\n          }\r\n          let new_market_state_0 := or(or(or(\r\n            /* quote_qty */ mul(and(quote_qty, 0xffffffffffffffff), 0x1000000000000000000000000000000000000000000000000), \r\n            /* base_qty */ mul(and(base_qty, 0xffffffffffffffff), 0x100000000000000000000000000000000)), \r\n            /* fee_limit */ and(update_limit_0, 0xffffffffffffffff)), and(0xffffffffffffffff0000000000000000, market_state_0))\r\n          sstore(market_state_ptr, new_market_state_0)\r\n          sstore(add(market_state_ptr, 1), update_limit_1)\r\n          sstore(add(market_state_ptr, 2), update_limit_2)\r\n        }\r\n      }\r\n  }\r\n  struct ExchangeId {\r\n    uint32 exchange_id;\r\n  }\r\n  struct GroupHeader {\r\n    uint32 quote_asset_id;\r\n    uint32 base_asset_id;\r\n    uint8 user_count;\r\n  }\r\n  struct Settlement {\r\n    uint64 user_id;\r\n    int64 quote_delta;\r\n    int64 base_delta;\r\n    uint64 fees;\r\n  }\r\n  \r\n  function exchange_apply_settlement_groups(bytes memory data) public  {\r\n    \r\n    uint256[6] memory variables;\r\n    assembly {\r\n      {\r\n        let locked_features := sload(security_locked_features_slot)\r\n        if and(locked_features, 0x200) {\r\n          mstore(32, 0)\r\n          revert(63, 1)\r\n        }\r\n      }\r\n      let data_len := mload(data)\r\n      let cursor := add(data, 32)\r\n      let cursor_end := add(cursor, data_len)\r\n      let exchange_id_0 := mload(cursor)\r\n      cursor := add(cursor, 4)\r\n      if gt(cursor, cursor_end) {\r\n        mstore(32, 1)\r\n        revert(63, 1)\r\n      }\r\n      let exchange_id := and(div(exchange_id_0, 0x100000000000000000000000000000000000000000000000000000000), 0xffffffff)\r\n      {\r\n        let exchange_count := sload(exchange_count_slot)\r\n        if iszero(lt(exchange_id, exchange_count)) {\r\n          mstore(32, 2)\r\n          revert(63, 1)\r\n        }\r\n      }\r\n      {\r\n        let exchange_ptr := add(exchanges_slot, mul(4294967300, exchange_id))\r\n        let exchange_0 := sload(exchange_ptr)\r\n        if iszero(eq(caller, and(exchange_0, 0xffffffffffffffffffffffffffffffffffffffff))) {\r\n          mstore(32, 2)\r\n          revert(63, 1)\r\n        }\r\n        if and(div(exchange_0, 0x10000000000000000000000000000000000000000), 0xff) {\r\n          mstore(32, 3)\r\n          revert(63, 1)\r\n        }\r\n      }\r\n      for {} lt(cursor, cursor_end) {} {\r\n        let header_0 := mload(cursor)\r\n        cursor := add(cursor, 9)\r\n        if gt(cursor, cursor_end) {\r\n          mstore(32, 4)\r\n          revert(63, 1)\r\n        }\r\n        let quote_asset_id := and(div(header_0, 0x100000000000000000000000000000000000000000000000000000000), 0xffffffff)\r\n        let base_asset_id := and(div(header_0, 0x1000000000000000000000000000000000000000000000000), 0xffffffff)\r\n        if eq(quote_asset_id, base_asset_id) {\r\n          mstore(32, 16)\r\n          revert(63, 1)\r\n        }\r\n        let group_end := add(cursor, mul(and(div(header_0, 0x10000000000000000000000000000000000000000000000), 0xff), 32))\r\n        {\r\n          let asset_count := sload(asset_count_slot)\r\n          if iszero(and(lt(quote_asset_id, asset_count), lt(base_asset_id, asset_count))) {\r\n            mstore(32, 5)\r\n            revert(63, 1)\r\n          }\r\n        }\r\n        if gt(group_end, cursor_end) {\r\n          mstore(32, 6)\r\n          revert(63, 1)\r\n        }\r\n        let quote_net := 0\r\n        let base_net := 0\r\n        let exchange_ptr := add(exchanges_slot, mul(4294967300, exchange_id))\r\n        let exchange_balance_ptr := add(add(exchange_ptr, 4), quote_asset_id)\r\n        let exchange_balance := sload(exchange_balance_ptr)\r\n        for {} lt(cursor, group_end) {\r\n          cursor := add(cursor, 32)\r\n        } {\r\n          let settlement_0 := mload(cursor)\r\n          let user_ptr := add(users_slot, mul(237684487561239756867226304516, and(div(settlement_0, 0x1000000000000000000000000000000000000000000000000), 0xffffffffffffffff)))\r\n          let session_ptr := add(add(user_ptr, 4294967300), mul(55340232225423622146, exchange_id))\r\n          let market_state_ptr := add(add(session_ptr, 4294967298), mul(3, or(mul(quote_asset_id, 4294967296), base_asset_id)))\r\n          let quote_delta := and(div(settlement_0, 0x100000000000000000000000000000000), 0xffffffffffffffff)\r\n          quote_delta := signextend(7, quote_delta)\r\n          let base_delta := and(div(settlement_0, 0x10000000000000000), 0xffffffffffffffff)\r\n          base_delta := signextend(7, base_delta)\r\n          quote_net := add(quote_net, quote_delta)\r\n          base_net := add(base_net, base_delta)\r\n          let fees := and(settlement_0, 0xffffffffffffffff)\r\n          exchange_balance := add(exchange_balance, fees)\r\n          let market_state_0 := sload(market_state_ptr)\r\n          {\r\n            let quote_qty := and(div(market_state_0, 0x1000000000000000000000000000000000000000000000000), 0xffffffffffffffff)\r\n            quote_qty := signextend(7, quote_qty)\r\n            let base_qty := and(div(market_state_0, 0x100000000000000000000000000000000), 0xffffffffffffffff)\r\n            base_qty := signextend(7, base_qty)\r\n            quote_qty := add(quote_qty, quote_delta)\r\n            base_qty := add(base_qty, base_delta)\r\n            if or(or(slt(quote_qty, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF8000000000000000), sgt(quote_qty, 0x7FFFFFFFFFFFFFFF)), or(slt(base_qty, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF8000000000000000), sgt(base_qty, 0x7FFFFFFFFFFFFFFF))) {\r\n              mstore(32, 7)\r\n              revert(63, 1)\r\n            }\r\n            let fee_used := add(and(div(market_state_0, 0x10000000000000000), 0xffffffffffffffff), fees)\r\n            let fee_limit := and(market_state_0, 0xffffffffffffffff)\r\n            if gt(fee_used, fee_limit) {\r\n              mstore(32, 8)\r\n              revert(63, 1)\r\n            }\r\n            market_state_0 := or(or(or(\r\n              /* quote_qty */ mul(quote_qty, 0x1000000000000000000000000000000000000000000000000), \r\n              /* base_qty */ mul(and(base_qty, 0xFFFFFFFFFFFFFFFF), 0x100000000000000000000000000000000)), \r\n              /* fee_used */ mul(fee_used, 0x10000000000000000)), \r\n              /* fee_limit */ fee_limit)\r\n            let market_state_1 := sload(add(market_state_ptr, 1))\r\n            {\r\n              let min_quote_qty := and(div(market_state_1, 0x1000000000000000000000000000000000000000000000000), 0xffffffffffffffff)\r\n              min_quote_qty := signextend(7, min_quote_qty)\r\n              let min_base_qty := and(div(market_state_1, 0x100000000000000000000000000000000), 0xffffffffffffffff)\r\n              min_base_qty := signextend(7, min_base_qty)\r\n              if or(slt(quote_qty, min_quote_qty), slt(base_qty, min_base_qty)) {\r\n                mstore(32, 9)\r\n                revert(63, 1)\r\n              }\r\n            }\r\n            {\r\n              let negatives := add(slt(quote_qty, 1), mul(slt(base_qty, 1), 2))\r\n              switch negatives\r\n                case 3 {\r\n                  if or(quote_qty, base_qty) {\r\n                    mstore(32, 10)\r\n                    revert(63, 1)\r\n                  }\r\n                }\r\n                case 1 {\r\n                  let current_price := div(mul(sub(0, quote_qty), 100000000), base_qty)\r\n                  let long_max_price := and(div(market_state_1, 0x10000000000000000), 0xffffffffffffffff)\r\n                  if gt(current_price, long_max_price) {\r\n                    mstore(32, 11)\r\n                    revert(63, 1)\r\n                  }\r\n                }\r\n                case 2 {\r\n                  if base_qty {\r\n                    let current_price := div(mul(quote_qty, 100000000), sub(0, base_qty))\r\n                    let short_min_price := and(market_state_1, 0xffffffffffffffff)\r\n                    if lt(current_price, short_min_price) {\r\n                      mstore(32, 12)\r\n                      revert(63, 1)\r\n                    }\r\n                  }\r\n                }\r\n            }\r\n          }\r\n          let quote_session_balance_ptr := add(add(session_ptr, 2), quote_asset_id)\r\n          let base_session_balance_ptr := add(add(session_ptr, 2), base_asset_id)\r\n          let quote_session_balance_0 := sload(quote_session_balance_ptr)\r\n          let base_session_balance_0 := sload(base_session_balance_ptr)\r\n          let quote_balance := and(quote_session_balance_0, 0xffffffffffffffff)\r\n          quote_balance := add(quote_balance, quote_delta)\r\n          quote_balance := sub(quote_balance, fees)\r\n          if gt(quote_balance, 0xFFFFFFFFFFFFFFFF) {\r\n            mstore(32, 13)\r\n            revert(63, 1)\r\n          }\r\n          let base_balance := and(base_session_balance_0, 0xffffffffffffffff)\r\n          base_balance := add(base_balance, base_delta)\r\n          if gt(base_balance, 0xFFFFFFFFFFFFFFFF) {\r\n            mstore(32, 14)\r\n            revert(63, 1)\r\n          }\r\n          sstore(market_state_ptr, market_state_0)\r\n          sstore(quote_session_balance_ptr, or(and(0xffffffffffffffffffffffffffffffffffffffffffffffff0000000000000000, quote_session_balance_0), \r\n            /* asset_balance */ quote_balance))\r\n          sstore(base_session_balance_ptr, or(and(0xffffffffffffffffffffffffffffffffffffffffffffffff0000000000000000, base_session_balance_0), \r\n            /* asset_balance */ base_balance))\r\n        }\r\n        if or(quote_net, base_net) {\r\n          mstore(32, 15)\r\n          revert(63, 1)\r\n        }\r\n        sstore(exchange_balance_ptr, exchange_balance)\r\n      }\r\n    }\r\n  }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"user_id\",\"type\":\"uint64\"},{\"name\":\"exchange_id\",\"type\":\"uint32\"},{\"name\":\"asset_id\",\"type\":\"uint32\"},{\"name\":\"quantity\",\"type\":\"uint64\"}],\"name\":\"user_deposit_to_session\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"user_id\",\"type\":\"uint64\"},{\"name\":\"trade_address\",\"type\":\"address\"}],\"name\":\"user_set_trade_address\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"proposed_locked_features\",\"type\":\"uint256\"}],\"name\":\"security_propose\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"exchange_apply_settlement_groups\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"name\",\"type\":\"string\"},{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"add_exchange\",\"outputs\":[{\"name\":\"exchange_id\",\"type\":\"uint64\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"user_id\",\"type\":\"uint64\"},{\"name\":\"exchange_id\",\"type\":\"uint32\"},{\"name\":\"quote_asset_id\",\"type\":\"uint32\"},{\"name\":\"base_asset_id\",\"type\":\"uint32\"}],\"name\":\"user_market_reset\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"lock_features\",\"type\":\"uint256\"}],\"name\":\"security_lock\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"user_create\",\"outputs\":[{\"name\":\"user_id\",\"type\":\"uint64\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"user_id\",\"type\":\"uint64\"}],\"name\":\"user_set_recovery_address\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"recovery\",\"type\":\"address\"}],\"name\":\"creator_propose_recovery\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"user_id\",\"type\":\"uint64\"},{\"name\":\"exchange_id\",\"type\":\"uint32\"},{\"name\":\"asset_id\",\"type\":\"uint32\"}],\"name\":\"get_session_balance\",\"outputs\":[{\"name\":\"total_deposit\",\"type\":\"uint128\"},{\"name\":\"unsettled_withdraw_total\",\"type\":\"uint64\"},{\"name\":\"asset_balance\",\"type\":\"uint64\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"exchange_transfer_from\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"get_exchange_count\",\"outputs\":[{\"name\":\"count\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"exchange_id\",\"type\":\"uint32\"}],\"name\":\"get_exchange\",\"outputs\":[{\"name\":\"name\",\"type\":\"string\"},{\"name\":\"locked\",\"type\":\"bool\"},{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"withdraw_address\",\"type\":\"address\"},{\"name\":\"recovery_address\",\"type\":\"address\"},{\"name\":\"recovery_address_proposed\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"security_set_proposed\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"user_id\",\"type\":\"uint64\"},{\"name\":\"exchange_id\",\"type\":\"uint32\"},{\"name\":\"asset_id\",\"type\":\"uint32\"},{\"name\":\"quantity\",\"type\":\"uint64\"}],\"name\":\"transfer_to_session\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"user_id\",\"type\":\"uint64\"},{\"name\":\"exchange_id\",\"type\":\"uint32\"}],\"name\":\"get_session\",\"outputs\":[{\"name\":\"unlock_at\",\"type\":\"uint256\"},{\"name\":\"trade_address\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"symbol\",\"type\":\"string\"},{\"name\":\"unit_scale\",\"type\":\"uint192\"},{\"name\":\"contract_address\",\"type\":\"address\"}],\"name\":\"add_asset\",\"outputs\":[{\"name\":\"asset_id\",\"type\":\"uint64\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"user_id\",\"type\":\"uint64\"}],\"name\":\"get_user\",\"outputs\":[{\"name\":\"trade_address\",\"type\":\"address\"},{\"name\":\"withdraw_address\",\"type\":\"address\"},{\"name\":\"recovery_address\",\"type\":\"address\"},{\"name\":\"recovery_address_proposed\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"creator_set_recovery\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"user_id\",\"type\":\"uint64\"},{\"name\":\"exchange_id\",\"type\":\"uint32\"},{\"name\":\"asset_id\",\"type\":\"uint32\"},{\"name\":\"quantity\",\"type\":\"uint64\"}],\"name\":\"transfer_from_session\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"new_creator\",\"type\":\"address\"}],\"name\":\"creator_update\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"user_id\",\"type\":\"uint64\"},{\"name\":\"proposed\",\"type\":\"address\"}],\"name\":\"user_propose_recovery_address\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"asset_id\",\"type\":\"uint32\"}],\"name\":\"get_asset\",\"outputs\":[{\"name\":\"symbol\",\"type\":\"string\"},{\"name\":\"unit_scale\",\"type\":\"uint192\"},{\"name\":\"contract_address\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"recover_unsettled_withdraws\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"get_asset_count\",\"outputs\":[{\"name\":\"count\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"get_creator\",\"outputs\":[{\"name\":\"dcn_creator\",\"type\":\"address\"},{\"name\":\"dcn_creator_recovery\",\"type\":\"address\"},{\"name\":\"dcn_creator_recovery_proposed\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"user_id\",\"type\":\"uint64\"},{\"name\":\"exchange_id\",\"type\":\"uint32\"},{\"name\":\"quote_asset_id\",\"type\":\"uint32\"},{\"name\":\"base_asset_id\",\"type\":\"uint32\"}],\"name\":\"get_market_state\",\"outputs\":[{\"name\":\"quote_qty\",\"type\":\"int64\"},{\"name\":\"base_qty\",\"type\":\"int64\"},{\"name\":\"fee_used\",\"type\":\"uint64\"},{\"name\":\"fee_limit\",\"type\":\"uint64\"},{\"name\":\"min_quote_qty\",\"type\":\"int64\"},{\"name\":\"min_base_qty\",\"type\":\"int64\"},{\"name\":\"long_max_price\",\"type\":\"uint64\"},{\"name\":\"short_min_price\",\"type\":\"uint64\"},{\"name\":\"limit_version\",\"type\":\"uint64\"},{\"name\":\"quote_shift\",\"type\":\"int96\"},{\"name\":\"base_shift\",\"type\":\"int96\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"exchange_id\",\"type\":\"uint32\"},{\"name\":\"locked\",\"type\":\"bool\"}],\"name\":\"set_exchange_locked\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"user_id\",\"type\":\"uint64\"},{\"name\":\"asset_id\",\"type\":\"uint32\"}],\"name\":\"get_balance\",\"outputs\":[{\"name\":\"return_balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"exchange_id\",\"type\":\"uint32\"}],\"name\":\"exchange_set_recovery\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"get_security_state\",\"outputs\":[{\"name\":\"locked_features\",\"type\":\"uint256\"},{\"name\":\"locked_features_proposed\",\"type\":\"uint256\"},{\"name\":\"proposed_unlock_timestamp\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"user_id\",\"type\":\"uint64\"},{\"name\":\"asset_id\",\"type\":\"uint32\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"user_deposit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"exchange_id\",\"type\":\"uint32\"},{\"name\":\"asset_id\",\"type\":\"uint32\"},{\"name\":\"quantity\",\"type\":\"uint64\"}],\"name\":\"exchange_deposit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"exchange_id\",\"type\":\"uint32\"},{\"name\":\"new_owner\",\"type\":\"address\"}],\"name\":\"exchange_set_owner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"exchange_id\",\"type\":\"uint32\"},{\"name\":\"new_withdraw\",\"type\":\"address\"}],\"name\":\"exchange_set_withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"exchange_set_limits\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"user_id\",\"type\":\"uint64\"},{\"name\":\"withdraw_address\",\"type\":\"address\"}],\"name\":\"user_set_withdraw_address\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"exchange_id\",\"type\":\"uint32\"},{\"name\":\"asset_id\",\"type\":\"uint32\"},{\"name\":\"destination\",\"type\":\"address\"},{\"name\":\"quantity\",\"type\":\"uint64\"}],\"name\":\"exchange_withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"user_id\",\"type\":\"uint64\"},{\"name\":\"asset_id\",\"type\":\"uint32\"},{\"name\":\"destination\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"user_withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"user_id\",\"type\":\"uint64\"},{\"name\":\"exchange_id\",\"type\":\"uint32\"},{\"name\":\"unlock_at\",\"type\":\"uint256\"}],\"name\":\"user_session_set_unlock_at\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"exchange_id\",\"type\":\"uint32\"},{\"name\":\"asset_id\",\"type\":\"uint32\"}],\"name\":\"get_exchange_balance\",\"outputs\":[{\"name\":\"exchange_balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"get_user_count\",\"outputs\":[{\"name\":\"count\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"exchange_id\",\"type\":\"uint32\"},{\"name\":\"proposed\",\"type\":\"address\"}],\"name\":\"exchange_propose_recovery\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"creator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"user_id\",\"type\":\"uint64\"}],\"name\":\"UserCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"user_id\",\"type\":\"uint64\"}],\"name\":\"UserTradeAddressUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"user_id\",\"type\":\"uint64\"},{\"indexed\":false,\"name\":\"exchange_id\",\"type\":\"uint64\"}],\"name\":\"SessionUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"user_id\",\"type\":\"uint64\"},{\"indexed\":false,\"name\":\"exchange_id\",\"type\":\"uint64\"},{\"indexed\":false,\"name\":\"asset_id\",\"type\":\"uint32\"}],\"name\":\"ExchangeDeposit\",\"type\":\"event\"}]","ContractName":"DCN","CompilerVersion":"v0.5.7+commit.6da8b019","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://ecd805e9fa0a888388dd88c0bcfe4f267f89cb9aa933b92339dc6c62f7918a49"}]}