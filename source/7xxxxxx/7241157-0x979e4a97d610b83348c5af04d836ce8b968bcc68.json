{"status":"1","message":"OK","result":[{"SourceCode":"// Written by Jesse Busman (jesse@jesbus.com) in january 2018 and june 2018 and december 2018 and january 2019 and february 2019\r\n// This is the back end of https://etherprime.jesbus.com/\r\n\r\npragma solidity 0.5.4;\r\n\r\n\r\n// ----------------------------------------------------------------------------\r\n// ERC Token Standard #20 Interface\r\n// https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md\r\n// ----------------------------------------------------------------------------\r\ninterface ERC20\r\n{\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address tokenOwner) external view returns (uint balance);\r\n    function allowance(address tokenOwner, address spender) external view returns (uint remaining);\r\n    function transfer(address to, uint tokens) external returns (bool success);\r\n    function approve(address spender, uint tokens) external returns (bool success);\r\n    function transferFrom(address from, address to, uint tokens) external returns (bool success);\r\n    \r\n    event Transfer(address indexed from, address indexed to, uint tokens);\r\n    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\r\n    \r\n    function name() external pure returns (string memory);\r\n    function symbol() external pure returns (string memory);\r\n    function decimals() external pure returns (uint8);\r\n}\r\n\r\n\r\ninterface ERC165\r\n{\r\n    /// @notice Query if a contract implements an interface\r\n    /// @param interfaceID The interface identifier, as specified in ERC-165\r\n    /// @dev Interface identification is specified in ERC-165. This function\r\n    ///  uses less than 30,000 gas.\r\n    /// @return `true` if the contract implements `interfaceID` and\r\n    ///  `interfaceID` is not 0xffffffff, `false` otherwise\r\n    function supportsInterface(bytes4 interfaceID) external pure returns (bool);\r\n}\r\n\r\n\r\n\r\n/// @title ERC-721 Non-Fungible Token Standard\r\n/// @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\r\n///  Note: the ERC-165 identifier for this interface is 0x80ac58cd\r\ninterface ERC721 /*is ERC165*/\r\n{\r\n    /// @dev This emits when ownership of any NFT changes by any mechanism.\r\n    ///  This event emits when NFTs are created (`from` == 0) and destroyed\r\n    ///  (`to` == 0). Exception: during contract creation, any number of NFTs\r\n    ///  may be created and assigned without emitting Transfer. At the time of\r\n    ///  any transfer, the approved address for that NFT (if any) is reset to none.\r\n    event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);\r\n    \r\n    /// @dev This emits when the approved address for an NFT is changed or\r\n    ///  reaffirmed. The zero address indicates there is no approved address.\r\n    ///  When a Transfer event emits, this also indicates that the approved\r\n    ///  address for that NFT (if any) is reset to none.\r\n    event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);\r\n    \r\n    /// @dev This emits when an operator is enabled or disabled for an owner.\r\n    ///  The operator can manage all NFTs of the owner.\r\n    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\r\n    \r\n    /// @notice Count all NFTs assigned to an owner\r\n    /// @dev NFTs assigned to the zero address are considered invalid, and this\r\n    ///  function throws for queries about the zero address.\r\n    /// @param _owner An address for whom to query the balance\r\n    /// @return The number of NFTs owned by `_owner`, possibly zero\r\n    function balanceOf(address _owner) external view returns (uint256);\r\n    \r\n    /// @notice Find the owner of an NFT\r\n    /// @dev NFTs assigned to zero address are considered invalid, and queries\r\n    ///  about them do throw.\r\n    /// @param _tokenId The identifier for an NFT\r\n    /// @return The address of the owner of the NFT\r\n    function ownerOf(uint256 _tokenId) external view returns (address);\r\n    \r\n    /// @notice Transfers the ownership of an NFT from one address to another address\r\n    /// @dev Throws unless `msg.sender` is the current owner, an authorized\r\n    ///  operator, or the approved address for this NFT. Throws if `_from` is\r\n    ///  not the current owner. Throws if `_to` is the zero address. Throws if\r\n    ///  `_tokenId` is not a valid NFT. When transfer is complete, this function\r\n    ///  checks if `_to` is a smart contract (code size > 0). If so, it calls\r\n    ///  `onERC721Received` on `_to` and throws if the return value is not\r\n    ///  `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`.\r\n    /// @param _from The current owner of the NFT\r\n    /// @param _to The new owner\r\n    /// @param _tokenId The NFT to transfer\r\n    /// @param data Additional data with no specified format, sent in call to `_to`\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes calldata data) external returns (bool);\r\n    \r\n    /// @notice Transfers the ownership of an NFT from one address to another address\r\n    /// @dev This works identically to the other function with an extra data parameter,\r\n    ///  except this function just sets data to \"\"\r\n    /// @param _from The current owner of the NFT\r\n    /// @param _to The new owner\r\n    /// @param _tokenId The NFT to transfer\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external returns (bool);\r\n    \r\n    /// @notice Transfer ownership of an NFT -- THE CALLER IS RESPONSIBLE\r\n    ///  TO CONFIRM THAT `_to` IS CAPABLE OF RECEIVING NFTS OR ELSE\r\n    ///  THEY MAY BE PERMANENTLY LOST\r\n    /// @dev Throws unless `msg.sender` is the current owner, an authorized\r\n    ///  operator, or the approved address for this NFT. Throws if `_from` is\r\n    ///  not the current owner. Throws if `_to` is the zero address. Throws if\r\n    ///  `_tokenId` is not a valid NFT.\r\n    /// @param _from The current owner of the NFT\r\n    /// @param _to The new owner\r\n    /// @param _tokenId The NFT to transfer\r\n    function transferFrom(address _from, address _to, uint256 _tokenId) external returns (bool);\r\n    \r\n    /// @notice Set or reaffirm the approved address for an NFT\r\n    /// @dev The zero address indicates there is no approved address.\r\n    /// @dev Throws unless `msg.sender` is the current NFT owner, or an authorized\r\n    ///  operator of the current owner.\r\n    /// @param _approved The new approved NFT controller\r\n    /// @param _tokenId The NFT to approve\r\n    function approve(address _approved, uint256 _tokenId) external returns (bool);\r\n    \r\n    /// @notice Enable or disable approval for a third party (\"operator\") to manage\r\n    ///  all of `msg.sender`'s assets.\r\n    /// @dev Emits the ApprovalForAll event. The contract MUST allow\r\n    ///  multiple operators per owner.\r\n    /// @param _operator Address to add to the set of authorized operators.\r\n    /// @param _approved True if the operator is approved, false to revoke approval\r\n    function setApprovalForAll(address _operator, bool _approved) external returns (bool);\r\n    \r\n    /// @notice Get the approved address for a single NFT\r\n    /// @dev Throws if `_tokenId` is not a valid NFT\r\n    /// @param _tokenId The NFT to find the approved address for\r\n    /// @return The approved address for this NFT, or the zero address if there is none\r\n    function getApproved(uint256 _tokenId) external view returns (address);\r\n    \r\n    /// @notice Query if an address is an authorized operator for another address\r\n    /// @param _owner The address that owns the NFTs\r\n    /// @param _operator The address that acts on behalf of the owner\r\n    /// @return True if `_operator` is an approved operator for `_owner`, false otherwise\r\n    function isApprovedForAll(address _owner, address _operator) external view returns (bool);\r\n}\r\n\r\ninterface ERC721Enumerable\r\n{\r\n    function totalSupply() external view returns (uint256);\r\n    function tokenOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256 _tokenId);\r\n    function tokenByIndex(uint256 _index) external view returns (uint256);\r\n}\r\n\r\n\r\n/**\r\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\r\n * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\r\n */\r\ninterface ERC721Metadata\r\n{\r\n    function name() external pure returns (string memory _name);\r\n    function symbol() external pure returns (string memory _symbol);\r\n    function tokenURI(uint256 _tokenId) external view returns (string memory _uri);\r\n}\r\n\r\n\r\ninterface ERC721TokenReceiver\r\n{\r\n    /// @notice Handle the receipt of an NFT\r\n    /// @dev The ERC721 smart contract calls this function on the\r\n    /// recipient after a `transfer`. This function MAY throw to revert and reject the transfer. Return\r\n    /// of other than the magic value MUST result in the transaction being reverted.\r\n    /// @notice The contract address is always the message sender.\r\n    /// @param _operator The address which called `safeTransferFrom` function\r\n    /// @param _from The address which previously owned the token\r\n    /// @param _tokenId The NFT identifier which is being transferred\r\n    /// @param _data Additional data with no specified format\r\n    /// @return `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\r\n    /// unless throwing\r\n    function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes calldata _data) external returns(bytes4);\r\n}\r\n\r\n\r\n\r\n\r\ninterface ERC223\r\n{\r\n    function balanceOf(address who) external view returns (uint256);\r\n    \r\n    function name() external pure returns (string memory _name);\r\n    function symbol() external pure returns (string memory _symbol);\r\n    function decimals() external pure returns (uint8 _decimals);\r\n    function totalSupply() external view returns (uint256 _supply);\r\n    \r\n    function transfer(address to, uint value) external returns (bool ok);\r\n    function transfer(address to, uint value, bytes calldata data) external returns (bool ok);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint value, bytes indexed data);\r\n}\r\n\r\n\r\n\r\ninterface ERC223Receiver\r\n{\r\n    function tokenFallback(address _from, uint256 _value, bytes calldata _data) external;\r\n}\r\n\r\n\r\n\r\ninterface ERC777TokensRecipient\r\n{\r\n    function tokensReceived(\r\n        address operator,\r\n        address from,\r\n        address to,\r\n        uint256 amount,\r\n        bytes calldata data,\r\n        bytes calldata operatorData\r\n    ) external;\r\n}\r\n\r\n\r\ninterface ERC777TokensSender\r\n{\r\n    function tokensToSend(\r\n        address operator,\r\n        address from,\r\n        address to,\r\n        uint256 amount,\r\n        bytes calldata data,\r\n        bytes calldata operatorData\r\n    ) external;\r\n}\r\n\r\n\r\n\r\n\r\ncontract EtherPrime is ERC20, ERC721, ERC721Enumerable, ERC721Metadata, ERC165, ERC223\r\n{\r\n    ////////////////////////////////////////////////////////////\r\n    ////////////////////////////////////////////////////////////\r\n    ////////////                                    ////////////\r\n    ////////////          State variables           ////////////\r\n    ////////////                                    ////////////\r\n    ////////////////////////////////////////////////////////////\r\n    ////////////////////////////////////////////////////////////\r\n    \r\n    // Array of definite prime numbers\r\n    uint256[] public definitePrimes;\r\n    \r\n    // Array of probable primes\r\n    uint256[] public probablePrimes;\r\n    \r\n    // Allowances\r\n    mapping(uint256 => address) public primeToAllowedAddress;\r\n    \r\n    // Allowed operators\r\n    mapping(address => mapping(address => bool)) private ownerToOperators;\r\n    \r\n    // Ownership of primes\r\n    mapping(address => uint256[]) private ownerToPrimes;\r\n    \r\n    // Number data contains:\r\n    // - Index of prime in ownerToPrimes array\r\n    // - Index of prime in definitePrimes or probablePrimes array\r\n    // - NumberType\r\n    // - Owner of prime\r\n    mapping(uint256 => bytes32) private numberToNumberdata;\r\n    \r\n    // Store known non-2 divisors of non-primes\r\n    mapping(uint256 => uint256) private numberToNonTwoDivisor;\r\n    \r\n    // List of all participants\r\n    address[] public participants;\r\n    mapping(address => uint256) private addressToParticipantsArrayIndex;\r\n    \r\n    // Statistics\r\n    mapping(address => uint256) public addressToGasSpent;\r\n    mapping(address => uint256) public addressToEtherSpent;\r\n    mapping(address => uint256) public addressToProbablePrimesClaimed;\r\n    mapping(address => uint256) public addressToProbablePrimesDisprovenBy;\r\n    mapping(address => uint256) public addressToProbablePrimesDisprovenFrom;\r\n\r\n    // Prime calculator state\r\n    uint256 public numberBeingTested;\r\n    uint256 public divisorIndexBeingTested;\r\n    \r\n    // Prime trading\r\n    mapping(address => uint256) public addressToEtherBalance;\r\n    mapping(uint256 => uint256) public primeToSellOrderPrice;\r\n    mapping(uint256 => BuyOrder[]) private primeToBuyOrders;\r\n\r\n    \r\n    \r\n    \r\n    \r\n    ////////////////////////////////////////////////////////////\r\n    ////////////////////////////////////////////////////////////\r\n    ////////////                                    ////////////\r\n    ////////////               Events               ////////////\r\n    ////////////                                    ////////////\r\n    ////////////////////////////////////////////////////////////\r\n    ////////////////////////////////////////////////////////////\r\n    \r\n    // Prime generation\r\n    event DefinitePrimeDiscovered(uint256 indexed prime, address indexed discoverer, uint256 indexed definitePrimesArrayIndex);\r\n    event ProbablePrimeDiscovered(uint256 indexed prime, address indexed discoverer, uint256 indexed probablePrimesArrayIndex);\r\n    event ProbablePrimeDisproven(uint256 indexed prime, uint256 divisor, address indexed owner, address indexed disprover, uint256 probablePrimesArrayIndex);\r\n    \r\n    // Token\r\n    event Transfer(address indexed from, address indexed to, uint256 prime);\r\n    event Approval(address indexed owner, address indexed spender, uint256 prime);\r\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n    \r\n    // Trading\r\n    event BuyOrderCreated(address indexed buyer, uint256 indexed prime, uint256 indexed buyOrdersArrayIndex, uint256 bid);\r\n    event BuyOrderDestroyed(address indexed buyer, uint256 indexed prime, uint256 indexed buyOrdersArrayIndex);\r\n    event SellPriceSet(address indexed seller, uint256 indexed prime, uint256 price);\r\n    event PrimeTraded(address indexed seller, address indexed buyer, uint256 indexed prime, uint256 buyOrdersArrayIndex, uint256 price);\r\n    event EtherDeposited(address indexed depositer, uint256 amount);\r\n    event EtherWithdrawn(address indexed withdrawer, uint256 amount);\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    ////////////////////////////////////////////////////////////\r\n    ////////////////////////////////////////////////////////////\r\n    ////////////                                    ////////////\r\n    ////////////  Internal functions that write to  ////////////\r\n    ////////////          state variables           ////////////\r\n    ////////////                                    ////////////\r\n    ////////////////////////////////////////////////////////////\r\n    ////////////////////////////////////////////////////////////\r\n    \r\n    function _addParticipant(address _newParticipant) private\r\n    {\r\n        // Add the participant to the list, but only if they are not 0x0 and they are not already in the list.\r\n        if (_newParticipant != address(0x0) && addressToParticipantsArrayIndex[_newParticipant] == 0)\r\n        {\r\n            addressToParticipantsArrayIndex[_newParticipant] = participants.length;\r\n            participants.push(_newParticipant);\r\n        }\r\n    }\r\n    \r\n    ////////////////////////////////////\r\n    //////// Internal functions to change ownership of a prime\r\n    \r\n    function _removePrimeFromOwnerPrimesArray(uint256 _prime) private\r\n    {\r\n        bytes32 numberdata = numberToNumberdata[_prime];\r\n        uint256[] storage ownerPrimes = ownerToPrimes[numberdataToOwner(numberdata)];\r\n        uint256 primeIndex = numberdataToOwnerPrimesIndex(numberdata);\r\n        \r\n        // Move the last one backwards into the freed slot\r\n        uint256 otherPrimeBeingMoved = ownerPrimes[ownerPrimes.length-1];\r\n        ownerPrimes[primeIndex] = otherPrimeBeingMoved;\r\n        _numberdataSetOwnerPrimesIndex(otherPrimeBeingMoved, uint40(primeIndex));\r\n        \r\n        // Refund gas by setting the now unused array slot to 0\r\n        // Advantage: Current transaction gets a gas refund of 15000\r\n        // Disadvantage: Next transaction that gives a prime to this owner will cost 15000 more gas\r\n        ownerPrimes[ownerPrimes.length-1] = 0; // Refund some gas\r\n        \r\n        // Decrease the length of the array\r\n        ownerPrimes.length--;\r\n    }\r\n    \r\n    function _setOwner(uint256 _prime, address _newOwner) private\r\n    {\r\n        _setOwner(_prime, _newOwner, \"\", address(0x0), \"\");\r\n    }\r\n    \r\n    function _setOwner(uint256 _prime, address _newOwner, bytes memory _data, address _operator, bytes memory _operatorData) private\r\n    {\r\n        // getOwner does not throw, so previousOwner can be 0x0\r\n        address previousOwner = getOwner(_prime);\r\n        \r\n        if (_operator == address(0x0))\r\n        {\r\n            _operator = previousOwner;\r\n        }\r\n        \r\n        // Shortcut in case we don't need to do anything\r\n        if (previousOwner == _newOwner)\r\n        {\r\n            return;\r\n        }\r\n        \r\n        // Delete _prime from ownerToPrimes[previousOwner]\r\n        if (previousOwner != address(0x0))\r\n        {\r\n            _removePrimeFromOwnerPrimesArray(_prime);\r\n        }\r\n        \r\n        // Store the new ownerPrimes array index and the new owner in the numberdata\r\n        _numberdataSetOwnerAndOwnerPrimesIndex(_prime, _newOwner, uint40(ownerToPrimes[_newOwner].length));\r\n        \r\n        // Add _prime to ownerToPrimes[_newOwner]\r\n        ownerToPrimes[_newOwner].push(_prime);\r\n        \r\n        // Delete any existing allowance\r\n        if (primeToAllowedAddress[_prime] != address(0x0))\r\n        {\r\n            primeToAllowedAddress[_prime] = address(0x0);\r\n        }\r\n        \r\n        // Delete any existing sell order\r\n        if (primeToSellOrderPrice[_prime] != 0)\r\n        {\r\n            primeToSellOrderPrice[_prime] = 0;\r\n            emit SellPriceSet(_newOwner, _prime, 0);\r\n        }\r\n        \r\n        // Add the new owner to the list of EtherPrime participants\r\n        _addParticipant(_newOwner);\r\n        \r\n        // If the new owner is a contract, try to notify them of the received token.\r\n        if (isContract(_newOwner))\r\n        {\r\n            bool success;\r\n            bytes32 returnValue;\r\n            \r\n            // Try to call onERC721Received (as per ERC721)\r\n            \r\n            (success, returnValue) = _tryCall(_newOwner, abi.encodeWithSelector(ERC721TokenReceiver(_newOwner).onERC721Received.selector, _operator, previousOwner, _prime, _data));\r\n            \r\n            if (!success || returnValue != bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\")))\r\n            {\r\n                // If ERC721::onERC721Received failed, try to call tokenFallback (as per ERC223)\r\n                \r\n                (success, returnValue) = _tryCall(_newOwner, abi.encodeWithSelector(ERC223Receiver(_newOwner).tokenFallback.selector, previousOwner, _prime, 0x0));\r\n                \r\n                if (!success)\r\n                {\r\n                    // If ERC223::tokenFallback failed, try to call tokensReceived (as per ERC777)\r\n                    \r\n                    (success, returnValue) = _tryCall(_newOwner, abi.encodeWithSelector(ERC777TokensRecipient(_newOwner).tokensReceived.selector, _operator, previousOwner, _newOwner, _prime, _data, _operatorData));\r\n                    \r\n                    if (!success)\r\n                    {\r\n                        // If all token fallback calls failed, give up and just give them their token.\r\n                        return;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        \r\n        emit Transfer(previousOwner, _newOwner, _prime);\r\n    }\r\n    \r\n    function _createPrime(uint256 _prime, address _owner, bool _isDefinitePrime) private\r\n    {\r\n        // Create the prime\r\n        _numberdataSetAllPrimesIndexAndNumberType(\r\n            _prime,\r\n            uint48(_isDefinitePrime ? definitePrimes.length : probablePrimes.length),\r\n            _isDefinitePrime ? NumberType.DEFINITE_PRIME : NumberType.PROBABLE_PRIME\r\n        );\r\n        if (_isDefinitePrime)\r\n        {\r\n            emit DefinitePrimeDiscovered(_prime, msg.sender, definitePrimes.length);\r\n            definitePrimes.push(_prime);\r\n        }\r\n        else\r\n        {\r\n            emit ProbablePrimeDiscovered(_prime, msg.sender, probablePrimes.length);\r\n            probablePrimes.push(_prime);\r\n        }\r\n        \r\n        // Give it to its new owner\r\n        _setOwner(_prime, _owner);\r\n    }\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    ////////////////////////////////////////////////////////////\r\n    ////////////////////////////////////////////////////////////\r\n    ////////////                                    ////////////\r\n    ////////////    Bitwise stuff on numberdata     ////////////\r\n    ////////////                                    ////////////\r\n    ////////////////////////////////////////////////////////////\r\n    ////////////////////////////////////////////////////////////\r\n    \r\n    enum NumberType\r\n    {\r\n        NOT_PRIME_IF_PASSED,\r\n        NOT_PRIME,\r\n        PROBABLE_PRIME,\r\n        DEFINITE_PRIME\r\n    }\r\n    \r\n    // Number data format:\r\n    \r\n    // MSB                                                                                                                                           LSB\r\n    // [  40 bits for owner primes array index  ] [  48 bits for all primes array index  ] [  8 bits for number type  ] [  160 bits for owner address  ]\r\n    //   ^                                            ^                                               ^                            ^\r\n    //   ^ the index in ownerToPrimes array           ^ index in definitePrimes or probablePrimes     ^ a NumberType value         ^ owner of the number\r\n    \r\n    uint256 private constant NUMBERDATA_OWNER_PRIME_INDEX_SIZE = 40;\r\n    uint256 private constant NUMBERDATA_OWNER_PRIME_INDEX_SHIFT = NUMBERDATA_ALL_PRIME_INDEX_SHIFT + NUMBERDATA_ALL_PRIME_INDEX_SIZE;\r\n    bytes32 private constant NUMBERDATA_OWNER_PRIME_INDEX_MASK = bytes32(uint256(~uint40(0)) << NUMBERDATA_OWNER_PRIME_INDEX_SHIFT);\r\n    \r\n    uint256 private constant NUMBERDATA_ALL_PRIME_INDEX_SIZE = 48;\r\n    uint256 private constant NUMBERDATA_ALL_PRIME_INDEX_SHIFT = NUMBERDATA_NUMBER_TYPE_SHIFT + NUMBERDATA_NUMBER_TYPE_SIZE;\r\n    bytes32 private constant NUMBERDATA_ALL_PRIME_INDEX_MASK = bytes32(uint256(~uint48(0)) << NUMBERDATA_ALL_PRIME_INDEX_SHIFT);\r\n    \r\n    uint256 private constant NUMBERDATA_NUMBER_TYPE_SIZE = 8;\r\n    uint256 private constant NUMBERDATA_NUMBER_TYPE_SHIFT = NUMBERDATA_OWNER_ADDRESS_SHIFT + NUMBERDATA_OWNER_ADDRESS_SIZE;\r\n    bytes32 private constant NUMBERDATA_NUMBER_TYPE_MASK = bytes32(uint256(~uint8(0)) << NUMBERDATA_NUMBER_TYPE_SHIFT);\r\n    \r\n    uint256 private constant NUMBERDATA_OWNER_ADDRESS_SIZE = 160;\r\n    uint256 private constant NUMBERDATA_OWNER_ADDRESS_SHIFT = 0;\r\n    bytes32 private constant NUMBERDATA_OWNER_ADDRESS_MASK = bytes32(uint256(~uint160(0)) << NUMBERDATA_OWNER_ADDRESS_SHIFT);\r\n    \r\n    function numberdataToOwnerPrimesIndex(bytes32 _numberdata) private pure returns (uint40)\r\n    {\r\n        return uint40(uint256(_numberdata & NUMBERDATA_OWNER_PRIME_INDEX_MASK) >> NUMBERDATA_OWNER_PRIME_INDEX_SHIFT);\r\n    }\r\n    \r\n    function numberdataToAllPrimesIndex(bytes32 _numberdata) private pure returns (uint48)\r\n    {\r\n        return uint48(uint256(_numberdata & NUMBERDATA_ALL_PRIME_INDEX_MASK) >> NUMBERDATA_ALL_PRIME_INDEX_SHIFT);\r\n    }\r\n    \r\n    function numberdataToNumberType(bytes32 _numberdata) private pure returns (NumberType)\r\n    {\r\n        return NumberType(uint256(_numberdata & NUMBERDATA_NUMBER_TYPE_MASK) >> NUMBERDATA_NUMBER_TYPE_SHIFT);\r\n    }\r\n    \r\n    function numberdataToOwner(bytes32 _numberdata) private pure returns (address)\r\n    {\r\n        return address(uint160(uint256(_numberdata & NUMBERDATA_OWNER_ADDRESS_MASK) >> NUMBERDATA_OWNER_ADDRESS_SHIFT));\r\n    }\r\n    \r\n    function ownerPrimesIndex_allPrimesIndex_numberType_owner__toNumberdata(uint40 _ownerPrimesIndex, uint48 _allPrimesIndex, NumberType _numberType, address _owner) private pure returns (bytes32)\r\n    {\r\n        return\r\n            bytes32(\r\n                (uint256(_ownerPrimesIndex) << NUMBERDATA_OWNER_PRIME_INDEX_SHIFT) |\r\n                (uint256(_allPrimesIndex) << NUMBERDATA_ALL_PRIME_INDEX_SHIFT) |\r\n                (uint256(uint8(_numberType)) << NUMBERDATA_NUMBER_TYPE_SHIFT) |\r\n                (uint256(uint160(_owner)) << NUMBERDATA_OWNER_ADDRESS_SHIFT)\r\n            );\r\n    }\r\n    \r\n    function _numberdataSetOwnerPrimesIndex(uint256 _number, uint40 _ownerPrimesIndex) private\r\n    {\r\n        bytes32 numberdata = numberToNumberdata[_number];\r\n        numberdata &= ~NUMBERDATA_OWNER_PRIME_INDEX_MASK;\r\n        numberdata |= bytes32(uint256(_ownerPrimesIndex)) << NUMBERDATA_OWNER_PRIME_INDEX_SHIFT;\r\n        numberToNumberdata[_number] = numberdata;\r\n    }\r\n    \r\n    function _numberdataSetAllPrimesIndex(uint256 _number, uint48 _allPrimesIndex) private\r\n    {\r\n        bytes32 numberdata = numberToNumberdata[_number];\r\n        numberdata &= ~NUMBERDATA_ALL_PRIME_INDEX_MASK;\r\n        numberdata |= bytes32(uint256(_allPrimesIndex)) << NUMBERDATA_ALL_PRIME_INDEX_SHIFT;\r\n        numberToNumberdata[_number] = numberdata;\r\n    }\r\n    \r\n    function _numberdataSetNumberType(uint256 _number, NumberType _numberType) private\r\n    {\r\n        bytes32 numberdata = numberToNumberdata[_number];\r\n        numberdata &= ~NUMBERDATA_NUMBER_TYPE_MASK;\r\n        numberdata |= bytes32(uint256(uint8(_numberType))) << NUMBERDATA_NUMBER_TYPE_SHIFT;\r\n        numberToNumberdata[_number] = numberdata;\r\n    }\r\n    \r\n    /*function _numberdataSetOwner(uint256 _number, address _owner) private\r\n    {\r\n        bytes32 numberdata = numberToNumberdata[_number];\r\n        numberdata &= ~NUMBERDATA_OWNER_ADDRESS_MASK;\r\n        numberdata |= bytes32(uint256(uint160(_owner))) << NUMBERDATA_OWNER_ADDRESS_SHIFT;\r\n        numberToNumberdata[_number] = numberdata;\r\n    }*/\r\n    \r\n    function _numberdataSetOwnerAndOwnerPrimesIndex(uint256 _number, address _owner, uint40 _ownerPrimesIndex) private\r\n    {\r\n        bytes32 numberdata = numberToNumberdata[_number];\r\n        \r\n        numberdata &= ~NUMBERDATA_OWNER_ADDRESS_MASK;\r\n        numberdata |= bytes32(uint256(uint160(_owner))) << NUMBERDATA_OWNER_ADDRESS_SHIFT;\r\n        \r\n        numberdata &= ~NUMBERDATA_OWNER_PRIME_INDEX_MASK;\r\n        numberdata |= bytes32(uint256(_ownerPrimesIndex)) << NUMBERDATA_OWNER_PRIME_INDEX_SHIFT;\r\n        \r\n        numberToNumberdata[_number] = bytes32(numberdata);\r\n    }\r\n\r\n    function _numberdataSetAllPrimesIndexAndNumberType(uint256 _number, uint48 _allPrimesIndex, NumberType _numberType) private\r\n    {\r\n        bytes32 numberdata = numberToNumberdata[_number];\r\n        \r\n        numberdata &= ~NUMBERDATA_ALL_PRIME_INDEX_MASK;\r\n        numberdata |= bytes32(uint256(_allPrimesIndex)) << NUMBERDATA_ALL_PRIME_INDEX_SHIFT;\r\n        \r\n        numberdata &= ~NUMBERDATA_NUMBER_TYPE_MASK;\r\n        numberdata |= bytes32(uint256(uint8(_numberType))) << NUMBERDATA_NUMBER_TYPE_SHIFT;\r\n        \r\n        numberToNumberdata[_number] = bytes32(numberdata);\r\n    }\r\n    \r\n\r\n    \r\n    \r\n\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    ////////////////////////////////////////////////////////////\r\n    ////////////////////////////////////////////////////////////\r\n    ////////////                                    ////////////\r\n    ////////////       Utility functions for        ////////////\r\n    ////////////       ERC721 implementation        ////////////\r\n    ////////////                                    ////////////\r\n    ////////////////////////////////////////////////////////////\r\n    ////////////////////////////////////////////////////////////\r\n    \r\n    function isValidNFT(uint256 _prime) private view returns (bool)\r\n    {\r\n        NumberType numberType = numberdataToNumberType(numberToNumberdata[_prime]);\r\n        return numberType == NumberType.PROBABLE_PRIME || numberType == NumberType.DEFINITE_PRIME;\r\n    }\r\n    \r\n    function isApprovedFor(address _operator, uint256 _prime) private view returns (bool)\r\n    {\r\n        address owner = getOwner(_prime);\r\n        \r\n        return\r\n            (owner == _operator) ||\r\n            (primeToAllowedAddress[_prime] == _operator) ||\r\n            (ownerToOperators[owner][_operator] == true);\r\n    }\r\n    \r\n    function isContract(address _addr) private view returns (bool)\r\n    {\r\n        uint256 addrCodesize;\r\n        assembly { addrCodesize := extcodesize(_addr) }\r\n        return addrCodesize != 0;\r\n    }\r\n    \r\n    function _tryCall(address _contract, bytes memory _selectorAndArguments) private returns (bool _success, bytes32 _returnData)\r\n    {\r\n        bytes32[1] memory returnDataArray;\r\n        uint256 dataLengthBytes = _selectorAndArguments.length;\r\n        \r\n        assembly\r\n        {\r\n            // call(gas, address, value, arg_ptr, arg_size, return_ptr, return_max_size)\r\n            _success := call(gas(), _contract, 0, _selectorAndArguments, dataLengthBytes, returnDataArray, 32)\r\n        }\r\n        \r\n        _returnData = returnDataArray[0];\r\n    }\r\n    \r\n    // Does not throw if prime does not exist or has no owner\r\n    function getOwner(uint256 _prime) public view returns (address)\r\n    {\r\n        return numberdataToOwner(numberToNumberdata[_prime]);\r\n    }\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    ////////////////////////////////////////////////////////////\r\n    ////////////////////////////////////////////////////////////\r\n    ////////////                                    ////////////\r\n    ////////////        Token implementation        ////////////\r\n    ////////////                                    ////////////\r\n    ////////////////////////////////////////////////////////////\r\n    ////////////////////////////////////////////////////////////\r\n    \r\n    function name() external pure returns (string memory)\r\n    {\r\n        return \"Prime number\";\r\n    }\r\n    \r\n    function symbol() external pure returns (string memory)\r\n    {\r\n        return \"PRIME\";\r\n    }\r\n    \r\n    function decimals() external pure returns (uint8)\r\n    {\r\n        return 0;\r\n    }\r\n    \r\n    function tokenURI(uint256 _tokenId) external view returns (string memory _uri)\r\n    {\r\n        require(isValidNFT(_tokenId));\r\n        \r\n        _uri = \"https://etherprime.jesbus.com/#search:\";\r\n        \r\n        uint256 baseURIlen = bytes(_uri).length;\r\n\r\n        // Count the amount of digits required to represent the prime number\r\n        uint256 digits = 0;\r\n        uint256 _currentNum = _tokenId;\r\n        while (_currentNum != 0)\r\n        {\r\n            _currentNum /= 10;\r\n            digits++;\r\n        }\r\n        \r\n        uint256 divisor = 10 ** (digits-1);\r\n        _currentNum = _tokenId;\r\n        \r\n        for (uint256 i=0; i<digits; i++)\r\n        {\r\n            uint8 digit = 0x30 + uint8(_currentNum / divisor);\r\n            \r\n            assembly { mstore8(add(add(_uri, 0x20), add(baseURIlen, i)), digit) }\r\n            \r\n            _currentNum %= divisor;\r\n            divisor /= 10;\r\n        }\r\n        \r\n        assembly { mstore(_uri, add(baseURIlen, digits)) }\r\n    }\r\n    \r\n    function totalSupply() external view returns (uint256)\r\n    {\r\n        return definitePrimes.length + probablePrimes.length;\r\n    }\r\n    \r\n    function balanceOf(address _owner) external view returns (uint256)\r\n    {\r\n        // According to ERC721 we should throw on queries about the 0x0 address\r\n        require(_owner != address(0x0), \"balanceOf error: owner may not be 0x0\");\r\n        \r\n        return ownerToPrimes[_owner].length;\r\n    }\r\n    \r\n    function addressPrimeCount(address _owner) external view returns (uint256)\r\n    {\r\n        return ownerToPrimes[_owner].length;\r\n    }\r\n    \r\n    function allowance(address _owner, address _spender) external view returns (uint256)\r\n    {\r\n        uint256 total = 0;\r\n        uint256[] storage primes = ownerToPrimes[_owner];\r\n        uint256 primesLength = primes.length;\r\n        for (uint256 i=0; i<primesLength; i++)\r\n        {\r\n            uint256 prime = primes[i];\r\n            if (primeToAllowedAddress[prime] == _spender)\r\n            {\r\n                total += prime;\r\n            }\r\n        }\r\n        return total;\r\n    }\r\n    \r\n    // Throws if prime has no owner or does not exist\r\n    function ownerOf(uint256 _prime) external view returns (address)\r\n    {\r\n        address owner = getOwner(_prime);\r\n        require(owner != address(0x0), \"ownerOf error: owner is set to 0x0\");\r\n        return owner;\r\n    }\r\n    \r\n    function safeTransferFrom(address _from, address _to, uint256 _prime, bytes memory _data) public returns (bool)\r\n    {\r\n        require(getOwner(_prime) == _from, \"safeTransferFrom error: from address does not own that prime\");\r\n        require(isApprovedFor(msg.sender, _prime), \"safeTransferFrom error: you do not have approval from the owner of that prime\");\r\n        _setOwner(_prime, _to, _data, msg.sender, \"\");\r\n        return true;\r\n    }\r\n    \r\n    function safeTransferFrom(address _from, address _to, uint256 _prime) external returns (bool)\r\n    {\r\n        return safeTransferFrom(_from, _to, _prime, \"\");\r\n    }\r\n    \r\n    function transferFrom(address _from, address _to, uint256 _prime) external returns (bool)\r\n    {\r\n        return safeTransferFrom(_from, _to, _prime, \"\");\r\n    }\r\n    \r\n    function approve(address _to, uint256 _prime) external returns (bool)\r\n    {\r\n        require(isApprovedFor(msg.sender, _prime), \"approve error: you do not have approval from the owner of that prime\");\r\n        primeToAllowedAddress[_prime] = _to;\r\n        emit Approval(msg.sender, _to, _prime);\r\n        return true;\r\n    }\r\n    \r\n    function setApprovalForAll(address _operator, bool _allowed) external returns (bool)\r\n    {\r\n        ownerToOperators[msg.sender][_operator] = _allowed;\r\n        emit ApprovalForAll(msg.sender, _operator, _allowed);\r\n        return true;\r\n    }\r\n    \r\n    function getApproved(uint256 _prime) external view returns (address)\r\n    {\r\n        require(isValidNFT(_prime), \"getApproved error: prime does not exist\");\r\n        return primeToAllowedAddress[_prime];\r\n    }\r\n    \r\n    function isApprovedForAll(address _owner, address _operator) external view returns (bool)\r\n    {\r\n        return ownerToOperators[_owner][_operator];\r\n    }\r\n    \r\n    function takeOwnership(uint256 _prime) external returns (bool)\r\n    {\r\n        require(isApprovedFor(msg.sender, _prime), \"takeOwnership error: you do not have approval from the owner of that prime\");\r\n        _setOwner(_prime, msg.sender);\r\n        return true;\r\n    }\r\n    \r\n    function transfer(address _to, uint256 _prime) external returns (bool)\r\n    {\r\n        require(isApprovedFor(msg.sender, _prime), \"transfer error: you do not have approval from the owner of that prime\");\r\n        _setOwner(_prime, _to);\r\n        return true;\r\n    }\r\n    \r\n    function transfer(address _to, uint _prime, bytes calldata _data) external returns (bool ok)\r\n    {\r\n        require(isApprovedFor(msg.sender, _prime), \"transfer error: you do not have approval from the owner of that prime\");\r\n        _setOwner(_prime, _to, _data, msg.sender, \"\");\r\n        return true;\r\n    }\r\n    \r\n    function tokenOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256)\r\n    {\r\n        uint256[] storage ownerPrimes = ownerToPrimes[_owner];\r\n        require(_index < ownerPrimes.length, \"tokenOfOwnerByIndex: index out of bounds\");\r\n        return ownerPrimes[_index];\r\n    }\r\n    \r\n    function tokenByIndex(uint256 _index) external view returns (uint256)\r\n    {\r\n        if (_index < definitePrimes.length) return definitePrimes[_index];\r\n        else if (_index < definitePrimes.length + probablePrimes.length) return probablePrimes[_index - definitePrimes.length];\r\n        else revert(\"tokenByIndex error: index out of bounds\");\r\n    }\r\n    \r\n    function tokensOf(address _owner) external view returns (uint256[] memory)\r\n    {\r\n        return ownerToPrimes[_owner];\r\n    }\r\n    \r\n    function implementsERC721() external pure returns (bool)\r\n    {\r\n        return true;\r\n    }\r\n    \r\n    function supportsInterface(bytes4 _interfaceID) external pure returns (bool)\r\n    {\r\n        \r\n        if (_interfaceID == 0x01ffc9a7) return true; // ERC165\r\n        if (_interfaceID == 0x80ac58cd) return true; // ERC721\r\n        if (_interfaceID == 0x5b5e139f) return true; // ERC721Metadata\r\n        if (_interfaceID == 0x780e9d63) return true; // ERC721Enumerable\r\n        return false;\r\n    }\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    ////////////////////////////////////////////////////////////\r\n    ////////////////////////////////////////////////////////////\r\n    ////////////                                    ////////////\r\n    ////////////           View functions           ////////////\r\n    ////////////                                    ////////////\r\n    ////////////////////////////////////////////////////////////\r\n    ////////////////////////////////////////////////////////////\r\n    \r\n    // numberToDivisor returns 0 if no divisor was found\r\n    function numberToDivisor(uint256 _number) public view returns (uint256)\r\n    {\r\n        if (_number == 0) return 0;\r\n        else if ((_number & 1) == 0) return 2;\r\n        else return numberToNonTwoDivisor[_number];\r\n    }\r\n    \r\n    function isPrime(uint256 _number) public view returns (Booly)\r\n    {\r\n        NumberType numberType = numberdataToNumberType(numberToNumberdata[_number]);\r\n        if (numberType == NumberType.DEFINITE_PRIME) return DEFINITELY;\r\n        else if (numberType == NumberType.PROBABLE_PRIME) return PROBABLY;\r\n        else if (numberType == NumberType.NOT_PRIME_IF_PASSED)\r\n        {\r\n            if (_number < numberBeingTested)\r\n            {\r\n                return DEFINITELY_NOT;\r\n            }\r\n            else\r\n            {\r\n                return UNKNOWN;\r\n            }\r\n        }\r\n        else if (numberType == NumberType.NOT_PRIME) return DEFINITELY_NOT;\r\n        else revert();\r\n    }\r\n    \r\n    function getPrimeFactors(uint256 _number) external view returns (bool _success, uint256[] memory _primeFactors)\r\n    {\r\n        _primeFactors = new uint256[](0);\r\n        if (_number == 0) { _success = false; return (_success, _primeFactors); }\r\n        \r\n        // Track length of primeFactors array\r\n        uint256 amount = 0;\r\n        \r\n        \r\n        uint256 currentNumber = _number;\r\n        \r\n        while (true)\r\n        {\r\n            // If we've divided to 1, we're done :)\r\n            if (currentNumber == 1) { _success = true; return (_success, _primeFactors); }\r\n            \r\n            uint256 divisor = numberToDivisor(currentNumber);\r\n            \r\n            if (divisor == 0)\r\n            {\r\n                if (isPrime(currentNumber) == DEFINITELY)\r\n                {\r\n                    // If we couldn't find a divisor and the current number is a definite prime,\r\n                    // then the current prime is itself the divisor.\r\n                    // It will be added to primeFactors, currentNumber will go to one,\r\n                    // and we will exit successfully on the next iteration.\r\n                    divisor = currentNumber;\r\n                }\r\n                else\r\n                {\r\n                    // If we don't know a divisor and we don't know for sure that the\r\n                    // current number is a definite prime, exit with failure.\r\n                    _success = false;\r\n                    return (_success, _primeFactors);\r\n                }\r\n            }\r\n            else\r\n            {\r\n                while (isPrime(divisor) != DEFINITELY)\r\n                {\r\n                    divisor = numberToDivisor(divisor);\r\n                    if (divisor == 0) { _success = false; return (_success, _primeFactors); }\r\n                }\r\n            }\r\n            \r\n            currentNumber /= divisor;\r\n            \r\n            // This in effect does: primeFactors.push(primeFactor)\r\n            {\r\n                amount++;\r\n                assembly\r\n                {\r\n                    mstore(0x40, add(mload(0x40), 0x20)) // dirty: extend usable memory\r\n                    mstore(_primeFactors, amount) // dirty: set memory array size\r\n                }\r\n                _primeFactors[amount-1] = divisor;\r\n            }\r\n        }\r\n    }\r\n    \r\n    /*function isKnownNotPrime(uint256 _number) external view returns (bool)\r\n    {\r\n        return numberdataToNumberType(numberToNumberdata[_number]) == NumberType.NOT_PRIME;\r\n    }\r\n    \r\n    function isKnownDefinitePrime(uint256 _number) public view returns (bool)\r\n    {\r\n        return numberdataToNumberType(numberToNumberdata[_number]) == NumberType.DEFINITE_PRIME;\r\n    }\r\n    \r\n    function isKnownProbablePrime(uint256 _number) public view returns (bool)\r\n    {\r\n        return numberdataToNumberType(numberToNumberdata[_number]) == NumberType.PROBABLE_PRIME;\r\n    }*/\r\n\r\n    function amountOfParticipants() external view returns (uint256)\r\n    {\r\n        return participants.length;\r\n    }\r\n    \r\n    function amountOfPrimesOwnedByOwner(address owner) external view returns (uint256)\r\n    {\r\n        return ownerToPrimes[owner].length;\r\n    }\r\n    \r\n    function amountOfPrimesFound() external view returns (uint256)\r\n    {\r\n        return definitePrimes.length + probablePrimes.length;\r\n    }\r\n    \r\n    function amountOfDefinitePrimesFound() external view returns (uint256)\r\n    {\r\n        return definitePrimes.length;\r\n    }\r\n    \r\n    function amountOfProbablePrimesFound() external view returns (uint256)\r\n    {\r\n        return probablePrimes.length;\r\n    }\r\n    \r\n    function largestDefinitePrimeFound() public view returns (uint256)\r\n    {\r\n        return definitePrimes[definitePrimes.length-1];\r\n    }\r\n    \r\n    function getInsecureRandomDefinitePrime() external view returns (uint256)\r\n    {\r\n        return definitePrimes[insecureRand()%definitePrimes.length];\r\n    }\r\n    \r\n    function getInsecureRandomProbablePrime() external view returns (uint256)\r\n    {\r\n        return probablePrimes[insecureRand()%probablePrimes.length];\r\n    }\r\n\r\n\r\n\r\n    \r\n    ////////////////////////////////////////////////////////////\r\n    ////////////////////////////////////////////////////////////\r\n    ////////////                                    ////////////\r\n    ////////////            Constructor             ////////////\r\n    ////////////                                    ////////////\r\n    ////////////////////////////////////////////////////////////\r\n    ////////////////////////////////////////////////////////////\r\n    \r\n    constructor() public\r\n    {\r\n        participants.push(address(0x0));\r\n        \r\n        // Let's start with 2.\r\n        _createPrime(2, msg.sender, true);\r\n        \r\n        // The next one up for prime checking will be 3.\r\n        numberBeingTested = 3;\r\n        divisorIndexBeingTested = 0;\r\n        \r\n        new EtherPrimeChat(this);\r\n    }\r\n    \r\n    \r\n\r\n    \r\n    \r\n    \r\n    ////////////////////////////////////////////////////////////\r\n    ////////////////////////////////////////////////////////////\r\n    ////////////                                    ////////////\r\n    ////////////     Definite prime generation      ////////////\r\n    ////////////                                    ////////////\r\n    ////////////////////////////////////////////////////////////\r\n    ////////////////////////////////////////////////////////////\r\n    \r\n    // Call these function to help calculate prime numbers.\r\n    // The reward shall be your immortalized glory.\r\n    \r\n    uint256 private constant DEFAULT_PRIMES_TO_MEMORIZE = 0;\r\n    uint256 private constant DEFAULT_LOW_LEVEL_GAS = 200000;\r\n    \r\n    function () external\r\n    {\r\n        computeWithParams(definitePrimes.length/2, DEFAULT_LOW_LEVEL_GAS, msg.sender);\r\n    }\r\n    \r\n    function compute() external\r\n    {\r\n        computeWithParams(definitePrimes.length/2, DEFAULT_LOW_LEVEL_GAS, msg.sender);\r\n    }\r\n    \r\n    function computeAndGiveTo(address _recipient) external\r\n    {\r\n        computeWithParams(definitePrimes.length/2, DEFAULT_LOW_LEVEL_GAS, _recipient);\r\n    }\r\n    \r\n    function computeWithPrimesToMemorize(uint256 _primesToMemorize) external\r\n    {\r\n        computeWithParams(_primesToMemorize, DEFAULT_LOW_LEVEL_GAS, msg.sender);\r\n    }\r\n    \r\n    function computeWithPrimesToMemorizeAndLowLevelGas(uint256 _primesToMemorize, uint256 _lowLevelGas) external\r\n    {\r\n        computeWithParams(_primesToMemorize, _lowLevelGas, msg.sender);\r\n    }\r\n    \r\n    function computeWithParams(uint256 _primesToMemorize, uint256 _lowLevelGas, address _recipient) public\r\n    {\r\n        require(_primesToMemorize <= definitePrimes.length, \"computeWithParams error: _primesToMemorize out of bounds\");\r\n        \r\n        uint256 startGas = gasleft();\r\n        \r\n        // We need to continue where we stopped last time.\r\n        uint256 number = numberBeingTested;\r\n        uint256 divisorIndex = divisorIndexBeingTested;\r\n        \r\n        // Read this in advance so we don't have to keep SLOAD'ing it\r\n        uint256 totalPrimes = definitePrimes.length;\r\n        \r\n        // Load some discovered definite primes into memory\r\n        uint256[] memory definitePrimesCache = new uint256[](_primesToMemorize);\r\n        for (uint256 i=0; i<_primesToMemorize; i++)\r\n        {\r\n            definitePrimesCache[i] = definitePrimes[i];\r\n        }\r\n        \r\n        for (; ; number += 2)\r\n        {\r\n            // Save state and stop if remaining gas is too low\r\n            if (gasleft() < _lowLevelGas)\r\n            {\r\n                numberBeingTested = number;\r\n                divisorIndexBeingTested = divisorIndex;\r\n                uint256 gasSpent = startGas - gasleft();\r\n                addressToGasSpent[msg.sender] += gasSpent;\r\n                addressToEtherSpent[msg.sender] += gasSpent * tx.gasprice;\r\n                return;\r\n            }\r\n            \r\n            if (isPrime(number) != DEFINITELY_NOT)\r\n            {\r\n                uint256 sqrtNumberRoundedDown = sqrtRoundedDown(number);\r\n                \r\n                bool numberCanStillBePrime = true;\r\n                uint256 divisor;\r\n                \r\n                for (; divisorIndex<totalPrimes; divisorIndex++)\r\n                {\r\n                    // Save state and stop if remaining gas is too low\r\n                    if (gasleft() < _lowLevelGas)\r\n                    {\r\n                        numberBeingTested = number;\r\n                        divisorIndexBeingTested = divisorIndex;\r\n                        uint256 gasSpent = startGas - gasleft();\r\n                        addressToGasSpent[msg.sender] += gasSpent;\r\n                        addressToEtherSpent[msg.sender] += gasSpent * tx.gasprice;\r\n                        return;\r\n                    }\r\n                    \r\n                    if (divisorIndex < definitePrimesCache.length) divisor = definitePrimesCache[divisorIndex];\r\n                    else divisor = definitePrimes[divisorIndex];\r\n                    \r\n                    if (number % divisor == 0)\r\n                    {\r\n                        numberCanStillBePrime = false;\r\n                        break;\r\n                    }\r\n                    \r\n                    // We don't have to try to divide by numbers higher than the\r\n                    // square root of the number. Why? Well, suppose you're testing\r\n                    // if 29 is prime. You've already tried dividing by 2, 3, 4, 5\r\n                    // and found that you couldn't, so now you move on to 6.\r\n                    // Trying to divide it by 6 is futile, because if 29 were\r\n                    // divisible by 6, it would logically also be divisible by 29/6\r\n                    // which you should already have found at that point, because\r\n                    // 29/6 < 6, because 6 > sqrt(29)\r\n                    if (divisor > sqrtNumberRoundedDown)\r\n                    {\r\n                        break;\r\n                    }\r\n                }\r\n                \r\n                if (numberCanStillBePrime)\r\n                {\r\n                    _createPrime(number, _recipient, true);\r\n                    totalPrimes++;\r\n                }\r\n                else\r\n                {\r\n                    numberToNonTwoDivisor[number] = divisor;\r\n                }\r\n                \r\n                // Start trying to divide by 3.\r\n                // We skip all the even numbers so we don't have to bother dividing by 2.\r\n                divisorIndex = 1;\r\n            }\r\n        }\r\n        \r\n        // This point should be unreachable.\r\n        revert(\"computeWithParams error: This point should never be reached.\");\r\n    }\r\n    \r\n    // https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method\r\n    function sqrtRoundedDown(uint256 x) private pure returns (uint256 y)\r\n    {\r\n        if (x == ~uint256(0)) return 340282366920938463463374607431768211455;\r\n        \r\n        uint256 z = (x + 1) >> 1;\r\n        y = x;\r\n        while (z < y)\r\n        {\r\n            y = z;\r\n            z = ((x / z) + z) >> 1;\r\n        }\r\n        return y;\r\n    }\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    ////////////////////////////////////////////////////////////\r\n    ////////////////////////////////////////////////////////////\r\n    ////////////                                    ////////////\r\n    ////////////            Prime classes           ////////////\r\n    ////////////                                    ////////////\r\n    ////////////////////////////////////////////////////////////\r\n    ////////////////////////////////////////////////////////////\r\n    \r\n    // Balanced primes are exactly in the middle between the two surrounding primes\r\n    function isBalancedPrime(uint256 _prime) external view returns (Booly result, uint256 lowerPrime, uint256 higherPrime)\r\n    {\r\n        Booly primality = isPrime(_prime);\r\n        if (primality == DEFINITELY_NOT)\r\n        {\r\n            return (DEFINITELY_NOT, 0, 0);\r\n        }\r\n        else if (primality == PROBABLY_NOT)\r\n        {\r\n            return (PROBABLY_NOT, 0, 0);\r\n        }\r\n        else if (primality == UNKNOWN)\r\n        {\r\n            return (UNKNOWN, 0, 0);\r\n        }\r\n        else if (primality == PROBABLY)\r\n        {\r\n            return (UNKNOWN, 0, 0);\r\n        }\r\n        else if (primality == DEFINITELY)\r\n        {\r\n            uint256 index = numberdataToAllPrimesIndex(numberToNumberdata[_prime]);\r\n            if (index == 0)\r\n            {\r\n                // 2 is not a balanced prime, because there is no prime before it\r\n                return (DEFINITELY_NOT, 0, 0);\r\n            }\r\n            else if (index == definitePrimes.length-1)\r\n            {\r\n                // We cannot determine this property for the last prime we've found\r\n                return (UNKNOWN, 0, 0);\r\n            }\r\n            else\r\n            {\r\n                uint256 primeBefore = definitePrimes[index-1];\r\n                uint256 primeAfter = definitePrimes[index+1];\r\n                if (_prime - primeBefore == primeAfter - _prime) return (DEFINITELY, primeBefore, primeAfter);\r\n                else return (DEFINITELY_NOT, primeBefore, primeAfter);\r\n            }\r\n        }\r\n        else\r\n        {\r\n            revert();\r\n        }\r\n    }\r\n    \r\n    // NTuple mersenne primes:\r\n    // n=0 => primes                                            returns []\r\n    // n=1 => mersenne primes of form 2^p-1                     returns [p]\r\n    // n=2 => double mersenne primes of form 2^(2^p-1)-1        returns [2^p-1, p]\r\n    // n=3 => triple mersenne primes of form 2^(2^(2^p-1)-1)-1  returns [2^(2^p-1)-1, 2^p-1, p]\r\n    // etc..\r\n    function isNTupleMersennePrime(uint256 _number, uint256 _n) external view returns (Booly _result, uint256[] memory _powers)\r\n    {\r\n        _powers = new uint256[](_n);\r\n        \r\n        // Prevent overflow on _number+1\r\n        if (_number+1 < _number) return (UNKNOWN, _powers);\r\n        \r\n        _result = isPrime(_number);\r\n        if (_result == DEFINITELY_NOT) { return (DEFINITELY_NOT, _powers); }\r\n        \r\n        uint256 currentNumber = _number;\r\n        \r\n        for (uint256 i=0; i<_n; i++)\r\n        {\r\n            Booly powerOf2ity = isPowerOf2(currentNumber+1) ? DEFINITELY : DEFINITELY_NOT;\r\n            if (powerOf2ity == DEFINITELY_NOT) { return (DEFINITELY_NOT, _powers); }\r\n            \r\n            _powers[i] = currentNumber = log2ofPowerOf2(currentNumber+1);\r\n        }\r\n        \r\n        return (_result, _powers);\r\n    }\r\n    \r\n    // A good prime's square is greater than the product of all equally distant (by index) primes\r\n    function isGoodPrime(uint256 _number) external view returns (Booly)\r\n    {\r\n        // 2 is defined not to be a good prime.\r\n        if (_number == 2) return DEFINITELY_NOT;\r\n        \r\n        Booly primality = isPrime(_number);\r\n        if (primality == DEFINITELY)\r\n        {\r\n            uint256 index = numberdataToAllPrimesIndex(numberToNumberdata[_number]);\r\n            \r\n            if (index*2 >= definitePrimes.length)\r\n            {\r\n                // We haven't found enough definite primes yet to determine this property\r\n                return UNKNOWN;\r\n            }\r\n            else\r\n            {\r\n                uint256 squareOfInput;\r\n                bool mulSuccess;\r\n                \r\n                (squareOfInput, mulSuccess) = TRY_MUL(_number, _number);\r\n                if (!mulSuccess) return UNKNOWN;\r\n                \r\n                for (uint256 i=1; i<=index; i++)\r\n                {\r\n                    uint256 square;\r\n                    (square, mulSuccess) = TRY_MUL(definitePrimes[index-i], definitePrimes[index+i]);\r\n                    if (!mulSuccess) return UNKNOWN;\r\n                    if (square >= squareOfInput)\r\n                    {\r\n                        return DEFINITELY_NOT;\r\n                    }\r\n                }\r\n                return DEFINITELY;\r\n            }\r\n        }\r\n        else if (primality == PROBABLY || primality == UNKNOWN)\r\n        {\r\n            // We can't determine it\r\n            return UNKNOWN;\r\n        }\r\n        else if (primality == DEFINITELY_NOT)\r\n        {\r\n            return DEFINITELY_NOT;\r\n        }\r\n        else if (primality == PROBABLY_NOT)\r\n        {\r\n            return PROBABLY_NOT;\r\n        }\r\n        else\r\n        {\r\n            // This should never happen\r\n            revert();\r\n        }\r\n    }\r\n    \r\n    // Factorial primes are of the form n!+delta where delta = +1 or delta = -1\r\n    function isFactorialPrime(uint256 _number) external view returns (Booly _result, uint256 _n, int256 _delta)\r\n    {\r\n        // Prevent underflow on _number-1\r\n        if (_number == 0) return (DEFINITELY_NOT, 0, 0);\r\n        \r\n        // Prevent overflow on _number+1\r\n        if (_number == ~uint256(0)) return (DEFINITELY_NOT, 0, 0);\r\n        \r\n        \r\n        Booly primality = isPrime(_number);\r\n        \r\n        if (primality == DEFINITELY_NOT) return (DEFINITELY_NOT, 0, 0);\r\n        \r\n        bool factorialityOfPrimePlus1;\r\n        uint256 primePlus1n;\r\n\r\n        // Detect factorial primes of the form n!-1\r\n        (primePlus1n, factorialityOfPrimePlus1) = reverseFactorial(_number+1);\r\n        if (factorialityOfPrimePlus1) return (AND(primality, factorialityOfPrimePlus1), primePlus1n, -1);\r\n\r\n        bool factorialityOfPrimeMinus1;\r\n        uint256 primeMinus1n;\r\n        \r\n        (primeMinus1n, factorialityOfPrimeMinus1) = reverseFactorial(_number-1);\r\n        if (factorialityOfPrimeMinus1) return (AND(primality, factorialityOfPrimeMinus1), primeMinus1n, 1);\r\n        \r\n        return (DEFINITELY_NOT, 0, 0);\r\n    }\r\n    \r\n    // Cullen primes are of the form n * 2^n + 1\r\n    function isCullenPrime(uint256 _number) external pure returns (Booly _result, uint256 _n)\r\n    {\r\n        // There are only two cullen primes that fit in a 256-bit integer\r\n        if (_number == 3)  // n = 1\r\n        {\r\n            return (DEFINITELY, 1);\r\n        }\r\n        else if (_number == 393050634124102232869567034555427371542904833) // n = 141\r\n        {\r\n            return (DEFINITELY, 141);\r\n        }\r\n        else\r\n        {\r\n            return (DEFINITELY_NOT, 0);\r\n        }\r\n    }\r\n    \r\n    // Fermat primes are of the form 2^(2^n)+1\r\n    // Conjecturally, 3, 5, 17, 257, 65537 are the only ones\r\n    function isFermatPrime(uint256 _number) external view returns (Booly result, uint256 _2_pow_n, uint256 _n)\r\n    {\r\n        // Prevent underflow on _number-1\r\n        if (_number == 0) return (DEFINITELY_NOT, 0, 0);\r\n        \r\n        \r\n        Booly primality = isPrime(_number);\r\n        \r\n        if (primality == DEFINITELY_NOT) return (DEFINITELY_NOT, 0, 0);\r\n        \r\n        bool is__2_pow_2_pow_n__powerOf2 = isPowerOf2(_number-1);\r\n        \r\n        if (!is__2_pow_2_pow_n__powerOf2) return (DEFINITELY_NOT, 0, 0);\r\n        \r\n        _2_pow_n = log2ofPowerOf2(_number-1);\r\n        \r\n        bool is__2_pow_n__powerOf2 = isPowerOf2(_2_pow_n);\r\n        \r\n        if (!is__2_pow_n__powerOf2) return (DEFINITELY_NOT, _2_pow_n, 0);\r\n        \r\n        _n = log2ofPowerOf2(_2_pow_n);\r\n    }\r\n    \r\n    // Super-primes are primes with a prime index in the sequence of prime numbers. (indexed starting with 1)\r\n    function isSuperPrime(uint256 _number) public view returns (Booly _result, uint256 _indexStartAtOne)\r\n    {\r\n        Booly primality = isPrime(_number);\r\n        if (primality == DEFINITELY)\r\n        {\r\n            _indexStartAtOne = numberdataToAllPrimesIndex(numberToNumberdata[_number]) + 1;\r\n            _result = isPrime(_indexStartAtOne);\r\n            return (_result, _indexStartAtOne);\r\n        }\r\n        else if (primality == DEFINITELY_NOT)\r\n        {\r\n            return (DEFINITELY_NOT, 0);\r\n        }\r\n        else if (primality == UNKNOWN)\r\n        {\r\n            return (UNKNOWN, 0);\r\n        }\r\n        else if (primality == PROBABLY)\r\n        {\r\n            return (UNKNOWN, 0);\r\n        }\r\n        else if (primality == PROBABLY_NOT)\r\n        {\r\n            return (PROBABLY_NOT, 0);\r\n        }\r\n        else\r\n        {\r\n            revert();\r\n        }\r\n    }\r\n    \r\n    function isFibonacciPrime(uint256 _number) public view returns (Booly _result)\r\n    {\r\n        return AND_F(isPrime, isFibonacciNumber, _number);\r\n    }\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    ////////////////////////////////////////////////////////////\r\n    ////////////////////////////////////////////////////////////\r\n    ////////////                                    ////////////\r\n    ////////////          Number classes            ////////////\r\n    ////////////                                    ////////////\r\n    ////////////////////////////////////////////////////////////\r\n    ////////////////////////////////////////////////////////////\r\n    \r\n    function isFibonacciNumber(uint256 _number) public pure returns (Booly _result)\r\n    {\r\n        // If _number doesn't fit inside a uint126, we can't perform the computations necessary to check fibonaccality.\r\n        // We need to be able to square it, multiply by 5 then add 4.\r\n        // Adding 4 removes 1 bit of room: uint256 -> uint255\r\n        // Multiplying by 5 removes 3 bits of room: uint255 -> uint252\r\n        // Squaring removes 50% of room: uint252 -> uint126\r\n        // Rounding down to the nearest solidity type: uint126 -> uint120\r\n\r\n        if (uint256(uint120(_number)) != _number) return UNKNOWN;\r\n        \r\n        uint256 squareOfNumber = _number * _number;\r\n        uint256 squareTimes5 = squareOfNumber * 5;\r\n        uint256 squareTimes5plus4 = squareTimes5 + 4;\r\n        \r\n        bool squareTimes5plus4squarality;\r\n        (squareTimes5plus4squarality, ) = isSquareNumber(squareTimes5plus4);\r\n        \r\n        if (squareTimes5plus4squarality) return DEFINITELY;\r\n        \r\n        uint256 squareTimes5minus4 = squareTimes5 - 4;\r\n        \r\n        bool squareTimes5minus4squarality;\r\n        \r\n        // Check underflow\r\n        if (squareTimes5minus4 > squareTimes5) \r\n        {\r\n            squareTimes5minus4squarality = false;\r\n        }\r\n        else\r\n        {\r\n            (squareTimes5minus4squarality, ) = isSquareNumber(squareTimes5minus4);\r\n        }\r\n        \r\n        return (squareTimes5plus4squarality || squareTimes5minus4squarality) ? DEFINITELY : DEFINITELY_NOT;\r\n    }\r\n    \r\n    function isSquareNumber(uint256 _number) private pure returns (bool _result, uint256 _squareRoot)\r\n    {\r\n        uint256 rootRoundedDown = sqrtRoundedDown(_number);\r\n        return (rootRoundedDown * rootRoundedDown == _number, rootRoundedDown);\r\n    }\r\n    \r\n\r\n\r\n\r\n\r\n\r\n\r\n    \r\n    ////////////////////////////////////////////////////////////\r\n    ////////////////////////////////////////////////////////////\r\n    ////////////                                    ////////////\r\n    ////////////           Math functions           ////////////\r\n    ////////////                                    ////////////\r\n    ////////////////////////////////////////////////////////////\r\n    ////////////////////////////////////////////////////////////\r\n    \r\n    function reverseFactorial(uint256 _number) private pure returns (uint256 output, bool success)\r\n    {\r\n        // 0 = immediate failure\r\n        if (_number == 0) return (0, false);\r\n        \r\n        uint256 divisor = 1;\r\n        while (_number > 1)\r\n        {\r\n            divisor++;\r\n            uint256 remainder = _number % divisor;\r\n            if (remainder != 0) return (divisor, false);\r\n            _number /= divisor;\r\n        }\r\n        \r\n        return (divisor, true);\r\n    }\r\n    \r\n    function isPowerOf2(uint256 _number) private pure returns (bool)\r\n    {\r\n        if (_number == 0) return false;\r\n        else return ((_number-1) & _number) == 0;\r\n    }\r\n    \r\n    // Performs a log2 on a power of 2.\r\n    // This function will throw if the input was not a power of 2.\r\n    function log2ofPowerOf2(uint256 _powerOf2) private pure returns (uint256)\r\n    {\r\n        require(_powerOf2 != 0, \"log2ofPowerOf2 error: 0 is not a power of 2\");\r\n        uint256 iterations = 0;\r\n        while (true)\r\n        {\r\n            if (_powerOf2 == 1) return iterations;\r\n            require((_powerOf2 & 1) == 0, \"log2ofPowerOf2 error: argument is not a power of 2\"); // The current number must be divisible by 2\r\n            _powerOf2 >>= 1; // Divide by 2\r\n            iterations++;\r\n        }\r\n    }\r\n    \r\n    // Generate a random number with low gas cost.\r\n    // This RNG is not secure and can be influenced!\r\n    function insecureRand() private view returns (uint256)\r\n    {\r\n        return uint256(keccak256(abi.encodePacked(\r\n            largestDefinitePrimeFound(),\r\n            probablePrimes.length,\r\n            block.coinbase,\r\n            block.timestamp,\r\n            block.number,\r\n            block.difficulty,\r\n            tx.origin,\r\n            tx.gasprice,\r\n            msg.sender,\r\n            now,\r\n            gasleft()\r\n        )));\r\n    }\r\n    \r\n    // TRY_POW_MOD function defines 0^0 % n = 1\r\n    function TRY_POW_MOD(uint256 _base, uint256 _power, uint256 _modulus) private pure returns (uint256 result, bool success)\r\n    {\r\n        if (_modulus == 0) return (0, false);\r\n        \r\n        bool mulSuccess;\r\n        _base %= _modulus;\r\n        result = 1;\r\n        while (_power > 0)\r\n        {\r\n            if (_power & uint256(1) != 0)\r\n            {\r\n                (result, mulSuccess) = TRY_MUL(result, _base);\r\n                if (!mulSuccess) return (0, false);\r\n                result %= _modulus;\r\n            }\r\n            (_base, mulSuccess) = TRY_MUL(_base, _base);\r\n            if (!mulSuccess) return (0, false);\r\n            _base = _base % _modulus;\r\n            _power >>= 1;\r\n        }\r\n        success = true;\r\n    }\r\n    \r\n    function TRY_MUL(uint256 _i, uint256 _j) private pure returns (uint256 result, bool success)\r\n    {\r\n        if (_i == 0) { return (0, true); }\r\n        uint256 ret = _i * _j;\r\n        if (ret / _i == _j) return (ret, true);\r\n        else return (ret, false);\r\n    }\r\n\r\n\r\n\r\n\r\n    \r\n    ////////////////////////////////////////////////////////////\r\n    ////////////////////////////////////////////////////////////\r\n    ////////////                                    ////////////\r\n    ////////////           Miller-rabin             ////////////\r\n    ////////////                                    ////////////\r\n    ////////////////////////////////////////////////////////////\r\n    ////////////////////////////////////////////////////////////\r\n    \r\n    // This function runs one trial. It returns false if n is\r\n    // definitely composite and true if n is probably prime.\r\n    // d must be an odd number such that d*2^r = n-1 for some r >= 1\r\n    function probabilisticTest(uint256 d, uint256 _number, uint256 _random) private pure returns (bool result, bool success)\r\n    {\r\n        // Check d\r\n        assert(d & 1 == 1); // d is odd\r\n        assert((_number-1) % d == 0); // n-1 divisible by d\r\n        uint256 nMinusOneOverD = (_number-1) / d;\r\n        assert(isPowerOf2(nMinusOneOverD)); // (n-1)/d is power of 2\r\n        assert(nMinusOneOverD >= 1); // 2^r >= 2 therefore r >= 1\r\n        \r\n        // Make sure we can subtract 4 from _number\r\n        if (_number < 4) return (false, false);\r\n        \r\n        // Pick a random number in [2..n-2]\r\n        uint256 a = 2 + _random % (_number - 4);\r\n        \r\n        // Compute a^d % n\r\n        uint256 x;\r\n        (x, success) = TRY_POW_MOD(a, d, _number);\r\n        if (!success) return (false, false);\r\n        \r\n        if (x == 1 || x == _number-1)\r\n        {\r\n            return (true, true);\r\n        }\r\n        \r\n        // Keep squaring x while one of the following doesn't\r\n        // happen\r\n        // (i)   d does not reach n-1\r\n        // (ii)  (x^2) % n is not 1\r\n        // (iii) (x^2) % n is not n-1\r\n        while (d != _number-1)\r\n        {\r\n            (x, success) = TRY_MUL(x, x);\r\n            if (!success) return (false, false);\r\n            \r\n            x %= _number;\r\n            \r\n            (d, success) = TRY_MUL(d, 2);\r\n            if (!success) return (false, false);\r\n            \r\n            \r\n            if (x == 1) return (false, true);\r\n            if (x == _number-1) return (true, true);\r\n        }\r\n     \r\n        // Return composite\r\n        return (false, true);\r\n    }\r\n    \r\n    // This functions runs multiple miller-rabin trials.\r\n    // It returns false if _number is definitely composite and\r\n    // true if _number is probably prime.\r\n    function isPrime_probabilistic(uint256 _number) public view returns (Booly)\r\n    {\r\n        // 40 iterations is heuristically enough for extremely high certainty\r\n        uint256 probabilistic_iterations = 40;\r\n        \r\n        // Corner cases\r\n        if (_number == 0 || _number == 1 || _number == 4)  return DEFINITELY_NOT;\r\n        if (_number == 2 || _number == 3) return DEFINITELY;\r\n        \r\n        // Find d such that _number == 2^d * r + 1 for some r >= 1\r\n        uint256 d = _number - 1;\r\n        while ((d & 1) == 0)\r\n        {\r\n            d >>= 1;\r\n        }\r\n        \r\n        uint256 random = insecureRand();\r\n        \r\n        // Run the probabilistic test many times with different randomness\r\n        for (uint256 i = 0; i < probabilistic_iterations; i++)\r\n        {\r\n            bool result;\r\n            bool success;\r\n            (result, success) = probabilisticTest(d, _number, random);\r\n            if (success == false)\r\n            {\r\n                return UNKNOWN;\r\n            }\r\n            if (result == false)\r\n            {\r\n                return DEFINITELY_NOT;\r\n            }\r\n            \r\n            // Shuffle bits\r\n            random *= 22777;\r\n            random ^= (random >> 7);\r\n            random *= 71879;\r\n            random ^= (random >> 11);\r\n        }\r\n        \r\n        return PROBABLY;\r\n    }\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    ////////////////////////////////////////////////////////////\r\n    ////////////////////////////////////////////////////////////\r\n    ////////////                                    ////////////\r\n    ////////////  Claim & disprove probable primes  ////////////\r\n    ////////////                                    ////////////\r\n    ////////////////////////////////////////////////////////////\r\n    ////////////////////////////////////////////////////////////\r\n    \r\n    function claimProbablePrime(uint256 _number) public\r\n    {\r\n        require(tryClaimProbablePrime(_number), \"claimProbablePrime error: that number is not prime or has already been claimed\");\r\n    }\r\n    \r\n    function tryClaimProbablePrime(uint256 _number) public returns (bool _success)\r\n    {\r\n        uint256 startGas = gasleft();\r\n        \r\n        Booly primality = isPrime(_number);\r\n        \r\n        // If we already have knowledge about the provided number, cancel the claim attempt.\r\n        if (primality != UNKNOWN)\r\n        {\r\n            _success = false;\r\n        }\r\n        else\r\n        {\r\n            primality = isPrime_probabilistic(_number);\r\n            \r\n            if (primality == DEFINITELY_NOT)\r\n            {\r\n                // If it's not prime, remember it as such\r\n                _numberdataSetNumberType(_number, NumberType.NOT_PRIME);\r\n                \r\n                 _success = false;\r\n            }\r\n            else if (primality == PROBABLY)\r\n            {\r\n                _createPrime(_number, msg.sender, false);\r\n                \r\n                addressToProbablePrimesClaimed[msg.sender]++;\r\n                \r\n                 _success = true;\r\n            }\r\n            else\r\n            {\r\n                 _success = false;\r\n            }\r\n        }\r\n        \r\n        uint256 gasSpent = startGas - gasleft();\r\n        addressToGasSpent[msg.sender] += gasSpent;\r\n        addressToEtherSpent[msg.sender] += gasSpent * tx.gasprice;\r\n    }\r\n    \r\n    function disproveProbablePrime(uint256 _prime, uint256 _divisor) external\r\n    {\r\n        require(_divisor > 1 && _divisor < _prime, \"disproveProbablePrime error: divisor must be greater than 1 and smaller than prime\");\r\n        \r\n        bytes32 numberdata = numberToNumberdata[_prime];\r\n        \r\n        // If _prime is a probable prime...\r\n        require(numberdataToNumberType(numberdata) == NumberType.PROBABLE_PRIME, \"disproveProbablePrime error: that prime is not a probable prime\");\r\n        \r\n        // ... and _prime is divisible by _divisor ...\r\n        require((_prime % _divisor) == 0, \"disproveProbablePrime error: that prime is not divisible by that divisor\");\r\n        \r\n        address owner = numberdataToOwner(numberdata);\r\n        \r\n        // Statistics\r\n        addressToProbablePrimesDisprovenFrom[owner]++;\r\n        addressToProbablePrimesDisprovenBy[msg.sender]++;\r\n        \r\n        _setOwner(_prime, address(0x0));\r\n        \r\n        _numberdataSetNumberType(_prime, NumberType.NOT_PRIME);\r\n        \r\n        // Remove it from the probablePrimes array\r\n        uint256 primeIndex = numberdataToAllPrimesIndex(numberdata);\r\n        \r\n        // If the prime we're removing is not the last one in the probablePrimes array...\r\n        if (primeIndex < probablePrimes.length-1)\r\n        {\r\n            // ...move the last one back into its slot.\r\n            uint256 otherPrimeBeingMoved = probablePrimes[probablePrimes.length-1];\r\n            _numberdataSetAllPrimesIndex(otherPrimeBeingMoved, uint48(primeIndex));\r\n            probablePrimes[primeIndex] = otherPrimeBeingMoved;\r\n        }\r\n        probablePrimes[probablePrimes.length-1] = 0; // Refund some gas\r\n        probablePrimes.length--;\r\n        \r\n        // Broadcast event\r\n        emit ProbablePrimeDisproven(_prime, _divisor, owner, msg.sender, primeIndex);\r\n        \r\n        // Store the divisor\r\n        numberToNonTwoDivisor[_prime] = _divisor;\r\n    }\r\n    \r\n    function claimProbablePrimeInRange(uint256 _start, uint256 _end) external returns (bool _success, uint256 _prime)\r\n    {\r\n        for (uint256 currentNumber = _start; currentNumber <= _end; currentNumber++)\r\n        {\r\n            if (tryClaimProbablePrime(currentNumber)) { return (true, currentNumber); }\r\n        }\r\n        return (false, 0);\r\n    }\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    ////////////////////////////////////////////////////////////\r\n    ////////////////////////////////////////////////////////////\r\n    ////////////                                    ////////////\r\n    ////////////      Try to stop people from       ////////////\r\n    ////////////    accidentally sending tokens     ////////////\r\n    ////////////         to this contract           ////////////\r\n    ////////////                                    ////////////\r\n    ////////////////////////////////////////////////////////////\r\n    ////////////////////////////////////////////////////////////\r\n    \r\n    function onERC721Received(address, address, uint256, bytes calldata) external pure // ERC721\r\n    {\r\n        revert(\"EtherPrime contract should not receive tokens\");\r\n    }\r\n    \r\n    function tokenFallback(address, uint256, bytes calldata) external pure // ERC223\r\n    {\r\n        revert(\"EtherPrime contract should not receive tokens\");\r\n    }\r\n    \r\n    function tokensReceived(address, address, address, uint, bytes calldata, bytes calldata) external pure // ERC777\r\n    {\r\n        revert(\"EtherPrime contract should not receive tokens\");\r\n    }\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    ////////////////////////////////////////////////////////////\r\n    ////////////////////////////////////////////////////////////\r\n    ////////////                                    ////////////\r\n    ////////////            Booly stuff             ////////////\r\n    ////////////                                    ////////////\r\n    ////////////////////////////////////////////////////////////\r\n    ////////////////////////////////////////////////////////////\r\n    \r\n    // Penta-state logic implementation\r\n    \r\n    enum Booly\r\n    {\r\n        DEFINITELY_NOT,\r\n        PROBABLY_NOT,\r\n        UNKNOWN,\r\n        PROBABLY,\r\n        DEFINITELY\r\n    }\r\n    \r\n    Booly public constant DEFINITELY_NOT = Booly.DEFINITELY_NOT;\r\n    Booly public constant PROBABLY_NOT = Booly.PROBABLY_NOT;\r\n    Booly public constant UNKNOWN = Booly.UNKNOWN;\r\n    Booly public constant PROBABLY = Booly.PROBABLY;\r\n    Booly public constant DEFINITELY = Booly.DEFINITELY;\r\n    \r\n    function OR(Booly a, Booly b) internal pure returns (Booly)\r\n    {\r\n        if (a == DEFINITELY || b == DEFINITELY) return DEFINITELY;\r\n        else if (a == PROBABLY || b == PROBABLY) return PROBABLY;\r\n        else if (a == UNKNOWN || b == UNKNOWN) return UNKNOWN;\r\n        else if (a == PROBABLY_NOT || b == PROBABLY_NOT) return PROBABLY_NOT;\r\n        else if (a == DEFINITELY_NOT && b == DEFINITELY_NOT) return DEFINITELY_NOT;\r\n        else revert();\r\n    }\r\n    \r\n    function NOT(Booly a) internal pure returns (Booly)\r\n    {\r\n        if (a == DEFINITELY_NOT) return DEFINITELY;\r\n        else if (a == PROBABLY_NOT) return PROBABLY;\r\n        else if (a == UNKNOWN) return UNKNOWN;\r\n        else if (a == PROBABLY) return PROBABLY_NOT;\r\n        else if (a == DEFINITELY) return DEFINITELY_NOT;\r\n        else revert();\r\n    }\r\n    \r\n    function AND(Booly a, Booly b) internal pure returns (Booly)\r\n    {\r\n        if (a == DEFINITELY_NOT || b == DEFINITELY_NOT) return DEFINITELY_NOT;\r\n        else if (a == PROBABLY_NOT || b == PROBABLY_NOT) return PROBABLY_NOT;\r\n        else if (a == UNKNOWN || b == UNKNOWN) return UNKNOWN;\r\n        else if (a == PROBABLY || b == PROBABLY) return PROBABLY;\r\n        else if (a == DEFINITELY && b == DEFINITELY) return DEFINITELY;\r\n        else revert();\r\n    }\r\n    \r\n    function AND(Booly a, bool b) internal pure returns (Booly)\r\n    {\r\n        if (b == true) return a;\r\n        else return DEFINITELY_NOT;\r\n    }\r\n    \r\n    function XOR(Booly a, Booly b) internal pure returns (Booly)\r\n    {\r\n        return AND(OR(a, b), NOT(AND(a, b)));\r\n    }\r\n    \r\n    function NAND(Booly a, Booly b) internal pure returns (Booly)\r\n    {\r\n        return NOT(AND(a, b));\r\n    }\r\n    \r\n    function NOR(Booly a, Booly b) internal pure returns (Booly)\r\n    {\r\n        return NOT(OR(a, b));\r\n    }\r\n    \r\n    function XNOR(Booly a, Booly b) internal pure returns (Booly)\r\n    {\r\n        return NOT(XOR(a, b));\r\n    }\r\n    \r\n    function AND_F(function(uint256)view returns(Booly) aFunc, function(uint256)view returns(Booly) bFunc, uint256 _arg) internal view returns (Booly)\r\n    {\r\n        Booly a = aFunc(_arg);\r\n        if (a == DEFINITELY_NOT) return DEFINITELY_NOT;\r\n        else\r\n        {\r\n            Booly b = bFunc(_arg);\r\n            if (b == DEFINITELY_NOT) return DEFINITELY_NOT;\r\n            else if (a == PROBABLY_NOT) return PROBABLY_NOT;\r\n            else if (b == PROBABLY_NOT) return PROBABLY_NOT;\r\n            else if (a == UNKNOWN || b == UNKNOWN) return UNKNOWN;\r\n            else if (a == PROBABLY || b == PROBABLY) return PROBABLY;\r\n            else if (a == DEFINITELY && b == DEFINITELY) return DEFINITELY;\r\n            else revert();\r\n        }\r\n    }\r\n    \r\n    function OR_F(function(uint256)view returns(Booly) aFunc, function(uint256)view returns(Booly) bFunc, uint256 _arg) internal view returns (Booly)\r\n    {\r\n        Booly a = aFunc(_arg);\r\n        if (a == DEFINITELY) return DEFINITELY;\r\n        else\r\n        {\r\n            Booly b = bFunc(_arg);\r\n            if (b == DEFINITELY) return DEFINITELY;\r\n            else if (a == PROBABLY || b == PROBABLY) return PROBABLY;\r\n            else if (a == UNKNOWN || b == UNKNOWN) return UNKNOWN;\r\n            else if (a == PROBABLY_NOT || b == PROBABLY_NOT) return PROBABLY_NOT;\r\n            else if (a == DEFINITELY_NOT && b == DEFINITELY_NOT) return DEFINITELY_NOT;\r\n            else revert();\r\n        }\r\n    }\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    ////////////////////////////////////////////////////////////\r\n    ////////////////////////////////////////////////////////////\r\n    ////////////                                    ////////////\r\n    ////////////           Trading stuff            ////////////\r\n    ////////////                                    ////////////\r\n    ////////////////////////////////////////////////////////////\r\n    ////////////////////////////////////////////////////////////\r\n    \r\n    // depositEther() should only be called at the start of 'external payable' functions.\r\n    function depositEther() public payable\r\n    {\r\n        addressToEtherBalance[msg.sender] += msg.value;\r\n        \r\n        emit EtherDeposited(msg.sender, msg.value);\r\n    }\r\n    \r\n    function withdrawEther(uint256 _amount) public\r\n    {\r\n        require(addressToEtherBalance[msg.sender] >= _amount, \"withdrawEther error: insufficient balance to withdraw that much ether\");\r\n        addressToEtherBalance[msg.sender] -= _amount;\r\n        msg.sender.transfer(_amount);\r\n        \r\n        emit EtherWithdrawn(msg.sender, _amount);\r\n    }\r\n    \r\n    struct BuyOrder\r\n    {\r\n        address buyer;\r\n        uint256 bid;\r\n    }\r\n    \r\n    function depositEtherAndCreateBuyOrder(uint256 _prime, uint256 _bid, uint256 _indexHint) external payable\r\n    {\r\n        depositEther();\r\n        \r\n        require(_bid > 0, \"createBuyOrder error: bid must be greater than 0\");\r\n        require(_prime >= 2, \"createBuyOrder error: prime must be greater than or equal to 2\");\r\n        \r\n        BuyOrder[] storage buyOrders = primeToBuyOrders[_prime];\r\n\r\n        uint256 _index;\r\n        \r\n        if (_indexHint == buyOrders.length)\r\n        {\r\n            _index = _indexHint;\r\n        }\r\n        else if (_indexHint < buyOrders.length &&\r\n                 buyOrders[_indexHint].buyer == address(0x0) &&\r\n                 buyOrders[_indexHint].bid == 0)\r\n        {\r\n            _index = _indexHint;\r\n        }\r\n        else\r\n        {\r\n            _index = findFreeBuyOrderSlot(_prime);\r\n        }\r\n        \r\n        if (_index == buyOrders.length)\r\n        {\r\n            buyOrders.length++;\r\n        }\r\n        \r\n        BuyOrder storage buyOrder = buyOrders[_index];\r\n        \r\n        buyOrder.buyer = msg.sender;\r\n        buyOrder.bid = _bid;\r\n        \r\n        emit BuyOrderCreated(msg.sender, _prime, _index, _bid);\r\n        \r\n        tryMatchSellAndBuyOrdersRange(_prime, _index, _index);\r\n    }\r\n    \r\n    function modifyBuyOrder(uint256 _prime, uint256 _index, uint256 _newBid) external\r\n    {\r\n        BuyOrder[] storage buyOrders = primeToBuyOrders[_prime];\r\n        require(_index < buyOrders.length, \"modifyBuyOrder error: index out of bounds\");\r\n        \r\n        BuyOrder storage buyOrder = buyOrders[_index];\r\n        require(buyOrder.buyer == msg.sender, \"modifyBuyOrder error: you do not own that buy order\");\r\n        \r\n        emit BuyOrderDestroyed(msg.sender, _prime, _index);\r\n        \r\n        buyOrder.bid = _newBid;\r\n        \r\n        emit BuyOrderCreated(msg.sender, _prime, _index, _newBid);\r\n    }\r\n    \r\n\r\n    function tryCancelBuyOrders(uint256[] memory _primes, uint256[] memory _buyOrderIndices) public returns (uint256 _amountCancelled)\r\n    {\r\n        require(_primes.length == _buyOrderIndices.length, \"tryCancelBuyOrders error: invalid input, arrays are not the same length\");\r\n        \r\n        _amountCancelled = 0;\r\n        \r\n        for (uint256 i=0; i<_primes.length; i++)\r\n        {\r\n            uint256 index = _buyOrderIndices[i];\r\n            uint256 prime = _primes[i];\r\n            \r\n            BuyOrder[] storage buyOrders = primeToBuyOrders[prime];\r\n            if (index < buyOrders.length)\r\n            {\r\n                BuyOrder storage buyOrder = buyOrders[index];\r\n                if (buyOrder.buyer == msg.sender)\r\n                {\r\n                    emit BuyOrderDestroyed(msg.sender, prime, index);\r\n                    \r\n                    buyOrder.buyer = address(0x0);\r\n                    buyOrder.bid = 0;\r\n                    \r\n                    _amountCancelled++;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    function setSellPrice(uint256 _prime, uint256 _price, uint256 _matchStartBuyOrderIndex, uint256 _matchEndBuyOrderIndex) external returns (bool _sold)\r\n    {\r\n        require(isApprovedFor(msg.sender, _prime), \"createSellOrder error: you do not have ownership of or approval for that prime\");\r\n        \r\n        primeToSellOrderPrice[_prime] = _price;\r\n        \r\n        emit SellPriceSet(msg.sender, _prime, _price);\r\n        \r\n        if (_matchStartBuyOrderIndex != ~uint256(0))\r\n        {\r\n            return tryMatchSellAndBuyOrdersRange(_prime, _matchStartBuyOrderIndex, _matchEndBuyOrderIndex);\r\n        }\r\n        else\r\n        {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function tryMatchSellAndBuyOrdersRange(uint256 _prime, uint256 _startBuyOrderIndex, uint256 _endBuyOrderIndex) public returns (bool _sold)\r\n    {\r\n        uint256 sellOrderPrice = primeToSellOrderPrice[_prime];\r\n        address seller = getOwner(_prime);\r\n        \r\n        if (sellOrderPrice == 0 ||\r\n            seller == address(0x0))\r\n        {\r\n            return false;\r\n        }\r\n        else\r\n        {\r\n            BuyOrder[] storage buyOrders = primeToBuyOrders[_prime];\r\n            \r\n            uint256 buyOrders_length = buyOrders.length;\r\n\r\n            if (_startBuyOrderIndex > _endBuyOrderIndex ||\r\n                _endBuyOrderIndex >= buyOrders.length)\r\n            {\r\n                return false;\r\n            }\r\n            else\r\n            {\r\n                for (uint256 i=_startBuyOrderIndex; i<=_endBuyOrderIndex && i<buyOrders_length; i++)\r\n                {\r\n                    BuyOrder storage buyOrder = buyOrders[i];\r\n                    address buyer = buyOrder.buyer;\r\n                    uint256 bid = buyOrder.bid;\r\n                    \r\n                    if (bid >= sellOrderPrice &&\r\n                        addressToEtherBalance[buyer] >= bid)\r\n                    {\r\n                        addressToEtherBalance[buyer] -= bid;\r\n                        addressToEtherBalance[seller] += bid;\r\n                        \r\n                        _setOwner(_prime, buyer); // _setOwner sets primeToSellOrderPrice[_prime] = 0\r\n                        \r\n                        emit BuyOrderDestroyed(buyer, _prime, i);\r\n                        emit PrimeTraded(seller, buyer, _prime, i, bid);\r\n                        \r\n                        buyOrder.buyer = address(0x0);\r\n                        buyOrder.bid = 0;\r\n                        return true;\r\n                    }\r\n                }\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    ////////////////////////////////////////////////////////////\r\n    ////////////////////////////////////////////////////////////\r\n    ////////////                                    ////////////\r\n    ////////////       Trading view functions       ////////////\r\n    ////////////                                    ////////////\r\n    ////////////////////////////////////////////////////////////\r\n    ////////////////////////////////////////////////////////////\r\n    \r\n    function countPrimeBuyOrders(uint256 _prime) external view returns (uint256 _amountOfBuyOrders)\r\n    {\r\n        _amountOfBuyOrders = 0;\r\n        \r\n        BuyOrder[] storage buyOrders = primeToBuyOrders[_prime];\r\n        for (uint256 i=0; i<buyOrders.length; i++)\r\n        {\r\n            if (buyOrders[i].buyer != address(0x0))\r\n            {\r\n                _amountOfBuyOrders++;\r\n            }\r\n        }\r\n    }\r\n    \r\n    function lengthOfPrimeBuyOrdersArray(uint256 _prime) external view returns (uint256 _lengthOfPrimeBuyOrdersArray)\r\n    {\r\n        return primeToBuyOrders[_prime].length;\r\n    }\r\n    \r\n    function getPrimeBuyOrder(uint256 _prime, uint256 _index) external view returns (address _buyer, uint256 _bid, bool _buyerHasEnoughFunds)\r\n    {\r\n       BuyOrder storage buyOrder = primeToBuyOrders[_prime][_index];\r\n       \r\n       _buyer = buyOrder.buyer;\r\n       _bid = buyOrder.bid;\r\n       \r\n       require(_buyer != address(0x0) && _bid != 0);\r\n       \r\n       _buyerHasEnoughFunds = addressToEtherBalance[_buyer] >= _bid;\r\n    }\r\n    \r\n    function findFreeBuyOrderSlot(uint256 _prime) public view returns (uint256 _buyOrderSlotIndex)\r\n    {\r\n        BuyOrder[] storage buyOrders = primeToBuyOrders[_prime];\r\n        uint256 len = buyOrders.length;\r\n        \r\n        for (uint256 i=0; i<len; i++)\r\n        {\r\n            if (buyOrders[i].buyer == address(0x0) &&\r\n                buyOrders[i].bid == 0)\r\n            {\r\n                return i;\r\n            }\r\n        }\r\n        \r\n        return len;\r\n    }  \r\n\r\n    function findHighestBidBuyOrder(uint256 _prime) public view returns (bool _found, uint256 _buyOrderIndex, address _buyer, uint256 _bid)\r\n    {\r\n        BuyOrder[] storage buyOrders = primeToBuyOrders[_prime];\r\n        uint256 highestBidBuyOrderIndexFound = 0;\r\n        uint256 highestBidFound = 0;\r\n        address highestBidAddress = address(0x0);\r\n        for (uint256 i=0; i<buyOrders.length; i++)\r\n        {\r\n            BuyOrder storage buyOrder = buyOrders[i];\r\n            if (buyOrder.bid > highestBidFound &&\r\n                addressToEtherBalance[buyOrder.buyer] >= buyOrder.bid)\r\n            {\r\n                highestBidBuyOrderIndexFound = i;\r\n                highestBidFound = buyOrder.bid;\r\n                highestBidAddress = buyOrder.buyer;\r\n            }\r\n        }\r\n        if (highestBidFound == 0)\r\n        {\r\n            return (false, 0, address(0x0), 0);\r\n        }\r\n        else\r\n        {\r\n            return (true, highestBidBuyOrderIndexFound, highestBidAddress, highestBidFound);\r\n        }\r\n    }\r\n    \r\n    function findBuyOrdersOfUserOnPrime(address _user, uint256 _prime) external view returns (uint256[] memory _buyOrderIndices, uint256[] memory _bids)\r\n    {\r\n        BuyOrder[] storage buyOrders = primeToBuyOrders[_prime];\r\n        \r\n        _buyOrderIndices = new uint256[](buyOrders.length);\r\n        _bids = new uint256[](buyOrders.length);\r\n        \r\n        uint256 amountOfBuyOrdersFound = 0;\r\n\r\n        for (uint256 i=0; i<buyOrders.length; i++)\r\n        {\r\n            BuyOrder storage buyOrder = buyOrders[i];\r\n            if (buyOrder.buyer == _user)\r\n            {\r\n                _buyOrderIndices[amountOfBuyOrdersFound] = i;\r\n                _bids[amountOfBuyOrdersFound] = buyOrder.bid;\r\n                amountOfBuyOrdersFound++;\r\n            }\r\n        }\r\n        \r\n        assembly\r\n        {\r\n            // _buyOrderIndices.length = amountOfBuyOrdersFound;\r\n            mstore(_buyOrderIndices, amountOfBuyOrdersFound)\r\n            \r\n            // _bids.length = amountOfBuyOrdersFound;\r\n            mstore(_bids, amountOfBuyOrdersFound)\r\n        }\r\n    }\r\n    \r\n    function findBuyOrdersOnUsersPrimes(address _user) external view returns (uint256[] memory _primes, uint256[] memory _buyOrderIndices, address[] memory _buyers, uint256[] memory _bids, bool[] memory _buyersHaveEnoughFunds)\r\n    {\r\n        uint256[] storage userPrimes = ownerToPrimes[_user];\r\n        \r\n        _primes = new uint256[](userPrimes.length);\r\n        _buyOrderIndices = new uint256[](userPrimes.length);\r\n        _buyers = new address[](userPrimes.length);\r\n        _bids = new uint256[](userPrimes.length);\r\n        _buyersHaveEnoughFunds = new bool[](userPrimes.length);\r\n        \r\n        uint256 amountOfBuyOrdersFound = 0;\r\n\r\n        for (uint256 i=0; i<userPrimes.length; i++)\r\n        {\r\n            uint256 prime = userPrimes[i];\r\n            \r\n            bool found; uint256 buyOrderIndex; address buyer; uint256 bid;\r\n            (found, buyOrderIndex, buyer, bid) = findHighestBidBuyOrder(prime);\r\n            \r\n            if (found == true)\r\n            {\r\n                _primes[amountOfBuyOrdersFound] = prime;\r\n                _buyers[amountOfBuyOrdersFound] = buyer;\r\n                _buyOrderIndices[amountOfBuyOrdersFound] = buyOrderIndex;\r\n                _bids[amountOfBuyOrdersFound] = bid;\r\n                _buyersHaveEnoughFunds[amountOfBuyOrdersFound] = addressToEtherBalance[buyer] >= bid;\r\n                amountOfBuyOrdersFound++;\r\n            }\r\n        }\r\n        \r\n        assembly\r\n        {\r\n            // _primes.length = amountOfBuyOrdersFound;\r\n            mstore(_primes, amountOfBuyOrdersFound)\r\n            \r\n            // _buyOrderIndices.length = amountOfBuyOrdersFound;\r\n            mstore(_buyOrderIndices, amountOfBuyOrdersFound)\r\n            \r\n            // _buyers.length = amountOfBuyOrdersFound;\r\n            mstore(_buyers, amountOfBuyOrdersFound)\r\n            \r\n            // _bids.length = amountOfBuyOrdersFound;\r\n            mstore(_bids, amountOfBuyOrdersFound)\r\n            \r\n            // _buyersHaveEnoughFunds.length = amountOfBuyOrdersFound;\r\n            mstore(_buyersHaveEnoughFunds, amountOfBuyOrdersFound)\r\n        }\r\n    }\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    ////////////////////////////////////////////////////////////\r\n    ////////////////////////////////////////////////////////////\r\n    ////////////                                    ////////////\r\n    ////////////   Trading convenience functions    ////////////\r\n    ////////////                                    ////////////\r\n    ////////////////////////////////////////////////////////////\r\n    ////////////////////////////////////////////////////////////\r\n    \r\n    // These functions don't directly modify state variables.\r\n    // They only serve as a wrapper for other functions.\r\n    // They do not introduce new state transitions.\r\n    \r\n    /*function withdrawAllEther() external\r\n    {\r\n        withdrawEther(addressToEtherBalance[msg.sender]);\r\n    }*/\r\n    \r\n    /*function cancelBuyOrders(uint256[] calldata _primes, uint256[] calldata _buyOrderIndices) external\r\n    {\r\n        require(tryCancelBuyOrders(_primes, _buyOrderIndices) == _primes.length, \"cancelBuyOrders error: not all buy orders could be cancelled\");\r\n    }*/\r\n    \r\n    function tryCancelBuyOrdersAndWithdrawEther(uint256[] calldata _primes, uint256[] calldata _buyOrderIndices, uint256 _amountToWithdraw) external returns (uint256 _amountCancelled)\r\n    {\r\n        withdrawEther(_amountToWithdraw);\r\n        return tryCancelBuyOrders(_primes, _buyOrderIndices);\r\n    }\r\n}\r\n\r\ncontract EtherPrimeChat\r\n{\r\n    EtherPrime etherPrime;\r\n    \r\n    constructor(EtherPrime _etherPrime) public\r\n    {\r\n        etherPrime = _etherPrime;\r\n    }\r\n    \r\n    // Social\r\n    mapping(address => bytes32) public addressToUsername;\r\n    mapping(bytes32 => address) public usernameToAddress;\r\n    mapping(address => uint256) public addressToGasUsedTowardsChatMessage;\r\n    uint256 public constant GAS_PER_CHAT_MESSAGE = 1000000;\r\n    address[] public chatMessageSenders;\r\n    uint256[] public chatMessageReplyToIndices;\r\n    string[] public chatMessages;\r\n    \r\n    event UsernameSet(address user, bytes32 username);\r\n    event ChatMessageSent(address indexed sender, uint256 indexed index, uint256 indexed replyToIndex);\r\n    \r\n    function setUsername(bytes32 _username) external\r\n    {\r\n        require(_username[0] != 0x00);\r\n        \r\n        bool seen0x00 = false;\r\n        for (uint256 i=0; i<32; i++)\r\n        {\r\n            if (_username[i] == 0x00)\r\n            {\r\n                seen0x00 = true;\r\n            }\r\n            \r\n            // If there's a non-0x00 after an 0x00, this is not a valid string.\r\n            else if (seen0x00)\r\n            {\r\n                revert(\"setUsername error: invalid string; character present after null terminator\");\r\n            }\r\n        }\r\n        \r\n        require(usernameToAddress[_username] == address(0x0), \"setUsername error: that username already exists\");\r\n        \r\n        usernameToAddress[_username] = msg.sender;\r\n        addressToUsername[msg.sender] = _username;\r\n        \r\n        emit UsernameSet(msg.sender, _username);\r\n    }\r\n    \r\n    function amountOfChatMessages() external view returns (uint256)\r\n    {\r\n        return chatMessages.length;\r\n    }\r\n    \r\n    function getChatMessage(uint256 _index) external view returns (address _sender, string memory _message, uint256 _replyToIndex)\r\n    {\r\n        require(_index < chatMessages.length, \"getChatMessage error: index out of bounds\");\r\n        \r\n        _sender = chatMessageSenders[_index];\r\n        _message = chatMessages[_index];\r\n        _replyToIndex = chatMessageReplyToIndices[_replyToIndex];\r\n    }\r\n    \r\n    function sendChatMessage(string calldata _message, uint256 _replyToIndex) external\r\n    {\r\n        require(etherPrime.addressToGasSpent(msg.sender) - addressToGasUsedTowardsChatMessage[msg.sender] >= GAS_PER_CHAT_MESSAGE, \"sendChatMessage error: you need to spend more gas on compute() to send a chat message\");\r\n        require(_replyToIndex == ~uint256(0) || _replyToIndex < chatMessages.length, \"sendChatMessage error: invalid reply index\");\r\n        \r\n        addressToGasUsedTowardsChatMessage[msg.sender] += GAS_PER_CHAT_MESSAGE;\r\n        \r\n        emit ChatMessageSent(msg.sender, chatMessages.length, _replyToIndex);\r\n        \r\n        chatMessageReplyToIndices.push(_replyToIndex);\r\n        chatMessageSenders.push(msg.sender);\r\n        chatMessages.push(_message);\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"bytes\"},{\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"tokensReceived\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_prime\",\"type\":\"uint256\"},{\"name\":\"_index\",\"type\":\"uint256\"},{\"name\":\"_newBid\",\"type\":\"uint256\"}],\"name\":\"modifyBuyOrder\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_interfaceID\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_prime\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_prime\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"UNKNOWN\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"findBuyOrdersOnUsersPrimes\",\"outputs\":[{\"name\":\"_primes\",\"type\":\"uint256[]\"},{\"name\":\"_buyOrderIndices\",\"type\":\"uint256[]\"},{\"name\":\"_buyers\",\"type\":\"address[]\"},{\"name\":\"_bids\",\"type\":\"uint256[]\"},{\"name\":\"_buyersHaveEnoughFunds\",\"type\":\"bool[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"implementsERC721\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC721Received\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"compute\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_prime\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_prime\",\"type\":\"uint256\"}],\"name\":\"findHighestBidBuyOrder\",\"outputs\":[{\"name\":\"_found\",\"type\":\"bool\"},{\"name\":\"_buyOrderIndex\",\"type\":\"uint256\"},{\"name\":\"_buyer\",\"type\":\"address\"},{\"name\":\"_bid\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"DEFINITELY_NOT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_number\",\"type\":\"uint256\"}],\"name\":\"isGoodPrime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_number\",\"type\":\"uint256\"}],\"name\":\"isCullenPrime\",\"outputs\":[{\"name\":\"_result\",\"type\":\"uint8\"},{\"name\":\"_n\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"tokenOfOwnerByIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"PROBABLY\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"addressPrimeCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"participants\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdrawEther\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_prime\",\"type\":\"uint256\"}],\"name\":\"isBalancedPrime\",\"outputs\":[{\"name\":\"result\",\"type\":\"uint8\"},{\"name\":\"lowerPrime\",\"type\":\"uint256\"},{\"name\":\"higherPrime\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"divisorIndexBeingTested\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_recipient\",\"type\":\"address\"}],\"name\":\"computeAndGiveTo\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_number\",\"type\":\"uint256\"}],\"name\":\"isPrime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_prime\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_primes\",\"type\":\"uint256[]\"},{\"name\":\"_buyOrderIndices\",\"type\":\"uint256[]\"},{\"name\":\"_amountToWithdraw\",\"type\":\"uint256\"}],\"name\":\"tryCancelBuyOrdersAndWithdrawEther\",\"outputs\":[{\"name\":\"_amountCancelled\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_number\",\"type\":\"uint256\"}],\"name\":\"numberToDivisor\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_start\",\"type\":\"uint256\"},{\"name\":\"_end\",\"type\":\"uint256\"}],\"name\":\"claimProbablePrimeInRange\",\"outputs\":[{\"name\":\"_success\",\"type\":\"bool\"},{\"name\":\"_prime\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"tokenByIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_prime\",\"type\":\"uint256\"},{\"name\":\"_divisor\",\"type\":\"uint256\"}],\"name\":\"disproveProbablePrime\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_number\",\"type\":\"uint256\"}],\"name\":\"isPrime_probabilistic\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"tokensOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"addressToEtherBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_prime\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_prime\",\"type\":\"uint256\"}],\"name\":\"findFreeBuyOrderSlot\",\"outputs\":[{\"name\":\"_buyOrderSlotIndex\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_number\",\"type\":\"uint256\"}],\"name\":\"getPrimeFactors\",\"outputs\":[{\"name\":\"_success\",\"type\":\"bool\"},{\"name\":\"_primeFactors\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"amountOfProbablePrimesFound\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_primes\",\"type\":\"uint256[]\"},{\"name\":\"_buyOrderIndices\",\"type\":\"uint256[]\"}],\"name\":\"tryCancelBuyOrders\",\"outputs\":[{\"name\":\"_amountCancelled\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_prime\",\"type\":\"uint256\"},{\"name\":\"_price\",\"type\":\"uint256\"},{\"name\":\"_matchStartBuyOrderIndex\",\"type\":\"uint256\"},{\"name\":\"_matchEndBuyOrderIndex\",\"type\":\"uint256\"}],\"name\":\"setSellPrice\",\"outputs\":[{\"name\":\"_sold\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_number\",\"type\":\"uint256\"}],\"name\":\"tryClaimProbablePrime\",\"outputs\":[{\"name\":\"_success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getInsecureRandomProbablePrime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_primesToMemorize\",\"type\":\"uint256\"},{\"name\":\"_lowLevelGas\",\"type\":\"uint256\"}],\"name\":\"computeWithPrimesToMemorizeAndLowLevelGas\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"addressToGasSpent\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"primeToSellOrderPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"addressToProbablePrimesClaimed\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"definitePrimes\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_number\",\"type\":\"uint256\"}],\"name\":\"isFactorialPrime\",\"outputs\":[{\"name\":\"_result\",\"type\":\"uint8\"},{\"name\":\"_n\",\"type\":\"uint256\"},{\"name\":\"_delta\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"largestDefinitePrimeFound\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_prime\",\"type\":\"uint256\"}],\"name\":\"countPrimeBuyOrders\",\"outputs\":[{\"name\":\"_amountOfBuyOrders\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_number\",\"type\":\"uint256\"}],\"name\":\"isFibonacciPrime\",\"outputs\":[{\"name\":\"_result\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_primesToMemorize\",\"type\":\"uint256\"}],\"name\":\"computeWithPrimesToMemorize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"addressToProbablePrimesDisprovenFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"DEFINITELY\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_number\",\"type\":\"uint256\"}],\"name\":\"isFibonacciNumber\",\"outputs\":[{\"name\":\"_result\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_user\",\"type\":\"address\"},{\"name\":\"_prime\",\"type\":\"uint256\"}],\"name\":\"findBuyOrdersOfUserOnPrime\",\"outputs\":[{\"name\":\"_buyOrderIndices\",\"type\":\"uint256[]\"},{\"name\":\"_bids\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"amountOfPrimesOwnedByOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"depositEther\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"numberBeingTested\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_operator\",\"type\":\"address\"},{\"name\":\"_allowed\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_prime\",\"type\":\"uint256\"},{\"name\":\"_startBuyOrderIndex\",\"type\":\"uint256\"},{\"name\":\"_endBuyOrderIndex\",\"type\":\"uint256\"}],\"name\":\"tryMatchSellAndBuyOrdersRange\",\"outputs\":[{\"name\":\"_sold\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_prime\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_primesToMemorize\",\"type\":\"uint256\"},{\"name\":\"_lowLevelGas\",\"type\":\"uint256\"},{\"name\":\"_recipient\",\"type\":\"address\"}],\"name\":\"computeWithParams\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_prime\",\"type\":\"uint256\"}],\"name\":\"lengthOfPrimeBuyOrdersArray\",\"outputs\":[{\"name\":\"_lengthOfPrimeBuyOrdersArray\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"primeToAllowedAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_prime\",\"type\":\"uint256\"}],\"name\":\"takeOwnership\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_prime\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_number\",\"type\":\"uint256\"}],\"name\":\"claimProbablePrime\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_prime\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"ok\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"amountOfPrimesFound\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"tokenFallback\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_prime\",\"type\":\"uint256\"}],\"name\":\"getOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"addressToEtherSpent\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"name\":\"_uri\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"amountOfDefinitePrimesFound\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_number\",\"type\":\"uint256\"}],\"name\":\"isSuperPrime\",\"outputs\":[{\"name\":\"_result\",\"type\":\"uint8\"},{\"name\":\"_indexStartAtOne\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_number\",\"type\":\"uint256\"}],\"name\":\"isFermatPrime\",\"outputs\":[{\"name\":\"result\",\"type\":\"uint8\"},{\"name\":\"_2_pow_n\",\"type\":\"uint256\"},{\"name\":\"_n\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"probablePrimes\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"PROBABLY_NOT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"amountOfParticipants\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_prime\",\"type\":\"uint256\"},{\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"getPrimeBuyOrder\",\"outputs\":[{\"name\":\"_buyer\",\"type\":\"address\"},{\"name\":\"_bid\",\"type\":\"uint256\"},{\"name\":\"_buyerHasEnoughFunds\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"addressToProbablePrimesDisprovenBy\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_prime\",\"type\":\"uint256\"},{\"name\":\"_bid\",\"type\":\"uint256\"},{\"name\":\"_indexHint\",\"type\":\"uint256\"}],\"name\":\"depositEtherAndCreateBuyOrder\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_number\",\"type\":\"uint256\"},{\"name\":\"_n\",\"type\":\"uint256\"}],\"name\":\"isNTupleMersennePrime\",\"outputs\":[{\"name\":\"_result\",\"type\":\"uint8\"},{\"name\":\"_powers\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getInsecureRandomDefinitePrime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"prime\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"discoverer\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"definitePrimesArrayIndex\",\"type\":\"uint256\"}],\"name\":\"DefinitePrimeDiscovered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"prime\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"discoverer\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"probablePrimesArrayIndex\",\"type\":\"uint256\"}],\"name\":\"ProbablePrimeDiscovered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"prime\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"divisor\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"disprover\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"probablePrimesArrayIndex\",\"type\":\"uint256\"}],\"name\":\"ProbablePrimeDisproven\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"prime\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"prime\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"prime\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"buyOrdersArrayIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"bid\",\"type\":\"uint256\"}],\"name\":\"BuyOrderCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"prime\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"buyOrdersArrayIndex\",\"type\":\"uint256\"}],\"name\":\"BuyOrderDestroyed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"seller\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"prime\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"SellPriceSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"seller\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"prime\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"buyOrdersArrayIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"PrimeTraded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"depositer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"EtherDeposited\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"withdrawer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"EtherWithdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"Transfer\",\"type\":\"event\"}]","ContractName":"EtherPrime","CompilerVersion":"v0.5.4+commit.9549d8ff","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://ae8276540fd97545f69678da3f2ef940e2a21829dfce1520ab923f900ea2a065"}]}