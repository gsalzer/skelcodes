{"status":"1","message":"OK","result":[{"SourceCode":"/**\r\n *  The Consumer Contract Wallet\r\n *  Copyright (C) 2018 The Contract Wallet Company Limited\r\n *\r\n *  This program is free software: you can redistribute it and/or modify\r\n *  it under the terms of the GNU General Public License as published by\r\n *  the Free Software Foundation, either version 3 of the License, or\r\n *  (at your option) any later version.\r\n\r\n *  This program is distributed in the hope that it will be useful,\r\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n *  GNU General Public License for more details.\r\n\r\n *  You should have received a copy of the GNU General Public License\r\n *  along with this program.  If not, see <https://www.gnu.org/licenses/>.\r\n */\r\n\r\npragma solidity ^0.4.25;\r\n\r\n/// @title The Controller interface provides access to an external list of controllers.\r\ninterface IController {\r\n    function isController(address) external view returns (bool);\r\n}\r\n\r\n/// @title Controller stores a list of controller addresses that can be used for authentication in other contracts.\r\ncontract Controller is IController {\r\n    event AddedController(address _sender, address _controller);\r\n    event RemovedController(address _sender, address _controller);\r\n\r\n    mapping (address => bool) private _isController;\r\n    uint private _controllerCount;\r\n\r\n    /// @dev Constructor initializes the list of controllers with the provided address.\r\n    /// @param _account address to add to the list of controllers.\r\n    constructor(address _account) public {\r\n        _addController(_account);\r\n    }\r\n\r\n    /// @dev Checks if message sender is a controller.\r\n    modifier onlyController() {\r\n        require(isController(msg.sender), \"sender is not a controller\");\r\n        _;\r\n    }\r\n\r\n    /// @dev Add a new controller to the list of controllers.\r\n    /// @param _account address to add to the list of controllers.\r\n    function addController(address _account) external onlyController {\r\n        _addController(_account);\r\n    }\r\n\r\n    /// @dev Remove a controller from the list of controllers.\r\n    /// @param _account address to remove from the list of controllers.\r\n    function removeController(address _account) external onlyController {\r\n        _removeController(_account);\r\n    }\r\n\r\n    /// @return true if the provided account is a controller.\r\n    function isController(address _account) public view returns (bool) {\r\n        return _isController[_account];\r\n    }\r\n\r\n    /// @return the current number of controllers.\r\n    function controllerCount() public view returns (uint) {\r\n        return _controllerCount;\r\n    }\r\n\r\n    /// @dev Internal-only function that adds a new controller.\r\n    function _addController(address _account) internal {\r\n        require(!_isController[_account], \"provided account is already a controller\");\r\n        _isController[_account] = true;\r\n        _controllerCount++;\r\n        emit AddedController(msg.sender, _account);\r\n    }\r\n\r\n    /// @dev Internal-only function that removes an existing controller.\r\n    function _removeController(address _account) internal {\r\n        require(_isController[_account], \"provided account is not a controller\");\r\n        require(_controllerCount > 1, \"cannot remove the last controller\");\r\n        _isController[_account] = false;\r\n        _controllerCount--;\r\n        emit RemovedController(msg.sender, _account);\r\n    }\r\n}\r\n\r\n/**\r\n * BSD 2-Clause License\r\n *\r\n * Copyright (c) 2018, True Names Limited\r\n * All rights reserved.\r\n *\r\n * Redistribution and use in source and binary forms, with or without\r\n * modification, are permitted provided that the following conditions are met:\r\n *\r\n * * Redistributions of source code must retain the above copyright notice, this\r\n *   list of conditions and the following disclaimer.\r\n *\r\n * * Redistributions in binary form must reproduce the above copyright notice,\r\n *   this list of conditions and the following disclaimer in the documentation\r\n *   and/or other materials provided with the distribution.\r\n *\r\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\r\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\r\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\r\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\r\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\r\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\r\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\r\n * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\r\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\r\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n*/\r\n\r\ninterface ENS {\r\n\r\n    // Logged when the owner of a node assigns a new owner to a subnode.\r\n    event NewOwner(bytes32 indexed node, bytes32 indexed label, address owner);\r\n\r\n    // Logged when the owner of a node transfers ownership to a new account.\r\n    event Transfer(bytes32 indexed node, address owner);\r\n\r\n    // Logged when the resolver for a node changes.\r\n    event NewResolver(bytes32 indexed node, address resolver);\r\n\r\n    // Logged when the TTL of a node changes\r\n    event NewTTL(bytes32 indexed node, uint64 ttl);\r\n\r\n\r\n    function setSubnodeOwner(bytes32 node, bytes32 label, address owner) public;\r\n    function setResolver(bytes32 node, address resolver) public;\r\n    function setOwner(bytes32 node, address owner) public;\r\n    function setTTL(bytes32 node, uint64 ttl) public;\r\n    function owner(bytes32 node) public view returns (address);\r\n    function resolver(bytes32 node) public view returns (address);\r\n    function ttl(bytes32 node) public view returns (uint64);\r\n\r\n}\r\n\r\n/// @title Resolver returns the controller contract address.\r\ninterface IResolver {\r\n    function addr(bytes32) external view returns (address);\r\n}\r\n\r\n/// @title Controllable implements access control functionality based on a controller set in ENS.\r\ncontract Controllable {\r\n    /// @dev _ENS points to the ENS registry smart contract.\r\n    ENS private _ENS;\r\n    /// @dev Is the registered ENS name of the controller contract.\r\n    bytes32 private _node;\r\n\r\n    /// @dev Constructor initializes the controller contract object.\r\n    /// @param _ens is the address of the ENS.\r\n    /// @param _controllerName is the ENS name of the Controller.\r\n    constructor(address _ens, bytes32 _controllerName) internal {\r\n      _ENS = ENS(_ens);\r\n      _node = _controllerName;\r\n    }\r\n\r\n    /// @dev Checks if message sender is the controller.\r\n    modifier onlyController() {\r\n        require(_isController(msg.sender), \"sender is not a controller\");\r\n        _;\r\n    }\r\n\r\n    /// @return true if the provided account is the controller.\r\n    function _isController(address _account) internal view returns (bool) {\r\n        return IController(IResolver(_ENS.resolver(_node)).addr(_node)).isController(_account);\r\n    }\r\n}\r\n\r\n/// @title Date provides date parsing functionality.\r\ncontract Date {\r\n\r\n    bytes32 constant private JANUARY = keccak256(\"Jan\");\r\n    bytes32 constant private FEBRUARY = keccak256(\"Feb\");\r\n    bytes32 constant private MARCH = keccak256(\"Mar\");\r\n    bytes32 constant private APRIL = keccak256(\"Apr\");\r\n    bytes32 constant private MAY = keccak256(\"May\");\r\n    bytes32 constant private JUNE = keccak256(\"Jun\");\r\n    bytes32 constant private JULY = keccak256(\"Jul\");\r\n    bytes32 constant private AUGUST = keccak256(\"Aug\");\r\n    bytes32 constant private SEPTEMBER = keccak256(\"Sep\");\r\n    bytes32 constant private OCTOBER = keccak256(\"Oct\");\r\n    bytes32 constant private NOVEMBER = keccak256(\"Nov\");\r\n    bytes32 constant private DECEMBER = keccak256(\"Dec\");\r\n\r\n    /// @return the number of the month based on its name.\r\n    /// @param _month the first three letters of a month's name e.g. \"Jan\".\r\n    function _monthToNumber(string _month) internal pure returns (uint8) {\r\n        bytes32 month = keccak256(abi.encodePacked(_month));\r\n        if (month == JANUARY) {\r\n            return 1;\r\n        } else if (month == FEBRUARY) {\r\n            return 2;\r\n        } else if (month == MARCH) {\r\n            return 3;\r\n        } else if (month == APRIL) {\r\n            return 4;\r\n        } else if (month == MAY) {\r\n            return 5;\r\n        } else if (month == JUNE) {\r\n            return 6;\r\n        } else if (month == JULY) {\r\n            return 7;\r\n        } else if (month == AUGUST) {\r\n            return 8;\r\n        } else if (month == SEPTEMBER) {\r\n            return 9;\r\n        } else if (month == OCTOBER) {\r\n            return 10;\r\n        } else if (month == NOVEMBER) {\r\n            return 11;\r\n        } else if (month == DECEMBER) {\r\n            return 12;\r\n        } else {\r\n            revert(\"not a valid month\");\r\n        }\r\n    }\r\n}\r\n\r\n/*\r\n * Copyright 2016 Nick Johnson\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\n/*\r\n * @title String & slice utility library for Solidity contracts.\r\n * @author Nick Johnson <arachnid@notdot.net>\r\n *\r\n * @dev Functionality in this library is largely implemented using an\r\n *      abstraction called a 'slice'. A slice represents a part of a string -\r\n *      anything from the entire string to a single character, or even no\r\n *      characters at all (a 0-length slice). Since a slice only has to specify\r\n *      an offset and a length, copying and manipulating slices is a lot less\r\n *      expensive than copying and manipulating the strings they reference.\r\n *\r\n *      To further reduce gas costs, most functions on slice that need to return\r\n *      a slice modify the original one instead of allocating a new one; for\r\n *      instance, `s.split(\".\")` will return the text up to the first '.',\r\n *      modifying s to only contain the remainder of the string after the '.'.\r\n *      In situations where you do not want to modify the original slice, you\r\n *      can make a copy first with `.copy()`, for example:\r\n *      `s.copy().split(\".\")`. Try and avoid using this idiom in loops; since\r\n *      Solidity has no memory management, it will result in allocating many\r\n *      short-lived slices that are later discarded.\r\n *\r\n *      Functions that return two slices come in two versions: a non-allocating\r\n *      version that takes the second slice as an argument, modifying it in\r\n *      place, and an allocating version that allocates and returns the second\r\n *      slice; see `nextRune` for example.\r\n *\r\n *      Functions that have to copy string data will return strings rather than\r\n *      slices; these can be cast back to slices for further processing if\r\n *      required.\r\n *\r\n *      For convenience, some functions are provided with non-modifying\r\n *      variants that create a new slice and return both; for instance,\r\n *      `s.splitNew('.')` leaves s unmodified, and returns two values\r\n *      corresponding to the left and right parts of the string.\r\n */\r\n\r\nlibrary strings {\r\n    struct slice {\r\n        uint _len;\r\n        uint _ptr;\r\n    }\r\n\r\n    function memcpy(uint dest, uint src, uint len) private pure {\r\n        // Copy word-length chunks while possible\r\n        for(; len >= 32; len -= 32) {\r\n            assembly {\r\n                mstore(dest, mload(src))\r\n            }\r\n            dest += 32;\r\n            src += 32;\r\n        }\r\n\r\n        // Copy remaining bytes\r\n        uint mask = 256 ** (32 - len) - 1;\r\n        assembly {\r\n            let srcpart := and(mload(src), not(mask))\r\n            let destpart := and(mload(dest), mask)\r\n            mstore(dest, or(destpart, srcpart))\r\n        }\r\n    }\r\n\r\n    /*\r\n     * @dev Returns a slice containing the entire string.\r\n     * @param self The string to make a slice from.\r\n     * @return A newly allocated slice containing the entire string.\r\n     */\r\n    function toSlice(string memory self) internal pure returns (slice memory) {\r\n        uint ptr;\r\n        assembly {\r\n            ptr := add(self, 0x20)\r\n        }\r\n        return slice(bytes(self).length, ptr);\r\n    }\r\n\r\n    /*\r\n     * @dev Returns the length of a null-terminated bytes32 string.\r\n     * @param self The value to find the length of.\r\n     * @return The length of the string, from 0 to 32.\r\n     */\r\n    function len(bytes32 self) internal pure returns (uint) {\r\n        uint ret;\r\n        if (self == 0)\r\n            return 0;\r\n        if (self & 0xffffffffffffffffffffffffffffffff == 0) {\r\n            ret += 16;\r\n            self = bytes32(uint(self) / 0x100000000000000000000000000000000);\r\n        }\r\n        if (self & 0xffffffffffffffff == 0) {\r\n            ret += 8;\r\n            self = bytes32(uint(self) / 0x10000000000000000);\r\n        }\r\n        if (self & 0xffffffff == 0) {\r\n            ret += 4;\r\n            self = bytes32(uint(self) / 0x100000000);\r\n        }\r\n        if (self & 0xffff == 0) {\r\n            ret += 2;\r\n            self = bytes32(uint(self) / 0x10000);\r\n        }\r\n        if (self & 0xff == 0) {\r\n            ret += 1;\r\n        }\r\n        return 32 - ret;\r\n    }\r\n\r\n    /*\r\n     * @dev Returns a slice containing the entire bytes32, interpreted as a\r\n     *      null-terminated utf-8 string.\r\n     * @param self The bytes32 value to convert to a slice.\r\n     * @return A new slice containing the value of the input argument up to the\r\n     *         first null.\r\n     */\r\n    function toSliceB32(bytes32 self) internal pure returns (slice memory ret) {\r\n        // Allocate space for `self` in memory, copy it there, and point ret at it\r\n        assembly {\r\n            let ptr := mload(0x40)\r\n            mstore(0x40, add(ptr, 0x20))\r\n            mstore(ptr, self)\r\n            mstore(add(ret, 0x20), ptr)\r\n        }\r\n        ret._len = len(self);\r\n    }\r\n\r\n    /*\r\n     * @dev Returns a new slice containing the same data as the current slice.\r\n     * @param self The slice to copy.\r\n     * @return A new slice containing the same data as `self`.\r\n     */\r\n    function copy(slice memory self) internal pure returns (slice memory) {\r\n        return slice(self._len, self._ptr);\r\n    }\r\n\r\n    /*\r\n     * @dev Copies a slice to a new string.\r\n     * @param self The slice to copy.\r\n     * @return A newly allocated string containing the slice's text.\r\n     */\r\n    function toString(slice memory self) internal pure returns (string memory) {\r\n        string memory ret = new string(self._len);\r\n        uint retptr;\r\n        assembly { retptr := add(ret, 32) }\r\n\r\n        memcpy(retptr, self._ptr, self._len);\r\n        return ret;\r\n    }\r\n\r\n    /*\r\n     * @dev Returns the length in runes of the slice. Note that this operation\r\n     *      takes time proportional to the length of the slice; avoid using it\r\n     *      in loops, and call `slice.empty()` if you only need to know whether\r\n     *      the slice is empty or not.\r\n     * @param self The slice to operate on.\r\n     * @return The length of the slice in runes.\r\n     */\r\n    function len(slice memory self) internal pure returns (uint l) {\r\n        // Starting at ptr-31 means the LSB will be the byte we care about\r\n        uint ptr = self._ptr - 31;\r\n        uint end = ptr + self._len;\r\n        for (l = 0; ptr < end; l++) {\r\n            uint8 b;\r\n            assembly { b := and(mload(ptr), 0xFF) }\r\n            if (b < 0x80) {\r\n                ptr += 1;\r\n            } else if(b < 0xE0) {\r\n                ptr += 2;\r\n            } else if(b < 0xF0) {\r\n                ptr += 3;\r\n            } else if(b < 0xF8) {\r\n                ptr += 4;\r\n            } else if(b < 0xFC) {\r\n                ptr += 5;\r\n            } else {\r\n                ptr += 6;\r\n            }\r\n        }\r\n    }\r\n\r\n    /*\r\n     * @dev Returns true if the slice is empty (has a length of 0).\r\n     * @param self The slice to operate on.\r\n     * @return True if the slice is empty, False otherwise.\r\n     */\r\n    function empty(slice memory self) internal pure returns (bool) {\r\n        return self._len == 0;\r\n    }\r\n\r\n    /*\r\n     * @dev Returns a positive number if `other` comes lexicographically after\r\n     *      `self`, a negative number if it comes before, or zero if the\r\n     *      contents of the two slices are equal. Comparison is done per-rune,\r\n     *      on unicode codepoints.\r\n     * @param self The first slice to compare.\r\n     * @param other The second slice to compare.\r\n     * @return The result of the comparison.\r\n     */\r\n    function compare(slice memory self, slice memory other) internal pure returns (int) {\r\n        uint shortest = self._len;\r\n        if (other._len < self._len)\r\n            shortest = other._len;\r\n\r\n        uint selfptr = self._ptr;\r\n        uint otherptr = other._ptr;\r\n        for (uint idx = 0; idx < shortest; idx += 32) {\r\n            uint a;\r\n            uint b;\r\n            assembly {\r\n                a := mload(selfptr)\r\n                b := mload(otherptr)\r\n            }\r\n            if (a != b) {\r\n                // Mask out irrelevant bytes and check again\r\n                uint256 mask = uint256(-1); // 0xffff...\r\n                if(shortest < 32) {\r\n                  mask = ~(2 ** (8 * (32 - shortest + idx)) - 1);\r\n                }\r\n                uint256 diff = (a & mask) - (b & mask);\r\n                if (diff != 0)\r\n                    return int(diff);\r\n            }\r\n            selfptr += 32;\r\n            otherptr += 32;\r\n        }\r\n        return int(self._len) - int(other._len);\r\n    }\r\n\r\n    /*\r\n     * @dev Returns true if the two slices contain the same text.\r\n     * @param self The first slice to compare.\r\n     * @param self The second slice to compare.\r\n     * @return True if the slices are equal, false otherwise.\r\n     */\r\n    function equals(slice memory self, slice memory other) internal pure returns (bool) {\r\n        return compare(self, other) == 0;\r\n    }\r\n\r\n    /*\r\n     * @dev Extracts the first rune in the slice into `rune`, advancing the\r\n     *      slice to point to the next rune and returning `self`.\r\n     * @param self The slice to operate on.\r\n     * @param rune The slice that will contain the first rune.\r\n     * @return `rune`.\r\n     */\r\n    function nextRune(slice memory self, slice memory rune) internal pure returns (slice memory) {\r\n        rune._ptr = self._ptr;\r\n\r\n        if (self._len == 0) {\r\n            rune._len = 0;\r\n            return rune;\r\n        }\r\n\r\n        uint l;\r\n        uint b;\r\n        // Load the first byte of the rune into the LSBs of b\r\n        assembly { b := and(mload(sub(mload(add(self, 32)), 31)), 0xFF) }\r\n        if (b < 0x80) {\r\n            l = 1;\r\n        } else if(b < 0xE0) {\r\n            l = 2;\r\n        } else if(b < 0xF0) {\r\n            l = 3;\r\n        } else {\r\n            l = 4;\r\n        }\r\n\r\n        // Check for truncated codepoints\r\n        if (l > self._len) {\r\n            rune._len = self._len;\r\n            self._ptr += self._len;\r\n            self._len = 0;\r\n            return rune;\r\n        }\r\n\r\n        self._ptr += l;\r\n        self._len -= l;\r\n        rune._len = l;\r\n        return rune;\r\n    }\r\n\r\n    /*\r\n     * @dev Returns the first rune in the slice, advancing the slice to point\r\n     *      to the next rune.\r\n     * @param self The slice to operate on.\r\n     * @return A slice containing only the first rune from `self`.\r\n     */\r\n    function nextRune(slice memory self) internal pure returns (slice memory ret) {\r\n        nextRune(self, ret);\r\n    }\r\n\r\n    /*\r\n     * @dev Returns the number of the first codepoint in the slice.\r\n     * @param self The slice to operate on.\r\n     * @return The number of the first codepoint in the slice.\r\n     */\r\n    function ord(slice memory self) internal pure returns (uint ret) {\r\n        if (self._len == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint word;\r\n        uint length;\r\n        uint divisor = 2 ** 248;\r\n\r\n        // Load the rune into the MSBs of b\r\n        assembly { word:= mload(mload(add(self, 32))) }\r\n        uint b = word / divisor;\r\n        if (b < 0x80) {\r\n            ret = b;\r\n            length = 1;\r\n        } else if(b < 0xE0) {\r\n            ret = b & 0x1F;\r\n            length = 2;\r\n        } else if(b < 0xF0) {\r\n            ret = b & 0x0F;\r\n            length = 3;\r\n        } else {\r\n            ret = b & 0x07;\r\n            length = 4;\r\n        }\r\n\r\n        // Check for truncated codepoints\r\n        if (length > self._len) {\r\n            return 0;\r\n        }\r\n\r\n        for (uint i = 1; i < length; i++) {\r\n            divisor = divisor / 256;\r\n            b = (word / divisor) & 0xFF;\r\n            if (b & 0xC0 != 0x80) {\r\n                // Invalid UTF-8 sequence\r\n                return 0;\r\n            }\r\n            ret = (ret * 64) | (b & 0x3F);\r\n        }\r\n\r\n        return ret;\r\n    }\r\n\r\n    /*\r\n     * @dev Returns the keccak-256 hash of the slice.\r\n     * @param self The slice to hash.\r\n     * @return The hash of the slice.\r\n     */\r\n    function keccak(slice memory self) internal pure returns (bytes32 ret) {\r\n        assembly {\r\n            ret := keccak256(mload(add(self, 32)), mload(self))\r\n        }\r\n    }\r\n\r\n    /*\r\n     * @dev Returns true if `self` starts with `needle`.\r\n     * @param self The slice to operate on.\r\n     * @param needle The slice to search for.\r\n     * @return True if the slice starts with the provided text, false otherwise.\r\n     */\r\n    function startsWith(slice memory self, slice memory needle) internal pure returns (bool) {\r\n        if (self._len < needle._len) {\r\n            return false;\r\n        }\r\n\r\n        if (self._ptr == needle._ptr) {\r\n            return true;\r\n        }\r\n\r\n        bool equal;\r\n        assembly {\r\n            let length := mload(needle)\r\n            let selfptr := mload(add(self, 0x20))\r\n            let needleptr := mload(add(needle, 0x20))\r\n            equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\r\n        }\r\n        return equal;\r\n    }\r\n\r\n    /*\r\n     * @dev If `self` starts with `needle`, `needle` is removed from the\r\n     *      beginning of `self`. Otherwise, `self` is unmodified.\r\n     * @param self The slice to operate on.\r\n     * @param needle The slice to search for.\r\n     * @return `self`\r\n     */\r\n    function beyond(slice memory self, slice memory needle) internal pure returns (slice memory) {\r\n        if (self._len < needle._len) {\r\n            return self;\r\n        }\r\n\r\n        bool equal = true;\r\n        if (self._ptr != needle._ptr) {\r\n            assembly {\r\n                let length := mload(needle)\r\n                let selfptr := mload(add(self, 0x20))\r\n                let needleptr := mload(add(needle, 0x20))\r\n                equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\r\n            }\r\n        }\r\n\r\n        if (equal) {\r\n            self._len -= needle._len;\r\n            self._ptr += needle._len;\r\n        }\r\n\r\n        return self;\r\n    }\r\n\r\n    /*\r\n     * @dev Returns true if the slice ends with `needle`.\r\n     * @param self The slice to operate on.\r\n     * @param needle The slice to search for.\r\n     * @return True if the slice starts with the provided text, false otherwise.\r\n     */\r\n    function endsWith(slice memory self, slice memory needle) internal pure returns (bool) {\r\n        if (self._len < needle._len) {\r\n            return false;\r\n        }\r\n\r\n        uint selfptr = self._ptr + self._len - needle._len;\r\n\r\n        if (selfptr == needle._ptr) {\r\n            return true;\r\n        }\r\n\r\n        bool equal;\r\n        assembly {\r\n            let length := mload(needle)\r\n            let needleptr := mload(add(needle, 0x20))\r\n            equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\r\n        }\r\n\r\n        return equal;\r\n    }\r\n\r\n    /*\r\n     * @dev If `self` ends with `needle`, `needle` is removed from the\r\n     *      end of `self`. Otherwise, `self` is unmodified.\r\n     * @param self The slice to operate on.\r\n     * @param needle The slice to search for.\r\n     * @return `self`\r\n     */\r\n    function until(slice memory self, slice memory needle) internal pure returns (slice memory) {\r\n        if (self._len < needle._len) {\r\n            return self;\r\n        }\r\n\r\n        uint selfptr = self._ptr + self._len - needle._len;\r\n        bool equal = true;\r\n        if (selfptr != needle._ptr) {\r\n            assembly {\r\n                let length := mload(needle)\r\n                let needleptr := mload(add(needle, 0x20))\r\n                equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\r\n            }\r\n        }\r\n\r\n        if (equal) {\r\n            self._len -= needle._len;\r\n        }\r\n\r\n        return self;\r\n    }\r\n\r\n    // Returns the memory address of the first byte of the first occurrence of\r\n    // `needle` in `self`, or the first byte after `self` if not found.\r\n    function findPtr(uint selflen, uint selfptr, uint needlelen, uint needleptr) private pure returns (uint) {\r\n        uint ptr = selfptr;\r\n        uint idx;\r\n\r\n        if (needlelen <= selflen) {\r\n            if (needlelen <= 32) {\r\n                bytes32 mask = bytes32(~(2 ** (8 * (32 - needlelen)) - 1));\r\n\r\n                bytes32 needledata;\r\n                assembly { needledata := and(mload(needleptr), mask) }\r\n\r\n                uint end = selfptr + selflen - needlelen;\r\n                bytes32 ptrdata;\r\n                assembly { ptrdata := and(mload(ptr), mask) }\r\n\r\n                while (ptrdata != needledata) {\r\n                    if (ptr >= end)\r\n                        return selfptr + selflen;\r\n                    ptr++;\r\n                    assembly { ptrdata := and(mload(ptr), mask) }\r\n                }\r\n                return ptr;\r\n            } else {\r\n                // For long needles, use hashing\r\n                bytes32 hash;\r\n                assembly { hash := keccak256(needleptr, needlelen) }\r\n\r\n                for (idx = 0; idx <= selflen - needlelen; idx++) {\r\n                    bytes32 testHash;\r\n                    assembly { testHash := keccak256(ptr, needlelen) }\r\n                    if (hash == testHash)\r\n                        return ptr;\r\n                    ptr += 1;\r\n                }\r\n            }\r\n        }\r\n        return selfptr + selflen;\r\n    }\r\n\r\n    // Returns the memory address of the first byte after the last occurrence of\r\n    // `needle` in `self`, or the address of `self` if not found.\r\n    function rfindPtr(uint selflen, uint selfptr, uint needlelen, uint needleptr) private pure returns (uint) {\r\n        uint ptr;\r\n\r\n        if (needlelen <= selflen) {\r\n            if (needlelen <= 32) {\r\n                bytes32 mask = bytes32(~(2 ** (8 * (32 - needlelen)) - 1));\r\n\r\n                bytes32 needledata;\r\n                assembly { needledata := and(mload(needleptr), mask) }\r\n\r\n                ptr = selfptr + selflen - needlelen;\r\n                bytes32 ptrdata;\r\n                assembly { ptrdata := and(mload(ptr), mask) }\r\n\r\n                while (ptrdata != needledata) {\r\n                    if (ptr <= selfptr)\r\n                        return selfptr;\r\n                    ptr--;\r\n                    assembly { ptrdata := and(mload(ptr), mask) }\r\n                }\r\n                return ptr + needlelen;\r\n            } else {\r\n                // For long needles, use hashing\r\n                bytes32 hash;\r\n                assembly { hash := keccak256(needleptr, needlelen) }\r\n                ptr = selfptr + (selflen - needlelen);\r\n                while (ptr >= selfptr) {\r\n                    bytes32 testHash;\r\n                    assembly { testHash := keccak256(ptr, needlelen) }\r\n                    if (hash == testHash)\r\n                        return ptr + needlelen;\r\n                    ptr -= 1;\r\n                }\r\n            }\r\n        }\r\n        return selfptr;\r\n    }\r\n\r\n    /*\r\n     * @dev Modifies `self` to contain everything from the first occurrence of\r\n     *      `needle` to the end of the slice. `self` is set to the empty slice\r\n     *      if `needle` is not found.\r\n     * @param self The slice to search and modify.\r\n     * @param needle The text to search for.\r\n     * @return `self`.\r\n     */\r\n    function find(slice memory self, slice memory needle) internal pure returns (slice memory) {\r\n        uint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr);\r\n        self._len -= ptr - self._ptr;\r\n        self._ptr = ptr;\r\n        return self;\r\n    }\r\n\r\n    /*\r\n     * @dev Modifies `self` to contain the part of the string from the start of\r\n     *      `self` to the end of the first occurrence of `needle`. If `needle`\r\n     *      is not found, `self` is set to the empty slice.\r\n     * @param self The slice to search and modify.\r\n     * @param needle The text to search for.\r\n     * @return `self`.\r\n     */\r\n    function rfind(slice memory self, slice memory needle) internal pure returns (slice memory) {\r\n        uint ptr = rfindPtr(self._len, self._ptr, needle._len, needle._ptr);\r\n        self._len = ptr - self._ptr;\r\n        return self;\r\n    }\r\n\r\n    /*\r\n     * @dev Splits the slice, setting `self` to everything after the first\r\n     *      occurrence of `needle`, and `token` to everything before it. If\r\n     *      `needle` does not occur in `self`, `self` is set to the empty slice,\r\n     *      and `token` is set to the entirety of `self`.\r\n     * @param self The slice to split.\r\n     * @param needle The text to search for in `self`.\r\n     * @param token An output parameter to which the first token is written.\r\n     * @return `token`.\r\n     */\r\n    function split(slice memory self, slice memory needle, slice memory token) internal pure returns (slice memory) {\r\n        uint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr);\r\n        token._ptr = self._ptr;\r\n        token._len = ptr - self._ptr;\r\n        if (ptr == self._ptr + self._len) {\r\n            // Not found\r\n            self._len = 0;\r\n        } else {\r\n            self._len -= token._len + needle._len;\r\n            self._ptr = ptr + needle._len;\r\n        }\r\n        return token;\r\n    }\r\n\r\n    /*\r\n     * @dev Splits the slice, setting `self` to everything after the first\r\n     *      occurrence of `needle`, and returning everything before it. If\r\n     *      `needle` does not occur in `self`, `self` is set to the empty slice,\r\n     *      and the entirety of `self` is returned.\r\n     * @param self The slice to split.\r\n     * @param needle The text to search for in `self`.\r\n     * @return The part of `self` up to the first occurrence of `delim`.\r\n     */\r\n    function split(slice memory self, slice memory needle) internal pure returns (slice memory token) {\r\n        split(self, needle, token);\r\n    }\r\n\r\n    /*\r\n     * @dev Splits the slice, setting `self` to everything before the last\r\n     *      occurrence of `needle`, and `token` to everything after it. If\r\n     *      `needle` does not occur in `self`, `self` is set to the empty slice,\r\n     *      and `token` is set to the entirety of `self`.\r\n     * @param self The slice to split.\r\n     * @param needle The text to search for in `self`.\r\n     * @param token An output parameter to which the first token is written.\r\n     * @return `token`.\r\n     */\r\n    function rsplit(slice memory self, slice memory needle, slice memory token) internal pure returns (slice memory) {\r\n        uint ptr = rfindPtr(self._len, self._ptr, needle._len, needle._ptr);\r\n        token._ptr = ptr;\r\n        token._len = self._len - (ptr - self._ptr);\r\n        if (ptr == self._ptr) {\r\n            // Not found\r\n            self._len = 0;\r\n        } else {\r\n            self._len -= token._len + needle._len;\r\n        }\r\n        return token;\r\n    }\r\n\r\n    /*\r\n     * @dev Splits the slice, setting `self` to everything before the last\r\n     *      occurrence of `needle`, and returning everything after it. If\r\n     *      `needle` does not occur in `self`, `self` is set to the empty slice,\r\n     *      and the entirety of `self` is returned.\r\n     * @param self The slice to split.\r\n     * @param needle The text to search for in `self`.\r\n     * @return The part of `self` after the last occurrence of `delim`.\r\n     */\r\n    function rsplit(slice memory self, slice memory needle) internal pure returns (slice memory token) {\r\n        rsplit(self, needle, token);\r\n    }\r\n\r\n    /*\r\n     * @dev Counts the number of nonoverlapping occurrences of `needle` in `self`.\r\n     * @param self The slice to search.\r\n     * @param needle The text to search for in `self`.\r\n     * @return The number of occurrences of `needle` found in `self`.\r\n     */\r\n    function count(slice memory self, slice memory needle) internal pure returns (uint cnt) {\r\n        uint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr) + needle._len;\r\n        while (ptr <= self._ptr + self._len) {\r\n            cnt++;\r\n            ptr = findPtr(self._len - (ptr - self._ptr), ptr, needle._len, needle._ptr) + needle._len;\r\n        }\r\n    }\r\n\r\n    /*\r\n     * @dev Returns True if `self` contains `needle`.\r\n     * @param self The slice to search.\r\n     * @param needle The text to search for in `self`.\r\n     * @return True if `needle` is found in `self`, false otherwise.\r\n     */\r\n    function contains(slice memory self, slice memory needle) internal pure returns (bool) {\r\n        return rfindPtr(self._len, self._ptr, needle._len, needle._ptr) != self._ptr;\r\n    }\r\n\r\n    /*\r\n     * @dev Returns a newly allocated string containing the concatenation of\r\n     *      `self` and `other`.\r\n     * @param self The first slice to concatenate.\r\n     * @param other The second slice to concatenate.\r\n     * @return The concatenation of the two strings.\r\n     */\r\n    function concat(slice memory self, slice memory other) internal pure returns (string memory) {\r\n        string memory ret = new string(self._len + other._len);\r\n        uint retptr;\r\n        assembly { retptr := add(ret, 32) }\r\n        memcpy(retptr, self._ptr, self._len);\r\n        memcpy(retptr + self._len, other._ptr, other._len);\r\n        return ret;\r\n    }\r\n\r\n    /*\r\n     * @dev Joins an array of slices, using `self` as a delimiter, returning a\r\n     *      newly allocated string.\r\n     * @param self The delimiter to use.\r\n     * @param parts A list of slices to join.\r\n     * @return A newly allocated string containing all the slices in `parts`,\r\n     *         joined with `self`.\r\n     */\r\n    function join(slice memory self, slice[] memory parts) internal pure returns (string memory) {\r\n        if (parts.length == 0)\r\n            return \"\";\r\n\r\n        uint length = self._len * (parts.length - 1);\r\n        for(uint i = 0; i < parts.length; i++)\r\n            length += parts[i]._len;\r\n\r\n        string memory ret = new string(length);\r\n        uint retptr;\r\n        assembly { retptr := add(ret, 32) }\r\n\r\n        for(i = 0; i < parts.length; i++) {\r\n            memcpy(retptr, parts[i]._ptr, parts[i]._len);\r\n            retptr += parts[i]._len;\r\n            if (i < parts.length - 1) {\r\n                memcpy(retptr, self._ptr, self._len);\r\n                retptr += self._len;\r\n            }\r\n        }\r\n\r\n        return ret;\r\n    }\r\n}\r\n\r\n// <ORACLIZE_API>\r\n// Release targetted at solc 0.4.25 to silence compiler warning/error messages, compatible down to 0.4.22\r\n/*\r\nCopyright (c) 2015-2016 Oraclize SRL\r\nCopyright (c) 2016 Oraclize LTD\r\n\r\n\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining a copy\r\nof this software and associated documentation files (the \"Software\"), to deal\r\nin the Software without restriction, including without limitation the rights\r\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\ncopies of the Software, and to permit persons to whom the Software is\r\nfurnished to do so, subject to the following conditions:\r\n\r\n\r\n\r\nThe above copyright notice and this permission notice shall be included in\r\nall copies or substantial portions of the Software.\r\n\r\n\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\r\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\nTHE SOFTWARE.\r\n*/\r\n\r\n// This api is currently targeted at 0.4.22 to 0.4.25 (stable builds), please import oraclizeAPI_pre0.4.sol or oraclizeAPI_0.4 where necessary\r\n\r\ncontract OraclizeI {\r\n    address public cbAddress;\r\n    function query(uint _timestamp, string _datasource, string _arg) external payable returns (bytes32 _id);\r\n    function query_withGasLimit(uint _timestamp, string _datasource, string _arg, uint _gaslimit) external payable returns (bytes32 _id);\r\n    function query2(uint _timestamp, string _datasource, string _arg1, string _arg2) public payable returns (bytes32 _id);\r\n    function query2_withGasLimit(uint _timestamp, string _datasource, string _arg1, string _arg2, uint _gaslimit) external payable returns (bytes32 _id);\r\n    function queryN(uint _timestamp, string _datasource, bytes _argN) public payable returns (bytes32 _id);\r\n    function queryN_withGasLimit(uint _timestamp, string _datasource, bytes _argN, uint _gaslimit) external payable returns (bytes32 _id);\r\n    function getPrice(string _datasource) public returns (uint _dsprice);\r\n    function getPrice(string _datasource, uint gaslimit) public returns (uint _dsprice);\r\n    function setProofType(byte _proofType) external;\r\n    function setCustomGasPrice(uint _gasPrice) external;\r\n    function randomDS_getSessionPubKeyHash() external constant returns(bytes32);\r\n}\r\n\r\ncontract OraclizeAddrResolverI {\r\n    function getAddress() public returns (address _addr);\r\n}\r\n\r\n/*\r\nBegin solidity-cborutils\r\n\r\nhttps://github.com/smartcontractkit/solidity-cborutils\r\n\r\nMIT License\r\n\r\nCopyright (c) 2018 SmartContract ChainLink, Ltd.\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining a copy\r\nof this software and associated documentation files (the \"Software\"), to deal\r\nin the Software without restriction, including without limitation the rights\r\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\ncopies of the Software, and to permit persons to whom the Software is\r\nfurnished to do so, subject to the following conditions:\r\n\r\nThe above copyright notice and this permission notice shall be included in all\r\ncopies or substantial portions of the Software.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\nSOFTWARE.\r\n */\r\n\r\nlibrary Buffer {\r\n    struct buffer {\r\n        bytes buf;\r\n        uint capacity;\r\n    }\r\n\r\n    function init(buffer memory buf, uint _capacity) internal pure {\r\n        uint capacity = _capacity;\r\n        if(capacity % 32 != 0) capacity += 32 - (capacity % 32);\r\n        // Allocate space for the buffer data\r\n        buf.capacity = capacity;\r\n        assembly {\r\n            let ptr := mload(0x40)\r\n            mstore(buf, ptr)\r\n            mstore(ptr, 0)\r\n            mstore(0x40, add(ptr, capacity))\r\n        }\r\n    }\r\n\r\n    function resize(buffer memory buf, uint capacity) private pure {\r\n        bytes memory oldbuf = buf.buf;\r\n        init(buf, capacity);\r\n        append(buf, oldbuf);\r\n    }\r\n\r\n    function max(uint a, uint b) private pure returns(uint) {\r\n        if(a > b) {\r\n            return a;\r\n        }\r\n        return b;\r\n    }\r\n\r\n    /**\r\n     * @dev Appends a byte array to the end of the buffer. Resizes if doing so\r\n     *      would exceed the capacity of the buffer.\r\n     * @param buf The buffer to append to.\r\n     * @param data The data to append.\r\n     * @return The original buffer.\r\n     */\r\n    function append(buffer memory buf, bytes data) internal pure returns(buffer memory) {\r\n        if(data.length + buf.buf.length > buf.capacity) {\r\n            resize(buf, max(buf.capacity, data.length) * 2);\r\n        }\r\n\r\n        uint dest;\r\n        uint src;\r\n        uint len = data.length;\r\n        assembly {\r\n            // Memory address of the buffer data\r\n            let bufptr := mload(buf)\r\n            // Length of existing buffer data\r\n            let buflen := mload(bufptr)\r\n            // Start address = buffer address + buffer length + sizeof(buffer length)\r\n            dest := add(add(bufptr, buflen), 32)\r\n            // Update buffer length\r\n            mstore(bufptr, add(buflen, mload(data)))\r\n            src := add(data, 32)\r\n        }\r\n\r\n        // Copy word-length chunks while possible\r\n        for(; len >= 32; len -= 32) {\r\n            assembly {\r\n                mstore(dest, mload(src))\r\n            }\r\n            dest += 32;\r\n            src += 32;\r\n        }\r\n\r\n        // Copy remaining bytes\r\n        uint mask = 256 ** (32 - len) - 1;\r\n        assembly {\r\n            let srcpart := and(mload(src), not(mask))\r\n            let destpart := and(mload(dest), mask)\r\n            mstore(dest, or(destpart, srcpart))\r\n        }\r\n\r\n        return buf;\r\n    }\r\n\r\n    /**\r\n     * @dev Appends a byte to the end of the buffer. Resizes if doing so would\r\n     * exceed the capacity of the buffer.\r\n     * @param buf The buffer to append to.\r\n     * @param data The data to append.\r\n     * @return The original buffer.\r\n     */\r\n    function append(buffer memory buf, uint8 data) internal pure {\r\n        if(buf.buf.length + 1 > buf.capacity) {\r\n            resize(buf, buf.capacity * 2);\r\n        }\r\n\r\n        assembly {\r\n            // Memory address of the buffer data\r\n            let bufptr := mload(buf)\r\n            // Length of existing buffer data\r\n            let buflen := mload(bufptr)\r\n            // Address = buffer address + buffer length + sizeof(buffer length)\r\n            let dest := add(add(bufptr, buflen), 32)\r\n            mstore8(dest, data)\r\n            // Update buffer length\r\n            mstore(bufptr, add(buflen, 1))\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Appends a byte to the end of the buffer. Resizes if doing so would\r\n     * exceed the capacity of the buffer.\r\n     * @param buf The buffer to append to.\r\n     * @param data The data to append.\r\n     * @return The original buffer.\r\n     */\r\n    function appendInt(buffer memory buf, uint data, uint len) internal pure returns(buffer memory) {\r\n        if(len + buf.buf.length > buf.capacity) {\r\n            resize(buf, max(buf.capacity, len) * 2);\r\n        }\r\n\r\n        uint mask = 256 ** len - 1;\r\n        assembly {\r\n            // Memory address of the buffer data\r\n            let bufptr := mload(buf)\r\n            // Length of existing buffer data\r\n            let buflen := mload(bufptr)\r\n            // Address = buffer address + buffer length + sizeof(buffer length) + len\r\n            let dest := add(add(bufptr, buflen), len)\r\n            mstore(dest, or(and(mload(dest), not(mask)), data))\r\n            // Update buffer length\r\n            mstore(bufptr, add(buflen, len))\r\n        }\r\n        return buf;\r\n    }\r\n}\r\n\r\nlibrary CBOR {\r\n    using Buffer for Buffer.buffer;\r\n\r\n    uint8 private constant MAJOR_TYPE_INT = 0;\r\n    uint8 private constant MAJOR_TYPE_NEGATIVE_INT = 1;\r\n    uint8 private constant MAJOR_TYPE_BYTES = 2;\r\n    uint8 private constant MAJOR_TYPE_STRING = 3;\r\n    uint8 private constant MAJOR_TYPE_ARRAY = 4;\r\n    uint8 private constant MAJOR_TYPE_MAP = 5;\r\n    uint8 private constant MAJOR_TYPE_CONTENT_FREE = 7;\r\n\r\n    function encodeType(Buffer.buffer memory buf, uint8 major, uint value) private pure {\r\n        if(value <= 23) {\r\n            buf.append(uint8((major << 5) | value));\r\n        } else if(value <= 0xFF) {\r\n            buf.append(uint8((major << 5) | 24));\r\n            buf.appendInt(value, 1);\r\n        } else if(value <= 0xFFFF) {\r\n            buf.append(uint8((major << 5) | 25));\r\n            buf.appendInt(value, 2);\r\n        } else if(value <= 0xFFFFFFFF) {\r\n            buf.append(uint8((major << 5) | 26));\r\n            buf.appendInt(value, 4);\r\n        } else if(value <= 0xFFFFFFFFFFFFFFFF) {\r\n            buf.append(uint8((major << 5) | 27));\r\n            buf.appendInt(value, 8);\r\n        }\r\n    }\r\n\r\n    function encodeIndefiniteLengthType(Buffer.buffer memory buf, uint8 major) private pure {\r\n        buf.append(uint8((major << 5) | 31));\r\n    }\r\n\r\n    function encodeUInt(Buffer.buffer memory buf, uint value) internal pure {\r\n        encodeType(buf, MAJOR_TYPE_INT, value);\r\n    }\r\n\r\n    function encodeInt(Buffer.buffer memory buf, int value) internal pure {\r\n        if(value >= 0) {\r\n            encodeType(buf, MAJOR_TYPE_INT, uint(value));\r\n        } else {\r\n            encodeType(buf, MAJOR_TYPE_NEGATIVE_INT, uint(-1 - value));\r\n        }\r\n    }\r\n\r\n    function encodeBytes(Buffer.buffer memory buf, bytes value) internal pure {\r\n        encodeType(buf, MAJOR_TYPE_BYTES, value.length);\r\n        buf.append(value);\r\n    }\r\n\r\n    function encodeString(Buffer.buffer memory buf, string value) internal pure {\r\n        encodeType(buf, MAJOR_TYPE_STRING, bytes(value).length);\r\n        buf.append(bytes(value));\r\n    }\r\n\r\n    function startArray(Buffer.buffer memory buf) internal pure {\r\n        encodeIndefiniteLengthType(buf, MAJOR_TYPE_ARRAY);\r\n    }\r\n\r\n    function startMap(Buffer.buffer memory buf) internal pure {\r\n        encodeIndefiniteLengthType(buf, MAJOR_TYPE_MAP);\r\n    }\r\n\r\n    function endSequence(Buffer.buffer memory buf) internal pure {\r\n        encodeIndefiniteLengthType(buf, MAJOR_TYPE_CONTENT_FREE);\r\n    }\r\n}\r\n\r\n/*\r\nEnd solidity-cborutils\r\n */\r\n\r\ncontract usingOraclize {\r\n    uint constant day = 60*60*24;\r\n    uint constant week = 60*60*24*7;\r\n    uint constant month = 60*60*24*30;\r\n    byte constant proofType_NONE = 0x00;\r\n    byte constant proofType_TLSNotary = 0x10;\r\n    byte constant proofType_Ledger = 0x30;\r\n    byte constant proofType_Android = 0x40;\r\n    byte constant proofType_Native = 0xF0;\r\n    byte constant proofStorage_IPFS = 0x01;\r\n    uint8 constant networkID_auto = 0;\r\n    uint8 constant networkID_mainnet = 1;\r\n    uint8 constant networkID_testnet = 2;\r\n    uint8 constant networkID_morden = 2;\r\n    uint8 constant networkID_consensys = 161;\r\n\r\n    OraclizeAddrResolverI OAR;\r\n\r\n    OraclizeI oraclize;\r\n    modifier oraclizeAPI {\r\n        if((address(OAR)==0)||(getCodeSize(address(OAR))==0))\r\n            oraclize_setNetwork(networkID_auto);\r\n\r\n        if(address(oraclize) != OAR.getAddress())\r\n            oraclize = OraclizeI(OAR.getAddress());\r\n\r\n        _;\r\n    }\r\n    modifier coupon(string code){\r\n        oraclize = OraclizeI(OAR.getAddress());\r\n        _;\r\n    }\r\n\r\n    function oraclize_setNetwork(uint8 networkID) internal returns(bool){\r\n      return oraclize_setNetwork();\r\n      networkID; // silence the warning and remain backwards compatible\r\n    }\r\n    function oraclize_setNetwork() internal returns(bool){\r\n        if (getCodeSize(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed)>0){ //mainnet\r\n            OAR = OraclizeAddrResolverI(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed);\r\n            oraclize_setNetworkName(\"eth_mainnet\");\r\n            return true;\r\n        }\r\n        if (getCodeSize(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1)>0){ //ropsten testnet\r\n            OAR = OraclizeAddrResolverI(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1);\r\n            oraclize_setNetworkName(\"eth_ropsten3\");\r\n            return true;\r\n        }\r\n        if (getCodeSize(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e)>0){ //kovan testnet\r\n            OAR = OraclizeAddrResolverI(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e);\r\n            oraclize_setNetworkName(\"eth_kovan\");\r\n            return true;\r\n        }\r\n        if (getCodeSize(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48)>0){ //rinkeby testnet\r\n            OAR = OraclizeAddrResolverI(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48);\r\n            oraclize_setNetworkName(\"eth_rinkeby\");\r\n            return true;\r\n        }\r\n        if (getCodeSize(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475)>0){ //ethereum-bridge\r\n            OAR = OraclizeAddrResolverI(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475);\r\n            return true;\r\n        }\r\n        if (getCodeSize(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF)>0){ //ether.camp ide\r\n            OAR = OraclizeAddrResolverI(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF);\r\n            return true;\r\n        }\r\n        if (getCodeSize(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA)>0){ //browser-solidity\r\n            OAR = OraclizeAddrResolverI(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function __callback(bytes32 myid, string result) public {\r\n        __callback(myid, result, new bytes(0));\r\n    }\r\n    function __callback(bytes32 myid, string result, bytes proof) public {\r\n      return;\r\n      // Following should never be reached with a preceding return, however\r\n      // this is just a placeholder function, ideally meant to be defined in\r\n      // child contract when proofs are used\r\n      myid; result; proof; // Silence compiler warnings\r\n      oraclize = OraclizeI(0); // Additional compiler silence about making function pure/view. \r\n    }\r\n\r\n    function oraclize_getPrice(string datasource) oraclizeAPI internal returns (uint){\r\n        return oraclize.getPrice(datasource);\r\n    }\r\n\r\n    function oraclize_getPrice(string datasource, uint gaslimit) oraclizeAPI internal returns (uint){\r\n        return oraclize.getPrice(datasource, gaslimit);\r\n    }\r\n\r\n    function oraclize_query(string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource);\r\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\r\n        return oraclize.query.value(price)(0, datasource, arg);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource);\r\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\r\n        return oraclize.query.value(price)(timestamp, datasource, arg);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource, gaslimit);\r\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\r\n        return oraclize.query_withGasLimit.value(price)(timestamp, datasource, arg, gaslimit);\r\n    }\r\n    function oraclize_query(string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource, gaslimit);\r\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\r\n        return oraclize.query_withGasLimit.value(price)(0, datasource, arg, gaslimit);\r\n    }\r\n    function oraclize_query(string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource);\r\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\r\n        return oraclize.query2.value(price)(0, datasource, arg1, arg2);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource);\r\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\r\n        return oraclize.query2.value(price)(timestamp, datasource, arg1, arg2);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource, gaslimit);\r\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\r\n        return oraclize.query2_withGasLimit.value(price)(timestamp, datasource, arg1, arg2, gaslimit);\r\n    }\r\n    function oraclize_query(string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource, gaslimit);\r\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\r\n        return oraclize.query2_withGasLimit.value(price)(0, datasource, arg1, arg2, gaslimit);\r\n    }\r\n    function oraclize_query(string datasource, string[] argN) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource);\r\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\r\n        bytes memory args = stra2cbor(argN);\r\n        return oraclize.queryN.value(price)(0, datasource, args);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, string[] argN) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource);\r\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\r\n        bytes memory args = stra2cbor(argN);\r\n        return oraclize.queryN.value(price)(timestamp, datasource, args);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, string[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource, gaslimit);\r\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\r\n        bytes memory args = stra2cbor(argN);\r\n        return oraclize.queryN_withGasLimit.value(price)(timestamp, datasource, args, gaslimit);\r\n    }\r\n    function oraclize_query(string datasource, string[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource, gaslimit);\r\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\r\n        bytes memory args = stra2cbor(argN);\r\n        return oraclize.queryN_withGasLimit.value(price)(0, datasource, args, gaslimit);\r\n    }\r\n    function oraclize_query(string datasource, string[1] args) oraclizeAPI internal returns (bytes32 id) {\r\n        string[] memory dynargs = new string[](1);\r\n        dynargs[0] = args[0];\r\n        return oraclize_query(datasource, dynargs);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, string[1] args) oraclizeAPI internal returns (bytes32 id) {\r\n        string[] memory dynargs = new string[](1);\r\n        dynargs[0] = args[0];\r\n        return oraclize_query(timestamp, datasource, dynargs);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, string[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\r\n        string[] memory dynargs = new string[](1);\r\n        dynargs[0] = args[0];\r\n        return oraclize_query(timestamp, datasource, dynargs, gaslimit);\r\n    }\r\n    function oraclize_query(string datasource, string[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\r\n        string[] memory dynargs = new string[](1);\r\n        dynargs[0] = args[0];\r\n        return oraclize_query(datasource, dynargs, gaslimit);\r\n    }\r\n\r\n    function oraclize_query(string datasource, string[2] args) oraclizeAPI internal returns (bytes32 id) {\r\n        string[] memory dynargs = new string[](2);\r\n        dynargs[0] = args[0];\r\n        dynargs[1] = args[1];\r\n        return oraclize_query(datasource, dynargs);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, string[2] args) oraclizeAPI internal returns (bytes32 id) {\r\n        string[] memory dynargs = new string[](2);\r\n        dynargs[0] = args[0];\r\n        dynargs[1] = args[1];\r\n        return oraclize_query(timestamp, datasource, dynargs);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, string[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\r\n        string[] memory dynargs = new string[](2);\r\n        dynargs[0] = args[0];\r\n        dynargs[1] = args[1];\r\n        return oraclize_query(timestamp, datasource, dynargs, gaslimit);\r\n    }\r\n    function oraclize_query(string datasource, string[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\r\n        string[] memory dynargs = new string[](2);\r\n        dynargs[0] = args[0];\r\n        dynargs[1] = args[1];\r\n        return oraclize_query(datasource, dynargs, gaslimit);\r\n    }\r\n    function oraclize_query(string datasource, string[3] args) oraclizeAPI internal returns (bytes32 id) {\r\n        string[] memory dynargs = new string[](3);\r\n        dynargs[0] = args[0];\r\n        dynargs[1] = args[1];\r\n        dynargs[2] = args[2];\r\n        return oraclize_query(datasource, dynargs);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, string[3] args) oraclizeAPI internal returns (bytes32 id) {\r\n        string[] memory dynargs = new string[](3);\r\n        dynargs[0] = args[0];\r\n        dynargs[1] = args[1];\r\n        dynargs[2] = args[2];\r\n        return oraclize_query(timestamp, datasource, dynargs);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, string[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\r\n        string[] memory dynargs = new string[](3);\r\n        dynargs[0] = args[0];\r\n        dynargs[1] = args[1];\r\n        dynargs[2] = args[2];\r\n        return oraclize_query(timestamp, datasource, dynargs, gaslimit);\r\n    }\r\n    function oraclize_query(string datasource, string[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\r\n        string[] memory dynargs = new string[](3);\r\n        dynargs[0] = args[0];\r\n        dynargs[1] = args[1];\r\n        dynargs[2] = args[2];\r\n        return oraclize_query(datasource, dynargs, gaslimit);\r\n    }\r\n\r\n    function oraclize_query(string datasource, string[4] args) oraclizeAPI internal returns (bytes32 id) {\r\n        string[] memory dynargs = new string[](4);\r\n        dynargs[0] = args[0];\r\n        dynargs[1] = args[1];\r\n        dynargs[2] = args[2];\r\n        dynargs[3] = args[3];\r\n        return oraclize_query(datasource, dynargs);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, string[4] args) oraclizeAPI internal returns (bytes32 id) {\r\n        string[] memory dynargs = new string[](4);\r\n        dynargs[0] = args[0];\r\n        dynargs[1] = args[1];\r\n        dynargs[2] = args[2];\r\n        dynargs[3] = args[3];\r\n        return oraclize_query(timestamp, datasource, dynargs);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, string[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\r\n        string[] memory dynargs = new string[](4);\r\n        dynargs[0] = args[0];\r\n        dynargs[1] = args[1];\r\n        dynargs[2] = args[2];\r\n        dynargs[3] = args[3];\r\n        return oraclize_query(timestamp, datasource, dynargs, gaslimit);\r\n    }\r\n    function oraclize_query(string datasource, string[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\r\n        string[] memory dynargs = new string[](4);\r\n        dynargs[0] = args[0];\r\n        dynargs[1] = args[1];\r\n        dynargs[2] = args[2];\r\n        dynargs[3] = args[3];\r\n        return oraclize_query(datasource, dynargs, gaslimit);\r\n    }\r\n    function oraclize_query(string datasource, string[5] args) oraclizeAPI internal returns (bytes32 id) {\r\n        string[] memory dynargs = new string[](5);\r\n        dynargs[0] = args[0];\r\n        dynargs[1] = args[1];\r\n        dynargs[2] = args[2];\r\n        dynargs[3] = args[3];\r\n        dynargs[4] = args[4];\r\n        return oraclize_query(datasource, dynargs);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, string[5] args) oraclizeAPI internal returns (bytes32 id) {\r\n        string[] memory dynargs = new string[](5);\r\n        dynargs[0] = args[0];\r\n        dynargs[1] = args[1];\r\n        dynargs[2] = args[2];\r\n        dynargs[3] = args[3];\r\n        dynargs[4] = args[4];\r\n        return oraclize_query(timestamp, datasource, dynargs);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, string[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\r\n        string[] memory dynargs = new string[](5);\r\n        dynargs[0] = args[0];\r\n        dynargs[1] = args[1];\r\n        dynargs[2] = args[2];\r\n        dynargs[3] = args[3];\r\n        dynargs[4] = args[4];\r\n        return oraclize_query(timestamp, datasource, dynargs, gaslimit);\r\n    }\r\n    function oraclize_query(string datasource, string[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\r\n        string[] memory dynargs = new string[](5);\r\n        dynargs[0] = args[0];\r\n        dynargs[1] = args[1];\r\n        dynargs[2] = args[2];\r\n        dynargs[3] = args[3];\r\n        dynargs[4] = args[4];\r\n        return oraclize_query(datasource, dynargs, gaslimit);\r\n    }\r\n    function oraclize_query(string datasource, bytes[] argN) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource);\r\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\r\n        bytes memory args = ba2cbor(argN);\r\n        return oraclize.queryN.value(price)(0, datasource, args);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, bytes[] argN) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource);\r\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\r\n        bytes memory args = ba2cbor(argN);\r\n        return oraclize.queryN.value(price)(timestamp, datasource, args);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, bytes[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource, gaslimit);\r\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\r\n        bytes memory args = ba2cbor(argN);\r\n        return oraclize.queryN_withGasLimit.value(price)(timestamp, datasource, args, gaslimit);\r\n    }\r\n    function oraclize_query(string datasource, bytes[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource, gaslimit);\r\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\r\n        bytes memory args = ba2cbor(argN);\r\n        return oraclize.queryN_withGasLimit.value(price)(0, datasource, args, gaslimit);\r\n    }\r\n    function oraclize_query(string datasource, bytes[1] args) oraclizeAPI internal returns (bytes32 id) {\r\n        bytes[] memory dynargs = new bytes[](1);\r\n        dynargs[0] = args[0];\r\n        return oraclize_query(datasource, dynargs);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, bytes[1] args) oraclizeAPI internal returns (bytes32 id) {\r\n        bytes[] memory dynargs = new bytes[](1);\r\n        dynargs[0] = args[0];\r\n        return oraclize_query(timestamp, datasource, dynargs);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, bytes[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\r\n        bytes[] memory dynargs = new bytes[](1);\r\n        dynargs[0] = args[0];\r\n        return oraclize_query(timestamp, datasource, dynargs, gaslimit);\r\n    }\r\n    function oraclize_query(string datasource, bytes[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\r\n        bytes[] memory dynargs = new bytes[](1);\r\n        dynargs[0] = args[0];\r\n        return oraclize_query(datasource, dynargs, gaslimit);\r\n    }\r\n\r\n    function oraclize_query(string datasource, bytes[2] args) oraclizeAPI internal returns (bytes32 id) {\r\n        bytes[] memory dynargs = new bytes[](2);\r\n        dynargs[0] = args[0];\r\n        dynargs[1] = args[1];\r\n        return oraclize_query(datasource, dynargs);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, bytes[2] args) oraclizeAPI internal returns (bytes32 id) {\r\n        bytes[] memory dynargs = new bytes[](2);\r\n        dynargs[0] = args[0];\r\n        dynargs[1] = args[1];\r\n        return oraclize_query(timestamp, datasource, dynargs);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, bytes[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\r\n        bytes[] memory dynargs = new bytes[](2);\r\n        dynargs[0] = args[0];\r\n        dynargs[1] = args[1];\r\n        return oraclize_query(timestamp, datasource, dynargs, gaslimit);\r\n    }\r\n    function oraclize_query(string datasource, bytes[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\r\n        bytes[] memory dynargs = new bytes[](2);\r\n        dynargs[0] = args[0];\r\n        dynargs[1] = args[1];\r\n        return oraclize_query(datasource, dynargs, gaslimit);\r\n    }\r\n    function oraclize_query(string datasource, bytes[3] args) oraclizeAPI internal returns (bytes32 id) {\r\n        bytes[] memory dynargs = new bytes[](3);\r\n        dynargs[0] = args[0];\r\n        dynargs[1] = args[1];\r\n        dynargs[2] = args[2];\r\n        return oraclize_query(datasource, dynargs);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, bytes[3] args) oraclizeAPI internal returns (bytes32 id) {\r\n        bytes[] memory dynargs = new bytes[](3);\r\n        dynargs[0] = args[0];\r\n        dynargs[1] = args[1];\r\n        dynargs[2] = args[2];\r\n        return oraclize_query(timestamp, datasource, dynargs);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, bytes[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\r\n        bytes[] memory dynargs = new bytes[](3);\r\n        dynargs[0] = args[0];\r\n        dynargs[1] = args[1];\r\n        dynargs[2] = args[2];\r\n        return oraclize_query(timestamp, datasource, dynargs, gaslimit);\r\n    }\r\n    function oraclize_query(string datasource, bytes[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\r\n        bytes[] memory dynargs = new bytes[](3);\r\n        dynargs[0] = args[0];\r\n        dynargs[1] = args[1];\r\n        dynargs[2] = args[2];\r\n        return oraclize_query(datasource, dynargs, gaslimit);\r\n    }\r\n\r\n    function oraclize_query(string datasource, bytes[4] args) oraclizeAPI internal returns (bytes32 id) {\r\n        bytes[] memory dynargs = new bytes[](4);\r\n        dynargs[0] = args[0];\r\n        dynargs[1] = args[1];\r\n        dynargs[2] = args[2];\r\n        dynargs[3] = args[3];\r\n        return oraclize_query(datasource, dynargs);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, bytes[4] args) oraclizeAPI internal returns (bytes32 id) {\r\n        bytes[] memory dynargs = new bytes[](4);\r\n        dynargs[0] = args[0];\r\n        dynargs[1] = args[1];\r\n        dynargs[2] = args[2];\r\n        dynargs[3] = args[3];\r\n        return oraclize_query(timestamp, datasource, dynargs);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, bytes[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\r\n        bytes[] memory dynargs = new bytes[](4);\r\n        dynargs[0] = args[0];\r\n        dynargs[1] = args[1];\r\n        dynargs[2] = args[2];\r\n        dynargs[3] = args[3];\r\n        return oraclize_query(timestamp, datasource, dynargs, gaslimit);\r\n    }\r\n    function oraclize_query(string datasource, bytes[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\r\n        bytes[] memory dynargs = new bytes[](4);\r\n        dynargs[0] = args[0];\r\n        dynargs[1] = args[1];\r\n        dynargs[2] = args[2];\r\n        dynargs[3] = args[3];\r\n        return oraclize_query(datasource, dynargs, gaslimit);\r\n    }\r\n    function oraclize_query(string datasource, bytes[5] args) oraclizeAPI internal returns (bytes32 id) {\r\n        bytes[] memory dynargs = new bytes[](5);\r\n        dynargs[0] = args[0];\r\n        dynargs[1] = args[1];\r\n        dynargs[2] = args[2];\r\n        dynargs[3] = args[3];\r\n        dynargs[4] = args[4];\r\n        return oraclize_query(datasource, dynargs);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, bytes[5] args) oraclizeAPI internal returns (bytes32 id) {\r\n        bytes[] memory dynargs = new bytes[](5);\r\n        dynargs[0] = args[0];\r\n        dynargs[1] = args[1];\r\n        dynargs[2] = args[2];\r\n        dynargs[3] = args[3];\r\n        dynargs[4] = args[4];\r\n        return oraclize_query(timestamp, datasource, dynargs);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, bytes[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\r\n        bytes[] memory dynargs = new bytes[](5);\r\n        dynargs[0] = args[0];\r\n        dynargs[1] = args[1];\r\n        dynargs[2] = args[2];\r\n        dynargs[3] = args[3];\r\n        dynargs[4] = args[4];\r\n        return oraclize_query(timestamp, datasource, dynargs, gaslimit);\r\n    }\r\n    function oraclize_query(string datasource, bytes[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\r\n        bytes[] memory dynargs = new bytes[](5);\r\n        dynargs[0] = args[0];\r\n        dynargs[1] = args[1];\r\n        dynargs[2] = args[2];\r\n        dynargs[3] = args[3];\r\n        dynargs[4] = args[4];\r\n        return oraclize_query(datasource, dynargs, gaslimit);\r\n    }\r\n\r\n    function oraclize_cbAddress() oraclizeAPI internal returns (address){\r\n        return oraclize.cbAddress();\r\n    }\r\n    function oraclize_setProof(byte proofP) oraclizeAPI internal {\r\n        return oraclize.setProofType(proofP);\r\n    }\r\n    function oraclize_setCustomGasPrice(uint gasPrice) oraclizeAPI internal {\r\n        return oraclize.setCustomGasPrice(gasPrice);\r\n    }\r\n\r\n    function oraclize_randomDS_getSessionPubKeyHash() oraclizeAPI internal returns (bytes32){\r\n        return oraclize.randomDS_getSessionPubKeyHash();\r\n    }\r\n\r\n    function getCodeSize(address _addr) view internal returns(uint _size) {\r\n        assembly {\r\n            _size := extcodesize(_addr)\r\n        }\r\n    }\r\n\r\n    function parseAddr(string _a) internal pure returns (address){\r\n        bytes memory tmp = bytes(_a);\r\n        uint160 iaddr = 0;\r\n        uint160 b1;\r\n        uint160 b2;\r\n        for (uint i=2; i<2+2*20; i+=2){\r\n            iaddr *= 256;\r\n            b1 = uint160(tmp[i]);\r\n            b2 = uint160(tmp[i+1]);\r\n            if ((b1 >= 97)&&(b1 <= 102)) b1 -= 87;\r\n            else if ((b1 >= 65)&&(b1 <= 70)) b1 -= 55;\r\n            else if ((b1 >= 48)&&(b1 <= 57)) b1 -= 48;\r\n            if ((b2 >= 97)&&(b2 <= 102)) b2 -= 87;\r\n            else if ((b2 >= 65)&&(b2 <= 70)) b2 -= 55;\r\n            else if ((b2 >= 48)&&(b2 <= 57)) b2 -= 48;\r\n            iaddr += (b1*16+b2);\r\n        }\r\n        return address(iaddr);\r\n    }\r\n\r\n    function strCompare(string _a, string _b) internal pure returns (int) {\r\n        bytes memory a = bytes(_a);\r\n        bytes memory b = bytes(_b);\r\n        uint minLength = a.length;\r\n        if (b.length < minLength) minLength = b.length;\r\n        for (uint i = 0; i < minLength; i ++)\r\n            if (a[i] < b[i])\r\n                return -1;\r\n            else if (a[i] > b[i])\r\n                return 1;\r\n        if (a.length < b.length)\r\n            return -1;\r\n        else if (a.length > b.length)\r\n            return 1;\r\n        else\r\n            return 0;\r\n    }\r\n\r\n    function indexOf(string _haystack, string _needle) internal pure returns (int) {\r\n        bytes memory h = bytes(_haystack);\r\n        bytes memory n = bytes(_needle);\r\n        if(h.length < 1 || n.length < 1 || (n.length > h.length))\r\n            return -1;\r\n        else if(h.length > (2**128 -1))\r\n            return -1;\r\n        else\r\n        {\r\n            uint subindex = 0;\r\n            for (uint i = 0; i < h.length; i ++)\r\n            {\r\n                if (h[i] == n[0])\r\n                {\r\n                    subindex = 1;\r\n                    while(subindex < n.length && (i + subindex) < h.length && h[i + subindex] == n[subindex])\r\n                    {\r\n                        subindex++;\r\n                    }\r\n                    if(subindex == n.length)\r\n                        return int(i);\r\n                }\r\n            }\r\n            return -1;\r\n        }\r\n    }\r\n\r\n    function strConcat(string _a, string _b, string _c, string _d, string _e) internal pure returns (string) {\r\n        bytes memory _ba = bytes(_a);\r\n        bytes memory _bb = bytes(_b);\r\n        bytes memory _bc = bytes(_c);\r\n        bytes memory _bd = bytes(_d);\r\n        bytes memory _be = bytes(_e);\r\n        string memory abcde = new string(_ba.length + _bb.length + _bc.length + _bd.length + _be.length);\r\n        bytes memory babcde = bytes(abcde);\r\n        uint k = 0;\r\n        for (uint i = 0; i < _ba.length; i++) babcde[k++] = _ba[i];\r\n        for (i = 0; i < _bb.length; i++) babcde[k++] = _bb[i];\r\n        for (i = 0; i < _bc.length; i++) babcde[k++] = _bc[i];\r\n        for (i = 0; i < _bd.length; i++) babcde[k++] = _bd[i];\r\n        for (i = 0; i < _be.length; i++) babcde[k++] = _be[i];\r\n        return string(babcde);\r\n    }\r\n\r\n    function strConcat(string _a, string _b, string _c, string _d) internal pure returns (string) {\r\n        return strConcat(_a, _b, _c, _d, \"\");\r\n    }\r\n\r\n    function strConcat(string _a, string _b, string _c) internal pure returns (string) {\r\n        return strConcat(_a, _b, _c, \"\", \"\");\r\n    }\r\n\r\n    function strConcat(string _a, string _b) internal pure returns (string) {\r\n        return strConcat(_a, _b, \"\", \"\", \"\");\r\n    }\r\n\r\n    // parseInt\r\n    function parseInt(string _a) internal pure returns (uint) {\r\n        return parseInt(_a, 0);\r\n    }\r\n\r\n    // parseInt(parseFloat*10^_b)\r\n    function parseInt(string _a, uint _b) internal pure returns (uint) {\r\n        bytes memory bresult = bytes(_a);\r\n        uint mint = 0;\r\n        bool decimals = false;\r\n        for (uint i=0; i<bresult.length; i++){\r\n            if ((bresult[i] >= 48)&&(bresult[i] <= 57)){\r\n                if (decimals){\r\n                   if (_b == 0) break;\r\n                    else _b--;\r\n                }\r\n                mint *= 10;\r\n                mint += uint(bresult[i]) - 48;\r\n            } else if (bresult[i] == 46) decimals = true;\r\n        }\r\n        if (_b > 0) mint *= 10**_b;\r\n        return mint;\r\n    }\r\n\r\n    function uint2str(uint i) internal pure returns (string){\r\n        if (i == 0) return \"0\";\r\n        uint j = i;\r\n        uint len;\r\n        while (j != 0){\r\n            len++;\r\n            j /= 10;\r\n        }\r\n        bytes memory bstr = new bytes(len);\r\n        uint k = len - 1;\r\n        while (i != 0){\r\n            bstr[k--] = byte(48 + i % 10);\r\n            i /= 10;\r\n        }\r\n        return string(bstr);\r\n    }\r\n\r\n    using CBOR for Buffer.buffer;\r\n    function stra2cbor(string[] arr) internal pure returns (bytes) {\r\n        safeMemoryCleaner();\r\n        Buffer.buffer memory buf;\r\n        Buffer.init(buf, 1024);\r\n        buf.startArray();\r\n        for (uint i = 0; i < arr.length; i++) {\r\n            buf.encodeString(arr[i]);\r\n        }\r\n        buf.endSequence();\r\n        return buf.buf;\r\n    }\r\n\r\n    function ba2cbor(bytes[] arr) internal pure returns (bytes) {\r\n        safeMemoryCleaner();\r\n        Buffer.buffer memory buf;\r\n        Buffer.init(buf, 1024);\r\n        buf.startArray();\r\n        for (uint i = 0; i < arr.length; i++) {\r\n            buf.encodeBytes(arr[i]);\r\n        }\r\n        buf.endSequence();\r\n        return buf.buf;\r\n    }\r\n\r\n    string oraclize_network_name;\r\n    function oraclize_setNetworkName(string _network_name) internal {\r\n        oraclize_network_name = _network_name;\r\n    }\r\n\r\n    function oraclize_getNetworkName() internal view returns (string) {\r\n        return oraclize_network_name;\r\n    }\r\n\r\n    function oraclize_newRandomDSQuery(uint _delay, uint _nbytes, uint _customGasLimit) internal returns (bytes32){\r\n        require((_nbytes > 0) && (_nbytes <= 32));\r\n        // Convert from seconds to ledger timer ticks\r\n        _delay *= 10;\r\n        bytes memory nbytes = new bytes(1);\r\n        nbytes[0] = byte(_nbytes);\r\n        bytes memory unonce = new bytes(32);\r\n        bytes memory sessionKeyHash = new bytes(32);\r\n        bytes32 sessionKeyHash_bytes32 = oraclize_randomDS_getSessionPubKeyHash();\r\n        assembly {\r\n            mstore(unonce, 0x20)\r\n            // the following variables can be relaxed\r\n            // check relaxed random contract under ethereum-examples repo\r\n            // for an idea on how to override and replace comit hash vars\r\n            mstore(add(unonce, 0x20), xor(blockhash(sub(number, 1)), xor(coinbase, timestamp)))\r\n            mstore(sessionKeyHash, 0x20)\r\n            mstore(add(sessionKeyHash, 0x20), sessionKeyHash_bytes32)\r\n        }\r\n        bytes memory delay = new bytes(32);\r\n        assembly {\r\n            mstore(add(delay, 0x20), _delay)\r\n        }\r\n\r\n        bytes memory delay_bytes8 = new bytes(8);\r\n        copyBytes(delay, 24, 8, delay_bytes8, 0);\r\n\r\n        bytes[4] memory args = [unonce, nbytes, sessionKeyHash, delay];\r\n        bytes32 queryId = oraclize_query(\"random\", args, _customGasLimit);\r\n\r\n        bytes memory delay_bytes8_left = new bytes(8);\r\n\r\n        assembly {\r\n            let x := mload(add(delay_bytes8, 0x20))\r\n            mstore8(add(delay_bytes8_left, 0x27), div(x, 0x100000000000000000000000000000000000000000000000000000000000000))\r\n            mstore8(add(delay_bytes8_left, 0x26), div(x, 0x1000000000000000000000000000000000000000000000000000000000000))\r\n            mstore8(add(delay_bytes8_left, 0x25), div(x, 0x10000000000000000000000000000000000000000000000000000000000))\r\n            mstore8(add(delay_bytes8_left, 0x24), div(x, 0x100000000000000000000000000000000000000000000000000000000))\r\n            mstore8(add(delay_bytes8_left, 0x23), div(x, 0x1000000000000000000000000000000000000000000000000000000))\r\n            mstore8(add(delay_bytes8_left, 0x22), div(x, 0x10000000000000000000000000000000000000000000000000000))\r\n            mstore8(add(delay_bytes8_left, 0x21), div(x, 0x100000000000000000000000000000000000000000000000000))\r\n            mstore8(add(delay_bytes8_left, 0x20), div(x, 0x1000000000000000000000000000000000000000000000000))\r\n\r\n        }\r\n\r\n        oraclize_randomDS_setCommitment(queryId, keccak256(abi.encodePacked(delay_bytes8_left, args[1], sha256(args[0]), args[2])));\r\n        return queryId;\r\n    }\r\n\r\n    function oraclize_randomDS_setCommitment(bytes32 queryId, bytes32 commitment) internal {\r\n        oraclize_randomDS_args[queryId] = commitment;\r\n    }\r\n\r\n    mapping(bytes32=>bytes32) oraclize_randomDS_args;\r\n    mapping(bytes32=>bool) oraclize_randomDS_sessionKeysHashVerified;\r\n\r\n    function verifySig(bytes32 tosignh, bytes dersig, bytes pubkey) internal returns (bool){\r\n        bool sigok;\r\n        address signer;\r\n\r\n        bytes32 sigr;\r\n        bytes32 sigs;\r\n\r\n        bytes memory sigr_ = new bytes(32);\r\n        uint offset = 4+(uint(dersig[3]) - 0x20);\r\n        sigr_ = copyBytes(dersig, offset, 32, sigr_, 0);\r\n        bytes memory sigs_ = new bytes(32);\r\n        offset += 32 + 2;\r\n        sigs_ = copyBytes(dersig, offset+(uint(dersig[offset-1]) - 0x20), 32, sigs_, 0);\r\n\r\n        assembly {\r\n            sigr := mload(add(sigr_, 32))\r\n            sigs := mload(add(sigs_, 32))\r\n        }\r\n\r\n\r\n        (sigok, signer) = safer_ecrecover(tosignh, 27, sigr, sigs);\r\n        if (address(keccak256(pubkey)) == signer) return true;\r\n        else {\r\n            (sigok, signer) = safer_ecrecover(tosignh, 28, sigr, sigs);\r\n            return (address(keccak256(pubkey)) == signer);\r\n        }\r\n    }\r\n\r\n    function oraclize_randomDS_proofVerify__sessionKeyValidity(bytes proof, uint sig2offset) internal returns (bool) {\r\n        bool sigok;\r\n\r\n        // Step 6: verify the attestation signature, APPKEY1 must sign the sessionKey from the correct ledger app (CODEHASH)\r\n        bytes memory sig2 = new bytes(uint(proof[sig2offset+1])+2);\r\n        copyBytes(proof, sig2offset, sig2.length, sig2, 0);\r\n\r\n        bytes memory appkey1_pubkey = new bytes(64);\r\n        copyBytes(proof, 3+1, 64, appkey1_pubkey, 0);\r\n\r\n        bytes memory tosign2 = new bytes(1+65+32);\r\n        tosign2[0] = byte(1); //role\r\n        copyBytes(proof, sig2offset-65, 65, tosign2, 1);\r\n        bytes memory CODEHASH = hex\"fd94fa71bc0ba10d39d464d0d8f465efeef0a2764e3887fcc9df41ded20f505c\";\r\n        copyBytes(CODEHASH, 0, 32, tosign2, 1+65);\r\n        sigok = verifySig(sha256(tosign2), sig2, appkey1_pubkey);\r\n\r\n        if (sigok == false) return false;\r\n\r\n\r\n        // Step 7: verify the APPKEY1 provenance (must be signed by Ledger)\r\n        bytes memory LEDGERKEY = hex\"7fb956469c5c9b89840d55b43537e66a98dd4811ea0a27224272c2e5622911e8537a2f8e86a46baec82864e98dd01e9ccc2f8bc5dfc9cbe5a91a290498dd96e4\";\r\n\r\n        bytes memory tosign3 = new bytes(1+65);\r\n        tosign3[0] = 0xFE;\r\n        copyBytes(proof, 3, 65, tosign3, 1);\r\n\r\n        bytes memory sig3 = new bytes(uint(proof[3+65+1])+2);\r\n        copyBytes(proof, 3+65, sig3.length, sig3, 0);\r\n\r\n        sigok = verifySig(sha256(tosign3), sig3, LEDGERKEY);\r\n\r\n        return sigok;\r\n    }\r\n\r\n    modifier oraclize_randomDS_proofVerify(bytes32 _queryId, string _result, bytes _proof) {\r\n        // Step 1: the prefix has to match 'LP\\x01' (Ledger Proof version 1)\r\n        require((_proof[0] == \"L\") && (_proof[1] == \"P\") && (_proof[2] == 1));\r\n\r\n        bool proofVerified = oraclize_randomDS_proofVerify__main(_proof, _queryId, bytes(_result), oraclize_getNetworkName());\r\n        require(proofVerified);\r\n\r\n        _;\r\n    }\r\n\r\n    function oraclize_randomDS_proofVerify__returnCode(bytes32 _queryId, string _result, bytes _proof) internal returns (uint8){\r\n        // Step 1: the prefix has to match 'LP\\x01' (Ledger Proof version 1)\r\n        if ((_proof[0] != \"L\")||(_proof[1] != \"P\")||(_proof[2] != 1)) return 1;\r\n\r\n        bool proofVerified = oraclize_randomDS_proofVerify__main(_proof, _queryId, bytes(_result), oraclize_getNetworkName());\r\n        if (proofVerified == false) return 2;\r\n\r\n        return 0;\r\n    }\r\n\r\n    function matchBytes32Prefix(bytes32 content, bytes prefix, uint n_random_bytes) internal pure returns (bool){\r\n        bool match_ = true;\r\n\r\n        require(prefix.length == n_random_bytes);\r\n\r\n        for (uint256 i=0; i< n_random_bytes; i++) {\r\n            if (content[i] != prefix[i]) match_ = false;\r\n        }\r\n\r\n        return match_;\r\n    }\r\n\r\n    function oraclize_randomDS_proofVerify__main(bytes proof, bytes32 queryId, bytes result, string context_name) internal returns (bool){\r\n\r\n        // Step 2: the unique keyhash has to match with the sha256 of (context name + queryId)\r\n        uint ledgerProofLength = 3+65+(uint(proof[3+65+1])+2)+32;\r\n        bytes memory keyhash = new bytes(32);\r\n        copyBytes(proof, ledgerProofLength, 32, keyhash, 0);\r\n        if (!(keccak256(keyhash) == keccak256(abi.encodePacked(sha256(abi.encodePacked(context_name, queryId)))))) return false;\r\n\r\n        bytes memory sig1 = new bytes(uint(proof[ledgerProofLength+(32+8+1+32)+1])+2);\r\n        copyBytes(proof, ledgerProofLength+(32+8+1+32), sig1.length, sig1, 0);\r\n\r\n        // Step 3: we assume sig1 is valid (it will be verified during step 5) and we verify if 'result' is the prefix of sha256(sig1)\r\n        if (!matchBytes32Prefix(sha256(sig1), result, uint(proof[ledgerProofLength+32+8]))) return false;\r\n\r\n        // Step 4: commitment match verification, keccak256(delay, nbytes, unonce, sessionKeyHash) == commitment in storage.\r\n        // This is to verify that the computed args match with the ones specified in the query.\r\n        bytes memory commitmentSlice1 = new bytes(8+1+32);\r\n        copyBytes(proof, ledgerProofLength+32, 8+1+32, commitmentSlice1, 0);\r\n\r\n        bytes memory sessionPubkey = new bytes(64);\r\n        uint sig2offset = ledgerProofLength+32+(8+1+32)+sig1.length+65;\r\n        copyBytes(proof, sig2offset-64, 64, sessionPubkey, 0);\r\n\r\n        bytes32 sessionPubkeyHash = sha256(sessionPubkey);\r\n        if (oraclize_randomDS_args[queryId] == keccak256(abi.encodePacked(commitmentSlice1, sessionPubkeyHash))){ //unonce, nbytes and sessionKeyHash match\r\n            delete oraclize_randomDS_args[queryId];\r\n        } else return false;\r\n\r\n\r\n        // Step 5: validity verification for sig1 (keyhash and args signed with the sessionKey)\r\n        bytes memory tosign1 = new bytes(32+8+1+32);\r\n        copyBytes(proof, ledgerProofLength, 32+8+1+32, tosign1, 0);\r\n        if (!verifySig(sha256(tosign1), sig1, sessionPubkey)) return false;\r\n\r\n        // verify if sessionPubkeyHash was verified already, if not.. let's do it!\r\n        if (oraclize_randomDS_sessionKeysHashVerified[sessionPubkeyHash] == false){\r\n            oraclize_randomDS_sessionKeysHashVerified[sessionPubkeyHash] = oraclize_randomDS_proofVerify__sessionKeyValidity(proof, sig2offset);\r\n        }\r\n\r\n        return oraclize_randomDS_sessionKeysHashVerified[sessionPubkeyHash];\r\n    }\r\n\r\n    // the following function has been written by Alex Beregszaszi (@axic), use it under the terms of the MIT license\r\n    function copyBytes(bytes from, uint fromOffset, uint length, bytes to, uint toOffset) internal pure returns (bytes) {\r\n        uint minLength = length + toOffset;\r\n\r\n        // Buffer too small\r\n        require(to.length >= minLength); // Should be a better way?\r\n\r\n        // NOTE: the offset 32 is added to skip the `size` field of both bytes variables\r\n        uint i = 32 + fromOffset;\r\n        uint j = 32 + toOffset;\r\n\r\n        while (i < (32 + fromOffset + length)) {\r\n            assembly {\r\n                let tmp := mload(add(from, i))\r\n                mstore(add(to, j), tmp)\r\n            }\r\n            i += 32;\r\n            j += 32;\r\n        }\r\n\r\n        return to;\r\n    }\r\n\r\n    // the following function has been written by Alex Beregszaszi (@axic), use it under the terms of the MIT license\r\n    // Duplicate Solidity's ecrecover, but catching the CALL return value\r\n    function safer_ecrecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal returns (bool, address) {\r\n        // We do our own memory management here. Solidity uses memory offset\r\n        // 0x40 to store the current end of memory. We write past it (as\r\n        // writes are memory extensions), but don't update the offset so\r\n        // Solidity will reuse it. The memory used here is only needed for\r\n        // this context.\r\n\r\n        // FIXME: inline assembly can't access return values\r\n        bool ret;\r\n        address addr;\r\n\r\n        assembly {\r\n            let size := mload(0x40)\r\n            mstore(size, hash)\r\n            mstore(add(size, 32), v)\r\n            mstore(add(size, 64), r)\r\n            mstore(add(size, 96), s)\r\n\r\n            // NOTE: we can reuse the request memory because we deal with\r\n            //       the return code\r\n            ret := call(3000, 1, 0, size, 128, size, 32)\r\n            addr := mload(size)\r\n        }\r\n\r\n        return (ret, addr);\r\n    }\r\n\r\n    // the following function has been written by Alex Beregszaszi (@axic), use it under the terms of the MIT license\r\n    function ecrecovery(bytes32 hash, bytes sig) internal returns (bool, address) {\r\n        bytes32 r;\r\n        bytes32 s;\r\n        uint8 v;\r\n\r\n        if (sig.length != 65)\r\n          return (false, 0);\r\n\r\n        // The signature format is a compact form of:\r\n        //   {bytes32 r}{bytes32 s}{uint8 v}\r\n        // Compact means, uint8 is not padded to 32 bytes.\r\n        assembly {\r\n            r := mload(add(sig, 32))\r\n            s := mload(add(sig, 64))\r\n\r\n            // Here we are loading the last 32 bytes. We exploit the fact that\r\n            // 'mload' will pad with zeroes if we overread.\r\n            // There is no 'mload8' to do this, but that would be nicer.\r\n            v := byte(0, mload(add(sig, 96)))\r\n\r\n            // Alternative solution:\r\n            // 'byte' is not working due to the Solidity parser, so lets\r\n            // use the second best option, 'and'\r\n            // v := and(mload(add(sig, 65)), 255)\r\n        }\r\n\r\n        // albeit non-transactional signatures are not specified by the YP, one would expect it\r\n        // to match the YP range of [27, 28]\r\n        //\r\n        // geth uses [0, 1] and some clients have followed. This might change, see:\r\n        //  https://github.com/ethereum/go-ethereum/issues/2053\r\n        if (v < 27)\r\n          v += 27;\r\n\r\n        if (v != 27 && v != 28)\r\n            return (false, 0);\r\n\r\n        return safer_ecrecover(hash, v, r, s);\r\n    }\r\n\r\n    function safeMemoryCleaner() internal pure {\r\n        assembly {\r\n            let fmem := mload(0x40)\r\n            codecopy(fmem, codesize, sub(msize, fmem))\r\n        }\r\n    }\r\n\r\n}\r\n// </ORACLIZE_API>\r\n\r\n/// @title JSON provides JSON parsing functionality.\r\ncontract JSON is usingOraclize{\r\n    using strings for *;\r\n\r\n    bytes32 constant private prefixHash = keccak256(\"{\\\"ETH\\\":\");\r\n\r\n    /// @dev Extracts JSON rate value from the response object.\r\n    /// @param _json body of the JSON response from the CryptoCompare API.\r\n    function parseRate(string _json) public pure returns (string) {\r\n\r\n        uint json_len = abi.encodePacked(_json).length;\r\n        //{\"ETH\":}.length = 8, assuming a (maximum of) 18 digit prevision\r\n        require(json_len > 8 && json_len <= 28, \"misformatted input\");\r\n\r\n        bytes memory jsonPrefix = new bytes(7);\r\n        copyBytes(abi.encodePacked(_json), 0, 7, jsonPrefix, 0);\r\n        require(keccak256(jsonPrefix) == prefixHash, \"prefix mismatch\");\r\n\r\n        strings.slice memory body = _json.toSlice();\r\n        body.split(\":\".toSlice()); //we are sure that ':' is included in the string, body now contains the rate+'}'\r\n        json_len = body._len;\r\n        body.until(\"}\".toSlice());\r\n        require(body._len == json_len-1,\"not json format\"); //ensure that the json is properly terminated with a '}'\r\n        return body.toString();\r\n\r\n    }\r\n}\r\n\r\n/**\r\n * The MIT License (MIT)\r\n * \r\n * Copyright (c) 2016 Smart Contract Solutions, Inc.\r\n * \r\n * Permission is hereby granted, free of charge, to any person obtaining\r\n * a copy of this software and associated documentation files (the\r\n * \"Software\"), to deal in the Software without restriction, including\r\n * without limitation the rights to use, copy, modify, merge, publish,\r\n * distribute, sublicense, and/or sell copies of the Software, and to\r\n * permit persons to whom the Software is furnished to do so, subject to\r\n * the following conditions:\r\n * \r\n * The above copyright notice and this permission notice shall be included\r\n * in all copies or substantial portions of the Software.\r\n * \r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\r\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\r\n * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\r\n * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\r\n * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\r\n * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n */\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, reverts on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    uint256 c = a * b;\r\n    require(c / a == b);\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b > 0); // Solidity only automatically asserts when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b <= a);\r\n    uint256 c = a - b;\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, reverts on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    require(c >= a);\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\r\n  * reverts when dividing by zero.\r\n  */\r\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b != 0);\r\n    return a % b;\r\n  }\r\n}\r\n\r\n/// @title ParseIntScientific provides floating point in scientific notation (e.g. e-5) parsing functionality.\r\ncontract ParseIntScientific {\r\n\r\n    using SafeMath for uint256;\r\n\r\n    byte constant private PLUS_ASCII = byte(43); //decimal value of '+'\r\n    byte constant private DASH_ASCII = byte(45); //decimal value of '-'\r\n    byte constant private DOT_ASCII = byte(46); //decimal value of '.'\r\n    byte constant private ZERO_ASCII = byte(48); //decimal value of '0'\r\n    byte constant private NINE_ASCII = byte(57); //decimal value of '9'\r\n    byte constant private E_ASCII = byte(69); //decimal value of 'E'\r\n    byte constant private e_ASCII = byte(101); //decimal value of 'e'\r\n\r\n    /// @dev ParseIntScientific delegates the call to _parseIntScientific(string, uint) with the 2nd argument being 0.\r\n    function _parseIntScientific(string _inString) internal pure returns (uint) {\r\n        return _parseIntScientific(_inString, 0);\r\n    }\r\n\r\n    /// @dev ParseIntScientificWei parses a rate expressed in ETH and returns its wei denomination\r\n    function _parseIntScientificWei(string _inString) internal pure returns (uint) {\r\n        return _parseIntScientific(_inString, 18);\r\n    }\r\n\r\n    /// @dev ParseIntScientific parses a JSON standard - floating point number.\r\n    /// @param _inString is input string.\r\n    /// @param _magnitudeMult multiplies the number with 10^_magnitudeMult.\r\n    function _parseIntScientific(string _inString, uint _magnitudeMult) internal pure returns (uint) {\r\n\r\n        bytes memory inBytes = bytes(_inString);\r\n        uint mint = 0; // the final uint returned\r\n        uint mintDec = 0; // the uint following the decimal point\r\n        uint mintExp = 0; // the exponent\r\n        uint decMinted = 0; // how many decimals were 'minted'.\r\n        uint expIndex = 0; // the position in the byte array that 'e' was found (if found)\r\n        bool integral = false; // indicates the existence of the integral part, it should always exist (even if 0) e.g. 'e+1'  or '.1' is not valid\r\n        bool decimals = false; // indicates a decimal number, set to true if '.' is found\r\n        bool exp = false; // indicates if the number being parsed has an exponential representation\r\n        bool minus = false; // indicated if the exponent is negative\r\n        bool plus = false; // indicated if the exponent is positive\r\n\r\n        for (uint i = 0; i < inBytes.length; i++) {\r\n            if ((inBytes[i] >= ZERO_ASCII) && (inBytes[i] <= NINE_ASCII) && (!exp)) {\r\n                // 'e' not encountered yet, minting integer part or decimals\r\n                if (decimals) {\r\n                    // '.' encountered\r\n                    //use safeMath in case there is an overflow\r\n                    mintDec = mintDec.mul(10);\r\n                    mintDec = mintDec.add(uint(inBytes[i]) - uint(ZERO_ASCII));\r\n                    decMinted++; //keep track of the #decimals\r\n                } else {\r\n                    // integral part (before '.')\r\n                    integral = true;\r\n                    //use safeMath in case there is an overflow\r\n                    mint = mint.mul(10);\r\n                    mint = mint.add(uint(inBytes[i]) - uint(ZERO_ASCII));\r\n                }\r\n            } else if ((inBytes[i] >= ZERO_ASCII) && (inBytes[i] <= NINE_ASCII) && (exp)) {\r\n                //exponential notation (e-/+) has been detected, mint the exponent\r\n                mintExp = mintExp.mul(10);\r\n                mintExp = mintExp.add(uint(inBytes[i]) - uint(ZERO_ASCII));\r\n            } else if (inBytes[i] == DOT_ASCII) {\r\n                //an integral part before should always exist before '.'\r\n                require(integral, \"missing integral part\");\r\n                // an extra decimal point makes the format invalid\r\n                require(!decimals, \"duplicate decimal point\");\r\n                //the decimal point should always be before the exponent\r\n                require(!exp, \"decimal after exponent\");\r\n                decimals = true;\r\n            } else if (inBytes[i] == DASH_ASCII) {\r\n                // an extra '-' should be considered an invalid character\r\n                require(!minus, \"duplicate -\");\r\n                require(!plus, \"extra sign\");\r\n                require(expIndex + 1 == i, \"- sign not immediately after e\");\r\n                minus = true;\r\n            } else if (inBytes[i] == PLUS_ASCII) {\r\n                // an extra '+' should be considered an invalid character\r\n                require(!plus, \"duplicate +\");\r\n                require(!minus, \"extra sign\");\r\n                require(expIndex + 1 == i, \"+ sign not immediately after e\");\r\n                plus = true;\r\n            } else if ((inBytes[i] == E_ASCII) || (inBytes[i] == e_ASCII)) {\r\n                //an integral part before should always exist before 'e'\r\n                require(integral, \"missing integral part\");\r\n                // an extra 'e' or 'E' should be considered an invalid character\r\n                require(!exp, \"duplicate exponent symbol\");\r\n                exp = true;\r\n                expIndex = i;\r\n            } else {\r\n                revert(\"invalid digit\");\r\n            }\r\n        }\r\n\r\n        if (minus || plus) {\r\n            // end of string e[x|-] without specifying the exponent\r\n            require(i > expIndex + 2);\r\n        } else if (exp) {\r\n            // end of string (e) without specifying the exponent\r\n            require(i > expIndex + 1);\r\n        }\r\n\r\n        if (minus) {\r\n            // e^(-x)\r\n            if (mintExp >= _magnitudeMult) {\r\n                // the (negative) exponent is bigger than the given parameter for \"shifting left\".\r\n                // use integer division to reduce the precision.\r\n                require(mintExp - _magnitudeMult < 78, \"exponent > 77\"); //\r\n                mint /= 10 ** (mintExp - _magnitudeMult);\r\n                return mint;\r\n\r\n            } else {\r\n                // the (negative) exponent is smaller than the given parameter for \"shifting left\".\r\n                //no need for underflow check\r\n                _magnitudeMult = _magnitudeMult - mintExp;\r\n            }\r\n        } else {\r\n            // e^(+x), positive exponent or no exponent\r\n            // just shift left as many times as indicated by the exponent and the shift parameter\r\n            _magnitudeMult = _magnitudeMult.add(mintExp);\r\n          }\r\n\r\n          if (_magnitudeMult >= decMinted) {\r\n              // the decimals are fewer or equal than the shifts: use all of them\r\n              // shift number and add the decimals at the end\r\n              // include decimals if present in the original input\r\n              require(decMinted < 78, \"more than 77 decimal digits parsed\"); //\r\n              mint = mint.mul(10 ** (decMinted));\r\n              mint = mint.add(mintDec);\r\n              //// add zeros at the end if the decimals were fewer than #_magnitudeMult\r\n              require(_magnitudeMult - decMinted < 78, \"exponent > 77\"); //\r\n              mint = mint.mul(10 ** (_magnitudeMult - decMinted));\r\n          } else {\r\n              // the decimals are more than the #_magnitudeMult shifts\r\n              // use only the ones needed, discard the rest\r\n              decMinted -= _magnitudeMult;\r\n              require(decMinted < 78, \"more than 77 decimal digits parsed\"); //\r\n              mintDec /= 10 ** (decMinted);\r\n              // shift number and add the decimals at the end\r\n              require(_magnitudeMult < 78, \"more than 77 decimal digits parsed\"); //\r\n              mint = mint.mul(10 ** (_magnitudeMult));\r\n              mint = mint.add(mintDec);\r\n          }\r\n\r\n        return mint;\r\n    }\r\n}\r\n\r\n/**\r\n * This method was modified from the GPLv3 solidity code found in this repository\r\n * https://github.com/vcealicu/melonport-price-feed/blob/master/pricefeed/PriceFeed.sol\r\n */\r\n\r\n/// @title Base64 provides base 64 decoding functionality.\r\ncontract Base64 {\r\n    bytes constant BASE64_DECODE_CHAR = hex\"000000000000000000000000000000000000000000000000000000000000000000000000000000000000003e003e003f3435363738393a3b3c3d00000000000000000102030405060708090a0b0c0d0e0f10111213141516171819000000003f001a1b1c1d1e1f202122232425262728292a2b2c2d2e2f30313233\";\r\n\r\n    /// @return decoded array of bytes.\r\n    /// @param _encoded base 64 encoded array of bytes.\r\n    function _base64decode(bytes _encoded) internal pure returns (bytes) {\r\n        byte v1;\r\n        byte v2;\r\n        byte v3;\r\n        byte v4;\r\n        uint length = _encoded.length;\r\n        bytes memory result = new bytes(length);\r\n        uint index;\r\n\r\n        // base64 encoded strings can't be length 0 and they must be divisble by 4\r\n        require(length > 0  && length % 4 == 0, \"invalid base64 encoding\");\r\n\r\n          if (keccak256(abi.encodePacked(_encoded[length - 2])) == keccak256(\"=\")) {\r\n              length -= 2;\r\n          } else if (keccak256(abi.encodePacked(_encoded[length - 1])) == keccak256(\"=\")) {\r\n              length -= 1;\r\n          }\r\n          uint count = length >> 2 << 2;\r\n          for (uint i = 0; i < count;) {\r\n              v1 = BASE64_DECODE_CHAR[uint(_encoded[i++])];\r\n              v2 = BASE64_DECODE_CHAR[uint(_encoded[i++])];\r\n              v3 = BASE64_DECODE_CHAR[uint(_encoded[i++])];\r\n              v4 = BASE64_DECODE_CHAR[uint(_encoded[i++])];\r\n\r\n              result[index++] = (v1 << 2 | v2 >> 4) & 255;\r\n              result[index++] = (v2 << 4 | v3 >> 2) & 255;\r\n              result[index++] = (v3 << 6 | v4) & 255;\r\n          }\r\n          if (length - count == 2) {\r\n              v1 = BASE64_DECODE_CHAR[uint(_encoded[i++])];\r\n              v2 = BASE64_DECODE_CHAR[uint(_encoded[i++])];\r\n              result[index++] = (v1 << 2 | v2 >> 4) & 255;\r\n          } else if (length - count == 3) {\r\n              v1 = BASE64_DECODE_CHAR[uint(_encoded[i++])];\r\n              v2 = BASE64_DECODE_CHAR[uint(_encoded[i++])];\r\n              v3 = BASE64_DECODE_CHAR[uint(_encoded[i++])];\r\n\r\n              result[index++] = (v1 << 2 | v2 >> 4) & 255;\r\n              result[index++] = (v2 << 4 | v3 >> 2) & 255;\r\n          }\r\n\r\n        // Set to correct length.\r\n        assembly {\r\n            mstore(result, index)\r\n        }\r\n\r\n        return result;\r\n    }\r\n}\r\n\r\n\r\n/// @title Oracle converts ERC20 token amounts into equivalent ether amounts based on cryptocurrency exchange rates.\r\ninterface IOracle {\r\n    function convert(address, uint) external view returns (bool, uint);\r\n}\r\n\r\n\r\n/// @title Oracle provides asset exchange rates and conversion functionality.\r\ncontract Oracle is usingOraclize, Base64, Date, JSON, Controllable, ParseIntScientific, IOracle {\r\n    using strings for *;\r\n    using SafeMath for uint256;\r\n\r\n\r\n    /*******************/\r\n    /*     Events     */\r\n    /*****************/\r\n\r\n    event AddedToken(address _sender, address _token, string _symbol, uint _magnitude);\r\n    event RemovedToken(address _sender, address _token);\r\n    event UpdatedTokenRate(address _sender, address _token, uint _rate);\r\n\r\n    event SetGasPrice(address _sender, uint _gasPrice);\r\n    event Converted(address _sender, address _token, uint _amount, uint _ether);\r\n\r\n    event RequestedUpdate(string _symbol);\r\n    event FailedUpdateRequest(string _reason);\r\n\r\n    event VerifiedProof(bytes _publicKey, string _result);\r\n\r\n    event SetCryptoComparePublicKey(address _sender, bytes _publicKey);\r\n\r\n    /**********************/\r\n    /*     Constants     */\r\n    /********************/\r\n\r\n    uint constant private PROOF_LEN = 165;\r\n    uint constant private ECDSA_SIG_LEN = 65;\r\n    uint constant private ENCODING_BYTES = 2;\r\n    uint constant private HEADERS_LEN = PROOF_LEN - 2 * ENCODING_BYTES - ECDSA_SIG_LEN; // 2 bytes encoding headers length + 2 for signature.\r\n    uint constant private DIGEST_BASE64_LEN = 44; //base64 encoding of the SHA256 hash (32-bytes) of the result: fixed length.\r\n    uint constant private DIGEST_OFFSET = HEADERS_LEN - DIGEST_BASE64_LEN; // the starting position of the result hash in the headers string.\r\n\r\n    uint constant private MAX_BYTE_SIZE = 256; //for calculating length encoding\r\n\r\n    struct Token {\r\n        string symbol;    // Token symbol\r\n        uint magnitude;   // 10^decimals\r\n        uint rate;        // Token exchange rate in wei\r\n        uint lastUpdate;  // Time of the last rate update\r\n        bool exists;      // Flags if the struct is empty or not\r\n    }\r\n\r\n    mapping(address => Token) public tokens;\r\n    address[] private _tokenAddresses;\r\n\r\n    bytes public APIPublicKey;\r\n    mapping(bytes32 => address) private _queryToToken;\r\n\r\n    /// @dev Construct the oracle with multiple controllers, address resolver and custom gas price.\r\n    /// @dev _resolver is the oraclize address resolver contract address.\r\n    /// @param _ens is the address of the ENS.\r\n    /// @param _controllerName is the ENS name of the Controller.\r\n    constructor(address _resolver, address _ens, bytes32 _controllerName) Controllable(_ens, _controllerName) public {\r\n        APIPublicKey = hex\"a0f4f688350018ad1b9785991c0bde5f704b005dc79972b114dbed4a615a983710bfc647ebe5a320daa28771dce6a2d104f5efa2e4a85ba3760b76d46f8571ca\";\r\n        OAR = OraclizeAddrResolverI(_resolver);\r\n        oraclize_setCustomGasPrice(10000000000);\r\n        oraclize_setProof(proofType_Native);\r\n    }\r\n\r\n    /// @dev Updates the Crypto Compare public API key.\r\n    function updateAPIPublicKey(bytes _publicKey) external onlyController {\r\n        APIPublicKey = _publicKey;\r\n        emit SetCryptoComparePublicKey(msg.sender, _publicKey);\r\n    }\r\n\r\n    /// @dev Sets the gas price used by oraclize query.\r\n    function setCustomGasPrice(uint _gasPrice) external onlyController {\r\n        oraclize_setCustomGasPrice(_gasPrice);\r\n        emit SetGasPrice(msg.sender, _gasPrice);\r\n    }\r\n\r\n    /// @dev Convert ERC20 token amount to the corresponding ether amount (used by the wallet contract).\r\n    /// @param _token ERC20 token contract address.\r\n    /// @param _amount amount of token in base units.\r\n    function convert(address _token, uint _amount) external view returns (bool, uint) {\r\n        // Store the token in memory to save map entry lookup gas.\r\n        Token storage token = tokens[_token];\r\n        // If the token exists require that its rate is not zero\r\n        if (token.exists) {\r\n            require(token.rate != 0, \"token rate is 0\");\r\n            // Safely convert the token amount to ether based on the exchange rate.\r\n            // return the value and a 'true' implying that the token is protected\r\n            return (true, _amount.mul(token.rate).div(token.magnitude));\r\n        }\r\n        // this returns a 'false' to imply that a card is not protected \r\n        return (false, 0);\r\n        \r\n    }\r\n\r\n    /// @dev Add ERC20 tokens to the list of supported tokens.\r\n    /// @param _tokens ERC20 token contract addresses.\r\n    /// @param _symbols ERC20 token names.\r\n    /// @param _magnitude 10 to the power of number of decimal places used by each ERC20 token.\r\n    /// @param _updateDate date for the token updates. This will be compared to when oracle updates are received.\r\n    function addTokens(address[] _tokens, bytes32[] _symbols, uint[] _magnitude, uint _updateDate) external onlyController {\r\n        // Require that all parameters have the same length.\r\n        require(_tokens.length == _symbols.length && _tokens.length == _magnitude.length, \"parameter lengths do not match\");\r\n        // Add each token to the list of supported tokens.\r\n        for (uint i = 0; i < _tokens.length; i++) {\r\n            // Require that the token doesn't already exist.\r\n            address token = _tokens[i];\r\n            require(!tokens[token].exists, \"token already exists\");\r\n            // Store the intermediate values.\r\n            string memory symbol = _symbols[i].toSliceB32().toString();\r\n            uint magnitude = _magnitude[i];\r\n            // Add the token to the token list.\r\n            tokens[token] = Token({\r\n                symbol : symbol,\r\n                magnitude : magnitude,\r\n                rate : 0,\r\n                exists : true,\r\n                lastUpdate: _updateDate\r\n            });\r\n            // Add the token address to the address list.\r\n            _tokenAddresses.push(token);\r\n            // Emit token addition event.\r\n            emit AddedToken(msg.sender, token, symbol, magnitude);\r\n        }\r\n    }\r\n\r\n    /// @dev Remove ERC20 tokens from the list of supported tokens.\r\n    /// @param _tokens ERC20 token contract addresses.\r\n    function removeTokens(address[] _tokens) external onlyController {\r\n        // Delete each token object from the list of supported tokens based on the addresses provided.\r\n        for (uint i = 0; i < _tokens.length; i++) {\r\n            //token must exist, reverts on duplicates as well\r\n            require(tokens[_tokens[i]].exists, \"token does not exist\");\r\n            // Store the token address.\r\n            address token = _tokens[i];\r\n            // Delete the token object.\r\n            delete tokens[token];\r\n            // Remove the token address from the address list.\r\n            for (uint j = 0; j < _tokenAddresses.length.sub(1); j++) {\r\n                if (_tokenAddresses[j] == token) {\r\n                    _tokenAddresses[j] = _tokenAddresses[_tokenAddresses.length.sub(1)];\r\n                    break;\r\n                }\r\n            }\r\n            _tokenAddresses.length--;\r\n            // Emit token removal event.\r\n            emit RemovedToken(msg.sender, token);\r\n        }\r\n    }\r\n\r\n    /// @dev Update ERC20 token exchange rate manually.\r\n    /// @param _token ERC20 token contract address.\r\n    /// @param _rate ERC20 token exchange rate in wei.\r\n    /// @param _updateDate date for the token updates. This will be compared to when oracle updates are received.\r\n    function updateTokenRate(address _token, uint _rate, uint _updateDate) external onlyController {\r\n        // Require that the token exists.\r\n        require(tokens[_token].exists, \"token does not exist\");\r\n        // Update the token's rate.\r\n        tokens[_token].rate = _rate;\r\n        // Update the token's last update timestamp.\r\n        tokens[_token].lastUpdate = _updateDate;\r\n        // Emit the rate update event.\r\n        emit UpdatedTokenRate(msg.sender, _token, _rate);\r\n    }\r\n\r\n    /// @dev Update ERC20 token exchange rates for all supported tokens.\r\n    //// @param _gasLimit the gas limit is passed, this is used for the Oraclize callback\r\n    function updateTokenRates(uint _gasLimit) external payable onlyController {\r\n        _updateTokenRates(_gasLimit);\r\n    }\r\n\r\n    //// @dev Withdraw ether from the smart contract to the specified account.\r\n    function withdraw(address _to, uint _amount) external onlyController {\r\n        _to.transfer(_amount);\r\n    }\r\n\r\n    //// @dev Handle Oraclize query callback and verifiy the provided origin proof.\r\n    //// @param _queryID Oraclize query ID.\r\n    //// @param _result query result in JSON format.\r\n    //// @param _proof origin proof from crypto compare.\r\n    // solium-disable-next-line mixedcase\r\n    function __callback(bytes32 _queryID, string _result, bytes _proof) public {\r\n        // Require that the caller is the Oraclize contract.\r\n        require(msg.sender == oraclize_cbAddress(), \"sender is not oraclize\");\r\n        // Use the query ID to find the matching token address.\r\n        address _token = _queryToToken[_queryID];\r\n        require(_token != address(0), \"queryID matches to address 0\");\r\n        // Get the corresponding token object.\r\n        Token storage token = tokens[_token];\r\n\r\n        bool valid;\r\n        uint timestamp;\r\n        (valid, timestamp) = _verifyProof(_result, _proof, APIPublicKey, token.lastUpdate);\r\n\r\n        // Require that the proof is valid.\r\n        if (valid) {\r\n            // Parse the JSON result to get the rate in wei.\r\n            token.rate = _parseIntScientificWei(parseRate(_result));\r\n            // Set the update time of the token rate.\r\n            token.lastUpdate = timestamp;\r\n            // Remove query from the list.\r\n            delete _queryToToken[_queryID];\r\n            // Emit the rate update event.\r\n            emit UpdatedTokenRate(msg.sender, _token, token.rate);\r\n        }\r\n    }\r\n\r\n    /// @dev Re-usable helper function that performs the Oraclize Query.\r\n    //// @param _gasLimit the gas limit is passed, this is used for the Oraclize callback\r\n    function _updateTokenRates(uint _gasLimit) private {\r\n        // Check if there are any existing tokens.\r\n        if (_tokenAddresses.length == 0) {\r\n            // Emit a query failure event.\r\n            emit FailedUpdateRequest(\"no tokens\");\r\n        // Check if the contract has enough Ether to pay for the query.\r\n        } else if (oraclize_getPrice(\"URL\") * _tokenAddresses.length > address(this).balance) {\r\n            // Emit a query failure event.\r\n            emit FailedUpdateRequest(\"insufficient balance\");\r\n        } else {\r\n            // Set up the cryptocompare API query strings.\r\n            strings.slice memory apiPrefix = \"https://min-api.cryptocompare.com/data/price?fsym=\".toSlice();\r\n            strings.slice memory apiSuffix = \"&tsyms=ETH&sign=true\".toSlice();\r\n\r\n            // Create a new oraclize query for each supported token.\r\n            for (uint i = 0; i < _tokenAddresses.length; i++) {\r\n                // Store the token symbol used in the query.\r\n                strings.slice memory symbol = tokens[_tokenAddresses[i]].symbol.toSlice();\r\n                // Create a new oraclize query from the component strings.\r\n                bytes32 queryID = oraclize_query(\"URL\", apiPrefix.concat(symbol).toSlice().concat(apiSuffix), _gasLimit);\r\n                // Store the query ID together with the associated token address.\r\n                _queryToToken[queryID] = _tokenAddresses[i];\r\n                // Emit the query success event.\r\n                emit RequestedUpdate(symbol.toString());\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @dev Verify the origin proof returned by the cryptocompare API.\r\n    /// @param _result query result in JSON format.\r\n    /// @param _proof origin proof from cryptocompare.\r\n    /// @param _publicKey cryptocompare public key.\r\n    /// @param _lastUpdate timestamp of the last time the requested token was updated.\r\n    function _verifyProof(string _result, bytes _proof, bytes _publicKey, uint _lastUpdate) private returns (bool, uint) {\r\n\r\n        //expecting fixed length proofs\r\n        if (_proof.length != PROOF_LEN)\r\n          revert(\"invalid proof length\");\r\n\r\n        //proof should be 65 bytes long: R (32 bytes) + S (32 bytes) + v (1 byte)\r\n        if (uint(_proof[1]) != ECDSA_SIG_LEN)\r\n          revert(\"invalid signature length\");\r\n\r\n        bytes memory signature = new bytes(ECDSA_SIG_LEN);\r\n\r\n        signature = copyBytes(_proof, 2, ECDSA_SIG_LEN, signature, 0);\r\n\r\n        // Extract the headers, big endian encoding of headers length\r\n        if (uint(_proof[ENCODING_BYTES + ECDSA_SIG_LEN]) * MAX_BYTE_SIZE + uint(_proof[ENCODING_BYTES + ECDSA_SIG_LEN + 1]) != HEADERS_LEN)\r\n          revert(\"invalid headers length\");\r\n\r\n        bytes memory headers = new bytes(HEADERS_LEN);\r\n        headers = copyBytes(_proof, 2*ENCODING_BYTES + ECDSA_SIG_LEN, HEADERS_LEN, headers, 0);\r\n\r\n        // Check if the signature is valid and if the signer address is matching.\r\n        if (!_verifySignature(headers, signature, _publicKey)) {\r\n            revert(\"invalid signature\");\r\n        }\r\n\r\n        // Check if the date is valid.\r\n        bytes memory dateHeader = new bytes(20);\r\n        //keep only the relevant string(e.g. \"16 Nov 2018 16:22:18\")\r\n        dateHeader = copyBytes(headers, 11, 20, dateHeader, 0);\r\n\r\n        bool dateValid;\r\n        uint timestamp;\r\n        (dateValid, timestamp) = _verifyDate(string(dateHeader), _lastUpdate);\r\n\r\n        // Check whether the date returned is valid or not\r\n        if (!dateValid)\r\n            revert(\"invalid date\");\r\n\r\n        // Check if the signed digest hash matches the result hash.\r\n        bytes memory digest = new bytes(DIGEST_BASE64_LEN);\r\n        digest = copyBytes(headers, DIGEST_OFFSET, DIGEST_BASE64_LEN, digest, 0);\r\n\r\n        if (keccak256(abi.encodePacked(sha256(abi.encodePacked(_result)))) != keccak256(_base64decode(digest)))\r\n          revert(\"result hash not matching\");\r\n\r\n        emit VerifiedProof(_publicKey, _result);\r\n        return (true, timestamp);\r\n    }\r\n\r\n    /// @dev Verify the HTTP headers and the signature\r\n    /// @param _headers HTTP headers provided by the cryptocompare api\r\n    /// @param _signature signature provided by the cryptocompare api\r\n    /// @param _publicKey cryptocompare public key.\r\n    function _verifySignature(bytes _headers, bytes _signature, bytes _publicKey) private returns (bool) {\r\n        address signer;\r\n        bool signatureOK;\r\n\r\n        // Checks if the signature is valid by hashing the headers\r\n        (signatureOK, signer) = ecrecovery(sha256(_headers), _signature);\r\n        return signatureOK && signer == address(keccak256(_publicKey));\r\n    }\r\n\r\n    /// @dev Verify the signed HTTP date header.\r\n    /// @param _dateHeader extracted date string e.g. Wed, 12 Sep 2018 15:18:14 GMT.\r\n    /// @param _lastUpdate timestamp of the last time the requested token was updated.\r\n    function _verifyDate(string _dateHeader, uint _lastUpdate) private pure returns (bool, uint) {\r\n\r\n        //called by verifyProof(), _dateHeader is always a string of length = 20\r\n        assert(abi.encodePacked(_dateHeader).length == 20);\r\n\r\n        //Split the date string and get individual date components.\r\n        strings.slice memory date = _dateHeader.toSlice();\r\n        strings.slice memory timeDelimiter = \":\".toSlice();\r\n        strings.slice memory dateDelimiter = \" \".toSlice();\r\n\r\n        uint day = _parseIntScientific(date.split(dateDelimiter).toString());\r\n        require(day > 0 && day < 32, \"day error\");\r\n\r\n        uint month = _monthToNumber(date.split(dateDelimiter).toString());\r\n        require(month > 0 && month < 13, \"month error\");\r\n\r\n        uint year = _parseIntScientific(date.split(dateDelimiter).toString());\r\n        require(year > 2017 && year < 3000, \"year error\");\r\n\r\n        uint hour = _parseIntScientific(date.split(timeDelimiter).toString());\r\n        require(hour < 25, \"hour error\");\r\n\r\n        uint minute = _parseIntScientific(date.split(timeDelimiter).toString());\r\n        require(minute < 60, \"minute error\");\r\n\r\n        uint second = _parseIntScientific(date.split(timeDelimiter).toString());\r\n        require(second < 60, \"second error\");\r\n\r\n        uint timestamp = year * (10 ** 10) + month * (10 ** 8) + day * (10 ** 6) + hour * (10 ** 4) + minute * (10 ** 2) + second;\r\n\r\n        return (timestamp > _lastUpdate, timestamp);\r\n    }\r\n}\r\n\r\n/// @title Ownable has an owner address and provides basic authorization control functions.\r\n/// This contract is modified version of the MIT OpenZepplin Ownable contract \r\n/// This contract doesn't allow for multiple changeOwner operations\r\n/// https://github.com/OpenZeppelin/openzeppelin-solidity/blob/master/contracts/ownership/Ownable.sol\r\ncontract Ownable {\r\n    event TransferredOwnership(address _from, address _to);\r\n\r\n    address private _owner;\r\n    bool private _isTransferable;\r\n\r\n    /// @dev Constructor sets the original owner of the contract and whether or not it is one time transferable.\r\n    constructor(address _account, bool _transferable) internal {\r\n        _owner = _account;\r\n        _isTransferable = _transferable;\r\n        emit TransferredOwnership(address(0), _account);\r\n    }\r\n\r\n    /// @dev Reverts if called by any account other than the owner.\r\n    modifier onlyOwner() {\r\n        require(_isOwner(), \"sender is not an owner\");\r\n        _;\r\n    }\r\n\r\n    /// @dev Allows the current owner to transfer control of the contract to a new address.\r\n    /// @param _account address to transfer ownership to.\r\n    function transferOwnership(address _account) external onlyOwner {\r\n        // Require that the ownership is transferable.\r\n        require(_isTransferable, \"ownership is not transferable\");\r\n        // Require that the new owner is not the zero address.\r\n        require(_account != address(0), \"owner cannot be set to zero address\");\r\n        // Set the transferable flag to false.\r\n        _isTransferable = false;\r\n        // Emit the ownership transfer event.\r\n        emit TransferredOwnership(_owner, _account);\r\n        // Set the owner to the provided address.\r\n        _owner = _account;\r\n    }\r\n\r\n    /// @dev Allows the current owner to relinquish control of the contract.\r\n    /// @notice Renouncing to ownership will leave the contract without an owner and unusable.\r\n    /// It will not be possible to call the functions with the `onlyOwner` modifier anymore.\r\n    function renounceOwnership() public onlyOwner {\r\n        // Require that the ownership is transferable.\r\n        require(_isTransferable, \"ownership is not transferable\");\r\n        emit TransferredOwnership(_owner, address(0));\r\n        // note that this could be terminal\r\n        _owner = address(0);\r\n    }\r\n\r\n    /// @return the address of the owner.\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /// @return true if the ownership is transferable.\r\n    function isTransferable() public view returns (bool) {\r\n        return _isTransferable;\r\n    }\r\n\r\n    /// @return true if sender is the owner of the contract.\r\n    function _isOwner() internal view returns (bool) {\r\n        return msg.sender == _owner;\r\n    }\r\n}\r\n\r\n/**\r\n * BSD 2-Clause License\r\n * \r\n * Copyright (c) 2018, True Names Limited\r\n * All rights reserved.\r\n * \r\n * Redistribution and use in source and binary forms, with or without\r\n * modification, are permitted provided that the following conditions are met:\r\n * \r\n * * Redistributions of source code must retain the above copyright notice, this\r\n *   list of conditions and the following disclaimer.\r\n * \r\n * * Redistributions in binary form must reproduce the above copyright notice,\r\n *   this list of conditions and the following disclaimer in the documentation\r\n *   and/or other materials provided with the distribution.\r\n * \r\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\r\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\r\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\r\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\r\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\r\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\r\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\r\n * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\r\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\r\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n*/\r\n\r\n/**\r\n * A simple resolver anyone can use; only allows the owner of a node to set its\r\n * address.\r\n */\r\ncontract PublicResolver {\r\n\r\n    bytes4 constant INTERFACE_META_ID = 0x01ffc9a7;\r\n    bytes4 constant ADDR_INTERFACE_ID = 0x3b3b57de;\r\n    bytes4 constant CONTENT_INTERFACE_ID = 0xd8389dc5;\r\n    bytes4 constant NAME_INTERFACE_ID = 0x691f3431;\r\n    bytes4 constant ABI_INTERFACE_ID = 0x2203ab56;\r\n    bytes4 constant PUBKEY_INTERFACE_ID = 0xc8690233;\r\n    bytes4 constant TEXT_INTERFACE_ID = 0x59d1d43c;\r\n    bytes4 constant MULTIHASH_INTERFACE_ID = 0xe89401a1;\r\n\r\n    event AddrChanged(bytes32 indexed node, address a);\r\n    event ContentChanged(bytes32 indexed node, bytes32 hash);\r\n    event NameChanged(bytes32 indexed node, string name);\r\n    event ABIChanged(bytes32 indexed node, uint256 indexed contentType);\r\n    event PubkeyChanged(bytes32 indexed node, bytes32 x, bytes32 y);\r\n    event TextChanged(bytes32 indexed node, string indexedKey, string key);\r\n    event MultihashChanged(bytes32 indexed node, bytes hash);\r\n\r\n    struct PublicKey {\r\n        bytes32 x;\r\n        bytes32 y;\r\n    }\r\n\r\n    struct Record {\r\n        address addr;\r\n        bytes32 content;\r\n        string name;\r\n        PublicKey pubkey;\r\n        mapping(string=>string) text;\r\n        mapping(uint256=>bytes) abis;\r\n        bytes multihash;\r\n    }\r\n\r\n    ENS ens;\r\n\r\n    mapping (bytes32 => Record) records;\r\n\r\n    modifier only_owner(bytes32 node) {\r\n        require(ens.owner(node) == msg.sender);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * Constructor.\r\n     * @param ensAddr The ENS registrar contract.\r\n     */\r\n    constructor(ENS ensAddr) public {\r\n        ens = ensAddr;\r\n    }\r\n\r\n    /**\r\n     * Sets the address associated with an ENS node.\r\n     * May only be called by the owner of that node in the ENS registry.\r\n     * @param node The node to update.\r\n     * @param addr The address to set.\r\n     */\r\n    function setAddr(bytes32 node, address addr) public only_owner(node) {\r\n        records[node].addr = addr;\r\n        emit AddrChanged(node, addr);\r\n    }\r\n\r\n    /**\r\n     * Sets the content hash associated with an ENS node.\r\n     * May only be called by the owner of that node in the ENS registry.\r\n     * Note that this resource type is not standardized, and will likely change\r\n     * in future to a resource type based on multihash.\r\n     * @param node The node to update.\r\n     * @param hash The content hash to set\r\n     */\r\n    function setContent(bytes32 node, bytes32 hash) public only_owner(node) {\r\n        records[node].content = hash;\r\n        emit ContentChanged(node, hash);\r\n    }\r\n\r\n    /**\r\n     * Sets the multihash associated with an ENS node.\r\n     * May only be called by the owner of that node in the ENS registry.\r\n     * @param node The node to update.\r\n     * @param hash The multihash to set\r\n     */\r\n    function setMultihash(bytes32 node, bytes hash) public only_owner(node) {\r\n        records[node].multihash = hash;\r\n        emit MultihashChanged(node, hash);\r\n    }\r\n    \r\n    /**\r\n     * Sets the name associated with an ENS node, for reverse records.\r\n     * May only be called by the owner of that node in the ENS registry.\r\n     * @param node The node to update.\r\n     * @param name The name to set.\r\n     */\r\n    function setName(bytes32 node, string name) public only_owner(node) {\r\n        records[node].name = name;\r\n        emit NameChanged(node, name);\r\n    }\r\n\r\n    /**\r\n     * Sets the ABI associated with an ENS node.\r\n     * Nodes may have one ABI of each content type. To remove an ABI, set it to\r\n     * the empty string.\r\n     * @param node The node to update.\r\n     * @param contentType The content type of the ABI\r\n     * @param data The ABI data.\r\n     */\r\n    function setABI(bytes32 node, uint256 contentType, bytes data) public only_owner(node) {\r\n        // Content types must be powers of 2\r\n        require(((contentType - 1) & contentType) == 0);\r\n        \r\n        records[node].abis[contentType] = data;\r\n        emit ABIChanged(node, contentType);\r\n    }\r\n    \r\n    /**\r\n     * Sets the SECP256k1 public key associated with an ENS node.\r\n     * @param node The ENS node to query\r\n     * @param x the X coordinate of the curve point for the public key.\r\n     * @param y the Y coordinate of the curve point for the public key.\r\n     */\r\n    function setPubkey(bytes32 node, bytes32 x, bytes32 y) public only_owner(node) {\r\n        records[node].pubkey = PublicKey(x, y);\r\n        emit PubkeyChanged(node, x, y);\r\n    }\r\n\r\n    /**\r\n     * Sets the text data associated with an ENS node and key.\r\n     * May only be called by the owner of that node in the ENS registry.\r\n     * @param node The node to update.\r\n     * @param key The key to set.\r\n     * @param value The text data value to set.\r\n     */\r\n    function setText(bytes32 node, string key, string value) public only_owner(node) {\r\n        records[node].text[key] = value;\r\n        emit TextChanged(node, key, key);\r\n    }\r\n\r\n    /**\r\n     * Returns the text data associated with an ENS node and key.\r\n     * @param node The ENS node to query.\r\n     * @param key The text data key to query.\r\n     * @return The associated text data.\r\n     */\r\n    function text(bytes32 node, string key) public view returns (string) {\r\n        return records[node].text[key];\r\n    }\r\n\r\n    /**\r\n     * Returns the SECP256k1 public key associated with an ENS node.\r\n     * Defined in EIP 619.\r\n     * @param node The ENS node to query\r\n     * @return x, y the X and Y coordinates of the curve point for the public key.\r\n     */\r\n    function pubkey(bytes32 node) public view returns (bytes32 x, bytes32 y) {\r\n        return (records[node].pubkey.x, records[node].pubkey.y);\r\n    }\r\n\r\n    /**\r\n     * Returns the ABI associated with an ENS node.\r\n     * Defined in EIP205.\r\n     * @param node The ENS node to query\r\n     * @param contentTypes A bitwise OR of the ABI formats accepted by the caller.\r\n     * @return contentType The content type of the return value\r\n     * @return data The ABI data\r\n     */\r\n    function ABI(bytes32 node, uint256 contentTypes) public view returns (uint256 contentType, bytes data) {\r\n        Record storage record = records[node];\r\n        for (contentType = 1; contentType <= contentTypes; contentType <<= 1) {\r\n            if ((contentType & contentTypes) != 0 && record.abis[contentType].length > 0) {\r\n                data = record.abis[contentType];\r\n                return;\r\n            }\r\n        }\r\n        contentType = 0;\r\n    }\r\n\r\n    /**\r\n     * Returns the name associated with an ENS node, for reverse records.\r\n     * Defined in EIP181.\r\n     * @param node The ENS node to query.\r\n     * @return The associated name.\r\n     */\r\n    function name(bytes32 node) public view returns (string) {\r\n        return records[node].name;\r\n    }\r\n\r\n    /**\r\n     * Returns the content hash associated with an ENS node.\r\n     * Note that this resource type is not standardized, and will likely change\r\n     * in future to a resource type based on multihash.\r\n     * @param node The ENS node to query.\r\n     * @return The associated content hash.\r\n     */\r\n    function content(bytes32 node) public view returns (bytes32) {\r\n        return records[node].content;\r\n    }\r\n\r\n    /**\r\n     * Returns the multihash associated with an ENS node.\r\n     * @param node The ENS node to query.\r\n     * @return The associated multihash.\r\n     */\r\n    function multihash(bytes32 node) public view returns (bytes) {\r\n        return records[node].multihash;\r\n    }\r\n\r\n    /**\r\n     * Returns the address associated with an ENS node.\r\n     * @param node The ENS node to query.\r\n     * @return The associated address.\r\n     */\r\n    function addr(bytes32 node) public view returns (address) {\r\n        return records[node].addr;\r\n    }\r\n\r\n    /**\r\n     * Returns true if the resolver implements the interface specified by the provided hash.\r\n     * @param interfaceID The ID of the interface to check for.\r\n     * @return True if the contract implements the requested interface.\r\n     */\r\n    function supportsInterface(bytes4 interfaceID) public pure returns (bool) {\r\n        return interfaceID == ADDR_INTERFACE_ID ||\r\n        interfaceID == CONTENT_INTERFACE_ID ||\r\n        interfaceID == NAME_INTERFACE_ID ||\r\n        interfaceID == ABI_INTERFACE_ID ||\r\n        interfaceID == PUBKEY_INTERFACE_ID ||\r\n        interfaceID == TEXT_INTERFACE_ID ||\r\n        interfaceID == MULTIHASH_INTERFACE_ID ||\r\n        interfaceID == INTERFACE_META_ID;\r\n    }\r\n}\r\n\r\n/// @title ERC20 interface is a subset of the ERC20 specification.\r\ninterface ERC20 {\r\n    function transfer(address, uint) external returns (bool);\r\n    function balanceOf(address) external view returns (uint);\r\n}\r\n\r\n\r\n/// @title ERC165 interface specifies a standard way of querying if a contract implements an interface.\r\ninterface ERC165 {\r\n    function supportsInterface(bytes4) external view returns (bool);\r\n}\r\n\r\n\r\n/// @title Whitelist provides payee-whitelist functionality.\r\ncontract Whitelist is Controllable, Ownable {\r\n    event AddedToWhitelist(address _sender, address[] _addresses);\r\n    event SubmittedWhitelistAddition(address[] _addresses, bytes32 _hash);\r\n    event CancelledWhitelistAddition(address _sender, bytes32 _hash);\r\n\r\n    event RemovedFromWhitelist(address _sender, address[] _addresses);\r\n    event SubmittedWhitelistRemoval(address[] _addresses, bytes32 _hash);\r\n    event CancelledWhitelistRemoval(address _sender, bytes32 _hash);\r\n\r\n    mapping(address => bool) public isWhitelisted;\r\n    address[] private _pendingWhitelistAddition;\r\n    address[] private _pendingWhitelistRemoval;\r\n    bool public submittedWhitelistAddition;\r\n    bool public submittedWhitelistRemoval;\r\n    bool public initializedWhitelist;\r\n\r\n    /// @dev Check if the provided addresses contain the owner or the zero-address address.\r\n    modifier hasNoOwnerOrZeroAddress(address[] _addresses) {\r\n        for (uint i = 0; i < _addresses.length; i++) {\r\n            require(_addresses[i] != owner(), \"provided whitelist contains the owner address\");\r\n            require(_addresses[i] != address(0), \"provided whitelist contains the zero address\");\r\n        }\r\n        _;\r\n    }\r\n\r\n    /// @dev Check that neither addition nor removal operations have already been submitted.\r\n    modifier noActiveSubmission() {\r\n        require(!submittedWhitelistAddition && !submittedWhitelistRemoval, \"whitelist operation has already been submitted\");\r\n        _;\r\n    }\r\n\r\n    /// @dev Getter for pending addition array.\r\n    function pendingWhitelistAddition() external view returns(address[]) {\r\n        return _pendingWhitelistAddition;\r\n    }\r\n\r\n    /// @dev Getter for pending removal array.\r\n    function pendingWhitelistRemoval() external view returns(address[]) {\r\n        return _pendingWhitelistRemoval;\r\n    }\r\n\r\n    /// @dev Getter for pending addition/removal array hash.\r\n    function pendingWhitelistHash(address[] _pendingWhitelist) public pure returns(bytes32) {\r\n        return keccak256(abi.encodePacked(_pendingWhitelist));\r\n    }\r\n\r\n    /// @dev Add initial addresses to the whitelist.\r\n    /// @param _addresses are the Ethereum addresses to be whitelisted.\r\n    function initializeWhitelist(address[] _addresses) external onlyOwner hasNoOwnerOrZeroAddress(_addresses) {\r\n        // Require that the whitelist has not been initialized.\r\n        require(!initializedWhitelist, \"whitelist has already been initialized\");\r\n        // Add each of the provided addresses to the whitelist.\r\n        for (uint i = 0; i < _addresses.length; i++) {\r\n            isWhitelisted[_addresses[i]] = true;\r\n        }\r\n        initializedWhitelist = true;\r\n        // Emit the addition event.\r\n        emit AddedToWhitelist(msg.sender, _addresses);\r\n    }\r\n\r\n    /// @dev Add addresses to the whitelist.\r\n    /// @param _addresses are the Ethereum addresses to be whitelisted.\r\n    function submitWhitelistAddition(address[] _addresses) external onlyOwner noActiveSubmission hasNoOwnerOrZeroAddress(_addresses)  {\r\n        // Require that the whitelist has been initialized.\r\n        require(initializedWhitelist, \"whitelist has not been initialized\");\r\n        // Set the provided addresses to the pending addition addresses.\r\n        _pendingWhitelistAddition = _addresses;\r\n        // Flag the operation as submitted.\r\n        submittedWhitelistAddition = true;\r\n        // Emit the submission event.\r\n        emit SubmittedWhitelistAddition(_addresses, pendingWhitelistHash(_pendingWhitelistAddition));\r\n    }\r\n\r\n    /// @dev Confirm pending whitelist addition.\r\n    function confirmWhitelistAddition(bytes32 _hash) external onlyController {\r\n        // Require that the whitelist addition has been submitted.\r\n        require(submittedWhitelistAddition, \"whitelist addition has not been submitted\");\r\n\r\n        // Require that confirmation hash and the hash of the pending whitelist addition match\r\n        require(_hash == pendingWhitelistHash(_pendingWhitelistAddition), \"hash of the pending whitelist addition do not match\");\r\n\r\n        // Whitelist pending addresses.\r\n        for (uint i = 0; i < _pendingWhitelistAddition.length; i++) {\r\n            isWhitelisted[_pendingWhitelistAddition[i]] = true;\r\n        }\r\n        // Emit the addition event.\r\n        emit AddedToWhitelist(msg.sender, _pendingWhitelistAddition);\r\n        // Reset pending addresses.\r\n        delete _pendingWhitelistAddition;\r\n        // Reset the submission flag.\r\n        submittedWhitelistAddition = false;\r\n    }\r\n\r\n    /// @dev Cancel pending whitelist addition.\r\n    function cancelWhitelistAddition(bytes32 _hash) external onlyController {\r\n        // Require that confirmation hash and the hash of the pending whitelist addition match\r\n        require(_hash == pendingWhitelistHash(_pendingWhitelistAddition), \"hash of the pending whitelist addition does not match\");\r\n        // Reset pending addresses.\r\n        delete _pendingWhitelistAddition;\r\n        // Reset the submitted operation flag.\r\n        submittedWhitelistAddition = false;\r\n        // Emit the cancellation event.\r\n        emit CancelledWhitelistAddition(msg.sender, _hash);\r\n    }\r\n\r\n    /// @dev Remove addresses from the whitelist.\r\n    /// @param _addresses are the Ethereum addresses to be removed.\r\n    function submitWhitelistRemoval(address[] _addresses) external onlyOwner noActiveSubmission {\r\n        // Add the provided addresses to the pending addition list.\r\n        _pendingWhitelistRemoval = _addresses;\r\n        // Flag the operation as submitted.\r\n        submittedWhitelistRemoval = true;\r\n        // Emit the submission event.\r\n        emit SubmittedWhitelistRemoval(_addresses, pendingWhitelistHash(_pendingWhitelistRemoval));\r\n    }\r\n\r\n    /// @dev Confirm pending removal of whitelisted addresses.\r\n    function confirmWhitelistRemoval(bytes32 _hash) external onlyController {\r\n        // Require that the pending whitelist is not empty and the operation has been submitted.\r\n        require(submittedWhitelistRemoval, \"whitelist removal has not been submitted\");\r\n        require(_pendingWhitelistRemoval.length > 0, \"pending whitelist removal is empty\");\r\n        // Require that confirmation hash and the hash of the pending whitelist removal match\r\n        require(_hash == pendingWhitelistHash(_pendingWhitelistRemoval), \"hash of the pending whitelist removal does not match the confirmed hash\");\r\n        // Remove pending addresses.\r\n        for (uint i = 0; i < _pendingWhitelistRemoval.length; i++) {\r\n            isWhitelisted[_pendingWhitelistRemoval[i]] = false;\r\n        }\r\n        // Emit the removal event.\r\n        emit RemovedFromWhitelist(msg.sender, _pendingWhitelistRemoval);\r\n        // Reset pending addresses.\r\n        delete _pendingWhitelistRemoval;\r\n        // Reset the submission flag.\r\n        submittedWhitelistRemoval = false;\r\n    }\r\n\r\n    /// @dev Cancel pending removal of whitelisted addresses.\r\n    function cancelWhitelistRemoval(bytes32 _hash) external onlyController {\r\n        // Require that confirmation hash and the hash of the pending whitelist removal match\r\n        require(_hash == pendingWhitelistHash(_pendingWhitelistRemoval), \"hash of the pending whitelist removal does not match\");\r\n        // Reset pending addresses.\r\n        delete _pendingWhitelistRemoval;\r\n        // Reset the submitted operation flag.\r\n        submittedWhitelistRemoval = false;\r\n        // Emit the cancellation event.\r\n        emit CancelledWhitelistRemoval(msg.sender, _hash);\r\n    }\r\n}\r\n\r\n\r\n//// @title SpendLimit provides daily spend limit functionality.\r\ncontract SpendLimit is Controllable, Ownable {\r\n    event SetSpendLimit(address _sender, uint _amount);\r\n    event SubmittedSpendLimitChange(uint _amount);\r\n    event CancelledSpendLimitChange(address _sender, uint _amount);\r\n\r\n    using SafeMath for uint256;\r\n\r\n    uint public spendLimit;\r\n    uint private _spendLimitDay;\r\n    uint private _spendAvailable;\r\n\r\n    uint public pendingSpendLimit;\r\n    bool public submittedSpendLimit;\r\n    bool public initializedSpendLimit;\r\n\r\n    /// @dev Constructor initializes the daily spend limit in wei.\r\n    constructor(uint _spendLimit) internal {\r\n        spendLimit = _spendLimit;\r\n        _spendLimitDay = now;\r\n        _spendAvailable = spendLimit;\r\n    }\r\n\r\n    /// @dev Returns the available daily balance - accounts for daily limit reset.\r\n    /// @return amount of ether in wei.\r\n    function spendAvailable() public view returns (uint) {\r\n        if (now > _spendLimitDay + 24 hours) {\r\n            return spendLimit;\r\n        } else {\r\n            return _spendAvailable;\r\n        }\r\n    }\r\n\r\n    /// @dev Initialize a daily spend (aka transfer) limit for non-whitelisted addresses.\r\n    /// @param _amount is the daily limit amount in wei.\r\n    function initializeSpendLimit(uint _amount) external onlyOwner {\r\n        // Require that the spend limit has not been initialized.\r\n        require(!initializedSpendLimit, \"spend limit has already been initialized\");\r\n        // Modify spend limit based on the provided value.\r\n        _modifySpendLimit(_amount);\r\n        // Flag the operation as initialized.\r\n        initializedSpendLimit = true;\r\n        // Emit the set limit event.\r\n        emit SetSpendLimit(msg.sender, _amount);\r\n    }\r\n\r\n    /// @dev Set a daily transfer limit for non-whitelisted addresses.\r\n    /// @param _amount is the daily limit amount in wei.\r\n    function submitSpendLimit(uint _amount) external onlyOwner {\r\n        // Require that the spend limit has been initialized.\r\n        require(initializedSpendLimit, \"spend limit has not been initialized\");\r\n        // Require that the operation has been submitted.\r\n        require(!submittedSpendLimit, \"spend limit has already been submitted\");\r\n        // Assign the provided amount to pending daily limit change.\r\n        pendingSpendLimit = _amount;\r\n        // Flag the operation as submitted.\r\n        submittedSpendLimit = true;\r\n        // Emit the submission event.\r\n        emit SubmittedSpendLimitChange(_amount);\r\n    }\r\n\r\n    /// @dev Confirm pending set daily limit operation.\r\n    function confirmSpendLimit(uint _amount) external onlyController {\r\n        // Require that the operation has been submitted.\r\n        require(submittedSpendLimit, \"spend limit has not been submitted\");\r\n        // Require that pending and confirmed spend limit are the same\r\n        require(pendingSpendLimit == _amount, \"confirmed and submitted spend limits dont match\");\r\n        // Modify spend limit based on the pending value.\r\n        _modifySpendLimit(pendingSpendLimit);\r\n        // Emit the set limit event.\r\n        emit SetSpendLimit(msg.sender, pendingSpendLimit);\r\n        // Reset the submission flag.\r\n        submittedSpendLimit = false;\r\n        // Reset pending daily limit.\r\n        pendingSpendLimit = 0;\r\n    }\r\n\r\n    /// @dev Cancel pending set daily limit operation.\r\n    function cancelSpendLimit(uint _amount) external onlyController {\r\n        // Require that pending and confirmed spend limit are the same\r\n        require(pendingSpendLimit == _amount, \"pending and cancelled spend limits dont match\");\r\n        // Reset pending daily limit.\r\n        pendingSpendLimit = 0;\r\n        // Reset the submitted operation flag.\r\n        submittedSpendLimit = false;\r\n        // Emit the cancellation event.\r\n        emit CancelledSpendLimitChange(msg.sender, _amount);\r\n    }\r\n\r\n    // @dev Setter method for the available daily spend limit.\r\n    function _setSpendAvailable(uint _amount) internal {\r\n        _spendAvailable = _amount;\r\n    }\r\n\r\n    /// @dev Update available spend limit based on the daily reset.\r\n    function _updateSpendAvailable() internal {\r\n        if (now > _spendLimitDay.add(24 hours)) {\r\n            // Advance the current day by how many days have passed.\r\n            uint extraDays = now.sub(_spendLimitDay).div(24 hours);\r\n            _spendLimitDay = _spendLimitDay.add(extraDays.mul(24 hours));\r\n            // Set the available limit to the current spend limit.\r\n            _spendAvailable = spendLimit;\r\n        }\r\n    }\r\n\r\n    /// @dev Modify the spend limit and spend available based on the provided value.\r\n    /// @dev _amount is the daily limit amount in wei.\r\n    function _modifySpendLimit(uint _amount) private {\r\n        // Account for the spend limit daily reset.\r\n        _updateSpendAvailable();\r\n        // Set the daily limit to the provided amount.\r\n        spendLimit = _amount;\r\n        // Lower the available limit if it's higher than the new daily limit.\r\n        if (_spendAvailable > spendLimit) {\r\n            _spendAvailable = spendLimit;\r\n        }\r\n    }\r\n}\r\n\r\n\r\n//// @title Asset store with extra security features.\r\ncontract Vault is Whitelist, SpendLimit, ERC165 {\r\n    event Received(address _from, uint _amount);\r\n    event Transferred(address _to, address _asset, uint _amount);\r\n\r\n    using SafeMath for uint256;\r\n\r\n    /// @dev Supported ERC165 interface ID.\r\n    bytes4 private constant _ERC165_INTERFACE_ID = 0x01ffc9a7; // solium-disable-line uppercase\r\n\r\n    /// @dev ENS points to the ENS registry smart contract.\r\n    ENS private _ENS;\r\n    /// @dev Is the registered ENS name of the oracle contract.\r\n    bytes32 private _node;\r\n\r\n    /// @dev Constructor initializes the vault with an owner address and spend limit. It also sets up the oracle and controller contracts.\r\n    /// @param _owner is the owner account of the wallet contract.\r\n    /// @param _transferable indicates whether the contract ownership can be transferred.\r\n    /// @param _ens is the ENS public registry contract address.\r\n    /// @param _oracleName is the ENS name of the Oracle.\r\n    /// @param _controllerName is the ENS name of the controller.\r\n    /// @param _spendLimit is the initial spend limit.\r\n    constructor(address _owner, bool _transferable, address _ens, bytes32 _oracleName, bytes32 _controllerName, uint _spendLimit) SpendLimit(_spendLimit) Ownable(_owner, _transferable) Controllable(_ens, _controllerName) public {\r\n        _ENS = ENS(_ens);\r\n        _node = _oracleName;\r\n    }\r\n\r\n    /// @dev Checks if the value is not zero.\r\n    modifier isNotZero(uint _value) {\r\n        require(_value != 0, \"provided value cannot be zero\");\r\n        _;\r\n    }\r\n\r\n    /// @dev Ether can be deposited from any source, so this contract must be payable by anyone.\r\n    function() public payable {\r\n        //TODO question: Why is this check here, is it necessary or are we building into a corner?\r\n        require(msg.data.length == 0);\r\n        emit Received(msg.sender, msg.value);\r\n    }\r\n\r\n    /// @dev Returns the amount of an asset owned by the contract.\r\n    /// @param _asset address of an ERC20 token or 0x0 for ether.\r\n    /// @return balance associated with the wallet address in wei.\r\n    function balance(address _asset) external view returns (uint) {\r\n        if (_asset != address(0)) {\r\n            return ERC20(_asset).balanceOf(this);\r\n        } else {\r\n            return address(this).balance;\r\n        }\r\n    }\r\n\r\n    /// @dev Transfers the specified asset to the recipient's address.\r\n    /// @param _to is the recipient's address.\r\n    /// @param _asset is the address of an ERC20 token or 0x0 for ether.\r\n    /// @param _amount is the amount of tokens to be transferred in base units.\r\n    function transfer(address _to, address _asset, uint _amount) external onlyOwner isNotZero(_amount) {\r\n        // Checks if the _to address is not the zero-address\r\n        require(_to != address(0), \"_to address cannot be set to 0x0\");\r\n\r\n        // If address is not whitelisted, take daily limit into account.\r\n        if (!isWhitelisted[_to]) {\r\n            // Update the available spend limit.\r\n            _updateSpendAvailable();\r\n            // Convert token amount to ether value.\r\n            uint etherValue;\r\n            bool tokenExists;\r\n            if (_asset != address(0)) {\r\n                (tokenExists, etherValue) = IOracle(PublicResolver(_ENS.resolver(_node)).addr(_node)).convert(_asset, _amount);\r\n            } else {\r\n                etherValue = _amount;\r\n            }\r\n\r\n            // If token is supported by our oracle or is ether\r\n            // Check against the daily spent limit and update accordingly\r\n            if (tokenExists || _asset == address(0)) {\r\n                // Require that the value is under remaining limit.\r\n                require(etherValue <= spendAvailable(), \"transfer amount exceeds available spend limit\");\r\n                // Update the available limit.\r\n                _setSpendAvailable(spendAvailable().sub(etherValue));\r\n            }\r\n        }\r\n        // Transfer token or ether based on the provided address.\r\n        if (_asset != address(0)) {\r\n            require(ERC20(_asset).transfer(_to, _amount), \"ERC20 token transfer was unsuccessful\");\r\n        } else {\r\n            _to.transfer(_amount);\r\n        }\r\n        // Emit the transfer event.\r\n        emit Transferred(_to, _asset, _amount);\r\n    }\r\n\r\n    /// @dev Checks for interface support based on ERC165.\r\n    function supportsInterface(bytes4 interfaceID) external view returns (bool) {\r\n        return interfaceID == _ERC165_INTERFACE_ID;\r\n    }\r\n}\r\n\r\n\r\n//// @title Asset wallet with extra security features and gas top up management.\r\ncontract Wallet is Vault {\r\n    event SetTopUpLimit(address _sender, uint _amount);\r\n    event SubmittedTopUpLimitChange(uint _amount);\r\n    event CancelledTopUpLimitChange(address _sender, uint _amount);\r\n\r\n    event ToppedUpGas(address _sender, address _owner, uint _amount);\r\n\r\n    using SafeMath for uint256;\r\n\r\n    uint constant private MINIMUM_TOPUP_LIMIT = 1 finney; // solium-disable-line uppercase\r\n    uint constant private MAXIMUM_TOPUP_LIMIT = 500 finney; // solium-disable-line uppercase\r\n\r\n    uint public topUpLimit;\r\n    uint private _topUpLimitDay;\r\n    uint private _topUpAvailable;\r\n\r\n    uint public pendingTopUpLimit;\r\n    bool public submittedTopUpLimit;\r\n    bool public initializedTopUpLimit;\r\n\r\n    /// @dev Constructor initializes the wallet top up limit and the vault contract.\r\n    /// @param _owner is the owner account of the wallet contract.\r\n    /// @param _transferable indicates whether the contract ownership can be transferred.\r\n    /// @param _ens is the address of the ENS.\r\n    /// @param _oracleName is the ENS name of the Oracle.\r\n    /// @param _controllerName is the ENS name of the Controller.\r\n    /// @param _spendLimit is the initial spend limit.\r\n    constructor(address _owner, bool _transferable, address _ens, bytes32 _oracleName, bytes32 _controllerName, uint _spendLimit) Vault(_owner, _transferable, _ens, _oracleName, _controllerName, _spendLimit) public {\r\n        _topUpLimitDay = now;\r\n        topUpLimit = MAXIMUM_TOPUP_LIMIT;\r\n        _topUpAvailable = topUpLimit;\r\n    }\r\n\r\n    /// @dev Returns the available daily gas top up balance - accounts for daily limit reset.\r\n    /// @return amount of gas in wei.\r\n    function topUpAvailable() external view returns (uint) {\r\n        if (now > _topUpLimitDay + 24 hours) {\r\n            return topUpLimit;\r\n        } else {\r\n            return _topUpAvailable;\r\n        }\r\n    }\r\n\r\n    /// @dev Initialize a daily gas top up limit.\r\n    /// @param _amount is the gas top up amount in wei.\r\n    function initializeTopUpLimit(uint _amount) external onlyOwner {\r\n        // Require that the top up limit has not been initialized.\r\n        require(!initializedTopUpLimit, \"top up limit has already been initialized\");\r\n        // Require that the limit amount is within the acceptable range.\r\n        require(MINIMUM_TOPUP_LIMIT <= _amount && _amount <= MAXIMUM_TOPUP_LIMIT, \"top up amount is outside of the min/max range\");\r\n        // Modify spend limit based on the provided value.\r\n        _modifyTopUpLimit(_amount);\r\n        // Flag operation as initialized.\r\n        initializedTopUpLimit = true;\r\n        // Emit the set limit event.\r\n        emit SetTopUpLimit(msg.sender, _amount);\r\n    }\r\n\r\n    /// @dev Set a daily top up top up limit.\r\n    /// @param _amount is the daily top up limit amount in wei.\r\n    function submitTopUpLimit(uint _amount) external onlyOwner {\r\n        // Require that the top up limit has been initialized.\r\n        require(initializedTopUpLimit, \"top up limit has not been initialized\");\r\n        // Require that the operation has not been submitted.\r\n        require(!submittedTopUpLimit, \"top up limit has already been submitted\");\r\n        // Require that the limit amount is within the acceptable range.\r\n        require(MINIMUM_TOPUP_LIMIT <= _amount && _amount <= MAXIMUM_TOPUP_LIMIT, \"top up amount is outside of the min/max range\");\r\n        // Assign the provided amount to pending daily limit change.\r\n        pendingTopUpLimit = _amount;\r\n        // Flag the operation as submitted.\r\n        submittedTopUpLimit = true;\r\n        // Emit the submission event.\r\n        emit SubmittedTopUpLimitChange(_amount);\r\n    }\r\n\r\n    /// @dev Confirm pending set top up limit operation.\r\n    function confirmTopUpLimit(uint _amount) external onlyController {\r\n        // Require that the operation has been submitted.\r\n        require(submittedTopUpLimit, \"top up limit has not been submitted\");\r\n        // Assert that the pending top up limit amount is within the acceptable range.\r\n        require(MINIMUM_TOPUP_LIMIT <= pendingTopUpLimit && pendingTopUpLimit <= MAXIMUM_TOPUP_LIMIT, \"top up amount is outside the min/max range\");\r\n        // Assert that confirmed and pending topup limit are the same.\r\n        require(_amount == pendingTopUpLimit, \"confirmed and pending topup limit are not same\");\r\n        // Modify top up limit based on the pending value.\r\n        _modifyTopUpLimit(pendingTopUpLimit);\r\n        // Emit the set limit event.\r\n        emit SetTopUpLimit(msg.sender, pendingTopUpLimit);\r\n        // Reset pending daily limit.\r\n        pendingTopUpLimit = 0;\r\n        // Reset the submission flag.\r\n        submittedTopUpLimit = false;\r\n    }\r\n\r\n    /// @dev Cancel pending set top up limit operation.\r\n    function cancelTopUpLimit(uint _amount) external onlyController {\r\n        // Require that pending and confirmed spend limit are the same\r\n        require(pendingTopUpLimit == _amount, \"pending and cancelled top up limits dont match\");\r\n        // Reset pending daily limit.\r\n        pendingTopUpLimit = 0;\r\n        // Reset the submitted operation flag.\r\n        submittedTopUpLimit = false;\r\n        // Emit the cancellation event.\r\n        emit CancelledTopUpLimitChange(msg.sender, _amount);\r\n    }\r\n\r\n    /// @dev Refill owner's gas balance.\r\n    /// @dev Revert if the transaction amount is too large\r\n    /// @param _amount is the amount of ether to transfer to the owner account in wei.\r\n    function topUpGas(uint _amount) external isNotZero(_amount) {\r\n        // Require that the sender is either the owner or a controller.\r\n        require(_isOwner() || _isController(msg.sender), \"sender is neither an owner nor a controller\");\r\n        // Account for the top up limit daily reset.\r\n        _updateTopUpAvailable();\r\n        // Make sure the available top up amount is not zero.\r\n        require(_topUpAvailable != 0, \"available top up limit cannot be zero\");\r\n        // Fail if there isn't enough in the daily top up limit to perform topUp\r\n        require(_amount <= _topUpAvailable, \"available top up limit less than amount passed in\");\r\n        // Reduce the top up amount from available balance and transfer corresponding\r\n        // ether to the owner's account.\r\n        _topUpAvailable = _topUpAvailable.sub(_amount);\r\n        owner().transfer(_amount);\r\n        // Emit the gas top up event.\r\n        emit ToppedUpGas(tx.origin, owner(), _amount);\r\n    }\r\n\r\n    /// @dev Modify the top up limit and top up available based on the provided value.\r\n    /// @dev _amount is the daily limit amount in wei.\r\n    function _modifyTopUpLimit(uint _amount) private {\r\n        // Account for the top up limit daily reset.\r\n        _updateTopUpAvailable();\r\n        // Set the daily limit to the provided amount.\r\n        topUpLimit = _amount;\r\n        // Lower the available limit if it's higher than the new daily limit.\r\n        if (_topUpAvailable > topUpLimit) {\r\n            _topUpAvailable = topUpLimit;\r\n        }\r\n    }\r\n\r\n    /// @dev Update available top up limit based on the daily reset.\r\n    function _updateTopUpAvailable() private {\r\n        if (now > _topUpLimitDay.add(24 hours)) {\r\n            // Advance the current day by how many days have passed.\r\n            uint extraDays = now.sub(_topUpLimitDay).div(24 hours);\r\n            _topUpLimitDay = _topUpLimitDay.add(extraDays.mul(24 hours));\r\n            // Set the available limit to the current top up limit.\r\n            _topUpAvailable = topUpLimit;\r\n        }\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"interfaceID\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_hash\",\"type\":\"bytes32\"}],\"name\":\"cancelWhitelistAddition\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isTransferable\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"submittedWhitelistAddition\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"confirmTopUpLimit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pendingWhitelistRemoval\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"submitTopUpLimit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"isWhitelisted\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pendingWhitelistAddition\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"initializedSpendLimit\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"initializeSpendLimit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_hash\",\"type\":\"bytes32\"}],\"name\":\"confirmWhitelistAddition\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addresses\",\"type\":\"address[]\"}],\"name\":\"submitWhitelistRemoval\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"initializeTopUpLimit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pendingTopUpLimit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"cancelTopUpLimit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_pendingWhitelist\",\"type\":\"address[]\"}],\"name\":\"pendingWhitelistHash\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addresses\",\"type\":\"address[]\"}],\"name\":\"submitWhitelistAddition\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"topUpLimit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"submittedTopUpLimit\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"topUpAvailable\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"spendLimit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"initializedWhitelist\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_asset\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pendingSpendLimit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_hash\",\"type\":\"bytes32\"}],\"name\":\"confirmWhitelistRemoval\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_hash\",\"type\":\"bytes32\"}],\"name\":\"cancelWhitelistRemoval\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"submittedSpendLimit\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"submitSpendLimit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"spendAvailable\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"submittedWhitelistRemoval\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_asset\",\"type\":\"address\"}],\"name\":\"balance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"cancelSpendLimit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"topUpGas\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"confirmSpendLimit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addresses\",\"type\":\"address[]\"}],\"name\":\"initializeWhitelist\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"initializedTopUpLimit\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_transferable\",\"type\":\"bool\"},{\"name\":\"_ens\",\"type\":\"address\"},{\"name\":\"_oracleName\",\"type\":\"bytes32\"},{\"name\":\"_controllerName\",\"type\":\"bytes32\"},{\"name\":\"_spendLimit\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_sender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"SetTopUpLimit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"SubmittedTopUpLimitChange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_sender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"CancelledTopUpLimitChange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_sender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"ToppedUpGas\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"Received\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_asset\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"Transferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_sender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"SetSpendLimit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"SubmittedSpendLimitChange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_sender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"CancelledSpendLimitChange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_sender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_addresses\",\"type\":\"address[]\"}],\"name\":\"AddedToWhitelist\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_addresses\",\"type\":\"address[]\"},{\"indexed\":false,\"name\":\"_hash\",\"type\":\"bytes32\"}],\"name\":\"SubmittedWhitelistAddition\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_sender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_hash\",\"type\":\"bytes32\"}],\"name\":\"CancelledWhitelistAddition\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_sender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_addresses\",\"type\":\"address[]\"}],\"name\":\"RemovedFromWhitelist\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_addresses\",\"type\":\"address[]\"},{\"indexed\":false,\"name\":\"_hash\",\"type\":\"bytes32\"}],\"name\":\"SubmittedWhitelistRemoval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_sender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_hash\",\"type\":\"bytes32\"}],\"name\":\"CancelledWhitelistRemoval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"TransferredOwnership\",\"type\":\"event\"}]","ContractName":"Wallet","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000004283faf6df7668260d8bf1fe61c862201d2f60de0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000314159265dd8dbb310642f98f50c066173c1259b641c0900086ccfffea93c7d8b16693544f9f4ce389c6aeaa13ba5df602aa73147f2ce995617d2816b426c5c8698c5ec2952f7a34bb10f38326f74933d58936970000000000000000000000000000000000000000000000000de0b6b3a7640000","Library":"","SwarmSource":"bzzr://cd4f20f9be37fe4efd58f4dfeafff897efd05419fe9a870175a92f90a4a8656f"}]}