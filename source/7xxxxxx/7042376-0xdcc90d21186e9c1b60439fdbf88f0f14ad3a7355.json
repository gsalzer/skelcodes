{"status":"1","message":"OK","result":[{"SourceCode":"/**\r\n * Token recurring billing smart contracts, which enable recurring billing feature for ERC20-compatible tokens.\r\n * Developed by DreamTeam.GG contributors. Visit dreamteam.gg and github.com/dreamteam-gg/smart-contracts for more info.\r\n * Copyright Â© 2019 DREAMTEAM.\r\n * Licensed under the Apache License, Version 2.0 (the \"License\").\r\n */\r\n\r\npragma solidity 0.5.2;\r\n\r\ninterface ERC20CompatibleToken {\r\n    function balanceOf(address tokenOwner) external view returns (uint balance);\r\n    function allowance(address tokenOwner, address spender) external view returns (uint remaining);\r\n    function transfer (address to, uint tokens) external returns (bool success);\r\n    function transferFrom (address from, address to, uint tokens) external returns (bool success);\r\n}\r\n\r\n/**\r\n * Math operations with safety checks that throw on overflows.\r\n */\r\nlibrary SafeMath {\r\n\r\n    function mul (uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        c = a * b;\r\n        require(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function div (uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a / b;\r\n    }\r\n\r\n    function sub (uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add (uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        c = a + b;\r\n        require(c >= a);\r\n        return c;\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * Factory that creates recurring billing smart contracts for specified token.\r\n * You can enable recurring billing for your own ERC20-compatible tokens!\r\n * Find the documentation here: https://github.com/dreamteam-gg/smart-contracts#smart-contracts-documentation\r\n */\r\ncontract RecurringBillingContractFactory {\r\n\r\n    event NewRecurringBillingContractCreated(address token, address recurringBillingContract);\r\n\r\n    function newRecurringBillingContract (address tokenAddress) public returns (address recurringBillingContractAddress) {\r\n        TokenRecurringBilling rb = new TokenRecurringBilling(tokenAddress);\r\n        emit NewRecurringBillingContractCreated(tokenAddress, address(rb));\r\n        return address(rb);\r\n    }\r\n\r\n}\r\n \t\t   \t  \t\t\t\t  \t  \t      \t\t \t\t\t  \t\t \t  \t \t\t \t \t\t \t\t \t  \t \t\t\t \t   \t\t    \t  \t \t\t\t  \t\t\t \t   \t\t \t \t\t\r\n/**\r\n * Smart contract for recurring billing in ERC20-compatible tokens. This smart contract defines workflow between\r\n * a merchant and a customer. Workflow:\r\n * 1. Merchant registers theirselves in this smart contract using `registerNewMerchant`.\r\n *   1.1. Merchant specifies `beneficiary` address, which receives tokens.\r\n *   1.2. Merchant specifies `merchant` address, which is able to change `merchant` and `beneficiary` addresses.\r\n *   1.3. Merchant specified an address that is authorized to call `charge` related to this merchant.\r\n *     1.3.1. Later, merchant can (de)authorize another addresses to call `charge` using `changeMerchantChargingAccount`.\r\n *   1.4. As a result, merchant gets `merchantId`, which is used to initialize recurring billing by customers.\r\n *   1.5. Merchant account can change their `beneficiary`, `merchant` and authorized charging addresses by calling:\r\n *     1.4.1. Function `changeMerchantAccount`, which changes account that can control this merchant (`merchantId`).\r\n *     1.4.2. Function `changeMerchantBeneficiaryAddress`, which changes merchant's `beneficiary`.\r\n *     1.4.3. Function `changeMerchantChargingAccount`, which (de)authorizes addresses to call `charge` on behalf of this merchant.\r\n * 2. According to an off-chain agreement with merchant, customer calls `allowRecurringBilling` and:\r\n *   2.1. Specifies `billingId`, which is given off-chain by merchant (merchant will listen blockchain Event on this ID).\r\n *   2.2. Specifies `merchantId`, the merchant which will receive tokens.\r\n *   2.3. Specifies `period` in seconds, during which only one charge can occur.\r\n *   2.4. Specifies `value`, amount in tokens which can be charged each `period`.\r\n *     2.4.1. If the customer doesn't have at least `value` tokens, `allowRecurringBilling` errors.\r\n *     2.4.2. If the customer haven't approved at least `value` tokens for a smart contract, `allowRecurringBilling` errors.\r\n *   2.5. `billingId` is then used by merchant to charge customer each `period`.\r\n * 3. Merchant use authorized accounts (1.3) to call the `charge` function each `period` to charge agreed amount from a customer.\r\n *   3.1. It is impossible to call `charge` if the date of the last charge is less than `period`.\r\n *   3.2. Calling `charge` cancels billing when called after 2 `period`s from the last charge.\r\n *   3.3. Thus, to successfully charge an account, `charge` must be strictly called within 1 and 2 `period`s after the last charge.\r\n *   3.4. Calling `charge` errors if any of the following occur:\r\n *     3.4.1. Customer canceled recurring billing with `cancelRecurringBilling`.\r\n *     3.4.2. Customer's balance is lower than the chargeable amount.\r\n *     3.4.3. Customer's allowance to the smart contract is less than the chargable amount.\r\n *     3.4.4. Specified `billingId` does not exists.\r\n *     3.4.5. There's no `period` passed since the last charge.\r\n *   3.5. Next charge date increments strictly by `period` each charge, thus, there's no need to exec `charge` strictly on time.\r\n * 4. Customer can cancel further billing by calling `cancelRecurringBilling` and passing `billingId`.\r\n * 5. TokenRecurringBilling smart contract implements `receiveApproval` function for allowing/cancelling billing within one call from\r\n *    the token smart contract. Parameter `data` is encoded as tightly-packed (uint256 metadata, uint256 billingId).\r\n *   5.1. `metadata` is encoded using `encodeBillingMetadata`.\r\n *   5.2. As for `receiveApproval`, `lastChargeAt` in `metadata` is used as an action identifier.\r\n *      5.2.1. `lastChargeAt=0` specifies that customer wants to allow new recurring billing.\r\n *      5.2.2. `lastChargeAt=1` specifies that customer wants to cancel existing recurring billing.\r\n *   5.3. Make sure that passed `bytes` parameter is exactly 64 bytes in length.\r\n */\r\ncontract TokenRecurringBilling {\r\n\r\n    using SafeMath for uint256;\r\n\r\n    event BillingAllowed(uint256 indexed billingId, address customer, uint256 merchantId, uint256 timestamp, uint256 period, uint256 value);\r\n    event BillingCharged(uint256 indexed billingId, uint256 timestamp, uint256 nextChargeTimestamp);\r\n    event BillingCanceled(uint256 indexed billingId);\r\n    event MerchantRegistered(uint256 indexed merchantId, address merchantAccount, address beneficiaryAddress);\r\n    event MerchantAccountChanged(uint256 indexed merchantId, address merchantAccount);\r\n    event MerchantBeneficiaryAddressChanged(uint256 indexed merchantId, address beneficiaryAddress);\r\n    event MerchantChargingAccountAllowed(uint256 indexed merchantId, address chargingAccount, bool allowed);\r\n\r\n    struct BillingRecord {\r\n        address customer; // Billing address (those who pay).\r\n        uint256 metadata; // Metadata packs 5 values to save on storage. Metadata spec (from first to last byte):\r\n                          //   + uint32 period;       // Billing period in seconds; configurable period of up to 136 years.\r\n                          //   + uint32 merchantId;   // Merchant ID; up to ~4.2 Milliard IDs.\r\n                          //   + uint48 lastChargeAt; // When the last charge occurred; up to year 999999+.\r\n                          //   + uint144 value;       // Billing value charrged each period; up to ~22 septillion tokens with 18 decimals\r\n    }\r\n\r\n    struct Merchant {\r\n        address merchant;    // Merchant admin address that can change all merchant struct properties.\r\n        address beneficiary; // Address receiving tokens.\r\n    }\r\n\r\n    enum receiveApprovalAction { // In receiveApproval, `lastChargeAt` in passed `metadata` specifies an action to execute.\r\n        allowRecurringBilling,   // == 0\r\n        cancelRecurringBilling   // == 1\r\n    }\r\n\r\n    uint256 public lastMerchantId;     // This variable increments on each new merchant registered, generating unique ids for merchant.\r\n    ERC20CompatibleToken public token; // Token address.\r\n\r\n    mapping(uint256 => BillingRecord) public billingRegistry;                           // List of all billings registered by ID.\r\n    mapping(uint256 => Merchant) public merchantRegistry;                               // List of all merchants registered by ID.\r\n    mapping(uint256 => mapping(address => bool)) public merchantChargingAccountAllowed; // Accounts that are allowed to charge customers.\r\n\r\n    // Checks whether {merchant} owns {merchantId}\r\n    modifier isMerchant (uint256 merchantId) {\r\n        require(merchantRegistry[merchantId].merchant == msg.sender, \"Sender is not a merchant\");\r\n        _;\r\n    }\r\n\r\n    // Checks whether {customer} owns {billingId}\r\n    modifier isCustomer (uint256 billingId) {\r\n        require(billingRegistry[billingId].customer == msg.sender, \"Sender is not a customer\");\r\n        _;\r\n    }\r\n\r\n    // Guarantees that the transaction is sent by token smart contract only.\r\n    modifier tokenOnly () {\r\n        require(msg.sender == address(token), \"Sender is not a token\");\r\n        _;\r\n    }\r\n\r\n    /// ======================================================== Constructor ========================================================= \\\\\\\r\n\r\n    // Creates a recurring billing smart contract for particular token.\r\n    constructor (address tokenAddress) public {\r\n        token = ERC20CompatibleToken(tokenAddress);\r\n    }\r\n\r\n    /// ====================================================== Public Functions ====================================================== \\\\\\\r\n\r\n    // Enables merchant with {merchantId} to charge transaction signer's account according to specified {value} and {period}.\r\n    function allowRecurringBilling (uint256 billingId, uint256 merchantId, uint256 value, uint256 period) public {\r\n        allowRecurringBillingInternal(msg.sender, merchantId, billingId, value, period);\r\n    }\r\n\r\n    // Enables anyone to become a merchant, charging tokens for their services.\r\n    function registerNewMerchant (address beneficiary, address chargingAccount) public returns (uint256 merchantId) {\r\n\r\n        merchantId = ++lastMerchantId;\r\n        Merchant storage record = merchantRegistry[merchantId];\r\n        record.merchant = msg.sender;\r\n        record.beneficiary = beneficiary;\r\n        emit MerchantRegistered(merchantId, msg.sender, beneficiary);\r\n\r\n        changeMerchantChargingAccount(merchantId, chargingAccount, true);\r\n\r\n    }\r\n\r\n    /// =========================================== Public Functions with Restricted Access =========================================== \\\\\\\r\n\r\n    // Calcels recurring billing with id {billingId} if it is owned by a transaction signer.\r\n    function cancelRecurringBilling (uint256 billingId) public isCustomer(billingId) {\r\n        cancelRecurringBillingInternal(billingId);\r\n    }\r\n\r\n    // Charges customer's account according to defined {billingId} billing rules. Only merchant's authorized accounts can charge the customer.\r\n    function charge (uint256 billingId) public {\r\n\r\n        BillingRecord storage billingRecord = billingRegistry[billingId];\r\n        (uint256 value, uint256 lastChargeAt, uint256 merchantId, uint256 period) = decodeBillingMetadata(billingRecord.metadata);\r\n\r\n        require(merchantChargingAccountAllowed[merchantId][msg.sender], \"Sender is not allowed to charge\");\r\n        require(merchantId != 0, \"Billing does not exist\");\r\n        require(lastChargeAt.add(period) <= now, \"Charged too early\");\r\n\r\n        // If 2 periods have already passed since the last charge (or beginning), no further charges are possible\r\n        // and recurring billing is canceled in case of a charge.\r\n        if (now > lastChargeAt.add(period.mul(2))) {\r\n            cancelRecurringBillingInternal(billingId);\r\n            return;\r\n        }\r\n\r\n        require(\r\n            token.transferFrom(billingRecord.customer, merchantRegistry[merchantId].beneficiary, value),\r\n            \"Unable to charge customer\"\r\n        );\r\n\r\n        billingRecord.metadata = encodeBillingMetadata(value, lastChargeAt.add(period), merchantId, period);\r\n\r\n        emit BillingCharged(billingId, now, lastChargeAt.add(period.mul(2)));\r\n\r\n    }\r\n\r\n    /**\r\n     * Invoked by a token smart contract on approveAndCall. Allows or cancels recurring billing.\r\n     * @param sender - Address that approved some tokens for this smart contract.\r\n     * @param data - Tightly-packed (uint256,uint256) values of (metadata, billingId). Metadata's `lastChargeAt`\r\n     *               specifies an action to perform (see `receiveApprovalAction` enum).\r\n     */\r\n    function receiveApproval (address sender, uint, address, bytes calldata data) external tokenOnly {\r\n\r\n        // The token contract MUST guarantee that \"sender\" is actually the token owner, and metadata is signed by a token owner.\r\n        require(data.length == 64, \"Invalid data length\");\r\n\r\n        // `action` is used instead of `lastCahrgeAt` to save some space.\r\n        (uint256 value, uint256 action, uint256 merchantId, uint256 period) = decodeBillingMetadata(bytesToUint256(data, 0));\r\n        uint256 billingId = bytesToUint256(data, 32);\r\n\r\n        if (action == uint256(receiveApprovalAction.allowRecurringBilling)) {\r\n            allowRecurringBillingInternal(sender, merchantId, billingId, value, period);\r\n        } else if (action == uint256(receiveApprovalAction.cancelRecurringBilling)) {\r\n            require(billingRegistry[billingId].customer == sender, \"Unable to cancel recurring billing of another customer\");\r\n            cancelRecurringBillingInternal(billingId);\r\n        } else {\r\n            revert(\"Unknown action provided\");\r\n        }\r\n\r\n    }\r\n\r\n    // Changes merchant account with id {merchantId} to {newMerchantAccount}.\r\n    function changeMerchantAccount (uint256 merchantId, address newMerchantAccount) public isMerchant(merchantId) {\r\n        merchantRegistry[merchantId].merchant = newMerchantAccount;\r\n        emit MerchantAccountChanged(merchantId, newMerchantAccount);\r\n    }\r\n\r\n    // Changes merchant's beneficiary address (address that receives charged tokens) to {newBeneficiaryAddress}.\r\n    function changeMerchantBeneficiaryAddress (uint256 merchantId, address newBeneficiaryAddress) public isMerchant(merchantId) {\r\n        merchantRegistry[merchantId].beneficiary = newBeneficiaryAddress;\r\n        emit MerchantBeneficiaryAddressChanged(merchantId, newBeneficiaryAddress);\r\n    }\r\n\r\n    // Allows or disallows particular {account} to charge customers related to this merchant.\r\n    function changeMerchantChargingAccount (uint256 merchantId, address account, bool allowed) public isMerchant(merchantId) {\r\n        merchantChargingAccountAllowed[merchantId][account] = allowed;\r\n        emit MerchantChargingAccountAllowed(merchantId, account, allowed);\r\n    }\r\n\r\n    /// ================================================== Public Utility Functions ================================================== \\\\\\\r\n\r\n    // Used to encode 5 values into one uint256 value. This is primarily made for cheaper storage.\r\n    function encodeBillingMetadata (\r\n        uint256 value,\r\n        uint256 lastChargeAt,\r\n        uint256 merchantId,\r\n        uint256 period\r\n    ) public pure returns (uint256 result) {\r\n\r\n        require(\r\n            value < 2 ** 144\r\n            && lastChargeAt < 2 ** 48\r\n            && merchantId < 2 ** 32\r\n            && period < 2 ** 32,\r\n            \"Invalid input sizes to encode\"\r\n        );\r\n\r\n        result = value;\r\n        result |= lastChargeAt << (144);\r\n        result |= merchantId << (144 + 48);\r\n        result |= period << (144 + 48 + 32);\r\n\r\n        return result;\r\n\r\n    }\r\n\r\n    // Used to decode 5 values from one uint256 value encoded by `encodeBillingMetadata` function.\r\n    function decodeBillingMetadata (uint256 encodedData) public pure returns (\r\n        uint256 value,\r\n        uint256 lastChargeAt,\r\n        uint256 merchantId,\r\n        uint256 period\r\n    ) {\r\n        value = uint144(encodedData);\r\n        lastChargeAt = uint48(encodedData >> (144));\r\n        merchantId = uint32(encodedData >> (144 + 48));\r\n        period = uint32(encodedData >> (144 + 48 + 32));\r\n    }\r\n\r\n    /// ================================================ Internal (Private) Functions ================================================ \\\\\\\r\n\r\n    // Allows recurring billing. Noone but this contract can call this function.\r\n    function allowRecurringBillingInternal (\r\n        address customer,\r\n        uint256 merchantId,\r\n        uint256 billingId,\r\n        uint256 value,\r\n        uint256 period\r\n    ) internal {\r\n\r\n        require(merchantId <= lastMerchantId && merchantId != 0, \"Invalid merchant specified\");\r\n        require(period < now, \"Invalid period specified\");\r\n        require(token.balanceOf(customer) >= value, \"Not enough tokens for the first charge\");\r\n        require(token.allowance(customer, address(this)) >= value, \"Tokens are not approved for this smart contract\");\r\n        require(billingRegistry[billingId].customer == address(0x0), \"Recurring billing with this ID is already registered\");\r\n\r\n        BillingRecord storage newRecurringBilling = billingRegistry[billingId];\r\n        newRecurringBilling.metadata = encodeBillingMetadata(value, now.sub(period), merchantId, period);\r\n        newRecurringBilling.customer = customer;\r\n\r\n        emit BillingAllowed(billingId, customer, merchantId, now, period, value);\r\n\r\n    }\r\n\r\n    // Cancels recurring billing. Noone but this contract can call this function.\r\n    function cancelRecurringBillingInternal (uint256 billingId) internal {\r\n        delete billingRegistry[billingId];\r\n        emit BillingCanceled(billingId);\r\n    }\r\n\r\n    // Utility function to convert bytes type to uint256. Noone but this contract can call this function.\r\n    function bytesToUint256(bytes memory input, uint offset) internal pure returns (uint256 output) {\r\n        assembly { output := mload(add(add(input, 32), offset)) }\r\n    }\r\n\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"tokenAddress\",\"type\":\"address\"}],\"name\":\"newRecurringBillingContract\",\"outputs\":[{\"name\":\"recurringBillingContractAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"recurringBillingContract\",\"type\":\"address\"}],\"name\":\"NewRecurringBillingContractCreated\",\"type\":\"event\"}]","ContractName":"RecurringBillingContractFactory","CompilerVersion":"v0.5.2+commit.1df8f40c","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://1cc1efc1eef791dcb151481223309dfaca0402a9e7b5bd47ac54f227daee5044"}]}