{"status":"1","message":"OK","result":[{"SourceCode":"// Dependency file: contracts/interfaces/IAuthority.sol\r\n\r\n// pragma solidity ^0.4.24;\r\n\r\ncontract IAuthority {\r\n    function canCall(\r\n        address src, address dst, bytes4 sig\r\n    ) public view returns (bool);\r\n}\r\n\r\n// Dependency file: contracts/DSAuth.sol\r\n\r\n// pragma solidity ^0.4.24;\r\n\r\n// import 'contracts/interfaces/IAuthority.sol';\r\n\r\ncontract DSAuthEvents {\r\n    event LogSetAuthority (address indexed authority);\r\n    event LogSetOwner     (address indexed owner);\r\n}\r\n\r\n/**\r\n * @title DSAuth\r\n * @dev The DSAuth contract is reference implement of https://github.com/dapphub/ds-auth\r\n * But in the isAuthorized method, the src from address(this) is remove for safty concern.\r\n */\r\ncontract DSAuth is DSAuthEvents {\r\n    IAuthority   public  authority;\r\n    address      public  owner;\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n        emit LogSetOwner(msg.sender);\r\n    }\r\n\r\n    function setOwner(address owner_)\r\n        public\r\n        auth\r\n    {\r\n        owner = owner_;\r\n        emit LogSetOwner(owner);\r\n    }\r\n\r\n    function setAuthority(IAuthority authority_)\r\n        public\r\n        auth\r\n    {\r\n        authority = authority_;\r\n        emit LogSetAuthority(authority);\r\n    }\r\n\r\n    modifier auth {\r\n        require(isAuthorized(msg.sender, msg.sig));\r\n        _;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    function isAuthorized(address src, bytes4 sig) internal view returns (bool) {\r\n        if (src == owner) {\r\n            return true;\r\n        } else if (authority == IAuthority(0)) {\r\n            return false;\r\n        } else {\r\n            return authority.canCall(src, this, sig);\r\n        }\r\n    }\r\n}\r\n\r\n\r\n// Dependency file: contracts/PausableDSAuth.sol\r\n\r\n// pragma solidity ^0.4.24;\r\n\r\n// import \"contracts/DSAuth.sol\";\r\n\r\n\r\n/**\r\n * @title Pausable\r\n * @dev Base contract which allows children to implement an emergency stop mechanism.\r\n */\r\ncontract PausableDSAuth is DSAuth {\r\n  event Pause();\r\n  event Unpause();\r\n\r\n  bool public paused = false;\r\n\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is not paused.\r\n   */\r\n  modifier whenNotPaused() {\r\n    require(!paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is paused.\r\n   */\r\n  modifier whenPaused() {\r\n    require(paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to pause, triggers stopped state\r\n   */\r\n  function pause() public onlyOwner whenNotPaused {\r\n    paused = true;\r\n    emit Pause();\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to unpause, returns to normal state\r\n   */\r\n  function unpause() public onlyOwner whenPaused {\r\n    paused = false;\r\n    emit Unpause();\r\n  }\r\n}\r\n\r\n// Dependency file: contracts/interfaces/ISettingsRegistry.sol\r\n\r\n// pragma solidity ^0.4.24;\r\n\r\ncontract ISettingsRegistry {\r\n    enum SettingsValueTypes { NONE, UINT, STRING, ADDRESS, BYTES, BOOL, INT }\r\n\r\n    function uintOf(bytes32 _propertyName) public view returns (uint256);\r\n\r\n    function stringOf(bytes32 _propertyName) public view returns (string);\r\n\r\n    function addressOf(bytes32 _propertyName) public view returns (address);\r\n\r\n    function bytesOf(bytes32 _propertyName) public view returns (bytes);\r\n\r\n    function boolOf(bytes32 _propertyName) public view returns (bool);\r\n\r\n    function intOf(bytes32 _propertyName) public view returns (int);\r\n\r\n    function setUintProperty(bytes32 _propertyName, uint _value) public;\r\n\r\n    function setStringProperty(bytes32 _propertyName, string _value) public;\r\n\r\n    function setAddressProperty(bytes32 _propertyName, address _value) public;\r\n\r\n    function setBytesProperty(bytes32 _propertyName, bytes _value) public;\r\n\r\n    function setBoolProperty(bytes32 _propertyName, bool _value) public;\r\n\r\n    function setIntProperty(bytes32 _propertyName, int _value) public;\r\n\r\n    function getValueTypeOf(bytes32 _propertyName) public view returns (uint /* SettingsValueTypes */ );\r\n\r\n    event ChangeProperty(bytes32 indexed _propertyName, uint256 _type);\r\n}\r\n\r\n// Dependency file: contracts/SettingIds.sol\r\n\r\n// pragma solidity ^0.4.24;\r\n\r\n/**\r\n    Id definitions for SettingsRegistry.sol\r\n    Can be used in conjunction with the settings registry to get properties\r\n*/\r\ncontract SettingIds {\r\n    bytes32 public constant CONTRACT_RING_ERC20_TOKEN = \"CONTRACT_RING_ERC20_TOKEN\";\r\n\r\n    bytes32 public constant CONTRACT_KTON_ERC20_TOKEN = \"CONTRACT_KTON_ERC20_TOKEN\";\r\n\r\n    bytes32 public constant CONTRACT_GOLD_ERC20_TOKEN = \"CONTRACT_GOLD_ERC20_TOKEN\";\r\n\r\n    bytes32 public constant CONTRACT_WOOD_ERC20_TOKEN = \"CONTRACT_WOOD_ERC20_TOKEN\";\r\n\r\n    bytes32 public constant CONTRACT_WATER_ERC20_TOKEN = \"CONTRACT_WATER_ERC20_TOKEN\";\r\n\r\n    bytes32 public constant CONTRACT_FIRE_ERC20_TOKEN = \"CONTRACT_FIRE_ERC20_TOKEN\";\r\n\r\n    bytes32 public constant CONTRACT_SOIL_ERC20_TOKEN = \"CONTRACT_SOIL_ERC20_TOKEN\";\r\n\r\n    bytes32 public constant CONTRACT_OBJECT_OWNERSHIP = \"CONTRACT_OBJECT_OWNERSHIP\";\r\n\r\n    bytes32 public constant CONTRACT_TOKEN_LOCATION = \"CONTRACT_TOKEN_LOCATION\";\r\n\r\n    bytes32 public constant CONTRACT_LAND_BASE = \"CONTRACT_LAND_BASE\";\r\n\r\n    bytes32 public constant CONTRACT_USER_POINTS = \"CONTRACT_USER_POINTS\";\r\n\r\n    bytes32 public constant CONTRACT_INTERSTELLAR_ENCODER = \"CONTRACT_INTERSTELLAR_ENCODER\";\r\n\r\n    bytes32 public constant CONTRACT_DIVIDENDS_POOL = \"CONTRACT_DIVIDENDS_POOL\";\r\n\r\n    bytes32 public constant CONTRACT_TOKEN_USE = \"CONTRACT_TOKEN_USE\";\r\n\r\n    bytes32 public constant CONTRACT_REVENUE_POOL = \"CONTRACT_REVENUE_POOL\";\r\n\r\n    bytes32 public constant CONTRACT_ERC721_BRIDGE = \"CONTRACT_ERC721_BRIDGE\";\r\n\r\n    bytes32 public constant CONTRACT_PET_BASE = \"CONTRACT_PET_BASE\";\r\n\r\n    // Cut owner takes on each auction, measured in basis points (1/100 of a percent).\r\n    // this can be considered as transaction fee.\r\n    // Values 0-10,000 map to 0%-100%\r\n    // set ownerCut to 4%\r\n    // ownerCut = 400;\r\n    bytes32 public constant UINT_AUCTION_CUT = \"UINT_AUCTION_CUT\";  // Denominator is 10000\r\n\r\n    bytes32 public constant UINT_TOKEN_OFFER_CUT = \"UINT_TOKEN_OFFER_CUT\";  // Denominator is 10000\r\n\r\n    // Cut referer takes on each auction, measured in basis points (1/100 of a percent).\r\n    // which cut from transaction fee.\r\n    // Values 0-10,000 map to 0%-100%\r\n    // set refererCut to 4%\r\n    // refererCut = 400;\r\n    bytes32 public constant UINT_REFERER_CUT = \"UINT_REFERER_CUT\";\r\n\r\n    bytes32 public constant CONTRACT_LAND_RESOURCE = \"CONTRACT_LAND_RESOURCE\";\r\n}\r\n\r\n// Dependency file: contracts/interfaces/IInterstellarEncoderV3.sol\r\n\r\n// pragma solidity ^0.4.24;\r\n\r\ncontract IInterstellarEncoderV3 {\r\n    uint256 constant CLEAR_HIGH =  0x00000000000000000000000000000000ffffffffffffffffffffffffffffffff;\r\n\r\n    uint256 public constant MAGIC_NUMBER = 42;    // Interstellar Encoding Magic Number.\r\n    uint256 public constant CHAIN_ID = 1; // Ethereum mainet.\r\n    uint256 public constant CURRENT_LAND = 1; // 1 is Atlantis, 0 is NaN.\r\n\r\n    enum ObjectClass { \r\n        NaN,\r\n        LAND,\r\n        APOSTLE,\r\n        OBJECT_CLASS_COUNT\r\n    }\r\n\r\n    function registerNewObjectClass(address _objectContract, uint8 objectClass) public;\r\n\r\n    function encodeTokenId(address _tokenAddress, uint8 _objectClass, uint128 _objectIndex) public view returns (uint256 _tokenId);\r\n\r\n    function encodeTokenIdForObjectContract(\r\n        address _tokenAddress, address _objectContract, uint128 _objectId) public view returns (uint256 _tokenId);\r\n\r\n    function encodeTokenIdForOuterObjectContract(\r\n        address _objectContract, address nftAddress, address _originNftAddress, uint128 _objectId, uint16 _producerId, uint8 _convertType) public view returns (uint256);\r\n\r\n    function getContractAddress(uint256 _tokenId) public view returns (address);\r\n\r\n    function getObjectId(uint256 _tokenId) public view returns (uint128 _objectId);\r\n\r\n    function getObjectClass(uint256 _tokenId) public view returns (uint8);\r\n\r\n    function getObjectAddress(uint256 _tokenId) public view returns (address);\r\n\r\n    function getProducerId(uint256 _tokenId) public view returns (uint16);\r\n\r\n    function getOriginAddress(uint256 _tokenId) public view returns (address);\r\n\r\n}\r\n\r\n// Dependency file: contracts/interfaces/IMintableERC20.sol\r\n\r\n// pragma solidity ^0.4.23;\r\n\r\ncontract IMintableERC20 {\r\n\r\n    function mint(address _to, uint256 _value) public;\r\n}\r\n\r\n// Dependency file: contracts/interfaces/INFTAdaptor.sol\r\n\r\n// pragma solidity ^0.4.24;\r\n\r\n\r\ncontract INFTAdaptor {\r\n    function toMirrorTokenId(uint256 _originTokenId) public view returns (uint256);\r\n\r\n    function toOriginTokenId(uint256 _mirrorTokenId) public view returns (uint256);\r\n\r\n    function approveOriginToken(address _bridge, uint256 _originTokenId) public;\r\n\r\n    function ownerInOrigin(uint256 _originTokenId) public view returns (address);\r\n\r\n    function cacheMirrorTokenId(uint256 _originTokenId, uint256 _mirrorTokenId) public;\r\n}\r\n\r\n\r\n// Dependency file: openzeppelin-solidity/contracts/introspection/ERC165.sol\r\n\r\n// pragma solidity ^0.4.24;\r\n\r\n\r\n/**\r\n * @title ERC165\r\n * @dev https://github.com/ethereum/EIPs/blob/master/EIPS/eip-165.md\r\n */\r\ninterface ERC165 {\r\n\r\n  /**\r\n   * @notice Query if a contract implements an interface\r\n   * @param _interfaceId The interface identifier, as specified in ERC-165\r\n   * @dev Interface identification is specified in ERC-165. This function\r\n   * uses less than 30,000 gas.\r\n   */\r\n  function supportsInterface(bytes4 _interfaceId)\r\n    external\r\n    view\r\n    returns (bool);\r\n}\r\n\r\n\r\n// Dependency file: openzeppelin-solidity/contracts/token/ERC721/ERC721Basic.sol\r\n\r\n// pragma solidity ^0.4.24;\r\n\r\n// import \"openzeppelin-solidity/contracts/introspection/ERC165.sol\";\r\n\r\n\r\n/**\r\n * @title ERC721 Non-Fungible Token Standard basic interface\r\n * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\r\n */\r\ncontract ERC721Basic is ERC165 {\r\n\r\n  bytes4 internal constant InterfaceId_ERC721 = 0x80ac58cd;\r\n  /*\r\n   * 0x80ac58cd ===\r\n   *   bytes4(keccak256('balanceOf(address)')) ^\r\n   *   bytes4(keccak256('ownerOf(uint256)')) ^\r\n   *   bytes4(keccak256('approve(address,uint256)')) ^\r\n   *   bytes4(keccak256('getApproved(uint256)')) ^\r\n   *   bytes4(keccak256('setApprovalForAll(address,bool)')) ^\r\n   *   bytes4(keccak256('isApprovedForAll(address,address)')) ^\r\n   *   bytes4(keccak256('transferFrom(address,address,uint256)')) ^\r\n   *   bytes4(keccak256('safeTransferFrom(address,address,uint256)')) ^\r\n   *   bytes4(keccak256('safeTransferFrom(address,address,uint256,bytes)'))\r\n   */\r\n\r\n  bytes4 internal constant InterfaceId_ERC721Exists = 0x4f558e79;\r\n  /*\r\n   * 0x4f558e79 ===\r\n   *   bytes4(keccak256('exists(uint256)'))\r\n   */\r\n\r\n  bytes4 internal constant InterfaceId_ERC721Enumerable = 0x780e9d63;\r\n  /**\r\n   * 0x780e9d63 ===\r\n   *   bytes4(keccak256('totalSupply()')) ^\r\n   *   bytes4(keccak256('tokenOfOwnerByIndex(address,uint256)')) ^\r\n   *   bytes4(keccak256('tokenByIndex(uint256)'))\r\n   */\r\n\r\n  bytes4 internal constant InterfaceId_ERC721Metadata = 0x5b5e139f;\r\n  /**\r\n   * 0x5b5e139f ===\r\n   *   bytes4(keccak256('name()')) ^\r\n   *   bytes4(keccak256('symbol()')) ^\r\n   *   bytes4(keccak256('tokenURI(uint256)'))\r\n   */\r\n\r\n  event Transfer(\r\n    address indexed _from,\r\n    address indexed _to,\r\n    uint256 indexed _tokenId\r\n  );\r\n  event Approval(\r\n    address indexed _owner,\r\n    address indexed _approved,\r\n    uint256 indexed _tokenId\r\n  );\r\n  event ApprovalForAll(\r\n    address indexed _owner,\r\n    address indexed _operator,\r\n    bool _approved\r\n  );\r\n\r\n  function balanceOf(address _owner) public view returns (uint256 _balance);\r\n  function ownerOf(uint256 _tokenId) public view returns (address _owner);\r\n  function exists(uint256 _tokenId) public view returns (bool _exists);\r\n\r\n  function approve(address _to, uint256 _tokenId) public;\r\n  function getApproved(uint256 _tokenId)\r\n    public view returns (address _operator);\r\n\r\n  function setApprovalForAll(address _operator, bool _approved) public;\r\n  function isApprovedForAll(address _owner, address _operator)\r\n    public view returns (bool);\r\n\r\n  function transferFrom(address _from, address _to, uint256 _tokenId) public;\r\n  function safeTransferFrom(address _from, address _to, uint256 _tokenId)\r\n    public;\r\n\r\n  function safeTransferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _tokenId,\r\n    bytes _data\r\n  )\r\n    public;\r\n}\r\n\r\n\r\n// Dependency file: openzeppelin-solidity/contracts/token/ERC721/ERC721.sol\r\n\r\n// pragma solidity ^0.4.24;\r\n\r\n// import \"openzeppelin-solidity/contracts/token/ERC721/ERC721Basic.sol\";\r\n\r\n\r\n/**\r\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\r\n * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\r\n */\r\ncontract ERC721Enumerable is ERC721Basic {\r\n  function totalSupply() public view returns (uint256);\r\n  function tokenOfOwnerByIndex(\r\n    address _owner,\r\n    uint256 _index\r\n  )\r\n    public\r\n    view\r\n    returns (uint256 _tokenId);\r\n\r\n  function tokenByIndex(uint256 _index) public view returns (uint256);\r\n}\r\n\r\n\r\n/**\r\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\r\n * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\r\n */\r\ncontract ERC721Metadata is ERC721Basic {\r\n  function name() external view returns (string _name);\r\n  function symbol() external view returns (string _symbol);\r\n  function tokenURI(uint256 _tokenId) public view returns (string);\r\n}\r\n\r\n\r\n/**\r\n * @title ERC-721 Non-Fungible Token Standard, full implementation interface\r\n * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\r\n */\r\ncontract ERC721 is ERC721Basic, ERC721Enumerable, ERC721Metadata {\r\n}\r\n\r\n\r\n// Root file: contracts/ERC721Bridge.sol\r\n\r\npragma solidity ^0.4.23;\r\n\r\n// import \"contracts/PausableDSAuth.sol\";\r\n// import \"contracts/interfaces/ISettingsRegistry.sol\";\r\n// import \"contracts/SettingIds.sol\";\r\n// import \"contracts/interfaces/IInterstellarEncoderV3.sol\";\r\n// import \"contracts/interfaces/IMintableERC20.sol\";\r\n// import \"contracts/interfaces/INFTAdaptor.sol\";\r\n// import \"openzeppelin-solidity/contracts/token/ERC721/ERC721.sol\";\r\n\r\n\r\n/*\r\n * naming convention:\r\n * originTokenId - token outside evolutionLand\r\n * mirrorTokenId - mirror token\r\n */\r\ncontract ERC721Bridge is SettingIds, PausableDSAuth {\r\n\r\n    /*\r\n     *  Storage\r\n    */\r\n    bool private singletonLock = false;\r\n\r\n    ISettingsRegistry public registry;\r\n\r\n\r\n    // originNFTContract => its adator\r\n    // for instance, CryptoKitties => CryptoKittiesAdaptor\r\n    // this need to be registered by owner\r\n    mapping(address => address) public originNFT2Adaptor;\r\n\r\n    // tokenId_inside => tokenId_outside\r\n    mapping(uint256 => uint256) public mirrorId2OriginId;\r\n\r\n    /*\r\n     *  Event\r\n     */\r\n    event BridgeIn(uint256 originTokenId, uint256 mirrorTokenId, address originContract, address adaptorAddress, address owner);\r\n\r\n    event SwapIn(uint256 originTokenId, uint256 mirrorTokenId, address owner);\r\n    event SwapOut(uint256 originTokenId, uint256 mirrorTokenId, address owner);\r\n\r\n\r\n    /*\r\n    *  Modifiers\r\n    */\r\n    modifier singletonLockCall() {\r\n        require(!singletonLock, \"Only can call once\");\r\n        _;\r\n        singletonLock = true;\r\n    }\r\n\r\n    function initializeContract(ISettingsRegistry _registry) public singletonLockCall {\r\n        owner = msg.sender;\r\n        emit LogSetOwner(msg.sender);\r\n        registry = _registry;\r\n    }\r\n\r\n    function registerAdaptor(address _originNftAddress, address _erc721Adaptor) public whenNotPaused onlyOwner {\r\n        originNFT2Adaptor[_originNftAddress] = _erc721Adaptor;\r\n    }\r\n\r\n    // used by PetBase\r\n    function bridgeInAuth(address _originNftAddress, uint256 _originTokenId, address _owner) public auth returns (uint256) {\r\n        return _bridgeIn(_originNftAddress, _originTokenId, _owner);\r\n    }\r\n\r\n\r\n    // generate new mirror token without origin token frozen\r\n    function bridgeIn(address _originNftAddress, uint256 _originTokenId) public returns (uint256) {\r\n        _bridgeIn(_originNftAddress, _originTokenId, msg.sender);\r\n    }\r\n\r\n    function _bridgeIn(address _originNftAddress, uint256 _originTokenId, address _owner) internal returns (uint256) {\r\n        address adaptor = originNFT2Adaptor[_originNftAddress];\r\n        require(adaptor != address(0), \"Not registered!\");\r\n\r\n        require(INFTAdaptor(adaptor).ownerInOrigin(_originTokenId) == _owner, \"Invalid owner!\");\r\n\r\n        uint256 mirrorTokenId = INFTAdaptor(adaptor).toMirrorTokenId(_originTokenId);\r\n\r\n        // if it is the first time to bridge in\r\n        if (!isBridged(mirrorTokenId)) {\r\n            // keep new mirror object in this contract\r\n            // before the owner has transferred his/her outerObject into this contract\r\n            // mirror object can not be transferred\r\n            address objectOwnership = registry.addressOf(SettingIds.CONTRACT_OBJECT_OWNERSHIP);\r\n            IMintableERC20(objectOwnership).mint(address(this), mirrorTokenId);\r\n\r\n            // link objects_in and objects_out\r\n            INFTAdaptor(adaptor).cacheMirrorTokenId(_originTokenId, mirrorTokenId);\r\n            mirrorId2OriginId[mirrorTokenId] = _originTokenId;\r\n\r\n            emit BridgeIn(_originTokenId, mirrorTokenId, _originNftAddress, adaptor, _owner);\r\n        }\r\n\r\n        return mirrorTokenId;\r\n    }\r\n\r\n    // freeze origin token to free mirror token\r\n    function swapIn(address _originNftAddress, uint256 _originTokenId) public {\r\n        require(ERC721(_originNftAddress).ownerOf(_originTokenId) == msg.sender, \"Invalid owner!\");\r\n\r\n        address adaptor = originNFT2Adaptor[_originNftAddress];\r\n        require(adaptor != address(0), \"Not registered!\");\r\n\r\n        // all specific originTokens are kept in bridge\r\n        ERC721(_originNftAddress).transferFrom(msg.sender, address(this), _originTokenId);\r\n\r\n        uint256 mirrorTokenId = INFTAdaptor(adaptor).toMirrorTokenId(_originTokenId);\r\n        address objectOwnership = registry.addressOf(SettingIds.CONTRACT_OBJECT_OWNERSHIP);\r\n        ERC721(objectOwnership).transferFrom(address(this), msg.sender, mirrorTokenId);\r\n\r\n        emit SwapIn(_originTokenId, mirrorTokenId, msg.sender);\r\n    }\r\n\r\n    function bridgeAndSwapIn(address _originNftAddress, uint256 _originTokenId) public {\r\n        bridgeIn(_originNftAddress, _originTokenId);\r\n        swapIn(_originNftAddress, _originTokenId);\r\n    }\r\n\r\n    function swapOut(uint256 _mirrorTokenId) public  {\r\n        IInterstellarEncoderV3 interstellarEncoder = IInterstellarEncoderV3(registry.addressOf(SettingIds.CONTRACT_INTERSTELLAR_ENCODER));\r\n        address nftContract = interstellarEncoder.getContractAddress(_mirrorTokenId);\r\n        require(nftContract != address(0), \"No such NFT contract\");\r\n        address adaptor = originNFT2Adaptor[nftContract];\r\n        require(adaptor != address(0), \"not registered!\");\r\n        require(ownerOfMirror(_mirrorTokenId) == msg.sender, \"you have no right to swap it out!\");\r\n\r\n        // TODO: if it is needed to check its current status\r\n        uint256 originTokenId = mirrorId2OriginId[_mirrorTokenId];\r\n        address objectOwnership = registry.addressOf(SettingIds.CONTRACT_OBJECT_OWNERSHIP);\r\n        ERC721(objectOwnership).transferFrom(msg.sender, address(this), _mirrorTokenId);\r\n        ERC721(nftContract).transferFrom(address(this), msg.sender, originTokenId);\r\n\r\n        emit SwapOut(originTokenId, _mirrorTokenId, msg.sender);\r\n    }\r\n\r\n    function approveOriginToken(address _originNFT, address _approved, uint256 _originTokenId) public auth {\r\n        ERC721(_originNFT).approve(_approved, _originTokenId);\r\n    }\r\n\r\n    function ownerOf(uint256 _mirrorTokenId) public view returns (address) {\r\n        return ownerOfMirror(_mirrorTokenId);\r\n    }\r\n\r\n    // return human owner of the token\r\n    function mirrorOfOrigin(address _originNFT, uint256 _originTokenId) public view returns (uint256) {\r\n        INFTAdaptor adapter = INFTAdaptor(originNFT2Adaptor[_originNFT]);\r\n\r\n        return adapter.toMirrorTokenId(_originTokenId);\r\n    }\r\n\r\n    // return human owner of the token\r\n    function ownerOfMirror(uint256 _mirrorTokenId) public view returns (address) {\r\n        address objectOwnership = registry.addressOf(SettingIds.CONTRACT_OBJECT_OWNERSHIP);\r\n        address owner = ERC721(objectOwnership).ownerOf(_mirrorTokenId);\r\n        if(owner != address(this)) {\r\n            return owner;\r\n        } else {\r\n            uint originTokenId = mirrorId2OriginId[_mirrorTokenId];\r\n            return INFTAdaptor(originNFT2Adaptor[originOwnershipAddress(_mirrorTokenId)]).ownerInOrigin(originTokenId);\r\n        }\r\n    }\r\n\r\n    function originOwnershipAddress(uint256 _mirrorTokenId) public view returns (address) {\r\n        IInterstellarEncoderV3 interstellarEncoder = IInterstellarEncoderV3(registry.addressOf(SettingIds.CONTRACT_INTERSTELLAR_ENCODER));\r\n\r\n        return interstellarEncoder.getOriginAddress(_mirrorTokenId);\r\n    }\r\n\r\n    function isBridged(uint256 _mirrorTokenId) public view returns (bool) {\r\n        return (mirrorId2OriginId[_mirrorTokenId] != 0);\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"CONTRACT_USER_POINTS\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"mirrorId2OriginId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"owner_\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_originNftAddress\",\"type\":\"address\"},{\"name\":\"_originTokenId\",\"type\":\"uint256\"}],\"name\":\"bridgeAndSwapIn\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CONTRACT_WATER_ERC20_TOKEN\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CONTRACT_GOLD_ERC20_TOKEN\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CONTRACT_RING_ERC20_TOKEN\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"UINT_AUCTION_CUT\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_originNFT\",\"type\":\"address\"},{\"name\":\"_originTokenId\",\"type\":\"uint256\"}],\"name\":\"mirrorOfOrigin\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CONTRACT_TOKEN_LOCATION\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"originNFT2Adaptor\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_originNftAddress\",\"type\":\"address\"},{\"name\":\"_originTokenId\",\"type\":\"uint256\"}],\"name\":\"swapIn\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CONTRACT_KTON_ERC20_TOKEN\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CONTRACT_WOOD_ERC20_TOKEN\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CONTRACT_FIRE_ERC20_TOKEN\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_mirrorTokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CONTRACT_LAND_BASE\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_mirrorTokenId\",\"type\":\"uint256\"}],\"name\":\"originOwnershipAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_mirrorTokenId\",\"type\":\"uint256\"}],\"name\":\"swapOut\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"authority_\",\"type\":\"address\"}],\"name\":\"setAuthority\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"registry\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CONTRACT_INTERSTELLAR_ENCODER\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CONTRACT_PET_BASE\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_originNftAddress\",\"type\":\"address\"},{\"name\":\"_originTokenId\",\"type\":\"uint256\"},{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"bridgeInAuth\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_originNftAddress\",\"type\":\"address\"},{\"name\":\"_erc721Adaptor\",\"type\":\"address\"}],\"name\":\"registerAdaptor\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CONTRACT_SOIL_ERC20_TOKEN\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_mirrorTokenId\",\"type\":\"uint256\"}],\"name\":\"isBridged\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_originNFT\",\"type\":\"address\"},{\"name\":\"_approved\",\"type\":\"address\"},{\"name\":\"_originTokenId\",\"type\":\"uint256\"}],\"name\":\"approveOriginToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_mirrorTokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOfMirror\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_originNftAddress\",\"type\":\"address\"},{\"name\":\"_originTokenId\",\"type\":\"uint256\"}],\"name\":\"bridgeIn\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CONTRACT_OBJECT_OWNERSHIP\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CONTRACT_TOKEN_USE\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_registry\",\"type\":\"address\"}],\"name\":\"initializeContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CONTRACT_ERC721_BRIDGE\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CONTRACT_REVENUE_POOL\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"authority\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CONTRACT_LAND_RESOURCE\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"UINT_REFERER_CUT\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"UINT_TOKEN_OFFER_CUT\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CONTRACT_DIVIDENDS_POOL\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"originTokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"mirrorTokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"originContract\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"adaptorAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"BridgeIn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"originTokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"mirrorTokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"SwapIn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"originTokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"mirrorTokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"SwapOut\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"authority\",\"type\":\"address\"}],\"name\":\"LogSetAuthority\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"LogSetOwner\",\"type\":\"event\"}]","ContractName":"ERC721Bridge","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"bzzr://9cbc5affab154a047b62c5c5bec84a992e11b87d3b1c9d74db188f3c63dd0611"}]}