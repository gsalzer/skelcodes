{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.0;\r\n\r\n// File: contracts/math/SafeMath.sol\r\n\r\nlibrary SafeMath {\r\n\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) return 0;\r\n\r\n    uint256 c = a * b;\r\n    require(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b > 0);\r\n    uint256 c = a / b;\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b <= a);\r\n    uint256 c = a - b;\r\n    return c;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    require(c >= a);\r\n\r\n    return c;\r\n  }\r\n\r\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b != 0);\r\n    return a % b;\r\n  }\r\n}\r\n\r\n// File: contracts/blacklist/Blacklist.sol\r\n\r\nlibrary Blacklist {\r\n  struct List {\r\n    mapping(address => bool) registry;\r\n  }\r\n  function add(List storage list, address beneficiary) internal {\r\n    list.registry[beneficiary] = true;\r\n  }\r\n  function remove(List storage list, address beneficiary) internal {\r\n    list.registry[beneficiary] = false;\r\n  }\r\n  function check(List storage list, address beneficiary) view internal returns (bool) {\r\n    return list.registry[beneficiary];\r\n  }\r\n}\r\n\r\n// File: contracts/ownership/Multiownable.sol\r\n\r\ncontract Multiownable {\r\n\r\n  uint256 public ownersGeneration;\r\n  uint256 public howManyOwnersDecide;\r\n  address[] public owners;\r\n  bytes32[] public allOperations;\r\n  address internal insideCallSender;\r\n  uint256 internal insideCallCount;\r\n\r\n  // Reverse lookup tables for owners and allOperations\r\n  mapping(address => uint) public ownersIndices;\r\n  mapping(bytes32 => uint) public allOperationsIndicies;\r\n\r\n  // Owners voting mask per operations\r\n  mapping(bytes32 => uint256) public votesMaskByOperation;\r\n  mapping(bytes32 => uint256) public votesCountByOperation;\r\n\r\n  event OwnershipTransferred(address[] previousOwners, uint howManyOwnersDecide, address[] newOwners, uint newHowManyOwnersDecide);\r\n  event OperationCreated(bytes32 operation, uint howMany, uint ownersCount, address proposer);\r\n  event OperationUpvoted(bytes32 operation, uint votes, uint howMany, uint ownersCount, address upvoter);\r\n  event OperationPerformed(bytes32 operation, uint howMany, uint ownersCount, address performer);\r\n  event OperationDownvoted(bytes32 operation, uint votes, uint ownersCount,  address downvoter);\r\n  event OperationCancelled(bytes32 operation, address lastCanceller);\r\n\r\n  function isOwner(address wallet) public view returns(bool) {\r\n    return ownersIndices[wallet] > 0;\r\n  }\r\n\r\n  function ownersCount() public view returns(uint) {\r\n    return owners.length;\r\n  }\r\n\r\n  function allOperationsCount() public view returns(uint) {\r\n    return allOperations.length;\r\n  }\r\n\r\n  /**\r\n  * @dev Allows to perform method by any of the owners\r\n  */\r\n  modifier onlyAnyOwner {\r\n    if (checkHowManyOwners(1)) {\r\n      bool update = (insideCallSender == address(0));\r\n      if (update) {\r\n        insideCallSender = msg.sender;\r\n        insideCallCount = 1;\r\n      }\r\n      _;\r\n      if (update) {\r\n        insideCallSender = address(0);\r\n        insideCallCount = 0;\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n  * @dev Allows to perform method only after some owners call it with the same arguments\r\n  */\r\n  modifier onlyOwners() {\r\n    require(howManyOwnersDecide > 0);\r\n    require(howManyOwnersDecide <= owners.length);\r\n\r\n    if (checkHowManyOwners(howManyOwnersDecide)) {\r\n      bool update = (insideCallSender == address(0));\r\n      if (update) {\r\n        insideCallSender = msg.sender;\r\n        insideCallCount = howManyOwnersDecide;\r\n      }\r\n      _;\r\n      if (update) {\r\n        insideCallSender = address(0);\r\n        insideCallCount = 0;\r\n      }\r\n    }\r\n  }\r\n\r\n  constructor(address[] memory _owners) public {\r\n    owners.push(msg.sender);\r\n    ownersIndices[msg.sender] = 1;\r\n    howManyOwnersDecide = 1;\r\n    transferOwnership(_owners, 2);\r\n  }\r\n\r\n  /**\r\n  * @dev onlyManyOwners modifier helper\r\n  */\r\n  function checkHowManyOwners(uint howMany) internal returns(bool) {\r\n    if (insideCallSender == msg.sender) {\r\n      require(howMany <= insideCallCount);\r\n      return true;\r\n    }\r\n\r\n    uint ownerIndex = ownersIndices[msg.sender] - 1;\r\n    require(ownerIndex < owners.length);\r\n    bytes32 operation = keccak256(abi.encodePacked(msg.data, ownersGeneration));\r\n\r\n    require((votesMaskByOperation[operation] & (2 ** ownerIndex)) == 0);\r\n    votesMaskByOperation[operation] |= (2 ** ownerIndex);\r\n    uint operationVotesCount = votesCountByOperation[operation] + 1;\r\n    votesCountByOperation[operation] = operationVotesCount;\r\n    if (operationVotesCount == 1) {\r\n      allOperationsIndicies[operation] = allOperations.length;\r\n      allOperations.push(operation);\r\n      emit OperationCreated(operation, howMany, owners.length, msg.sender);\r\n    }\r\n    emit OperationUpvoted(operation, operationVotesCount, howMany, owners.length, msg.sender);\r\n\r\n    // If enough owners confirmed the same operation\r\n    if (votesCountByOperation[operation] == howMany) {\r\n      deleteOperation(operation);\r\n      emit OperationPerformed(operation, howMany, owners.length, msg.sender);\r\n      return true;\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  function deleteOperation(bytes32 operation) internal {\r\n    uint index = allOperationsIndicies[operation];\r\n    if (index < allOperations.length - 1) { // Not last\r\n      allOperations[index] = allOperations[allOperations.length - 1];\r\n      allOperationsIndicies[allOperations[index]] = index;\r\n    }\r\n    allOperations.length--;\r\n\r\n    delete votesMaskByOperation[operation];\r\n    delete votesCountByOperation[operation];\r\n    delete allOperationsIndicies[operation];\r\n  }\r\n\r\n  function cancelPending(bytes32 operation) public onlyAnyOwner {\r\n    uint ownerIndex = ownersIndices[msg.sender] - 1;\r\n    require((votesMaskByOperation[operation] & (2 ** ownerIndex)) != 0);\r\n    votesMaskByOperation[operation] &= ~(2 ** ownerIndex);\r\n    uint operationVotesCount = votesCountByOperation[operation] - 1;\r\n    votesCountByOperation[operation] = operationVotesCount;\r\n    emit OperationDownvoted(operation, operationVotesCount, owners.length, msg.sender);\r\n    if (operationVotesCount == 0) {\r\n      deleteOperation(operation);\r\n      emit OperationCancelled(operation, msg.sender);\r\n    }\r\n  }\r\n\r\n  function transferOwnership(address[] memory newOwners, uint256 _howManyOwnersDecide) public onlyAnyOwner {\r\n    _transferOwnership(newOwners, _howManyOwnersDecide);\r\n  }\r\n\r\n  function _transferOwnership(address[] memory newOwners, uint256 newHowManyOwnersDecide) internal onlyOwners {\r\n    require(newOwners.length > 0);\r\n    require(newOwners.length <= 256);\r\n    require(newHowManyOwnersDecide > 0);\r\n    require(newHowManyOwnersDecide <= newOwners.length);\r\n\r\n    // Reset owners reverse lookup table\r\n    for (uint j = 0; j < owners.length; j++) {\r\n      delete ownersIndices[owners[j]];\r\n    }\r\n    for (uint i = 0; i < newOwners.length; i++) {\r\n      require(newOwners[i] != address(0));\r\n      require(ownersIndices[newOwners[i]] == 0);\r\n      ownersIndices[newOwners[i]] = i + 1;\r\n    }\r\n\r\n    emit OwnershipTransferred(owners, howManyOwnersDecide, newOwners, newHowManyOwnersDecide);\r\n    owners = newOwners;\r\n    howManyOwnersDecide = newHowManyOwnersDecide;\r\n    allOperations.length = 0;\r\n    ownersGeneration++;\r\n  }\r\n\r\n}\r\n\r\n// File: contracts/blacklist/Blacklisted.sol\r\n\r\ncontract Blacklisted is Multiownable {\r\n  Blacklist.List private _list;\r\n  modifier whenNotFrozen() {\r\n    require(Blacklist.check(_list, msg.sender) == false);\r\n    _;\r\n  }\r\n  event AddressAdded(address[] beneficiary);\r\n  event AddressRemoved(address[] beneficiary);\r\n\r\n  function freezeAccount(address[] calldata _beneficiary) external onlyOwners {\r\n    for (uint256 i = 0; i < _beneficiary.length; i++) {\r\n      Blacklist.add(_list, _beneficiary[i]);\r\n    }\r\n    emit AddressAdded(_beneficiary);\r\n  }\r\n\r\n  function deFreezeAccount(address[] calldata _beneficiary) external onlyOwners {\r\n    for (uint256 i = 0; i < _beneficiary.length; i++) {\r\n      Blacklist.remove(_list, _beneficiary[i]);\r\n    }\r\n    emit AddressRemoved(_beneficiary);\r\n  }\r\n\r\n  function isFrozen(address _beneficiary) external view returns (bool){\r\n    return Blacklist.check(_list, _beneficiary);\r\n  }\r\n}\r\n\r\n// File: contracts/lifecycle/Pausable.sol\r\n\r\ncontract Pausable is Multiownable {\r\n\r\n  event Pause();\r\n  event Unpause();\r\n\r\n  bool public paused = false;\r\n\r\n  modifier whenNotPaused() {\r\n    require(!paused);\r\n    _;\r\n  }\r\n\r\n  modifier whenPaused() {\r\n    require(paused);\r\n    _;\r\n  }\r\n\r\n  function pause() whenNotPaused onlyOwners external {\r\n    paused = true;\r\n    emit Pause();\r\n  }\r\n\r\n  function unpause() whenPaused onlyOwners external {\r\n    paused = false;\r\n    emit Unpause();\r\n  }\r\n}\r\n\r\n// File: contracts/token/BasicInterface.sol\r\n\r\ncontract ERC20 {\r\n    function balanceOf(address tokenOwner) public view returns (uint256 balance);\r\n    function allowance(address tokenOwner, address spender) public view returns (uint256 remaining);\r\n    function transfer(address to, uint256 tokens) public returns (bool success);\r\n    function approve(address spender, uint256 tokens) public returns (bool success);\r\n    function transferFrom(address from, address to, uint256 tokens) public returns (bool success);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 tokens);\r\n    event Approval(address indexed tokenOwner, address indexed spender, uint256 tokens);\r\n}\r\n\r\n// File: contracts/token/BasicToken.sol\r\n\r\ncontract BasicToken is ERC20 {\r\n  using SafeMath for uint256;\r\n\r\n  mapping(address => uint256) balances;\r\n  uint256 public _totalSupply;\r\n\r\n  function totalSupply() public view returns (uint256) {\r\n    return _totalSupply;\r\n  }\r\n\r\n  function balanceOf(address owner) public view returns (uint256 balance) {\r\n    return balances[owner];\r\n  }\r\n\r\n  function transfer(address to, uint256 value) public returns (bool) {\r\n    _transfer(msg.sender, to, value);\r\n    return true;\r\n  }\r\n\r\n  function _transfer(address from, address to, uint256 value) internal {\r\n    require(address(to) != address(0));\r\n    balances[from] = balances[from].sub(value);\r\n    balances[to] = balances[to].add(value);\r\n    emit Transfer(from, to, value);\r\n  }\r\n\r\n}\r\n\r\n// File: contracts/token/StandardToken.sol\r\n\r\ncontract StandardToken is BasicToken {\r\n  mapping (address => mapping (address => uint256)) allowed;\r\n\r\n  function transferFrom(address from, address to, uint256 value) public returns (bool) {\r\n    allowed[from][msg.sender] = allowed[from][msg.sender].sub(value);\r\n    _transfer(from, to, value);\r\n    emit Approval(from, msg.sender, allowed[from][msg.sender]);\r\n    return true;\r\n  }\r\n\r\n  function approve(address spender, uint256 value) public returns (bool) {\r\n    allowed[msg.sender][spender] = value;\r\n    emit Approval(msg.sender, spender, value);\r\n    return true;\r\n  }\r\n\r\n  function allowance(address owner, address spender) public view returns (uint256 remaining) {\r\n    return allowed[owner][spender];\r\n  }\r\n\r\n  function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\r\n    require(spender != address(0));\r\n    allowed[msg.sender][spender] = allowed[msg.sender][spender].add(addedValue);\r\n    emit Approval(msg.sender, spender, allowed[msg.sender][spender]);\r\n    return true;\r\n  }\r\n\r\n  function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\r\n    require(spender != address(0));\r\n    allowed[msg.sender][spender] = allowed[msg.sender][spender].sub(subtractedValue);\r\n    emit Approval(msg.sender, spender, allowed[msg.sender][spender]);\r\n    return true;\r\n  }\r\n}\r\n\r\n// File: contracts/token/BurnableToken.sol\r\n\r\ncontract BurnableToken is StandardToken {\r\n\r\n  function burn(address account, uint256 value) public {\r\n    require(account != address(0));\r\n    _totalSupply = _totalSupply.sub(value);\r\n    balances[account] = balances[account].sub(value);\r\n    emit Transfer(account, address(0), value);\r\n  }\r\n\r\n  function burnFrom(address account, uint256 value) public {\r\n    allowed[account][msg.sender] = allowed[account][msg.sender].sub(value);\r\n    burn(account, value);\r\n    emit Approval(account, msg.sender, allowed[account][msg.sender]);\r\n  }\r\n\r\n}\r\n\r\n// File: contracts/Hydra.sol\r\n\r\ncontract MultiSignatureVault is Multiownable {\r\n\r\n  bool lockState;\r\n  function () external payable {}\r\n\r\n  constructor(address[] memory _owners) public Multiownable(_owners) {\r\n    lockState = false;\r\n  }\r\n\r\n  function transferTo(address payable to, uint256 amount) external onlyOwners {\r\n    require(!lockState);\r\n    lockState = true;\r\n    to.transfer(amount);\r\n    lockState = false;\r\n  }\r\n\r\n  function transferTokensTo(address token, address to, uint256 amount) external onlyOwners {\r\n    require(!lockState);\r\n    lockState = true;\r\n    ERC20(token).transfer(to, amount);\r\n    lockState = false;\r\n  }\r\n}\r\n\r\ncontract Hydra is StandardToken, BurnableToken, Blacklisted, Pausable {\r\n\r\n  string private _name;\r\n  string private _symbol;\r\n  uint8 private _decimals;\r\n\r\n  MultiSignatureVault public vaultTeam;\r\n  MultiSignatureVault public vaultInvestor;\r\n  MultiSignatureVault public vaultOperation;\r\n\r\n  constructor(address[] memory owners) public Multiownable(owners) {\r\n    _name = \"Hydra Token\";\r\n    _symbol = \"HDRA\";\r\n    _decimals = 18;\r\n    _totalSupply = 300000000E18;\r\n\r\n    vaultTeam = new MultiSignatureVault(owners);\r\n    vaultInvestor = new MultiSignatureVault(owners);\r\n    vaultOperation = new MultiSignatureVault(owners);\r\n\r\n    balances[address(vaultTeam)] = 60000000E18;\r\n    balances[address(vaultInvestor)] = 150000000E18;\r\n    balances[address(vaultOperation)] = 90000000E18;\r\n\r\n    emit Transfer(address(this), address(vaultTeam), 60000000E18);\r\n    emit Transfer(address(this), address(vaultInvestor), 150000000E18);\r\n    emit Transfer(address(this), address(vaultOperation), 90000000E18);\r\n  }\r\n\r\n  function name() public view returns (string memory) {\r\n    return _name;\r\n  }\r\n\r\n  function symbol() public view returns (string memory) {\r\n    return _symbol;\r\n  }\r\n\r\n  function decimals() public view returns (uint8) {\r\n    return _decimals;\r\n  }\r\n\r\n  function transfer(address to, uint256 value) public whenNotPaused whenNotFrozen returns (bool) {\r\n    return super.transfer(to, value);\r\n  }\r\n\r\n  function transferFrom(address from, address to, uint256 value) public whenNotPaused whenNotFrozen returns (bool) {\r\n    return super.transferFrom(from, to, value);\r\n  }\r\n\r\n  function approve(address spender, uint256 value) public whenNotPaused whenNotFrozen returns (bool) {\r\n    return super.approve(spender, value);\r\n  }\r\n\r\n  function increaseAllowance(address spender, uint addedValue) public whenNotPaused whenNotFrozen returns (bool success) {\r\n    return super.increaseAllowance(spender, addedValue);\r\n  }\r\n\r\n  function decreaseAllowance(address spender, uint subtractedValue) public whenNotPaused whenNotFrozen returns (bool success) {\r\n    return super.decreaseAllowance(spender, subtractedValue);\r\n  }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"owners\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"allOperationsCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"howManyOwnersDecide\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"allOperations\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address[]\"}],\"name\":\"freezeAccount\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"votesMaskByOperation\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address[]\"}],\"name\":\"deFreezeAccount\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"burnFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"vaultInvestor\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"operation\",\"type\":\"bytes32\"}],\"name\":\"cancelPending\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"votesCountByOperation\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"vaultTeam\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ownersGeneration\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwners\",\"type\":\"address[]\"},{\"name\":\"_howManyOwnersDecide\",\"type\":\"uint256\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ownersCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"ownersIndices\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"isFrozen\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"allOperationsIndicies\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"vaultOperation\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"owners\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"beneficiary\",\"type\":\"address[]\"}],\"name\":\"AddressAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"beneficiary\",\"type\":\"address[]\"}],\"name\":\"AddressRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"previousOwners\",\"type\":\"address[]\"},{\"indexed\":false,\"name\":\"howManyOwnersDecide\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"newOwners\",\"type\":\"address[]\"},{\"indexed\":false,\"name\":\"newHowManyOwnersDecide\",\"type\":\"uint256\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"howMany\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"ownersCount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"proposer\",\"type\":\"address\"}],\"name\":\"OperationCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"votes\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"howMany\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"ownersCount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"upvoter\",\"type\":\"address\"}],\"name\":\"OperationUpvoted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"howMany\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"ownersCount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"performer\",\"type\":\"address\"}],\"name\":\"OperationPerformed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"votes\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"ownersCount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"downvoter\",\"type\":\"address\"}],\"name\":\"OperationDownvoted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"lastCanceller\",\"type\":\"address\"}],\"name\":\"OperationCancelled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"tokenOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"Hydra","CompilerVersion":"v0.5.1+commit.c8a2cb62","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000400000000000000000000000098598d4c5cc0b99a19fab50c015d7d8049339f0600000000000000000000000010348ed616908010dc94bead1774d5d4a80c31ff000000000000000000000000bc4344802e628a9b651feef5c5520a21156636cc00000000000000000000000047db3bf883f12673768b61b46eae74f8ffae3928","Library":"","SwarmSource":"bzzr://b30d89ac79267f375bc7217543dace0601a4f258d4755d233290d8303c14f87f"}]}