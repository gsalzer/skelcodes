{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\n/**\r\n * @title Utility contract to allow pausing and unpausing of certain functions\r\n */\r\ncontract Pausable {\r\n\r\n    event Pause(uint256 _timestammp);\r\n    event Unpause(uint256 _timestamp);\r\n\r\n    bool public paused = false;\r\n\r\n    /**\r\n    * @notice Modifier to make a function callable only when the contract is not paused.\r\n    */\r\n    modifier whenNotPaused() {\r\n        require(!paused, \"Contract is paused\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @notice Modifier to make a function callable only when the contract is paused.\r\n    */\r\n    modifier whenPaused() {\r\n        require(paused, \"Contract is not paused\");\r\n        _;\r\n    }\r\n\r\n   /**\r\n    * @notice Called by the owner to pause, triggers stopped state\r\n    */\r\n    function _pause() internal whenNotPaused {\r\n        paused = true;\r\n        /*solium-disable-next-line security/no-block-members*/\r\n        emit Pause(now);\r\n    }\r\n\r\n    /**\r\n    * @notice Called by the owner to unpause, returns to normal state\r\n    */\r\n    function _unpause() internal whenPaused {\r\n        paused = false;\r\n        /*solium-disable-next-line security/no-block-members*/\r\n        emit Unpause(now);\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * @title Interface that every module contract should implement\r\n */\r\ninterface IModule {\r\n\r\n    /**\r\n     * @notice This function returns the signature of configure function\r\n     */\r\n    function getInitFunction() external pure returns (bytes4);\r\n\r\n    /**\r\n     * @notice Return the permission flags that are associated with a module\r\n     */\r\n    function getPermissions() external view returns(bytes32[]);\r\n\r\n    /**\r\n     * @notice Used to withdraw the fee by the factory owner\r\n     */\r\n    function takeFee(uint256 _amount) external returns(bool);\r\n\r\n}\r\n\r\n/**\r\n * @title Interface for all security tokens\r\n */\r\ninterface ISecurityToken {\r\n\r\n    // Standard ERC20 interface\r\n    function decimals() external view returns (uint8);\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address _owner) external view returns (uint256);\r\n    function allowance(address _owner, address _spender) external view returns (uint256);\r\n    function transfer(address _to, uint256 _value) external returns (bool);\r\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool);\r\n    function approve(address _spender, uint256 _value) external returns (bool);\r\n    function decreaseApproval(address _spender, uint _subtractedValue) external returns (bool);\r\n    function increaseApproval(address _spender, uint _addedValue) external returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    //transfer, transferFrom must respect the result of verifyTransfer\r\n    function verifyTransfer(address _from, address _to, uint256 _value) external returns (bool success);\r\n\r\n    /**\r\n     * @notice Mints new tokens and assigns them to the target _investor.\r\n     * Can only be called by the STO attached to the token (Or by the ST owner if there's no STO attached yet)\r\n     * @param _investor Address the tokens will be minted to\r\n     * @param _value is the amount of tokens that will be minted to the investor\r\n     */\r\n    function mint(address _investor, uint256 _value) external returns (bool success);\r\n\r\n    /**\r\n     * @notice Mints new tokens and assigns them to the target _investor.\r\n     * Can only be called by the STO attached to the token (Or by the ST owner if there's no STO attached yet)\r\n     * @param _investor Address the tokens will be minted to\r\n     * @param _value is The amount of tokens that will be minted to the investor\r\n     * @param _data Data to indicate validation\r\n     */\r\n    function mintWithData(address _investor, uint256 _value, bytes _data) external returns (bool success);\r\n\r\n    /**\r\n     * @notice Used to burn the securityToken on behalf of someone else\r\n     * @param _from Address for whom to burn tokens\r\n     * @param _value No. of tokens to be burned\r\n     * @param _data Data to indicate validation\r\n     */\r\n    function burnFromWithData(address _from, uint256 _value, bytes _data) external;\r\n\r\n    /**\r\n     * @notice Used to burn the securityToken\r\n     * @param _value No. of tokens to be burned\r\n     * @param _data Data to indicate validation\r\n     */\r\n    function burnWithData(uint256 _value, bytes _data) external;\r\n\r\n    event Minted(address indexed _to, uint256 _value);\r\n    event Burnt(address indexed _burner, uint256 _value);\r\n\r\n    // Permissions this to a Permission module, which has a key of 1\r\n    // If no Permission return false - note that IModule withPerm will allow ST owner all permissions anyway\r\n    // this allows individual modules to override this logic if needed (to not allow ST owner all permissions)\r\n    function checkPermission(address _delegate, address _module, bytes32 _perm) external view returns (bool);\r\n\r\n    /**\r\n     * @notice Returns module list for a module type\r\n     * @param _module Address of the module\r\n     * @return bytes32 Name\r\n     * @return address Module address\r\n     * @return address Module factory address\r\n     * @return bool Module archived\r\n     * @return uint8 Module type\r\n     * @return uint256 Module index\r\n     * @return uint256 Name index\r\n\r\n     */\r\n    function getModule(address _module) external view returns(bytes32, address, address, bool, uint8, uint256, uint256);\r\n\r\n    /**\r\n     * @notice Returns module list for a module name\r\n     * @param _name Name of the module\r\n     * @return address[] List of modules with this name\r\n     */\r\n    function getModulesByName(bytes32 _name) external view returns (address[]);\r\n\r\n    /**\r\n     * @notice Returns module list for a module type\r\n     * @param _type Type of the module\r\n     * @return address[] List of modules with this type\r\n     */\r\n    function getModulesByType(uint8 _type) external view returns (address[]);\r\n\r\n    /**\r\n     * @notice Queries totalSupply at a specified checkpoint\r\n     * @param _checkpointId Checkpoint ID to query as of\r\n     */\r\n    function totalSupplyAt(uint256 _checkpointId) external view returns (uint256);\r\n\r\n    /**\r\n     * @notice Queries balance at a specified checkpoint\r\n     * @param _investor Investor to query balance for\r\n     * @param _checkpointId Checkpoint ID to query as of\r\n     */\r\n    function balanceOfAt(address _investor, uint256 _checkpointId) external view returns (uint256);\r\n\r\n    /**\r\n     * @notice Creates a checkpoint that can be used to query historical balances / totalSuppy\r\n     */\r\n    function createCheckpoint() external returns (uint256);\r\n\r\n    /**\r\n     * @notice Gets length of investors array\r\n     * NB - this length may differ from investorCount if the list has not been pruned of zero-balance investors\r\n     * @return Length\r\n     */\r\n    function getInvestors() external view returns (address[]);\r\n\r\n    /**\r\n     * @notice returns an array of investors at a given checkpoint\r\n     * NB - this length may differ from investorCount as it contains all investors that ever held tokens\r\n     * @param _checkpointId Checkpoint id at which investor list is to be populated\r\n     * @return list of investors\r\n     */\r\n    function getInvestorsAt(uint256 _checkpointId) external view returns(address[]);\r\n\r\n    /**\r\n     * @notice generates subset of investors\r\n     * NB - can be used in batches if investor list is large\r\n     * @param _start Position of investor to start iteration from\r\n     * @param _end Position of investor to stop iteration at\r\n     * @return list of investors\r\n     */\r\n    function iterateInvestors(uint256 _start, uint256 _end) external view returns(address[]);\r\n    \r\n    /**\r\n     * @notice Gets current checkpoint ID\r\n     * @return Id\r\n     */\r\n    function currentCheckpointId() external view returns (uint256);\r\n\r\n    /**\r\n    * @notice Gets an investor at a particular index\r\n    * @param _index Index to return address from\r\n    * @return Investor address\r\n    */\r\n    function investors(uint256 _index) external view returns (address);\r\n\r\n   /**\r\n    * @notice Allows the owner to withdraw unspent POLY stored by them on the ST or any ERC20 token.\r\n    * @dev Owner can transfer POLY to the ST which will be used to pay for modules that require a POLY fee.\r\n    * @param _tokenContract Address of the ERC20Basic compliance token\r\n    * @param _value Amount of POLY to withdraw\r\n    */\r\n    function withdrawERC20(address _tokenContract, uint256 _value) external;\r\n\r\n    /**\r\n    * @notice Allows owner to approve more POLY to one of the modules\r\n    * @param _module Module address\r\n    * @param _budget New budget\r\n    */\r\n    function changeModuleBudget(address _module, uint256 _budget) external;\r\n\r\n    /**\r\n     * @notice Changes the tokenDetails\r\n     * @param _newTokenDetails New token details\r\n     */\r\n    function updateTokenDetails(string _newTokenDetails) external;\r\n\r\n    /**\r\n    * @notice Allows the owner to change token granularity\r\n    * @param _granularity Granularity level of the token\r\n    */\r\n    function changeGranularity(uint256 _granularity) external;\r\n\r\n    /**\r\n    * @notice Removes addresses with zero balances from the investors list\r\n    * @param _start Index in investors list at which to start removing zero balances\r\n    * @param _iters Max number of iterations of the for loop\r\n    * NB - pruning this list will mean you may not be able to iterate over investors on-chain as of a historical checkpoint\r\n    */\r\n    function pruneInvestors(uint256 _start, uint256 _iters) external;\r\n\r\n    /**\r\n     * @notice Freezes all the transfers\r\n     */\r\n    function freezeTransfers() external;\r\n\r\n    /**\r\n     * @notice Un-freezes all the transfers\r\n     */\r\n    function unfreezeTransfers() external;\r\n\r\n    /**\r\n     * @notice Ends token minting period permanently\r\n     */\r\n    function freezeMinting() external;\r\n\r\n    /**\r\n     * @notice Mints new tokens and assigns them to the target investors.\r\n     * Can only be called by the STO attached to the token or by the Issuer (Security Token contract owner)\r\n     * @param _investors A list of addresses to whom the minted tokens will be delivered\r\n     * @param _values A list of the amount of tokens to mint to corresponding addresses from _investor[] list\r\n     * @return Success\r\n     */\r\n    function mintMulti(address[] _investors, uint256[] _values) external returns (bool success);\r\n\r\n    /**\r\n     * @notice Function used to attach a module to the security token\r\n     * @dev  E.G.: On deployment (through the STR) ST gets a TransferManager module attached to it\r\n     * @dev to control restrictions on transfers.\r\n     * @dev You are allowed to add a new moduleType if:\r\n     * @dev - there is no existing module of that type yet added\r\n     * @dev - the last member of the module list is replacable\r\n     * @param _moduleFactory is the address of the module factory to be added\r\n     * @param _data is data packed into bytes used to further configure the module (See STO usage)\r\n     * @param _maxCost max amount of POLY willing to pay to module. (WIP)\r\n     */\r\n    function addModule(\r\n        address _moduleFactory,\r\n        bytes _data,\r\n        uint256 _maxCost,\r\n        uint256 _budget\r\n    ) external;\r\n\r\n    /**\r\n    * @notice Archives a module attached to the SecurityToken\r\n    * @param _module address of module to archive\r\n    */\r\n    function archiveModule(address _module) external;\r\n\r\n    /**\r\n    * @notice Unarchives a module attached to the SecurityToken\r\n    * @param _module address of module to unarchive\r\n    */\r\n    function unarchiveModule(address _module) external;\r\n\r\n    /**\r\n    * @notice Removes a module attached to the SecurityToken\r\n    * @param _module address of module to archive\r\n    */\r\n    function removeModule(address _module) external;\r\n\r\n    /**\r\n     * @notice Used by the issuer to set the controller addresses\r\n     * @param _controller address of the controller\r\n     */\r\n    function setController(address _controller) external;\r\n\r\n    /**\r\n     * @notice Used by a controller to execute a forced transfer\r\n     * @param _from address from which to take tokens\r\n     * @param _to address where to send tokens\r\n     * @param _value amount of tokens to transfer\r\n     * @param _data data to indicate validation\r\n     * @param _log data attached to the transfer by controller to emit in event\r\n     */\r\n    function forceTransfer(address _from, address _to, uint256 _value, bytes _data, bytes _log) external;\r\n\r\n    /**\r\n     * @notice Used by a controller to execute a foced burn\r\n     * @param _from address from which to take tokens\r\n     * @param _value amount of tokens to transfer\r\n     * @param _data data to indicate validation\r\n     * @param _log data attached to the transfer by controller to emit in event\r\n     */\r\n    function forceBurn(address _from, uint256 _value, bytes _data, bytes _log) external;\r\n\r\n    /**\r\n     * @notice Used by the issuer to permanently disable controller functionality\r\n     * @dev enabled via feature switch \"disableControllerAllowed\"\r\n     */\r\n     function disableController() external;\r\n\r\n     /**\r\n     * @notice Used to get the version of the securityToken\r\n     */\r\n     function getVersion() external view returns(uint8[]);\r\n\r\n     /**\r\n     * @notice Gets the investor count\r\n     */\r\n     function getInvestorCount() external view returns(uint256);\r\n\r\n     /**\r\n      * @notice Overloaded version of the transfer function\r\n      * @param _to receiver of transfer\r\n      * @param _value value of transfer\r\n      * @param _data data to indicate validation\r\n      * @return bool success\r\n      */\r\n     function transferWithData(address _to, uint256 _value, bytes _data) external returns (bool success);\r\n\r\n     /**\r\n      * @notice Overloaded version of the transferFrom function\r\n      * @param _from sender of transfer\r\n      * @param _to receiver of transfer\r\n      * @param _value value of transfer\r\n      * @param _data data to indicate validation\r\n      * @return bool success\r\n      */\r\n     function transferFromWithData(address _from, address _to, uint256 _value, bytes _data) external returns(bool);\r\n\r\n     /**\r\n      * @notice Provides the granularity of the token\r\n      * @return uint256\r\n      */\r\n     function granularity() external view returns(uint256);\r\n}\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ninterface IERC20 {\r\n    function decimals() external view returns (uint8);\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address _owner) external view returns (uint256);\r\n    function allowance(address _owner, address _spender) external view returns (uint256);\r\n    function transfer(address _to, uint256 _value) external returns (bool);\r\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool);\r\n    function approve(address _spender, uint256 _value) external returns (bool);\r\n    function decreaseApproval(address _spender, uint _subtractedValue) external returns (bool);\r\n    function increaseApproval(address _spender, uint _addedValue) external returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n/**\r\n * @title Storage for Module contract\r\n * @notice Contract is abstract\r\n */\r\ncontract ModuleStorage {\r\n\r\n    /**\r\n     * @notice Constructor\r\n     * @param _securityToken Address of the security token\r\n     * @param _polyAddress Address of the polytoken\r\n     */\r\n    constructor (address _securityToken, address _polyAddress) public {\r\n        securityToken = _securityToken;\r\n        factory = msg.sender;\r\n        polyToken = IERC20(_polyAddress);\r\n    }\r\n    \r\n    address public factory;\r\n\r\n    address public securityToken;\r\n\r\n    bytes32 public constant FEE_ADMIN = \"FEE_ADMIN\";\r\n\r\n    IERC20 public polyToken;\r\n\r\n}\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipRenounced(address indexed previousOwner);\r\n  event OwnershipTransferred(\r\n    address indexed previousOwner,\r\n    address indexed newOwner\r\n  );\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  constructor() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to relinquish control of the contract.\r\n   */\r\n  function renounceOwnership() public onlyOwner {\r\n    emit OwnershipRenounced(owner);\r\n    owner = address(0);\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address _newOwner) public onlyOwner {\r\n    _transferOwnership(_newOwner);\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function _transferOwnership(address _newOwner) internal {\r\n    require(_newOwner != address(0));\r\n    emit OwnershipTransferred(owner, _newOwner);\r\n    owner = _newOwner;\r\n  }\r\n}\r\n\r\n/**\r\n * @title Interface that any module contract should implement\r\n * @notice Contract is abstract\r\n */\r\ncontract Module is IModule, ModuleStorage {\r\n\r\n    /**\r\n     * @notice Constructor\r\n     * @param _securityToken Address of the security token\r\n     * @param _polyAddress Address of the polytoken\r\n     */\r\n    constructor (address _securityToken, address _polyAddress) public\r\n    ModuleStorage(_securityToken, _polyAddress)\r\n    {\r\n    }\r\n\r\n    //Allows owner, factory or permissioned delegate\r\n    modifier withPerm(bytes32 _perm) {\r\n        bool isOwner = msg.sender == Ownable(securityToken).owner();\r\n        bool isFactory = msg.sender == factory;\r\n        require(isOwner||isFactory||ISecurityToken(securityToken).checkPermission(msg.sender, address(this), _perm), \"Permission check failed\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        require(msg.sender == Ownable(securityToken).owner(), \"Sender is not owner\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyFactory {\r\n        require(msg.sender == factory, \"Sender is not factory\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyFactoryOwner {\r\n        require(msg.sender == Ownable(factory).owner(), \"Sender is not factory owner\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyFactoryOrOwner {\r\n        require((msg.sender == Ownable(securityToken).owner()) || (msg.sender == factory), \"Sender is not factory or owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @notice used to withdraw the fee by the factory owner\r\n     */\r\n    function takeFee(uint256 _amount) public withPerm(FEE_ADMIN) returns(bool) {\r\n        require(polyToken.transferFrom(securityToken, Ownable(factory).owner(), _amount), \"Unable to take fee\");\r\n        return true;\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * @title Interface to be implemented by all Transfer Manager modules\r\n * @dev abstract contract\r\n */\r\ncontract ITransferManager is Module, Pausable {\r\n\r\n    //If verifyTransfer returns:\r\n    //  FORCE_VALID, the transaction will always be valid, regardless of other TM results\r\n    //  INVALID, then the transfer should not be allowed regardless of other TM results\r\n    //  VALID, then the transfer is valid for this TM\r\n    //  NA, then the result from this TM is ignored\r\n    enum Result {INVALID, NA, VALID, FORCE_VALID}\r\n\r\n    function verifyTransfer(address _from, address _to, uint256 _amount, bytes _data, bool _isTransfer) public returns(Result);\r\n\r\n    function unpause() public onlyOwner {\r\n        super._unpause();\r\n    }\r\n\r\n    function pause() public onlyOwner {\r\n        super._pause();\r\n    }\r\n}\r\n\r\n/**\r\n * @title Transfer Manager module for core transfer validation functionality\r\n */\r\ncontract GeneralTransferManagerStorage {\r\n\r\n    //Address from which issuances come\r\n    address public issuanceAddress = address(0);\r\n\r\n    //Address which can sign whitelist changes\r\n    address public signingAddress = address(0);\r\n\r\n    bytes32 public constant WHITELIST = \"WHITELIST\";\r\n    bytes32 public constant FLAGS = \"FLAGS\";\r\n\r\n    //from and to timestamps that an investor can send / receive tokens respectively\r\n    struct TimeRestriction {\r\n        //the moment when the sale lockup period ends and the investor can freely sell or transfer away their tokens\r\n        uint64 canSendAfter;\r\n        //the moment when the purchase lockup period ends and the investor can freely purchase or receive from others\r\n        uint64 canReceiveAfter;\r\n        uint64 expiryTime;\r\n        uint8 canBuyFromSTO;\r\n        uint8 added;\r\n    }\r\n\r\n    // Allows all TimeRestrictions to be offset\r\n    struct Defaults {\r\n        uint64 canSendAfter;\r\n        uint64 canReceiveAfter;\r\n    }\r\n\r\n    // Offset to be applied to all timings (except KYC expiry)\r\n    Defaults public defaults;\r\n\r\n    // List of all addresses that have been added to the GTM at some point\r\n    address[] public investors;\r\n\r\n    // An address can only send / receive tokens once their corresponding uint256 > block.number\r\n    // (unless allowAllTransfers == true or allowAllWhitelistTransfers == true)\r\n    mapping (address => TimeRestriction) public whitelist;\r\n    // Map of used nonces by customer\r\n    mapping(address => mapping(uint256 => bool)) public nonceMap;\r\n\r\n    //If true, there are no transfer restrictions, for any addresses\r\n    bool public allowAllTransfers = false;\r\n    //If true, time lock is ignored for transfers (address must still be on whitelist)\r\n    bool public allowAllWhitelistTransfers = false;\r\n    //If true, time lock is ignored for issuances (address must still be on whitelist)\r\n    bool public allowAllWhitelistIssuances = true;\r\n    //If true, time lock is ignored for burn transactions\r\n    bool public allowAllBurnTransfers = false;\r\n\r\n}\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return a / b;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n/**\r\n * @title Transfer Manager module for core transfer validation functionality\r\n */\r\ncontract GeneralTransferManager is GeneralTransferManagerStorage, ITransferManager {\r\n\r\n    using SafeMath for uint256;\r\n\r\n    // Emit when Issuance address get changed\r\n    event ChangeIssuanceAddress(address _issuanceAddress);\r\n    // Emit when there is change in the flag variable called allowAllTransfers\r\n    event AllowAllTransfers(bool _allowAllTransfers);\r\n    // Emit when there is change in the flag variable called allowAllWhitelistTransfers\r\n    event AllowAllWhitelistTransfers(bool _allowAllWhitelistTransfers);\r\n    // Emit when there is change in the flag variable called allowAllWhitelistIssuances\r\n    event AllowAllWhitelistIssuances(bool _allowAllWhitelistIssuances);\r\n    // Emit when there is change in the flag variable called allowAllBurnTransfers\r\n    event AllowAllBurnTransfers(bool _allowAllBurnTransfers);\r\n    // Emit when there is change in the flag variable called signingAddress\r\n    event ChangeSigningAddress(address _signingAddress);\r\n    // Emit when investor details get modified related to their whitelisting\r\n    event ChangeDefaults(uint64 _defaultCanSendAfter, uint64 _defaultCanReceiveAfter);\r\n\r\n    // _canSendAfter is the time from which the _investor can send tokens\r\n    // _canReceiveAfter is the time from which the _investor can receive tokens\r\n    // if allowAllWhitelistIssuances is TRUE, then _canReceiveAfter is ignored when receiving tokens from the issuance address\r\n    // if allowAllWhitelistTransfers is TRUE, then _canReceiveAfter and _canSendAfter is ignored when sending or receiving tokens\r\n    // in any case, any investor sending or receiving tokens, must have a _expiryTime in the future\r\n    event ModifyWhitelist(\r\n        address indexed _investor,\r\n        uint256 _dateAdded,\r\n        address indexed _addedBy,\r\n        uint256 _canSendAfter,\r\n        uint256 _canReceiveAfter,\r\n        uint256 _expiryTime,\r\n        bool _canBuyFromSTO\r\n    );\r\n\r\n    /**\r\n     * @notice Constructor\r\n     * @param _securityToken Address of the security token\r\n     * @param _polyAddress Address of the polytoken\r\n     */\r\n    constructor (address _securityToken, address _polyAddress)\r\n    public\r\n    Module(_securityToken, _polyAddress)\r\n    {\r\n    }\r\n\r\n    /**\r\n     * @notice This function returns the signature of configure function\r\n     */\r\n    function getInitFunction() public pure returns (bytes4) {\r\n        return bytes4(0);\r\n    }\r\n\r\n    /**\r\n     * @notice Used to change the default times used when canSendAfter / canReceiveAfter are zero\r\n     * @param _defaultCanSendAfter default for zero canSendAfter\r\n     * @param _defaultCanReceiveAfter default for zero canReceiveAfter\r\n     */\r\n    function changeDefaults(uint64 _defaultCanSendAfter, uint64 _defaultCanReceiveAfter) public withPerm(FLAGS) {\r\n        /* 0 values are also allowed as they represent that the Issuer\r\n           does not want a default value for these variables.\r\n           0 is also the default value of these variables */\r\n        defaults.canSendAfter = _defaultCanSendAfter;\r\n        defaults.canReceiveAfter = _defaultCanReceiveAfter;\r\n        emit ChangeDefaults(_defaultCanSendAfter, _defaultCanReceiveAfter);\r\n    }\r\n\r\n    /**\r\n     * @notice Used to change the Issuance Address\r\n     * @param _issuanceAddress new address for the issuance\r\n     */\r\n    function changeIssuanceAddress(address _issuanceAddress) public withPerm(FLAGS) {\r\n        // address(0x0) is also a valid value and in most cases, the address that issues tokens is 0x0.\r\n        issuanceAddress = _issuanceAddress;\r\n        emit ChangeIssuanceAddress(_issuanceAddress);\r\n    }\r\n\r\n    /**\r\n     * @notice Used to change the Sigining Address\r\n     * @param _signingAddress new address for the signing\r\n     */\r\n    function changeSigningAddress(address _signingAddress) public withPerm(FLAGS) {\r\n        /* address(0x0) is also a valid value as an Issuer might want to\r\n           give this permission to nobody (except their own address).\r\n           0x0 is also the default value */\r\n        signingAddress = _signingAddress;\r\n        emit ChangeSigningAddress(_signingAddress);\r\n    }\r\n\r\n    /**\r\n     * @notice Used to change the flag\r\n            true - It refers there are no transfer restrictions, for any addresses\r\n            false - It refers transfers are restricted for all addresses.\r\n     * @param _allowAllTransfers flag value\r\n     */\r\n    function changeAllowAllTransfers(bool _allowAllTransfers) public withPerm(FLAGS) {\r\n        allowAllTransfers = _allowAllTransfers;\r\n        emit AllowAllTransfers(_allowAllTransfers);\r\n    }\r\n\r\n    /**\r\n     * @notice Used to change the flag\r\n            true - It refers that time lock is ignored for transfers (address must still be on whitelist)\r\n            false - It refers transfers are restricted for all addresses.\r\n     * @param _allowAllWhitelistTransfers flag value\r\n     */\r\n    function changeAllowAllWhitelistTransfers(bool _allowAllWhitelistTransfers) public withPerm(FLAGS) {\r\n        allowAllWhitelistTransfers = _allowAllWhitelistTransfers;\r\n        emit AllowAllWhitelistTransfers(_allowAllWhitelistTransfers);\r\n    }\r\n\r\n    /**\r\n     * @notice Used to change the flag\r\n            true - It refers that time lock is ignored for issuances (address must still be on whitelist)\r\n            false - It refers transfers are restricted for all addresses.\r\n     * @param _allowAllWhitelistIssuances flag value\r\n     */\r\n    function changeAllowAllWhitelistIssuances(bool _allowAllWhitelistIssuances) public withPerm(FLAGS) {\r\n        allowAllWhitelistIssuances = _allowAllWhitelistIssuances;\r\n        emit AllowAllWhitelistIssuances(_allowAllWhitelistIssuances);\r\n    }\r\n\r\n    /**\r\n     * @notice Used to change the flag\r\n            true - It allow to burn the tokens\r\n            false - It deactivate the burning mechanism.\r\n     * @param _allowAllBurnTransfers flag value\r\n     */\r\n    function changeAllowAllBurnTransfers(bool _allowAllBurnTransfers) public withPerm(FLAGS) {\r\n        allowAllBurnTransfers = _allowAllBurnTransfers;\r\n        emit AllowAllBurnTransfers(_allowAllBurnTransfers);\r\n    }\r\n\r\n    /**\r\n     * @notice Default implementation of verifyTransfer used by SecurityToken\r\n     * If the transfer request comes from the STO, it only checks that the investor is in the whitelist\r\n     * If the transfer request comes from a token holder, it checks that:\r\n     * a) Both are on the whitelist\r\n     * b) Seller's sale lockup period is over\r\n     * c) Buyer's purchase lockup is over\r\n     * @param _from Address of the sender\r\n     * @param _to Address of the receiver\r\n    */\r\n    function verifyTransfer(address _from, address _to, uint256 /*_amount*/, bytes /* _data */, bool /* _isTransfer */) public returns(Result) {\r\n        if (!paused) {\r\n            if (allowAllTransfers) {\r\n                //All transfers allowed, regardless of whitelist\r\n                return Result.VALID;\r\n            }\r\n            if (allowAllBurnTransfers && (_to == address(0))) {\r\n                return Result.VALID;\r\n            }\r\n            if (allowAllWhitelistTransfers) {\r\n                //Anyone on the whitelist can transfer, regardless of time\r\n                return (_onWhitelist(_to) && _onWhitelist(_from)) ? Result.VALID : Result.NA;\r\n            }\r\n\r\n            (uint64 adjustedCanSendAfter, uint64 adjustedCanReceiveAfter) = _adjustTimes(whitelist[_from].canSendAfter, whitelist[_to].canReceiveAfter);\r\n            if (_from == issuanceAddress) {\r\n                // Possible STO transaction, but investor not allowed to purchased from STO\r\n                if ((whitelist[_to].canBuyFromSTO == 0) && _isSTOAttached()) {\r\n                    return Result.NA;\r\n                }\r\n                // if allowAllWhitelistIssuances is true, so time stamp ignored\r\n                if (allowAllWhitelistIssuances) {\r\n                    return _onWhitelist(_to) ? Result.VALID : Result.NA;\r\n                } else {\r\n                    return (_onWhitelist(_to) && (adjustedCanReceiveAfter <= uint64(now))) ? Result.VALID : Result.NA;\r\n                }\r\n            }\r\n\r\n            //Anyone on the whitelist can transfer provided the blocknumber is large enough\r\n            /*solium-disable-next-line security/no-block-members*/\r\n            return ((_onWhitelist(_from) && (adjustedCanSendAfter <= uint64(now))) &&\r\n                (_onWhitelist(_to) && (adjustedCanReceiveAfter <= uint64(now)))) ? Result.VALID : Result.NA; /*solium-disable-line security/no-block-members*/\r\n        }\r\n        return Result.NA;\r\n    }\r\n\r\n    /**\r\n    * @notice Adds or removes addresses from the whitelist.\r\n    * @param _investor is the address to whitelist\r\n    * @param _canSendAfter the moment when the sale lockup period ends and the investor can freely sell or transfer away their tokens\r\n    * @param _canReceiveAfter the moment when the purchase lockup period ends and the investor can freely purchase or receive from others\r\n    * @param _expiryTime is the moment till investors KYC will be validated. After that investor need to do re-KYC\r\n    * @param _canBuyFromSTO is used to know whether the investor is restricted investor or not.\r\n    */\r\n    function modifyWhitelist(\r\n        address _investor,\r\n        uint256 _canSendAfter,\r\n        uint256 _canReceiveAfter,\r\n        uint256 _expiryTime,\r\n        bool _canBuyFromSTO\r\n    )\r\n        public\r\n        withPerm(WHITELIST)\r\n    {\r\n        _modifyWhitelist(_investor, _canSendAfter, _canReceiveAfter, _expiryTime, _canBuyFromSTO);\r\n    }\r\n\r\n    /**\r\n    * @notice Adds or removes addresses from the whitelist.\r\n    * @param _investor is the address to whitelist\r\n    * @param _canSendAfter is the moment when the sale lockup period ends and the investor can freely sell his tokens\r\n    * @param _canReceiveAfter is the moment when the purchase lockup period ends and the investor can freely purchase tokens from others\r\n    * @param _expiryTime is the moment till investors KYC will be validated. After that investor need to do re-KYC\r\n    * @param _canBuyFromSTO is used to know whether the investor is restricted investor or not.\r\n    */\r\n    function _modifyWhitelist(\r\n        address _investor,\r\n        uint256 _canSendAfter,\r\n        uint256 _canReceiveAfter,\r\n        uint256 _expiryTime,\r\n        bool _canBuyFromSTO\r\n    )\r\n        internal\r\n    {\r\n        require(_investor != address(0), \"Invalid investor\");\r\n        uint8 canBuyFromSTO = 0;\r\n        if (_canBuyFromSTO) {\r\n            canBuyFromSTO = 1;\r\n        }\r\n        if (whitelist[_investor].added == uint8(0)) {\r\n            investors.push(_investor);\r\n        }\r\n        require(\r\n            uint64(_canSendAfter) == _canSendAfter &&\r\n            uint64(_canReceiveAfter) == _canReceiveAfter &&\r\n            uint64(_expiryTime) == _expiryTime,\r\n            \"uint64 overflow\"\r\n        );\r\n        whitelist[_investor] = TimeRestriction(uint64(_canSendAfter), uint64(_canReceiveAfter), uint64(_expiryTime), canBuyFromSTO, uint8(1));\r\n        emit ModifyWhitelist(_investor, now, msg.sender, _canSendAfter, _canReceiveAfter, _expiryTime, _canBuyFromSTO);\r\n    }\r\n\r\n    /**\r\n    * @notice Adds or removes addresses from the whitelist.\r\n    * @param _investors List of the addresses to whitelist\r\n    * @param _canSendAfters An array of the moment when the sale lockup period ends and the investor can freely sell his tokens\r\n    * @param _canReceiveAfters An array of the moment when the purchase lockup period ends and the investor can freely purchase tokens from others\r\n    * @param _expiryTimes An array of the moment till investors KYC will be validated. After that investor need to do re-KYC\r\n    * @param _canBuyFromSTO An array of boolean values\r\n    */\r\n    function modifyWhitelistMulti(\r\n        address[] _investors,\r\n        uint256[] _canSendAfters,\r\n        uint256[] _canReceiveAfters,\r\n        uint256[] _expiryTimes,\r\n        bool[] _canBuyFromSTO\r\n    ) public withPerm(WHITELIST) {\r\n        require(_investors.length == _canSendAfters.length, \"Mismatched input lengths\");\r\n        require(_canSendAfters.length == _canReceiveAfters.length, \"Mismatched input lengths\");\r\n        require(_canReceiveAfters.length == _expiryTimes.length, \"Mismatched input lengths\");\r\n        require(_canBuyFromSTO.length == _canReceiveAfters.length, \"Mismatched input length\");\r\n        for (uint256 i = 0; i < _investors.length; i++) {\r\n            _modifyWhitelist(_investors[i], _canSendAfters[i], _canReceiveAfters[i], _expiryTimes[i], _canBuyFromSTO[i]);\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @notice Adds or removes addresses from the whitelist - can be called by anyone with a valid signature\r\n    * @param _investor is the address to whitelist\r\n    * @param _canSendAfter is the moment when the sale lockup period ends and the investor can freely sell his tokens\r\n    * @param _canReceiveAfter is the moment when the purchase lockup period ends and the investor can freely purchase tokens from others\r\n    * @param _expiryTime is the moment till investors KYC will be validated. After that investor need to do re-KYC\r\n    * @param _canBuyFromSTO is used to know whether the investor is restricted investor or not.\r\n    * @param _validFrom is the time that this signature is valid from\r\n    * @param _validTo is the time that this signature is valid until\r\n    * @param _nonce nonce of signature (avoid replay attack)\r\n    * @param _v issuer signature\r\n    * @param _r issuer signature\r\n    * @param _s issuer signature\r\n    */\r\n    function modifyWhitelistSigned(\r\n        address _investor,\r\n        uint256 _canSendAfter,\r\n        uint256 _canReceiveAfter,\r\n        uint256 _expiryTime,\r\n        bool _canBuyFromSTO,\r\n        uint256 _validFrom,\r\n        uint256 _validTo,\r\n        uint256 _nonce,\r\n        uint8 _v,\r\n        bytes32 _r,\r\n        bytes32 _s\r\n    ) public {\r\n        /*solium-disable-next-line security/no-block-members*/\r\n        require(_validFrom <= now, \"ValidFrom is too early\");\r\n        /*solium-disable-next-line security/no-block-members*/\r\n        require(_validTo >= now, \"ValidTo is too late\");\r\n        require(!nonceMap[_investor][_nonce], \"Already used signature\");\r\n        nonceMap[_investor][_nonce] = true;\r\n        bytes32 hash = keccak256(\r\n            abi.encodePacked(this, _investor, _canSendAfter, _canReceiveAfter, _expiryTime, _canBuyFromSTO, _validFrom, _validTo, _nonce)\r\n        );\r\n        _checkSig(hash, _v, _r, _s);\r\n        _modifyWhitelist(_investor, _canSendAfter, _canReceiveAfter, _expiryTime, _canBuyFromSTO);\r\n    }\r\n\r\n    /**\r\n     * @notice Used to verify the signature\r\n     */\r\n    function _checkSig(bytes32 _hash, uint8 _v, bytes32 _r, bytes32 _s) internal view {\r\n        //Check that the signature is valid\r\n        //sig should be signing - _investor, _canSendAfter, _canReceiveAfter & _expiryTime and be signed by the issuer address\r\n        address signer = ecrecover(keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", _hash)), _v, _r, _s);\r\n        require(signer == Ownable(securityToken).owner() || signer == signingAddress, \"Incorrect signer\");\r\n    }\r\n\r\n    /**\r\n     * @notice Internal function used to check whether the investor is in the whitelist or not\r\n            & also checks whether the KYC of investor get expired or not\r\n     * @param _investor Address of the investor\r\n     */\r\n    function _onWhitelist(address _investor) internal view returns(bool) {\r\n        return (whitelist[_investor].expiryTime >= uint64(now)); /*solium-disable-line security/no-block-members*/\r\n    }\r\n\r\n    /**\r\n     * @notice Internal function use to know whether the STO is attached or not\r\n     */\r\n    function _isSTOAttached() internal view returns(bool) {\r\n        bool attached = ISecurityToken(securityToken).getModulesByType(3).length > 0;\r\n        return attached;\r\n    }\r\n\r\n    /**\r\n     * @notice Internal function to adjust times using default values\r\n     */\r\n    function _adjustTimes(uint64 _canSendAfter, uint64 _canReceiveAfter) internal view returns(uint64, uint64) {\r\n        uint64 adjustedCanSendAfter = _canSendAfter;\r\n        uint64 adjustedCanReceiveAfter = _canReceiveAfter;\r\n        if (_canSendAfter == 0) {\r\n            adjustedCanSendAfter = defaults.canSendAfter;\r\n        }\r\n        if (_canReceiveAfter == 0) {\r\n            adjustedCanReceiveAfter = defaults.canReceiveAfter;\r\n        }\r\n        return (adjustedCanSendAfter, adjustedCanReceiveAfter);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns list of all investors\r\n     */\r\n    function getInvestors() external view returns(address[]) {\r\n        return investors;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns list of all investors data\r\n     */\r\n    function getAllInvestorsData() external view returns(address[], uint256[], uint256[], uint256[], bool[]) {\r\n        (uint256[] memory canSendAfters, uint256[] memory canReceiveAfters, uint256[] memory expiryTimes, bool[] memory canBuyFromSTOs)\r\n          = _investorsData(investors);\r\n        return (investors, canSendAfters, canReceiveAfters, expiryTimes, canBuyFromSTOs);\r\n\r\n    }\r\n\r\n    /**\r\n     * @dev Returns list of specified investors data\r\n     */\r\n    function getInvestorsData(address[] _investors) external view returns(uint256[], uint256[], uint256[], bool[]) {\r\n        return _investorsData(_investors);\r\n    }\r\n\r\n    function _investorsData(address[] _investors) internal view returns(uint256[], uint256[], uint256[], bool[]) {\r\n        uint256[] memory canSendAfters = new uint256[](_investors.length);\r\n        uint256[] memory canReceiveAfters = new uint256[](_investors.length);\r\n        uint256[] memory expiryTimes = new uint256[](_investors.length);\r\n        bool[] memory canBuyFromSTOs = new bool[](_investors.length);\r\n        for (uint256 i = 0; i < _investors.length; i++) {\r\n            canSendAfters[i] = whitelist[_investors[i]].canSendAfter;\r\n            canReceiveAfters[i] = whitelist[_investors[i]].canReceiveAfter;\r\n            expiryTimes[i] = whitelist[_investors[i]].expiryTime;\r\n            if (whitelist[_investors[i]].canBuyFromSTO == 0) {\r\n                canBuyFromSTOs[i] = false;\r\n            } else {\r\n                canBuyFromSTOs[i] = true;\r\n            }\r\n        }\r\n        return (canSendAfters, canReceiveAfters, expiryTimes, canBuyFromSTOs);\r\n    }\r\n\r\n    /**\r\n     * @notice Return the permissions flag that are associated with general trnasfer manager\r\n     */\r\n    function getPermissions() public view returns(bytes32[]) {\r\n        bytes32[] memory allPermissions = new bytes32[](2);\r\n        allPermissions[0] = WHITELIST;\r\n        allPermissions[1] = FLAGS;\r\n        return allPermissions;\r\n    }\r\n\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_investors\",\"type\":\"address[]\"},{\"name\":\"_canSendAfters\",\"type\":\"uint256[]\"},{\"name\":\"_canReceiveAfters\",\"type\":\"uint256[]\"},{\"name\":\"_expiryTimes\",\"type\":\"uint256[]\"},{\"name\":\"_canBuyFromSTO\",\"type\":\"bool[]\"}],\"name\":\"modifyWhitelistMulti\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_investors\",\"type\":\"address[]\"}],\"name\":\"getInvestorsData\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"},{\"name\":\"\",\"type\":\"uint256[]\"},{\"name\":\"\",\"type\":\"uint256[]\"},{\"name\":\"\",\"type\":\"bool[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"allowAllBurnTransfers\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getInitFunction\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes4\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"WHITELIST\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAllInvestorsData\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"},{\"name\":\"\",\"type\":\"uint256[]\"},{\"name\":\"\",\"type\":\"uint256[]\"},{\"name\":\"\",\"type\":\"uint256[]\"},{\"name\":\"\",\"type\":\"bool[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"allowAllWhitelistTransfers\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_allowAllTransfers\",\"type\":\"bool\"}],\"name\":\"changeAllowAllTransfers\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"investors\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_signingAddress\",\"type\":\"address\"}],\"name\":\"changeSigningAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"takeFee\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"polyToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_allowAllWhitelistIssuances\",\"type\":\"bool\"}],\"name\":\"changeAllowAllWhitelistIssuances\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_allowAllWhitelistTransfers\",\"type\":\"bool\"}],\"name\":\"changeAllowAllWhitelistTransfers\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"FLAGS\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"whitelist\",\"outputs\":[{\"name\":\"canSendAfter\",\"type\":\"uint64\"},{\"name\":\"canReceiveAfter\",\"type\":\"uint64\"},{\"name\":\"expiryTime\",\"type\":\"uint64\"},{\"name\":\"canBuyFromSTO\",\"type\":\"uint8\"},{\"name\":\"added\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"nonceMap\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"allowAllTransfers\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getInvestors\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"signingAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"issuanceAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"securityToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getPermissions\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"factory\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"FEE_ADMIN\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_investor\",\"type\":\"address\"},{\"name\":\"_canSendAfter\",\"type\":\"uint256\"},{\"name\":\"_canReceiveAfter\",\"type\":\"uint256\"},{\"name\":\"_expiryTime\",\"type\":\"uint256\"},{\"name\":\"_canBuyFromSTO\",\"type\":\"bool\"}],\"name\":\"modifyWhitelist\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"bytes\"},{\"name\":\"\",\"type\":\"bool\"}],\"name\":\"verifyTransfer\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_issuanceAddress\",\"type\":\"address\"}],\"name\":\"changeIssuanceAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"allowAllWhitelistIssuances\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_allowAllBurnTransfers\",\"type\":\"bool\"}],\"name\":\"changeAllowAllBurnTransfers\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"defaults\",\"outputs\":[{\"name\":\"canSendAfter\",\"type\":\"uint64\"},{\"name\":\"canReceiveAfter\",\"type\":\"uint64\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_defaultCanSendAfter\",\"type\":\"uint64\"},{\"name\":\"_defaultCanReceiveAfter\",\"type\":\"uint64\"}],\"name\":\"changeDefaults\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_investor\",\"type\":\"address\"},{\"name\":\"_canSendAfter\",\"type\":\"uint256\"},{\"name\":\"_canReceiveAfter\",\"type\":\"uint256\"},{\"name\":\"_expiryTime\",\"type\":\"uint256\"},{\"name\":\"_canBuyFromSTO\",\"type\":\"bool\"},{\"name\":\"_validFrom\",\"type\":\"uint256\"},{\"name\":\"_validTo\",\"type\":\"uint256\"},{\"name\":\"_nonce\",\"type\":\"uint256\"},{\"name\":\"_v\",\"type\":\"uint8\"},{\"name\":\"_r\",\"type\":\"bytes32\"},{\"name\":\"_s\",\"type\":\"bytes32\"}],\"name\":\"modifyWhitelistSigned\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_securityToken\",\"type\":\"address\"},{\"name\":\"_polyAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_issuanceAddress\",\"type\":\"address\"}],\"name\":\"ChangeIssuanceAddress\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_allowAllTransfers\",\"type\":\"bool\"}],\"name\":\"AllowAllTransfers\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_allowAllWhitelistTransfers\",\"type\":\"bool\"}],\"name\":\"AllowAllWhitelistTransfers\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_allowAllWhitelistIssuances\",\"type\":\"bool\"}],\"name\":\"AllowAllWhitelistIssuances\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_allowAllBurnTransfers\",\"type\":\"bool\"}],\"name\":\"AllowAllBurnTransfers\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_signingAddress\",\"type\":\"address\"}],\"name\":\"ChangeSigningAddress\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_defaultCanSendAfter\",\"type\":\"uint64\"},{\"indexed\":false,\"name\":\"_defaultCanReceiveAfter\",\"type\":\"uint64\"}],\"name\":\"ChangeDefaults\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_investor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_dateAdded\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"_addedBy\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_canSendAfter\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_canReceiveAfter\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_expiryTime\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_canBuyFromSTO\",\"type\":\"bool\"}],\"name\":\"ModifyWhitelist\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_timestammp\",\"type\":\"uint256\"}],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_timestamp\",\"type\":\"uint256\"}],\"name\":\"Unpause\",\"type\":\"event\"}]","ContractName":"GeneralTransferManager","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000","Library":"","SwarmSource":"bzzr://c378092c63fbc9518e5352b64e71f4a9081811e3e1546f9f65210c91054a9f38"}]}