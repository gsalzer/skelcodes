{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.7;\r\n// @notice SECURITY TOKEN CONTRACT\r\n// @dev ERC-1404 with ERC-20 with ERC223 protection Token Standard Compliant\r\n// @author Geoffrey Tipton at AEN\r\n// ----------------------------------------------------------------------------\r\n// Deployed by : Geoffrey Tipton\r\n// Symbol      : SMPT\r\n// Name        : Smart Pharmaceutical Token\r\n// Total supply: 1,000,000,000\r\n// Decimals    : 8\r\n//\r\n// (c) AENCOIN. The MIT Licence.\r\n// ----------------------------------------------------------------------------\r\n// THE SMPT TOKENS HAVE NOT BEEN REGISTERED UNDER THE U.S. SECURITIES ACT OF\r\n// 1933, AS AMENDED (THE　“SECURITIES ACT”).  THE SMPT TOKENS WERE ISSUED IN\r\n// A TRANSACTION EXEMPT FROM THE REGISTRATION REQUIREMENTS OF THE SECURITIES\r\n// ACT PURSUANT TO REGULATION S PROMULGATED UNDER IT.  THE SMPT TOKENS MAY NOT\r\n// BE OFFERED OR SOLD IN THE UNITED STATES UNLESS REGISTERED UNDER THE SECURITIES\r\n// ACT OR AN EXEMPTION FROM REGISTRATION IS AVAILABLE.  TRANSFERS OF THE SMPT\r\n// TOKENS MAY NOT BE MADE EXCEPT IN ACCORDANCE WITH THE PROVISIONS OF REGULATION S,\r\n// PURSUANT TO REGISTRATION UNDER THE SECURITIES ACT, OR PURSUANT TO AN AVAILABLE\r\n// EXEMPTION FROM REGISTRATION.  FURTHER, HEDGING TRANSACTIONS WITH REGARD TO THE\r\n// SMPT TOKENS MAY NOT BE CONDUCTED UNLESS IN COMPLIANCE WITH THE SECURITIES ACT.\r\n// ----------------------------------------------------------------------------\r\nlibrary SafeMath {\r\n    function add(uint a, uint b) internal pure returns (uint c) {\r\n        c = a + b; require(c >= a,\"Can not add Negative Values\"); }\r\n    function sub(uint a, uint b) internal pure returns (uint c) {\r\n        require(b <= a, \"Result can not be negative\"); c = a - b;  }\r\n    function mul(uint a, uint b) internal pure returns (uint c) {\r\n        c = a * b; require(a == 0 || c / a == b,\"Dived by Zero protection\"); }\r\n    function div(uint a, uint b) internal pure returns (uint c) {\r\n        require(b > 0,\"Devide by Zero protection\"); c = a / b; }\r\n}\r\n\r\n// ----------------------------------------------------------------------------\r\n// ERC Token Standard #20 Interface\r\n// https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md\r\n// ----------------------------------------------------------------------------\r\ncontract ERC20Interface {\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address owner) public view returns (uint256 balance);\r\n    function allowance(address owner, address spender) public view returns (uint remaining);\r\n    function transfer(address to, uint value) public returns (bool success);\r\n    function approve(address spender, uint value) public returns (bool success);\r\n    function transferFrom(address from, address to, uint value) public returns (bool success);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ncontract ERC1404 is ERC20Interface {\r\n    function detectTransferRestriction (address from, address to, uint256 value) public view returns (uint8);\r\n    function messageForTransferRestriction (uint8 restrictionCode) public view returns (string memory);\r\n}\r\n\r\n// ----------------------------------------------------------------------------\r\n// Owned contract\r\n// ----------------------------------------------------------------------------\r\ncontract Owned {\r\n    address public owner;\r\n    address internal newOwner;\r\n\r\n    event OwnershipTransferred(address indexed _from, address indexed _to);\r\n\r\n    constructor() public { //Only on contract creation\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner, \"Only the contract owner can execute this function\");\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address _newOwner) external onlyOwner {\r\n        newOwner = _newOwner;\r\n    }\r\n\r\n    function acceptOwnership() external {\r\n        require(msg.sender == newOwner);\r\n        emit OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n        newOwner = address(0);\r\n    }\r\n}\r\n\r\ncontract Managed is Owned {\r\n    mapping (address => bool) public managers;\r\n\r\n\r\n    modifier onlyManager () {\r\n        require(managers[msg.sender], \"Only managers may perform this action\");\r\n        _;\r\n    }\r\n\r\n    function addManager (address managerAddress) public onlyOwner {\r\n        managers[managerAddress] = true;\r\n    }\r\n\r\n    function removeManager (address managerAddress) external onlyOwner {\r\n        managers[managerAddress] = false;\r\n    }\r\n}\r\n\r\n/* ----------------------------------------------------------------------------\r\n * Contract function to manage the white list\r\n * Byte operation to control function of the whitelist,\r\n * and prevent duplicate address entries. simple example\r\n * whiteList[add] = 0000 = 0x00 = Not allowed to do either\r\n * whiteList[add] = 0001 = 0x01 = Allowed to receive\r\n * whiteList[add] = 0010 = 0x02 = Allowed to send\r\n * whiteList[add] = 0011 = 0x03 = Allowed to Send and Receive\r\n * whiteList[add] = 0100 = 0x04 = Frozen not allowed to do either\r\n *----------------------------------------------------------------------------\r\n */\r\ncontract Whitelist is Managed {\r\n    mapping(address => bytes1) public whiteList;\r\n    bytes1 internal listRule;\r\n    bytes1 internal constant WHITELISTED_CAN_RX_CODE = 0x01;  // binary for 0001\r\n    bytes1 internal constant WHITELISTED_CAN_TX_CODE = 0x02;  // binary for 0010\r\n    bytes1 internal constant WHITELISTED_FREEZE_CODE = 0x04;  // binary for 0100\r\n\r\n    function frozen(address _account) public view returns (bool){ //If account is flagged to freeze return true\r\n        return (WHITELISTED_FREEZE_CODE == (whiteList[_account] & WHITELISTED_FREEZE_CODE)); // 10 & 11 = True\r\n    }\r\n\r\n    function addToSendAllowed(address _to) external onlyManager {\r\n        whiteList[_to] = whiteList[_to] | WHITELISTED_CAN_TX_CODE; // just add the code 1\r\n    }\r\n\r\n    function addToReceiveAllowed(address _to) external onlyManager {\r\n        whiteList[_to] = whiteList[_to] | WHITELISTED_CAN_RX_CODE; // just add the code 2\r\n    }\r\n\r\n    function removeFromSendAllowed(address _to) public onlyManager {\r\n        if (WHITELISTED_CAN_TX_CODE == (whiteList[_to] & WHITELISTED_CAN_TX_CODE))  { //check code 4 so it does toggle when recalled\r\n            whiteList[_to] = whiteList[_to] ^ WHITELISTED_CAN_TX_CODE; // xor the code to remove the flag\r\n        }\r\n    }\r\n\r\n    function removeFromReceiveAllowed(address _to) public onlyManager {\r\n        if (WHITELISTED_CAN_RX_CODE == (whiteList[_to] & WHITELISTED_CAN_RX_CODE))  {\r\n            whiteList[_to] = whiteList[_to] ^ WHITELISTED_CAN_RX_CODE;\r\n        }\r\n    }\r\n\r\n    function removeFromBothSendAndReceiveAllowed (address _to) external onlyManager {\r\n        removeFromSendAllowed(_to);\r\n        removeFromReceiveAllowed(_to);\r\n    }\r\n\r\n    /*  this overides the individual whitelisting and manager positions so a\r\n        frozen account can not be unfrozen by a lower level manager\r\n    */\r\n    function freeze(address _to) external onlyOwner {\r\n        whiteList[_to] = whiteList[_to] | WHITELISTED_FREEZE_CODE; // 4 [0100]\r\n    }\r\n\r\n    function unFreeze(address _to) external onlyOwner {\r\n        if (WHITELISTED_FREEZE_CODE == (whiteList[_to] & WHITELISTED_FREEZE_CODE )) { //Already UnFrozen\r\n            whiteList[_to] = whiteList[_to] ^ WHITELISTED_FREEZE_CODE; // 4 [0100]\r\n        }\r\n    }\r\n\r\n    /*    WhitlistRule defines what the rules are for the white listing.\r\n          0x00 = No rule\r\n          0x01 = Receiver must be Listed\r\n          0x10 = Sender must be listed\r\n          0x11 = Both must be listed\r\n    */\r\n    function setWhitelistRule(byte _newRule) external onlyOwner {\r\n        listRule = _newRule;\r\n    }\r\n    function getWhitelistRule() external view returns (byte){\r\n        return listRule;\r\n    }\r\n}\r\n\r\n// ----------------------------------------------------------------------------\r\n// ERC20 Token, with the addition of symbol, name and decimals and an initial fixed supply\r\ncontract SPTToken is ERC1404, Owned, Whitelist {\r\n    using SafeMath for uint;\r\n\r\n    string public symbol;\r\n    string public  name;\r\n    uint8 public decimals;\r\n    uint public _totalSupply;\r\n    uint8 internal restrictionCheck;\r\n\r\n    mapping(address => uint) public balances;\r\n    mapping(address => mapping(address => uint)) allowed;\r\n\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Constructor\r\n    constructor() public {\r\n        symbol = \"SMPT\";\r\n        name = \"Smart Pharmaceutical Token\";\r\n        decimals = 8;\r\n        _totalSupply = 100000000000000000;\r\n        balances[msg.sender] = _totalSupply;\r\n        managers[msg.sender] = true;\r\n        listRule = 0x00; //Receiver does not need to be whitelisted.\r\n        emit Transfer(address(0), msg.sender, _totalSupply);\r\n    }\r\n\r\n    modifier transferAllowed(address _from, address _to, uint256 _amount ) {\r\n        require(!frozen(_to) && !frozen(_from), \"One of the Accounts are Frozen\");  //If not frozen go check\r\n        if ((listRule & WHITELISTED_CAN_TX_CODE) != 0) { // if whitelist send rul applies then must be set\r\n            require(WHITELISTED_CAN_TX_CODE == (whiteList[_from] & WHITELISTED_CAN_TX_CODE), \"Sending Account is not whitelisted\"); // 10 & 11 = true\r\n        }\r\n        if ((listRule & WHITELISTED_CAN_RX_CODE) != 0) { //if whitelist to receive is required, then check,\r\n            require(WHITELISTED_CAN_RX_CODE == (whiteList[_to] & WHITELISTED_CAN_RX_CODE),\"Receiving Account is not Whitelisted\"); // 01 & 11 = True\r\n        }\r\n        // restrictionCheck = detectTransferRestriction(_from,_to, _amount);\r\n        // require(restrictionCheck==0, messageForTransferRestriction(restrictionCheck) );\r\n        _;\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Total supply minus any lost tokens to the zero address (Potential burn)\r\n    function totalSupply() external view returns (uint) {\r\n        return _totalSupply.sub(balances[address(0)]);\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Get the token balance for account `tokenOwner`\r\n    function balanceOf(address owner) public view returns (uint256) {\r\n        return balances[owner];\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Transfer the balance from token owner's account to `to` account\r\n    // - Owner's account must have sufficient balance to transfer\r\n    // - 0 value transfers are allowed\r\n    // function transfer(address _to, uint _tokens)  public receiveAllowed(_to)  returns (bool success) {\r\n    function transfer(address _to, uint _value)  public transferAllowed(msg.sender, _to, _value) returns (bool) {\r\n        require((_to != address(0)) && (_to != address(this))); // Do not allow transfer to 0x0 or the token contract itself\r\n        balances[msg.sender] = balances[msg.sender].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n        emit Transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Token owner can approve for `spender` to transferFrom(...) `tokens`\r\n    // from the token owner's account\r\n    function approve(address spender, uint value) public transferAllowed(msg.sender, spender, value) returns (bool) {\r\n        allowed[msg.sender][spender] = value;\r\n        emit Approval(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Transfer `tokens` from the `from` account to the `to` account\r\n    function transferFrom(address _from, address _to, uint _value) public transferAllowed(_from, _to, _value) returns (bool) {\r\n        // function transferFrom(address _from, address _to, uint _value) public returns (bool success) {\r\n        require((_to != address(0)) && (_to != address(this))); // Do not allow transfer to 0x0 or the token contract itself\r\n        balances[_from] = balances[_from].sub(_value);\r\n        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n        emit Transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    /* ------------------------------------------------------------------------\r\n     * Returns the amount of tokens approved by the owner that can be\r\n     * transferred to the spender's account\r\n    */\r\n    function allowance(address owner, address spender) public view returns (uint) {\r\n        return allowed[owner][spender];\r\n    }\r\n\r\n    /* ------------------------------------------------------------------------\r\n     * don't accept ETH\r\n     */\r\n    function () payable external {\r\n        revert();\r\n    }\r\n\r\n    /* ------------------------------------------------------------------------\r\n     * @This is a security over ride function that allows error correction.\r\n     * Owner can transfer out any accidentally sent tokens\r\n     * Call the contract address with the token address, which pretends to be the sender\r\n     * The receiving address is the caller of the contract.\r\n     */\r\n    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {\r\n        return ERC20Interface(tokenAddress).transfer(owner, tokens);\r\n    }\r\n\r\n    /* ------------------------------------------------------------------------\r\n     * The following functions are for 1404 interface compliance, to detect\r\n     * a transaction is allowed before sending, to save gas and obtain a clear Message\r\n    */\r\n    function detectTransferRestriction (address _from, address _to, uint256 _value) public view returns (uint8 restrictionCode)\r\n    {\r\n        restrictionCode = 0; // No restrictions\r\n        if ( WHITELISTED_CAN_TX_CODE == (listRule & WHITELISTED_CAN_TX_CODE) ) { //Can Send rule applies\r\n            if (!(WHITELISTED_CAN_TX_CODE == (whiteList[_to] & WHITELISTED_CAN_TX_CODE)) ) { //True if allowed to send\r\n                restrictionCode += 1; // Send is not allowed\r\n            }\r\n        }\r\n        if (WHITELISTED_CAN_RX_CODE == (listRule & WHITELISTED_CAN_RX_CODE)){ // Can Receive Rule applied\r\n            if (!(WHITELISTED_CAN_RX_CODE == (whiteList[_from] & WHITELISTED_CAN_RX_CODE))) {\r\n                restrictionCode += 2; // Receive is not allowed\r\n            }\r\n        }\r\n        if ((WHITELISTED_FREEZE_CODE == (whiteList[_from] & WHITELISTED_FREEZE_CODE)) ) { // Added to Frozen\r\n            restrictionCode += 4; // Sender is Frozen\r\n        }\r\n        if ((WHITELISTED_FREEZE_CODE == (whiteList[_to] & WHITELISTED_FREEZE_CODE)) ) { // Added to Frozen\r\n            restrictionCode += 8; // Receiver is Frozen\r\n        }\r\n\r\n        if (balanceOf(_from) < _value) {\r\n            restrictionCode += 16; // Send has insufficient balance\r\n        }\r\n\r\n        return restrictionCode;\r\n    }\r\n\r\n    /* ------------------------------------------------------------------------------------\r\n    * helper function to return a human readable message for the detectTransferRestriction\r\n    */\r\n    function messageForTransferRestriction (uint8 _restrictionCode) public view returns (string memory _message) {\r\n        _message = \"Transfer Allowed\";  // default and when is zero\r\n        if (_restrictionCode >= 16) {\r\n            _message = \"Insufficient Balance to send\";\r\n        } else if (_restrictionCode >= 8) {\r\n            _message = \"To Account is Frozen, contact provider\";\r\n        } else if (_restrictionCode >= 4) {\r\n            _message = \"From Account is Frozen, contact provider\";\r\n        } else if (_restrictionCode >= 3) {\r\n            _message = \"Both Sending and receiving address has not been KYC Approved\";\r\n        } else if (_restrictionCode >= 2) {\r\n            _message = \"Receiving address has not been KYC Approved\";\r\n        } else if (_restrictionCode >= 1) {\r\n            _message = \"Sending address has not been KYC Approved\";\r\n        }\r\n        return _message;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"removeFromBothSendAndReceiveAllowed\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"removeFromReceiveAllowed\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"addToReceiveAllowed\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"balances\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"managerAddress\",\"type\":\"address\"}],\"name\":\"addManager\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"whiteList\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes1\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newRule\",\"type\":\"bytes1\"}],\"name\":\"setWhitelistRule\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getWhitelistRule\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes1\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_restrictionCode\",\"type\":\"uint8\"}],\"name\":\"messageForTransferRestriction\",\"outputs\":[{\"name\":\"_message\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"unFreeze\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"freeze\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"managerAddress\",\"type\":\"address\"}],\"name\":\"removeManager\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"frozen\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"detectTransferRestriction\",\"outputs\":[{\"name\":\"restrictionCode\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenAddress\",\"type\":\"address\"},{\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"transferAnyERC20Token\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"addToSendAllowed\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"removeFromSendAllowed\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"managers\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"SPTToken","CompilerVersion":"v0.5.7+commit.6da8b019","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://9f8c1a0d521ab37c6c445de7839820a2c4e8a802c632d6f5c3ef5a58609f7cb2"}]}