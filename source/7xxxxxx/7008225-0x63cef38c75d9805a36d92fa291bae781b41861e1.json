{"status":"1","message":"OK","result":[{"SourceCode":"///auto-generated single file for verifying contract on etherscan\r\npragma solidity ^0.4.20;\r\n\r\ncontract SafeMath {\r\n\r\n    function safeAdd(uint256 _x, uint256 _y) internal pure returns (uint256) {\r\n        uint256 z = _x + _y;\r\n        assert(z >= _x);\r\n        return z;\r\n    }\r\n\r\n    function safeSub(uint256 _x, uint256 _y) internal pure returns (uint256) {\r\n        assert(_x >= _y);\r\n        return _x - _y;\r\n    }\r\n\r\n    function safeMul(uint256 _x, uint256 _y) internal pure returns (uint256) {\r\n        uint256 z = _x * _y;\r\n        assert(_x == 0 || z / _x == _y);\r\n        return z;\r\n    }\r\n}\r\n\r\ncontract Ownable {\r\n    address public owner;\r\n\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n\r\n    /**\r\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n     * account.\r\n     */\r\n    function Ownable() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        require(newOwner != address(0));\r\n        OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n}\r\n\r\ncontract Token {\r\n    uint256 public totalSupply;\r\n\r\n    function balanceOf(address _owner) public constant returns (uint256 balance);\r\n\r\n    function transfer(address _to, uint256 _value) public returns (bool success);\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\r\n\r\n    function approve(address _spender, uint256 _value) public returns (bool success);\r\n\r\n    function allowance(address _owner, address _spender) public constant returns (uint256 remaining);\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}\r\ncontract R1Exchange is SafeMath, Ownable {\r\n    mapping(address => bool) public admins;\r\n    mapping(address => bool) public feeAccounts;\r\n    // mapping(token address => mapping(owner address => mapping(channelId uint => uint256))) public tokenList;\r\n    mapping(address => mapping(address => mapping(uint256 => uint256))) public tokenList;\r\n    // mapping(owner address =>  mapping(orderHash bytes32 => uint256)) public tokenList;\r\n    mapping(address => mapping(bytes32 => uint256)) public orderFilled;//tokens filled\r\n    mapping(bytes32 => bool) public withdrawn;\r\n    mapping(address => mapping(address => mapping(uint256 => uint256))) public withdrawAllowance;\r\n    mapping(address => mapping(address => mapping(uint256 => uint256))) public applyList;//withdraw apply list\r\n    mapping(address => mapping(address => mapping(uint256 => uint))) public latestApply;//save the latest apply timestamp\r\n    // mapping(owner address => mapping(channelId uint => nonce uint256))) public canceled;\r\n    mapping(address => mapping(uint256 => uint)) public canceled;\r\n    string public constant version = '2.0.0';\r\n    uint public applyWait = 1 days;\r\n    uint public feeRate = 10;\r\n    bool public withdrawEnabled = false;\r\n    bool public stop = false;\r\n    uint256 private DEFAULT_CHANNEL_ID = 0;\r\n    bool public depositToEnabled = true;\r\n    bool public transferEnabled = false;\r\n    bool public changeChannelEnabled = false;\r\n    event Deposit(address indexed token, address indexed user, uint256 amount, uint256 balance, uint256 channelId);\r\n    event DepositTo(address indexed token, address indexed from, address indexed user, uint256 amount, uint256 balance, uint256 channelId);\r\n    event Withdraw(address indexed token, address indexed user, uint256 amount, uint256 balance, uint256 channelId);\r\n    event ApplyWithdraw(address indexed token, address indexed user, uint256 amount, uint256 time, uint256 channelId);\r\n    event ApproveWithdraw(address indexed token, address indexed user, uint256 channelId);\r\n    event Trade(address indexed maker, address indexed taker, uint256 amount, uint256 makerFee, uint256 takerFee, uint256 makerNonce, uint256 takerNonce);\r\n    event InnerTransfer(address indexed token, address indexed from, address indexed to, uint256 amount, uint256 balance, uint256 channelId);\r\n    event ChangeChannel(address indexed token, address indexed user, uint256 amount, uint256 fromChannelId, uint256 toChannelId);\r\n    event BatchCancel(uint256 count, uint256 channelId);\r\n    modifier onlyAdmin {\r\n        require(admins[msg.sender]);\r\n        _;\r\n    }\r\n    modifier isWithdrawEnabled {\r\n        require(withdrawEnabled);\r\n        _;\r\n    }\r\n    modifier isFeeAccount(address fa) {\r\n        require(feeAccounts[fa]);\r\n        _;\r\n    }\r\n    modifier notStop() {\r\n        require(!stop);\r\n        _;\r\n    }\r\n    modifier isDepositToEnabled() {\r\n        require(depositToEnabled);\r\n        _;\r\n    }\r\n    modifier isTransferEnabled() {\r\n        require(transferEnabled);\r\n        _;\r\n    }\r\n    modifier isChangeChannelEnabled() {\r\n        require(changeChannelEnabled);\r\n        _;\r\n    }\r\n    function() public {\r\n        revert();\r\n    }\r\n    function setAdmin(address admin, bool isAdmin) public onlyOwner {\r\n        require(admin != 0);\r\n        admins[admin] = isAdmin;\r\n    }\r\n    function setFeeAccount(address acc, bool asFee) public onlyOwner {\r\n        require(acc != 0);\r\n        feeAccounts[acc] = asFee;\r\n    }\r\n    function enableWithdraw(bool enabled) public onlyOwner {\r\n        withdrawEnabled = enabled;\r\n    }\r\n    function enableDepositTo(bool enabled) public onlyOwner {\r\n        depositToEnabled = enabled;\r\n    }\r\n    function enableTransfer(bool enabled) public onlyOwner {\r\n        transferEnabled = enabled;\r\n    }\r\n    function enableChangeChannel(bool enabled) public onlyOwner {\r\n        changeChannelEnabled = enabled;\r\n    }\r\n    function changeLockTime(uint lock) public onlyOwner {\r\n        require(lock <= 7 days);\r\n        applyWait = lock;\r\n    }\r\n    function changeFeeRate(uint fr) public onlyOwner {\r\n        //max fee rate MUST <=10%\r\n        require(fr >= 10);\r\n        feeRate = fr;\r\n    }\r\n    function stopTrade() public onlyOwner {\r\n        stop = true;\r\n    }\r\n    /**\r\n    * cancel the order that before nonce.\r\n    **/\r\n    function batchCancel(address[] users, uint256[] nonces, uint256 channelId) public onlyAdmin {\r\n        require(users.length == nonces.length);\r\n        uint256 count = 0;\r\n        for (uint i = 0; i < users.length; i++) {\r\n            require(nonces[i] >= canceled[users[i]][channelId]);\r\n            canceled[users[i]][channelId] = nonces[i];\r\n            count++;\r\n        }\r\n        BatchCancel(count, channelId);\r\n    }\r\n    function deposit(uint256 channelId) public payable {\r\n        tokenList[0][msg.sender][channelId] = safeAdd(tokenList[0][msg.sender][channelId], msg.value);\r\n        Deposit(0, msg.sender, msg.value, tokenList[0][msg.sender][channelId], channelId);\r\n    }\r\n    function depositToken(address token, uint256 amount, uint256 channelId) public {\r\n        require(token != 0);\r\n        tokenList[token][msg.sender][channelId] = safeAdd(tokenList[token][msg.sender][channelId], amount);\r\n        require(Token(token).transferFrom(msg.sender, this, amount));\r\n        Deposit(token, msg.sender, amount, tokenList[token][msg.sender][channelId], channelId);\r\n    }\r\n    function depositTo(address to, uint256 channelId) public payable isDepositToEnabled {\r\n        require(to != 0 && msg.value > 0);\r\n        tokenList[0][to][channelId] = safeAdd(tokenList[0][to][channelId], msg.value);\r\n        DepositTo(0, msg.sender, to, msg.value, tokenList[0][to][channelId], channelId);\r\n    }\r\n    function depositTokenTo(address token, address to, uint256 amount, uint256 channelId) public isDepositToEnabled {\r\n        require(token != 0 && to != 0 && amount > 0);\r\n        tokenList[token][to][channelId] = safeAdd(tokenList[token][to][channelId], amount);\r\n        require(Token(token).transferFrom(msg.sender, this, amount));\r\n        DepositTo(token, msg.sender, to, amount, tokenList[token][to][channelId], channelId);\r\n    }\r\n    function batchDepositTokenTo(address[] token, address[] to, uint256[] amount, uint256 channelId) public isDepositToEnabled {\r\n        require(to.length == amount.length && to.length <= 200);\r\n        for (uint i = 0; i < to.length; i++) {\r\n            depositTokenTo(token[i], to[i], amount[i], channelId);\r\n        }\r\n    }\r\n    function innerTransfer(address token, address to, uint256 amount, uint256 channelId) public isTransferEnabled {\r\n        require(to != 0);\r\n        require(amount <= tokenList[token][msg.sender][channelId]);\r\n        tokenList[token][msg.sender][channelId] = safeSub(tokenList[token][msg.sender][channelId], amount);\r\n        tokenList[token][to][channelId] = safeAdd(tokenList[token][to][channelId], amount);\r\n        InnerTransfer(token, msg.sender, to, amount, tokenList[token][msg.sender][channelId], channelId);\r\n    }\r\n    function batchInnerTransfer(address[] token, address[] to, uint256[] amount, uint256 channelId) public isTransferEnabled {\r\n        require(to.length == amount.length && to.length <= 200);\r\n        for (uint i = 0; i < to.length; i++) {\r\n            innerTransfer(token[i], to[i], amount[i], channelId);\r\n        }\r\n    }\r\n    function changeChannel(address token, uint256 amount, uint256 fromChannelId, uint256 toChannelId) public isChangeChannelEnabled {\r\n        require(amount <= tokenList[token][msg.sender][fromChannelId]);\r\n        tokenList[token][msg.sender][fromChannelId] = safeSub(tokenList[token][msg.sender][fromChannelId], amount);\r\n        tokenList[token][msg.sender][toChannelId] = safeAdd(tokenList[token][msg.sender][toChannelId], amount);\r\n        ChangeChannel(token, msg.sender, amount, fromChannelId, toChannelId);\r\n    }\r\n    function batchChangeChannel(address[] token, uint256[] amount, uint256 fromChannelId, uint256 toChannelId) public isChangeChannelEnabled {\r\n        require(token.length == amount.length && amount.length <= 200);\r\n        for (uint i = 0; i < amount.length; i++) {\r\n            changeChannel(token[i], amount[i], fromChannelId, toChannelId);\r\n        }\r\n    }\r\n    function applyWithdraw(address token, uint256 amount, uint256 channelId) public {\r\n        uint256 apply = safeAdd(applyList[token][msg.sender][channelId], amount);\r\n        require(safeAdd(apply, withdrawAllowance[token][msg.sender][channelId]) <= tokenList[token][msg.sender][channelId]);\r\n        applyList[token][msg.sender][channelId] = apply;\r\n        latestApply[token][msg.sender][channelId] = block.timestamp;\r\n        ApplyWithdraw(token, msg.sender, amount, block.timestamp, channelId);\r\n    }\r\n    /**\r\n    * approve user's withdraw application\r\n    **/\r\n    function approveWithdraw(address token, address user, uint256 channelId) public onlyAdmin {\r\n        withdrawAllowance[token][user][channelId] = safeAdd(withdrawAllowance[token][user][channelId], applyList[token][user][channelId]);\r\n        applyList[token][user][channelId] = 0;\r\n        latestApply[token][user][channelId] = 0;\r\n        ApproveWithdraw(token, user, channelId);\r\n    }\r\n    /**\r\n    * user's withdraw will success in two cases:\r\n    *    1. when the admin calls the approveWithdraw function;\r\n    * or 2. when the lock time has passed since the application;\r\n    **/\r\n    function withdraw(address token, uint256 amount, uint256 channelId) public {\r\n        require(amount <= tokenList[token][msg.sender][channelId]);\r\n        if (amount > withdrawAllowance[token][msg.sender][channelId]) {\r\n            //withdraw wait over time\r\n            require(latestApply[token][msg.sender][channelId] != 0 && safeSub(block.timestamp, latestApply[token][msg.sender][channelId]) > applyWait);\r\n            withdrawAllowance[token][msg.sender][channelId] = safeAdd(withdrawAllowance[token][msg.sender][channelId], applyList[token][msg.sender][channelId]);\r\n            applyList[token][msg.sender][channelId] = 0;\r\n        }\r\n        require(amount <= withdrawAllowance[token][msg.sender][channelId]);\r\n        withdrawAllowance[token][msg.sender][channelId] = safeSub(withdrawAllowance[token][msg.sender][channelId], amount);\r\n        tokenList[token][msg.sender][channelId] = safeSub(tokenList[token][msg.sender][channelId], amount);\r\n        latestApply[token][msg.sender][channelId] = 0;\r\n        if (token == 0) {//withdraw ether\r\n            require(msg.sender.send(amount));\r\n        } else {//withdraw token\r\n            require(Token(token).transfer(msg.sender, amount));\r\n        }\r\n        Withdraw(token, msg.sender, amount, tokenList[token][msg.sender][channelId], channelId);\r\n    }\r\n    /**\r\n    * withdraw directly when withdrawEnabled=true\r\n    **/\r\n    function withdrawNoLimit(address token, uint256 amount, uint256 channelId) public isWithdrawEnabled {\r\n        require(amount <= tokenList[token][msg.sender][channelId]);\r\n        tokenList[token][msg.sender][channelId] = safeSub(tokenList[token][msg.sender][channelId], amount);\r\n        if (token == 0) {//withdraw ether\r\n            require(msg.sender.send(amount));\r\n        } else {//withdraw token\r\n            require(Token(token).transfer(msg.sender, amount));\r\n        }\r\n        Withdraw(token, msg.sender, amount, tokenList[token][msg.sender][channelId], channelId);\r\n    }\r\n    struct AdminWithdrawParam {\r\n        address user;\r\n        address token;\r\n        address feeAccount;\r\n        address channelFeeAccount;\r\n        uint256 amount;\r\n        uint256 nonce;\r\n        uint256 fee;\r\n        uint256 channelFee;\r\n        uint256 channelId;\r\n    }\r\n    /**\r\n    * admin withdraw according to user's signed withdraw info\r\n    * PARAMS:\r\n    * addresses:\r\n    * [0] user\r\n    * [1] token\r\n    * [2] feeAccount\r\n    * [3] channelFeeAccount\r\n    * values:\r\n    * [0] amount\r\n    * [1] nonce\r\n    * [2] fee\r\n    * [3] channelFee\r\n    * [4] channelId\r\n    **/\r\n    function adminWithdraw(address[4] addresses, uint256[5] values, uint8 v, bytes32 r, bytes32 s)\r\n    public\r\n    onlyAdmin\r\n    isFeeAccount(addresses[2])\r\n    {\r\n        AdminWithdrawParam memory param = AdminWithdrawParam({\r\n            user : addresses[0],\r\n            token : addresses[1],\r\n            feeAccount : addresses[2],\r\n            channelFeeAccount : addresses[3],\r\n            amount : values[0],\r\n            nonce : values[1],\r\n            fee : values[2],\r\n            channelFee : values[3],\r\n            channelId : values[4]\r\n            });\r\n        require(param.amount <= tokenList[param.token][param.user][param.channelId]);\r\n        param.fee = checkFee(param.amount, param.fee);\r\n        param.channelFee = checkFee(param.amount, param.channelFee);\r\n        bytes32 hash = keccak256(this, param.user, param.token, param.amount, param.nonce, param.channelFeeAccount, param.channelId);\r\n        require(!withdrawn[hash]);\r\n        withdrawn[hash] = true;\r\n        require(ecrecover(keccak256(\"\\x19Ethereum Signed Message:\\n32\", hash), v, r, s) == param.user);\r\n        tokenList[param.token][param.user][param.channelId] = safeSub(tokenList[param.token][param.user][param.channelId], param.amount);\r\n        tokenList[param.token][param.feeAccount][DEFAULT_CHANNEL_ID] = safeAdd(tokenList[param.token][param.feeAccount][DEFAULT_CHANNEL_ID], param.fee);\r\n        tokenList[param.token][param.channelFeeAccount][param.channelId] = safeAdd(tokenList[param.token][param.channelFeeAccount][param.channelId], param.channelFee);\r\n        param.amount = safeSub(param.amount, param.fee);\r\n        param.amount = safeSub(param.amount, param.channelFee);\r\n        if (param.token == 0) {//withdraw ether\r\n            require(param.user.send(param.amount));\r\n        } else {//withdraw token\r\n            require(Token(param.token).transfer(param.user, param.amount));\r\n        }\r\n        Withdraw(param.token, param.user, param.amount, tokenList[param.token][param.user][param.channelId], param.channelId);\r\n    }\r\n    function checkFee(uint256 amount, uint256 fee) private returns (uint256){\r\n        uint256 maxFee = fee;\r\n        if (safeMul(fee, feeRate) > amount) {\r\n            maxFee = amount / feeRate;\r\n        }\r\n        return maxFee;\r\n    }\r\n    function getOrderHash(address tokenBuy, uint256 amountBuy, address tokenSell, uint256 amountSell, address base, uint256 expires, uint256 nonce, address feeToken, address channelFeeAccount, uint256 channelId) public view returns (bytes32) {\r\n        return keccak256(this, tokenBuy, amountBuy, tokenSell, amountSell, base, expires, nonce, feeToken, channelFeeAccount, channelId);\r\n    }\r\n    function balanceOf(address token, address user, uint256 channelId) public constant returns (uint256) {\r\n        return tokenList[token][user][channelId];\r\n    }\r\n    struct Order {\r\n        address tokenBuy;\r\n        address tokenSell;\r\n        uint256 amountBuy;\r\n        uint256 amountSell;\r\n        address user;\r\n        uint256 fee;\r\n        uint256 expires;\r\n        uint256 nonce;\r\n        bytes32 orderHash;\r\n        address baseToken;\r\n        address feeToken;//0:default;others:payed with erc-20 token\r\n        address channelFeeAccount;\r\n        uint256 channelFee;\r\n        uint256 channelId;\r\n    }\r\n    /**\r\n    * swap maker and taker's tokens according to their signed order info.\r\n    *\r\n    * PARAMS:\r\n    * addresses:\r\n    * [0]:maker tokenBuy\r\n    * [1]:taker tokenBuy\r\n    * [2]:maker tokenSell\r\n    * [3]:taker tokenSell\r\n    * [4]:maker user\r\n    * [5]:taker user\r\n    * [6]:maker baseTokenAddr .default:0 ,then baseToken is ETH\r\n    * [7]:taker baseTokenAddr .default:0 ,then baseToken is ETH\r\n    * [8]:maker feeToken .\r\n    * [9]:taker feeToken .\r\n    * [10]:feeAccount\r\n    * [11]:makerChannelAccount\r\n    * [12]:takerChannelAccount\r\n    * values:\r\n    * [0]:maker amountBuy\r\n    * [1]:taker amountBuy\r\n    * [2]:maker amountSell\r\n    * [3]:taker amountSell\r\n    * [4]:maker fee\r\n    * [5]:taker fee\r\n    * [6]:maker expires\r\n    * [7]:taker expires\r\n    * [8]:maker nonce\r\n    * [9]:taker nonce\r\n    * [10]:tradeAmount of token\r\n    * [11]:makerChannelFee\r\n    * [12]:takerChannelFee\r\n    * [13]:makerChannelId\r\n    * [14]:takerChannelId\r\n    * v,r,s:maker and taker's signature\r\n    **/\r\n    function trade(\r\n        address[13] addresses,\r\n        uint256[15] values,\r\n        uint8[2] v,\r\n        bytes32[2] r,\r\n        bytes32[2] s\r\n    ) public\r\n    onlyAdmin\r\n    isFeeAccount(addresses[10])\r\n    notStop\r\n    {\r\n        Order memory makerOrder = Order({\r\n            tokenBuy : addresses[0],\r\n            tokenSell : addresses[2],\r\n            user : addresses[4],\r\n            amountBuy : values[0],\r\n            amountSell : values[2],\r\n            fee : values[4],\r\n            expires : values[6],\r\n            nonce : values[8],\r\n            orderHash : 0,\r\n            baseToken : addresses[6],\r\n            feeToken : addresses[8],\r\n            channelFeeAccount : addresses[11],\r\n            channelFee : values[11],\r\n            channelId : values[13]\r\n            });\r\n        Order memory takerOrder = Order({\r\n            tokenBuy : addresses[1],\r\n            tokenSell : addresses[3],\r\n            user : addresses[5],\r\n            amountBuy : values[1],\r\n            amountSell : values[3],\r\n            fee : values[5],\r\n            expires : values[7],\r\n            nonce : values[9],\r\n            orderHash : 0,\r\n            baseToken : addresses[7],\r\n            feeToken : addresses[9],\r\n            channelFeeAccount : addresses[12],\r\n            channelFee : values[12],\r\n            channelId : values[14]\r\n            });\r\n        uint256 tradeAmount = values[10];\r\n        //check expires\r\n        require(makerOrder.expires >= block.number && takerOrder.expires >= block.number);\r\n        //check order nonce canceled\r\n        require(makerOrder.nonce >= canceled[makerOrder.user][makerOrder.channelId] && takerOrder.nonce >= canceled[takerOrder.user][takerOrder.channelId]);\r\n        //make sure both is the same trade pair\r\n        require(makerOrder.baseToken == takerOrder.baseToken && makerOrder.tokenBuy == takerOrder.tokenSell && makerOrder.tokenSell == takerOrder.tokenBuy);\r\n        require(takerOrder.baseToken == takerOrder.tokenBuy || takerOrder.baseToken == takerOrder.tokenSell);\r\n        makerOrder.orderHash = getOrderHash(makerOrder.tokenBuy, makerOrder.amountBuy, makerOrder.tokenSell, makerOrder.amountSell, makerOrder.baseToken, makerOrder.expires, makerOrder.nonce, makerOrder.feeToken, makerOrder.channelFeeAccount, makerOrder.channelId);\r\n        takerOrder.orderHash = getOrderHash(takerOrder.tokenBuy, takerOrder.amountBuy, takerOrder.tokenSell, takerOrder.amountSell, takerOrder.baseToken, takerOrder.expires, takerOrder.nonce, takerOrder.feeToken, takerOrder.channelFeeAccount, takerOrder.channelId);\r\n        require(ecrecover(keccak256(\"\\x19Ethereum Signed Message:\\n32\", makerOrder.orderHash), v[0], r[0], s[0]) == makerOrder.user);\r\n        require(ecrecover(keccak256(\"\\x19Ethereum Signed Message:\\n32\", takerOrder.orderHash), v[1], r[1], s[1]) == takerOrder.user);\r\n        balance(makerOrder, takerOrder, addresses[10], tradeAmount);\r\n        //event\r\n        Trade(makerOrder.user, takerOrder.user, tradeAmount, makerOrder.fee, takerOrder.fee, makerOrder.nonce, takerOrder.nonce);\r\n    }\r\n    function balance(Order makerOrder, Order takerOrder, address feeAccount, uint256 tradeAmount) internal {\r\n        ///check the price meets the condition.\r\n        ///match condition: (makerOrder.amountSell*takerOrder.amountSell)/(makerOrder.amountBuy*takerOrder.amountBuy) >=1\r\n        require(safeMul(makerOrder.amountSell, takerOrder.amountSell) >= safeMul(makerOrder.amountBuy, takerOrder.amountBuy));\r\n        ///If the price is ok,always use maker's price first!\r\n        uint256 takerBuy = 0;\r\n        uint256 takerSell = 0;\r\n        if (takerOrder.baseToken == takerOrder.tokenBuy) {\r\n            //taker sell tokens\r\n            uint256 makerAmount = safeSub(makerOrder.amountBuy, orderFilled[makerOrder.user][makerOrder.orderHash]);\r\n            uint256 takerAmount = safeSub(takerOrder.amountSell, orderFilled[takerOrder.user][takerOrder.orderHash]);\r\n            require(tradeAmount > 0 && tradeAmount <= makerAmount && tradeAmount <= takerAmount);\r\n            takerSell = tradeAmount;\r\n            takerBuy = safeMul(makerOrder.amountSell, takerSell) / makerOrder.amountBuy;\r\n            orderFilled[takerOrder.user][takerOrder.orderHash] = safeAdd(orderFilled[takerOrder.user][takerOrder.orderHash], takerSell);\r\n            orderFilled[makerOrder.user][makerOrder.orderHash] = safeAdd(orderFilled[makerOrder.user][makerOrder.orderHash], takerSell);\r\n        } else {\r\n            // taker buy tokens\r\n            takerAmount = safeSub(takerOrder.amountBuy, orderFilled[takerOrder.user][takerOrder.orderHash]);\r\n            makerAmount = safeSub(makerOrder.amountSell, orderFilled[makerOrder.user][makerOrder.orderHash]);\r\n            require(tradeAmount > 0 && tradeAmount <= makerAmount && tradeAmount <= takerAmount);\r\n            takerBuy = tradeAmount;\r\n            takerSell = safeMul(makerOrder.amountBuy, takerBuy) / makerOrder.amountSell;\r\n            orderFilled[takerOrder.user][takerOrder.orderHash] = safeAdd(orderFilled[takerOrder.user][takerOrder.orderHash], takerBuy);\r\n            orderFilled[makerOrder.user][makerOrder.orderHash] = safeAdd(orderFilled[makerOrder.user][makerOrder.orderHash], takerBuy);\r\n        }\r\n        //taker give tokens\r\n        tokenList[takerOrder.tokenSell][takerOrder.user][takerOrder.channelId] = safeSub(tokenList[takerOrder.tokenSell][takerOrder.user][takerOrder.channelId], takerSell);\r\n        //taker get tokens\r\n        tokenList[takerOrder.tokenBuy][takerOrder.user][takerOrder.channelId] = safeAdd(tokenList[takerOrder.tokenBuy][takerOrder.user][takerOrder.channelId], takerBuy);\r\n        //maker give tokens\r\n        tokenList[makerOrder.tokenSell][makerOrder.user][makerOrder.channelId] = safeSub(tokenList[makerOrder.tokenSell][makerOrder.user][makerOrder.channelId], takerBuy);\r\n        //maker get tokens\r\n        tokenList[makerOrder.tokenBuy][makerOrder.user][makerOrder.channelId] = safeAdd(tokenList[makerOrder.tokenBuy][makerOrder.user][makerOrder.channelId], takerSell);\r\n        chargeFee(makerOrder, feeAccount, takerSell);\r\n        chargeFee(takerOrder, feeAccount, takerBuy);\r\n    }\r\n    ///charge fees.fee can be payed as other erc20 token or the tokens that user get\r\n    ///returns:fees to reduce from the user's tokenBuy\r\n    function chargeFee(Order order, address feeAccount, uint256 amountBuy) internal returns (uint256){\r\n        uint256 totalFee = 0;\r\n        if (order.feeToken != 0) {\r\n            ///use erc-20 token as fee .\r\n            //make sure the user has enough tokens\r\n            totalFee = safeAdd(order.fee, order.channelFee);\r\n            require(totalFee <= tokenList[order.feeToken][order.user][order.channelId]);\r\n            tokenList[order.feeToken][feeAccount][DEFAULT_CHANNEL_ID] = safeAdd(tokenList[order.feeToken][feeAccount][DEFAULT_CHANNEL_ID], order.fee);\r\n            tokenList[order.feeToken][order.channelFeeAccount][order.channelId] = safeAdd(tokenList[order.feeToken][order.channelFeeAccount][order.channelId], order.channelFee);\r\n            tokenList[order.feeToken][order.user][order.channelId] = safeSub(tokenList[order.feeToken][order.user][order.channelId], totalFee);\r\n        } else {\r\n            order.fee = checkFee(amountBuy, order.fee);\r\n            order.channelFee = checkFee(amountBuy, order.channelFee);\r\n            totalFee = safeAdd(order.fee, order.channelFee);\r\n            tokenList[order.tokenBuy][feeAccount][DEFAULT_CHANNEL_ID] = safeAdd(tokenList[order.tokenBuy][feeAccount][DEFAULT_CHANNEL_ID], order.fee);\r\n            tokenList[order.tokenBuy][order.channelFeeAccount][order.channelId] = safeAdd(tokenList[order.tokenBuy][order.channelFeeAccount][order.channelId], order.channelFee);\r\n            tokenList[order.tokenBuy][order.user][order.channelId] = safeSub(tokenList[order.tokenBuy][order.user][order.channelId], totalFee);\r\n        }\r\n    }\r\n    function batchTrade(\r\n        address[13][] addresses,\r\n        uint256[15][] values,\r\n        uint8[2][] v,\r\n        bytes32[2][] r,\r\n        bytes32[2][] s\r\n    ) public onlyAdmin {\r\n        for (uint i = 0; i < addresses.length; i++) {\r\n            trade(addresses[i], values[i], v[i], r[i], s[i]);\r\n        }\r\n    }\r\n    ///help to refund token to users.this method is called when contract needs updating\r\n    function refund(address user, address[] tokens, uint256[] channelIds) public onlyAdmin {\r\n        for (uint i = 0; i < tokens.length; i++) {\r\n            address token = tokens[i];\r\n            for (uint j = 0; j < channelIds.length; j++) {\r\n                uint256 channelId = channelIds[j];\r\n                uint256 amount = tokenList[token][user][channelId];\r\n                if (amount > 0) {\r\n                    tokenList[token][user][channelId] = 0;\r\n                    if (token == 0) {//withdraw ether\r\n                        require(user.send(amount));\r\n                    } else {//withdraw token\r\n                        require(Token(token).transfer(user, amount));\r\n                    }\r\n                    Withdraw(token, user, amount, tokenList[token][user][channelId], channelId);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"stop\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenBuy\",\"type\":\"address\"},{\"name\":\"amountBuy\",\"type\":\"uint256\"},{\"name\":\"tokenSell\",\"type\":\"address\"},{\"name\":\"amountSell\",\"type\":\"uint256\"},{\"name\":\"base\",\"type\":\"address\"},{\"name\":\"expires\",\"type\":\"uint256\"},{\"name\":\"nonce\",\"type\":\"uint256\"},{\"name\":\"feeToken\",\"type\":\"address\"},{\"name\":\"channelFeeAccount\",\"type\":\"address\"},{\"name\":\"channelId\",\"type\":\"uint256\"}],\"name\":\"getOrderHash\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address[]\"},{\"name\":\"amount\",\"type\":\"uint256[]\"},{\"name\":\"fromChannelId\",\"type\":\"uint256\"},{\"name\":\"toChannelId\",\"type\":\"uint256\"}],\"name\":\"batchChangeChannel\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"applyList\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"withdrawEnabled\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"channelId\",\"type\":\"uint256\"}],\"name\":\"withdrawNoLimit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokenList\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"withdrawn\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"depositToEnabled\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"user\",\"type\":\"address\"},{\"name\":\"tokens\",\"type\":\"address[]\"},{\"name\":\"channelIds\",\"type\":\"uint256[]\"}],\"name\":\"refund\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"admins\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"admin\",\"type\":\"address\"},{\"name\":\"isAdmin\",\"type\":\"bool\"}],\"name\":\"setAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"transferEnabled\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"channelId\",\"type\":\"uint256\"}],\"name\":\"innerTransfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"orderFilled\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"changeChannelEnabled\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"channelId\",\"type\":\"uint256\"}],\"name\":\"applyWithdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"channelId\",\"type\":\"uint256\"}],\"name\":\"depositTokenTo\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"user\",\"type\":\"address\"},{\"name\":\"channelId\",\"type\":\"uint256\"}],\"name\":\"approveWithdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"users\",\"type\":\"address[]\"},{\"name\":\"nonces\",\"type\":\"uint256[]\"},{\"name\":\"channelId\",\"type\":\"uint256\"}],\"name\":\"batchCancel\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address[]\"},{\"name\":\"to\",\"type\":\"address[]\"},{\"name\":\"amount\",\"type\":\"uint256[]\"},{\"name\":\"channelId\",\"type\":\"uint256\"}],\"name\":\"batchDepositTokenTo\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"stopTrade\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"enableWithdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"lock\",\"type\":\"uint256\"}],\"name\":\"changeLockTime\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"feeRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"channelId\",\"type\":\"uint256\"}],\"name\":\"depositToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"acc\",\"type\":\"address\"},{\"name\":\"asFee\",\"type\":\"bool\"}],\"name\":\"setFeeAccount\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"enableDepositTo\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"fromChannelId\",\"type\":\"uint256\"},{\"name\":\"toChannelId\",\"type\":\"uint256\"}],\"name\":\"changeChannel\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addresses\",\"type\":\"address[13]\"},{\"name\":\"values\",\"type\":\"uint256[15]\"},{\"name\":\"v\",\"type\":\"uint8[2]\"},{\"name\":\"r\",\"type\":\"bytes32[2]\"},{\"name\":\"s\",\"type\":\"bytes32[2]\"}],\"name\":\"trade\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addresses\",\"type\":\"address[13][]\"},{\"name\":\"values\",\"type\":\"uint256[15][]\"},{\"name\":\"v\",\"type\":\"uint8[2][]\"},{\"name\":\"r\",\"type\":\"bytes32[2][]\"},{\"name\":\"s\",\"type\":\"bytes32[2][]\"}],\"name\":\"batchTrade\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"fr\",\"type\":\"uint256\"}],\"name\":\"changeFeeRate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"canceled\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"enableChangeChannel\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"channelId\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"channelId\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address[]\"},{\"name\":\"to\",\"type\":\"address[]\"},{\"name\":\"amount\",\"type\":\"uint256[]\"},{\"name\":\"channelId\",\"type\":\"uint256\"}],\"name\":\"batchInnerTransfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"latestApply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"feeAccounts\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"withdrawAllowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"user\",\"type\":\"address\"},{\"name\":\"channelId\",\"type\":\"uint256\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"enableTransfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"applyWait\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addresses\",\"type\":\"address[4]\"},{\"name\":\"values\",\"type\":\"uint256[5]\"},{\"name\":\"v\",\"type\":\"uint8\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"adminWithdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"channelId\",\"type\":\"uint256\"}],\"name\":\"depositTo\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"balance\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"channelId\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"balance\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"channelId\",\"type\":\"uint256\"}],\"name\":\"DepositTo\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"balance\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"channelId\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"time\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"channelId\",\"type\":\"uint256\"}],\"name\":\"ApplyWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"channelId\",\"type\":\"uint256\"}],\"name\":\"ApproveWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"maker\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"taker\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"makerFee\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"takerFee\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"makerNonce\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"takerNonce\",\"type\":\"uint256\"}],\"name\":\"Trade\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"balance\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"channelId\",\"type\":\"uint256\"}],\"name\":\"InnerTransfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"fromChannelId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"toChannelId\",\"type\":\"uint256\"}],\"name\":\"ChangeChannel\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"count\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"channelId\",\"type\":\"uint256\"}],\"name\":\"BatchCancel\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"R1Exchange","CompilerVersion":"v0.4.20+commit.3155dd80","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://0d1225673238323992ca55afee13200a0daef9e7ac34865282ae9922677b1c6c"}]}