{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\n/**\r\n * @title LotteryInterface\r\n */\r\ninterface LotteryInterface {\r\n\tfunction claimReward(address playerAddress, uint256 tokenAmount) external returns (bool);\r\n\tfunction calculateLotteryContributionPercentage() external constant returns (uint256);\r\n\tfunction getNumLottery() external constant returns (uint256);\r\n\tfunction isActive() external constant returns (bool);\r\n\tfunction getCurrentTicketMultiplierHonor() external constant returns (uint256);\r\n\tfunction getCurrentLotteryTargetBalance() external constant returns (uint256, uint256);\r\n}\r\n\r\n\r\n/**\r\n * @title SettingInterface\r\n */\r\ninterface SettingInterface {\r\n\tfunction uintSettings(bytes32 name) external constant returns (uint256);\r\n\tfunction boolSettings(bytes32 name) external constant returns (bool);\r\n\tfunction isActive() external constant returns (bool);\r\n\tfunction canBet(uint256 rewardValue, uint256 betValue, uint256 playerNumber, uint256 houseEdge) external constant returns (bool);\r\n\tfunction isExchangeAllowed(address playerAddress, uint256 tokenAmount) external constant returns (bool);\r\n\r\n\t/******************************************/\r\n\t/*          SPINWIN ONLY METHODS          */\r\n\t/******************************************/\r\n\tfunction spinwinSetUintSetting(bytes32 name, uint256 value) external;\r\n\tfunction spinwinIncrementUintSetting(bytes32 name) external;\r\n\tfunction spinwinSetBoolSetting(bytes32 name, bool value) external;\r\n\tfunction spinwinAddFunds(uint256 amount) external;\r\n\tfunction spinwinUpdateTokenToWeiExchangeRate() external;\r\n\tfunction spinwinRollDice(uint256 betValue) external;\r\n\tfunction spinwinUpdateWinMetric(uint256 playerProfit) external;\r\n\tfunction spinwinUpdateLoseMetric(uint256 betValue, uint256 tokenRewardValue) external;\r\n\tfunction spinwinUpdateLotteryContributionMetric(uint256 lotteryContribution) external;\r\n\tfunction spinwinUpdateExchangeMetric(uint256 exchangeAmount) external;\r\n\r\n\t/******************************************/\r\n\t/*      SPINLOTTERY ONLY METHODS          */\r\n\t/******************************************/\r\n\tfunction spinlotterySetUintSetting(bytes32 name, uint256 value) external;\r\n\tfunction spinlotteryIncrementUintSetting(bytes32 name) external;\r\n\tfunction spinlotterySetBoolSetting(bytes32 name, bool value) external;\r\n\tfunction spinlotteryUpdateTokenToWeiExchangeRate() external;\r\n\tfunction spinlotterySetMinBankroll(uint256 _minBankroll) external returns (bool);\r\n}\r\n\r\n\r\n/**\r\n * @title TokenInterface\r\n */\r\ninterface TokenInterface {\r\n\tfunction getTotalSupply() external constant returns (uint256);\r\n\tfunction getBalanceOf(address account) external constant returns (uint256);\r\n\tfunction transfer(address _to, uint256 _value) external returns (bool);\r\n\tfunction transferFrom(address _from, address _to, uint256 _value) external returns (bool);\r\n\tfunction approve(address _spender, uint256 _value) external returns (bool success);\r\n\tfunction approveAndCall(address _spender, uint256 _value, bytes _extraData) external returns (bool success);\r\n\tfunction burn(uint256 _value) external returns (bool success);\r\n\tfunction burnFrom(address _from, uint256 _value) external returns (bool success);\r\n\tfunction mintTransfer(address _to, uint _value) external returns (bool);\r\n\tfunction burnAt(address _at, uint _value) external returns (bool);\r\n}\r\n\r\n\r\n\r\n\r\n// https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts/math/SafeMath.sol\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\tfunction mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\t\tif (a == 0) {\r\n\t\t\treturn 0;\r\n\t\t}\r\n\t\tuint256 c = a * b;\r\n\t\tassert(c / a == b);\r\n\t\treturn c;\r\n\t}\r\n\r\n\tfunction div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\t\t// assert(b > 0); // Solidity automatically throws when dividing by 0\r\n\t\tuint256 c = a / b;\r\n\t\t// assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\t\treturn c;\r\n\t}\r\n\r\n\tfunction sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\t\tassert(b <= a);\r\n\t\treturn a - b;\r\n\t}\r\n\r\n\tfunction add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\t\tuint256 c = a + b;\r\n\t\tassert(c >= a);\r\n\t\treturn c;\r\n\t}\r\n}\r\n\r\n\r\n\r\ninterface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) external; }\r\n\r\ncontract TokenERC20 {\r\n\t// Public variables of the token\r\n\tstring public name;\r\n\tstring public symbol;\r\n\tuint8 public decimals = 18;\r\n\t// 18 decimals is the strongly suggested default, avoid changing it\r\n\tuint256 public totalSupply;\r\n\r\n\t// This creates an array with all balances\r\n\tmapping (address => uint256) public balanceOf;\r\n\tmapping (address => mapping (address => uint256)) public allowance;\r\n\r\n\t// This generates a public event on the blockchain that will notify clients\r\n\tevent Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n\t// This generates a public event on the blockchain that will notify clients\r\n\tevent Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n\r\n\t// This notifies clients about the amount burnt\r\n\tevent Burn(address indexed from, uint256 value);\r\n\r\n\t/**\r\n\t * Constructor function\r\n\t *\r\n\t * Initializes contract with initial supply tokens to the creator of the contract\r\n\t */\r\n\tconstructor(\r\n\t\tuint256 initialSupply,\r\n\t\tstring tokenName,\r\n\t\tstring tokenSymbol\r\n\t) public {\r\n\t\ttotalSupply = initialSupply * 10 ** uint256(decimals);  // Update total supply with the decimal amount\r\n\t\tbalanceOf[msg.sender] = totalSupply;                // Give the creator all initial tokens\r\n\t\tname = tokenName;                                   // Set the name for display purposes\r\n\t\tsymbol = tokenSymbol;                               // Set the symbol for display purposes\r\n\t}\r\n\r\n\t/**\r\n\t * Internal transfer, only can be called by this contract\r\n\t */\r\n\tfunction _transfer(address _from, address _to, uint _value) internal {\r\n\t\t// Prevent transfer to 0x0 address. Use burn() instead\r\n\t\trequire(_to != 0x0);\r\n\t\t// Check if the sender has enough\r\n\t\trequire(balanceOf[_from] >= _value);\r\n\t\t// Check for overflows\r\n\t\trequire(balanceOf[_to] + _value > balanceOf[_to]);\r\n\t\t// Save this for an assertion in the future\r\n\t\tuint previousBalances = balanceOf[_from] + balanceOf[_to];\r\n\t\t// Subtract from the sender\r\n\t\tbalanceOf[_from] -= _value;\r\n\t\t// Add the same to the recipient\r\n\t\tbalanceOf[_to] += _value;\r\n\t\temit Transfer(_from, _to, _value);\r\n\t\t// Asserts are used to use static analysis to find bugs in your code. They should never fail\r\n\t\tassert(balanceOf[_from] + balanceOf[_to] == previousBalances);\r\n\t}\r\n\r\n\t/**\r\n\t * Transfer tokens\r\n\t *\r\n\t * Send `_value` tokens to `_to` from your account\r\n\t *\r\n\t * @param _to The address of the recipient\r\n\t * @param _value the amount to send\r\n\t */\r\n\tfunction transfer(address _to, uint256 _value) public returns (bool success) {\r\n\t\t_transfer(msg.sender, _to, _value);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * Transfer tokens from other address\r\n\t *\r\n\t * Send `_value` tokens to `_to` in behalf of `_from`\r\n\t *\r\n\t * @param _from The address of the sender\r\n\t * @param _to The address of the recipient\r\n\t * @param _value the amount to send\r\n\t */\r\n\tfunction transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\r\n\t\trequire(_value <= allowance[_from][msg.sender]);     // Check allowance\r\n\t\tallowance[_from][msg.sender] -= _value;\r\n\t\t_transfer(_from, _to, _value);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * Set allowance for other address\r\n\t *\r\n\t * Allows `_spender` to spend no more than `_value` tokens in your behalf\r\n\t *\r\n\t * @param _spender The address authorized to spend\r\n\t * @param _value the max amount they can spend\r\n\t */\r\n\tfunction approve(address _spender, uint256 _value) public returns (bool success) {\r\n\t\tallowance[msg.sender][_spender] = _value;\r\n\t\temit Approval(msg.sender, _spender, _value);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * Set allowance for other address and notify\r\n\t *\r\n\t * Allows `_spender` to spend no more than `_value` tokens in your behalf, and then ping the contract about it\r\n\t *\r\n\t * @param _spender The address authorized to spend\r\n\t * @param _value the max amount they can spend\r\n\t * @param _extraData some extra information to send to the approved contract\r\n\t */\r\n\tfunction approveAndCall(address _spender, uint256 _value, bytes _extraData)\r\n\t\tpublic\r\n\t\treturns (bool success) {\r\n\t\ttokenRecipient spender = tokenRecipient(_spender);\r\n\t\tif (approve(_spender, _value)) {\r\n\t\t\tspender.receiveApproval(msg.sender, _value, this, _extraData);\r\n\t\t\treturn true;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Destroy tokens\r\n\t *\r\n\t * Remove `_value` tokens from the system irreversibly\r\n\t *\r\n\t * @param _value the amount of money to burn\r\n\t */\r\n\tfunction burn(uint256 _value) public returns (bool success) {\r\n\t\trequire(balanceOf[msg.sender] >= _value);   // Check if the sender has enough\r\n\t\tbalanceOf[msg.sender] -= _value;            // Subtract from the sender\r\n\t\ttotalSupply -= _value;                      // Updates totalSupply\r\n\t\temit Burn(msg.sender, _value);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * Destroy tokens from other account\r\n\t *\r\n\t * Remove `_value` tokens from the system irreversibly on behalf of `_from`.\r\n\t *\r\n\t * @param _from the address of the sender\r\n\t * @param _value the amount of money to burn\r\n\t */\r\n\tfunction burnFrom(address _from, uint256 _value) public returns (bool success) {\r\n\t\trequire(balanceOf[_from] >= _value);                // Check if the targeted balance is enough\r\n\t\trequire(_value <= allowance[_from][msg.sender]);    // Check allowance\r\n\t\tbalanceOf[_from] -= _value;                         // Subtract from the targeted balance\r\n\t\tallowance[_from][msg.sender] -= _value;             // Subtract from the sender's allowance\r\n\t\ttotalSupply -= _value;                              // Update totalSupply\r\n\t\temit Burn(_from, _value);\r\n\t\treturn true;\r\n\t}\r\n}\r\n\r\ncontract developed {\r\n\taddress public developer;\r\n\r\n\t/**\r\n\t * Constructor\r\n\t */\r\n\tconstructor() public {\r\n\t\tdeveloper = msg.sender;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Checks only developer address is calling\r\n\t */\r\n\tmodifier onlyDeveloper {\r\n\t\trequire(msg.sender == developer);\r\n\t\t_;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Allows developer to switch developer address\r\n\t * @param _developer The new developer address to be set\r\n\t */\r\n\tfunction changeDeveloper(address _developer) public onlyDeveloper {\r\n\t\tdeveloper = _developer;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Allows developer to withdraw ERC20 Token\r\n\t */\r\n\tfunction withdrawToken(address tokenContractAddress) public onlyDeveloper {\r\n\t\tTokenERC20 _token = TokenERC20(tokenContractAddress);\r\n\t\tif (_token.balanceOf(this) > 0) {\r\n\t\t\t_token.transfer(developer, _token.balanceOf(this));\r\n\t\t}\r\n\t}\r\n}\r\n\r\n\r\n\r\ncontract escaped {\r\n\taddress public escapeActivator;\r\n\r\n\t/**\r\n\t * Constructor\r\n\t */\r\n\tconstructor() public {\r\n\t\tescapeActivator = 0xB15C54b4B9819925Cd2A7eE3079544402Ac33cEe;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Checks only escapeActivator address is calling\r\n\t */\r\n\tmodifier onlyEscapeActivator {\r\n\t\trequire(msg.sender == escapeActivator);\r\n\t\t_;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Allows escapeActivator to switch escapeActivator address\r\n\t * @param _escapeActivator The new escapeActivator address to be set\r\n\t */\r\n\tfunction changeAddress(address _escapeActivator) public onlyEscapeActivator {\r\n\t\tescapeActivator = _escapeActivator;\r\n\t}\r\n}\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title SpinLottery\r\n */\r\ncontract SpinLottery is developed, escaped, LotteryInterface {\r\n\tusing SafeMath for uint256;\r\n\r\n\t/**\r\n\t * @dev Game variables\r\n\t */\r\n\taddress public owner;\r\n\taddress public spinwinAddress;\r\n\r\n\tbool public contractKilled;\r\n\tbool public gamePaused;\r\n\r\n\tuint256 public numLottery;\r\n\tuint256 public lotteryTarget;\r\n\tuint256 public totalBankroll;\r\n\tuint256 public totalBuyTickets;\r\n\tuint256 public totalTokenWagered;\r\n\tuint256 public lotteryTargetIncreasePercentage;\r\n\tuint256 public lastBlockNumber;\r\n\tuint256 public lastLotteryTotalBlocks;\r\n\r\n\tuint256 public currentTicketMultiplier;\r\n\tuint256 public currentTicketMultiplierHonor;\r\n\tuint256 public currentTicketMultiplierBlockNumber;\r\n\r\n\tuint256 public maxBlockSecurityCount;\r\n\tuint256 public blockSecurityCount;\r\n\tuint256 public currentTicketMultiplierBlockSecurityCount;\r\n\r\n\tuint256 public ticketMultiplierModifier;\r\n\r\n\tuint256 public avgLotteryHours; // Average hours needed to complete a lottery\r\n\tuint256 public totalLotteryHours; // Total accumulative lottery hours\r\n\tuint256 public minBankrollDecreaseRate; // The rate to use to decrease spinwin's min bankroll\r\n\tuint256 public minBankrollIncreaseRate; // The rate to use to increase spinwin's min bankroll\r\n\tuint256 public lotteryContributionPercentageModifier; // The lottery contribution percentage modifier, used to calculate lottery contribution percentage\r\n\tuint256 public rateConfidenceModifier; // The rate confidence modifier, used to calculate lottery contribution percentage\r\n\tuint256 public currentLotteryPaceModifier; // The current lottery pace modifier, used to calculate lottery contribution percentage\r\n\tuint256 public maxLotteryContributionPercentage; // The maximum percent that we can contribute to the lottery\r\n\r\n\tuint256 constant public PERCENTAGE_DIVISOR = 1000000;\r\n\tuint256 constant public TWO_DECIMALS = 100; // To account for calculation with 2 decimal points\r\n\tuint256 constant public CURRENCY_DIVISOR = 10 ** 18;\r\n\r\n\tuint256 public startLotteryRewardPercentage; // The percentage of blocks that we want to reward player for starting next lottery\r\n\tuint256 internal lotteryContribution;\r\n\tuint256 internal carryOverContribution;\r\n\tuint256 public minRewardBlocksAmount;\r\n\r\n\tTokenInterface internal _spintoken;\r\n\tSettingInterface internal _setting;\r\n\r\n\tstruct Lottery {\r\n\t\tuint256 lotteryTarget;\r\n\t\tuint256 bankroll;\r\n\t\tuint256 tokenWagered;\r\n\t\tuint256 lotteryResult;\r\n\t\tuint256 totalBlocks;\r\n\t\tuint256 totalBlocksRewarded;\r\n\t\tuint256 startTimestamp;\r\n\t\tuint256 endTimestamp;\r\n\t\taddress winnerPlayerAddress;\r\n\t\tbool ended;\r\n\t\tbool cashedOut;\r\n\t}\r\n\r\n\tstruct Ticket {\r\n\t\tbytes32 ticketId;\r\n\t\tuint256 numLottery;\r\n\t\taddress playerAddress;\r\n\t\tuint256 minNumber;\r\n\t\tuint256 maxNumber;\r\n\t\tbool claimed;\r\n\t}\r\n\tmapping (uint256 => Lottery) public lotteries;\r\n\tmapping (bytes32 => Ticket) public tickets;\r\n\tmapping (uint256 => mapping (address => uint256)) public playerTokenWagered;\r\n\tmapping (address => uint256) public playerPendingWithdrawals;\r\n\tmapping (uint256 => mapping (address => uint256)) public playerTotalBlocks;\r\n\tmapping (uint256 => mapping (address => uint256)) public playerTotalBlocksRewarded;\r\n\r\n\t/**\r\n\t * @dev Log when new lottery is created\r\n\t */\r\n\tevent LogCreateLottery(uint256 indexed numLottery, uint256 lotteryBankrollGoal);\r\n\r\n\t/**\r\n\t * @dev Log when lottery is ended\r\n\t */\r\n\tevent LogEndLottery(uint256 indexed numLottery, uint256 lotteryResult);\r\n\r\n\t/**\r\n\t * @dev Log when spinwin adds some funds\r\n\t */\r\n\tevent LogAddBankRoll(uint256 indexed numLottery, uint256 amount);\r\n\r\n\t/**\r\n\t * @dev Log when player buys ticket\r\n\t * Ticket type\r\n\t * 1 = normal purchase\r\n\t * 2 = Spinwin Reward\r\n\t * 3 = Start Lottery Reward\r\n\t */\r\n\tevent LogBuyTicket(uint256 indexed numLottery, bytes32 indexed ticketId, address indexed playerAddress, uint256 tokenAmount, uint256 ticketMultiplier, uint256 minNumber, uint256 maxNumber, uint256 ticketType);\r\n\r\n\t/**\r\n\t * @dev Log when player claims lotto ticket\r\n\t *\r\n\t * Status:\r\n\t * 0: Lose\r\n\t * 1: Win\r\n\t * 2: Win + Failed send\r\n\t */\r\n\tevent LogClaimTicket(uint256 indexed numLottery, bytes32 indexed ticketId, address indexed playerAddress, uint256 lotteryResult, uint256 playerMinNumber, uint256 playerMaxNumber, uint256 winningReward, uint256 status);\r\n\r\n\t/**\r\n\t * @dev Log when player withdraw balance\r\n\t *\r\n\t * Status:\r\n\t * 0 = failed\r\n\t * 1 = success\r\n\t */\r\n\tevent LogPlayerWithdrawBalance(address indexed playerAddress, uint256 withdrawAmount, uint256 status);\r\n\r\n\t/**\r\n\t * @dev Log when current ticket multiplier is updated\r\n\t */\r\n\tevent LogUpdateCurrentTicketMultiplier(uint256 currentTicketMultiplier, uint256 currentTicketMultiplierBlockNumber);\r\n\r\n\t/**\r\n\t * @dev Log when developer set contract to emergency mode\r\n\t */\r\n\tevent LogEscapeHatch();\r\n\r\n\t/**\r\n\t * Constructor\r\n\t */\r\n\tconstructor(address _settingAddress, address _tokenAddress, address _spinwinAddress) public {\r\n\t\t_setting = SettingInterface(_settingAddress);\r\n\t\t_spintoken = TokenInterface(_tokenAddress);\r\n\t\tspinwinAddress = _spinwinAddress;\r\n\t\tlastLotteryTotalBlocks = 100 * CURRENCY_DIVISOR;                // init last lottery total blocks (10^20 blocks)\r\n\t\tdevSetLotteryTargetIncreasePercentage(150000);                  // init lottery target increase percentage (15%);\r\n\t\tdevSetMaxBlockSecurityCount(256);                               // init max block security count (256)\r\n\t\tdevSetBlockSecurityCount(3);                                    // init block security count (3)\r\n\t\tdevSetCurrentTicketMultiplierBlockSecurityCount(3);             // init current ticket multiplier block security count (3)\r\n\t\tdevSetTicketMultiplierModifier(300);                            // init ticket multiplier modifier (3)\r\n\t\tdevSetMinBankrollDecreaseRate(80);                              // init min bankroll decrease rate (0.8)\r\n\t\tdevSetMinBankrollIncreaseRate(170);                             // init min bankroll increase rate (1.7)\r\n\t\tdevSetLotteryContributionPercentageModifier(10);                // init lottery contribution percentage modifier (0.1)\r\n\t\tdevSetRateConfidenceModifier(200);                              // init rate confidence modifier (2)\r\n\t\tdevSetCurrentLotteryPaceModifier(200);                          // init current lottery pace modifier (2)\r\n\t\tdevSetStartLotteryRewardPercentage(10000);                      // init start lottery reward percentage (1%)\r\n\t\tdevSetMinRewardBlocksAmount(1);                                 // init min reward blocks amount (1)\r\n\t\tdevSetMaxLotteryContributionPercentage(100);                    // init max lottery contribution percentage (1)\r\n\t\t_createNewLottery();                                            // start lottery\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Checks if the contract is currently alive\r\n\t */\r\n\tmodifier contractIsAlive {\r\n\t\trequire(contractKilled == false);\r\n\t\t_;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Checks if the game is currently active\r\n\t */\r\n\tmodifier gameIsActive {\r\n\t\trequire(gamePaused == false);\r\n\t\t_;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Checks only spinwin address is calling\r\n\t */\r\n\tmodifier onlySpinwin {\r\n\t\trequire(msg.sender == spinwinAddress);\r\n\t\t_;\r\n\t}\r\n\r\n\t/******************************************/\r\n\t/*       DEVELOPER ONLY METHODS           */\r\n\t/******************************************/\r\n\r\n\t/**\r\n\t * @dev Allows developer to set lotteryTarget\r\n\t * @param _lotteryTarget The new lottery target value to be set\r\n\t */\r\n\tfunction devSetLotteryTarget(uint256 _lotteryTarget) public onlyDeveloper {\r\n\t\trequire (_lotteryTarget >= 0);\r\n\t\tlotteryTarget = _lotteryTarget;\r\n\t\tLottery storage _lottery = lotteries[numLottery];\r\n\t\t_lottery.lotteryTarget = lotteryTarget;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Allows developer to set lottery target increase percentage\r\n\t * @param _lotteryTargetIncreasePercentage The new value to be set\r\n\t * 1% = 10000\r\n\t */\r\n\tfunction devSetLotteryTargetIncreasePercentage(uint256 _lotteryTargetIncreasePercentage) public onlyDeveloper {\r\n\t\tlotteryTargetIncreasePercentage = _lotteryTargetIncreasePercentage;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Allows developer to set block security count\r\n\t * @param _blockSecurityCount The new value to be set\r\n\t */\r\n\tfunction devSetBlockSecurityCount(uint256 _blockSecurityCount) public onlyDeveloper {\r\n\t\trequire (_blockSecurityCount > 0);\r\n\t\tblockSecurityCount = _blockSecurityCount;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Allows developer to set max block security count\r\n\t * @param _maxBlockSecurityCount The new value to be set\r\n\t */\r\n\tfunction devSetMaxBlockSecurityCount(uint256 _maxBlockSecurityCount) public onlyDeveloper {\r\n\t\trequire (_maxBlockSecurityCount > 0);\r\n\t\tmaxBlockSecurityCount = _maxBlockSecurityCount;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Allows developer to set current ticket multiplier block security count\r\n\t * @param _currentTicketMultiplierBlockSecurityCount The new value to be set\r\n\t */\r\n\tfunction devSetCurrentTicketMultiplierBlockSecurityCount(uint256 _currentTicketMultiplierBlockSecurityCount) public onlyDeveloper {\r\n\t\trequire (_currentTicketMultiplierBlockSecurityCount > 0);\r\n\t\tcurrentTicketMultiplierBlockSecurityCount = _currentTicketMultiplierBlockSecurityCount;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Allows developer to set ticket multiplier modifier\r\n\t * @param _ticketMultiplierModifier The new value to be set (in two decimals)\r\n\t * 1 = 100\r\n\t */\r\n\tfunction devSetTicketMultiplierModifier(uint256 _ticketMultiplierModifier) public onlyDeveloper {\r\n\t\trequire (_ticketMultiplierModifier > 0);\r\n\t\tticketMultiplierModifier = _ticketMultiplierModifier;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Allows developer to set min bankroll decrease rate\r\n\t * @param _minBankrollDecreaseRate The new value to be set  (in two decimals)\r\n\t * 1 = 100\r\n\t */\r\n\tfunction devSetMinBankrollDecreaseRate(uint256 _minBankrollDecreaseRate) public onlyDeveloper {\r\n\t\trequire (_minBankrollDecreaseRate >= 0);\r\n\t\tminBankrollDecreaseRate = _minBankrollDecreaseRate;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Allows developer to set min bankroll increase rate\r\n\t * @param _minBankrollIncreaseRate The new value to be set  (in two decimals)\r\n\t * 1 = 100\r\n\t */\r\n\tfunction devSetMinBankrollIncreaseRate(uint256 _minBankrollIncreaseRate) public onlyDeveloper {\r\n\t\trequire (_minBankrollIncreaseRate > minBankrollDecreaseRate);\r\n\t\tminBankrollIncreaseRate = _minBankrollIncreaseRate;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Allows developer to set lottery contribution percentage modifier\r\n\t * @param _lotteryContributionPercentageModifier The new value to be set (in two decimals)\r\n\t * 1 = 100\r\n\t */\r\n\tfunction devSetLotteryContributionPercentageModifier(uint256 _lotteryContributionPercentageModifier) public onlyDeveloper {\r\n\t\tlotteryContributionPercentageModifier = _lotteryContributionPercentageModifier;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Allows developer to set rate confidence modifier\r\n\t * @param _rateConfidenceModifier The new value to be set (in two decimals)\r\n\t * 1 = 100\r\n\t */\r\n\tfunction devSetRateConfidenceModifier(uint256 _rateConfidenceModifier) public onlyDeveloper {\r\n\t\trateConfidenceModifier = _rateConfidenceModifier;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Allows developer to set current lottery pace modifier\r\n\t * @param _currentLotteryPaceModifier The new value to be set (in two decimals)\r\n\t * 1 = 100\r\n\t */\r\n\tfunction devSetCurrentLotteryPaceModifier(uint256 _currentLotteryPaceModifier) public onlyDeveloper {\r\n\t\tcurrentLotteryPaceModifier = _currentLotteryPaceModifier;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Allows developer to pause the game\r\n\t * @param paused The new paused value to be set\r\n\t */\r\n\tfunction devPauseGame(bool paused) public onlyDeveloper {\r\n\t\tgamePaused = paused;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Allows developer to start new lottery (only when current lottery is ended)\r\n\t * @return Return true if success\r\n\t */\r\n\tfunction devStartLottery() public onlyDeveloper returns (bool) {\r\n\t\tLottery memory _currentLottery = lotteries[numLottery];\r\n\t\trequire (_currentLottery.ended == true);\r\n\t\t_createNewLottery();\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Allows developer to end current lottery\r\n\t * @param _startNextLottery Boolean value whether or not we should start next lottery\r\n\t * @return Return true if success\r\n\t */\r\n\tfunction devEndLottery(bool _startNextLottery) public onlyDeveloper returns (bool) {\r\n\t\t_endLottery();\r\n\t\tif (_startNextLottery) {\r\n\t\t\t_createNewLottery();\r\n\t\t}\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Allows developer to set start lottery reward percentage\r\n\t * @param _startLotteryRewardPercentage The new value to be set\r\n\t * 1% = 10000\r\n\t */\r\n\tfunction devSetStartLotteryRewardPercentage(uint256 _startLotteryRewardPercentage) public onlyDeveloper {\r\n\t\tstartLotteryRewardPercentage = _startLotteryRewardPercentage;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Allows developer to set start lottery min reward blocks amount\r\n\t * @param _minRewardBlocksAmount The new value to be set\r\n\t */\r\n\tfunction devSetMinRewardBlocksAmount(uint256 _minRewardBlocksAmount) public onlyDeveloper {\r\n\t\tminRewardBlocksAmount = _minRewardBlocksAmount;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Allows developer to set max lottery contribution percentage\r\n\t * @param _maxLotteryContributionPercentage The new value to be set\r\n\t * 1 = 100\r\n\t */\r\n\tfunction devSetMaxLotteryContributionPercentage(uint256 _maxLotteryContributionPercentage) public onlyDeveloper {\r\n\t\tmaxLotteryContributionPercentage = _maxLotteryContributionPercentage;\r\n\t}\r\n\r\n\t/******************************************/\r\n\t/*      ESCAPE ACTIVATOR ONLY METHODS     */\r\n\t/******************************************/\r\n\r\n\t/**\r\n\t * @dev Allows escapeActivator to trigger emergency mode. Will end current lottery and stop the game.\r\n\t * @return Return true if success\r\n\t */\r\n\tfunction escapeHatch() public\r\n\t\tonlyEscapeActivator\r\n\t\tcontractIsAlive\r\n\t\treturns (bool) {\r\n\t\tcontractKilled = true;\r\n\t\t_endLottery();\r\n\t\temit LogEscapeHatch();\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/******************************************/\r\n\t/*         SPINWIN ONLY METHODS           */\r\n\t/******************************************/\r\n\t/**\r\n\t * @dev Allows spinwin to buy ticket on behalf of playerAddress as part of claiming spinwin reward\r\n\t * @param playerAddress The player address to be rewarded\r\n\t * @param tokenAmount The amount of token to be spent\r\n\t * @return The ticket ID\r\n\t */\r\n\tfunction claimReward(address playerAddress, uint256 tokenAmount) public\r\n\t\tcontractIsAlive\r\n\t\tgameIsActive\r\n\t\tonlySpinwin\r\n\t\treturns (bool) {\r\n\t\treturn _buyTicket(playerAddress, tokenAmount, 2);\r\n\t}\r\n\r\n\t/******************************************/\r\n\t/*             PUBLIC METHODS             */\r\n\t/******************************************/\r\n\t/**\r\n\t * @dev Add funds to the contract\r\n\t * If the bankroll goal is reached, we want to end current lottery and start new lottery.\r\n\t */\r\n\tfunction () payable public\r\n\t\tcontractIsAlive\r\n\t\tgameIsActive {\r\n\t\t// Update the last block number\r\n\t\tlastBlockNumber = block.number;\r\n\r\n\t\tLottery storage _currentLottery = lotteries[numLottery];\r\n\t\tif (_currentLottery.bankroll.add(msg.value) > lotteryTarget) {\r\n\t\t\tlotteryContribution = lotteryTarget.sub(_currentLottery.bankroll);\r\n\t\t\tcarryOverContribution = carryOverContribution.add(msg.value.sub(lotteryContribution));\r\n\t\t} else {\r\n\t\t\tlotteryContribution = msg.value;\r\n\t\t}\r\n\r\n\t\t// Safely update bankroll\r\n\t\tif (lotteryContribution > 0) {\r\n\t\t\t_currentLottery.bankroll = _currentLottery.bankroll.add(lotteryContribution);\r\n\t\t\ttotalBankroll = totalBankroll.add(lotteryContribution);\r\n\t\t\temit LogAddBankRoll(numLottery, lotteryContribution);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Player buys lottery ticket\r\n\t * @param tokenAmount The amount of token to spend\r\n\t * @return Return the ticket ID\r\n\t */\r\n\tfunction buyTicket(uint tokenAmount) public\r\n\t\tcontractIsAlive\r\n\t\tgameIsActive\r\n\t\treturns (bool) {\r\n\t\trequire (_spintoken.burnAt(msg.sender, tokenAmount));\r\n\t\treturn _buyTicket(msg.sender, tokenAmount, 1);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Player claims lottery ticket\r\n\t * @param ticketId The ticket ID to be claimed\r\n\t * @return Return true if success\r\n\t */\r\n\tfunction claimTicket(bytes32 ticketId) public\r\n\t\tgameIsActive\r\n\t\treturns (bool) {\r\n\t\tTicket storage _ticket = tickets[ticketId];\r\n\t\trequire(_ticket.claimed == false && _ticket.playerAddress == msg.sender);\r\n\r\n\t\tLottery storage _lottery = lotteries[_ticket.numLottery];\r\n\t\trequire(_lottery.ended == true && _lottery.cashedOut == false && _lottery.bankroll > 0 && _lottery.totalBlocks.add(_lottery.totalBlocksRewarded) > 0 && _lottery.lotteryResult > 0);\r\n\r\n\t\t// Mark this ticket as claimed\r\n\t\t_ticket.claimed = true;\r\n\t\tuint256 status = 0; // status = failed\r\n\t\tif (_lottery.lotteryResult >= _ticket.minNumber && _lottery.lotteryResult <= _ticket.maxNumber) {\r\n\t\t\tuint256 lotteryReward = _lottery.bankroll;\r\n\r\n\t\t\t// Check if contract has enough bankroll to payout\r\n\t\t\trequire(totalBankroll >= lotteryReward);\r\n\r\n\t\t\t// Safely adjust totalBankroll\r\n\t\t\ttotalBankroll = totalBankroll.sub(lotteryReward);\r\n\r\n\t\t\t_lottery.bankroll = 0;\r\n\t\t\t_lottery.winnerPlayerAddress = msg.sender;\r\n\t\t\t_lottery.cashedOut = true;\r\n\r\n\r\n\t\t\tif (!msg.sender.send(lotteryReward)) {\r\n\t\t\t\tstatus = 2; // status = win + failed send\r\n\t\t\t\t// If send failed, let player withdraw via playerWithdrawPendingTransactions\r\n\t\t\t\tplayerPendingWithdrawals[msg.sender] = playerPendingWithdrawals[msg.sender].add(lotteryReward);\r\n\t\t\t} else {\r\n\t\t\t\tstatus = 1; // status = win\r\n\t\t\t}\r\n\t\t}\r\n\t\temit LogClaimTicket(_ticket.numLottery, ticketId, msg.sender, _lottery.lotteryResult, _ticket.minNumber, _ticket.maxNumber, lotteryReward, status);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Allows player to withdraw balance in case of a failed win send\r\n\t * @return Return true if success\r\n\t */\r\n\tfunction playerWithdrawPendingTransactions() public\r\n\t\tgameIsActive {\r\n\t\trequire(playerPendingWithdrawals[msg.sender] > 0);\r\n\t\tuint256 withdrawAmount = playerPendingWithdrawals[msg.sender];\r\n\r\n\t\tplayerPendingWithdrawals[msg.sender] = 0;\r\n\r\n\t\t// External call to untrusted contract\r\n\t\tuint256 status = 1; // status = success\r\n\t\tif (!msg.sender.send(withdrawAmount)) {\r\n\t\t\tstatus = 0; // status = failed\r\n\r\n\t\t\t/*\r\n\t\t\t * If send failed, revert playerPendingWithdrawals[msg.sender] = 0\r\n\t\t\t * so that player can try to withdraw again later\r\n\t\t\t */\r\n\t\t\tplayerPendingWithdrawals[msg.sender] = withdrawAmount;\r\n\t\t}\r\n\t\temit LogPlayerWithdrawBalance(msg.sender, withdrawAmount, status);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Calculates number of blocks the player will get when he/she buys the lottery ticket\r\n\t *      based on player's entered token amount and current multiplier honor\r\n\t * @return ticketMultiplier The ticket multiplier during this transaction\r\n\t * @return numBlocks The lotto block count for this ticket\r\n\t */\r\n\tfunction calculateNumBlocks(uint256 tokenAmount) public constant returns (uint256 ticketMultiplier, uint256 numBlocks) {\r\n\t\treturn (currentTicketMultiplierHonor, currentTicketMultiplierHonor.mul(tokenAmount).div(TWO_DECIMALS));\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Get current num lottery\r\n\t * @return Current num lottery\r\n\t */\r\n\tfunction getNumLottery() public constant returns (uint256) {\r\n\t\treturn numLottery;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Check if contract is active\r\n\t * @return Current state of contract\r\n\t */\r\n\tfunction isActive() public constant returns (bool) {\r\n\t\tif (gamePaused == true || contractKilled == true) {\r\n\t\t\treturn false;\r\n\t\t} else {\r\n\t\t\treturn true;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Determines the lottery contribution percentage\r\n\t * @return lotteryContributionPercentage (in two decimals)\r\n\t */\r\n\tfunction calculateLotteryContributionPercentage() public\r\n\t\tcontractIsAlive\r\n\t\tgameIsActive\r\n\t\tconstant returns (uint256) {\r\n\t\tLottery memory _currentLottery = lotteries[numLottery];\r\n\t\tuint256 currentTotalLotteryHours = _getHoursBetween(_currentLottery.startTimestamp, now);\r\n\r\n\t\tuint256 currentWeiToLotteryRate = 0;\r\n\t\t// To prevent division by 0\r\n\t\tif (currentTotalLotteryHours > 0) {\r\n\t\t\t/*\r\n\t\t\t * currentWeiToLotteryRate = _currentLottery.bankroll / currentTotalLotteryHours;\r\n\t\t\t * But since we need to account for decimal points\r\n\t\t\t * currentWeiToLotteryRate = (_currentLottery.bankroll * TWO_DECIMALS)/currentTotalLotteryHours;\r\n\t\t\t * currentWeiToLotteryRate needs to be divided by TWO_DECIMALS later on\r\n\t\t\t */\r\n\t\t\tcurrentWeiToLotteryRate = (_currentLottery.bankroll.mul(TWO_DECIMALS)).div(currentTotalLotteryHours);\r\n\t\t}\r\n\r\n\t\tuint256 predictedCurrentLotteryHours = currentTotalLotteryHours;\r\n\t\t// To prevent division by 0\r\n\t\tif (currentWeiToLotteryRate > 0) {\r\n\t\t\t/*\r\n\t\t\t * predictedCurrentLotteryHours = currentTotalLotteryHours + ((lotteryTarget - _currentLottery.bankroll)/currentWeiToLotteryRate);\r\n\t\t\t * Let temp = (lotteryTarget - _currentLottery.bankroll)/currentWeiToLotteryRate;\r\n\t\t\t * Since we need to account for decimal points\r\n\t\t\t * temp = ((lotteryTarget - _currentLottery.bankroll)*TWO_DECIMALS)/currentWeiToLotteryRate;\r\n\t\t\t * But currentWeiToLotteryRate is already in decimals\r\n\t\t\t * temp = ((lotteryTarget - _currentLottery.bankroll)*TWO_DECIMALS)/(currentWeiToLotteryRate/TWO_DECIMALS);\r\n\t\t\t * temp = ((lotteryTarget - _currentLottery.bankroll)*TWO_DECIMALS*TWO_DECIMALS)/currentWeiToLotteryRate;\r\n\t\t\t * predictedCurrentLotteryHours = currentTotalLotteryHours + (temp/TWO_DECIMALS);\r\n\t\t\t */\r\n\t\t\tuint256 temp = (lotteryTarget.sub(_currentLottery.bankroll)).mul(TWO_DECIMALS).mul(TWO_DECIMALS).div(currentWeiToLotteryRate);\r\n\t\t\tpredictedCurrentLotteryHours = currentTotalLotteryHours.add(temp.div(TWO_DECIMALS));\r\n\t\t}\r\n\r\n\t\tuint256 currentLotteryPace = 0;\r\n\t\t// To prevent division by 0\r\n\t\tif (avgLotteryHours > 0) {\r\n\t\t\t/*\r\n\t\t\t * currentLotteryPace = predictedCurrentLotteryHours/avgLotteryHours;\r\n\t\t\t * But since we need to account for decimal points\r\n\t\t\t * currentLotteryPace = (predictedCurrentLotteryHours*TWO_DECIMALS)/avgLotteryHours;\r\n\t\t\t * But avgLotteryHours is already in decimals so we need to divide it by TWO_DECIMALS as well\r\n\t\t\t * currentLotteryPace = (predictedCurrentLotteryHours*TWO_DECIMALS)/(avgLotteryHours/TWO_DECIMALS);\r\n\t\t\t * OR\r\n\t\t\t * currentLotteryPace = (predictedCurrentLotteryHours*TWO_DECIMALS*TWO_DECIMALS)/avgLotteryHours;\r\n\t\t\t * currentLotteryPace needs to be divided by TWO_DECIMALS later on\r\n\t\t\t */\r\n\t\t\tcurrentLotteryPace = (predictedCurrentLotteryHours.mul(TWO_DECIMALS).mul(TWO_DECIMALS)).div(avgLotteryHours);\r\n\t\t}\r\n\r\n\t\tuint256 percentageOverTarget = 0;\r\n\t\t// To prevent division by 0\r\n\t\tif (_setting.uintSettings('minBankroll') > 0) {\r\n\t\t\t/*\r\n\t\t\t * percentageOverTarget = _spinwin.contractBalance() / _spinwin.minBankroll();\r\n\t\t\t * But since we need to account for decimal points\r\n\t\t\t * percentageOverTarget = (_spinwin.contractBalance()*TWO_DECIMALS) / _spinwin.minBankroll();\r\n\t\t\t * percentageOverTarget needs to be divided by TWO_DECIMALS later on\r\n\t\t\t */\r\n\t\t\tpercentageOverTarget = (_setting.uintSettings('contractBalance').mul(TWO_DECIMALS)).div(_setting.uintSettings('minBankroll'));\r\n\t\t}\r\n\r\n\t\tcurrentTotalLotteryHours = currentTotalLotteryHours.mul(TWO_DECIMALS); // So that it has two decimals\r\n\t\tuint256 rateConfidence = 0;\r\n\t\t// To prevent division by 0\r\n\t\tif (avgLotteryHours.add(currentTotalLotteryHours) > 0) {\r\n\t\t\t/*\r\n\t\t\t * rateConfidence = currentTotalLotteryHours / (avgLotteryHours + currentTotalLotteryHours);\r\n\t\t\t * But since we need to account for decimal points\r\n\t\t\t * rateConfidence = (currentTotalLotteryHours*TWO_DECIMALS) / (avgLotteryHours + currentTotalLotteryHours);\r\n\t\t\t * rateConfidence needs to be divided by TWO_DECIMALS later on\r\n\t\t\t */\r\n\t\t\trateConfidence = currentTotalLotteryHours.mul(TWO_DECIMALS).div(avgLotteryHours.add(currentTotalLotteryHours));\r\n\t\t}\r\n\r\n\t\t/*\r\n\t\t * lotteryContributionPercentage = 0.1 + (1-(1/percentageOverTarget))+(rateConfidence*2*(currentLotteryPace/(currentLotteryPace+2)))\r\n\t\t * Replace the static number with modifier variables (that are already in decimals, so 0.1 is actually 10, 2 is actually 200)\r\n\t\t * lotteryContributionPercentage = lotteryContributionPercentageModifier + (1-(1/percentageOverTarget)) + (rateConfidence*rateConfidenceModifier*(currentLotteryPace/(currentLotteryPace+currentLotteryPaceModifier)));\r\n\t\t *\r\n\t\t * Split to 3 sections\r\n\t\t * lotteryContributionPercentage = calc1 + calc2 + calc3\r\n\t\t * calc1 = lotteryContributionPercentageModifier\r\n\t\t * calc2 = (1-(1/percentageOverTarget))\r\n\t\t * calc3 = (rateConfidence*rateConfidenceModifier*(currentLotteryPace/(currentLotteryPace+currentLotteryPaceModifier)))\r\n\t\t */\r\n\t\tuint256 lotteryContributionPercentage = lotteryContributionPercentageModifier;\r\n\r\n\t\t/*\r\n\t\t * calc2 = 1-(1/percentageOverTarget)\r\n\t\t * Since percentageOverTarget is already in two decimals\r\n\t\t * calc2 = 1-(1/(percentageOverTarget/TWO_DECIMALS))\r\n\t\t * calc2 = 1-(TWO_DECIMALS/percentageOverTarget)\r\n\t\t * mult TWO_DECIMALS/TWO_DECIMALS to calculate fraction\r\n\t\t * calc2 = (TWO_DECIMALS-((TWO_DECIMALS*TWO_DECIMALS)/percentageOverTarget))/TWO_DECIMALS\r\n\t\t * since lotteryContributionPercentage needs to be in decimals, we can take out the division by TWO_DECIMALS\r\n\t\t * calc2 = TWO_DECIMALS-((TWO_DECIMALS*TWO_DECIMALS)/percentageOverTarget)\r\n\t\t */\r\n\t\t// To prevent division by 0\r\n\t\tif (percentageOverTarget > 0) {\r\n\t\t\tlotteryContributionPercentage = lotteryContributionPercentage.add(TWO_DECIMALS.sub((TWO_DECIMALS.mul(TWO_DECIMALS)).div(percentageOverTarget)));\r\n\t\t} else {\r\n\t\t\tlotteryContributionPercentage = lotteryContributionPercentage.add(TWO_DECIMALS);\r\n\t\t}\r\n\r\n\t\t/*\r\n\t\t * calc3 = rateConfidence*rateConfidenceModifier*(currentLotteryPace/(currentLotteryPace+currentLotteryPaceModifier))\r\n\t\t * But since rateConfidence, rateConfidenceModifier are already in decimals, we need to divide them by TWO_DECIMALS\r\n\t\t * calc3 = (rateConfidence/TWO_DECIMALS)*(rateConfidenceModifier/TWO_DECIMALS)*(currentLotteryPace/(currentLotteryPace+currentLotteryPaceModifier))\r\n\t\t * since we need to account for decimal points, mult the numerator `currentLotteryPace` with TWO_DECIMALS\r\n\t\t * calc3 = (rateConfidence/TWO_DECIMALS)*(rateConfidenceModifier/TWO_DECIMALS)*((currentLotteryPace*TWO_DECIMALS)/(currentLotteryPace+currentLotteryPaceModifier))\r\n\t\t * OR\r\n\t\t * calc3 = (rateConfidence*rateConfidenceModifier*currentLotteryPace)/(TWO_DECIMALS*(currentLotteryPace+currentLotteryPaceModifier))\r\n\t\t */\r\n\t\t// To prevent division by 0\r\n\t\tif (currentLotteryPace.add(currentLotteryPaceModifier) > 0) {\r\n\t\t\tlotteryContributionPercentage = lotteryContributionPercentage.add((rateConfidence.mul(rateConfidenceModifier).mul(currentLotteryPace)).div(TWO_DECIMALS.mul(currentLotteryPace.add(currentLotteryPaceModifier))));\r\n\t\t}\r\n\t\tif (lotteryContributionPercentage > maxLotteryContributionPercentage) {\r\n\t\t\tlotteryContributionPercentage = maxLotteryContributionPercentage;\r\n\t\t}\r\n\t\treturn lotteryContributionPercentage;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Allows player to start next lottery and reward player a percentage of last lottery total blocks\r\n\t */\r\n\tfunction startNextLottery() public\r\n\t\tcontractIsAlive\r\n\t\tgameIsActive {\r\n\t\tLottery storage _currentLottery = lotteries[numLottery];\r\n\t\trequire (_currentLottery.bankroll >= lotteryTarget && _currentLottery.totalBlocks.add(_currentLottery.totalBlocksRewarded) > 0);\r\n\t\tuint256 startLotteryRewardBlocks = calculateStartLotteryRewardBlocks();\r\n\t\t_endLottery();\r\n\t\t_createNewLottery();\r\n\r\n\t\t// If we have carry over contribution from prev contribution\r\n\t\t// add it to the next lottery\r\n\t\tif (carryOverContribution > 0) {\r\n\t\t\t_currentLottery = lotteries[numLottery];\r\n\t\t\tif (_currentLottery.bankroll.add(carryOverContribution) > lotteryTarget) {\r\n\t\t\t\tlotteryContribution = lotteryTarget.sub(_currentLottery.bankroll);\r\n\t\t\t\tcarryOverContribution = carryOverContribution.sub(lotteryContribution);\r\n\t\t\t} else {\r\n\t\t\t\tlotteryContribution = carryOverContribution;\r\n\t\t\t\tcarryOverContribution = 0;\r\n\t\t\t}\r\n\r\n\t\t\t// Safely update bankroll\r\n\t\t\t_currentLottery.bankroll = _currentLottery.bankroll.add(lotteryContribution);\r\n\t\t\ttotalBankroll = totalBankroll.add(lotteryContribution);\r\n\t\t\temit LogAddBankRoll(numLottery, lotteryContribution);\r\n\t\t}\r\n\t\t_buyTicket(msg.sender, startLotteryRewardBlocks, 3);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Calculate start lottery reward blocks amount\r\n\t * @return The reward blocks amount\r\n\t */\r\n\tfunction calculateStartLotteryRewardBlocks() public constant returns (uint256) {\r\n\t\tuint256 totalRewardBlocks = lastLotteryTotalBlocks.mul(startLotteryRewardPercentage).div(PERCENTAGE_DIVISOR);\r\n\t\tif (totalRewardBlocks == 0) {\r\n\t\t\ttotalRewardBlocks = minRewardBlocksAmount;\r\n\t\t}\r\n\t\treturn totalRewardBlocks;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Get current ticket multiplier honor\r\n\t * @return Current ticket multiplier honor\r\n\t */\r\n\tfunction getCurrentTicketMultiplierHonor() public constant returns (uint256) {\r\n\t\treturn currentTicketMultiplierHonor;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Get current lottery target and bankroll\r\n\t * @return Current lottery target\r\n\t * @return Current lottery bankroll\r\n\t */\r\n\tfunction getCurrentLotteryTargetBalance() public constant returns (uint256, uint256) {\r\n\t\tLottery memory _lottery = lotteries[numLottery];\r\n\t\treturn (_lottery.lotteryTarget, _lottery.bankroll);\r\n\t}\r\n\r\n\t/*****************************************/\r\n\t/*          INTERNAL METHODS              */\r\n\t/******************************************/\r\n\r\n\t/**\r\n\t * @dev Creates new lottery\r\n\t */\r\n\tfunction _createNewLottery() internal returns (bool) {\r\n\t\tnumLottery++;\r\n\t\tlotteryTarget = _setting.uintSettings('minBankroll').add(_setting.uintSettings('minBankroll').mul(lotteryTargetIncreasePercentage).div(PERCENTAGE_DIVISOR));\r\n\t\tLottery storage _lottery = lotteries[numLottery];\r\n\t\t_lottery.lotteryTarget = lotteryTarget;\r\n\t\t_lottery.startTimestamp = now;\r\n\t\t_updateCurrentTicketMultiplier();\r\n\t\temit LogCreateLottery(numLottery, lotteryTarget);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Ends current lottery\r\n\t */\r\n\tfunction _endLottery() internal returns (bool) {\r\n\t\tLottery storage _currentLottery = lotteries[numLottery];\r\n\t\trequire (_currentLottery.totalBlocks.add(_currentLottery.totalBlocksRewarded) > 0);\r\n\r\n\t\tuint256 blockNumberDifference = block.number - lastBlockNumber;\r\n\t\tuint256 targetBlockNumber = 0;\r\n\t\tif (blockNumberDifference < maxBlockSecurityCount.sub(blockSecurityCount)) {\r\n\t\t\ttargetBlockNumber = lastBlockNumber.add(blockSecurityCount);\r\n\t\t} else {\r\n\t\t\ttargetBlockNumber = lastBlockNumber.add(maxBlockSecurityCount.mul(blockNumberDifference.div(maxBlockSecurityCount))).add(blockSecurityCount);\r\n\t\t}\r\n\t\t_currentLottery.lotteryResult = _generateRandomNumber(_currentLottery.totalBlocks.add(_currentLottery.totalBlocksRewarded), targetBlockNumber);\r\n\r\n\t\t// If contract is killed, we don't want any leftover eth sits in the contract\r\n\t\t// Add the carry over contribution to current lottery\r\n\t\tif (contractKilled == true && carryOverContribution > 0) {\r\n\t\t\tlotteryTarget = lotteryTarget.add(carryOverContribution);\r\n\t\t\t_currentLottery.lotteryTarget = lotteryTarget;\r\n\t\t\t_currentLottery.bankroll = _currentLottery.bankroll.add(carryOverContribution);\r\n\t\t\ttotalBankroll = totalBankroll.add(carryOverContribution);\r\n\t\t\temit LogAddBankRoll(numLottery, carryOverContribution);\r\n\t\t}\r\n\t\t_currentLottery.endTimestamp = now;\r\n\t\t_currentLottery.ended = true;\r\n\t\tuint256 endingLotteryHours = _getHoursBetween(_currentLottery.startTimestamp, now);\r\n\t\ttotalLotteryHours = totalLotteryHours.add(endingLotteryHours);\r\n\r\n\t\t/*\r\n\t\t * avgLotteryHours = totalLotteryHours/numLottery\r\n\t\t * But since we are doing division in integer, needs to account for the decimal points\r\n\t\t * avgLotteryHours = totalLotteryHours * TWO_DECIMALS / numLottery; // TWO_DECIMALS = 100\r\n\t\t * avgLotteryHours needs to be divided by TWO_DECIMALS again later on\r\n\t\t */\r\n\t\tavgLotteryHours = totalLotteryHours.mul(TWO_DECIMALS).div(numLottery);\r\n\t\tlastLotteryTotalBlocks = _currentLottery.totalBlocks.add(_currentLottery.totalBlocksRewarded);\r\n\r\n\t\t// Update spinwin's min bankroll\r\n\t\tif (_setting.boolSettings('contractKilled') == false && _setting.boolSettings('gamePaused') == false) {\r\n\t\t\tuint256 lotteryPace = 0;\r\n\t\t\tif (endingLotteryHours > 0) {\r\n\t\t\t\t/*\r\n\t\t\t\t * lotteryPace = avgLotteryHours/endingLotteryHours\r\n\t\t\t\t * Mult avgLotteryHours with TWO_DECIMALS to account for two decimal points\r\n\t\t\t\t * lotteryPace = (avgLotteryHours * TWO_DECIMALS) / endingLotteryHours\r\n\t\t\t\t * But from previous calculation, we already know that avgLotteryHours is already in decimals\r\n\t\t\t\t * So, lotteryPace = ((avgLotteryHours*TWO_DECIMALS)/endingLotteryHours)/TWO_DECIMALS\r\n\t\t\t\t * lotteryPace needs to be divided by TWO_DECIMALS again later on\r\n\t\t\t\t */\r\n\t\t\t\tlotteryPace = avgLotteryHours.mul(TWO_DECIMALS).div(endingLotteryHours).div(TWO_DECIMALS);\r\n\t\t\t}\r\n\r\n\t\t\tuint256 newMinBankroll = 0;\r\n\t\t\tif (lotteryPace <= minBankrollDecreaseRate) {\r\n\t\t\t\t// If the pace is too slow, then we want to decrease spinwin min bankroll\r\n\t\t\t\tnewMinBankroll = _setting.uintSettings('minBankroll').mul(minBankrollDecreaseRate).div(TWO_DECIMALS);\r\n\t\t\t} else if (lotteryPace <= minBankrollIncreaseRate) {\r\n\t\t\t\t// If the pace is too fast, then we want to increase spinwin min bankroll\r\n\t\t\t\tnewMinBankroll = _setting.uintSettings('minBankroll').mul(minBankrollIncreaseRate).div(TWO_DECIMALS);\r\n\t\t\t} else {\r\n\t\t\t\t// Otherwise, set new min bankroll according to the lottery pace\r\n\t\t\t\tnewMinBankroll = _setting.uintSettings('minBankroll').mul(lotteryPace).div(TWO_DECIMALS);\r\n\t\t\t}\r\n\t\t\t_setting.spinlotterySetMinBankroll(newMinBankroll);\r\n\t\t}\r\n\r\n\t\temit LogEndLottery(numLottery, _currentLottery.lotteryResult);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Buys ticket\r\n\t * @param _playerAddress The player address that buys this ticket\r\n\t * @param _tokenAmount The amount of SPIN token to spend\r\n\t * @param _ticketType Is this a normal purchase / part of spinwin's reward program / start lottery reward?\r\n\t * 1 = normal purchase\r\n\t * 2 = spinwin reward\r\n\t * 3 = start lottery reward\r\n\t * @return Return true if success\r\n\t */\r\n\tfunction _buyTicket(address _playerAddress, uint256 _tokenAmount, uint256 _ticketType) internal returns (bool) {\r\n\t\trequire (_ticketType >=1 && _ticketType <= 3);\r\n\t\ttotalBuyTickets++;\r\n\t\tLottery storage _currentLottery = lotteries[numLottery];\r\n\r\n\t\tif (_ticketType > 1) {\r\n\t\t\tuint256 _ticketMultiplier = TWO_DECIMALS; // Ticket multiplier is 1\r\n\t\t\tuint256 _numBlocks = _tokenAmount;\r\n\t\t\t_tokenAmount = 0;  // Set token amount to 0 since we are not charging player any SPIN\r\n\t\t} else {\r\n\t\t\t_currentLottery.tokenWagered = _currentLottery.tokenWagered.add(_tokenAmount);\r\n\t\t\ttotalTokenWagered = totalTokenWagered.add(_tokenAmount);\r\n\t\t\t(_ticketMultiplier, _numBlocks) = calculateNumBlocks(_tokenAmount);\r\n\t\t}\r\n\r\n\t\t// Generate ticketId\r\n\t\tbytes32 _ticketId = keccak256(abi.encodePacked(this, _playerAddress, numLottery, totalBuyTickets));\r\n\t\tTicket storage _ticket = tickets[_ticketId];\r\n\t\t_ticket.ticketId = _ticketId;\r\n\t\t_ticket.numLottery = numLottery;\r\n\t\t_ticket.playerAddress = _playerAddress;\r\n\t\t_ticket.minNumber = _currentLottery.totalBlocks.add(_currentLottery.totalBlocksRewarded).add(1);\r\n\t\t_ticket.maxNumber = _currentLottery.totalBlocks.add(_currentLottery.totalBlocksRewarded).add(_numBlocks);\r\n\r\n\t\tplayerTokenWagered[numLottery][_playerAddress] = playerTokenWagered[numLottery][_playerAddress].add(_tokenAmount);\r\n\t\tif (_ticketType > 1) {\r\n\t\t\t_currentLottery.totalBlocksRewarded = _currentLottery.totalBlocksRewarded.add(_numBlocks);\r\n\t\t\tplayerTotalBlocksRewarded[numLottery][_playerAddress] = playerTotalBlocksRewarded[numLottery][_playerAddress].add(_numBlocks);\r\n\t\t} else {\r\n\t\t\t_currentLottery.totalBlocks = _currentLottery.totalBlocks.add(_numBlocks);\r\n\t\t\tplayerTotalBlocks[numLottery][_playerAddress] = playerTotalBlocks[numLottery][_playerAddress].add(_numBlocks);\r\n\t\t}\r\n\r\n\t\temit LogBuyTicket(numLottery, _ticket.ticketId, _ticket.playerAddress, _tokenAmount, _ticketMultiplier, _ticket.minNumber, _ticket.maxNumber, _ticketType);\r\n\r\n\t\t// Safely update current ticket multiplier\r\n\t\t_updateCurrentTicketMultiplier();\r\n\r\n\t\t// Call spinwin update token to wei exchange rate\r\n\t\t_setting.spinlotteryUpdateTokenToWeiExchangeRate();\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Updates current ticket multiplier\r\n\t */\r\n\tfunction _updateCurrentTicketMultiplier() internal returns (bool) {\r\n\t\t// Safely update current ticket multiplier\r\n\t\tLottery memory _currentLottery = lotteries[numLottery];\r\n\t\tif (lastLotteryTotalBlocks > _currentLottery.totalBlocks.add(_currentLottery.totalBlocksRewarded)) {\r\n\t\t\t/*\r\n\t\t\t * currentTicketMultiplier = 1 + (ticketMultiplierModifier * ((lastLotteryTotalBlocks-currentLotteryBlocks)/lastLotteryTotalBlocks))\r\n\t\t\t * Since we are calculating in decimals so 1 is actually 100 or TWO_DECIMALS\r\n\t\t\t * currentTicketMultiplier = TWO_DECIMALS + (ticketMultiplierModifier * ((lastLotteryTotalBlocks-currentLotteryBlocks)/lastLotteryTotalBlocks))\r\n\t\t\t * Let temp = (lastLotteryTotalBlocks-currentLotteryBlocks)/lastLotteryTotalBlocks\r\n\t\t\t * To account for decimal points, we mult (lastLotteryTotalBlocks-currentLotteryBlocks) with TWO_DECIMALS\r\n\t\t\t * temp = ((lastLotteryTotalBlocks-currentLotteryBlocks)*TWO_DECIMALS)/lastLotteryTotalBlocks\r\n\t\t\t * We need to divide temp with TWO_DECIMALS later\r\n\t\t\t *\r\n\t\t\t * currentTicketMultiplier = TWO_DECIMALS + ((ticketMultiplierModifier * temp)/TWO_DECIMALS);\r\n\t\t\t */\r\n\t\t\tuint256 temp = (lastLotteryTotalBlocks.sub(_currentLottery.totalBlocks.add(_currentLottery.totalBlocksRewarded))).mul(TWO_DECIMALS).div(lastLotteryTotalBlocks);\r\n\t\t\tcurrentTicketMultiplier = TWO_DECIMALS.add(ticketMultiplierModifier.mul(temp).div(TWO_DECIMALS));\r\n\t\t} else {\r\n\t\t\tcurrentTicketMultiplier = TWO_DECIMALS;\r\n\t\t}\r\n\t\tif (block.number > currentTicketMultiplierBlockNumber.add(currentTicketMultiplierBlockSecurityCount) || _currentLottery.tokenWagered == 0) {\r\n\t\t\tcurrentTicketMultiplierHonor = currentTicketMultiplier;\r\n\t\t\tcurrentTicketMultiplierBlockNumber = block.number;\r\n\t\t\temit LogUpdateCurrentTicketMultiplier(currentTicketMultiplierHonor, currentTicketMultiplierBlockNumber);\r\n\t\t}\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Generates random number between 1 to maxNumber based on targetBlockNumber\r\n\t * @return The random number integer between 1 to maxNumber\r\n\t */\r\n\tfunction _generateRandomNumber(uint256 maxNumber, uint256 targetBlockNumber) internal constant returns (uint256) {\r\n\t\tuint256 randomNumber = 0;\r\n\t\tfor (uint256 i = 1; i < blockSecurityCount; i++) {\r\n\t\t\trandomNumber = ((uint256(keccak256(abi.encodePacked(randomNumber, blockhash(targetBlockNumber-i), numLottery + totalBuyTickets + totalTokenWagered))) % maxNumber)+1);\r\n\t\t}\r\n\t\treturn randomNumber;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Get hours between two timestamp\r\n\t * @param _startTimestamp Starting timestamp\r\n\t * @param _endTimestamp End timestamp\r\n\t * @return Hours in between starting and ending timestamp\r\n\t */\r\n\tfunction _getHoursBetween(uint256 _startTimestamp, uint256 _endTimestamp) internal pure returns (uint256) {\r\n\t\tuint256 _timestampDiff = _endTimestamp.sub(_startTimestamp);\r\n\r\n\t\tuint256 _hours = 0;\r\n\t\twhile(_timestampDiff >= 3600) {\r\n\t\t\t_timestampDiff -= 3600;\r\n\t\t\t_hours++;\r\n\t\t}\r\n\t\treturn _hours;\r\n\t}\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_lotteryTargetIncreasePercentage\",\"type\":\"uint256\"}],\"name\":\"devSetLotteryTargetIncreasePercentage\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"calculateNumBlocks\",\"outputs\":[{\"name\":\"ticketMultiplier\",\"type\":\"uint256\"},{\"name\":\"numBlocks\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalLotteryHours\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rateConfidenceModifier\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"lotteries\",\"outputs\":[{\"name\":\"lotteryTarget\",\"type\":\"uint256\"},{\"name\":\"bankroll\",\"type\":\"uint256\"},{\"name\":\"tokenWagered\",\"type\":\"uint256\"},{\"name\":\"lotteryResult\",\"type\":\"uint256\"},{\"name\":\"totalBlocks\",\"type\":\"uint256\"},{\"name\":\"totalBlocksRewarded\",\"type\":\"uint256\"},{\"name\":\"startTimestamp\",\"type\":\"uint256\"},{\"name\":\"endTimestamp\",\"type\":\"uint256\"},{\"name\":\"winnerPlayerAddress\",\"type\":\"address\"},{\"name\":\"ended\",\"type\":\"bool\"},{\"name\":\"cashedOut\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"escapeHatch\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"playerAddress\",\"type\":\"address\"},{\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"claimReward\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lotteryTargetIncreasePercentage\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"contractKilled\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_blockSecurityCount\",\"type\":\"uint256\"}],\"name\":\"devSetBlockSecurityCount\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"playerPendingWithdrawals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isActive\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastBlockNumber\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minRewardBlocksAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_developer\",\"type\":\"address\"}],\"name\":\"changeDeveloper\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lotteryTarget\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalBuyTickets\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCurrentLotteryTargetBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentTicketMultiplierBlockSecurityCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getNumLottery\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"blockSecurityCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_currentLotteryPaceModifier\",\"type\":\"uint256\"}],\"name\":\"devSetCurrentLotteryPaceModifier\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_ticketMultiplierModifier\",\"type\":\"uint256\"}],\"name\":\"devSetTicketMultiplierModifier\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastLotteryTotalBlocks\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_lotteryTarget\",\"type\":\"uint256\"}],\"name\":\"devSetLotteryTarget\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_minRewardBlocksAmount\",\"type\":\"uint256\"}],\"name\":\"devSetMinRewardBlocksAmount\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"buyTicket\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCurrentTicketMultiplierHonor\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentTicketMultiplierBlockNumber\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_startLotteryRewardPercentage\",\"type\":\"uint256\"}],\"name\":\"devSetStartLotteryRewardPercentage\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"playerTokenWagered\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"startNextLottery\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_maxLotteryContributionPercentage\",\"type\":\"uint256\"}],\"name\":\"devSetMaxLotteryContributionPercentage\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startLotteryRewardPercentage\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentLotteryPaceModifier\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lotteryContributionPercentageModifier\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_minBankrollDecreaseRate\",\"type\":\"uint256\"}],\"name\":\"devSetMinBankrollDecreaseRate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenContractAddress\",\"type\":\"address\"}],\"name\":\"withdrawToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"calculateLotteryContributionPercentage\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"numLottery\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentTicketMultiplierHonor\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ticketMultiplierModifier\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"devStartLottery\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"playerWithdrawPendingTransactions\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TWO_DECIMALS\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_minBankrollIncreaseRate\",\"type\":\"uint256\"}],\"name\":\"devSetMinBankrollIncreaseRate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalBankroll\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"spinwinAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"playerTotalBlocks\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minBankrollDecreaseRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"escapeActivator\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_currentTicketMultiplierBlockSecurityCount\",\"type\":\"uint256\"}],\"name\":\"devSetCurrentTicketMultiplierBlockSecurityCount\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_rateConfidenceModifier\",\"type\":\"uint256\"}],\"name\":\"devSetRateConfidenceModifier\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"gamePaused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_startNextLottery\",\"type\":\"bool\"}],\"name\":\"devEndLottery\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"developer\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"PERCENTAGE_DIVISOR\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"paused\",\"type\":\"bool\"}],\"name\":\"devPauseGame\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalTokenWagered\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CURRENCY_DIVISOR\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"tickets\",\"outputs\":[{\"name\":\"ticketId\",\"type\":\"bytes32\"},{\"name\":\"numLottery\",\"type\":\"uint256\"},{\"name\":\"playerAddress\",\"type\":\"address\"},{\"name\":\"minNumber\",\"type\":\"uint256\"},{\"name\":\"maxNumber\",\"type\":\"uint256\"},{\"name\":\"claimed\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_lotteryContributionPercentageModifier\",\"type\":\"uint256\"}],\"name\":\"devSetLotteryContributionPercentageModifier\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxLotteryContributionPercentage\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentTicketMultiplier\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_maxBlockSecurityCount\",\"type\":\"uint256\"}],\"name\":\"devSetMaxBlockSecurityCount\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"avgLotteryHours\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"ticketId\",\"type\":\"bytes32\"}],\"name\":\"claimTicket\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minBankrollIncreaseRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"calculateStartLotteryRewardBlocks\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"playerTotalBlocksRewarded\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxBlockSecurityCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_escapeActivator\",\"type\":\"address\"}],\"name\":\"changeAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_settingAddress\",\"type\":\"address\"},{\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"name\":\"_spinwinAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"numLottery\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"lotteryBankrollGoal\",\"type\":\"uint256\"}],\"name\":\"LogCreateLottery\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"numLottery\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"lotteryResult\",\"type\":\"uint256\"}],\"name\":\"LogEndLottery\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"numLottery\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"LogAddBankRoll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"numLottery\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"ticketId\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"playerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"ticketMultiplier\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"minNumber\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"maxNumber\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"ticketType\",\"type\":\"uint256\"}],\"name\":\"LogBuyTicket\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"numLottery\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"ticketId\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"playerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"lotteryResult\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"playerMinNumber\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"playerMaxNumber\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"winningReward\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"status\",\"type\":\"uint256\"}],\"name\":\"LogClaimTicket\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"playerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"withdrawAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"status\",\"type\":\"uint256\"}],\"name\":\"LogPlayerWithdrawBalance\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"currentTicketMultiplier\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"currentTicketMultiplierBlockNumber\",\"type\":\"uint256\"}],\"name\":\"LogUpdateCurrentTicketMultiplier\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"LogEscapeHatch\",\"type\":\"event\"}]","ContractName":"SpinLottery","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000b654457bab03011531ef939cb31f76eb36e2ddf3000000000000000000000000b42f5366792ed7c08995451c1a93780b7554762b000000000000000000000000453939ddbb64a8ce1da8b0648281ca281dfaa2ef","Library":"","SwarmSource":"bzzr://88390987498b21887aa253da8277fb4142ec114cdc6585c3f08540c5e915a0e0"}]}