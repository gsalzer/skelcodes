{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.5.5;\r\n\r\n/**\r\n * @dev Standard interface for a dex proxy contract.\r\n */\r\ninterface Proxy {\r\n\r\n  /**\r\n   * @dev Executes an action.\r\n   * @param _target Target of execution.\r\n   * @param _a Address usually representing from.\r\n   * @param _b Address usually representing to.\r\n   * @param _c Integer usually repersenting amount/value/id.\r\n   */\r\n  function execute(\r\n    address _target,\r\n    address _a,\r\n    address _b,\r\n    uint256 _c\r\n  )\r\n    external;\r\n    \r\n}\r\n\r\n/**\r\n * @dev Xcert interface.\r\n */\r\ninterface Xcert // is ERC721 metadata enumerable\r\n{\r\n\r\n  /**\r\n   * @dev Creates a new Xcert.\r\n   * @param _to The address that will own the created Xcert.\r\n   * @param _id The Xcert to be created by the msg.sender.\r\n   * @param _imprint Cryptographic asset imprint.\r\n   */\r\n  function create(\r\n    address _to,\r\n    uint256 _id,\r\n    bytes32 _imprint\r\n  )\r\n    external;\r\n\r\n  /**\r\n   * @dev Change URI base.\r\n   * @param _uriBase New uriBase.\r\n   */\r\n  function setUriBase(\r\n    string calldata _uriBase\r\n  )\r\n    external;\r\n\r\n  /**\r\n   * @dev Returns a bytes4 of keccak256 of json schema representing 0xcert Protocol convention.\r\n   * @return Schema id.\r\n   */\r\n  function schemaId()\r\n    external\r\n    view\r\n    returns (bytes32 _schemaId);\r\n\r\n  /**\r\n   * @dev Returns imprint for Xcert.\r\n   * @param _tokenId Id of the Xcert.\r\n   * @return Token imprint.\r\n   */\r\n  function tokenImprint(\r\n    uint256 _tokenId\r\n  )\r\n    external\r\n    view\r\n    returns(bytes32 imprint);\r\n\r\n}\r\n\r\n/**\r\n * @dev Xcert burnable interface.\r\n */\r\ninterface XcertBurnable // is Xcert\r\n{\r\n\r\n  /**\r\n   * @dev Destroys a specified Xcert. Reverts if not called from Xcert owner or operator.\r\n   * @param _tokenId Id of the Xcert we want to destroy.\r\n   */\r\n  function destroy(\r\n    uint256 _tokenId\r\n  )\r\n    external;\r\n\r\n}\r\n\r\n/**\r\n * @dev Xcert nutable interface.\r\n */\r\ninterface XcertMutable // is Xcert\r\n{\r\n  \r\n  /**\r\n   * @dev Updates Xcert imprint.\r\n   * @param _tokenId Id of the Xcert.\r\n   * @param _imprint New imprint.\r\n   */\r\n  function updateTokenImprint(\r\n    uint256 _tokenId,\r\n    bytes32 _imprint\r\n  )\r\n    external;\r\n\r\n}\r\n\r\n/**\r\n * @dev Xcert pausable interface.\r\n */\r\ninterface XcertPausable // is Xcert\r\n{\r\n\r\n  /**\r\n   * @dev Sets if Xcerts transfers are paused (can be performed) or not.\r\n   * @param _isPaused Pause status.\r\n   */\r\n  function setPause(\r\n    bool _isPaused\r\n  )\r\n    external;\r\n    \r\n}\r\n\r\n/**\r\n * @dev Xcert revokable interface.\r\n */\r\ninterface XcertRevokable // is Xcert\r\n{\r\n  \r\n  /**\r\n   * @dev Revokes a specified Xcert. Reverts if not called from contract owner or authorized \r\n   * address.\r\n   * @param _tokenId Id of the Xcert we want to destroy.\r\n   */\r\n  function revoke(\r\n    uint256 _tokenId\r\n  )\r\n    external;\r\n\r\n}\r\n\r\n/**\r\n * @dev Math operations with safety checks that throw on error. This contract is based on the \r\n * source code at: \r\n * https://github.com/OpenZeppelin/openzeppelin-solidity/blob/master/contracts/math/SafeMath.sol.\r\n */\r\nlibrary SafeMath\r\n{\r\n\r\n  /**\r\n   * @dev Error constants.\r\n   */\r\n  string constant OVERFLOW = \"008001\";\r\n  string constant SUBTRAHEND_GREATER_THEN_MINUEND = \"008002\";\r\n  string constant DIVISION_BY_ZERO = \"008003\";\r\n\r\n  /**\r\n   * @dev Multiplies two numbers, reverts on overflow.\r\n   * @param _factor1 Factor number.\r\n   * @param _factor2 Factor number.\r\n   * @return The product of the two factors.\r\n   */\r\n  function mul(\r\n    uint256 _factor1,\r\n    uint256 _factor2\r\n  )\r\n    internal\r\n    pure\r\n    returns (uint256 product)\r\n  {\r\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (_factor1 == 0)\r\n    {\r\n      return 0;\r\n    }\r\n\r\n    product = _factor1 * _factor2;\r\n    require(product / _factor1 == _factor2, OVERFLOW);\r\n  }\r\n\r\n  /**\r\n   * @dev Integer division of two numbers, truncating the quotient, reverts on division by zero.\r\n   * @param _dividend Dividend number.\r\n   * @param _divisor Divisor number.\r\n   * @return The quotient.\r\n   */\r\n  function div(\r\n    uint256 _dividend,\r\n    uint256 _divisor\r\n  )\r\n    internal\r\n    pure\r\n    returns (uint256 quotient)\r\n  {\r\n    // Solidity automatically asserts when dividing by 0, using all gas.\r\n    require(_divisor > 0, DIVISION_BY_ZERO);\r\n    quotient = _dividend / _divisor;\r\n    // assert(_dividend == _divisor * quotient + _dividend % _divisor); // There is no case in which this doesn't hold.\r\n  }\r\n\r\n  /**\r\n   * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n   * @param _minuend Minuend number.\r\n   * @param _subtrahend Subtrahend number.\r\n   * @return Difference.\r\n   */\r\n  function sub(\r\n    uint256 _minuend,\r\n    uint256 _subtrahend\r\n  )\r\n    internal\r\n    pure\r\n    returns (uint256 difference)\r\n  {\r\n    require(_subtrahend <= _minuend, SUBTRAHEND_GREATER_THEN_MINUEND);\r\n    difference = _minuend - _subtrahend;\r\n  }\r\n\r\n  /**\r\n   * @dev Adds two numbers, reverts on overflow.\r\n   * @param _addend1 Number.\r\n   * @param _addend2 Number.\r\n   * @return Sum.\r\n   */\r\n  function add(\r\n    uint256 _addend1,\r\n    uint256 _addend2\r\n  )\r\n    internal\r\n    pure\r\n    returns (uint256 sum)\r\n  {\r\n    sum = _addend1 + _addend2;\r\n    require(sum >= _addend1, OVERFLOW);\r\n  }\r\n\r\n  /**\r\n    * @dev Divides two numbers and returns the remainder (unsigned integer modulo), reverts when\r\n    * dividing by zero.\r\n    * @param _dividend Number.\r\n    * @param _divisor Number.\r\n    * @return Remainder.\r\n    */\r\n  function mod(\r\n    uint256 _dividend,\r\n    uint256 _divisor\r\n  )\r\n    internal\r\n    pure\r\n    returns (uint256 remainder) \r\n  {\r\n    require(_divisor != 0, DIVISION_BY_ZERO);\r\n    remainder = _dividend % _divisor;\r\n  }\r\n\r\n}\r\n\r\n/**\r\n * @title Contract for setting abilities.\r\n * @dev For optimization purposes the abilities are represented as a bitfield. Maximum number of\r\n * abilities is therefore 256. This is an example(for simplicity is made for max 8 abilities) of how\r\n * this works. \r\n * 00000001 Ability A - number representation 1\r\n * 00000010 Ability B - number representation 2\r\n * 00000100 Ability C - number representation 4\r\n * 00001000 Ability D - number representation 8\r\n * 00010000 Ability E - number representation 16\r\n * etc ... \r\n * To grant abilities B and C, we would need a bitfield of 00000110 which is represented by number\r\n * 6, in other words, the sum of abilities B and C. The same concept works for revoking abilities\r\n * and checking if someone has multiple abilities.\r\n */\r\ncontract Abilitable\r\n{\r\n  using SafeMath for uint;\r\n\r\n  /**\r\n   * @dev Error constants.\r\n   */\r\n  string constant NOT_AUTHORIZED = \"017001\";\r\n  string constant CANNOT_REVOKE_OWN_SUPER_ABILITY = \"017002\";\r\n  string constant INVALID_INPUT = \"017003\";\r\n\r\n  /**\r\n   * @dev Ability 1 (00000001) is a reserved ability called super ability. It is an\r\n   * ability to grant or revoke abilities of other accounts. Other abilities are determined by the\r\n   * implementing contract.\r\n   */\r\n  uint8 constant SUPER_ABILITY = 1;\r\n\r\n  /**\r\n   * @dev Maps address to ability ids.\r\n   */\r\n  mapping(address => uint256) public addressToAbility;\r\n\r\n  /**\r\n   * @dev Emits when an address is granted an ability.\r\n   * @param _target Address to which we are granting abilities.\r\n   * @param _abilities Number representing bitfield of abilities we are granting.\r\n   */\r\n  event GrantAbilities(\r\n    address indexed _target,\r\n    uint256 indexed _abilities\r\n  );\r\n\r\n  /**\r\n   * @dev Emits when an address gets an ability revoked.\r\n   * @param _target Address of which we are revoking an ability.\r\n   * @param _abilities Number representing bitfield of abilities we are revoking.\r\n   */\r\n  event RevokeAbilities(\r\n    address indexed _target,\r\n    uint256 indexed _abilities\r\n  );\r\n\r\n  /**\r\n   * @dev Guarantees that msg.sender has certain abilities.\r\n   */\r\n  modifier hasAbilities(\r\n    uint256 _abilities\r\n  ) \r\n  {\r\n    require(_abilities > 0, INVALID_INPUT);\r\n    require(\r\n      addressToAbility[msg.sender] & _abilities == _abilities,\r\n      NOT_AUTHORIZED\r\n    );\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Contract constructor.\r\n   * Sets SUPER_ABILITY ability to the sender account.\r\n   */\r\n  constructor()\r\n    public\r\n  {\r\n    addressToAbility[msg.sender] = SUPER_ABILITY;\r\n    emit GrantAbilities(msg.sender, SUPER_ABILITY);\r\n  }\r\n\r\n  /**\r\n   * @dev Grants specific abilities to specified address.\r\n   * @param _target Address to grant abilities to.\r\n   * @param _abilities Number representing bitfield of abilities we are granting.\r\n   */\r\n  function grantAbilities(\r\n    address _target,\r\n    uint256 _abilities\r\n  )\r\n    external\r\n    hasAbilities(SUPER_ABILITY)\r\n  {\r\n    addressToAbility[_target] |= _abilities;\r\n    emit GrantAbilities(_target, _abilities);\r\n  }\r\n\r\n  /**\r\n   * @dev Unassigns specific abilities from specified address.\r\n   * @param _target Address of which we revoke abilites.\r\n   * @param _abilities Number representing bitfield of abilities we are revoking.\r\n   * @param _allowSuperRevoke Additional check that prevents you from removing your own super\r\n   * ability by mistake.\r\n   */\r\n  function revokeAbilities(\r\n    address _target,\r\n    uint256 _abilities,\r\n    bool _allowSuperRevoke\r\n  )\r\n    external\r\n    hasAbilities(SUPER_ABILITY)\r\n  {\r\n    if (!_allowSuperRevoke && msg.sender == _target)\r\n    {\r\n      require((_abilities & 1) == 0, CANNOT_REVOKE_OWN_SUPER_ABILITY);\r\n    }\r\n    addressToAbility[_target] &= ~_abilities;\r\n    emit RevokeAbilities(_target, _abilities);\r\n  }\r\n\r\n  /**\r\n   * @dev Check if an address has a specific ability. Throws if checking for 0.\r\n   * @param _target Address for which we want to check if it has a specific abilities.\r\n   * @param _abilities Number representing bitfield of abilities we are checking.\r\n   */\r\n  function isAble(\r\n    address _target,\r\n    uint256 _abilities\r\n  )\r\n    external\r\n    view\r\n    returns (bool)\r\n  {\r\n    require(_abilities > 0, INVALID_INPUT);\r\n    return (addressToAbility[_target] & _abilities) == _abilities;\r\n  }\r\n  \r\n}\r\n\r\n/**\r\n * @dev ERC-721 non-fungible token standard. \r\n * See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md.\r\n */\r\ninterface ERC721\r\n{\r\n\r\n  /**\r\n   * @dev Emits when ownership of any NFT changes by any mechanism. This event emits when NFTs are\r\n   * created (`from` == 0) and destroyed (`to` == 0). Exception: during contract creation, any\r\n   * number of NFTs may be created and assigned without emitting Transfer. At the time of any\r\n   * transfer, the approved address for that NFT (if any) is reset to none.\r\n   */\r\n  event Transfer(\r\n    address indexed _from,\r\n    address indexed _to,\r\n    uint256 indexed _tokenId\r\n  );\r\n\r\n  /**\r\n   * @dev This emits when the approved address for an NFT is changed or reaffirmed. The zero\r\n   * address indicates there is no approved address. When a Transfer event emits, this also\r\n   * indicates that the approved address for that NFT (if any) is reset to none.\r\n   */\r\n  event Approval(\r\n    address indexed _owner,\r\n    address indexed _approved,\r\n    uint256 indexed _tokenId\r\n  );\r\n\r\n  /**\r\n   * @dev This emits when an operator is enabled or disabled for an owner. The operator can manage\r\n   * all NFTs of the owner.\r\n   */\r\n  event ApprovalForAll(\r\n    address indexed _owner,\r\n    address indexed _operator,\r\n    bool _approved\r\n  );\r\n\r\n  /**\r\n   * @dev Transfers the ownership of an NFT from one address to another address.\r\n   * @notice Throws unless `msg.sender` is the current owner, an authorized operator, or the\r\n   * approved address for this NFT. Throws if `_from` is not the current owner. Throws if `_to` is\r\n   * the zero address. Throws if `_tokenId` is not a valid NFT. When transfer is complete, this\r\n   * function checks if `_to` is a smart contract (code size > 0). If so, it calls\r\n   * `onERC721Received` on `_to` and throws if the return value is not \r\n   * `bytes4(keccak256(\"onERC721Received(address,uint256,bytes)\"))`.\r\n   * @param _from The current owner of the NFT.\r\n   * @param _to The new owner.\r\n   * @param _tokenId The NFT to transfer.\r\n   * @param _data Additional data with no specified format, sent in call to `_to`.\r\n   */\r\n  function safeTransferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _tokenId,\r\n    bytes calldata _data\r\n  )\r\n    external;\r\n\r\n  /**\r\n   * @dev Transfers the ownership of an NFT from one address to another address.\r\n   * @notice This works identically to the other function with an extra data parameter, except this\r\n   * function just sets data to \"\"\r\n   * @param _from The current owner of the NFT.\r\n   * @param _to The new owner.\r\n   * @param _tokenId The NFT to transfer.\r\n   */\r\n  function safeTransferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _tokenId\r\n  )\r\n    external;\r\n\r\n  /**\r\n   * @dev Throws unless `msg.sender` is the current owner, an authorized operator, or the approved\r\n   * address for this NFT. Throws if `_from` is not the current owner. Throws if `_to` is the zero\r\n   * address. Throws if `_tokenId` is not a valid NFT.\r\n   * @notice The caller is responsible to confirm that `_to` is capable of receiving NFTs or else\r\n   * they mayb be permanently lost.\r\n   * @param _from The current owner of the NFT.\r\n   * @param _to The new owner.\r\n   * @param _tokenId The NFT to transfer.\r\n   */\r\n  function transferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _tokenId\r\n  )\r\n    external;\r\n\r\n  /**\r\n   * @dev Set or reaffirm the approved address for an NFT.\r\n   * @notice The zero address indicates there is no approved address. Throws unless `msg.sender` is\r\n   * the current NFT owner, or an authorized operator of the current owner.\r\n   * @param _approved The new approved NFT controller.\r\n   * @param _tokenId The NFT to approve.\r\n   */\r\n  function approve(\r\n    address _approved,\r\n    uint256 _tokenId\r\n  )\r\n    external;\r\n\r\n  /**\r\n   * @dev Enables or disables approval for a third party (\"operator\") to manage all of\r\n   * `msg.sender`'s assets. It also emits the ApprovalForAll event.\r\n   * @notice The contract MUST allow multiple operators per owner.\r\n   * @param _operator Address to add to the set of authorized operators.\r\n   * @param _approved True if the operators is approved, false to revoke approval.\r\n   */\r\n  function setApprovalForAll(\r\n    address _operator,\r\n    bool _approved\r\n  )\r\n    external;\r\n\r\n  /**\r\n   * @dev Returns the number of NFTs owned by `_owner`. NFTs assigned to the zero address are\r\n   * considered invalid, and this function throws for queries about the zero address.\r\n   * @param _owner Address for whom to query the balance.\r\n   * @return Balance of _owner.\r\n   */\r\n  function balanceOf(\r\n    address _owner\r\n  )\r\n    external\r\n    view\r\n    returns (uint256);\r\n\r\n  /**\r\n   * @dev Returns the address of the owner of the NFT. NFTs assigned to zero address are considered\r\n   * invalid, and queries about them do throw.\r\n   * @param _tokenId The identifier for an NFT.\r\n   * @return Address of _tokenId owner.\r\n   */\r\n  function ownerOf(\r\n    uint256 _tokenId\r\n  )\r\n    external\r\n    view\r\n    returns (address);\r\n    \r\n  /**\r\n   * @dev Get the approved address for a single NFT.\r\n   * @notice Throws if `_tokenId` is not a valid NFT.\r\n   * @param _tokenId The NFT to find the approved address for.\r\n   * @return Address that _tokenId is approved for. \r\n   */\r\n  function getApproved(\r\n    uint256 _tokenId\r\n  )\r\n    external\r\n    view\r\n    returns (address);\r\n\r\n  /**\r\n   * @dev Returns true if `_operator` is an approved operator for `_owner`, false otherwise.\r\n   * @param _owner The address that owns the NFTs.\r\n   * @param _operator The address that acts on behalf of the owner.\r\n   * @return True if approved for all, false otherwise.\r\n   */\r\n  function isApprovedForAll(\r\n    address _owner,\r\n    address _operator\r\n  )\r\n    external\r\n    view\r\n    returns (bool);\r\n\r\n}\r\n\r\n/**\r\n * @dev Optional metadata extension for ERC-721 non-fungible token standard.\r\n * See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md.\r\n */\r\ninterface ERC721Metadata\r\n{\r\n\r\n  /**\r\n   * @dev Returns a descriptive name for a collection of NFTs in this contract.\r\n   * @return Representing name. \r\n   */\r\n  function name()\r\n    external\r\n    view\r\n    returns (string memory _name);\r\n\r\n  /**\r\n   * @dev Returns a abbreviated name for a collection of NFTs in this contract.\r\n   * @return Representing symbol. \r\n   */\r\n  function symbol()\r\n    external\r\n    view\r\n    returns (string memory _symbol);\r\n\r\n  /**\r\n   * @dev Returns a distinct Uniform Resource Identifier (URI) for a given asset. It Throws if\r\n   * `_tokenId` is not a valid NFT. URIs are defined in RFC3986. The URI may point to a JSON file\r\n   * that conforms to the \"ERC721 Metadata JSON Schema\".\r\n   * @return URI of _tokenId.\r\n   */\r\n  function tokenURI(uint256 _tokenId)\r\n    external\r\n    view\r\n    returns (string memory);\r\n\r\n}\r\n\r\n/**\r\n * @dev Optional enumeration extension for ERC-721 non-fungible token standard.\r\n * See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md.\r\n */\r\ninterface ERC721Enumerable\r\n{\r\n\r\n  /**\r\n   * @dev Returns a count of valid NFTs tracked by this contract, where each one of them has an\r\n   * assigned and queryable owner not equal to the zero address.\r\n   * @return Total supply of NFTs.\r\n   */\r\n  function totalSupply()\r\n    external\r\n    view\r\n    returns (uint256);\r\n\r\n  /**\r\n   * @dev Returns the token identifier for the `_index`th NFT. Sort order is not specified.\r\n   * @param _index A counter less than `totalSupply()`.\r\n   * @return Token id.\r\n   */\r\n  function tokenByIndex(\r\n    uint256 _index\r\n  )\r\n    external\r\n    view\r\n    returns (uint256);\r\n\r\n  /**\r\n   * @dev Returns the token identifier for the `_index`th NFT assigned to `_owner`. Sort order is\r\n   * not specified. It throws if `_index` >= `balanceOf(_owner)` or if `_owner` is the zero address,\r\n   * representing invalid NFTs.\r\n   * @param _owner An address where we are interested in NFTs owned by them.\r\n   * @param _index A counter less than `balanceOf(_owner)`.\r\n   * @return Token id.\r\n   */\r\n  function tokenOfOwnerByIndex(\r\n    address _owner,\r\n    uint256 _index\r\n  )\r\n    external\r\n    view\r\n    returns (uint256);\r\n\r\n}\r\n\r\n/**\r\n * @dev ERC-721 interface for accepting safe transfers. \r\n * See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md.\r\n */\r\ninterface ERC721TokenReceiver\r\n{\r\n\r\n  /**\r\n   * @dev Handle the receipt of a NFT. The ERC721 smart contract calls this function on the\r\n   * recipient after a `transfer`. This function MAY throw to revert and reject the transfer. Return\r\n   * of other than the magic value MUST result in the transaction being reverted.\r\n   * Returns `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))` unless throwing.\r\n   * @notice The contract address is always the message sender. A wallet/broker/auction application\r\n   * MUST implement the wallet interface if it will accept safe transfers.\r\n   * @param _operator The address which called `safeTransferFrom` function.\r\n   * @param _from The address which previously owned the token.\r\n   * @param _tokenId The NFT identifier which is being transferred.\r\n   * @param _data Additional data with no specified format.\r\n   * @return Returns `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`.\r\n   */\r\n  function onERC721Received(\r\n    address _operator,\r\n    address _from,\r\n    uint256 _tokenId,\r\n    bytes calldata _data\r\n  )\r\n    external\r\n    returns(bytes4);\r\n    \r\n}\r\n\r\n/**\r\n * @dev A standard for detecting smart contract interfaces.\r\n * See: https://eips.ethereum.org/EIPS/eip-165.\r\n */\r\ninterface ERC165\r\n{\r\n\r\n  /**\r\n   * @dev Checks if the smart contract implements a specific interface.\r\n   * @notice This function uses less than 30,000 gas.\r\n   * @param _interfaceID The interface identifier, as specified in ERC-165.\r\n   */\r\n  function supportsInterface(\r\n    bytes4 _interfaceID\r\n  )\r\n    external\r\n    view\r\n    returns (bool);\r\n\r\n}\r\n\r\n/**\r\n * @dev Implementation of standard to publish supported interfaces.\r\n */\r\ncontract SupportsInterface is\r\n  ERC165\r\n{\r\n\r\n  /**\r\n   * @dev Mapping of supported intefraces.\r\n   * @notice You must not set element 0xffffffff to true.\r\n   */\r\n  mapping(bytes4 => bool) internal supportedInterfaces;\r\n\r\n  /**\r\n   * @dev Contract constructor.\r\n   */\r\n  constructor()\r\n    public\r\n  {\r\n    supportedInterfaces[0x01ffc9a7] = true; // ERC165\r\n  }\r\n\r\n  /**\r\n   * @dev Function to check which interfaces are suported by this contract.\r\n   * @param _interfaceID Id of the interface.\r\n   */\r\n  function supportsInterface(\r\n    bytes4 _interfaceID\r\n  )\r\n    external\r\n    view\r\n    returns (bool)\r\n  {\r\n    return supportedInterfaces[_interfaceID];\r\n  }\r\n\r\n}\r\n\r\n/**\r\n * @dev Utility library of inline functions on addresses.\r\n */\r\nlibrary AddressUtils\r\n{\r\n\r\n  /**\r\n   * @dev Returns whether the target address is a contract.\r\n   * @param _addr Address to check.\r\n   * @return True if _addr is a contract, false if not.\r\n   */\r\n  function isContract(\r\n    address _addr\r\n  )\r\n    internal\r\n    view\r\n    returns (bool addressCheck)\r\n  {\r\n    uint256 size;\r\n\r\n    /**\r\n     * XXX Currently there is no better way to check if there is a contract in an address than to\r\n     * check the size of the code at that address.\r\n     * See https://ethereum.stackexchange.com/a/14016/36603 for more details about how this works.\r\n     * TODO: Check this again before the Serenity release, because all addresses will be\r\n     * contracts then.\r\n     */\r\n    assembly { size := extcodesize(_addr) } // solhint-disable-line\r\n    addressCheck = size > 0;\r\n  }\r\n\r\n}\r\n\r\n/**\r\n * @dev Optional metadata enumerable implementation for ERC-721 non-fungible token standard.\r\n */\r\ncontract NFTokenMetadataEnumerable is\r\n  ERC721,\r\n  ERC721Metadata,\r\n  ERC721Enumerable,\r\n  SupportsInterface\r\n{\r\n  using SafeMath for uint256;\r\n  using AddressUtils for address;\r\n\r\n  /**\r\n   * @dev Error constants.\r\n   */\r\n  string constant ZERO_ADDRESS = \"006001\";\r\n  string constant NOT_VALID_NFT = \"006002\";\r\n  string constant NOT_OWNER_OR_OPERATOR = \"006003\";\r\n  string constant NOT_OWNER_APPROWED_OR_OPERATOR = \"006004\";\r\n  string constant NOT_ABLE_TO_RECEIVE_NFT = \"006005\";\r\n  string constant NFT_ALREADY_EXISTS = \"006006\";\r\n  string constant INVALID_INDEX = \"006007\";\r\n\r\n  /**\r\n   * @dev Magic value of a smart contract that can recieve NFT.\r\n   * Equal to: bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\")).\r\n   */\r\n  bytes4 constant MAGIC_ON_ERC721_RECEIVED = 0x150b7a02;\r\n\r\n  /**\r\n   * @dev A descriptive name for a collection of NFTs.\r\n   */\r\n  string internal nftName;\r\n\r\n  /**\r\n   * @dev An abbreviated name for NFTs.\r\n   */\r\n  string internal nftSymbol;\r\n\r\n  /**\r\n   * @dev URI base for NFT metadata. NFT URI is made from base + NFT id.\r\n   */\r\n  string public uriBase;\r\n\r\n  /**\r\n   * @dev Array of all NFT IDs.\r\n   */\r\n  uint256[] internal tokens;\r\n\r\n  /**\r\n   * @dev Mapping from token ID its index in global tokens array.\r\n   */\r\n  mapping(uint256 => uint256) internal idToIndex;\r\n\r\n  /**\r\n   * @dev Mapping from owner to list of owned NFT IDs.\r\n   */\r\n  mapping(address => uint256[]) internal ownerToIds;\r\n\r\n  /**\r\n   * @dev Mapping from NFT ID to its index in the owner tokens list.\r\n   */\r\n  mapping(uint256 => uint256) internal idToOwnerIndex;\r\n\r\n  /**\r\n   * @dev A mapping from NFT ID to the address that owns it.\r\n   */\r\n  mapping (uint256 => address) internal idToOwner;\r\n\r\n  /**\r\n   * @dev Mapping from NFT ID to approved address.\r\n   */\r\n  mapping (uint256 => address) internal idToApproval;\r\n\r\n  /**\r\n   * @dev Mapping from owner address to mapping of operator addresses.\r\n   */\r\n  mapping (address => mapping (address => bool)) internal ownerToOperators;\r\n\r\n  /**\r\n   * @dev Emits when ownership of any NFT changes by any mechanism. This event emits when NFTs are\r\n   * created (`from` == 0) and destroyed (`to` == 0). Exception: during contract creation, any\r\n   * number of NFTs may be created and assigned without emitting Transfer. At the time of any\r\n   * transfer, the approved address for that NFT (if any) is reset to none.\r\n   * @param _from Sender of NFT (if address is zero address it indicates token creation).\r\n   * @param _to Receiver of NFT (if address is zero address it indicates token destruction).\r\n   * @param _tokenId The NFT that got transfered.\r\n   */\r\n  event Transfer(\r\n    address indexed _from,\r\n    address indexed _to,\r\n    uint256 indexed _tokenId\r\n  );\r\n\r\n  /**\r\n   * @dev This emits when the approved address for an NFT is changed or reaffirmed. The zero\r\n   * address indicates there is no approved address. When a Transfer event emits, this also\r\n   * indicates that the approved address for that NFT (if any) is reset to none.\r\n   * @param _owner Owner of NFT.\r\n   * @param _approved Address that we are approving.\r\n   * @param _tokenId NFT which we are approving.\r\n   */\r\n  event Approval(\r\n    address indexed _owner,\r\n    address indexed _approved,\r\n    uint256 indexed _tokenId\r\n  );\r\n\r\n  /**\r\n   * @dev This emits when an operator is enabled or disabled for an owner. The operator can manage\r\n   * all NFTs of the owner.\r\n   * @param _owner Owner of NFT.\r\n   * @param _operator Address to which we are setting operator rights.\r\n   * @param _approved Status of operator rights(true if operator rights are given and false if\r\n   * revoked).\r\n   */\r\n  event ApprovalForAll(\r\n    address indexed _owner,\r\n    address indexed _operator,\r\n    bool _approved\r\n  );\r\n\r\n  /**\r\n   * @dev Contract constructor.\r\n   * @notice When implementing this contract don't forget to set nftName, nftSymbol and uriBase.\r\n   */\r\n  constructor()\r\n    public\r\n  {\r\n    supportedInterfaces[0x80ac58cd] = true; // ERC721\r\n    supportedInterfaces[0x5b5e139f] = true; // ERC721Metadata\r\n    supportedInterfaces[0x780e9d63] = true; // ERC721Enumerable\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers the ownership of an NFT from one address to another address.\r\n   * @notice Throws unless `msg.sender` is the current owner, an authorized operator, or the\r\n   * approved address for this NFT. Throws if `_from` is not the current owner. Throws if `_to` is\r\n   * the zero address. Throws if `_tokenId` is not a valid NFT. When transfer is complete, this\r\n   * function checks if `_to` is a smart contract (code size > 0). If so, it calls \r\n   * `onERC721Received` on `_to` and throws if the return value is not \r\n   * `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`.\r\n   * @param _from The current owner of the NFT.\r\n   * @param _to The new owner.\r\n   * @param _tokenId The NFT to transfer.\r\n   * @param _data Additional data with no specified format, sent in call to `_to`.\r\n   */\r\n  function safeTransferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _tokenId,\r\n    bytes calldata _data\r\n  )\r\n    external\r\n  {\r\n    _safeTransferFrom(_from, _to, _tokenId, _data);\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers the ownership of an NFT from one address to another address.\r\n   * @notice This works identically to the other function with an extra data parameter, except this\r\n   * function just sets data to \"\".\r\n   * @param _from The current owner of the NFT.\r\n   * @param _to The new owner.\r\n   * @param _tokenId The NFT to transfer.\r\n   */\r\n  function safeTransferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _tokenId\r\n  )\r\n    external\r\n  {\r\n    _safeTransferFrom(_from, _to, _tokenId, \"\");\r\n  }\r\n\r\n  /**\r\n   * @dev Throws unless `msg.sender` is the current owner, an authorized operator, or the approved\r\n   * address for this NFT. Throws if `_from` is not the current owner. Throws if `_to` is the zero\r\n   * address. Throws if `_tokenId` is not a valid NFT.\r\n   * @notice The caller is responsible to confirm that `_to` is capable of receiving NFTs or else\r\n   * they maybe be permanently lost.\r\n   * @param _from The current owner of the NFT.\r\n   * @param _to The new owner.\r\n   * @param _tokenId The NFT to transfer.\r\n   */\r\n  function transferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _tokenId\r\n  )\r\n    external\r\n  {\r\n    _transferFrom(_from, _to, _tokenId);\r\n  }\r\n\r\n  /**\r\n   * @dev Set or reaffirm the approved address for an NFT.\r\n   * @notice The zero address indicates there is no approved address. Throws unless `msg.sender` is\r\n   * the current NFT owner, or an authorized operator of the current owner.\r\n   * @param _approved Address to be approved for the given NFT ID.\r\n   * @param _tokenId ID of the token to be approved.\r\n   */\r\n  function approve(\r\n    address _approved,\r\n    uint256 _tokenId\r\n  )\r\n    external\r\n  {\r\n    // can operate\r\n    address tokenOwner = idToOwner[_tokenId];\r\n    require(\r\n      tokenOwner == msg.sender || ownerToOperators[tokenOwner][msg.sender],\r\n      NOT_OWNER_OR_OPERATOR\r\n    );\r\n\r\n    idToApproval[_tokenId] = _approved;\r\n    emit Approval(tokenOwner, _approved, _tokenId);\r\n  }\r\n\r\n  /**\r\n   * @dev Enables or disables approval for a third party (\"operator\") to manage all of\r\n   * `msg.sender`'s assets. It also emits the ApprovalForAll event.\r\n   * @notice This works even if sender doesn't own any tokens at the time.\r\n   * @param _operator Address to add to the set of authorized operators.\r\n   * @param _approved True if the operators is approved, false to revoke approval.\r\n   */\r\n  function setApprovalForAll(\r\n    address _operator,\r\n    bool _approved\r\n  )\r\n    external\r\n  {\r\n    ownerToOperators[msg.sender][_operator] = _approved;\r\n    emit ApprovalForAll(msg.sender, _operator, _approved);\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the number of NFTs owned by `_owner`. NFTs assigned to the zero address are\r\n   * considered invalid, and this function throws for queries about the zero address.\r\n   * @param _owner Address for whom to query the balance.\r\n   * @return Balance of _owner.\r\n   */\r\n  function balanceOf(\r\n    address _owner\r\n  )\r\n    external\r\n    view\r\n    returns (uint256)\r\n  {\r\n    require(_owner != address(0), ZERO_ADDRESS);\r\n    return ownerToIds[_owner].length;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the address of the owner of the NFT. NFTs assigned to zero address are considered\r\n   * invalid, and queries about them do throw.\r\n   * @param _tokenId The identifier for an NFT.\r\n   * @return Address of _tokenId owner.\r\n   */\r\n  function ownerOf(\r\n    uint256 _tokenId\r\n  )\r\n    external\r\n    view\r\n    returns (address _owner)\r\n  {\r\n    _owner = idToOwner[_tokenId];\r\n    require(_owner != address(0), NOT_VALID_NFT);\r\n  }\r\n\r\n  /**\r\n   * @dev Get the approved address for a single NFT.\r\n   * @notice Throws if `_tokenId` is not a valid NFT.\r\n   * @param _tokenId ID of the NFT to query the approval of.\r\n   * @return Address that _tokenId is approved for. \r\n   */\r\n  function getApproved(\r\n    uint256 _tokenId\r\n  )\r\n    external\r\n    view\r\n    returns (address)\r\n  {\r\n    require(idToOwner[_tokenId] != address(0), NOT_VALID_NFT);\r\n    return idToApproval[_tokenId];\r\n  }\r\n\r\n  /**\r\n   * @dev Checks if `_operator` is an approved operator for `_owner`.\r\n   * @param _owner The address that owns the NFTs.\r\n   * @param _operator The address that acts on behalf of the owner.\r\n   * @return True if approved for all, false otherwise.\r\n   */\r\n  function isApprovedForAll(\r\n    address _owner,\r\n    address _operator\r\n  )\r\n    external\r\n    view\r\n    returns (bool)\r\n  {\r\n    return ownerToOperators[_owner][_operator];\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the count of all existing NFTs.\r\n   * @return Total supply of NFTs.\r\n   */\r\n  function totalSupply()\r\n    external\r\n    view\r\n    returns (uint256)\r\n  {\r\n    return tokens.length;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns NFT ID by its index.\r\n   * @param _index A counter less than `totalSupply()`.\r\n   * @return Token id.\r\n   */\r\n  function tokenByIndex(\r\n    uint256 _index\r\n  )\r\n    external\r\n    view\r\n    returns (uint256)\r\n  {\r\n    require(_index < tokens.length, INVALID_INDEX);\r\n    return tokens[_index];\r\n  }\r\n\r\n  /**\r\n   * @dev returns the n-th NFT ID from a list of owner's tokens.\r\n   * @param _owner Token owner's address.\r\n   * @param _index Index number representing n-th token in owner's list of tokens.\r\n   * @return Token id.\r\n   */\r\n  function tokenOfOwnerByIndex(\r\n    address _owner,\r\n    uint256 _index\r\n  )\r\n    external\r\n    view\r\n    returns (uint256)\r\n  {\r\n    require(_index < ownerToIds[_owner].length, INVALID_INDEX);\r\n    return ownerToIds[_owner][_index];\r\n  }\r\n\r\n  /**\r\n   * @dev Returns a descriptive name for a collection of NFTs.\r\n   * @return Representing name. \r\n   */\r\n  function name()\r\n    external\r\n    view\r\n    returns (string memory _name)\r\n  {\r\n    _name = nftName;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns an abbreviated name for NFTs.\r\n   * @return Representing symbol. \r\n   */\r\n  function symbol()\r\n    external\r\n    view\r\n    returns (string memory _symbol)\r\n  {\r\n    _symbol = nftSymbol;\r\n  }\r\n  \r\n  /**\r\n   * @notice A distinct Uniform Resource Identifier (URI) for a given asset.\r\n   * @dev Throws if `_tokenId` is not a valid NFT. URIs are defined in RFC 3986. The URI may point\r\n   * to a JSON file that conforms to the \"ERC721 Metadata JSON Schema\".\r\n   * @param _tokenId Id for which we want URI.\r\n   * @return URI of _tokenId.\r\n   */\r\n  function tokenURI(\r\n    uint256 _tokenId\r\n  )\r\n    external\r\n    view\r\n    returns (string memory)\r\n  {\r\n    require(idToOwner[_tokenId] != address(0), NOT_VALID_NFT);\r\n    if (bytes(uriBase).length > 0)\r\n    {\r\n      return string(abi.encodePacked(uriBase, _uint2str(_tokenId)));\r\n    }\r\n    return \"\";\r\n  }\r\n\r\n  /**\r\n   * @dev Set a distinct URI (RFC 3986) base for all nfts.\r\n   * @notice this is a internal function which should be called from user-implemented external\r\n   * function. Its purpose is to show and properly initialize data structures when using this\r\n   * implementation.\r\n   * @param _uriBase String representing RFC 3986 URI base.\r\n   */\r\n  function _setUriBase(\r\n    string memory _uriBase\r\n  )\r\n    internal\r\n  {\r\n    uriBase = _uriBase;\r\n  }\r\n\r\n  /**\r\n   * @dev Creates a new NFT.\r\n   * @notice This is a private function which should be called from user-implemented external\r\n   * function. Its purpose is to show and properly initialize data structures when using this\r\n   * implementation.\r\n   * @param _to The address that will own the created NFT.\r\n   * @param _tokenId of the NFT to be created by the msg.sender.\r\n   */\r\n  function _create(\r\n    address _to,\r\n    uint256 _tokenId\r\n  )\r\n    internal\r\n  {\r\n    require(_to != address(0), ZERO_ADDRESS);\r\n    require(idToOwner[_tokenId] == address(0), NFT_ALREADY_EXISTS);\r\n\r\n    // add NFT\r\n    idToOwner[_tokenId] = _to;\r\n\r\n    uint256 length = ownerToIds[_to].push(_tokenId);\r\n    idToOwnerIndex[_tokenId] = length - 1;\r\n\r\n    // add to tokens array\r\n    length = tokens.push(_tokenId);\r\n    idToIndex[_tokenId] = length - 1;\r\n\r\n    emit Transfer(address(0), _to, _tokenId);\r\n  }\r\n\r\n  /**\r\n   * @dev Destroys a NFT.\r\n   * @notice This is a private function which should be called from user-implemented external\r\n   * destroy function. Its purpose is to show and properly initialize data structures when using this\r\n   * implementation.\r\n   * @param _tokenId ID of the NFT to be destroyed.\r\n   */\r\n  function _destroy(\r\n    uint256 _tokenId\r\n  )\r\n    internal\r\n  {\r\n    // valid NFT\r\n    address owner = idToOwner[_tokenId];\r\n    require(owner != address(0), NOT_VALID_NFT);\r\n\r\n    // clear approval\r\n    if (idToApproval[_tokenId] != address(0))\r\n    {\r\n      delete idToApproval[_tokenId];\r\n    }\r\n\r\n    // remove NFT\r\n    assert(ownerToIds[owner].length > 0);\r\n\r\n    uint256 tokenToRemoveIndex = idToOwnerIndex[_tokenId];\r\n    uint256 lastTokenIndex = ownerToIds[owner].length - 1;\r\n    uint256 lastToken;\r\n    if (lastTokenIndex != tokenToRemoveIndex)\r\n    {\r\n      lastToken = ownerToIds[owner][lastTokenIndex];\r\n      ownerToIds[owner][tokenToRemoveIndex] = lastToken;\r\n      idToOwnerIndex[lastToken] = tokenToRemoveIndex;\r\n    }\r\n\r\n    delete idToOwner[_tokenId];\r\n    delete idToOwnerIndex[_tokenId];\r\n    ownerToIds[owner].length--;\r\n\r\n    // remove from tokens array\r\n    assert(tokens.length > 0);\r\n\r\n    uint256 tokenIndex = idToIndex[_tokenId];\r\n    lastTokenIndex = tokens.length - 1;\r\n    lastToken = tokens[lastTokenIndex];\r\n\r\n    tokens[tokenIndex] = lastToken;\r\n\r\n    tokens.length--;\r\n    // Consider adding a conditional check for the last token in order to save GAS.\r\n    idToIndex[lastToken] = tokenIndex;\r\n    idToIndex[_tokenId] = 0;\r\n\r\n    emit Transfer(owner, address(0), _tokenId);\r\n  }\r\n\r\n  /**\r\n   * @dev Helper methods that actually does the transfer.\r\n   * @param _from The current owner of the NFT.\r\n   * @param _to The new owner.\r\n   * @param _tokenId The NFT to transfer.\r\n   */\r\n  function _transferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _tokenId\r\n  )\r\n    internal\r\n  {\r\n    // valid NFT\r\n    require(_from != address(0), ZERO_ADDRESS);\r\n    require(idToOwner[_tokenId] == _from, NOT_VALID_NFT);\r\n    require(_to != address(0), ZERO_ADDRESS);\r\n\r\n    // can transfer\r\n    require(\r\n      _from == msg.sender\r\n      || idToApproval[_tokenId] == msg.sender\r\n      || ownerToOperators[_from][msg.sender],\r\n      NOT_OWNER_APPROWED_OR_OPERATOR\r\n    );\r\n\r\n    // clear approval\r\n    if (idToApproval[_tokenId] != address(0))\r\n    {\r\n      delete idToApproval[_tokenId];\r\n    }\r\n\r\n    // remove NFT\r\n    assert(ownerToIds[_from].length > 0);\r\n\r\n    uint256 tokenToRemoveIndex = idToOwnerIndex[_tokenId];\r\n    uint256 lastTokenIndex = ownerToIds[_from].length - 1;\r\n\r\n    if (lastTokenIndex != tokenToRemoveIndex)\r\n    {\r\n      uint256 lastToken = ownerToIds[_from][lastTokenIndex];\r\n      ownerToIds[_from][tokenToRemoveIndex] = lastToken;\r\n      idToOwnerIndex[lastToken] = tokenToRemoveIndex;\r\n    }\r\n\r\n    ownerToIds[_from].length--;\r\n\r\n    // add NFT\r\n    idToOwner[_tokenId] = _to;\r\n    uint256 length = ownerToIds[_to].push(_tokenId);\r\n    idToOwnerIndex[_tokenId] = length - 1;\r\n\r\n    emit Transfer(_from, _to, _tokenId);\r\n  }\r\n\r\n  /**\r\n   * @dev Helper function that actually does the safeTransfer.\r\n   * @param _from The current owner of the NFT.\r\n   * @param _to The new owner.\r\n   * @param _tokenId The NFT to transfer.\r\n   * @param _data Additional data with no specified format, sent in call to `_to`.\r\n   */\r\n  function _safeTransferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _tokenId,\r\n    bytes memory _data\r\n  )\r\n    internal\r\n  {\r\n    if (_to.isContract())\r\n    {\r\n      require(\r\n        ERC721TokenReceiver(_to)\r\n          .onERC721Received(msg.sender, _from, _tokenId, _data) == MAGIC_ON_ERC721_RECEIVED,\r\n        NOT_ABLE_TO_RECEIVE_NFT\r\n      );\r\n    }\r\n\r\n    _transferFrom(_from, _to, _tokenId);\r\n  }\r\n\r\n  /**\r\n   * @dev Helper function that changes uint to string representation.\r\n   * @return String representation.\r\n   */\r\n  function _uint2str(\r\n    uint256 _i\r\n  ) \r\n    internal\r\n    pure\r\n    returns (string memory str)\r\n  {\r\n    if (_i == 0)\r\n    {\r\n      return \"0\";\r\n    }\r\n    uint256 j = _i;\r\n    uint256 length;\r\n    while (j != 0)\r\n    {\r\n      length++;\r\n      j /= 10;\r\n    }\r\n    bytes memory bstr = new bytes(length);\r\n    uint256 k = length - 1;\r\n    j = _i;\r\n    while (j != 0)\r\n    {\r\n      bstr[k--] = byte(uint8(48 + j % 10));\r\n      j /= 10;\r\n    }\r\n    str = string(bstr);\r\n  }\r\n  \r\n}\r\n\r\n/**\r\n * @dev Xcert implementation.\r\n */\r\ncontract XcertToken is \r\n  Xcert,\r\n  XcertBurnable,\r\n  XcertMutable,\r\n  XcertPausable,\r\n  XcertRevokable,\r\n  NFTokenMetadataEnumerable,\r\n  Abilitable\r\n{\r\n\r\n  /**\r\n   * @dev List of abilities (gathered from all extensions):\r\n   */\r\n  uint8 constant ABILITY_CREATE_ASSET = 2;\r\n  uint8 constant ABILITY_REVOKE_ASSET = 4;\r\n  uint8 constant ABILITY_TOGGLE_TRANSFERS = 8;\r\n  uint8 constant ABILITY_UPDATE_ASSET_IMPRINT = 16;\r\n  /// ABILITY_ALLOW_CREATE_ASSET = 32 - A specific ability that is bounded to atomic orders.\r\n  /// When creating a new Xcert trough `OrderGateway`, the order maker has to have this ability.\r\n  uint8 constant ABILITY_UPDATE_URI_BASE = 64;\r\n\r\n  /**\r\n   * @dev List of capabilities (supportInterface bytes4 representations).\r\n   */\r\n  bytes4 constant MUTABLE = 0xbda0e852;\r\n  bytes4 constant BURNABLE = 0x9d118770;\r\n  bytes4 constant PAUSABLE = 0xbedb86fb;\r\n  bytes4 constant REVOKABLE = 0x20c5429b;\r\n\r\n  /**\r\n   * @dev Error constants.\r\n   */\r\n  string constant CAPABILITY_NOT_SUPPORTED = \"007001\";\r\n  string constant TRANSFERS_DISABLED = \"007002\";\r\n  string constant NOT_VALID_XCERT = \"007003\";\r\n  string constant NOT_OWNER_OR_OPERATOR = \"007004\";\r\n\r\n  /**\r\n   * @dev This emits when ability of beeing able to transfer Xcerts changes (paused/unpaused).\r\n   */\r\n  event IsPaused(bool isPaused);\r\n\r\n  /**\r\n   * @dev Emits when imprint of a token is changed.\r\n   * @param _tokenId Id of the Xcert.\r\n   * @param _imprint Cryptographic asset imprint.\r\n   */\r\n  event TokenImprintUpdate(\r\n    uint256 indexed _tokenId,\r\n    bytes32 _imprint\r\n  );\r\n\r\n  /**\r\n   * @dev Unique ID which determines each Xcert smart contract type by its JSON convention.\r\n   * @notice Calculated as keccak256(jsonSchema).\r\n   */\r\n  bytes32 internal nftSchemaId;\r\n\r\n  /**\r\n   * @dev Maps NFT ID to imprint.\r\n   */\r\n  mapping (uint256 => bytes32) internal idToImprint;\r\n\r\n  /**\r\n   * @dev Maps address to authorization of contract.\r\n   */\r\n  mapping (address => bool) internal addressToAuthorized;\r\n\r\n  /**\r\n   * @dev Are Xcerts transfers paused (can be performed) or not.\r\n   */\r\n  bool public isPaused;\r\n\r\n  /**\r\n   * @dev Contract constructor.\r\n   * @notice When implementing this contract don't forget to set nftSchemaId, nftName, nftSymbol\r\n   * and uriBase.\r\n   */\r\n  constructor()\r\n    public\r\n  {\r\n    supportedInterfaces[0xe08725ee] = true; // Xcert\r\n  }\r\n\r\n  /**\r\n   * @dev Creates a new Xcert.\r\n   * @param _to The address that will own the created Xcert.\r\n   * @param _id The Xcert to be created by the msg.sender.\r\n   * @param _imprint Cryptographic asset imprint.\r\n   */\r\n  function create(\r\n    address _to,\r\n    uint256 _id,\r\n    bytes32 _imprint\r\n  )\r\n    external\r\n    hasAbilities(ABILITY_CREATE_ASSET)\r\n  {\r\n    super._create(_to, _id);\r\n    idToImprint[_id] = _imprint;\r\n  }\r\n\r\n  /**\r\n   * @dev Change URI base.\r\n   * @param _uriBase New uriBase.\r\n   */\r\n  function setUriBase(\r\n    string calldata _uriBase\r\n  )\r\n    external\r\n    hasAbilities(ABILITY_UPDATE_URI_BASE)\r\n  {\r\n    super._setUriBase(_uriBase);\r\n  }\r\n\r\n  /**\r\n   * @dev Revokes(destroys) a specified Xcert. Reverts if not called from contract owner or \r\n   * authorized address.\r\n   * @param _tokenId Id of the Xcert we want to destroy.\r\n   */\r\n  function revoke(\r\n    uint256 _tokenId\r\n  )\r\n    external\r\n    hasAbilities(ABILITY_REVOKE_ASSET)\r\n  {\r\n    require(supportedInterfaces[REVOKABLE], CAPABILITY_NOT_SUPPORTED);\r\n    super._destroy(_tokenId);\r\n    delete idToImprint[_tokenId];\r\n  }\r\n\r\n  /**\r\n   * @dev Sets if Xcerts transfers are paused (can be performed) or not.\r\n   * @param _isPaused Pause status.\r\n   */\r\n  function setPause(\r\n    bool _isPaused\r\n  )\r\n    external\r\n    hasAbilities(ABILITY_TOGGLE_TRANSFERS)\r\n  {\r\n    require(supportedInterfaces[PAUSABLE], CAPABILITY_NOT_SUPPORTED);\r\n    isPaused = _isPaused;\r\n    emit IsPaused(_isPaused);\r\n  }\r\n\r\n  /**\r\n   * @dev Updates Xcert imprint.\r\n   * @param _tokenId Id of the Xcert.\r\n   * @param _imprint New imprint.\r\n   */\r\n  function updateTokenImprint(\r\n    uint256 _tokenId,\r\n    bytes32 _imprint\r\n  )\r\n    external\r\n    hasAbilities(ABILITY_UPDATE_ASSET_IMPRINT)\r\n  {\r\n    require(supportedInterfaces[MUTABLE], CAPABILITY_NOT_SUPPORTED);\r\n    require(idToOwner[_tokenId] != address(0), NOT_VALID_XCERT);\r\n    idToImprint[_tokenId] = _imprint;\r\n    emit TokenImprintUpdate(_tokenId, _imprint);\r\n  }\r\n\r\n  /**\r\n   * @dev Destroys a specified Xcert. Reverts if not called from Xcert owner or operator.\r\n   * @param _tokenId Id of the Xcert we want to destroy.\r\n   */\r\n  function destroy(\r\n    uint256 _tokenId\r\n  )\r\n    external\r\n  {\r\n    require(supportedInterfaces[BURNABLE], CAPABILITY_NOT_SUPPORTED);\r\n    address tokenOwner = idToOwner[_tokenId];\r\n    super._destroy(_tokenId);\r\n    require(\r\n      tokenOwner == msg.sender || ownerToOperators[tokenOwner][msg.sender],\r\n      NOT_OWNER_OR_OPERATOR\r\n    );\r\n    delete idToImprint[_tokenId];\r\n  }\r\n\r\n  /**\r\n   * @dev Returns a bytes32 of sha256 of json schema representing 0xcert Protocol convention.\r\n   * @return Schema id.\r\n   */\r\n  function schemaId()\r\n    external\r\n    view\r\n    returns (bytes32 _schemaId)\r\n  {\r\n    _schemaId = nftSchemaId;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns imprint for Xcert.\r\n   * @param _tokenId Id of the Xcert.\r\n   * @return Token imprint.\r\n   */\r\n  function tokenImprint(\r\n    uint256 _tokenId\r\n  )\r\n    external\r\n    view\r\n    returns(bytes32 imprint)\r\n  {\r\n    imprint = idToImprint[_tokenId];\r\n  }\r\n\r\n  /**\r\n   * @dev Helper methods that actually does the transfer.\r\n   * @param _from The current owner of the NFT.\r\n   * @param _to The new owner.\r\n   * @param _tokenId The NFT to transfer.\r\n   */\r\n  function _transferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _tokenId\r\n  )\r\n    internal\r\n  {\r\n    /**\r\n     * if (supportedInterfaces[0xbedb86fb])\r\n     * {\r\n     *   require(!isPaused, TRANSFERS_DISABLED);\r\n     * }\r\n     * There is no need to check for pausable capability here since by using logical deduction we \r\n     * can say based on code above that:\r\n     * !supportedInterfaces[0xbedb86fb] => !isPaused\r\n     * isPaused => supportedInterfaces[0xbedb86fb]\r\n     * (supportedInterfaces[0xbedb86fb] âˆ§ isPaused) <=> isPaused. \r\n     * This saves 200 gas.\r\n     */\r\n    require(!isPaused, TRANSFERS_DISABLED); \r\n    super._transferFrom(_from, _to, _tokenId);\r\n  }\r\n}\r\n\r\n/**\r\n * @title XcertCreateProxy - creates a token on behalf of contracts that have been approved via\r\n * decentralized governance.\r\n */\r\ncontract XcertCreateProxy is \r\n  Abilitable \r\n{\r\n\r\n  /**\r\n   * @dev List of abilities:\r\n   * 2 - Ability to execute create. \r\n   */\r\n  uint8 constant ABILITY_TO_EXECUTE = 2;\r\n\r\n  /**\r\n   * @dev Creates a new NFT.\r\n   * @param _xcert Address of the Xcert contract on which the creation will be perfomed.\r\n   * @param _to The address that will own the created NFT.\r\n   * @param _id The NFT to be created by the msg.sender.\r\n   * @param _imprint Cryptographic asset imprint.\r\n   */\r\n  function create(\r\n    address _xcert,\r\n    address _to,\r\n    uint256 _id,\r\n    bytes32 _imprint\r\n  )\r\n    external\r\n    hasAbilities(ABILITY_TO_EXECUTE)\r\n  {\r\n    Xcert(_xcert).create(_to, _id, _imprint);\r\n  }\r\n  \r\n}\r\n\r\npragma experimental ABIEncoderV2;\r\n\r\n\r\n\r\n\r\n/**\r\n * @dev Decentralize exchange, creating, updating and other actions for fundgible and non-fundgible \r\n * tokens powered by atomic swaps. \r\n */\r\ncontract OrderGateway is\r\n  Abilitable\r\n{\r\n\r\n  /**\r\n   * @dev List of abilities:\r\n   * 2 - Ability to set proxies.\r\n   */\r\n  uint8 constant ABILITY_TO_SET_PROXIES = 2;\r\n\r\n  /**\r\n   * @dev Xcert abilities.\r\n   */\r\n  uint8 constant ABILITY_ALLOW_CREATE_ASSET = 32;\r\n\r\n  /**\r\n   * @dev Error constants.\r\n   */\r\n  string constant INVALID_SIGNATURE_KIND = \"015001\";\r\n  string constant INVALID_PROXY = \"015002\";\r\n  string constant TAKER_NOT_EQUAL_TO_SENDER = \"015003\";\r\n  string constant SENDER_NOT_TAKER_OR_MAKER = \"015004\";\r\n  string constant CLAIM_EXPIRED = \"015005\";\r\n  string constant INVALID_SIGNATURE = \"015006\";\r\n  string constant ORDER_CANCELED = \"015007\";\r\n  string constant ORDER_ALREADY_PERFORMED = \"015008\";\r\n  string constant MAKER_NOT_EQUAL_TO_SENDER = \"015009\";\r\n  string constant SIGNER_NOT_AUTHORIZED = \"015010\";\r\n\r\n  /**\r\n   * @dev Enum of available signature kinds.\r\n   * @param eth_sign Signature using eth sign.\r\n   * @param trezor Signature from Trezor hardware wallet.\r\n   * It differs from web3.eth_sign in the encoding of message length\r\n   * (Bitcoin varint encoding vs ascii-decimal, the latter is not\r\n   * self-terminating which leads to ambiguities).\r\n   * See also:\r\n   * https://en.bitcoin.it/wiki/Protocol_documentation#Variable_length_integer\r\n   * https://github.com/trezor/trezor-mcu/blob/master/firmware/ethereum.c#L602\r\n   * https://github.com/trezor/trezor-mcu/blob/master/firmware/crypto.c#L36 \r\n   * @param eip721 Signature using eip721.\r\n   */\r\n  enum SignatureKind\r\n  {\r\n    eth_sign,\r\n    trezor,\r\n    eip712\r\n  }\r\n\r\n  /**\r\n   * Enum of available action kinds.\r\n   */\r\n  enum ActionKind\r\n  {\r\n    create,\r\n    transfer\r\n  }\r\n\r\n  /**\r\n   * @dev Structure representing what to send and where.\r\n   * @param kind Enum representing action kind. \r\n   * @param proxy Id representing approved proxy address.\r\n   * @param token Address of the token we are sending.\r\n   * @param param1 Address of the sender or imprint.\r\n   * @param to Address of the receiver.\r\n   * @param value Amount of ERC20 or ID of ERC721.\r\n   */\r\n  struct ActionData \r\n  {\r\n    ActionKind kind;\r\n    uint32 proxy;\r\n    address token;\r\n    bytes32 param1;\r\n    address to;\r\n    uint256 value;\r\n  }\r\n\r\n  /**\r\n   * @dev Structure representing the signature parts.\r\n   * @param r ECDSA signature parameter r.\r\n   * @param s ECDSA signature parameter s.\r\n   * @param v ECDSA signature parameter v.\r\n   * @param kind Type of signature. \r\n   */\r\n  struct SignatureData\r\n  {\r\n    bytes32 r;\r\n    bytes32 s;\r\n    uint8 v;\r\n    SignatureKind kind;\r\n  }\r\n\r\n  /**\r\n   * @dev Structure representing the data needed to do the order.\r\n   * @param maker Address of the one that made the claim.\r\n   * @param taker Address of the one that is executing the claim.\r\n   * @param actions Data of all the actions that should accure it this order.\r\n   * @param signature Data from the signed claim.\r\n   * @param seed Arbitrary number to facilitate uniqueness of the order's hash. Usually timestamp.\r\n   * @param expiration Timestamp of when the claim expires. 0 if indefinet. \r\n   */\r\n  struct OrderData \r\n  {\r\n    address maker;\r\n    address taker;\r\n    ActionData[] actions;\r\n    uint256 seed;\r\n    uint256 expiration;\r\n  }\r\n\r\n  /** \r\n   * @dev Valid proxy contract addresses.\r\n   */\r\n  address[] public proxies;\r\n\r\n  /**\r\n   * @dev Mapping of all cancelled orders.\r\n   */\r\n  mapping(bytes32 => bool) public orderCancelled;\r\n\r\n  /**\r\n   * @dev Mapping of all performed orders.\r\n   */\r\n  mapping(bytes32 => bool) public orderPerformed;\r\n\r\n  /**\r\n   * @dev This event emmits when tokens change ownership.\r\n   */\r\n  event Perform(\r\n    address indexed _maker,\r\n    address indexed _taker,\r\n    bytes32 _claim\r\n  );\r\n\r\n  /**\r\n   * @dev This event emmits when transfer order is cancelled.\r\n   */\r\n  event Cancel(\r\n    address indexed _maker,\r\n    address indexed _taker,\r\n    bytes32 _claim\r\n  );\r\n\r\n  /**\r\n   * @dev This event emmits when proxy address is changed..\r\n   */\r\n  event ProxyChange(\r\n    uint256 indexed _index,\r\n    address _proxy\r\n  );\r\n\r\n  /**\r\n   * @dev Adds a verified proxy address. \r\n   * @notice Can be done through a multisig wallet in the future.\r\n   * @param _proxy Proxy address.\r\n   */\r\n  function addProxy(\r\n    address _proxy\r\n  )\r\n    external\r\n    hasAbilities(ABILITY_TO_SET_PROXIES)\r\n  {\r\n    uint256 length = proxies.push(_proxy);\r\n    emit ProxyChange(length - 1, _proxy);\r\n  }\r\n\r\n  /**\r\n   * @dev Removes a proxy address. \r\n   * @notice Can be done through a multisig wallet in the future.\r\n   * @param _index Index of proxy we are removing.\r\n   */\r\n  function removeProxy(\r\n    uint256 _index\r\n  )\r\n    external\r\n    hasAbilities(ABILITY_TO_SET_PROXIES)\r\n  {\r\n    proxies[_index] = address(0);\r\n    emit ProxyChange(_index, address(0));\r\n  }\r\n\r\n  /**\r\n   * @dev Performs the atomic swap that can exchange, create, update and do other actions for\r\n   * fungible and non-fungible tokens.\r\n   * @param _data Data required to make the order.\r\n   * @param _signature Data from the signature. \r\n   */\r\n  function perform(\r\n    OrderData memory _data,\r\n    SignatureData memory _signature\r\n  )\r\n    public \r\n  {\r\n    require(_data.taker == msg.sender, TAKER_NOT_EQUAL_TO_SENDER);\r\n    require(_data.expiration >= now, CLAIM_EXPIRED);\r\n\r\n    bytes32 claim = getOrderDataClaim(_data);\r\n    require(\r\n      isValidSignature(\r\n        _data.maker,\r\n        claim,\r\n        _signature\r\n      ), \r\n      INVALID_SIGNATURE\r\n    );\r\n\r\n    require(!orderCancelled[claim], ORDER_CANCELED);\r\n    require(!orderPerformed[claim], ORDER_ALREADY_PERFORMED);\r\n\r\n    orderPerformed[claim] = true;\r\n\r\n    _doActions(_data);\r\n\r\n    emit Perform(\r\n      _data.maker,\r\n      _data.taker,\r\n      claim\r\n    );\r\n  }\r\n\r\n  /** \r\n   * @dev Cancels order.\r\n   * @notice You can cancel the same order multiple times. There is no check for whether the order\r\n   * was already canceled due to gas optimization. You should either check orderCancelled variable\r\n   * or listen to Cancel event if you want to check if an order is already canceled.\r\n   * @param _data Data of order to cancel.\r\n   */\r\n  function cancel(\r\n    OrderData memory _data\r\n  )\r\n    public\r\n  {\r\n    require(_data.maker == msg.sender, MAKER_NOT_EQUAL_TO_SENDER);\r\n\r\n    bytes32 claim = getOrderDataClaim(_data);\r\n    require(!orderPerformed[claim], ORDER_ALREADY_PERFORMED);\r\n\r\n    orderCancelled[claim] = true;\r\n    emit Cancel(\r\n      _data.maker,\r\n      _data.taker,\r\n      claim\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @dev Calculates keccak-256 hash of OrderData from parameters.\r\n   * @param _orderData Data needed for atomic swap.\r\n   * @return keccak-hash of order data.\r\n   */\r\n  function getOrderDataClaim(\r\n    OrderData memory _orderData\r\n  )\r\n    public\r\n    view\r\n    returns (bytes32)\r\n  {\r\n    bytes32 temp = 0x0;\r\n\r\n    for(uint256 i = 0; i < _orderData.actions.length; i++)\r\n    {\r\n      temp = keccak256(\r\n        abi.encodePacked(\r\n          temp,\r\n          _orderData.actions[i].kind,\r\n          _orderData.actions[i].proxy,\r\n          _orderData.actions[i].token,\r\n          _orderData.actions[i].param1,\r\n          _orderData.actions[i].to,\r\n          _orderData.actions[i].value\r\n        )\r\n      );\r\n    }\r\n\r\n    return keccak256(\r\n      abi.encodePacked(\r\n        address(this),\r\n        _orderData.maker,\r\n        _orderData.taker,\r\n        temp,\r\n        _orderData.seed,\r\n        _orderData.expiration\r\n      )\r\n    );\r\n  }\r\n  \r\n  /**\r\n   * @dev Verifies if claim signature is valid.\r\n   * @param _signer address of signer.\r\n   * @param _claim Signed Keccak-256 hash.\r\n   * @param _signature Signature data.\r\n   */\r\n  function isValidSignature(\r\n    address _signer,\r\n    bytes32 _claim,\r\n    SignatureData memory _signature\r\n  )\r\n    public\r\n    pure\r\n    returns (bool)\r\n  {\r\n    if (_signature.kind == SignatureKind.eth_sign)\r\n    {\r\n      return _signer == ecrecover(\r\n        keccak256(\r\n          abi.encodePacked(\r\n            \"\\x19Ethereum Signed Message:\\n32\",\r\n            _claim\r\n          )\r\n        ),\r\n        _signature.v,\r\n        _signature.r,\r\n        _signature.s\r\n      );\r\n    } else if (_signature.kind == SignatureKind.trezor)\r\n    {\r\n      return _signer == ecrecover(\r\n        keccak256(\r\n          abi.encodePacked(\r\n            \"\\x19Ethereum Signed Message:\\n\\x20\",\r\n            _claim\r\n          )\r\n        ),\r\n        _signature.v,\r\n        _signature.r,\r\n        _signature.s\r\n      );\r\n    } else if (_signature.kind == SignatureKind.eip712)\r\n    {\r\n      return _signer == ecrecover(\r\n        _claim,\r\n        _signature.v,\r\n        _signature.r,\r\n        _signature.s\r\n      );\r\n    }\r\n\r\n    revert(INVALID_SIGNATURE_KIND);\r\n  }\r\n\r\n  /**\r\n   * @dev Helper function that makes transfes.\r\n   * @param _order Data needed for order.\r\n   */\r\n  function _doActions(\r\n    OrderData memory _order\r\n  )\r\n    private\r\n  {\r\n    for(uint256 i = 0; i < _order.actions.length; i++)\r\n    {\r\n      require(\r\n        proxies[_order.actions[i].proxy] != address(0),\r\n        INVALID_PROXY\r\n      );\r\n\r\n      if (_order.actions[i].kind == ActionKind.create)\r\n      {\r\n        require(\r\n          Abilitable(_order.actions[i].token).isAble(_order.maker, ABILITY_ALLOW_CREATE_ASSET),\r\n          SIGNER_NOT_AUTHORIZED\r\n        );\r\n        \r\n        XcertCreateProxy(proxies[_order.actions[i].proxy]).create(\r\n          _order.actions[i].token,\r\n          _order.actions[i].to,\r\n          _order.actions[i].value,\r\n          _order.actions[i].param1\r\n        );\r\n      } \r\n      else if (_order.actions[i].kind == ActionKind.transfer)\r\n      {\r\n        address from = address(uint160(bytes20(_order.actions[i].param1)));\r\n        require(\r\n          from == _order.maker\r\n          || from == _order.taker,\r\n          SENDER_NOT_TAKER_OR_MAKER\r\n        );\r\n        \r\n        Proxy(proxies[_order.actions[i].proxy]).execute(\r\n          _order.actions[i].token,\r\n          from,\r\n          _order.actions[i].to,\r\n          _order.actions[i].value\r\n        );\r\n      }\r\n    }\r\n  }\r\n  \r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_target\",\"type\":\"address\"},{\"name\":\"_abilities\",\"type\":\"uint256\"}],\"name\":\"grantAbilities\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_proxy\",\"type\":\"address\"}],\"name\":\"addProxy\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"components\":[{\"name\":\"maker\",\"type\":\"address\"},{\"name\":\"taker\",\"type\":\"address\"},{\"components\":[{\"name\":\"kind\",\"type\":\"uint8\"},{\"name\":\"proxy\",\"type\":\"uint32\"},{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"param1\",\"type\":\"bytes32\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"actions\",\"type\":\"tuple[]\"},{\"name\":\"seed\",\"type\":\"uint256\"},{\"name\":\"expiration\",\"type\":\"uint256\"}],\"name\":\"_data\",\"type\":\"tuple\"}],\"name\":\"cancel\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"removeProxy\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"addressToAbility\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"orderCancelled\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"components\":[{\"name\":\"maker\",\"type\":\"address\"},{\"name\":\"taker\",\"type\":\"address\"},{\"components\":[{\"name\":\"kind\",\"type\":\"uint8\"},{\"name\":\"proxy\",\"type\":\"uint32\"},{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"param1\",\"type\":\"bytes32\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"actions\",\"type\":\"tuple[]\"},{\"name\":\"seed\",\"type\":\"uint256\"},{\"name\":\"expiration\",\"type\":\"uint256\"}],\"name\":\"_data\",\"type\":\"tuple\"},{\"components\":[{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"},{\"name\":\"v\",\"type\":\"uint8\"},{\"name\":\"kind\",\"type\":\"uint8\"}],\"name\":\"_signature\",\"type\":\"tuple\"}],\"name\":\"perform\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_signer\",\"type\":\"address\"},{\"name\":\"_claim\",\"type\":\"bytes32\"},{\"components\":[{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"},{\"name\":\"v\",\"type\":\"uint8\"},{\"name\":\"kind\",\"type\":\"uint8\"}],\"name\":\"_signature\",\"type\":\"tuple\"}],\"name\":\"isValidSignature\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"proxies\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_target\",\"type\":\"address\"},{\"name\":\"_abilities\",\"type\":\"uint256\"},{\"name\":\"_allowSuperRevoke\",\"type\":\"bool\"}],\"name\":\"revokeAbilities\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_target\",\"type\":\"address\"},{\"name\":\"_abilities\",\"type\":\"uint256\"}],\"name\":\"isAble\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"components\":[{\"name\":\"maker\",\"type\":\"address\"},{\"name\":\"taker\",\"type\":\"address\"},{\"components\":[{\"name\":\"kind\",\"type\":\"uint8\"},{\"name\":\"proxy\",\"type\":\"uint32\"},{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"param1\",\"type\":\"bytes32\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"actions\",\"type\":\"tuple[]\"},{\"name\":\"seed\",\"type\":\"uint256\"},{\"name\":\"expiration\",\"type\":\"uint256\"}],\"name\":\"_orderData\",\"type\":\"tuple\"}],\"name\":\"getOrderDataClaim\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"orderPerformed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_maker\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_taker\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_claim\",\"type\":\"bytes32\"}],\"name\":\"Perform\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_maker\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_taker\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_claim\",\"type\":\"bytes32\"}],\"name\":\"Cancel\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_index\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_proxy\",\"type\":\"address\"}],\"name\":\"ProxyChange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_target\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_abilities\",\"type\":\"uint256\"}],\"name\":\"GrantAbilities\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_target\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_abilities\",\"type\":\"uint256\"}],\"name\":\"RevokeAbilities\",\"type\":\"event\"}]","ContractName":"OrderGateway","CompilerVersion":"v0.5.5+commit.47a71e8f","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://35d95e84b77938745f31baeaa0bed8c296c14afd93751ba5b8d062c559fa9d19"}]}