{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.4;\r\npragma experimental ABIEncoderV2;\r\n\r\n//Where r you Vitalik, we don't have FLOAT :( and money to develop plz~ :D\r\n\r\n\r\n\r\n\r\n\r\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n//End contract of base component\r\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\ncontract AI_on_BlockChain__BaseComponent {\r\n    \r\n\r\n    struct NeuralNetWork_Struct_Object\r\n    {\r\n        uint Im_Number_Of_Layer ;\r\n        uint[] Im_Nodes_In_EachLayer;\r\n        int[][] Im_Bias_Of_Nodes_In_EachLayer;\r\n        int[][][] Im_Weights_Of_Nodes_In_EachLayer;\r\n    }    \r\n    \r\n    function Im_StanderRandomNumber(uint Im_Cute_Input_Number) \r\n    public view  \r\n    returns (int Im_Cute_Random_Number)\r\n    {\r\n        //Worship Lu\r\n        require(msg.sender != block.coinbase);\r\n        require(msg.sender == tx.origin);\r\n        \r\n        int Im_Random_Number = int(keccak256(abi.encodePacked(blockhash(block.number - 1), msg.sender, block.difficulty,  Im_Cute_Input_Number))) % 2;\r\n        \r\n        return Im_Random_Number;\r\n    }\r\n        \r\n    \r\n    function Im_Function_Initialize_NeuralNetwork(uint TotalNumber_Of_Layer, uint[] memory WeR_Nodes_In_EachLayer) \r\n    public view \r\n    returns (NeuralNetWork_Struct_Object memory Im_NeuralNetWork_Object)\r\n    {\r\n        \r\n        int[][] memory WeR_Bias_Of_Nodes_In_EachLayer;\r\n        int[][][] memory WeR_Weights_Of_Nodes_In_EachLayer;\r\n        \r\n        for (uint Im_Number_Of_Layer = 1 ; Im_Number_Of_Layer <= TotalNumber_Of_Layer ; Im_Number_Of_Layer++) \r\n        {\r\n            for(uint Im_Number_Of_Node = 0 ; Im_Number_Of_Node <= WeR_Nodes_In_EachLayer[Im_Number_Of_Layer]; Im_Number_Of_Node++) \r\n            {\r\n                WeR_Bias_Of_Nodes_In_EachLayer[Im_Number_Of_Layer][Im_Number_Of_Node] = Im_StanderRandomNumber(now)-1;\r\n                \r\n                for(uint Im_Weights_For_Node ;  Im_Weights_For_Node <= WeR_Nodes_In_EachLayer[Im_Number_Of_Layer-1] ; Im_Weights_For_Node++){\r\n                    \r\n                    WeR_Weights_Of_Nodes_In_EachLayer[Im_Number_Of_Layer][Im_Number_Of_Node][Im_Weights_For_Node]= Im_StanderRandomNumber(now);\r\n                }\r\n            }\r\n        }\r\n        \r\n        NeuralNetWork_Struct_Object memory Im_NeuralNetWork_Struct_Object = NeuralNetWork_Struct_Object\r\n        (\r\n            {Im_Number_Of_Layer : TotalNumber_Of_Layer,\r\n            Im_Nodes_In_EachLayer : WeR_Nodes_In_EachLayer,\r\n            Im_Bias_Of_Nodes_In_EachLayer : WeR_Bias_Of_Nodes_In_EachLayer,\r\n            Im_Weights_Of_Nodes_In_EachLayer : WeR_Weights_Of_Nodes_In_EachLayer}\r\n        );\r\n        \r\n        return Im_NeuralNetWork_Struct_Object;\r\n    }\r\n    \r\n    \r\n    \r\n    \r\n    function Im_Sum_For_NodeInput(int[] memory Im_InputData, int[] memory Im_EachWeights, int Im_Bias) \r\n    public pure \r\n    returns (int TransferValue_For_ActivationFunction) \r\n    {\r\n        int Sum_Value;\r\n        for(uint Im_Calculous_Pair = 0; Im_Calculous_Pair < Im_InputData.length; Im_Calculous_Pair++)\r\n        {\r\n            Sum_Value = Sum_Value + Im_InputData[Im_Calculous_Pair] * Im_EachWeights[Im_Calculous_Pair];\r\n        }\r\n        \r\n        Sum_Value = Sum_Value + Im_Bias;\r\n        \r\n        return Sum_Value;\r\n    }\r\n    \r\n}\r\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n//End contract of base component\r\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\n\r\n\r\n\r\n\r\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n//Start contract of computational function\r\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\ncontract AI_on_BlockChain__ComputationalFunction is AI_on_BlockChain__BaseComponent{\r\n    \r\n    function Im_Activation_Function__Sigmoid(int Im_InputValue) \r\n    public pure \r\n    returns (int Im_OutputValue) \r\n    {\r\n        //int Im_interger = 12345e-2;\r\n        int Im_Exponencial_Number;\r\n        int Im_Sigmoid_Output;\r\n        \r\n//searching operand Im_Exponencial_Number = int(2.71828) ** ( - Im_InputValue);\r\n        \r\n        Im_Sigmoid_Output = 1 / ( 1 + Im_Exponencial_Number );\r\n         \r\n        return  Im_Sigmoid_Output;\r\n        \r\n    }\r\n    \r\n    \r\n    \r\n    function Im_Activation_Function__Relu(int Im_Input) \r\n    public pure \r\n    returns (int Im_Output) \r\n    {\r\n        \r\n        int Im_Relu_Output;\r\n        \r\n        if(Im_Input <= 0)\r\n        {\r\n            Im_Relu_Output = 0;  \r\n        } \r\n        \r\n        \r\n        else if(Im_Input > 0)\r\n        {\r\n            Im_Relu_Output = Im_Input;\r\n        }\r\n        \r\n        return Im_Relu_Output;\r\n        \r\n    }\r\n\r\n\r\n    function Im_sigmoid_function_Derivative (int Im_InputValue)\r\n    public pure\r\n    returns(int Im_OutputValue) \r\n    {\r\n        int Im_OutputValue_Computation;\r\n        \r\n        Im_OutputValue_Computation = Im_InputValue * (1 - Im_InputValue);\r\n        \r\n        return Im_OutputValue_Computation;\r\n    }\r\n\r\n\r\n//    function Im_relu_function_Derivative () returns() {    }\r\n    \r\n    \r\n    function Im_Loss_function__L2 (int[] memory Im_Predict_ResultSets, int[] memory Im_Actual_ResultSets) \r\n    public pure\r\n    returns (int Im_Result_Error) \r\n    {\r\n        int Im_L2_Error;\r\n        \r\n        for (uint Im_Number_Of_ComputationalPair ; Im_Number_Of_ComputationalPair < Im_Predict_ResultSets.length; Im_Number_Of_ComputationalPair++)\r\n        {\r\n            int Im_Residual;\r\n            Im_Residual = Im_Actual_ResultSets[Im_Number_Of_ComputationalPair] - Im_Predict_ResultSets[Im_Number_Of_ComputationalPair];\r\n            Im_L2_Error = Im_L2_Error + (Im_Residual * Im_Residual);\r\n        }\r\n        \r\n        return Im_L2_Error;\r\n    }\r\n\r\n    function Im_Loss_function__MSE (int[] memory Im_Predict_ResultSets, int[] memory Im_Actual_ResultSets) \r\n    public pure \r\n    returns (int Im_Result_Error) \r\n    {\r\n        int Im_MSE_Error;\r\n        \r\n        for (uint Im_Number_Of_ComputationalPair ; Im_Number_Of_ComputationalPair < Im_Predict_ResultSets.length; Im_Number_Of_ComputationalPair++)\r\n        {\r\n            int Im_Residual;\r\n            Im_Residual = Im_Actual_ResultSets[Im_Number_Of_ComputationalPair] - Im_Predict_ResultSets[Im_Number_Of_ComputationalPair];\r\n            Im_MSE_Error = Im_MSE_Error + (Im_Residual * Im_Residual);\r\n        }        \r\n        Im_MSE_Error = Im_MSE_Error / int(Im_Predict_ResultSets.length);\r\n        \r\n        return Im_MSE_Error;\r\n    }\r\n}\r\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n//Start contract of computational function\r\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\n\r\n\r\n\r\n\r\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n//Start contract of operational function\r\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\ncontract AI_on_BlockChain__OperationalFunction is AI_on_BlockChain__ComputationalFunction {\r\n\r\n\r\n    function Im_Forward_Propagation__Prediction(int[] memory Im_Input_Feature , NeuralNetWork_Struct_Object memory Im_NeuralNetWork_Object)\r\n    public pure\r\n    returns(int Im_OutPut_PredictionResult)\r\n    {\r\n\r\n        int[] memory Im_Current_FlowingTensor;\r\n        int[] memory Im_New_FlowingTensor;\r\n        int Im_OutPutResult;\r\n        Im_Current_FlowingTensor = Im_Input_Feature;\r\n        \r\n        for(uint Im_Propagation_Layer = 1; Im_Propagation_Layer <= Im_NeuralNetWork_Object.Im_Number_Of_Layer; Im_Propagation_Layer++)\r\n        {\r\n            for(uint Im_Current_Neural = 0; Im_Current_Neural <= Im_NeuralNetWork_Object.Im_Nodes_In_EachLayer[Im_Propagation_Layer]; Im_Current_Neural++)\r\n            {\r\n                int Im_Activation_Function_Input_Sum;\r\n                Im_Activation_Function_Input_Sum = Im_Sum_For_NodeInput\r\n                (\r\n                    {Im_InputData : Im_Current_FlowingTensor, \r\n                    Im_EachWeights : Im_NeuralNetWork_Object.Im_Weights_Of_Nodes_In_EachLayer[Im_Propagation_Layer][Im_Current_Neural], \r\n                    Im_Bias : Im_NeuralNetWork_Object.Im_Bias_Of_Nodes_In_EachLayer[Im_Propagation_Layer][Im_Current_Neural]}\r\n                );\r\n                \r\n                Im_New_FlowingTensor[Im_Current_Neural] = Im_Activation_Function__Sigmoid(Im_Activation_Function_Input_Sum);\r\n            }\r\n            \r\n            Im_Current_FlowingTensor = Im_New_FlowingTensor;\r\n\r\n        }\r\n        \r\n        Im_OutPutResult = Im_Current_FlowingTensor[0];\r\n        \r\n        return Im_OutPutResult;\r\n    }    \r\n    \r\n\r\n// throw out the input summation of each node and partial derivative of input summation respect to each weight\r\n\r\n    function Im_Backward_Propagation__ForwardPass(int[] memory Im_Current_InputData, NeuralNetWork_Struct_Object memory Im_NeuralNetWork_Object)\r\n    public pure\r\n    returns (int[][] memory InputSum_Of_Nodes, int[][][] memory Im_PartialDerivative__Of_InputSum_RespectTo_Weights)\r\n    {\r\n        int[][] memory Im_InputSum_Of_Nodes;\r\n        int[][][] memory Im_PartialDerivative_Of_InputSum_RespectTo_Weights;\r\n        \r\n        int[] memory Im_Current_FlowingTensor;\r\n        int[] memory Im_New_FlowingTensor;        \r\n        Im_Current_FlowingTensor = Im_Current_InputData;\r\n        \r\n        for(uint Im_Propagation_Layer = 1; Im_Propagation_Layer <= Im_NeuralNetWork_Object.Im_Number_Of_Layer; Im_Propagation_Layer++)\r\n        {\r\n            for(uint Im_Current_Neural = 0; Im_Current_Neural <= Im_NeuralNetWork_Object.Im_Nodes_In_EachLayer[Im_Propagation_Layer]; Im_Current_Neural++)\r\n            {\r\n                int Im_Activation_Function_Input_Sum;\r\n                Im_Activation_Function_Input_Sum = Im_Sum_For_NodeInput\r\n                (\r\n                    Im_Current_FlowingTensor, \r\n                    Im_NeuralNetWork_Object.Im_Weights_Of_Nodes_In_EachLayer[Im_Propagation_Layer][Im_Current_Neural], \r\n                    Im_NeuralNetWork_Object.Im_Bias_Of_Nodes_In_EachLayer[Im_Propagation_Layer][Im_Current_Neural]\r\n                );\r\n                \r\n                Im_New_FlowingTensor[Im_Current_Neural] = Im_Activation_Function__Sigmoid(Im_Activation_Function_Input_Sum);\r\n                \r\n//                \r\n                Im_InputSum_Of_Nodes[Im_Propagation_Layer][Im_Current_Neural] = Im_Activation_Function_Input_Sum;\r\n                Im_PartialDerivative_Of_InputSum_RespectTo_Weights[Im_Propagation_Layer][Im_Current_Neural] = Im_Current_FlowingTensor;\r\n//                \r\n            }\r\n            \r\n            Im_Current_FlowingTensor = Im_New_FlowingTensor;\r\n\r\n        }\r\n        \r\n        return (Im_InputSum_Of_Nodes, Im_PartialDerivative_Of_InputSum_RespectTo_Weights); \r\n        \r\n    }\r\n    \r\n\r\n    function Im_Backward_Propagation__BackwardPass(int[] memory Im_PartialDerivative__Current_Error, int[][] memory Im_InputSum_Of_Nodes, NeuralNetWork_Struct_Object memory Im_NeuralNetWork_Object)\r\n    public pure\r\n    returns (int[][] memory PartialDerivative__of_Error_RespectTo_InputSum_Of_Nodes)\r\n    {\r\n        \r\n        int[][] memory Im_PartialDerivative__of_Error_RespectTo_InputSum_Of_Nodes;\r\n        int[] memory Im_PartialDerivative__TensorSet___In_Previous_Layer;\r\n        \r\n        Im_PartialDerivative__TensorSet___In_Previous_Layer = Im_PartialDerivative__Current_Error;\r\n        \r\n        \r\n        for(uint Im_Propagation_Layer = 1; Im_Propagation_Layer <= Im_NeuralNetWork_Object.Im_Number_Of_Layer; Im_Propagation_Layer++)\r\n        {\r\n\r\n            int[] memory Im_PartialDerivative__InputSum_Of_Nodes___In_Current_Layer;            \r\n            \r\n            for(uint Im_Current_Neural = 0; Im_Current_Neural <= Im_NeuralNetWork_Object.Im_Nodes_In_EachLayer[Im_Propagation_Layer]; Im_Current_Neural++)\r\n            {\r\n                int Im_Sum_Of__Weight_Time_PartialDerivativePreviousLayerInputSum;\r\n                int Im_PartialDerivative__Of_Loss_Respect_to_InputSum__in_Current_Neural;\r\n                \r\n                for(uint Im_Number_Of_CurrentWeight; Im_Number_Of_CurrentWeight < Im_NeuralNetWork_Object.Im_Weights_Of_Nodes_In_EachLayer[Im_Propagation_Layer][Im_Current_Neural].length; Im_Number_Of_CurrentWeight++)\r\n                {\r\n                    int Im_CurrentWeight;\r\n                    int Im_PartialDerivative_PreviousLayerInputSum;\r\n                    \r\n                    Im_CurrentWeight = Im_NeuralNetWork_Object.Im_Weights_Of_Nodes_In_EachLayer[Im_Propagation_Layer][Im_Current_Neural][Im_Number_Of_CurrentWeight];\r\n                    Im_PartialDerivative_PreviousLayerInputSum = Im_PartialDerivative__TensorSet___In_Previous_Layer[Im_Number_Of_CurrentWeight];\r\n                    \r\n                    Im_Sum_Of__Weight_Time_PartialDerivativePreviousLayerInputSum = Im_Sum_Of__Weight_Time_PartialDerivativePreviousLayerInputSum + (Im_CurrentWeight * Im_PartialDerivative_PreviousLayerInputSum);\r\n                }\r\n                \r\n                Im_PartialDerivative__Of_Loss_Respect_to_InputSum__in_Current_Neural = Im_sigmoid_function_Derivative(Im_InputSum_Of_Nodes[Im_Propagation_Layer][Im_Current_Neural]) * Im_Sum_Of__Weight_Time_PartialDerivativePreviousLayerInputSum;\r\n                Im_PartialDerivative__InputSum_Of_Nodes___In_Current_Layer[Im_Current_Neural] = Im_PartialDerivative__Of_Loss_Respect_to_InputSum__in_Current_Neural;\r\n            }\r\n            \r\n            Im_PartialDerivative__of_Error_RespectTo_InputSum_Of_Nodes[Im_NeuralNetWork_Object.Im_Number_Of_Layer - Im_Propagation_Layer] = Im_PartialDerivative__InputSum_Of_Nodes___In_Current_Layer;\r\n            Im_PartialDerivative__TensorSet___In_Previous_Layer = Im_PartialDerivative__InputSum_Of_Nodes___In_Current_Layer;\r\n            \r\n        }\r\n        \r\n        return Im_PartialDerivative__of_Error_RespectTo_InputSum_Of_Nodes;\r\n        \r\n    }\r\n    \r\n\r\n\r\n    function Im_ComputationFunction_PartialDerivative__Of_LossFunction_RespectTo_Weights\r\n    (\r\n        int[][] memory Im_Input_Feature, \r\n        int[] memory Im_Input_Label, \r\n        NeuralNetWork_Struct_Object memory Im_NeuralNetWork_Object        \r\n    )\r\n    public pure\r\n    returns\r\n    (int[][][] memory PartialDerivative__Of_LossFunction_RespectTo_Weights_TotalAccumulation)\r\n    {\r\n    //    compute partial derivative of loss respect to weight\r\n        int[][][] memory Im_PartialDerivative__Of_LossFunction_RespectTo_Weights_TotalAccumulation;          \r\n        \r\n    //    compute the total loss and the total partial derivative of loss respect to each weight of the current weight from all the prediction value and actual value(label      \r\n        for(uint Im_Number_Of_Data; Im_Number_Of_Data < Im_Input_Label.length ; Im_Number_Of_Data)\r\n        {\r\n            \r\n            int[][][] memory Im_PartialDerivative__Of_LossFunction_RespectTo_Weights;\r\n            //    store result of forward pass in backward propogation\r\n            int[][] memory Im_InputSum_Of_EachNodes;\r\n            int[][][] memory Im_PartialDerivative__Of_InputSum_RespectTo_Weights;            \r\n            //    store result of backward pass in backward propogation\r\n            int[][] memory Im_PartialDerivative__of_Error_RespectTo_InputSum_Of_Nodes;    \r\n\r\n            \r\n            int[] memory Im_OutPut_PredictionResult_Of_This_Data;\r\n            int[] memory Im_OutPut_ActualLabelResult_Of_This_Data;\r\n            int[] memory Im_Error_Of_This_Data;\r\n            \r\n        //    forward propogation compute all the prediction value for total input feature\r\n            Im_OutPut_PredictionResult_Of_This_Data[0] = Im_Forward_Propagation__Prediction\r\n            (\r\n                {Im_Input_Feature : Im_Input_Feature[Im_Number_Of_Data], \r\n                Im_NeuralNetWork_Object : Im_NeuralNetWork_Object}\r\n            );\r\n            \r\n            Im_OutPut_ActualLabelResult_Of_This_Data[0] = Im_Input_Label[Im_Number_Of_Data];\r\n            Im_Error_Of_This_Data[0] = Im_Loss_function__L2({Im_Predict_ResultSets : Im_OutPut_PredictionResult_Of_This_Data, Im_Actual_ResultSets : Im_OutPut_ActualLabelResult_Of_This_Data});                \r\n            \r\n        //  compute all the partial derivative of input sum respect to each weight\r\n        \r\n            (Im_InputSum_Of_EachNodes, Im_PartialDerivative__Of_InputSum_RespectTo_Weights) = Im_Backward_Propagation__ForwardPass\r\n            (\r\n                {Im_Current_InputData : Im_Input_Feature[Im_Number_Of_Data], \r\n                Im_NeuralNetWork_Object : Im_NeuralNetWork_Object}\r\n            );\r\n            \r\n            \r\n        //  compute all the partial derivative of loss respect to each input sum\r\n            Im_PartialDerivative__of_Error_RespectTo_InputSum_Of_Nodes = Im_Backward_Propagation__BackwardPass\r\n            (\r\n                {Im_PartialDerivative__Current_Error : Im_Error_Of_This_Data, \r\n                Im_InputSum_Of_Nodes : Im_InputSum_Of_EachNodes, \r\n                Im_NeuralNetWork_Object : Im_NeuralNetWork_Object}   \r\n            );                \r\n            \r\n            \r\n            for(uint Im_Number_Of_layer = 1; Im_Number_Of_layer < Im_NeuralNetWork_Object.Im_Number_Of_Layer; Im_Number_Of_layer++ )\r\n            {                \r\n                for(uint Im_Number_Of_Neural; Im_Number_Of_Neural < Im_NeuralNetWork_Object.Im_Nodes_In_EachLayer[Im_Number_Of_layer]; Im_Number_Of_Neural++ )\r\n                {                \r\n                    for(uint Im_Number_Of_Weight; Im_Number_Of_Weight < Im_NeuralNetWork_Object.Im_Weights_Of_Nodes_In_EachLayer[Im_Number_Of_layer][Im_Number_Of_Neural].length; Im_Number_Of_Weight++ )\r\n                    {\r\n                        Im_PartialDerivative__Of_LossFunction_RespectTo_Weights[Im_Number_Of_layer][Im_Number_Of_Neural][Im_Number_Of_Weight] = Im_PartialDerivative__Of_InputSum_RespectTo_Weights[Im_Number_Of_layer][Im_Number_Of_Neural][Im_Number_Of_Weight] * Im_PartialDerivative__of_Error_RespectTo_InputSum_Of_Nodes[Im_Number_Of_layer][Im_Number_Of_Neural];\r\n                        Im_PartialDerivative__Of_LossFunction_RespectTo_Weights_TotalAccumulation[Im_Number_Of_layer][Im_Number_Of_Neural][Im_Number_Of_Weight] = Im_PartialDerivative__Of_LossFunction_RespectTo_Weights_TotalAccumulation[Im_Number_Of_layer][Im_Number_Of_Neural][Im_Number_Of_Weight] + Im_PartialDerivative__Of_LossFunction_RespectTo_Weights[Im_Number_Of_layer][Im_Number_Of_Neural][Im_Number_Of_Weight] ;\r\n                    }                \r\n                } \r\n            }\r\n        }\r\n        \r\n        return Im_PartialDerivative__Of_LossFunction_RespectTo_Weights_TotalAccumulation;\r\n    }\r\n\r\n}\r\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n//End contract of operational function\r\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\n\r\n\r\n\r\n\r\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n//Start contract of excution\r\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\ncontract AI_on_BlockChain__Execution is AI_on_BlockChain__OperationalFunction {\r\n    \r\n    function Im_Predict_Function(int[] memory Im_Input_Feature , NeuralNetWork_Struct_Object memory Im_NeuralNetWork_Object)\r\n    public pure\r\n    returns(int Im_Prediction_Result)\r\n    {\r\n        int Im_Prediction_ResultValue;\r\n        Im_Prediction_ResultValue = Im_Forward_Propagation__Prediction\r\n        (\r\n            {Im_Input_Feature : Im_Input_Feature, \r\n            Im_NeuralNetWork_Object : Im_NeuralNetWork_Object}\r\n        );\r\n\r\n        return Im_Prediction_ResultValue;\r\n    }    \r\n    \r\n\r\n    function Im_Training_Function__BackwardPropagation\r\n    (\r\n        int[][] memory Im_Input_Feature, \r\n        int[] memory Im_Input_Label, \r\n        int Learing_Rate, \r\n        uint TrainingTimes, \r\n        NeuralNetWork_Struct_Object memory Im_NeuralNetWork_Object\r\n    )\r\n    public pure\r\n    returns \r\n    (\r\n        int Avrage_Error, \r\n        int[] memory PredictionResultSet_AfterTraining, \r\n        int[][][] memory Current_WeightSet_Of_Nodes_In_EachLayer\r\n    )\r\n    {\r\n    // initialize original weight equal to Im_NeuralNetWork_Object.Im_Weights_Of_Nodes_In_EachLayer\r\n        int[][][] memory Im_Current_WeightSet_Of_Nodes_In_EachLayer = Im_NeuralNetWork_Object.Im_Weights_Of_Nodes_In_EachLayer;\r\n        \r\n    // loop training times\r\n        for(uint Im_NumberOfTraining = 0; Im_NumberOfTraining < TrainingTimes; Im_NumberOfTraining++ )\r\n        {\r\n\r\n    //    compute partial derivative of loss respect to weight\r\n            \r\n        \r\n            int[][][] memory Im_PartialDerivative__Of_LossFunction_RespectTo_Weights_TotalAccumulation;          \r\n            \r\n            Im_PartialDerivative__Of_LossFunction_RespectTo_Weights_TotalAccumulation = Im_ComputationFunction_PartialDerivative__Of_LossFunction_RespectTo_Weights\r\n            (\r\n                {Im_Input_Feature : Im_Input_Feature, \r\n                Im_Input_Label : Im_Input_Label, \r\n                Im_NeuralNetWork_Object : Im_NeuralNetWork_Object}\r\n            );    \r\n                \r\n            for(uint Im_Number_Of_layer = 1; Im_Number_Of_layer < Im_NeuralNetWork_Object.Im_Number_Of_Layer; Im_Number_Of_layer++ )\r\n            {                \r\n                for(uint Im_Number_Of_Neural; Im_Number_Of_Neural < Im_NeuralNetWork_Object.Im_Nodes_In_EachLayer[Im_Number_Of_layer]; Im_Number_Of_Neural++ )\r\n                {                \r\n                    for(uint Im_Number_Of_Weight; Im_Number_Of_Weight < Im_NeuralNetWork_Object.Im_Weights_Of_Nodes_In_EachLayer[Im_Number_Of_layer][Im_Number_Of_Neural].length; Im_Number_Of_Weight++ )\r\n                    {\r\n                        Im_Current_WeightSet_Of_Nodes_In_EachLayer[Im_Number_Of_layer][Im_Number_Of_Neural][Im_Number_Of_Weight] = Im_Current_WeightSet_Of_Nodes_In_EachLayer[Im_Number_Of_layer][Im_Number_Of_Neural][Im_Number_Of_Weight]  - ( Learing_Rate * Im_PartialDerivative__Of_LossFunction_RespectTo_Weights_TotalAccumulation[Im_Number_Of_layer][Im_Number_Of_Neural][Im_Number_Of_Weight] );\r\n                        Im_NeuralNetWork_Object.Im_Weights_Of_Nodes_In_EachLayer = Im_Current_WeightSet_Of_Nodes_In_EachLayer;\r\n                    }                \r\n                } \r\n            }\r\n            \r\n            //    update partial derivative of loss respect to weight by updateing : (weight = Learing_Rate * partial derivative of loss respect to weight)\r\n            \r\n        }\r\n        \r\n        int Im_PredictionResult_AfterTraining;\r\n        int[] memory Im_PredictionResultSet_AfterTraining;\r\n        int Im_Avrage_Error;\r\n        \r\n        for(uint Im_Number_Of_Data; Im_Number_Of_Data <= Im_Input_Feature.length ; Im_Number_Of_Data++)\r\n        {\r\n            Im_PredictionResult_AfterTraining = Im_Forward_Propagation__Prediction({Im_Input_Feature : Im_Input_Feature[Im_Number_Of_Data], Im_NeuralNetWork_Object : Im_NeuralNetWork_Object});\r\n            Im_PredictionResultSet_AfterTraining[Im_Number_Of_Data] = Im_PredictionResult_AfterTraining;\r\n        }\r\n        \r\n        Im_Avrage_Error = Im_Loss_function__L2({Im_Predict_ResultSets : Im_PredictionResultSet_AfterTraining, Im_Actual_ResultSets : Im_Input_Label});\r\n        \r\n        return (Im_Avrage_Error, Im_PredictionResultSet_AfterTraining, Im_Current_WeightSet_Of_Nodes_In_EachLayer);\r\n    }\r\n    \r\n}\r\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n//End contract of execution\r\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\n\r\n\r\n//Create by meowent@gmail.com\r\n//Worship LuGoddess forever","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"TotalNumber_Of_Layer\",\"type\":\"uint256\"},{\"name\":\"WeR_Nodes_In_EachLayer\",\"type\":\"uint256[]\"}],\"name\":\"Im_Function_Initialize_NeuralNetwork\",\"outputs\":[{\"components\":[{\"name\":\"Im_Number_Of_Layer\",\"type\":\"uint256\"},{\"name\":\"Im_Nodes_In_EachLayer\",\"type\":\"uint256[]\"},{\"name\":\"Im_Bias_Of_Nodes_In_EachLayer\",\"type\":\"int256[][]\"},{\"name\":\"Im_Weights_Of_Nodes_In_EachLayer\",\"type\":\"int256[][][]\"}],\"name\":\"Im_NeuralNetWork_Object\",\"type\":\"tuple\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"Im_Input_Feature\",\"type\":\"int256[][]\"},{\"name\":\"Im_Input_Label\",\"type\":\"int256[]\"},{\"components\":[{\"name\":\"Im_Number_Of_Layer\",\"type\":\"uint256\"},{\"name\":\"Im_Nodes_In_EachLayer\",\"type\":\"uint256[]\"},{\"name\":\"Im_Bias_Of_Nodes_In_EachLayer\",\"type\":\"int256[][]\"},{\"name\":\"Im_Weights_Of_Nodes_In_EachLayer\",\"type\":\"int256[][][]\"}],\"name\":\"Im_NeuralNetWork_Object\",\"type\":\"tuple\"}],\"name\":\"Im_ComputationFunction_PartialDerivative__Of_LossFunction_RespectTo_Weights\",\"outputs\":[{\"name\":\"PartialDerivative__Of_LossFunction_RespectTo_Weights_TotalAccumulation\",\"type\":\"int256[][][]\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"Im_InputValue\",\"type\":\"int256\"}],\"name\":\"Im_Activation_Function__Sigmoid\",\"outputs\":[{\"name\":\"Im_OutputValue\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"Im_InputValue\",\"type\":\"int256\"}],\"name\":\"Im_sigmoid_function_Derivative\",\"outputs\":[{\"name\":\"Im_OutputValue\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"Im_PartialDerivative__Current_Error\",\"type\":\"int256[]\"},{\"name\":\"Im_InputSum_Of_Nodes\",\"type\":\"int256[][]\"},{\"components\":[{\"name\":\"Im_Number_Of_Layer\",\"type\":\"uint256\"},{\"name\":\"Im_Nodes_In_EachLayer\",\"type\":\"uint256[]\"},{\"name\":\"Im_Bias_Of_Nodes_In_EachLayer\",\"type\":\"int256[][]\"},{\"name\":\"Im_Weights_Of_Nodes_In_EachLayer\",\"type\":\"int256[][][]\"}],\"name\":\"Im_NeuralNetWork_Object\",\"type\":\"tuple\"}],\"name\":\"Im_Backward_Propagation__BackwardPass\",\"outputs\":[{\"name\":\"PartialDerivative__of_Error_RespectTo_InputSum_Of_Nodes\",\"type\":\"int256[][]\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"Im_Input_Feature\",\"type\":\"int256[]\"},{\"components\":[{\"name\":\"Im_Number_Of_Layer\",\"type\":\"uint256\"},{\"name\":\"Im_Nodes_In_EachLayer\",\"type\":\"uint256[]\"},{\"name\":\"Im_Bias_Of_Nodes_In_EachLayer\",\"type\":\"int256[][]\"},{\"name\":\"Im_Weights_Of_Nodes_In_EachLayer\",\"type\":\"int256[][][]\"}],\"name\":\"Im_NeuralNetWork_Object\",\"type\":\"tuple\"}],\"name\":\"Im_Forward_Propagation__Prediction\",\"outputs\":[{\"name\":\"Im_OutPut_PredictionResult\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"Im_Input_Feature\",\"type\":\"int256[][]\"},{\"name\":\"Im_Input_Label\",\"type\":\"int256[]\"},{\"name\":\"Learing_Rate\",\"type\":\"int256\"},{\"name\":\"TrainingTimes\",\"type\":\"uint256\"},{\"components\":[{\"name\":\"Im_Number_Of_Layer\",\"type\":\"uint256\"},{\"name\":\"Im_Nodes_In_EachLayer\",\"type\":\"uint256[]\"},{\"name\":\"Im_Bias_Of_Nodes_In_EachLayer\",\"type\":\"int256[][]\"},{\"name\":\"Im_Weights_Of_Nodes_In_EachLayer\",\"type\":\"int256[][][]\"}],\"name\":\"Im_NeuralNetWork_Object\",\"type\":\"tuple\"}],\"name\":\"Im_Training_Function__BackwardPropagation\",\"outputs\":[{\"name\":\"Avrage_Error\",\"type\":\"int256\"},{\"name\":\"PredictionResultSet_AfterTraining\",\"type\":\"int256[]\"},{\"name\":\"Current_WeightSet_Of_Nodes_In_EachLayer\",\"type\":\"int256[][][]\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"Im_Predict_ResultSets\",\"type\":\"int256[]\"},{\"name\":\"Im_Actual_ResultSets\",\"type\":\"int256[]\"}],\"name\":\"Im_Loss_function__L2\",\"outputs\":[{\"name\":\"Im_Result_Error\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"Im_Cute_Input_Number\",\"type\":\"uint256\"}],\"name\":\"Im_StanderRandomNumber\",\"outputs\":[{\"name\":\"Im_Cute_Random_Number\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"Im_InputData\",\"type\":\"int256[]\"},{\"name\":\"Im_EachWeights\",\"type\":\"int256[]\"},{\"name\":\"Im_Bias\",\"type\":\"int256\"}],\"name\":\"Im_Sum_For_NodeInput\",\"outputs\":[{\"name\":\"TransferValue_For_ActivationFunction\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"Im_Predict_ResultSets\",\"type\":\"int256[]\"},{\"name\":\"Im_Actual_ResultSets\",\"type\":\"int256[]\"}],\"name\":\"Im_Loss_function__MSE\",\"outputs\":[{\"name\":\"Im_Result_Error\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"Im_Input\",\"type\":\"int256\"}],\"name\":\"Im_Activation_Function__Relu\",\"outputs\":[{\"name\":\"Im_Output\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"Im_Input_Feature\",\"type\":\"int256[]\"},{\"components\":[{\"name\":\"Im_Number_Of_Layer\",\"type\":\"uint256\"},{\"name\":\"Im_Nodes_In_EachLayer\",\"type\":\"uint256[]\"},{\"name\":\"Im_Bias_Of_Nodes_In_EachLayer\",\"type\":\"int256[][]\"},{\"name\":\"Im_Weights_Of_Nodes_In_EachLayer\",\"type\":\"int256[][][]\"}],\"name\":\"Im_NeuralNetWork_Object\",\"type\":\"tuple\"}],\"name\":\"Im_Predict_Function\",\"outputs\":[{\"name\":\"Im_Prediction_Result\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"Im_Current_InputData\",\"type\":\"int256[]\"},{\"components\":[{\"name\":\"Im_Number_Of_Layer\",\"type\":\"uint256\"},{\"name\":\"Im_Nodes_In_EachLayer\",\"type\":\"uint256[]\"},{\"name\":\"Im_Bias_Of_Nodes_In_EachLayer\",\"type\":\"int256[][]\"},{\"name\":\"Im_Weights_Of_Nodes_In_EachLayer\",\"type\":\"int256[][][]\"}],\"name\":\"Im_NeuralNetWork_Object\",\"type\":\"tuple\"}],\"name\":\"Im_Backward_Propagation__ForwardPass\",\"outputs\":[{\"name\":\"InputSum_Of_Nodes\",\"type\":\"int256[][]\"},{\"name\":\"Im_PartialDerivative__Of_InputSum_RespectTo_Weights\",\"type\":\"int256[][][]\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"}]","ContractName":"AI_on_BlockChain__Execution","CompilerVersion":"v0.5.4+commit.9549d8ff","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://2146f5ded74747f5fe655deb7ed841fa3fc2458604bbc8def7bc03492ae489f4"}]}