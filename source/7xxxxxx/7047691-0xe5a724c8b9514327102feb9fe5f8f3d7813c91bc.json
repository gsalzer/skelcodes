{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.23;\r\n\r\n// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  function Ownable() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    require(newOwner != address(0));\r\n    emit OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n\r\n}\r\n\r\n// File: contracts/Administrable.sol\r\n\r\n/**\r\n * @title Administrable\r\n * @dev Base contract extending Ownable with support for administration capabilities.\r\n */\r\ncontract Administrable is Ownable {\r\n\r\n    event LogAdministratorAdded(address indexed caller, address indexed administrator);\r\n    event LogAdministratorRemoved(address indexed caller, address indexed administrator);\r\n\r\n    mapping (address => bool) private administrators;\r\n\r\n    modifier onlyAdministrator() {\r\n        require(administrators[msg.sender], \"caller is not administrator\");\r\n        _;\r\n    }\r\n\r\n    constructor() internal {\r\n        administrators[msg.sender] = true;\r\n\r\n        emit LogAdministratorAdded(msg.sender, msg.sender);\r\n    }\r\n\r\n    /**\r\n     * Add a new administrator to the list.\r\n     * @param newAdministrator The administrator address to add.\r\n     */\r\n    function addAdministrator(address newAdministrator) public onlyOwner {\r\n        require(newAdministrator != address(0), \"newAdministrator is zero\");\r\n        require(!administrators[newAdministrator], \"newAdministrator is already present\");\r\n\r\n        administrators[newAdministrator] = true;\r\n\r\n        emit LogAdministratorAdded(msg.sender, newAdministrator);\r\n    }\r\n\r\n    /**\r\n     * Remove an existing administrator from the list.\r\n     * @param oldAdministrator The administrator address to remove.\r\n     */\r\n    function removeAdministrator(address oldAdministrator) public onlyOwner {\r\n        require(oldAdministrator != address(0), \"oldAdministrator is zero\");\r\n        require(administrators[oldAdministrator], \"oldAdministrator is not present\");\r\n\r\n        administrators[oldAdministrator] = false;\r\n\r\n        emit LogAdministratorRemoved(msg.sender, oldAdministrator);\r\n    }\r\n\r\n    /**\r\n     * @return true if target address has administrator privileges, false otherwise\r\n     */\r\n    function isAdministrator(address target) public view returns(bool isReallyAdministrator) {\r\n        return administrators[target];\r\n    }\r\n\r\n    /**\r\n     * Transfer ownership taking administration privileges into account.\r\n     * @param newOwner The new contract owner.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        administrators[msg.sender] = false;\r\n        emit LogAdministratorRemoved(msg.sender, msg.sender);\r\n\r\n        administrators[newOwner] = true;\r\n        emit LogAdministratorAdded(msg.sender, newOwner);\r\n\r\n        Ownable.transferOwnership(newOwner);\r\n    }\r\n}\r\n\r\n// File: contracts/TokenSale.sol\r\n\r\ncontract TokenSale {\r\n    /**\r\n    * Buy tokens for the beneficiary using paid Ether.\r\n    * @param beneficiary the beneficiary address that will receive the tokens.\r\n    */\r\n    function buyTokens(address beneficiary) public payable;\r\n}\r\n\r\n// File: contracts/WhitelistableConstraints.sol\r\n\r\n/**\r\n * @title WhitelistableConstraints\r\n * @dev Contract encapsulating the constraints applicable to a Whitelistable contract.\r\n */\r\ncontract WhitelistableConstraints {\r\n\r\n    /**\r\n     * @dev Check if whitelist with specified parameters is allowed.\r\n     * @param _maxWhitelistLength The maximum length of whitelist. Zero means no whitelist.\r\n     * @param _weiWhitelistThresholdBalance The threshold balance triggering whitelist check.\r\n     * @return true if whitelist with specified parameters is allowed, false otherwise\r\n     */\r\n    function isAllowedWhitelist(uint256 _maxWhitelistLength, uint256 _weiWhitelistThresholdBalance)\r\n        public pure returns(bool isReallyAllowedWhitelist) {\r\n        return _maxWhitelistLength > 0 || _weiWhitelistThresholdBalance > 0;\r\n    }\r\n}\r\n\r\n// File: contracts/Whitelistable.sol\r\n\r\n/**\r\n * @title Whitelistable\r\n * @dev Base contract implementing a whitelist to keep track of investors.\r\n * The construction parameters allow for both whitelisted and non-whitelisted contracts:\r\n * 1) maxWhitelistLength = 0 and whitelistThresholdBalance > 0: whitelist disabled\r\n * 2) maxWhitelistLength > 0 and whitelistThresholdBalance = 0: whitelist enabled, full whitelisting\r\n * 3) maxWhitelistLength > 0 and whitelistThresholdBalance > 0: whitelist enabled, partial whitelisting\r\n */\r\ncontract Whitelistable is WhitelistableConstraints {\r\n\r\n    event LogMaxWhitelistLengthChanged(address indexed caller, uint256 indexed maxWhitelistLength);\r\n    event LogWhitelistThresholdBalanceChanged(address indexed caller, uint256 indexed whitelistThresholdBalance);\r\n    event LogWhitelistAddressAdded(address indexed caller, address indexed subscriber);\r\n    event LogWhitelistAddressRemoved(address indexed caller, address indexed subscriber);\r\n\r\n    mapping (address => bool) public whitelist;\r\n\r\n    uint256 public whitelistLength;\r\n\r\n    uint256 public maxWhitelistLength;\r\n\r\n    uint256 public whitelistThresholdBalance;\r\n\r\n    constructor(uint256 _maxWhitelistLength, uint256 _whitelistThresholdBalance) internal {\r\n        require(isAllowedWhitelist(_maxWhitelistLength, _whitelistThresholdBalance), \"parameters not allowed\");\r\n\r\n        maxWhitelistLength = _maxWhitelistLength;\r\n        whitelistThresholdBalance = _whitelistThresholdBalance;\r\n    }\r\n\r\n    /**\r\n     * @return true if whitelist is currently enabled, false otherwise\r\n     */\r\n    function isWhitelistEnabled() public view returns(bool isReallyWhitelistEnabled) {\r\n        return maxWhitelistLength > 0;\r\n    }\r\n\r\n    /**\r\n     * @return true if subscriber is whitelisted, false otherwise\r\n     */\r\n    function isWhitelisted(address _subscriber) public view returns(bool isReallyWhitelisted) {\r\n        return whitelist[_subscriber];\r\n    }\r\n\r\n    function setMaxWhitelistLengthInternal(uint256 _maxWhitelistLength) internal {\r\n        require(isAllowedWhitelist(_maxWhitelistLength, whitelistThresholdBalance),\r\n            \"_maxWhitelistLength not allowed\");\r\n        require(_maxWhitelistLength != maxWhitelistLength, \"_maxWhitelistLength equal to current one\");\r\n\r\n        maxWhitelistLength = _maxWhitelistLength;\r\n\r\n        emit LogMaxWhitelistLengthChanged(msg.sender, maxWhitelistLength);\r\n    }\r\n\r\n    function setWhitelistThresholdBalanceInternal(uint256 _whitelistThresholdBalance) internal {\r\n        require(isAllowedWhitelist(maxWhitelistLength, _whitelistThresholdBalance),\r\n            \"_whitelistThresholdBalance not allowed\");\r\n        require(whitelistLength == 0 || _whitelistThresholdBalance > whitelistThresholdBalance,\r\n            \"_whitelistThresholdBalance not greater than current one\");\r\n\r\n        whitelistThresholdBalance = _whitelistThresholdBalance;\r\n\r\n        emit LogWhitelistThresholdBalanceChanged(msg.sender, _whitelistThresholdBalance);\r\n    }\r\n\r\n    function addToWhitelistInternal(address _subscriber) internal {\r\n        require(_subscriber != address(0), \"_subscriber is zero\");\r\n        require(!whitelist[_subscriber], \"already whitelisted\");\r\n        require(whitelistLength < maxWhitelistLength, \"max whitelist length reached\");\r\n\r\n        whitelistLength++;\r\n\r\n        whitelist[_subscriber] = true;\r\n\r\n        emit LogWhitelistAddressAdded(msg.sender, _subscriber);\r\n    }\r\n\r\n    function removeFromWhitelistInternal(address _subscriber, uint256 _balance) internal {\r\n        require(_subscriber != address(0), \"_subscriber is zero\");\r\n        require(whitelist[_subscriber], \"not whitelisted\");\r\n        require(_balance <= whitelistThresholdBalance, \"_balance greater than whitelist threshold\");\r\n\r\n        assert(whitelistLength > 0);\r\n\r\n        whitelistLength--;\r\n\r\n        whitelist[_subscriber] = false;\r\n\r\n        emit LogWhitelistAddressRemoved(msg.sender, _subscriber);\r\n    }\r\n\r\n    /**\r\n     * @param _subscriber The subscriber for which the balance check is required.\r\n     * @param _balance The balance value to check for allowance.\r\n     * @return true if the balance is allowed for the subscriber, false otherwise\r\n     */\r\n    function isAllowedBalance(address _subscriber, uint256 _balance) public view returns(bool isReallyAllowed) {\r\n        return !isWhitelistEnabled() || _balance <= whitelistThresholdBalance || whitelist[_subscriber];\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/math/SafeMath.sol\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return a / b;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC20/ERC20Basic.sol\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/179\r\n */\r\ncontract ERC20Basic {\r\n  function totalSupply() public view returns (uint256);\r\n  function balanceOf(address who) public view returns (uint256);\r\n  function transfer(address to, uint256 value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC20/ERC20.sol\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address owner, address spender) public view returns (uint256);\r\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\r\n  function approve(address spender, uint256 value) public returns (bool);\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: contracts/MultipleBidReservation.sol\r\n\r\n/**\r\n * A multiple-bid Reservation Contract (RC) for early deposit collection and manual token bid during\r\n * the Initial Coin Offering (ICO) crowdsale events.\r\n * The RC implements the following spec:\r\n * - investors allowed to simply send ethers to the RC address\r\n * - investors allowed to get refunded after ICO event if RC failed\r\n * - multiple bids using investor addresses performed by owner or authorized administator\r\n * - maximum cap on the total balance\r\n * - minimum threshold on each subscriber balance\r\n * - maximum number of subscribers\r\n * - optional whitelist with max deposit threshold for non-whitelisted subscribers\r\n * - kill switch callable by owner or authorized administator\r\n * - withdraw pattern for refunding\r\n * Just the RC owner or an authorized administator is allowed to shutdown the lifecycle halting the\r\n * RC; no bounties are provided.\r\n */\r\ncontract MultipleBidReservation is Administrable, Whitelistable {\r\n    using SafeMath for uint256;\r\n\r\n    event LogMultipleBidReservationCreated(\r\n        uint256 indexed startBlock,\r\n        uint256 indexed endBlock,\r\n        uint256 maxSubscribers,\r\n        uint256 maxCap,\r\n        uint256 minDeposit,\r\n        uint256 maxWhitelistLength,\r\n        uint256 indexed whitelistThreshold\r\n    );\r\n    event LogStartBlockChanged(uint256 indexed startBlock);\r\n    event LogEndBlockChanged(uint256 indexed endBlock);\r\n    event LogMaxCapChanged(uint256 indexed maxCap);\r\n    event LogMinDepositChanged(uint256 indexed minDeposit);\r\n    event LogMaxSubscribersChanged(uint256 indexed maxSubscribers);\r\n    event LogCrowdsaleAddressChanged(address indexed crowdsale);\r\n    event LogAbort(address indexed caller);\r\n    event LogDeposit(\r\n        address indexed subscriber,\r\n        uint256 indexed amount,\r\n        uint256 indexed balance,\r\n        uint256 raisedFunds\r\n    );\r\n    event LogBuy(address caller, uint256 indexed from, uint256 indexed to);\r\n    event LogRefund(address indexed subscriber, uint256 indexed amount, uint256 indexed raisedFunds);\r\n\r\n    // The block interval [start, end] where investments are allowed (both inclusive)\r\n    uint256 public startBlock;\r\n    uint256 public endBlock;\r\n\r\n    // RC maximum cap (expressed in wei)\r\n    uint256 public maxCap;\r\n\r\n    // RC minimum balance per subscriber (expressed in wei)\r\n    uint256 public minDeposit;\r\n\r\n    // RC maximum number of allowed subscribers\r\n    uint256 public maxSubscribers;\r\n\r\n    // Crowdsale public address\r\n    TokenSale public crowdsale;\r\n\r\n    // RC current raised balance expressed in wei\r\n    uint256 public raisedFunds;\r\n\r\n    // ERC20-compliant token issued during ICO\r\n    ERC20 public token;\r\n\r\n    // Reservation balances (expressed in wei) deposited by each subscriber\r\n    mapping (address => uint256) public balances;\r\n\r\n    // The list of subscribers in incoming order\r\n    address[] public subscribers;\r\n\r\n    // Flag indicating if reservation has been forcibly terminated\r\n    bool public aborted;\r\n\r\n    // The maximum value for whitelist threshold in wei\r\n    uint256 constant public MAX_WHITELIST_THRESHOLD = 2**256 - 1;\r\n\r\n    modifier beforeStart() {\r\n        require(block.number < startBlock, \"already started\");\r\n        _;\r\n    }\r\n\r\n    modifier beforeEnd() {\r\n        require(block.number <= endBlock, \"already ended\");\r\n        _;\r\n    }\r\n\r\n    modifier whenReserving() {\r\n        require(!aborted, \"aborted\");\r\n        _;\r\n    }\r\n\r\n    modifier whenAborted() {\r\n        require(aborted, \"not aborted\");\r\n        _;\r\n    }\r\n\r\n    constructor(\r\n        uint256 _startBlock,\r\n        uint256 _endBlock,\r\n        uint256 _maxSubscribers,\r\n        uint256 _maxCap,\r\n        uint256 _minDeposit,\r\n        uint256 _maxWhitelistLength,\r\n        uint256 _whitelistThreshold\r\n    )\r\n    Whitelistable(_maxWhitelistLength, _whitelistThreshold) public\r\n    {\r\n        require(_startBlock >= block.number, \"_startBlock < current block\");\r\n        require(_endBlock >= _startBlock, \"_endBlock < _startBlock\");\r\n        require(_maxSubscribers > 0, \"_maxSubscribers is 0\");\r\n        require(_maxCap > 0, \"_maxCap is 0\");\r\n        require(_minDeposit > 0, \"_minDeposit is 0\");\r\n\r\n        startBlock = _startBlock;\r\n        endBlock = _endBlock;\r\n        maxSubscribers = _maxSubscribers;\r\n        maxCap = _maxCap;\r\n        minDeposit = _minDeposit;\r\n\r\n        emit LogMultipleBidReservationCreated(\r\n            startBlock,\r\n            endBlock,\r\n            maxSubscribers,\r\n            maxCap,\r\n            minDeposit,\r\n            _maxWhitelistLength,\r\n            _whitelistThreshold\r\n        );\r\n    }\r\n\r\n    function hasStarted() public view returns(bool started) {\r\n        return block.number >= startBlock;\r\n    }\r\n\r\n    function hasEnded() public view returns(bool ended) {\r\n        return block.number > endBlock;\r\n    }\r\n\r\n    /**\r\n     * @return The current number of RC subscribers\r\n     */\r\n    function numSubscribers() public view returns(uint256 numberOfSubscribers) {\r\n        return subscribers.length;\r\n    }\r\n\r\n    /**\r\n     * Change the RC start block number.\r\n     * @param _startBlock The start block\r\n     */\r\n    function setStartBlock(uint256 _startBlock) external onlyOwner beforeStart whenReserving {\r\n        require(_startBlock >= block.number, \"_startBlock < current block\");\r\n        require(_startBlock <= endBlock, \"_startBlock > endBlock\");\r\n        require(_startBlock != startBlock, \"_startBlock == startBlock\");\r\n\r\n        startBlock = _startBlock;\r\n\r\n        emit LogStartBlockChanged(_startBlock);\r\n    }\r\n\r\n    /**\r\n     * Change the RC end block number.\r\n     * @param _endBlock The end block\r\n     */\r\n    function setEndBlock(uint256 _endBlock) external onlyOwner beforeEnd whenReserving {\r\n        require(_endBlock >= block.number, \"_endBlock < current block\");\r\n        require(_endBlock >= startBlock, \"_endBlock < startBlock\");\r\n        require(_endBlock != endBlock, \"_endBlock == endBlock\");\r\n\r\n        endBlock = _endBlock;\r\n\r\n        emit LogEndBlockChanged(_endBlock);\r\n    }\r\n\r\n    /**\r\n     * Change the RC maximum cap. New value shall be at least equal to raisedFunds.\r\n     * @param _maxCap The RC maximum cap, expressed in wei\r\n     */\r\n    function setMaxCap(uint256 _maxCap) external onlyOwner beforeEnd whenReserving {\r\n        require(_maxCap > 0 && _maxCap >= raisedFunds, \"invalid _maxCap\");\r\n\r\n        maxCap = _maxCap;\r\n\r\n        emit LogMaxCapChanged(maxCap);\r\n    }\r\n\r\n    /**\r\n     * Change the minimum deposit for each RC subscriber. New value shall be lower than previous.\r\n     * @param _minDeposit The minimum deposit for each RC subscriber, expressed in wei\r\n     */\r\n    function setMinDeposit(uint256 _minDeposit) external onlyOwner beforeEnd whenReserving {\r\n        require(_minDeposit > 0 && _minDeposit < minDeposit, \"_minDeposit not in (0, minDeposit)\");\r\n\r\n        minDeposit = _minDeposit;\r\n\r\n        emit LogMinDepositChanged(minDeposit);\r\n    }\r\n\r\n    /**\r\n     * Change the maximum number of accepted RC subscribers. New value shall be at least equal to the current\r\n     * number of subscribers.\r\n     * @param _maxSubscribers The maximum number of subscribers\r\n     */\r\n    function setMaxSubscribers(uint256 _maxSubscribers) external onlyOwner beforeEnd whenReserving {\r\n        require(_maxSubscribers > 0 && _maxSubscribers >= subscribers.length, \"invalid _maxSubscribers\");\r\n\r\n        maxSubscribers = _maxSubscribers;\r\n\r\n        emit LogMaxSubscribersChanged(maxSubscribers);\r\n    }\r\n\r\n    /**\r\n     * Change the ICO crowdsale address.\r\n     * @param _crowdsale The ICO crowdsale address\r\n     */\r\n    function setCrowdsaleAddress(address _crowdsale) external onlyOwner whenReserving {\r\n        require(_crowdsale != address(0), \"_crowdsale is 0\");\r\n\r\n        crowdsale = TokenSale(_crowdsale);\r\n\r\n        emit LogCrowdsaleAddressChanged(_crowdsale);\r\n    }\r\n\r\n    /**\r\n     * Change the maximum whitelist length. New value shall satisfy the #isAllowedWhitelist conditions.\r\n     * @param _maxWhitelistLength The maximum whitelist length\r\n     */\r\n    function setMaxWhitelistLength(uint256 _maxWhitelistLength) external onlyOwner beforeEnd whenReserving {\r\n        setMaxWhitelistLengthInternal(_maxWhitelistLength);\r\n    }\r\n\r\n    /**\r\n     * Change the whitelist threshold balance. New value shall satisfy the #isAllowedWhitelist conditions.\r\n     * @param _whitelistThreshold The threshold balance (in wei) above which whitelisting is required to invest\r\n     */\r\n    function setWhitelistThresholdBalance(uint256 _whitelistThreshold) external onlyOwner beforeEnd whenReserving {\r\n        setWhitelistThresholdBalanceInternal(_whitelistThreshold);\r\n    }\r\n\r\n    /**\r\n     * Add the subscriber to the whitelist.\r\n     * @param _subscriber The subscriber to add to the whitelist.\r\n     */\r\n    function addToWhitelist(address _subscriber) external onlyOwner beforeEnd whenReserving {\r\n        addToWhitelistInternal(_subscriber);\r\n    }\r\n\r\n    /**\r\n     * Removed the subscriber from the whitelist.\r\n     * @param _subscriber The subscriber to remove from the whitelist.\r\n     */\r\n    function removeFromWhitelist(address _subscriber) external onlyOwner beforeEnd whenReserving {\r\n        removeFromWhitelistInternal(_subscriber, balances[_subscriber]);\r\n    }\r\n\r\n    /**\r\n     * Abort the contract before the ICO start time. An administrator is allowed to use this 'kill switch'\r\n     * to deactivate any contract function except the investor refunding.\r\n     */\r\n    function abort() external onlyAdministrator whenReserving {\r\n        aborted = true;\r\n\r\n        emit LogAbort(msg.sender);\r\n    }\r\n\r\n    /**\r\n     * Let the caller invest its money before the ICO start time.\r\n     */\r\n    function invest() external payable whenReserving {\r\n        deposit(msg.sender, msg.value);\r\n    }\r\n\r\n    /**\r\n     * Execute a batch of multiple bids into the ICO crowdsale.\r\n     * @param _from The subscriber index, included, from which the batch starts.\r\n     * @param _to The subscriber index, excluded, to which the batch ends.\r\n     */\r\n    function buy(uint256 _from, uint256 _to) external onlyAdministrator whenReserving {\r\n        require(_from < _to, \"_from >= _to\");\r\n        require(crowdsale != address(0), \"crowdsale not set\");\r\n        require(subscribers.length > 0, \"subscribers size is 0\");\r\n        require(hasEnded(), \"not ended\");\r\n\r\n        uint to = _to > subscribers.length ? subscribers.length : _to;\r\n\r\n        for (uint256 i=_from; i<to; i++) {\r\n            address subscriber = subscribers[i];\r\n\r\n            uint256 subscriberBalance = balances[subscriber];\r\n\r\n            if (subscriberBalance > 0) {\r\n                balances[subscriber] = 0;\r\n\r\n                crowdsale.buyTokens.value(subscriberBalance)(subscriber);\r\n            }\r\n        }\r\n\r\n        emit LogBuy(msg.sender, _from, _to);\r\n    }\r\n\r\n    /**\r\n     * Refund the invested money to the caller after the RC termination.\r\n     */\r\n    function refund() external whenAborted {\r\n        // Read the calling subscriber balance once\r\n        uint256 subscriberBalance = balances[msg.sender];\r\n\r\n        // Withdraw is allowed IFF the calling subscriber has not zero balance\r\n        require(subscriberBalance > 0, \"caller balance is 0\");\r\n\r\n        // Withdraw is allowed IFF the contract has some token balance\r\n        require(raisedFunds > 0, \"token balance is 0\");\r\n\r\n        // Safely decrease the total balance\r\n        raisedFunds = raisedFunds.sub(subscriberBalance);\r\n\r\n        // Clear the subscriber balance before transfer to prevent re-entrant attacks\r\n        balances[msg.sender] = 0;\r\n\r\n        emit LogRefund(msg.sender, subscriberBalance, raisedFunds);\r\n\r\n        // Transfer the balance back to the calling subscriber or throws on error\r\n        msg.sender.transfer(subscriberBalance);\r\n    }\r\n\r\n    /**\r\n     * Allow investing by just sending money to the contract address.\r\n     */\r\n    function () external payable whenReserving {\r\n        deposit(msg.sender, msg.value);\r\n    }\r\n\r\n    /**\r\n     * Deposit the money amount for the beneficiary when RC is running.\r\n     */\r\n    function deposit(address beneficiary, uint256 amount) internal {\r\n        // Deposit is allowed IFF the RC is currently running\r\n        require(startBlock <= block.number && block.number <= endBlock, \"not open\");\r\n\r\n        uint256 newRaisedFunds = raisedFunds.add(amount);\r\n\r\n        // Deposit is allowed IFF the contract balance will not reach its maximum cap\r\n        require(newRaisedFunds <= maxCap, \"over max cap\");\r\n\r\n        uint256 currentBalance = balances[beneficiary];\r\n        uint256 finalBalance = currentBalance.add(amount);\r\n\r\n        // Deposit is allowed IFF investor deposit shall be at least equal to the minimum deposit threshold\r\n        require(finalBalance >= minDeposit, \"deposit < min deposit\");\r\n\r\n        // Balances over whitelist threshold are allowed IFF the sender is in whitelist\r\n        require(isAllowedBalance(beneficiary, finalBalance), \"balance not allowed\");\r\n\r\n        // Increase the subscriber count if sender does not have a balance yet\r\n        if (currentBalance == 0) {\r\n            // New subscribers are allowed IFF the contract has not yet the max number of subscribers\r\n            require(subscribers.length < maxSubscribers, \"max subscribers reached\");\r\n\r\n            subscribers.push(beneficiary);\r\n        }\r\n\r\n        // Add the received amount to the subscriber balance\r\n        balances[beneficiary] = finalBalance;\r\n\r\n        raisedFunds = newRaisedFunds;\r\n\r\n        emit LogDeposit(beneficiary, amount, finalBalance, newRaisedFunds);\r\n    }\r\n}\r\n\r\n// File: contracts/NokuCustomReservation.sol\r\n\r\n/**\r\n * @title NokuCustomReservation\r\n * @dev Extension of MultipleBidReservation.\r\n */\r\ncontract NokuCustomReservation is MultipleBidReservation {\r\n    event LogNokuCustomReservationCreated();\r\n\r\n    constructor(\r\n        uint256 _startBlock,\r\n        uint256 _endBlock,\r\n        uint256 _maxSubscribers,\r\n        uint256 _maxCap,\r\n        uint256 _minDeposit,\r\n        uint256 _maxWhitelistLength,\r\n        uint256 _whitelistThreshold\r\n    )\r\n    MultipleBidReservation(\r\n        _startBlock,\r\n        _endBlock,\r\n        _maxSubscribers,\r\n        _maxCap,\r\n        _minDeposit,\r\n        _maxWhitelistLength,\r\n        _whitelistThreshold\r\n    )\r\n    public {\r\n        emit LogNokuCustomReservationCreated();\r\n    }\r\n}\r\n\r\n// File: contracts/NokuPricingPlan.sol\r\n\r\n/**\r\n* @dev The NokuPricingPlan contract defines the responsibilities of a Noku pricing plan.\r\n*/\r\ncontract NokuPricingPlan {\r\n    /**\r\n    * @dev Pay the fee for the service identified by the specified name.\r\n    * The fee amount shall already be approved by the client.\r\n    * @param serviceName The name of the target service.\r\n    * @param multiplier The multiplier of the base service fee to apply.\r\n    * @param client The client of the target service.\r\n    * @return true if fee has been paid.\r\n    */\r\n    function payFee(bytes32 serviceName, uint256 multiplier, address client) public returns(bool paid);\r\n\r\n    /**\r\n    * @dev Get the usage fee for the service identified by the specified name.\r\n    * The returned fee amount shall be approved before using #payFee method.\r\n    * @param serviceName The name of the target service.\r\n    * @param multiplier The multiplier of the base service fee to apply.\r\n    * @return The amount to approve before really paying such fee.\r\n    */\r\n    function usageFee(bytes32 serviceName, uint256 multiplier) public constant returns(uint fee);\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/AddressUtils.sol\r\n\r\n/**\r\n * Utility library of inline functions on addresses\r\n */\r\nlibrary AddressUtils {\r\n\r\n  /**\r\n   * Returns whether the target address is a contract\r\n   * @dev This function will return false if invoked during the constructor of a contract,\r\n   *  as the code is not actually created until after the constructor finishes.\r\n   * @param addr address to check\r\n   * @return whether the target address is a contract\r\n   */\r\n  function isContract(address addr) internal view returns (bool) {\r\n    uint256 size;\r\n    // XXX Currently there is no better way to check if there is a contract in an address\r\n    // than to check the size of the code at that address.\r\n    // See https://ethereum.stackexchange.com/a/14016/36603\r\n    // for more details about how this works.\r\n    // TODO Check this again before the Serenity release, because all addresses will be\r\n    // contracts then.\r\n    assembly { size := extcodesize(addr) }  // solium-disable-line security/no-inline-assembly\r\n    return size > 0;\r\n  }\r\n\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/lifecycle/Pausable.sol\r\n\r\n/**\r\n * @title Pausable\r\n * @dev Base contract which allows children to implement an emergency stop mechanism.\r\n */\r\ncontract Pausable is Ownable {\r\n  event Pause();\r\n  event Unpause();\r\n\r\n  bool public paused = false;\r\n\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is not paused.\r\n   */\r\n  modifier whenNotPaused() {\r\n    require(!paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is paused.\r\n   */\r\n  modifier whenPaused() {\r\n    require(paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to pause, triggers stopped state\r\n   */\r\n  function pause() onlyOwner whenNotPaused public {\r\n    paused = true;\r\n    emit Pause();\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to unpause, returns to normal state\r\n   */\r\n  function unpause() onlyOwner whenPaused public {\r\n    paused = false;\r\n    emit Unpause();\r\n  }\r\n}\r\n\r\n// File: contracts/NokuCustomService.sol\r\n\r\ncontract NokuCustomService is Pausable {\r\n    using AddressUtils for address;\r\n\r\n    event LogPricingPlanChanged(address indexed caller, address indexed pricingPlan);\r\n\r\n    // The pricing plan determining the fee to be paid in NOKU tokens by customers\r\n    NokuPricingPlan public pricingPlan;\r\n\r\n    constructor(address _pricingPlan) internal {\r\n        require(_pricingPlan.isContract(), \"_pricingPlan is not contract\");\r\n\r\n        pricingPlan = NokuPricingPlan(_pricingPlan);\r\n    }\r\n\r\n    function setPricingPlan(address _pricingPlan) public onlyOwner {\r\n        require(_pricingPlan.isContract(), \"_pricingPlan is not contract\");\r\n        require(NokuPricingPlan(_pricingPlan) != pricingPlan, \"_pricingPlan equal to current\");\r\n        \r\n        pricingPlan = NokuPricingPlan(_pricingPlan);\r\n\r\n        emit LogPricingPlanChanged(msg.sender, _pricingPlan);\r\n    }\r\n}\r\n\r\n// File: contracts/NokuCustomReservationService.sol\r\n\r\n/**\r\n * @title NokuCustomReservationService\r\n * @dev Extension of NokuCustomService adding the fee payment in NOKU tokens.\r\n */\r\ncontract NokuCustomReservationService is NokuCustomService {\r\n    event LogNokuCustomReservationServiceCreated(address indexed caller);\r\n\r\n    bytes32 public constant SERVICE_NAME = \"NokuCustomERC20.reservation\";\r\n    uint256 public constant CREATE_AMOUNT = 1 * 10**18;\r\n\r\n    constructor(address _pricingPlan) NokuCustomService(_pricingPlan) public {\r\n        emit LogNokuCustomReservationServiceCreated(msg.sender);\r\n    }\r\n\r\n    function createCustomReservation(\r\n        uint256 _startBlock,\r\n        uint256 _endBlock,\r\n        uint256 _maxSubscribers,\r\n        uint256 _maxCap,\r\n        uint256 _minDeposit,\r\n        uint256 _maxWhitelistLength,\r\n        uint256 _whitelistThreshold\r\n    )\r\n    public returns(NokuCustomReservation customReservation)\r\n    {\r\n        customReservation = new NokuCustomReservation(\r\n            _startBlock,\r\n            _endBlock,\r\n            _maxSubscribers,\r\n            _maxCap,\r\n            _minDeposit,\r\n            _maxWhitelistLength,\r\n            _whitelistThreshold\r\n        );\r\n\r\n        // Transfer NokuCustomReservation ownership to the client\r\n        customReservation.transferOwnership(msg.sender);\r\n\r\n        require(pricingPlan.payFee(SERVICE_NAME, CREATE_AMOUNT, msg.sender), \"fee payment failed\");\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_pricingPlan\",\"type\":\"address\"}],\"name\":\"setPricingPlan\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pricingPlan\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_startBlock\",\"type\":\"uint256\"},{\"name\":\"_endBlock\",\"type\":\"uint256\"},{\"name\":\"_maxSubscribers\",\"type\":\"uint256\"},{\"name\":\"_maxCap\",\"type\":\"uint256\"},{\"name\":\"_minDeposit\",\"type\":\"uint256\"},{\"name\":\"_maxWhitelistLength\",\"type\":\"uint256\"},{\"name\":\"_whitelistThreshold\",\"type\":\"uint256\"}],\"name\":\"createCustomReservation\",\"outputs\":[{\"name\":\"customReservation\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"SERVICE_NAME\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CREATE_AMOUNT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_pricingPlan\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"caller\",\"type\":\"address\"}],\"name\":\"LogNokuCustomReservationServiceCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"pricingPlan\",\"type\":\"address\"}],\"name\":\"LogPricingPlanChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"NokuCustomReservationService","CompilerVersion":"v0.4.23+commit.124ca40d","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000749aba9e082ccb185d1ef88fa514339e3c3368d3","Library":"","SwarmSource":"bzzr://efdc3391cc5a7b04d68c077bf328a0293dff40a1c2a2ad3eafccbb8df288ffae"}]}