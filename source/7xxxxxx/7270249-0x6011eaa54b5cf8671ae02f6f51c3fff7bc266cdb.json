{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity \r\n\r\n\r\n\r\n\r\n^0.5.0;\r\n\r\ncontract Lockbox {\r\n\r\n    event PayOut(\r\n        address indexed to,\r\n        uint indexed nonce,\r\n        uint256 amount\r\n    );\r\n\r\n    uint constant UINT_MAX = ~uint(0);\r\n\r\n    address public owner; // = msg.sender;\r\n    address payable public returnFundsAddress;\r\n\r\n    mapping(uint256 => bool) usedNonces;\r\n\r\n    constructor(address payable returnFunds) public payable {\r\n        owner = msg.sender;\r\n        returnFundsAddress = returnFunds;\r\n    }\r\n\r\n    // @notice Will receive any eth sent to the contract\r\n    function () external payable {\r\n    }\r\n\r\n    function getOwner() public view returns (address) {\r\n        return owner;\r\n    }\r\n\r\n    function claimPayment(uint256 amount, uint nonce, bytes memory sig) public {\r\n        require(!usedNonces[nonce], \"Reused nonce\");\r\n\r\n        // This recreates the message that was signed on the client.\r\n        bytes32 message = prefixed(keccak256(abi.encodePacked(amount, nonce, this)));\r\n\r\n        //return recoverSigner(message, sig);\r\n        require(recoverSigner(message, sig) == owner, \"Non-owner signature\");\r\n        \r\n        if (nonce == 0) {\r\n            require(amount == 1, \"Req. 1 WEI amt for 0 nonce\");\r\n        } else {\r\n            usedNonces[nonce] = true;\r\n        }\r\n\r\n        emit PayOut(msg.sender, nonce, amount);\r\n        msg.sender.transfer(amount);\r\n    }\r\n\r\n    function returnFunds(uint256 amount, uint[] memory nonces) public {\r\n        require(msg.sender == owner, \"Non-owner sender\");\r\n\r\n        for (uint i = 0; i < nonces.length; i++){\r\n            if (nonces[i] != 0)\r\n                usedNonces[nonces[i]] = true;\r\n        }\r\n\r\n        emit PayOut(returnFundsAddress, UINT_MAX, amount);\r\n        returnFundsAddress.transfer(amount);\r\n    }\r\n\r\n    // Destroy contract and reclaim leftover funds.\r\n    function kill() public {\r\n        require(msg.sender == owner, \"Non-owner sender\");\r\n        selfdestruct(returnFundsAddress);\r\n    }\r\n\r\n    // Signature methods\r\n    function splitSignature(bytes memory sig)\r\n        internal\r\n        pure\r\n        returns (uint8, bytes32, bytes32)\r\n    {\r\n        require(sig.length == 65, \"Malformed sig\");\r\n\r\n        bytes32 r;\r\n        bytes32 s;\r\n        uint8 v;\r\n\r\n        assembly {\r\n            // first 32 bytes, after the length prefix\r\n            r := mload(add(sig, 32))\r\n            // second 32 bytes\r\n            s := mload(add(sig, 64))\r\n            // final byte (first byte of the next 32 bytes)\r\n            v := byte(0, mload(add(sig, 96)))\r\n        }\r\n\r\n        // support both versions of `eth_sign` responses\r\n        if (v < 27) \r\n            v += 27;\r\n\r\n        return (v, r, s);\r\n    }\r\n\r\n    function recoverSigner(bytes32 message, bytes memory sig)\r\n        internal\r\n        pure\r\n        returns (address)\r\n    {\r\n        uint8 v;\r\n        bytes32 r;\r\n        bytes32 s;\r\n\r\n        (v, r, s) = splitSignature(sig);\r\n\r\n        return ecrecover(message, v, r, s);\r\n    }\r\n\r\n    // Builds a prefixed hash to mimic the behavior of eth_sign.\r\n    function prefixed(bytes32 hash) internal pure returns (bytes32) {\r\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"nonces\",\"type\":\"uint256[]\"}],\"name\":\"returnFunds\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"kill\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"returnFundsAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"nonce\",\"type\":\"uint256\"},{\"name\":\"sig\",\"type\":\"bytes\"}],\"name\":\"claimPayment\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"returnFunds\",\"type\":\"address\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"nonce\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"PayOut\",\"type\":\"event\"}]","ContractName":"Lockbox","CompilerVersion":"v0.5.4+commit.9549d8ff","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000fa8e3920daf271dab92be9b87d9998ddd94fef08","Library":"","SwarmSource":"bzzr://00ebd7898ba83c604d2e5c828ae3fe0966ac590588e2f5a6c4e48a1b1514638d"}]}