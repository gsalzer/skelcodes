{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.5.1;\r\n\r\n/**\r\n* @dev Base contract for teams\r\n*/\r\ncontract Team {\r\n    using SafeMath for uint256;\r\n\r\n    //DEEX fund address\r\n    address payable public DEEXFund = 0xA2A3aD8319D24f4620Fbe06D2bC57c045ECF0932;\r\n\r\n    JackPot public JPContract;\r\n    DEEX public DEEXContract;\r\n\r\n    /**\r\n    * @dev Payable function. 10% will send to DEEX fund and 90% will send to JackPot contract.\r\n    * Also setting info about player.\r\n    */\r\n    function () external payable {\r\n        require(JPContract.getState() && msg.value >= 0.05 ether);\r\n\r\n        JPContract.setInfo(msg.sender, msg.value.mul(90).div(100));\r\n\r\n        DEEXFund.transfer(msg.value.mul(10).div(100));\r\n\r\n        address(JPContract).transfer(msg.value.mul(90).div(100));\r\n    }\r\n}\r\n\r\n/*\r\n* @dev Dragons contract. To play game with Dragons send ETH to this contract\r\n*/\r\ncontract Dragons is Team {\r\n\r\n    /*\r\n    * @dev Approving JackPot contract for spending token from Dragons contract.\r\n    * Also setting Dragons address in JackPot contract\r\n    */\r\n    constructor(address payable _jackPotAddress, address payable _DEEXAddress) public {\r\n        JPContract = JackPot(_jackPotAddress);\r\n        JPContract.setDragonsAddress(address(this));\r\n        DEEXContract = DEEX(_DEEXAddress);\r\n        DEEXContract.approve(_jackPotAddress, 9999999999999999999000000000000000000);\r\n    }\r\n}\r\n\r\n/*\r\n* @dev Hamsters contract. To play game with Hamsters send ETH to this contract\r\n*/\r\ncontract Hamsters is Team {\r\n\r\n    /*\r\n    * @dev Approving JackPot contract for spending token from Hamsters contract.\r\n    * Also setting Hamsters address in JackPot contract\r\n    */\r\n    constructor(address payable _jackPotAddress, address payable _DEEXAddress) public {\r\n        JPContract = JackPot(_jackPotAddress);\r\n        JPContract.setHamstersAddress(address(this));\r\n        DEEXContract = DEEX(_DEEXAddress);\r\n        DEEXContract.approve(_jackPotAddress, 9999999999999999999000000000000000000);\r\n    }\r\n}\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that revert on error. Latest version on 05.01.2019\r\n */\r\nlibrary SafeMath {\r\n    int256 constant private INT256_MIN = -2**255;\r\n\r\n    /**\r\n    * @dev Multiplies two unsigned integers, reverts on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Multiplies two signed integers, reverts on overflow.\r\n    */\r\n    function mul(int256 a, int256 b) internal pure returns (int256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        require(!(a == -1 && b == INT256_MIN)); // This is the only case of overflow not detected by the check below\r\n\r\n        int256 c = a * b;\r\n        require(c / a == b);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two signed integers truncating the quotient, reverts on division by zero.\r\n    */\r\n    function div(int256 a, int256 b) internal pure returns (int256) {\r\n        require(b != 0); // Solidity only automatically asserts when dividing by 0\r\n        require(!(b == -1 && a == INT256_MIN)); // This is the only case of overflow\r\n\r\n        int256 c = a / b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two signed integers, reverts on overflow.\r\n    */\r\n    function sub(int256 a, int256 b) internal pure returns (int256) {\r\n        int256 c = a - b;\r\n        require((b >= 0 && c <= a) || (b < 0 && c > a));\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two unsigned integers, reverts on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two signed integers, reverts on overflow.\r\n    */\r\n    function add(int256 a, int256 b) internal pure returns (int256) {\r\n        int256 c = a + b;\r\n        require((b >= 0 && c >= a) || (b < 0 && c < a));\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\r\n    * reverts when dividing by zero.\r\n    */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n/*\r\n* @title JackPot\r\n* @dev Jackpot contract which contained all ETH from Dragons and Hamsters teams.\r\n* When time in blockchain will be grater then current deadline or last deadline need call getWinner function\r\n* then participants able get prizes.\r\n*\r\n* Last participant(last hero) win 10% from all bank\r\n*\r\n* - To get prize send 0 ETH to this contract\r\n*/\r\ncontract JackPot {\r\n\r\n    using SafeMath for uint256;\r\n\r\n    mapping (address => uint256) public depositDragons;\r\n    mapping (address => uint256) public depositHamsters;\r\n    uint256 public currentDeadline;\r\n    uint256 public lastDeadline = 1551978000; //last deadline for game\r\n    uint256 public countOfDragons;\r\n    uint256 public countOfHamsters;\r\n    uint256 public totalSupplyOfHamsters;\r\n    uint256 public totalSupplyOfDragons;\r\n    uint256 public totalDEEXSupplyOfHamsters;\r\n    uint256 public totalDEEXSupplyOfDragons;\r\n    uint256 public probabilityOfHamsters;\r\n    uint256 public probabilityOfDragons;\r\n    address public lastHero;\r\n    address public lastHeroHistory;\r\n    uint256 public jackPot;\r\n    uint256 public winner;\r\n    bool public finished = false;\r\n\r\n    Dragons public DragonsContract;\r\n    Hamsters public HamstersContract;\r\n    DEEX public DEEXContract;\r\n\r\n    /*\r\n    * @dev Constructor create first deadline\r\n    */\r\n    constructor() public {\r\n        currentDeadline = block.timestamp + 60 * 60 * 24 * 30 ; //days for first deadline\r\n    }\r\n\r\n    /**\r\n    * @dev Setter the DEEX Token contract address. Address can be set at once.\r\n    * @param _DEEXAddress Address of the DEEX Token contract\r\n    */\r\n    function setDEEXAddress(address payable _DEEXAddress) public {\r\n        require(address(DEEXContract) == address(0x0));\r\n        DEEXContract = DEEX(_DEEXAddress);\r\n    }\r\n\r\n    /**\r\n    * @dev Setter the Dragons contract address. Address can be set at once.\r\n    * @param _dragonsAddress Address of the Dragons contract\r\n    */\r\n    function setDragonsAddress(address payable _dragonsAddress) external {\r\n        require(address(DragonsContract) == address(0x0));\r\n        DragonsContract = Dragons(_dragonsAddress);\r\n    }\r\n\r\n    /**\r\n    * @dev Setter the Hamsters contract address. Address can be set at once.\r\n    * @param _hamstersAddress Address of the Hamsters contract\r\n    */\r\n    function setHamstersAddress(address payable _hamstersAddress) external {\r\n        require(address(HamstersContract) == address(0x0));\r\n        HamstersContract = Hamsters(_hamstersAddress);\r\n    }\r\n\r\n    /**\r\n    * @dev Getting time from blockchain\r\n    */\r\n    function getNow() view public returns(uint){\r\n        return block.timestamp;\r\n    }\r\n\r\n    /**\r\n    * @dev Getting state of game. True - game continue, False - game stopped\r\n    */\r\n    function getState() view public returns(bool) {\r\n        if (block.timestamp > currentDeadline) {\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev Setting info about participant from Dragons or Hamsters contract\r\n    * @param _lastHero Address of participant\r\n    * @param _deposit Amount of deposit\r\n    */\r\n    function setInfo(address _lastHero, uint256 _deposit) public {\r\n        require(address(DragonsContract) == msg.sender || address(HamstersContract) == msg.sender);\r\n\r\n        if (address(DragonsContract) == msg.sender) {\r\n            require(depositHamsters[_lastHero] == 0, \"You are already in hamsters team\");\r\n            if (depositDragons[_lastHero] == 0)\r\n                countOfDragons++;\r\n            totalSupplyOfDragons = totalSupplyOfDragons.add(_deposit.mul(90).div(100));\r\n            depositDragons[_lastHero] = depositDragons[_lastHero].add(_deposit.mul(90).div(100));\r\n        }\r\n\r\n        if (address(HamstersContract) == msg.sender) {\r\n            require(depositDragons[_lastHero] == 0, \"You are already in dragons team\");\r\n            if (depositHamsters[_lastHero] == 0)\r\n                countOfHamsters++;\r\n            totalSupplyOfHamsters = totalSupplyOfHamsters.add(_deposit.mul(90).div(100));\r\n            depositHamsters[_lastHero] = depositHamsters[_lastHero].add(_deposit.mul(90).div(100));\r\n        }\r\n\r\n        lastHero = _lastHero;\r\n\r\n        if (currentDeadline.add(120) <= lastDeadline) {\r\n            currentDeadline = currentDeadline.add(120);\r\n        } else {\r\n            currentDeadline = lastDeadline;\r\n        }\r\n\r\n        jackPot = (address(this).balance.add(_deposit)).mul(10).div(100);\r\n\r\n        calculateProbability();\r\n    }\r\n\r\n    /**\r\n    * @dev Calculation probability for team's win\r\n    */\r\n    function calculateProbability() public {\r\n        require(winner == 0 && getState());\r\n\r\n        totalDEEXSupplyOfHamsters = DEEXContract.balanceOf(address(HamstersContract));\r\n        totalDEEXSupplyOfDragons = DEEXContract.balanceOf(address(DragonsContract));\r\n        uint256 percent = (totalSupplyOfHamsters.add(totalSupplyOfDragons)).div(100);\r\n\r\n        if (totalDEEXSupplyOfHamsters < 1) {\r\n            totalDEEXSupplyOfHamsters = 0;\r\n        }\r\n\r\n        if (totalDEEXSupplyOfDragons < 1) {\r\n            totalDEEXSupplyOfDragons = 0;\r\n        }\r\n\r\n        if (totalDEEXSupplyOfHamsters <= totalDEEXSupplyOfDragons) {\r\n            uint256 difference = (totalDEEXSupplyOfDragons.sub(totalDEEXSupplyOfHamsters)).mul(100);\r\n            probabilityOfDragons = totalSupplyOfDragons.mul(100).div(percent).add(difference);\r\n\r\n            if (probabilityOfDragons > 8000) {\r\n                probabilityOfDragons = 8000;\r\n            }\r\n            if (probabilityOfDragons < 2000) {\r\n                probabilityOfDragons = 2000;\r\n            }\r\n            probabilityOfHamsters = 10000 - probabilityOfDragons;\r\n        } else {\r\n            uint256 difference = (totalDEEXSupplyOfHamsters.sub(totalDEEXSupplyOfDragons)).mul(100);\r\n\r\n            probabilityOfHamsters = totalSupplyOfHamsters.mul(100).div(percent).add(difference);\r\n\r\n            if (probabilityOfHamsters > 8000) {\r\n                probabilityOfHamsters = 8000;\r\n            }\r\n            if (probabilityOfHamsters < 2000) {\r\n                probabilityOfHamsters = 2000;\r\n            }\r\n            probabilityOfDragons = 10000 - probabilityOfHamsters;\r\n        }\r\n\r\n        totalDEEXSupplyOfHamsters = DEEXContract.balanceOf(address(HamstersContract));\r\n        totalDEEXSupplyOfDragons = DEEXContract.balanceOf(address(DragonsContract));\r\n    }\r\n\r\n    /**\r\n    * @dev Getting winner team\r\n    */\r\n    function getWinners() public {\r\n        require(winner == 0 && !getState());\r\n\r\n        uint256 seed1 = address(this).balance;\r\n        uint256 seed2 = totalSupplyOfHamsters;\r\n        uint256 seed3 = totalSupplyOfDragons;\r\n        uint256 seed4 = totalDEEXSupplyOfHamsters;\r\n        uint256 seed5 = totalDEEXSupplyOfHamsters;\r\n        uint256 seed6 = block.difficulty;\r\n        uint256 seed7 = block.timestamp;\r\n\r\n        bytes32 randomHash = keccak256(abi.encodePacked(seed1, seed2, seed3, seed4, seed5, seed6, seed7));\r\n        uint randomNumber = uint(randomHash);\r\n\r\n        if (randomNumber == 0){\r\n            randomNumber = 1;\r\n        }\r\n\r\n        uint winningNumber = randomNumber % 10000;\r\n\r\n        if (1 <= winningNumber && winningNumber <= probabilityOfDragons){\r\n            winner = 1;\r\n        }\r\n\r\n        if (probabilityOfDragons < winningNumber && winningNumber <= 10000){\r\n            winner = 2;\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Payable function for take prize\r\n    */\r\n    function () external payable {\r\n        if (msg.value == 0 &&  !getState() && winner > 0){\r\n            require(depositDragons[msg.sender] > 0 || depositHamsters[msg.sender] > 0);\r\n\r\n            uint payout = 0;\r\n            uint payoutDEEX = 0;\r\n\r\n            if (winner == 1 && depositDragons[msg.sender] > 0) {\r\n                payout = calculateETHPrize(msg.sender);\r\n            }\r\n            if (winner == 2 && depositHamsters[msg.sender] > 0) {\r\n                payout = calculateETHPrize(msg.sender);\r\n            }\r\n\r\n            if (payout > 0) {\r\n                depositDragons[msg.sender] = 0;\r\n                depositHamsters[msg.sender] = 0;\r\n                msg.sender.transfer(payout);\r\n            }\r\n\r\n            if ((winner == 1 && depositDragons[msg.sender] == 0) || (winner == 2 && depositHamsters[msg.sender] == 0)) {\r\n                payoutDEEX = calculateDEEXPrize(msg.sender);\r\n                if (DEEXContract.balanceOf(address(HamstersContract)) > 0)\r\n                    DEEXContract.transferFrom(\r\n                        address(HamstersContract),\r\n                        address(this),\r\n                        DEEXContract.balanceOf(address(HamstersContract))\r\n                    );\r\n                if (DEEXContract.balanceOf(address(DragonsContract)) > 0)\r\n                    DEEXContract.transferFrom(\r\n                        address(DragonsContract),\r\n                        address(this),\r\n                        DEEXContract.balanceOf(address(DragonsContract))\r\n                    );\r\n                if (payoutDEEX > 0){\r\n                    DEEXContract.transfer(msg.sender, payoutDEEX);\r\n                }\r\n            }\r\n\r\n            if (msg.sender == lastHero) {\r\n                lastHeroHistory = lastHero;\r\n                lastHero = address(0x0);\r\n                msg.sender.transfer(jackPot);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Getting ETH prize of participant\r\n    * @param participant Address of participant\r\n    */\r\n    function calculateETHPrize(address participant) public view returns(uint) {\r\n        uint payout = 0;\r\n\r\n        uint256 totalSupply = totalSupplyOfDragons.add(totalSupplyOfHamsters);\r\n        if (totalSupply > 0) {\r\n            if (depositDragons[participant] > 0) {\r\n                payout = totalSupply.mul(depositDragons[participant]).div(totalSupplyOfDragons);\r\n            }\r\n\r\n            if (depositHamsters[participant] > 0) {\r\n                payout = totalSupply.mul(depositHamsters[participant]).div(totalSupplyOfHamsters);\r\n            }\r\n        }\r\n        return payout;\r\n    }\r\n\r\n    /**\r\n    * @dev Getting DEEX Token prize of participant\r\n    * @param participant Address of participant\r\n    */\r\n    function calculateDEEXPrize(address participant) public view returns(uint) {\r\n        uint payout = 0;\r\n\r\n        if (totalDEEXSupplyOfDragons.add(totalDEEXSupplyOfHamsters) > 0){\r\n            uint totalSupply = (totalDEEXSupplyOfDragons.add(totalDEEXSupplyOfHamsters)).mul(80).div(100);\r\n\r\n            if (depositDragons[participant] > 0) {\r\n                payout = totalSupply.mul(depositDragons[participant]).div(totalSupplyOfDragons);\r\n            }\r\n\r\n            if (depositHamsters[participant] > 0) {\r\n                payout = totalSupply.mul(depositHamsters[participant]).div(totalSupplyOfHamsters);\r\n            }\r\n\r\n            return payout;\r\n        }\r\n        return payout;\r\n    }\r\n}\r\n\r\n/*\r\n*  deex.exchange pre-ICO tokens smart contract\r\n*  implements [ERC-20 Token Standard](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md)\r\n*\r\n*  Style\r\n*  1) before start coding, run Python and type 'import this' in Python console.\r\n*  2) we avoid using inheritance (contract B is A) as it makes code less clear for observer\r\n*  (\"Flat is better than nested\", \"Readability counts\")\r\n*  3) we avoid using -= ; =- ; +=; =+\r\n*  see: https://github.com/ether-camp/virtual-accelerator/issues/8\r\n*  https://www.ethnews.com/ethercamps-hkg-token-has-a-bug-and-needs-to-be-reissued\r\n*  4) always explicitly mark variables and functions visibility (\"Explicit is better than implicit\")\r\n*  5) every function except constructor should trigger at leas one event.\r\n*  6) smart contracts have to be audited and reviewed, comment your code.\r\n*\r\n*  Code is published on https://github.com/thedeex/thedeex.github.io\r\n*/\r\n\r\n\r\n/* \"Interfaces\" */\r\n\r\n//  this is expected from another contracts\r\n//  if it wants to spend tokens of behalf of the token owner in our contract\r\n//  this can be used in many situations, for example to convert pre-ICO tokens to ICO tokens\r\n//  see 'approveAndCall' function\r\ncontract allowanceRecipient {\r\n    function receiveApproval(address _from, uint256 _value, address _inContract, bytes memory _extraData) public returns (bool success);\r\n}\r\n\r\n\r\n// see:\r\n// https://github.com/ethereum/EIPs/issues/677\r\ncontract tokenRecipient {\r\n    function tokenFallback(address _from, uint256 _value, bytes memory _extraData) public returns (bool success);\r\n}\r\n\r\n\r\ncontract DEEX {\r\n\r\n    // ver. 2.0\r\n\r\n    /* ---------- Variables */\r\n\r\n    /* --- ERC-20 variables */\r\n\r\n    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md#name\r\n    // function name() constant returns (string name)\r\n    string public name = \"deex\";\r\n\r\n    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md#symbol\r\n    // function symbol() constant returns (string symbol)\r\n    string public symbol = \"deex\";\r\n\r\n    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md#decimals\r\n    // function decimals() constant returns (uint8 decimals)\r\n    uint8 public decimals = 0;\r\n\r\n    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md#totalsupply\r\n    // function totalSupply() constant returns (uint256 totalSupply)\r\n    // we start with zero and will create tokens as SC receives ETH\r\n    uint256 public totalSupply;\r\n\r\n    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md#balanceof\r\n    // function balanceOf(address _owner) constant returns (uint256 balance)\r\n    mapping (address => uint256) public balanceOf;\r\n\r\n    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md#allowance\r\n    // function allowance(address _owner, address _spender) constant returns (uint256 remaining)\r\n    mapping (address => mapping (address => uint256)) public allowance;\r\n\r\n    /* ----- For tokens sale */\r\n\r\n    uint256 public salesCounter = 0;\r\n\r\n    uint256 public maxSalesAllowed;\r\n\r\n    bool private transfersBetweenSalesAllowed;\r\n\r\n    // initial value should be changed by the owner\r\n    uint256 public tokenPriceInWei = 0;\r\n\r\n    uint256 public saleStartUnixTime = 0; // block.timestamp\r\n    uint256 public saleEndUnixTime = 0;  // block.timestamp\r\n\r\n    /* --- administrative */\r\n    address public owner;\r\n\r\n    // account that can set prices\r\n    address public priceSetter;\r\n\r\n    // 0 - not set\r\n    uint256 private priceMaxWei = 0;\r\n    // 0 - not set\r\n    uint256 private priceMinWei = 0;\r\n\r\n    // accounts holding tokens for for the team, for advisers and for the bounty campaign\r\n    mapping (address => bool) public isPreferredTokensAccount;\r\n\r\n    bool public contractInitialized = false;\r\n\r\n\r\n    /* ---------- Constructor */\r\n    // do not forget about:\r\n    // https://medium.com/@codetractio/a-look-into-paritys-multisig-wallet-bug-affecting-100-million-in-ether-and-tokens-356f5ba6e90a\r\n    constructor () public {\r\n        owner = msg.sender;\r\n\r\n        // for testNet can be more than 2\r\n        // --------------------------------2------------------------------------------------------change  in production!\r\n        maxSalesAllowed = 2;\r\n        //\r\n        transfersBetweenSalesAllowed = true;\r\n    }\r\n\r\n\r\n    function initContract(address team, address advisers, address bounty) public onlyBy(owner) returns (bool){\r\n\r\n        require(contractInitialized == false);\r\n        contractInitialized = true;\r\n\r\n        priceSetter = msg.sender;\r\n\r\n        totalSupply = 100000000;\r\n\r\n        // tokens for sale go SC own account\r\n        balanceOf[address(this)] = 75000000;\r\n\r\n        // for the team\r\n        balanceOf[team] = balanceOf[team] + 15000000;\r\n        isPreferredTokensAccount[team] = true;\r\n\r\n        // for advisers\r\n        balanceOf[advisers] = balanceOf[advisers] + 7000000;\r\n        isPreferredTokensAccount[advisers] = true;\r\n\r\n        // for the bounty campaign\r\n        balanceOf[bounty] = balanceOf[bounty] + 3000000;\r\n        isPreferredTokensAccount[bounty] = true;\r\n\r\n    }\r\n\r\n    /* ---------- Events */\r\n\r\n    /* --- ERC-20 events */\r\n    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md#events\r\n\r\n    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md#transfer-1\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md#approval\r\n    event Approval(address indexed _owner, address indexed spender, uint256 value);\r\n\r\n    /* --- Administrative events:  */\r\n    event OwnerChanged(address indexed oldOwner, address indexed newOwner);\r\n\r\n    /* ---- Tokens creation and sale events  */\r\n\r\n    event PriceChanged(uint256 indexed newTokenPriceInWei);\r\n\r\n    event SaleStarted(uint256 startUnixTime, uint256 endUnixTime, uint256 indexed saleNumber);\r\n\r\n    event NewTokensSold(uint256 numberOfTokens, address indexed purchasedBy, uint256 indexed priceInWei);\r\n\r\n    event Withdrawal(address indexed to, uint sumInWei);\r\n\r\n    /* --- Interaction with other contracts events  */\r\n    event DataSentToAnotherContract(address indexed _from, address indexed _toContract, bytes _extraData);\r\n\r\n    /* ---------- Functions */\r\n\r\n    /* --- Modifiers  */\r\n    modifier onlyBy(address _account){\r\n        require(msg.sender == _account);\r\n\r\n        _;\r\n    }\r\n\r\n    /* --- ERC-20 Functions */\r\n    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md#methods\r\n\r\n    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md#transfer\r\n    function transfer(address _to, uint256 _value) public returns (bool){\r\n        return transferFrom(msg.sender, _to, _value);\r\n    }\r\n\r\n    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md#transferfrom\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool){\r\n\r\n        // transfers are possible only after sale is finished\r\n        // except for manager and preferred accounts\r\n\r\n        bool saleFinished = saleIsFinished();\r\n        require(saleFinished || msg.sender == owner || isPreferredTokensAccount[msg.sender]);\r\n\r\n        // transfers can be forbidden until final ICO is finished\r\n        // except for manager and preferred accounts\r\n        require(transfersBetweenSalesAllowed || salesCounter == maxSalesAllowed || msg.sender == owner || isPreferredTokensAccount[msg.sender]);\r\n\r\n        // Transfers of 0 values MUST be treated as normal transfers and fire the Transfer event (ERC-20)\r\n        require(_value >= 0);\r\n\r\n        // The function SHOULD throw unless the _from account has deliberately authorized the sender of the message via some mechanism\r\n        require(msg.sender == _from || _value <= allowance[_from][msg.sender]);\r\n\r\n        // check if _from account have required amount\r\n        require(_value <= balanceOf[_from]);\r\n\r\n        // Subtract from the sender\r\n        balanceOf[_from] = balanceOf[_from] - _value;\r\n        //\r\n        // Add the same to the recipient\r\n        balanceOf[_to] = balanceOf[_to] + _value;\r\n\r\n        // If allowance used, change allowances correspondingly\r\n        if (_from != msg.sender) {\r\n            allowance[_from][msg.sender] = allowance[_from][msg.sender] - _value;\r\n        }\r\n\r\n        // event\r\n        emit Transfer(_from, _to, _value);\r\n\r\n        return true;\r\n    }\r\n\r\n    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md#approve\r\n    // there is and attack, see:\r\n    // https://github.com/CORIONplatform/solidity/issues/6,\r\n    // https://drive.google.com/file/d/0ByMtMw2hul0EN3NCaVFHSFdxRzA/view\r\n    // but this function is required by ERC-20\r\n    function approve(address _spender, uint256 _value) public returns (bool success){\r\n\r\n        require(_value >= 0);\r\n\r\n        allowance[msg.sender][_spender] = _value;\r\n\r\n        // event\r\n        emit Approval(msg.sender, _spender, _value);\r\n\r\n        return true;\r\n    }\r\n\r\n    /*  ---------- Interaction with other contracts  */\r\n\r\n    /* User can allow another smart contract to spend some shares in his behalf\r\n    *  (this function should be called by user itself)\r\n    *  @param _spender another contract's address\r\n    *  @param _value number of tokens\r\n    *  @param _extraData Data that can be sent from user to another contract to be processed\r\n    *  bytes - dynamically-sized byte array,\r\n    *  see http://solidity.readthedocs.io/en/v0.4.15/types.html#dynamically-sized-byte-array\r\n    *  see possible attack information in comments to function 'approve'\r\n    *  > this may be used to convert pre-ICO tokens to ICO tokens\r\n    */\r\n    function approveAndCall(address _spender, uint256 _value, bytes memory _extraData) public returns (bool success) {\r\n\r\n        approve(_spender, _value);\r\n\r\n        // 'spender' is another contract that implements code as prescribed in 'allowanceRecipient' above\r\n        allowanceRecipient spender = allowanceRecipient(_spender);\r\n\r\n        // our contract calls 'receiveApproval' function of another contract ('allowanceRecipient') to send information about\r\n        // allowance and data sent by user\r\n        // 'this' is this (our) contract address\r\n        if (spender.receiveApproval(msg.sender, _value, address(this), _extraData)) {\r\n            emit DataSentToAnotherContract(msg.sender, _spender, _extraData);\r\n            return true;\r\n        }\r\n        else return false;\r\n    }\r\n\r\n    function approveAllAndCall(address _spender, bytes memory _extraData) public returns (bool success) {\r\n        return approveAndCall(_spender, balanceOf[msg.sender], _extraData);\r\n    }\r\n\r\n    /* https://github.com/ethereum/EIPs/issues/677\r\n    * transfer tokens with additional info to another smart contract, and calls its correspondent function\r\n    * @param address _to - another smart contract address\r\n    * @param uint256 _value - number of tokens\r\n    * @param bytes _extraData - data to send to another contract\r\n    * > this may be used to convert pre-ICO tokens to ICO tokens\r\n    */\r\n    function transferAndCall(address _to, uint256 _value, bytes memory _extraData) public returns (bool success){\r\n\r\n        transferFrom(msg.sender, _to, _value);\r\n\r\n        tokenRecipient receiver = tokenRecipient(_to);\r\n\r\n        if (receiver.tokenFallback(msg.sender, _value, _extraData)) {\r\n            emit DataSentToAnotherContract(msg.sender, _to, _extraData);\r\n            return true;\r\n        }\r\n        else return false;\r\n    }\r\n\r\n    // for example for conveting ALL tokens of user account to another tokens\r\n    function transferAllAndCall(address _to, bytes memory _extraData) public returns (bool success){\r\n        return transferAndCall(_to, balanceOf[msg.sender], _extraData);\r\n    }\r\n\r\n    /* --- Administrative functions */\r\n\r\n    function changeOwner(address _newOwner) public onlyBy(owner) returns (bool success){\r\n        //\r\n        require(_newOwner != address(0));\r\n\r\n        address oldOwner = owner;\r\n        owner = _newOwner;\r\n\r\n        emit OwnerChanged(oldOwner, _newOwner);\r\n\r\n        return true;\r\n    }\r\n\r\n    /* ---------- Create and sell tokens  */\r\n\r\n    /* set time for start and time for end pre-ICO\r\n    * time is integer representing block timestamp\r\n    * in UNIX Time,\r\n    * see: https://www.epochconverter.com\r\n    * @param uint256 startTime - time to start\r\n    * @param uint256 endTime - time to end\r\n    * should be taken into account that\r\n    * \"block.timestamp\" can be influenced by miners to a certain degree.\r\n    * That means that a miner can \"choose\" the block.timestamp, to a certain degree,\r\n    * to change the outcome of a transaction in the mined block.\r\n    * see:\r\n    * http://solidity.readthedocs.io/en/v0.4.15/frequently-asked-questions.html#are-timestamps-now-block-timestamp-reliable\r\n    */\r\n\r\n    function startSale(uint256 _startUnixTime, uint256 _endUnixTime) public onlyBy(owner) returns (bool success){\r\n\r\n        require(balanceOf[address(this)] > 0);\r\n        require(salesCounter < maxSalesAllowed);\r\n\r\n        // time for sale can be set only if:\r\n        // this is first sale (saleStartUnixTime == 0 && saleEndUnixTime == 0) , or:\r\n        // previous sale finished ( saleIsFinished() )\r\n        require(\r\n        (saleStartUnixTime == 0 && saleEndUnixTime == 0) || saleIsFinished()\r\n        );\r\n        // time can be set only for future\r\n        require(_startUnixTime > now && _endUnixTime > now);\r\n        // end time should be later than start time\r\n        require(_endUnixTime - _startUnixTime > 0);\r\n\r\n        saleStartUnixTime = _startUnixTime;\r\n        saleEndUnixTime = _endUnixTime;\r\n        salesCounter = salesCounter + 1;\r\n\r\n        emit SaleStarted(_startUnixTime, _endUnixTime, salesCounter);\r\n\r\n        return true;\r\n    }\r\n\r\n    function saleIsRunning() public view returns (bool){\r\n\r\n        if (balanceOf[address(this)] == 0) {\r\n            return false;\r\n        }\r\n\r\n        if (saleStartUnixTime == 0 && saleEndUnixTime == 0) {\r\n            return false;\r\n        }\r\n\r\n        if (now > saleStartUnixTime && now < saleEndUnixTime) {\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    function saleIsFinished() public view returns (bool){\r\n\r\n        if (balanceOf[address(this)] == 0) {\r\n            return true;\r\n        }\r\n\r\n        else if (\r\n        (saleStartUnixTime > 0 && saleEndUnixTime > 0)\r\n        && now > saleEndUnixTime) {\r\n\r\n            return true;\r\n        }\r\n\r\n        // <<<\r\n        return true;\r\n    }\r\n\r\n    function changePriceSetter(address _priceSetter) public onlyBy(owner) returns (bool success) {\r\n        priceSetter = _priceSetter;\r\n        return true;\r\n    }\r\n\r\n    function setMinMaxPriceInWei(uint256 _priceMinWei, uint256 _priceMaxWei) public onlyBy(owner) returns (bool success){\r\n        require(_priceMinWei >= 0 && _priceMaxWei >= 0);\r\n        priceMinWei = _priceMinWei;\r\n        priceMaxWei = _priceMaxWei;\r\n        return true;\r\n    }\r\n\r\n\r\n    function setTokenPriceInWei(uint256 _priceInWei) public onlyBy(priceSetter) returns (bool success){\r\n\r\n        require(_priceInWei >= 0);\r\n\r\n        // if 0 - not set\r\n        if (priceMinWei != 0 && _priceInWei < priceMinWei) {\r\n            tokenPriceInWei = priceMinWei;\r\n        }\r\n        else if (priceMaxWei != 0 && _priceInWei > priceMaxWei) {\r\n            tokenPriceInWei = priceMaxWei;\r\n        }\r\n        else {\r\n            tokenPriceInWei = _priceInWei;\r\n        }\r\n\r\n        emit PriceChanged(tokenPriceInWei);\r\n\r\n        return true;\r\n    }\r\n\r\n    // allows sending ether and receiving tokens just using contract address\r\n    // warning:\r\n    // 'If the fallback function requires more than 2300 gas, the contract cannot receive Ether'\r\n    // see:\r\n    // https://ethereum.stackexchange.com/questions/21643/fallback-function-best-practices-when-registering-information\r\n    function() external payable {\r\n        buyTokens();\r\n    }\r\n\r\n    //\r\n    function buyTokens() public payable returns (bool success){\r\n\r\n        if (saleIsRunning() && tokenPriceInWei > 0) {\r\n\r\n            uint256 numberOfTokens = msg.value / tokenPriceInWei;\r\n\r\n            if (numberOfTokens <= balanceOf[address(this)]) {\r\n\r\n                balanceOf[msg.sender] = balanceOf[msg.sender] + numberOfTokens;\r\n                balanceOf[address(this)] = balanceOf[address(this)] - numberOfTokens;\r\n\r\n                emit NewTokensSold(numberOfTokens, msg.sender, tokenPriceInWei);\r\n\r\n                return true;\r\n            }\r\n            else {\r\n                // (payable)\r\n                revert();\r\n            }\r\n        }\r\n        else {\r\n            // (payable)\r\n            revert();\r\n        }\r\n    }\r\n\r\n    /*  After sale contract owner\r\n    *  (can be another contract or account)\r\n    *  can withdraw all collected Ether\r\n    */\r\n    function withdrawAllToOwner() public onlyBy(owner) returns (bool) {\r\n\r\n        // only after sale is finished:\r\n        require(saleIsFinished());\r\n        uint256 sumInWei = address(this).balance;\r\n\r\n        if (\r\n        // makes withdrawal and returns true or false\r\n        !msg.sender.send(address(this).balance)\r\n        ) {\r\n            return false;\r\n        }\r\n        else {\r\n            // event\r\n            emit Withdrawal(msg.sender, sumInWei);\r\n            return true;\r\n        }\r\n    }\r\n\r\n    /* ---------- Referral System */\r\n\r\n    // list of registered referrers\r\n    // represented by keccak256(address) (returns bytes32)\r\n    // ! referrers can not be removed !\r\n    mapping (bytes32 => bool) private isReferrer;\r\n\r\n    uint256 private referralBonus = 0;\r\n\r\n    uint256 private referrerBonus = 0;\r\n    // tokens owned by referrers:\r\n    mapping (bytes32 => uint256) public referrerBalanceOf;\r\n\r\n    mapping (bytes32 => uint) public referrerLinkedSales;\r\n\r\n    function addReferrer(bytes32 _referrer) public onlyBy(owner) returns (bool success){\r\n        isReferrer[_referrer] = true;\r\n        return true;\r\n    }\r\n\r\n    function removeReferrer(bytes32 _referrer) public onlyBy(owner) returns (bool success){\r\n        isReferrer[_referrer] = false;\r\n        return true;\r\n    }\r\n\r\n    // bonuses are set in as integers (20%, 30%), initial 0%\r\n    function setReferralBonuses(uint256 _referralBonus, uint256 _referrerBonus) public onlyBy(owner) returns (bool success){\r\n        require(_referralBonus > 0 && _referrerBonus > 0);\r\n        referralBonus = _referralBonus;\r\n        referrerBonus = _referrerBonus;\r\n        return true;\r\n    }\r\n\r\n    function buyTokensWithReferrerAddress(address _referrer) public payable returns (bool success){\r\n\r\n        bytes32 referrer = keccak256(abi.encodePacked(_referrer));\r\n\r\n        if (saleIsRunning() && tokenPriceInWei > 0) {\r\n\r\n            if (isReferrer[referrer]) {\r\n\r\n                uint256 numberOfTokens = msg.value / tokenPriceInWei;\r\n\r\n                if (numberOfTokens <= balanceOf[address(this)]) {\r\n\r\n                    referrerLinkedSales[referrer] = referrerLinkedSales[referrer] + numberOfTokens;\r\n\r\n                    uint256 referralBonusTokens = (numberOfTokens * (100 + referralBonus) / 100) - numberOfTokens;\r\n                    uint256 referrerBonusTokens = (numberOfTokens * (100 + referrerBonus) / 100) - numberOfTokens;\r\n\r\n                    balanceOf[address(this)] = balanceOf[address(this)] - numberOfTokens - referralBonusTokens - referrerBonusTokens;\r\n\r\n                    balanceOf[msg.sender] = balanceOf[msg.sender] + (numberOfTokens + referralBonusTokens);\r\n\r\n                    referrerBalanceOf[referrer] = referrerBalanceOf[referrer] + referrerBonusTokens;\r\n\r\n                    emit NewTokensSold(numberOfTokens + referralBonusTokens, msg.sender, tokenPriceInWei);\r\n\r\n                    return true;\r\n                }\r\n                else {\r\n                    // (payable)\r\n                    revert();\r\n                }\r\n            }\r\n            else {\r\n                // (payable)\r\n                buyTokens();\r\n            }\r\n        }\r\n        else {\r\n            // (payable)\r\n            revert();\r\n        }\r\n    }\r\n\r\n    event ReferrerBonusTokensTaken(address referrer, uint256 bonusTokensValue);\r\n\r\n    function getReferrerBonusTokens() public returns (bool success){\r\n        require(saleIsFinished());\r\n        uint256 bonusTokens = referrerBalanceOf[keccak256(abi.encodePacked(msg.sender))];\r\n        balanceOf[msg.sender] = balanceOf[msg.sender] + bonusTokens;\r\n        emit ReferrerBonusTokensTaken(msg.sender, bonusTokens);\r\n        return true;\r\n    }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"JPContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"DEEXContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"DEEXFund\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_jackPotAddress\",\"type\":\"address\"},{\"name\":\"_DEEXAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"}]","ContractName":"Dragons","CompilerVersion":"v0.5.1+commit.c8a2cb62","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000bc05889af534ea29e333fe5fa9bc9b4767ca7653000000000000000000000000c16cf13922c18de7842374f9baace4489f1d24af","Library":"","SwarmSource":"bzzr://66b60b4d283c5a92d09bc7116158e59c205c8e912ba44f62a8770b295de9ea94"}]}