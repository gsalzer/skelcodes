{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity >=0.5.0 <0.6.0;\r\n\r\n/**\r\n * @title SafeMath for uint256\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMathUint256 {\r\n    /**\r\n    * @dev Multiplies two numbers, throws on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        c = a * b;\r\n        require(c / a == b, \"SafeMath: Multiplier exception\");\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two numbers, truncating the quotient.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a / b; // Solidity automatically throws when dividing by 0\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"SafeMath: Subtraction exception\");\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, throws on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        c = a + b;\r\n        require(c >= a, \"SafeMath: Addition exception\");\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\r\n    * reverts when dividing by zero.\r\n    */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0, \"SafeMath: Modulo exception\");\r\n        return a % b;\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * @title SafeMath for uint8\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMathUint8 {\r\n    /**\r\n    * @dev Multiplies two numbers, throws on overflow.\r\n    */\r\n    function mul(uint8 a, uint8 b) internal pure returns (uint8 c) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        c = a * b;\r\n        require(c / a == b, \"SafeMath: Multiplier exception\");\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two numbers, truncating the quotient.\r\n    */\r\n    function div(uint8 a, uint8 b) internal pure returns (uint8) {\r\n        return a / b; // Solidity automatically throws when dividing by 0\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint8 a, uint8 b) internal pure returns (uint8) {\r\n        require(b <= a, \"SafeMath: Subtraction exception\");\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, throws on overflow.\r\n    */\r\n    function add(uint8 a, uint8 b) internal pure returns (uint8 c) {\r\n        c = a + b;\r\n        require(c >= a, \"SafeMath: Addition exception\");\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\r\n    * reverts when dividing by zero.\r\n    */\r\n    function mod(uint8 a, uint8 b) internal pure returns (uint8) {\r\n        require(b != 0, \"SafeMath: Modulo exception\");\r\n        return a % b;\r\n    }\r\n\r\n}\r\n\r\ncontract Ownership {\r\n    address payable public owner;\r\n    address payable public pendingOwner;\r\n\r\n    event OwnershipTransferred (address indexed from, address indexed to);\r\n\r\n    constructor () public\r\n    {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        require (msg.sender == owner, \"Ownership: Access denied\");\r\n        _;\r\n    }\r\n\r\n    function transferOwnership (address payable _pendingOwner) public\r\n        onlyOwner\r\n    {\r\n        pendingOwner = _pendingOwner;\r\n    }\r\n\r\n    function acceptOwnership () public\r\n    {\r\n        require (msg.sender == pendingOwner, \"Ownership: Only new owner is allowed\");\r\n\r\n        emit OwnershipTransferred (owner, pendingOwner);\r\n\r\n        owner = pendingOwner;\r\n        pendingOwner = address(0);\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * @title Controllable contract\r\n * @dev Implementation of the controllable operations\r\n */\r\ncontract Controllable is Ownership {\r\n\r\n    bool public stopped;\r\n    mapping (address => bool) public freezeAddresses;\r\n\r\n    event Paused();\r\n    event Resumed();\r\n\r\n    event FreezeAddress(address indexed addressOf);\r\n    event UnfreezeAddress(address indexed addressOf);\r\n\r\n    modifier onlyActive(address _sender) {\r\n        require(!freezeAddresses[_sender], \"Controllable: Not active\");\r\n        _;\r\n    }\r\n\r\n    modifier isUsable {\r\n        require(!stopped, \"Controllable: Paused\");\r\n        _;\r\n    }\r\n\r\n    function pause () public\r\n        onlyOwner\r\n    {\r\n        stopped = true;\r\n        emit Paused ();\r\n    }\r\n    \r\n    function resume () public\r\n        onlyOwner\r\n    {\r\n        stopped = false;\r\n        emit Resumed ();\r\n    }\r\n\r\n    function freezeAddress(address _addressOf) public\r\n        onlyOwner\r\n        returns (bool)\r\n    {\r\n        if (!freezeAddresses[_addressOf]) {\r\n            freezeAddresses[_addressOf] = true;\r\n            emit FreezeAddress(_addressOf);\r\n        }\r\n\r\n        return true;\r\n    }\r\n\t\r\n    function unfreezeAddress(address _addressOf) public\r\n        onlyOwner\r\n        returns (bool)\r\n    {\r\n        if (freezeAddresses[_addressOf]) {\r\n            delete freezeAddresses[_addressOf];\r\n            emit UnfreezeAddress(_addressOf);\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/179\r\n */\r\ncontract ERC20Basic {\r\n    function balanceOf(address who) public view returns (uint256);\r\n    function transfer(address to, uint256 value) public returns (bool);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 is ERC20Basic {\r\n    function allowance(address owner, address spender) public view returns (uint256);\r\n    function transferFrom(address from, address to, uint256 value) public returns (bool);\r\n    function approve(address spender, uint256 value) public returns (bool);\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\n/**\r\n * @title Basic token\r\n * @dev Basic version of StandardToken, with no allowances.\r\n */\r\ncontract BasicToken is ERC20Basic, Controllable {\r\n    using SafeMathUint256 for uint256;\r\n\r\n    mapping(address => uint256) balances;\r\n\r\n    uint256 public totalSupply;\r\n\r\n    constructor(uint256 _initialSupply) public\r\n    {\r\n        totalSupply = _initialSupply;\r\n\r\n        if (0 < _initialSupply) {\r\n            balances[msg.sender] = _initialSupply;\r\n            emit Transfer(address(0), msg.sender, _initialSupply);\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev transfer token for a specified address\r\n    * @param _to The address to transfer to.\r\n    * @param _value The amount to be transferred.\r\n    */\r\n    function transfer(address _to, uint256 _value) public\r\n        isUsable\r\n        onlyActive(msg.sender)\r\n        onlyActive(_to)\r\n        returns (bool)\r\n    {\r\n        require(0 < _value, \"BasicToken.transfer: Zero value\");\r\n        require(_value <= balances[msg.sender], \"BasicToken.transfer: Insufficient fund\");\r\n\r\n        // SafeMath.sub will throw if there is not enough balance.\r\n        balances[msg.sender] = balances[msg.sender].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n        emit Transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev Gets the balance of the specified address.\r\n    * @param _owner The address to query the the balance of.\r\n    * @return An uint256 representing the amount owned by the passed address.\r\n    */\r\n    function balanceOf(address _owner) public view\r\n        returns (uint256 balance)\r\n    {\r\n        return balances[_owner];\r\n    }\r\n\r\n}\r\n\r\n\r\n/**\r\n * @title Standard ERC20 token\r\n *\r\n * @dev Implementation of the basic standard token.\r\n * @dev https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract StandardToken is ERC20, BasicToken {\r\n\r\n    mapping (address => mapping (address => uint256)) internal allowed;\r\n\r\n    /**\r\n    * @dev Transfer tokens from one address to another\r\n    * @param _from address The address which you want to send tokens from\r\n    * @param _to address The address which you want to transfer to\r\n    * @param _value uint256 the amount of tokens to be transferred\r\n    */\r\n    function transferFrom(address _from, address _to, uint256 _value) public\r\n        isUsable\r\n        onlyActive(msg.sender)\r\n        onlyActive(_from)\r\n        onlyActive(_to)\r\n        returns (bool)\r\n    {\r\n        require(0 < _value, \"StandardToken.transferFrom: Zero value\");\r\n        require(_value <= balances[_from], \"StandardToken.transferFrom: Insufficient fund\");\r\n        require(_value <= allowed[_from][msg.sender], \"StandardToken.transferFrom: Insufficient allowance\");\r\n\r\n        balances[_from] = balances[_from].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n        emit Transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n    *\r\n    * Beware that changing an allowance with this method brings the risk that someone may use both the old\r\n    * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\r\n    * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\r\n    * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n    * @param _spender The address which will spend the funds.\r\n    * @param _value The amount of tokens to be spent.\r\n    */\r\n    function approve(address _spender, uint256 _value) public\r\n        isUsable\r\n        onlyActive(msg.sender)\r\n        onlyActive(_spender)\r\n        returns (bool)\r\n    {\r\n        require(0 < _value, \"StandardToken.approve: Zero value\");\r\n\r\n        allowed[msg.sender][_spender] = _value;\r\n        emit Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n    * @param _owner address The address which owns the funds.\r\n    * @param _spender address The address which will spend the funds.\r\n    * @return A uint256 specifying the amount of tokens still available for the spender.\r\n    */\r\n    function allowance(address _owner, address _spender) public view\r\n        returns (uint256)\r\n    {\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n    /**\r\n    * @dev Increase the amount of tokens that an owner allowed to a spender.\r\n    *\r\n    * approve should be called when allowed[_spender] == 0. To increment\r\n    * allowed value is better to use this function to avoid 2 calls (and wait until\r\n    * the first transaction is mined)\r\n    * From MonolithDAO Token.sol\r\n    * @param _spender The address which will spend the funds.\r\n    * @param _addedValue The amount of tokens to increase the allowance by.\r\n    */\r\n    function increaseApproval(address _spender, uint256 _addedValue) public\r\n        isUsable\r\n        onlyActive(msg.sender)\r\n        onlyActive(_spender)\r\n        returns (bool)\r\n    {\r\n        require(0 < _addedValue, \"StandardToken.increaseApproval: Zero value\");\r\n\r\n        allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\r\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev Decrease the amount of tokens that an owner allowed to a spender.\r\n    *\r\n    * approve should be called when allowed[_spender] == 0. To decrement\r\n    * allowed value is better to use this function to avoid 2 calls (and wait until\r\n    * the first transaction is mined)\r\n    * From MonolithDAO Token.sol\r\n    * @param _spender The address which will spend the funds.\r\n    * @param _subtractedValue The amount of tokens to decrease the allowance by.\r\n    */\r\n    function decreaseApproval(address _spender, uint256 _subtractedValue) public\r\n        isUsable\r\n        onlyActive(msg.sender)\r\n        onlyActive(_spender)\r\n        returns (bool)\r\n    {\r\n        require(0 < _subtractedValue, \"StandardToken.decreaseApproval: Zero value\");\r\n\r\n        uint256 oldValue = allowed[msg.sender][_spender];\r\n\r\n        if (_subtractedValue > oldValue)\r\n            allowed[msg.sender][_spender] = 0;\r\n        else\r\n            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\r\n\r\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n        return true;\r\n    }\r\n\r\n}\r\n\r\ncontract ApprovalReceiver {\r\n    function receiveApproval(address _from, uint256 _value, address _tokenContract, bytes calldata _extraData) external;\r\n}\r\n\r\ncontract USDA is StandardToken {\r\n    using SafeMathUint256 for uint256;\r\n\r\n    bytes32 constant FREEZE_CODE_DEFAULT = 0x0000000000000000000000000000000000000000000000000000000000000000;\r\n\r\n    event Freeze(address indexed from, uint256 value);\r\n    event Unfreeze(address indexed from, uint256 value);\r\n\r\n    event FreezeWithPurpose(address indexed from, uint256 value, bytes32 purpose);\r\n    event UnfreezeWithPurpose(address indexed from, uint256 value, bytes32 purpose);\r\n\r\n    string public name;\r\n    string public symbol;\r\n    uint8 public decimals;\r\n\r\n    // Keep track total frozen balances\r\n    mapping (address => uint256) public freezeOf;\r\n    // Keep track sub total frozen balances\r\n    mapping (address => mapping (bytes32 => uint256)) public freezes;\r\n\r\n    constructor(string memory _name, string memory _symbol, uint8 _decimals, uint256 _initialSupply) public\r\n        BasicToken(_initialSupply)\r\n    {\r\n        name = _name;\r\n        symbol = _symbol;\r\n        decimals = _decimals;\r\n    }\r\n\r\n    /**\r\n     * @dev Increase total supply (mint) to an address\r\n     *\r\n     * @param _value The amount of tokens to be mint\r\n     * @param _to The address which will receive token\r\n     */\r\n    function increaseSupply(uint256 _value, address _to) external\r\n        onlyOwner\r\n        onlyActive(_to)\r\n        returns (bool)\r\n    {\r\n        require(0 < _value, \"StableCoin.increaseSupply: Zero value\");\r\n\r\n        totalSupply = totalSupply.add(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n        emit Transfer(address(0), _to, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Increase total supply (mint) to an address with deposit\r\n     *\r\n     * @param _value The amount of tokens to be mint\r\n     * @param _to The address which will receive token\r\n     * @param _deposit The amount of deposit\r\n     */\r\n    function increaseSupplyWithDeposit(uint256 _value, address _to, uint256 _deposit) external\r\n        onlyOwner\r\n        onlyActive(_to)\r\n        returns (bool)\r\n    {\r\n        require(0 < _value, \"StableCoin.increaseSupplyWithDeposit: Zero value\");\r\n        require(_deposit <= _value, \"StableCoin.increaseSupplyWithDeposit: Insufficient deposit\");\r\n\r\n        totalSupply = totalSupply.add(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n        freezeWithPurposeCode(_to, _deposit, encodePacked(\"InitialDeposit\"));\r\n        emit Transfer(address(0), _to, _value.sub(_deposit));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Decrease total supply (burn) from an address that gave allowance\r\n     *\r\n     * @param _value The amount of tokens to be burn\r\n     * @param _from The address's token will be burn\r\n     */\r\n    function decreaseSupply(uint256 _value, address _from) external\r\n        onlyOwner\r\n        onlyActive(_from)\r\n        returns (bool)\r\n    {\r\n        require(0 < _value, \"StableCoin.decreaseSupply: Zero value\");\r\n        require(_value <= balances[_from], \"StableCoin.decreaseSupply: Insufficient fund\");\r\n        require(_value <= allowed[_from][address(0)], \"StableCoin.decreaseSupply: Insufficient allowance\");\r\n\r\n        totalSupply = totalSupply.sub(_value);\r\n        balances[_from] = balances[_from].sub(_value);\r\n        allowed[_from][address(0)] = allowed[_from][address(0)].sub(_value);\r\n        emit Transfer(_from, address(0), _value);\r\n        return true;\r\n    }\r\n\t\r\n    /**\r\n    * @dev Freeze holder balance\r\n    *\r\n    * @param _from The address which will be freeze\r\n    * @param _value The amount of tokens to be freeze\r\n    */\r\n    function freeze(address _from, uint256 _value) external\r\n        onlyOwner\r\n        returns (bool)\r\n    {\r\n        require(_value <= balances[_from], \"StableCoin.freeze: Insufficient fund\");\r\n\r\n        balances[_from] = balances[_from].sub(_value);\r\n        freezeOf[_from] = freezeOf[_from].add(_value);\r\n        freezes[_from][FREEZE_CODE_DEFAULT] = freezes[_from][FREEZE_CODE_DEFAULT].add(_value);\r\n        emit Freeze(_from, _value);\r\n        emit FreezeWithPurpose(_from, _value, FREEZE_CODE_DEFAULT);\r\n        return true;\r\n    }\r\n\t\r\n    /**\r\n    * @dev Freeze holder balance with purpose code\r\n    *\r\n    * @param _from The address which will be freeze\r\n    * @param _value The amount of tokens to be freeze\r\n    * @param _purpose The purpose of freeze\r\n    */\r\n    function freezeWithPurpose(address _from, uint256 _value, string calldata _purpose) external\r\n        returns (bool)\r\n    {\r\n        return freezeWithPurposeCode(_from, _value, encodePacked(_purpose));\r\n    }\r\n\t\r\n    /**\r\n    * @dev Freeze holder balance with purpose code\r\n    *\r\n    * @param _from The address which will be freeze\r\n    * @param _value The amount of tokens to be freeze\r\n    * @param _purposeCode The purpose code of freeze\r\n    */\r\n    function freezeWithPurposeCode(address _from, uint256 _value, bytes32 _purposeCode) public\r\n        onlyOwner\r\n        returns (bool)\r\n    {\r\n        require(_value <= balances[_from], \"StableCoin.freezeWithPurposeCode: Insufficient fund\");\r\n\r\n        balances[_from] = balances[_from].sub(_value);\r\n        freezeOf[_from] = freezeOf[_from].add(_value);\r\n        freezes[_from][_purposeCode] = freezes[_from][_purposeCode].add(_value);\r\n        emit Freeze(_from, _value);\r\n        emit FreezeWithPurpose(_from, _value, _purposeCode);\r\n        return true;\r\n    }\r\n\t\r\n    /**\r\n    * @dev Unfreeze holder balance\r\n    *\r\n    * @param _from The address which will be unfreeze\r\n    * @param _value The amount of tokens to be unfreeze\r\n    */\r\n    function unfreeze(address _from, uint256 _value) external\r\n        onlyOwner\r\n        returns (bool)\r\n    {\r\n        require(_value <= freezes[_from][FREEZE_CODE_DEFAULT], \"StableCoin.unfreeze: Insufficient fund\");\r\n\r\n        freezeOf[_from] = freezeOf[_from].sub(_value);\r\n        freezes[_from][FREEZE_CODE_DEFAULT] = freezes[_from][FREEZE_CODE_DEFAULT].sub(_value);\r\n        balances[_from] = balances[_from].add(_value);\r\n        emit Unfreeze(_from, _value);\r\n        emit UnfreezeWithPurpose(_from, _value, FREEZE_CODE_DEFAULT);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev Unfreeze holder balance with purpose code\r\n    *\r\n    * @param _from The address which will be unfreeze\r\n    * @param _value The amount of tokens to be unfreeze\r\n    * @param _purpose The purpose of unfreeze\r\n    */\r\n    function unfreezeWithPurpose(address _from, uint256 _value, string calldata _purpose) external\r\n        onlyOwner\r\n        returns (bool)\r\n    {\r\n        return unfreezeWithPurposeCode(_from, _value, encodePacked(_purpose));\r\n    }\r\n\r\n    /**\r\n    * @dev Unfreeze holder balance with purpose code\r\n    *\r\n    * @param _from The address which will be unfreeze\r\n    * @param _value The amount of tokens to be unfreeze\r\n    * @param _purposeCode The purpose code of unfreeze\r\n    */\r\n    function unfreezeWithPurposeCode(address _from, uint256 _value, bytes32 _purposeCode) public\r\n        onlyOwner\r\n        returns (bool)\r\n    {\r\n        require(_value <= freezes[_from][_purposeCode], \"StableCoin.unfreezeWithPurposeCode: Insufficient fund\");\r\n\r\n        freezeOf[_from] = freezeOf[_from].sub(_value);\r\n        freezes[_from][_purposeCode] = freezes[_from][_purposeCode].sub(_value);\r\n        balances[_from] = balances[_from].add(_value);\r\n        emit Unfreeze(_from, _value);\r\n        emit UnfreezeWithPurpose(_from, _value, _purposeCode);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Allocate allowance and perform contract call\r\n     *\r\n     * @param _spender The spender address\r\n     * @param _value The allowance value\r\n     * @param _extraData The function call data\r\n     */\r\n    function approveAndCall(address _spender, uint256 _value, bytes calldata _extraData) external\r\n        isUsable\r\n        returns (bool)\r\n    {\r\n        // Give allowance to spender (previous approved allowances will be clear)\r\n        approve(_spender, _value);\r\n\r\n        ApprovalReceiver(_spender).receiveApproval(msg.sender, _value, address(this), _extraData);\r\n        return true;\r\n    }\r\n\r\n    function encodePacked(string memory s) internal pure\r\n        returns (bytes32)\r\n    {\r\n        return keccak256(abi.encodePacked(s));\r\n    }\r\n\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_deposit\",\"type\":\"uint256\"}],\"name\":\"increaseSupplyWithDeposit\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"resume\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"increaseSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"freezes\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"freeze\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addressOf\",\"type\":\"address\"}],\"name\":\"freezeAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_purposeCode\",\"type\":\"bytes32\"}],\"name\":\"unfreezeWithPurposeCode\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseApproval\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_purposeCode\",\"type\":\"bytes32\"}],\"name\":\"freezeWithPurposeCode\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"stopped\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_purpose\",\"type\":\"string\"}],\"name\":\"freezeWithPurpose\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"unfreeze\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_purpose\",\"type\":\"string\"}],\"name\":\"unfreezeWithPurpose\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_from\",\"type\":\"address\"}],\"name\":\"decreaseSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addressOf\",\"type\":\"address\"}],\"name\":\"unfreezeAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_extraData\",\"type\":\"bytes\"}],\"name\":\"approveAndCall\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"freezeOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseApproval\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pendingOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"freezeAddresses\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_pendingOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_name\",\"type\":\"string\"},{\"name\":\"_symbol\",\"type\":\"string\"},{\"name\":\"_decimals\",\"type\":\"uint8\"},{\"name\":\"_initialSupply\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Freeze\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Unfreeze\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"purpose\",\"type\":\"bytes32\"}],\"name\":\"FreezeWithPurpose\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"purpose\",\"type\":\"bytes32\"}],\"name\":\"UnfreezeWithPurpose\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Resumed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"addressOf\",\"type\":\"address\"}],\"name\":\"FreezeAddress\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"addressOf\",\"type\":\"address\"}],\"name\":\"UnfreezeAddress\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"}]","ContractName":"USDA","CompilerVersion":"v0.5.0+commit.1d4f565a","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000c0000000000000000000000000000000000000000000000000000000000000001200000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000009555344204173736574000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000045553444100000000000000000000000000000000000000000000000000000000","Library":"","SwarmSource":"bzzr://23f4106daff7dea932097c3373fbddf46f30696cc0631f87b6f184207ee1286e"}]}