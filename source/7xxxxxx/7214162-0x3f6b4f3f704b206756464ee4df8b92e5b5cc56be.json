{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity >0.4.99 <0.6.0;\r\n\r\n\r\nlibrary Zero {\r\n    function requireNotZero(address addr) internal pure {\r\n        require(addr != address(0), \"require not zero address\");\r\n    }\r\n\r\n    function requireNotZero(uint val) internal pure {\r\n        require(val != 0, \"require not zero value\");\r\n    }\r\n\r\n    function notZero(address addr) internal pure returns(bool) {\r\n        return !(addr == address(0));\r\n    }\r\n\r\n    function isZero(address addr) internal pure returns(bool) {\r\n        return addr == address(0);\r\n    }\r\n\r\n    function isZero(uint a) internal pure returns(bool) {\r\n        return a == 0;\r\n    }\r\n\r\n    function notZero(uint a) internal pure returns(bool) {\r\n        return a != 0;\r\n    }\r\n}\r\n\r\n\r\nlibrary Percent {\r\n    struct percent {\r\n        uint num;\r\n        uint den;\r\n    }\r\n\r\n    function mul(percent storage p, uint a) internal view returns (uint) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        return a*p.num/p.den;\r\n    }\r\n\r\n    function div(percent storage p, uint a) internal view returns (uint) {\r\n        return a/p.num*p.den;\r\n    }\r\n\r\n    function sub(percent storage p, uint a) internal view returns (uint) {\r\n        uint b = mul(p, a);\r\n        if (b >= a) {\r\n            return 0;\r\n        }\r\n        return a - b;\r\n    }\r\n\r\n    function add(percent storage p, uint a) internal view returns (uint) {\r\n        return a + mul(p, a);\r\n    }\r\n\r\n    function toMemory(percent storage p) internal view returns (Percent.percent memory) {\r\n        return Percent.percent(p.num, p.den);\r\n    }\r\n\r\n    function mmul(percent memory p, uint a) internal pure returns (uint) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        return a*p.num/p.den;\r\n    }\r\n\r\n    function mdiv(percent memory p, uint a) internal pure returns (uint) {\r\n        return a/p.num*p.den;\r\n    }\r\n\r\n    function msub(percent memory p, uint a) internal pure returns (uint) {\r\n        uint b = mmul(p, a);\r\n        if (b >= a) {\r\n            return 0;\r\n        }\r\n        return a - b;\r\n    }\r\n\r\n    function madd(percent memory p, uint a) internal pure returns (uint) {\r\n        return a + mmul(p, a);\r\n    }\r\n}\r\n\r\n\r\nlibrary Address {\r\n    function toAddress(bytes memory source) internal pure returns(address addr) {\r\n        assembly { addr := mload(add(source,0x14)) }\r\n        return addr;\r\n    }\r\n\r\n    function isNotContract(address addr) internal view returns(bool) {\r\n        uint length;\r\n        assembly { length := extcodesize(addr) }\r\n        return length == 0;\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n\r\n    /**\r\n    * @dev Multiplies two numbers, reverts on overflow.\r\n    */\r\n    function mul(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n        if (_a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = _a * _b;\r\n        require(c / _a == _b);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\r\n    */\r\n    function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n        require(_b > 0); // Solidity only automatically asserts when dividing by 0\r\n        uint256 c = _a / _b;\r\n        // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n        require(_b <= _a);\r\n        uint256 c = _a - _b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, reverts on overflow.\r\n    */\r\n    function add(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n        uint256 c = _a + _b;\r\n        require(c >= _a);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\r\n    * reverts when dividing by zero.\r\n    */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n\r\ncontract Accessibility {\r\n    address private owner;\r\n    event OwnerChanged(address indexed previousOwner, address indexed newOwner);\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"access denied\");\r\n        _;\r\n    }\r\n\t\r\n\tconstructor() public {\r\n\t\towner = msg.sender;\r\n    }\r\n\r\n    function changeOwner(address _newOwner) onlyOwner public {\r\n        require(_newOwner != address(0));\r\n        emit OwnerChanged(owner, _newOwner);\r\n        owner = _newOwner;\r\n    }\r\n}\r\n\r\n\r\ncontract InvestorsStorage is Accessibility {\r\n    using SafeMath for uint;\r\n\r\n    struct Investor {\r\n        uint paymentTime;\r\n        uint fundDepositType_1;\r\n        uint fundDepositType_2;\r\n        uint fundDepositType_3;\r\n        uint referrerBonus;\r\n        uint numberReferral;\r\n    }\r\n    uint public size;\r\n\r\n    mapping (address => Investor) private investors;\r\n\r\n    function isInvestor(address addr) public view returns (bool) {\r\n        uint fundDeposit = investors[addr].fundDepositType_1.add(investors[addr].fundDepositType_2).add(investors[addr].fundDepositType_3);\r\n        return fundDeposit > 0;\r\n    }\r\n\r\n    function investorInfo(address addr) public view returns(uint paymentTime,\r\n        uint fundDepositType_1, uint fundDepositType_2, uint fundDepositType_3,\r\n        uint referrerBonus, uint numberReferral) {\r\n        paymentTime = investors[addr].paymentTime;\r\n        fundDepositType_1 = investors[addr].fundDepositType_1;\r\n        fundDepositType_2 = investors[addr].fundDepositType_2;\r\n        fundDepositType_3 = investors[addr].fundDepositType_3;\r\n        referrerBonus = investors[addr].referrerBonus;\r\n        numberReferral = investors[addr].numberReferral;\r\n    }\r\n\r\n    function newInvestor(address addr, uint investment, uint paymentTime, uint typeDeposit) public onlyOwner returns (bool) {\r\n        Investor storage inv = investors[addr];\r\n        uint fundDeposit = inv.fundDepositType_1.add(inv.fundDepositType_2).add(inv.fundDepositType_3);\r\n        if (fundDeposit != 0 || investment == 0) {\r\n            return false;\r\n        }\r\n        if (typeDeposit < 0 || typeDeposit > 2) {\r\n            return false;\r\n        }\r\n\r\n        if (typeDeposit == 0) {\r\n            inv.fundDepositType_1 = investment;\r\n        } else if (typeDeposit == 1) {\r\n            inv.fundDepositType_2 = investment;\r\n        } else if (typeDeposit == 2) {\r\n            inv.fundDepositType_3 = investment;\r\n        }\r\n\r\n        inv.paymentTime = paymentTime;\r\n        size++;\r\n        return true;\r\n    }\r\n\r\n    function checkSetZeroFund(address addr, uint currentTime) public onlyOwner {\r\n        uint numberDays = currentTime.sub(investors[addr].paymentTime) / 1 days;\r\n\r\n        if (investors[addr].fundDepositType_1 > 0 && numberDays > 30) {\r\n            investors[addr].fundDepositType_1 = 0;\r\n        }\r\n        if (investors[addr].fundDepositType_2 > 0 && numberDays > 90) {\r\n            investors[addr].fundDepositType_2 = 0;\r\n        }\r\n        if (investors[addr].fundDepositType_3 > 0 && numberDays > 180) {\r\n            investors[addr].fundDepositType_3 = 0;\r\n        }\r\n    }\r\n\r\n    function addInvestment(address addr, uint investment, uint typeDeposit) public onlyOwner returns (bool) {\r\n        if (typeDeposit == 0) {\r\n            investors[addr].fundDepositType_1 = investors[addr].fundDepositType_1.add(investment);\r\n        } else if (typeDeposit == 1) {\r\n            investors[addr].fundDepositType_2 = investors[addr].fundDepositType_2.add(investment);\r\n        } else if (typeDeposit == 2) {\r\n            investors[addr].fundDepositType_3 = investors[addr].fundDepositType_3.add(investment);\r\n        } else if (typeDeposit == 10) {\r\n            investors[addr].referrerBonus = investors[addr].referrerBonus.add(investment);\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    function addReferral(address addr) public onlyOwner {\r\n        investors[addr].numberReferral++;\r\n    }\r\n\r\n    function getCountReferral(address addr) public view onlyOwner returns (uint) {\r\n        return investors[addr].numberReferral;\r\n    }\r\n\r\n    function getReferrerBonus(address addr) public onlyOwner returns (uint) {\r\n        uint referrerBonus = investors[addr].referrerBonus;\r\n        investors[addr].referrerBonus = 0;\r\n        return referrerBonus;\r\n    }\r\n\r\n    function setPaymentTime(address addr, uint paymentTime) public onlyOwner returns (bool) {\r\n        uint fundDeposit = investors[addr].fundDepositType_1.add(investors[addr].fundDepositType_2).add(investors[addr].fundDepositType_3);\r\n        if (fundDeposit == 0) {\r\n            return false;\r\n        }\r\n        investors[addr].paymentTime = paymentTime;\r\n        return true;\r\n    }\r\n}\r\n\r\ncontract Ethbank is Accessibility {\r\n    using Percent for Percent.percent;\r\n    using SafeMath for uint;\r\n\r\n    // easy read for investors\r\n    using Address for *;\r\n    using Zero for *;\r\n\r\n    bool public isDemo;\r\n\tuint public simulateDate;\r\n\r\n    mapping(address => bool) private m_referrals;\r\n    InvestorsStorage private m_investors;\r\n\r\n    // automatically generates getters\r\n    uint public constant minInvesment = 10 finney;\r\n    address payable public advertisingAddress;\r\n    uint public investmentsNumber;\r\n    uint public totalEthRaised;\r\n\r\n\r\n    // percents tariff\r\n    Percent.percent private m_1_percent = Percent.percent(1,100);            // 1/100 *100% = 1%\r\n    Percent.percent private m_2_percent = Percent.percent(2,100);            // 2/100 *100% = 2%\r\n    Percent.percent private m_3_percent = Percent.percent(3,100);            // 3/100 *100% = 3%\r\n\r\n    // percents referal\r\n    Percent.percent private m_3_referal_percent = Percent.percent(3,100);        // 3/100 *100% = 3%\r\n    Percent.percent private m_3_referrer_percent = Percent.percent(3,100);       // 3/100 *100% = 3%\r\n\r\n    Percent.percent private m_5_referal_percent = Percent.percent(5,100);        // 5/100 *100% = 5%\r\n    Percent.percent private m_4_referrer_percent = Percent.percent(4,100);       // 4/100 *100% = 4%\r\n\r\n    Percent.percent private m_10_referal_percent = Percent.percent(10,100);      // 10/100 *100% = 10%\r\n    Percent.percent private m_5_referrer_percent = Percent.percent(5,100);       // 5/100 *100% = 5%\r\n\r\n    // percents advertising\r\n    Percent.percent private m_advertisingPercent = Percent.percent(10, 100);      // 10/100  *100% = 10%\r\n\r\n    // more events for easy read from blockchain\r\n    event LogNewReferral(address indexed addr, address indexed referrerAddr, uint when, uint referralBonus);\r\n    event LogNewInvesment(address indexed addr, uint when, uint investment, uint typeDeposit);\r\n    event LogAutomaticReinvest(address indexed addr, uint when, uint investment, uint typeDeposit);\r\n    event LogPayDividends(address indexed addr, uint when, uint dividends);\r\n    event LogPayReferrerBonus(address indexed addr, uint when, uint referrerBonus);\r\n    event LogNewInvestor(address indexed addr, uint when, uint typeDeposit);\r\n    event LogBalanceChanged(uint when, uint balance);\r\n    event ChangeTime(uint256 _newDate, uint256 simulateDate);\r\n\r\n    modifier balanceChanged {\r\n        _;\r\n        emit LogBalanceChanged(getCurrentDate(), address(this).balance);\r\n    }\r\n\r\n    modifier notFromContract() {\r\n        require(msg.sender.isNotContract(), \"only externally accounts\");\r\n        _;\r\n    }\r\n\r\n    constructor(address payable _advertisingAddress) public {\r\n        advertisingAddress = _advertisingAddress;\r\n        m_investors = new InvestorsStorage();\r\n        investmentsNumber = 0;\r\n    }\r\n\r\n    function() external payable {\r\n        if (msg.value.isZero()) {\r\n            getMyDividends();\r\n            return;\r\n        } else {\r\n\t\t\tdoInvest(msg.data.toAddress(), 0);\r\n\t\t}\r\n    }\r\n\r\n    function setAdvertisingAddress(address payable addr) public onlyOwner {\r\n        addr.requireNotZero();\r\n        advertisingAddress = addr;\r\n    }\r\n\r\n    function investorsNumber() public view returns(uint) {\r\n        return m_investors.size();\r\n    }\r\n\r\n    function balanceETH() public view returns(uint) {\r\n        return address(this).balance;\r\n    }\r\n\r\n    function advertisingPercent() public view returns(uint numerator, uint denominator) {\r\n        (numerator, denominator) = (m_advertisingPercent.num, m_advertisingPercent.den);\r\n    }\r\n\r\n    function investorInfo(address investorAddr) public view returns(uint paymentTime, bool isReferral,\r\n                        uint fundDepositType_1, uint fundDepositType_2, uint fundDepositType_3,\r\n                        uint referrerBonus, uint numberReferral) {\r\n        (paymentTime, fundDepositType_1, fundDepositType_2, fundDepositType_3, referrerBonus, numberReferral) = m_investors.investorInfo(investorAddr);\r\n        isReferral = m_referrals[investorAddr];\r\n    }\r\n\r\n    function investorDividendsAtNow(address investorAddr) public view returns(uint dividends) {\r\n        dividends = calcDividends(investorAddr);\r\n    }\r\n\r\n    function doInvest(address referrerAddr, uint typeDeposit) public payable notFromContract balanceChanged {\r\n        uint investment = msg.value;\r\n        require(investment >= minInvesment, \"investment must be >= minInvesment\");\r\n        require(typeDeposit >= 0 && typeDeposit < 3, \"wrong deposit type\");\r\n\r\n        bool senderIsInvestor = m_investors.isInvestor(msg.sender);\r\n\r\n        if (referrerAddr.notZero() && !senderIsInvestor && !m_referrals[msg.sender] &&\r\n        referrerAddr != msg.sender && m_investors.isInvestor(referrerAddr)) {\r\n\r\n            m_referrals[msg.sender] = true;\r\n            m_investors.addReferral(referrerAddr);\r\n            uint countReferral = m_investors.getCountReferral(referrerAddr);\r\n            uint referrerBonus = 0;\r\n            uint referralBonus = 0;\r\n\r\n            if (countReferral <= 9) {\r\n                referrerBonus = m_3_referrer_percent.mmul(investment);\r\n                referralBonus = m_3_referal_percent.mmul(investment);\r\n            }\r\n            if (countReferral > 9 && countReferral <= 29) {\r\n                referrerBonus = m_4_referrer_percent.mmul(investment);\r\n                referralBonus = m_5_referal_percent.mmul(investment);\r\n            }\r\n            if (countReferral > 29) {\r\n                referrerBonus = m_5_referrer_percent.mmul(investment);\r\n                referralBonus = m_10_referal_percent.mmul(investment);\r\n            }\r\n\r\n            assert(m_investors.addInvestment(referrerAddr, referrerBonus, 10)); // add referrer bonus\r\n            assert(m_investors.addInvestment(msg.sender, referralBonus, 10)); // add referral bonus\r\n            emit LogNewReferral(msg.sender, referrerAddr, getCurrentDate(), referralBonus);\r\n        } else {\r\n            // commission\r\n            advertisingAddress.transfer(m_advertisingPercent.mul(investment));\r\n        }\r\n\r\n        // automatic reinvest - prevent burning dividends\r\n        uint dividends = calcDividends(msg.sender);\r\n        if (senderIsInvestor && dividends.notZero()) {\r\n            investment = investment.add(dividends);\r\n            emit LogAutomaticReinvest(msg.sender, getCurrentDate(), dividends, typeDeposit);\r\n        }\r\n\r\n        if (senderIsInvestor) {\r\n            // update existing investor\r\n            assert(m_investors.addInvestment(msg.sender, investment, typeDeposit));\r\n            assert(m_investors.setPaymentTime(msg.sender, getCurrentDate()));\r\n        } else {\r\n            // create new investor\r\n            assert(m_investors.newInvestor(msg.sender, investment, getCurrentDate(), typeDeposit));\r\n            emit LogNewInvestor(msg.sender, getCurrentDate(), typeDeposit);\r\n        }\r\n\r\n        investmentsNumber++;\r\n        totalEthRaised = totalEthRaised.add(msg.value);\r\n        emit LogNewInvesment(msg.sender, getCurrentDate(), investment, typeDeposit);\r\n    }\r\n\r\n    function getMemInvestor(address investorAddr) internal view returns(InvestorsStorage.Investor memory) {\r\n        (uint paymentTime,\r\n        uint fundDepositType_1, uint fundDepositType_2,\r\n        uint fundDepositType_3, uint referrerBonus, uint numberReferral) = m_investors.investorInfo(investorAddr);\r\n        return InvestorsStorage.Investor(paymentTime, fundDepositType_1, fundDepositType_2, fundDepositType_3, referrerBonus, numberReferral);\r\n    }\r\n\r\n    function getMyDividends() public payable notFromContract balanceChanged {\r\n        address payable investor = msg.sender;\r\n        require(investor.notZero(), \"require not zero address\");\r\n        uint currentTime = getCurrentDate();\r\n\r\n        uint receivedEther = msg.value;\r\n        require(receivedEther.isZero(), \"amount ETH must be 0\");\r\n\r\n        //check if 1 day passed after last payment\r\n        require(currentTime.sub(getMemInvestor(investor).paymentTime) > 24 hours, \"must pass 24 hours after the investment\");\r\n\r\n        // calculate dividends\r\n        uint dividends = calcDividends(msg.sender);\r\n        require (dividends.notZero(), \"cannot to pay zero dividends\");\r\n\r\n        m_investors.checkSetZeroFund(investor, currentTime);\r\n\r\n        // update investor payment timestamp\r\n        assert(m_investors.setPaymentTime(investor, currentTime));\r\n\r\n        // transfer dividends to investor\r\n        investor.transfer(dividends);\r\n        emit LogPayDividends(investor, currentTime, dividends);\r\n    }\r\n\r\n    function getMyReferrerBonus() public notFromContract balanceChanged {\r\n        uint referrerBonus = m_investors.getReferrerBonus(msg.sender);\r\n        require (referrerBonus.notZero(), \"cannot to pay zero referrer bonus\");\r\n\r\n        // transfer referrer bonus to investor\r\n        msg.sender.transfer(referrerBonus);\r\n        emit LogPayReferrerBonus(msg.sender, getCurrentDate(), referrerBonus);\r\n    }\r\n\r\n    function calcDividends(address investorAddress) internal view returns(uint dividends) {\r\n        InvestorsStorage.Investor memory inv = getMemInvestor(investorAddress);\r\n        dividends = 0;\r\n        uint fundDeposit = inv.fundDepositType_1.add(inv.fundDepositType_2).add(inv.fundDepositType_3);\r\n        uint numberDays = getCurrentDate().sub(inv.paymentTime) / 1 days;\r\n\r\n        // safe gas if dividends will be 0\r\n        if (fundDeposit.isZero() || numberDays.isZero()) {\r\n            return 0;\r\n        }\r\n\r\n        if (inv.fundDepositType_1 > 0) {\r\n            if (numberDays > 30) {\r\n                dividends = 30 * m_1_percent.mmul(inv.fundDepositType_1);\r\n                dividends = dividends.add(inv.fundDepositType_1);\r\n            } else {\r\n                dividends = numberDays * m_1_percent.mmul(inv.fundDepositType_1);\r\n            }\r\n        }\r\n        if (inv.fundDepositType_2 > 0) {\r\n            if (numberDays > 90) {\r\n                dividends = dividends.add(90 * m_2_percent.mmul(inv.fundDepositType_2));\r\n                dividends = dividends.add(inv.fundDepositType_2);\r\n            } else {\r\n                dividends = dividends.add(numberDays * m_2_percent.mmul(inv.fundDepositType_2));\r\n            }\r\n        }\r\n        if (inv.fundDepositType_3 > 0) {\r\n            if (numberDays > 180) {\r\n                dividends = dividends.add(180 * m_3_percent.mmul(inv.fundDepositType_3));\r\n                dividends = dividends.add(inv.fundDepositType_3);\r\n            } else {\r\n                dividends = dividends.add(numberDays * m_3_percent.mmul(inv.fundDepositType_3));\r\n            }\r\n        }\r\n    }\r\n\r\n    function getCurrentDate() public view returns (uint) {\r\n        if (isDemo) {\r\n            return simulateDate;\r\n        }\r\n        return now;\r\n    }\r\n\t\r\n    function setSimulateDate(uint256 _newDate) public onlyOwner {\r\n        if (isDemo) {\r\n            require(_newDate > simulateDate);\r\n            emit ChangeTime(_newDate, simulateDate);\r\n            simulateDate = _newDate;\r\n        } \r\n    }\r\n\r\n    function setDemo() public onlyOwner {\r\n        if (investorsNumber() == 0) {\r\n            isDemo = true;\r\n        }\r\n    }\r\n\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"simulateDate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"advertisingAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minInvesment\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"investorsNumber\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"setDemo\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newDate\",\"type\":\"uint256\"}],\"name\":\"setSimulateDate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"referrerAddr\",\"type\":\"address\"},{\"name\":\"typeDeposit\",\"type\":\"uint256\"}],\"name\":\"doInvest\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"investorAddr\",\"type\":\"address\"}],\"name\":\"investorDividendsAtNow\",\"outputs\":[{\"name\":\"dividends\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCurrentDate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"advertisingPercent\",\"outputs\":[{\"name\":\"numerator\",\"type\":\"uint256\"},{\"name\":\"denominator\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"investmentsNumber\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalEthRaised\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"setAdvertisingAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"getMyReferrerBonus\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"getMyDividends\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"investorAddr\",\"type\":\"address\"}],\"name\":\"investorInfo\",\"outputs\":[{\"name\":\"paymentTime\",\"type\":\"uint256\"},{\"name\":\"isReferral\",\"type\":\"bool\"},{\"name\":\"fundDepositType_1\",\"type\":\"uint256\"},{\"name\":\"fundDepositType_2\",\"type\":\"uint256\"},{\"name\":\"fundDepositType_3\",\"type\":\"uint256\"},{\"name\":\"referrerBonus\",\"type\":\"uint256\"},{\"name\":\"numberReferral\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isDemo\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"balanceETH\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_advertisingAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"referrerAddr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"when\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"referralBonus\",\"type\":\"uint256\"}],\"name\":\"LogNewReferral\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"when\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"investment\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"typeDeposit\",\"type\":\"uint256\"}],\"name\":\"LogNewInvesment\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"when\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"investment\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"typeDeposit\",\"type\":\"uint256\"}],\"name\":\"LogAutomaticReinvest\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"when\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"dividends\",\"type\":\"uint256\"}],\"name\":\"LogPayDividends\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"when\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"referrerBonus\",\"type\":\"uint256\"}],\"name\":\"LogPayReferrerBonus\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"when\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"typeDeposit\",\"type\":\"uint256\"}],\"name\":\"LogNewInvestor\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"when\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"balance\",\"type\":\"uint256\"}],\"name\":\"LogBalanceChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_newDate\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"simulateDate\",\"type\":\"uint256\"}],\"name\":\"ChangeTime\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerChanged\",\"type\":\"event\"}]","ContractName":"Ethbank","CompilerVersion":"v0.5.3+commit.10d17f24","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"0000000000000000000000000f9603569b7d9bdb9cb50f193f48875825b6a9e1","Library":"","SwarmSource":"bzzr://8e3405018eb7cffb29c2485baa02ff6987e8a3b6452a0820c44e767ac1d44e9a"}]}