{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.2;\r\n\r\n/*\r\n * Admin sets only for revealling address restricton\r\n */\r\ncontract RevealPrivilege {\r\n    address owner;\r\n    address public delegateAddr;\r\n    mapping(address => bool) public isAdmin;\r\n\r\n    modifier onlyAdmins() {\r\n        require(isAdmin[msg.sender] == true);\r\n        _;\r\n    }\r\n    \r\n    modifier isContractOwner() {\r\n        require(owner == msg.sender);\r\n        _;\r\n    }\r\n    \r\n    function addAdmin(address _addr) isContractOwner public {\r\n        isAdmin[_addr] = true;\r\n    }\r\n    \r\n    function removeAdmin(address _addr) isContractOwner public {\r\n        isAdmin[_addr] = false;\r\n    }\r\n    \r\n    function transferOwner(address _addr) isContractOwner public {\r\n        owner = _addr;\r\n    }\r\n    \r\n    function setdelegateAddr(address _addr) onlyAdmins public {\r\n        delegateAddr = _addr;\r\n    }\r\n}\r\n\r\ncontract FIH is RevealPrivilege {\r\n    using SafeMath for uint256;\r\n    \r\n    // constant value\r\n    uint256 constant withdrawalFee = 0.05 ether;\r\n    uint256 constant stake = 0.01 ether;\r\n    \r\n    uint256 public bonusCodeNonce;\r\n    uint16 public currentPeriod;\r\n    uint256 bonusPool;\r\n    uint256 public teamBonus;\r\n    \r\n    struct BonusCode {\r\n        uint8 prefix;\r\n        uint256 orderId;\r\n        uint256 code;\r\n        uint256 nums;\r\n        uint256 period;\r\n        address addr;\r\n    }\r\n    \r\n    //user balance\r\n    mapping(address => uint256) balanceOf;\r\n    mapping(address => bool) public allowance;\r\n    // _period => BonusCode\r\n    mapping(uint16 => BonusCode) public revealResultPerPeriod;\r\n    mapping(uint16 => uint256) revealBonusPerPeriod;\r\n    \r\n    mapping(address => BonusCode[]) revealInfoByAddr;\r\n\r\n    mapping(uint16 => uint256) gameBonusPerPeriod;\r\n    \r\n    mapping(uint16 => mapping(address => uint256)) invitedBonus; // period => address => amount\r\n    mapping(address => address) invitedRelations;\r\n\r\n    mapping(uint16 => mapping(uint8 => uint256)) sideTotalAmount; // period => prefix => amount\r\n    mapping(uint16 => mapping(uint256 => BonusCode)) public revealBonusCodes; // period => code => BonusCode\r\n    mapping(uint16 => uint256[]) bcodes; // period => code\r\n\r\n    event Bet(uint16 _currentPeriod, uint256 _orderId, uint256 _code, address _from);\r\n    event Deposit(address _from, address _to, uint256 _amount);\r\n    event Reveal(uint16 _currentPeriod, uint256 _orderId, uint256 _prefix, uint256 _code, address _addr, uint256 _winnerBonus);\r\n    event Withdrawal(address _to, uint256 _amount);\r\n\r\n    constructor () public {\r\n        owner = msg.sender;\r\n        isAdmin[owner] = true;\r\n        currentPeriod = 1;\r\n        bonusCodeNonce = 0;\r\n        bonusPool = 0;\r\n        teamBonus = 0;\r\n        gameBonusPerPeriod[currentPeriod] = 0;\r\n    }\r\n\r\n    function deposit(address _to) payable public { \r\n        require(msg.value > 0);\r\n        if (msg.sender != _to) {\r\n            require(msg.sender == delegateAddr, \"deposit can only from self-address or delegated address\");\r\n            allowance[_to] = true;\r\n        }\r\n        balanceOf[_to] = SafeMath.safeAdd(balanceOf[_to], msg.value);\r\n        emit Deposit(msg.sender, _to, msg.value);\r\n    }\r\n    \r\n    function bet(address _from, address _invitedAddr, uint256 _amount, uint8 _fType) public {\r\n        // validate\r\n        require(stake <= _amount  && _amount <= balanceOf[_from], \"amount should more than stake and less or equal to balance\");\r\n        if (msg.sender != _from) {\r\n            require(msg.sender == delegateAddr && allowance[_from] == true, \"permission rejected\");\r\n        }\r\n        if (_invitedAddr != address(0x0)) {\r\n             require(_from != _invitedAddr, \"bet _from is not equals _invitedAddr\");\r\n        }\r\n        \r\n        //handler balance and allowance\r\n        balanceOf[_from] = balanceOf[_from].safeSub(_amount);\r\n         \r\n        sideTotalAmount[currentPeriod][_fType] = sideTotalAmount[currentPeriod][_fType].safeAdd(_amount);\r\n        /* split amount */\r\n        //1. bonusPool\r\n        uint256 currentAmount = _amount;\r\n        uint256 gameBonusPercentVal = _amount.safeMul(20).safeDiv(100);\r\n        uint256 teamBonusPercentVal = _amount.safeMul(15).safeDiv(100);\r\n        uint256 bonusPoolPercentVal = _amount.safeMul(50).safeDiv(100);\r\n        \r\n        gameBonusPerPeriod[currentPeriod] = gameBonusPerPeriod[currentPeriod].safeAdd(gameBonusPercentVal);\r\n        currentAmount = currentAmount.safeSub(gameBonusPercentVal);\r\n        \r\n        teamBonus = teamBonus.safeAdd(teamBonusPercentVal);\r\n        currentAmount = currentAmount.safeSub(teamBonusPercentVal);\r\n        \r\n        bonusPool = bonusPool.safeAdd(bonusPoolPercentVal);\r\n        currentAmount = currentAmount.safeSub(bonusPoolPercentVal);\r\n        \r\n        //invited bonus \r\n        uint256 bonusLevelOne = _amount.safeMul(10).safeDiv(100);\r\n        uint256 bonusLevelTwo = _amount.safeMul(5).safeDiv(100);\r\n        \r\n        if(_invitedAddr != address(0x0)) {\r\n            invitedRelations[_from] = _invitedAddr;\r\n        }\r\n        if (invitedRelations[_from] != address(0x0)) {\r\n            address fa = invitedRelations[_from];\r\n            invitedBonus[currentPeriod][fa] = invitedBonus[currentPeriod][fa].safeAdd(bonusLevelOne);\r\n            balanceOf[fa] = balanceOf[fa].safeAdd(bonusLevelOne);\r\n            currentAmount = currentAmount.safeSub(bonusLevelOne);\r\n            address gfa = invitedRelations[fa];\r\n            if (gfa != address(0x0)) {\r\n               invitedBonus[currentPeriod][gfa] = invitedBonus[currentPeriod][gfa].safeAdd(bonusLevelTwo);\r\n               balanceOf[gfa] = balanceOf[gfa].safeAdd(bonusLevelTwo);\r\n               currentAmount = currentAmount.safeSub(bonusLevelTwo);\r\n            }\r\n        }\r\n        assert(currentAmount >= 0);\r\n        bonusPool = bonusPool.safeAdd(currentAmount);\r\n        \r\n        //generate order and bonusCodes\r\n        uint256 oId = block.timestamp;\r\n        \r\n        BonusCode memory bc = BonusCode({\r\n            orderId: oId,\r\n            prefix:  _fType,\r\n            code:    bonusCodeNonce,\r\n            nums:    _amount.safeDiv(stake),\r\n            addr:    _from, \r\n            period:  currentPeriod\r\n        });\r\n        revealBonusCodes[currentPeriod][bonusCodeNonce] = bc;\r\n        bcodes[currentPeriod].push(bonusCodeNonce);\r\n        emit Bet(currentPeriod, oId, bonusCodeNonce, _from);\r\n        bonusCodeNonce = bonusCodeNonce.safeAdd(_amount.safeDiv(stake));\r\n    }\r\n    \r\n    event Debug(uint256 winnerIndex, uint256 bcodesLen, uint256 pos);\r\n    function reveal(string memory _seed) public onlyAdmins {\r\n        // random winner index\r\n        \r\n        uint256 winner = uint256(keccak256(abi.encodePacked(_seed, msg.sender, block.timestamp))) % bonusCodeNonce;\r\n        uint256 lt = 0;\r\n        uint256 rt = bcodes[currentPeriod].length - 1;\r\n        require(lt <= rt, \"bcodes length is not correct\");\r\n        uint256 pos = lt;\r\n        while (lt <= rt) {\r\n            uint256 mid = lt + (rt - lt) / 2;\r\n            if (bcodes[currentPeriod][mid] <= winner) {\r\n                pos = mid;\r\n                lt = mid + 1;\r\n            } else {\r\n                rt = mid - 1;\r\n            }\r\n        }\r\n        emit Debug(winner, bcodes[currentPeriod].length, pos);\r\n        \r\n        \r\n        uint256 halfBonusPool = bonusPool.safeMul(50).safeDiv(100);\r\n        BonusCode memory winnerBcode = revealBonusCodes[currentPeriod][bcodes[currentPeriod][pos]];\r\n        \r\n        // iterate;  \r\n        uint256 bcodesLen = bcodes[currentPeriod].length;\r\n        for (uint256 i = 0; i < bcodesLen; i++) {\r\n            if (revealBonusCodes[currentPeriod][bcodes[currentPeriod][i]].prefix != winnerBcode.prefix) {\r\n                continue;\r\n            }\r\n            BonusCode memory thisBonusCode = revealBonusCodes[currentPeriod][bcodes[currentPeriod][i]];\r\n            if (thisBonusCode.addr == winnerBcode.addr && thisBonusCode.orderId == winnerBcode.orderId) {\r\n                balanceOf[winnerBcode.addr] = balanceOf[winnerBcode.addr].safeAdd(halfBonusPool);\r\n            } else {\r\n                uint256 bonusAmount = halfBonusPool.safeMul(\r\n                    thisBonusCode.nums.safeMul(stake).safeDiv(sideTotalAmount[currentPeriod][winnerBcode.prefix])\r\n                    );\r\n                balanceOf[thisBonusCode.addr] = balanceOf[thisBonusCode.addr].safeAdd(bonusAmount);\r\n            }\r\n        }\r\n        \r\n        // update reveal result && reset value\r\n        revealBonusPerPeriod[currentPeriod] = halfBonusPool;\r\n        revealResultPerPeriod[currentPeriod] = winnerBcode;\r\n        revealInfoByAddr[winnerBcode.addr].push(winnerBcode);\r\n        currentPeriod++;\r\n        bonusPool = 0;\r\n        bonusCodeNonce = 0;\r\n        gameBonusPerPeriod[currentPeriod] = 0;\r\n        \r\n        emit Reveal(currentPeriod - 1, winnerBcode.orderId, winnerBcode.prefix, winnerBcode.code, winnerBcode.addr, halfBonusPool);\r\n    }\r\n    \r\n    function withdrawal(address _from, address payable _to, uint256 _amount) public {\r\n        // permission check\r\n        if (msg.sender != _from) {\r\n            require(allowance[_from] == true && msg.sender == delegateAddr, \"permission rejected\");\r\n        }\r\n        // amount check\r\n        require(withdrawalFee <= _amount && _amount <= balanceOf[_from], \"Don't have enough balance\");\r\n        \r\n        balanceOf[_from] = balanceOf[_from].safeSub(_amount);\r\n        _amount = _amount.safeSub(withdrawalFee);\r\n        teamBonus = teamBonus.safeAdd(withdrawalFee);\r\n        \r\n\t  \t_to.transfer(_amount);\r\n\t    emit Withdrawal(_to, _amount);\r\n    }\r\n    \r\n    function teamWithdrawal() onlyAdmins public {\r\n        require(teamBonus > 0, \"Don't have enough teamBonus\");\r\n        uint256 tmp = teamBonus;\r\n        teamBonus = 0;\r\n        msg.sender.transfer(tmp);\r\n    }\r\n    \r\n    function gameBonusWithdrawal(uint16 _period) onlyAdmins public {\r\n        require(gameBonusPerPeriod[_period] > 0, \"Don't have enough money\");\r\n        uint256 tmp = gameBonusPerPeriod[_period];\r\n        gameBonusPerPeriod[_period] = 0;\r\n        msg.sender.transfer(tmp);\r\n    }\r\n    \r\n    function updateContract() isContractOwner public {\r\n        msg.sender.transfer(address(this).balance);\r\n    }\r\n    \r\n    /*\r\n     * read only part\r\n     * for query \r\n     */\r\n    function getBalance(address _addr) public view returns(uint256) {\r\n        return balanceOf[_addr];\r\n    }\r\n    \r\n    function getBonusPool() public view returns(uint256) {\r\n        return bonusPool;\r\n    }\r\n\r\n    function getBonusInvited(address _from) public view returns(uint256) {\r\n        return invitedBonus[currentPeriod][_from];\r\n    }\r\n    \r\n    function getRevealResultPerPeriod(uint16 _period) public view returns(uint8 _prefix, uint256 _orderId, uint256 _code, uint256 _nums, address _addr, uint256 _revealBonus) {\r\n        _prefix = revealResultPerPeriod[_period].prefix;\r\n        _orderId = revealResultPerPeriod[_period].orderId;\r\n        _code = revealResultPerPeriod[_period].code;\r\n        _nums = revealResultPerPeriod[_period].nums;\r\n        _addr = revealResultPerPeriod[_period].addr;\r\n        _revealBonus = revealBonusPerPeriod[_period];\r\n    }\r\n}\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Unsigned math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Multiplies two unsigned integers, reverts on overflow.\r\n     */\r\n    function safeMul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\r\n     */\r\n    function safeDiv(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n     */\r\n    function safeSub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Adds two unsigned integers, reverts on overflow.\r\n     */\r\n    function safeAdd(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\r\n     * reverts when dividing by zero.\r\n     */\r\n    function safeMod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdrawal\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentPeriod\",\"outputs\":[{\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"teamBonus\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"}],\"name\":\"getBonusInvited\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"removeAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"isAdmin\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_period\",\"type\":\"uint16\"}],\"name\":\"getRevealResultPerPeriod\",\"outputs\":[{\"name\":\"_prefix\",\"type\":\"uint8\"},{\"name\":\"_orderId\",\"type\":\"uint256\"},{\"name\":\"_code\",\"type\":\"uint256\"},{\"name\":\"_nums\",\"type\":\"uint256\"},{\"name\":\"_addr\",\"type\":\"address\"},{\"name\":\"_revealBonus\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint16\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"revealBonusCodes\",\"outputs\":[{\"name\":\"prefix\",\"type\":\"uint8\"},{\"name\":\"orderId\",\"type\":\"uint256\"},{\"name\":\"code\",\"type\":\"uint256\"},{\"name\":\"nums\",\"type\":\"uint256\"},{\"name\":\"period\",\"type\":\"uint256\"},{\"name\":\"addr\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"teamWithdrawal\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_seed\",\"type\":\"string\"}],\"name\":\"reveal\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"transferOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"addAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_invitedAddr\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_fType\",\"type\":\"uint8\"}],\"name\":\"bet\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"updateContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bonusCodeNonce\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getBonusPool\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint16\"}],\"name\":\"revealResultPerPeriod\",\"outputs\":[{\"name\":\"prefix\",\"type\":\"uint8\"},{\"name\":\"orderId\",\"type\":\"uint256\"},{\"name\":\"code\",\"type\":\"uint256\"},{\"name\":\"nums\",\"type\":\"uint256\"},{\"name\":\"period\",\"type\":\"uint256\"},{\"name\":\"addr\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"setdelegateAddr\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"delegateAddr\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"deposit\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"getBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_period\",\"type\":\"uint16\"}],\"name\":\"gameBonusWithdrawal\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_currentPeriod\",\"type\":\"uint16\"},{\"indexed\":false,\"name\":\"_orderId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_code\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_from\",\"type\":\"address\"}],\"name\":\"Bet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_currentPeriod\",\"type\":\"uint16\"},{\"indexed\":false,\"name\":\"_orderId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_prefix\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_code\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_winnerBonus\",\"type\":\"uint256\"}],\"name\":\"Reveal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"Withdrawal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"winnerIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"bcodesLen\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"pos\",\"type\":\"uint256\"}],\"name\":\"Debug\",\"type\":\"event\"}]","ContractName":"FIH","CompilerVersion":"v0.5.2+commit.1df8f40c","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://4eb2826c27ccd25b4191327c63875f69eb230bd31e827256d05cf5903f3d9eb2"}]}