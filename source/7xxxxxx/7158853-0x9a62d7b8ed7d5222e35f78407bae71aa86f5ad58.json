{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.23;\r\n\r\n\r\n\r\n\r\n\r\n// ----------------------------------------------------------------------------\r\ncontract ERC20 {\r\n\r\n    // ERC Token Standard #223 Interface\r\n    // https://github.com/ethereum/EIPs/issues/223\r\n\r\n    string public symbol;\r\n    string public  name;\r\n    uint8 public decimals;\r\n\r\n    function transfer(address _to, uint _value, bytes _data) external returns (bool success);\r\n\r\n    // approveAndCall\r\n    function approveAndCall(address spender, uint tokens, bytes data) external returns (bool success);\r\n\r\n    // ERC Token Standard #20 Interface\r\n    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md\r\n\r\n\r\n    function totalSupply() public constant returns (uint);\r\n    function balanceOf(address tokenOwner) public constant returns (uint balance);\r\n    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);\r\n    function transfer(address to, uint tokens) public returns (bool success);\r\n    function approve(address spender, uint tokens) public returns (bool success);\r\n    function transferFrom(address from, address to, uint tokens) public returns (bool success);\r\n    event Transfer(address indexed from, address indexed to, uint tokens);\r\n    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\r\n\r\n    // bulk operations\r\n    function transferBulk(address[] to, uint[] tokens) public;\r\n    function approveBulk(address[] spender, uint[] tokens) public;\r\n}\r\n\r\n\r\ninterface TokenRegistryInterface\r\n{\r\n    function getPriceInToken(ERC20 _tokenContract, uint128 priceWei) external view returns (uint128);\r\n    function areAllTokensAllowed(address[] _tokens) external view returns (bool);\r\n    function isTokenInList(address[] _allowedTokens, address _currentToken) external pure returns (bool);\r\n    function getAllSupportedTokens() external view returns (address[]);\r\n}\r\n\r\n\r\n\r\n// https://etherscan.io/address/0x3127be52acba38beab6b4b3a406dc04e557c037c#code\r\ncontract PriceOracleInterface {\r\n\r\n    // How much TOKENs you get for 1 ETH, multiplied by 10^18\r\n    uint256 public ETHPrice;\r\n}\r\n\r\npragma solidity ^0.4.18;\r\n\r\n\r\n\r\n\r\n\r\n/// @title Kyber Network interface\r\n/// https://raw.githubusercontent.com/KyberNetwork/smart-contracts/master/contracts/KyberNetworkProxyInterface.sol\r\ninterface KyberNetworkProxyInterface {\r\n    function maxGasPrice() external view returns(uint);\r\n    function getUserCapInWei(address user) external view returns(uint);\r\n    function getUserCapInTokenWei(address user, ERC20 token) external view returns(uint);\r\n    function enabled() external view returns(bool);\r\n    function info(bytes32 id) external view returns(uint);\r\n\r\n    function getExpectedRate(ERC20 src, ERC20 dest, uint srcQty) external view\r\n    returns (uint expectedRate, uint slippageRate);\r\n\r\n    function tradeWithHint(ERC20 src, uint srcAmount, ERC20 dest, address destAddress, uint maxDestAmount,\r\n        uint minConversionRate, address walletId, bytes hint) external payable returns(uint);\r\n}\r\n\r\n\r\n\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  constructor() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    require(newOwner != address(0));\r\n    emit OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n\r\n}\r\n\r\n\r\ncontract TokenRegistry is TokenRegistryInterface, Ownable\r\n{\r\n    mapping (address => PriceOracleInterface) public priceOracle;\r\n    address[] public allTokens;\r\n    address operatorAddress;\r\n    mapping (address => KyberNetworkProxyInterface) public kyberOracle;\r\n    ERC20 constant internal ETH_TOKEN_ADDRESS = ERC20(0x00eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee);\r\n\r\n    modifier onlyOperator() {\r\n        require(msg.sender == operatorAddress || msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    function setOperator(address _newOperator) public onlyOwner {\r\n        require(_newOperator != address(0));\r\n\r\n        operatorAddress = _newOperator;\r\n    }\r\n\r\n    function getAllSupportedTokens() external view returns (address[])\r\n    {\r\n        return allTokens;\r\n    }\r\n\r\n    function areAllTokensAllowed(address[] _tokens) external view returns (bool)\r\n    {\r\n        for (uint i = 0; i < _tokens.length; i++)\r\n        {\r\n            if (address(priceOracle[_tokens[i]]) == address(0x0))\r\n            {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    function getPriceInToken(ERC20 _tokenContract, uint128 priceWei)\r\n        external\r\n        view\r\n        returns (uint128)\r\n    {\r\n        if (address(kyberOracle[address(_tokenContract)]) != 0x0)\r\n        {\r\n            return getPriceInTokenKyber(_tokenContract, priceWei);\r\n        }\r\n        else\r\n        {\r\n            return getPriceInTokenCustom(_tokenContract, priceWei);\r\n        }\r\n    }\r\n\r\n    function getPriceInTokenCustom(ERC20 _tokenContract, uint128 priceWei)\r\n        internal\r\n        view\r\n        returns (uint128)\r\n    {\r\n        PriceOracleInterface oracle = priceOracle[address(_tokenContract)];\r\n        require(address(oracle) != address(0));\r\n\r\n        uint256 ethPerToken = oracle.ETHPrice();\r\n        int256 power = 36 - _tokenContract.decimals();\r\n        require(power > 0);\r\n        return uint128(uint256(priceWei) * ethPerToken / (10 ** uint256(power)));\r\n    }\r\n\r\n    function getPriceInTokenKyber(ERC20 _tokenContract, uint128 priceWei)\r\n        internal\r\n        view\r\n        returns (uint128)\r\n    {\r\n        KyberNetworkProxyInterface oracle = kyberOracle[address(_tokenContract)];\r\n        require(address(oracle) != address(0));\r\n\r\n        uint256 ethPerToken;\r\n        (, ethPerToken) = oracle.getExpectedRate(ETH_TOKEN_ADDRESS, _tokenContract, priceWei);\r\n        require(ethPerToken > 0);\r\n        int256 power = 36 - _tokenContract.decimals();\r\n        require(power > 0);\r\n        return uint128(uint256(priceWei) * ethPerToken / (10 ** uint256(power)));\r\n    }\r\n\r\n    function isTokenInList(address[] _allowedTokens, address _currentToken)\r\n        external\r\n        pure\r\n        returns (bool)\r\n    {\r\n        for (uint i = 0; i < _allowedTokens.length; i++)\r\n        {\r\n            if (_allowedTokens[i] == _currentToken)\r\n            {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /// @dev Allow buy cuties for token\r\n    function addToken(ERC20 _tokenContract, PriceOracleInterface _priceOracle) external onlyOwner\r\n    {\r\n        // check if not added yet\r\n        require(address(priceOracle[address(_tokenContract)]) == address(0x0));\r\n        require(address(kyberOracle[address(_tokenContract)]) == address(0x0));\r\n\r\n        priceOracle[address(_tokenContract)] = _priceOracle;\r\n        allTokens.push(_tokenContract);\r\n    }\r\n\r\n    /// @dev Allow buy cuties for token\r\n    function addKyberToken(ERC20 _tokenContract, KyberNetworkProxyInterface _priceOracle) external onlyOwner\r\n    {\r\n        // check if not added yet\r\n        require(address(priceOracle[address(_tokenContract)]) == address(0x0));\r\n        require(address(kyberOracle[address(_tokenContract)]) == address(0x0));\r\n\r\n        kyberOracle[address(_tokenContract)] = _priceOracle;\r\n        allTokens.push(_tokenContract);\r\n    }\r\n\r\n    /// @dev Disallow buy cuties for token\r\n    function removeToken(ERC20 _tokenContract) external onlyOwner\r\n    {\r\n        delete priceOracle[address(_tokenContract)];\r\n        delete kyberOracle[address(_tokenContract)];\r\n\r\n        uint256 kindex = 0;\r\n        while (kindex < allTokens.length)\r\n        {\r\n            if (address(allTokens[kindex]) == address(_tokenContract))\r\n            {\r\n                allTokens[kindex] = allTokens[allTokens.length-1];\r\n                allTokens.length--;\r\n            }\r\n            else\r\n            {\r\n                kindex++;\r\n            }\r\n        }\r\n    }\r\n\r\n    // @dev Transfers to _withdrawToAddress all tokens controlled by\r\n    // contract _tokenContract.\r\n    function withdrawTokenFromBalance(ERC20 _tokenContract, address _withdrawToAddress) external\r\n    {\r\n        require(\r\n            msg.sender == owner ||\r\n            msg.sender == operatorAddress\r\n        );\r\n        uint256 balance = _tokenContract.balanceOf(address(this));\r\n        _tokenContract.transfer(_withdrawToAddress, balance);\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"getAllSupportedTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenContract\",\"type\":\"address\"},{\"name\":\"_priceOracle\",\"type\":\"address\"}],\"name\":\"addKyberToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_allowedTokens\",\"type\":\"address[]\"},{\"name\":\"_currentToken\",\"type\":\"address\"}],\"name\":\"isTokenInList\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"priceOracle\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenContract\",\"type\":\"address\"},{\"name\":\"_priceOracle\",\"type\":\"address\"}],\"name\":\"addToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenContract\",\"type\":\"address\"}],\"name\":\"removeToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"allTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"kyberOracle\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokens\",\"type\":\"address[]\"}],\"name\":\"areAllTokensAllowed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenContract\",\"type\":\"address\"},{\"name\":\"priceWei\",\"type\":\"uint128\"}],\"name\":\"getPriceInToken\",\"outputs\":[{\"name\":\"\",\"type\":\"uint128\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOperator\",\"type\":\"address\"}],\"name\":\"setOperator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenContract\",\"type\":\"address\"},{\"name\":\"_withdrawToAddress\",\"type\":\"address\"}],\"name\":\"withdrawTokenFromBalance\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"TokenRegistry","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://bc341367663794d65fd05d38f34c59ffdd8b11c1fc84ee500dcde54fbf92ec14"}]}