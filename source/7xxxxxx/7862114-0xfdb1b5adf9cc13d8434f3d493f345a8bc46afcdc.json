{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\n// File: contracts/SafeMath32.sol\r\n\r\nlibrary SafeMath32 {\r\n\r\n  function mul(uint32 a, uint32 b) internal pure returns (uint32) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    uint32 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint32 a, uint32 b) internal pure returns (uint32) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint32 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesnâ€™t hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint32 a, uint32 b) internal pure returns (uint32) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint32 a, uint32 b) internal pure returns (uint32) {\r\n    uint32 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n// File: contracts/AraProxy.sol\r\n\r\n/**\r\n * @title AraProxy\r\n * @dev Gives the possibility to delegate any call to a foreign implementation.\r\n */\r\ncontract AraProxy {\r\n\r\n  bytes32 private constant registryPosition_ = keccak256(\"io.ara.proxy.registry\");\r\n  bytes32 private constant implementationPosition_ = keccak256(\"io.ara.proxy.implementation\");\r\n\r\n  modifier restricted() {\r\n    bytes32 registryPosition = registryPosition_;\r\n    address registryAddress;\r\n    assembly {\r\n      registryAddress := sload(registryPosition)\r\n    }\r\n    require(\r\n      msg.sender == registryAddress,\r\n      \"Only the AraRegistry can upgrade this proxy.\"\r\n    );\r\n    _;\r\n  }\r\n\r\n  /**\r\n  * @dev the constructor sets the AraRegistry address\r\n  */\r\n  constructor(address _registryAddress, address _implementationAddress) public {\r\n    bytes32 registryPosition = registryPosition_;\r\n    bytes32 implementationPosition = implementationPosition_;\r\n    assembly {\r\n      sstore(registryPosition, _registryAddress)\r\n      sstore(implementationPosition, _implementationAddress)\r\n    }\r\n  }\r\n\r\n  function setImplementation(address _newImplementation) public restricted {\r\n    require(_newImplementation != address(0));\r\n    bytes32 implementationPosition = implementationPosition_;\r\n    assembly {\r\n      sstore(implementationPosition, _newImplementation)\r\n    }\r\n  }\r\n\r\n  /**\r\n  * @dev Fallback function allowing to perform a delegatecall to the given implementation.\r\n  * This function will return whatever the implementation call returns\r\n  */\r\n  function () payable public {\r\n    bytes32 implementationPosition = implementationPosition_;\r\n    address _impl;\r\n    assembly {\r\n      _impl := sload(implementationPosition)\r\n    }\r\n\r\n    assembly {\r\n      let ptr := mload(0x40)\r\n      calldatacopy(ptr, 0, calldatasize)\r\n      let result := delegatecall(gas, _impl, ptr, calldatasize, 0, 0)\r\n      let size := returndatasize\r\n      returndatacopy(ptr, 0, size)\r\n\r\n      switch result\r\n      case 0 { revert(ptr, size) }\r\n      default { return(ptr, size) }\r\n    }\r\n  }\r\n}\r\n\r\n// File: contracts/ignored_contracts/Registry.sol\r\n\r\ncontract Registry {\r\n  address public owner_;\r\n  mapping (bytes32 => address) private proxies_; // contentId (unhashed) => proxy\r\n  mapping (bytes32 => address) private proxyOwners_; // contentId (unhashed) => owner\r\n  mapping (string => address) private versions_; // version => implementation\r\n  mapping (address => string) public proxyImpls_; // proxy => version\r\n  string public latestVersion_;\r\n\r\n  event ProxyDeployed(address indexed _owner, bytes32 indexed _contentId, address _address);\r\n  event ProxyUpgraded(bytes32 indexed _contentId, string indexed _version);\r\n  event StandardAdded(string indexed _version, address _address);\r\n\r\n  function init(bytes _data) public {\r\n    require(owner_ == address(0), 'Registry has already been initialized.');\r\n\r\n    uint256 btsptr;\r\n    address ownerAddr;\r\n    assembly {\r\n      btsptr := add(_data, 32)\r\n      ownerAddr := mload(btsptr)\r\n    }\r\n    owner_ = ownerAddr;\r\n  }\r\n\r\n  modifier restricted() {\r\n    require (\r\n      msg.sender == owner_,\r\n      \"Sender not authorized.\"\r\n    );\r\n    _;\r\n  }\r\n\r\n  modifier onlyProxyOwner(bytes32 _contentId) {\r\n    require(\r\n      proxyOwners_[_contentId] == msg.sender,\r\n      \"Sender not authorized.\"\r\n    );\r\n    _;\r\n  }\r\n\r\n  function getProxyAddress(bytes32 _contentId) public view returns (address) {\r\n    return proxies_[_contentId];\r\n  }\r\n\r\n  function getProxyOwner(bytes32 _contentId) public view returns (address) {\r\n    return proxyOwners_[_contentId];\r\n  }\r\n\r\n  function getImplementation(string _version) public view returns (address) {\r\n    return versions_[_version];\r\n  }\r\n\r\n  function getProxyVersion(bytes32 _contentId) public view returns (string) {\r\n    return proxyImpls_[getProxyAddress(_contentId)];\r\n  }\r\n  \r\n  /**\r\n   * @dev AFS Proxy Factory\r\n   * @param _contentId The unhashed methodless content DID\r\n   * @param _version The implementation version to use with this Proxy\r\n   * @param _data AFS initialization data\r\n   * @return address of the newly deployed Proxy\r\n   */\r\n  function createAFS(bytes32 _contentId, string _version, bytes _data) public {\r\n    require(proxies_[_contentId] == address(0), \"Proxy already exists for this content.\");\r\n    require(versions_[_version] != address(0), \"Version does not exist.\");\r\n    AraProxy proxy = new AraProxy(address(this), versions_[_version]);\r\n    proxies_[_contentId] = proxy;\r\n    proxyOwners_[_contentId] = msg.sender;\r\n    upgradeProxyAndCall(_contentId, _version, _data);\r\n    emit ProxyDeployed(msg.sender, _contentId, address(proxy));\r\n  }\r\n\r\n  /**\r\n   * @dev Upgrades proxy implementation version\r\n   * @param _contentId The unhashed methodless content DID\r\n   * @param _version The implementation version to upgrade this Proxy to\r\n   */\r\n  function upgradeProxy(bytes32 _contentId, string _version) public onlyProxyOwner(_contentId) {\r\n    require(versions_[_version] != address(0), \"Version does not exist.\");\r\n    AraProxy proxy = AraProxy(proxies_[_contentId]);\r\n    proxy.setImplementation(versions_[_version]);\r\n    proxyImpls_[proxies_[_contentId]] = _version;\r\n    emit ProxyUpgraded(_contentId, _version);\r\n  }\r\n\r\n  /**\r\n   * @dev Upgrades proxy implementation version with initialization\r\n   * @param _contentId The unhashed methodless content DID\r\n   * @param _version The implementation version to upgrade this Proxy to\r\n   * @param _data AFS initialization data\r\n   */\r\n  function upgradeProxyAndCall(bytes32 _contentId, string _version, bytes _data) public onlyProxyOwner(_contentId) {\r\n    require(versions_[_version] != address(0), \"Version does not exist.\");\r\n    require(keccak256(abi.encodePacked(proxyImpls_[proxy])) != keccak256(abi.encodePacked(_version)), \"Proxy is already on this version.\");\r\n    AraProxy proxy = AraProxy(proxies_[_contentId]);\r\n    proxy.setImplementation(versions_[_version]);\r\n    proxyImpls_[proxy] = _version;\r\n    require(address(proxy).call(abi.encodeWithSignature(\"init(bytes)\", _data)), \"Init failed.\");\r\n    emit ProxyUpgraded(_contentId, _version);\r\n  }\r\n\r\n  /**\r\n   * @dev Adds a new AFS implementation standard\r\n   * @param _version The implementation version name\r\n   * @param _address The address of the new AFS implementation\r\n   */\r\n  function addStandardVersion(string _version, address _address) public restricted {\r\n    require(versions_[_version] == address(0), \"Version already exists.\");\r\n    versions_[_version] = _address;\r\n    latestVersion_ = _version;\r\n    emit StandardAdded(_version, _address);\r\n  }\r\n}\r\n\r\n// File: contracts/ignored_contracts/Library.sol\r\n\r\ncontract Library {\r\n  using SafeMath32 for uint32;\r\n\r\n  address public owner_;\r\n  mapping (bytes32 => Lib) private libraries_; // hashed methodless owner did => library\r\n  Registry registry_;\r\n\r\n  struct Lib {\r\n    uint32 size;\r\n    mapping (uint32 => bytes32) content; // index => contentId (unhashed)\r\n  }\r\n\r\n  event AddedToLib(bytes32 indexed _identity, bytes32 indexed _contentId);\r\n\r\n  function init(bytes _data) public {\r\n    require(owner_ == address(0), 'Library has already been initialized.');\r\n\r\n    uint256 btsptr;\r\n    address ownerAddr;\r\n    address registryAddr;\r\n    assembly {\r\n      btsptr := add(_data, 32)\r\n      ownerAddr := mload(btsptr)\r\n      btsptr := add(_data, 64)\r\n      registryAddr := mload(btsptr)\r\n    }\r\n    owner_ = ownerAddr;\r\n    registry_ = Registry(registryAddr);\r\n  }\r\n\r\n  modifier restricted() {\r\n    require (msg.sender == owner_, \"Sender not authorized.\");\r\n     _;\r\n  }\r\n\r\n  modifier fromProxy(bytes32 _contentId) {\r\n    require (msg.sender == registry_.getProxyAddress(_contentId), \"Proxy not authorized.\");\r\n     _;\r\n  }\r\n\r\n  function getLibrarySize(bytes32 _identity) public view returns (uint32 size) {\r\n    return libraries_[_identity].size;\r\n  }\r\n\r\n  function getLibraryItem(bytes32 _identity, uint32 _index) public view returns (bytes32 contentId) {\r\n    require (_index < libraries_[_identity].size, \"Index does not exist.\");\r\n    return libraries_[_identity].content[_index];\r\n  }\r\n\r\n  function addLibraryItem(bytes32 _identity, bytes32 _contentId) public fromProxy(_contentId) {\r\n    uint32 libSize = libraries_[_identity].size;\r\n    assert (libraries_[_identity].content[libSize] == bytes32(0));\r\n    libraries_[_identity].content[libSize] = _contentId;\r\n    libraries_[_identity].size++;\r\n    emit AddedToLib(_identity, _contentId);\r\n  }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_identity\",\"type\":\"bytes32\"},{\"name\":\"_contentId\",\"type\":\"bytes32\"}],\"name\":\"addLibraryItem\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_identity\",\"type\":\"bytes32\"},{\"name\":\"_index\",\"type\":\"uint32\"}],\"name\":\"getLibraryItem\",\"outputs\":[{\"name\":\"contentId\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"init\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_identity\",\"type\":\"bytes32\"}],\"name\":\"getLibrarySize\",\"outputs\":[{\"name\":\"size\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner_\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_identity\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"_contentId\",\"type\":\"bytes32\"}],\"name\":\"AddedToLib\",\"type\":\"event\"}]","ContractName":"Library","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000e4127f775e738f30ca3672f62d0f63fd3aab66b800000000000000000000000017a6033535b1ab8cbbb430c62782d164d8f6ac45","Library":"","SwarmSource":"bzzr://b89f4596f8cd6e298e89cfabd69cab2f9a4904e1f3cd22ecb511f6d0241999d5"}]}