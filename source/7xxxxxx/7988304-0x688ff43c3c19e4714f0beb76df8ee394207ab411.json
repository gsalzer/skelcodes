{"status":"1","message":"OK","result":[{"SourceCode":"{\"AddressUtils.sol\":{\"content\":\"pragma solidity ^0.4.24;\\n\\n\\n/**\\n * Utility library of inline functions on addresses\\n */\\nlibrary AddressUtils {\\n\\n    /**\\n     * Returns whether the target address is a contract\\n     * @dev This function will return false if invoked during the constructor of a contract,\\n     * as the code is not actually created until after the constructor finishes.\\n     * @param _addr address to check\\n     * @return whether the target address is a contract\\n     */\\n    function isContract(address _addr) internal view returns (bool) {\\n        uint256 size;\\n        // XXX Currently there is no better way to check if there is a contract in an address\\n        // than to check the size of the code at that address.\\n        // See https://ethereum.stackexchange.com/a/14016/36603\\n        // for more details about how this works.\\n        // TODO Check this again before the Serenity release, because all addresses will be\\n        // contracts then.\\n        // solium-disable-next-line security/no-inline-assembly\\n        assembly { size := extcodesize(_addr) }\\n        return size \\u003e 0;\\n    }\\n\\n}\\n\"},\"Ownable.sol\":{\"content\":\"pragma solidity \\u003e=0.4.21 \\u003c0.6.0;\\n\\n\\n/**\\n * @title Ownable\\n * @dev The Ownable contract has an owner address, and provides basic authorization control\\n * functions, this simplifies the implementation of \\\"user permissions\\\". This adds two-phase\\n * ownership control to OpenZeppelin\\u0027s Ownable class. In this model, the original owner\\n * designates a new owner but does not actually transfer ownership. The new owner then accepts\\n * ownership and completes the transfer.\\n */\\ncontract Ownable {\\n    address _owner;\\n\\n    modifier onlyOwner() {\\n        require(isOwner(msg.sender), \\\"OwnerRole: caller does not have the Owner role\\\");\\n        _;\\n    }\\n\\n    function isOwner(address account) public view returns (bool) {\\n        return account == _owner;\\n    }\\n}\\n\"},\"Proxy.sol\":{\"content\":\"pragma solidity ^0.4.24;\\n\\n/**\\n * @title Proxy\\n * @dev Implements delegation of calls to other contracts, with proper\\n * forwarding of return values and bubbling of failures.\\n * It defines a fallback function that delegates all calls to the address\\n * returned by the abstract _implementation() internal function.\\n */\\ncontract Proxy {\\n    /**\\n     * @dev Fallback function.\\n     * Implemented entirely in `_fallback`.\\n     */\\n    function () payable external {\\n        _fallback();\\n    }\\n\\n    /**\\n     * @return The Address of the implementation.\\n     */\\n    function _implementation() internal view returns (address);\\n\\n    /**\\n     * @dev Delegates execution to an implementation contract.\\n     * This is a low level function that doesn\\u0027t return to its internal call site.\\n     * It will return to the external caller whatever the implementation returns.\\n     * @param implementation Address to delegate.\\n     */\\n    function _delegate(address implementation) internal {\\n        assembly {\\n        // Copy msg.data. We take full control of memory in this inline assembly\\n        // block because it will not return to Solidity code. We overwrite the\\n        // Solidity scratch pad at memory position 0.\\n            calldatacopy(0, 0, calldatasize)\\n\\n        // Call the implementation.\\n        // out and outsize are 0 because we don\\u0027t know the size yet.\\n            let result := delegatecall(gas, implementation, 0, calldatasize, 0, 0)\\n\\n        // Copy the returned data.\\n            returndatacopy(0, 0, returndatasize)\\n\\n            switch result\\n            // delegatecall returns 0 on error.\\n            case 0 { revert(0, returndatasize) }\\n            default { return(0, returndatasize) }\\n        }\\n    }\\n\\n    /**\\n     * @dev Function that is run as the first thing in the fallback function.\\n     * Can be redefined in derived contracts to add functionality.\\n     * Redefinitions must call super._willFallback().\\n     */\\n    function _willFallback() internal {\\n    }\\n\\n    /**\\n     * @dev fallback implementation.\\n     * Extracted to enable manual triggering.\\n     */\\n    function _fallback() internal {\\n        _willFallback();\\n        _delegate(_implementation());\\n    }\\n}\\n\"},\"SafeMath.sol\":{\"content\":\"pragma solidity ^0.4.24;\\n\\n\\n/**\\n * @title SafeMath\\n * @dev Math operations with safety checks that throw on error\\n */\\nlibrary SafeMath {\\n\\n    /**\\n    * @dev Multiplies two numbers, throws on overflow.\\n    */\\n    function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\\n        // Gas optimization: this is cheaper than asserting \\u0027a\\u0027 not being zero, but the\\n        // benefit is lost if \\u0027b\\u0027 is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\\n        if (_a == 0) {\\n            return 0;\\n        }\\n\\n        c = _a * _b;\\n        assert(c / _a == _b);\\n        return c;\\n    }\\n\\n    /**\\n    * @dev Integer division of two numbers, truncating the quotient.\\n    */\\n    function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\\n        // assert(_b \\u003e 0); // Solidity automatically throws when dividing by 0\\n        // uint256 c = _a / _b;\\n        // assert(_a == _b * c + _a % _b); // There is no case in which this doesn\\u0027t hold\\n        return _a / _b;\\n    }\\n\\n    /**\\n    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\\n    */\\n    function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\\n        assert(_b \\u003c= _a);\\n        return _a - _b;\\n    }\\n\\n    /**\\n    * @dev Adds two numbers, throws on overflow.\\n    */\\n    function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\\n        c = _a + _b;\\n        assert(c \\u003e= _a);\\n        return c;\\n    }\\n}\\n\"},\"TokenProxy.sol\":{\"content\":\"pragma solidity \\u003e=0.4.21 \\u003c0.6.0;\\n\\nimport \\\"./TokenStorage.sol\\\";\\nimport \\\"./UpgradeabilityProxy.sol\\\";\\nimport \\u0027./Ownable.sol\\u0027;\\n\\n/**\\n* @title TokenProxy\\n* @notice A proxy contract that serves the latest implementation of TokenProxy.\\n*/\\ncontract TokenProxy is UpgradeabilityProxy, Ownable {\\n    TokenStorage private dataStore;\\n\\n\\n    constructor(address _implementation, address storageAddress)\\n    UpgradeabilityProxy(_implementation)\\n    public {\\n        _owner = msg.sender;\\n        dataStore = TokenStorage(storageAddress);\\n    }\\n\\n    /**\\n    * @dev Upgrade the backing implementation of the proxy.\\n    * Only the admin can call this function.\\n    * @param newImplementation Address of the new implementation.\\n    */\\n    function upgradeTo(address newImplementation) public onlyOwner {\\n        _upgradeTo(newImplementation);\\n    }\\n\\n    /**\\n    * @return The address of the implementation.\\n    */\\n    function implementation() public view returns (address) {\\n        return _implementation();\\n    }\\n}\"},\"TokenStorage.sol\":{\"content\":\"pragma solidity \\u003e=0.4.21 \\u003c0.6.0;\\n\\nimport \\\"./SafeMath.sol\\\";\\nimport \\u0027./Ownable.sol\\u0027;\\n\\n/**\\n* @title TokenStorage\\n*/\\ncontract TokenStorage  is Ownable{\\n    using SafeMath for uint256;\\n\\n    //    mapping (address =\\u003e bool) internal _allowedAccess;\\n\\n    // Access Modifier for Storage contract\\n    address internal _registryContract;\\n\\n    constructor() public {\\n        _owner = msg.sender;\\n        _totalSupply = 1000000000 * 10 ** 18;\\n        _balances[_owner] = _totalSupply;\\n    }\\n\\n    function setProxyContractAndVersionOneDeligatee(address registryContract) onlyOwner public{\\n        require(registryContract != address(0), \\\"InvalidAddress: invalid address passed for proxy contract\\\");\\n        _registryContract = registryContract;\\n    }\\n\\n    function getRegistryContract() view public returns(address){\\n        return _registryContract;\\n    }\\n\\n    //    function addDeligateContract(address upgradedDeligatee) public{\\n    //        require(msg.sender == _registryContract, \\\"AccessDenied: only registry contract allowed access\\\");\\n    //        _allowedAccess[upgradedDeligatee] = true;\\n    //    }\\n\\n    modifier onlyAllowedAccess() {\\n        require(msg.sender == _registryContract, \\\"AccessDenied: This address is not allowed to access the storage\\\");\\n        _;\\n    }\\n\\n    // Allowances with its Getter and Setter\\n    mapping (address =\\u003e mapping (address =\\u003e uint256)) internal _allowances;\\n\\n    function setAllowance(address _tokenHolder, address _spender, uint256 _value) public onlyAllowedAccess {\\n        _allowances[_tokenHolder][_spender] = _value;\\n    }\\n\\n    function getAllowance(address _tokenHolder, address _spender) public view onlyAllowedAccess returns(uint256){\\n        return _allowances[_tokenHolder][_spender];\\n    }\\n\\n\\n    // Balances with its Getter and Setter\\n    mapping (address =\\u003e uint256) internal _balances;\\n    function addBalance(address _addr, uint256 _value) public onlyAllowedAccess {\\n        _balances[_addr] = _balances[_addr].add(_value);\\n    }\\n\\n    function subBalance(address _addr, uint256 _value) public onlyAllowedAccess {\\n        _balances[_addr] = _balances[_addr].sub(_value);\\n    }\\n\\n    function setBalance(address _addr, uint256 _value) public onlyAllowedAccess {\\n        _balances[_addr] = _value;\\n    }\\n\\n    function getBalance(address _addr) public view onlyAllowedAccess returns(uint256){\\n        return _balances[_addr];\\n    }\\n\\n    // Total Supply with Getter and Setter\\n    uint256 internal _totalSupply = 0;\\n\\n    function addTotalSupply(uint256 _value) public onlyAllowedAccess {\\n        _totalSupply = _totalSupply.add(_value);\\n    }\\n\\n    function subTotalSupply(uint256 _value) public onlyAllowedAccess {\\n        _totalSupply = _totalSupply.sub(_value);\\n    }\\n\\n    function setTotalSupply(uint256 _value) public onlyAllowedAccess {\\n        _totalSupply = _value;\\n    }\\n\\n    function getTotalSupply() public view onlyAllowedAccess returns(uint256) {\\n        return(_totalSupply);\\n    }\\n\\n\\n    // Locking Storage\\n    /**\\n    * @dev Reasons why a user\\u0027s tokens have been locked\\n    */\\n    mapping(address =\\u003e bytes32[]) internal lockReason;\\n\\n    /**\\n     * @dev locked token structure\\n     */\\n    struct lockToken {\\n        uint256 amount;\\n        uint256 validity;\\n        bool claimed;\\n    }\\n\\n    /**\\n     * @dev Holds number \\u0026 validity of tokens locked for a given reason for\\n     *      a specified address\\n     */\\n    mapping(address =\\u003e mapping(bytes32 =\\u003e lockToken)) internal locked;\\n\\n\\n    // Lock Access Functions\\n    function getLockedTokenAmount(address _of, bytes32 _reason) public view onlyAllowedAccess returns (uint256 amount){\\n        if (!locked[_of][_reason].claimed)\\n            amount = locked[_of][_reason].amount;\\n    }\\n\\n    function getLockedTokensAtTime(address _of, bytes32 _reason, uint256 _time) public view onlyAllowedAccess returns(uint256 amount){\\n        if (locked[_of][_reason].validity \\u003e _time)\\n            amount = locked[_of][_reason].amount;\\n    }\\n\\n    function getTotalLockedTokens(address _of) public view onlyAllowedAccess returns(uint256 amount){\\n        for (uint256 i = 0; i \\u003c lockReason[_of].length; i++) {\\n            amount = amount.add(getLockedTokenAmount(_of, lockReason[_of][i]));\\n        }\\n    }\\n\\n    function extendTokenLock(address _of, bytes32 _reason, uint256 _time) public onlyAllowedAccess returns(uint256 amount, uint256 validity){\\n\\n        locked[_of][_reason].validity = locked[_of][_reason].validity.add(_time);\\n        amount = locked[_of][_reason].amount;\\n        validity = locked[_of][_reason].validity;\\n    }\\n\\n    function increaseLockAmount(address _of, bytes32 _reason, uint256 _amount) public onlyAllowedAccess returns(uint256 amount, uint256 validity){\\n        locked[_of][_reason].amount = locked[_of][_reason].amount.add(_amount);\\n        amount = locked[_of][_reason].amount;\\n        validity = locked[_of][_reason].validity;\\n    }\\n\\n    function getUnlockable(address _of, bytes32 _reason) public view onlyAllowedAccess returns(uint256 amount){\\n        if (locked[_of][_reason].validity \\u003c= now \\u0026\\u0026 !locked[_of][_reason].claimed)\\n            amount = locked[_of][_reason].amount;\\n    }\\n\\n    function addLockedToken(address _of, bytes32 _reason, uint256 _amount, uint256 _validity) public onlyAllowedAccess {\\n        locked[_of][_reason] = lockToken(_amount, _validity, false);\\n    }\\n\\n    function addLockReason(address _of, bytes32 _reason) public onlyAllowedAccess {\\n        lockReason[_of].push(_reason);\\n    }\\n\\n    function getNumberOfLockReasons(address _of) public view onlyAllowedAccess returns(uint256 number){\\n        number = lockReason[_of].length;\\n    }\\n\\n    function getLockReason(address _of, uint256 _i) public view onlyAllowedAccess returns(bytes32 reason){\\n        reason = lockReason[_of][_i];\\n    }\\n\\n    function setClaimed(address _of, bytes32 _reason) public onlyAllowedAccess{\\n        locked[_of][_reason].claimed = true;\\n    }\\n\\n    function caller(address _of) public view  onlyAllowedAccess returns(uint){\\n        return getTotalLockedTokens(_of);\\n    }\\n}\"},\"UpgradeabilityProxy.sol\":{\"content\":\"pragma solidity ^0.4.24;\\n\\nimport \\u0027./Proxy.sol\\u0027;\\nimport \\u0027./AddressUtils.sol\\u0027;\\n\\n/**\\n * @title UpgradeabilityProxy\\n * @dev This contract implements a proxy that allows to change the\\n * implementation address to which it will delegate.\\n * Such a change is called an implementation upgrade.\\n */\\ncontract UpgradeabilityProxy is Proxy {\\n    /**\\n     * @dev Emitted when the implementation is upgraded.\\n     * @param implementation Address of the new implementation.\\n     */\\n    event Upgraded(address implementation);\\n\\n    /**\\n     * @dev Storage slot with the address of the current implementation.\\n     * This is the keccak-256 hash of \\\"org.zeppelinos.proxy.implementation\\\", and is\\n     * validated in the constructor.\\n     */\\n    bytes32 private constant IMPLEMENTATION_SLOT = 0x7050c9e0f4ca769c69bd3a8ef740bc37934f8e2c036e5a723fd8ee048ed3f8c3;\\n\\n    /**\\n     * @dev Contract constructor.\\n     * @param _implementation Address of the initial implementation.\\n     */\\n    constructor(address _implementation) public {\\n        assert(IMPLEMENTATION_SLOT == keccak256(\\\"org.zeppelinos.proxy.implementation\\\"));\\n\\n        _setImplementation(_implementation);\\n    }\\n\\n    /**\\n     * @dev Returns the current implementation.\\n     * @return Address of the current implementation\\n     */\\n    function _implementation() internal view returns (address impl) {\\n        bytes32 slot = IMPLEMENTATION_SLOT;\\n        assembly {\\n            impl := sload(slot)\\n        }\\n    }\\n\\n    /**\\n     * @dev Upgrades the proxy to a new implementation.\\n     * @param newImplementation Address of the new implementation.\\n     */\\n    function _upgradeTo(address newImplementation) internal {\\n        _setImplementation(newImplementation);\\n        emit Upgraded(newImplementation);\\n    }\\n\\n    /**\\n     * @dev Sets the implementation address of the proxy.\\n     * @param newImplementation Address of the new implementation.\\n     */\\n    function _setImplementation(address newImplementation) private {\\n        require(AddressUtils.isContract(newImplementation), \\\"Cannot set a proxy implementation to a non-contract address\\\");\\n\\n        bytes32 slot = IMPLEMENTATION_SLOT;\\n\\n        assembly {\\n            sstore(slot, newImplementation)\\n        }\\n    }\\n}\\n\"}}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newImplementation\",\"type\":\"address\"}],\"name\":\"upgradeTo\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"implementation\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_implementation\",\"type\":\"address\"},{\"name\":\"storageAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"implementation\",\"type\":\"address\"}],\"name\":\"Upgraded\",\"type\":\"event\"}]","ContractName":"TokenProxy","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000d48aab91f6de4c09a827eb83bfe1489d8b7245ae0000000000000000000000006da3b1c40cf4591fb55dccc09f22763e36a7db9e","Library":"","SwarmSource":"bzzr://0b5d2dadcad91f3b785d95eecc7b21ba1b82bcf44b9595b0277e96ea95490d45"}]}