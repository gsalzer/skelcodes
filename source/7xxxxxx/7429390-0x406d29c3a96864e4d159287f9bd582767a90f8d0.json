{"status":"1","message":"OK","result":[{"SourceCode":"/*\r\n * Copyright 2019 Authpaper Team\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\npragma solidity ^0.5.1;\r\n//import \"github.com/oraclize/ethereum-api/oraclizeAPI.sol\";\r\n\r\ncontract Adminstrator {\r\n  address public admin;\r\n  address payable public owner;\r\n\r\n  modifier onlyAdmin() { \r\n        require(msg.sender == admin || msg.sender == owner,\"Not authorized\"); \r\n        _;\r\n  } \r\n\r\n  constructor() public {\r\n    admin = msg.sender;\r\n\towner = msg.sender;\r\n  }\r\n\r\n  function transferAdmin(address newAdmin) public onlyAdmin {\r\n    admin = newAdmin; \r\n  }\r\n}\r\ncontract FiftyContract is Adminstrator {//,usingOraclize {\r\n    uint public mRate = 150 finney; //membership fee\r\n\tuint public membershiptime = 183 * 86400; //183 days, around 0.5 year\r\n\tuint public divideRadio = 49; //The divide ratio, each uplevel will get 0.48 by default\r\n\tmapping (address => uint) public membership;\r\n\tevent membershipExtended(address indexed _self, uint newexpiretime);\r\n\t\r\n\tstring public website=\"http://globalcfo.org/getAddresses.php?eth=\";\r\n\tstring public websiteGrand=\"http://globalcfo.org/getAddresses.php?grand=1&eth=\";\r\n\tmapping (bytes32 => treeNode) public oraclizeCallbacks;\r\n\t\r\n\t//About the tree\r\n\tevent completeTree(address indexed _self, uint indexed _nodeID, uint indexed _amount);\r\n\tevent startTree(address indexed _self, uint indexed _nodeID, uint indexed _amount);\r\n\tevent assignTreeNode(address indexed _self, uint indexed _nodeID, uint indexed _amount, address _root);\r\n\tevent distributeETH(address indexed _to, address _from, uint _amount);\r\n\t//Keep the nodeID they are using, (2 ** 32) - 1 means they are banned\r\n\tmapping (address => mapping (uint => uint)) public nodeIDIndex;\r\n\t//Keep children of a node, no matter the tree is completed or not\r\n\t//treeNode => mapping (uint => treeNode)\r\n\tmapping (address => mapping (uint => mapping (uint => mapping (uint => treeNode)))) public treeChildren;\r\n\tmapping (address => mapping (uint => mapping (uint => treeNode))) public treeParent;\r\n\t//Keep the current running nodes given an address\r\n\tmapping (address => mapping (uint => bool)) public currentNodes;\r\n\t//Temporary direct referral\r\n\tmapping (address => mapping (uint => mapping (uint => address))) public tempDirRefer;\r\n\tmapping (address => address) public tempSearchRefer;\r\n\tuint public spread=2;\r\n\tuint public minimumTreeNodeReferred=2;\r\n\tuint public minTreeType=1;\r\n\tuint public maxTreeType=4;\r\n\t\r\n\tstruct treeNode {\r\n\t\t address payable ethAddress; \r\n\t\t uint nodeType; \r\n\t\t uint nodeID;\r\n\t\t bool isDirectParent;\r\n\t}\r\n\tstruct rewardDistribution {\r\n\t\taddress payable first;\r\n\t\taddress payable second;\r\n\t}\r\n\t\r\n\t//Statistic issue\r\n\tuint256 public receivedAmount=0;\r\n\tuint256 public sentAmount=0;\r\n\tbool public paused=false;\r\n\tmapping (address => uint) public nodeLatestAction;\r\n\tmapping (address => uint) public nodeReceivedETH;\r\n\tmapping (address => mapping (uint => nodeAction)) public nodeActionHistory;\r\n\tstruct nodeAction {\r\n\t\tnodeActionType aType;\r\n\t\tuint8 nodePlace;\r\n\t\tuint256 treeType;\r\n\t}\r\n\tenum nodeActionType{\r\n\t\tjoinMember,\r\n\t\tstartTree,\r\n\t\taddNode,\r\n\t\tcompleteTree\r\n\t}\r\n\tevent Paused(address account);\r\n\tevent Unpaused(address account);\r\n\tevent makeQuery(address indexed account, string msg);\r\n\t\r\n\t//Setting the variables\r\n\tfunction setMembershipFee(uint newMrate, uint newTime) public onlyAdmin{\r\n\t\trequire(newMrate > 0, \"new rate must be positive\");\r\n\t\trequire(newTime > 0, \"new membership time must be positive\");\r\n\t\tmRate = newMrate * 10 ** uint256(15); //In finney\r\n\t\tmembershiptime = newTime * 86400; //In days\r\n\t\t\r\n\t}\r\n\tfunction setTreeSpec(uint newSpread, uint newDivideRate, uint newTreeNodeReferred) public onlyAdmin{\r\n\t\trequire(newSpread > 1, \"new spread must > 1\");\r\n\t\trequire(newDivideRate > 1, \"new divide level must > 1\");\r\n\t\trequire(newTreeNodeReferred > 1, \"new min tree nodes referred by root must > 1\");\r\n\t\tspread = newSpread;\r\n\t\tdivideRadio = newDivideRate;\r\n\t\tminimumTreeNodeReferred = newTreeNodeReferred;\r\n\t}\r\n\tfunction setWebAndTreeType(string memory web, string memory webGrand, uint minTreeSize, uint maxTreeSize) public onlyAdmin{\r\n\t\trequire(minTreeSize > 0, \"min tree size must > 0\");\r\n\t\trequire(maxTreeSize > minTreeSize, \"max tree size must > min\");\r\n\t\twebsite = web;\r\n\t\twebsiteGrand = webGrand;\r\n\t\tminTreeType = minTreeSize;\r\n\t\tmaxTreeType = maxTreeSize;\r\n\t}\r\n\tfunction pause(bool isPause) public onlyAdmin{\r\n\t\tpaused = isPause;\r\n\t\tif(isPause) emit Paused(msg.sender);\r\n\t\telse emit Unpaused(msg.sender);\r\n\t}\r\n\tfunction withdraw(uint amount) public onlyAdmin returns(bool) {\r\n        require(amount < address(this).balance);\r\n        owner.transfer(amount);\r\n        return true;\r\n    }\r\n    function withdrawAll() public onlyAdmin returns(bool) {\r\n        uint balanceOld = address(this).balance;\r\n        owner.transfer(balanceOld);\r\n        return true;\r\n    }\r\n\tfunction _addMember(address _member) internal {\r\n\t\trequire(_member != address(0));\r\n\t\tif(membership[_member] <= now) membership[_member] = now;\r\n\t\tmembership[_member] += membershiptime;\r\n\t\temit membershipExtended(_member,membership[_member]);\r\n\t\tnodeActionHistory[_member][nodeLatestAction[_member]] \r\n\t\t    = nodeAction(nodeActionType.joinMember,0,membership[_member]);\r\n\t\tnodeLatestAction[_member] +=1;\r\n\t}\r\n\tfunction addMember(address member) public onlyAdmin {\r\n\t\t_addMember(member);\r\n\t}\r\n\tfunction banMember(address member) public onlyAdmin {\r\n\t\trequire(member != address(0));\r\n\t\tmembership[member] = 0;\r\n\t}\r\n\tfunction checkMemberShip(address member) public view returns(uint) {\r\n\t\trequire(member != address(0));\r\n\t\treturn membership[member];\r\n\t}\r\n\t\r\n\tfunction testReturnDefault() public{\r\n\t\t__callback(bytes32(\"AAA\"),\"0xa5bc03ddc951966b0df385653fa5b7cadf1fc3da\");\r\n\t}\r\n\tfunction testReturnRoot() public{\r\n\t\t__callback(bytes32(\"AAA\"),\"0x22dc2c686e2e23af806aaa0c7c65f81e00adbc99\");\r\n\t}\r\n\tfunction testReturnRootGrand() public{\r\n\t\t__callback(bytes32(\"BBB\"),\"0x22dc2c686e2e23af806aaa0c7c65f81e00adbc99\");\r\n\t}\r\n\tfunction testReturnChild1() public{\r\n\t\t__callback(bytes32(\"AAA\"),\"0x44822c4b2f76d05d7e0749908021453d205275fc\");\r\n\t}\r\n\tfunction testReturnChild1Grand() public{\r\n\t\t__callback(bytes32(\"BBB\"),\"0x44822c4b2f76d05d7e0749908021453d205275fc\");\r\n\t}\r\n\t\r\n\tfunction() external payable { \r\n\t\trequire(!paused,\"The contract is paused\");\r\n\t\trequire(address(this).balance + msg.value > address(this).balance);\r\n\t\t\r\n\t\tuint newTreeType; uint reminder;\r\n\t\tfor(uint i=minTreeType;i<=maxTreeType;i++){\r\n\t\t    uint tti = i * 10 ** uint256(18);\r\n\t\t\tif(msg.value>=tti) newTreeType=tti;\r\n\t\t}\r\n\t\treminder = msg.value-newTreeType;\r\n\t\tif(newTreeType <minTreeType && msg.value == mRate){\r\n\t\t\t_addMember(msg.sender);\r\n\t\t\treturn;\r\n\t\t}\r\n\t\trequire(newTreeType >= (minTreeType *10 ** uint256(18)),\r\n\t\t    \"No tree can create\");\r\n\t\tif(reminder >= mRate){\r\n\t\t\t_addMember(msg.sender);\r\n\t\t\treminder -= mRate;\r\n\t\t}\r\n\t\t//require(msg.value >= 1 ether ,\"Not enough ETH\");\r\n\t\trequire(reminder <= msg.value, \"Too much reminder\");\r\n\t\trequire(membership[msg.sender] > now,\"Membership not valid\");\r\n\t\t//First of all, create a tree with this node as the root\r\n\t\taddress payable sender = msg.sender;\r\n\t\trequire(currentNodes[sender][newTreeType] == false,\"Started this kind of tree already\");\r\n\t\trequire(nodeIDIndex[sender][newTreeType] < (2 ** 32) -1,\"Banned from this kind of tree already\");\r\n\t\tcurrentNodes[sender][newTreeType] = true;\r\n\t\tnodeIDIndex[sender][newTreeType] += 1;\r\n\t\treceivedAmount += msg.value;\r\n\t\temit startTree(sender, nodeIDIndex[sender][newTreeType] - 1, newTreeType);\r\n\t\tif(reminder>0){\r\n\t\t\tsender.transfer(reminder);\r\n\t\t\tsentAmount +=reminder;\r\n\t\t}\r\n\t\tnodeActionHistory[sender][nodeLatestAction[sender]] = nodeAction(nodeActionType.startTree,0,newTreeType);\r\n\t\tnodeLatestAction[sender] +=1;\r\n\t\t//Make web call to find its uplines\r\n\t\t//Remember, each query burns 0.01 USD from the contract !!\r\n\t\tstring memory queryStr = strConcating(website,addressToString(sender));\r\n\t\temit makeQuery(msg.sender,\"Oraclize query sent\");\r\n\t\t//bytes32 queryId=oraclize_query(\"URL\", queryStr, 600000);\r\n\t\tbytes32 queryId=bytes32(\"AAA\");\r\n        oraclizeCallbacks[queryId] = \r\n\t\t\ttreeNode(msg.sender,newTreeType,nodeIDIndex[msg.sender][newTreeType] - 1,true);\r\n\t}\r\n\tfunction __callback(bytes32 myid, string memory result) public {\r\n        //if (msg.sender != oraclize_cbAddress()) revert();\r\n        treeNode memory o = oraclizeCallbacks[myid];\r\n\t\tbytes memory _baseBytes = bytes(result);\r\n\t\trequire(_baseBytes.length == 42, \"The return string is not valid\");\r\n\t\taddress payable firstUpline=parseAddrFromStr(result);\r\n\t\trequire(firstUpline != address(0), \"The firstUpline is incorrect\");\r\n\t\t\r\n\t\tuint treeType = o.nodeType;\r\n\t\taddress payable treeRoot = o.ethAddress;\r\n\t\tuint treeNodeID = o.nodeID;\r\n\t\t//If this has been searched before\r\n\t\tif(tempSearchRefer[treeRoot] == firstUpline || firstUpline == owner) return;\r\n\t\tif(o.isDirectParent) tempDirRefer[treeRoot][treeType][treeNodeID] = firstUpline;\r\n\t\t//Now check its parent for a place for node\r\n\t\trewardDistribution memory rewardResult = _placeChildTree(firstUpline,treeType,treeRoot,treeNodeID);\r\n\t\tif(rewardResult.first == address(0)){\r\n\t\t\t//Search not successful, find upline\r\n\t\t\ttempSearchRefer[treeRoot] = firstUpline;\r\n\t\t\tstring memory queryStr = strConcating(websiteGrand,result);\r\n\t\t\temit makeQuery(msg.sender,\"Oraclize query sent\");\r\n\t\t\t//bytes32 queryId=oraclize_query(\"URL\", queryStr, 600000);\r\n\t\t\tbytes32 queryId=bytes32(\"BBB\");\r\n            oraclizeCallbacks[queryId] = treeNode(treeRoot,treeType,treeNodeID,false);            \r\n\t\t\treturn;\r\n\t\t}\r\n\t\ttempSearchRefer[treeRoot] = address(0);\r\n\t\temit assignTreeNode(treeRoot,treeNodeID,treeType,rewardResult.first);\r\n\t\t//Distribute the award\r\n\t\tuint moneyToDistribute = (treeType * divideRadio) / 100;\r\n\t\trequire(treeType >= 2*moneyToDistribute, \"Too much ether to send\");\r\n\t\trequire(address(this).balance > treeType, \"Nothing to send\");\r\n\t\tuint previousBalances = address(this).balance;\r\n\t\tif(rewardResult.first != address(0)){\r\n\t\t\trewardResult.first.transfer(moneyToDistribute);\r\n\t\t\tsentAmount += moneyToDistribute;\r\n\t\t\tnodeReceivedETH[rewardResult.first] += moneyToDistribute;\r\n\t\t\temit distributeETH(rewardResult.first, treeRoot, moneyToDistribute);\r\n\t\t} \r\n\t\tif(rewardResult.second != address(0)){\r\n\t\t\trewardResult.second.transfer(moneyToDistribute);\r\n\t\t\tsentAmount += moneyToDistribute;\r\n\t\t\tnodeReceivedETH[rewardResult.second] += moneyToDistribute;\r\n\t\t\temit distributeETH(rewardResult.second, treeRoot, moneyToDistribute);\r\n\t\t}\r\n\t\t// Asserts are used to use static analysis to find bugs in your code. They should never fail\r\n        assert(address(this).balance + (2*moneyToDistribute) >= previousBalances);\r\n    }\r\n\tfunction _placeChildTree(address payable firstUpline, uint treeType, address payable treeRoot, uint treeNodeID) internal returns(rewardDistribution memory) {\r\n\t\t//We do BFS here, so need to search layer by layer\r\n\t\taddress payable getETHOne = address(0); address payable getETHTwo = address(0);\r\n\t\tuint8 firstLevelSearch=_placeChild(firstUpline,treeType,treeRoot,treeNodeID); \r\n\t\tif(firstLevelSearch == 1){\r\n\t\t\tgetETHOne=firstUpline;\r\n\t\t\tuint cNodeID=nodeIDIndex[firstUpline][treeType] - 1;\r\n\t\t\tnodeActionHistory[getETHOne][nodeLatestAction[getETHOne]] = nodeAction(nodeActionType.addNode,1,treeType);\r\n\t\t\tnodeLatestAction[getETHOne] +=1;\r\n\t\t\t//So the firstUpline will get the money, as well as the parent of the firstUpline\r\n\t\t\tif(treeParent[firstUpline][treeType][cNodeID].nodeType != 0){\r\n\t\t\t\tgetETHTwo = treeParent[firstUpline][treeType][cNodeID].ethAddress;\r\n\t\t\t\tnodeActionHistory[getETHTwo][nodeLatestAction[getETHTwo]] = nodeAction(nodeActionType.addNode,2,treeType);\r\n\t\t\t\tnodeLatestAction[getETHTwo] +=1;\r\n\t\t\t}\r\n\t\t}\r\n\t\t//The same address has been here before\r\n\t\tif(firstLevelSearch == 2) return rewardDistribution(address(0),address(0));\r\n\t\tif(getETHOne == address(0)){\r\n\t\t\t//Now search the grandchildren of the firstUpline for a place\r\n\t\t\tif(currentNodes[firstUpline][treeType] && nodeIDIndex[firstUpline][treeType] <(2 ** 32) -1){\r\n\t\t\t\tuint cNodeID=nodeIDIndex[firstUpline][treeType] - 1;\r\n\t\t\t\tfor (uint256 i=0; i < spread; i++) {\r\n\t\t\t\t\tif(treeChildren[firstUpline][treeType][cNodeID][i].nodeType != 0){\r\n\t\t\t\t\t\ttreeNode memory kids = treeChildren[firstUpline][treeType][cNodeID][i];\r\n\t\t\t\t\t\tif(_placeChild(kids.ethAddress,treeType,treeRoot,treeNodeID) == 1){\r\n\t\t\t\t\t\t\tgetETHOne=kids.ethAddress;\r\n\t\t\t\t\t\t\t//So the child of firstUpline will get the money, as well as the child\r\n\t\t\t\t\t\t\tgetETHTwo = firstUpline;\r\n\t\t\t\t\t\t\tnodeActionHistory[getETHOne][nodeLatestAction[getETHOne]] = nodeAction(nodeActionType.addNode,1,treeType);\r\n\t\t\t\t\t\t\tnodeLatestAction[getETHOne] +=1;\r\n\t\t\t\t\t\t\tnodeActionHistory[getETHTwo][nodeLatestAction[getETHTwo]] = nodeAction(nodeActionType.addNode,2,treeType);\r\n\t\t\t\t\t\t\tnodeLatestAction[getETHTwo] +=1;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn rewardDistribution(getETHOne,getETHTwo);\r\n\t}\r\n\t//Return 0, there is no place for the node, 1, there is a place and placed, 2, duplicate node is found\r\n\tfunction _placeChild(address payable firstUpline, uint treeType, address payable treeRoot, uint treeNodeID) internal returns(uint8) {\r\n\t\tif(currentNodes[firstUpline][treeType] && nodeIDIndex[firstUpline][treeType] <(2 ** 32) -1){\r\n\t\t\tuint cNodeID=nodeIDIndex[firstUpline][treeType] - 1;\r\n\t\t\tfor (uint256 i=0; i < spread; i++) {\r\n\t\t\t\tif(treeChildren[firstUpline][treeType][cNodeID][i].nodeType == 0){\r\n\t\t\t\t\t//firstUpline has a place\r\n\t\t\t\t\ttreeChildren[firstUpline][treeType][cNodeID][i]\r\n\t\t\t\t\t\t= treeNode(treeRoot,treeType,treeNodeID,false);\r\n\t\t\t\t\t//Set parent\r\n\t\t\t\t\ttreeParent[treeRoot][treeType][treeNodeID] \r\n\t\t\t\t\t\t= treeNode(firstUpline,treeType,cNodeID,false);\r\n\t\t\t\t\t_checkTreeComplete(firstUpline,treeType,cNodeID);\r\n\t\t\t\t\treturn 1;\r\n\t\t\t\t}else{\r\n\t\t\t\t    treeNode memory kids = treeChildren[firstUpline][treeType][cNodeID][i];\r\n\t\t\t\t    //The child has been here in previous project\r\n\t\t\t\t    if(kids.ethAddress == treeRoot) return 2;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn 0;\r\n\t}\r\n\tfunction _checkTreeComplete(address _root, uint _treeType, uint _nodeID) internal {\r\n\t\trequire(_root != address(0), \"Tree root to check completness is 0\");\r\n\t\tbool _isCompleted = true;\r\n\t\tuint _isDirectRefCount = 0;\r\n\t\tfor (uint256 i=0; i < spread; i++) {\r\n\t\t\tif(treeChildren[_root][_treeType][_nodeID][i].nodeType == 0){\r\n\t\t\t\t_isCompleted = false;\r\n\t\t\t\tbreak;\r\n\t\t\t}else{\r\n\t\t\t\t//Search the grandchildren\r\n\t\t\t\ttreeNode memory _child = treeChildren[_root][_treeType][_nodeID][i];\r\n\t\t\t\taddress referral = tempDirRefer[_child.ethAddress][_child.nodeType][_child.nodeID];\r\n\t\t\t\tif(referral == _root) _isDirectRefCount += 1;\r\n\t\t\t\tfor (uint256 a=0; a < spread; a++) {\r\n\t\t\t\t\tif(treeChildren[_child.ethAddress][_treeType][_child.nodeID][a].nodeType == 0){\r\n\t\t\t\t\t\t_isCompleted = false;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}else{\r\n\t\t\t\t\t\ttreeNode memory _gChild=treeChildren[_child.ethAddress][_treeType][_child.nodeID][a];\r\n\t\t\t\t\t\taddress referral2 = tempDirRefer[_gChild.ethAddress][_gChild.nodeType][_gChild.nodeID];\r\n\t\t\t\t\t\tif(referral2 == _root) _isDirectRefCount += 1;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif(!_isCompleted) break;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif(!_isCompleted) return;\r\n\t\t//The tree is completed, root can start over again\r\n\t\tcurrentNodes[_root][_treeType] = false;\r\n\t\t//Ban this user\r\n\t\tif(_isDirectRefCount <= minimumTreeNodeReferred) nodeIDIndex[_root][_treeType] = (2 ** 32) -1;\r\n\t\tnodeActionHistory[_root][nodeLatestAction[_root]] = nodeAction(nodeActionType.completeTree,0,_treeType);\r\n\t\tnodeLatestAction[_root] +=1;\r\n\t}\r\n    function strConcating(string memory _a, string memory _b) internal pure returns (string memory){\r\n        bytes memory _ba = bytes(_a);\r\n        bytes memory _bb = bytes(_b);\r\n        string memory ab = new string(_ba.length + _bb.length);\r\n        bytes memory bab = bytes(ab);\r\n        uint k = 0;\r\n        for (uint i = 0; i < _ba.length; i++) bab[k++] = _ba[i];\r\n        for (uint i = 0; i < _bb.length; i++) bab[k++] = _bb[i];\r\n        return string(bab);\r\n    }\r\n    function addressToString(address _addr) public pure returns(string memory) {\r\n        bytes32 value = bytes32(uint256(_addr));\r\n        bytes memory alphabet = \"0123456789abcdef\";    \r\n        bytes memory str = new bytes(42);\r\n        str[0] = '0';\r\n        str[1] = 'x';\r\n        for (uint i = 0; i < 20; i++) {\r\n            str[2+i*2] = alphabet[uint8(value[i + 12] >> 4)];\r\n            str[3+i*2] = alphabet[uint8(value[i + 12] & 0x0f)];\r\n        }\r\n        return string(str);\r\n    }\r\n\r\n      function parseAddrFromStr(string memory _a) internal pure returns (address payable){\r\n         bytes memory tmp = bytes(_a);\r\n         uint160 iaddr = 0;\r\n         uint160 b1;\r\n         uint160 b2;\r\n         for (uint i=2; i<2+2*20; i+=2){\r\n             iaddr *= 256;\r\n             b1 = uint8(tmp[i]);\r\n             b2 = uint8(tmp[i+1]);\r\n             if ((b1 >= 97)&&(b1 <= 102)) b1 -= 87;\r\n             else if ((b1 >= 48)&&(b1 <= 57)) b1 -= 48;\r\n             if ((b2 >= 97)&&(b2 <= 102)) b2 -= 87;\r\n             else if ((b2 >= 48)&&(b2 <= 57)) b2 -= 48;\r\n             iaddr += (b1*16+b2);\r\n         }\r\n         return address(iaddr);\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"isPause\",\"type\":\"bool\"}],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"testReturnRootGrand\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"websiteGrand\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"treeChildren\",\"outputs\":[{\"name\":\"ethAddress\",\"type\":\"address\"},{\"name\":\"nodeType\",\"type\":\"uint256\"},{\"name\":\"nodeID\",\"type\":\"uint256\"},{\"name\":\"isDirectParent\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newSpread\",\"type\":\"uint256\"},{\"name\":\"newDivideRate\",\"type\":\"uint256\"},{\"name\":\"newTreeNodeReferred\",\"type\":\"uint256\"}],\"name\":\"setTreeSpec\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"nodeReceivedETH\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"myid\",\"type\":\"bytes32\"},{\"name\":\"result\",\"type\":\"string\"}],\"name\":\"__callback\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tempDirRefer\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"member\",\"type\":\"address\"}],\"name\":\"checkMemberShip\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"nodeActionHistory\",\"outputs\":[{\"name\":\"aType\",\"type\":\"uint8\"},{\"name\":\"nodePlace\",\"type\":\"uint8\"},{\"name\":\"treeType\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"mRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"oraclizeCallbacks\",\"outputs\":[{\"name\":\"ethAddress\",\"type\":\"address\"},{\"name\":\"nodeType\",\"type\":\"uint256\"},{\"name\":\"nodeID\",\"type\":\"uint256\"},{\"name\":\"isDirectParent\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"nodeLatestAction\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"spread\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"addressToString\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"treeParent\",\"outputs\":[{\"name\":\"ethAddress\",\"type\":\"address\"},{\"name\":\"nodeType\",\"type\":\"uint256\"},{\"name\":\"nodeID\",\"type\":\"uint256\"},{\"name\":\"isDirectParent\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"membershiptime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"transferAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"membership\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minimumTreeNodeReferred\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minTreeType\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"testReturnRoot\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawAll\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"receivedAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"currentNodes\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"testReturnDefault\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"nodeIDIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxTreeType\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"divideRadio\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newMrate\",\"type\":\"uint256\"},{\"name\":\"newTime\",\"type\":\"uint256\"}],\"name\":\"setMembershipFee\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"website\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"tempSearchRefer\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"member\",\"type\":\"address\"}],\"name\":\"addMember\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"member\",\"type\":\"address\"}],\"name\":\"banMember\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"sentAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"web\",\"type\":\"string\"},{\"name\":\"webGrand\",\"type\":\"string\"},{\"name\":\"minTreeSize\",\"type\":\"uint256\"},{\"name\":\"maxTreeSize\",\"type\":\"uint256\"}],\"name\":\"setWebAndTreeType\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"testReturnChild1Grand\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"testReturnChild1\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_self\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newexpiretime\",\"type\":\"uint256\"}],\"name\":\"membershipExtended\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_self\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_nodeID\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"completeTree\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_self\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_nodeID\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"startTree\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_self\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_nodeID\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_root\",\"type\":\"address\"}],\"name\":\"assignTreeNode\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"distributeETH\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"msg\",\"type\":\"string\"}],\"name\":\"makeQuery\",\"type\":\"event\"}]","ContractName":"FiftyContract","CompilerVersion":"v0.5.3+commit.10d17f24","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://6884bbafba9284bac3b09ff22515c07b636f27cde7692514f279eb4629caa729"}]}