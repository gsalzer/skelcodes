{"status":"1","message":"OK","result":[{"SourceCode":"// Verified using https://dapp.tools\n\n// hevm: flattened sources of src/DexC2CGateway.sol\npragma solidity ^0.4.24;\n\n////// lib/ds-auth/src/auth.sol\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n/* pragma solidity >=0.4.23; */\n\ncontract DSAuthority {\n    function canCall(\n        address src, address dst, bytes4 sig\n    ) public view returns (bool);\n}\n\ncontract DSAuthEvents {\n    event LogSetAuthority (address indexed authority);\n    event LogSetOwner     (address indexed owner);\n}\n\ncontract DSAuth is DSAuthEvents {\n    DSAuthority  public  authority;\n    address      public  owner;\n\n    constructor() public {\n        owner = msg.sender;\n        emit LogSetOwner(msg.sender);\n    }\n\n    function setOwner(address owner_)\n        public\n        auth\n    {\n        owner = owner_;\n        emit LogSetOwner(owner);\n    }\n\n    function setAuthority(DSAuthority authority_)\n        public\n        auth\n    {\n        authority = authority_;\n        emit LogSetAuthority(address(authority));\n    }\n\n    modifier auth {\n        require(isAuthorized(msg.sender, msg.sig), \"ds-auth-unauthorized\");\n        _;\n    }\n\n    function isAuthorized(address src, bytes4 sig) internal view returns (bool) {\n        if (src == address(this)) {\n            return true;\n        } else if (src == owner) {\n            return true;\n        } else if (authority == DSAuthority(0)) {\n            return false;\n        } else {\n            return authority.canCall(src, address(this), sig);\n        }\n    }\n}\n\n////// lib/ds-math/src/math.sol\n/// math.sol -- mixin for inline numerical wizardry\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n/* pragma solidity >0.4.13; */\n\ncontract DSMath {\n    function add(uint x, uint y) internal pure returns (uint z) {\n        require((z = x + y) >= x, \"ds-math-add-overflow\");\n    }\n    function sub(uint x, uint y) internal pure returns (uint z) {\n        require((z = x - y) <= x, \"ds-math-sub-underflow\");\n    }\n    function mul(uint x, uint y) internal pure returns (uint z) {\n        require(y == 0 || (z = x * y) / y == x, \"ds-math-mul-overflow\");\n    }\n\n    function min(uint x, uint y) internal pure returns (uint z) {\n        return x <= y ? x : y;\n    }\n    function max(uint x, uint y) internal pure returns (uint z) {\n        return x >= y ? x : y;\n    }\n    function imin(int x, int y) internal pure returns (int z) {\n        return x <= y ? x : y;\n    }\n    function imax(int x, int y) internal pure returns (int z) {\n        return x >= y ? x : y;\n    }\n\n    uint constant WAD = 10 ** 18;\n    uint constant RAY = 10 ** 27;\n\n    function wmul(uint x, uint y) internal pure returns (uint z) {\n        z = add(mul(x, y), WAD / 2) / WAD;\n    }\n    function rmul(uint x, uint y) internal pure returns (uint z) {\n        z = add(mul(x, y), RAY / 2) / RAY;\n    }\n    function wdiv(uint x, uint y) internal pure returns (uint z) {\n        z = add(mul(x, WAD), y / 2) / y;\n    }\n    function rdiv(uint x, uint y) internal pure returns (uint z) {\n        z = add(mul(x, RAY), y / 2) / y;\n    }\n\n    // This famous algorithm is called \"exponentiation by squaring\"\n    // and calculates x^n with x as fixed-point and n as regular unsigned.\n    //\n    // It's O(log n), instead of O(n) for naive repeated multiplication.\n    //\n    // These facts are why it works:\n    //\n    //  If n is even, then x^n = (x^2)^(n/2).\n    //  If n is odd,  then x^n = x * x^(n-1),\n    //   and applying the equation for even x gives\n    //    x^n = x * (x^2)^((n-1) / 2).\n    //\n    //  Also, EVM division is flooring and\n    //    floor[(n-1) / 2] = floor[n / 2].\n    //\n    function rpow(uint x, uint n) internal pure returns (uint z) {\n        z = n % 2 != 0 ? x : RAY;\n\n        for (n /= 2; n != 0; n /= 2) {\n            x = rmul(x, x);\n\n            if (n % 2 != 0) {\n                z = rmul(z, x);\n            }\n        }\n    }\n}\n\n////// lib/ds-token/lib/ds-stop/lib/ds-note/src/note.sol\n/// note.sol -- the `note' modifier, for logging calls as events\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n/* pragma solidity >=0.4.23; */\n\ncontract DSNote {\n    event LogNote(\n        bytes4   indexed  sig,\n        address  indexed  guy,\n        bytes32  indexed  foo,\n        bytes32  indexed  bar,\n        uint256           wad,\n        bytes             fax\n    ) anonymous;\n\n    modifier note {\n        bytes32 foo;\n        bytes32 bar;\n        uint256 wad;\n\n        assembly {\n            foo := calldataload(4)\n            bar := calldataload(36)\n            wad := callvalue\n        }\n\n        emit LogNote(msg.sig, msg.sender, foo, bar, wad, msg.data);\n\n        _;\n    }\n}\n\n////// lib/ds-token/lib/ds-stop/src/stop.sol\n/// stop.sol -- mixin for enable/disable functionality\n\n// Copyright (C) 2017  DappHub, LLC\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n/* pragma solidity >=0.4.23; */\n\n/* import \"ds-auth/auth.sol\"; */\n/* import \"ds-note/note.sol\"; */\n\ncontract DSStop is DSNote, DSAuth {\n    bool public stopped;\n\n    modifier stoppable {\n        require(!stopped, \"ds-stop-is-stopped\");\n        _;\n    }\n    function stop() public auth note {\n        stopped = true;\n    }\n    function start() public auth note {\n        stopped = false;\n    }\n\n}\n\n////// lib/ds-token/lib/erc20/src/erc20.sol\n/// erc20.sol -- API for the ERC20 token standard\n\n// See <https://github.com/ethereum/EIPs/issues/20>.\n\n// This file likely does not meet the threshold of originality\n// required for copyright to apply.  As a result, this is free and\n// unencumbered software belonging to the public domain.\n\n/* pragma solidity >0.4.20; */\n\ncontract ERC20Events {\n    event Approval(address indexed src, address indexed guy, uint wad);\n    event Transfer(address indexed src, address indexed dst, uint wad);\n}\n\ncontract ERC20 is ERC20Events {\n    function totalSupply() public view returns (uint);\n    function balanceOf(address guy) public view returns (uint);\n    function allowance(address src, address guy) public view returns (uint);\n\n    function approve(address guy, uint wad) public returns (bool);\n    function transfer(address dst, uint wad) public returns (bool);\n    function transferFrom(\n        address src, address dst, uint wad\n    ) public returns (bool);\n}\n\n////// lib/ds-token/src/base.sol\n/// base.sol -- basic ERC20 implementation\n\n// Copyright (C) 2015, 2016, 2017  DappHub, LLC\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n/* pragma solidity >=0.4.23; */\n\n/* import \"erc20/erc20.sol\"; */\n/* import \"ds-math/math.sol\"; */\n\ncontract DSTokenBase is ERC20, DSMath {\n    uint256                                            _supply;\n    mapping (address => uint256)                       _balances;\n    mapping (address => mapping (address => uint256))  _approvals;\n\n    constructor(uint supply) public {\n        _balances[msg.sender] = supply;\n        _supply = supply;\n    }\n\n    function totalSupply() public view returns (uint) {\n        return _supply;\n    }\n    function balanceOf(address src) public view returns (uint) {\n        return _balances[src];\n    }\n    function allowance(address src, address guy) public view returns (uint) {\n        return _approvals[src][guy];\n    }\n\n    function transfer(address dst, uint wad) public returns (bool) {\n        return transferFrom(msg.sender, dst, wad);\n    }\n\n    function transferFrom(address src, address dst, uint wad)\n        public\n        returns (bool)\n    {\n        if (src != msg.sender) {\n            require(_approvals[src][msg.sender] >= wad, \"ds-token-insufficient-approval\");\n            _approvals[src][msg.sender] = sub(_approvals[src][msg.sender], wad);\n        }\n\n        require(_balances[src] >= wad, \"ds-token-insufficient-balance\");\n        _balances[src] = sub(_balances[src], wad);\n        _balances[dst] = add(_balances[dst], wad);\n\n        emit Transfer(src, dst, wad);\n\n        return true;\n    }\n\n    function approve(address guy, uint wad) public returns (bool) {\n        _approvals[msg.sender][guy] = wad;\n\n        emit Approval(msg.sender, guy, wad);\n\n        return true;\n    }\n}\n\n////// lib/ds-token/src/token.sol\n/// token.sol -- ERC20 implementation with minting and burning\n\n// Copyright (C) 2015, 2016, 2017  DappHub, LLC\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n/* pragma solidity >=0.4.23; */\n\n/* import \"ds-stop/stop.sol\"; */\n\n/* import \"./base.sol\"; */\n\ncontract DSToken is DSTokenBase(0), DSStop {\n\n    bytes32  public  symbol;\n    uint256  public  decimals = 18; // standard token precision. override to customize\n\n    constructor(bytes32 symbol_) public {\n        symbol = symbol_;\n    }\n\n    event Mint(address indexed guy, uint wad);\n    event Burn(address indexed guy, uint wad);\n\n    function approve(address guy) public stoppable returns (bool) {\n        return super.approve(guy, uint(-1));\n    }\n\n    function approve(address guy, uint wad) public stoppable returns (bool) {\n        return super.approve(guy, wad);\n    }\n\n    function transferFrom(address src, address dst, uint wad)\n        public\n        stoppable\n        returns (bool)\n    {\n        if (src != msg.sender && _approvals[src][msg.sender] != uint(-1)) {\n            require(_approvals[src][msg.sender] >= wad, \"ds-token-insufficient-approval\");\n            _approvals[src][msg.sender] = sub(_approvals[src][msg.sender], wad);\n        }\n\n        require(_balances[src] >= wad, \"ds-token-insufficient-balance\");\n        _balances[src] = sub(_balances[src], wad);\n        _balances[dst] = add(_balances[dst], wad);\n\n        emit Transfer(src, dst, wad);\n\n        return true;\n    }\n\n    function push(address dst, uint wad) public {\n        transferFrom(msg.sender, dst, wad);\n    }\n    function pull(address src, uint wad) public {\n        transferFrom(src, msg.sender, wad);\n    }\n    function move(address src, address dst, uint wad) public {\n        transferFrom(src, dst, wad);\n    }\n\n    function mint(uint wad) public {\n        mint(msg.sender, wad);\n    }\n    function burn(uint wad) public {\n        burn(msg.sender, wad);\n    }\n    function mint(address guy, uint wad) public auth stoppable {\n        _balances[guy] = add(_balances[guy], wad);\n        _supply = add(_supply, wad);\n        emit Mint(guy, wad);\n    }\n    function burn(address guy, uint wad) public auth stoppable {\n        if (guy != msg.sender && _approvals[guy][msg.sender] != uint(-1)) {\n            require(_approvals[guy][msg.sender] >= wad, \"ds-token-insufficient-approval\");\n            _approvals[guy][msg.sender] = sub(_approvals[guy][msg.sender], wad);\n        }\n\n        require(_balances[guy] >= wad, \"ds-token-insufficient-balance\");\n        _balances[guy] = sub(_balances[guy], wad);\n        _supply = sub(_supply, wad);\n        emit Burn(guy, wad);\n    }\n\n    // Optional token name\n    bytes32   public  name = \"\";\n\n    function setName(bytes32 name_) public auth {\n        name = name_;\n    }\n}\n\n////// lib/ds-value/lib/ds-thing/src/thing.sol\n// thing.sol - `auth` with handy mixins. your things should be DSThings\n\n// Copyright (C) 2017  DappHub, LLC\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n/* pragma solidity >=0.4.23; */\n\n/* import 'ds-auth/auth.sol'; */\n/* import 'ds-note/note.sol'; */\n/* import 'ds-math/math.sol'; */\n\ncontract DSThing is DSAuth, DSNote, DSMath {\n    function S(string memory s) internal pure returns (bytes4) {\n        return bytes4(keccak256(abi.encodePacked(s)));\n    }\n\n}\n\n////// lib/ds-value/src/value.sol\n/// value.sol - a value is a simple thing, it can be get and set\n\n// Copyright (C) 2017  DappHub, LLC\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n/* pragma solidity >=0.4.23; */\n\n/* import 'ds-thing/thing.sol'; */\n\ncontract DSValue is DSThing {\n    bool    has;\n    bytes32 val;\n    function peek() public view returns (bytes32, bool) {\n        return (val,has);\n    }\n    function read() public view returns (bytes32) {\n        bytes32 wut; bool haz;\n        (wut, haz) = peek();\n        assert(haz);\n        return wut;\n    }\n    function poke(bytes32 wut) public note auth {\n        val = wut;\n        has = true;\n    }\n    function void() public note auth {  // unset the value\n        has = false;\n    }\n}\n\n////// src/EscrowDataInterface.sol\n/* pragma solidity ^0.4.24; */\n\n/* import \"ds-token/token.sol\"; */\n\ninterface EscrowDataInterface\n{\n    ///@notice Create and fund a new escrow.\n    function createEscrow(\n        bytes32 _tradeId, \n        DSToken _token, \n        address _buyer, \n        address _seller, \n        uint256 _value, \n        uint16 _fee,\n        uint32 _paymentWindowInSeconds\n    ) external returns(bool);\n\n    function getEscrow(\n        bytes32 _tradeHash\n    ) external returns(bool, uint32, uint128);\n\n    function removeEscrow(\n        bytes32 _tradeHash\n    ) external returns(bool);\n\n    function updateSellerCanCancelAfter(\n        bytes32 _tradeHash,\n        uint32 _paymentWindowInSeconds\n    ) external returns(bool);\n\n    function increaseTotalGasFeesSpentByRelayer(\n        bytes32 _tradeHash,\n        uint128 _increaseGasFees\n    ) external returns(bool);\n}\n////// src/DexC2C.sol\n/* pragma solidity ^0.4.24; */\n\n/* import \"ds-token/token.sol\"; */\n/* import \"ds-auth/auth.sol\"; */\n/* import \"ds-value/value.sol\"; */\n// import \"ds-math/math.sol\";\n/* import \"./EscrowDataInterface.sol\"; */\n\ncontract DexC2C is DSAuth\n{\n    DSToken constant internal ETH_TOKEN_ADDRESS = DSToken(0x00eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee);\n    bool public enableMake = true;\n    EscrowDataInterface escrowData;\n    // address escrowData;\n    address public gateway;\n    address public arbitrator;\n    address public relayer;\n    address public signer;\n    uint32 public requestCancellationMinimumTime;\n\n    uint8 constant ACTION_TYPE_BUYER_PAID = 0x01;\n    uint8 constant ACTION_TYPE_SELLER_CANCEL = 0x02;\n    uint8 constant ACTION_TYPE_RELEASE = 0x03;\n    uint8 constant ACTION_TYPE_RESOLVE = 0x04;\n\n    mapping(address => bool) public listTokens;\n    mapping(address => uint256) feesAvailableForWithdraw;\n    // mapping(bytes32 => bool) withdrawAddresses;\n    mapping(address => DSValue) public tokenPriceFeed;\n\n\n    // event SetGateway(address _gateway);\n    // event SetEscrowData(address _escrowData);\n    // event SetToken(address caller, DSToken token, bool enable);\n    // event ResetOwner(address curr, address old);\n    // event ResetRelayer(address curr, address old);\n    // event ResetSigner(address curr, address old);\n    // event ResetArbitrator(address curr, address ocl);\n    // event ResetEnabled(bool curr, bool old);\n    // event WithdrawAddressApproved(DSToken token, address addr, bool approve);\n    // event LogWithdraw(DSToken token, address receiver, uint amnt);\n\n    event CreatedEscrow(address indexed _buyer, address indexed _seller, bytes32 indexed _tradeHash, DSToken _token);\n    event CancelledBySeller(address indexed _buyer, address indexed _seller, bytes32 indexed _tradeHash, DSToken _token);\n    event BuyerPaid(address indexed _buyer, address indexed _seller, bytes32 indexed _tradeHash, DSToken _token);\n    event Release(address indexed _buyer, address indexed _seller, bytes32 indexed _tradeHash, DSToken _token);\n    event DisputeResolved(address indexed _buyer, address indexed _seller, bytes32 indexed _tradeHash, DSToken _token);\n\n    struct EscrowParams{\n        bytes32 tradeId;\n        DSToken tradeToken;\n        address buyer;\n        address seller;\n        uint256 value;\n        uint16 fee;\n        uint32 paymentWindowInSeconds;\n        uint32 expiry;\n        uint8 v;\n        bytes32 r;\n        bytes32 s;\n        address caller;\n    }\n\n    struct Escrow{\n        bytes32 tradeHash;\n        bool exists;\n        uint32 sellerCanCancelAfter;\n        uint128 totalGasFeesSpentByRelayer;\n    }\n\n    modifier onlyGateway(){\n        require(msg.sender == gateway, \"Must be gateway contract\");\n        _;\n    }\n    \n    constructor(EscrowDataInterface _escrowData, address _signer) DSAuth() public{\n        // require(_escrowData != address(0x00), \"EscrowData address must exists\");\n        arbitrator = msg.sender;\n        relayer = msg.sender;\n        signer = _signer;\n        escrowData = _escrowData;\n        listTokens[ETH_TOKEN_ADDRESS] = true;\n        requestCancellationMinimumTime = 2 hours;\n    }\n\n    function setPriceFeed(DSToken _token, DSValue _priceFeed) public auth{\n        // require(_priceFeed != address(0x00), \"price feed must not be null\");\n        tokenPriceFeed[_token] = _priceFeed;\n    }\n\n    function setRelayer(address _relayer) public auth {\n        // require(_relayer != address(0x00), \"Relayer is null\");\n        // emit ResetRelayer(_relayer, relayer);\n        relayer = _relayer;\n    }\n\n    function setSigner(address _signer) public auth {\n        // require(_signer != address(0x00), \"Signer is null\");\n        // emit ResetSigner(_signer, signer);\n        signer = _signer;\n    }\n\n    function setArbitrator(address _arbitrator) public auth{\n        // require(_arbitrator != address(0x00), \"Arbitrator is null\");\n        // emit ResetArbitrator(arbitrator, _arbitrator);\n        arbitrator = _arbitrator;\n    }\n\n\n    function setGateway(address _gateway) public auth returns(bool){\n        // require(_gateway != address(0x00), \"Gateway address must valid\");\n        gateway = _gateway;\n        // emit SetGateway(_gateway);\n    }\n\n    function setEscrowData(EscrowDataInterface _escrowData) public auth returns(bool){\n        // require(_escrowData != address(0x00), \"EscrowData address must valid\");\n        escrowData = _escrowData;\n        // emit SetEscrowData(_escrowData);\n    }\n\n    function setToken(DSToken token, bool enable) public auth returns(bool){\n        // require(gateway != address(0x00), \"Set gateway first\");\n        // require(token != address(0x00), \"Token address can not be 0x00\");\n        listTokens[token] = enable;\n        // emit SetToken(msg.sender, token, enable);\n    }\n\n    function setRequestCancellationMinimumTime(\n        uint32 _newRequestCancellationMinimumTime\n    ) external auth {\n        requestCancellationMinimumTime = _newRequestCancellationMinimumTime;\n    }\n\n    function enabled() public view returns(bool) {\n        return enableMake;\n    }\n\n    function setEnabled(bool _enableMake) public auth{\n        require(_enableMake != enableMake, \"Enabled same value\");\n        // emit ResetEnabled(enableMake, _enableMake);\n        enableMake = _enableMake;\n    }\n\n    function getTokenAmount(DSToken _token, uint ethWad) public view returns(uint){\n        require(tokenPriceFeed[address(_token)] != address(0x00), \"the token has not price feed(to eth).\");\n        DSValue feed = tokenPriceFeed[address(_token)];\n        return wmul(ethWad, uint(feed.read()));\n    }\n\n    function checkCanResolveDispute(\n        bytes32 _tradeId,\n        DSToken _token,\n        address _buyer,\n        address _seller,\n        uint256 _value,\n        uint16 _fee,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s,\n        uint8 _buyerPercent,\n        address _caller\n    ) private view {\n        require(_caller == arbitrator, \"Must be arbitrator\");\n        bytes32 tradeHash = keccak256(abi.encodePacked(_tradeId, _token, _buyer, _seller, _value, _fee));\n        bytes32 invitationHash = keccak256(abi.encodePacked(tradeHash, ACTION_TYPE_RESOLVE, _buyerPercent));\n        address _signature = recoverAddress(invitationHash, _v, _r, _s);\n        require(_signature == _buyer || _signature == _seller, \"Must be buyer or seller\");\n    }\n\n    function resolveDispute(\n        bytes32 _tradeId,\n        DSToken _token,\n        address _buyer,\n        address _seller,\n        uint256 _value,\n        uint16 _fee,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s,\n        uint8 _buyerPercent,\n        address _caller\n    ) external onlyGateway {\n        checkCanResolveDispute(_tradeId, _token, _buyer, _seller, _value, _fee, _v, _r, _s,_buyerPercent, _caller);\n\n        Escrow memory escrow = getEscrow(_tradeId, _token, _buyer, _seller, _value, _fee);\n        require(escrow.exists, \"Escrow does not exists\");\n        require(_buyerPercent <= 100, \"BuyerPercent must be 100 or lower\");\n\n        doResolveDispute(\n            escrow.tradeHash,\n            _token,\n            _buyer,\n            _seller,\n            _value,\n            _buyerPercent,\n            escrow.totalGasFeesSpentByRelayer\n        );\n    }\n\n    uint16 constant GAS_doResolveDispute = 36100;\n    function doResolveDispute(\n        bytes32 _tradeHash,\n        DSToken _token,\n        address _buyer,\n        address _seller,\n        uint256 _value,\n        uint8 _buyerPercent,\n        uint128 _totalGasFeesSpentByRelayer\n    ) private {\n        uint256 _totalFees = _totalGasFeesSpentByRelayer;\n        if(_token == ETH_TOKEN_ADDRESS){\n            _totalFees += (GAS_doResolveDispute * uint128(tx.gasprice));\n        } else {\n            ///如果交易非ETH需要按照汇率换算成等值的token\n            _totalFees += getTokenAmount(_token, GAS_doResolveDispute * uint(tx.gasprice));\n        }\n        require(_value - _totalFees <= _value, \"Overflow error\");\n        feesAvailableForWithdraw[_token] += _totalFees;\n\n        escrowData.removeEscrow(_tradeHash);\n        emit DisputeResolved(_buyer, _seller, _tradeHash, _token);\n        if(_token == ETH_TOKEN_ADDRESS){\n            if (_buyerPercent > 0){\n                _buyer.transfer((_value - _totalFees) * _buyerPercent / 100);\n            }\n            if (_buyerPercent < 100){\n                _seller.transfer((_value - _totalFees) * (100 - _buyerPercent) / 100);\n            }\n        }else{\n            if (_buyerPercent > 0){\n                require(_token.transfer(_buyer, (_value - _totalFees) * _buyerPercent / 100));\n            }\n            if (_buyerPercent < 100){\n                require(_token.transfer(_seller, (_value - _totalFees) * (100 - _buyerPercent) / 100));\n            }\n        }\n\n    }\n\n    uint16 constant GAS_relayBaseCost = 35500;\n    function relay(\n        bytes32 _tradeId,\n        DSToken _tradeToken,\n        address _buyer,\n        address _seller,\n        uint256 _value,\n        uint16 _fee,\n        uint128 _maxGasPrice,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s,\n        uint8 _actionType,\n        address _caller\n    ) public onlyGateway returns (bool) {\n        address _relayedSender = getRelayedSender(_tradeId, _actionType, _maxGasPrice, _v, _r, _s);\n        uint128 _additionalGas = uint128(_caller == relayer ? GAS_relayBaseCost : 0);\n        if(_relayedSender == _buyer){\n            if(_actionType == ACTION_TYPE_BUYER_PAID){\n                return doBuyerPaid(_tradeId, _tradeToken, _buyer, _seller, _value, _fee, _caller, _additionalGas);\n            }\n        }else if(_relayedSender == _seller) {\n            if(_actionType == ACTION_TYPE_SELLER_CANCEL){\n                return doSellerCancel(_tradeId, _tradeToken, _buyer, _seller, _value, _fee, _caller, _additionalGas);\n            }else if(_actionType == ACTION_TYPE_RELEASE){\n                return doRelease(_tradeId, _tradeToken, _buyer, _seller, _value, _fee, _caller, _additionalGas);\n            }\n        }else{\n            require(_relayedSender == _seller, \"Unrecognised party\");\n            return false;\n        }\n    }\n\n    function createEscrow(\n        bytes32 _tradeId,\n        DSToken _tradeToken,\n        address _buyer,\n        address _seller,\n        uint256 _value,\n        uint16 _fee,\n        uint32 _paymentWindowInSeconds,\n        uint32 _expiry,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s,\n        address _caller\n    ) external payable onlyGateway returns (bool){\n        EscrowParams memory params;\n        params.tradeId = _tradeId;\n        params.tradeToken = _tradeToken;\n        params.buyer = _buyer;\n        params.seller = _seller;\n        params.value = _value;\n        params.fee = _fee;\n        params.paymentWindowInSeconds = _paymentWindowInSeconds;\n        params.expiry = _expiry;\n        params.v = _v;\n        params.r = _r;\n        params.s = _s;\n        params.caller = _caller;\n\n        return doCreateEscrow(params);\n    }\n\n    function doCreateEscrow(\n        EscrowParams params\n    ) internal returns (bool) {\n        require(enableMake, \"DESC2C is not enable\");\n        require(listTokens[params.tradeToken], \"Token is not allowed\");\n        // require(params.caller == params.seller, \"Must be seller\");\n\n        bytes32 _tradeHash = keccak256(\n            abi.encodePacked(params.tradeId, params.tradeToken, params.buyer, params.seller, params.value, params.fee));\n        bytes32 _invitationHash = keccak256(abi.encodePacked(_tradeHash, params.paymentWindowInSeconds, params.expiry));\n        require(recoverAddress(_invitationHash, params.v, params.r, params.s) == signer, \"Must be signer\");\n        require(block.timestamp < params.expiry, \"Signature has expired\");\n\n        emit CreatedEscrow(params.buyer, params.seller, _tradeHash, params.tradeToken);\n        return escrowData.createEscrow(params.tradeId, params.tradeToken, params.buyer, params.seller, params.value, \n        params.fee, params.paymentWindowInSeconds);\n    }\n\n    function buyerPaid(\n        bytes32 _tradeId,\n        DSToken _token,\n        address _buyer,\n        address _seller,\n        uint256 _value,\n        uint16 _fee,\n        address _caller\n    ) external onlyGateway returns(bool) {\n        require(_caller == _buyer, \"Must by buyer\");\n        return doBuyerPaid(_tradeId, _token, _buyer, _seller, _value, _fee, _caller, 0);\n    }\n\n    function release(\n        bytes32 _tradeId,\n        DSToken _token,\n        address _buyer,\n        address _seller,\n        uint256 _value,\n        uint16 _fee,\n        address _caller\n    ) external onlyGateway returns(bool){\n        require(_caller == _seller, \"Must by seller\");\n        doRelease(_tradeId, _token, _buyer, _seller, _value, _fee, _caller, 0);\n    }\n\n    uint16 constant GAS_doRelease = 46588;\n    function doRelease(\n        bytes32 _tradeId,\n        DSToken _token,\n        address _buyer,\n        address _seller,\n        uint256 _value,\n        uint16 _fee,\n        address _caller,\n        uint128 _additionalGas\n    ) internal returns(bool){\n        Escrow memory escrow = getEscrow(_tradeId, _token, _buyer, _seller, _value, _fee);\n        require(escrow.exists, \"Escrow does not exists\");\n\n        uint128 _gasFees = escrow.totalGasFeesSpentByRelayer;\n        if(_caller == relayer){\n            if(_token == ETH_TOKEN_ADDRESS){\n                _gasFees += (GAS_doRelease + _additionalGas) * uint128(tx.gasprice);\n            }else{\n                uint256 relayGas = (GAS_doRelease + _additionalGas) * tx.gasprice;\n                _gasFees += uint128(getTokenAmount(_token, relayGas));\n            }\n        }else{\n            require(_caller == _seller, \"Must by seller\");\n        }\n        escrowData.removeEscrow(escrow.tradeHash);\n        transferMinusFees(_token, _buyer, _value, _gasFees, _fee);\n        emit Release(_buyer, _seller, escrow.tradeHash, _token);\n        return true;\n    }\n\n    uint16 constant GAS_doBuyerPaid = 35944;\n    function doBuyerPaid(\n        bytes32 _tradeId,\n        DSToken _token,\n        address _buyer,\n        address _seller,\n        uint256 _value,\n        uint16 _fee,\n        address _caller,\n        uint128 _additionalGas\n    ) internal returns(bool){\n        Escrow memory escrow = getEscrow(_tradeId, _token, _buyer, _seller, _value, _fee);\n        require(escrow.exists, \"Escrow not exists\");\n\n        if(_caller == relayer){\n            if(_token == ETH_TOKEN_ADDRESS){\n                require(escrowData.increaseTotalGasFeesSpentByRelayer(escrow.tradeHash, (GAS_doBuyerPaid + _additionalGas) * uint128(tx.gasprice)));\n            }else{\n                uint256 relayGas = (GAS_doBuyerPaid + _additionalGas) * tx.gasprice;\n                require(escrowData.increaseTotalGasFeesSpentByRelayer(escrow.tradeHash, uint128(getTokenAmount(_token, relayGas))));\n            }\n        }else{\n            require(_caller == _buyer, \"Must be buyer\");\n        }\n        \n        require(escrowData.updateSellerCanCancelAfter(escrow.tradeHash, requestCancellationMinimumTime));\n        emit BuyerPaid(_buyer, _seller, escrow.tradeHash, _token);\n        return true;\n    }\n\n    function sellerCancel(\n        bytes32 _tradeId,\n        DSToken _token,\n        address _buyer,\n        address _seller,\n        uint256 _value,\n        uint16 _fee,\n        uint32 _expiry,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s,\n        address _caller\n    ) external onlyGateway returns (bool){\n        require(_caller == _seller, \"Must be seller\");\n        bytes32 tradeHash = keccak256(abi.encodePacked(_tradeId, _token, _buyer, _seller, _value, _fee));\n        bytes32 invitationHash = keccak256(abi.encodePacked(tradeHash, ACTION_TYPE_SELLER_CANCEL, _expiry));\n        require(recoverAddress(invitationHash, _v, _r, _s) == signer, \"Must be signer\");\n        return doSellerCancel(_tradeId, _token, _buyer, _seller, _value, _fee, _caller, 0);\n    }\n\n    uint16 constant GAS_doSellerCancel = 46255;\n    function doSellerCancel(\n        bytes32 _tradeId,\n        DSToken _token,\n        address _buyer,\n        address _seller,\n        uint256 _value,\n        uint16 _fee,\n        address _caller,\n        uint128 _additionalGas\n    ) private returns (bool) {\n        Escrow memory escrow = getEscrow(_tradeId, _token, _buyer, _seller, _value, _fee);\n        require(escrow.exists, \"Escrow does not exists\");\n\n        if(block.timestamp < escrow.sellerCanCancelAfter){\n            return false;\n        }\n\n        uint128 _gasFees = escrow.totalGasFeesSpentByRelayer;\n        if(_caller == relayer){\n            if(_token == ETH_TOKEN_ADDRESS){\n                _gasFees += (GAS_doSellerCancel + _additionalGas) * uint128(tx.gasprice);\n            }else{\n                uint256 relayGas = (GAS_doSellerCancel + _additionalGas) * tx.gasprice;\n                _gasFees += uint128(getTokenAmount(_token, relayGas));\n            }\n        }else{\n            require(_caller == _seller, \"Must be buyer\");\n        }\n        \n        escrowData.removeEscrow(escrow.tradeHash);\n        emit CancelledBySeller(_buyer, _seller, escrow.tradeHash, _token);\n        transferMinusFees(_token, _seller, _value, _gasFees, 0);\n        return true;\n    }\n\n    function transferMinusFees(\n        DSToken _token,\n        address _to,\n        uint256 _value,\n        uint128 _totalGasFeesSpentByRelayer,\n        uint16 _fee\n    ) private {\n        uint256 _totalFees = (_value * _fee / 10000);\n        _totalFees += _totalGasFeesSpentByRelayer;\n        if(_value - _totalFees > _value) {\n            return;\n        }\n        feesAvailableForWithdraw[_token] += _totalFees;\n\n        if(_token == ETH_TOKEN_ADDRESS){\n            _to.transfer(_value - _totalFees);\n        }else{\n            require(_token.transfer(_to, _value - _totalFees));\n        }\n    }\n\n    function getFeesAvailableForWithdraw(\n        DSToken _token\n    ) public view auth returns(uint256){\n        // bytes32 key = keccak256(abi.encodePacked(_token, msg.sender));\n        // require(withdrawAddresses[key], \"unauthorization address!\");\n        return feesAvailableForWithdraw[_token];\n    }\n\n    // function approvedWithdrawAddress(DSToken _token, address _addr, bool _approve) public auth returns(bool){\n    //     // require(_addr != address(0x00), \"Approved address is null\");\n    //     bytes32 key = keccak256(abi.encodePacked(_token, _addr));\n    //     require(withdrawAddresses[key] != _approve, \"Address has approved\");\n    //     withdrawAddresses[key] = _approve;\n    //     // emit WithdrawAddressApproved(_token, _addr, _approve);\n    //     return true;\n    // }\n\n    function withdraw(DSToken _token, uint _amnt, address _receiver) external auth returns(bool){\n        // require(withdrawAddresses[keccak256(abi.encodePacked(_token, _receiver))], \"Address not in white list\");\n        require(feesAvailableForWithdraw[_token] > 0, \"Fees is 0 or token not exists\");\n        require(_amnt <= feesAvailableForWithdraw[_token], \"Amount is higher than amount available\");\n        if(_token == ETH_TOKEN_ADDRESS){\n            _receiver.transfer(_amnt);\n        }else{\n            require(_token.transfer(_receiver, _amnt), \"Withdraw failed\");\n        }\n        // emit LogWithdraw(_token, _receiver, _amnt);\n        return true;\n    }\n\n    function getEscrow(\n        bytes32 _tradeId,\n        DSToken _token,\n        address _buyer,\n        address _seller,\n        uint256 _value,\n        uint16 _fee\n    ) private returns(Escrow){\n        bytes32 _tradeHash = keccak256(abi.encodePacked(_tradeId, _token, _buyer, _seller, _value, _fee));\n        bool exists;\n        uint32 sellerCanCancelAfter;\n        uint128 totalFeesSpentByRelayer; \n        (exists, sellerCanCancelAfter, totalFeesSpentByRelayer) = escrowData.getEscrow(_tradeHash);\n\n        return Escrow(_tradeHash, exists, sellerCanCancelAfter, totalFeesSpentByRelayer);\n    }\n\n    function () public payable{\n    }\n\n    function recoverAddress(\n        bytes32 _h,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    ) internal pure returns (address){\n        bytes memory _prefix = \"\\x19Ethereum Signed Message:\\n32\";\n        bytes32 _prefixedHash = keccak256(abi.encodePacked(_prefix, _h));\n        return ecrecover(_prefixedHash, _v, _r, _s); \n    }\n\n    function getRelayedSender(\n        bytes32 _tradeId,\n        uint8 _actionType,\n        uint128 _maxGasPrice,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    ) internal view returns(address){\n        bytes32 _hash = keccak256(abi.encodePacked(_tradeId, _actionType, _maxGasPrice));\n        if(tx.gasprice > _maxGasPrice){\n            return;\n        }\n        return recoverAddress(_hash, _v, _r, _s);\n    }\n    function add(uint x, uint y) internal pure returns (uint z) {\n        require((z = x + y) >= x, \"ds-math-add-overflow\");\n    }\n    function mul(uint x, uint y) internal pure returns (uint z) {\n        require(y == 0 || (z = x * y) / y == x, \"ds-math-mul-overflow\");\n    }\n    uint constant WAD = 10 ** 18;\n    function wmul(uint x, uint y) internal pure returns (uint z) {\n        z = add(mul(x, y), WAD / 2) / WAD;\n    }\n}\n////// src/DexC2CGateway.sol\n/* pragma solidity ^0.4.24; */\n\n/* import \"./DexC2C.sol\"; */\n/* import \"ds-token/token.sol\"; */\n/* import \"ds-auth/auth.sol\"; */\n\ncontract DexC2CGateway is DSAuth{\n    \n    DSToken constant internal ETH_TOKEN_ADDRESS = DSToken(0x00eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee);\n    DexC2C dexc2c;\n\n    event ResetDexC2C(address curr, address old);\n\n    struct BatchRelayParams{\n        bytes32[] _tradeId;\n        DSToken[] _token;\n        address[] _buyer;\n        address[] _seller;\n        uint256[] _value;\n        uint16[] _fee;\n        uint128[] _maxGasPrice;\n        uint8[] _v;\n        bytes32[] _r;\n        bytes32[] _s;\n        uint8[] _actionType;\n    }\n\n\n    constructor() DSAuth() public{\n    }\n\n    function setDexC2C(DexC2C _dexc2c) public auth{\n        require(_dexc2c != address(0x00), \"DexC2C is null\");\n        dexc2c = _dexc2c;\n        emit ResetDexC2C(_dexc2c, dexc2c);\n    }\n\n    function resolveDispute(\n        bytes32 _tradeId,\n        DSToken _token,\n        address _buyer,\n        address _seller,\n        uint256 _value,\n        uint16 _fee,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s,\n        uint8 _buyerPercent\n    ) public{\n        dexc2c.resolveDispute(_tradeId, _token, _buyer, _seller, _value, _fee, _v, _r, _s, _buyerPercent, msg.sender);\n    }\n\n    function relay(\n        bytes32 _tradeId,\n        DSToken _token,\n        address _buyer,\n        address _seller,\n        uint256 _value,\n        uint16 _fee,\n        uint128 _maxGasPrice,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s,\n        uint8 _actionType\n    ) public returns(bool){\n        return dexc2c.relay(_tradeId, _token, _buyer, _seller, _value, _fee, _maxGasPrice, _v, _r, _s, _actionType, msg.sender);\n    }\n\n    function createEscrow(\n        bytes32 _tradeId,\n        DSToken _tradeToken,\n        address _buyer,\n        address _seller,\n        uint256 _value,\n        uint16 _fee,\n        uint32 _paymentWindowInSeconds,\n        uint32 _expiry,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    ) public payable returns(bool) {\n        if(_tradeToken == ETH_TOKEN_ADDRESS){\n            require(msg.value == _value && msg.value > 0, \"Incorrect token sent\");\n        }else{\n            require(_tradeToken.transferFrom(_seller, dexc2c, _value), \"Can not transfer token from seller\");\n        }\n        return doCreateEscrow(_tradeId, _tradeToken, _buyer, _seller, _value, _fee, _paymentWindowInSeconds, _expiry, _v, _r, _s, msg.sender);\n    }\n\n    function sellerCancel(\n        bytes32 _tradeId,\n        DSToken _tradeToken,\n        address _buyer,\n        address _seller,\n        uint256 _value,\n        uint16 _fee,\n        uint32 _expiry,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    ) public returns(bool){\n        return dexc2c.sellerCancel(_tradeId, _tradeToken, _buyer, _seller, _value, _fee, _expiry, _v, _r, _s, msg.sender);\n    }\n\n    function buyerPaid(\n        bytes32 _tradeId,\n        DSToken _tradeToken,\n        address _buyer,\n        address _seller,\n        uint256 _value,\n        uint16 _fee\n    )public returns(bool){\n        return dexc2c.buyerPaid(_tradeId, _tradeToken, _buyer, _seller, _value, _fee, msg.sender);\n    }\n\n    function release(\n        bytes32 _tradeId,\n        DSToken _tradeToken,\n        address _buyer,\n        address _seller,\n        uint256 _value,\n        uint16 _fee\n    )public returns(bool){\n        return dexc2c.release(_tradeId, _tradeToken, _buyer, _seller, _value, _fee, msg.sender);\n    }\n\n    function doCreateEscrow(\n        bytes32 _tradeId,\n        DSToken _tradeToken,\n        address _buyer,\n        address _seller,\n        uint256 _value,\n        uint16 _fee,\n        uint32 _paymentWindowInSeconds,\n        uint32 _expiry,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s,\n        address _caller\n    ) internal returns(bool){\n        return dexc2c.createEscrow.value(msg.value)(\n            _tradeId,\n            _tradeToken,\n            _buyer,\n            _seller,\n            _value,\n            _fee,\n            _paymentWindowInSeconds,\n            _expiry,\n            _v,\n            _r,\n            _s,\n            _caller\n        );\n    }\n\n    function recoverAddress(\n        bytes32 _h,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    ) internal pure returns (address){\n        // bytes memory _prefix = \"\\x19Ethereum Signed Message:\\n32\";\n        // bytes32 _prefixedHash = keccak256(abi.encodePacked(_prefix, _h));\n        // return ecrecover(_prefixedHash, _v, _r, _s); \n        return ecrecover(_h, _v, _r, _s);\n    }\n\n    function getRelayedSender(\n        bytes32 _tradeId,\n        uint8 _actionType,\n        uint128 _maxGasPrice,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    ) internal view returns(address){\n        bytes32 _hash = keccak256(abi.encodePacked(_tradeId, _actionType, _maxGasPrice));\n        if(tx.gasprice > _maxGasPrice){\n            return;\n        }\n        return recoverAddress(_hash, _v, _r, _s);\n    }\n}\n","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"owner_\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tradeId\",\"type\":\"bytes32\"},{\"name\":\"_tradeToken\",\"type\":\"address\"},{\"name\":\"_buyer\",\"type\":\"address\"},{\"name\":\"_seller\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_fee\",\"type\":\"uint16\"},{\"name\":\"_expiry\",\"type\":\"uint32\"},{\"name\":\"_v\",\"type\":\"uint8\"},{\"name\":\"_r\",\"type\":\"bytes32\"},{\"name\":\"_s\",\"type\":\"bytes32\"}],\"name\":\"sellerCancel\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tradeId\",\"type\":\"bytes32\"},{\"name\":\"_tradeToken\",\"type\":\"address\"},{\"name\":\"_buyer\",\"type\":\"address\"},{\"name\":\"_seller\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_fee\",\"type\":\"uint16\"},{\"name\":\"_paymentWindowInSeconds\",\"type\":\"uint32\"},{\"name\":\"_expiry\",\"type\":\"uint32\"},{\"name\":\"_v\",\"type\":\"uint8\"},{\"name\":\"_r\",\"type\":\"bytes32\"},{\"name\":\"_s\",\"type\":\"bytes32\"}],\"name\":\"createEscrow\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tradeId\",\"type\":\"bytes32\"},{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_buyer\",\"type\":\"address\"},{\"name\":\"_seller\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_fee\",\"type\":\"uint16\"},{\"name\":\"_maxGasPrice\",\"type\":\"uint128\"},{\"name\":\"_v\",\"type\":\"uint8\"},{\"name\":\"_r\",\"type\":\"bytes32\"},{\"name\":\"_s\",\"type\":\"bytes32\"},{\"name\":\"_actionType\",\"type\":\"uint8\"}],\"name\":\"relay\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"authority_\",\"type\":\"address\"}],\"name\":\"setAuthority\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tradeId\",\"type\":\"bytes32\"},{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_buyer\",\"type\":\"address\"},{\"name\":\"_seller\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_fee\",\"type\":\"uint16\"},{\"name\":\"_v\",\"type\":\"uint8\"},{\"name\":\"_r\",\"type\":\"bytes32\"},{\"name\":\"_s\",\"type\":\"bytes32\"},{\"name\":\"_buyerPercent\",\"type\":\"uint8\"}],\"name\":\"resolveDispute\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tradeId\",\"type\":\"bytes32\"},{\"name\":\"_tradeToken\",\"type\":\"address\"},{\"name\":\"_buyer\",\"type\":\"address\"},{\"name\":\"_seller\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_fee\",\"type\":\"uint16\"}],\"name\":\"buyerPaid\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tradeId\",\"type\":\"bytes32\"},{\"name\":\"_tradeToken\",\"type\":\"address\"},{\"name\":\"_buyer\",\"type\":\"address\"},{\"name\":\"_seller\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_fee\",\"type\":\"uint16\"}],\"name\":\"release\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"authority\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_dexc2c\",\"type\":\"address\"}],\"name\":\"setDexC2C\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"curr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"old\",\"type\":\"address\"}],\"name\":\"ResetDexC2C\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"authority\",\"type\":\"address\"}],\"name\":\"LogSetAuthority\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"LogSetOwner\",\"type\":\"event\"}]","ContractName":"DexC2CGateway","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://7eb547cff081dbcb0715a3cdfbe1ba941f4e53f82ea54c13443b2f8c8ede1326"}]}