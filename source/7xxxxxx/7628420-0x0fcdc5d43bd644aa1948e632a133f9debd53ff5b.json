{"status":"1","message":"OK","result":[{"SourceCode":"//                                               __                __                                                            \r\n//                                              |  \\              |  \\                                                           \r\n//   _______  __   __   __   ______    ______  _| $$_     ______  | $$   __   ______   _______       ______    ______    ______  \r\n//  /       \\|  \\ |  \\ |  \\ |      \\  /      \\|   $$ \\   /      \\ | $$  /  \\ /      \\ |       \\     |      \\  /      \\  /      \\ \r\n// |  $$$$$$$| $$ | $$ | $$  \\$$$$$$\\|  $$$$$$\\\\$$$$$$  |  $$$$$$\\| $$_/  $$|  $$$$$$\\| $$$$$$$\\     \\$$$$$$\\|  $$$$$$\\|  $$$$$$\\\r\n//  \\$$    \\ | $$ | $$ | $$ /      $$| $$  | $$ | $$ __ | $$  | $$| $$   $$ | $$    $$| $$  | $$    /      $$| $$  | $$| $$  | $$\r\n//  _\\$$$$$$\\| $$_/ $$_/ $$|  $$$$$$$| $$__/ $$ | $$|  \\| $$__/ $$| $$$$$$\\ | $$$$$$$$| $$  | $$ __|  $$$$$$$| $$__/ $$| $$__/ $$\r\n// |       $$ \\$$   $$   $$ \\$$    $$| $$    $$  \\$$  $$ \\$$    $$| $$  \\$$\\ \\$$     \\| $$  | $$|  \\\\$$    $$| $$    $$| $$    $$\r\n//  \\$$$$$$$   \\$$$$$\\$$$$   \\$$$$$$$| $$$$$$$    \\$$$$   \\$$$$$$  \\$$   \\$$  \\$$$$$$$ \\$$   \\$$ \\$$ \\$$$$$$$| $$$$$$$ | $$$$$$$ \r\n//                                   | $$                                                                    | $$      | $$      \r\n//                                   | $$                                                                    | $$      | $$      \r\n//                                    \\$$                                                                     \\$$       \\$$      \r\n// https://swaptoken.app\r\npragma solidity ^0.5.2;\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Unsigned math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Multiplies two unsigned integers, reverts on overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Adds two unsigned integers, reverts on overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\r\n     * reverts when dividing by zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC20/IERC20.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://eips.ethereum.org/EIPS/eip-20\r\n */\r\ninterface IERC20 {\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n\r\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address who) external view returns (uint256);\r\n\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: contracts/HashedTimelock.sol\r\n\r\npragma solidity 0.5.3;\r\n\r\n\r\n\r\n/**\r\n * @title Hashed Timelock Contracts (HTLCs) on Ethereum ETH.\r\n *\r\n * This contract provides a way to create and keep HTLCs for ETH.\r\n *\r\n *\r\n * Protocol:\r\n *\r\n *  1) newContract(receiver, hashlock, timelock) - a sender calls this to create\r\n *      a new HTLC and gets back a 32 byte contract id\r\n *  2) withdraw(contractId, preimage) - once the receiver knows the preimage of\r\n *      the hashlock hash they can claim the ETH with this function\r\n *  3) refund() - after timelock has expired and if the receiver did not \r\n *      withdraw funds the sender / creater of the HTLC can get their ETH \r\n *      back with this function.\r\n */\r\ncontract HashedTimelock {\r\n\r\n    using SafeMath for uint256;\r\n\r\n    event LogHTLCNew(\r\n        bytes32 indexed contractId,\r\n        address indexed sender,\r\n        address indexed receiver,\r\n        uint amount,\r\n        uint timelock\r\n    );\r\n    event LogHTLCWithdraw(bytes32 indexed contractId, bytes32 preimage);\r\n    event LogHTLCRefund(bytes32 indexed contractId);\r\n\r\n    struct LockContract {\r\n        address payable sender;\r\n        address payable receiver;\r\n        uint amount;\r\n        uint timelock; // UNIX timestamp seconds - locked UNTIL this time\r\n        bool withdrawn;\r\n        bool refunded;\r\n        bytes32 preimage;\r\n    }\r\n\r\n    modifier fundsSent() {\r\n        require(msg.value > 0, \"msg.value must be > 0\");\r\n        _;\r\n    }\r\n    modifier futureTimelock(uint _time) {\r\n        // only requirement is the timelock time is after the last blocktime (now).\r\n        // probably want something a bit further in the future then this.\r\n        // but this is still a useful sanity check:\r\n        require(_time > now + 1 hours, \"timelock time must be in the future\");\r\n        _;\r\n    }\r\n    modifier contractExists(bytes32 _contractId) {\r\n        require(haveContract(_contractId), \"contractId does not exist\");\r\n        _;\r\n    }\r\n    modifier hashlockMatches(bytes32 _contractId, bytes32 _x) {\r\n        require(\r\n            _contractId == keccak256(abi.encodePacked(_x)),\r\n            \"hashlock hash does not match\"\r\n        );\r\n        _;\r\n    }\r\n    modifier withdrawable(bytes32 _contractId) {\r\n        require(contracts[_contractId].receiver == msg.sender, \"withdrawable: not receiver\");\r\n        require(contracts[_contractId].withdrawn == false, \"withdrawable: already withdrawn\");\r\n        _;\r\n    }\r\n    modifier refundable(bytes32 _contractId) {\r\n        require(contracts[_contractId].sender == msg.sender, \"refundable: not sender\");\r\n        require(contracts[_contractId].refunded == false, \"refundable: already refunded\");\r\n        require(contracts[_contractId].withdrawn == false, \"refundable: already withdrawn\");\r\n        require(contracts[_contractId].timelock <= now, \"refundable: timelock not yet passed\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"you are not an owner\");\r\n        _;\r\n    }\r\n\r\n    mapping (bytes32 => LockContract) contracts;\r\n    uint256 public feePercent; // 5 == 0.05 %\r\n    uint oneHundredPercent = 10000; // 100 %\r\n    address payable public owner;\r\n    uint feeToWithdraw;\r\n\r\n    constructor(address payable _owner, uint256 _feePercent) public {\r\n        feePercent = _feePercent;\r\n        owner = _owner;\r\n    }\r\n\r\n    function setFeePercent(uint256 _feePercent) external onlyOwner {\r\n        require(_feePercent < oneHundredPercent.div(2), \"should be less than 50%\");\r\n        feePercent = _feePercent;\r\n    }\r\n    /**\r\n     * @dev Sender sets up a new hash time lock contract depositing the ETH and \r\n     * providing the reciever lock terms.\r\n     *\r\n     * @param _receiver Receiver of the ETH.\r\n     * @param _hashlock A keccak256 hash hashlock.\r\n     * @param _timelock UNIX epoch seconds time that the lock expires at. \r\n     *                  Refunds can be made after this time.\r\n     */\r\n    function newContract(address payable _receiver, bytes32 _hashlock, uint _timelock)\r\n        external\r\n        payable\r\n        fundsSent\r\n        futureTimelock(_timelock)\r\n    {\r\n        uint256 swapValue = msg.value.mul(oneHundredPercent).div(oneHundredPercent.add(feePercent));\r\n        uint feeValue = msg.value.sub(swapValue);\r\n        feeToWithdraw = feeValue.add(feeToWithdraw);\r\n\r\n        // Reject if a contract already exists with the same parameters. The\r\n        // sender must change one of these parameters to create a new distinct \r\n        // contract.\r\n        if (haveContract(_hashlock)) {\r\n            revert(\"contract exist\");\r\n        }\r\n\r\n        contracts[_hashlock] = LockContract(\r\n            msg.sender,\r\n            _receiver,\r\n            swapValue,\r\n            _timelock,\r\n            false,\r\n            false,\r\n            0x0\r\n        );\r\n\r\n        emit LogHTLCNew(\r\n            _hashlock,\r\n            msg.sender,\r\n            _receiver,\r\n            swapValue,\r\n            _timelock\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Called by the receiver once they know the preimage of the hashlock.\r\n     * This will transfer the locked funds to their address.\r\n     *\r\n     * @param _contractId Id of the HTLC.\r\n     * @param _preimage keccak256(_preimage) should equal the contract hashlock.\r\n     * @return bool true on success\r\n     */\r\n    function withdraw(bytes32 _contractId, bytes32 _preimage)\r\n        external\r\n        contractExists(_contractId)\r\n        hashlockMatches(_contractId, _preimage)\r\n        withdrawable(_contractId)\r\n        returns (bool)\r\n    {\r\n        LockContract storage c = contracts[_contractId];\r\n        c.preimage = _preimage;\r\n        c.withdrawn = true;\r\n        c.receiver.transfer(c.amount);\r\n        emit LogHTLCWithdraw(_contractId, _preimage);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Called by the sender if there was no withdraw AND the time lock has\r\n     * expired. This will refund the contract amount.\r\n     *\r\n     * @param _contractId Id of HTLC to refund from.\r\n     * @return bool true on success\r\n     */\r\n    function refund(bytes32 _contractId)\r\n        external\r\n        contractExists(_contractId)\r\n        refundable(_contractId)\r\n        returns (bool)\r\n    {\r\n        LockContract storage c = contracts[_contractId];\r\n        c.refunded = true;\r\n        c.sender.transfer(c.amount);\r\n        emit LogHTLCRefund(_contractId);\r\n        return true;\r\n    }\r\n\r\n    function claimTokens(address _token) external onlyOwner {\r\n        if (_token == address(0)) {\r\n            owner.transfer(feeToWithdraw);\r\n            return;\r\n        }\r\n        IERC20 erc20token = IERC20(_token);\r\n        uint256 balance = erc20token.balanceOf(address(this));\r\n        erc20token.transfer(owner, balance);\r\n    }\r\n\r\n    /**\r\n     * @dev Get contract details.\r\n     * @param _contractId HTLC contract id\r\n     * @return All parameters in struct LockContract for _contractId HTLC\r\n     */\r\n    function getContract(bytes32 _contractId)\r\n        public\r\n        view\r\n        returns (\r\n            address sender,\r\n            address receiver,\r\n            uint amount,\r\n            uint timelock,\r\n            bool withdrawn,\r\n            bool refunded,\r\n            bytes32 preimage\r\n        )\r\n    {\r\n        if (haveContract(_contractId) == false)\r\n            return (address(0), address(0), 0, 0, false, false, 0);\r\n        LockContract storage c = contracts[_contractId];\r\n        return (c.sender, c.receiver, c.amount, c.timelock,\r\n            c.withdrawn, c.refunded, c.preimage);\r\n    }\r\n\r\n    /**\r\n     * @dev Is there a contract with id _contractId.\r\n     * @param _contractId Id into contracts mapping.\r\n     */\r\n    function haveContract(bytes32 _contractId)\r\n        public\r\n        view\r\n        returns (bool exists)\r\n    {\r\n        exists = (contracts[_contractId].sender != address(0));\r\n    }\r\n\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_receiver\",\"type\":\"address\"},{\"name\":\"_hashlock\",\"type\":\"bytes32\"},{\"name\":\"_timelock\",\"type\":\"uint256\"}],\"name\":\"newContract\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_contractId\",\"type\":\"bytes32\"}],\"name\":\"haveContract\",\"outputs\":[{\"name\":\"exists\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_contractId\",\"type\":\"bytes32\"},{\"name\":\"_preimage\",\"type\":\"bytes32\"}],\"name\":\"withdraw\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_contractId\",\"type\":\"bytes32\"}],\"name\":\"refund\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_feePercent\",\"type\":\"uint256\"}],\"name\":\"setFeePercent\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"feePercent\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"claimTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_contractId\",\"type\":\"bytes32\"}],\"name\":\"getContract\",\"outputs\":[{\"name\":\"sender\",\"type\":\"address\"},{\"name\":\"receiver\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"timelock\",\"type\":\"uint256\"},{\"name\":\"withdrawn\",\"type\":\"bool\"},{\"name\":\"refunded\",\"type\":\"bool\"},{\"name\":\"preimage\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_feePercent\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"contractId\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timelock\",\"type\":\"uint256\"}],\"name\":\"LogHTLCNew\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"contractId\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"preimage\",\"type\":\"bytes32\"}],\"name\":\"LogHTLCWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"contractId\",\"type\":\"bytes32\"}],\"name\":\"LogHTLCRefund\",\"type\":\"event\"}]","ContractName":"HashedTimelock","CompilerVersion":"v0.5.3+commit.10d17f24","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000000039f22efb07a647557c7c5d17854cfd6d489ef3000000000000000000000000000000000000000000000000000000000000000a","Library":"","SwarmSource":"bzzr://d73c4edb6c8195479619d3d699680e0582b0a3e67790d8b440573821d85c98a1"}]}