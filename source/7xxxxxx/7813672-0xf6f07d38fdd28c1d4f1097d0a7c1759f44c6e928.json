{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.0;\r\npragma experimental ABIEncoderV2;\r\n\r\ncontract IERC721 {\r\n  function balanceOf(address owner) public view returns (uint256 balance);\r\n  function ownerOf(uint256 tokenId) public view returns (address owner);\r\n\r\n  function approve(address to, uint256 tokenId) public;\r\n  function getApproved(uint256 tokenId) public view returns (address operator);\r\n\r\n  function setApprovalForAll(address operator, bool _approved) public;\r\n  function isApprovedForAll(address owner, address operator) public view returns (bool);\r\n\r\n  function transferFrom(address from, address to, uint256 tokenId) public;\r\n  function safeTransferFrom(address from, address to, uint256 tokenId) public;\r\n\r\n  function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public;\r\n}\r\n\r\ncontract Wizards {\r\n\r\n  IERC721 internal constant wizards = IERC721(0x2F4Bdafb22bd92AA7b7552d270376dE8eDccbc1E);\r\n  uint8 internal constant ELEMENT_FIRE = 1;\r\n  uint8 internal constant ELEMENT_WIND = 2;\r\n  uint8 internal constant ELEMENT_WATER = 3;\r\n  uint256 internal constant MAX_WAIT = 86400; // 1 day timeout\r\n\r\n  uint256 public ids;\r\n\r\n  struct Game {\r\n    uint256 id;\r\n    // player 1\r\n    address player1;\r\n    uint256 player1TokenId;\r\n    bytes32 player1SpellHash;\r\n    uint8 player1Spell;\r\n    // player 2\r\n    address player2;\r\n    uint256 player2TokenId;\r\n    uint8 player2Spell;\r\n    uint256 timer;\r\n    // result\r\n    address winner;\r\n  }\r\n\r\n  mapping (uint256 => Game) public games;\r\n  \r\n  event GameUpdate(uint256 indexed gameId);\r\n\r\n  function start(uint256 tokenId, bytes32 spellHash) external {\r\n    // TODO: transfer wizard to this contract\r\n    // wizards.transferFrom(msg.sender, address(this), tokenId);\r\n    \r\n    // increment game ids\r\n    ids++;\r\n\r\n    // add game details\r\n    games[ids].id = ids;\r\n    games[ids].player1 = msg.sender;\r\n    games[ids].player1TokenId = tokenId;\r\n    games[ids].player1SpellHash = spellHash;\r\n    \r\n    emit GameUpdate(ids);\r\n  }\r\n\r\n  function join(uint256 gameId, uint256 tokenId, uint8 player2Spell) external {\r\n    Game storage game = games[gameId];\r\n\r\n    // player 1 must exist\r\n    require(game.player1 != address(0));\r\n\r\n    // player 2 must not exist\r\n    require(game.player2 == address(0));\r\n    \r\n    // player1 cannot be player2\r\n    require(game.player1 != game.player2);\r\n    \r\n    // spell must be valid\r\n    require(player2Spell > 0 && player2Spell < 4);\r\n    \r\n    // TODO: player 2 wizard power can only be equal to or greater than player 1 wizard\r\n   \r\n    // TODO: transfer wizard to this contract\r\n    // wizards.transferFrom(msg.sender, address(this), tokenId);\r\n\r\n    // update game details\r\n    game.player2 = msg.sender;\r\n    game.player2TokenId = tokenId;\r\n    game.player2Spell = player2Spell;\r\n    game.timer = now;\r\n    \r\n    emit GameUpdate(gameId);\r\n  }\r\n\r\n  function revealSpell(uint256 gameId, uint256 salt, uint8 player1Spell) external {\r\n    Game storage game = games[gameId];\r\n\r\n    // player 2 must exist\r\n    require(game.player2 != address(0));\r\n    \r\n    // game must not have ended\r\n    require(game.winner == address(0));\r\n    \r\n    // spell must be valid\r\n    require(player1Spell > 0 && player1Spell < 4);\r\n    \r\n    bytes32 revealHash = keccak256(abi.encodePacked(address(this), salt, player1Spell));\r\n\r\n    // revealed hash must match committed hash\r\n    require(revealHash == game.player1SpellHash);\r\n    \r\n    // set player 1 spell\r\n    game.player1Spell = player1Spell;\r\n    \r\n    uint8 player2Spell = game.player2Spell;\r\n    \r\n    emit GameUpdate(gameId);\r\n\r\n    if (player1Spell == player2Spell) {\r\n      // draw\r\n      game.winner = address(this);\r\n      // TODO: return wizards to rightful owners\r\n      // wizards.transferFrom(address(this), game.player1, game.player1TokenId);\r\n      // wizards.transferFrom(address(this), game.player2, game.player2TokenId);\r\n      return;\r\n    }\r\n\r\n    // Fire is effective against wind and weak to water\r\n    if (player1Spell == ELEMENT_FIRE) {\r\n      if (player2Spell == ELEMENT_WIND) {\r\n        // player 1 wins\r\n        _winner(gameId, game.player1);\r\n      } else {\r\n        // player 2 wins\r\n        _winner(gameId, game.player2);\r\n      }\r\n    }\r\n\r\n    // Water is effective against fire and weak to wind\r\n    if (player1Spell == ELEMENT_WATER) {\r\n      if (player2Spell == ELEMENT_FIRE) {\r\n        // player 1 wins\r\n        _winner(gameId, game.player1);\r\n      } else {\r\n        // player 2 wins\r\n        _winner(gameId, game.player2);\r\n      }\r\n    }\r\n\r\n    // Wind is effective against water and weak to fire\r\n    if (player1Spell == ELEMENT_WIND) {\r\n      if (player2Spell == ELEMENT_WATER) {\r\n        // player 1 wins\r\n        _winner(gameId, game.player1);\r\n      } else {\r\n        // player 2 wins\r\n        _winner(gameId, game.player2);\r\n      }\r\n    }\r\n  }\r\n\r\n  function timeout(uint256 gameId) public {\r\n    Game storage game = games[gameId];\r\n    \r\n    // game must not have ended\r\n    require(game.winner == address(0));\r\n    \r\n    // game timer must have started\r\n    require(game.timer != 0);\r\n\r\n    // game must have timed out\r\n    require(now - game.timer >= MAX_WAIT);\r\n\r\n    // if player 1 did not reveal their spell\r\n    // player2 wins automatically\r\n    _winner(gameId, game.player2);\r\n    \r\n    emit GameUpdate(gameId);\r\n  }\r\n\r\n  function _winner(uint256 gameId, address winner) internal {\r\n    Game storage game = games[gameId];\r\n    game.winner = winner;\r\n    // wizards.transferFrom(address(this), winner, game.player2TokenId);\r\n    // wizards.transferFrom(address(this), winner, game.player1TokenId);\r\n  }\r\n  \r\n  function getGames(uint256 from, uint256 limit, bool descending) public view returns (Game [] memory) {\r\n    Game [] memory gameArr = new Game[](limit);\r\n    if (descending) {\r\n      for (uint256 i = 0; i < limit; i++) {\r\n        gameArr[i] = games[from - i];\r\n      }\r\n    } else {\r\n      for (uint256 i = 0; i < limit; i++) {\r\n        gameArr[i] = games[from + i];\r\n      }\r\n    }\r\n    return gameArr;\r\n  }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"gameId\",\"type\":\"uint256\"}],\"name\":\"timeout\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"games\",\"outputs\":[{\"name\":\"id\",\"type\":\"uint256\"},{\"name\":\"player1\",\"type\":\"address\"},{\"name\":\"player1TokenId\",\"type\":\"uint256\"},{\"name\":\"player1SpellHash\",\"type\":\"bytes32\"},{\"name\":\"player1Spell\",\"type\":\"uint8\"},{\"name\":\"player2\",\"type\":\"address\"},{\"name\":\"player2TokenId\",\"type\":\"uint256\"},{\"name\":\"player2Spell\",\"type\":\"uint8\"},{\"name\":\"timer\",\"type\":\"uint256\"},{\"name\":\"winner\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"from\",\"type\":\"uint256\"},{\"name\":\"limit\",\"type\":\"uint256\"},{\"name\":\"descending\",\"type\":\"bool\"}],\"name\":\"getGames\",\"outputs\":[{\"components\":[{\"name\":\"id\",\"type\":\"uint256\"},{\"name\":\"player1\",\"type\":\"address\"},{\"name\":\"player1TokenId\",\"type\":\"uint256\"},{\"name\":\"player1SpellHash\",\"type\":\"bytes32\"},{\"name\":\"player1Spell\",\"type\":\"uint8\"},{\"name\":\"player2\",\"type\":\"address\"},{\"name\":\"player2TokenId\",\"type\":\"uint256\"},{\"name\":\"player2Spell\",\"type\":\"uint8\"},{\"name\":\"timer\",\"type\":\"uint256\"},{\"name\":\"winner\",\"type\":\"address\"}],\"name\":\"\",\"type\":\"tuple[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"gameId\",\"type\":\"uint256\"},{\"name\":\"tokenId\",\"type\":\"uint256\"},{\"name\":\"player2Spell\",\"type\":\"uint8\"}],\"name\":\"join\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"gameId\",\"type\":\"uint256\"},{\"name\":\"salt\",\"type\":\"uint256\"},{\"name\":\"player1Spell\",\"type\":\"uint8\"}],\"name\":\"revealSpell\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ids\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenId\",\"type\":\"uint256\"},{\"name\":\"spellHash\",\"type\":\"bytes32\"}],\"name\":\"start\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"gameId\",\"type\":\"uint256\"}],\"name\":\"GameUpdate\",\"type\":\"event\"}]","ContractName":"Wizards","CompilerVersion":"v0.5.1+commit.c8a2cb62","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://f6df20f9a061c12544c831dadcca99d3aefc5664bc1ebcc37081a014e194e772"}]}