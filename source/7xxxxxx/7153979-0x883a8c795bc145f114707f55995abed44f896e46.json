{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.0;\r\n\r\ncontract MinerGame {\r\n\r\n    address owner;\r\n\r\n    string[] allMines;\r\n\r\n    mapping(bytes32 => string) mines;\r\n\r\n    mapping(bytes32 => string) miners;\r\n\r\n    event NewMineEvent (\r\n        bytes32 md5OfMineName,\r\n        string mineName          \r\n    );\r\n\r\n    event DispatchMinersEvent (\r\n        bytes32 md5OfMineName,\r\n        string md5OfMiners\r\n    );\r\n\r\n    constructor()\r\n        public \r\n    {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    function newMine (\r\n        bytes32 md5OfMineName,\r\n        string memory mineName       \r\n    )\r\n        public\r\n        onlyOwner()\r\n        onlyWriteMineOnce(md5OfMineName)\r\n    {\r\n       \r\n        allMines.push(mineName);\r\n        mines[md5OfMineName] = mineName;\r\n        emit NewMineEvent(md5OfMineName,mineName);\r\n    }\r\n\r\n    function dispatchMiners (\r\n        bytes32 md5OfMineName,\r\n        string memory md5OfMiners\r\n    )\r\n        public \r\n        onlyOwner()\r\n        onlyWriteMinersOnce(md5OfMineName)\r\n    {\r\n        miners[md5OfMineName] = md5OfMiners;\r\n        emit DispatchMinersEvent(md5OfMineName,md5OfMiners);\r\n    }\r\n\r\n    function isOwner (\r\n        address addr\r\n    )\r\n        public\r\n        view\r\n        returns(bool)\r\n    {\r\n        if(addr == owner) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function isNotDuplicateMine  (\r\n        bytes32 md5OfMineName\r\n    )\r\n        public\r\n        view\r\n        returns(bool) \r\n    {\r\n        string memory mineName = mines[md5OfMineName];\r\n        return isEmptyString(mineName);\r\n    }\r\n\r\n    function isNotDuplicateMiners(\r\n        bytes32 md5OfMineName\r\n    )\r\n        public \r\n        view \r\n        returns(bool)\r\n    {\r\n        string memory minerHash = miners[md5OfMineName];\r\n        return isEmptyString(minerHash);\r\n    }\r\n\r\n    modifier onlyWriteMineOnce (\r\n        bytes32 signature\r\n    ) {\r\n        require(isNotDuplicateMine(signature),\"error : duplicate miners of the mine\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyWriteMinersOnce (\r\n        bytes32 signature\r\n    ) {\r\n        require(isNotDuplicateMiners(signature),\"error : duplicate miners\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(isOwner(msg.sender),\"only the owner has the permession\");\r\n        _;\r\n    }\r\n\r\n    function getMines ()\r\n        public\r\n        view\r\n        returns(byte[] memory) \r\n    {\r\n        return concat(allMines,0); \r\n    }\r\n\r\n    function getMine (\r\n        bytes32 md5OfMineName\r\n    )\r\n        public\r\n        view \r\n        returns(string memory)\r\n    {\r\n        return mines[md5OfMineName];\r\n    }\r\n\r\n    function getMiners (\r\n        bytes32 md5OfMineName\r\n    )\r\n        public\r\n        view\r\n\t    returns(string memory)\r\n\t{\r\n        return miners[md5OfMineName];\r\n    }\r\n\r\n    // 连接字符串数组\r\n    function concat(\r\n        string[] memory arrs,\r\n        uint256 index\r\n    )\r\n      private \r\n      pure\r\n      returns(byte[] memory)\r\n    {\r\n        uint256 arrSize = arrs.length;\r\n        if(arrs.length == 0) {\r\n            return new byte[](0);\r\n        }\r\n        uint256 total = count(arrs,index);\r\n        byte[] memory result = new byte[](total); \r\n        uint256 k = 0;\r\n        for(uint256 i = index; i < arrSize; i++) {\r\n            bytes memory arr = bytes(arrs[i]);\r\n            for(uint j = 0; j < arr.length; j++) {\r\n                result[k] = arr[j];\r\n                k++;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    // 统计长度\r\n    function count(\r\n        string[] memory arrs,\r\n        uint256 index\r\n    )\r\n        private\r\n        pure\r\n        returns(uint256) \r\n    {\r\n        uint256 total = 0;    \r\n        uint256 len1 = arrs.length;\r\n        for(uint256 i = index;i < len1; i++) {\r\n            bytes memory arr = bytes(arrs[i]);\r\n            total = total + arr.length;\r\n        }\r\n        return total;\r\n    }\r\n\r\n    function compare(\r\n        string memory _a, \r\n        string memory _b\r\n    ) \r\n        private\r\n        pure\r\n        returns (int) \r\n    {\r\n        bytes memory a = bytes(_a);\r\n        bytes memory b = bytes(_b);\r\n        uint minLength = a.length;\r\n        if (b.length < minLength) minLength = b.length;\r\n        //@todo unroll the loop into increments of 32 and do full 32 byte comparisons\r\n        for (uint i = 0; i < minLength; i ++) {\r\n            if (a[i] < b[i])\r\n                return -1;\r\n            else if (a[i] > b[i])\r\n                return 1;\r\n        }  \r\n        if (a.length < b.length)\r\n            return -1;\r\n        else if (a.length > b.length)\r\n            return 1;\r\n        else\r\n            return 0;\r\n    }\r\n    \r\n    function equal(\r\n        string memory _a, \r\n        string memory _b\r\n    ) \r\n        private\r\n        pure\r\n        returns (bool) \r\n    {\r\n        return compare(_a, _b) == 0;\r\n    }\r\n\r\n    function isEmptyString (\r\n        string memory str\r\n    )\r\n        private \r\n        pure\r\n        returns(bool)\r\n    {\r\n        bytes memory temp = bytes(str);\r\n        if(temp.length == 0) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"md5OfMineName\",\"type\":\"bytes32\"},{\"name\":\"md5OfMiners\",\"type\":\"string\"}],\"name\":\"dispatchMiners\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"md5OfMineName\",\"type\":\"bytes32\"}],\"name\":\"getMiners\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"md5OfMineName\",\"type\":\"bytes32\"},{\"name\":\"mineName\",\"type\":\"string\"}],\"name\":\"newMine\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"md5OfMineName\",\"type\":\"bytes32\"}],\"name\":\"isNotDuplicateMiners\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"md5OfMineName\",\"type\":\"bytes32\"}],\"name\":\"getMine\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"md5OfMineName\",\"type\":\"bytes32\"}],\"name\":\"isNotDuplicateMine\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getMines\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes1[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"md5OfMineName\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"mineName\",\"type\":\"string\"}],\"name\":\"NewMineEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"md5OfMineName\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"md5OfMiners\",\"type\":\"string\"}],\"name\":\"DispatchMinersEvent\",\"type\":\"event\"}]","ContractName":"MinerGame","CompilerVersion":"v0.5.1+commit.c8a2cb62","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://120b82fa6a4c755838796a76618c7b4c3d91130b28e75cc7c40988a3e970a7de"}]}