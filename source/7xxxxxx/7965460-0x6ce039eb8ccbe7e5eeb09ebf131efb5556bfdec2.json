{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity >=0.4.25 <0.6.0;\npragma experimental ABIEncoderV2;\n\n\ncontract Modifiable {\n    \n    \n    \n    modifier notNullAddress(address _address) {\n        require(_address != address(0));\n        _;\n    }\n\n    modifier notThisAddress(address _address) {\n        require(_address != address(this));\n        _;\n    }\n\n    modifier notNullOrThisAddress(address _address) {\n        require(_address != address(0));\n        require(_address != address(this));\n        _;\n    }\n\n    modifier notSameAddresses(address _address1, address _address2) {\n        if (_address1 != _address2)\n            _;\n    }\n}\n\ncontract SelfDestructible {\n    \n    \n    \n    bool public selfDestructionDisabled;\n\n    \n    \n    \n    event SelfDestructionDisabledEvent(address wallet);\n    event TriggerSelfDestructionEvent(address wallet);\n\n    \n    \n    \n    \n    function destructor()\n    public\n    view\n    returns (address);\n\n    \n    \n    function disableSelfDestruction()\n    public\n    {\n        \n        require(destructor() == msg.sender);\n\n        \n        selfDestructionDisabled = true;\n\n        \n        emit SelfDestructionDisabledEvent(msg.sender);\n    }\n\n    \n    function triggerSelfDestruction()\n    public\n    {\n        \n        require(destructor() == msg.sender);\n\n        \n        require(!selfDestructionDisabled);\n\n        \n        emit TriggerSelfDestructionEvent(msg.sender);\n\n        \n        selfdestruct(msg.sender);\n    }\n}\n\ncontract Ownable is Modifiable, SelfDestructible {\n    \n    \n    \n    address public deployer;\n    address public operator;\n\n    \n    \n    \n    event SetDeployerEvent(address oldDeployer, address newDeployer);\n    event SetOperatorEvent(address oldOperator, address newOperator);\n\n    \n    \n    \n    constructor(address _deployer) internal notNullOrThisAddress(_deployer) {\n        deployer = _deployer;\n        operator = _deployer;\n    }\n\n    \n    \n    \n    \n    function destructor()\n    public\n    view\n    returns (address)\n    {\n        return deployer;\n    }\n\n    \n    \n    function setDeployer(address newDeployer)\n    public\n    onlyDeployer\n    notNullOrThisAddress(newDeployer)\n    {\n        if (newDeployer != deployer) {\n            \n            address oldDeployer = deployer;\n            deployer = newDeployer;\n\n            \n            emit SetDeployerEvent(oldDeployer, newDeployer);\n        }\n    }\n\n    \n    \n    function setOperator(address newOperator)\n    public\n    onlyOperator\n    notNullOrThisAddress(newOperator)\n    {\n        if (newOperator != operator) {\n            \n            address oldOperator = operator;\n            operator = newOperator;\n\n            \n            emit SetOperatorEvent(oldOperator, newOperator);\n        }\n    }\n\n    \n    \n    function isDeployer()\n    internal\n    view\n    returns (bool)\n    {\n        return msg.sender == deployer;\n    }\n\n    \n    \n    function isOperator()\n    internal\n    view\n    returns (bool)\n    {\n        return msg.sender == operator;\n    }\n\n    \n    \n    \n    function isDeployerOrOperator()\n    internal\n    view\n    returns (bool)\n    {\n        return isDeployer() || isOperator();\n    }\n\n    \n    \n    modifier onlyDeployer() {\n        require(isDeployer());\n        _;\n    }\n\n    modifier notDeployer() {\n        require(!isDeployer());\n        _;\n    }\n\n    modifier onlyOperator() {\n        require(isOperator());\n        _;\n    }\n\n    modifier notOperator() {\n        require(!isOperator());\n        _;\n    }\n\n    modifier onlyDeployerOrOperator() {\n        require(isDeployerOrOperator());\n        _;\n    }\n\n    modifier notDeployerOrOperator() {\n        require(!isDeployerOrOperator());\n        _;\n    }\n}\n\ncontract Beneficiary {\n    \n    \n    \n    function receiveEthersTo(address wallet, string memory balanceType)\n    public\n    payable;\n\n    \n    \n    \n    \n    \n    \n    \n    \n    function receiveTokensTo(address wallet, string memory balanceType, int256 amount, address currencyCt,\n        uint256 currencyId, string memory standard)\n    public;\n}\n\nlibrary MonetaryTypesLib {\n    \n    \n    \n    struct Currency {\n        address ct;\n        uint256 id;\n    }\n\n    struct Figure {\n        int256 amount;\n        Currency currency;\n    }\n\n    struct NoncedAmount {\n        uint256 nonce;\n        int256 amount;\n    }\n}\n\ncontract AccrualBeneficiary is Beneficiary {\n    \n    \n    \n    event CloseAccrualPeriodEvent();\n\n    \n    \n    \n    function closeAccrualPeriod(MonetaryTypesLib.Currency[] memory)\n    public\n    {\n        emit CloseAccrualPeriodEvent();\n    }\n}\n\ncontract Servable is Ownable {\n    \n    \n    \n    struct ServiceInfo {\n        bool registered;\n        uint256 activationTimestamp;\n        mapping(bytes32 => bool) actionsEnabledMap;\n        bytes32[] actionsList;\n    }\n\n    \n    \n    \n    mapping(address => ServiceInfo) internal registeredServicesMap;\n    uint256 public serviceActivationTimeout;\n\n    \n    \n    \n    event ServiceActivationTimeoutEvent(uint256 timeoutInSeconds);\n    event RegisterServiceEvent(address service);\n    event RegisterServiceDeferredEvent(address service, uint256 timeout);\n    event DeregisterServiceEvent(address service);\n    event EnableServiceActionEvent(address service, string action);\n    event DisableServiceActionEvent(address service, string action);\n\n    \n    \n    \n    \n    \n    function setServiceActivationTimeout(uint256 timeoutInSeconds)\n    public\n    onlyDeployer\n    {\n        serviceActivationTimeout = timeoutInSeconds;\n\n        \n        emit ServiceActivationTimeoutEvent(timeoutInSeconds);\n    }\n\n    \n    \n    function registerService(address service)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        _registerService(service, 0);\n\n        \n        emit RegisterServiceEvent(service);\n    }\n\n    \n    \n    function registerServiceDeferred(address service)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        _registerService(service, serviceActivationTimeout);\n\n        \n        emit RegisterServiceDeferredEvent(service, serviceActivationTimeout);\n    }\n\n    \n    \n    function deregisterService(address service)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        require(registeredServicesMap[service].registered);\n\n        registeredServicesMap[service].registered = false;\n\n        \n        emit DeregisterServiceEvent(service);\n    }\n\n    \n    \n    \n    function enableServiceAction(address service, string memory action)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        require(registeredServicesMap[service].registered);\n\n        bytes32 actionHash = hashString(action);\n\n        require(!registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        registeredServicesMap[service].actionsEnabledMap[actionHash] = true;\n        registeredServicesMap[service].actionsList.push(actionHash);\n\n        \n        emit EnableServiceActionEvent(service, action);\n    }\n\n    \n    \n    \n    function disableServiceAction(address service, string memory action)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        bytes32 actionHash = hashString(action);\n\n        require(registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        registeredServicesMap[service].actionsEnabledMap[actionHash] = false;\n\n        \n        emit DisableServiceActionEvent(service, action);\n    }\n\n    \n    \n    \n    function isRegisteredService(address service)\n    public\n    view\n    returns (bool)\n    {\n        return registeredServicesMap[service].registered;\n    }\n\n    \n    \n    \n    function isRegisteredActiveService(address service)\n    public\n    view\n    returns (bool)\n    {\n        return isRegisteredService(service) && block.timestamp >= registeredServicesMap[service].activationTimestamp;\n    }\n\n    \n    \n    \n    function isEnabledServiceAction(address service, string memory action)\n    public\n    view\n    returns (bool)\n    {\n        bytes32 actionHash = hashString(action);\n        return isRegisteredActiveService(service) && registeredServicesMap[service].actionsEnabledMap[actionHash];\n    }\n\n    \n    \n    \n    function hashString(string memory _string)\n    internal\n    pure\n    returns (bytes32)\n    {\n        return keccak256(abi.encodePacked(_string));\n    }\n\n    \n    \n    \n    function _registerService(address service, uint256 timeout)\n    private\n    {\n        if (!registeredServicesMap[service].registered) {\n            registeredServicesMap[service].registered = true;\n            registeredServicesMap[service].activationTimestamp = block.timestamp + timeout;\n        }\n    }\n\n    \n    \n    \n    modifier onlyActiveService() {\n        require(isRegisteredActiveService(msg.sender));\n        _;\n    }\n\n    modifier onlyEnabledServiceAction(string memory action) {\n        require(isEnabledServiceAction(msg.sender, action));\n        _;\n    }\n}\n\ncontract TransferController {\n    \n    \n    \n    event CurrencyTransferred(address from, address to, uint256 value,\n        address currencyCt, uint256 currencyId);\n\n    \n    \n    \n    function isFungible()\n    public\n    view\n    returns (bool);\n\n    function standard()\n    public\n    view\n    returns (string memory);\n\n    \n    function receive(address from, address to, uint256 value, address currencyCt, uint256 currencyId)\n    public;\n\n    \n    function approve(address to, uint256 value, address currencyCt, uint256 currencyId)\n    public;\n\n    \n    function dispatch(address from, address to, uint256 value, address currencyCt, uint256 currencyId)\n    public;\n\n    \n\n    function getReceiveSignature()\n    public\n    pure\n    returns (bytes4)\n    {\n        return bytes4(keccak256(\"receive(address,address,uint256,address,uint256)\"));\n    }\n\n    function getApproveSignature()\n    public\n    pure\n    returns (bytes4)\n    {\n        return bytes4(keccak256(\"approve(address,uint256,address,uint256)\"));\n    }\n\n    function getDispatchSignature()\n    public\n    pure\n    returns (bytes4)\n    {\n        return bytes4(keccak256(\"dispatch(address,address,uint256,address,uint256)\"));\n    }\n}\n\ncontract TransferControllerManager is Ownable {\n    \n    \n    \n    struct CurrencyInfo {\n        bytes32 standard;\n        bool blacklisted;\n    }\n\n    \n    \n    \n    mapping(bytes32 => address) public registeredTransferControllers;\n    mapping(address => CurrencyInfo) public registeredCurrencies;\n\n    \n    \n    \n    event RegisterTransferControllerEvent(string standard, address controller);\n    event ReassociateTransferControllerEvent(string oldStandard, string newStandard, address controller);\n\n    event RegisterCurrencyEvent(address currencyCt, string standard);\n    event DeregisterCurrencyEvent(address currencyCt);\n    event BlacklistCurrencyEvent(address currencyCt);\n    event WhitelistCurrencyEvent(address currencyCt);\n\n    \n    \n    \n    constructor(address deployer) Ownable(deployer) public {\n    }\n\n    \n    \n    \n    function registerTransferController(string calldata standard, address controller)\n    external\n    onlyDeployer\n    notNullAddress(controller)\n    {\n        require(bytes(standard).length > 0, \"Empty standard not supported [TransferControllerManager.sol:58]\");\n        bytes32 standardHash = keccak256(abi.encodePacked(standard));\n\n        registeredTransferControllers[standardHash] = controller;\n\n        \n        emit RegisterTransferControllerEvent(standard, controller);\n    }\n\n    function reassociateTransferController(string calldata oldStandard, string calldata newStandard, address controller)\n    external\n    onlyDeployer\n    notNullAddress(controller)\n    {\n        require(bytes(newStandard).length > 0, \"Empty new standard not supported [TransferControllerManager.sol:72]\");\n        bytes32 oldStandardHash = keccak256(abi.encodePacked(oldStandard));\n        bytes32 newStandardHash = keccak256(abi.encodePacked(newStandard));\n\n        require(registeredTransferControllers[oldStandardHash] != address(0), \"Old standard not registered [TransferControllerManager.sol:76]\");\n        require(registeredTransferControllers[newStandardHash] == address(0), \"New standard previously registered [TransferControllerManager.sol:77]\");\n\n        registeredTransferControllers[newStandardHash] = registeredTransferControllers[oldStandardHash];\n        registeredTransferControllers[oldStandardHash] = address(0);\n\n        \n        emit ReassociateTransferControllerEvent(oldStandard, newStandard, controller);\n    }\n\n    function registerCurrency(address currencyCt, string calldata standard)\n    external\n    onlyOperator\n    notNullAddress(currencyCt)\n    {\n        require(bytes(standard).length > 0, \"Empty standard not supported [TransferControllerManager.sol:91]\");\n        bytes32 standardHash = keccak256(abi.encodePacked(standard));\n\n        require(registeredCurrencies[currencyCt].standard == bytes32(0), \"Currency previously registered [TransferControllerManager.sol:94]\");\n\n        registeredCurrencies[currencyCt].standard = standardHash;\n\n        \n        emit RegisterCurrencyEvent(currencyCt, standard);\n    }\n\n    function deregisterCurrency(address currencyCt)\n    external\n    onlyOperator\n    {\n        require(registeredCurrencies[currencyCt].standard != 0, \"Currency not registered [TransferControllerManager.sol:106]\");\n\n        registeredCurrencies[currencyCt].standard = bytes32(0);\n        registeredCurrencies[currencyCt].blacklisted = false;\n\n        \n        emit DeregisterCurrencyEvent(currencyCt);\n    }\n\n    function blacklistCurrency(address currencyCt)\n    external\n    onlyOperator\n    {\n        require(registeredCurrencies[currencyCt].standard != bytes32(0), \"Currency not registered [TransferControllerManager.sol:119]\");\n\n        registeredCurrencies[currencyCt].blacklisted = true;\n\n        \n        emit BlacklistCurrencyEvent(currencyCt);\n    }\n\n    function whitelistCurrency(address currencyCt)\n    external\n    onlyOperator\n    {\n        require(registeredCurrencies[currencyCt].standard != bytes32(0), \"Currency not registered [TransferControllerManager.sol:131]\");\n\n        registeredCurrencies[currencyCt].blacklisted = false;\n\n        \n        emit WhitelistCurrencyEvent(currencyCt);\n    }\n\n    \n    function transferController(address currencyCt, string memory standard)\n    public\n    view\n    returns (TransferController)\n    {\n        if (bytes(standard).length > 0) {\n            bytes32 standardHash = keccak256(abi.encodePacked(standard));\n\n            require(registeredTransferControllers[standardHash] != address(0), \"Standard not registered [TransferControllerManager.sol:150]\");\n            return TransferController(registeredTransferControllers[standardHash]);\n        }\n\n        require(registeredCurrencies[currencyCt].standard != bytes32(0), \"Currency not registered [TransferControllerManager.sol:154]\");\n        require(!registeredCurrencies[currencyCt].blacklisted, \"Currency blacklisted [TransferControllerManager.sol:155]\");\n\n        address controllerAddress = registeredTransferControllers[registeredCurrencies[currencyCt].standard];\n        require(controllerAddress != address(0), \"No matching transfer controller [TransferControllerManager.sol:158]\");\n\n        return TransferController(controllerAddress);\n    }\n}\n\ncontract TransferControllerManageable is Ownable {\n    \n    \n    \n    TransferControllerManager public transferControllerManager;\n\n    \n    \n    \n    event SetTransferControllerManagerEvent(TransferControllerManager oldTransferControllerManager,\n        TransferControllerManager newTransferControllerManager);\n\n    \n    \n    \n    \n    \n    function setTransferControllerManager(TransferControllerManager newTransferControllerManager)\n    public\n    onlyDeployer\n    notNullAddress(address(newTransferControllerManager))\n    notSameAddresses(address(newTransferControllerManager), address(transferControllerManager))\n    {\n        \n        TransferControllerManager oldTransferControllerManager = transferControllerManager;\n        transferControllerManager = newTransferControllerManager;\n\n        \n        emit SetTransferControllerManagerEvent(oldTransferControllerManager, newTransferControllerManager);\n    }\n\n    \n    function transferController(address currencyCt, string memory standard)\n    internal\n    view\n    returns (TransferController)\n    {\n        return transferControllerManager.transferController(currencyCt, standard);\n    }\n\n    \n    \n    \n    modifier transferControllerManagerInitialized() {\n        require(address(transferControllerManager) != address(0), \"Transfer controller manager not initialized [TransferControllerManageable.sol:63]\");\n        _;\n    }\n}\n\nlibrary SafeMathIntLib {\n    int256 constant INT256_MIN = int256((uint256(1) << 255));\n    int256 constant INT256_MAX = int256(~((uint256(1) << 255)));\n\n    \n    \n    \n    function div(int256 a, int256 b)\n    internal\n    pure\n    returns (int256)\n    {\n        require(a != INT256_MIN || b != - 1);\n        return a / b;\n    }\n\n    function mul(int256 a, int256 b)\n    internal\n    pure\n    returns (int256)\n    {\n        require(a != - 1 || b != INT256_MIN);\n        \n        require(b != - 1 || a != INT256_MIN);\n        \n        int256 c = a * b;\n        require((b == 0) || (c / b == a));\n        return c;\n    }\n\n    function sub(int256 a, int256 b)\n    internal\n    pure\n    returns (int256)\n    {\n        require((b >= 0 && a - b <= a) || (b < 0 && a - b > a));\n        return a - b;\n    }\n\n    function add(int256 a, int256 b)\n    internal\n    pure\n    returns (int256)\n    {\n        int256 c = a + b;\n        require((b >= 0 && c >= a) || (b < 0 && c < a));\n        return c;\n    }\n\n    \n    \n    \n    function div_nn(int256 a, int256 b)\n    internal\n    pure\n    returns (int256)\n    {\n        require(a >= 0 && b > 0);\n        return a / b;\n    }\n\n    function mul_nn(int256 a, int256 b)\n    internal\n    pure\n    returns (int256)\n    {\n        require(a >= 0 && b >= 0);\n        int256 c = a * b;\n        require(a == 0 || c / a == b);\n        require(c >= 0);\n        return c;\n    }\n\n    function sub_nn(int256 a, int256 b)\n    internal\n    pure\n    returns (int256)\n    {\n        require(a >= 0 && b >= 0 && b <= a);\n        return a - b;\n    }\n\n    function add_nn(int256 a, int256 b)\n    internal\n    pure\n    returns (int256)\n    {\n        require(a >= 0 && b >= 0);\n        int256 c = a + b;\n        require(c >= a);\n        return c;\n    }\n\n    \n    \n    \n    function abs(int256 a)\n    public\n    pure\n    returns (int256)\n    {\n        return a < 0 ? neg(a) : a;\n    }\n\n    function neg(int256 a)\n    public\n    pure\n    returns (int256)\n    {\n        return mul(a, - 1);\n    }\n\n    function toNonZeroInt256(uint256 a)\n    public\n    pure\n    returns (int256)\n    {\n        require(a > 0 && a < (uint256(1) << 255));\n        return int256(a);\n    }\n\n    function toInt256(uint256 a)\n    public\n    pure\n    returns (int256)\n    {\n        require(a >= 0 && a < (uint256(1) << 255));\n        return int256(a);\n    }\n\n    function toUInt256(int256 a)\n    public\n    pure\n    returns (uint256)\n    {\n        require(a >= 0);\n        return uint256(a);\n    }\n\n    function isNonZeroPositiveInt256(int256 a)\n    public\n    pure\n    returns (bool)\n    {\n        return (a > 0);\n    }\n\n    function isPositiveInt256(int256 a)\n    public\n    pure\n    returns (bool)\n    {\n        return (a >= 0);\n    }\n\n    function isNonZeroNegativeInt256(int256 a)\n    public\n    pure\n    returns (bool)\n    {\n        return (a < 0);\n    }\n\n    function isNegativeInt256(int256 a)\n    public\n    pure\n    returns (bool)\n    {\n        return (a <= 0);\n    }\n\n    \n    \n    \n    function clamp(int256 a, int256 min, int256 max)\n    public\n    pure\n    returns (int256)\n    {\n        if (a < min)\n            return min;\n        return (a > max) ? max : a;\n    }\n\n    function clampMin(int256 a, int256 min)\n    public\n    pure\n    returns (int256)\n    {\n        return (a < min) ? min : a;\n    }\n\n    function clampMax(int256 a, int256 max)\n    public\n    pure\n    returns (int256)\n    {\n        return (a > max) ? max : a;\n    }\n}\n\nlibrary SafeMathUintLib {\n    function mul(uint256 a, uint256 b)\n    internal\n    pure\n    returns (uint256)\n    {\n        uint256 c = a * b;\n        assert(a == 0 || c / a == b);\n        return c;\n    }\n\n    function div(uint256 a, uint256 b)\n    internal\n    pure\n    returns (uint256)\n    {\n        \n        uint256 c = a / b;\n        \n        return c;\n    }\n\n    function sub(uint256 a, uint256 b)\n    internal\n    pure\n    returns (uint256)\n    {\n        assert(b <= a);\n        return a - b;\n    }\n\n    function add(uint256 a, uint256 b)\n    internal\n    pure\n    returns (uint256)\n    {\n        uint256 c = a + b;\n        assert(c >= a);\n        return c;\n    }\n\n    \n    \n    \n    function clamp(uint256 a, uint256 min, uint256 max)\n    public\n    pure\n    returns (uint256)\n    {\n        return (a > max) ? max : ((a < min) ? min : a);\n    }\n\n    function clampMin(uint256 a, uint256 min)\n    public\n    pure\n    returns (uint256)\n    {\n        return (a < min) ? min : a;\n    }\n\n    function clampMax(uint256 a, uint256 max)\n    public\n    pure\n    returns (uint256)\n    {\n        return (a > max) ? max : a;\n    }\n}\n\nlibrary CurrenciesLib {\n    using SafeMathUintLib for uint256;\n\n    \n    \n    \n    struct Currencies {\n        MonetaryTypesLib.Currency[] currencies;\n        mapping(address => mapping(uint256 => uint256)) indexByCurrency;\n    }\n\n    \n    \n    \n    function add(Currencies storage self, address currencyCt, uint256 currencyId)\n    internal\n    {\n        \n        if (0 == self.indexByCurrency[currencyCt][currencyId]) {\n            self.currencies.push(MonetaryTypesLib.Currency(currencyCt, currencyId));\n            self.indexByCurrency[currencyCt][currencyId] = self.currencies.length;\n        }\n    }\n\n    function removeByCurrency(Currencies storage self, address currencyCt, uint256 currencyId)\n    internal\n    {\n        \n        uint256 index = self.indexByCurrency[currencyCt][currencyId];\n        if (0 < index)\n            removeByIndex(self, index - 1);\n    }\n\n    function removeByIndex(Currencies storage self, uint256 index)\n    internal\n    {\n        require(index < self.currencies.length, \"Index out of bounds [CurrenciesLib.sol:51]\");\n\n        address currencyCt = self.currencies[index].ct;\n        uint256 currencyId = self.currencies[index].id;\n\n        if (index < self.currencies.length - 1) {\n            self.currencies[index] = self.currencies[self.currencies.length - 1];\n            self.indexByCurrency[self.currencies[index].ct][self.currencies[index].id] = index + 1;\n        }\n        self.currencies.length--;\n        self.indexByCurrency[currencyCt][currencyId] = 0;\n    }\n\n    function count(Currencies storage self)\n    internal\n    view\n    returns (uint256)\n    {\n        return self.currencies.length;\n    }\n\n    function has(Currencies storage self, address currencyCt, uint256 currencyId)\n    internal\n    view\n    returns (bool)\n    {\n        return 0 != self.indexByCurrency[currencyCt][currencyId];\n    }\n\n    function getByIndex(Currencies storage self, uint256 index)\n    internal\n    view\n    returns (MonetaryTypesLib.Currency memory)\n    {\n        require(index < self.currencies.length, \"Index out of bounds [CurrenciesLib.sol:85]\");\n        return self.currencies[index];\n    }\n\n    function getByIndices(Currencies storage self, uint256 low, uint256 up)\n    internal\n    view\n    returns (MonetaryTypesLib.Currency[] memory)\n    {\n        require(0 < self.currencies.length, \"No currencies found [CurrenciesLib.sol:94]\");\n        require(low <= up, \"Bounds parameters mismatch [CurrenciesLib.sol:95]\");\n\n        up = up.clampMax(self.currencies.length - 1);\n        MonetaryTypesLib.Currency[] memory _currencies = new MonetaryTypesLib.Currency[](up - low + 1);\n        for (uint256 i = low; i <= up; i++)\n            _currencies[i - low] = self.currencies[i];\n\n        return _currencies;\n    }\n}\n\nlibrary FungibleBalanceLib {\n    using SafeMathIntLib for int256;\n    using SafeMathUintLib for uint256;\n    using CurrenciesLib for CurrenciesLib.Currencies;\n\n    \n    \n    \n    struct Record {\n        int256 amount;\n        uint256 blockNumber;\n    }\n\n    struct Balance {\n        mapping(address => mapping(uint256 => int256)) amountByCurrency;\n        mapping(address => mapping(uint256 => Record[])) recordsByCurrency;\n\n        CurrenciesLib.Currencies inUseCurrencies;\n        CurrenciesLib.Currencies everUsedCurrencies;\n    }\n\n    \n    \n    \n    function get(Balance storage self, address currencyCt, uint256 currencyId)\n    internal\n    view\n    returns (int256)\n    {\n        return self.amountByCurrency[currencyCt][currencyId];\n    }\n\n    function getByBlockNumber(Balance storage self, address currencyCt, uint256 currencyId, uint256 blockNumber)\n    internal\n    view\n    returns (int256)\n    {\n        (int256 amount,) = recordByBlockNumber(self, currencyCt, currencyId, blockNumber);\n        return amount;\n    }\n\n    function set(Balance storage self, int256 amount, address currencyCt, uint256 currencyId)\n    internal\n    {\n        self.amountByCurrency[currencyCt][currencyId] = amount;\n\n        self.recordsByCurrency[currencyCt][currencyId].push(\n            Record(self.amountByCurrency[currencyCt][currencyId], block.number)\n        );\n\n        updateCurrencies(self, currencyCt, currencyId);\n    }\n\n    function add(Balance storage self, int256 amount, address currencyCt, uint256 currencyId)\n    internal\n    {\n        self.amountByCurrency[currencyCt][currencyId] = self.amountByCurrency[currencyCt][currencyId].add(amount);\n\n        self.recordsByCurrency[currencyCt][currencyId].push(\n            Record(self.amountByCurrency[currencyCt][currencyId], block.number)\n        );\n\n        updateCurrencies(self, currencyCt, currencyId);\n    }\n\n    function sub(Balance storage self, int256 amount, address currencyCt, uint256 currencyId)\n    internal\n    {\n        self.amountByCurrency[currencyCt][currencyId] = self.amountByCurrency[currencyCt][currencyId].sub(amount);\n\n        self.recordsByCurrency[currencyCt][currencyId].push(\n            Record(self.amountByCurrency[currencyCt][currencyId], block.number)\n        );\n\n        updateCurrencies(self, currencyCt, currencyId);\n    }\n\n    function transfer(Balance storage _from, Balance storage _to, int256 amount,\n        address currencyCt, uint256 currencyId)\n    internal\n    {\n        sub(_from, amount, currencyCt, currencyId);\n        add(_to, amount, currencyCt, currencyId);\n    }\n\n    function add_nn(Balance storage self, int256 amount, address currencyCt, uint256 currencyId)\n    internal\n    {\n        self.amountByCurrency[currencyCt][currencyId] = self.amountByCurrency[currencyCt][currencyId].add_nn(amount);\n\n        self.recordsByCurrency[currencyCt][currencyId].push(\n            Record(self.amountByCurrency[currencyCt][currencyId], block.number)\n        );\n\n        updateCurrencies(self, currencyCt, currencyId);\n    }\n\n    function sub_nn(Balance storage self, int256 amount, address currencyCt, uint256 currencyId)\n    internal\n    {\n        self.amountByCurrency[currencyCt][currencyId] = self.amountByCurrency[currencyCt][currencyId].sub_nn(amount);\n\n        self.recordsByCurrency[currencyCt][currencyId].push(\n            Record(self.amountByCurrency[currencyCt][currencyId], block.number)\n        );\n\n        updateCurrencies(self, currencyCt, currencyId);\n    }\n\n    function transfer_nn(Balance storage _from, Balance storage _to, int256 amount,\n        address currencyCt, uint256 currencyId)\n    internal\n    {\n        sub_nn(_from, amount, currencyCt, currencyId);\n        add_nn(_to, amount, currencyCt, currencyId);\n    }\n\n    function recordsCount(Balance storage self, address currencyCt, uint256 currencyId)\n    internal\n    view\n    returns (uint256)\n    {\n        return self.recordsByCurrency[currencyCt][currencyId].length;\n    }\n\n    function recordByBlockNumber(Balance storage self, address currencyCt, uint256 currencyId, uint256 blockNumber)\n    internal\n    view\n    returns (int256, uint256)\n    {\n        uint256 index = indexByBlockNumber(self, currencyCt, currencyId, blockNumber);\n        return 0 < index ? recordByIndex(self, currencyCt, currencyId, index - 1) : (0, 0);\n    }\n\n    function recordByIndex(Balance storage self, address currencyCt, uint256 currencyId, uint256 index)\n    internal\n    view\n    returns (int256, uint256)\n    {\n        if (0 == self.recordsByCurrency[currencyCt][currencyId].length)\n            return (0, 0);\n\n        index = index.clampMax(self.recordsByCurrency[currencyCt][currencyId].length - 1);\n        Record storage record = self.recordsByCurrency[currencyCt][currencyId][index];\n        return (record.amount, record.blockNumber);\n    }\n\n    function lastRecord(Balance storage self, address currencyCt, uint256 currencyId)\n    internal\n    view\n    returns (int256, uint256)\n    {\n        if (0 == self.recordsByCurrency[currencyCt][currencyId].length)\n            return (0, 0);\n\n        Record storage record = self.recordsByCurrency[currencyCt][currencyId][self.recordsByCurrency[currencyCt][currencyId].length - 1];\n        return (record.amount, record.blockNumber);\n    }\n\n    function hasInUseCurrency(Balance storage self, address currencyCt, uint256 currencyId)\n    internal\n    view\n    returns (bool)\n    {\n        return self.inUseCurrencies.has(currencyCt, currencyId);\n    }\n\n    function hasEverUsedCurrency(Balance storage self, address currencyCt, uint256 currencyId)\n    internal\n    view\n    returns (bool)\n    {\n        return self.everUsedCurrencies.has(currencyCt, currencyId);\n    }\n\n    function updateCurrencies(Balance storage self, address currencyCt, uint256 currencyId)\n    internal\n    {\n        if (0 == self.amountByCurrency[currencyCt][currencyId] && self.inUseCurrencies.has(currencyCt, currencyId))\n            self.inUseCurrencies.removeByCurrency(currencyCt, currencyId);\n        else if (!self.inUseCurrencies.has(currencyCt, currencyId)) {\n            self.inUseCurrencies.add(currencyCt, currencyId);\n            self.everUsedCurrencies.add(currencyCt, currencyId);\n        }\n    }\n\n    function indexByBlockNumber(Balance storage self, address currencyCt, uint256 currencyId, uint256 blockNumber)\n    internal\n    view\n    returns (uint256)\n    {\n        if (0 == self.recordsByCurrency[currencyCt][currencyId].length)\n            return 0;\n        for (uint256 i = self.recordsByCurrency[currencyCt][currencyId].length; i > 0; i--)\n            if (self.recordsByCurrency[currencyCt][currencyId][i - 1].blockNumber <= blockNumber)\n                return i;\n        return 0;\n    }\n}\n\nlibrary TxHistoryLib {\n    \n    \n    \n    struct AssetEntry {\n        int256 amount;\n        uint256 blockNumber;\n        address currencyCt;      \n        uint256 currencyId;\n    }\n\n    struct TxHistory {\n        AssetEntry[] deposits;\n        mapping(address => mapping(uint256 => AssetEntry[])) currencyDeposits;\n\n        AssetEntry[] withdrawals;\n        mapping(address => mapping(uint256 => AssetEntry[])) currencyWithdrawals;\n    }\n\n    \n    \n    \n    function addDeposit(TxHistory storage self, int256 amount, address currencyCt, uint256 currencyId)\n    internal\n    {\n        AssetEntry memory deposit = AssetEntry(amount, block.number, currencyCt, currencyId);\n        self.deposits.push(deposit);\n        self.currencyDeposits[currencyCt][currencyId].push(deposit);\n    }\n\n    function addWithdrawal(TxHistory storage self, int256 amount, address currencyCt, uint256 currencyId)\n    internal\n    {\n        AssetEntry memory withdrawal = AssetEntry(amount, block.number, currencyCt, currencyId);\n        self.withdrawals.push(withdrawal);\n        self.currencyWithdrawals[currencyCt][currencyId].push(withdrawal);\n    }\n\n    \n\n    function deposit(TxHistory storage self, uint index)\n    internal\n    view\n    returns (int256 amount, uint256 blockNumber, address currencyCt, uint256 currencyId)\n    {\n        require(index < self.deposits.length, \"Index ouf of bounds [TxHistoryLib.sol:56]\");\n\n        amount = self.deposits[index].amount;\n        blockNumber = self.deposits[index].blockNumber;\n        currencyCt = self.deposits[index].currencyCt;\n        currencyId = self.deposits[index].currencyId;\n    }\n\n    function depositsCount(TxHistory storage self)\n    internal\n    view\n    returns (uint256)\n    {\n        return self.deposits.length;\n    }\n\n    function currencyDeposit(TxHistory storage self, address currencyCt, uint256 currencyId, uint index)\n    internal\n    view\n    returns (int256 amount, uint256 blockNumber)\n    {\n        require(index < self.currencyDeposits[currencyCt][currencyId].length, \"Index out of bounds [TxHistoryLib.sol:77]\");\n\n        amount = self.currencyDeposits[currencyCt][currencyId][index].amount;\n        blockNumber = self.currencyDeposits[currencyCt][currencyId][index].blockNumber;\n    }\n\n    function currencyDepositsCount(TxHistory storage self, address currencyCt, uint256 currencyId)\n    internal\n    view\n    returns (uint256)\n    {\n        return self.currencyDeposits[currencyCt][currencyId].length;\n    }\n\n    \n\n    function withdrawal(TxHistory storage self, uint index)\n    internal\n    view\n    returns (int256 amount, uint256 blockNumber, address currencyCt, uint256 currencyId)\n    {\n        require(index < self.withdrawals.length, \"Index out of bounds [TxHistoryLib.sol:98]\");\n\n        amount = self.withdrawals[index].amount;\n        blockNumber = self.withdrawals[index].blockNumber;\n        currencyCt = self.withdrawals[index].currencyCt;\n        currencyId = self.withdrawals[index].currencyId;\n    }\n\n    function withdrawalsCount(TxHistory storage self)\n    internal\n    view\n    returns (uint256)\n    {\n        return self.withdrawals.length;\n    }\n\n    function currencyWithdrawal(TxHistory storage self, address currencyCt, uint256 currencyId, uint index)\n    internal\n    view\n    returns (int256 amount, uint256 blockNumber)\n    {\n        require(index < self.currencyWithdrawals[currencyCt][currencyId].length, \"Index out of bounds [TxHistoryLib.sol:119]\");\n\n        amount = self.currencyWithdrawals[currencyCt][currencyId][index].amount;\n        blockNumber = self.currencyWithdrawals[currencyCt][currencyId][index].blockNumber;\n    }\n\n    function currencyWithdrawalsCount(TxHistory storage self, address currencyCt, uint256 currencyId)\n    internal\n    view\n    returns (uint256)\n    {\n        return self.currencyWithdrawals[currencyCt][currencyId].length;\n    }\n}\n\ninterface IERC20 {\n    \n    function totalSupply() external view returns (uint256);\n\n    \n    function balanceOf(address account) external view returns (uint256);\n\n    \n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    \n    function allowance(address owner, address spender) external view returns (uint256);\n\n    \n    function approve(address spender, uint256 amount) external returns (bool);\n\n    \n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    \n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    \n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\nlibrary SafeMath {\n    \n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    \n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    \n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        \n        \n        \n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    \n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        \n        require(b > 0, \"SafeMath: division by zero\");\n        uint256 c = a / b;\n        \n\n        return c;\n    }\n\n    \n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n}\n\ncontract ERC20 is IERC20 {\n    using SafeMath for uint256;\n\n    mapping (address => uint256) private _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    \n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    \n    function balanceOf(address account) public view returns (uint256) {\n        return _balances[account];\n    }\n\n    \n    function transfer(address recipient, uint256 amount) public returns (bool) {\n        _transfer(msg.sender, recipient, amount);\n        return true;\n    }\n\n    \n    function allowance(address owner, address spender) public view returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    \n    function approve(address spender, uint256 value) public returns (bool) {\n        _approve(msg.sender, spender, value);\n        return true;\n    }\n\n    \n    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount));\n        return true;\n    }\n\n    \n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));\n        return true;\n    }\n\n    \n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue));\n        return true;\n    }\n\n    \n    function _transfer(address sender, address recipient, uint256 amount) internal {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _balances[sender] = _balances[sender].sub(amount);\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    \n    function _mint(address account, uint256 amount) internal {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n     \n    function _burn(address account, uint256 value) internal {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _totalSupply = _totalSupply.sub(value);\n        _balances[account] = _balances[account].sub(value);\n        emit Transfer(account, address(0), value);\n    }\n\n    \n    function _approve(address owner, address spender, uint256 value) internal {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = value;\n        emit Approval(owner, spender, value);\n    }\n\n    \n    function _burnFrom(address account, uint256 amount) internal {\n        _burn(account, amount);\n        _approve(account, msg.sender, _allowances[account][msg.sender].sub(amount));\n    }\n}\n\nlibrary Roles {\n    struct Role {\n        mapping (address => bool) bearer;\n    }\n\n    \n    function add(Role storage role, address account) internal {\n        require(!has(role, account), \"Roles: account already has role\");\n        role.bearer[account] = true;\n    }\n\n    \n    function remove(Role storage role, address account) internal {\n        require(has(role, account), \"Roles: account does not have role\");\n        role.bearer[account] = false;\n    }\n\n    \n    function has(Role storage role, address account) internal view returns (bool) {\n        require(account != address(0), \"Roles: account is the zero address\");\n        return role.bearer[account];\n    }\n}\n\ncontract MinterRole {\n    using Roles for Roles.Role;\n\n    event MinterAdded(address indexed account);\n    event MinterRemoved(address indexed account);\n\n    Roles.Role private _minters;\n\n    constructor () internal {\n        _addMinter(msg.sender);\n    }\n\n    modifier onlyMinter() {\n        require(isMinter(msg.sender), \"MinterRole: caller does not have the Minter role\");\n        _;\n    }\n\n    function isMinter(address account) public view returns (bool) {\n        return _minters.has(account);\n    }\n\n    function addMinter(address account) public onlyMinter {\n        _addMinter(account);\n    }\n\n    function renounceMinter() public {\n        _removeMinter(msg.sender);\n    }\n\n    function _addMinter(address account) internal {\n        _minters.add(account);\n        emit MinterAdded(account);\n    }\n\n    function _removeMinter(address account) internal {\n        _minters.remove(account);\n        emit MinterRemoved(account);\n    }\n}\n\ncontract ERC20Mintable is ERC20, MinterRole {\n    \n    function mint(address account, uint256 amount) public onlyMinter returns (bool) {\n        _mint(account, amount);\n        return true;\n    }\n}\n\ncontract RevenueToken is ERC20Mintable {\n    using SafeMath for uint256;\n\n    bool public mintingDisabled;\n\n    address[] public holders;\n\n    mapping(address => bool) public holdersMap;\n\n    mapping(address => uint256[]) public balances;\n\n    mapping(address => uint256[]) public balanceBlocks;\n\n    mapping(address => uint256[]) public balanceBlockNumbers;\n\n    event DisableMinting();\n\n    \n    function disableMinting()\n    public\n    onlyMinter\n    {\n        mintingDisabled = true;\n\n        emit DisableMinting();\n    }\n\n    \n    function mint(address to, uint256 value)\n    public\n    onlyMinter\n    returns (bool)\n    {\n        require(!mintingDisabled, \"Minting disabled [RevenueToken.sol:60]\");\n\n        \n        bool minted = super.mint(to, value);\n\n        if (minted) {\n            \n            addBalanceBlocks(to);\n\n            \n            if (!holdersMap[to]) {\n                holdersMap[to] = true;\n                holders.push(to);\n            }\n        }\n\n        return minted;\n    }\n\n    \n    function transfer(address to, uint256 value)\n    public\n    returns (bool)\n    {\n        \n        bool transferred = super.transfer(to, value);\n\n        if (transferred) {\n            \n            addBalanceBlocks(msg.sender);\n            addBalanceBlocks(to);\n\n            \n            if (!holdersMap[to]) {\n                holdersMap[to] = true;\n                holders.push(to);\n            }\n        }\n\n        return transferred;\n    }\n\n    \n    function approve(address spender, uint256 value)\n    public\n    returns (bool)\n    {\n        \n        require(\n            0 == value || 0 == allowance(msg.sender, spender),\n            \"Value or allowance non-zero [RevenueToken.sol:121]\"\n        );\n\n        \n        return super.approve(spender, value);\n    }\n\n    \n    function transferFrom(address from, address to, uint256 value)\n    public\n    returns (bool)\n    {\n        \n        bool transferred = super.transferFrom(from, to, value);\n\n        if (transferred) {\n            \n            addBalanceBlocks(from);\n            addBalanceBlocks(to);\n\n            \n            if (!holdersMap[to]) {\n                holdersMap[to] = true;\n                holders.push(to);\n            }\n        }\n\n        return transferred;\n    }\n\n    \n    function balanceBlocksIn(address account, uint256 startBlock, uint256 endBlock)\n    public\n    view\n    returns (uint256)\n    {\n        require(startBlock < endBlock, \"Bounds parameters mismatch [RevenueToken.sol:173]\");\n        require(account != address(0), \"Account is null address [RevenueToken.sol:174]\");\n\n        if (balanceBlockNumbers[account].length == 0 || endBlock < balanceBlockNumbers[account][0])\n            return 0;\n\n        uint256 i = 0;\n        while (i < balanceBlockNumbers[account].length && balanceBlockNumbers[account][i] < startBlock)\n            i++;\n\n        uint256 r;\n        if (i >= balanceBlockNumbers[account].length)\n            r = balances[account][balanceBlockNumbers[account].length - 1].mul(endBlock.sub(startBlock));\n\n        else {\n            uint256 l = (i == 0) ? startBlock : balanceBlockNumbers[account][i - 1];\n\n            uint256 h = balanceBlockNumbers[account][i];\n            if (h > endBlock)\n                h = endBlock;\n\n            h = h.sub(startBlock);\n            r = (h == 0) ? 0 : balanceBlocks[account][i].mul(h).div(balanceBlockNumbers[account][i].sub(l));\n            i++;\n\n            while (i < balanceBlockNumbers[account].length && balanceBlockNumbers[account][i] < endBlock) {\n                r = r.add(balanceBlocks[account][i]);\n                i++;\n            }\n\n            if (i >= balanceBlockNumbers[account].length)\n                r = r.add(\n                    balances[account][balanceBlockNumbers[account].length - 1].mul(\n                        endBlock.sub(balanceBlockNumbers[account][balanceBlockNumbers[account].length - 1])\n                    )\n                );\n\n            else if (balanceBlockNumbers[account][i - 1] < endBlock)\n                r = r.add(\n                    balanceBlocks[account][i].mul(\n                        endBlock.sub(balanceBlockNumbers[account][i - 1])\n                    ).div(\n                        balanceBlockNumbers[account][i].sub(balanceBlockNumbers[account][i - 1])\n                    )\n                );\n        }\n\n        return r;\n    }\n\n    \n    function balanceUpdatesCount(address account)\n    public\n    view\n    returns (uint256)\n    {\n        return balanceBlocks[account].length;\n    }\n\n    \n    function holdersCount()\n    public\n    view\n    returns (uint256)\n    {\n        return holders.length;\n    }\n\n    \n    function holdersByIndices(uint256 low, uint256 up, bool posOnly)\n    public\n    view\n    returns (address[] memory)\n    {\n        require(low <= up, \"Bounds parameters mismatch [RevenueToken.sol:259]\");\n\n        up = up > holders.length - 1 ? holders.length - 1 : up;\n\n        uint256 length = 0;\n        if (posOnly) {\n            for (uint256 i = low; i <= up; i++)\n                if (0 < balanceOf(holders[i]))\n                    length++;\n        } else\n            length = up - low + 1;\n\n        address[] memory _holders = new address[](length);\n\n        uint256 j = 0;\n        for (uint256 i = low; i <= up; i++)\n            if (!posOnly || 0 < balanceOf(holders[i]))\n                _holders[j++] = holders[i];\n\n        return _holders;\n    }\n\n    function addBalanceBlocks(address account)\n    private\n    {\n        uint256 length = balanceBlockNumbers[account].length;\n        balances[account].push(balanceOf(account));\n        if (0 < length)\n            balanceBlocks[account].push(\n                balances[account][length - 1].mul(\n                    block.number.sub(balanceBlockNumbers[account][length - 1])\n                )\n            );\n        else\n            balanceBlocks[account].push(0);\n        balanceBlockNumbers[account].push(block.number);\n    }\n}\n\nlibrary Address {\n    \n    function isContract(address account) internal view returns (bool) {\n        \n        \n        \n\n        uint256 size;\n        \n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n}\n\nlibrary SafeERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        \n        \n        \n        \n        require((value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value);\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    \n    function callOptionalReturn(IERC20 token, bytes memory data) private {\n        \n        \n\n        \n        \n        \n        \n        \n        require(address(token).isContract(), \"SafeERC20: call to non-contract\");\n\n        \n        (bool success, bytes memory returndata) = address(token).call(data);\n        require(success, \"SafeERC20: low-level call failed\");\n\n        if (returndata.length > 0) { \n            \n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n\ncontract TokenMultiTimelock is Ownable {\n    using SafeERC20 for IERC20;\n\n    \n    \n    \n    struct Release {\n        uint256 earliestReleaseTime;\n        uint256 amount;\n        uint256 blockNumber;\n        bool done;\n    }\n\n    \n    \n    \n    IERC20 public token;\n    address public beneficiary;\n\n    Release[] public releases;\n    uint256 public totalLockedAmount;\n    uint256 public executedReleasesCount;\n\n    \n    \n    \n    event SetTokenEvent(IERC20 token);\n    event SetBeneficiaryEvent(address beneficiary);\n    event DefineReleaseEvent(uint256 earliestReleaseTime, uint256 amount, uint256 blockNumber);\n    event SetReleaseBlockNumberEvent(uint256 index, uint256 blockNumber);\n    event ReleaseEvent(uint256 index, uint256 blockNumber, uint256 earliestReleaseTime,\n        uint256 actualReleaseTime, uint256 amount);\n\n    \n    \n    \n    constructor(address deployer)\n    Ownable(deployer)\n    public\n    {\n    }\n\n    \n    \n    \n    \n    \n    function setToken(IERC20 _token)\n    public\n    onlyOperator\n    notNullOrThisAddress(address(_token))\n    {\n        \n        require(address(token) == address(0), \"Token previously set [TokenMultiTimelock.sol:73]\");\n\n        \n        token = _token;\n\n        \n        emit SetTokenEvent(token);\n    }\n\n    \n    \n    function setBeneficiary(address _beneficiary)\n    public\n    onlyOperator\n    notNullAddress(_beneficiary)\n    {\n        \n        beneficiary = _beneficiary;\n\n        \n        emit SetBeneficiaryEvent(beneficiary);\n    }\n\n    \n    \n    \n    \n    \n    function defineReleases(uint256[] memory earliestReleaseTimes, uint256[] memory amounts, uint256[] memory releaseBlockNumbers)\n    onlyOperator\n    public\n    {\n        require(\n            earliestReleaseTimes.length == amounts.length,\n            \"Earliest release times and amounts lengths mismatch [TokenMultiTimelock.sol:105]\"\n        );\n        require(\n            earliestReleaseTimes.length >= releaseBlockNumbers.length,\n            \"Earliest release times and release block numbers lengths mismatch [TokenMultiTimelock.sol:109]\"\n        );\n\n        \n        require(address(token) != address(0), \"Token not initialized [TokenMultiTimelock.sol:115]\");\n\n        for (uint256 i = 0; i < earliestReleaseTimes.length; i++) {\n            \n            totalLockedAmount += amounts[i];\n\n            \n            \n            require(token.balanceOf(address(this)) >= totalLockedAmount, \"Total locked amount overrun [TokenMultiTimelock.sol:123]\");\n\n            \n            uint256 blockNumber = i < releaseBlockNumbers.length ? releaseBlockNumbers[i] : 0;\n\n            \n            releases.push(Release(earliestReleaseTimes[i], amounts[i], blockNumber, false));\n\n            \n            emit DefineReleaseEvent(earliestReleaseTimes[i], amounts[i], blockNumber);\n        }\n    }\n\n    \n    \n    function releasesCount()\n    public\n    view\n    returns (uint256)\n    {\n        return releases.length;\n    }\n\n    \n    \n    \n    function setReleaseBlockNumber(uint256 index, uint256 blockNumber)\n    public\n    onlyBeneficiary\n    {\n        \n        require(!releases[index].done, \"Release previously done [TokenMultiTimelock.sol:154]\");\n\n        \n        releases[index].blockNumber = blockNumber;\n\n        \n        emit SetReleaseBlockNumberEvent(index, blockNumber);\n    }\n\n    \n    \n    function release(uint256 index)\n    public\n    onlyBeneficiary\n    {\n        \n        Release storage _release = releases[index];\n\n        \n        require(0 < _release.amount, \"Release amount not strictly positive [TokenMultiTimelock.sol:173]\");\n\n        \n        require(!_release.done, \"Release previously done [TokenMultiTimelock.sol:176]\");\n\n        \n        require(block.timestamp >= _release.earliestReleaseTime, \"Block time stamp less than earliest release time [TokenMultiTimelock.sol:179]\");\n\n        \n        _release.done = true;\n\n        \n        if (0 == _release.blockNumber)\n            _release.blockNumber = block.number;\n\n        \n        executedReleasesCount++;\n\n        \n        totalLockedAmount -= _release.amount;\n\n        \n        token.safeTransfer(beneficiary, _release.amount);\n\n        \n        emit ReleaseEvent(index, _release.blockNumber, _release.earliestReleaseTime, block.timestamp, _release.amount);\n    }\n\n    \n    \n    modifier onlyBeneficiary() {\n        require(msg.sender == beneficiary, \"Message sender not beneficiary [TokenMultiTimelock.sol:204]\");\n        _;\n    }\n}\n\ncontract RevenueTokenManager is TokenMultiTimelock {\n    using SafeMathUintLib for uint256;\n\n    \n    \n    \n    uint256[] public totalReleasedAmounts;\n    uint256[] public totalReleasedAmountBlocks;\n\n    \n    \n    \n    constructor(address deployer)\n    public\n    TokenMultiTimelock(deployer)\n    {\n    }\n\n    \n    \n    \n    \n    \n    \n    function release(uint256 index)\n    public\n    onlyBeneficiary\n    {\n        \n        super.release(index);\n\n        \n        _addAmountBlocks(index);\n    }\n\n    \n    \n    \n    \n    \n    function releasedAmountBlocksIn(uint256 startBlock, uint256 endBlock)\n    public\n    view\n    returns (uint256)\n    {\n        require(startBlock < endBlock, \"Bounds parameters mismatch [RevenueTokenManager.sol:60]\");\n\n        if (executedReleasesCount == 0 || endBlock < releases[0].blockNumber)\n            return 0;\n\n        uint256 i = 0;\n        while (i < executedReleasesCount && releases[i].blockNumber < startBlock)\n            i++;\n\n        uint256 r;\n        if (i >= executedReleasesCount)\n            r = totalReleasedAmounts[executedReleasesCount - 1].mul(endBlock.sub(startBlock));\n\n        else {\n            uint256 l = (i == 0) ? startBlock : releases[i - 1].blockNumber;\n\n            uint256 h = releases[i].blockNumber;\n            if (h > endBlock)\n                h = endBlock;\n\n            h = h.sub(startBlock);\n            r = (h == 0) ? 0 : totalReleasedAmountBlocks[i].mul(h).div(releases[i].blockNumber.sub(l));\n            i++;\n\n            while (i < executedReleasesCount && releases[i].blockNumber < endBlock) {\n                r = r.add(totalReleasedAmountBlocks[i]);\n                i++;\n            }\n\n            if (i >= executedReleasesCount)\n                r = r.add(\n                    totalReleasedAmounts[executedReleasesCount - 1].mul(\n                        endBlock.sub(releases[executedReleasesCount - 1].blockNumber)\n                    )\n                );\n\n            else if (releases[i - 1].blockNumber < endBlock)\n                r = r.add(\n                    totalReleasedAmountBlocks[i].mul(\n                        endBlock.sub(releases[i - 1].blockNumber)\n                    ).div(\n                        releases[i].blockNumber.sub(releases[i - 1].blockNumber)\n                    )\n                );\n        }\n\n        return r;\n    }\n\n    \n    \n    \n    function releaseBlockNumbers(uint256 index)\n    public\n    view\n    returns (uint256)\n    {\n        return releases[index].blockNumber;\n    }\n\n    \n    \n    \n    function _addAmountBlocks(uint256 index)\n    private\n    {\n        \n        if (0 < index) {\n            totalReleasedAmounts.push(\n                totalReleasedAmounts[index - 1] + releases[index].amount\n            );\n            totalReleasedAmountBlocks.push(\n                totalReleasedAmounts[index - 1].mul(\n                    releases[index].blockNumber.sub(releases[index - 1].blockNumber)\n                )\n            );\n\n        } else {\n            totalReleasedAmounts.push(releases[index].amount);\n            totalReleasedAmountBlocks.push(0);\n        }\n    }\n}\n\ncontract TokenHolderRevenueFund is Ownable, AccrualBeneficiary, Servable, TransferControllerManageable {\n    using SafeMathIntLib for int256;\n    using SafeMathUintLib for uint256;\n    using FungibleBalanceLib for FungibleBalanceLib.Balance;\n    using TxHistoryLib for TxHistoryLib.TxHistory;\n    using CurrenciesLib for CurrenciesLib.Currencies;\n\n    \n    \n    \n    string constant public CLOSE_ACCRUAL_PERIOD_ACTION = \"close_accrual_period\";\n\n    \n    \n    \n    RevenueTokenManager public revenueTokenManager;\n\n    FungibleBalanceLib.Balance private periodAccrual;\n    CurrenciesLib.Currencies private periodCurrencies;\n\n    FungibleBalanceLib.Balance private aggregateAccrual;\n    CurrenciesLib.Currencies private aggregateCurrencies;\n\n    TxHistoryLib.TxHistory private txHistory;\n\n    mapping(address => mapping(address => mapping(uint256 => uint256[]))) public claimedAccrualBlockNumbersByWalletCurrency;\n\n    mapping(address => mapping(uint256 => uint256[])) public accrualBlockNumbersByCurrency;\n    mapping(address => mapping(uint256 => mapping(uint256 => int256))) public aggregateAccrualAmountByCurrencyBlockNumber;\n\n    mapping(address => FungibleBalanceLib.Balance) private stagedByWallet;\n\n    \n    \n    \n    event SetRevenueTokenManagerEvent(RevenueTokenManager oldRevenueTokenManager,\n        RevenueTokenManager newRevenueTokenManager);\n    event ReceiveEvent(address wallet, int256 amount, address currencyCt,\n        uint256 currencyId);\n    event WithdrawEvent(address to, int256 amount, address currencyCt, uint256 currencyId);\n    event CloseAccrualPeriodEvent(int256 periodAmount, int256 aggregateAmount, address currencyCt,\n        uint256 currencyId);\n    event ClaimAndTransferToBeneficiaryEvent(address wallet, string balanceType, int256 amount,\n        address currencyCt, uint256 currencyId, string standard);\n    event ClaimAndTransferToBeneficiaryByProxyEvent(address wallet, string balanceType, int256 amount,\n        address currencyCt, uint256 currencyId, string standard);\n    event ClaimAndStageEvent(address from, int256 amount, address currencyCt, uint256 currencyId);\n    event WithdrawEvent(address from, int256 amount, address currencyCt, uint256 currencyId,\n        string standard);\n\n    \n    \n    \n    constructor(address deployer) Ownable(deployer) public {\n    }\n\n    \n    \n    \n    \n    \n    function setRevenueTokenManager(RevenueTokenManager newRevenueTokenManager)\n    public\n    onlyDeployer\n    notNullAddress(address(newRevenueTokenManager))\n    {\n        if (newRevenueTokenManager != revenueTokenManager) {\n            \n            RevenueTokenManager oldRevenueTokenManager = revenueTokenManager;\n            revenueTokenManager = newRevenueTokenManager;\n\n            \n            emit SetRevenueTokenManagerEvent(oldRevenueTokenManager, newRevenueTokenManager);\n        }\n    }\n\n    \n    function() external payable {\n        receiveEthersTo(msg.sender, \"\");\n    }\n\n    \n    \n    function receiveEthersTo(address wallet, string memory)\n    public\n    payable\n    {\n        int256 amount = SafeMathIntLib.toNonZeroInt256(msg.value);\n\n        \n        periodAccrual.add(amount, address(0), 0);\n        aggregateAccrual.add(amount, address(0), 0);\n\n        \n        periodCurrencies.add(address(0), 0);\n        aggregateCurrencies.add(address(0), 0);\n\n        \n        txHistory.addDeposit(amount, address(0), 0);\n\n        \n        emit ReceiveEvent(wallet, amount, address(0), 0);\n    }\n\n    \n    \n    \n    \n    \n    function receiveTokens(string memory, int256 amount, address currencyCt, uint256 currencyId,\n        string memory standard)\n    public\n    {\n        receiveTokensTo(msg.sender, \"\", amount, currencyCt, currencyId, standard);\n    }\n\n    \n    \n    \n    \n    \n    \n    function receiveTokensTo(address wallet, string memory, int256 amount, address currencyCt,\n        uint256 currencyId, string memory standard)\n    public\n    {\n        require(amount.isNonZeroPositiveInt256(), \"Amount not strictly positive [TokenHolderRevenueFund.sol:157]\");\n\n        \n        TransferController controller = transferController(currencyCt, standard);\n        (bool success,) = address(controller).delegatecall(\n            abi.encodeWithSelector(\n                controller.getReceiveSignature(), msg.sender, this, uint256(amount), currencyCt, currencyId\n            )\n        );\n        require(success, \"Reception by controller failed [TokenHolderRevenueFund.sol:166]\");\n\n        \n        periodAccrual.add(amount, currencyCt, currencyId);\n        aggregateAccrual.add(amount, currencyCt, currencyId);\n\n        \n        periodCurrencies.add(currencyCt, currencyId);\n        aggregateCurrencies.add(currencyCt, currencyId);\n\n        \n        txHistory.addDeposit(amount, currencyCt, currencyId);\n\n        \n        emit ReceiveEvent(wallet, amount, currencyCt, currencyId);\n    }\n\n    \n    \n    \n    \n    function periodAccrualBalance(address currencyCt, uint256 currencyId)\n    public\n    view\n    returns (int256)\n    {\n        return periodAccrual.get(currencyCt, currencyId);\n    }\n\n    \n    \n    \n    \n    \n    function aggregateAccrualBalance(address currencyCt, uint256 currencyId)\n    public\n    view\n    returns (int256)\n    {\n        return aggregateAccrual.get(currencyCt, currencyId);\n    }\n\n    \n    \n    function periodCurrenciesCount()\n    public\n    view\n    returns (uint256)\n    {\n        return periodCurrencies.count();\n    }\n\n    \n    \n    \n    \n    function periodCurrenciesByIndices(uint256 low, uint256 up)\n    public\n    view\n    returns (MonetaryTypesLib.Currency[] memory)\n    {\n        return periodCurrencies.getByIndices(low, up);\n    }\n\n    \n    \n    function aggregateCurrenciesCount()\n    public\n    view\n    returns (uint256)\n    {\n        return aggregateCurrencies.count();\n    }\n\n    \n    \n    \n    \n    function aggregateCurrenciesByIndices(uint256 low, uint256 up)\n    public\n    view\n    returns (MonetaryTypesLib.Currency[] memory)\n    {\n        return aggregateCurrencies.getByIndices(low, up);\n    }\n\n    \n    \n    function depositsCount()\n    public\n    view\n    returns (uint256)\n    {\n        return txHistory.depositsCount();\n    }\n\n    \n    \n    function deposit(uint index)\n    public\n    view\n    returns (int256 amount, uint256 blockNumber, address currencyCt, uint256 currencyId)\n    {\n        return txHistory.deposit(index);\n    }\n\n    \n    \n    \n    \n    \n    function stagedBalance(address wallet, address currencyCt, uint256 currencyId)\n    public\n    view\n    returns (int256)\n    {\n        return stagedByWallet[wallet].get(currencyCt, currencyId);\n    }\n\n    \n    \n    function closeAccrualPeriod(MonetaryTypesLib.Currency[] memory currencies)\n    public\n    onlyEnabledServiceAction(CLOSE_ACCRUAL_PERIOD_ACTION)\n    {\n        \n        for (uint256 i = 0; i < currencies.length; i++) {\n            MonetaryTypesLib.Currency memory currency = currencies[i];\n\n            \n            int256 periodAmount = periodAccrual.get(currency.ct, currency.id);\n\n            \n            accrualBlockNumbersByCurrency[currency.ct][currency.id].push(block.number);\n\n            \n            aggregateAccrualAmountByCurrencyBlockNumber[currency.ct][currency.id][block.number] = aggregateAccrualBalance(\n                currency.ct, currency.id\n            );\n\n            if (periodAmount > 0) {\n                \n                periodAccrual.set(0, currency.ct, currency.id);\n\n                \n                periodCurrencies.removeByCurrency(currency.ct, currency.id);\n            }\n\n            \n            emit CloseAccrualPeriodEvent(\n                periodAmount,\n                aggregateAccrualAmountByCurrencyBlockNumber[currency.ct][currency.id][block.number],\n                currency.ct, currency.id\n            );\n        }\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    function claimAndTransferToBeneficiary(Beneficiary beneficiary, address destWallet, string memory balanceType,\n        address currencyCt, uint256 currencyId, string memory standard)\n    public\n    {\n        \n        int256 claimedAmount = _claim(msg.sender, currencyCt, currencyId);\n\n        \n        if (address(0) == currencyCt && 0 == currencyId)\n            beneficiary.receiveEthersTo.value(uint256(claimedAmount))(destWallet, balanceType);\n\n        else {\n            \n            TransferController controller = transferController(currencyCt, standard);\n            (bool success,) = address(controller).delegatecall(\n                abi.encodeWithSelector(\n                    controller.getApproveSignature(), address(beneficiary), uint256(claimedAmount), currencyCt, currencyId\n                )\n            );\n            require(success, \"Approval by controller failed [TokenHolderRevenueFund.sol:349]\");\n\n            \n            beneficiary.receiveTokensTo(destWallet, balanceType, claimedAmount, currencyCt, currencyId, standard);\n        }\n\n        \n        emit ClaimAndTransferToBeneficiaryEvent(msg.sender, balanceType, claimedAmount, currencyCt, currencyId, standard);\n    }\n\n    \n    \n    \n    function claimAndStage(address currencyCt, uint256 currencyId)\n    public\n    {\n        \n        int256 claimedAmount = _claim(msg.sender, currencyCt, currencyId);\n\n        \n        stagedByWallet[msg.sender].add(claimedAmount, currencyCt, currencyId);\n\n        \n        emit ClaimAndStageEvent(msg.sender, claimedAmount, currencyCt, currencyId);\n    }\n\n    \n    \n    \n    \n    \n    function withdraw(int256 amount, address currencyCt, uint256 currencyId, string memory standard)\n    public\n    {\n        \n        require(amount.isNonZeroPositiveInt256(), \"Amount not strictly positive [TokenHolderRevenueFund.sol:384]\");\n\n        \n        amount = amount.clampMax(stagedByWallet[msg.sender].get(currencyCt, currencyId));\n\n        \n        stagedByWallet[msg.sender].sub(amount, currencyCt, currencyId);\n\n        \n        if (address(0) == currencyCt && 0 == currencyId)\n            msg.sender.transfer(uint256(amount));\n\n        else {\n            TransferController controller = transferController(currencyCt, standard);\n            (bool success,) = address(controller).delegatecall(\n                abi.encodeWithSelector(\n                    controller.getDispatchSignature(), address(this), msg.sender, uint256(amount), currencyCt, currencyId\n                )\n            );\n            require(success, \"Dispatch by controller failed [TokenHolderRevenueFund.sol:403]\");\n        }\n\n        \n        emit WithdrawEvent(msg.sender, amount, currencyCt, currencyId, standard);\n    }\n\n    \n    \n    \n    function _claim(address wallet, address currencyCt, uint256 currencyId)\n    private\n    returns (int256)\n    {\n        \n        require(0 < accrualBlockNumbersByCurrency[currencyCt][currencyId].length, \"No terminated accrual period found [TokenHolderRevenueFund.sol:418]\");\n\n        \n        uint256[] storage claimedAccrualBlockNumbers = claimedAccrualBlockNumbersByWalletCurrency[wallet][currencyCt][currencyId];\n        uint256 bnLow = (0 == claimedAccrualBlockNumbers.length ? 0 : claimedAccrualBlockNumbers[claimedAccrualBlockNumbers.length - 1]);\n\n        \n        uint256 bnUp = accrualBlockNumbersByCurrency[currencyCt][currencyId][accrualBlockNumbersByCurrency[currencyCt][currencyId].length - 1];\n\n        \n        require(bnLow < bnUp, \"Bounds parameters mismatch [TokenHolderRevenueFund.sol:428]\");\n\n        \n        int256 claimableAmount = aggregateAccrualAmountByCurrencyBlockNumber[currencyCt][currencyId][bnUp]\n        - (0 == bnLow ? 0 : aggregateAccrualAmountByCurrencyBlockNumber[currencyCt][currencyId][bnLow]);\n\n        \n        require(claimableAmount.isNonZeroPositiveInt256(), \"Claimable amount not strictly positive [TokenHolderRevenueFund.sol:435]\");\n\n        \n        int256 walletBalanceBlocks = int256(\n            RevenueToken(address(revenueTokenManager.token())).balanceBlocksIn(wallet, bnLow, bnUp)\n        );\n\n        \n        int256 releasedAmountBlocks = int256(\n            revenueTokenManager.releasedAmountBlocksIn(bnLow, bnUp)\n        );\n\n        \n        int256 claimedAmount = walletBalanceBlocks.mul_nn(claimableAmount).mul_nn(1e18).div_nn(releasedAmountBlocks.mul_nn(1e18));\n\n        \n        claimedAccrualBlockNumbers.push(bnUp);\n\n        \n        return claimedAmount;\n    }\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"int256\"},{\"name\":\"currencyCt\",\"type\":\"address\"},{\"name\":\"currencyId\",\"type\":\"uint256\"},{\"name\":\"standard\",\"type\":\"string\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"wallet\",\"type\":\"address\"},{\"name\":\"currencyCt\",\"type\":\"address\"},{\"name\":\"currencyId\",\"type\":\"uint256\"}],\"name\":\"stagedBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"service\",\"type\":\"address\"}],\"name\":\"isRegisteredActiveService\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"triggerSelfDestruction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"accrualBlockNumbersByCurrency\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"service\",\"type\":\"address\"},{\"name\":\"action\",\"type\":\"string\"}],\"name\":\"enableServiceAction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"service\",\"type\":\"address\"}],\"name\":\"isRegisteredService\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"selfDestructionDisabled\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"currencyCt\",\"type\":\"address\"},{\"name\":\"currencyId\",\"type\":\"uint256\"}],\"name\":\"periodAccrualBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"service\",\"type\":\"address\"},{\"name\":\"action\",\"type\":\"string\"}],\"name\":\"disableServiceAction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"serviceActivationTimeout\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"currencyCt\",\"type\":\"address\"},{\"name\":\"currencyId\",\"type\":\"uint256\"}],\"name\":\"claimAndStage\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"destructor\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"depositsCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"components\":[{\"name\":\"ct\",\"type\":\"address\"},{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"currencies\",\"type\":\"tuple[]\"}],\"name\":\"closeAccrualPeriod\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"service\",\"type\":\"address\"}],\"name\":\"deregisterService\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"operator\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CLOSE_ACCRUAL_PERIOD_ACTION\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"service\",\"type\":\"address\"},{\"name\":\"action\",\"type\":\"string\"}],\"name\":\"isEnabledServiceAction\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"wallet\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"string\"},{\"name\":\"amount\",\"type\":\"int256\"},{\"name\":\"currencyCt\",\"type\":\"address\"},{\"name\":\"currencyId\",\"type\":\"uint256\"},{\"name\":\"standard\",\"type\":\"string\"}],\"name\":\"receiveTokensTo\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"periodCurrenciesCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"disableSelfDestruction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"revenueTokenManager\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"timeoutInSeconds\",\"type\":\"uint256\"}],\"name\":\"setServiceActivationTimeout\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"claimedAccrualBlockNumbersByWalletCurrency\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"service\",\"type\":\"address\"}],\"name\":\"registerServiceDeferred\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newDeployer\",\"type\":\"address\"}],\"name\":\"setDeployer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"low\",\"type\":\"uint256\"},{\"name\":\"up\",\"type\":\"uint256\"}],\"name\":\"aggregateCurrenciesByIndices\",\"outputs\":[{\"components\":[{\"name\":\"ct\",\"type\":\"address\"},{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"\",\"type\":\"tuple[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"wallet\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"string\"}],\"name\":\"receiveEthersTo\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"transferControllerManager\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOperator\",\"type\":\"address\"}],\"name\":\"setOperator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[{\"name\":\"amount\",\"type\":\"int256\"},{\"name\":\"blockNumber\",\"type\":\"uint256\"},{\"name\":\"currencyCt\",\"type\":\"address\"},{\"name\":\"currencyId\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newRevenueTokenManager\",\"type\":\"address\"}],\"name\":\"setRevenueTokenManager\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"aggregateCurrenciesCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"\",\"type\":\"string\"},{\"name\":\"amount\",\"type\":\"int256\"},{\"name\":\"currencyCt\",\"type\":\"address\"},{\"name\":\"currencyId\",\"type\":\"uint256\"},{\"name\":\"standard\",\"type\":\"string\"}],\"name\":\"receiveTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"low\",\"type\":\"uint256\"},{\"name\":\"up\",\"type\":\"uint256\"}],\"name\":\"periodCurrenciesByIndices\",\"outputs\":[{\"components\":[{\"name\":\"ct\",\"type\":\"address\"},{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"\",\"type\":\"tuple[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"beneficiary\",\"type\":\"address\"},{\"name\":\"destWallet\",\"type\":\"address\"},{\"name\":\"balanceType\",\"type\":\"string\"},{\"name\":\"currencyCt\",\"type\":\"address\"},{\"name\":\"currencyId\",\"type\":\"uint256\"},{\"name\":\"standard\",\"type\":\"string\"}],\"name\":\"claimAndTransferToBeneficiary\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newTransferControllerManager\",\"type\":\"address\"}],\"name\":\"setTransferControllerManager\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"deployer\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"aggregateAccrualAmountByCurrencyBlockNumber\",\"outputs\":[{\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"currencyCt\",\"type\":\"address\"},{\"name\":\"currencyId\",\"type\":\"uint256\"}],\"name\":\"aggregateAccrualBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"service\",\"type\":\"address\"}],\"name\":\"registerService\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"deployer\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldRevenueTokenManager\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newRevenueTokenManager\",\"type\":\"address\"}],\"name\":\"SetRevenueTokenManagerEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"wallet\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"int256\"},{\"indexed\":false,\"name\":\"currencyCt\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"currencyId\",\"type\":\"uint256\"}],\"name\":\"ReceiveEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"int256\"},{\"indexed\":false,\"name\":\"currencyCt\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"currencyId\",\"type\":\"uint256\"}],\"name\":\"WithdrawEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"periodAmount\",\"type\":\"int256\"},{\"indexed\":false,\"name\":\"aggregateAmount\",\"type\":\"int256\"},{\"indexed\":false,\"name\":\"currencyCt\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"currencyId\",\"type\":\"uint256\"}],\"name\":\"CloseAccrualPeriodEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"wallet\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"balanceType\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"int256\"},{\"indexed\":false,\"name\":\"currencyCt\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"currencyId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"standard\",\"type\":\"string\"}],\"name\":\"ClaimAndTransferToBeneficiaryEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"wallet\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"balanceType\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"int256\"},{\"indexed\":false,\"name\":\"currencyCt\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"currencyId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"standard\",\"type\":\"string\"}],\"name\":\"ClaimAndTransferToBeneficiaryByProxyEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"int256\"},{\"indexed\":false,\"name\":\"currencyCt\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"currencyId\",\"type\":\"uint256\"}],\"name\":\"ClaimAndStageEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"int256\"},{\"indexed\":false,\"name\":\"currencyCt\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"currencyId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"standard\",\"type\":\"string\"}],\"name\":\"WithdrawEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldTransferControllerManager\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newTransferControllerManager\",\"type\":\"address\"}],\"name\":\"SetTransferControllerManagerEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"timeoutInSeconds\",\"type\":\"uint256\"}],\"name\":\"ServiceActivationTimeoutEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"service\",\"type\":\"address\"}],\"name\":\"RegisterServiceEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"service\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"timeout\",\"type\":\"uint256\"}],\"name\":\"RegisterServiceDeferredEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"service\",\"type\":\"address\"}],\"name\":\"DeregisterServiceEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"service\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"action\",\"type\":\"string\"}],\"name\":\"EnableServiceActionEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"service\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"action\",\"type\":\"string\"}],\"name\":\"DisableServiceActionEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"CloseAccrualPeriodEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldDeployer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newDeployer\",\"type\":\"address\"}],\"name\":\"SetDeployerEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldOperator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newOperator\",\"type\":\"address\"}],\"name\":\"SetOperatorEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"SelfDestructionDisabledEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"TriggerSelfDestructionEvent\",\"type\":\"event\"}]","ContractName":"TokenHolderRevenueFund","CompilerVersion":"v0.5.9+commit.e560f70d","OptimizationUsed":"1","Runs":"0","ConstructorArguments":"000000000000000000000000f05179bac3d1fbef58a2fcd7ad0f769840027cc6","Library":"SafeMathIntLib:2fcb98529d58669e229c453de4b4705bb6b2d414;SafeMathUintLib:0ff948c236c8d4dfcd0168bf243314c8ff8ec967","SwarmSource":"bzzr://dda7e33a6769e61a17f0fc0827ca63b9b07318e00d8b83afd2ed2c2475b3e71f"}]}