{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.25;\n\npragma experimental ABIEncoderV2;\n\n/*\n * Hubii Nahmii\n *\n * Compliant with the Hubii Nahmii specification v0.12.\n *\n * Copyright (C) 2017-2018 Hubii AS\n */\n\n\n/**\n * @title Modifiable\n * @notice A contract with basic modifiers\n */\ncontract Modifiable {\n    //\n    // Modifiers\n    // -----------------------------------------------------------------------------------------------------------------\n    modifier notNullAddress(address _address) {\n        require(_address != address(0));\n        _;\n    }\n\n    modifier notThisAddress(address _address) {\n        require(_address != address(this));\n        _;\n    }\n\n    modifier notNullOrThisAddress(address _address) {\n        require(_address != address(0));\n        require(_address != address(this));\n        _;\n    }\n\n    modifier notSameAddresses(address _address1, address _address2) {\n        if (_address1 != _address2)\n            _;\n    }\n}\n\n/*\n * Hubii Nahmii\n *\n * Compliant with the Hubii Nahmii specification v0.12.\n *\n * Copyright (C) 2017-2018 Hubii AS\n */\n\n\n\n/**\n * @title SelfDestructible\n * @notice Contract that allows for self-destruction\n */\ncontract SelfDestructible {\n    //\n    // Variables\n    // -----------------------------------------------------------------------------------------------------------------\n    bool public selfDestructionDisabled;\n\n    //\n    // Events\n    // -----------------------------------------------------------------------------------------------------------------\n    event SelfDestructionDisabledEvent(address wallet);\n    event TriggerSelfDestructionEvent(address wallet);\n\n    //\n    // Functions\n    // -----------------------------------------------------------------------------------------------------------------\n    /// @notice Get the address of the destructor role\n    function destructor()\n    public\n    view\n    returns (address);\n\n    /// @notice Disable self-destruction of this contract\n    /// @dev This operation can not be undone\n    function disableSelfDestruction()\n    public\n    {\n        // Require that sender is the assigned destructor\n        require(destructor() == msg.sender);\n\n        // Disable self-destruction\n        selfDestructionDisabled = true;\n\n        // Emit event\n        emit SelfDestructionDisabledEvent(msg.sender);\n    }\n\n    /// @notice Destroy this contract\n    function triggerSelfDestruction()\n    public\n    {\n        // Require that sender is the assigned destructor\n        require(destructor() == msg.sender);\n\n        // Require that self-destruction has not been disabled\n        require(!selfDestructionDisabled);\n\n        // Emit event\n        emit TriggerSelfDestructionEvent(msg.sender);\n\n        // Self-destruct and reward destructor\n        selfdestruct(msg.sender);\n    }\n}\n\n/*\n * Hubii Nahmii\n *\n * Compliant with the Hubii Nahmii specification v0.12.\n *\n * Copyright (C) 2017-2018 Hubii AS\n */\n\n\n\n\n\n\n/**\n * @title Ownable\n * @notice A modifiable that has ownership roles\n */\ncontract Ownable is Modifiable, SelfDestructible {\n    //\n    // Variables\n    // -----------------------------------------------------------------------------------------------------------------\n    address public deployer;\n    address public operator;\n\n    //\n    // Events\n    // -----------------------------------------------------------------------------------------------------------------\n    event SetDeployerEvent(address oldDeployer, address newDeployer);\n    event SetOperatorEvent(address oldOperator, address newOperator);\n\n    //\n    // Constructor\n    // -----------------------------------------------------------------------------------------------------------------\n    constructor(address _deployer) internal notNullOrThisAddress(_deployer) {\n        deployer = _deployer;\n        operator = _deployer;\n    }\n\n    //\n    // Functions\n    // -----------------------------------------------------------------------------------------------------------------\n    /// @notice Return the address that is able to initiate self-destruction\n    function destructor()\n    public\n    view\n    returns (address)\n    {\n        return deployer;\n    }\n\n    /// @notice Set the deployer of this contract\n    /// @param newDeployer The address of the new deployer\n    function setDeployer(address newDeployer)\n    public\n    onlyDeployer\n    notNullOrThisAddress(newDeployer)\n    {\n        if (newDeployer != deployer) {\n            // Set new deployer\n            address oldDeployer = deployer;\n            deployer = newDeployer;\n\n            // Emit event\n            emit SetDeployerEvent(oldDeployer, newDeployer);\n        }\n    }\n\n    /// @notice Set the operator of this contract\n    /// @param newOperator The address of the new operator\n    function setOperator(address newOperator)\n    public\n    onlyOperator\n    notNullOrThisAddress(newOperator)\n    {\n        if (newOperator != operator) {\n            // Set new operator\n            address oldOperator = operator;\n            operator = newOperator;\n\n            // Emit event\n            emit SetOperatorEvent(oldOperator, newOperator);\n        }\n    }\n\n    /// @notice Gauge whether message sender is deployer or not\n    /// @return true if msg.sender is deployer, else false\n    function isDeployer()\n    internal\n    view\n    returns (bool)\n    {\n        return msg.sender == deployer;\n    }\n\n    /// @notice Gauge whether message sender is operator or not\n    /// @return true if msg.sender is operator, else false\n    function isOperator()\n    internal\n    view\n    returns (bool)\n    {\n        return msg.sender == operator;\n    }\n\n    /// @notice Gauge whether message sender is operator or deployer on the one hand, or none of these on these on\n    /// on the other hand\n    /// @return true if msg.sender is operator, else false\n    function isDeployerOrOperator()\n    internal\n    view\n    returns (bool)\n    {\n        return isDeployer() || isOperator();\n    }\n\n    // Modifiers\n    // -----------------------------------------------------------------------------------------------------------------\n    modifier onlyDeployer() {\n        require(isDeployer());\n        _;\n    }\n\n    modifier notDeployer() {\n        require(!isDeployer());\n        _;\n    }\n\n    modifier onlyOperator() {\n        require(isOperator());\n        _;\n    }\n\n    modifier notOperator() {\n        require(!isOperator());\n        _;\n    }\n\n    modifier onlyDeployerOrOperator() {\n        require(isDeployerOrOperator());\n        _;\n    }\n\n    modifier notDeployerOrOperator() {\n        require(!isDeployerOrOperator());\n        _;\n    }\n}\n\n/*\n * Hubii Nahmii\n *\n * Compliant with the Hubii Nahmii specification v0.12.\n *\n * Copyright (C) 2017-2018 Hubii AS\n */\n\n\n\n\n\n/**\n * @title Servable\n * @notice An ownable that contains registered services and their actions\n */\ncontract Servable is Ownable {\n    //\n    // Types\n    // -----------------------------------------------------------------------------------------------------------------\n    struct ServiceInfo {\n        bool registered;\n        uint256 activationTimestamp;\n        mapping(bytes32 => bool) actionsEnabledMap;\n        bytes32[] actionsList;\n    }\n\n    //\n    // Variables\n    // -----------------------------------------------------------------------------------------------------------------\n    mapping(address => ServiceInfo) internal registeredServicesMap;\n    uint256 public serviceActivationTimeout;\n\n    //\n    // Events\n    // -----------------------------------------------------------------------------------------------------------------\n    event ServiceActivationTimeoutEvent(uint256 timeoutInSeconds);\n    event RegisterServiceEvent(address service);\n    event RegisterServiceDeferredEvent(address service, uint256 timeout);\n    event DeregisterServiceEvent(address service);\n    event EnableServiceActionEvent(address service, string action);\n    event DisableServiceActionEvent(address service, string action);\n\n    //\n    // Functions\n    // -----------------------------------------------------------------------------------------------------------------\n    /// @notice Set the service activation timeout\n    /// @param timeoutInSeconds The set timeout in unit of seconds\n    function setServiceActivationTimeout(uint256 timeoutInSeconds)\n    public\n    onlyDeployer\n    {\n        serviceActivationTimeout = timeoutInSeconds;\n\n        // Emit event\n        emit ServiceActivationTimeoutEvent(timeoutInSeconds);\n    }\n\n    /// @notice Register a service contract whose activation is immediate\n    /// @param service The address of the service contract to be registered\n    function registerService(address service)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        _registerService(service, 0);\n\n        // Emit event\n        emit RegisterServiceEvent(service);\n    }\n\n    /// @notice Register a service contract whose activation is deferred by the service activation timeout\n    /// @param service The address of the service contract to be registered\n    function registerServiceDeferred(address service)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        _registerService(service, serviceActivationTimeout);\n\n        // Emit event\n        emit RegisterServiceDeferredEvent(service, serviceActivationTimeout);\n    }\n\n    /// @notice Deregister a service contract\n    /// @param service The address of the service contract to be deregistered\n    function deregisterService(address service)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        require(registeredServicesMap[service].registered);\n\n        registeredServicesMap[service].registered = false;\n\n        // Emit event\n        emit DeregisterServiceEvent(service);\n    }\n\n    /// @notice Enable a named action in an already registered service contract\n    /// @param service The address of the registered service contract\n    /// @param action The name of the action to be enabled\n    function enableServiceAction(address service, string action)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        require(registeredServicesMap[service].registered);\n\n        bytes32 actionHash = hashString(action);\n\n        require(!registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        registeredServicesMap[service].actionsEnabledMap[actionHash] = true;\n        registeredServicesMap[service].actionsList.push(actionHash);\n\n        // Emit event\n        emit EnableServiceActionEvent(service, action);\n    }\n\n    /// @notice Enable a named action in a service contract\n    /// @param service The address of the service contract\n    /// @param action The name of the action to be disabled\n    function disableServiceAction(address service, string action)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        bytes32 actionHash = hashString(action);\n\n        require(registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        registeredServicesMap[service].actionsEnabledMap[actionHash] = false;\n\n        // Emit event\n        emit DisableServiceActionEvent(service, action);\n    }\n\n    /// @notice Gauge whether a service contract is registered\n    /// @param service The address of the service contract\n    /// @return true if service is registered, else false\n    function isRegisteredService(address service)\n    public\n    view\n    returns (bool)\n    {\n        return registeredServicesMap[service].registered;\n    }\n\n    /// @notice Gauge whether a service contract is registered and active\n    /// @param service The address of the service contract\n    /// @return true if service is registered and activate, else false\n    function isRegisteredActiveService(address service)\n    public\n    view\n    returns (bool)\n    {\n        return isRegisteredService(service) && block.timestamp >= registeredServicesMap[service].activationTimestamp;\n    }\n\n    /// @notice Gauge whether a service contract action is enabled which implies also registered and active\n    /// @param service The address of the service contract\n    /// @param action The name of action\n    function isEnabledServiceAction(address service, string action)\n    public\n    view\n    returns (bool)\n    {\n        bytes32 actionHash = hashString(action);\n        return isRegisteredActiveService(service) && registeredServicesMap[service].actionsEnabledMap[actionHash];\n    }\n\n    //\n    // Internal functions\n    // -----------------------------------------------------------------------------------------------------------------\n    function hashString(string _string)\n    internal\n    pure\n    returns (bytes32)\n    {\n        return keccak256(abi.encodePacked(_string));\n    }\n\n    //\n    // Private functions\n    // -----------------------------------------------------------------------------------------------------------------\n    function _registerService(address service, uint256 timeout)\n    private\n    {\n        if (!registeredServicesMap[service].registered) {\n            registeredServicesMap[service].registered = true;\n            registeredServicesMap[service].activationTimestamp = block.timestamp + timeout;\n        }\n    }\n\n    //\n    // Modifiers\n    // -----------------------------------------------------------------------------------------------------------------\n    modifier onlyActiveService() {\n        require(isRegisteredActiveService(msg.sender));\n        _;\n    }\n\n    modifier onlyEnabledServiceAction(string action) {\n        require(isEnabledServiceAction(msg.sender, action));\n        _;\n    }\n}\n\n/*\n * Hubii Nahmii\n *\n * Compliant with the Hubii Nahmii specification v0.12.\n *\n * Copyright (C) 2017-2018 Hubii AS based on Open-Zeppelin's SafeMath library\n */\n\n\n\n/**\n * @title     SafeMathIntLib\n * @dev       Math operations with safety checks that throw on error\n */\nlibrary SafeMathIntLib {\n    int256 constant INT256_MIN = int256((uint256(1) << 255));\n    int256 constant INT256_MAX = int256(~((uint256(1) << 255)));\n\n    //\n    //Functions below accept positive and negative integers and result must not overflow.\n    //\n    function div(int256 a, int256 b)\n    internal\n    pure\n    returns (int256)\n    {\n        require(a != INT256_MIN || b != - 1);\n        return a / b;\n    }\n\n    function mul(int256 a, int256 b)\n    internal\n    pure\n    returns (int256)\n    {\n        require(a != - 1 || b != INT256_MIN);\n        // overflow\n        require(b != - 1 || a != INT256_MIN);\n        // overflow\n        int256 c = a * b;\n        require((b == 0) || (c / b == a));\n        return c;\n    }\n\n    function sub(int256 a, int256 b)\n    internal\n    pure\n    returns (int256)\n    {\n        require((b >= 0 && a - b <= a) || (b < 0 && a - b > a));\n        return a - b;\n    }\n\n    function add(int256 a, int256 b)\n    internal\n    pure\n    returns (int256)\n    {\n        int256 c = a + b;\n        require((b >= 0 && c >= a) || (b < 0 && c < a));\n        return c;\n    }\n\n    //\n    //Functions below only accept positive integers and result must be greater or equal to zero too.\n    //\n    function div_nn(int256 a, int256 b)\n    internal\n    pure\n    returns (int256)\n    {\n        require(a >= 0 && b > 0);\n        return a / b;\n    }\n\n    function mul_nn(int256 a, int256 b)\n    internal\n    pure\n    returns (int256)\n    {\n        require(a >= 0 && b >= 0);\n        int256 c = a * b;\n        require(a == 0 || c / a == b);\n        require(c >= 0);\n        return c;\n    }\n\n    function sub_nn(int256 a, int256 b)\n    internal\n    pure\n    returns (int256)\n    {\n        require(a >= 0 && b >= 0 && b <= a);\n        return a - b;\n    }\n\n    function add_nn(int256 a, int256 b)\n    internal\n    pure\n    returns (int256)\n    {\n        require(a >= 0 && b >= 0);\n        int256 c = a + b;\n        require(c >= a);\n        return c;\n    }\n\n    //\n    //Conversion and validation functions.\n    //\n    function abs(int256 a)\n    public\n    pure\n    returns (int256)\n    {\n        return a < 0 ? neg(a) : a;\n    }\n\n    function neg(int256 a)\n    public\n    pure\n    returns (int256)\n    {\n        return mul(a, - 1);\n    }\n\n    function toNonZeroInt256(uint256 a)\n    public\n    pure\n    returns (int256)\n    {\n        require(a > 0 && a < (uint256(1) << 255));\n        return int256(a);\n    }\n\n    function toInt256(uint256 a)\n    public\n    pure\n    returns (int256)\n    {\n        require(a >= 0 && a < (uint256(1) << 255));\n        return int256(a);\n    }\n\n    function toUInt256(int256 a)\n    public\n    pure\n    returns (uint256)\n    {\n        require(a >= 0);\n        return uint256(a);\n    }\n\n    function isNonZeroPositiveInt256(int256 a)\n    public\n    pure\n    returns (bool)\n    {\n        return (a > 0);\n    }\n\n    function isPositiveInt256(int256 a)\n    public\n    pure\n    returns (bool)\n    {\n        return (a >= 0);\n    }\n\n    function isNonZeroNegativeInt256(int256 a)\n    public\n    pure\n    returns (bool)\n    {\n        return (a < 0);\n    }\n\n    function isNegativeInt256(int256 a)\n    public\n    pure\n    returns (bool)\n    {\n        return (a <= 0);\n    }\n\n    //\n    //Clamping functions.\n    //\n    function clamp(int256 a, int256 min, int256 max)\n    public\n    pure\n    returns (int256)\n    {\n        if (a < min)\n            return min;\n        return (a > max) ? max : a;\n    }\n\n    function clampMin(int256 a, int256 min)\n    public\n    pure\n    returns (int256)\n    {\n        return (a < min) ? min : a;\n    }\n\n    function clampMax(int256 a, int256 max)\n    public\n    pure\n    returns (int256)\n    {\n        return (a > max) ? max : a;\n    }\n}\n\n/*\n * Hubii Nahmii\n *\n * Compliant with the Hubii Nahmii specification v0.12.\n *\n * Copyright (C) 2017-2018 Hubii AS\n */\n\n\n\nlibrary BlockNumbUintsLib {\n    //\n    // Structures\n    // -----------------------------------------------------------------------------------------------------------------\n    struct Entry {\n        uint256 blockNumber;\n        uint256 value;\n    }\n\n    struct BlockNumbUints {\n        Entry[] entries;\n    }\n\n    //\n    // Functions\n    // -----------------------------------------------------------------------------------------------------------------\n    function currentValue(BlockNumbUints storage self)\n    internal\n    view\n    returns (uint256)\n    {\n        return valueAt(self, block.number);\n    }\n\n    function currentEntry(BlockNumbUints storage self)\n    internal\n    view\n    returns (Entry)\n    {\n        return entryAt(self, block.number);\n    }\n\n    function valueAt(BlockNumbUints storage self, uint256 _blockNumber)\n    internal\n    view\n    returns (uint256)\n    {\n        return entryAt(self, _blockNumber).value;\n    }\n\n    function entryAt(BlockNumbUints storage self, uint256 _blockNumber)\n    internal\n    view\n    returns (Entry)\n    {\n        return self.entries[indexByBlockNumber(self, _blockNumber)];\n    }\n\n    function addEntry(BlockNumbUints storage self, uint256 blockNumber, uint256 value)\n    internal\n    {\n        require(\n            0 == self.entries.length ||\n            blockNumber > self.entries[self.entries.length - 1].blockNumber\n        );\n\n        self.entries.push(Entry(blockNumber, value));\n    }\n\n    function count(BlockNumbUints storage self)\n    internal\n    view\n    returns (uint256)\n    {\n        return self.entries.length;\n    }\n\n    function entries(BlockNumbUints storage self)\n    internal\n    view\n    returns (Entry[])\n    {\n        return self.entries;\n    }\n\n    function indexByBlockNumber(BlockNumbUints storage self, uint256 blockNumber)\n    internal\n    view\n    returns (uint256)\n    {\n        require(0 < self.entries.length);\n        for (uint256 i = self.entries.length - 1; i >= 0; i--)\n            if (blockNumber >= self.entries[i].blockNumber)\n                return i;\n        revert();\n    }\n}\n\n/*\n * Hubii Nahmii\n *\n * Compliant with the Hubii Nahmii specification v0.12.\n *\n * Copyright (C) 2017-2018 Hubii AS\n */\n\n\n\nlibrary BlockNumbIntsLib {\n    //\n    // Structures\n    // -----------------------------------------------------------------------------------------------------------------\n    struct Entry {\n        uint256 blockNumber;\n        int256 value;\n    }\n\n    struct BlockNumbInts {\n        Entry[] entries;\n    }\n\n    //\n    // Functions\n    // -----------------------------------------------------------------------------------------------------------------\n    function currentValue(BlockNumbInts storage self)\n    internal\n    view\n    returns (int256)\n    {\n        return valueAt(self, block.number);\n    }\n\n    function currentEntry(BlockNumbInts storage self)\n    internal\n    view\n    returns (Entry)\n    {\n        return entryAt(self, block.number);\n    }\n\n    function valueAt(BlockNumbInts storage self, uint256 _blockNumber)\n    internal\n    view\n    returns (int256)\n    {\n        return entryAt(self, _blockNumber).value;\n    }\n\n    function entryAt(BlockNumbInts storage self, uint256 _blockNumber)\n    internal\n    view\n    returns (Entry)\n    {\n        return self.entries[indexByBlockNumber(self, _blockNumber)];\n    }\n\n    function addEntry(BlockNumbInts storage self, uint256 blockNumber, int256 value)\n    internal\n    {\n        require(\n            0 == self.entries.length ||\n            blockNumber > self.entries[self.entries.length - 1].blockNumber\n        );\n\n        self.entries.push(Entry(blockNumber, value));\n    }\n\n    function count(BlockNumbInts storage self)\n    internal\n    view\n    returns (uint256)\n    {\n        return self.entries.length;\n    }\n\n    function entries(BlockNumbInts storage self)\n    internal\n    view\n    returns (Entry[])\n    {\n        return self.entries;\n    }\n\n    function indexByBlockNumber(BlockNumbInts storage self, uint256 blockNumber)\n    internal\n    view\n    returns (uint256)\n    {\n        require(0 < self.entries.length);\n        for (uint256 i = self.entries.length - 1; i >= 0; i--)\n            if (blockNumber >= self.entries[i].blockNumber)\n                return i;\n        revert();\n    }\n}\n\n/*\n * Hubii Nahmii\n *\n * Compliant with the Hubii Nahmii specification v0.12.\n *\n * Copyright (C) 2017-2018 Hubii AS\n */\n\n\n\nlibrary ConstantsLib {\n    // Get the fraction that represents the entirety, equivalent of 100%\n    function PARTS_PER()\n    public\n    pure\n    returns (int256)\n    {\n        return 1e18;\n    }\n}\n\n/*\n * Hubii Nahmii\n *\n * Compliant with the Hubii Nahmii specification v0.12.\n *\n * Copyright (C) 2017-2018 Hubii AS\n */\n\n\n\n\n\n\nlibrary BlockNumbDisdIntsLib {\n    using SafeMathIntLib for int256;\n\n    //\n    // Structures\n    // -----------------------------------------------------------------------------------------------------------------\n    struct Discount {\n        int256 tier;\n        int256 value;\n    }\n\n    struct Entry {\n        uint256 blockNumber;\n        int256 nominal;\n        Discount[] discounts;\n    }\n\n    struct BlockNumbDisdInts {\n        Entry[] entries;\n    }\n\n    //\n    // Functions\n    // -----------------------------------------------------------------------------------------------------------------\n    function currentNominalValue(BlockNumbDisdInts storage self)\n    internal\n    view\n    returns (int256)\n    {\n        return nominalValueAt(self, block.number);\n    }\n\n    function currentDiscountedValue(BlockNumbDisdInts storage self, int256 tier)\n    internal\n    view\n    returns (int256)\n    {\n        return discountedValueAt(self, block.number, tier);\n    }\n\n    function currentEntry(BlockNumbDisdInts storage self)\n    internal\n    view\n    returns (Entry)\n    {\n        return entryAt(self, block.number);\n    }\n\n    function nominalValueAt(BlockNumbDisdInts storage self, uint256 _blockNumber)\n    internal\n    view\n    returns (int256)\n    {\n        return entryAt(self, _blockNumber).nominal;\n    }\n\n    function discountedValueAt(BlockNumbDisdInts storage self, uint256 _blockNumber, int256 tier)\n    internal\n    view\n    returns (int256)\n    {\n        Entry memory entry = entryAt(self, _blockNumber);\n        if (0 < entry.discounts.length) {\n            uint256 index = indexByTier(entry.discounts, tier);\n            if (0 < index)\n                return entry.nominal.mul(\n                    ConstantsLib.PARTS_PER().sub(entry.discounts[index - 1].value)\n                ).div(\n                    ConstantsLib.PARTS_PER()\n                );\n            else\n                return entry.nominal;\n        } else\n            return entry.nominal;\n    }\n\n    function entryAt(BlockNumbDisdInts storage self, uint256 _blockNumber)\n    internal\n    view\n    returns (Entry)\n    {\n        return self.entries[indexByBlockNumber(self, _blockNumber)];\n    }\n\n    function addNominalEntry(BlockNumbDisdInts storage self, uint256 blockNumber, int256 nominal)\n    internal\n    {\n        require(\n            0 == self.entries.length ||\n            blockNumber > self.entries[self.entries.length - 1].blockNumber\n        );\n\n        self.entries.length++;\n        Entry storage entry = self.entries[self.entries.length - 1];\n\n        entry.blockNumber = blockNumber;\n        entry.nominal = nominal;\n    }\n\n    function addDiscountedEntry(BlockNumbDisdInts storage self, uint256 blockNumber, int256 nominal,\n        int256[] discountTiers, int256[] discountValues)\n    internal\n    {\n        require(discountTiers.length == discountValues.length);\n\n        addNominalEntry(self, blockNumber, nominal);\n\n        Entry storage entry = self.entries[self.entries.length - 1];\n        for (uint256 i = 0; i < discountTiers.length; i++)\n            entry.discounts.push(Discount(discountTiers[i], discountValues[i]));\n    }\n\n    function count(BlockNumbDisdInts storage self)\n    internal\n    view\n    returns (uint256)\n    {\n        return self.entries.length;\n    }\n\n    function entries(BlockNumbDisdInts storage self)\n    internal\n    view\n    returns (Entry[])\n    {\n        return self.entries;\n    }\n\n    function indexByBlockNumber(BlockNumbDisdInts storage self, uint256 blockNumber)\n    internal\n    view\n    returns (uint256)\n    {\n        require(0 < self.entries.length);\n        for (uint256 i = self.entries.length - 1; i >= 0; i--)\n            if (blockNumber >= self.entries[i].blockNumber)\n                return i;\n        revert();\n    }\n\n    /// @dev The index returned here is 1-based\n    function indexByTier(Discount[] discounts, int256 tier)\n    internal\n    pure\n    returns (uint256)\n    {\n        require(0 < discounts.length);\n        for (uint256 i = discounts.length; i > 0; i--)\n            if (tier >= discounts[i - 1].tier)\n                return i;\n        return 0;\n    }\n}\n\n/*\n * Hubii Nahmii\n *\n * Compliant with the Hubii Nahmii specification v0.12.\n *\n * Copyright (C) 2017-2018 Hubii AS\n */\n\n\n\n\n/**\n * @title     MonetaryTypesLib\n * @dev       Monetary data types\n */\nlibrary MonetaryTypesLib {\n    //\n    // Structures\n    // -----------------------------------------------------------------------------------------------------------------\n    struct Currency {\n        address ct;\n        uint256 id;\n    }\n\n    struct Figure {\n        int256 amount;\n        Currency currency;\n    }\n\n    struct NoncedAmount {\n        uint256 nonce;\n        int256 amount;\n    }\n}\n\n/*\n * Hubii Nahmii\n *\n * Compliant with the Hubii Nahmii specification v0.12.\n *\n * Copyright (C) 2017-2018 Hubii AS\n */\n\n\n\n\n\nlibrary BlockNumbReferenceCurrenciesLib {\n    //\n    // Structures\n    // -----------------------------------------------------------------------------------------------------------------\n    struct Entry {\n        uint256 blockNumber;\n        MonetaryTypesLib.Currency currency;\n    }\n\n    struct BlockNumbReferenceCurrencies {\n        mapping(address => mapping(uint256 => Entry[])) entriesByCurrency;\n    }\n\n    //\n    // Functions\n    // -----------------------------------------------------------------------------------------------------------------\n    function currentCurrency(BlockNumbReferenceCurrencies storage self, MonetaryTypesLib.Currency referenceCurrency)\n    internal\n    view\n    returns (MonetaryTypesLib.Currency storage)\n    {\n        return currencyAt(self, referenceCurrency, block.number);\n    }\n\n    function currentEntry(BlockNumbReferenceCurrencies storage self, MonetaryTypesLib.Currency referenceCurrency)\n    internal\n    view\n    returns (Entry storage)\n    {\n        return entryAt(self, referenceCurrency, block.number);\n    }\n\n    function currencyAt(BlockNumbReferenceCurrencies storage self, MonetaryTypesLib.Currency referenceCurrency,\n        uint256 _blockNumber)\n    internal\n    view\n    returns (MonetaryTypesLib.Currency storage)\n    {\n        return entryAt(self, referenceCurrency, _blockNumber).currency;\n    }\n\n    function entryAt(BlockNumbReferenceCurrencies storage self, MonetaryTypesLib.Currency referenceCurrency,\n        uint256 _blockNumber)\n    internal\n    view\n    returns (Entry storage)\n    {\n        return self.entriesByCurrency[referenceCurrency.ct][referenceCurrency.id][indexByBlockNumber(self, referenceCurrency, _blockNumber)];\n    }\n\n    function addEntry(BlockNumbReferenceCurrencies storage self, uint256 blockNumber,\n        MonetaryTypesLib.Currency referenceCurrency, MonetaryTypesLib.Currency currency)\n    internal\n    {\n        require(\n            0 == self.entriesByCurrency[referenceCurrency.ct][referenceCurrency.id].length ||\n            blockNumber > self.entriesByCurrency[referenceCurrency.ct][referenceCurrency.id][self.entriesByCurrency[referenceCurrency.ct][referenceCurrency.id].length - 1].blockNumber\n        );\n\n        self.entriesByCurrency[referenceCurrency.ct][referenceCurrency.id].push(Entry(blockNumber, currency));\n    }\n\n    function count(BlockNumbReferenceCurrencies storage self, MonetaryTypesLib.Currency referenceCurrency)\n    internal\n    view\n    returns (uint256)\n    {\n        return self.entriesByCurrency[referenceCurrency.ct][referenceCurrency.id].length;\n    }\n\n    function entriesByCurrency(BlockNumbReferenceCurrencies storage self, MonetaryTypesLib.Currency referenceCurrency)\n    internal\n    view\n    returns (Entry[] storage)\n    {\n        return self.entriesByCurrency[referenceCurrency.ct][referenceCurrency.id];\n    }\n\n    function indexByBlockNumber(BlockNumbReferenceCurrencies storage self, MonetaryTypesLib.Currency referenceCurrency, uint256 blockNumber)\n    internal\n    view\n    returns (uint256)\n    {\n        require(0 < self.entriesByCurrency[referenceCurrency.ct][referenceCurrency.id].length);\n        for (uint256 i = self.entriesByCurrency[referenceCurrency.ct][referenceCurrency.id].length - 1; i >= 0; i--)\n            if (blockNumber >= self.entriesByCurrency[referenceCurrency.ct][referenceCurrency.id][i].blockNumber)\n                return i;\n        revert();\n    }\n}\n\n/*\n * Hubii Nahmii\n *\n * Compliant with the Hubii Nahmii specification v0.12.\n *\n * Copyright (C) 2017-2018 Hubii AS\n */\n\n\n\n\n\n\nlibrary BlockNumbFiguresLib {\n    //\n    // Structures\n    // -----------------------------------------------------------------------------------------------------------------\n    struct Entry {\n        uint256 blockNumber;\n        MonetaryTypesLib.Figure value;\n    }\n\n    struct BlockNumbFigures {\n        Entry[] entries;\n    }\n\n    //\n    // Functions\n    // -----------------------------------------------------------------------------------------------------------------\n    function currentValue(BlockNumbFigures storage self)\n    internal\n    view\n    returns (MonetaryTypesLib.Figure storage)\n    {\n        return valueAt(self, block.number);\n    }\n\n    function currentEntry(BlockNumbFigures storage self)\n    internal\n    view\n    returns (Entry storage)\n    {\n        return entryAt(self, block.number);\n    }\n\n    function valueAt(BlockNumbFigures storage self, uint256 _blockNumber)\n    internal\n    view\n    returns (MonetaryTypesLib.Figure storage)\n    {\n        return entryAt(self, _blockNumber).value;\n    }\n\n    function entryAt(BlockNumbFigures storage self, uint256 _blockNumber)\n    internal\n    view\n    returns (Entry storage)\n    {\n        return self.entries[indexByBlockNumber(self, _blockNumber)];\n    }\n\n    function addEntry(BlockNumbFigures storage self, uint256 blockNumber, MonetaryTypesLib.Figure value)\n    internal\n    {\n        require(\n            0 == self.entries.length ||\n            blockNumber > self.entries[self.entries.length - 1].blockNumber\n        );\n\n        self.entries.push(Entry(blockNumber, value));\n    }\n\n    function count(BlockNumbFigures storage self)\n    internal\n    view\n    returns (uint256)\n    {\n        return self.entries.length;\n    }\n\n    function entries(BlockNumbFigures storage self)\n    internal\n    view\n    returns (Entry[] storage)\n    {\n        return self.entries;\n    }\n\n    function indexByBlockNumber(BlockNumbFigures storage self, uint256 blockNumber)\n    internal\n    view\n    returns (uint256)\n    {\n        require(0 < self.entries.length);\n        for (uint256 i = self.entries.length - 1; i >= 0; i--)\n            if (blockNumber >= self.entries[i].blockNumber)\n                return i;\n        revert();\n    }\n}\n\n/*\n * Hubii Nahmii\n *\n * Compliant with the Hubii Nahmii specification v0.12.\n *\n * Copyright (C) 2017-2018 Hubii AS\n */\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * @title Configuration\n * @notice An oracle for configurations values\n */\ncontract Configuration is Modifiable, Ownable, Servable {\n    using SafeMathIntLib for int256;\n    using BlockNumbUintsLib for BlockNumbUintsLib.BlockNumbUints;\n    using BlockNumbIntsLib for BlockNumbIntsLib.BlockNumbInts;\n    using BlockNumbDisdIntsLib for BlockNumbDisdIntsLib.BlockNumbDisdInts;\n    using BlockNumbReferenceCurrenciesLib for BlockNumbReferenceCurrenciesLib.BlockNumbReferenceCurrencies;\n    using BlockNumbFiguresLib for BlockNumbFiguresLib.BlockNumbFigures;\n\n    //\n    // Constants\n    // -----------------------------------------------------------------------------------------------------------------\n    string constant public OPERATIONAL_MODE_ACTION = \"operational_mode\";\n\n    //\n    // Enums\n    // -----------------------------------------------------------------------------------------------------------------\n    enum OperationalMode {Normal, Exit}\n\n    //\n    // Variables\n    // -----------------------------------------------------------------------------------------------------------------\n    OperationalMode public operationalMode = OperationalMode.Normal;\n\n    BlockNumbUintsLib.BlockNumbUints private updateDelayBlocksByBlockNumber;\n    BlockNumbUintsLib.BlockNumbUints private confirmationBlocksByBlockNumber;\n\n    BlockNumbDisdIntsLib.BlockNumbDisdInts private tradeMakerFeeByBlockNumber;\n    BlockNumbDisdIntsLib.BlockNumbDisdInts private tradeTakerFeeByBlockNumber;\n    BlockNumbDisdIntsLib.BlockNumbDisdInts private paymentFeeByBlockNumber;\n    mapping(address => mapping(uint256 => BlockNumbDisdIntsLib.BlockNumbDisdInts)) private currencyPaymentFeeByBlockNumber;\n\n    BlockNumbIntsLib.BlockNumbInts private tradeMakerMinimumFeeByBlockNumber;\n    BlockNumbIntsLib.BlockNumbInts private tradeTakerMinimumFeeByBlockNumber;\n    BlockNumbIntsLib.BlockNumbInts private paymentMinimumFeeByBlockNumber;\n    mapping(address => mapping(uint256 => BlockNumbIntsLib.BlockNumbInts)) private currencyPaymentMinimumFeeByBlockNumber;\n\n    BlockNumbReferenceCurrenciesLib.BlockNumbReferenceCurrencies private feeCurrencyByCurrencyBlockNumber;\n\n    BlockNumbUintsLib.BlockNumbUints private walletLockTimeoutByBlockNumber;\n    BlockNumbUintsLib.BlockNumbUints private cancelOrderChallengeTimeoutByBlockNumber;\n    BlockNumbUintsLib.BlockNumbUints private settlementChallengeTimeoutByBlockNumber;\n\n    BlockNumbUintsLib.BlockNumbUints private fraudStakeFractionByBlockNumber;\n    BlockNumbUintsLib.BlockNumbUints private walletSettlementStakeFractionByBlockNumber;\n    BlockNumbUintsLib.BlockNumbUints private operatorSettlementStakeFractionByBlockNumber;\n\n    BlockNumbFiguresLib.BlockNumbFigures private operatorSettlementStakeByBlockNumber;\n\n    uint256 public earliestSettlementBlockNumber;\n    bool public earliestSettlementBlockNumberUpdateDisabled;\n\n    //\n    // Events\n    // -----------------------------------------------------------------------------------------------------------------\n    event SetOperationalModeExitEvent();\n    event SetUpdateDelayBlocksEvent(uint256 fromBlockNumber, uint256 newBlocks);\n    event SetConfirmationBlocksEvent(uint256 fromBlockNumber, uint256 newBlocks);\n    event SetTradeMakerFeeEvent(uint256 fromBlockNumber, int256 nominal, int256[] discountTiers, int256[] discountValues);\n    event SetTradeTakerFeeEvent(uint256 fromBlockNumber, int256 nominal, int256[] discountTiers, int256[] discountValues);\n    event SetPaymentFeeEvent(uint256 fromBlockNumber, int256 nominal, int256[] discountTiers, int256[] discountValues);\n    event SetCurrencyPaymentFeeEvent(uint256 fromBlockNumber, address currencyCt, uint256 currencyId, int256 nominal,\n        int256[] discountTiers, int256[] discountValues);\n    event SetTradeMakerMinimumFeeEvent(uint256 fromBlockNumber, int256 nominal);\n    event SetTradeTakerMinimumFeeEvent(uint256 fromBlockNumber, int256 nominal);\n    event SetPaymentMinimumFeeEvent(uint256 fromBlockNumber, int256 nominal);\n    event SetCurrencyPaymentMinimumFeeEvent(uint256 fromBlockNumber, address currencyCt, uint256 currencyId, int256 nominal);\n    event SetFeeCurrencyEvent(uint256 fromBlockNumber, address referenceCurrencyCt, uint256 referenceCurrencyId,\n        address feeCurrencyCt, uint256 feeCurrencyId);\n    event SetWalletLockTimeoutEvent(uint256 fromBlockNumber, uint256 timeoutInSeconds);\n    event SetCancelOrderChallengeTimeoutEvent(uint256 fromBlockNumber, uint256 timeoutInSeconds);\n    event SetSettlementChallengeTimeoutEvent(uint256 fromBlockNumber, uint256 timeoutInSeconds);\n    event SetWalletSettlementStakeFractionEvent(uint256 fromBlockNumber, uint256 stakeFraction);\n    event SetOperatorSettlementStakeFractionEvent(uint256 fromBlockNumber, uint256 stakeFraction);\n    event SetOperatorSettlementStakeEvent(uint256 fromBlockNumber, int256 stakeAmount, address stakeCurrencyCt,\n        uint256 stakeCurrencyId);\n    event SetFraudStakeFractionEvent(uint256 fromBlockNumber, uint256 stakeFraction);\n    event SetEarliestSettlementBlockNumberEvent(uint256 earliestSettlementBlockNumber);\n    event DisableEarliestSettlementBlockNumberUpdateEvent();\n\n    //\n    // Constructor\n    // -----------------------------------------------------------------------------------------------------------------\n    constructor(address deployer) Ownable(deployer) public {\n        updateDelayBlocksByBlockNumber.addEntry(block.number, 0);\n    }\n\n    //\n\n    // Public functions\n    // -----------------------------------------------------------------------------------------------------------------\n    /// @notice Set operational mode to Exit\n    /// @dev Once operational mode is set to Exit it may not be set back to Normal\n    function setOperationalModeExit()\n    public\n    onlyEnabledServiceAction(OPERATIONAL_MODE_ACTION)\n    {\n        operationalMode = OperationalMode.Exit;\n        emit SetOperationalModeExitEvent();\n    }\n\n    /// @notice Return true if operational mode is Normal\n    function isOperationalModeNormal()\n    public\n    view\n    returns (bool)\n    {\n        return OperationalMode.Normal == operationalMode;\n    }\n\n    /// @notice Return true if operational mode is Exit\n    function isOperationalModeExit()\n    public\n    view\n    returns (bool)\n    {\n        return OperationalMode.Exit == operationalMode;\n    }\n\n    /// @notice Get the current value of update delay blocks\n    /// @return The value of update delay blocks\n    function updateDelayBlocks()\n    public\n    view\n    returns (uint256)\n    {\n        return updateDelayBlocksByBlockNumber.currentValue();\n    }\n\n    /// @notice Get the count of update delay blocks values\n    /// @return The count of update delay blocks values\n    function updateDelayBlocksCount()\n    public\n    view\n    returns (uint256)\n    {\n        return updateDelayBlocksByBlockNumber.count();\n    }\n\n    /// @notice Set the number of update delay blocks\n    /// @param fromBlockNumber Block number from which the update applies\n    /// @param newUpdateDelayBlocks The new update delay blocks value\n    function setUpdateDelayBlocks(uint256 fromBlockNumber, uint256 newUpdateDelayBlocks)\n    public\n    onlyOperator\n    onlyDelayedBlockNumber(fromBlockNumber)\n    {\n        updateDelayBlocksByBlockNumber.addEntry(fromBlockNumber, newUpdateDelayBlocks);\n        emit SetUpdateDelayBlocksEvent(fromBlockNumber, newUpdateDelayBlocks);\n    }\n\n    /// @notice Get the current value of confirmation blocks\n    /// @return The value of confirmation blocks\n    function confirmationBlocks()\n    public\n    view\n    returns (uint256)\n    {\n        return confirmationBlocksByBlockNumber.currentValue();\n    }\n\n    /// @notice Get the count of confirmation blocks values\n    /// @return The count of confirmation blocks values\n    function confirmationBlocksCount()\n    public\n    view\n    returns (uint256)\n    {\n        return confirmationBlocksByBlockNumber.count();\n    }\n\n    /// @notice Set the number of confirmation blocks\n    /// @param fromBlockNumber Block number from which the update applies\n    /// @param newConfirmationBlocks The new confirmation blocks value\n    function setConfirmationBlocks(uint256 fromBlockNumber, uint256 newConfirmationBlocks)\n    public\n    onlyOperator\n    onlyDelayedBlockNumber(fromBlockNumber)\n    {\n        confirmationBlocksByBlockNumber.addEntry(fromBlockNumber, newConfirmationBlocks);\n        emit SetConfirmationBlocksEvent(fromBlockNumber, newConfirmationBlocks);\n    }\n\n    /// @notice Get number of trade maker fee block number tiers\n    function tradeMakerFeesCount()\n    public\n    view\n    returns (uint256)\n    {\n        return tradeMakerFeeByBlockNumber.count();\n    }\n\n    /// @notice Get trade maker relative fee at given block number, possibly discounted by discount tier value\n    /// @param blockNumber The concerned block number\n    /// @param discountTier The concerned discount tier\n    function tradeMakerFee(uint256 blockNumber, int256 discountTier)\n    public\n    view\n    returns (int256)\n    {\n        return tradeMakerFeeByBlockNumber.discountedValueAt(blockNumber, discountTier);\n    }\n\n    /// @notice Set trade maker nominal relative fee and discount tiers and values at given block number tier\n    /// @param fromBlockNumber Block number from which the update applies\n    /// @param nominal Nominal relative fee\n    /// @param nominal Discount tier levels\n    /// @param nominal Discount values\n    function setTradeMakerFee(uint256 fromBlockNumber, int256 nominal, int256[] discountTiers, int256[] discountValues)\n    public\n    onlyOperator\n    onlyDelayedBlockNumber(fromBlockNumber)\n    {\n        tradeMakerFeeByBlockNumber.addDiscountedEntry(fromBlockNumber, nominal, discountTiers, discountValues);\n        emit SetTradeMakerFeeEvent(fromBlockNumber, nominal, discountTiers, discountValues);\n    }\n\n    /// @notice Get number of trade taker fee block number tiers\n    function tradeTakerFeesCount()\n    public\n    view\n    returns (uint256)\n    {\n        return tradeTakerFeeByBlockNumber.count();\n    }\n\n    /// @notice Get trade taker relative fee at given block number, possibly discounted by discount tier value\n    /// @param blockNumber The concerned block number\n    /// @param discountTier The concerned discount tier\n    function tradeTakerFee(uint256 blockNumber, int256 discountTier)\n    public\n    view\n    returns (int256)\n    {\n        return tradeTakerFeeByBlockNumber.discountedValueAt(blockNumber, discountTier);\n    }\n\n    /// @notice Set trade taker nominal relative fee and discount tiers and values at given block number tier\n    /// @param fromBlockNumber Block number from which the update applies\n    /// @param nominal Nominal relative fee\n    /// @param nominal Discount tier levels\n    /// @param nominal Discount values\n    function setTradeTakerFee(uint256 fromBlockNumber, int256 nominal, int256[] discountTiers, int256[] discountValues)\n    public\n    onlyOperator\n    onlyDelayedBlockNumber(fromBlockNumber)\n    {\n        tradeTakerFeeByBlockNumber.addDiscountedEntry(fromBlockNumber, nominal, discountTiers, discountValues);\n        emit SetTradeTakerFeeEvent(fromBlockNumber, nominal, discountTiers, discountValues);\n    }\n\n    /// @notice Get number of payment fee block number tiers\n    function paymentFeesCount()\n    public\n    view\n    returns (uint256)\n    {\n        return paymentFeeByBlockNumber.count();\n    }\n\n    /// @notice Get payment relative fee at given block number, possibly discounted by discount tier value\n    /// @param blockNumber The concerned block number\n    /// @param discountTier The concerned discount tier\n    function paymentFee(uint256 blockNumber, int256 discountTier)\n    public\n    view\n    returns (int256)\n    {\n        return paymentFeeByBlockNumber.discountedValueAt(blockNumber, discountTier);\n    }\n\n    /// @notice Set payment nominal relative fee and discount tiers and values at given block number tier\n    /// @param fromBlockNumber Block number from which the update applies\n    /// @param nominal Nominal relative fee\n    /// @param nominal Discount tier levels\n    /// @param nominal Discount values\n    function setPaymentFee(uint256 fromBlockNumber, int256 nominal, int256[] discountTiers, int256[] discountValues)\n    public\n    onlyOperator\n    onlyDelayedBlockNumber(fromBlockNumber)\n    {\n        paymentFeeByBlockNumber.addDiscountedEntry(fromBlockNumber, nominal, discountTiers, discountValues);\n        emit SetPaymentFeeEvent(fromBlockNumber, nominal, discountTiers, discountValues);\n    }\n\n    /// @notice Get number of payment fee block number tiers of given currency\n    /// @param currencyCt The address of the concerned currency contract (address(0) == ETH)\n    /// @param currencyId The ID of the concerned currency (0 for ETH and ERC20)\n    function currencyPaymentFeesCount(address currencyCt, uint256 currencyId)\n    public\n    view\n    returns (uint256)\n    {\n        return currencyPaymentFeeByBlockNumber[currencyCt][currencyId].count();\n    }\n\n    /// @notice Get payment relative fee for given currency at given block number, possibly discounted by\n    /// discount tier value\n    /// @param blockNumber The concerned block number\n    /// @param currencyCt The address of the concerned currency contract (address(0) == ETH)\n    /// @param currencyId The ID of the concerned currency (0 for ETH and ERC20)\n    /// @param discountTier The concerned discount tier\n    function currencyPaymentFee(uint256 blockNumber, address currencyCt, uint256 currencyId, int256 discountTier)\n    public\n    view\n    returns (int256)\n    {\n        if (0 < currencyPaymentFeeByBlockNumber[currencyCt][currencyId].count())\n            return currencyPaymentFeeByBlockNumber[currencyCt][currencyId].discountedValueAt(\n                blockNumber, discountTier\n            );\n        else\n            return paymentFee(blockNumber, discountTier);\n    }\n\n    /// @notice Set payment nominal relative fee and discount tiers and values for given currency at given\n    /// block number tier\n    /// @param fromBlockNumber Block number from which the update applies\n    /// @param currencyCt The address of the concerned currency contract (address(0) == ETH)\n    /// @param currencyId The ID of the concerned currency (0 for ETH and ERC20)\n    /// @param nominal Nominal relative fee\n    /// @param nominal Discount tier levels\n    /// @param nominal Discount values\n    function setCurrencyPaymentFee(uint256 fromBlockNumber, address currencyCt, uint256 currencyId, int256 nominal,\n        int256[] discountTiers, int256[] discountValues)\n    public\n    onlyOperator\n    onlyDelayedBlockNumber(fromBlockNumber)\n    {\n        currencyPaymentFeeByBlockNumber[currencyCt][currencyId].addDiscountedEntry(\n            fromBlockNumber, nominal, discountTiers, discountValues\n        );\n        emit SetCurrencyPaymentFeeEvent(\n            fromBlockNumber, currencyCt, currencyId, nominal, discountTiers, discountValues\n        );\n    }\n\n    /// @notice Get number of minimum trade maker fee block number tiers\n    function tradeMakerMinimumFeesCount()\n    public\n    view\n    returns (uint256)\n    {\n        return tradeMakerMinimumFeeByBlockNumber.count();\n    }\n\n    /// @notice Get trade maker minimum relative fee at given block number\n    /// @param blockNumber The concerned block number\n    function tradeMakerMinimumFee(uint256 blockNumber)\n    public\n    view\n    returns (int256)\n    {\n        return tradeMakerMinimumFeeByBlockNumber.valueAt(blockNumber);\n    }\n\n    /// @notice Set trade maker minimum relative fee at given block number tier\n    /// @param fromBlockNumber Block number from which the update applies\n    /// @param nominal Minimum relative fee\n    function setTradeMakerMinimumFee(uint256 fromBlockNumber, int256 nominal)\n    public\n    onlyOperator\n    onlyDelayedBlockNumber(fromBlockNumber)\n    {\n        tradeMakerMinimumFeeByBlockNumber.addEntry(fromBlockNumber, nominal);\n        emit SetTradeMakerMinimumFeeEvent(fromBlockNumber, nominal);\n    }\n\n    /// @notice Get number of minimum trade taker fee block number tiers\n    function tradeTakerMinimumFeesCount()\n    public\n    view\n    returns (uint256)\n    {\n        return tradeTakerMinimumFeeByBlockNumber.count();\n    }\n\n    /// @notice Get trade taker minimum relative fee at given block number\n    /// @param blockNumber The concerned block number\n    function tradeTakerMinimumFee(uint256 blockNumber)\n    public\n    view\n    returns (int256)\n    {\n        return tradeTakerMinimumFeeByBlockNumber.valueAt(blockNumber);\n    }\n\n    /// @notice Set trade taker minimum relative fee at given block number tier\n    /// @param fromBlockNumber Block number from which the update applies\n    /// @param nominal Minimum relative fee\n    function setTradeTakerMinimumFee(uint256 fromBlockNumber, int256 nominal)\n    public\n    onlyOperator\n    onlyDelayedBlockNumber(fromBlockNumber)\n    {\n        tradeTakerMinimumFeeByBlockNumber.addEntry(fromBlockNumber, nominal);\n        emit SetTradeTakerMinimumFeeEvent(fromBlockNumber, nominal);\n    }\n\n    /// @notice Get number of minimum payment fee block number tiers\n    function paymentMinimumFeesCount()\n    public\n    view\n    returns (uint256)\n    {\n        return paymentMinimumFeeByBlockNumber.count();\n    }\n\n    /// @notice Get payment minimum relative fee at given block number\n    /// @param blockNumber The concerned block number\n    function paymentMinimumFee(uint256 blockNumber)\n    public\n    view\n    returns (int256)\n    {\n        return paymentMinimumFeeByBlockNumber.valueAt(blockNumber);\n    }\n\n    /// @notice Set payment minimum relative fee at given block number tier\n    /// @param fromBlockNumber Block number from which the update applies\n    /// @param nominal Minimum relative fee\n    function setPaymentMinimumFee(uint256 fromBlockNumber, int256 nominal)\n    public\n    onlyOperator\n    onlyDelayedBlockNumber(fromBlockNumber)\n    {\n        paymentMinimumFeeByBlockNumber.addEntry(fromBlockNumber, nominal);\n        emit SetPaymentMinimumFeeEvent(fromBlockNumber, nominal);\n    }\n\n    /// @notice Get number of minimum payment fee block number tiers for given currency\n    /// @param currencyCt The address of the concerned currency contract (address(0) == ETH)\n    /// @param currencyId The ID of the concerned currency (0 for ETH and ERC20)\n    function currencyPaymentMinimumFeesCount(address currencyCt, uint256 currencyId)\n    public\n    view\n    returns (uint256)\n    {\n        return currencyPaymentMinimumFeeByBlockNumber[currencyCt][currencyId].count();\n    }\n\n    /// @notice Get payment minimum relative fee for given currency at given block number\n    /// @param blockNumber The concerned block number\n    /// @param currencyCt The address of the concerned currency contract (address(0) == ETH)\n    /// @param currencyId The ID of the concerned currency (0 for ETH and ERC20)\n    function currencyPaymentMinimumFee(uint256 blockNumber, address currencyCt, uint256 currencyId)\n    public\n    view\n    returns (int256)\n    {\n        if (0 < currencyPaymentMinimumFeeByBlockNumber[currencyCt][currencyId].count())\n            return currencyPaymentMinimumFeeByBlockNumber[currencyCt][currencyId].valueAt(blockNumber);\n        else\n            return paymentMinimumFee(blockNumber);\n    }\n\n    /// @notice Set payment minimum relative fee for given currency at given block number tier\n    /// @param fromBlockNumber Block number from which the update applies\n    /// @param currencyCt The address of the concerned currency contract (address(0) == ETH)\n    /// @param currencyId The ID of the concerned currency (0 for ETH and ERC20)\n    /// @param nominal Minimum relative fee\n    function setCurrencyPaymentMinimumFee(uint256 fromBlockNumber, address currencyCt, uint256 currencyId, int256 nominal)\n    public\n    onlyOperator\n    onlyDelayedBlockNumber(fromBlockNumber)\n    {\n        currencyPaymentMinimumFeeByBlockNumber[currencyCt][currencyId].addEntry(fromBlockNumber, nominal);\n        emit SetCurrencyPaymentMinimumFeeEvent(fromBlockNumber, currencyCt, currencyId, nominal);\n    }\n\n    /// @notice Get number of fee currencies for the given reference currency\n    /// @param currencyCt The address of the concerned reference currency contract (address(0) == ETH)\n    /// @param currencyId The ID of the concerned reference currency (0 for ETH and ERC20)\n    function feeCurrenciesCount(address currencyCt, uint256 currencyId)\n    public\n    view\n    returns (uint256)\n    {\n        return feeCurrencyByCurrencyBlockNumber.count(MonetaryTypesLib.Currency(currencyCt, currencyId));\n    }\n\n    /// @notice Get the fee currency for the given reference currency at given block number\n    /// @param blockNumber The concerned block number\n    /// @param currencyCt The address of the concerned reference currency contract (address(0) == ETH)\n    /// @param currencyId The ID of the concerned reference currency (0 for ETH and ERC20)\n    function feeCurrency(uint256 blockNumber, address currencyCt, uint256 currencyId)\n    public\n    view\n    returns (address ct, uint256 id)\n    {\n        MonetaryTypesLib.Currency storage _feeCurrency = feeCurrencyByCurrencyBlockNumber.currencyAt(\n            MonetaryTypesLib.Currency(currencyCt, currencyId), blockNumber\n        );\n        ct = _feeCurrency.ct;\n        id = _feeCurrency.id;\n    }\n\n    /// @notice Set the fee currency for the given reference currency at given block number\n    /// @param fromBlockNumber Block number from which the update applies\n    /// @param referenceCurrencyCt The address of the concerned reference currency contract (address(0) == ETH)\n    /// @param referenceCurrencyId The ID of the concerned reference currency (0 for ETH and ERC20)\n    /// @param feeCurrencyCt The address of the concerned fee currency contract (address(0) == ETH)\n    /// @param feeCurrencyId The ID of the concerned fee currency (0 for ETH and ERC20)\n    function setFeeCurrency(uint256 fromBlockNumber, address referenceCurrencyCt, uint256 referenceCurrencyId,\n        address feeCurrencyCt, uint256 feeCurrencyId)\n    public\n    onlyOperator\n    onlyDelayedBlockNumber(fromBlockNumber)\n    {\n        feeCurrencyByCurrencyBlockNumber.addEntry(\n            fromBlockNumber,\n            MonetaryTypesLib.Currency(referenceCurrencyCt, referenceCurrencyId),\n            MonetaryTypesLib.Currency(feeCurrencyCt, feeCurrencyId)\n        );\n        emit SetFeeCurrencyEvent(fromBlockNumber, referenceCurrencyCt, referenceCurrencyId,\n            feeCurrencyCt, feeCurrencyId);\n    }\n\n    /// @notice Get the current value of wallet lock timeout\n    /// @return The value of wallet lock timeout\n    function walletLockTimeout()\n    public\n    view\n    returns (uint256)\n    {\n        return walletLockTimeoutByBlockNumber.currentValue();\n    }\n\n    /// @notice Set timeout of wallet lock\n    /// @param fromBlockNumber Block number from which the update applies\n    /// @param timeoutInSeconds Timeout duration in seconds\n    function setWalletLockTimeout(uint256 fromBlockNumber, uint256 timeoutInSeconds)\n    public\n    onlyOperator\n    onlyDelayedBlockNumber(fromBlockNumber)\n    {\n        walletLockTimeoutByBlockNumber.addEntry(fromBlockNumber, timeoutInSeconds);\n        emit SetWalletLockTimeoutEvent(fromBlockNumber, timeoutInSeconds);\n    }\n\n    /// @notice Get the current value of cancel order challenge timeout\n    /// @return The value of cancel order challenge timeout\n    function cancelOrderChallengeTimeout()\n    public\n    view\n    returns (uint256)\n    {\n        return cancelOrderChallengeTimeoutByBlockNumber.currentValue();\n    }\n\n    /// @notice Set timeout of cancel order challenge\n    /// @param fromBlockNumber Block number from which the update applies\n    /// @param timeoutInSeconds Timeout duration in seconds\n    function setCancelOrderChallengeTimeout(uint256 fromBlockNumber, uint256 timeoutInSeconds)\n    public\n    onlyOperator\n    onlyDelayedBlockNumber(fromBlockNumber)\n    {\n        cancelOrderChallengeTimeoutByBlockNumber.addEntry(fromBlockNumber, timeoutInSeconds);\n        emit SetCancelOrderChallengeTimeoutEvent(fromBlockNumber, timeoutInSeconds);\n    }\n\n    /// @notice Get the current value of settlement challenge timeout\n    /// @return The value of settlement challenge timeout\n    function settlementChallengeTimeout()\n    public\n    view\n    returns (uint256)\n    {\n        return settlementChallengeTimeoutByBlockNumber.currentValue();\n    }\n\n    /// @notice Set timeout of settlement challenges\n    /// @param fromBlockNumber Block number from which the update applies\n    /// @param timeoutInSeconds Timeout duration in seconds\n    function setSettlementChallengeTimeout(uint256 fromBlockNumber, uint256 timeoutInSeconds)\n    public\n    onlyOperator\n    onlyDelayedBlockNumber(fromBlockNumber)\n    {\n        settlementChallengeTimeoutByBlockNumber.addEntry(fromBlockNumber, timeoutInSeconds);\n        emit SetSettlementChallengeTimeoutEvent(fromBlockNumber, timeoutInSeconds);\n    }\n\n    /// @notice Get the current value of fraud stake fraction\n    /// @return The value of fraud stake fraction\n    function fraudStakeFraction()\n    public\n    view\n    returns (uint256)\n    {\n        return fraudStakeFractionByBlockNumber.currentValue();\n    }\n\n    /// @notice Set fraction of security bond that will be gained from successfully challenging\n    /// in fraud challenge\n    /// @param fromBlockNumber Block number from which the update applies\n    /// @param stakeFraction The fraction gained\n    function setFraudStakeFraction(uint256 fromBlockNumber, uint256 stakeFraction)\n    public\n    onlyOperator\n    onlyDelayedBlockNumber(fromBlockNumber)\n    {\n        fraudStakeFractionByBlockNumber.addEntry(fromBlockNumber, stakeFraction);\n        emit SetFraudStakeFractionEvent(fromBlockNumber, stakeFraction);\n    }\n\n    /// @notice Get the current value of wallet settlement stake fraction\n    /// @return The value of wallet settlement stake fraction\n    function walletSettlementStakeFraction()\n    public\n    view\n    returns (uint256)\n    {\n        return walletSettlementStakeFractionByBlockNumber.currentValue();\n    }\n\n    /// @notice Set fraction of security bond that will be gained from successfully challenging\n    /// in settlement challenge triggered by wallet\n    /// @param fromBlockNumber Block number from which the update applies\n    /// @param stakeFraction The fraction gained\n    function setWalletSettlementStakeFraction(uint256 fromBlockNumber, uint256 stakeFraction)\n    public\n    onlyOperator\n    onlyDelayedBlockNumber(fromBlockNumber)\n    {\n        walletSettlementStakeFractionByBlockNumber.addEntry(fromBlockNumber, stakeFraction);\n        emit SetWalletSettlementStakeFractionEvent(fromBlockNumber, stakeFraction);\n    }\n\n    /// @notice Get the current value of operator settlement stake fraction\n    /// @return The value of operator settlement stake fraction\n    function operatorSettlementStakeFraction()\n    public\n    view\n    returns (uint256)\n    {\n        return operatorSettlementStakeFractionByBlockNumber.currentValue();\n    }\n\n    /// @notice Set fraction of security bond that will be gained from successfully challenging\n    /// in settlement challenge triggered by operator\n    /// @param fromBlockNumber Block number from which the update applies\n    /// @param stakeFraction The fraction gained\n    function setOperatorSettlementStakeFraction(uint256 fromBlockNumber, uint256 stakeFraction)\n    public\n    onlyOperator\n    onlyDelayedBlockNumber(fromBlockNumber)\n    {\n        operatorSettlementStakeFractionByBlockNumber.addEntry(fromBlockNumber, stakeFraction);\n        emit SetOperatorSettlementStakeFractionEvent(fromBlockNumber, stakeFraction);\n    }\n\n    /// @notice Get the current value of operator settlement stake\n    /// @return The value of operator settlement stake\n    function operatorSettlementStake()\n    public\n    view\n    returns (int256 amount, address currencyCt, uint256 currencyId)\n    {\n        MonetaryTypesLib.Figure storage stake = operatorSettlementStakeByBlockNumber.currentValue();\n        amount = stake.amount;\n        currencyCt = stake.currency.ct;\n        currencyId = stake.currency.id;\n    }\n\n    /// @notice Set figure of security bond that will be gained from successfully challenging\n    /// in settlement challenge triggered by operator\n    /// @param fromBlockNumber Block number from which the update applies\n    /// @param stakeAmount The amount gained\n    /// @param stakeCurrencyCt The address of currency gained\n    /// @param stakeCurrencyId The ID of currency gained\n    function setOperatorSettlementStake(uint256 fromBlockNumber, int256 stakeAmount,\n        address stakeCurrencyCt, uint256 stakeCurrencyId)\n    public\n    onlyOperator\n    onlyDelayedBlockNumber(fromBlockNumber)\n    {\n        MonetaryTypesLib.Figure memory stake = MonetaryTypesLib.Figure(stakeAmount, MonetaryTypesLib.Currency(stakeCurrencyCt, stakeCurrencyId));\n        operatorSettlementStakeByBlockNumber.addEntry(fromBlockNumber, stake);\n        emit SetOperatorSettlementStakeEvent(fromBlockNumber, stakeAmount, stakeCurrencyCt, stakeCurrencyId);\n    }\n\n    /// @notice Set the block number of the earliest settlement initiation\n    /// @param _earliestSettlementBlockNumber The block number of the earliest settlement\n    function setEarliestSettlementBlockNumber(uint256 _earliestSettlementBlockNumber)\n    public\n    onlyOperator\n    {\n        earliestSettlementBlockNumber = _earliestSettlementBlockNumber;\n        emit SetEarliestSettlementBlockNumberEvent(earliestSettlementBlockNumber);\n    }\n\n    /// @notice Disable further updates to the earliest settlement block number\n    /// @dev This operation can not be undone\n    function disableEarliestSettlementBlockNumberUpdate()\n    public\n    onlyOperator\n    {\n        earliestSettlementBlockNumberUpdateDisabled = true;\n        emit DisableEarliestSettlementBlockNumberUpdateEvent();\n    }\n\n    //\n    // Modifiers\n    // -----------------------------------------------------------------------------------------------------------------\n    modifier onlyDelayedBlockNumber(uint256 blockNumber) {\n        require(\n            0 == updateDelayBlocksByBlockNumber.count() ||\n        blockNumber >= block.number + updateDelayBlocksByBlockNumber.currentValue()\n        );\n        _;\n    }\n}\n\n/*\n * Hubii Nahmii\n *\n * Compliant with the Hubii Nahmii specification v0.12.\n *\n * Copyright (C) 2017-2018 Hubii AS\n */\n\n\n\n\n\n\n/**\n * @title Benefactor\n * @notice An ownable that has a client fund property\n */\ncontract Configurable is Ownable {\n    //\n    // Variables\n    // -----------------------------------------------------------------------------------------------------------------\n    Configuration public configuration;\n\n    //\n    // Events\n    // -----------------------------------------------------------------------------------------------------------------\n    event SetConfigurationEvent(Configuration oldConfiguration, Configuration newConfiguration);\n\n    //\n    // Functions\n    // -----------------------------------------------------------------------------------------------------------------\n    /// @notice Set the configuration contract\n    /// @param newConfiguration The (address of) Configuration contract instance\n    function setConfiguration(Configuration newConfiguration)\n    public\n    onlyDeployer\n    notNullAddress(newConfiguration)\n    notSameAddresses(newConfiguration, configuration)\n    {\n        // Set new configuration\n        Configuration oldConfiguration = configuration;\n        configuration = newConfiguration;\n\n        // Emit event\n        emit SetConfigurationEvent(oldConfiguration, newConfiguration);\n    }\n\n    //\n    // Modifiers\n    // -----------------------------------------------------------------------------------------------------------------\n    modifier configurationInitialized() {\n        require(configuration != address(0));\n        _;\n    }\n}\n\n/*\n * Hubii Nahmii\n *\n * Compliant with the Hubii Nahmii specification v0.12.\n *\n * Copyright (C) 2017-2018 Hubii AS based on Open-Zeppelin's SafeMath library\n */\n\n\n\n/**\n * @title     SafeMathUintLib\n * @dev       Math operations with safety checks that throw on error\n */\nlibrary SafeMathUintLib {\n    function mul(uint256 a, uint256 b)\n    internal\n    pure\n    returns (uint256)\n    {\n        uint256 c = a * b;\n        assert(a == 0 || c / a == b);\n        return c;\n    }\n\n    function div(uint256 a, uint256 b)\n    internal\n    pure\n    returns (uint256)\n    {\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n        return c;\n    }\n\n    function sub(uint256 a, uint256 b)\n    internal\n    pure\n    returns (uint256)\n    {\n        assert(b <= a);\n        return a - b;\n    }\n\n    function add(uint256 a, uint256 b)\n    internal\n    pure\n    returns (uint256)\n    {\n        uint256 c = a + b;\n        assert(c >= a);\n        return c;\n    }\n\n    //\n    //Clamping functions.\n    //\n    function clamp(uint256 a, uint256 min, uint256 max)\n    public\n    pure\n    returns (uint256)\n    {\n        return (a > max) ? max : ((a < min) ? min : a);\n    }\n\n    function clampMin(uint256 a, uint256 min)\n    public\n    pure\n    returns (uint256)\n    {\n        return (a < min) ? min : a;\n    }\n\n    function clampMax(uint256 a, uint256 max)\n    public\n    pure\n    returns (uint256)\n    {\n        return (a > max) ? max : a;\n    }\n}\n\n/*\n * Hubii Nahmii\n *\n * Compliant with the Hubii Nahmii specification v0.12.\n *\n * Copyright (C) 2017-2018 Hubii AS\n */\n\n\n\n\n\n/**\n * @title     NahmiiTypesLib\n * @dev       Data types of general nahmii character\n */\nlibrary NahmiiTypesLib {\n    //\n    // Enums\n    // -----------------------------------------------------------------------------------------------------------------\n    enum ChallengePhase {Dispute, Closed}\n\n    //\n    // Structures\n    // -----------------------------------------------------------------------------------------------------------------\n    struct OriginFigure {\n        uint256 originId;\n        MonetaryTypesLib.Figure figure;\n    }\n\n    struct IntendedConjugateCurrency {\n        MonetaryTypesLib.Currency intended;\n        MonetaryTypesLib.Currency conjugate;\n    }\n\n    struct SingleFigureTotalOriginFigures {\n        MonetaryTypesLib.Figure single;\n        OriginFigure[] total;\n    }\n\n    struct TotalOriginFigures {\n        OriginFigure[] total;\n    }\n\n    struct CurrentPreviousInt256 {\n        int256 current;\n        int256 previous;\n    }\n\n    struct SingleTotalInt256 {\n        int256 single;\n        int256 total;\n    }\n\n    struct IntendedConjugateCurrentPreviousInt256 {\n        CurrentPreviousInt256 intended;\n        CurrentPreviousInt256 conjugate;\n    }\n\n    struct IntendedConjugateSingleTotalInt256 {\n        SingleTotalInt256 intended;\n        SingleTotalInt256 conjugate;\n    }\n\n    struct WalletOperatorHashes {\n        bytes32 wallet;\n        bytes32 operator;\n    }\n\n    struct Signature {\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n    }\n\n    struct Seal {\n        bytes32 hash;\n        Signature signature;\n    }\n\n    struct WalletOperatorSeal {\n        Seal wallet;\n        Seal operator;\n    }\n}\n\n/*\n * Hubii Nahmii\n *\n * Compliant with the Hubii Nahmii specification v0.12.\n *\n * Copyright (C) 2017-2018 Hubii AS\n */\n\n\n\n\n\n\n/**\n * @title     SettlementChallengeTypesLib\n * @dev       Types for settlement challenges\n */\nlibrary SettlementChallengeTypesLib {\n    //\n    // Structures\n    // -----------------------------------------------------------------------------------------------------------------\n    enum Status {Qualified, Disqualified}\n\n    struct Proposal {\n        address wallet;\n        uint256 nonce;\n        uint256 referenceBlockNumber;\n        uint256 definitionBlockNumber;\n\n        uint256 expirationTime;\n\n        // Status\n        Status status;\n\n        // Amounts\n        Amounts amounts;\n\n        // Currency\n        MonetaryTypesLib.Currency currency;\n\n        // Info on challenged driip\n        Driip challenged;\n\n        // True is equivalent to reward coming from wallet's balance\n        bool walletInitiated;\n\n        // True if proposal has been terminated\n        bool terminated;\n\n        // Disqualification\n        Disqualification disqualification;\n    }\n\n    struct Amounts {\n        // Cumulative (relative) transfer info\n        int256 cumulativeTransfer;\n\n        // Stage info\n        int256 stage;\n\n        // Balances after amounts have been staged\n        int256 targetBalance;\n    }\n\n    struct Driip {\n        // Kind (\"payment\", \"trade\", ...)\n        string kind;\n\n        // Hash (of operator)\n        bytes32 hash;\n    }\n\n    struct Disqualification {\n        // Challenger\n        address challenger;\n        uint256 nonce;\n        uint256 blockNumber;\n\n        // Info on candidate driip\n        Driip candidate;\n    }\n}\n\n/*\n * Hubii Nahmii\n *\n * Compliant with the Hubii Nahmii specification v0.12.\n *\n * Copyright (C) 2017-2018 Hubii AS\n */\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * @title DriipSettlementChallengeState\n * @notice Where driip settlement challenge state is managed\n */\ncontract DriipSettlementChallengeState is Ownable, Servable, Configurable {\n    using SafeMathIntLib for int256;\n    using SafeMathUintLib for uint256;\n\n    //\n    // Constants\n    // -----------------------------------------------------------------------------------------------------------------\n    string constant public INITIATE_PROPOSAL_ACTION = \"initiate_proposal\";\n    string constant public TERMINATE_PROPOSAL_ACTION = \"terminate_proposal\";\n    string constant public REMOVE_PROPOSAL_ACTION = \"remove_proposal\";\n    string constant public DISQUALIFY_PROPOSAL_ACTION = \"disqualify_proposal\";\n    string constant public QUALIFY_PROPOSAL_ACTION = \"qualify_proposal\";\n\n    //\n    // Variables\n    // -----------------------------------------------------------------------------------------------------------------\n    SettlementChallengeTypesLib.Proposal[] public proposals;\n    mapping(address => mapping(address => mapping(uint256 => uint256))) public proposalIndexByWalletCurrency;\n    mapping(address => mapping(uint256 => mapping(address => mapping(uint256 => uint256)))) public proposalIndexByWalletNonceCurrency;\n\n    //\n    // Events\n    // -----------------------------------------------------------------------------------------------------------------\n    event InitiateProposalEvent(address wallet, uint256 nonce, int256 cumulativeTransferAmount, int256 stageAmount,\n        int256 targetBalanceAmount, MonetaryTypesLib.Currency currency, uint256 blockNumber, bool walletInitiated,\n        bytes32 challengedHash, string challengedKind);\n    event TerminateProposalEvent(address wallet, uint256 nonce, int256 cumulativeTransferAmount, int256 stageAmount,\n        int256 targetBalanceAmount, MonetaryTypesLib.Currency currency, uint256 blockNumber, bool walletInitiated,\n        bytes32 challengedHash, string challengedKind);\n    event RemoveProposalEvent(address wallet, uint256 nonce, int256 cumulativeTransferAmount, int256 stageAmount,\n        int256 targetBalanceAmount, MonetaryTypesLib.Currency currency, uint256 blockNumber, bool walletInitiated,\n        bytes32 challengedHash, string challengedKind);\n    event DisqualifyProposalEvent(address challengedWallet, uint256 challengedNonce, int256 cumulativeTransferAmount,\n        int256 stageAmount, int256 targetBalanceAmount, MonetaryTypesLib.Currency currency, uint256 blockNumber,\n        bool walletInitiated, address challengerWallet, uint256 candidateNonce, bytes32 candidateHash,\n        string candidateKind);\n    event QualifyProposalEvent(address challengedWallet, uint256 challengedNonce, int256 cumulativeTransferAmount,\n        int256 stageAmount, int256 targetBalanceAmount, MonetaryTypesLib.Currency currency, uint256 blockNumber,\n        bool walletInitiated, address challengerWallet, uint256 candidateNonce, bytes32 candidateHash,\n        string candidateKind);\n\n    //\n    // Constructor\n    // -----------------------------------------------------------------------------------------------------------------\n    constructor(address deployer) Ownable(deployer) public {\n    }\n\n    //\n    // Functions\n    // -----------------------------------------------------------------------------------------------------------------\n    /// @notice Get the number of proposals\n    /// @return The number of proposals\n    function proposalsCount()\n    public\n    view\n    returns (uint256)\n    {\n        return proposals.length;\n    }\n\n    /// @notice Initiate proposal\n    /// @param wallet The address of the concerned challenged wallet\n    /// @param nonce The wallet nonce\n    /// @param cumulativeTransferAmount The proposal cumulative transfer amount\n    /// @param stageAmount The proposal stage amount\n    /// @param targetBalanceAmount The proposal target balance amount\n    /// @param currency The concerned currency\n    /// @param blockNumber The proposal block number\n    /// @param walletInitiated True if reward from candidate balance\n    /// @param challengedHash The candidate driip hash\n    /// @param challengedKind The candidate driip kind\n    function initiateProposal(address wallet, uint256 nonce, int256 cumulativeTransferAmount, int256 stageAmount,\n        int256 targetBalanceAmount, MonetaryTypesLib.Currency currency, uint256 blockNumber, bool walletInitiated,\n        bytes32 challengedHash, string challengedKind)\n    public\n    onlyEnabledServiceAction(INITIATE_PROPOSAL_ACTION)\n    {\n        // Initiate proposal\n        _initiateProposal(\n            wallet, nonce, cumulativeTransferAmount, stageAmount, targetBalanceAmount,\n            currency, blockNumber, walletInitiated, challengedHash, challengedKind\n        );\n\n        // Emit event\n        emit InitiateProposalEvent(\n            wallet, nonce, cumulativeTransferAmount, stageAmount, targetBalanceAmount, currency,\n            blockNumber, walletInitiated, challengedHash, challengedKind\n        );\n    }\n\n    /// @notice Terminate a proposal\n    /// @param wallet The address of the concerned challenged wallet\n    /// @param currency The concerned currency\n    function terminateProposal(address wallet, MonetaryTypesLib.Currency currency, bool clearNonce)\n    public\n    onlyEnabledServiceAction(TERMINATE_PROPOSAL_ACTION)\n    {\n        // Get the proposal index\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n\n        // Return gracefully if there is no proposal to terminate\n        if (0 == index)\n            return;\n\n        // Clear wallet-nonce-currency triplet entry, which enables reinitiation of proposal for that triplet\n        if (clearNonce)\n            proposalIndexByWalletNonceCurrency[wallet][proposals[index - 1].nonce][currency.ct][currency.id] = 0;\n\n        // Terminate proposal\n        proposals[index - 1].terminated = true;\n\n        // Emit event\n        emit TerminateProposalEvent(\n            wallet, proposals[index - 1].nonce, proposals[index - 1].amounts.cumulativeTransfer,\n            proposals[index - 1].amounts.stage, proposals[index - 1].amounts.targetBalance, currency,\n            proposals[index - 1].referenceBlockNumber, proposals[index - 1].walletInitiated,\n            proposals[index - 1].challenged.hash, proposals[index - 1].challenged.kind\n        );\n    }\n\n    /// @notice Terminate a proposal\n    /// @param wallet The address of the concerned challenged wallet\n    /// @param currency The concerned currency\n    /// @param clearNonce Clear wallet-nonce-currency triplet entry\n    /// @param walletTerminated True if wallet terminated\n    function terminateProposal(address wallet, MonetaryTypesLib.Currency currency, bool clearNonce,\n        bool walletTerminated)\n    public\n    onlyEnabledServiceAction(TERMINATE_PROPOSAL_ACTION)\n    {\n        // Get the proposal index\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n\n        // Return gracefully if there is no proposal to terminate\n        if (0 == index)\n            return;\n\n        // Require that role that initialized (wallet or operator) can only cancel its own proposal\n        require(walletTerminated == proposals[index - 1].walletInitiated);\n\n        // Clear wallet-nonce-currency triplet entry, which enables reinitiation of proposal for that triplet\n        if (clearNonce)\n            proposalIndexByWalletNonceCurrency[wallet][proposals[index - 1].nonce][currency.ct][currency.id] = 0;\n\n        // Terminate proposal\n        proposals[index - 1].terminated = true;\n\n        // Emit event\n        emit TerminateProposalEvent(\n            wallet, proposals[index - 1].nonce, proposals[index - 1].amounts.cumulativeTransfer,\n            proposals[index - 1].amounts.stage, proposals[index - 1].amounts.targetBalance, currency,\n            proposals[index - 1].referenceBlockNumber, proposals[index - 1].walletInitiated,\n            proposals[index - 1].challenged.hash, proposals[index - 1].challenged.kind\n        );\n    }\n\n    /// @notice Remove a proposal\n    /// @param wallet The address of the concerned challenged wallet\n    /// @param currency The concerned currency\n    function removeProposal(address wallet, MonetaryTypesLib.Currency currency)\n    public\n    onlyEnabledServiceAction(REMOVE_PROPOSAL_ACTION)\n    {\n        // Get the proposal index\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n\n        // Return gracefully if there is no proposal to remove\n        if (0 == index)\n            return;\n\n        // Emit event\n        emit RemoveProposalEvent(\n            wallet, proposals[index - 1].nonce, proposals[index - 1].amounts.cumulativeTransfer,\n            proposals[index - 1].amounts.stage, proposals[index - 1].amounts.targetBalance, currency,\n            proposals[index - 1].referenceBlockNumber, proposals[index - 1].walletInitiated,\n            proposals[index - 1].challenged.hash, proposals[index - 1].challenged.kind\n        );\n\n        // Remove proposal\n        _removeProposal(index);\n    }\n\n    /// @notice Remove a proposal\n    /// @param wallet The address of the concerned challenged wallet\n    /// @param currency The concerned currency\n    /// @param walletTerminated True if wallet terminated\n    function removeProposal(address wallet, MonetaryTypesLib.Currency currency, bool walletTerminated)\n    public\n    onlyEnabledServiceAction(REMOVE_PROPOSAL_ACTION)\n    {\n        // Get the proposal index\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n\n        // Return gracefully if there is no proposal to remove\n        if (0 == index)\n            return;\n\n        // Require that role that initialized (wallet or operator) can only cancel its own proposal\n        require(walletTerminated == proposals[index - 1].walletInitiated);\n\n        // Emit event\n        emit RemoveProposalEvent(\n            wallet, proposals[index - 1].nonce, proposals[index - 1].amounts.cumulativeTransfer,\n            proposals[index - 1].amounts.stage, proposals[index - 1].amounts.targetBalance, currency,\n            proposals[index - 1].referenceBlockNumber, proposals[index - 1].walletInitiated,\n            proposals[index - 1].challenged.hash, proposals[index - 1].challenged.kind\n        );\n\n        // Remove proposal\n        _removeProposal(index);\n    }\n\n    /// @notice Disqualify a proposal\n    /// @dev A call to this function will intentionally override previous disqualifications if existent\n    /// @param challengedWallet The address of the concerned challenged wallet\n    /// @param currency The concerned currency\n    /// @param challengerWallet The address of the concerned challenger wallet\n    /// @param blockNumber The disqualification block number\n    /// @param candidateNonce The candidate nonce\n    /// @param candidateHash The candidate hash\n    /// @param candidateKind The candidate kind\n    function disqualifyProposal(address challengedWallet, MonetaryTypesLib.Currency currency, address challengerWallet,\n        uint256 blockNumber, uint256 candidateNonce, bytes32 candidateHash, string candidateKind)\n    public\n    onlyEnabledServiceAction(DISQUALIFY_PROPOSAL_ACTION)\n    {\n        // Get the proposal index\n        uint256 index = proposalIndexByWalletCurrency[challengedWallet][currency.ct][currency.id];\n        require(0 != index);\n\n        // Update proposal\n        proposals[index - 1].status = SettlementChallengeTypesLib.Status.Disqualified;\n        proposals[index - 1].expirationTime = block.timestamp.add(configuration.settlementChallengeTimeout());\n        proposals[index - 1].disqualification.challenger = challengerWallet;\n        proposals[index - 1].disqualification.nonce = candidateNonce;\n        proposals[index - 1].disqualification.blockNumber = blockNumber;\n        proposals[index - 1].disqualification.candidate.hash = candidateHash;\n        proposals[index - 1].disqualification.candidate.kind = candidateKind;\n\n        // Emit event\n        emit DisqualifyProposalEvent(\n            challengedWallet, proposals[index - 1].nonce, proposals[index - 1].amounts.cumulativeTransfer,\n            proposals[index - 1].amounts.stage, proposals[index - 1].amounts.targetBalance,\n            currency, proposals[index - 1].referenceBlockNumber, proposals[index - 1].walletInitiated,\n            challengerWallet, candidateNonce, candidateHash, candidateKind\n        );\n    }\n\n    /// @notice (Re)Qualify a proposal\n    /// @param wallet The address of the concerned challenged wallet\n    /// @param currency The concerned currency\n    function qualifyProposal(address wallet, MonetaryTypesLib.Currency currency)\n    public\n    onlyEnabledServiceAction(QUALIFY_PROPOSAL_ACTION)\n    {\n        // Get the proposal index\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n        require(0 != index);\n\n        // Emit event\n        emit QualifyProposalEvent(\n            wallet, proposals[index - 1].nonce, proposals[index - 1].amounts.cumulativeTransfer,\n            proposals[index - 1].amounts.stage, proposals[index - 1].amounts.targetBalance, currency,\n            proposals[index - 1].referenceBlockNumber, proposals[index - 1].walletInitiated,\n            proposals[index - 1].disqualification.challenger,\n            proposals[index - 1].disqualification.nonce,\n            proposals[index - 1].disqualification.candidate.hash,\n            proposals[index - 1].disqualification.candidate.kind\n        );\n\n        // Update proposal\n        proposals[index - 1].status = SettlementChallengeTypesLib.Status.Qualified;\n        proposals[index - 1].expirationTime = block.timestamp.add(configuration.settlementChallengeTimeout());\n        delete proposals[index - 1].disqualification;\n    }\n\n    /// @notice Gauge whether a driip settlement challenge for the given wallet-nonce-currency\n    /// triplet has been proposed and not later removed\n    /// @param wallet The address of the concerned wallet\n    /// @param nonce The wallet nonce\n    /// @param currency The concerned currency\n    /// @return true if driip settlement challenge has been, else false\n    function hasProposal(address wallet, uint256 nonce, MonetaryTypesLib.Currency currency)\n    public\n    view\n    returns (bool)\n    {\n        // 1-based index\n        return 0 != proposalIndexByWalletNonceCurrency[wallet][nonce][currency.ct][currency.id];\n    }\n\n    /// @notice Gauge whether the proposal for the given wallet and currency has expired\n    /// @param wallet The address of the concerned wallet\n    /// @param currency The concerned currency\n    /// @return true if proposal has expired, else false\n    function hasProposal(address wallet, MonetaryTypesLib.Currency currency)\n    public\n    view\n    returns (bool)\n    {\n        // 1-based index\n        return 0 != proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n    }\n\n    /// @notice Gauge whether the proposal for the given wallet and currency has terminated\n    /// @param wallet The address of the concerned wallet\n    /// @param currency The concerned currency\n    /// @return true if proposal has terminated, else false\n    function hasProposalTerminated(address wallet, MonetaryTypesLib.Currency currency)\n    public\n    view\n    returns (bool)\n    {\n        // 1-based index\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n        require(0 != index);\n        return proposals[index - 1].terminated;\n    }\n\n    /// @notice Gauge whether the proposal for the given wallet and currency has expired\n    /// @param wallet The address of the concerned wallet\n    /// @param currency The concerned currency\n    /// @return true if proposal has expired, else false\n    function hasProposalExpired(address wallet, MonetaryTypesLib.Currency currency)\n    public\n    view\n    returns (bool)\n    {\n        // 1-based index\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n        require(0 != index);\n        return block.timestamp >= proposals[index - 1].expirationTime;\n    }\n\n    /// @notice Get the proposal nonce of the given wallet and currency\n    /// @param wallet The address of the concerned wallet\n    /// @param currency The concerned currency\n    /// @return The settlement proposal nonce\n    function proposalNonce(address wallet, MonetaryTypesLib.Currency currency)\n    public\n    view\n    returns (uint256)\n    {\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n        require(0 != index);\n        return proposals[index - 1].nonce;\n    }\n\n    /// @notice Get the proposal reference block number of the given wallet and currency\n    /// @param wallet The address of the concerned wallet\n    /// @param currency The concerned currency\n    /// @return The settlement proposal reference block number\n    function proposalReferenceBlockNumber(address wallet, MonetaryTypesLib.Currency currency)\n    public\n    view\n    returns (uint256)\n    {\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n        require(0 != index);\n        return proposals[index - 1].referenceBlockNumber;\n    }\n\n    /// @notice Get the proposal definition block number of the given wallet and currency\n    /// @param wallet The address of the concerned wallet\n    /// @param currency The concerned currency\n    /// @return The settlement proposal definition block number\n    function proposalDefinitionBlockNumber(address wallet, MonetaryTypesLib.Currency currency)\n    public\n    view\n    returns (uint256)\n    {\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n        require(0 != index);\n        return proposals[index - 1].definitionBlockNumber;\n    }\n\n    /// @notice Get the proposal expiration time of the given wallet and currency\n    /// @param wallet The address of the concerned wallet\n    /// @param currency The concerned currency\n    /// @return The settlement proposal expiration time\n    function proposalExpirationTime(address wallet, MonetaryTypesLib.Currency currency)\n    public\n    view\n    returns (uint256)\n    {\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n        require(0 != index);\n        return proposals[index - 1].expirationTime;\n    }\n\n    /// @notice Get the proposal status of the given wallet and currency\n    /// @param wallet The address of the concerned wallet\n    /// @param currency The concerned currency\n    /// @return The settlement proposal status\n    function proposalStatus(address wallet, MonetaryTypesLib.Currency currency)\n    public\n    view\n    returns (SettlementChallengeTypesLib.Status)\n    {\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n        require(0 != index);\n        return proposals[index - 1].status;\n    }\n\n    /// @notice Get the proposal cumulative transfer amount of the given wallet and currency\n    /// @param wallet The address of the concerned wallet\n    /// @param currency The concerned currency\n    /// @return The settlement proposal cumulative transfer amount\n    function proposalCumulativeTransferAmount(address wallet, MonetaryTypesLib.Currency currency)\n    public\n    view\n    returns (int256)\n    {\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n        require(0 != index);\n        return proposals[index - 1].amounts.cumulativeTransfer;\n    }\n\n    /// @notice Get the proposal stage amount of the given wallet and currency\n    /// @param wallet The address of the concerned wallet\n    /// @param currency The concerned currency\n    /// @return The settlement proposal stage amount\n    function proposalStageAmount(address wallet, MonetaryTypesLib.Currency currency)\n    public\n    view\n    returns (int256)\n    {\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n        require(0 != index);\n        return proposals[index - 1].amounts.stage;\n    }\n\n    /// @notice Get the proposal target balance amount of the given wallet and currency\n    /// @param wallet The address of the concerned wallet\n    /// @param currency The concerned currency\n    /// @return The settlement proposal target balance amount\n    function proposalTargetBalanceAmount(address wallet, MonetaryTypesLib.Currency currency)\n    public\n    view\n    returns (int256)\n    {\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n        require(0 != index);\n        return proposals[index - 1].amounts.targetBalance;\n    }\n\n    /// @notice Get the proposal challenged hash of the given wallet and currency\n    /// @param wallet The address of the concerned wallet\n    /// @param currency The concerned currency\n    /// @return The settlement proposal challenged hash\n    function proposalChallengedHash(address wallet, MonetaryTypesLib.Currency currency)\n    public\n    view\n    returns (bytes32)\n    {\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n        require(0 != index);\n        return proposals[index - 1].challenged.hash;\n    }\n\n    /// @notice Get the proposal challenged kind of the given wallet and currency\n    /// @param wallet The address of the concerned wallet\n    /// @param currency The concerned currency\n    /// @return The settlement proposal challenged kind\n    function proposalChallengedKind(address wallet, MonetaryTypesLib.Currency currency)\n    public\n    view\n    returns (string)\n    {\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n        require(0 != index);\n        return proposals[index - 1].challenged.kind;\n    }\n\n    /// @notice Get the proposal balance reward of the given wallet and currency\n    /// @param wallet The address of the concerned wallet\n    /// @param currency The concerned currency\n    /// @return The settlement proposal balance reward\n    function proposalWalletInitiated(address wallet, MonetaryTypesLib.Currency currency)\n    public\n    view\n    returns (bool)\n    {\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n        require(0 != index);\n        return proposals[index - 1].walletInitiated;\n    }\n\n    /// @notice Get the proposal disqualification challenger of the given wallet and currency\n    /// @param wallet The address of the concerned wallet\n    /// @param currency The concerned currency\n    /// @return The settlement proposal disqualification challenger\n    function proposalDisqualificationChallenger(address wallet, MonetaryTypesLib.Currency currency)\n    public\n    view\n    returns (address)\n    {\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n        require(0 != index);\n        return proposals[index - 1].disqualification.challenger;\n    }\n\n    /// @notice Get the proposal disqualification nonce of the given wallet and currency\n    /// @param wallet The address of the concerned wallet\n    /// @param currency The concerned currency\n    /// @return The settlement proposal disqualification nonce\n    function proposalDisqualificationNonce(address wallet, MonetaryTypesLib.Currency currency)\n    public\n    view\n    returns (uint256)\n    {\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n        require(0 != index);\n        return proposals[index - 1].disqualification.nonce;\n    }\n\n    /// @notice Get the proposal disqualification block number of the given wallet and currency\n    /// @param wallet The address of the concerned wallet\n    /// @param currency The concerned currency\n    /// @return The settlement proposal disqualification block number\n    function proposalDisqualificationBlockNumber(address wallet, MonetaryTypesLib.Currency currency)\n    public\n    view\n    returns (uint256)\n    {\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n        require(0 != index);\n        return proposals[index - 1].disqualification.blockNumber;\n    }\n\n    /// @notice Get the proposal disqualification candidate hash of the given wallet and currency\n    /// @param wallet The address of the concerned wallet\n    /// @param currency The concerned currency\n    /// @return The settlement proposal disqualification candidate hash\n    function proposalDisqualificationCandidateHash(address wallet, MonetaryTypesLib.Currency currency)\n    public\n    view\n    returns (bytes32)\n    {\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n        require(0 != index);\n        return proposals[index - 1].disqualification.candidate.hash;\n    }\n\n    /// @notice Get the proposal disqualification candidate kind of the given wallet and currency\n    /// @param wallet The address of the concerned wallet\n    /// @param currency The concerned currency\n    /// @return The settlement proposal disqualification candidate kind\n    function proposalDisqualificationCandidateKind(address wallet, MonetaryTypesLib.Currency currency)\n    public\n    view\n    returns (string)\n    {\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n        require(0 != index);\n        return proposals[index - 1].disqualification.candidate.kind;\n    }\n\n    //\n    // Private functions\n    // -----------------------------------------------------------------------------------------------------------------\n    function _initiateProposal(address wallet, uint256 nonce, int256 cumulativeTransferAmount, int256 stageAmount,\n        int256 targetBalanceAmount, MonetaryTypesLib.Currency currency, uint256 referenceBlockNumber, bool walletInitiated,\n        bytes32 challengedHash, string challengedKind)\n    private\n    {\n        // Require that there is no other proposal on the given wallet-nonce-currency triplet\n        require(0 == proposalIndexByWalletNonceCurrency[wallet][nonce][currency.ct][currency.id]);\n\n        // Require that stage and target balance amounts are positive\n        require(stageAmount.isPositiveInt256());\n        require(targetBalanceAmount.isPositiveInt256());\n\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n\n        // Create proposal if needed\n        if (0 == index) {\n            index = ++(proposals.length);\n            proposalIndexByWalletCurrency[wallet][currency.ct][currency.id] = index;\n        }\n\n        // Populate proposal\n        proposals[index - 1].wallet = wallet;\n        proposals[index - 1].nonce = nonce;\n        proposals[index - 1].referenceBlockNumber = referenceBlockNumber;\n        proposals[index - 1].definitionBlockNumber = block.number;\n        proposals[index - 1].expirationTime = block.timestamp.add(configuration.settlementChallengeTimeout());\n        proposals[index - 1].status = SettlementChallengeTypesLib.Status.Qualified;\n        proposals[index - 1].currency = currency;\n        proposals[index - 1].amounts.cumulativeTransfer = cumulativeTransferAmount;\n        proposals[index - 1].amounts.stage = stageAmount;\n        proposals[index - 1].amounts.targetBalance = targetBalanceAmount;\n        proposals[index - 1].walletInitiated = walletInitiated;\n        proposals[index - 1].terminated = false;\n        proposals[index - 1].challenged.hash = challengedHash;\n        proposals[index - 1].challenged.kind = challengedKind;\n\n        // Update index of wallet-nonce-currency triplet\n        proposalIndexByWalletNonceCurrency[wallet][nonce][currency.ct][currency.id] = index;\n    }\n\n    function _removeProposal(uint256 index)\n    private\n    {\n        // Remove the proposal and clear references to it\n        proposalIndexByWalletCurrency[proposals[index - 1].wallet][proposals[index - 1].currency.ct][proposals[index - 1].currency.id] = 0;\n        proposalIndexByWalletNonceCurrency[proposals[index - 1].wallet][proposals[index - 1].nonce][proposals[index - 1].currency.ct][proposals[index - 1].currency.id] = 0;\n        if (index < proposals.length) {\n            proposals[index - 1] = proposals[proposals.length - 1];\n            proposalIndexByWalletCurrency[proposals[index - 1].wallet][proposals[index - 1].currency.ct][proposals[index - 1].currency.id] = index;\n            proposalIndexByWalletNonceCurrency[proposals[index - 1].wallet][proposals[index - 1].nonce][proposals[index - 1].currency.ct][proposals[index - 1].currency.id] = index;\n        }\n        proposals.length--;\n    }\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"proposals\",\"outputs\":[{\"name\":\"wallet\",\"type\":\"address\"},{\"name\":\"nonce\",\"type\":\"uint256\"},{\"name\":\"referenceBlockNumber\",\"type\":\"uint256\"},{\"name\":\"definitionBlockNumber\",\"type\":\"uint256\"},{\"name\":\"expirationTime\",\"type\":\"uint256\"},{\"name\":\"status\",\"type\":\"uint8\"},{\"components\":[{\"name\":\"cumulativeTransfer\",\"type\":\"int256\"},{\"name\":\"stage\",\"type\":\"int256\"},{\"name\":\"targetBalance\",\"type\":\"int256\"}],\"name\":\"amounts\",\"type\":\"tuple\"},{\"components\":[{\"name\":\"ct\",\"type\":\"address\"},{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"currency\",\"type\":\"tuple\"},{\"components\":[{\"name\":\"kind\",\"type\":\"string\"},{\"name\":\"hash\",\"type\":\"bytes32\"}],\"name\":\"challenged\",\"type\":\"tuple\"},{\"name\":\"walletInitiated\",\"type\":\"bool\"},{\"name\":\"terminated\",\"type\":\"bool\"},{\"components\":[{\"name\":\"challenger\",\"type\":\"address\"},{\"name\":\"nonce\",\"type\":\"uint256\"},{\"name\":\"blockNumber\",\"type\":\"uint256\"},{\"components\":[{\"name\":\"kind\",\"type\":\"string\"},{\"name\":\"hash\",\"type\":\"bytes32\"}],\"name\":\"candidate\",\"type\":\"tuple\"}],\"name\":\"disqualification\",\"type\":\"tuple\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"proposalsCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"service\",\"type\":\"address\"}],\"name\":\"isRegisteredActiveService\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"wallet\",\"type\":\"address\"},{\"components\":[{\"name\":\"ct\",\"type\":\"address\"},{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"currency\",\"type\":\"tuple\"}],\"name\":\"proposalDisqualificationCandidateHash\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"wallet\",\"type\":\"address\"},{\"components\":[{\"name\":\"ct\",\"type\":\"address\"},{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"currency\",\"type\":\"tuple\"}],\"name\":\"removeProposal\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"triggerSelfDestruction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"service\",\"type\":\"address\"},{\"name\":\"action\",\"type\":\"string\"}],\"name\":\"enableServiceAction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"service\",\"type\":\"address\"}],\"name\":\"isRegisteredService\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"wallet\",\"type\":\"address\"},{\"components\":[{\"name\":\"ct\",\"type\":\"address\"},{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"currency\",\"type\":\"tuple\"}],\"name\":\"proposalDisqualificationCandidateKind\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"wallet\",\"type\":\"address\"},{\"components\":[{\"name\":\"ct\",\"type\":\"address\"},{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"currency\",\"type\":\"tuple\"}],\"name\":\"proposalNonce\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"selfDestructionDisabled\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"wallet\",\"type\":\"address\"},{\"components\":[{\"name\":\"ct\",\"type\":\"address\"},{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"currency\",\"type\":\"tuple\"},{\"name\":\"clearNonce\",\"type\":\"bool\"},{\"name\":\"walletTerminated\",\"type\":\"bool\"}],\"name\":\"terminateProposal\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"wallet\",\"type\":\"address\"},{\"components\":[{\"name\":\"ct\",\"type\":\"address\"},{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"currency\",\"type\":\"tuple\"}],\"name\":\"hasProposal\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"service\",\"type\":\"address\"},{\"name\":\"action\",\"type\":\"string\"}],\"name\":\"disableServiceAction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"serviceActivationTimeout\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"destructor\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"service\",\"type\":\"address\"}],\"name\":\"deregisterService\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"wallet\",\"type\":\"address\"},{\"components\":[{\"name\":\"ct\",\"type\":\"address\"},{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"currency\",\"type\":\"tuple\"},{\"name\":\"walletTerminated\",\"type\":\"bool\"}],\"name\":\"removeProposal\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"wallet\",\"type\":\"address\"},{\"components\":[{\"name\":\"ct\",\"type\":\"address\"},{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"currency\",\"type\":\"tuple\"}],\"name\":\"proposalDefinitionBlockNumber\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"wallet\",\"type\":\"address\"},{\"components\":[{\"name\":\"ct\",\"type\":\"address\"},{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"currency\",\"type\":\"tuple\"}],\"name\":\"hasProposalExpired\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"wallet\",\"type\":\"address\"},{\"components\":[{\"name\":\"ct\",\"type\":\"address\"},{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"currency\",\"type\":\"tuple\"}],\"name\":\"proposalDisqualificationNonce\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"wallet\",\"type\":\"address\"},{\"components\":[{\"name\":\"ct\",\"type\":\"address\"},{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"currency\",\"type\":\"tuple\"}],\"name\":\"proposalDisqualificationChallenger\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"wallet\",\"type\":\"address\"},{\"components\":[{\"name\":\"ct\",\"type\":\"address\"},{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"currency\",\"type\":\"tuple\"}],\"name\":\"proposalExpirationTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"operator\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"service\",\"type\":\"address\"},{\"name\":\"action\",\"type\":\"string\"}],\"name\":\"isEnabledServiceAction\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"proposalIndexByWalletNonceCurrency\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"wallet\",\"type\":\"address\"},{\"components\":[{\"name\":\"ct\",\"type\":\"address\"},{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"currency\",\"type\":\"tuple\"}],\"name\":\"proposalStageAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"QUALIFY_PROPOSAL_ACTION\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newConfiguration\",\"type\":\"address\"}],\"name\":\"setConfiguration\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"wallet\",\"type\":\"address\"},{\"components\":[{\"name\":\"ct\",\"type\":\"address\"},{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"currency\",\"type\":\"tuple\"}],\"name\":\"qualifyProposal\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"wallet\",\"type\":\"address\"},{\"name\":\"nonce\",\"type\":\"uint256\"},{\"components\":[{\"name\":\"ct\",\"type\":\"address\"},{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"currency\",\"type\":\"tuple\"}],\"name\":\"hasProposal\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"challengedWallet\",\"type\":\"address\"},{\"components\":[{\"name\":\"ct\",\"type\":\"address\"},{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"currency\",\"type\":\"tuple\"},{\"name\":\"challengerWallet\",\"type\":\"address\"},{\"name\":\"blockNumber\",\"type\":\"uint256\"},{\"name\":\"candidateNonce\",\"type\":\"uint256\"},{\"name\":\"candidateHash\",\"type\":\"bytes32\"},{\"name\":\"candidateKind\",\"type\":\"string\"}],\"name\":\"disqualifyProposal\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"proposalIndexByWalletCurrency\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"configuration\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"wallet\",\"type\":\"address\"},{\"components\":[{\"name\":\"ct\",\"type\":\"address\"},{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"currency\",\"type\":\"tuple\"}],\"name\":\"proposalReferenceBlockNumber\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"disableSelfDestruction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"timeoutInSeconds\",\"type\":\"uint256\"}],\"name\":\"setServiceActivationTimeout\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"wallet\",\"type\":\"address\"},{\"components\":[{\"name\":\"ct\",\"type\":\"address\"},{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"currency\",\"type\":\"tuple\"}],\"name\":\"hasProposalTerminated\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TERMINATE_PROPOSAL_ACTION\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"wallet\",\"type\":\"address\"},{\"components\":[{\"name\":\"ct\",\"type\":\"address\"},{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"currency\",\"type\":\"tuple\"}],\"name\":\"proposalCumulativeTransferAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"wallet\",\"type\":\"address\"},{\"components\":[{\"name\":\"ct\",\"type\":\"address\"},{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"currency\",\"type\":\"tuple\"}],\"name\":\"proposalDisqualificationBlockNumber\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"service\",\"type\":\"address\"}],\"name\":\"registerServiceDeferred\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"REMOVE_PROPOSAL_ACTION\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"wallet\",\"type\":\"address\"},{\"components\":[{\"name\":\"ct\",\"type\":\"address\"},{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"currency\",\"type\":\"tuple\"}],\"name\":\"proposalChallengedKind\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newDeployer\",\"type\":\"address\"}],\"name\":\"setDeployer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"INITIATE_PROPOSAL_ACTION\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"wallet\",\"type\":\"address\"},{\"components\":[{\"name\":\"ct\",\"type\":\"address\"},{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"currency\",\"type\":\"tuple\"},{\"name\":\"clearNonce\",\"type\":\"bool\"}],\"name\":\"terminateProposal\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOperator\",\"type\":\"address\"}],\"name\":\"setOperator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"wallet\",\"type\":\"address\"},{\"components\":[{\"name\":\"ct\",\"type\":\"address\"},{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"currency\",\"type\":\"tuple\"}],\"name\":\"proposalStatus\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"wallet\",\"type\":\"address\"},{\"name\":\"nonce\",\"type\":\"uint256\"},{\"name\":\"cumulativeTransferAmount\",\"type\":\"int256\"},{\"name\":\"stageAmount\",\"type\":\"int256\"},{\"name\":\"targetBalanceAmount\",\"type\":\"int256\"},{\"components\":[{\"name\":\"ct\",\"type\":\"address\"},{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"currency\",\"type\":\"tuple\"},{\"name\":\"blockNumber\",\"type\":\"uint256\"},{\"name\":\"walletInitiated\",\"type\":\"bool\"},{\"name\":\"challengedHash\",\"type\":\"bytes32\"},{\"name\":\"challengedKind\",\"type\":\"string\"}],\"name\":\"initiateProposal\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"wallet\",\"type\":\"address\"},{\"components\":[{\"name\":\"ct\",\"type\":\"address\"},{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"currency\",\"type\":\"tuple\"}],\"name\":\"proposalTargetBalanceAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"wallet\",\"type\":\"address\"},{\"components\":[{\"name\":\"ct\",\"type\":\"address\"},{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"currency\",\"type\":\"tuple\"}],\"name\":\"proposalWalletInitiated\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"deployer\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"wallet\",\"type\":\"address\"},{\"components\":[{\"name\":\"ct\",\"type\":\"address\"},{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"currency\",\"type\":\"tuple\"}],\"name\":\"proposalChallengedHash\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"DISQUALIFY_PROPOSAL_ACTION\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"service\",\"type\":\"address\"}],\"name\":\"registerService\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"deployer\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"wallet\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"nonce\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"cumulativeTransferAmount\",\"type\":\"int256\"},{\"indexed\":false,\"name\":\"stageAmount\",\"type\":\"int256\"},{\"indexed\":false,\"name\":\"targetBalanceAmount\",\"type\":\"int256\"},{\"components\":[{\"name\":\"ct\",\"type\":\"address\"},{\"name\":\"id\",\"type\":\"uint256\"}],\"indexed\":false,\"name\":\"currency\",\"type\":\"tuple\"},{\"indexed\":false,\"name\":\"blockNumber\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"walletInitiated\",\"type\":\"bool\"},{\"indexed\":false,\"name\":\"challengedHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"challengedKind\",\"type\":\"string\"}],\"name\":\"InitiateProposalEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"wallet\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"nonce\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"cumulativeTransferAmount\",\"type\":\"int256\"},{\"indexed\":false,\"name\":\"stageAmount\",\"type\":\"int256\"},{\"indexed\":false,\"name\":\"targetBalanceAmount\",\"type\":\"int256\"},{\"components\":[{\"name\":\"ct\",\"type\":\"address\"},{\"name\":\"id\",\"type\":\"uint256\"}],\"indexed\":false,\"name\":\"currency\",\"type\":\"tuple\"},{\"indexed\":false,\"name\":\"blockNumber\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"walletInitiated\",\"type\":\"bool\"},{\"indexed\":false,\"name\":\"challengedHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"challengedKind\",\"type\":\"string\"}],\"name\":\"TerminateProposalEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"wallet\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"nonce\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"cumulativeTransferAmount\",\"type\":\"int256\"},{\"indexed\":false,\"name\":\"stageAmount\",\"type\":\"int256\"},{\"indexed\":false,\"name\":\"targetBalanceAmount\",\"type\":\"int256\"},{\"components\":[{\"name\":\"ct\",\"type\":\"address\"},{\"name\":\"id\",\"type\":\"uint256\"}],\"indexed\":false,\"name\":\"currency\",\"type\":\"tuple\"},{\"indexed\":false,\"name\":\"blockNumber\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"walletInitiated\",\"type\":\"bool\"},{\"indexed\":false,\"name\":\"challengedHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"challengedKind\",\"type\":\"string\"}],\"name\":\"RemoveProposalEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"challengedWallet\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"challengedNonce\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"cumulativeTransferAmount\",\"type\":\"int256\"},{\"indexed\":false,\"name\":\"stageAmount\",\"type\":\"int256\"},{\"indexed\":false,\"name\":\"targetBalanceAmount\",\"type\":\"int256\"},{\"components\":[{\"name\":\"ct\",\"type\":\"address\"},{\"name\":\"id\",\"type\":\"uint256\"}],\"indexed\":false,\"name\":\"currency\",\"type\":\"tuple\"},{\"indexed\":false,\"name\":\"blockNumber\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"walletInitiated\",\"type\":\"bool\"},{\"indexed\":false,\"name\":\"challengerWallet\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"candidateNonce\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"candidateHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"candidateKind\",\"type\":\"string\"}],\"name\":\"DisqualifyProposalEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"challengedWallet\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"challengedNonce\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"cumulativeTransferAmount\",\"type\":\"int256\"},{\"indexed\":false,\"name\":\"stageAmount\",\"type\":\"int256\"},{\"indexed\":false,\"name\":\"targetBalanceAmount\",\"type\":\"int256\"},{\"components\":[{\"name\":\"ct\",\"type\":\"address\"},{\"name\":\"id\",\"type\":\"uint256\"}],\"indexed\":false,\"name\":\"currency\",\"type\":\"tuple\"},{\"indexed\":false,\"name\":\"blockNumber\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"walletInitiated\",\"type\":\"bool\"},{\"indexed\":false,\"name\":\"challengerWallet\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"candidateNonce\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"candidateHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"candidateKind\",\"type\":\"string\"}],\"name\":\"QualifyProposalEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldConfiguration\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newConfiguration\",\"type\":\"address\"}],\"name\":\"SetConfigurationEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"timeoutInSeconds\",\"type\":\"uint256\"}],\"name\":\"ServiceActivationTimeoutEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"service\",\"type\":\"address\"}],\"name\":\"RegisterServiceEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"service\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"timeout\",\"type\":\"uint256\"}],\"name\":\"RegisterServiceDeferredEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"service\",\"type\":\"address\"}],\"name\":\"DeregisterServiceEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"service\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"action\",\"type\":\"string\"}],\"name\":\"EnableServiceActionEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"service\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"action\",\"type\":\"string\"}],\"name\":\"DisableServiceActionEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldDeployer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newDeployer\",\"type\":\"address\"}],\"name\":\"SetDeployerEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldOperator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newOperator\",\"type\":\"address\"}],\"name\":\"SetOperatorEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"SelfDestructionDisabledEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"TriggerSelfDestructionEvent\",\"type\":\"event\"}]","ContractName":"DriipSettlementChallengeState","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"0","ConstructorArguments":"000000000000000000000000f05179bac3d1fbef58a2fcd7ad0f769840027cc6","Library":"SafeMathIntLib:2fcb98529d58669e229c453de4b4705bb6b2d414","SwarmSource":"bzzr://d05da0ac3a104e7f35c72a5e38b50e57d0337e382f2bf25159f636d3667b48e0"}]}