{"status":"1","message":"OK","result":[{"SourceCode":"// File: openzeppelin-solidity\\contracts\\token\\ERC20\\ERC20Basic.sol\r\n\r\npragma solidity 0.4.24;\r\n\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * See https://github.com/ethereum/EIPs/issues/179\r\n */\r\ncontract ERC20Basic {\r\n  function totalSupply() public view returns (uint256);\r\n  function balanceOf(address _who) public view returns (uint256);\r\n  function transfer(address _to, uint256 _value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n// File: openzeppelin-solidity\\contracts\\token\\ERC20\\ERC20.sol\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address _owner, address _spender)\r\n    public view returns (uint256);\r\n\r\n  function transferFrom(address _from, address _to, uint256 _value)\r\n    public returns (bool);\r\n\r\n  function approve(address _spender, uint256 _value) public returns (bool);\r\n  event Approval(\r\n    address indexed owner,\r\n    address indexed spender,\r\n    uint256 value\r\n  );\r\n}\r\n\r\n// File: contracts\\ERC865Basic.sol\r\n\r\n/**\r\n * @title ERC865Basic\r\n * @dev Simpler version of the ERC865 interface from https://github.com/adilharis2001/ERC865Demo\r\n * @author jsdavis28\r\n * @notice ERC865Token allows for users to pay gas costs to a delegate in an ERC20 token\r\n * https://github.com/ethereum/EIPs/issues/865\r\n */\r\n contract ERC865Basic is ERC20 {\r\n     function _transferPreSigned(\r\n         bytes _signature,\r\n         address _from,\r\n         address _to,\r\n         uint256 _value,\r\n         uint256 _fee,\r\n         uint256 _nonce\r\n     )\r\n        internal;\r\n\r\n     event TransferPreSigned(\r\n         address indexed delegate,\r\n         address indexed from,\r\n         address indexed to,\r\n         uint256 value);\r\n}\r\n\r\n// File: openzeppelin-solidity\\contracts\\math\\SafeMath.sol\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\r\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (_a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    c = _a * _b;\r\n    assert(c / _a == _b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    // assert(_b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = _a / _b;\r\n    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\r\n    return _a / _b;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    assert(_b <= _a);\r\n    return _a - _b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\r\n    c = _a + _b;\r\n    assert(c >= _a);\r\n    return c;\r\n  }\r\n}\r\n\r\n// File: openzeppelin-solidity\\contracts\\token\\ERC20\\BasicToken.sol\r\n\r\n/**\r\n * @title Basic token\r\n * @dev Basic version of StandardToken, with no allowances.\r\n */\r\ncontract BasicToken is ERC20Basic {\r\n  using SafeMath for uint256;\r\n\r\n  mapping(address => uint256) internal balances;\r\n\r\n  uint256 internal totalSupply_;\r\n\r\n  /**\r\n  * @dev Total number of tokens in existence\r\n  */\r\n  function totalSupply() public view returns (uint256) {\r\n    return totalSupply_;\r\n  }\r\n\r\n  /**\r\n  * @dev Transfer token for a specified address\r\n  * @param _to The address to transfer to.\r\n  * @param _value The amount to be transferred.\r\n  */\r\n  function transfer(address _to, uint256 _value) public returns (bool) {\r\n    require(_value <= balances[msg.sender]);\r\n    require(_to != address(0));\r\n\r\n    balances[msg.sender] = balances[msg.sender].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    emit Transfer(msg.sender, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n  * @dev Gets the balance of the specified address.\r\n  * @param _owner The address to query the the balance of.\r\n  * @return An uint256 representing the amount owned by the passed address.\r\n  */\r\n  function balanceOf(address _owner) public view returns (uint256) {\r\n    return balances[_owner];\r\n  }\r\n\r\n}\r\n\r\n// File: openzeppelin-solidity\\contracts\\token\\ERC20\\StandardToken.sol\r\n\r\n/**\r\n * @title Standard ERC20 token\r\n *\r\n * @dev Implementation of the basic standard token.\r\n * https://github.com/ethereum/EIPs/issues/20\r\n * Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\r\n */\r\ncontract StandardToken is ERC20, BasicToken {\r\n\r\n  mapping (address => mapping (address => uint256)) internal allowed;\r\n\r\n\r\n  /**\r\n   * @dev Transfer tokens from one address to another\r\n   * @param _from address The address which you want to send tokens from\r\n   * @param _to address The address which you want to transfer to\r\n   * @param _value uint256 the amount of tokens to be transferred\r\n   */\r\n  function transferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _value\r\n  )\r\n    public\r\n    returns (bool)\r\n  {\r\n    require(_value <= balances[_from]);\r\n    require(_value <= allowed[_from][msg.sender]);\r\n    require(_to != address(0));\r\n\r\n    balances[_from] = balances[_from].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n    emit Transfer(_from, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\r\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\r\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\r\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _value The amount of tokens to be spent.\r\n   */\r\n  function approve(address _spender, uint256 _value) public returns (bool) {\r\n    allowed[msg.sender][_spender] = _value;\r\n    emit Approval(msg.sender, _spender, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n   * @param _owner address The address which owns the funds.\r\n   * @param _spender address The address which will spend the funds.\r\n   * @return A uint256 specifying the amount of tokens still available for the spender.\r\n   */\r\n  function allowance(\r\n    address _owner,\r\n    address _spender\r\n   )\r\n    public\r\n    view\r\n    returns (uint256)\r\n  {\r\n    return allowed[_owner][_spender];\r\n  }\r\n\r\n  /**\r\n   * @dev Increase the amount of tokens that an owner allowed to a spender.\r\n   * approve should be called when allowed[_spender] == 0. To increment\r\n   * allowed value is better to use this function to avoid 2 calls (and wait until\r\n   * the first transaction is mined)\r\n   * From MonolithDAO Token.sol\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _addedValue The amount of tokens to increase the allowance by.\r\n   */\r\n  function increaseApproval(\r\n    address _spender,\r\n    uint256 _addedValue\r\n  )\r\n    public\r\n    returns (bool)\r\n  {\r\n    allowed[msg.sender][_spender] = (\r\n      allowed[msg.sender][_spender].add(_addedValue));\r\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Decrease the amount of tokens that an owner allowed to a spender.\r\n   * approve should be called when allowed[_spender] == 0. To decrement\r\n   * allowed value is better to use this function to avoid 2 calls (and wait until\r\n   * the first transaction is mined)\r\n   * From MonolithDAO Token.sol\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _subtractedValue The amount of tokens to decrease the allowance by.\r\n   */\r\n  function decreaseApproval(\r\n    address _spender,\r\n    uint256 _subtractedValue\r\n  )\r\n    public\r\n    returns (bool)\r\n  {\r\n    uint256 oldValue = allowed[msg.sender][_spender];\r\n    if (_subtractedValue >= oldValue) {\r\n      allowed[msg.sender][_spender] = 0;\r\n    } else {\r\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\r\n    }\r\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n    return true;\r\n  }\r\n\r\n}\r\n\r\n// File: contracts\\ERC865BasicToken.sol\r\n\r\n/**\r\n * @title ERC865BasicToken\r\n * @dev Simpler version of the ERC865 token from https://github.com/adilharis2001/ERC865Demo\r\n * @author jsdavis28\r\n * @notice ERC865Token allows for users to pay gas costs to a delegate in an ERC20 token\r\n * https://github.com/ethereum/EIPs/issues/865\r\n */\r\n\r\n contract ERC865BasicToken is ERC865Basic, StandardToken {\r\n    /**\r\n     * @dev Sets internal variables for contract\r\n     */\r\n    address internal feeAccount;\r\n    mapping(bytes => bool) internal signatures;\r\n\r\n    /**\r\n     * @dev Allows a delegate to submit a transaction on behalf of the token holder.\r\n     * @param _signature The signature, issued by the token holder.\r\n     * @param _to The recipient's address.\r\n     * @param _value The amount of tokens to be transferred.\r\n     * @param _fee The amount of tokens paid to the delegate for gas costs.\r\n     * @param _nonce The transaction number.\r\n     */\r\n    function _transferPreSigned(\r\n        bytes _signature,\r\n        address _from,\r\n        address _to,\r\n        uint256 _value,\r\n        uint256 _fee,\r\n        uint256 _nonce\r\n    )\r\n        internal\r\n    {\r\n        //Pre-validate transaction\r\n        require(_to != address(0));\r\n        require(signatures[_signature] == false);\r\n\r\n        //Create a hash of the transaction details\r\n        bytes32 hashedTx = _transferPreSignedHashing(_to, _value, _fee, _nonce);\r\n\r\n        //Obtain the token holder's address and check balance\r\n        address from = _recover(hashedTx, _signature);\r\n        require(from == _from);\r\n        uint256 total = _value.add(_fee);\r\n        require(total <= balances[from]);\r\n\r\n        //Transfer tokens\r\n        balances[from] = balances[from].sub(_value).sub(_fee);\r\n        balances[_to] = balances[_to].add(_value);\r\n        balances[feeAccount] = balances[feeAccount].add(_fee);\r\n\r\n        //Mark transaction as completed\r\n        signatures[_signature] = true;\r\n\r\n        //TransferPreSigned ERC865 events\r\n        emit TransferPreSigned(msg.sender, from, _to, _value);\r\n        emit TransferPreSigned(msg.sender, from, feeAccount, _fee);\r\n        \r\n        //Transfer ERC20 events\r\n        emit Transfer(from, _to, _value);\r\n        emit Transfer(from, feeAccount, _fee);\r\n    }\r\n\r\n    /**\r\n     * @dev Creates a hash of the transaction information passed to transferPresigned.\r\n     * @param _to address The address which you want to transfer to.\r\n     * @param _value uint256 The amount of tokens to be transferred.\r\n     * @param _fee uint256 The amount of tokens paid to msg.sender, by the owner.\r\n     * @param _nonce uint256 Presigned transaction number.\r\n     * @return A copy of the hashed message signed by the token holder, with prefix added.\r\n     */\r\n    function _transferPreSignedHashing(\r\n        address _to,\r\n        uint256 _value,\r\n        uint256 _fee,\r\n        uint256 _nonce\r\n    )\r\n        internal pure\r\n        returns (bytes32)\r\n    {\r\n        //Create a copy of the hashed message signed by the token holder\r\n        bytes32 hash = keccak256(abi.encodePacked(_to, _value, _fee,_nonce));\r\n\r\n        //Add prefix to hash\r\n        return _prefix(hash);\r\n    }\r\n\r\n    /**\r\n     * @dev Adds prefix to the hashed message signed by the token holder.\r\n     * @param _hash The hashed message (keccak256) to be prefixed.\r\n     * @return Prefixed hashed message to return from _transferPreSignedHashing.\r\n     */\r\n    function _prefix(bytes32 _hash) internal pure returns (bytes32) {\r\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", _hash));\r\n    }\r\n\r\n    /**\r\n     * @dev Validate the transaction information and recover the token holder's address.\r\n     * @param _hash A prefixed version of the hash used in the original signed message.\r\n     * @param _sig The signature submitted by the token holder.\r\n     * @return The token holder/transaction signer's address.\r\n     */\r\n    function _recover(bytes32 _hash, bytes _sig) internal pure returns (address) {\r\n        bytes32 r;\r\n        bytes32 s;\r\n        uint8 v;\r\n\r\n        //Check the signature length\r\n        if (_sig.length != 65) {\r\n            return (address(0));\r\n        }\r\n\r\n        //Split the signature into r, s and v variables\r\n        assembly {\r\n            r := mload(add(_sig, 32))\r\n            s := mload(add(_sig, 64))\r\n            v := byte(0, mload(add(_sig, 96)))\r\n        }\r\n\r\n        //Version of signature should be 27 or 28, but 0 and 1 are also possible\r\n        if (v < 27) {\r\n            v += 27;\r\n        }\r\n\r\n        //If the version is correct, return the signer address\r\n        if (v != 27 && v != 28) {\r\n            return (address(0));\r\n        } else {\r\n            return ecrecover(_hash, v, r, s);\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts\\TaxedToken.sol\r\n\r\n/**\r\n * @title Taxed token\r\n * @dev Version of BasicToken that allows for a fee on token transfers.\r\n * See https://github.com/OpenZeppelin/openzeppelin-solidity/pull/788\r\n * @author jsdavis28\r\n */\r\ncontract TaxedToken is ERC865BasicToken {\r\n    /**\r\n     * @dev Sets taxRate fee as public\r\n     */\r\n    uint8 public taxRate;\r\n\r\n    /**\r\n     * @dev Transfer tokens to a specified account after diverting a fee to a central account.\r\n     * @param _to The receiving address.\r\n     * @param _value The number of tokens to transfer.\r\n     */\r\n    function transfer(\r\n        address _to,\r\n        uint256 _value\r\n    )\r\n        public\r\n        returns (bool)\r\n    {\r\n        require(_to != address(0));\r\n        require(_value <= balances[msg.sender]);\r\n\r\n        balances[msg.sender] = balances[msg.sender].sub(_value);\r\n        uint256 fee = _value.mul(taxRate).div(100);\r\n        uint256 taxedValue = _value.sub(fee);\r\n\r\n        balances[_to] = balances[_to].add(taxedValue);\r\n        emit Transfer(msg.sender, _to, taxedValue);\r\n        balances[feeAccount] = balances[feeAccount].add(fee);\r\n        emit Transfer(msg.sender, feeAccount, fee);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Provides a taxed transfer on StandardToken's transferFrom() function\r\n     * @param _from The address providing allowance to spend\r\n     * @param _to The receiving address.\r\n     * @param _value The number of tokens to transfer.\r\n     */\r\n    function transferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _value\r\n    )\r\n        public\r\n        returns (bool)\r\n    {\r\n        require(_to != address(0));\r\n        require(_value <= balances[_from]);\r\n        require(_value <= allowed[_from][msg.sender]);\r\n\r\n        balances[_from] = balances[_from].sub(_value);\r\n        uint256 fee = _value.mul(taxRate).div(100);\r\n        uint256 taxedValue = _value.sub(fee);\r\n\r\n        balances[_to] = balances[_to].add(taxedValue);\r\n        emit Transfer(_from, _to, taxedValue);\r\n        balances[feeAccount] = balances[feeAccount].add(fee);\r\n        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n        emit Transfer(_from, feeAccount, fee);\r\n\r\n        return true;\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity\\contracts\\ownership\\Ownable.sol\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipRenounced(address indexed previousOwner);\r\n  event OwnershipTransferred(\r\n    address indexed previousOwner,\r\n    address indexed newOwner\r\n  );\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  constructor() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to relinquish control of the contract.\r\n   * @notice Renouncing to ownership will leave the contract without an owner.\r\n   * It will not be possible to call the functions with the `onlyOwner`\r\n   * modifier anymore.\r\n   */\r\n  function renounceOwnership() public onlyOwner {\r\n    emit OwnershipRenounced(owner);\r\n    owner = address(0);\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address _newOwner) public onlyOwner {\r\n    _transferOwnership(_newOwner);\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function _transferOwnership(address _newOwner) internal {\r\n    require(_newOwner != address(0));\r\n    emit OwnershipTransferred(owner, _newOwner);\r\n    owner = _newOwner;\r\n  }\r\n}\r\n\r\n// File: contracts\\Authorizable.sol\r\n\r\n/**\r\n * @title Authorizable\r\n * @dev The Authorizable contract allows the owner to set a number of additional\r\n *  acccounts with limited administrative privileges to simplify user permissions.\r\n * Only the contract owner can add or remove authorized accounts.\r\n * @author jsdavis28\r\n */\r\ncontract Authorizable is Ownable {\r\n    using SafeMath for uint256;\r\n\r\n    address[] public authorized;\r\n    mapping(address => bool) internal authorizedIndex;\r\n    uint8 public numAuthorized;\r\n\r\n    /**\r\n     * @dev The Authorizable constructor sets the owner as authorized\r\n     */\r\n    constructor() public {\r\n        authorized.length = 2;\r\n        authorized[1] = msg.sender;\r\n        authorizedIndex[msg.sender] = true;\r\n        numAuthorized = 1;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than an authorized account.\r\n     */\r\n    modifier onlyAuthorized {\r\n        require(isAuthorized(msg.sender));\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to add an authorized account.\r\n     * @param _account The address being added as authorized.\r\n     */\r\n    function addAuthorized(address _account) public onlyOwner {\r\n        if (authorizedIndex[_account] == false) {\r\n        \tauthorizedIndex[_account] = true;\r\n        \tauthorized.length++;\r\n        \tauthorized[authorized.length.sub(1)] = _account;\r\n        \tnumAuthorized++;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Validates whether an account is authorized for enhanced permissions.\r\n     * @param _account The address being evaluated.\r\n     */\r\n    function isAuthorized(address _account) public constant returns (bool) {\r\n        if (authorizedIndex[_account] == true) {\r\n        \treturn true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to remove an authorized account.\r\n     * @param _account The address to remove from authorized.\r\n     */\r\n    function removeAuthorized(address _account) public onlyOwner {\r\n        require(isAuthorized(_account)); \r\n        authorizedIndex[_account] = false;\r\n        numAuthorized--;\r\n    }\r\n}\r\n\r\n// File: contracts\\BlockWRKToken.sol\r\n\r\n/**\r\n * @title BlockWRKToken\r\n * @dev BlockWRKToken contains administrative features that allow the BlockWRK\r\n *  application to interface with the BlockWRK token, an ERC20-compliant token\r\n *  that integrates taxed token and ERC865 functionality.\r\n * @author jsdavis28\r\n */\r\n\r\ncontract BlockWRKToken is TaxedToken, Authorizable {\r\n    /**\r\n     * @dev Sets token information.\r\n     */\r\n    string public name = \"BlockWRK\";\r\n    string public symbol = \"WRK\";\r\n    uint8 public decimals = 4;\r\n    uint256 public INITIAL_SUPPLY;\r\n\r\n    /**\r\n     * @dev Sets public variables for BlockWRK token.\r\n     */\r\n    address public distributionPoolWallet;\r\n    address public inAppPurchaseWallet;\r\n    address public reservedTokenWallet;\r\n    uint256 public premineDistributionPool;\r\n    uint256 public premineReserved;\r\n\r\n    /**\r\n     * @dev Sets private variables for custom token functions.\r\n     */\r\n    uint256 internal decimalValue = 10000;\r\n\r\n    constructor() public {\r\n        feeAccount = 0xeCced56A201d1A6D1Da31A060868F96ACdba99B3;\r\n        distributionPoolWallet = 0xAB3Edd46E9D52e1b3131757e1Ed87FA885f48019;\r\n        inAppPurchaseWallet = 0x97eae8151487e054112E27D8c2eE5f17B3C6A83c;\r\n        reservedTokenWallet = 0xd6E4E287a4aE2E9d8BF7f0323f440acC0d5AD301;\r\n        premineDistributionPool = decimalValue.mul(5600000000);\r\n        premineReserved = decimalValue.mul(2000000000);\r\n        INITIAL_SUPPLY = premineDistributionPool.add(premineReserved);\r\n        balances[distributionPoolWallet] = premineDistributionPool;\r\n        emit Transfer(address(this), distributionPoolWallet, premineDistributionPool);\r\n        balances[reservedTokenWallet] = premineReserved;\r\n        emit Transfer(address(this), reservedTokenWallet, premineReserved);\r\n        totalSupply_ = INITIAL_SUPPLY;\r\n        taxRate = 2;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows App to distribute WRK tokens to users.\r\n     * This function will be called by authorized from within the App.\r\n     * @param _to The recipient's BlockWRK address.\r\n     * @param _value The amount of WRK to transfer.\r\n     */\r\n    function inAppTokenDistribution(\r\n        address _to,\r\n        uint256 _value\r\n    )\r\n        public\r\n        onlyAuthorized\r\n    {\r\n        require(_value <= balances[distributionPoolWallet]);\r\n        require(_to != address(0));\r\n\r\n        balances[distributionPoolWallet] = balances[distributionPoolWallet].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n        emit Transfer(distributionPoolWallet, _to, _value);\r\n    }\r\n\r\n    /**\r\n     * @dev Allows App to process fiat payments for WRK tokens, charging a fee in WRK.\r\n     * This function will be called by authorized from within the App.\r\n     * @param _to The buyer's BlockWRK address.\r\n     * @param _value The amount of WRK to transfer.\r\n     * @param _fee The fee charged in WRK for token purchase.\r\n     */\r\n    function inAppTokenPurchase(\r\n        address _to,\r\n        uint256 _value,\r\n        uint256 _fee\r\n    )\r\n        public\r\n        onlyAuthorized\r\n    {\r\n        require(_value <= balances[inAppPurchaseWallet]);\r\n        require(_to != address(0));\r\n\r\n        balances[inAppPurchaseWallet] = balances[inAppPurchaseWallet].sub(_value);\r\n        uint256 netAmount = _value.sub(_fee);\r\n        balances[_to] = balances[_to].add(netAmount);\r\n        emit Transfer(inAppPurchaseWallet, _to, netAmount);\r\n        balances[feeAccount] = balances[feeAccount].add(_fee);\r\n        emit Transfer(inAppPurchaseWallet, feeAccount, _fee);\r\n    }\r\n\r\n    /**\r\n     * @dev Allows owner to set the percentage fee charged by TaxedToken on external transfers.\r\n     * @param _newRate The amount to be set.\r\n     */\r\n    function setTaxRate(uint8 _newRate) public onlyOwner {\r\n        taxRate = _newRate;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows owner to set the fee account to receive transfer fees.\r\n     * @param _newAddress The address to be set.\r\n     */\r\n    function setFeeAccount(address _newAddress) public onlyOwner {\r\n        require(_newAddress != address(0));\r\n        feeAccount = _newAddress;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows owner to set the wallet that holds WRK for sale via in-app purchases with fiat.\r\n     * @param _newAddress The address to be set.\r\n     */\r\n    function setInAppPurchaseWallet(address _newAddress) public onlyOwner {\r\n        require(_newAddress != address(0));\r\n        inAppPurchaseWallet = _newAddress;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows authorized to act as a delegate to transfer a pre-signed transaction for ERC865\r\n     * @param _signature The pre-signed message.\r\n     * @param _from The token sender.\r\n     * @param _to The token recipient.\r\n     * @param _value The amount of WRK to send the recipient.\r\n     * @param _fee The fee to be paid in WRK (calculated by App off-chain).\r\n     * @param _nonce The transaction number (stored in App off-chain).\r\n     */\r\n    function transactionHandler(\r\n        bytes _signature,\r\n        address _from,\r\n        address _to,\r\n        uint256 _value,\r\n        uint256 _fee,\r\n        uint256 _nonce\r\n    )\r\n        public\r\n        onlyAuthorized\r\n    {\r\n        _transferPreSigned(_signature, _from, _to, _value, _fee, _nonce);\r\n    }\r\n}\r\n\r\n// File: contracts\\BlockWRKICO.sol\r\n\r\n/**\r\n * @title BlockWRKICO\r\n * @notice This contract manages the sale of WRK tokens for the BlockWRK ICO.\r\n * @dev This contract incorporates elements of OpenZeppelin crowdsale contracts with some modifications.\r\n * @author jsdavis28\r\n */\r\n contract BlockWRKICO is BlockWRKToken {\r\n    /**\r\n     * @dev Sets public variables for BlockWRK ICO\r\n     */\r\n    address public salesWallet;\r\n    uint256 public cap;\r\n    uint256 public closingTime;\r\n    uint256 public currentTierRate;\r\n    uint256 public openingTime;\r\n    uint256 public weiRaised;\r\n\r\n    /**\r\n     * @dev Sets private variables for custom token functions.\r\n     */\r\n     uint256 internal availableInCurrentTier;\r\n     uint256 internal availableInSale;\r\n     uint256 internal totalPremineVolume;\r\n     uint256 internal totalSaleVolume;\r\n     uint256 internal totalTokenVolume;\r\n     uint256 internal tier1Rate;\r\n     uint256 internal tier2Rate;\r\n     uint256 internal tier3Rate;\r\n     uint256 internal tier4Rate;\r\n     uint256 internal tier5Rate;\r\n     uint256 internal tier6Rate;\r\n     uint256 internal tier7Rate;\r\n     uint256 internal tier8Rate;\r\n     uint256 internal tier9Rate;\r\n     uint256 internal tier10Rate;\r\n     uint256 internal tier1Volume;\r\n     uint256 internal tier2Volume;\r\n     uint256 internal tier3Volume;\r\n     uint256 internal tier4Volume;\r\n     uint256 internal tier5Volume;\r\n     uint256 internal tier6Volume;\r\n     uint256 internal tier7Volume;\r\n     uint256 internal tier8Volume;\r\n     uint256 internal tier9Volume;\r\n     uint256 internal tier10Volume;\r\n\r\n     constructor() public {\r\n         cap = 9999999999999999999999999999999999999999999999;\r\n         salesWallet = 0xA0E021fC3538ed52F9a3D79249ff1D3A67f91C42;\r\n         openingTime = 1557856800;\r\n         closingTime = 1589479200;\r\n\r\n         totalPremineVolume = 76000000000000;\r\n         totalSaleVolume = 43000000000000;\r\n         totalTokenVolume = 119000000000000;\r\n         availableInSale = totalSaleVolume;\r\n         tier1Rate = 100000;\r\n         tier2Rate = 10000;\r\n         tier3Rate = 2000;\r\n         tier4Rate = 1250;\r\n         tier5Rate = 625;\r\n         tier6Rate = 312;\r\n         tier7Rate = 156;\r\n         tier8Rate = 117;\r\n         tier9Rate = 104;\r\n         tier10Rate = 100;\r\n         tier1Volume = totalPremineVolume.add(1000000000000);\r\n         tier2Volume = tier1Volume.add(2000000000000);\r\n         tier3Volume = tier2Volume.add(5000000000000);\r\n         tier4Volume = tier3Volume.add(5000000000000);\r\n         tier5Volume = tier4Volume.add(5000000000000);\r\n         tier6Volume = tier5Volume.add(5000000000000);\r\n         tier7Volume = tier6Volume.add(5000000000000);\r\n         tier8Volume = tier7Volume.add(5000000000000);\r\n         tier9Volume = tier8Volume.add(5000000000000);\r\n         tier10Volume = tier9Volume.add(5000000000000);\r\n     }\r\n\r\n    /**\r\n     * Event for token purchase logging\r\n     * @param purchaser who paid for the tokens\r\n     * @param beneficiary who got the tokens\r\n     * @param value weis paid for purchase\r\n     * @param amount amount of tokens purchased\r\n     */\r\n    event TokenPurchase(\r\n        address indexed purchaser,\r\n        address indexed beneficiary,\r\n        uint256 value,\r\n        uint256 amount\r\n    );\r\n\r\n    /**\r\n     * Event marking the transfer of any remaining WRK to the distribution pool post-ICO\r\n     * @param wallet The address remaining sale tokens are delivered\r\n     * @param amount The remaining tokens after the sale has closed\r\n     */\r\n     event CloseoutSale(address indexed wallet, uint256 amount);\r\n\r\n\r\n\r\n    // -----------------------------------------\r\n    // Crowdsale external interface\r\n    // -----------------------------------------\r\n\r\n    /**\r\n     * @dev fallback function\r\n     */\r\n    function () external payable {\r\n      buyTokens(msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @dev Allows ICO participants to purchase WRK tokens\r\n     * @param _beneficiary The address of the ICO participant\r\n     */\r\n    function buyTokens(address _beneficiary) public payable {\r\n      uint256 weiAmount = msg.value;\r\n      _preValidatePurchase(_beneficiary, weiAmount);\r\n\r\n      //Calculate number of tokens to issue\r\n      uint256 tokens = _calculateTokens(weiAmount);\r\n\r\n      //Calculate new amount of Wei raised\r\n      weiRaised = weiRaised.add(weiAmount);\r\n\r\n      //Process token purchase and forward funcds to salesWallet\r\n      _processPurchase(_beneficiary, tokens);\r\n      _forwardFunds();\r\n      emit TokenPurchase(msg.sender, _beneficiary, weiAmount, tokens);\r\n    }\r\n\r\n    /**\r\n     * @dev Checks whether the cap has been reached.\r\n     * @return Whether the cap was reached\r\n     */\r\n    function capReached() public view returns (bool) {\r\n      return weiRaised >= cap;\r\n    }\r\n\r\n     /**\r\n      * @dev Checks whether the period in which the crowdsale is open has already elapsed.\r\n      * @return Whether crowdsale period has elapsed\r\n      */\r\n     function hasClosed() public view returns (bool) {\r\n         // solium-disable-next-line security/no-block-members\r\n         return block.timestamp > closingTime;\r\n     }\r\n\r\n\r\n\r\n    // -----------------------------------------\r\n    // Internal interface (extensible)\r\n    // -----------------------------------------\r\n\r\n    /**\r\n     * @dev Calculates total number of tokens to sell, accounting for varied rates per tier.\r\n     * @param _amountWei Total amount of Wei sent by ICO participant\r\n     * @return Total number of tokens to send to buyer\r\n     */\r\n    function _calculateTokens(uint256 _amountWei) internal returns (uint256) {\r\n        //Tokens pending in sale\r\n        uint256 tokenAmountPending;\r\n\r\n        //Tokens to be sold\r\n        uint256 tokenAmountToIssue;\r\n\r\n        //Note: tierCaps must take into account reserved and distribution pool tokens\r\n        //Determine tokens remaining in tier and set current token rate\r\n        uint256 tokensRemainingInTier = _getRemainingTokens(totalSupply_);\r\n\r\n        //Calculate new tokens pending sale\r\n        uint256 newTokens = _getTokenAmount(_amountWei);\r\n\r\n        //Check if _newTokens exceeds _tokensRemainingInTier\r\n        bool nextTier = true;\r\n        while (nextTier) {\r\n            if (newTokens > tokensRemainingInTier) {\r\n                //Get tokens sold in current tier and add to pending total supply\r\n                tokenAmountPending = tokensRemainingInTier;\r\n                uint256 newTotal = totalSupply_.add(tokenAmountPending);\r\n\r\n                //Save number of tokens pending from current tier\r\n                tokenAmountToIssue = tokenAmountToIssue.add(tokenAmountPending);\r\n\r\n                //Calculate Wei spent in current tier and set remaining Wei for next tier\r\n                uint256 pendingAmountWei = tokenAmountPending.div(currentTierRate);\r\n                uint256 remainingWei = _amountWei.sub(pendingAmountWei);\r\n\r\n                //Calculate number of tokens in next tier\r\n                tokensRemainingInTier = _getRemainingTokens(newTotal);\r\n                newTokens = _getTokenAmount(remainingWei);\r\n            } else {\r\n                tokenAmountToIssue = tokenAmountToIssue.add(newTokens);\r\n                nextTier = false;\r\n                _setAvailableInCurrentTier(tokensRemainingInTier, newTokens);\r\n                _setAvailableInSale(newTokens);\r\n            }\r\n        }\r\n\r\n        //Return amount of tokens to be issued in this sale\r\n        return tokenAmountToIssue;\r\n    }\r\n\r\n    /**\r\n     * @dev Source of tokens.\r\n     * @param _beneficiary Address performing the token purchase\r\n     * @param _tokenAmount Number of tokens to be emitted\r\n     */\r\n    function _deliverTokens(address _beneficiary, uint256 _tokenAmount) internal {\r\n        totalSupply_ = totalSupply_.add(_tokenAmount);\r\n        balances[_beneficiary] = balances[_beneficiary].add(_tokenAmount);\r\n    }\r\n\r\n    /**\r\n     * @dev Determines how ETH is stored/forwarded on purchases.\r\n     */\r\n    function _forwardFunds() internal {\r\n        salesWallet.transfer(msg.value);\r\n    }\r\n\r\n    /**\r\n     * @dev Performs a binary search of the sale tiers to determine current sales volume and rate.\r\n     * @param _tokensSold The total number of tokens sold in the ICO prior to this tx\r\n     * @return The remaining number of tokens for sale in the current sale tier\r\n     */\r\n    function _getRemainingTokens(uint256 _tokensSold) internal returns (uint256) {\r\n        //Deteremine the current sale tier, set current rate and find remaining tokens in tier\r\n        uint256 remaining;\r\n        if (_tokensSold < tier5Volume) {\r\n            if (_tokensSold < tier3Volume) {\r\n                if (_tokensSold < tier1Volume) {\r\n                    _setCurrentTierRate(tier1Rate);\r\n                    remaining = tier1Volume.sub(_tokensSold);\r\n                } else if (_tokensSold < tier2Volume) {\r\n                    _setCurrentTierRate(tier2Rate);\r\n                    remaining = tier2Volume.sub(_tokensSold);\r\n                } else {\r\n                    _setCurrentTierRate(tier3Rate);\r\n                    remaining = tier3Volume.sub(_tokensSold);\r\n                }\r\n            } else {\r\n                if (_tokensSold < tier4Volume) {\r\n                    _setCurrentTierRate(tier4Rate);\r\n                    remaining = tier4Volume.sub(_tokensSold);\r\n                } else {\r\n                    _setCurrentTierRate(tier5Rate);\r\n                    remaining = tier5Volume.sub(_tokensSold);\r\n                }\r\n            }\r\n        } else {\r\n            if (_tokensSold < tier8Volume) {\r\n                if (_tokensSold < tier6Volume) {\r\n                    _setCurrentTierRate(tier6Rate);\r\n                    remaining = tier6Volume.sub(_tokensSold);\r\n                } else if (_tokensSold < tier7Volume) {\r\n                    _setCurrentTierRate(tier7Rate);\r\n                    remaining = tier7Volume.sub(_tokensSold);\r\n                } else {\r\n                    _setCurrentTierRate(tier8Rate);\r\n                    remaining = tier8Volume.sub(_tokensSold);\r\n                }\r\n            } else {\r\n                if (_tokensSold < tier9Volume) {\r\n                    _setCurrentTierRate(tier9Rate);\r\n                    remaining = tier9Volume.sub(_tokensSold);\r\n                } else {\r\n                    _setCurrentTierRate(tier10Rate);\r\n                    remaining = tier10Volume.sub(_tokensSold);\r\n                }\r\n            }\r\n        }\r\n\r\n        return remaining;\r\n    }\r\n\r\n    /**\r\n     * @dev Override to extend the way in which ether is converted to tokens.\r\n     * @param _weiAmount Value in wei to be converted into tokens\r\n     * @return Number of tokens that can be purchased with the specified _weiAmount\r\n     */\r\n    function _getTokenAmount(uint256 _weiAmount) internal view returns (uint256) {\r\n        return _weiAmount.mul(currentTierRate).mul(decimalValue).div(1 ether);\r\n    }\r\n\r\n    /**\r\n     * @dev Validation of an incoming purchase.\r\n     * @param _beneficiary Address performing the token purchase\r\n     * @param _weiAmount Value in wei involved in the purchase\r\n     */\r\n    function _preValidatePurchase(address _beneficiary, uint256 _weiAmount) internal view {\r\n        require(_beneficiary != address(0));\r\n        require(_weiAmount != 0);\r\n        require(weiRaised.add(_weiAmount) <= cap);\r\n        // solium-disable-next-line security/no-block-members\r\n        require(block.timestamp >= openingTime && block.timestamp <= closingTime);\r\n    }\r\n\r\n    /**\r\n     * @dev Executed when a purchase has been validated and is ready to be executed. Not necessarily emits/sends tokens.\r\n     * @param _beneficiary Address receiving the tokens\r\n     * @param _tokenAmount Number of tokens to be purchased\r\n     */\r\n    function _processPurchase(address _beneficiary, uint256 _tokenAmount) internal {\r\n        _deliverTokens(_beneficiary, _tokenAmount);\r\n    }\r\n\r\n    /**\r\n     * @dev Calculates remaining tokens available in the current tier after a sale is processed\r\n     * @param _tierPreviousRemaining Number of tokens remaining prior to sale\r\n     * @param _newIssue Number of tokens to be purchased\r\n     */\r\n    function _setAvailableInCurrentTier(uint256 _tierPreviousRemaining, uint256 _newIssue) internal {\r\n        availableInCurrentTier = _tierPreviousRemaining.sub(_newIssue);\r\n    }\r\n\r\n    /**\r\n     * @dev Calculates remaining tokens available in the ICO after a sale is processed\r\n     * @param _newIssue Number of tokens to be purchased\r\n     */\r\n    function _setAvailableInSale(uint256 _newIssue) internal {\r\n        availableInSale = totalSaleVolume.sub(_newIssue);\r\n    }\r\n\r\n    /**\r\n     * @dev Sets the current tier rate based on sale volume\r\n     * @param _rate The new rate\r\n     */\r\n    function _setCurrentTierRate(uint256 _rate) internal {\r\n        currentTierRate = _rate;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens for sale\r\n     * @return Total remaining tokens available for sale\r\n     */\r\n    function tokensRemainingInSale() public view returns (uint256) {\r\n        return availableInSale;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens for sale in the current tier\r\n     * @return Total remaining tokens available for sale in the current tier\r\n     */\r\n    function tokensRemainingInTier() public view returns (uint256) {\r\n        return availableInCurrentTier;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the owner to transfer any remaining tokens not sold to a wallet\r\n     * @return Total remaining tokens available for sale\r\n     */\r\n     function transferRemainingTokens() public onlyOwner {\r\n         //require that sale is closed\r\n         require(hasClosed());\r\n\r\n         //require that tokens are still remaining after close\r\n         require(availableInSale > 0);\r\n\r\n         //send remaining tokens to distribution pool wallet\r\n         balances[distributionPoolWallet] = balances[distributionPoolWallet].add(availableInSale);\r\n         emit CloseoutSale(distributionPoolWallet, availableInSale);\r\n     }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"premineReserved\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"authorized\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"hasClosed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_fee\",\"type\":\"uint256\"}],\"name\":\"inAppTokenPurchase\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"INITIAL_SUPPLY\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"cap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentTierRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"weiRaised\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"removeAuthorized\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newAddress\",\"type\":\"address\"}],\"name\":\"setFeeAccount\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"closingTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"capReached\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensRemainingInSale\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"transferRemainingTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseApproval\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newRate\",\"type\":\"uint8\"}],\"name\":\"setTaxRate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"inAppTokenDistribution\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"taxRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newAddress\",\"type\":\"address\"}],\"name\":\"setInAppPurchaseWallet\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"reservedTokenWallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"premineDistributionPool\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"numAuthorized\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"openingTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"addAuthorized\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_signature\",\"type\":\"bytes\"},{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_fee\",\"type\":\"uint256\"},{\"name\":\"_nonce\",\"type\":\"uint256\"}],\"name\":\"transactionHandler\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseApproval\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"inAppPurchaseWallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"distributionPoolWallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"buyTokens\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"salesWallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensRemainingInTier\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"isAuthorized\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"purchaser\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TokenPurchase\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"wallet\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"CloseoutSale\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"}],\"name\":\"OwnershipRenounced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"delegate\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"TransferPreSigned\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"}]","ContractName":"BlockWRKICO","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://f6c48654dbdf5d07f556060f1719a80abb203dac97e4fce2e43b511dd59fdf03"}]}