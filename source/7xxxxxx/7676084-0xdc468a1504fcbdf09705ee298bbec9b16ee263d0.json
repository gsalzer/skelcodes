{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.18;\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n    address public owner;\r\n\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n\r\n    /**\r\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n     * account.\r\n     */\r\n    function Ownable() {\r\n        owner = msg.sender;\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function transferOwnership(address newOwner) onlyOwner {\r\n        require(newOwner != address(0));\r\n        OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n\r\n}\r\n\r\ncontract usingEthereumV2Erc20Consts {\r\n    uint constant TOKEN_DECIMALS = 18;\r\n    uint8 constant TOKEN_DECIMALS_UINT8 = 18;\r\n    uint constant TOKEN_DECIMAL_MULTIPLIER = 10 ** TOKEN_DECIMALS;\r\n\r\n    uint constant TEAM_TOKENS =   0 * TOKEN_DECIMAL_MULTIPLIER;\r\n    uint constant BOUNTY_TOKENS = 0 * TOKEN_DECIMAL_MULTIPLIER;\r\n    uint constant PREICO_TOKENS = 0 * TOKEN_DECIMAL_MULTIPLIER;\r\n    uint constant MINIMAL_PURCHASE = 0.00001 ether;\r\n\r\n    address constant TEAM_ADDRESS = 0x78cd8f794686ee8f6644447e961ef52776edf0cb;\r\n    address constant BOUNTY_ADDRESS = 0xff823588500d3ecd7777a1cfa198958df4deea11;\r\n    address constant PREICO_ADDRESS = 0xff823588500d3ecd7777a1cfa198958df4deea11;\r\n    address constant COLD_WALLET = 0x439415b03708bde585856b46666f34b65af6a5c3;\r\n\r\n    string constant TOKEN_NAME = \"Ethereum V2 Erc20\";\r\n    bytes32 constant TOKEN_SYMBOL = \"ETH20\";\r\n}\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n  function mul(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    uint256 c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/179\r\n */\r\ncontract ERC20Basic {\r\n  uint256 public totalSupply;\r\n  function balanceOf(address who) constant returns (uint256);\r\n  function transfer(address to, uint256 value) returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address owner, address spender) constant returns (uint256);\r\n  function transferFrom(address from, address to, uint256 value) returns (bool);\r\n  function approve(address spender, uint256 value) returns (bool);\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n/**\r\n * @title Basic token\r\n * @dev Basic version of StandardToken, with no allowances. \r\n */\r\ncontract BasicToken is ERC20Basic {\r\n    using SafeMath for uint256;\r\n\r\n    mapping (address => uint256) balances;\r\n\r\n    /**\r\n    * @dev transfer token for a specified address\r\n    * @param _to The address to transfer to.\r\n    * @param _value The amount to be transferred.\r\n    */\r\n    function transfer(address _to, uint256 _value) returns (bool) {\r\n        require(_to != address(0));\r\n\r\n        // SafeMath.sub will throw if there is not enough balance.\r\n        balances[msg.sender] = balances[msg.sender].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n        Transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev Gets the balance of the specified address.\r\n    * @param _owner The address to query the the balance of.\r\n    * @return An uint256 representing the amount owned by the passed address.\r\n    */\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * @title Standard ERC20 token\r\n *\r\n * @dev Implementation of the basic standard token.\r\n * @dev https://github.com/ethereum/EIPs/issues/20\r\n * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\r\n */\r\ncontract StandardToken is ERC20, BasicToken {\r\n\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n\r\n\r\n    /**\r\n     * @dev Transfer tokens from one address to another\r\n     * @param _from address The address which you want to send tokens from\r\n     * @param _to address The address which you want to transfer to\r\n     * @param _value uint256 the amount of tokens to be transferred\r\n     */\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool) {\r\n        require(_to != address(0));\r\n\r\n        var _allowance = allowed[_from][msg.sender];\r\n\r\n        // Check is not needed because sub(_allowance, _value) will already throw if this condition is not met\r\n        // require (_value <= _allowance);\r\n\r\n        balances[_from] = balances[_from].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n        allowed[_from][msg.sender] = _allowance.sub(_value);\r\n        Transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n     * @param _spender The address which will spend the funds.\r\n     * @param _value The amount of tokens to be spent.\r\n     */\r\n    function approve(address _spender, uint256 _value) returns (bool) {\r\n\r\n        // To change the approve amount you first have to reduce the addresses`\r\n        //  allowance to zero by calling `approve(_spender, 0)` if it is not\r\n        //  already 0 to mitigate the race condition described here:\r\n        //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n        require((_value == 0) || (allowed[msg.sender][_spender] == 0));\r\n\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n     * @param _owner address The address which owns the funds.\r\n     * @param _spender address The address which will spend the funds.\r\n     * @return A uint256 specifying the amount of tokens still available for the spender.\r\n     */\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n    /**\r\n     * approve should be called when allowed[_spender] == 0. To increment\r\n     * allowed value is better to use this function to avoid 2 calls (and wait until\r\n     * the first transaction is mined)\r\n     * From MonolithDAO Token.sol\r\n     */\r\n    function increaseApproval(address _spender, uint _addedValue) returns (bool success) {\r\n        allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\r\n        Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n        return true;\r\n    }\r\n\r\n    function decreaseApproval(address _spender, uint _subtractedValue) returns (bool success) {\r\n        uint oldValue = allowed[msg.sender][_spender];\r\n        if (_subtractedValue > oldValue) {\r\n            allowed[msg.sender][_spender] = 0;\r\n        }\r\n        else {\r\n            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\r\n        }\r\n        Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n        return true;\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * @title Mintable token\r\n * @dev Simple ERC20 Token example, with mintable token creation\r\n * @dev Issue: * https://github.com/OpenZeppelin/zeppelin-solidity/issues/120\r\n * Based on code by TokenMarketNet: https://github.com/TokenMarketNet/ico/blob/master/contracts/MintableToken.sol\r\n */\r\n\r\ncontract MintableToken is StandardToken, Ownable {\r\n    event Mint(address indexed to, uint256 amount);\r\n\r\n    event MintFinished();\r\n\r\n    bool public mintingFinished = false;\r\n\r\n\r\n    modifier canMint() {\r\n        require(!mintingFinished);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Function to mint tokens\r\n     * @param _to The address that will receive the minted tokens.\r\n     * @param _amount The amount of tokens to mint.\r\n     * @return A boolean that indicates if the operation was successful.\r\n     */\r\n    function mint(address _to, uint256 _amount) onlyOwner canMint returns (bool) {\r\n        totalSupply = totalSupply.add(_amount);\r\n        balances[_to] = balances[_to].add(_amount);\r\n        Mint(_to, _amount);\r\n        Transfer(0x0, _to, _amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Function to stop minting new tokens.\r\n     * @return True if the operation was successful.\r\n     */\r\n    function finishMinting() onlyOwner returns (bool) {\r\n        mintingFinished = true;\r\n        MintFinished();\r\n        return true;\r\n    }\r\n}\r\n\r\n/**\r\n * @title Burnable Token\r\n * @dev Token that can be irreversibly burned (destroyed).\r\n */\r\ncontract BurnableToken is StandardToken {\r\n\r\n    event Burn(address indexed burner, uint256 value);\r\n\r\n    /**\r\n     * @dev Burns a specific amount of tokens.\r\n     * @param _value The amount of token to be burned.\r\n     */\r\n    function burn(uint256 _value) public {\r\n        require(_value > 0);\r\n\r\n        address burner = msg.sender;\r\n        balances[burner] = balances[burner].sub(_value);\r\n        totalSupply = totalSupply.sub(_value);\r\n        Burn(burner, _value);\r\n    }\r\n}\r\n\r\ncontract EthereumV2Erc20 is usingEthereumV2Erc20Consts, MintableToken, BurnableToken {\r\n    /**\r\n     * @dev Pause token transfer. After successfully finished crowdsale it becomes true.\r\n     */\r\n    bool public paused = false;\r\n    /**\r\n     * @dev Accounts who can transfer token even if paused. Works only during crowdsale.\r\n     */\r\n    mapping(address => bool) excluded;\r\n\r\n    function name() constant public returns (string _name) {\r\n        return TOKEN_NAME;\r\n    }\r\n\r\n    function symbol() constant public returns (bytes32 _symbol) {\r\n        return TOKEN_SYMBOL;\r\n    }\r\n\r\n    function decimals() constant public returns (uint8 _decimals) {\r\n        return TOKEN_DECIMALS_UINT8;\r\n    }\r\n\r\n    function crowdsaleFinished() onlyOwner {\r\n        paused = false;\r\n        finishMinting();\r\n    }\r\n\r\n    function addExcluded(address _toExclude) onlyOwner {\r\n        excluded[_toExclude] = true;\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool) {\r\n        require(!paused || excluded[_from]);\r\n        return super.transferFrom(_from, _to, _value);\r\n    }\r\n\r\n    function transfer(address _to, uint256 _value) returns (bool) {\r\n        require(!paused || excluded[msg.sender]);\r\n        return super.transfer(_to, _value);\r\n    }\r\n\r\n    /**\r\n     * @dev Burn tokens from the specified address.\r\n     * @param _from     address The address which you want to burn tokens from.\r\n     * @param _value    uint    The amount of tokens to be burned.\r\n     */\r\n    function burnFrom(address _from, uint256 _value) returns (bool) {\r\n        require(_value > 0);\r\n        var allowance = allowed[_from][msg.sender];\r\n        balances[_from] = balances[_from].sub(_value);\r\n        totalSupply = totalSupply.sub(_value);\r\n        allowed[_from][msg.sender] = allowance.sub(_value);\r\n        Burn(_from, _value);\r\n        return true;\r\n    }\r\n}\r\ncontract EthereumV2Erc20RateProviderI {\r\n    /**\r\n     * @dev Calculate actual rate using the specified parameters.\r\n     * @param buyer     Investor (buyer) address.\r\n     * @param totalSold Amount of sold tokens.\r\n     * @param amountWei Amount of wei to purchase.\r\n     * @return ETH to Token rate.\r\n     */\r\n    function getRate(address buyer, uint totalSold, uint amountWei) public constant returns (uint);\r\n\r\n    /**\r\n     * @dev rate scale (or divider), to support not integer rates.\r\n     * @return Rate divider.\r\n     */\r\n    function getRateScale() public constant returns (uint);\r\n\r\n    /**\r\n     * @return Absolute base rate.\r\n     */\r\n    function getBaseRate() public constant returns (uint);\r\n}\r\n\r\ncontract EthereumV2Erc20RateProvider is usingEthereumV2Erc20Consts, EthereumV2Erc20RateProviderI, Ownable {\r\n    // rate calculate accuracy\r\n    uint constant RATE_SCALE = 1;\r\n    // Start time: Human time (GMT): Sunday, May 5, 2019 5:05:05 PM\r\n    // End time: Human time (GMT): Saturday, May 5, 2029 5:05:05 PM\r\n    \r\n    // Guaranteed by 100% ETH. \r\n    // Contract to buy 100% token to burn off. \r\n    // Service fee 2%. 98% of the funds were bought back by all contracts and then burned.\r\n    \r\n    uint constant STEP_9 =         50000 * TOKEN_DECIMAL_MULTIPLIER;           // Start from  0.00001      to  1.49 ETH         Price 100000 ETH20 = 1 ETH\r\n    uint constant STEP_8 =        150000 * TOKEN_DECIMAL_MULTIPLIER;         // Continue the next 0.5        - 2.99 ETH         Price  99000 ETH20 = 1 ETH\r\n    uint constant STEP_7 =       1150000 * TOKEN_DECIMAL_MULTIPLIER;         // Continue the next 1.5       - 19.99 ETH         Price  90000 ETH20 = 1 ETH\r\n    uint constant STEP_6 =      11150000 * TOKEN_DECIMAL_MULTIPLIER;        // Continue the next 11.5      - 199.99 ETH         Price  50000 ETH20 = 1 ETH\r\n    uint constant STEP_5 =     111150000 * TOKEN_DECIMAL_MULTIPLIER;       // Continue the next 111.5     - 1999.99 ETH         Price  10000 ETH20 = 1 ETH\r\n    uint constant STEP_4 =    1111150000 * TOKEN_DECIMAL_MULTIPLIER;      // Continue the next 1111.5    - 19999.99 ETH         Price   1000 ETH20 = 1 ETH\r\n    uint constant STEP_3 =   11111150000 * TOKEN_DECIMAL_MULTIPLIER;     // Continue the next 11111.5   - 199999.99 ETH         Price    100 ETH20 = 1 ETH\r\n    uint constant STEP_2 =  111111150000 * TOKEN_DECIMAL_MULTIPLIER;    // Continue the next 111111.5  - 1999999.99 ETH         Price     10 ETH20 = 1 ETH\r\n    uint constant STEP_1 = 2000000000000 * TOKEN_DECIMAL_MULTIPLIER;   // Continue the next 1111111.99 -19999999.99 ETH         Price      1 ETH20 = 1 ETH\r\n    \r\n    uint constant RATE_9 =   100000 * RATE_SCALE; // Price increases 0 %                       // Redemption price 98 %  Buy back burned\r\n    uint constant RATE_8 =    99000 * RATE_SCALE; // Price increases 1 %                       // Redemption price 98 %  Buy back burned\r\n    uint constant RATE_7 =    90000 * RATE_SCALE; // Price increases 10 %                      // Redemption price 98 %  Buy back burned\r\n    uint constant RATE_6 =    50000 * RATE_SCALE; // Price increases 100 % Increase by 2 times // Redemption price 98 %  Buy back burned\r\n    uint constant RATE_5 =    10000 * RATE_SCALE; // Price increases by 10 times               // Redemption price 98 %  Buy back burned\r\n    uint constant RATE_4 =    1000 * RATE_SCALE; // Price Increase by   100 times              // Redemption price 98 %  Buy back burned\r\n    uint constant RATE_3 =    100 * RATE_SCALE; // Price increase by    1000  times            // Redemption price 98 %  Buy back burned\r\n    uint constant RATE_2 =    10 * RATE_SCALE; // Price increase by     10000 times            // Redemption price 98 %  Buy back burned\r\n    uint constant RATE_1 =    1 * RATE_SCALE; // Price increase by      100000 times            // Redemption price 98 %  Buy back burned\r\n    \r\n    \r\n    uint constant BASE_RATE = 0 * RATE_SCALE;                                             // 1 ETH = 1 ETH20.  Standard price 0 %\r\n\r\n    struct ExclusiveRate {\r\n        // be careful, accuracies this about 1 minutes\r\n        uint32 workUntil;\r\n        // exclusive rate or 0\r\n        uint rate;\r\n        // rate bonus percent, which will be divided by 1000 or 0\r\n        uint16 bonusPercent1000;\r\n        // flag to check, that record exists\r\n        bool exists;\r\n    }\r\n\r\n    mapping(address => ExclusiveRate) exclusiveRate;\r\n\r\n    function getRateScale() public constant returns (uint) {\r\n        return RATE_SCALE;\r\n    }\r\n\r\n    function getBaseRate() public constant returns (uint) {\r\n        return BASE_RATE;\r\n    }\r\n    \r\n\r\n    function getRate(address buyer, uint totalSold, uint amountWei) public constant returns (uint) {\r\n        uint rate;\r\n        // apply sale\r\n        if (totalSold < STEP_9) {\r\n            rate = RATE_9;\r\n        }\r\n        else if (totalSold < STEP_8) {\r\n            rate = RATE_8;\r\n        }\r\n        else if (totalSold < STEP_7) {\r\n            rate = RATE_7;\r\n        }\r\n        else if (totalSold < STEP_6) {\r\n            rate = RATE_6;\r\n        }\r\n        else if (totalSold < STEP_5) {\r\n            rate = RATE_5;\r\n        }\r\n        else if (totalSold < STEP_4) {\r\n            rate = RATE_4;\r\n        }\r\n        else if (totalSold < STEP_3) {\r\n            rate = RATE_3;\r\n        }\r\n        else if (totalSold < STEP_2) {\r\n            rate = RATE_2;\r\n        }\r\n        else if (totalSold < STEP_1) {\r\n            rate = RATE_1;\r\n        }\r\n        else {\r\n            rate = BASE_RATE;\r\n        }\r\n    // apply bonus for amount\r\n        if (amountWei >= 100000 ether) {\r\n            rate += rate * 0 / 100;\r\n        }\r\n        else if (amountWei >= 10000 ether) {\r\n            rate += rate * 0 / 100;\r\n        }\r\n        else if (amountWei >= 1000 ether) {\r\n            rate += rate * 0 / 100;\r\n        }\r\n        else if (amountWei >= 100 ether) {\r\n            rate += rate * 0 / 100;\r\n        }\r\n        else if (amountWei >= 10 ether) {\r\n            rate += rate * 0 / 100;\r\n        }\r\n        else if (amountWei >= 1 ether) {\r\n            rate += rate * 0 / 1000;\r\n        }\r\n\r\n        ExclusiveRate memory eRate = exclusiveRate[buyer];\r\n        if (eRate.exists && eRate.workUntil >= now) {\r\n            if (eRate.rate != 0) {\r\n                rate = eRate.rate;\r\n            }\r\n            rate += rate * eRate.bonusPercent1000 / 1000;\r\n        }\r\n        return rate;\r\n    }\r\n\r\n    function setExclusiveRate(address _investor, uint _rate, uint16 _bonusPercent1000, uint32 _workUntil) onlyOwner {\r\n        exclusiveRate[_investor] = ExclusiveRate(_workUntil, _rate, _bonusPercent1000, true);\r\n    }\r\n\r\n    function removeExclusiveRate(address _investor) onlyOwner {\r\n        delete exclusiveRate[_investor];\r\n    }\r\n}\r\n/**\r\n * @title Crowdsale \r\n * @dev Crowdsale is a base contract for managing a token crowdsale.\r\n *\r\n * Crowdsales have a start and end timestamps, where investors can make\r\n * token purchases and the crowdsale will assign them tokens based\r\n * on a token per ETH rate. Funds collected are forwarded to a wallet \r\n * as they arrive.\r\n */\r\ncontract Crowdsale {\r\n    using SafeMath for uint;\r\n\r\n    // The token being sold\r\n    MintableToken public token;\r\n\r\n    // start and end timestamps where investments are allowed (both inclusive)\r\n    uint32 internal startTime;\r\n    uint32 internal endTime;\r\n\r\n    // address where funds are collected\r\n    address public wallet;\r\n\r\n    // amount of raised money in wei\r\n    uint public weiRaised;\r\n\r\n    /**\r\n     * @dev Amount of already sold tokens.\r\n     */\r\n    uint public soldTokens;\r\n\r\n    /**\r\n     * @dev Maximum amount of tokens to mint.\r\n     */\r\n    uint internal hardCap;\r\n\r\n    /**\r\n     * event for token purchase logging\r\n     * @param purchaser who paid for the tokens\r\n     * @param beneficiary who got the tokens\r\n     * @param value weis paid for purchase\r\n     * @param amount amount of tokens purchased\r\n     */\r\n    event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint value, uint amount);\r\n\r\n    function Crowdsale(uint _startTime, uint _endTime, uint _hardCap, address _wallet) {\r\n        require(_endTime >= _startTime);\r\n        require(_wallet != 0x0);\r\n        require(_hardCap > 0);\r\n\r\n        token = createTokenContract();\r\n        startTime = uint32(_startTime);\r\n        endTime = uint32(_endTime);\r\n        hardCap = _hardCap;\r\n        wallet = _wallet;\r\n    }\r\n\r\n    // creates the token to be sold.\r\n    // override this method to have crowdsale of a specific mintable token.\r\n    function createTokenContract() internal returns (MintableToken) {\r\n        return new MintableToken();\r\n    }\r\n\r\n    /**\r\n     * @dev this method might be overridden for implementing any sale logic.\r\n     * @return Actual rate.\r\n     */\r\n    function getRate(uint amount) internal constant returns (uint);\r\n\r\n    function getBaseRate() internal constant returns (uint);\r\n\r\n    /**\r\n     * @dev rate scale (or divider), to support not integer rates.\r\n     * @return Rate divider.\r\n     */\r\n    function getRateScale() internal constant returns (uint) {\r\n        return 1;\r\n    }\r\n\r\n    // fallback function can be used to buy tokens\r\n    function() payable {\r\n        buyTokens(msg.sender, msg.value);\r\n    }\r\n\r\n    // low level token purchase function\r\n    function buyTokens(address beneficiary, uint amountWei) internal {\r\n        require(beneficiary != 0x0);\r\n\r\n        // total minted tokens\r\n        uint totalSupply = token.totalSupply();\r\n\r\n        // actual token minting rate (with considering bonuses and discounts)\r\n        uint actualRate = getRate(amountWei);\r\n        uint rateScale = getRateScale();\r\n\r\n        require(validPurchase(amountWei, actualRate, totalSupply));\r\n\r\n        // calculate token amount to be created\r\n        uint tokens = amountWei.mul(actualRate).div(rateScale);\r\n\r\n        // update state\r\n        weiRaised = weiRaised.add(amountWei);\r\n        soldTokens = soldTokens.add(tokens);\r\n\r\n        token.mint(beneficiary, tokens);\r\n        TokenPurchase(msg.sender, beneficiary, amountWei, tokens);\r\n\r\n        forwardFunds(amountWei);\r\n    }\r\n\r\n    // send ether to the fund collection wallet\r\n    // override to create custom fund forwarding mechanisms\r\n    function forwardFunds(uint amountWei) internal {\r\n        wallet.transfer(amountWei);\r\n    }\r\n\r\n    /**\r\n     * @dev Check if the specified purchase is valid.\r\n     * @return true if the transaction can buy tokens\r\n     */\r\n    function validPurchase(uint _amountWei, uint _actualRate, uint _totalSupply) internal constant returns (bool) {\r\n        bool withinPeriod = now >= startTime && now <= endTime;\r\n        bool nonZeroPurchase = _amountWei != 0;\r\n        bool hardCapNotReached = _totalSupply <= hardCap;\r\n\r\n        return withinPeriod && nonZeroPurchase && hardCapNotReached;\r\n    }\r\n\r\n    /**\r\n     * @dev Because of discount hasEnded might be true, but validPurchase returns false.\r\n     * @return true if crowdsale event has ended\r\n     */\r\n    function hasEnded() public constant returns (bool) {\r\n        return now > endTime || token.totalSupply() > hardCap;\r\n    }\r\n\r\n    /**\r\n     * @return true if crowdsale event has started\r\n     */\r\n    function hasStarted() public constant returns (bool) {\r\n        return now >= startTime;\r\n    }\r\n}\r\n\r\ncontract FinalizableCrowdsale is Crowdsale, Ownable {\r\n    using SafeMath for uint256;\r\n\r\n    bool public isFinalized = false;\r\n\r\n    event Finalized();\r\n\r\n    function FinalizableCrowdsale(uint _startTime, uint _endTime, uint _hardCap, address _wallet)\r\n            Crowdsale(_startTime, _endTime, _hardCap, _wallet) {\r\n    }\r\n\r\n    /**\r\n     * @dev Must be called after crowdsale ends, to do some extra finalization\r\n     * work. Calls the contract's finalization function.\r\n     */\r\n    function finalize() onlyOwner notFinalized {\r\n        require(hasEnded());\r\n\r\n        finalization();\r\n        Finalized();\r\n\r\n        isFinalized = true;\r\n    }\r\n\r\n    /**\r\n     * @dev Can be overriden to add finalization logic. The overriding function\r\n     * should call super.finalization() to ensure the chain of finalization is\r\n     * executed entirely.\r\n     */\r\n    function finalization() internal {\r\n    }\r\n\r\n    modifier notFinalized() {\r\n        require(!isFinalized);\r\n        _;\r\n    }\r\n}\r\n\r\ncontract EthereumV2Erc20Crowdsale is usingEthereumV2Erc20Consts, FinalizableCrowdsale {\r\n    EthereumV2Erc20RateProviderI public rateProvider;\r\n\r\n    function EthereumV2Erc20Crowdsale(\r\n            uint _startTime,\r\n            uint _endTime,\r\n            uint _hardCapTokens\r\n    )\r\n            FinalizableCrowdsale(_startTime, _endTime, _hardCapTokens * TOKEN_DECIMAL_MULTIPLIER, COLD_WALLET) {\r\n\r\n        token.mint(TEAM_ADDRESS, TEAM_TOKENS);\r\n        token.mint(BOUNTY_ADDRESS, BOUNTY_TOKENS);\r\n        token.mint(PREICO_ADDRESS, PREICO_TOKENS);\r\n\r\n        EthereumV2Erc20(token).addExcluded(TEAM_ADDRESS);\r\n        EthereumV2Erc20(token).addExcluded(BOUNTY_ADDRESS);\r\n        EthereumV2Erc20(token).addExcluded(PREICO_ADDRESS);\r\n\r\n        EthereumV2Erc20RateProvider provider = new EthereumV2Erc20RateProvider();\r\n        provider.transferOwnership(owner);\r\n        rateProvider = provider;\r\n    }\r\n\r\n    /**\r\n     * @dev override token creation to integrate with MyWill token.\r\n     */\r\n    function createTokenContract() internal returns (MintableToken) {\r\n        return new EthereumV2Erc20();\r\n    }\r\n\r\n    /**\r\n     * @dev override getRate to integrate with rate provider.\r\n     */\r\n    function getRate(uint _value) internal constant returns (uint) {\r\n        return rateProvider.getRate(msg.sender, soldTokens, _value);\r\n    }\r\n\r\n    function getBaseRate() internal constant returns (uint) {\r\n        return rateProvider.getRate(msg.sender, soldTokens, MINIMAL_PURCHASE);\r\n    }\r\n\r\n    /**\r\n     * @dev override getRateScale to integrate with rate provider.\r\n     */\r\n    function getRateScale() internal constant returns (uint) {\r\n        return rateProvider.getRateScale();\r\n    }\r\n\r\n    /**\r\n     * @dev Admin can set new rate provider.\r\n     * @param _rateProviderAddress New rate provider.\r\n     */\r\n    function setRateProvider(address _rateProviderAddress) onlyOwner {\r\n        require(_rateProviderAddress != 0);\r\n        rateProvider = EthereumV2Erc20RateProviderI(_rateProviderAddress);\r\n    }\r\n\r\n    /**\r\n     * @dev Admin can move end time.\r\n     * @param _endTime New end time.\r\n     */\r\n    function setEndTime(uint _endTime) onlyOwner notFinalized {\r\n        require(_endTime > startTime);\r\n        endTime = uint32(_endTime);\r\n    }\r\n\r\n    function setHardCap(uint _hardCapTokens) onlyOwner notFinalized {\r\n        require(_hardCapTokens * TOKEN_DECIMAL_MULTIPLIER > hardCap);\r\n        hardCap = _hardCapTokens * TOKEN_DECIMAL_MULTIPLIER;\r\n    }\r\n\r\n    function setStartTime(uint _startTime) onlyOwner notFinalized {\r\n        require(_startTime < endTime);\r\n        startTime = uint32(_startTime);\r\n    }\r\n\r\n    function addExcluded(address _address) onlyOwner notFinalized {\r\n        EthereumV2Erc20(token).addExcluded(_address);\r\n    }\r\n\r\n    function validPurchase(uint _amountWei, uint _actualRate, uint _totalSupply) internal constant returns (bool) {\r\n        if (_amountWei < MINIMAL_PURCHASE) {\r\n            return false;\r\n        }\r\n        return super.validPurchase(_amountWei, _actualRate, _totalSupply);\r\n    }\r\n\r\n    function finalization() internal {\r\n        super.finalization();\r\n        token.finishMinting();\r\n        EthereumV2Erc20(token).crowdsaleFinished();\r\n        token.transferOwnership(owner);\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @title Proxy\r\n * @dev Implements delegation of calls to other contracts, with proper\r\n * forwarding of return values and bubbling of failures.\r\n * It defines a fallback function that delegates all calls to the address\r\n * returned by the abstract _implementation() internal function.\r\n */\r\ncontract Proxy {\r\n    /**\r\n     * @dev Fallback function.\r\n     * Implemented entirely in `_fallback`.\r\n     */\r\n    function () payable external {\r\n        _fallback();\r\n    }\r\n\r\n    /**\r\n     * @return The Address of the implementation.\r\n     */\r\n    function _implementation() internal view returns (address);\r\n\r\n    /**\r\n     * @dev Delegates execution to an implementation contract.\r\n     * This is a low level function that doesn't return to its internal call site.\r\n     * It will return to the external caller whatever the implementation returns.\r\n     * @param implementation Address to delegate.\r\n     */\r\n    function _delegate(address implementation) internal {\r\n        assembly {\r\n        // Copy msg.data. We take full control of memory in this inline assembly\r\n        // block because it will not return to Solidity code. We overwrite the\r\n        // Solidity scratch pad at memory position 0.\r\n            calldatacopy(0, 0, calldatasize)\r\n\r\n        // Call the implementation.\r\n        // out and outsize are 0 because we don't know the size yet.\r\n            let result := delegatecall(gas, implementation, 0, calldatasize, 0, 0)\r\n\r\n        // Copy the returned data.\r\n            returndatacopy(0, 0, returndatasize)\r\n\r\n            switch result\r\n            // delegatecall returns 0 on error.\r\n            case 0 { revert(0, returndatasize) }\r\n            default { return(0, returndatasize) }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Function that is run as the first thing in the fallback function.\r\n     * Can be redefined in derived contracts to add functionality.\r\n     * Redefinitions must call super._willFallback().\r\n     */\r\n    function _willFallback() internal {\r\n    }\r\n\r\n    /**\r\n     * @dev fallback implementation.\r\n     * Extracted to enable manual triggering.\r\n     */\r\n    function _fallback() internal {\r\n        _willFallback();\r\n        _delegate(_implementation());\r\n    }\r\n}\r\n\r\n// File: contracts/zeppelin/AddressUtils.sol\r\n\r\n/**\r\n * Utility library of inline functions on addresses\r\n */\r\nlibrary AddressUtils {\r\n\r\n    /**\r\n     * Returns whether the target address is a contract\r\n     * @dev This function will return false if invoked during the constructor of a contract,\r\n     * as the code is not actually created until after the constructor finishes.\r\n     * @param addr address to check\r\n     * @return whether the target address is a contract\r\n     */\r\n    function isContract(address addr) internal view returns (bool) {\r\n        uint256 size;\r\n        // XXX Currently there is no better way to check if there is a contract in an address\r\n        // than to check the size of the code at that address.\r\n        // See https://ethereum.stackexchange.com/a/14016/36603\r\n        // for more details about how this works.\r\n        // TODO Check this again before the Serenity release, because all addresses will be\r\n        // contracts then.\r\n        // solium-disable-next-line security/no-inline-assembly\r\n        assembly { size := extcodesize(addr) }\r\n        return size > 0;\r\n    }\r\n\r\n}\r\n\r\n\r\n\r\n\r\ncontract Token {\r\n    bytes32 public standard;\r\n    bytes32 public name;\r\n    bytes32 public symbol;\r\n    uint256 public totalSupply;\r\n    uint8 public decimals;\r\n    bool public allowTransactions;\r\n    mapping (address => uint256) public balanceOf;\r\n    mapping (address => mapping (address => uint256)) public allowance;\r\n    function transfer(address _to, uint256 _value) returns (bool success);\r\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success);\r\n    function approve(address _spender, uint256 _value) returns (bool success);\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\r\n}\r\n\r\ncontract Promotion {\r\n    mapping(address => address[]) public referrals; // mapping of affiliate address to referral addresses\r\n    mapping(address => address) public affiliates; // mapping of referrals addresses to affiliate addresses\r\n    mapping(address => bool) public admins; // mapping of admin accounts\r\n    string[] public affiliateList;\r\n    address public owner;\r\n\r\n    function setOwner(address newOwner);\r\n    function setAdmin(address admin, bool isAdmin) public;\r\n    function assignReferral (address affiliate, address referral) public;\r\n\r\n    function getAffiliateCount() returns (uint);\r\n    function getAffiliate(address refferal) public returns (address);\r\n    function getReferrals(address affiliate) public returns (address[]);\r\n}\r\n\r\ncontract TokenList {\r\n    function isTokenInList(address tokenAddress) public constant returns (bool);\r\n}\r\n\r\n\r\ncontract BTC20Exchange {\r\n    function assert(bool assertion) {\r\n        if (!assertion) throw;\r\n    }\r\n    function safeMul(uint a, uint b) returns (uint) {\r\n        uint c = a * b;\r\n        assert(a == 0 || c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function safeSub(uint a, uint b) returns (uint) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function safeAdd(uint a, uint b) returns (uint) {\r\n        uint c = a + b;\r\n        assert(c>=a && c>=b);\r\n        return c;\r\n    }\r\n    address public owner;\r\n    mapping (address => uint256) public invalidOrder;\r\n\r\n    event SetOwner(address indexed previousOwner, address indexed newOwner);\r\n    modifier onlyOwner {\r\n        assert(msg.sender == owner);\r\n        _;\r\n    }\r\n    function setOwner(address newOwner) onlyOwner {\r\n        SetOwner(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n    function getOwner() returns (address out) {\r\n        return owner;\r\n    }\r\n    function invalidateOrdersBefore(address user, uint256 nonce) onlyAdmin {\r\n        if (nonce < invalidOrder[user]) throw;\r\n        invalidOrder[user] = nonce;\r\n    }\r\n\r\n    mapping (address => mapping (address => uint256)) public tokens; //mapping of token addresses to mapping of account balances\r\n\r\n    mapping (address => bool) public admins;\r\n    mapping (address => uint256) public lastActiveTransaction;\r\n    mapping (bytes32 => uint256) public orderFills;\r\n    address public feeAccount;\r\n    uint256 public feeAffiliate; // percentage times (1 ether)\r\n    uint256 public inactivityReleasePeriod;\r\n    mapping (bytes32 => bool) public traded;\r\n    mapping (bytes32 => bool) public withdrawn;\r\n    uint256 public makerFee; // fraction * 1 ether\r\n    uint256 public takerFee; // fraction * 1 ether\r\n    uint256 public affiliateFee; // fraction as proportion of 1 ether\r\n    uint256 public makerAffiliateFee; // wei deductible from makerFee\r\n    uint256 public takerAffiliateFee; // wei deductible form takerFee\r\n\r\n    mapping (address => address) public referrer;  // mapping of user addresses to their referrer addresses\r\n\r\n    address public affiliateContract;\r\n    address public tokenListContract;\r\n\r\n\r\n    enum Errors {\r\n        INVLID_PRICE,           // Order prices don't match\r\n        INVLID_SIGNATURE,       // Signature is invalid\r\n        TOKENS_DONT_MATCH,      // Maker/taker tokens don't match\r\n        ORDER_ALREADY_FILLED,   // Order was already filled\r\n        GAS_TOO_HIGH            // Too high gas fee\r\n    }\r\n\r\n    //event Order(address tokenBuy, uint256 amountBuy, address tokenSell, uint256 amountSell, uint256 expires, uint256 nonce, address user, uint8 v, bytes32 r, bytes32 s);\r\n    //event Cancel(address tokenBuy, uint256 amountBuy, address tokenSell, uint256 amountSell, uint256 expires, uint256 nonce, address user, uint8 v, bytes32 r, bytes32 s);\r\n    event Trade(\r\n        address takerTokenBuy, uint256 takerAmountBuy,\r\n        address takerTokenSell, uint256 takerAmountSell,\r\n        address maker, address indexed taker,\r\n        uint256 makerFee, uint256 takerFee,\r\n        uint256 makerAmountTaken, uint256 takerAmountTaken,\r\n        bytes32 indexed makerOrderHash, bytes32 indexed takerOrderHash\r\n    );\r\n    event Deposit(address indexed token, address indexed user, uint256 amount, uint256 balance, address indexed referrerAddress);\r\n    event Withdraw(address indexed token, address indexed user, uint256 amount, uint256 balance, uint256 withdrawFee);\r\n    event FeeChange(uint256 indexed makerFee, uint256 indexed takerFee, uint256 indexed affiliateFee);\r\n    //event AffiliateFeeChange(uint256 newAffiliateFee);\r\n    event LogError(uint8 indexed errorId, bytes32 indexed makerOrderHash, bytes32 indexed takerOrderHash);\r\n    event CancelOrder(\r\n        bytes32 indexed cancelHash,\r\n        bytes32 indexed orderHash,\r\n        address indexed user,\r\n        address tokenSell,\r\n        uint256 amountSell,\r\n        uint256 cancelFee\r\n    );\r\n\r\n    function setInactivityReleasePeriod(uint256 expiry) onlyAdmin returns (bool success) {\r\n        if (expiry > 1000000) throw;\r\n        inactivityReleasePeriod = expiry;\r\n        return true;\r\n    }\r\n\r\n    function Exchange(address feeAccount_, uint256 makerFee_, uint256 takerFee_, uint256 affiliateFee_, address affiliateContract_, address tokenListContract_) {\r\n        owner = msg.sender;\r\n        feeAccount = feeAccount_;\r\n        inactivityReleasePeriod = 100000;\r\n        makerFee = makerFee_;\r\n        takerFee = takerFee_;\r\n        affiliateFee = affiliateFee_;\r\n\r\n\r\n\r\n        makerAffiliateFee = safeMul(makerFee, affiliateFee_) / (1 ether);\r\n        takerAffiliateFee = safeMul(takerFee, affiliateFee_) / (1 ether);\r\n\r\n        affiliateContract = affiliateContract_;\r\n        tokenListContract = tokenListContract_;\r\n    }\r\n\r\n    function setFees(uint256 makerFee_, uint256 takerFee_, uint256 affiliateFee_) onlyOwner {\r\n        require(makerFee_ < 10 finney && takerFee_ < 10 finney);\r\n        require(affiliateFee_ > affiliateFee);\r\n        makerFee = makerFee_;\r\n        takerFee = takerFee_;\r\n        affiliateFee = affiliateFee_;\r\n        makerAffiliateFee = safeMul(makerFee, affiliateFee_) / (1 ether);\r\n        takerAffiliateFee = safeMul(takerFee, affiliateFee_) / (1 ether);\r\n\r\n        FeeChange(makerFee, takerFee, affiliateFee_);\r\n    }\r\n\r\n    function setAdmin(address admin, bool isAdmin) onlyOwner {\r\n        admins[admin] = isAdmin;\r\n    }\r\n\r\n    modifier onlyAdmin {\r\n        if (msg.sender != owner && !admins[msg.sender]) throw;\r\n        _;\r\n    }\r\n\r\n    function() external {\r\n        throw;\r\n    }\r\n\r\n    function depositToken(address token, uint256 amount, address referrerAddress) {\r\n        //require(EthermiumTokenList(tokenListContract).isTokenInList(token));\r\n        if (referrerAddress == msg.sender) referrerAddress = address(0);\r\n        if (referrer[msg.sender] == address(0x0))   {\r\n            if (referrerAddress != address(0x0) && Promotion(affiliateContract).getAffiliate(msg.sender) == address(0))\r\n            {\r\n                referrer[msg.sender] = referrerAddress;\r\n                Promotion(affiliateContract).assignReferral(referrerAddress, msg.sender);\r\n            }\r\n            else\r\n            {\r\n                referrer[msg.sender] = Promotion(affiliateContract).getAffiliate(msg.sender);\r\n            }\r\n        }\r\n        tokens[token][msg.sender] = safeAdd(tokens[token][msg.sender], amount);\r\n        lastActiveTransaction[msg.sender] = block.number;\r\n        if (!Token(token).transferFrom(msg.sender, this, amount)) throw;\r\n        Deposit(token, msg.sender, amount, tokens[token][msg.sender], referrer[msg.sender]);\r\n    }\r\n\r\n    function deposit(address referrerAddress) payable {\r\n        if (referrerAddress == msg.sender) referrerAddress = address(0);\r\n        if (referrer[msg.sender] == address(0x0))   {\r\n            if (referrerAddress != address(0x0) && Promotion(affiliateContract).getAffiliate(msg.sender) == address(0))\r\n            {\r\n                referrer[msg.sender] = referrerAddress;\r\n                Promotion(affiliateContract).assignReferral(referrerAddress, msg.sender);\r\n            }\r\n            else\r\n            {\r\n                referrer[msg.sender] = Promotion(affiliateContract).getAffiliate(msg.sender);\r\n            }\r\n        }\r\n        tokens[address(0)][msg.sender] = safeAdd(tokens[address(0)][msg.sender], msg.value);\r\n        lastActiveTransaction[msg.sender] = block.number;\r\n        Deposit(address(0), msg.sender, msg.value, tokens[address(0)][msg.sender], referrer[msg.sender]);\r\n    }\r\n\r\n    function withdraw(address token, uint256 amount) returns (bool success) {\r\n        if (safeSub(block.number, lastActiveTransaction[msg.sender]) < inactivityReleasePeriod) throw;\r\n        if (tokens[token][msg.sender] < amount) throw;\r\n        tokens[token][msg.sender] = safeSub(tokens[token][msg.sender], amount);\r\n        if (token == address(0)) {\r\n            if (!msg.sender.send(amount)) throw;\r\n        } else {\r\n            if (!Token(token).transfer(msg.sender, amount)) throw;\r\n        }\r\n        Withdraw(token, msg.sender, amount, tokens[token][msg.sender], 0);\r\n    }\r\n\r\n    function adminWithdraw(address token, uint256 amount, address user, uint256 nonce, uint8 v, bytes32 r, bytes32 s, uint256 feeWithdrawal) onlyAdmin returns (bool success) {\r\n        bytes32 hash = keccak256(this, token, amount, user, nonce);\r\n        if (withdrawn[hash]) throw;\r\n        withdrawn[hash] = true;\r\n        if (ecrecover(keccak256(\"\\x19Ethereum Signed Message:\\n32\", hash), v, r, s) != user) throw;\r\n        if (feeWithdrawal > 50 finney) feeWithdrawal = 50 finney;\r\n        if (tokens[token][user] < amount) throw;\r\n        tokens[token][user] = safeSub(tokens[token][user], amount);\r\n        tokens[address(0)][user] = safeSub(tokens[address(0x0)][user], feeWithdrawal);\r\n        //tokens[token][feeAccount] = safeAdd(tokens[token][feeAccount], safeMul(feeWithdrawal, amount) / 1 ether);\r\n        tokens[address(0)][feeAccount] = safeAdd(tokens[address(0)][feeAccount], feeWithdrawal);\r\n\r\n        //amount = safeMul((1 ether - feeWithdrawal), amount) / 1 ether;\r\n        if (token == address(0)) {\r\n            if (!user.send(amount)) throw;\r\n        } else {\r\n            if (!Token(token).transfer(user, amount)) throw;\r\n        }\r\n        lastActiveTransaction[user] = block.number;\r\n        Withdraw(token, user, amount, tokens[token][user], feeWithdrawal);\r\n    }\r\n\r\n    function balanceOf(address token, address user) constant returns (uint256) {\r\n        return tokens[token][user];\r\n    }\r\n\r\n    struct OrderPair {\r\n        uint256 makerAmountBuy;\r\n        uint256 makerAmountSell;\r\n        uint256 makerNonce;\r\n        uint256 takerAmountBuy;\r\n        uint256 takerAmountSell;\r\n        uint256 takerNonce;\r\n        uint256 takerGasFee;\r\n\r\n        address makerTokenBuy;\r\n        address makerTokenSell;\r\n        address maker;\r\n        address takerTokenBuy;\r\n        address takerTokenSell;\r\n        address taker;\r\n\r\n        bytes32 makerOrderHash;\r\n        bytes32 takerOrderHash;\r\n    }\r\n\r\n    struct TradeValues {\r\n        uint256 qty;\r\n        uint256 invQty;\r\n        uint256 makerAmountTaken;\r\n        uint256 takerAmountTaken;\r\n        address makerReferrer;\r\n        address takerReferrer;\r\n    }\r\n\r\n\r\n\r\n\r\n    function trade(\r\n        uint8[2] v,\r\n        bytes32[4] rs,\r\n        uint256[7] tradeValues,\r\n        address[6] tradeAddresses\r\n    ) onlyAdmin returns (uint filledTakerTokenAmount)\r\n    {\r\n\r\n        /* tradeValues\r\n          [0] makerAmountBuy\r\n          [1] makerAmountSell\r\n          [2] makerNonce\r\n          [3] takerAmountBuy\r\n          [4] takerAmountSell\r\n          [5] takerNonce\r\n          [6] takerGasFee\r\n\r\n          tradeAddresses\r\n          [0] makerTokenBuy\r\n          [1] makerTokenSell\r\n          [2] maker\r\n          [3] takerTokenBuy\r\n          [4] takerTokenSell\r\n          [5] taker\r\n        */\r\n\r\n        OrderPair memory t  = OrderPair({\r\n            makerAmountBuy  : tradeValues[0],\r\n            makerAmountSell : tradeValues[1],\r\n            makerNonce      : tradeValues[2],\r\n            takerAmountBuy  : tradeValues[3],\r\n            takerAmountSell : tradeValues[4],\r\n            takerNonce      : tradeValues[5],\r\n            takerGasFee     : tradeValues[6],\r\n\r\n            makerTokenBuy   : tradeAddresses[0],\r\n            makerTokenSell  : tradeAddresses[1],\r\n            maker           : tradeAddresses[2],\r\n            takerTokenBuy   : tradeAddresses[3],\r\n            takerTokenSell  : tradeAddresses[4],\r\n            taker           : tradeAddresses[5],\r\n\r\n            makerOrderHash  : keccak256(this, tradeAddresses[0], tradeValues[0], tradeAddresses[1], tradeValues[1], tradeValues[2], tradeAddresses[2]),\r\n            takerOrderHash  : keccak256(this, tradeAddresses[3], tradeValues[3], tradeAddresses[4], tradeValues[4], tradeValues[5], tradeAddresses[5])\r\n        });\r\n\r\n        //bytes32 makerOrderHash = keccak256(this, tradeAddresses[0], tradeValues[0], tradeAddresses[1], tradeValues[1], tradeValues[2], tradeAddresses[2]);\r\n        //bytes32 makerOrderHash = ยง\r\n        if (ecrecover(keccak256(\"\\x19Ethereum Signed Message:\\n32\", t.makerOrderHash), v[0], rs[0], rs[1]) != t.maker)\r\n        {\r\n            LogError(uint8(Errors.INVLID_SIGNATURE), t.makerOrderHash, t.takerOrderHash);\r\n            return 0;\r\n        }\r\n        //bytes32 takerOrderHash = keccak256(this, tradeAddresses[3], tradeValues[3], tradeAddresses[4], tradeValues[4], tradeValues[5], tradeAddresses[5]);\r\n        //bytes32 takerOrderHash = keccak256(this, t.takerTokenBuy, t.takerAmountBuy, t.takerTokenSell, t.takerAmountSell, t.takerNonce, t.taker);\r\n        if (ecrecover(keccak256(\"\\x19Ethereum Signed Message:\\n32\", t.takerOrderHash), v[1], rs[2], rs[3]) != t.taker)\r\n        {\r\n            LogError(uint8(Errors.INVLID_SIGNATURE), t.makerOrderHash, t.takerOrderHash);\r\n            return 0;\r\n        }\r\n\r\n        if (t.makerTokenBuy != t.takerTokenSell || t.makerTokenSell != t.takerTokenBuy)\r\n        {\r\n            LogError(uint8(Errors.TOKENS_DONT_MATCH), t.makerOrderHash, t.takerOrderHash);\r\n            return 0;\r\n        } // tokens don't match\r\n\r\n        if (t.takerGasFee > 1 finney)\r\n        {\r\n            LogError(uint8(Errors.GAS_TOO_HIGH), t.makerOrderHash, t.takerOrderHash);\r\n            return 0;\r\n        } // takerGasFee too high\r\n\r\n\r\n\r\n        if (!(\r\n        (t.makerTokenBuy != address(0x0) && safeMul(t.makerAmountSell, 5 finney) / t.makerAmountBuy >= safeMul(t.takerAmountBuy, 5 finney) / t.takerAmountSell)\r\n        ||\r\n        (t.makerTokenBuy == address(0x0) && safeMul(t.makerAmountBuy, 5 finney) / t.makerAmountSell <= safeMul(t.takerAmountSell, 5 finney) / t.takerAmountBuy)\r\n        ))\r\n        {\r\n            LogError(uint8(Errors.INVLID_PRICE), t.makerOrderHash, t.takerOrderHash);\r\n            return 0; // prices don't match\r\n        }\r\n\r\n        TradeValues memory tv = TradeValues({\r\n            qty                 : 0,\r\n            invQty              : 0,\r\n            makerAmountTaken    : 0,\r\n            takerAmountTaken    : 0,\r\n            makerReferrer       : referrer[t.maker],\r\n            takerReferrer       : referrer[t.taker]\r\n        });\r\n\r\n        if (tv.makerReferrer == address(0x0)) tv.makerReferrer = feeAccount;\r\n        if (tv.takerReferrer == address(0x0)) tv.takerReferrer = feeAccount;\r\n\r\n\r\n\r\n        // maker buy, taker sell\r\n        if (t.makerTokenBuy != address(0x0))\r\n        {\r\n\r\n\r\n            tv.qty = min(safeSub(t.makerAmountBuy, orderFills[t.makerOrderHash]), safeSub(t.takerAmountSell, safeMul(orderFills[t.takerOrderHash], t.takerAmountSell) / t.takerAmountBuy));\r\n            if (tv.qty == 0)\r\n            {\r\n                LogError(uint8(Errors.ORDER_ALREADY_FILLED), t.makerOrderHash, t.takerOrderHash);\r\n                return 0;\r\n            }\r\n\r\n            tv.invQty = safeMul(tv.qty, t.makerAmountSell) / t.makerAmountBuy;\r\n\r\n            tokens[t.makerTokenSell][t.maker]           = safeSub(tokens[t.makerTokenSell][t.maker],           tv.invQty);\r\n            tv.makerAmountTaken                         = safeSub(tv.qty, safeMul(tv.qty, makerFee) / (1 ether));\r\n            tokens[t.makerTokenBuy][t.maker]            = safeAdd(tokens[t.makerTokenBuy][t.maker],            tv.makerAmountTaken);\r\n            tokens[t.makerTokenBuy][tv.makerReferrer]   = safeAdd(tokens[t.makerTokenBuy][tv.makerReferrer],   safeMul(tv.qty,    makerAffiliateFee) / (1 ether));\r\n\r\n            tokens[t.takerTokenSell][t.taker]           = safeSub(tokens[t.takerTokenSell][t.taker],           tv.qty);\r\n            tv.takerAmountTaken                         = safeSub(safeSub(tv.invQty, safeMul(tv.invQty, takerFee) / (1 ether)), safeMul(tv.invQty, t.takerGasFee) / (1 ether));\r\n            tokens[t.takerTokenBuy][t.taker]            = safeAdd(tokens[t.takerTokenBuy][t.taker],            tv.takerAmountTaken);\r\n            tokens[t.takerTokenBuy][tv.takerReferrer]   = safeAdd(tokens[t.takerTokenBuy][tv.takerReferrer],   safeMul(tv.invQty, takerAffiliateFee) / (1 ether));\r\n\r\n            tokens[t.makerTokenBuy][feeAccount]     = safeAdd(tokens[t.makerTokenBuy][feeAccount],      safeMul(tv.qty,    safeSub(makerFee, makerAffiliateFee)) / (1 ether));\r\n            tokens[t.takerTokenBuy][feeAccount]     = safeAdd(tokens[t.takerTokenBuy][feeAccount],      safeAdd(safeMul(tv.invQty, safeSub(takerFee, takerAffiliateFee)) / (1 ether), safeMul(tv.invQty, t.takerGasFee) / (1 ether)));\r\n\r\n\r\n            orderFills[t.makerOrderHash]            = safeAdd(orderFills[t.makerOrderHash], tv.qty);\r\n            orderFills[t.takerOrderHash]            = safeAdd(orderFills[t.takerOrderHash], safeMul(tv.qty, t.takerAmountBuy) / t.takerAmountSell);\r\n            lastActiveTransaction[t.maker]          = block.number;\r\n            lastActiveTransaction[t.taker]          = block.number;\r\n\r\n            Trade(\r\n                t.takerTokenBuy, tv.qty,\r\n                t.takerTokenSell, tv.invQty,\r\n                t.maker, t.taker,\r\n                makerFee, takerFee,\r\n                tv.makerAmountTaken , tv.takerAmountTaken,\r\n                t.makerOrderHash, t.takerOrderHash\r\n            );\r\n            return tv.qty;\r\n        }\r\n        // maker sell, taker buy\r\n        else\r\n        {\r\n\r\n            tv.qty = min(safeSub(t.makerAmountSell,  safeMul(orderFills[t.makerOrderHash], t.makerAmountSell) / t.makerAmountBuy), safeSub(t.takerAmountBuy, orderFills[t.takerOrderHash]));\r\n            if (tv.qty == 0)\r\n            {\r\n                LogError(uint8(Errors.ORDER_ALREADY_FILLED), t.makerOrderHash, t.takerOrderHash);\r\n                return 0;\r\n            }\r\n\r\n            tv.invQty = safeMul(tv.qty, t.makerAmountBuy) / t.makerAmountSell;\r\n\r\n            tokens[t.makerTokenSell][t.maker]           = safeSub(tokens[t.makerTokenSell][t.maker],           tv.qty);\r\n            tv.makerAmountTaken                         = safeSub(tv.invQty, safeMul(tv.invQty, makerFee) / (1 ether));\r\n            tokens[t.makerTokenBuy][t.maker]            = safeAdd(tokens[t.makerTokenBuy][t.maker],            tv.makerAmountTaken);\r\n            tokens[t.makerTokenBuy][tv.makerReferrer]   = safeAdd(tokens[t.makerTokenBuy][tv.makerReferrer],   safeMul(tv.invQty, makerAffiliateFee) / (1 ether));\r\n\r\n            tokens[t.takerTokenSell][t.taker]           = safeSub(tokens[t.takerTokenSell][t.taker],           tv.invQty);\r\n            tv.takerAmountTaken                         = safeSub(safeSub(tv.qty,    safeMul(tv.qty, takerFee) / (1 ether)), safeMul(tv.qty, t.takerGasFee) / (1 ether));\r\n            tokens[t.takerTokenBuy][t.taker]            = safeAdd(tokens[t.takerTokenBuy][t.taker],            tv.takerAmountTaken);\r\n            tokens[t.takerTokenBuy][tv.takerReferrer]   = safeAdd(tokens[t.takerTokenBuy][tv.takerReferrer],   safeMul(tv.qty,    takerAffiliateFee) / (1 ether));\r\n\r\n            tokens[t.makerTokenBuy][feeAccount]     = safeAdd(tokens[t.makerTokenBuy][feeAccount],      safeMul(tv.invQty, safeSub(makerFee, makerAffiliateFee)) / (1 ether));\r\n            tokens[t.takerTokenBuy][feeAccount]     = safeAdd(tokens[t.takerTokenBuy][feeAccount],      safeAdd(safeMul(tv.qty,    safeSub(takerFee, takerAffiliateFee)) / (1 ether), safeMul(tv.qty, t.takerGasFee) / (1 ether)));\r\n\r\n            orderFills[t.makerOrderHash]            = safeAdd(orderFills[t.makerOrderHash], tv.invQty);\r\n            orderFills[t.takerOrderHash]            = safeAdd(orderFills[t.takerOrderHash], tv.qty); //safeMul(qty, tradeValues[takerAmountBuy]) / tradeValues[takerAmountSell]);\r\n\r\n            lastActiveTransaction[t.maker]          = block.number;\r\n            lastActiveTransaction[t.taker]          = block.number;\r\n\r\n            Trade(\r\n                t.takerTokenBuy, tv.qty,\r\n                t.takerTokenSell, tv.invQty,\r\n                t.maker, t.taker,\r\n                makerFee, takerFee,\r\n                tv.makerAmountTaken , tv.takerAmountTaken,\r\n                t.makerOrderHash, t.takerOrderHash\r\n            );\r\n            return tv.qty;\r\n        }\r\n    }\r\n\r\n    function batchOrderTrade(\r\n        uint8[2][] v,\r\n        bytes32[4][] rs,\r\n        uint256[7][] tradeValues,\r\n        address[6][] tradeAddresses\r\n    )\r\n    {\r\n        for (uint i = 0; i < tradeAddresses.length; i++) {\r\n            trade(\r\n                v[i],\r\n                rs[i],\r\n                tradeValues[i],\r\n                tradeAddresses[i]\r\n            );\r\n        }\r\n    }\r\n\r\n    function cancelOrder(\r\n\t\t/*\r\n\t\t[0] orderV\r\n\t\t[1] cancelV\r\n\t\t*/\r\n\t    uint8[2] v,\r\n\r\n\t\t/*\r\n\t\t[0] orderR\r\n\t\t[1] orderS\r\n\t\t[2] cancelR\r\n\t\t[3] cancelS\r\n\t\t*/\r\n\t    bytes32[4] rs,\r\n\r\n\t\t/*\r\n\t\t[0] orderAmountBuy\r\n\t\t[1] orderAmountSell\r\n\t\t[2] orderNonce\r\n\t\t[3] cancelNonce\r\n\t\t[4] cancelFee\r\n\t\t*/\r\n\t\tuint256[5] cancelValues,\r\n\r\n\t\t/*\r\n\t\t[0] orderTokenBuy\r\n\t\t[1] orderTokenSell\r\n\t\t[2] orderUser\r\n\t\t[3] cancelUser\r\n\t\t*/\r\n\t\taddress[4] cancelAddresses\r\n    ) public onlyAdmin {\r\n        // Order values should be valid and signed by order owner\r\n        bytes32 orderHash = keccak256(\r\n\t        this, cancelAddresses[0], cancelValues[0], cancelAddresses[1],\r\n\t        cancelValues[1], cancelValues[2], cancelAddresses[2]\r\n        );\r\n        require(ecrecover(keccak256(\"\\x19Ethereum Signed Message:\\n32\", orderHash), v[0], rs[0], rs[1]) == cancelAddresses[2]);\r\n\r\n        // Cancel action should be signed by cancel's initiator\r\n        bytes32 cancelHash = keccak256(this, orderHash, cancelAddresses[3], cancelValues[3]);\r\n        require(ecrecover(keccak256(\"\\x19Ethereum Signed Message:\\n32\", cancelHash), v[1], rs[2], rs[3]) == cancelAddresses[3]);\r\n\r\n        // Order owner should be same as cancel's initiator\r\n        require(cancelAddresses[2] == cancelAddresses[3]);\r\n\r\n        // Do not allow to cancel already canceled or filled orders\r\n        require(orderFills[orderHash] != cancelValues[0]);\r\n\r\n        // Limit cancel fee\r\n        if (cancelValues[4] > 6 finney) {\r\n            cancelValues[4] = 6 finney;\r\n        }\r\n\r\n        // Take cancel fee\r\n        // This operation throw an error if fee amount is more than user balance\r\n        tokens[address(0)][cancelAddresses[3]] = safeSub(tokens[address(0)][cancelAddresses[3]], cancelValues[4]);\r\n\r\n        // Cancel order by filling it with amount buy value\r\n        orderFills[orderHash] = cancelValues[0];\r\n\r\n        // Emit cancel order\r\n        CancelOrder(cancelHash, orderHash, cancelAddresses[3], cancelAddresses[1], cancelValues[1], cancelValues[4]);\r\n    }\r\n\r\n    function min(uint a, uint b) private pure returns (uint) {\r\n        return a < b ? a : b;\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n/**\r\n * @title Token\r\n * @dev Token interface necessary for working with tokens within the exchange contract.\r\n */\r\ncontract IToken {\r\n    /// @return total amount of tokens\r\n    function totalSupply() public constant returns (uint256 supply);\r\n\r\n    /// @param _owner The address from which the balance will be retrieved\r\n    /// @return The balance\r\n    function balanceOf(address _owner) public constant returns (uint256 balance);\r\n\r\n    /// @notice send `_value` token to `_to` from `msg.sender`\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transfer(address _to, uint256 _value) public returns (bool success);\r\n\r\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n    /// @param _from The address of the sender\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\r\n\r\n    /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @param _value The amount of wei to be approved for transfer\r\n    /// @return Whether the approval was successful or not\r\n    function approve(address _spender, uint256 _value) public returns (bool success);\r\n\r\n    /// @param _owner The address of the account owning tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @return Amount of remaining tokens allowed to spent\r\n    function allowance(address _owner, address _spender) public constant returns (uint256 remaining);\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n\r\n    uint public decimals;\r\n    string public name;\r\n}\r\n\r\npragma solidity ^0.4.17;\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary LSafeMath {\r\n\r\n    uint256 constant WAD = 1 ether;\r\n    \r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        if (c / a == b)\r\n            return c;\r\n        revert();\r\n    }\r\n    \r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (b > 0) { \r\n            uint256 c = a / b;\r\n            return c;\r\n        }\r\n        revert();\r\n    }\r\n    \r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (b <= a)\r\n            return a - b;\r\n        revert();\r\n    }\r\n    \r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        if (c >= a) \r\n            return c;\r\n        revert();\r\n    }\r\n\r\n    function wmul(uint a, uint b) internal pure returns (uint256) {\r\n        return add(mul(a, b), WAD / 2) / WAD;\r\n    }\r\n\r\n    function wdiv(uint a, uint b) internal pure returns (uint256) {\r\n        return add(mul(a, WAD), b / 2) / b;\r\n    }\r\n}\r\n\r\n/**\r\n * @title Coinchangex\r\n * @dev This is the main contract for the Coinchangex exchange.\r\n */\r\ncontract Tokenchange {\r\n  \r\n  using LSafeMath for uint;\r\n  \r\n  struct SpecialTokenBalanceFeeTake {\r\n      bool exist;\r\n      address token;\r\n      uint256 balance;\r\n      uint256 feeTake;\r\n  }\r\n  \r\n  uint constant private MAX_SPECIALS = 10;\r\n\r\n  /// Variables\r\n  address public admin; // the admin address\r\n  address public feeAccount; // the account that will receive fees\r\n  uint public feeTake; // percentage times (1 ether)\r\n  bool private depositingTokenFlag; // True when Token.transferFrom is being called from depositToken\r\n  mapping (address => mapping (address => uint)) public tokens; // mapping of token addresses to mapping of account balances (token=0 means Ether)\r\n  mapping (address => mapping (bytes32 => uint)) public orderFills; // mapping of user accounts to mapping of order hashes to uints (amount of order that has been filled)\r\n  SpecialTokenBalanceFeeTake[] public specialFees;\r\n  \r\n\r\n  /// Logging Events\r\n  event Cancel(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s);\r\n  event Trade(address tokenGet, uint amountGet, address tokenGive, uint amountGive, address get, address give);\r\n  event Deposit(address token, address user, uint amount, uint balance);\r\n  event Withdraw(address token, address user, uint amount, uint balance);\r\n\r\n  /// This is a modifier for functions to check if the sending user address is the same as the admin user address.\r\n  modifier isAdmin() {\r\n      require(msg.sender == admin);\r\n      _;\r\n  }\r\n\r\n  /// Constructor function. This is only called on contract creation.\r\n  function Coinchangex(address admin_, address feeAccount_, uint feeTake_) public {\r\n    admin = admin_;\r\n    feeAccount = feeAccount_;\r\n    feeTake = feeTake_;\r\n    depositingTokenFlag = false;\r\n  }\r\n\r\n  /// The fallback function. Ether transfered into the contract is not accepted.\r\n  function() public {\r\n    revert();\r\n  }\r\n\r\n  /// Changes the official admin user address. Accepts Ethereum address.\r\n  function changeAdmin(address admin_) public isAdmin {\r\n    require(admin_ != address(0));\r\n    admin = admin_;\r\n  }\r\n\r\n  /// Changes the account address that receives trading fees. Accepts Ethereum address.\r\n  function changeFeeAccount(address feeAccount_) public isAdmin {\r\n    feeAccount = feeAccount_;\r\n  }\r\n\r\n  /// Changes the fee on takes. Can only be changed to a value less than it is currently set at.\r\n  function changeFeeTake(uint feeTake_) public isAdmin {\r\n    // require(feeTake_ <= feeTake);\r\n    feeTake = feeTake_;\r\n  }\r\n  \r\n  // add special promotion fee\r\n  function addSpecialFeeTake(address token, uint256 balance, uint256 feeTake) public isAdmin {\r\n      uint id = specialFees.push(SpecialTokenBalanceFeeTake(\r\n          true,\r\n          token,\r\n          balance,\r\n          feeTake\r\n      ));\r\n  }\r\n  \r\n  // chnage special promotion fee\r\n  function chnageSpecialFeeTake(uint id, address token, uint256 balance, uint256 feeTake) public isAdmin {\r\n      require(id < specialFees.length);\r\n      specialFees[id] = SpecialTokenBalanceFeeTake(\r\n          true,\r\n          token,\r\n          balance,\r\n          feeTake\r\n      );\r\n  }\r\n  \r\n    // remove special promotion fee\r\n   function removeSpecialFeeTake(uint id) public isAdmin {\r\n       if (id >= specialFees.length) revert();\r\n\r\n        uint last = specialFees.length-1;\r\n        for (uint i = id; i<last; i++){\r\n            specialFees[i] = specialFees[i+1];\r\n        }\r\n        \r\n        delete specialFees[last];\r\n        specialFees.length--;\r\n  } \r\n  \r\n  //return total count promotion fees\r\n  function TotalSpecialFeeTakes() public constant returns(uint)  {\r\n      return specialFees.length;\r\n  }\r\n  \r\n  \r\n  ////////////////////////////////////////////////////////////////////////////////\r\n  // Deposits, Withdrawals, Balances\r\n  ////////////////////////////////////////////////////////////////////////////////\r\n\r\n  /**\r\n  * This function handles deposits of Ether into the contract.\r\n  * Emits a Deposit event.\r\n  * Note: With the payable modifier, this function accepts Ether.\r\n  */\r\n  function deposit() public payable {\r\n    tokens[0][msg.sender] = tokens[0][msg.sender].add(msg.value);\r\n    Deposit(0, msg.sender, msg.value, tokens[0][msg.sender]);\r\n  }\r\n\r\n  /**\r\n  * This function handles withdrawals of Ether from the contract.\r\n  * Verifies that the user has enough funds to cover the withdrawal.\r\n  * Emits a Withdraw event.\r\n  * @param amount uint of the amount of Ether the user wishes to withdraw\r\n  */\r\n  function withdraw(uint amount) public {\r\n    require(tokens[0][msg.sender] >= amount);\r\n    tokens[0][msg.sender] = tokens[0][msg.sender].sub(amount);\r\n    msg.sender.transfer(amount);\r\n    Withdraw(0, msg.sender, amount, tokens[0][msg.sender]);\r\n  }\r\n\r\n  /**\r\n  * This function handles deposits of Ethereum based tokens to the contract.\r\n  * Does not allow Ether.\r\n  * If token transfer fails, transaction is reverted and remaining gas is refunded.\r\n  * Emits a Deposit event.\r\n  * Note: Remember to call Token(address).approve(this, amount) or this contract will not be able to do the transfer on your behalf.\r\n  * @param token Ethereum contract address of the token or 0 for Ether\r\n  * @param amount uint of the amount of the token the user wishes to deposit\r\n  */\r\n  function depositToken(address token, uint amount) public {\r\n    require(token != 0);\r\n    depositingTokenFlag = true;\r\n    require(IToken(token).transferFrom(msg.sender, this, amount));\r\n    depositingTokenFlag = false;\r\n    tokens[token][msg.sender] = tokens[token][msg.sender].add(amount);\r\n    Deposit(token, msg.sender, amount, tokens[token][msg.sender]);\r\n }\r\n\r\n  /**\r\n  * This function provides a fallback solution as outlined in ERC223.\r\n  * If tokens are deposited through depositToken(), the transaction will continue.\r\n  * If tokens are sent directly to this contract, the transaction is reverted.\r\n  * @param sender Ethereum address of the sender of the token\r\n  * @param amount amount of the incoming tokens\r\n  * @param data attached data similar to msg.data of Ether transactions\r\n  */\r\n  function tokenFallback( address sender, uint amount, bytes data) public returns (bool ok) {\r\n      if (depositingTokenFlag) {\r\n        // Transfer was initiated from depositToken(). User token balance will be updated there.\r\n        return true;\r\n      } else {\r\n        // Direct ECR223 Token.transfer into this contract not allowed, to keep it consistent\r\n        // with direct transfers of ECR20 and ETH.\r\n        revert();\r\n      }\r\n  }\r\n  \r\n  /**\r\n  * This function handles withdrawals of Ethereum based tokens from the contract.\r\n  * Does not allow Ether.\r\n  * If token transfer fails, transaction is reverted and remaining gas is refunded.\r\n  * Emits a Withdraw event.\r\n  * @param token Ethereum contract address of the token or 0 for Ether\r\n  * @param amount uint of the amount of the token the user wishes to withdraw\r\n  */\r\n  function withdrawToken(address token, uint amount) public {\r\n    require(token != 0);\r\n    require(tokens[token][msg.sender] >= amount);\r\n    tokens[token][msg.sender] = tokens[token][msg.sender].sub(amount);\r\n    require(IToken(token).transfer(msg.sender, amount));\r\n    Withdraw(token, msg.sender, amount, tokens[token][msg.sender]);\r\n  }\r\n\r\n  /**\r\n  * Retrieves the balance of a token based on a user address and token address.\r\n  * @param token Ethereum contract address of the token or 0 for Ether\r\n  * @param user Ethereum address of the user\r\n  * @return the amount of tokens on the exchange for a given user address\r\n  */\r\n  function balanceOf(address token, address user) public constant returns (uint) {\r\n    return tokens[token][user];\r\n  }\r\n\r\n  ////////////////////////////////////////////////////////////////////////////////\r\n  // Trading\r\n  ////////////////////////////////////////////////////////////////////////////////\r\n\r\n  /**\r\n  * Facilitates a trade from one user to another.\r\n  * Requires that the transaction is signed properly, the trade isn't past its expiration, and all funds are present to fill the trade.\r\n  * Calls tradeBalances().\r\n  * Updates orderFills with the amount traded.\r\n  * Emits a Trade event.\r\n  * Note: tokenGet & tokenGive can be the Ethereum contract address.\r\n  * Note: amount is in amountGet / tokenGet terms.\r\n  * @param tokenGet Ethereum contract address of the token to receive\r\n  * @param amountGet uint amount of tokens being received\r\n  * @param tokenGive Ethereum contract address of the token to give\r\n  * @param amountGive uint amount of tokens being given\r\n  * @param expires uint of block number when this order should expire\r\n  * @param nonce arbitrary random number\r\n  * @param user Ethereum address of the user who placed the order\r\n  * @param v part of signature for the order hash as signed by user\r\n  * @param r part of signature for the order hash as signed by user\r\n  * @param s part of signature for the order hash as signed by user\r\n  * @param amount uint amount in terms of tokenGet that will be \"buy\" in the trade\r\n  */\r\n  function trade(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s, uint amount) public {\r\n    bytes32 hash = sha256(this, tokenGet, amountGet, tokenGive, amountGive, expires, nonce);\r\n    require((\r\n      (ecrecover(keccak256(\"\\x19Ethereum Signed Message:\\n32\", hash), v, r, s) == user) &&\r\n      block.number <= expires &&\r\n      orderFills[user][hash].add(amount) <= amountGet\r\n    ));\r\n    tradeBalances(tokenGet, amountGet, tokenGive, amountGive, user, amount);\r\n    orderFills[user][hash] = orderFills[user][hash].add(amount);\r\n    Trade(tokenGet, amount, tokenGive, amountGive.mul(amount) / amountGet, user, msg.sender);\r\n  }\r\n\r\n  /**\r\n  * This is a private function and is only being called from trade().\r\n  * Handles the movement of funds when a trade occurs.\r\n  * Takes fees.\r\n  * Updates token balances for both buyer and seller.\r\n  * Note: tokenGet & tokenGive can be the Ethereum contract address.\r\n  * Note: amount is in amountGet / tokenGet terms.\r\n  * @param tokenGet Ethereum contract address of the token to receive\r\n  * @param amountGet uint amount of tokens being received\r\n  * @param tokenGive Ethereum contract address of the token to give\r\n  * @param amountGive uint amount of tokens being given\r\n  * @param user Ethereum address of the user who placed the order\r\n  * @param amount uint amount in terms of tokenGet that will be \"buy\" in the trade\r\n  */\r\n  function tradeBalances(address tokenGet, uint amountGet, address tokenGive, uint amountGive, address user, uint amount) private {\r\n    \r\n    uint256 feeTakeXfer = calculateFee(amount);\r\n    \r\n    tokens[tokenGet][msg.sender] = tokens[tokenGet][msg.sender].sub(amount.add(feeTakeXfer));\r\n    tokens[tokenGet][user] = tokens[tokenGet][user].add(amount);\r\n    tokens[tokenGet][feeAccount] = tokens[tokenGet][feeAccount].add(feeTakeXfer);\r\n    tokens[tokenGive][user] = tokens[tokenGive][user].sub(amountGive.mul(amount).div(amountGet));\r\n    tokens[tokenGive][msg.sender] = tokens[tokenGive][msg.sender].add(amountGive.mul(amount).div(amountGet));\r\n  }\r\n  \r\n  //calculate fee including special promotions\r\n  function calculateFee(uint amount) private constant returns(uint256)  {\r\n    uint256 feeTakeXfer = 0;\r\n    \r\n    uint length = specialFees.length;\r\n    bool applied = false;\r\n    for(uint i = 0; length > 0 && i < length; i++) {\r\n        SpecialTokenBalanceFeeTake memory special = specialFees[i];\r\n        if(special.exist && special.balance <= tokens[special.token][msg.sender]) {\r\n            applied = true;\r\n            feeTakeXfer = amount.mul(special.feeTake).div(1 ether);\r\n            break;\r\n        }\r\n        if(i >= MAX_SPECIALS)\r\n            break;\r\n    }\r\n    \r\n    if(!applied)\r\n        feeTakeXfer = amount.mul(feeTake).div(1 ether);\r\n    \r\n    \r\n    return feeTakeXfer;\r\n  }\r\n\r\n  /**\r\n  * This function is to test if a trade would go through.\r\n  * Note: tokenGet & tokenGive can be the Ethereum contract address.\r\n  * Note: amount is in amountGet / tokenGet terms.\r\n  * @param tokenGet Ethereum contract address of the token to receive\r\n  * @param amountGet uint amount of tokens being received\r\n  * @param tokenGive Ethereum contract address of the token to give\r\n  * @param amountGive uint amount of tokens being given\r\n  * @param expires uint of block number when this order should expire\r\n  * @param nonce arbitrary random number\r\n  * @param user Ethereum address of the user who placed the order\r\n  * @param v part of signature for the order hash as signed by user\r\n  * @param r part of signature for the order hash as signed by user\r\n  * @param s part of signature for the order hash as signed by user\r\n  * @param amount uint amount in terms of tokenGet that will be \"buy\" in the trade\r\n  * @param sender Ethereum address of the user taking the order\r\n  * @return bool: true if the trade would be successful, false otherwise\r\n  */\r\n  function testTrade(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s, uint amount, address sender) public constant returns(bool) {\r\n    if (!(\r\n      tokens[tokenGet][sender] >= amount &&\r\n      availableVolume(tokenGet, amountGet, tokenGive, amountGive, expires, nonce, user, v, r, s) >= amount\r\n      )) { \r\n      return false;\r\n    } else {\r\n      return true;\r\n    }\r\n  }\r\n\r\n  /**\r\n  * This function checks the available volume for a given order.\r\n  * Note: tokenGet & tokenGive can be the Ethereum contract address.\r\n  * @param tokenGet Ethereum contract address of the token to receive\r\n  * @param amountGet uint amount of tokens being received\r\n  * @param tokenGive Ethereum contract address of the token to give\r\n  * @param amountGive uint amount of tokens being given\r\n  * @param expires uint of block number when this order should expire\r\n  * @param nonce arbitrary random number\r\n  * @param user Ethereum address of the user who placed the order\r\n  * @param v part of signature for the order hash as signed by user\r\n  * @param r part of signature for the order hash as signed by user\r\n  * @param s part of signature for the order hash as signed by user\r\n  * @return uint: amount of volume available for the given order in terms of amountGet / tokenGet\r\n  */\r\n  function availableVolume(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s) public constant returns(uint) {\r\n    bytes32 hash = sha256(this, tokenGet, amountGet, tokenGive, amountGive, expires, nonce);\r\n    if (!(\r\n      (ecrecover(keccak256(\"\\x19Ethereum Signed Message:\\n32\", hash), v, r, s) == user) &&\r\n      block.number <= expires\r\n      )) {\r\n      return 0;\r\n    }\r\n    uint[2] memory available;\r\n    available[0] = amountGet.sub(orderFills[user][hash]);\r\n    available[1] = tokens[tokenGive][user].mul(amountGet) / amountGive;\r\n    if (available[0] < available[1]) {\r\n      return available[0];\r\n    } else {\r\n      return available[1];\r\n    }\r\n  }\r\n\r\n  /**\r\n  * This function checks the amount of an order that has already been filled.\r\n  * Note: tokenGet & tokenGive can be the Ethereum contract address.\r\n  * @param tokenGet Ethereum contract address of the token to receive\r\n  * @param amountGet uint amount of tokens being received\r\n  * @param tokenGive Ethereum contract address of the token to give\r\n  * @param amountGive uint amount of tokens being given\r\n  * @param expires uint of block number when this order should expire\r\n  * @param nonce arbitrary random number\r\n  * @param user Ethereum address of the user who placed the order\r\n  * @param v part of signature for the order hash as signed by user\r\n  * @param r part of signature for the order hash as signed by user\r\n  * @param s part of signature for the order hash as signed by user\r\n  * @return uint: amount of the given order that has already been filled in terms of amountGet / tokenGet\r\n  */\r\n  function amountFilled(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s) public constant returns(uint) {\r\n    bytes32 hash = sha256(this, tokenGet, amountGet, tokenGive, amountGive, expires, nonce);\r\n    return orderFills[user][hash];\r\n  }\r\n\r\n  /**\r\n  * This function cancels a given order by editing its fill data to the full amount.\r\n  * Requires that the transaction is signed properly.\r\n  * Updates orderFills to the full amountGet\r\n  * Emits a Cancel event.\r\n  * Note: tokenGet & tokenGive can be the Ethereum contract address.\r\n  * @param tokenGet Ethereum contract address of the token to receive\r\n  * @param amountGet uint amount of tokens being received\r\n  * @param tokenGive Ethereum contract address of the token to give\r\n  * @param amountGive uint amount of tokens being given\r\n  * @param expires uint of block number when this order should expire\r\n  * @param nonce arbitrary random number\r\n  * @param v part of signature for the order hash as signed by user\r\n  * @param r part of signature for the order hash as signed by user\r\n  * @param s part of signature for the order hash as signed by user\r\n  * @return uint: amount of the given order that has already been filled in terms of amountGet / tokenGet\r\n  */\r\n  function cancelOrder(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, uint8 v, bytes32 r, bytes32 s) public {\r\n    bytes32 hash = sha256(this, tokenGet, amountGet, tokenGive, amountGive, expires, nonce);\r\n    require ((ecrecover(keccak256(\"\\x19Ethereum Signed Message:\\n32\", hash), v, r, s) == msg.sender));\r\n    orderFills[msg.sender][hash] = amountGet;\r\n    Cancel(tokenGet, amountGet, tokenGive, amountGive, expires, nonce, msg.sender, v, r, s);\r\n  }\r\n\r\n  \r\n  /**\r\n  * This function handles deposits of Ether into the contract, but allows specification of a user.\r\n  * Note: This is generally used in migration of funds.\r\n  * Note: With the payable modifier, this function accepts Ether.\r\n  */\r\n  function depositForUser(address user) public payable {\r\n    require(user != address(0));\r\n    require(msg.value > 0);\r\n    tokens[0][user] = tokens[0][user].add(msg.value);\r\n  }\r\n  \r\n  /**\r\n  * This function handles deposits of Ethereum based tokens into the contract, but allows specification of a user.\r\n  * Does not allow Ether.\r\n  * If token transfer fails, transaction is reverted and remaining gas is refunded.\r\n  * Note: This is generally used in migration of funds.\r\n  * Note: Remember to call Token(address).approve(this, amount) or this contract will not be able to do the transfer on your behalf.\r\n  * @param token Ethereum contract address of the token\r\n  * @param amount uint of the amount of the token the user wishes to deposit\r\n  */\r\n  function depositTokenForUser(address token, uint amount, address user) public {\r\n    require(token != address(0));\r\n    require(user != address(0));\r\n    require(amount > 0);\r\n    depositingTokenFlag = true;\r\n    require(IToken(token).transferFrom(msg.sender, this, amount));\r\n    depositingTokenFlag = false;\r\n    tokens[token][user] = tokens[token][user].add(amount);\r\n  }\r\n  \r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_startTime\",\"type\":\"uint256\"}],\"name\":\"setStartTime\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"weiRaised\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"hasStarted\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finalize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"wallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"soldTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isFinalized\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rateProvider\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"addExcluded\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_rateProviderAddress\",\"type\":\"address\"}],\"name\":\"setRateProvider\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_endTime\",\"type\":\"uint256\"}],\"name\":\"setEndTime\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_hardCapTokens\",\"type\":\"uint256\"}],\"name\":\"setHardCap\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"hasEnded\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_startTime\",\"type\":\"uint256\"},{\"name\":\"_endTime\",\"type\":\"uint256\"},{\"name\":\"_hardCapTokens\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Finalized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"purchaser\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TokenPurchase\",\"type\":\"event\"}]","ContractName":"EthereumV2Erc20Crowdsale","CompilerVersion":"v0.4.18+commit.9cf6e910","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000000000000000000000000000000000005ccf17c1000000000000000000000000000000000000000000000000000000006f9f0f41000000000000000000000000000000000000000000000000000001d1a94a2000","Library":"","SwarmSource":"bzzr://88404773e823d9702e63005ac96c92b49d5fc7c522b548b2fe8fe025ea5cb567"}]}