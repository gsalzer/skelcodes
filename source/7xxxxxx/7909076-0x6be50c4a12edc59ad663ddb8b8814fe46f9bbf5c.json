{"status":"1","message":"OK","result":[{"SourceCode":"contract MintAndBurnAdmin {\r\n\r\n    // TYPES\r\n\r\n    struct Proposal {\r\n        address addr;\r\n        uint256 value;\r\n        bool isMint;\r\n        uint256 time;\r\n        bool closed;\r\n    }\r\n\r\n    // DATA\r\n\r\n    ReserveDollar public reserve;\r\n    uint256 public constant delay = 12 hours;\r\n    address public admin;\r\n\r\n    Proposal[] public proposals;\r\n\r\n    // EVENTS\r\n\r\n    event ProposalCreated(uint256 index, address indexed addr, uint256 value, bool isMint, uint256 delayUntil);\r\n    event ProposalConfirmed(uint256 index, address indexed addr, uint256 value, bool isMint);\r\n    event ProposalCancelled(uint256 index, address indexed addr, uint256 value, bool isMint);\r\n    event AllProposalsCancelled();\r\n\r\n    // FUNCTIONALITY\r\n\r\n    constructor(address reserveDollar) public {\r\n        reserve = ReserveDollar(reserveDollar);\r\n        admin = msg.sender;\r\n    }\r\n\r\n    modifier onlyAdmin() {\r\n        require(msg.sender == admin, \"must be admin\");\r\n        _;\r\n    }\r\n\r\n    /// Propose a new mint or burn, which can be confirmed after 12 hours.\r\n    function propose(address addr, uint256 value, bool isMint) external onlyAdmin {\r\n        // Delay by at least 12 hours.\r\n        // We are relying on block.timestamp for this, and aware of the possibility of its\r\n        // manipulation by miners. But given the in-protocol bounds on the change in\r\n        // block.timestamp and the way we are using it, we are satisfied with this choice.\r\n        // solium-disable-next-line security/no-block-members\r\n        uint256 delayUntil = now + delay;\r\n\r\n        proposals.push(Proposal({\r\n            addr: addr,\r\n            value: value,\r\n            isMint: isMint,\r\n            time: delayUntil,\r\n            closed: false\r\n        }));\r\n\r\n        emit ProposalCreated(proposals.length - 1, addr, value, isMint, delayUntil);\r\n    }\r\n\r\n    /// Cancel a proposed mint or burn.\r\n    function cancel(uint256 index, address addr, uint256 value, bool isMint) external onlyAdmin {\r\n        // Check authorization.\r\n        requireMatchingOpenProposal(index, addr, value, isMint);\r\n\r\n        // Cancel proposal.\r\n        proposals[index].closed = true;\r\n        emit ProposalCancelled(index, addr, value, isMint);\r\n    }\r\n\r\n    /// Cancel all proposals.\r\n    function cancelAll() external onlyAdmin {\r\n        proposals.length = 0;\r\n        emit AllProposalsCancelled();\r\n    }\r\n\r\n    /// Confirm and execute a proposed mint or burn, if enough time has passed since the proposal.\r\n    function confirm(uint256 index, address addr, uint256 value, bool isMint) external onlyAdmin {\r\n        // Check authorization.\r\n        requireMatchingOpenProposal(index, addr, value, isMint);\r\n\r\n        // See commentary above about using `now`.\r\n        // solium-disable-next-line security/no-block-members\r\n        require(proposals[index].time < now, \"too early\");\r\n\r\n        // Record execution of proposal.\r\n        proposals[index].closed = true;\r\n        emit ProposalConfirmed(index, addr, value, isMint);\r\n\r\n        // Proceed with execution of proposal.\r\n        if (proposals[index].isMint) {\r\n            reserve.mint(addr, value);\r\n        } else {\r\n            reserve.burnFrom(addr, value);\r\n        }\r\n    }\r\n\r\n    /// Throw unless the given proposal exists and matches `addr`, `value`, and `isMint`.\r\n    function requireMatchingOpenProposal(uint256 index, address addr, uint256 value, bool isMint) private view {\r\n        require(!proposals[index].closed, \"proposal already closed\");\r\n\r\n        // Slither reports \"dangerous strict equality\" for each of these, but it's OK.\r\n        // These equalities are to confirm that the proposal entered is equal to the\r\n        // matching previous proposal. We're vetting data entry; strict equality is appropriate.\r\n        require(proposals[index].addr == addr, \"addr mismatched\");\r\n        require(proposals[index].value == value, \"value mismatched\");\r\n        require(proposals[index].isMint == isMint, \"isMint mismatched\");\r\n    }\r\n}\r\n\r\ninterface IERC20 {\r\n    function transfer(address, uint256) external returns (bool);\r\n    function approve(address, uint256) external returns (bool);\r\n    function transferFrom(address, address, uint256) external returns (bool);\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address) external view returns (uint256);\r\n    function allowance(address, address) external view returns (uint256);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed holder, address indexed spender, uint256 value);\r\n}\r\n\r\ncontract ReserveDollar is IERC20 {\r\n    using SafeMath for uint256;\r\n\r\n\r\n    // DATA\r\n\r\n\r\n    // Non-constant-sized data\r\n    ReserveDollarEternalStorage internal data;\r\n\r\n    // Basic token data\r\n    string public name = \"Reserve Dollar\";\r\n    string public symbol = \"RSVD\";\r\n    uint8 public constant decimals = 18;\r\n    uint256 public totalSupply;\r\n\r\n    // Paused data\r\n    bool public paused;\r\n\r\n    // Auth roles\r\n    address public owner;\r\n    address public minter;\r\n    address public pauser;\r\n    address public freezer;\r\n    address public nominatedOwner;\r\n\r\n\r\n    // EVENTS\r\n\r\n\r\n    // Auth role change events\r\n    event OwnerChanged(address indexed newOwner);\r\n    event MinterChanged(address indexed newMinter);\r\n    event PauserChanged(address indexed newPauser);\r\n    event FreezerChanged(address indexed newFreezer);\r\n\r\n    // Pause events\r\n    event Paused(address indexed account);\r\n    event Unpaused(address indexed account);\r\n\r\n    // Name change event\r\n    event NameChanged(string newName, string newSymbol);\r\n\r\n    // Law enforcement events\r\n    event Frozen(address indexed freezer, address indexed account);\r\n    event Unfrozen(address indexed freezer, address indexed account);\r\n    event Wiped(address indexed freezer, address indexed wiped);\r\n\r\n\r\n    // FUNCTIONALITY\r\n\r\n\r\n    /// Initialize critical fields.\r\n    constructor() public {\r\n        data = new ReserveDollarEternalStorage(msg.sender);\r\n        owner = msg.sender;\r\n        pauser = msg.sender;\r\n        // Other roles deliberately default to the zero address.\r\n    }\r\n\r\n    /// Accessor for eternal storage contract address.\r\n    function getEternalStorageAddress() external view returns(address) {\r\n        return address(data);\r\n    }\r\n\r\n\r\n    // ==== Admin functions ====\r\n\r\n\r\n    /// Modifies a function to only run if sent by `role`.\r\n    modifier only(address role) {\r\n        require(msg.sender == role, \"unauthorized: not role holder\");\r\n        _;\r\n    }\r\n\r\n    /// Modifies a function to only run if sent by `role` or the contract's `owner`.\r\n    modifier onlyOwnerOr(address role) {\r\n        require(msg.sender == owner || msg.sender == role, \"unauthorized: not role holder and not owner\");\r\n        _;\r\n    }\r\n\r\n    /// Change who holds the `minter` role.\r\n    function changeMinter(address newMinter) external onlyOwnerOr(minter) {\r\n        minter = newMinter;\r\n        emit MinterChanged(newMinter);\r\n    }\r\n\r\n    /// Change who holds the `pauser` role.\r\n    function changePauser(address newPauser) external onlyOwnerOr(pauser) {\r\n        pauser = newPauser;\r\n        emit PauserChanged(newPauser);\r\n    }\r\n\r\n    /// Change who holds the `freezer` role.\r\n    function changeFreezer(address newFreezer) external onlyOwnerOr(freezer) {\r\n        freezer = newFreezer;\r\n        emit FreezerChanged(newFreezer);\r\n    }\r\n\r\n    /// Nominate a new `owner`.  We want to ensure that `owner` is always valid, so we don't\r\n    /// actually change `owner` to `nominatedOwner` until `nominatedOwner` calls `acceptOwnership`.\r\n    function nominateNewOwner(address nominee) external only(owner) {\r\n        nominatedOwner = nominee;\r\n    }\r\n\r\n    /// Accept nomination for ownership.\r\n    /// This completes the `nominateNewOwner` handshake.\r\n    function acceptOwnership() external onlyOwnerOr(nominatedOwner) {\r\n        if (msg.sender != owner) {\r\n            emit OwnerChanged(msg.sender);\r\n        }\r\n        owner = msg.sender;\r\n        nominatedOwner = address(0);\r\n    }\r\n\r\n    /// Set `owner` to 0.\r\n    /// Only do this to deliberately lock in the current permissions.\r\n    function renounceOwnership() external only(owner) {\r\n        owner = address(0);\r\n        emit OwnerChanged(owner);\r\n    }\r\n\r\n    /// Make a different address own the EternalStorage contract.\r\n    /// This will break this contract, so only do it if you're\r\n    /// abandoning this contract, e.g., for an upgrade.\r\n    function transferEternalStorage(address newOwner) external only(owner) {\r\n        data.transferOwnership(newOwner);\r\n    }\r\n\r\n    /// Change the name and ticker symbol of this token.\r\n    function changeName(string calldata newName, string calldata newSymbol) external only(owner) {\r\n        name = newName;\r\n        symbol = newSymbol;\r\n        emit NameChanged(newName, newSymbol);\r\n    }\r\n\r\n    /// Pause the contract.\r\n    function pause() external only(pauser) {\r\n        paused = true;\r\n        emit Paused(pauser);\r\n    }\r\n\r\n    /// Unpause the contract.\r\n    function unpause() external only(pauser) {\r\n        paused = false;\r\n        emit Unpaused(pauser);\r\n    }\r\n\r\n    /// Modifies a function to run only when the contract is not paused.\r\n    modifier notPaused() {\r\n        require(!paused, \"contract is paused\");\r\n        _;\r\n    }\r\n\r\n    /// Freeze token transactions for a particular address.\r\n    function freeze(address account) external only(freezer) {\r\n        require(data.frozenTime(account) == 0, \"account already frozen\");\r\n\r\n        // In `wipe` we use block.timestamp (aka `now`) to check that enough time has passed since\r\n        // this freeze happened. That required time delay -- 4 weeks -- is a long time relative to\r\n        // the maximum drift of block.timestamp, so it is fine to trust the miner here.\r\n        // solium-disable-next-line security/no-block-members\r\n        data.setFrozenTime(account, now);\r\n\r\n        emit Frozen(freezer, account);\r\n    }\r\n\r\n    /// Unfreeze token transactions for a particular address.\r\n    function unfreeze(address account) external only(freezer) {\r\n        require(data.frozenTime(account) > 0, \"account not frozen\");\r\n        data.setFrozenTime(account, 0);\r\n        emit Unfrozen(freezer, account);\r\n    }\r\n\r\n    /// Modifies a function to run only when the `account` is not frozen.\r\n    modifier notFrozen(address account) {\r\n        require(data.frozenTime(account) == 0, \"account frozen\");\r\n        _;\r\n    }\r\n\r\n    /// Burn the balance of an account that has been frozen for at least 4 weeks.\r\n    function wipe(address account) external only(freezer) {\r\n        require(data.frozenTime(account) > 0, \"cannot wipe unfrozen account\");\r\n        // See commentary above about using block.timestamp.\r\n        // solium-disable-next-line security/no-block-members\r\n        require(data.frozenTime(account) + 4 weeks < now, \"cannot wipe frozen account before 4 weeks\");\r\n        _burn(account, data.balance(account));\r\n        emit Wiped(freezer, account);\r\n    }\r\n\r\n\r\n    // ==== Token transfers, allowances, minting, and burning ====\r\n\r\n\r\n    /// @return how many attotokens are held by `holder`.\r\n    function balanceOf(address holder) external view returns (uint256) {\r\n        return data.balance(holder);\r\n    }\r\n\r\n    /// @return how many attotokens `holder` has allowed `spender` to control.\r\n    function allowance(address holder, address spender) external view returns (uint256) {\r\n        return data.allowed(holder, spender);\r\n    }\r\n\r\n    /// Transfer `value` attotokens from `msg.sender` to `to`.\r\n    function transfer(address to, uint256 value)\r\n        external\r\n        notPaused\r\n        notFrozen(msg.sender)\r\n        notFrozen(to)\r\n        returns (bool)\r\n    {\r\n        _transfer(msg.sender, to, value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Approve `spender` to spend `value` attotokens on behalf of `msg.sender`.\r\n     *\r\n     * Beware that changing a nonzero allowance with this method brings the risk that\r\n     * someone may use both the old and the new allowance by unfortunate transaction ordering. One\r\n     * way to mitigate this risk is to first reduce the spender's allowance\r\n     * to 0, and then set the desired value afterwards, per\r\n     * [this ERC-20 issue](https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729).\r\n     *\r\n     * A simpler workaround is to use `increaseAllowance` or `decreaseAllowance`, below.\r\n     *\r\n     * @param spender address The address which will spend the funds.\r\n     * @param value uint256 How many attotokens to allow `spender` to spend.\r\n     */\r\n    function approve(address spender, uint256 value)\r\n        external\r\n        notPaused\r\n        notFrozen(msg.sender)\r\n        notFrozen(spender)\r\n        returns (bool)\r\n    {\r\n        _approve(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n\r\n    /// Transfer approved tokens from one address to another.\r\n    /// @param from address The address to send tokens from.\r\n    /// @param to address The address to send tokens to.\r\n    /// @param value uint256 The number of attotokens to send.\r\n    function transferFrom(address from, address to, uint256 value)\r\n        external\r\n        notPaused\r\n        notFrozen(msg.sender)\r\n        notFrozen(from)\r\n        notFrozen(to)\r\n        returns (bool)\r\n    {\r\n        _transfer(from, to, value);\r\n        _approve(from, msg.sender, data.allowed(from, msg.sender).sub(value));\r\n        return true;\r\n    }\r\n\r\n    /// Increase `spender`'s allowance of the sender's tokens.\r\n    /// @dev From MonolithDAO Token.sol\r\n    /// @param spender The address which will spend the funds.\r\n    /// @param addedValue How many attotokens to increase the allowance by.\r\n    function increaseAllowance(address spender, uint256 addedValue)\r\n        external\r\n        notPaused\r\n        notFrozen(msg.sender)\r\n        notFrozen(spender)\r\n        returns (bool)\r\n    {\r\n        _approve(msg.sender, spender, data.allowed(msg.sender, spender).add(addedValue));\r\n        return true;\r\n    }\r\n\r\n    /// Decrease `spender`'s allowance of the sender's tokens.\r\n    /// @dev From MonolithDAO Token.sol\r\n    /// @param spender The address which will spend the funds.\r\n    /// @param subtractedValue How many attotokens to decrease the allowance by.\r\n    function decreaseAllowance(address spender, uint256 subtractedValue)\r\n        external\r\n        notPaused\r\n        notFrozen(msg.sender)\r\n        // This is the one case in which changing the allowance of a frozen spender is allowed.\r\n        // notFrozen(spender)\r\n        returns (bool)\r\n    {\r\n        _approve(msg.sender, spender, data.allowed(msg.sender, spender).sub(subtractedValue));\r\n        return true;\r\n    }\r\n\r\n    /// Mint `value` new attotokens to `account`.\r\n    function mint(address account, uint256 value)\r\n        external\r\n        notPaused\r\n        notFrozen(account)\r\n        only(minter)\r\n    {\r\n        require(account != address(0), \"can't mint to address zero\");\r\n\r\n        totalSupply = totalSupply.add(value);\r\n        data.addBalance(account, value);\r\n        emit Transfer(address(0), account, value);\r\n    }\r\n\r\n    /// Burn `value` attotokens from `account`, if sender has that much allowance from `account`.\r\n    function burnFrom(address account, uint256 value)\r\n        external\r\n        notPaused\r\n        notFrozen(account)\r\n        only(minter)\r\n    {\r\n        _burn(account, value);\r\n        _approve(account, msg.sender, data.allowed(account, msg.sender).sub(value));\r\n    }\r\n\r\n    /// @dev Transfer of `value` attotokens from `from` to `to`.\r\n    /// Internal; doesn't check permissions.\r\n    function _transfer(address from, address to, uint256 value) internal {\r\n        require(to != address(0), \"can't transfer to address zero\");\r\n\r\n        data.subBalance(from, value);\r\n        data.addBalance(to, value);\r\n        emit Transfer(from, to, value);\r\n    }\r\n\r\n    /// @dev Burn `value` attotokens from `account`.\r\n    /// Internal; doesn't check permissions.\r\n    function _burn(address account, uint256 value) internal {\r\n        require(account != address(0), \"can't burn from address zero\");\r\n\r\n        totalSupply = totalSupply.sub(value);\r\n        data.subBalance(account, value);\r\n        emit Transfer(account, address(0), value);\r\n    }\r\n\r\n    /// @dev Set `spender`'s allowance on `holder`'s tokens to `value` attotokens.\r\n    /// Internal; doesn't check permissions.\r\n    function _approve(address holder, address spender, uint256 value) internal {\r\n        require(spender != address(0), \"spender cannot be address zero\");\r\n        require(holder != address(0), \"holder cannot be address zero\");\r\n\r\n        data.setAllowed(holder, spender, value);\r\n        emit Approval(holder, spender, value);\r\n    }\r\n}\r\n\r\ncontract ReserveDollarEternalStorage {\r\n\r\n    using SafeMath for uint256;\r\n\r\n\r\n\r\n    // ===== auth =====\r\n\r\n    address public owner;\r\n    address public escapeHatch;\r\n\r\n    event OwnershipTransferred(address indexed oldOwner, address indexed newOwner);\r\n    event EscapeHatchTransferred(address indexed oldEscapeHatch, address indexed newEscapeHatch);\r\n\r\n    /// On construction, set auth fields.\r\n    constructor(address escapeHatchAddress) public {\r\n        owner = msg.sender;\r\n        escapeHatch = escapeHatchAddress;\r\n    }\r\n\r\n    /// Only run modified function if sent by `owner`.\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"onlyOwner\");\r\n        _;\r\n    }\r\n\r\n    /// Set `owner`.\r\n    function transferOwnership(address newOwner) external {\r\n        require(msg.sender == owner || msg.sender == escapeHatch, \"not authorized\");\r\n        emit OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n\r\n    /// Set `escape hatch`.\r\n    function transferEscapeHatch(address newEscapeHatch) external {\r\n        require(msg.sender == escapeHatch, \"not authorized\");\r\n        emit EscapeHatchTransferred(escapeHatch, newEscapeHatch);\r\n        escapeHatch = newEscapeHatch;\r\n    }\r\n\r\n    // ===== balance =====\r\n\r\n    mapping(address => uint256) public balance;\r\n\r\n    /// Add `value` to `balance[key]`, unless this causes integer overflow.\r\n    ///\r\n    /// @dev This is a slight divergence from the strict Eternal Storage pattern, but it reduces the gas\r\n    /// for the by-far most common token usage, it's a *very simple* divergence, and `setBalance` is\r\n    /// available anyway.\r\n    function addBalance(address key, uint256 value) external onlyOwner {\r\n        balance[key] = balance[key].add(value);\r\n    }\r\n\r\n    /// Subtract `value` from `balance[key]`, unless this causes integer underflow.\r\n    function subBalance(address key, uint256 value) external onlyOwner {\r\n        balance[key] = balance[key].sub(value);\r\n    }\r\n\r\n    /// Set `balance[key]` to `value`.\r\n    function setBalance(address key, uint256 value) external onlyOwner {\r\n        balance[key] = value;\r\n    }\r\n\r\n\r\n\r\n    // ===== allowed =====\r\n\r\n    mapping(address => mapping(address => uint256)) public allowed;\r\n\r\n    /// Set `to`'s allowance of `from`'s tokens to `value`.\r\n    function setAllowed(address from, address to, uint256 value) external onlyOwner {\r\n        allowed[from][to] = value;\r\n    }\r\n\r\n\r\n\r\n    // ===== frozenTime =====\r\n\r\n    /// @dev When `frozenTime[addr] == 0`, `addr` is not frozen. This is the normal state.\r\n    /// When `frozenTime[addr] == t` and `t > 0`, `addr` was last frozen at timestamp `t`.\r\n    /// So, to unfreeze an address `addr`, set `frozenTime[addr] = 0`.\r\n    mapping(address => uint256) public frozenTime;\r\n\r\n    /// Set `frozenTime[who]` to `time`.\r\n    function setFrozenTime(address who, uint256 time) external onlyOwner {\r\n        frozenTime[who] = time;\r\n    }\r\n}\r\n\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Multiplies two unsigned integers, reverts on overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Adds two unsigned integers, reverts on overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\r\n     * reverts when dividing by zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"proposals\",\"outputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"isMint\",\"type\":\"bool\"},{\"name\":\"time\",\"type\":\"uint256\"},{\"name\":\"closed\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"cancelAll\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"index\",\"type\":\"uint256\"},{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"isMint\",\"type\":\"bool\"}],\"name\":\"cancel\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"isMint\",\"type\":\"bool\"}],\"name\":\"propose\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"delay\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"reserve\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"index\",\"type\":\"uint256\"},{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"isMint\",\"type\":\"bool\"}],\"name\":\"confirm\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"reserveDollar\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"index\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"isMint\",\"type\":\"bool\"},{\"indexed\":false,\"name\":\"delayUntil\",\"type\":\"uint256\"}],\"name\":\"ProposalCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"index\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"isMint\",\"type\":\"bool\"}],\"name\":\"ProposalConfirmed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"index\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"isMint\",\"type\":\"bool\"}],\"name\":\"ProposalCancelled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"AllProposalsCancelled\",\"type\":\"event\"}]","ContractName":"MintAndBurnAdmin","CompilerVersion":"v0.5.4+commit.9549d8ff","OptimizationUsed":"1","Runs":"10000000","ConstructorArguments":"000000000000000000000000ffceeba0bdb21304a9f3d575dbcfebe583192c24","Library":"","SwarmSource":"bzzr://7c62bc273ac46c34a1c824db13d9f026b689e4d893f4d69383ab1c7b7d6cece9"}]}