{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.23;\r\n\r\n// File: contracts/TokenSale.sol\r\n\r\ncontract TokenSale {\r\n    /**\r\n    * Buy tokens for the beneficiary using paid Ether.\r\n    * @param beneficiary the beneficiary address that will receive the tokens.\r\n    */\r\n    function buyTokens(address beneficiary) public payable;\r\n}\r\n\r\n// File: contracts/WhitelistableConstraints.sol\r\n\r\n/**\r\n * @title WhitelistableConstraints\r\n * @dev Contract encapsulating the constraints applicable to a Whitelistable contract.\r\n */\r\ncontract WhitelistableConstraints {\r\n\r\n    /**\r\n     * @dev Check if whitelist with specified parameters is allowed.\r\n     * @param _maxWhitelistLength The maximum length of whitelist. Zero means no whitelist.\r\n     * @param _weiWhitelistThresholdBalance The threshold balance triggering whitelist check.\r\n     * @return true if whitelist with specified parameters is allowed, false otherwise\r\n     */\r\n    function isAllowedWhitelist(uint256 _maxWhitelistLength, uint256 _weiWhitelistThresholdBalance)\r\n        public pure returns(bool isReallyAllowedWhitelist) {\r\n        return _maxWhitelistLength > 0 || _weiWhitelistThresholdBalance > 0;\r\n    }\r\n}\r\n\r\n// File: contracts/Whitelistable.sol\r\n\r\n/**\r\n * @title Whitelistable\r\n * @dev Base contract implementing a whitelist to keep track of investors.\r\n * The construction parameters allow for both whitelisted and non-whitelisted contracts:\r\n * 1) maxWhitelistLength = 0 and whitelistThresholdBalance > 0: whitelist disabled\r\n * 2) maxWhitelistLength > 0 and whitelistThresholdBalance = 0: whitelist enabled, full whitelisting\r\n * 3) maxWhitelistLength > 0 and whitelistThresholdBalance > 0: whitelist enabled, partial whitelisting\r\n */\r\ncontract Whitelistable is WhitelistableConstraints {\r\n\r\n    event LogMaxWhitelistLengthChanged(address indexed caller, uint256 indexed maxWhitelistLength);\r\n    event LogWhitelistThresholdBalanceChanged(address indexed caller, uint256 indexed whitelistThresholdBalance);\r\n    event LogWhitelistAddressAdded(address indexed caller, address indexed subscriber);\r\n    event LogWhitelistAddressRemoved(address indexed caller, address indexed subscriber);\r\n\r\n    mapping (address => bool) public whitelist;\r\n\r\n    uint256 public whitelistLength;\r\n\r\n    uint256 public maxWhitelistLength;\r\n\r\n    uint256 public whitelistThresholdBalance;\r\n\r\n    constructor(uint256 _maxWhitelistLength, uint256 _whitelistThresholdBalance) internal {\r\n        require(isAllowedWhitelist(_maxWhitelistLength, _whitelistThresholdBalance), \"parameters not allowed\");\r\n\r\n        maxWhitelistLength = _maxWhitelistLength;\r\n        whitelistThresholdBalance = _whitelistThresholdBalance;\r\n    }\r\n\r\n    /**\r\n     * @return true if whitelist is currently enabled, false otherwise\r\n     */\r\n    function isWhitelistEnabled() public view returns(bool isReallyWhitelistEnabled) {\r\n        return maxWhitelistLength > 0;\r\n    }\r\n\r\n    /**\r\n     * @return true if subscriber is whitelisted, false otherwise\r\n     */\r\n    function isWhitelisted(address _subscriber) public view returns(bool isReallyWhitelisted) {\r\n        return whitelist[_subscriber];\r\n    }\r\n\r\n    function setMaxWhitelistLengthInternal(uint256 _maxWhitelistLength) internal {\r\n        require(isAllowedWhitelist(_maxWhitelistLength, whitelistThresholdBalance),\r\n            \"_maxWhitelistLength not allowed\");\r\n        require(_maxWhitelistLength != maxWhitelistLength, \"_maxWhitelistLength equal to current one\");\r\n\r\n        maxWhitelistLength = _maxWhitelistLength;\r\n\r\n        emit LogMaxWhitelistLengthChanged(msg.sender, maxWhitelistLength);\r\n    }\r\n\r\n    function setWhitelistThresholdBalanceInternal(uint256 _whitelistThresholdBalance) internal {\r\n        require(isAllowedWhitelist(maxWhitelistLength, _whitelistThresholdBalance),\r\n            \"_whitelistThresholdBalance not allowed\");\r\n        require(whitelistLength == 0 || _whitelistThresholdBalance > whitelistThresholdBalance,\r\n            \"_whitelistThresholdBalance not greater than current one\");\r\n\r\n        whitelistThresholdBalance = _whitelistThresholdBalance;\r\n\r\n        emit LogWhitelistThresholdBalanceChanged(msg.sender, _whitelistThresholdBalance);\r\n    }\r\n\r\n    function addToWhitelistInternal(address _subscriber) internal {\r\n        require(_subscriber != address(0), \"_subscriber is zero\");\r\n        require(!whitelist[_subscriber], \"already whitelisted\");\r\n        require(whitelistLength < maxWhitelistLength, \"max whitelist length reached\");\r\n\r\n        whitelistLength++;\r\n\r\n        whitelist[_subscriber] = true;\r\n\r\n        emit LogWhitelistAddressAdded(msg.sender, _subscriber);\r\n    }\r\n\r\n    function removeFromWhitelistInternal(address _subscriber, uint256 _balance) internal {\r\n        require(_subscriber != address(0), \"_subscriber is zero\");\r\n        require(whitelist[_subscriber], \"not whitelisted\");\r\n        require(_balance <= whitelistThresholdBalance, \"_balance greater than whitelist threshold\");\r\n\r\n        assert(whitelistLength > 0);\r\n\r\n        whitelistLength--;\r\n\r\n        whitelist[_subscriber] = false;\r\n\r\n        emit LogWhitelistAddressRemoved(msg.sender, _subscriber);\r\n    }\r\n\r\n    /**\r\n     * @param _subscriber The subscriber for which the balance check is required.\r\n     * @param _balance The balance value to check for allowance.\r\n     * @return true if the balance is allowed for the subscriber, false otherwise\r\n     */\r\n    function isAllowedBalance(address _subscriber, uint256 _balance) public view returns(bool isReallyAllowed) {\r\n        return !isWhitelistEnabled() || _balance <= whitelistThresholdBalance || whitelist[_subscriber];\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/AddressUtils.sol\r\n\r\n/**\r\n * Utility library of inline functions on addresses\r\n */\r\nlibrary AddressUtils {\r\n\r\n  /**\r\n   * Returns whether the target address is a contract\r\n   * @dev This function will return false if invoked during the constructor of a contract,\r\n   *  as the code is not actually created until after the constructor finishes.\r\n   * @param addr address to check\r\n   * @return whether the target address is a contract\r\n   */\r\n  function isContract(address addr) internal view returns (bool) {\r\n    uint256 size;\r\n    // XXX Currently there is no better way to check if there is a contract in an address\r\n    // than to check the size of the code at that address.\r\n    // See https://ethereum.stackexchange.com/a/14016/36603\r\n    // for more details about how this works.\r\n    // TODO Check this again before the Serenity release, because all addresses will be\r\n    // contracts then.\r\n    // solium-disable-next-line security/no-inline-assembly\r\n    assembly { size := extcodesize(addr) }\r\n    return size > 0;\r\n  }\r\n\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipRenounced(address indexed previousOwner);\r\n  event OwnershipTransferred(\r\n    address indexed previousOwner,\r\n    address indexed newOwner\r\n  );\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  constructor() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to relinquish control of the contract.\r\n   */\r\n  function renounceOwnership() public onlyOwner {\r\n    emit OwnershipRenounced(owner);\r\n    owner = address(0);\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address _newOwner) public onlyOwner {\r\n    _transferOwnership(_newOwner);\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function _transferOwnership(address _newOwner) internal {\r\n    require(_newOwner != address(0));\r\n    emit OwnershipTransferred(owner, _newOwner);\r\n    owner = _newOwner;\r\n  }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/lifecycle/Pausable.sol\r\n\r\n/**\r\n * @title Pausable\r\n * @dev Base contract which allows children to implement an emergency stop mechanism.\r\n */\r\ncontract Pausable is Ownable {\r\n  event Pause();\r\n  event Unpause();\r\n\r\n  bool public paused = false;\r\n\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is not paused.\r\n   */\r\n  modifier whenNotPaused() {\r\n    require(!paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is paused.\r\n   */\r\n  modifier whenPaused() {\r\n    require(paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to pause, triggers stopped state\r\n   */\r\n  function pause() onlyOwner whenNotPaused public {\r\n    paused = true;\r\n    emit Pause();\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to unpause, returns to normal state\r\n   */\r\n  function unpause() onlyOwner whenPaused public {\r\n    paused = false;\r\n    emit Unpause();\r\n  }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/math/SafeMath.sol\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return a / b;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC20/ERC20Basic.sol\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/179\r\n */\r\ncontract ERC20Basic {\r\n  function totalSupply() public view returns (uint256);\r\n  function balanceOf(address who) public view returns (uint256);\r\n  function transfer(address to, uint256 value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC20/BasicToken.sol\r\n\r\n/**\r\n * @title Basic token\r\n * @dev Basic version of StandardToken, with no allowances.\r\n */\r\ncontract BasicToken is ERC20Basic {\r\n  using SafeMath for uint256;\r\n\r\n  mapping(address => uint256) balances;\r\n\r\n  uint256 totalSupply_;\r\n\r\n  /**\r\n  * @dev total number of tokens in existence\r\n  */\r\n  function totalSupply() public view returns (uint256) {\r\n    return totalSupply_;\r\n  }\r\n\r\n  /**\r\n  * @dev transfer token for a specified address\r\n  * @param _to The address to transfer to.\r\n  * @param _value The amount to be transferred.\r\n  */\r\n  function transfer(address _to, uint256 _value) public returns (bool) {\r\n    require(_to != address(0));\r\n    require(_value <= balances[msg.sender]);\r\n\r\n    balances[msg.sender] = balances[msg.sender].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    emit Transfer(msg.sender, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n  * @dev Gets the balance of the specified address.\r\n  * @param _owner The address to query the the balance of.\r\n  * @return An uint256 representing the amount owned by the passed address.\r\n  */\r\n  function balanceOf(address _owner) public view returns (uint256) {\r\n    return balances[_owner];\r\n  }\r\n\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC20/ERC20.sol\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address owner, address spender)\r\n    public view returns (uint256);\r\n\r\n  function transferFrom(address from, address to, uint256 value)\r\n    public returns (bool);\r\n\r\n  function approve(address spender, uint256 value) public returns (bool);\r\n  event Approval(\r\n    address indexed owner,\r\n    address indexed spender,\r\n    uint256 value\r\n  );\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC20/StandardToken.sol\r\n\r\n/**\r\n * @title Standard ERC20 token\r\n *\r\n * @dev Implementation of the basic standard token.\r\n * @dev https://github.com/ethereum/EIPs/issues/20\r\n * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\r\n */\r\ncontract StandardToken is ERC20, BasicToken {\r\n\r\n  mapping (address => mapping (address => uint256)) internal allowed;\r\n\r\n\r\n  /**\r\n   * @dev Transfer tokens from one address to another\r\n   * @param _from address The address which you want to send tokens from\r\n   * @param _to address The address which you want to transfer to\r\n   * @param _value uint256 the amount of tokens to be transferred\r\n   */\r\n  function transferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _value\r\n  )\r\n    public\r\n    returns (bool)\r\n  {\r\n    require(_to != address(0));\r\n    require(_value <= balances[_from]);\r\n    require(_value <= allowed[_from][msg.sender]);\r\n\r\n    balances[_from] = balances[_from].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n    emit Transfer(_from, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n   *\r\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\r\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\r\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\r\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _value The amount of tokens to be spent.\r\n   */\r\n  function approve(address _spender, uint256 _value) public returns (bool) {\r\n    allowed[msg.sender][_spender] = _value;\r\n    emit Approval(msg.sender, _spender, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n   * @param _owner address The address which owns the funds.\r\n   * @param _spender address The address which will spend the funds.\r\n   * @return A uint256 specifying the amount of tokens still available for the spender.\r\n   */\r\n  function allowance(\r\n    address _owner,\r\n    address _spender\r\n   )\r\n    public\r\n    view\r\n    returns (uint256)\r\n  {\r\n    return allowed[_owner][_spender];\r\n  }\r\n\r\n  /**\r\n   * @dev Increase the amount of tokens that an owner allowed to a spender.\r\n   *\r\n   * approve should be called when allowed[_spender] == 0. To increment\r\n   * allowed value is better to use this function to avoid 2 calls (and wait until\r\n   * the first transaction is mined)\r\n   * From MonolithDAO Token.sol\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _addedValue The amount of tokens to increase the allowance by.\r\n   */\r\n  function increaseApproval(\r\n    address _spender,\r\n    uint _addedValue\r\n  )\r\n    public\r\n    returns (bool)\r\n  {\r\n    allowed[msg.sender][_spender] = (\r\n      allowed[msg.sender][_spender].add(_addedValue));\r\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Decrease the amount of tokens that an owner allowed to a spender.\r\n   *\r\n   * approve should be called when allowed[_spender] == 0. To decrement\r\n   * allowed value is better to use this function to avoid 2 calls (and wait until\r\n   * the first transaction is mined)\r\n   * From MonolithDAO Token.sol\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _subtractedValue The amount of tokens to decrease the allowance by.\r\n   */\r\n  function decreaseApproval(\r\n    address _spender,\r\n    uint _subtractedValue\r\n  )\r\n    public\r\n    returns (bool)\r\n  {\r\n    uint oldValue = allowed[msg.sender][_spender];\r\n    if (_subtractedValue > oldValue) {\r\n      allowed[msg.sender][_spender] = 0;\r\n    } else {\r\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\r\n    }\r\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n    return true;\r\n  }\r\n\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC20/MintableToken.sol\r\n\r\n/**\r\n * @title Mintable token\r\n * @dev Simple ERC20 Token example, with mintable token creation\r\n * @dev Issue: * https://github.com/OpenZeppelin/openzeppelin-solidity/issues/120\r\n * Based on code by TokenMarketNet: https://github.com/TokenMarketNet/ico/blob/master/contracts/MintableToken.sol\r\n */\r\ncontract MintableToken is StandardToken, Ownable {\r\n  event Mint(address indexed to, uint256 amount);\r\n  event MintFinished();\r\n\r\n  bool public mintingFinished = false;\r\n\r\n\r\n  modifier canMint() {\r\n    require(!mintingFinished);\r\n    _;\r\n  }\r\n\r\n  modifier hasMintPermission() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Function to mint tokens\r\n   * @param _to The address that will receive the minted tokens.\r\n   * @param _amount The amount of tokens to mint.\r\n   * @return A boolean that indicates if the operation was successful.\r\n   */\r\n  function mint(\r\n    address _to,\r\n    uint256 _amount\r\n  )\r\n    hasMintPermission\r\n    canMint\r\n    public\r\n    returns (bool)\r\n  {\r\n    totalSupply_ = totalSupply_.add(_amount);\r\n    balances[_to] = balances[_to].add(_amount);\r\n    emit Mint(_to, _amount);\r\n    emit Transfer(address(0), _to, _amount);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Function to stop minting new tokens.\r\n   * @return True if the operation was successful.\r\n   */\r\n  function finishMinting() onlyOwner canMint public returns (bool) {\r\n    mintingFinished = true;\r\n    emit MintFinished();\r\n    return true;\r\n  }\r\n}\r\n\r\n// File: contracts/Crowdsale.sol\r\n\r\n/**\r\n * @title Crowdsale \r\n * @dev Crowdsale is a base contract for managing a token crowdsale.\r\n * Crowdsales have a start and end block, where investors can make\r\n * token purchases and the crowdsale will assign them tokens based\r\n * on a token per ETH rate. Funds collected are forwarded to a wallet \r\n * as they arrive.\r\n */\r\ncontract Crowdsale is TokenSale, Pausable, Whitelistable {\r\n    using AddressUtils for address;\r\n    using SafeMath for uint256;\r\n\r\n    event LogStartBlockChanged(uint256 indexed startBlock);\r\n    event LogEndBlockChanged(uint256 indexed endBlock);\r\n    event LogMinDepositChanged(uint256 indexed minDeposit);\r\n    event LogTokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 indexed amount, uint256 tokenAmount);\r\n\r\n    // The token being sold\r\n    MintableToken public token;\r\n\r\n    // The start and end block where investments are allowed (both inclusive)\r\n    uint256 public startBlock;\r\n    uint256 public endBlock;\r\n\r\n    // How many token units a buyer gets per wei\r\n    uint256 public rate;\r\n\r\n    // Amount of raised money in wei\r\n    uint256 public raisedFunds;\r\n\r\n    // Amount of tokens already sold\r\n    uint256 public soldTokens;\r\n\r\n    // Balances in wei deposited by each subscriber\r\n    mapping (address => uint256) public balanceOf;\r\n\r\n    // The minimum balance for each subscriber in wei\r\n    uint256 public minDeposit;\r\n\r\n    modifier beforeStart() {\r\n        require(block.number < startBlock, \"already started\");\r\n        _;\r\n    }\r\n\r\n    modifier beforeEnd() {\r\n        require(block.number <= endBlock, \"already ended\");\r\n        _;\r\n    }\r\n\r\n    constructor(\r\n        uint256 _startBlock,\r\n        uint256 _endBlock,\r\n        uint256 _rate,\r\n        uint256 _minDeposit,\r\n        uint256 maxWhitelistLength,\r\n        uint256 whitelistThreshold\r\n    )\r\n    Whitelistable(maxWhitelistLength, whitelistThreshold) internal\r\n    {\r\n        require(_startBlock >= block.number, \"_startBlock is lower than current block.number\");\r\n        require(_endBlock >= _startBlock, \"_endBlock is lower than _startBlock\");\r\n        require(_rate > 0, \"_rate is zero\");\r\n        require(_minDeposit > 0, \"_minDeposit is zero\");\r\n\r\n        startBlock = _startBlock;\r\n        endBlock = _endBlock;\r\n        rate = _rate;\r\n        minDeposit = _minDeposit;\r\n    }\r\n\r\n    /*\r\n    * @return true if crowdsale event has started\r\n    */\r\n    function hasStarted() public view returns (bool started) {\r\n        return block.number >= startBlock;\r\n    }\r\n\r\n    /*\r\n    * @return true if crowdsale event has ended\r\n    */\r\n    function hasEnded() public view returns (bool ended) {\r\n        return block.number > endBlock;\r\n    }\r\n\r\n    /**\r\n     * Change the crowdsale start block number.\r\n     * @param _startBlock The new start block\r\n     */\r\n    function setStartBlock(uint256 _startBlock) external onlyOwner beforeStart {\r\n        require(_startBlock >= block.number, \"_startBlock < current block\");\r\n        require(_startBlock <= endBlock, \"_startBlock > endBlock\");\r\n        require(_startBlock != startBlock, \"_startBlock == startBlock\");\r\n\r\n        startBlock = _startBlock;\r\n\r\n        emit LogStartBlockChanged(_startBlock);\r\n    }\r\n\r\n    /**\r\n     * Change the crowdsale end block number.\r\n     * @param _endBlock The new end block\r\n     */\r\n    function setEndBlock(uint256 _endBlock) external onlyOwner beforeEnd {\r\n        require(_endBlock >= block.number, \"_endBlock < current block\");\r\n        require(_endBlock >= startBlock, \"_endBlock < startBlock\");\r\n        require(_endBlock != endBlock, \"_endBlock == endBlock\");\r\n\r\n        endBlock = _endBlock;\r\n\r\n        emit LogEndBlockChanged(_endBlock);\r\n    }\r\n\r\n    /**\r\n     * Change the minimum deposit for each subscriber. New value shall be lower than previous.\r\n     * @param _minDeposit The minimum deposit for each subscriber, expressed in wei\r\n     */\r\n    function setMinDeposit(uint256 _minDeposit) external onlyOwner beforeEnd {\r\n        require(0 < _minDeposit && _minDeposit < minDeposit, \"_minDeposit is not in [0, minDeposit]\");\r\n\r\n        minDeposit = _minDeposit;\r\n\r\n        emit LogMinDepositChanged(minDeposit);\r\n    }\r\n\r\n    /**\r\n     * Change the maximum whitelist length. New value shall satisfy the #isAllowedWhitelist conditions.\r\n     * @param maxWhitelistLength The maximum whitelist length\r\n     */\r\n    function setMaxWhitelistLength(uint256 maxWhitelistLength) external onlyOwner beforeEnd {\r\n        setMaxWhitelistLengthInternal(maxWhitelistLength);\r\n    }\r\n\r\n    /**\r\n     * Change the whitelist threshold balance. New value shall satisfy the #isAllowedWhitelist conditions.\r\n     * @param whitelistThreshold The threshold balance (in wei) above which whitelisting is required to invest\r\n     */\r\n    function setWhitelistThresholdBalance(uint256 whitelistThreshold) external onlyOwner beforeEnd {\r\n        setWhitelistThresholdBalanceInternal(whitelistThreshold);\r\n    }\r\n\r\n    /**\r\n     * Add the subscriber to the whitelist.\r\n     * @param subscriber The subscriber to add to the whitelist.\r\n     */\r\n    function addToWhitelist(address subscriber) external onlyOwner beforeEnd {\r\n        addToWhitelistInternal(subscriber);\r\n    }\r\n\r\n    /**\r\n     * Removed the subscriber from the whitelist.\r\n     * @param subscriber The subscriber to remove from the whitelist.\r\n     */\r\n    function removeFromWhitelist(address subscriber) external onlyOwner beforeEnd {\r\n        removeFromWhitelistInternal(subscriber, balanceOf[subscriber]);\r\n    }\r\n\r\n    // fallback function can be used to buy tokens\r\n    function () external payable whenNotPaused {\r\n        buyTokens(msg.sender);\r\n    }\r\n\r\n    // low level token purchase function\r\n    function buyTokens(address beneficiary) public payable whenNotPaused {\r\n        require(beneficiary != address(0), \"beneficiary is zero\");\r\n        require(isValidPurchase(beneficiary), \"invalid purchase by beneficiary\");\r\n\r\n        balanceOf[beneficiary] = balanceOf[beneficiary].add(msg.value);\r\n\r\n        raisedFunds = raisedFunds.add(msg.value);\r\n\r\n        uint256 tokenAmount = calculateTokens(msg.value);\r\n\r\n        soldTokens = soldTokens.add(tokenAmount);\r\n\r\n        distributeTokens(beneficiary, tokenAmount);\r\n\r\n        emit LogTokenPurchase(msg.sender, beneficiary, msg.value, tokenAmount);\r\n\r\n        forwardFunds(msg.value);\r\n    }\r\n\r\n    /**\r\n     * @dev Overrides Whitelistable#isAllowedBalance to add minimum deposit logic.\r\n     */\r\n    function isAllowedBalance(address beneficiary, uint256 balance) public view returns (bool isReallyAllowed) {\r\n        bool hasMinimumBalance = balance >= minDeposit;\r\n        return hasMinimumBalance && super.isAllowedBalance(beneficiary, balance);\r\n    }\r\n\r\n    /**\r\n     * @dev Determine if the token purchase is valid or not.\r\n     * @return true if the transaction can buy tokens\r\n     */\r\n    function isValidPurchase(address beneficiary) internal view returns (bool isValid) {\r\n        bool withinPeriod = startBlock <= block.number && block.number <= endBlock;\r\n        bool nonZeroPurchase = msg.value != 0;\r\n        bool isValidBalance = isAllowedBalance(beneficiary, balanceOf[beneficiary].add(msg.value));\r\n\r\n        return withinPeriod && nonZeroPurchase && isValidBalance;\r\n    }\r\n\r\n    // Calculate the token amount given the invested ether amount.\r\n    // Override to create custom fund forwarding mechanisms\r\n    function calculateTokens(uint256 amount) internal view returns (uint256 tokenAmount) {\r\n        return amount.mul(rate);\r\n    }\r\n\r\n    /**\r\n     * @dev Distribute the token amount to the beneficiary.\r\n     * @notice Override to create custom distribution mechanisms\r\n     */\r\n    function distributeTokens(address beneficiary, uint256 tokenAmount) internal {\r\n        token.mint(beneficiary, tokenAmount);\r\n    }\r\n\r\n    // Send ether amount to the fund collection wallet.\r\n    // override to create custom fund forwarding mechanisms\r\n    function forwardFunds(uint256 amount) internal;\r\n}\r\n\r\n// File: contracts/NokuPricingPlan.sol\r\n\r\n/**\r\n* @dev The NokuPricingPlan contract defines the responsibilities of a Noku pricing plan.\r\n*/\r\ncontract NokuPricingPlan {\r\n    /**\r\n    * @dev Pay the fee for the service identified by the specified name.\r\n    * The fee amount shall already be approved by the client.\r\n    * @param serviceName The name of the target service.\r\n    * @param multiplier The multiplier of the base service fee to apply.\r\n    * @param client The client of the target service.\r\n    * @return true if fee has been paid.\r\n    */\r\n    function payFee(bytes32 serviceName, uint256 multiplier, address client) public returns(bool paid);\r\n\r\n    /**\r\n    * @dev Get the usage fee for the service identified by the specified name.\r\n    * The returned fee amount shall be approved before using #payFee method.\r\n    * @param serviceName The name of the target service.\r\n    * @param multiplier The multiplier of the base service fee to apply.\r\n    * @return The amount to approve before really paying such fee.\r\n    */\r\n    function usageFee(bytes32 serviceName, uint256 multiplier) public view returns(uint fee);\r\n}\r\n\r\n// File: contracts/NokuCustomToken.sol\r\n\r\ncontract NokuCustomToken is Ownable {\r\n\r\n    event LogBurnFinished();\r\n    event LogPricingPlanChanged(address indexed caller, address indexed pricingPlan);\r\n\r\n    // The pricing plan determining the fee to be paid in NOKU tokens by customers for using Noku services\r\n    NokuPricingPlan public pricingPlan;\r\n\r\n    // The entity acting as Custom Token service provider i.e. Noku\r\n    address public serviceProvider;\r\n\r\n    // Flag indicating if Custom Token burning has been permanently finished or not.\r\n    bool public burningFinished;\r\n\r\n    /**\r\n    * @dev Modifier to make a function callable only by service provider i.e. Noku.\r\n    */\r\n    modifier onlyServiceProvider() {\r\n        require(msg.sender == serviceProvider, \"caller is not service provider\");\r\n        _;\r\n    }\r\n\r\n    modifier canBurn() {\r\n        require(!burningFinished, \"burning finished\");\r\n        _;\r\n    }\r\n\r\n    constructor(address _pricingPlan, address _serviceProvider) internal {\r\n        require(_pricingPlan != 0, \"_pricingPlan is zero\");\r\n        require(_serviceProvider != 0, \"_serviceProvider is zero\");\r\n\r\n        pricingPlan = NokuPricingPlan(_pricingPlan);\r\n        serviceProvider = _serviceProvider;\r\n    }\r\n\r\n    /**\r\n    * @dev Presence of this function indicates the contract is a Custom Token.\r\n    */\r\n    function isCustomToken() public pure returns(bool isCustom) {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev Stop burning new tokens.\r\n    * @return true if the operation was successful.\r\n    */\r\n    function finishBurning() public onlyOwner canBurn returns(bool finished) {\r\n        burningFinished = true;\r\n\r\n        emit LogBurnFinished();\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev Change the pricing plan of service fee to be paid in NOKU tokens.\r\n    * @param _pricingPlan The pricing plan of NOKU token to be paid, zero means flat subscription.\r\n    */\r\n    function setPricingPlan(address _pricingPlan) public onlyServiceProvider {\r\n        require(_pricingPlan != 0, \"_pricingPlan is 0\");\r\n        require(_pricingPlan != address(pricingPlan), \"_pricingPlan == pricingPlan\");\r\n\r\n        pricingPlan = NokuPricingPlan(_pricingPlan);\r\n\r\n        emit LogPricingPlanChanged(msg.sender, _pricingPlan);\r\n    }\r\n}\r\n\r\n// File: contracts/NokuTokenBurner.sol\r\n\r\ncontract BurnableERC20 is ERC20 {\r\n    function burn(uint256 amount) public returns (bool burned);\r\n}\r\n\r\n/**\r\n* @dev The NokuTokenBurner contract has the responsibility to burn the configured fraction of received\r\n* ERC20-compliant tokens and distribute the remainder to the configured wallet.\r\n*/\r\ncontract NokuTokenBurner is Pausable {\r\n    using SafeMath for uint256;\r\n\r\n    event LogNokuTokenBurnerCreated(address indexed caller, address indexed wallet);\r\n    event LogBurningPercentageChanged(address indexed caller, uint256 indexed burningPercentage);\r\n\r\n    // The wallet receiving the unburnt tokens.\r\n    address public wallet;\r\n\r\n    // The percentage of tokens to burn after being received (range [0, 100])\r\n    uint256 public burningPercentage;\r\n\r\n    // The cumulative amount of burnt tokens.\r\n    uint256 public burnedTokens;\r\n\r\n    // The cumulative amount of tokens transferred back to the wallet.\r\n    uint256 public transferredTokens;\r\n\r\n    /**\r\n    * @dev Create a new NokuTokenBurner with predefined burning fraction.\r\n    * @param _wallet The wallet receiving the unburnt tokens.\r\n    */\r\n    constructor(address _wallet) public {\r\n        require(_wallet != address(0), \"_wallet is zero\");\r\n        \r\n        wallet = _wallet;\r\n        burningPercentage = 100;\r\n\r\n        emit LogNokuTokenBurnerCreated(msg.sender, _wallet);\r\n    }\r\n\r\n    /**\r\n    * @dev Change the percentage of tokens to burn after being received.\r\n    * @param _burningPercentage The percentage of tokens to be burnt.\r\n    */\r\n    function setBurningPercentage(uint256 _burningPercentage) public onlyOwner {\r\n        require(0 <= _burningPercentage && _burningPercentage <= 100, \"_burningPercentage not in [0, 100]\");\r\n        require(_burningPercentage != burningPercentage, \"_burningPercentage equal to current one\");\r\n        \r\n        burningPercentage = _burningPercentage;\r\n\r\n        emit LogBurningPercentageChanged(msg.sender, _burningPercentage);\r\n    }\r\n\r\n    /**\r\n    * @dev Called after burnable tokens has been transferred for burning.\r\n    * @param _token THe extended ERC20 interface supported by the sent tokens.\r\n    * @param _amount The amount of burnable tokens just arrived ready for burning.\r\n    */\r\n    function tokenReceived(address _token, uint256 _amount) public whenNotPaused {\r\n        require(_token != address(0), \"_token is zero\");\r\n        require(_amount > 0, \"_amount is zero\");\r\n\r\n        uint256 amountToBurn = _amount.mul(burningPercentage).div(100);\r\n        if (amountToBurn > 0) {\r\n            assert(BurnableERC20(_token).burn(amountToBurn));\r\n            \r\n            burnedTokens = burnedTokens.add(amountToBurn);\r\n        }\r\n\r\n        uint256 amountToTransfer = _amount.sub(amountToBurn);\r\n        if (amountToTransfer > 0) {\r\n            assert(BurnableERC20(_token).transfer(wallet, amountToTransfer));\r\n\r\n            transferredTokens = transferredTokens.add(amountToTransfer);\r\n        }\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC20/BurnableToken.sol\r\n\r\n/**\r\n * @title Burnable Token\r\n * @dev Token that can be irreversibly burned (destroyed).\r\n */\r\ncontract BurnableToken is BasicToken {\r\n\r\n  event Burn(address indexed burner, uint256 value);\r\n\r\n  /**\r\n   * @dev Burns a specific amount of tokens.\r\n   * @param _value The amount of token to be burned.\r\n   */\r\n  function burn(uint256 _value) public {\r\n    _burn(msg.sender, _value);\r\n  }\r\n\r\n  function _burn(address _who, uint256 _value) internal {\r\n    require(_value <= balances[_who]);\r\n    // no need to require value <= totalSupply, since that would imply the\r\n    // sender's balance is greater than the totalSupply, which *should* be an assertion failure\r\n\r\n    balances[_who] = balances[_who].sub(_value);\r\n    totalSupply_ = totalSupply_.sub(_value);\r\n    emit Burn(_who, _value);\r\n    emit Transfer(_who, address(0), _value);\r\n  }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC20/DetailedERC20.sol\r\n\r\n/**\r\n * @title DetailedERC20 token\r\n * @dev The decimals are only for visualization purposes.\r\n * All the operations are done using the smallest and indivisible token unit,\r\n * just as on Ethereum all the operations are done in wei.\r\n */\r\ncontract DetailedERC20 is ERC20 {\r\n  string public name;\r\n  string public symbol;\r\n  uint8 public decimals;\r\n\r\n  constructor(string _name, string _symbol, uint8 _decimals) public {\r\n    name = _name;\r\n    symbol = _symbol;\r\n    decimals = _decimals;\r\n  }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC20/SafeERC20.sol\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure.\r\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n  function safeTransfer(ERC20Basic token, address to, uint256 value) internal {\r\n    require(token.transfer(to, value));\r\n  }\r\n\r\n  function safeTransferFrom(\r\n    ERC20 token,\r\n    address from,\r\n    address to,\r\n    uint256 value\r\n  )\r\n    internal\r\n  {\r\n    require(token.transferFrom(from, to, value));\r\n  }\r\n\r\n  function safeApprove(ERC20 token, address spender, uint256 value) internal {\r\n    require(token.approve(spender, value));\r\n  }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC20/TokenTimelock.sol\r\n\r\n/**\r\n * @title TokenTimelock\r\n * @dev TokenTimelock is a token holder contract that will allow a\r\n * beneficiary to extract the tokens after a given release time\r\n */\r\ncontract TokenTimelock {\r\n  using SafeERC20 for ERC20Basic;\r\n\r\n  // ERC20 basic token contract being held\r\n  ERC20Basic public token;\r\n\r\n  // beneficiary of tokens after they are released\r\n  address public beneficiary;\r\n\r\n  // timestamp when token release is enabled\r\n  uint256 public releaseTime;\r\n\r\n  constructor(\r\n    ERC20Basic _token,\r\n    address _beneficiary,\r\n    uint256 _releaseTime\r\n  )\r\n    public\r\n  {\r\n    // solium-disable-next-line security/no-block-members\r\n    require(_releaseTime > block.timestamp);\r\n    token = _token;\r\n    beneficiary = _beneficiary;\r\n    releaseTime = _releaseTime;\r\n  }\r\n\r\n  /**\r\n   * @notice Transfers tokens held by timelock to beneficiary.\r\n   */\r\n  function release() public {\r\n    // solium-disable-next-line security/no-block-members\r\n    require(block.timestamp >= releaseTime);\r\n\r\n    uint256 amount = token.balanceOf(this);\r\n    require(amount > 0);\r\n\r\n    token.safeTransfer(beneficiary, amount);\r\n  }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC20/TokenVesting.sol\r\n\r\n/* solium-disable security/no-block-members */\r\n\r\npragma solidity ^0.4.23;\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title TokenVesting\r\n * @dev A token holder contract that can release its token balance gradually like a\r\n * typical vesting scheme, with a cliff and vesting period. Optionally revocable by the\r\n * owner.\r\n */\r\ncontract TokenVesting is Ownable {\r\n  using SafeMath for uint256;\r\n  using SafeERC20 for ERC20Basic;\r\n\r\n  event Released(uint256 amount);\r\n  event Revoked();\r\n\r\n  // beneficiary of tokens after they are released\r\n  address public beneficiary;\r\n\r\n  uint256 public cliff;\r\n  uint256 public start;\r\n  uint256 public duration;\r\n\r\n  bool public revocable;\r\n\r\n  mapping (address => uint256) public released;\r\n  mapping (address => bool) public revoked;\r\n\r\n  /**\r\n   * @dev Creates a vesting contract that vests its balance of any ERC20 token to the\r\n   * _beneficiary, gradually in a linear fashion until _start + _duration. By then all\r\n   * of the balance will have vested.\r\n   * @param _beneficiary address of the beneficiary to whom vested tokens are transferred\r\n   * @param _cliff duration in seconds of the cliff in which tokens will begin to vest\r\n   * @param _start the time (as Unix time) at which point vesting starts \r\n   * @param _duration duration in seconds of the period in which the tokens will vest\r\n   * @param _revocable whether the vesting is revocable or not\r\n   */\r\n  constructor(\r\n    address _beneficiary,\r\n    uint256 _start,\r\n    uint256 _cliff,\r\n    uint256 _duration,\r\n    bool _revocable\r\n  )\r\n    public\r\n  {\r\n    require(_beneficiary != address(0));\r\n    require(_cliff <= _duration);\r\n\r\n    beneficiary = _beneficiary;\r\n    revocable = _revocable;\r\n    duration = _duration;\r\n    cliff = _start.add(_cliff);\r\n    start = _start;\r\n  }\r\n\r\n  /**\r\n   * @notice Transfers vested tokens to beneficiary.\r\n   * @param token ERC20 token which is being vested\r\n   */\r\n  function release(ERC20Basic token) public {\r\n    uint256 unreleased = releasableAmount(token);\r\n\r\n    require(unreleased > 0);\r\n\r\n    released[token] = released[token].add(unreleased);\r\n\r\n    token.safeTransfer(beneficiary, unreleased);\r\n\r\n    emit Released(unreleased);\r\n  }\r\n\r\n  /**\r\n   * @notice Allows the owner to revoke the vesting. Tokens already vested\r\n   * remain in the contract, the rest are returned to the owner.\r\n   * @param token ERC20 token which is being vested\r\n   */\r\n  function revoke(ERC20Basic token) public onlyOwner {\r\n    require(revocable);\r\n    require(!revoked[token]);\r\n\r\n    uint256 balance = token.balanceOf(this);\r\n\r\n    uint256 unreleased = releasableAmount(token);\r\n    uint256 refund = balance.sub(unreleased);\r\n\r\n    revoked[token] = true;\r\n\r\n    token.safeTransfer(owner, refund);\r\n\r\n    emit Revoked();\r\n  }\r\n\r\n  /**\r\n   * @dev Calculates the amount that has already vested but hasn't been released yet.\r\n   * @param token ERC20 token which is being vested\r\n   */\r\n  function releasableAmount(ERC20Basic token) public view returns (uint256) {\r\n    return vestedAmount(token).sub(released[token]);\r\n  }\r\n\r\n  /**\r\n   * @dev Calculates the amount that has already vested.\r\n   * @param token ERC20 token which is being vested\r\n   */\r\n  function vestedAmount(ERC20Basic token) public view returns (uint256) {\r\n    uint256 currentBalance = token.balanceOf(this);\r\n    uint256 totalBalance = currentBalance.add(released[token]);\r\n\r\n    if (block.timestamp < cliff) {\r\n      return 0;\r\n    } else if (block.timestamp >= start.add(duration) || revoked[token]) {\r\n      return totalBalance;\r\n    } else {\r\n      return totalBalance.mul(block.timestamp.sub(start)).div(duration);\r\n    }\r\n  }\r\n}\r\n\r\n// File: contracts/NokuCustomERC20.sol\r\n\r\n/**\r\n* @dev The NokuCustomERC20Token contract is a custom ERC20-compliant token available in the Noku Service Platform (NSP).\r\n* The Noku customer is able to choose the token name, symbol, decimals, initial supply and to administer its lifecycle\r\n* by minting or burning tokens in order to increase or decrease the token supply.\r\n*/\r\ncontract NokuCustomERC20 is NokuCustomToken, DetailedERC20, MintableToken, BurnableToken {\r\n    using SafeMath for uint256;\r\n\r\n    event LogNokuCustomERC20Created(\r\n        address indexed caller,\r\n        string indexed name,\r\n        string indexed symbol,\r\n        uint8 decimals,\r\n        uint256 transferableFromBlock,\r\n        uint256 lockEndBlock,\r\n        address pricingPlan,\r\n        address serviceProvider\r\n    );\r\n    event LogMintingFeeEnabledChanged(address indexed caller, bool indexed mintingFeeEnabled);\r\n    event LogInformationChanged(address indexed caller, string name, string symbol);\r\n    event LogTransferFeePaymentFinished(address indexed caller);\r\n    event LogTransferFeePercentageChanged(address indexed caller, uint256 indexed transferFeePercentage);\r\n\r\n    // Flag indicating if minting fees are enabled or disabled\r\n    bool public mintingFeeEnabled;\r\n\r\n    // Block number from which tokens are initially transferable\r\n    uint256 public transferableFromBlock;\r\n\r\n    // Block number from which initial lock ends\r\n    uint256 public lockEndBlock;\r\n\r\n    // The initially locked balances by address\r\n    mapping (address => uint256) public initiallyLockedBalanceOf;\r\n\r\n    // The fee percentage for Custom Token transfer or zero if transfer is free of charge\r\n    uint256 public transferFeePercentage;\r\n\r\n    // Flag indicating if fee payment in Custom Token transfer has been permanently finished or not. \r\n    bool public transferFeePaymentFinished;\r\n\r\n    // Address of optional Timelock smart contract, otherwise 0x0\r\n    TokenTimelock public timelock;\r\n\r\n    // Address of optional Vesting smart contract, otherwise 0x0\r\n    TokenVesting public vesting;\r\n\r\n    bytes32 public constant BURN_SERVICE_NAME     = \"NokuCustomERC20.burn\";\r\n    bytes32 public constant MINT_SERVICE_NAME     = \"NokuCustomERC20.mint\";\r\n    bytes32 public constant TIMELOCK_SERVICE_NAME = \"NokuCustomERC20.timelock\";\r\n    bytes32 public constant VESTING_SERVICE_NAME  = \"NokuCustomERC20.vesting\";\r\n\r\n    modifier canTransfer(address _from, uint _value) {\r\n        require(block.number >= transferableFromBlock, \"token not transferable\");\r\n\r\n        if (block.number < lockEndBlock) {\r\n            uint256 locked = lockedBalanceOf(_from);\r\n            if (locked > 0) {\r\n                uint256 newBalance = balanceOf(_from).sub(_value);\r\n                require(newBalance >= locked, \"_value exceeds locked amount\");\r\n            }\r\n        }\r\n        _;\r\n    }\r\n\r\n    constructor(\r\n        string _name,\r\n        string _symbol,\r\n        uint8 _decimals,\r\n        uint256 _transferableFromBlock,\r\n        uint256 _lockEndBlock,\r\n        address _pricingPlan,\r\n        address _serviceProvider\r\n    )\r\n    NokuCustomToken(_pricingPlan, _serviceProvider)\r\n    DetailedERC20(_name, _symbol, _decimals) public\r\n    {\r\n        require(bytes(_name).length > 0, \"_name is empty\");\r\n        require(bytes(_symbol).length > 0, \"_symbol is empty\");\r\n        require(_lockEndBlock >= _transferableFromBlock, \"_lockEndBlock lower than _transferableFromBlock\");\r\n\r\n        transferableFromBlock = _transferableFromBlock;\r\n        lockEndBlock = _lockEndBlock;\r\n        mintingFeeEnabled = true;\r\n\r\n        emit LogNokuCustomERC20Created(\r\n            msg.sender,\r\n            _name,\r\n            _symbol,\r\n            _decimals,\r\n            _transferableFromBlock,\r\n            _lockEndBlock,\r\n            _pricingPlan,\r\n            _serviceProvider\r\n        );\r\n    }\r\n\r\n    function setMintingFeeEnabled(bool _mintingFeeEnabled) public onlyOwner returns(bool successful) {\r\n        require(_mintingFeeEnabled != mintingFeeEnabled, \"_mintingFeeEnabled == mintingFeeEnabled\");\r\n\r\n        mintingFeeEnabled = _mintingFeeEnabled;\r\n\r\n        emit LogMintingFeeEnabledChanged(msg.sender, _mintingFeeEnabled);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev Change the Custom Token detailed information after creation.\r\n    * @param _name The name to assign to the Custom Token.\r\n    * @param _symbol The symbol to assign to the Custom Token.\r\n    */\r\n    function setInformation(string _name, string _symbol) public onlyOwner returns(bool successful) {\r\n        require(bytes(_name).length > 0, \"_name is empty\");\r\n        require(bytes(_symbol).length > 0, \"_symbol is empty\");\r\n\r\n        name = _name;\r\n        symbol = _symbol;\r\n\r\n        emit LogInformationChanged(msg.sender, _name, _symbol);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev Stop trasfer fee payment for tokens.\r\n    * @return true if the operation was successful.\r\n    */\r\n    function finishTransferFeePayment() public onlyOwner returns(bool finished) {\r\n        require(!transferFeePaymentFinished, \"transfer fee finished\");\r\n\r\n        transferFeePaymentFinished = true;\r\n\r\n        emit LogTransferFeePaymentFinished(msg.sender);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev Change the transfer fee percentage to be paid in Custom tokens.\r\n    * @param _transferFeePercentage The fee percentage to be paid for transfer in range [0, 100].\r\n    */\r\n    function setTransferFeePercentage(uint256 _transferFeePercentage) public onlyOwner {\r\n        require(0 <= _transferFeePercentage && _transferFeePercentage <= 100, \"_transferFeePercentage not in [0, 100]\");\r\n        require(_transferFeePercentage != transferFeePercentage, \"_transferFeePercentage equal to current value\");\r\n\r\n        transferFeePercentage = _transferFeePercentage;\r\n\r\n        emit LogTransferFeePercentageChanged(msg.sender, _transferFeePercentage);\r\n    }\r\n\r\n    function lockedBalanceOf(address _to) public view returns(uint256 locked) {\r\n        uint256 initiallyLocked = initiallyLockedBalanceOf[_to];\r\n        if (block.number >= lockEndBlock) return 0;\r\n        else if (block.number <= transferableFromBlock) return initiallyLocked;\r\n\r\n        uint256 releaseForBlock = initiallyLocked.div(lockEndBlock.sub(transferableFromBlock));\r\n        uint256 released = block.number.sub(transferableFromBlock).mul(releaseForBlock);\r\n        return initiallyLocked.sub(released);\r\n    }\r\n\r\n    /**\r\n    * @dev Get the fee to be paid for the transfer of NOKU tokens.\r\n    * @param _value The amount of NOKU tokens to be transferred.\r\n    */\r\n    function transferFee(uint256 _value) public view returns(uint256 usageFee) {\r\n        return _value.mul(transferFeePercentage).div(100);\r\n    }\r\n\r\n    /**\r\n    * @dev Check if token transfer is free of any charge or not.\r\n    * @return true if transfer is free of any charge.\r\n    */\r\n    function freeTransfer() public view returns (bool isTransferFree) {\r\n        return transferFeePaymentFinished || transferFeePercentage == 0;\r\n    }\r\n\r\n    /**\r\n    * @dev Override #transfer for optionally paying fee to Custom token owner.\r\n    */\r\n    function transfer(address _to, uint256 _value) canTransfer(msg.sender, _value) public returns(bool transferred) {\r\n        if (freeTransfer()) {\r\n            return super.transfer(_to, _value);\r\n        }\r\n        else {\r\n            uint256 usageFee = transferFee(_value);\r\n            uint256 netValue = _value.sub(usageFee);\r\n\r\n            bool feeTransferred = super.transfer(owner, usageFee);\r\n            bool netValueTransferred = super.transfer(_to, netValue);\r\n\r\n            return feeTransferred && netValueTransferred;\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Override #transferFrom for optionally paying fee to Custom token owner.\r\n    */\r\n    function transferFrom(address _from, address _to, uint256 _value) canTransfer(_from, _value) public returns(bool transferred) {\r\n        if (freeTransfer()) {\r\n            return super.transferFrom(_from, _to, _value);\r\n        }\r\n        else {\r\n            uint256 usageFee = transferFee(_value);\r\n            uint256 netValue = _value.sub(usageFee);\r\n\r\n            bool feeTransferred = super.transferFrom(_from, owner, usageFee);\r\n            bool netValueTransferred = super.transferFrom(_from, _to, netValue);\r\n\r\n            return feeTransferred && netValueTransferred;\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Burn a specific amount of tokens, paying the service fee.\r\n    * @param _amount The amount of token to be burned.\r\n    */\r\n    function burn(uint256 _amount) public canBurn {\r\n        require(_amount > 0, \"_amount is zero\");\r\n\r\n        super.burn(_amount);\r\n\r\n        require(pricingPlan.payFee(BURN_SERVICE_NAME, _amount, msg.sender), \"burn fee failed\");\r\n    }\r\n\r\n    /**\r\n    * @dev Mint a specific amount of tokens, paying the service fee.\r\n    * @param _to The address that will receive the minted tokens.\r\n    * @param _amount The amount of tokens to mint.\r\n    * @return A boolean that indicates if the operation was successful.\r\n    */\r\n    function mint(address _to, uint256 _amount) public onlyOwner canMint returns(bool minted) {\r\n        require(_to != 0, \"_to is zero\");\r\n        require(_amount > 0, \"_amount is zero\");\r\n\r\n        super.mint(_to, _amount);\r\n\r\n        if (mintingFeeEnabled) {\r\n            require(pricingPlan.payFee(MINT_SERVICE_NAME, _amount, msg.sender), \"mint fee failed\");\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev Mint new locked tokens, which will unlock progressively.\r\n    * @param _to The address that will receieve the minted locked tokens.\r\n    * @param _amount The amount of tokens to mint.\r\n    * @return A boolean that indicates if the operation was successful.\r\n    */\r\n    function mintLocked(address _to, uint256 _amount) public onlyOwner canMint returns(bool minted) {\r\n        initiallyLockedBalanceOf[_to] = initiallyLockedBalanceOf[_to].add(_amount);\r\n\r\n        return mint(_to, _amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Mint the specified amount of timelocked tokens.\r\n     * @param _to The address that will receieve the minted locked tokens.\r\n     * @param _amount The amount of tokens to mint.\r\n     * @param _releaseTime The token release time as timestamp from Unix epoch.\r\n     * @return A boolean that indicates if the operation was successful.\r\n     */\r\n    function mintTimelocked(address _to, uint256 _amount, uint256 _releaseTime) public onlyOwner canMint\r\n    returns(bool minted)\r\n    {\r\n        require(timelock == address(0), \"TokenTimelock already activated\");\r\n\r\n        timelock = new TokenTimelock(this, _to, _releaseTime);\r\n\r\n        minted = mint(timelock, _amount);\r\n\r\n        require(pricingPlan.payFee(TIMELOCK_SERVICE_NAME, _amount, msg.sender), \"timelock fee failed\");\r\n    }\r\n\r\n    /**\r\n    * @dev Mint the specified amount of vested tokens.\r\n    * @param _to The address that will receieve the minted vested tokens.\r\n    * @param _amount The amount of tokens to mint.\r\n    * @param _startTime When the vesting starts as timestamp in seconds from Unix epoch.\r\n    * @param _duration The duration in seconds of the period in which the tokens will vest.\r\n    * @return A boolean that indicates if the operation was successful.\r\n    */\r\n    function mintVested(address _to, uint256 _amount, uint256 _startTime, uint256 _duration) public onlyOwner canMint\r\n    returns(bool minted)\r\n    {\r\n        require(vesting == address(0), \"TokenVesting already activated\");\r\n\r\n        vesting = new TokenVesting(_to, _startTime, 0, _duration, true);\r\n\r\n        minted = mint(vesting, _amount);\r\n\r\n        require(pricingPlan.payFee(VESTING_SERVICE_NAME, _amount, msg.sender), \"vesting fee failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Release vested tokens to the beneficiary. Anyone can release vested tokens.\r\n    * @return A boolean that indicates if the operation was successful.\r\n     */\r\n    function releaseVested() public returns(bool released) {\r\n        require(vesting != address(0), \"TokenVesting not activated\");\r\n\r\n        vesting.release(this);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Revoke vested tokens. Just the token can revoke because it is the vesting owner.\r\n    * @return A boolean that indicates if the operation was successful.\r\n     */\r\n    function revokeVested() public onlyOwner returns(bool revoked) {\r\n        require(vesting != address(0), \"TokenVesting not activated\");\r\n\r\n        vesting.revoke(this);\r\n\r\n        return true;\r\n    }\r\n}\r\n\r\n// File: contracts/TokenCappedCrowdsale.sol\r\n\r\n/**\r\n * @title CappedCrowdsale\r\n * @dev Extension of Crowsdale with a max amount of funds raised\r\n */\r\ncontract TokenCappedCrowdsale is Crowdsale {\r\n    using SafeMath for uint256;\r\n\r\n    // The maximum token cap, should be initialized in derived contract\r\n    uint256 public tokenCap;\r\n\r\n    // Overriding Crowdsale#hasEnded to add tokenCap logic\r\n    // @return true if crowdsale event has ended\r\n    function hasEnded() public view returns (bool) {\r\n        bool capReached = soldTokens >= tokenCap;\r\n        return super.hasEnded() || capReached;\r\n    }\r\n\r\n    // Overriding Crowdsale#isValidPurchase to add extra cap logic\r\n    // @return true if investors can buy at the moment\r\n    function isValidPurchase(address beneficiary) internal view returns (bool isValid) {\r\n        uint256 tokenAmount = calculateTokens(msg.value);\r\n        bool withinCap = soldTokens.add(tokenAmount) <= tokenCap;\r\n        return withinCap && super.isValidPurchase(beneficiary);\r\n    }\r\n}\r\n\r\n// File: contracts/NokuCustomCrowdsale.sol\r\n\r\n/**\r\n * @title NokuCustomCrowdsale\r\n * @dev Extension of TokenCappedCrowdsale using values specific for Noku Custom ICO crowdsale\r\n */\r\ncontract NokuCustomCrowdsale is TokenCappedCrowdsale {\r\n    using AddressUtils for address;\r\n    using SafeMath for uint256;\r\n\r\n    event LogNokuCustomCrowdsaleCreated(\r\n        address sender,\r\n        uint256 indexed startBlock,\r\n        uint256 indexed endBlock,\r\n        address indexed wallet\r\n    );\r\n    event LogThreePowerAgesChanged(\r\n        address indexed sender,\r\n        uint256 indexed platinumAgeEndBlock,\r\n        uint256 indexed goldenAgeEndBlock,\r\n        uint256 silverAgeEndBlock,\r\n        uint256 platinumAgeRate,\r\n        uint256 goldenAgeRate,\r\n        uint256 silverAgeRate\r\n    );\r\n    event LogTwoPowerAgesChanged(\r\n        address indexed sender,\r\n        uint256 indexed platinumAgeEndBlock,\r\n        uint256 indexed goldenAgeEndBlock,\r\n        uint256 platinumAgeRate,\r\n        uint256 goldenAgeRate\r\n    );\r\n    event LogOnePowerAgeChanged(address indexed sender, uint256 indexed platinumAgeEndBlock, uint256 indexed platinumAgeRate);\r\n\r\n    // The end block of the 'platinum' age interval\r\n    uint256 public platinumAgeEndBlock;\r\n\r\n    // The end block of the 'golden' age interval\r\n    uint256 public goldenAgeEndBlock;\r\n\r\n    // The end block of the 'silver' age interval\r\n    uint256 public silverAgeEndBlock;\r\n\r\n    // The conversion rate of the 'platinum' age\r\n    uint256 public platinumAgeRate;\r\n\r\n    // The conversion rate of the 'golden' age\r\n    uint256 public goldenAgeRate;\r\n\r\n    // The conversion rate of the 'silver' age\r\n    uint256 public silverAgeRate;\r\n\r\n    // The wallet address or contract\r\n    address public wallet;\r\n\r\n    constructor(\r\n        uint256 _startBlock,\r\n        uint256 _endBlock,\r\n        uint256 _rate,\r\n        uint256 _minDeposit,\r\n        uint256 _maxWhitelistLength,\r\n        uint256 _whitelistThreshold,\r\n        address _token,\r\n        uint256 _tokenMaximumSupply,\r\n        address _wallet\r\n    )\r\n    Crowdsale(\r\n        _startBlock,\r\n        _endBlock,\r\n        _rate,\r\n        _minDeposit,\r\n        _maxWhitelistLength,\r\n        _whitelistThreshold\r\n    )\r\n    public {\r\n        require(_token.isContract(), \"_token is not contract\");\r\n        require(_tokenMaximumSupply > 0, \"_tokenMaximumSupply is zero\");\r\n\r\n        platinumAgeRate = _rate;\r\n        goldenAgeRate = _rate;\r\n        silverAgeRate = _rate;\r\n\r\n        token = NokuCustomERC20(_token);\r\n        wallet = _wallet;\r\n\r\n        // Assume predefined token supply has been minted and calculate the maximum number of tokens that can be sold\r\n        tokenCap = _tokenMaximumSupply.sub(token.totalSupply());\r\n\r\n        emit LogNokuCustomCrowdsaleCreated(msg.sender, startBlock, endBlock, _wallet);\r\n    }\r\n\r\n    function setThreePowerAges(\r\n        uint256 _platinumAgeEndBlock,\r\n        uint256 _goldenAgeEndBlock,\r\n        uint256 _silverAgeEndBlock,\r\n        uint256 _platinumAgeRate,\r\n        uint256 _goldenAgeRate,\r\n        uint256 _silverAgeRate\r\n    )\r\n    external onlyOwner beforeStart\r\n    {\r\n        require(startBlock <= _platinumAgeEndBlock, \"_platinumAgeEndBlock lower than start block\");\r\n        require(_platinumAgeEndBlock <= _goldenAgeEndBlock, \"_platinumAgeEndBlock greater than _goldenAgeEndBlock\");\r\n        require(_goldenAgeEndBlock <= _silverAgeEndBlock, \"_silverAgeEndBlock lower than _goldenAgeEndBlock\");\r\n        require(_silverAgeEndBlock <= endBlock, \"_silverAgeEndBlock greater than end block\");\r\n        require(_platinumAgeRate >= _goldenAgeRate, \"_platinumAgeRate lower than _goldenAgeRate\");\r\n        require(_goldenAgeRate >= _silverAgeRate, \"_goldenAgeRate lower than _silverAgeRate\");\r\n        require(_silverAgeRate >= rate, \"_silverAgeRate lower than nominal rate\");\r\n\r\n        platinumAgeEndBlock = _platinumAgeEndBlock;\r\n        goldenAgeEndBlock = _goldenAgeEndBlock;\r\n        silverAgeEndBlock = _silverAgeEndBlock;\r\n\r\n        platinumAgeRate = _platinumAgeRate;\r\n        goldenAgeRate = _goldenAgeRate;\r\n        silverAgeRate = _silverAgeRate;\r\n\r\n        emit LogThreePowerAgesChanged(\r\n            msg.sender,\r\n            _platinumAgeEndBlock,\r\n            _goldenAgeEndBlock,\r\n            _silverAgeEndBlock,\r\n            _platinumAgeRate,\r\n            _goldenAgeRate,\r\n            _silverAgeRate\r\n        );\r\n    }\r\n\r\n    function setTwoPowerAges(\r\n        uint256 _platinumAgeEndBlock,\r\n        uint256 _goldenAgeEndBlock,\r\n        uint256 _platinumAgeRate,\r\n        uint256 _goldenAgeRate\r\n    )\r\n    external onlyOwner beforeStart\r\n    {\r\n        require(startBlock <= _platinumAgeEndBlock, \"_platinumAgeEndBlock lower than start block\");\r\n        require(_platinumAgeEndBlock <= _goldenAgeEndBlock, \"_platinumAgeEndBlock greater than _goldenAgeEndBlock\");\r\n        require(_goldenAgeEndBlock <= endBlock, \"_goldenAgeEndBlock greater than end block\");\r\n        require(_platinumAgeRate >= _goldenAgeRate, \"_platinumAgeRate lower than _goldenAgeRate\");\r\n        require(_goldenAgeRate >= rate, \"_goldenAgeRate lower than nominal rate\");\r\n\r\n        platinumAgeEndBlock = _platinumAgeEndBlock;\r\n        goldenAgeEndBlock = _goldenAgeEndBlock;\r\n\r\n        platinumAgeRate = _platinumAgeRate;\r\n        goldenAgeRate = _goldenAgeRate;\r\n\r\n        emit LogTwoPowerAgesChanged(\r\n            msg.sender,\r\n            _platinumAgeEndBlock,\r\n            _goldenAgeEndBlock,\r\n            _platinumAgeRate,\r\n            _goldenAgeRate\r\n        );\r\n    }\r\n\r\n    function setOnePowerAge(uint256 _platinumAgeEndBlock, uint256 _platinumAgeRate)\r\n    external onlyOwner beforeStart\r\n    {\r\n        require(startBlock <= _platinumAgeEndBlock, \"_platinumAgeEndBlock lower than start block\");\r\n        require(_platinumAgeEndBlock <= endBlock, \"_platinumAgeEndBlock greater than end block\");\r\n        require(_platinumAgeRate >= rate, \"_platinumAgeRate lower than nominal rate\");\r\n\r\n        platinumAgeEndBlock = _platinumAgeEndBlock;\r\n        platinumAgeRate = _platinumAgeRate;\r\n\r\n        emit LogOnePowerAgeChanged(msg.sender, _platinumAgeEndBlock, _platinumAgeRate);\r\n    }\r\n\r\n    // Overriding Crowdsale#calculateTokens to apply age discounts to token calculus.\r\n    function calculateTokens(uint256 amount) internal view returns(uint256 tokenAmount) {\r\n        uint256 conversionRate = block.number <= platinumAgeEndBlock ? platinumAgeRate :\r\n            block.number <= goldenAgeEndBlock ? goldenAgeRate :\r\n            block.number <= silverAgeEndBlock ? silverAgeRate :\r\n            rate;\r\n\r\n        return amount.mul(conversionRate);\r\n    }\r\n\r\n    /**\r\n     * @dev Overriding Crowdsale#distributeTokens to apply age rules to token distributions.\r\n     */\r\n    function distributeTokens(address beneficiary, uint256 tokenAmount) internal {\r\n        if (block.number <= platinumAgeEndBlock) {\r\n            NokuCustomERC20(token).mintLocked(beneficiary, tokenAmount);\r\n        }\r\n        else {\r\n            super.distributeTokens(beneficiary, tokenAmount);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Overriding Crowdsale#forwardFunds to split net/fee payment.\r\n     */\r\n    function forwardFunds(uint256 amount) internal {\r\n        wallet.transfer(amount);\r\n    }\r\n}\r\n\r\n// File: contracts/NokuCustomService.sol\r\n\r\ncontract NokuCustomService is Pausable {\r\n    using AddressUtils for address;\r\n\r\n    event LogPricingPlanChanged(address indexed caller, address indexed pricingPlan);\r\n\r\n    // The pricing plan determining the fee to be paid in NOKU tokens by customers\r\n    NokuPricingPlan public pricingPlan;\r\n\r\n    constructor(address _pricingPlan) internal {\r\n        require(_pricingPlan.isContract(), \"_pricingPlan is not contract\");\r\n\r\n        pricingPlan = NokuPricingPlan(_pricingPlan);\r\n    }\r\n\r\n    function setPricingPlan(address _pricingPlan) public onlyOwner {\r\n        require(_pricingPlan.isContract(), \"_pricingPlan is not contract\");\r\n        require(NokuPricingPlan(_pricingPlan) != pricingPlan, \"_pricingPlan equal to current\");\r\n        \r\n        pricingPlan = NokuPricingPlan(_pricingPlan);\r\n\r\n        emit LogPricingPlanChanged(msg.sender, _pricingPlan);\r\n    }\r\n}\r\n\r\n// File: contracts/NokuCustomCrowdsaleService.sol\r\n\r\n/**\r\n * @title NokuCustomCrowdsaleService\r\n * @dev Extension of NokuCustomService adding the fee payment in NOKU tokens.\r\n */\r\ncontract NokuCustomCrowdsaleService is NokuCustomService {\r\n    event LogNokuCustomCrowdsaleServiceCreated(address indexed caller);\r\n\r\n    bytes32 public constant SERVICE_NAME = \"NokuCustomERC20.crowdsale\";\r\n    uint256 public constant CREATE_AMOUNT = 1 * 10**18;\r\n\r\n    constructor(address _pricingPlan) NokuCustomService(_pricingPlan) public {\r\n        emit LogNokuCustomCrowdsaleServiceCreated(msg.sender);\r\n    }\r\n\r\n    function createCustomCrowdsale(\r\n        uint256 _startBlock,\r\n        uint256 _endBlock,\r\n        uint256 _rate,\r\n        uint256 _minDeposit,\r\n        uint256 _maxWhitelistLength,\r\n        uint256 _whitelistThreshold,\r\n        address _token,\r\n        uint256 _tokenMaximumSupply,\r\n        address _wallet\r\n    )\r\n    public returns(NokuCustomCrowdsale customCrowdsale)\r\n    {\r\n        customCrowdsale = new NokuCustomCrowdsale(\r\n            _startBlock,\r\n            _endBlock,\r\n            _rate,\r\n            _minDeposit,\r\n            _maxWhitelistLength,\r\n            _whitelistThreshold,\r\n            _token,\r\n            _tokenMaximumSupply,\r\n            _wallet\r\n        );\r\n\r\n        // Transfer NokuCustomCrowdsale ownership to the client\r\n        customCrowdsale.transferOwnership(msg.sender);\r\n\r\n        require(pricingPlan.payFee(SERVICE_NAME, CREATE_AMOUNT, msg.sender), \"fee payment failed\");\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_startBlock\",\"type\":\"uint256\"},{\"name\":\"_endBlock\",\"type\":\"uint256\"},{\"name\":\"_rate\",\"type\":\"uint256\"},{\"name\":\"_minDeposit\",\"type\":\"uint256\"},{\"name\":\"_maxWhitelistLength\",\"type\":\"uint256\"},{\"name\":\"_whitelistThreshold\",\"type\":\"uint256\"},{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_tokenMaximumSupply\",\"type\":\"uint256\"},{\"name\":\"_wallet\",\"type\":\"address\"}],\"name\":\"createCustomCrowdsale\",\"outputs\":[{\"name\":\"customCrowdsale\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_pricingPlan\",\"type\":\"address\"}],\"name\":\"setPricingPlan\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pricingPlan\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"SERVICE_NAME\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CREATE_AMOUNT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_pricingPlan\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"caller\",\"type\":\"address\"}],\"name\":\"LogNokuCustomCrowdsaleServiceCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"pricingPlan\",\"type\":\"address\"}],\"name\":\"LogPricingPlanChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"}],\"name\":\"OwnershipRenounced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"NokuCustomCrowdsaleService","CompilerVersion":"v0.4.23+commit.124ca40d","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000749aba9e082ccb185d1ef88fa514339e3c3368d3","Library":"","SwarmSource":"bzzr://5cc0b7186e8da82278677f4debcef59dafaf03c7cffacf4e088cd05c6dc19325"}]}