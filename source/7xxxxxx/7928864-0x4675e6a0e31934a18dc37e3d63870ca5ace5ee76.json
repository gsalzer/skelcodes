{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity >=0.4.22 <0.6.0;\r\n\r\ncontract Ownable {\r\n    address payable public owner;\r\n    address payable public developer;\r\n\r\n\r\n    event OwnershipRenounced(address indexed previousOwner);\r\n    event OwnershipTransferred(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n\r\n\r\n    /**\r\n    * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n    * account.\r\n    */\r\n    constructor() public {\r\n        // owner = msg.sender;\r\n        owner = msg.sender;\r\n        developer = 0x67264cB47c717838Ae684F22E686d6f35dA90981;\r\n    }\r\n\r\n    /**\r\n    * @dev Throws if called by any account other than the owner.\r\n    */\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"Only Owner Can Do This\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyDeveloper() {\r\n        require(msg.sender == developer, \"Only Developer Can Do This\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev Allows the current owner to relinquish control of the contract.\r\n    * @notice Renouncing to ownership will leave the contract without an owner.\r\n    * It will not be possible to call the functions with the `onlyOwner`\r\n    * modifier anymore.\r\n    */\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipRenounced(owner);\r\n        owner = address(0);\r\n    }\r\n\r\n    function renounceDevelopership() public onlyDeveloper {\r\n        // emit OwnershipRenounced(owner);\r\n        developer = address(0);\r\n    }\r\n\r\n    /**\r\n    * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n    * @param _newOwner The address to transfer ownership to.\r\n    */\r\n    function transferOwnership(address payable _newOwner) public onlyOwner {\r\n        _transferOwnership(_newOwner);\r\n    }\r\n\r\n    function transferDevelopership(address payable _newDeveloper) public onlyDeveloper {\r\n        require(_newDeveloper != address(0), \"New Developer's Address is Required\");\r\n        // emit OwnershipTransferred(owner, _newOwner);\r\n        developer = _newDeveloper;\r\n    }\r\n\r\n    /**\r\n    * @dev Transfers control of the contract to a newOwner.\r\n    * @param _newOwner The address to transfer ownership to.\r\n    */\r\n    function _transferOwnership(address payable _newOwner) internal {\r\n        require(_newOwner != address(0), \"New Owner's Address is Required\");\r\n        emit OwnershipTransferred(owner, _newOwner);\r\n        owner = _newOwner;\r\n    }\r\n}\r\n\r\ncontract Pausable is Ownable {\r\n    event Pause();\r\n    event Unpause();\r\n\r\n    bool public paused = false;\r\n\r\n\r\n    /**\r\n    * @dev Modifier to make a function callable only when the contract is not paused.\r\n    */\r\n    modifier whenNotPaused() {\r\n        require(!paused);\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev Modifier to make a function callable only when the contract is paused.\r\n    */\r\n    modifier whenPaused() {\r\n        require(paused);\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev called by the owner to pause, triggers stopped state\r\n    */\r\n    function pause() public onlyOwner whenNotPaused {\r\n        paused = true;\r\n        emit Pause();\r\n    }\r\n\r\n    /**\r\n    * @dev called by the owner to unpause, returns to normal state\r\n    */\r\n    function unpause() public onlyOwner whenPaused {\r\n        paused = false;\r\n        emit Unpause();\r\n    }\r\n}\r\n\r\nlibrary SafeMath {\r\n    int256 constant private INT256_MIN = -2**255;\r\n\r\n    /**\r\n    * @dev Multiplies two unsigned integers, reverts on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Multiplies two signed integers, reverts on overflow.\r\n    */\r\n    function mul(int256 a, int256 b) internal pure returns (int256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        require(!(a == -1 && b == INT256_MIN)); // This is the only case of overflow not detected by the check below\r\n\r\n        int256 c = a * b;\r\n        require(c / a == b);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two signed integers truncating the quotient, reverts on division by zero.\r\n    */\r\n    function div(int256 a, int256 b) internal pure returns (int256) {\r\n        require(b != 0); // Solidity only automatically asserts when dividing by 0\r\n        require(!(b == -1 && a == INT256_MIN)); // This is the only case of overflow\r\n\r\n        int256 c = a / b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two signed integers, reverts on overflow.\r\n    */\r\n    function sub(int256 a, int256 b) internal pure returns (int256) {\r\n        int256 c = a - b;\r\n        require((b >= 0 && c <= a) || (b < 0 && c > a));\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two unsigned integers, reverts on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two signed integers, reverts on overflow.\r\n    */\r\n    function add(int256 a, int256 b) internal pure returns (int256) {\r\n        int256 c = a + b;\r\n        require((b >= 0 && c >= a) || (b < 0 && c < a));\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\r\n    * reverts when dividing by zero.\r\n    */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}\r\n\r\ncontract Fishbowl is Ownable ,Pausable{\r\n\r\n    using SafeMath for uint;\r\n\r\n    uint[9] fishBowlSize = [0,2000,3000,4000,7000,9000,10000,14000,17000]; //等級、尺寸轉換表\r\n    uint[9] fishBowlLevelByAmount = [0,1,5,10,30,50,100,150,200]; //魚數、魚缸等級對照表\r\n    address private playerBookAddress;\r\n\r\n    event setPlayerBookAddrEvent(address _newPlayerBookAddr, uint _time);\r\n\r\n    constructor(address _playerBookAddress) public{\r\n        playerBookAddress = _playerBookAddress;\r\n    }\r\n\r\n    /* @dev only transaction system can call */\r\n    modifier onlyForPlayerBook(){\r\n        // require(msg.sender == playerBookAddress, \"Only for palyerBook contract!\");\r\n        _;\r\n    }\r\n\r\n    /* @dev\r\n        (魚缸升級(lv8前)、新魚缸)\r\n        將購魚數量與魚價傳入，回傳玩家專屬魚缸資訊(新購入及升級) -> 呼叫player函數設定值 -> return 給player使用\r\n        uint level; //等級\r\n        uint fodderFee; //需支付的飼料費用(魚價*購魚數)\r\n        uint fishbowlSize; //魚缸倍數\r\n        uint admissionPrice; //基礎入場價格(魚價*購魚數*2)\r\n        uint amountToSale; //可銷售總額(基礎入場價格*魚缸倍數)\r\n    */\r\n    function fishBowl(uint _totalFishPrice, uint _fishAmount)\r\n    public view onlyForPlayerBook returns(uint fishbowlLevel, uint fishbowlSize, uint admissionPrice, uint amountToSale)\r\n    {\r\n        uint _fishbowlLevel = getFishBowlLevel(_fishAmount);\r\n        uint _fishbowlSize = getFishbowlSize(_fishbowlLevel);\r\n        uint _admissionPrice = getAdmissionPrice(_totalFishPrice);\r\n        uint _amountToSale = getAmountToSale(_fishbowlLevel, _admissionPrice);\r\n\r\n        return (_fishbowlLevel, _fishbowlSize, _admissionPrice, _amountToSale);\r\n    }\r\n\r\n    /* @dev\r\n        (多重購魚(lv8後))將原先的基礎入場價格及可購買總額、這次多重購魚購買魚數及魚價傳入，回傳多重購魚後基礎入場價格及可銷售總額\r\n        @notice 魚價單位轉換\r\n    */\r\n    function multipleBuy(uint _totalFishPrice, uint _oldAdmissionPrice, uint _oldAmountToSale)\r\n    public view onlyForPlayerBook returns(uint newAdmissionPrice, uint newAmountToSale)\r\n    {\r\n        uint _admissionPrice = getAdmissionPrice(_totalFishPrice);\r\n        uint _newAdmissionPrice = _admissionPrice.add(_oldAdmissionPrice);\r\n        uint _newAmountToSale = getAmountToSale(8, _admissionPrice).add(_oldAmountToSale);\r\n\r\n        return (_newAdmissionPrice, _newAmountToSale);\r\n    }\r\n\r\n    /*@dev 將購魚數量傳入，回傳魚缸等級 */\r\n    function getFishBowlLevel(uint _fishAmount) public view onlyForPlayerBook returns(uint fishbowlLevel){\r\n        for(uint i = 0; i < 9; i++){\r\n            if( _fishAmount == fishBowlLevelByAmount[i]){\r\n                return i;\r\n            }\r\n        }\r\n    }\r\n\r\n    /*@dev 將購魚數量與魚價傳入，回傳飼料費(魚價*購魚數) */\r\n    function getFodderFee(uint _fishPrice, uint _fishAmount) public pure onlyForPlayerBook returns(uint fodderFee){\r\n        return _fishPrice.mul(_fishAmount);\r\n    }\r\n\r\n    /*@dev 將魚缸等級傳入，回傳魚缸尺寸 */\r\n    function getFishbowlSize(uint _fishbowlLevel) public view onlyForPlayerBook returns(uint fishbowlSize){\r\n        return fishBowlSize[_fishbowlLevel];\r\n    }\r\n\r\n    /*@dev 將購魚總價傳入，回傳基礎入場價格(購魚總價*2)*/\r\n    function getAdmissionPrice(uint _totalFishPrice) public pure onlyForPlayerBook returns(uint admissionPrice){\r\n        return _totalFishPrice.mul(2);\r\n    }\r\n\r\n    /*@dev 將魚缸等級、基礎入場價格傳入，回傳可銷售總額(基礎入場價格*魚缸倍數) */\r\n    function getAmountToSale(uint _fishbowlLevel, uint _admissionPrice)\r\n    public view onlyForPlayerBook returns(uint amountToSale)\r\n    {\r\n        return _admissionPrice.mul(getFishbowlSize(_fishbowlLevel));\r\n    }\r\n\r\n    /*@dev set playerbookAddr */\r\n    function setPlayerBookAddr(address _newPlayerBookAddr) public onlyOwner{\r\n        playerBookAddress = _newPlayerBookAddr;\r\n\r\n        emit setPlayerBookAddrEvent(_newPlayerBookAddr, now);\r\n    }\r\n\r\n    /*@dev get playerbookAddr */\r\n    function getPlayerBookAddr() public view returns(address _playerBookAddress){\r\n        return playerBookAddress;\r\n    }\r\n\r\n}\r\n\r\ncontract TransactionSystem is Ownable{\r\n\tusing SafeMath for uint;\r\n\tusing SafeMath for int;\r\n\r\n\tstruct GlobalData {\r\n\t\tuint fishAmount; // -> still alive fishAmount\r\n\t\tuint fishPrice;\r\n\t\tuint systemTotalFishAmount; //掛新單子用 \r\n\t\tuint selledAmount; //累積銷售魚數\r\n\t\tuint[7] priceInterval;\r\n\t}\r\n\r\n\tstruct PlayerSellOrderData {\r\n\t\taddress payable owner;\r\n\t\tuint fishAmount;\r\n\t\tuint fishPrice;\r\n\t\tuint round;\r\n\t}\r\n\r\n\tstruct Queue{\r\n\t\tuint[] idList;\r\n\t\tuint front;\r\n\t}\r\n\r\n\t/* Config public variables */\r\n\tuint constant public INIT_FISHAMOUNT = 10000;\r\n\tuint constant public INIT_FISHPRICE = 50 finney; // 50 * (10 ** 15) = 0.05ETH\r\n\t// uint constant public INIT_FISHPRICE = 91 finney; // 50 * (10 ** 15) = 0.05ETH\r\n\t\r\n\t/* Global data for the entire game */\r\n\tGlobalData globalData;\r\n\r\n\t/* Player book inplement*/\r\n\tPlayerBook playerBook = PlayerBook(0x0);\r\n\taddress payable public playerBookAddress;\r\n\r\n\t/* order data */\r\n\tmapping(uint => uint) private priceTotalFishAmount; //每個價位玩家總共幾條魚(只有賣單)\r\n\tmapping(uint => Queue) public sellOrderSequence; // [價格] 單子[] (賣單)\r\n\r\n\t/* address query */\r\n\tmapping(address => uint) private personSellOrders; //每個人還在的賣單紀錄\r\n\r\n\t// Order Stored\r\n\tPlayerSellOrderData[] private sellOrders; //全部的賣單\r\n\r\n\t/* 系統坊賣單 */\r\n\tmapping(uint => uint) systemFishAmount; //價格 對應的魚數\r\n\tuint systemFishPriceCumulativeCount;\r\n\r\n\t// 長肉模式用\r\n\tbool public isFleshUp; //是否為長肉的 flag，true 代表是\r\n\tuint public fleshUpCount; //長肉模式總共會賣出的魚數\r\n\tbool public haveFish; //區間還有多少魚\r\n\r\n\t// 紀錄繁殖區塊\r\n\tuint[] private reproductionBlockNumbers;\r\n\r\n\tevent changePriceEvent(address indexed _contract, uint indexed _price, uint _timestamp);\r\n\tevent orderEvent(address indexed _from, uint _amount, uint _timestamp);\r\n\tevent fleshUpEvent(uint _price, uint fleshUpCount, uint _timestamp);\r\n\r\n\t/* contructor */\r\n\tconstructor() public {\r\n\t\tglobalData = GlobalData({\r\n\t\t\tfishAmount: INIT_FISHAMOUNT,\r\n\t\t\tfishPrice: INIT_FISHPRICE,\r\n\t\t\tsystemTotalFishAmount: 0,\r\n\t\t\tselledAmount: 0,\r\n\t\t\tpriceInterval: [uint256(50 finney), uint256(51 finney), uint256(52 finney), uint256(53 finney), uint256(54 finney), uint256(55 finney), uint256(56 finney)]\r\n\t\t\t// priceInterval: [uint256(93 finney), uint256(94 finney), uint256(95 finney), uint256(96 finney), uint256(97 finney), uint256(98 finney), uint256(99 finney)]\r\n\t\t});\r\n\t\tisFleshUp = false;\r\n\t\t/* Initial order setup */\r\n\t\t/* @dev\r\n\t\t\t1.初始系統庫存魚數:10000 \r\n\t\t\t2.交易系統中已顯示的 7 個價位,第一優先掛賣庫存魚數的 2% 取整數計算(無條件捨去)。 \r\n\t\t\t3.交易系統中出現新價位(高價格)時, 第一優先掛賣庫存魚數的 2%, 取整數計算(無條件捨去)。 \r\n\t\t*/\r\n\t\tglobalData.systemTotalFishAmount = INIT_FISHAMOUNT;\r\n\t\t// globalData.systemTotalFishAmount = 6000;\r\n\t\tfor (uint orderPrice = INIT_FISHPRICE; orderPrice < INIT_FISHPRICE.add(7 finney); orderPrice = orderPrice.add(1 finney)) {\r\n\t\t\tsystemFishAmount[orderPrice] = 200;\r\n\t\t}/*\r\n\t\tsystemFishAmount[97 finney] = 200;\r\n\t\tsystemFishAmount[98 finney] = 39;\r\n\t\tsystemFishAmount[99 finney] = 123;\r\n\t\tfleshUpCount = 700;\r\n\t\tisFleshUp = true;*/\r\n\t\treproductionBlockNumbers.push(0);\r\n\t\tsystemFishPriceCumulativeCount = 56 finney; //初始累進最高價位為 56\r\n\t\t// systemFishPriceCumulativeCount = 99 finney; //初始累進最高價位為 56\r\n\t}\r\n\r\n\t//only call from playerbook is allowed\r\n\tmodifier onlyPlayerBook() {\r\n\t\trequire(msg.sender == playerBookAddress);\r\n\t\t_;\r\n\t}\r\n\r\n\t//if u want to make a donation... <3\r\n\tfunction() payable external{\r\n\t\tplayerBookAddress.transfer(msg.value);\r\n\t}\r\n\r\n\t\r\n\t/* @dev\r\n\t\t0. need setup playerBookAddress first\r\n\t\t1. all call should from playerBook (this contract should not get any ETH)\r\n\t\t2. price should been preprocess from playerBook\r\n\t*/\r\n\t//買魚並記錄金額。\r\n\tfunction addNewBuyOrder(address payable _buyer, uint _fishAmount, uint _balance, bool _isRebuy)\r\n\t\tpublic\r\n\t\tonlyPlayerBook()\r\n\t{\r\n\t\t//require(_fishAmount <= 200); //max value //或是 playerbook 檢查\r\n\t\t/* @dev\r\n\t\t\t魚價範圍 0.05~0.1ETH ，以 0.001 為一個檔位做跳動. -> 50~100\r\n\t\t\t每個檔位最高可掛賣數量為總可交易魚數的 5%, \r\n\t\t*/\r\n\r\n\t\t//addFishAmount -> 處理買家飼料費\r\n\t\t//sellerProcessProfit -> 處理賣家獲利\r\n\t\t//交易總共投入金額\r\n\t\tuint totalCost = 0; //處理跨價購買的問題\r\n\t\tuint _addFishAmount = 0; //總共要增加的魚數\r\n\t\tuint _tempRound = playerBook.reproductionRound();\r\n\r\n\t\tQueue storage Q = sellOrderSequence[globalData.fishPrice];\r\n\t\twhile(_fishAmount > 0){ \r\n\t\t\t//系統還有魚 -> 進入系統單\r\n\t\t\tif(systemFishAmount[globalData.fishPrice] > 0){ \r\n\t\t\t\t//系統能賣夠\r\n\t\t\t\tif(_fishAmount <= systemFishAmount[globalData.fishPrice]){\r\n\t\t\t\t\t//最終要新增的魚數量\r\n\t\t\t\t\t_addFishAmount = _addFishAmount.add(_fishAmount);\r\n\t\t\t\t\t//扣掉花費\r\n\t\t\t\t\t_balance = _balance.sub(_fishAmount.mul(globalData.fishPrice));\r\n\t\t\t\t\ttotalCost = totalCost.add(_fishAmount.mul(globalData.fishPrice));\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t//更新 player 狀態 //totalCost , isBuy\r\n\t\t\t\t\tplayerBook.addFishAmount(_buyer, _addFishAmount, totalCost, true);\r\n\t\t\t\t\t//更新全域賣出魚數\r\n\t\t\t\t\tglobalData.selledAmount = globalData.selledAmount.add(_fishAmount);\r\n\t\t\t\t\t//更新賣家\r\n\t\t\t\t\tplayerBook.sellerProcessProfit(playerBookAddress, _fishAmount.mul(globalData.fishPrice));\r\n\t\t\t\t\t//更新系統該價位魚的資訊\r\n\t\t\t\t\tsystemFishAmount[globalData.fishPrice] = systemFishAmount[globalData.fishPrice].sub(_fishAmount);\r\n\t\t\t\t\tglobalData.systemTotalFishAmount = globalData.systemTotalFishAmount.sub(_fishAmount);\r\n\t\t\t\t\t//減少要購買的數量\r\n\t\t\t\t\t_fishAmount = 0;\r\n\r\n\t\t\t\t\t//找零\r\n\t\t\t\t\tif(_balance > 0 && _isRebuy == false){ \r\n\t\t\t\t\t\tuint temp = _balance;\r\n\t\t\t\t\t\t_balance = 0;\r\n\t\t\t\t\t\tplayerBook.buyOrderRefund(_buyer, temp);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif( priceTotalFishAmount[globalData.fishPrice] == 0 && systemFishAmount[globalData.fishPrice] == 0 ){\r\n\t\t\t\t\t\tchangePriceInterval();\r\n\t\t\t\t\t\tQ = sellOrderSequence[globalData.fishPrice]; //To-Notice: 不知道這樣會不會 work\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}else{\r\n\t\t\t\t\t//要新增的魚數量\r\n\t\t\t\t\t_addFishAmount = _addFishAmount.add(systemFishAmount[globalData.fishPrice]);\r\n\t\t\t\t\t//減少要購買的數量\r\n\t\t\t\t\t_fishAmount = _fishAmount.sub(systemFishAmount[globalData.fishPrice]);\r\n\t\t\t\t\t//扣掉花費\r\n\t\t\t\t\t_balance = _balance.sub(systemFishAmount[globalData.fishPrice].mul(globalData.fishPrice));\r\n\t\t\t\t\ttotalCost = totalCost.add(systemFishAmount[globalData.fishPrice].mul(globalData.fishPrice));\r\n\t\t\t\t\t//不能更新 player 狀態，因為沒買完\r\n\t\t\t\t\t//更新全域賣出魚數\r\n\t\t\t\t\tglobalData.selledAmount = globalData.selledAmount.add(systemFishAmount[globalData.fishPrice]);\r\n\t\t\t\t\t//更新賣家\r\n\t\t\t\t\tplayerBook.sellerProcessProfit(playerBookAddress, systemFishAmount[globalData.fishPrice].mul(globalData.fishPrice));\r\n\t\t\t\t\t//更新系統該價位魚的資訊\r\n\t\t\t\t\tglobalData.systemTotalFishAmount = globalData.systemTotalFishAmount.sub(systemFishAmount[globalData.fishPrice]);\r\n\t\t\t\t\tsystemFishAmount[globalData.fishPrice] = 0;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t//系統處理完還有魚(不會 break) -> 進入玩家賣單\r\n\t\t\t\r\n\t\t\t//當玩家沒有賣單 -> 跳價格\r\n\t\t\tif( priceTotalFishAmount[globalData.fishPrice] == 0 ){\r\n\t\t\t\tchangePriceInterval();\r\n\t\t\t\tQ = sellOrderSequence[globalData.fishPrice]; //To-Notice: 不知道這樣會不會 work\r\n\t\t\t\tif ( playerBook.reproductionRound() > _tempRound ) {\r\n\t\t\t\t\t_addFishAmount = _addFishAmount.mul(2);\r\n\t\t\t\t\t_tempRound = playerBook.reproductionRound();\r\n\t\t\t\t}\r\n\t\t\t\tcontinue; //或可以把整個 if 放到迴圈末端\r\n\t\t\t}\r\n\r\n\t\t\t//檢查單子是否存在\r\n\t\t\tif(sellOrders[ Q.idList[Q.front] ].fishAmount <= 0){\r\n\t\t\t\tQ.front++;\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\t//處理繁殖次數 (amount = amount * 2**(globalRound - localRound))\r\n\t\t\tuint realAmount = sellOrders[ Q.idList[Q.front] ].fishAmount.mul( 2 **(playerBook.reproductionRound().sub(sellOrders[ Q.idList[Q.front] ].round)) );\r\n\t\t\t//魚的數量 overflow 可能另外檢查(?) (To-Notice)\r\n\r\n\t\t\tif(_fishAmount >= realAmount){\r\n\t\t\t\t//買的完，不用改賣單\r\n\r\n\t\t\t\t//要新增的魚數量\r\n\t\t\t\t_addFishAmount = _addFishAmount.add(realAmount);\r\n\t\t\t\t//減少要購買的數量\r\n\t\t\t\t_fishAmount = _fishAmount.sub(realAmount);\r\n\t\t\t\t//扣掉花費\r\n\t\t\t\t_balance = _balance.sub(realAmount.mul(globalData.fishPrice));\r\n\t\t\t\ttotalCost = totalCost.add(realAmount.mul(globalData.fishPrice));\r\n\r\n\t\t\t\t//不能更新 player 狀態，因為沒買完\r\n\t\t\t\t//更新全域賣出魚數\r\n\t\t\t\tglobalData.selledAmount = globalData.selledAmount.add(realAmount);\r\n\t\t\t\t//更新賣家\r\n\t\t\t\tplayerBook.sellerProcessProfit(sellOrders[ Q.idList[Q.front] ].owner, realAmount.mul(globalData.fishPrice));\r\n\t\t\t\tdelete sellOrders[ Q.idList[Q.front] ]; //刪除該筆賣單\r\n\t\t\t\tdelete Q.idList[Q.front]; //刪除該筆排序\r\n\t\t\t\t//更新該價位魚的總量\r\n\t\t\t\tpriceTotalFishAmount[globalData.fishPrice] = priceTotalFishAmount[globalData.fishPrice].sub(realAmount);\r\n\t\t\t\t//下一筆賣單\r\n\t\t\t\tQ.front++;\r\n\t\t\t}else{ \r\n\t\t\t\t//剩下要購買的魚數量 < 賣單的\r\n\t\t\t\t//買完了，但買不完賣單，修改賣單魚數\r\n\t\t\t\t//注意 realFishAmount (To-Notice)\r\n\r\n\t\t\t\t//要新增的魚數量 \r\n\t\t\t\t_addFishAmount = _addFishAmount.add(_fishAmount);\r\n\t\t\t\t\t\r\n\t\t\t\t//扣掉花費\r\n\t\t\t\t_balance = _balance.sub(_fishAmount.mul(globalData.fishPrice));\r\n\t\t\t\ttotalCost = totalCost.add(_fishAmount.mul(globalData.fishPrice));\r\n\t\t\t\t\t\r\n\t\t\t\t//更新 player 狀態 //isBuy\r\n\t\t\t\tplayerBook.addFishAmount(_buyer, _addFishAmount, totalCost, true);\r\n\t\t\t\t//更新全域賣出魚數\r\n\t\t\t\tglobalData.selledAmount = globalData.selledAmount.add(_fishAmount);\r\n\t\t\t\t//更新賣家\r\n\t\t\t\tplayerBook.sellerProcessProfit(sellOrders[ Q.idList[Q.front] ].owner, _fishAmount.mul(globalData.fishPrice));\r\n\t\t\t\t//更新賣單的狀態\r\n\t\t\t\tsellOrders[ Q.idList[Q.front] ].fishAmount = realAmount.sub(_fishAmount);\r\n\t\t\t\tsellOrders[ Q.idList[Q.front] ].round = playerBook.reproductionRound();\r\n\r\n\t\t\t\t//更新該價位魚的總量\r\n\t\t\t\tpriceTotalFishAmount[globalData.fishPrice] = priceTotalFishAmount[globalData.fishPrice].sub(_fishAmount);\r\n\t\t\t\t\t\r\n\t\t\t\t//減少要購買的數量\r\n\t\t\t\t_fishAmount = 0;\r\n\r\n\t\t\t\t//找零\r\n\t\t\t\tif(_balance > 0 && _isRebuy == false){ \r\n\t\t\t\t\tuint temp = _balance;\r\n\t\t\t\t\t_balance = 0;\r\n\t\t\t\t\tplayerBook.buyOrderRefund(_buyer, temp);\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\temit orderEvent(_buyer, _addFishAmount, now);\r\n\t}\r\n\r\n\tfunction getEstimateFishPrice(uint _fishAmount) external view returns(uint){\r\n\t\tuint tempBalance = 0;\r\n\t\tuint tempFishPrice = globalData.fishPrice;\r\n\t\tuint tempFishAmount = _fishAmount;\r\n\t\tbool tempJumpPrice = isFleshUp;\r\n\t\tuint tempfleshUpCount = fleshUpCount;\r\n\t\twhile(tempFishAmount > 0){\r\n\t\t\t//To-Notice 跳價格後的價格區間\r\n\t\t\t//價格往下跳不管\r\n\t\t\tif(systemFishAmount[tempFishPrice] >= tempFishAmount || tempFishPrice > globalData.priceInterval[6]){//99->100 100\r\n\t\t\t\t// > priceInterval[6] 代表跑到最新的系統單去了\r\n\t\t\t\ttempBalance = tempBalance.add(tempFishAmount.mul(tempFishPrice));\r\n\t\t\t\ttempFishAmount = 0;\r\n\t\t\t\tbreak;\t\t\r\n\t\t\t}else{\r\n\t\t\t\ttempFishAmount = tempFishAmount.sub(systemFishAmount[tempFishPrice]);//減掉該價位所有魚\r\n\t\t\t\ttempBalance = tempBalance.add(systemFishAmount[tempFishPrice].mul(tempFishPrice));//花費增加\r\n\t\t\t\tif(priceTotalFishAmount[tempFishPrice] > tempFishAmount){\r\n\t\t\t\t\ttempBalance = tempBalance.add(tempFishAmount.mul(tempFishPrice));\r\n\t\t\t\t\ttempFishAmount = 0;\r\n\t\t\t\t\tbreak;\t\r\n\t\t\t\t}else{\r\n\t\t\t\t\ttempFishAmount = tempFishAmount.sub(priceTotalFishAmount[tempFishPrice]);\r\n\t\t\t\t\ttempBalance = tempBalance.add(priceTotalFishAmount[tempFishPrice].mul(tempFishPrice));\r\n\t\t\t\t}\t\r\n\t\t\t}\r\n\r\n\t\t\t//價格變動方向\r\n\t\t\tif(tempJumpPrice == false){//不是長肉就正常跳價\r\n\t\t\t\t//跑完所有顯示過的價位後沒變動的話，目前價位 + 1\r\n\t\t\t\ttempFishPrice = tempFishPrice.add(1 finney);\r\n\t\t\t\tfor(uint i = tempFishPrice; i < 100 finney; i = i.add(1 finney)){\r\n\t\t\t\t\tif(priceTotalFishAmount[i] > 0 || systemFishAmount[i] > 0){\r\n\t\t\t\t\t\ttempFishPrice = i; \r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t}else if(tempFishPrice == globalData.priceInterval[6]){ //長肉結束，跳到新的價位 -> 不一定超過 globalData.priceInterval[6]\r\n\t\t\t\t//會進到 else 代表 isFleshUp == true\r\n\t\t\t\ttempJumpPrice = false;\r\n\t\t\t\t//清空累計銷售\r\n\t\t\t\t//globalData.selledAmount = 0;\r\n\t\t\t\t// 678 * 100 / 10000 = 6.78\r\n\t\t\t\tif(tempFishPrice == 99 finney){//如果為準繁殖 -> 下一輪\r\n\t\t\t\t\ttempFishPrice = 100 finney;\r\n\t\t\t\t}else{\r\n\t\t\t\t\ttempFishPrice = tempFishPrice.add( tempfleshUpCount.mul(100).div(globalData.fishAmount).mul(1 finney) ); //要加的價位\r\n\t\t\t\t\tif(tempfleshUpCount.mul(100) % globalData.fishAmount > 0){ //無條件進位\r\n\t\t\t\t\t\ttempFishPrice = tempFishPrice.add(1 finney);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif(tempFishPrice > 99 finney){ //估價的部分可以多估\r\n\t\t\t\t\t\ttempFishPrice = 101 finney;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}else if(tempJumpPrice == true || globalData.selledAmount.add(_fishAmount - tempFishAmount).mul(50) >= globalData.fishAmount){ //這邊處理到新價位後，達到長肉 2% 的狀況\r\n\t\t\t\tif(tempJumpPrice == false){\r\n\t\t\t\t\ttempfleshUpCount = 0; //第一次進入，把凍結區間的總魚數歸零\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfor(uint i = globalData.priceInterval[0]; i <= globalData.priceInterval[6] && tempJumpPrice == false; i += 1 finney){\r\n\t\t\t\t\t//第一次進入，紀錄凍結後的總魚數\r\n\t\t\t\t\ttempfleshUpCount += priceTotalFishAmount[i];\r\n\t\t\t\t\ttempfleshUpCount += systemFishAmount[i];\r\n\t\t\t\t}\r\n\t\t\t\ttempJumpPrice = true; //鎖住掛賣\r\n\t\t\t\ttempFishPrice = tempFishPrice.add(1 finney);\r\n\t\t\t\t//7檔位不動\r\n\t\t\t}\r\n\t\t} \r\n\t\ttempBalance = tempBalance.mul(110);\r\n\t\ttempBalance = tempBalance.div(100);\r\n\t\treturn tempBalance;\r\n\t}\r\n\r\n\t/* Add new order to the contract */\r\n\tfunction addNewSellOrder(address payable _seller, uint _fishAmount, uint _fishPrice) \r\n\t\tpublic \r\n\t\tonlyPlayerBook()\r\n\t{\r\n\t\t/*\r\n\t\t\t每個檔位最高可掛賣數量為總可交易魚數的 2%\r\n\t\t\t玩家只能掛 10% -> PB 檢查\r\n\t\t*/\r\n\t\t//長肉不可掛單\r\n\t\trequire(isFleshUp == false, \"isFleshUp\");\r\n\r\n\t\t//check is legal price interval\r\n\t\tif(_fishPrice == globalData.fishPrice\r\n\t\t\t|| _fishPrice < globalData.priceInterval[0] \r\n\t\t\t|| (_fishPrice > globalData.priceInterval[6] && _fishPrice != 100 finney)\r\n\t\t){\r\n\t\t\trevert(\"out of range\");\r\n\t\t}\r\n\r\n\t\t/*\r\n\t\t\t當魚的時價來到 0.099 時進入準繁殖狀態, 所有<0.99價位不可掛賣\r\n\t\t\t系統只會出現 0.099 跟 0.1  這 2 個價位   \r\n\t\t\t0.1 價位為預掛單 <- ,總掛賣量上限為總可交易魚數的 3% \r\n\t\t*/\r\n\t\t// only price=99 then allow price=100 orders\r\n\t\tif(globalData.fishPrice < 99 finney && _fishPrice > 99 finney){\r\n\t\t\trevert(\"out of range\");\r\n\t\t}\r\n\t\t// if global price>=99 only 0.1 ETH orders is allowed\r\n\t\tif(globalData.fishPrice >= 99 finney && _fishPrice != 100 finney){\r\n\t\t\trevert(\"0.099 only allowed 0.1 eth\");\r\n\t\t}\r\n\r\n\t\t//not current price legal amount (2% allowed)\r\n\t\tif( priceTotalFishAmount[_fishPrice].add(systemFishAmount[_fishPrice]).add(_fishAmount).mul(50) > globalData.fishAmount ){\r\n\t\t\trevert(\"no more than 2% total fishAmount\");\r\n\t\t}\r\n\t\tif(globalData.fishPrice == 99 finney && priceTotalFishAmount[50 finney].add(systemFishAmount[50 finney]).add(_fishAmount).mul(25) > globalData.fishAmount ){\r\n\t\t\trevert(\"no more than 2% total fishAmount\");\r\n\t\t}\r\n\r\n\t\trequire(_fishAmount > 0, \"no zero fish\"); //不能掛 0 條\r\n\r\n\t\trequire(_fishPrice % (1 finney) == 0, \"illegal price\");\r\n\r\n\t\t//檢查是否已有掛單\r\n\t\trequire(sellOrders.length == 0 || sellOrders[ personSellOrders[_seller] ].owner != _seller, \"already exist\");\r\n\r\n\t\t//reduce _seller fishAmount\r\n\t\tplayerBook.minusFishAmount(_seller, _fishAmount);\r\n\t\t\r\n\t\t//add Order\r\n\t\tuint sellOrdersCount = sellOrders.length;\r\n\t\tif(_fishPrice == 100 finney){ //100 的玩家單其實為下一輪 50 的玩家掛單\r\n\t\t\t_fishAmount = _fishAmount.mul(2);\r\n\t\t\t_fishPrice = 50 finney;\r\n\t\t\tsellOrders.push( PlayerSellOrderData({\r\n\t\t\t\towner: _seller,\r\n\t\t\t\tfishAmount: _fishAmount,\r\n\t\t\t\tfishPrice: _fishPrice,\r\n\t\t\t\t//要記錄繁殖階段\r\n\t\t\t\tround: playerBook.reproductionRound().add(1)\r\n\t\t\t}) );\r\n\t\t}else{\r\n\t\t\tsellOrders.push( PlayerSellOrderData({\r\n\t\t\t\towner: _seller,\r\n\t\t\t\tfishAmount: _fishAmount,\r\n\t\t\t\tfishPrice: _fishPrice,\r\n\t\t\t\t//要記錄繁殖階段\r\n\t\t\t\tround: playerBook.reproductionRound()\r\n\t\t\t}) );\r\n\t\t}\r\n\r\n\t\t//更新該價位整體魚數\r\n\t\tpriceTotalFishAmount[_fishPrice] = priceTotalFishAmount[_fishPrice].add(_fishAmount);\r\n\t\t// Can improve by double-linked-list (or Not?)\r\n\t\tpersonSellOrders[_seller] = sellOrdersCount; //owner\r\n\t\tsellOrderSequence[_fishPrice].idList.push(sellOrdersCount); //system\r\n\r\n\t\temit orderEvent(_seller, _fishAmount, now);\r\n\t}\r\n\r\n\r\n\t// Cancel sell order \r\n\tfunction cancelSellOrder(address payable _caller, uint _orderId)\r\n\t\tpublic\r\n\t\tonlyPlayerBook()\r\n\t{\r\n\t\tif(sellOrders.length <= _orderId){\r\n\t\t\trevert(\"id error\");\r\n\t\t}\r\n\r\n\t\tif(sellOrders[_orderId].owner != _caller){ //less gas cost, since cancel probably fail\r\n\t\t\trevert(\"only owner\");\r\n\t\t}\r\n\r\n\t\tif(globalData.fishPrice == 99 finney && sellOrders[_orderId].fishPrice == 50 finney){ //避免被在價位 99 用來洗 50 的魚數\r\n\t\t\trevert(\"0.099 not allowed cancel 0.1 eth order\");\r\n\t\t}\r\n\r\n\t\trequire(isFleshUp == false, \"isFleshUp\");\r\n\r\n\t\t//處理魚繁殖問題\r\n\t\tuint tempFishAmount = sellOrders[_orderId].fishAmount.mul(2 **(playerBook.reproductionRound().sub(sellOrders[_orderId].round)) );\r\n        uint _fishPrice = sellOrders[_orderId].fishPrice;\r\n\t\tdelete sellOrders[_orderId];\r\n\r\n\t\t//return fish Amount to _caller\r\n\t\tplayerBook.addFishAmount(_caller, tempFishAmount, 0, false);\r\n\r\n\t\t//更新該價位整體魚數\r\n\t\tpriceTotalFishAmount[_fishPrice] = priceTotalFishAmount[_fishPrice].sub(tempFishAmount);\r\n\r\n\t\tpersonSellOrders[_caller] = 0; //清空 owner 掛單\r\n\r\n\t\temit orderEvent(_caller, tempFishAmount, now);\r\n\t}\r\n\r\n\r\n\t/* reproduce */\r\n\tfunction reproductionStage()\r\n\t\tprivate\r\n\t{\r\n\t\t//魚變兩倍 & 更新價位 & 累進計數器\r\n\t\tglobalData.fishAmount = globalData.fishAmount.mul(2);\r\n\t\tglobalData.systemTotalFishAmount = globalData.systemTotalFishAmount.mul(2);\r\n\t\tglobalData.fishPrice = 50 finney;\r\n\t\tglobalData.selledAmount = 0;\r\n\t\tsystemFishPriceCumulativeCount = 56 finney;\r\n\t\tisFleshUp = false;\r\n\r\n\t\t//更新個別價位 總魚數\r\n\t\tuint _addSystemFishAmount = globalData.systemTotalFishAmount.div(50);\r\n\t\tuint j=1;\r\n\t\tglobalData.priceInterval[0] = 50 finney; //50 其他在跳價格處理\r\n\t\tfor(uint i = 51 finney; i <= 98 finney; i += 1 finney){ //只更新到 98 (99賣完 -> 回到 50)\r\n\t\t\tpriceTotalFishAmount[i] = priceTotalFishAmount[i].mul(2); //殘存玩家單\r\n\t\t\tsystemFishAmount[i] = systemFishAmount[i].mul(2); //殘存系統單\r\n\t\t\t//systemFishAmount 直接加新的的\r\n\t\t\tif(i <= 56 finney){\r\n\t\t\t\tglobalData.priceInterval[j] = i;\r\n\t\t\t\tj++;\r\n\t\t\t\tsystemFishAmount[i] = systemFishAmount[i].add(_addSystemFishAmount);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t//告知 playerBook 更新 round 資訊\r\n\t\tplayerBook.addReproductionRound();\r\n\t\treproductionBlockNumbers.push(block.number);\r\n\t}\r\n\r\n\r\n\tfunction changePriceInterval() \r\n\t\tprivate\r\n\t{\r\n\t\t/*\r\n\t\t\t檢查是否長肉:\r\n\t\t\t\t每個檔位銷售完後, 每當累計銷售量大於等於到總可交易魚數的 2%\r\n\t\t*/\r\n\t\t\r\n\t\t\r\n\t\tif( isFleshUp == true || globalData.selledAmount.mul(50) >= globalData.fishAmount ){//長肉模式\r\n\t\t\tif(isFleshUp == false){\r\n\t\t\t\tfleshUpCount = 0; //第一次進入，把凍結區間的總魚數歸零\r\n\t\t\t}\r\n\r\n\t\t\thaveFish = false;// 長肉的正常跳價\r\n\t\t\tfor(uint i = globalData.priceInterval[0]; i <= globalData.priceInterval[6]; i += 1 finney){\r\n\t\t\t\tif(haveFish == false &&(priceTotalFishAmount[i] > 0 || systemFishAmount[i] > 0)){\r\n\t\t\t\t\tglobalData.fishPrice = i;\r\n\t\t\t\t\thaveFish = true;\r\n\t\t\t\t}\r\n\t\t\t\tif(isFleshUp == false){ //第一次進入，紀錄凍結後的總魚數\r\n\t\t\t\t\tfleshUpCount += priceTotalFishAmount[i];\r\n\t\t\t\t\tfleshUpCount += systemFishAmount[i];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tisFleshUp = true; //鎖住掛賣\r\n\t\t\t//7檔位不動\r\n\t\t\t//清空累計銷售\r\n\t\t\tglobalData.selledAmount = 0;\r\n\r\n\t\t\tif(fleshUpCount == 0){ //避免進入長肉，結果區間沒有魚\r\n\t\t\t\t//變回正常跳價\r\n\t\t\t\t//檢查價位往哪 (下3 or 上最多變成 0.099 eth 價位)\r\n\t\t\t\tfor(uint i = globalData.priceInterval[0]; i < 100 finney; i = i.add(1 finney)){\r\n\t\t\t\t\tif(priceTotalFishAmount[i] > 0 || systemFishAmount[i] > 0){\r\n\t\t\t\t\t\tglobalData.fishPrice = i; //99 一定有魚，沒魚就長肉了\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t} //          98 -> 95 -> 92 -> *89 -> 94* -> 99\r\n\t\t\t\t}\r\n\t\t\t\tisFleshUp = false;\r\n\t\t\t}else if(haveFish == false){//長肉結束，跳到新的價位\r\n\t\t\t\t//會進到 else 代表 isFleshUp == true\r\n\t\t\t\tisFleshUp = false;\r\n\t\t\t\t//清空累計銷售\r\n\t\t\t\tglobalData.selledAmount = 0;\r\n\t\t\t\t// 678 * 100 / 10000 = 6.78\r\n\t\t\t\tif(globalData.fishPrice == 99 finney){//如果為準繁殖 -> 下一輪\r\n\t\t\t\t\tglobalData.fishPrice = 100 finney;\r\n\t\t\t\t}else{\r\n\t\t\t\t\tglobalData.fishPrice = globalData.fishPrice.add( fleshUpCount.mul(100).div(globalData.fishAmount).mul(1 finney) ); //要加的價位\r\n\t\t\t\t\tif(fleshUpCount.mul(100) % globalData.fishAmount > 0){ //無條件進位\r\n\t\t\t\t\t\tglobalData.fishPrice = globalData.fishPrice.add(1 finney);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif(globalData.fishPrice > 99 finney){\r\n\t\t\t\t\t\tglobalData.fishPrice = 99 finney;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t//跳完價格後，跳到無魚的地方由 line 629 開始處裡\r\n\t\t\t}\r\n\r\n\t\t\temit fleshUpEvent(globalData.fishPrice, fleshUpCount, now);\r\n\t\t}else{\r\n\t\t\t//不是長肉就正常跳價\r\n\t\t\tif(globalData.fishPrice == 99 finney){//如果為準繁殖 -> 下一輪\r\n\t\t\t\tglobalData.fishPrice = 100 finney;\r\n\t\t\t}else{\r\n\t\t\t\t//檢查價位往哪 (下3 or 上最多變成 0.099 eth 價位)\r\n\t\t\t\tfor(uint i = globalData.priceInterval[0]; i < 100 finney; i = i.add(1 finney)){\r\n\t\t\t\t\tif(priceTotalFishAmount[i] > 0 || systemFishAmount[i] > 0){\r\n\t\t\t\t\t\tglobalData.fishPrice = i; //99 一定有魚，沒魚就長肉了\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t} //          98 -> 95 -> 92 -> *89 -> 94* -> 99\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t//如果繁殖 -> 由繁殖修改資訊\r\n\t\tif(globalData.fishPrice > 99 finney){\r\n\t\t\treproductionStage();\r\n\t\t\treturn;\r\n\t\t}\r\n\t\t\r\n\t\t// 94 [95] 96 97 |98| 99\r\n\t\t// 97 -> 98 cumulativecount = 99\r\n\t\t// 93-> 99 確實會進入這邊，但因為只會更新到 99 價位，所以不會動到 100\r\n\t\tif(globalData.fishPrice.add(3 finney) > systemFishPriceCumulativeCount && systemFishPriceCumulativeCount < 99 finney && isFleshUp == false){//讓 99 , 而且不是長肉\r\n\t\t\t// 交易系統中出現新價位(高價格)時, 第一優先掛賣庫存魚數的 2%, 取整數計算(無條件捨去)。 \r\n\t\t\tuint _addSystemFishAmount = globalData.systemTotalFishAmount.div(50);\r\n\t\t\tuint newPrice = globalData.fishPrice.add(3 finney); \r\n\t\t\tif(newPrice > 99 finney){\r\n\t\t\t\tnewPrice = 99 finney;\r\n\t\t\t}\r\n\t\t\t//更新 systemFishAmount\r\n\t\t\tfor(uint i = globalData.fishPrice; i <= newPrice; i = i.add(1 finney)){ //從當前價位更新魚數，而不用管前面的價位(就算是新的)\r\n\t\t\t\tif(systemFishAmount[i] == 0){ //沒有掛過魚 (舊的價位不該進到這個判斷，systemFishPriceCumulativeCount 不會讓舊的價位部署上去)\r\n\t\t\t\t\tsystemFishAmount[i] = systemFishAmount[i].add(_addSystemFishAmount);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tsystemFishPriceCumulativeCount = newPrice;\r\n\t\t\t//由價位更新 priceInterval\r\n\t\t\t// for(uint i = 6; i >= 0; i--){\r\n\t\t\t// \tglobalData.priceInterval[i] = newPrice.sub( (6-i).mul(1 finney));\r\n\t\t\t// }\r\n\t\t\tglobalData.priceInterval[0] = newPrice.sub(6 finney);\r\n\t\t\tglobalData.priceInterval[1] = newPrice.sub(5 finney);\r\n\t\t\tglobalData.priceInterval[2] = newPrice.sub(4 finney);\r\n\t\t\tglobalData.priceInterval[3] = newPrice.sub(3 finney);\r\n\t\t\tglobalData.priceInterval[4] = newPrice.sub(2 finney);\r\n\t\t\tglobalData.priceInterval[5] = newPrice.sub(1 finney);\r\n\t\t\tglobalData.priceInterval[6] = newPrice;\r\n\t\t}else if(globalData.fishPrice < 96 finney && globalData.fishPrice.sub(3 finney) >= 50 finney && isFleshUp == false){ //加上不是長肉\r\n\t\t\t//|96| 97 98 99  \r\n\t\t\t//50 51 52 |53|<-54\r\n\t\t\tglobalData.priceInterval[0] = globalData.fishPrice.sub(3 finney);\r\n\t\t\tglobalData.priceInterval[1] = globalData.fishPrice.sub(2 finney);\r\n\t\t\tglobalData.priceInterval[2] = globalData.fishPrice.sub(1 finney);\r\n\t\t\tglobalData.priceInterval[3] = globalData.fishPrice;\r\n\t\t\tglobalData.priceInterval[4] = globalData.fishPrice.add(1 finney);\r\n\t\t\tglobalData.priceInterval[5] = globalData.fishPrice.add(2 finney);\r\n\t\t\tglobalData.priceInterval[6] = globalData.fishPrice.add(3 finney);\r\n\t\t}\r\n\r\n\t\tif(priceTotalFishAmount[globalData.fishPrice] == 0 && systemFishAmount[globalData.fishPrice] == 0){//避免跳到一個沒魚的舊價位\r\n\t\t\tfor(uint i = globalData.priceInterval[0]; i < 100 finney; i = i.add(1 finney)){\r\n\t\t\t\tif(priceTotalFishAmount[i] > 0 || systemFishAmount[i] > 0){\r\n\t\t\t\t\tglobalData.fishPrice = i; //99 一定有魚，沒魚就長肉了\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t} //          98 -> 95 -> 92 -> *89 -> 94* -> 99\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif(globalData.fishPrice == 99 finney){ //新的價位為 99 的話，繁殖的問題系統單\r\n\t\t\tpriceTotalFishAmount[50 finney] = priceTotalFishAmount[50 finney].mul(2); //先繁殖下一輪的 50 價位\r\n\t\t\tuint _addSystemFishAmount = globalData.systemTotalFishAmount.div(50); //2%\r\n\t\t\tsystemFishAmount[50 finney] = systemFishAmount[50 finney].add(_addSystemFishAmount).mul(2);\r\n\r\n\t\t\t//如果還是要讓 100 顯示 100，而不是下一輪的 50\r\n\t\t\tuint newPrice = 100 finney;\r\n\t\t\tglobalData.priceInterval[0] = newPrice.sub(6 finney);\r\n\t\t\tglobalData.priceInterval[1] = newPrice.sub(5 finney);\r\n\t\t\tglobalData.priceInterval[2] = newPrice.sub(4 finney);\r\n\t\t\tglobalData.priceInterval[3] = newPrice.sub(3 finney);\r\n\t\t\tglobalData.priceInterval[4] = newPrice.sub(2 finney);\r\n\t\t\tglobalData.priceInterval[5] = newPrice.sub(1 finney);\r\n\t\t\tglobalData.priceInterval[6] = newPrice;\r\n\t\t}\r\n\r\n\t\temit changePriceEvent(address(this), globalData.fishPrice, now);\r\n\t}\r\n\r\n\t//@dev 減少可交易魚數\r\n\tfunction deadFish(uint _fishAmount) \r\n\t\texternal\r\n\t\tonlyPlayerBook\r\n\t{\r\n\t\tglobalData.fishAmount = globalData.fishAmount.sub(_fishAmount);\r\n\t}\r\n\r\n\r\n\tfunction setPlayerBookAddress(address payable _PBaddress) \r\n\t\texternal\r\n\t\tonlyOwner\r\n\t{\r\n\t\tplayerBookAddress = _PBaddress;\r\n\t\tplayerBook = PlayerBook(_PBaddress);\r\n\t}\r\n\r\n\r\n\r\n\tfunction getPersonSellOrders()\r\n\t\texternal\r\n\t\tview\r\n\t\treturns(uint)\r\n\t{\r\n\t\treturn(personSellOrders[msg.sender]);\r\n\t}\r\n\r\n\r\n\tfunction getSellOrderData(uint _orderId)\r\n\t\texternal\r\n\t\tview\r\n\t\treturns(address, uint, uint)\r\n\t{\r\n\t\treturn(sellOrders[_orderId].owner, sellOrders[_orderId].fishAmount, sellOrders[_orderId].fishPrice);\r\n\t}\r\n\r\n\r\n\tfunction showGlobalData() \r\n\t\tpublic\r\n\t\tview\r\n\t\treturns( uint _fishAmount, uint _fishPrice, uint _selledAmount )\r\n\t{\r\n\t\treturn( \r\n\t\t\tglobalData.fishAmount,\r\n\t\t\tglobalData.fishPrice,\r\n\t\t\tglobalData.selledAmount\r\n\t\t);\r\n\t}\r\n\r\n\r\n\tfunction showAvaliablePriceInterval() \r\n\t\tpublic \r\n\t\tview\r\n\t\treturns (uint256 [7] memory) \r\n\t{\r\n\t\treturn globalData.priceInterval;\r\n\t}\r\n\r\n\r\n\tfunction showPriceIntervalFishAmount()\r\n\t\tpublic \r\n\t\tview\r\n\t\treturns (uint256 [7] memory) \r\n\t{\r\n\t\tuint[7] memory temp;\r\n\t\tfor(uint i = 0; i < 7; i++){\r\n\t\t\tuint tempPrice = globalData.priceInterval[i];\r\n\t\t\tif(tempPrice == 100 finney){\r\n\t\t\t\ttemp[i] += priceTotalFishAmount[50 finney];\r\n\t\t\t\ttemp[i] += systemFishAmount[50 finney];\r\n\t\t\t\ttemp[i] /= 2;\r\n\t\t\t}else{\r\n\t\t\t\ttemp[i] += priceTotalFishAmount[tempPrice];\r\n\t\t\t\ttemp[i] += systemFishAmount[tempPrice];\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn temp;\r\n\t}\r\n\r\n\tfunction showFish()\r\n\t\tpublic \r\n\t\tview\r\n\t\treturns (uint256) \r\n\t{\r\n\t\treturn globalData.systemTotalFishAmount;\r\n\t}\r\n\r\n\tfunction getRepoBlockNumbers() \r\n\t\texternal\r\n\t\tview\r\n\t\treturns(uint[] memory)\r\n\t{\r\n\t\treturn reproductionBlockNumbers;\r\n\t}\r\n}\r\n\r\ncontract Commission is Ownable ,Pausable{\r\n    using SafeMath for uint;\r\n\r\n    /* @dev 魚缸等級 => 影響推薦獎金趴數、魚缸尺寸倍增多寡\r\n        @notice 小數點位數處理(3位)\r\n    */\r\n    uint[9] levelToCommission = [100,400,400,500,500,600,600,700,700]; //千分比\r\n    // uint[9] levelToCommission = [100,400,400,500,500,600,600,700,700]; //千分比\r\n    uint[9] fishbowlGrow = [0,0,0,0,0,0,0,0,1000]; //千分比\r\n    address private playerBookAddress;\r\n\r\n\r\n    /* @dev Generation model */\r\n    struct Generation{\r\n        /*false => 普通玩家, true=> 第一代玩家*/ //用ancestorList.length 判斷？\r\n        //bool firstGeneration;\r\n\r\n        /*向上，分發獎金用 => 10代 建立時檢查*/\r\n        address[] ancestorList; //往上延伸，需要分發獎金的人 => push\r\n\r\n        /*向下，擴增魚缸尺寸用*/\r\n        address[] inviteesList; //邀請者列表\r\n    }\r\n    mapping (address => Generation) generations; //用每個使用者的address 對應出自己的上下線\r\n\r\n\r\n\r\n    constructor(address _playerBookAddress) public{\r\n        playerBookAddress = _playerBookAddress;\r\n    }\r\n\r\n    event firstGenerationJoinGameEvent(address _newUser, uint _time);\r\n    event joinGameEvent(address _newUser, address invitedBy, uint _time);\r\n    event distributeCommissionEvent(uint[] _commission, uint _bonusPool, uint _ghostComission, uint _time);\r\n    event setPlayerBookAddrEvent(address _newPlayerBookAddr, uint _time);\r\n\r\n\r\n    /* @dev only transaction system can call */\r\n    modifier onlyForPlayerBook(){\r\n        require(msg.sender == playerBookAddress, \"Only for palyerBook contract!\");\r\n        _;\r\n    }\r\n\r\n    /* @dev 第一代加入遊戲 */\r\n    function firstGenerationJoinGame(address _newUser) public onlyForPlayerBook{\r\n        //generations[_newUser].firstGeneration = true;\r\n\r\n        emit firstGenerationJoinGameEvent(_newUser, now);\r\n    }\r\n\r\n    /* @dev 輸入新用戶跟他的邀請人，幫他建立好他的上線列表*/\r\n    function joinGame(address _newUser, address _inviter) public onlyForPlayerBook{\r\n\r\n        if(generations[_inviter].ancestorList.length == 10){\r\n            generations[_newUser].ancestorList.push(_inviter);\r\n            for (uint i = 0; i < 9; i++) {\r\n                generations[_newUser].ancestorList.push(generations[_inviter].ancestorList[i]);\r\n            }\r\n            //generations[_newUser].firstGeneration = false;\r\n        }\r\n        else if(generations[_inviter].ancestorList.length == 0){\r\n            generations[_newUser].ancestorList.push(_inviter);\r\n        }\r\n        else{\r\n            generations[_newUser].ancestorList.push(_inviter);\r\n            for (uint j = 0; j < generations[_inviter].ancestorList.length; j++) {\r\n                generations[_newUser].ancestorList.push(generations[_inviter].ancestorList[j]);\r\n            }\r\n            //generations[_newUser].firstGeneration = false;\r\n        }\r\n\r\n        emit joinGameEvent(_newUser, _inviter, now);\r\n    }\r\n\r\n    /* @dev\r\n        輸入用戶地址、此次購魚的飼料費、上線目前等級，依據ancestorList、fishbowlSize來分配每一個上限的金額，剩餘的錢轉入開發者地址\r\n        @notice 千分比 + 標準單位位移 => 總共6位\r\n    *//*\r\n    function distributeCommission(address _user, uint _fodderFee, uint _fishbowlLevel)\r\n\r\n    public onlyForPlayerBook returns(uint[] memory commission, uint bonusPool, uint ghostComission)\r\n    {\r\n        uint[] memory _commission = new uint[](generations[_user].ancestorList.length);\r\n        uint _bonusPool;\r\n        uint _ghostComission = _fodderFee;\r\n        for(uint i = 0; i < generations[_user].ancestorList.length; i++){\r\n            if(i==0){\r\n                _commission[i] = _fodderFee.mul(levelToCommission[_fishbowlLevel]).div(1000);\r\n                _ghostComission = _ghostComission.sub(_commission[i]);\r\n            }\r\n            else{\r\n                _commission[i] = _fodderFee.mul(20).div(1000);\r\n                _ghostComission = _ghostComission.sub(_commission[i]);\r\n            }\r\n        }\r\n        _bonusPool = _fodderFee.mul(20).div(1000);\r\n        _ghostComission = _ghostComission.sub(_bonusPool);\r\n\r\n        emit distributeCommissionEvent(_commission, _bonusPool, _ghostComission, now);\r\n        return (_commission, _bonusPool, _ghostComission);\r\n    }*/\r\n \r\n    /* @dev\r\n        輸入邀請人地址及魚缸尺寸、受邀者地址及首次購魚後魚缸等級，幫邀請人將下線列表更新並回傳新的魚缸尺寸\r\n    */\r\n    function inviteNewUser(address _inviter, uint _inviterFishBowlSize, address _invitee, uint _inviteeFishbowlLevel)\r\n    public onlyForPlayerBook returns(uint newFishbowlSize)\r\n    {\r\n        generations[_inviter].inviteesList.push(_invitee);\r\n        uint _newFishbowlSize = _inviterFishBowlSize.add(fishbowlGrow[_inviteeFishbowlLevel]);\r\n\r\n        return _newFishbowlSize;\r\n    }\r\n\r\n    /* @dev 回傳ancestorList */\r\n    function getAncestorList(address _user) public view returns(address[] memory ancestorList){\r\n        require(generations[_user].ancestorList.length != 0, \"你是第一代\");\r\n\r\n        address[] memory _ancestorList = new address[](generations[_user].ancestorList.length);\r\n        for(uint i = 0; i < generations[_user].ancestorList.length; i++){\r\n            _ancestorList[i] = generations[_user].ancestorList[i];\r\n        }\r\n\r\n        return _ancestorList;\r\n    }\r\n\r\n    /* @dev 回傳上一代 */\r\n    function getMotherGeneration(address _user) public view returns(address motherGeneration){\r\n        require(generations[_user].ancestorList.length != 0, \"你是第一代\");\r\n\r\n        return generations[_user].ancestorList[0];\r\n    }\r\n\r\n    /* @dev 回傳inviteesList */\r\n    function getInviteesList(address _user) public view returns(address[] memory inviteesList){\r\n        require(generations[_user].inviteesList.length != 0, \"你沒有下線\");\r\n\r\n        address[] memory _inviteesList = new address[](generations[_user].inviteesList.length);\r\n        for(uint i = 0; i < generations[_user].inviteesList.length; i++){\r\n            _inviteesList[i] = generations[_user].inviteesList[i];\r\n        }\r\n\r\n        return _inviteesList;\r\n    }\r\n\r\n    /* @dev 回傳inviteesCount */\r\n    function getInviteesCount(address _user) public view returns(uint inviteesCount){\r\n        //require(generations[_user].inviteesList.length != 0, \"你沒有下線\");\r\n\r\n        return generations[_user].inviteesList.length;\r\n    }\r\n\r\n    /*@dev set playerbookAddr */\r\n    function setPlayerBookAddr(address _newPlayerBookAddr) public onlyOwner{\r\n        playerBookAddress = _newPlayerBookAddr;\r\n\r\n        emit setPlayerBookAddrEvent(_newPlayerBookAddr, now);\r\n    }\r\n\r\n    /*@dev get playerbookAddr */\r\n    function getPlayerBookAddr() public view returns(address _playerBookAddress){\r\n        return playerBookAddress;\r\n    }\r\n}\r\n\r\ncontract PlayerBook is Ownable, Pausable {\r\n\r\n    using SafeMath for uint;\r\n\r\n    uint public reproductionRound;\r\n    uint public weekRound;\r\n\r\n    uint constant public BONUS_TIMEOUT_NO_USER = 33200;\r\n    uint constant public BONUS_TIMEOUT_WEEK = 46500;\r\n\r\n    uint private _ghostProfit;\r\n\r\n    uint[9] public avaliableFishAmountList = [0,1,5,10,30,50,100,150,200];\r\n\r\n    event LogBuyOrderRefund( address indexed _refunder, uint _refundValue, uint _now);\r\n    event LogSellerProcessProfit( address indexed _seller, uint _totalValue, uint _now);\r\n    event LogAddNewSellOrder( address indexed _player, uint _fishAmount, uint _cPrice, uint _now);\r\n    event LogAddFishAmount( address indexed _buyer, uint _successBuyFishAmount, uint _totalCost, bool _isBuy, uint _now ); \r\n    event LogDistributeCommission( address indexed _user, uint _fodderFee, address[] _ancestorList, uint bonusPool, uint _now);\r\n    event LogFirstGenerationJoinGame( address indexed _user, uint _initFishAmount, uint _value, uint _now);\r\n    event LogJoinGame( address indexed _newUser, uint _initFishAmount, uint _value, address _inviter, uint _now);\r\n\r\n    event LogIncreseFishbowlSize( address indexed _newUser, uint _initFishAmount, uint _value, uint _now);\r\n    event LogWithdrawProfit( address indexed _user, uint _profit, uint _recomandBonus, uint _now);\r\n    event LogWithdrawRecommandBonus( address indexed _user, uint _recommandBonus, uint _now);\r\n\r\n    event LogGetWeekBonusPool( address indexed _user, uint _bonus, uint _now);\r\n    event LogGetBonusPool( address indexed _user, uint _bonus, uint _now);\r\n\r\n    event LogWithdrawOwnerProfit( address indexed _owner, uint _profit );\r\n\r\n    /* @dev Player model */\r\n    struct Player {\r\n        /* pricing data */\r\n        uint admissionPrice;\r\n        uint accumulatedSellPrice;\r\n        uint amountToSale;\r\n        uint recomandBonus;\r\n        uint profit; \r\n        uint rebuy;\r\n        /* fish data of the player */\r\n        uint fishbowlLevel;\r\n        uint fishbowlSize;\r\n        uint fishAmount;\r\n        /* status of player */\r\n        PlayerStatus status;\r\n        /* reproduction round */\r\n        uint round;\r\n        /* weekly data */\r\n        uint playerWeekRound;\r\n        uint playerWeekCount;\r\n        /* is first generation */\r\n        bool isFirstGeneration;\r\n        // 限制多重購魚\r\n        uint joinRound;\r\n    }\r\n\r\n    /* @dev week data tracking */\r\n    // struct WeekData {\r\n    //     address payable currentWinner;\r\n    //     uint count;\r\n    //     uint round;\r\n    // }\r\n\r\n    address payable[3] private weekData; //0 < 1 < 2\r\n\r\n    /*\r\n    struct WeekNode {\r\n        address payable player;\r\n        uint count;\r\n        bytes32 _next;\r\n    }\r\n\r\n    bytes32 private WEEK_HEAD = keccak256(\"WEEK_HEAD\");\r\n\r\n    mapping (bytes32=>WeekNode) weekPlayerNodeList;*/\r\n\r\n    struct BonusPool {\r\n        uint totalAmount;\r\n        uint bonusWeekBlock;\r\n        address weekBonusUser;\r\n        uint bonusWeekBlockWithoutUser;\r\n        address lastBonusUser;\r\n    }\r\n\r\n    BonusPool bonusPool;\r\n    // WeekData weekData;\r\n\r\n    /* @dev outer contracts */\r\n    TransactionSystem transactionSystem;\r\n    Fishbowl fishbowl;\r\n    Commission commission; \r\n\r\n    /* @dev mark the current status of a player */\r\n    enum PlayerStatus { NOT_JOINED, NORMAL, EXCEEDED }\r\n    \r\n    address payable public TransactionSystemAddress;\r\n    address payable public FishbowlAddress;\r\n    address payable public CommissionAddress;\r\n    \r\n    /* @dev game books datastructure */\r\n    mapping (address=>Player) playerBook;\r\n    mapping (address=>uint) internal playerLastTotalCost;\r\n\r\n    mapping (address=>bool) whiteList;\r\n    \r\n\r\n    /* @dev player not exceeding can call */\r\n    modifier PlayerIsAlive() {\r\n        require(playerBook[msg.sender].status == PlayerStatus.NORMAL, \"Exceed or not Join\");\r\n        _;\r\n    }\r\n\r\n    /* @dev only transaction system can call */\r\n    modifier OnlyForTxContract() {\r\n        require( msg.sender == TransactionSystemAddress, \"Only for tx contract!\");\r\n        _; \r\n    }\r\n\r\n    /* @dev contract address is not allowed */\r\n    modifier isHuman() {\r\n        address _addr = msg.sender;\r\n        uint256 _codeLength;\r\n        \r\n        assembly {_codeLength := extcodesize(_addr)}\r\n        require(_codeLength == 0, \"Addresses not owned by human are forbidden\");\r\n        _;\r\n    }\r\n\r\n    /* @dev check that the fish amount is in valid range */\r\n    modifier isValidFishAmount (uint _fishAmount) {\r\n        require(\r\n            _fishAmount == avaliableFishAmountList[0] ||\r\n            _fishAmount == avaliableFishAmountList[1] ||\r\n            _fishAmount == avaliableFishAmountList[2] ||\r\n            _fishAmount == avaliableFishAmountList[3] ||\r\n            _fishAmount == avaliableFishAmountList[4] ||\r\n            _fishAmount == avaliableFishAmountList[5] ||\r\n            _fishAmount == avaliableFishAmountList[6] ||\r\n            _fishAmount == avaliableFishAmountList[7] ||\r\n            _fishAmount == avaliableFishAmountList[8] ,\r\n            \"Invalid fish amount!\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    constructor() public payable {\r\n\r\n        reproductionRound = 1;\r\n        weekRound = 1;\r\n        \r\n        bonusPool = BonusPool(0, block.number, address(0), block.number, address(0));\r\n        // weekData = WeekData(address(0), 0, 1);\r\n\r\n        _ghostProfit = 0;\r\n        whiteList[owner] = true;\r\n        whiteList[0x83b73144939e81236C8d5561509CC50e7A30D0F7] = true;//客戶初代\r\n    }\r\n\r\n    /* @dev a function that allows owner to add */\r\n    function firstGenerationJoinGame(uint _initFishAmount) public payable isHuman() isValidFishAmount(_initFishAmount) {      \r\n        address payable _user = msg.sender;\r\n        uint _value = msg.value;\r\n\r\n        require(whiteList[_user], \"Invalid user\");\r\n        require(playerBook[_user].status == PlayerStatus.NOT_JOINED, \"Player has joined!\");\r\n\r\n        playerBook[_user].isFirstGeneration = true;\r\n        emit LogFirstGenerationJoinGame( _user, _initFishAmount, _value, now);\r\n\r\n        // flow of paticipation on first generation\r\n        // 3. add buyer in consultant's first, add consultant to buyer's consultant list (Commission)\r\n        commission.firstGenerationJoinGame(_user);\r\n        // 2. init player data\r\n        initFishData(_user, _initFishAmount);\r\n        // 1. add buy order.\r\n        transactionSystem.addNewBuyOrder(_user, _initFishAmount, _value, false);\r\n        initPriceData(_user, playerLastTotalCost[_user]);\r\n    }\r\n\r\n    /* @dev Player join the game at first time\r\n      * @param _initFishAmount _inviter\r\n`    */\r\n    function joinGame (uint _initFishAmount, address payable _inviter) public payable isHuman() isValidFishAmount(_initFishAmount) {    \r\n        address payable _newUser = msg.sender;\r\n        uint _value = msg.value;\r\n\r\n        require(_inviter != address(0x0) && playerBook[_inviter].status > PlayerStatus.NOT_JOINED, \"No such inviter!\");\r\n        require(playerBook[_newUser].status == PlayerStatus.NOT_JOINED, \"Player has joined!\");\r\n\r\n        playerBook[_newUser].isFirstGeneration = false;\r\n        emit LogJoinGame (_newUser, _initFishAmount, _value, _inviter,  now);\r\n\r\n        uint _balance = _value.div(2);\r\n        // uint _fodderFee = _value.div(2);\r\n\r\n        // flow of paticipation\r\n        // 3. add buyer in consultant's first, add consultant to buyer's consultant list (Commission)\r\n        commission.joinGame(_newUser, _inviter);\r\n        // 1. init player data\r\n        initFishData(_newUser, _initFishAmount);\r\n        // 2. reset consultant fishbowl data (Fishbowler, playerBook[_inviter].fishbowlSize, _newUser, playerBook[_newUser].fishbowl) -> return\r\n        playerBook[_inviter].fishbowlSize = commission.inviteNewUser(_inviter, playerBook[_inviter].fishbowlSize, _newUser, playerBook[_newUser].fishbowlLevel);\r\n        playerBook[_inviter].amountToSale = playerBook[_inviter].fishbowlSize.mul(playerBook[_inviter].admissionPrice);\r\n        // 3. renew weekly data\r\n        // if (playerBook[_inviter].playerWeekRound != weekData.round) \r\n        if (playerBook[_inviter].playerWeekRound != weekRound) {\r\n            playerBook[_inviter].playerWeekRound = weekRound;\r\n            playerBook[_inviter].playerWeekCount = 0;\r\n        }\r\n\r\n        // playerBook[_inviter].playerWeekCount = playerBook[_inviter].playerWeekCount.add(1);\r\n        playerBook[_inviter].playerWeekCount = playerBook[_inviter].playerWeekCount.add(_initFishAmount);\r\n        // 4. set week bonus data and sort list\r\n        bool tempJudge = false;\r\n        int index = -1;\r\n        for(uint i = 0; i < 3; i++){\r\n            if(playerBook[_inviter].playerWeekCount > playerBook[ weekData[i] ].playerWeekCount){\r\n                index = int(i); //紀錄當前使用者大過的排名\r\n                if(tempJudge){ //當前使用者有在榜上，直接更動排名\r\n                    address payable temp = weekData[i];\r\n                    weekData[i] = _inviter;\r\n                    weekData[i-1] = temp;\r\n                }\r\n            }\r\n            if (_inviter == weekData[i]) { //檢查當前使用者有無上榜\r\n                tempJudge = true;\r\n            }\r\n        }\r\n        if(tempJudge == false){ //當前使用者沒在榜上\r\n            for(uint i = 0; int(i) <= index; i++){\r\n                address payable temp = weekData[i];\r\n                weekData[i] = _inviter;\r\n                if(i != 0){\r\n                    weekData[i-1] = temp;\r\n                }\r\n            }\r\n        }\r\n        /*\r\n        bytes32 _startID = WEEK_HEAD;\r\n        for (uint i = 0; i < 3; i++) {\r\n            bytes32 _nextID = weekPlayerNodeList[_startID]._next;\r\n\r\n            if (playerBook[_inviter].playerWeekCount <= weekPlayerNodeList[_startID].count && playerBook[_inviter].playerWeekCount > weekPlayerNodeList[_nextID].count) {\r\n                if (weekPlayerNodeList[_nextID].player == _inviter) {\r\n                    weekPlayerNodeList[_nextID].count = playerBook[_inviter].playerWeekCount;\r\n                    break;\r\n                }\r\n                bytes32 _insertID = keccak256(abi.encodePacked(_inviter, playerBook[_inviter].playerWeekCount));\r\n                weekPlayerNodeList[_insertID] = WeekNode(_inviter, playerBook[_inviter].playerWeekCount, _nextID);\r\n                weekPlayerNodeList[_startID]._next = _insertID;\r\n                break;\r\n\r\n            } else if (playerBook[_inviter].playerWeekCount > weekPlayerNodeList[_startID].count) {\r\n                if (weekPlayerNodeList[_startID].player == _inviter) {\r\n                    weekPlayerNodeList[_startID].count = playerBook[_inviter].playerWeekCount;\r\n                    break;\r\n                }\r\n                bytes32 _insertID = keccak256(abi.encodePacked(_inviter, playerBook[_inviter].playerWeekCount));\r\n                weekPlayerNodeList[_insertID] = WeekNode(_inviter, playerBook[_inviter].playerWeekCount, _startID);\r\n\r\n                WEEK_HEAD = _insertID;\r\n                break;\r\n\r\n            } else {\r\n                _startID = _nextID;\r\n                continue;\r\n            }\r\n        }*/\r\n        // 5. add buy order.\r\n        transactionSystem.addNewBuyOrder(_newUser, _initFishAmount, _balance, false);\r\n        initPriceData(_newUser, playerLastTotalCost[_newUser]);\r\n        // 5. distribute fodder fee(Commission) -> (playerbook profit setter)\r\n        // distributeCommission(_newUser, _fodderFee);\r\n    }\r\n\r\n\r\n     /* @dev Update bowl size kobe control\r\n       * @notice Need to buy larger than current size\r\n       * @param _fishAmount _fishPrice\r\n    */\r\n    function increseFishbowlSizeByMoney (uint _fishAmount) public payable isHuman() PlayerIsAlive() isValidFishAmount(_fishAmount){   \r\n        address payable _player = msg.sender;\r\n        uint _value = msg.value;\r\n        require (playerBook[_player].fishbowlLevel <= 8 && playerBook[_player].fishbowlLevel >= 0, \"Invalid fish level!\");\r\n        require (fishbowl.getFishBowlLevel(_fishAmount) >= playerBook[_player].fishbowlLevel, \"Should buy more fish to upgrade!\");\r\n        \r\n        /* normalize fish amount */\r\n        // normalizeFishAmount(_player);\r\n\r\n        uint _balance = playerBook[_player].isFirstGeneration ? _value : _value.div(2);\r\n        \r\n        // uint _fodderFee = playerLastTotalCost[_player];\r\n        uint _beforeFishbowlSize = playerBook[_player].fishbowlSize;\r\n\r\n        if (playerBook[_player].fishbowlLevel < 8 && playerBook[_player].fishbowlLevel != 0) {\r\n            transactionSystem.addNewBuyOrder(_player, _fishAmount, _balance, false);\r\n            (playerBook[_player].fishbowlLevel, playerBook[_player].fishbowlSize, playerBook[_player].admissionPrice, playerBook[_player].amountToSale) = fishbowl.fishBowl(playerLastTotalCost[_player], _fishAmount);\r\n        \r\n        } else if (playerBook[_player].fishbowlLevel == 8 && playerBook[_player].joinRound == reproductionRound) {\r\n            transactionSystem.addNewBuyOrder(_player, _fishAmount, _balance, false);\r\n            (playerBook[_player].admissionPrice, playerBook[_player].amountToSale) = fishbowl.multipleBuy(playerLastTotalCost[_player], playerBook[_player].admissionPrice, playerBook[_player].amountToSale);\r\n            \r\n            if(playerBook[_player].isFirstGeneration == false){ //不是第一代才有直一\r\n                address temp = commission.getMotherGeneration(_player);\r\n                address payable _inviter = address(uint160(temp));\r\n                if (playerBook[_inviter].playerWeekRound != weekRound) {\r\n                    playerBook[_inviter].playerWeekRound = weekRound;\r\n                    playerBook[_inviter].playerWeekCount = 0;\r\n                }\r\n\r\n                playerBook[_inviter].playerWeekCount = playerBook[_inviter].playerWeekCount.add(_fishAmount);\r\n                // 4. set week bonus data and sort list\r\n                bool tempJudge = false;\r\n                int index = -1;\r\n                for(uint i = 0; i < 3; i++){\r\n                    if(playerBook[_inviter].playerWeekCount > playerBook[ weekData[i] ].playerWeekCount){\r\n                        index = int(i); //紀錄當前使用者大過的排名\r\n                        if(tempJudge){ //當前使用者有在榜上，直接更動排名\r\n                            address payable _temp = weekData[i];\r\n                            weekData[i] = _inviter;\r\n                            weekData[i-1] = _temp;\r\n                        }\r\n                    }\r\n                    if (_inviter == weekData[i]) { //檢查當前使用者有無上榜\r\n                        tempJudge = true;\r\n                    }\r\n                }\r\n                if(tempJudge == false){ //當前使用者沒在榜上\r\n                    for(uint i = 0; int(i) <= index; i++){\r\n                        address payable _temp = weekData[i];\r\n                        weekData[i] = _inviter;\r\n                        if(i != 0){\r\n                            weekData[i-1] = _temp;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n        } else{\r\n            revert(\"out of join round\");\r\n        }\r\n\r\n        if ( playerBook[_player].fishbowlSize <= _beforeFishbowlSize) {\r\n            playerBook[_player].fishbowlSize = _beforeFishbowlSize;\r\n            playerBook[_player].amountToSale = playerBook[_player].admissionPrice.mul(playerBook[_player].fishbowlSize);\r\n        }\r\n\r\n        \r\n        emit LogIncreseFishbowlSize( _player, _fishAmount, _value, now);\r\n\r\n    }\r\n\r\n\r\n    /* @dev user buy fish order via playerbook */\r\n    function rebuyAddNewBuyOrder(uint _fishAmount, uint _rebuy) public isHuman() PlayerIsAlive() {\r\n        address payable _player = msg.sender;\r\n        /* check rebuy value */\r\n        require(playerBook[_player].rebuy >= _rebuy, \"Invalid rebuy value!\");\r\n\r\n        /* normalize fish amount */\r\n        // normalizeFishAmount(_player);\r\n       \r\n        uint _balance = playerBook[_player].isFirstGeneration ? _rebuy : _rebuy.div(2);\r\n        /* new buy-order process */\r\n        transactionSystem.addNewBuyOrder(_player, _fishAmount, _balance, true);\r\n        uint _actualRebuy = playerBook[_player].isFirstGeneration ? playerLastTotalCost[_player] : playerLastTotalCost[_player].mul(2);\r\n        playerBook[_player].rebuy = (playerBook[_player].rebuy).sub(_actualRebuy);\r\n    }\r\n\r\n\r\n    /* \r\n      * @dev player setup.\r\n      * Init fishbowl level, fishbowl size, player status\r\n      * @param _newUser _initFishAmount \r\n    */\r\n    function initFishData(address _newUser, uint _initFishAmount) internal {\r\n        // addFishAmount(_newUser, _initFishAmount);\r\n        playerBook[_newUser].fishbowlLevel = fishbowl.getFishBowlLevel(_initFishAmount); \r\n        playerBook[_newUser].fishbowlSize = fishbowl.getFishbowlSize(playerBook[_newUser].fishbowlLevel);\r\n        playerBook[_newUser].status = PlayerStatus.NORMAL;\r\n        playerBook[_newUser].round = reproductionRound;\r\n        // playerBook[_newUser].playerWeekRound = weekData.round;\r\n        playerBook[_newUser].playerWeekRound = weekRound;\r\n        playerBook[_newUser].playerWeekCount = 0;\r\n        playerBook[_newUser].joinRound = reproductionRound;\r\n    }\r\n\r\n    /* \r\n      * @dev Player price data initialization\r\n      * Init selled price, admission price, maximum sellable price, recommandation bonus, profit, and rebuy amount.\r\n      * @param _newUser _initFishAmount\r\n    */\r\n    function initPriceData(address _newUser, uint _totalFishPrice) internal {    \r\n        playerBook[_newUser].accumulatedSellPrice = 0;\r\n        playerBook[_newUser].admissionPrice = fishbowl.getAdmissionPrice(_totalFishPrice);\r\n        playerBook[_newUser].amountToSale = fishbowl.getAmountToSale(playerBook[_newUser].fishbowlLevel, playerBook[_newUser].admissionPrice);\r\n        playerBook[_newUser].recomandBonus = 0;\r\n        playerBook[_newUser].profit = 0;\r\n        playerBook[_newUser].rebuy = 0;\r\n    }\r\n\r\n    /* @dev user sell fish order via playerbook\r\n     */\r\n    function addNewSellOrder(uint _fishAmount, uint _fishPrice)  public isHuman() PlayerIsAlive() {\r\n        require(_fishAmount != 0, \"not allowd zero fish amount\");\r\n        address payable _player = msg.sender;\r\n        /* normalize fish amount */\r\n        normalizeFishAmount(_player);\r\n        (uint _quo, uint _rem) = getDivided(playerBook[msg.sender].fishAmount, 10);\r\n        if ( _rem != 0 ) {\r\n            _quo = _quo.add(1);\r\n        }\r\n\r\n        require(\r\n            playerBook[msg.sender].fishAmount >= _fishAmount &&\r\n            _fishAmount <= _quo,\r\n            \"Unmatched avaliable sell fish amount!\"\r\n        );\r\n\r\n        uint accumulated = playerBook[_player].accumulatedSellPrice;\r\n        accumulated = accumulated.add(_fishAmount * _fishPrice);\r\n        require( playerBook[_player].amountToSale.div(1000) >= accumulated , \"exceed amount to sale\");\r\n            \r\n        /* new sell-order process */\r\n        transactionSystem.addNewSellOrder(_player, _fishAmount, _fishPrice);\r\n\r\n        emit LogAddNewSellOrder( _player, _fishAmount, _fishPrice, now);\r\n    }\r\n\r\n\r\n    /* @dev cancel sell order\r\n     */\r\n    function cancelSellOrder(uint _orderId) public payable isHuman()  PlayerIsAlive() {\r\n        // normalizeFishAmount(msg.sender);\r\n        transactionSystem.cancelSellOrder(msg.sender, _orderId);\r\n    }\r\n\r\n    /* \r\n      * @dev Add fish amount(called from transaction system or fishbowl)\r\n      * @notice Cases of adding fish to a player\r\n      * 1. Buy fish at current price (TransactionSystem.buyFishAtCurrentPrice())\r\n      * 2. Reproduction\r\n      * 3. player cancel order (TransactionSystem.cancelSellOrder())\r\n      * @param _buyer _fushAmount\r\n    */\r\n    function addFishAmount (address payable _buyer, uint _successBuyFishAmount, uint _totalCost, bool _isBuy ) external OnlyForTxContract() {\r\n        \r\n        //要正規化要加的對象的魚數\r\n        normalizeFishAmount(_buyer);\r\n        \r\n        playerBook[_buyer].fishAmount = (playerBook[_buyer].fishAmount).add(_successBuyFishAmount);\r\n        playerLastTotalCost[_buyer] = _totalCost;\r\n        emit LogAddFishAmount( _buyer, _successBuyFishAmount, _totalCost, _isBuy, now);\r\n        \r\n        \r\n        // if it's a cancel order or buyed\r\n        if (_isBuy && !playerBook[_buyer].isFirstGeneration) {\r\n            // distribute commission\r\n            distributeCommission(_buyer, _totalCost);\r\n        }\r\n    }\r\n\r\n\r\n    /* @dev profit setting, including 60% profit and 40% rebuy amount (70%+18% 12%) (100%) (100% -> 60% 40% )\r\n      * when a non-system seller gets profit, it need to be distributed.\r\n      * @param _seller _totalRevenue\r\n    */ \r\n    function sellerProcessProfit (address _seller, uint _totalRevenue) external OnlyForTxContract() {\r\n        emit LogSellerProcessProfit( _seller, _totalRevenue, now);\r\n\r\n        if (_seller != address(this) ) {\r\n            addAccumulatedValue (_seller, _totalRevenue);\r\n\r\n            uint _profit = _totalRevenue.mul(60).div(100);\r\n            playerBook[_seller].profit = (playerBook[_seller].profit).add(_profit);\r\n\r\n            uint _rebuy = _totalRevenue.mul(40).div(100);\r\n            if (playerBook[_seller].status == PlayerStatus.EXCEEDED) {\r\n                _ghostProfit = _ghostProfit.add(_rebuy);\r\n            } else {\r\n                playerBook[_seller].rebuy = (playerBook[_seller].rebuy).add(_rebuy); \r\n            }\r\n        } else {\r\n            _ghostProfit = _ghostProfit.add(_totalRevenue);\r\n        }\r\n    }\r\n\r\n\r\n    /* @dev buy order refunding setting\r\n      * @param _refunder _refundValue\r\n    */ \r\n    function buyOrderRefund (address payable _refunder, uint _refundValue) external OnlyForTxContract() {   \r\n        uint _tmpRefundValue = _refundValue;\r\n        if ( !playerBook[_refunder].isFirstGeneration) \r\n            _tmpRefundValue = _tmpRefundValue.mul(2);\r\n\r\n        emit LogBuyOrderRefund( _refunder, _refundValue, now);\r\n\r\n        _refunder.transfer(_tmpRefundValue);\r\n    }\r\n\r\n\r\n    /* @dev Minus fish amount(called from transaction system or fishbowl)\r\n      * @notice Only when MAKING ORDER that minus fish amount (TransactionSystem.addNewSellOrder())\r\n      * @param _seller _fishAmount\r\n    */\r\n    function minusFishAmount (address _seller, uint _fishAmount) external OnlyForTxContract() {\r\n        playerBook[_seller].fishAmount = (playerBook[_seller].fishAmount).sub(_fishAmount);\r\n    }\r\n\r\n\r\n    /* @dev Set reproduction round */\r\n    function addReproductionRound () external OnlyForTxContract() {\r\n        reproductionRound = reproductionRound.add(1);\r\n    }\r\n    \r\n\r\n    /* @dev check if the player is exceed maximum sell price \r\n      * @param _player _profit\r\n    */\r\n    function addAccumulatedValue (address _player, uint _profit) internal {\r\n        playerBook[_player].accumulatedSellPrice = (playerBook[_player].accumulatedSellPrice).add(_profit);\r\n        if ( (playerBook[_player].amountToSale.div(1000) < playerBook[_player].accumulatedSellPrice) && (playerBook[_player].status != PlayerStatus.EXCEEDED) ) {\r\n            playerBook[_player].status = PlayerStatus.EXCEEDED;\r\n            transactionSystem.deadFish(playerBook[_player].fishAmount);\r\n\r\n            uint _tempRebuy = playerBook[_player].rebuy;\r\n            playerBook[_player].rebuy = 0;\r\n\r\n            _ghostProfit = _ghostProfit.add(_tempRebuy);\r\n        }\r\n    }\r\n\r\n    /* @dev normalize fish amount by reproduction round\r\n     * @parem _player\r\n     */\r\n    function normalizeFishAmount (address _player) internal {\r\n        if( reproductionRound != playerBook[_player].round ) {\r\n            playerBook[_player].fishAmount = playerBook[_player].fishAmount.mul( 2 **  (reproductionRound.sub(playerBook[_player].round)) );\r\n            playerBook[_player].round = reproductionRound;\r\n        }\r\n    }\r\n    /* @dev get week bonus condition when there's no user amoung this week */\r\n    function checkBonusPoolBlockNoUser () internal returns(bool) {\r\n        uint lastBonusBlock = bonusPool.bonusWeekBlockWithoutUser;\r\n        bonusPool.bonusWeekBlockWithoutUser = block.number;\r\n\r\n        if (bonusPool.bonusWeekBlockWithoutUser.sub(lastBonusBlock) > BONUS_TIMEOUT_NO_USER) \r\n            return true;\r\n        \r\n        return false;\r\n    }\r\n    /* @dev get week bonus condition */\r\n    function checkBonusPoolBlockWeek () internal returns(bool) {\r\n        uint lastBonusBlock = bonusPool.bonusWeekBlock;\r\n        uint _nowBlock = block.number;\r\n\r\n        if (_nowBlock.sub(lastBonusBlock) > BONUS_TIMEOUT_WEEK)  {\r\n            bonusPool.bonusWeekBlock = _nowBlock;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function resetWeekData() internal {\r\n        // weekData.round = weekData.round.add(1);\r\n        // weekData.count = 0;\r\n        weekRound = weekRound.add(1);\r\n\r\n        delete weekData;\r\n\r\n        /*\r\n        bytes32 _startID = WEEK_HEAD;\r\n        for (uint i = 0; i < 3; i++) {\r\n            bytes32 _nextID = weekPlayerNodeList[_startID]._next;\r\n            delete weekPlayerNodeList[_startID];\r\n\r\n            _startID = _nextID;\r\n        }*/\r\n    }\r\n\r\n\r\n    /* @dev distribute commission when buy fish\r\n        @param _user _fodderFee\r\n    */\r\n    uint[9] levelToCommission = [100,400,400,500,500,600,600,700,700]; //千分比\r\n    function distributeCommission(address payable _user, uint _fodderFee) internal {\r\n        uint _ghostCommission;\r\n        uint _bonusPool;\r\n        address[] memory _ancestorList = commission.getAncestorList(_user);\r\n        uint[] memory _commissionList = new uint[](_ancestorList.length);\r\n\r\n        _ghostCommission = _fodderFee;\r\n        for(uint i = 0; i < _ancestorList.length; i++){\r\n            if(i==0){\r\n                _commissionList[i] = _fodderFee.mul(levelToCommission[playerBook[_ancestorList[i]].fishbowlLevel]).div(1000);\r\n                _ghostCommission = _ghostCommission.sub(_commissionList[i]);\r\n            }else if(playerBook[_ancestorList[i]].fishbowlLevel != 0){\r\n                _commissionList[i] = _fodderFee.mul(20).div(1000); //實際上的1%\r\n                _ghostCommission = _ghostCommission.sub(_commissionList[i]);\r\n            }\r\n        }\r\n        _bonusPool = _fodderFee.mul(20).div(1000);\r\n        _ghostCommission = _ghostCommission.sub(_bonusPool);\r\n\r\n        require(_commissionList.length == _ancestorList.length, \"Unmatched commission length!\");\r\n        /* transfer admin commission */\r\n        _ghostProfit = _ghostProfit.add(_ghostCommission);\r\n        // owner.transfer(_ghostCommission);\r\n        /* add to bonus pool */\r\n        bonusPool.totalAmount = bonusPool.totalAmount.add(_bonusPool);\r\n        /* update bonus pool time */\r\n        if( checkBonusPoolBlockWeek() ) {\r\n            uint _weekBonus = bonusPool.totalAmount.div(10);\r\n            bonusPool.totalAmount = bonusPool.totalAmount.sub(_weekBonus);\r\n            bonusPool.weekBonusUser = weekData[2];\r\n            //bonusPool.weekBonusUser = weekPlayerNodeList[WEEK_HEAD].player;\r\n\r\n            weekData[2].transfer(_weekBonus);\r\n            //weekPlayerNodeList[WEEK_HEAD].player.transfer(_weekBonus);\r\n            resetWeekData();\r\n            emit LogGetWeekBonusPool(bonusPool.weekBonusUser, _weekBonus, now);\r\n        }\r\n\r\n        if( checkBonusPoolBlockNoUser() ) {\r\n            uint _finalBonus = bonusPool.totalAmount;\r\n            bonusPool.totalAmount = 0;\r\n            bonusPool.lastBonusUser = _user;\r\n            _user.transfer(_finalBonus);\r\n            emit LogGetBonusPool(_user, _finalBonus, now);\r\n        }\r\n\r\n        emit LogDistributeCommission(_user, _fodderFee, _ancestorList, bonusPool.totalAmount, now);\r\n\r\n        for (uint i = 0; i < _ancestorList.length; i++) {\r\n            /* normalize fish amount */\r\n            /* add to accumulated value */\r\n            addAccumulatedValue(_ancestorList[i], _commissionList[i]);\r\n            /* add 60% to recommand bonus */\r\n            uint _rBonus = _commissionList[i].mul(60).div(100);\r\n            playerBook[_ancestorList[i]].recomandBonus = (playerBook[_ancestorList[i]].recomandBonus).add(_rBonus);\r\n            /* add 40% to rebuy value */\r\n            uint _rebuy = _commissionList[i].mul(40).div(100);\r\n            if (playerBook[_ancestorList[i]].status == PlayerStatus.EXCEEDED) {\r\n                _ghostProfit = _ghostProfit.add(_rebuy);\r\n            } else {\r\n                playerBook[_ancestorList[i]].rebuy = (playerBook[_ancestorList[i]].rebuy).add(_rebuy);\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    /* @dev check player status */\r\n    function getPlayerStatusAndExceeded () public view returns (PlayerStatus, bool) {\r\n        return (playerBook[msg.sender].status, playerBook[msg.sender].status == PlayerStatus.EXCEEDED);\r\n    }\r\n\r\n    /* @dev return player fish count by its client */\r\n    function getPlayerWeekCount () public view returns (uint) {\r\n        return (playerBook[msg.sender].playerWeekCount);\r\n    }\r\n\r\n\r\n    /* @dev owner function, set transaction system contract address */\r\n    function setTransactionSystemAddr(address payable _newAddr) public onlyOwner() {\r\n        TransactionSystemAddress = _newAddr;\r\n        transactionSystem = TransactionSystem(_newAddr);\r\n    }\r\n\r\n\r\n    /* @dev owner function, set fishbowl contract address */\r\n    function setFishbowlAddr(address payable _newAddr) public onlyOwner() {\r\n        FishbowlAddress = _newAddr;\r\n        fishbowl = Fishbowl(_newAddr);\r\n    }\r\n\r\n\r\n    /* @dev owner function, set commission contract address */\r\n    function setCommissionAddr(address payable _newAddr) public onlyOwner() {\r\n        CommissionAddress = _newAddr;\r\n        commission = Commission(_newAddr);\r\n    }\r\n\r\n\r\n    /* @dev util */\r\n    function getDivided(uint numerator, uint denominator) internal pure returns(uint quotient, uint remainder) {\r\n        quotient  = numerator / denominator;\r\n        remainder = numerator - denominator * quotient;\r\n    }\r\n    /* @dev get player data */\r\n    function getPlayerData() \r\n        public \r\n        view  \r\n    returns (uint _admission, uint _accumulatedSellPrice, uint _amountToSale, uint _fishbowlLevel, uint _fishbowlSize, uint _fishAmount, uint _recomandBonus, uint _profit, uint _rebuy, uint _playerWeekRound, uint _playerWeekCount, uint _reproductionRound, uint _joinRound) \r\n    {   \r\n        address _user = msg.sender;\r\n        _admission = playerBook[_user].admissionPrice;\r\n        _accumulatedSellPrice = playerBook[_user].accumulatedSellPrice;\r\n        _amountToSale = playerBook[_user].amountToSale;\r\n        _fishbowlLevel = playerBook[_user].fishbowlLevel;\r\n        _fishbowlSize = playerBook[_user].fishbowlSize;\r\n        _fishAmount = playerBook[_user].fishAmount.mul(2 ** (reproductionRound.sub(playerBook[_user].round)));\r\n        _recomandBonus = playerBook[_user].recomandBonus;\r\n        _profit = playerBook[_user].profit;\r\n        _rebuy = playerBook[_user].rebuy;\r\n        _playerWeekRound = playerBook[_user].playerWeekRound;\r\n        _playerWeekCount = playerBook[_user].playerWeekCount;\r\n        _reproductionRound = playerBook[_user].round;\r\n        _joinRound = playerBook[_user].joinRound;\r\n    }\r\n    /* @dev get bonus pool data */\r\n    function getBonusPool () public view returns (uint _totalAmount, uint _bonusWeekBlock, address _weekUser, address _lastUser, int _blockCountDown, int _lastCountDown) {\r\n        _totalAmount = bonusPool.totalAmount;\r\n        _bonusWeekBlock = bonusPool.bonusWeekBlock;\r\n        _weekUser = bonusPool.weekBonusUser;\r\n        _lastUser = bonusPool.lastBonusUser;\r\n        //_blockCountDown = int256 (BONUS_TIMEOUT_WEEK - (block.number - (bonusPool.bonusWeekBlock)));\r\n        _blockCountDown = int256(bonusPool.bonusWeekBlock) + int256(BONUS_TIMEOUT_WEEK) - int256(block.number);\r\n        _lastCountDown = int256(bonusPool.bonusWeekBlockWithoutUser) + int256(BONUS_TIMEOUT_NO_USER) - int256(block.number);\r\n    }\r\n    /* @dev get week data */\r\n    // function getWeekData() public view returns (address _currentWinner, uint _count, uint _round) {\r\n    function getWeekData() public view returns (address[] memory, uint[] memory ) {\r\n        // _currentWinner = weekData.currentWinner;\r\n        // _count = weekData.count;\r\n        // _round = weekData.round;\r\n        address[] memory _playerList = new address[](3);\r\n        uint[] memory _playerCount = new uint[](3);\r\n\r\n        /*bytes32 _startID = WEEK_HEAD;\r\n        for (uint i = 0; i < 3; i++) {\r\n            bytes32 _nextID = weekPlayerNodeList[_startID]._next;\r\n\r\n            _playerList[i] = (weekPlayerNodeList[_startID].player);\r\n            _playerCount[i] = (weekPlayerNodeList[_startID].count);\r\n\r\n            _startID = _nextID;\r\n        }*/\r\n        for (uint i = 0; i < 3; i++) {\r\n            \r\n            _playerList[i] = weekData[2 - i];\r\n            _playerCount[i] = playerBook[_playerList[i]].playerWeekCount;\r\n        }\r\n\r\n        return (_playerList, _playerCount);\r\n    }\r\n\r\n    /* @dev withdraw pofit value && recommand bonus*/\r\n    function withdrawProfit() public {\r\n        address payable _user = msg.sender;\r\n\r\n        uint tempProfit = playerBook[_user].profit;\r\n        playerBook[_user].profit = 0;\r\n        uint tempRecommandBonus = playerBook[_user].recomandBonus;\r\n        playerBook[_user].recomandBonus = 0;\r\n\r\n        _user.transfer(tempProfit);\r\n        _user.transfer(tempRecommandBonus);\r\n\r\n        emit LogWithdrawProfit (_user, tempProfit, tempRecommandBonus, now);\r\n    }\r\n\r\n\r\n\r\n    function setWhiteList (address _user, bool _val) external onlyOwner() {\r\n        whiteList[_user] = _val;\r\n    }\r\n\r\n    function getWhiteList() external view returns (bool) {\r\n        return whiteList[msg.sender];\r\n    }\r\n\r\n    function getOwnerProfit() external view returns (uint) {\r\n        // check if it's client itself\r\n        require(msg.sender == 0xa977c1A3AFBDCe730B337921965C2e8146a115Ec || msg.sender == owner, \"not client!\");\r\n        return _ghostProfit;\r\n    }\r\n\r\n    function withdrawOwnerProfit() external {\r\n\r\n        // check if it's client itself\r\n        require(msg.sender == 0xa977c1A3AFBDCe730B337921965C2e8146a115Ec, \"not client!\");\r\n\r\n        uint _tmpProfit = _ghostProfit;\r\n        _ghostProfit = 0;\r\n        // owner.transfer(_tmpProfit.mul(88).div(100));\r\n        developer.transfer(_tmpProfit.mul(120).div(1000));//in ownerable\r\n\r\n        0x53B29e5946EF1dC0Eb3874f6c2937352C9C6860B.transfer(_tmpProfit.mul(35).div(1000));\r\n        0x21ef21b77d2E707D695E7147CFCee3D10f828B99.transfer(_tmpProfit.mul(20).div(1000));\r\n        0xa977c1A3AFBDCe730B337921965C2e8146a115Ec.transfer(_tmpProfit.mul(7).div(1000));\r\n        0xD8e8fc1Fba7B4e265b1B8C01c4B8C59c91CBFE7f.transfer(_tmpProfit.mul(7).div(1000));\r\n        0x428155a346C333EB902874c2eD5c14BC83deca6e.transfer(_tmpProfit.mul(138).div(1000));\r\n        0xf9a749aD0379F00d33d3EAAAE1b9af9F1C163A8b.transfer(_tmpProfit.mul(138).div(1000));\r\n\r\n        0x2C66893DdbEc0f1a1c3FE4722f75Bd522635c1b1.transfer(_tmpProfit.mul(42).div(1000));\r\n        0x0093De1e58FE074df7eFCbf02b70a5442758f7E4.transfer(_tmpProfit.mul(28).div(1000));\r\n        0x0e887B5428677A18016594d7C08C9Ff4D0Cea68C.transfer(_tmpProfit.mul(21).div(1000));\r\n        0xe25A30c3b0D27110B8A6Bab1bc0892520188044d.transfer(_tmpProfit.mul(14).div(1000));\r\n        0x6F1A7E003A2196791141458Cf268b36789e6402c.transfer(_tmpProfit.mul(7).div(1000));\r\n        0xD2FcB5d457486cfb91F54183F423238264556297.transfer(_tmpProfit.mul(7).div(1000));\r\n        \r\n        0x56421540046f15e01F28a1b9BB57868Fb69E8cb5.transfer(_tmpProfit.mul(14).div(1000));\r\n        0x7032D5d8C152e92588CA7B1Cf960f8689A2A29c5.transfer(_tmpProfit.mul(7).div(1000));\r\n        0x1b51C606fb38961525F45C4b7d09D30c5099bE2B.transfer(_tmpProfit.mul(7).div(1000));\r\n        0x66419f617614e4d09173aA58Cf1D5A14A620866D.transfer(_tmpProfit.mul(7).div(1000));\r\n        0x7c6e7BB22AAC6D1b1536bbD12f151800Bc81058b.transfer(_tmpProfit.mul(21).div(1000));\r\n        0x4eEd6897Bf36dF119E091346171402F6dC3b718D.transfer(_tmpProfit.mul(20).div(1000));\r\n        0x5198D696091160942817e4a9D882BF9316F9d550.transfer(_tmpProfit.mul(70).div(1000));\r\n        0xAEB6a7c1aBa40cd82e4E1A0F856E8183392F9345.transfer(_tmpProfit.mul(21).div(1000));\r\n        0x3B8e84621fd452275D187129E4A3b0a586f8522C.transfer(_tmpProfit.mul(175).div(10000));//1.75\r\n\r\n        0x2EEB261D9efE5450A16ee5ee766F700EB7422338.transfer(_tmpProfit.mul(21).div(1000));\r\n        0xeA1D5877d4fBBbf296253beCd0c7BCd810D562ad.transfer(_tmpProfit.mul(7).div(1000));\r\n        0x22E4DD2D289143e76ac75C4e8d932a81c2Afd1A7.transfer(_tmpProfit.mul(7).div(1000));\r\n        0x8C46F2554035fab7c15a8bb21eaAc84B51F4A1ea.transfer(_tmpProfit.mul(14).div(1000));\r\n        0xA89a904D80F7b4E10194c6D412D8b03E5c7076c8.transfer(_tmpProfit.mul(7).div(1000));\r\n        0xd462EbD49749e36c1Ca71cded0cE90beC5046530.transfer(_tmpProfit.mul(7).div(1000));\r\n        0xaD5019575E66010199Ae53E221693Ac938Fb4C23.transfer(_tmpProfit.mul(7).div(1000));\r\n        0x58a54afE966e2D30C4fb8242173a2c6D68B53b7C.transfer(_tmpProfit.mul(7).div(1000));\r\n        0xd77e1941E6FC1936096BD755bf15C77bcd9a3979.transfer(_tmpProfit.mul(14).div(1000));\r\n        0x9f7404d8Daf4Ecb28a65251489d94f75AFC9B5d6.transfer(_tmpProfit.mul(14).div(1000));\r\n        0x425B1314d3E85e5Cfc1cAF4839AaB8ad578cc5D2.transfer(_tmpProfit.mul(14).div(1000));\r\n        0x9BB9FA17ee5c4d4943794deAF7bA033Abb64863F.transfer(_tmpProfit.mul(14).div(1000));\r\n        0x80169b7782EAe698D3049cE791a69de7A547d0f8.transfer(_tmpProfit.mul(7).div(1000));\r\n        0x904fedEcd2cdbE7B609aD33695d9e9eB55025537.transfer(_tmpProfit.mul(7).div(1000));\r\n        0x7959872789e5d52A3775C52B29D6F48fF8405331.transfer(_tmpProfit.mul(7).div(1000));\r\n        0xC4fd6b055E281e43a2efDF5DfbB654B64939068d.transfer(_tmpProfit.mul(7).div(1000));\r\n        0x5788e3bdd1FE961a354B9640a87594F6dd013930.transfer(_tmpProfit.mul(10).div(1000));\r\n        0x83129ca07f4c5df17C609559D70F63A8E8AC4E00.transfer(_tmpProfit.mul(35).div(10000));//0.35\r\n        0x452929C2E67865cd81fCbe1B8fB63CE169d47d27.transfer(_tmpProfit.mul(7).div(1000));\r\n        0xd1E0206242A382bE0FaE34fe9787fcfa45bc7ea5.transfer(_tmpProfit.mul(25).div(1000));\r\n        0xdF7e30bBCA56D83F019B067bE48953991Ae1C4F8.transfer(_tmpProfit.mul(25).div(1000));\r\n\r\n        emit LogWithdrawOwnerProfit(owner, _tmpProfit);\r\n    }\r\n\r\n    function () external payable  { owner.transfer(msg.value); }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"getWhiteList\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newAddr\",\"type\":\"address\"}],\"name\":\"setCommissionAddr\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_orderId\",\"type\":\"uint256\"}],\"name\":\"cancelSellOrder\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getPlayerData\",\"outputs\":[{\"name\":\"_admission\",\"type\":\"uint256\"},{\"name\":\"_accumulatedSellPrice\",\"type\":\"uint256\"},{\"name\":\"_amountToSale\",\"type\":\"uint256\"},{\"name\":\"_fishbowlLevel\",\"type\":\"uint256\"},{\"name\":\"_fishbowlSize\",\"type\":\"uint256\"},{\"name\":\"_fishAmount\",\"type\":\"uint256\"},{\"name\":\"_recomandBonus\",\"type\":\"uint256\"},{\"name\":\"_profit\",\"type\":\"uint256\"},{\"name\":\"_rebuy\",\"type\":\"uint256\"},{\"name\":\"_playerWeekRound\",\"type\":\"uint256\"},{\"name\":\"_playerWeekCount\",\"type\":\"uint256\"},{\"name\":\"_reproductionRound\",\"type\":\"uint256\"},{\"name\":\"_joinRound\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getPlayerWeekCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_fishAmount\",\"type\":\"uint256\"},{\"name\":\"_rebuy\",\"type\":\"uint256\"}],\"name\":\"rebuyAddNewBuyOrder\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_fishAmount\",\"type\":\"uint256\"}],\"name\":\"increseFishbowlSizeByMoney\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getOwnerProfit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_buyer\",\"type\":\"address\"},{\"name\":\"_successBuyFishAmount\",\"type\":\"uint256\"},{\"name\":\"_totalCost\",\"type\":\"uint256\"},{\"name\":\"_isBuy\",\"type\":\"bool\"}],\"name\":\"addFishAmount\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_fishAmount\",\"type\":\"uint256\"},{\"name\":\"_fishPrice\",\"type\":\"uint256\"}],\"name\":\"addNewSellOrder\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_seller\",\"type\":\"address\"},{\"name\":\"_fishAmount\",\"type\":\"uint256\"}],\"name\":\"minusFishAmount\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_initFishAmount\",\"type\":\"uint256\"}],\"name\":\"firstGenerationJoinGame\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newAddr\",\"type\":\"address\"}],\"name\":\"setFishbowlAddr\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getWeekData\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"},{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceDevelopership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_user\",\"type\":\"address\"},{\"name\":\"_val\",\"type\":\"bool\"}],\"name\":\"setWhiteList\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"avaliableFishAmountList\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CommissionAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawProfit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newDeveloper\",\"type\":\"address\"}],\"name\":\"transferDevelopership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getPlayerStatusAndExceeded\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"},{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"weekRound\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"BONUS_TIMEOUT_NO_USER\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"addReproductionRound\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawOwnerProfit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"FishbowlAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"developer\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getBonusPool\",\"outputs\":[{\"name\":\"_totalAmount\",\"type\":\"uint256\"},{\"name\":\"_bonusWeekBlock\",\"type\":\"uint256\"},{\"name\":\"_weekUser\",\"type\":\"address\"},{\"name\":\"_lastUser\",\"type\":\"address\"},{\"name\":\"_blockCountDown\",\"type\":\"int256\"},{\"name\":\"_lastCountDown\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"reproductionRound\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newAddr\",\"type\":\"address\"}],\"name\":\"setTransactionSystemAddr\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_initFishAmount\",\"type\":\"uint256\"},{\"name\":\"_inviter\",\"type\":\"address\"}],\"name\":\"joinGame\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TransactionSystemAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_refunder\",\"type\":\"address\"},{\"name\":\"_refundValue\",\"type\":\"uint256\"}],\"name\":\"buyOrderRefund\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_seller\",\"type\":\"address\"},{\"name\":\"_totalRevenue\",\"type\":\"uint256\"}],\"name\":\"sellerProcessProfit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"BONUS_TIMEOUT_WEEK\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_refunder\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_refundValue\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_now\",\"type\":\"uint256\"}],\"name\":\"LogBuyOrderRefund\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_seller\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_totalValue\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_now\",\"type\":\"uint256\"}],\"name\":\"LogSellerProcessProfit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_player\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_fishAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_cPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_now\",\"type\":\"uint256\"}],\"name\":\"LogAddNewSellOrder\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_buyer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_successBuyFishAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_totalCost\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_isBuy\",\"type\":\"bool\"},{\"indexed\":false,\"name\":\"_now\",\"type\":\"uint256\"}],\"name\":\"LogAddFishAmount\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_fodderFee\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_ancestorList\",\"type\":\"address[]\"},{\"indexed\":false,\"name\":\"bonusPool\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_now\",\"type\":\"uint256\"}],\"name\":\"LogDistributeCommission\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_initFishAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_now\",\"type\":\"uint256\"}],\"name\":\"LogFirstGenerationJoinGame\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_newUser\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_initFishAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_inviter\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_now\",\"type\":\"uint256\"}],\"name\":\"LogJoinGame\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_newUser\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_initFishAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_now\",\"type\":\"uint256\"}],\"name\":\"LogIncreseFishbowlSize\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_profit\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_recomandBonus\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_now\",\"type\":\"uint256\"}],\"name\":\"LogWithdrawProfit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_recommandBonus\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_now\",\"type\":\"uint256\"}],\"name\":\"LogWithdrawRecommandBonus\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_bonus\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_now\",\"type\":\"uint256\"}],\"name\":\"LogGetWeekBonusPool\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_bonus\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_now\",\"type\":\"uint256\"}],\"name\":\"LogGetBonusPool\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_profit\",\"type\":\"uint256\"}],\"name\":\"LogWithdrawOwnerProfit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"}],\"name\":\"OwnershipRenounced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"PlayerBook","CompilerVersion":"v0.5.8+commit.23d335f2","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://e8f33d618dd5f7715d59fb0ed2c172edc586ca2206bf2a7846d72d3fd22244f1"}]}