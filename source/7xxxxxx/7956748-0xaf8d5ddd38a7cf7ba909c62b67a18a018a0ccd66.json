{"status":"1","message":"OK","result":[{"SourceCode":"{\"AuctionityLibrary_V1.sol\":{\"content\":\"pragma solidity ^0.5.4;\\n\\nimport \\\"./AuctionityStorage0.sol\\\";\\n\\n/// @title Auction library for delegate for some delegated function\\ncontract AuctionityLibrary_V1 is AuctionityStorage0 {\\n    /// @notice get delegated addrss from a selector\\n    /// @param _selector byte4\\n    /// @return _contractDelegate address\\n    function getDelegate_V1(bytes4 _selector)\\n        public\\n        view\\n        returns (address _contractDelegate)\\n    {\\n        return delegates[_selector];\\n    }\\n\\n    /// @notice call delegated function\\n    /// @param _calldata bytes : data sended to delegated contract\\n    /// @param _contractFallback address: address of fallback if selector is not exist, address(0) if no fallback\\n    /// @return uint return pointer and uint return size of callData return\\n    function _callDelegated_V1(\\n        bytes memory _calldata,\\n        address _contractFallback\\n    ) internal returns (uint returnPtr, uint returnSize) {\\n        /// @dev get selector from _calldata\\n        bytes4 _selector;\\n        assembly {\\n            _selector := mload(add(_calldata, 0x20))\\n        }\\n\\n        /// @dev get address of delegated from selector\\n        address _contractDelegate = getDelegate_V1(_selector);\\n\\n        /// @dev if _contractDelegate not found set _contractFallback into _contractFallback\\n        if (_contractDelegate == address(0)) {\\n            _contractDelegate = _contractFallback;\\n        }\\n\\n        require(\\n            _contractDelegate != address(0),\\n            \\\"Auctionity function does not exist.\\\"\\n        );\\n\\n        /// @dev delegate call and return result, or the eventual revert\\n        assembly {\\n            let result := delegatecall(\\n                gas,\\n                _contractDelegate,\\n                add(_calldata, 0x20),\\n                mload(_calldata),\\n                0,\\n                0\\n            )\\n            returnSize := returndatasize\\n            returnPtr := mload(0x40)\\n            returndatacopy(returnPtr, 0, returnSize)\\n            if eq(result, 0) {\\n                revert(returnPtr, returnSize)\\n            }\\n        }\\n\\n        /// @dev return returndatacopy\\n        return (returnPtr, returnSize);\\n\\n    }\\n\\n    /// @notice delegate IsContractOwner_V1\\n    /// @return  _isContractOwner\\n    function delegatedSendIsContractOwner_V1()\\n        public\\n        returns (bool _isContractOwner)\\n    {\\n        uint returnPtr;\\n        uint returnSize;\\n\\n        (returnPtr, returnSize) = _callDelegated_V1(\\n            abi.encodeWithSelector(\\n                bytes4(keccak256(\\\"delegatedReceiveIsContractOwner_V1()\\\"))\\n            ),\\n            address(0)\\n        );\\n\\n        assembly {\\n            _isContractOwner := mload(returnPtr)\\n        }\\n\\n        return _isContractOwner;\\n    }\\n\\n    modifier delegatedSendIsOracle_V1() {\\n        require(\\n            msg.sender == delegatedSendGetOracle_V1(),\\n            \\\"Sender must be oracle\\\"\\n        );\\n        _;\\n    }\\n\\n    /// @notice delegate getOracle_V1\\n    /// @return address _oracle\\n    function delegatedSendGetOracle_V1() public returns (address _oracle) {\\n        uint returnPtr;\\n        uint returnSize;\\n\\n        (returnPtr, returnSize) = _callDelegated_V1(\\n            abi.encodeWithSelector(\\n                bytes4(keccak256(\\\"delegatedReceiveGetOracle_V1()\\\"))\\n            ),\\n            address(0)\\n        );\\n\\n        assembly {\\n            _oracle := mload(returnPtr)\\n        }\\n        return _oracle;\\n\\n    }\\n\\n    /// @notice delegate getPaused_V1\\n    /// @return bool _isPaused\\n    function delegatedSendGetPaused_V1() public returns (bool _isPaused) {\\n        uint returnPtr;\\n        uint returnSize;\\n\\n        (returnPtr, returnSize) = _callDelegated_V1(\\n            abi.encodeWithSelector(\\n                bytes4(keccak256(\\\"delegatedReceiveGetPaused_V1()\\\"))\\n            ),\\n            address(0)\\n        );\\n        assembly {\\n            _isPaused := mload(returnPtr)\\n        }\\n        return _isPaused;\\n\\n    }\\n\\n    /// @notice delegate lockDeposit_V1\\n    /// @param _tokenContractAddress address\\n    /// @param _tokenId uint256\\n    /// @param _amount uint256\\n    /// @param _auctionId uint256\\n    /// @param _refundUser address\\n    /// @return bool _isPaused\\n    function delegatedLockDeposit_V1(\\n        address _tokenContractAddress,\\n        uint256 _tokenId,\\n        uint256 _amount,\\n        uint256 _auctionId,\\n        address _refundUser\\n    ) public returns (bool _success) {\\n        uint returnPtr;\\n        uint returnSize;\\n\\n        (returnPtr, returnSize) = _callDelegated_V1(\\n            abi.encodeWithSelector(\\n                bytes4(\\n                    keccak256(\\n                        \\\"lockDeposit_V1(address,uint256,uint256,uint256,address)\\\"\\n                    )\\n                ),\\n                _tokenContractAddress,\\n                _tokenId,\\n                _amount,\\n                _auctionId,\\n                _refundUser\\n            ),\\n            address(0)\\n        );\\n\\n        assembly {\\n            _success := mload(returnPtr)\\n        }\\n        return _success;\\n\\n    }\\n\\n    /// @notice verify if _contractAddress is a contract\\n    /// @param _contractAddress address\\n    /// @return _isContract\\n    function isContract_V1(address _contractAddress)\\n        internal\\n        view\\n        returns (bool _isContract)\\n    {\\n        uint _size;\\n        assembly {\\n            _size := extcodesize(_contractAddress)\\n        }\\n        return _size \\u003e 0;\\n    }\\n\\n    /// @notice cast a bytesmemory into a uint256\\n    /// @param b bytes\\n    /// @return uint256\\n    function bytesToUint_V1(bytes memory b) internal pure returns (uint256) {\\n        uint256 _number;\\n        for (uint i = 0; i \\u003c b.length; i++) {\\n            _number = _number + uint8(b[i]) * (2 ** (8 * (b.length - (i + 1))));\\n        }\\n        return _number;\\n    }\\n}\\n\"},\"AuctionityOwnable_V1.sol\":{\"content\":\"pragma solidity ^0.5.4;\\n\\nimport \\\"./AuctionityStorage0.sol\\\";\\n\\n/// @title Ownable\\n/// @dev The Ownable contract has an owner address, and provides basic authorization control\\n/// functions, this simplifies the implementation of \\\"user permissions\\\".\\n\\ncontract AuctionityOwnable_V1 is AuctionityStorage0 {\\n    event OwnershipRenounced_V1(address indexed previousOwner);\\n    event OwnershipTransferred_V1(\\n        address indexed previousOwner,\\n        address indexed newOwner\\n    );\\n\\n    /// @notice get contract owner address\\n    /// @return _contractOwner address\\n    function getContractOwner_V1()\\n        public\\n        view\\n        returns (address _contractOwner)\\n    {\\n        return contractOwner;\\n    }\\n\\n    /// @notice delegate receive of isContractOwner\\n    /// @return  _isContractOwner bool\\n    function delegatedReceiveIsContractOwner_V1()\\n        public\\n        payable\\n        returns (bool _isContractOwner)\\n    {\\n        return isContractOwner_V1();\\n    }\\n\\n    /// @notice verify if msg.sender is contract owner\\n    /// @return _isContractOwner bool\\n    function isContractOwner_V1() public view returns (bool _isContractOwner) {\\n        return msg.sender == contractOwner;\\n    }\\n\\n    /// @notice Renouncing to ownership will leave the contract without an owner.\\n    function renounceOwnership_V1() public {\\n        require(isContractOwner_V1(), \\\"Not the owner\\\");\\n        emit OwnershipRenounced_V1(contractOwner);\\n        contractOwner = address(0);\\n    }\\n\\n    /// @notice Allows the current owner to transfer control of the contract to a newOwner.\\n    /// @param newOwner The address to transfer ownership to.\\n    function transferOwnership_V1(address newOwner) public {\\n        require(isContractOwner_V1(), \\\"Not the owner\\\");\\n        _transferOwnership_V1(newOwner);\\n    }\\n\\n    /// @notice Transfers control of the contract to a newOwner.\\n    /// @param newOwner The address to transfer ownership to.\\n    function _transferOwnership_V1(address newOwner) internal {\\n        require(newOwner != address(0));\\n        emit OwnershipTransferred_V1(contractOwner, newOwner);\\n        contractOwner = newOwner;\\n    }\\n}\\n\"},\"AuctionityProxyUpdate_V1.sol\":{\"content\":\"pragma solidity ^0.5.4;\\n\\nimport \\\"./AuctionityStorage0.sol\\\";\\nimport \\\"./AuctionityOwnable_V1.sol\\\";\\nimport \\\"./AuctionityLibrary_V1.sol\\\";\\n\\n/**\\n * @title ProxyUpdate\\n */\\ncontract AuctionityProxyUpdate_V1 is AuctionityLibrary_V1 {\\n    event LogSelectorAdded_V1(bytes4 selector, address delegate);\\n    event LogSelectorUpdated_V1(\\n        bytes4 selector,\\n        address delegate,\\n        address previousDelegate\\n    );\\n    event LogSelectorRemoved_V1(bytes4 selector, address delegate);\\n    event LogProxyFallbackContractUpdated_V1(address proxyFallbackContract);\\n\\n    /// @notice Implement all selector for initial proxy update and ownable\\n    /// @dev this is call only by proxy contract\\n    /// @param _proxyUpdates address : contract proxyUpdate (this contract deployed)\\n    /// @param _ownable address : contract ownable\\n    function initProxyContract_V1(address _proxyUpdates, address _ownable)\\n        public\\n    {\\n        require(contractOwner == address(0), \\\"Contract owner has been set.\\\");\\n        contractOwner = msg.sender;\\n\\n        _initProxyContract_V1(\\n            _proxyUpdates,\\n            bytes4(keccak256(\\\"addSelectors_V1(address,bytes4[])\\\"))\\n        );\\n        _initProxyContract_V1(\\n            _proxyUpdates,\\n            bytes4(keccak256(\\\"updateSelectors_V1(address,bytes4[])\\\"))\\n        );\\n        _initProxyContract_V1(\\n            _proxyUpdates,\\n            bytes4(keccak256(\\\"removeSelectors_V1(bytes4[])\\\"))\\n        );\\n        _initProxyContract_V1(\\n            _proxyUpdates,\\n            bytes4(keccak256(\\\"updateProxyFallbackContract_V1(address)\\\"))\\n        );\\n        _initProxyContract_V1(\\n            _ownable,\\n            bytes4(keccak256(\\\"getContractOwner_V1()\\\"))\\n        );\\n        _initProxyContract_V1(\\n            _ownable,\\n            bytes4(keccak256(\\\"delegatedReceiveIsContractOwner_V1()\\\"))\\n        );\\n        _initProxyContract_V1(\\n            _ownable,\\n            bytes4(keccak256(\\\"isContractOwner_V1()\\\"))\\n        );\\n        _initProxyContract_V1(\\n            _ownable,\\n            bytes4(keccak256(\\\"renounceOwnership_V1()\\\"))\\n        );\\n        _initProxyContract_V1(\\n            _ownable,\\n            bytes4(keccak256(\\\"transferOwnership_V1(address)\\\"))\\n        );\\n\\n    }\\n\\n    /// @notice Add selector only in intitate contract\\n    /// @param _delegate address : contract delegated\\n    /// @param _selector bytes4 : selector implemented for delegated contract\\n    function _initProxyContract_V1(address _delegate, bytes4 _selector)\\n        internal\\n    {\\n        require(\\n            delegates[_selector] == address(0),\\n            \\\"_initProxyContract_V1 FuncId clash\\\"\\n        );\\n        delegates[_selector] = _delegate;\\n        emit LogSelectorAdded_V1(_selector, _delegate);\\n    }\\n\\n    /// @notice Add selector from proxy\\n    /// @param _delegate address : contract delegated\\n    /// @param _selectors bytes4[] : list of selector implemented for delegated contract\\n    function addSelectors_V1(address _delegate, bytes4[] memory _selectors)\\n        public\\n    {\\n        require(\\n            delegatedSendIsContractOwner_V1(),\\n            \\\"addSelectors_V1 Contract owner\\\"\\n        );\\n\\n        require(_delegate != address(0), \\\"delegate can\\u0027t be zero address.\\\");\\n\\n        for (uint selectorIndex; selectorIndex \\u003c _selectors.length; selectorIndex++) {\\n            require(\\n                delegates[_selectors[selectorIndex]] == address(0),\\n                \\\"FuncId clash.\\\"\\n            );\\n            delegates[_selectors[selectorIndex]] = _delegate;\\n            emit LogSelectorAdded_V1(_selectors[selectorIndex], _delegate);\\n        }\\n    }\\n\\n    /// @notice Update selector from proxy\\n    /// @param _delegate address : contract delegated\\n    /// @param _selectors bytes4[] : list of selector implemented for delegated contract\\n    function updateSelectors_V1(address _delegate, bytes4[] memory _selectors)\\n        public\\n    {\\n        require(\\n            delegatedSendIsContractOwner_V1(),\\n            \\\"updateSelectors_V1 Contract owner\\\"\\n        );\\n\\n        require(_delegate != address(0), \\\"delegate can\\u0027t be zero address.\\\");\\n\\n        for (uint selectorIndex; selectorIndex \\u003c _selectors.length; selectorIndex++) {\\n            require(\\n                delegates[_selectors[selectorIndex]] != address(0),\\n                \\\"Selector does not exist.\\\"\\n            );\\n            address previousDelegate = delegates[_selectors[selectorIndex]];\\n            delegates[_selectors[selectorIndex]] = _delegate;\\n            emit LogSelectorUpdated_V1(\\n                _selectors[selectorIndex],\\n                _delegate,\\n                previousDelegate\\n            );\\n\\n        }\\n    }\\n\\n    /// @notice remove selector from proxy\\n    /// @param _selectors bytes4[] : list of selector implemented for delegated contract\\n    function removeSelectors_V1(bytes4[] memory _selectors) public {\\n        require(\\n            delegatedSendIsContractOwner_V1(),\\n            \\\"removeSelectors_V1 Contract owner\\\"\\n        );\\n\\n        for (uint selectorIndex; selectorIndex \\u003c _selectors.length; selectorIndex++) {\\n            require(\\n                delegates[_selectors[selectorIndex]] != address(0),\\n                \\\"Selector does not exist.\\\"\\n            );\\n            address previousDelegate = delegates[_selectors[selectorIndex]];\\n            delete delegates[_selectors[selectorIndex]];\\n            emit LogSelectorRemoved_V1(\\n                _selectors[selectorIndex],\\n                previousDelegate\\n            );\\n\\n        }\\n    }\\n\\n    /// @notice add a fallback contract for another selector unimplemented\\n    /// @param _proxyFallbackContract address : contract fallback delegated\\n    function updateProxyFallbackContract_V1(address _proxyFallbackContract)\\n        public\\n    {\\n        require(\\n            delegatedSendIsContractOwner_V1(),\\n            \\\"updateProxyFallbackContract_V1 Contract owner\\\"\\n        );\\n\\n        proxyFallbackContract = _proxyFallbackContract;\\n\\n        emit LogProxyFallbackContractUpdated_V1(_proxyFallbackContract);\\n\\n    }\\n}\\n\"},\"AuctionityStorage0.sol\":{\"content\":\"pragma solidity ^0.5.4;\\n\\ncontract AuctionityStorage0 {\\n    // selector =\\u003e delegate contract\\n    mapping(bytes4 =\\u003e address) internal delegates;\\n\\n    // If selector not found, fallback contract address\\n    address public proxyFallbackContract;\\n\\n    address public contractOwner;\\n    address public oracle;\\n\\n    bool public paused;\\n\\n    uint8 public ethereumChainId;\\n    uint8 public auctionityChainId;\\n}\\n\"}}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"ethereumChainId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_selectors\",\"type\":\"bytes4[]\"}],\"name\":\"removeSelectors_V1\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"delegatedSendGetOracle_V1\",\"outputs\":[{\"name\":\"_oracle\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenContractAddress\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_auctionId\",\"type\":\"uint256\"},{\"name\":\"_refundUser\",\"type\":\"address\"}],\"name\":\"delegatedLockDeposit_V1\",\"outputs\":[{\"name\":\"_success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_delegate\",\"type\":\"address\"},{\"name\":\"_selectors\",\"type\":\"bytes4[]\"}],\"name\":\"addSelectors_V1\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"oracle\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_proxyFallbackContract\",\"type\":\"address\"}],\"name\":\"updateProxyFallbackContract_V1\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"auctionityChainId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_proxyUpdates\",\"type\":\"address\"},{\"name\":\"_ownable\",\"type\":\"address\"}],\"name\":\"initProxyContract_V1\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"proxyFallbackContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"contractOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_selector\",\"type\":\"bytes4\"}],\"name\":\"getDelegate_V1\",\"outputs\":[{\"name\":\"_contractDelegate\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"delegatedSendGetPaused_V1\",\"outputs\":[{\"name\":\"_isPaused\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_delegate\",\"type\":\"address\"},{\"name\":\"_selectors\",\"type\":\"bytes4[]\"}],\"name\":\"updateSelectors_V1\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"delegatedSendIsContractOwner_V1\",\"outputs\":[{\"name\":\"_isContractOwner\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"selector\",\"type\":\"bytes4\"},{\"indexed\":false,\"name\":\"delegate\",\"type\":\"address\"}],\"name\":\"LogSelectorAdded_V1\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"selector\",\"type\":\"bytes4\"},{\"indexed\":false,\"name\":\"delegate\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"previousDelegate\",\"type\":\"address\"}],\"name\":\"LogSelectorUpdated_V1\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"selector\",\"type\":\"bytes4\"},{\"indexed\":false,\"name\":\"delegate\",\"type\":\"address\"}],\"name\":\"LogSelectorRemoved_V1\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"proxyFallbackContract\",\"type\":\"address\"}],\"name\":\"LogProxyFallbackContractUpdated_V1\",\"type\":\"event\"}]","ContractName":"AuctionityProxyUpdate_V1","CompilerVersion":"v0.5.4+commit.9549d8ff","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://b266277ca095e93ad7867d2222a5c51e2b7a4061d9c5d14f792276e531a8aab2"}]}