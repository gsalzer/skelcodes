{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.25;\r\n\r\n /*\r\n  * @title: SafeMath\r\n  * @dev: Helper contract functions to arithmatic operations safely.\r\n  */\r\ncontract SafeMath {\r\n  function Sub(uint128 a, uint128 b) pure public returns (uint128) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function Add(uint128 a, uint128 b) pure public returns (uint128) {\r\n    uint128 c = a + b;\r\n    assert(c>=a && c>=b);\r\n    return c;\r\n  }\r\n}\r\n\r\n /*\r\n  * @title: Token\r\n  * @dev: Interface contract for ERC20 tokens\r\n  */\r\ncontract Token {\r\n  function totalSupply() public view returns (uint256 supply);\r\n  function balanceOf(address _owner) public view returns (uint256 balance);\r\n  function transfer(address _to, uint256 _value) public returns (bool success);\r\n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\r\n  function approve(address _spender, uint256 _value) public returns (bool success);\r\n  function allowance(address _owner, address _spender) public view returns (uint256 remaining);\r\n  event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n  event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}\r\n\r\n /*\r\n  * @title: Dex\r\n  * @author Dexhigh Services Pvt. Ltd (https://www.dexhigh.com)\r\n  * @dev The Dex Contract implement all the required functionalities viz order sharing, local exchange etc.\r\n  */\r\ncontract DEX is SafeMath\r\n{\r\n    uint32 public lastTransferId = 1;\r\n\r\n    // Events\r\n    event NewDeposit(uint32 indexed exId, uint32  prCode, uint32 indexed accountId, uint128 amount, uint64 timestamp, uint32 lastTransferId);\r\n    event NewWithdraw(uint32 indexed exId, uint32  prCode, uint32 indexed accountId, uint128 amount, uint64 timestamp, uint32 lastTransferId);\r\n    uint32 public lastNewOrderId = 1;\r\n    event NewOrder(uint32 indexed prTrade, uint32 indexed prBase, uint32 indexed accountId, uint32 id, bool isSell, uint80 price, uint104 qty, uint32 lastNewOrderId);\r\n    event NewCancel(uint32 indexed prTrade, uint32 indexed prBase, uint32 indexed accountId, uint32 id, bool isSell, uint80 price, uint104 qty, uint32 lastNewOrderId);\r\n    event NewBestBidAsk(uint32 indexed prTrade, uint32 indexed prBase, bool isBid, uint80 price);\r\n    uint32 public lastTradeId = 1;\r\n    event NewTrade(uint32 indexed prTrade, uint32 prBase, uint32 indexed bidId, uint32 indexed askId, uint32 accountIdBid, uint32 accountIdAsk, bool isSell, uint80 price, uint104 qty, uint32 lastTradeId, uint64 timestamp);\r\n\r\n    // basePrice, All the prices will be \"based\" by basePrice\r\n    uint256 public constant basePrice = 10000000000;\r\n    uint80 public constant maxPrice = 10000000000000000000001;\r\n    uint104 public constant maxQty = 1000000000000000000000000000001;\r\n    uint128 public constant maxBalance = 1000000000000000000000000000000000001;\r\n    bool public isContractUse = true;\r\n\r\n    //No Args constructor will add msg.sender as owner/operator\r\n    // Add ETH product\r\n    constructor() public\r\n    {\r\n        owner = msg.sender;\r\n        operator = owner;\r\n        AddOwner(msg.sender);\r\n        AddProduct(18, 0x0);\r\n        //lastProductId = 1; // productId == 1 -> ETH 0x0\r\n    }\r\n\r\n    address public owner;\r\n    // Functions with this modifier can only be executed by the owner\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    address public operator;\r\n    // Functions with this modifier can only be executed by the operator\r\n    modifier onlyOperator() {\r\n        require(msg.sender == operator);\r\n        _;\r\n    }\r\n    function transferOperator(address _operator) onlyOwner public {\r\n        operator = _operator;\r\n    }\r\n\r\n    // Functions with this modifier can only be executed by the owner of each exchange\r\n    modifier onlyExOwner()  {\r\n        require(owner_id[msg.sender] != 0);\r\n        _;\r\n    }\r\n\r\n    // Functions with this modifier can only be executed when this contract is not abandoned\r\n    modifier onlyContractUse {\r\n        require(isContractUse == true);\r\n        _;\r\n    }\r\n\r\n    uint32 public lastOwnerId;\r\n    mapping (uint32 => address) id_owner;\r\n    mapping (address => uint32) owner_id;\r\n    mapping (uint32 => uint8) ownerId_takerFeeRateLocal;\r\n    mapping (uint32 => uint32) ownerId_accountId;\r\n\r\n    //Delete the owner of exchange\r\n    function DeleteOwner(uint32 exId) onlyOperator public\r\n    {\r\n        require(lastOwnerId >= exId && exId > 0);\r\n        owner_id[id_owner[exId]] = 0;\r\n    }\r\n\r\n    //Add Owner of exchange\r\n    function AddOwner(address newOwner) onlyOperator public\r\n    {\r\n        require(owner_id[newOwner] == 0);\r\n\r\n        owner_id[newOwner] = ++lastOwnerId;\r\n        id_owner[lastOwnerId] = newOwner;\r\n\r\n        ownerId_accountId[lastOwnerId] = FindOrAddAccount(newOwner);\r\n    }\r\n    //Get exchange owner list and id\r\n    function GetOwnerList() view public returns (address[] owners, uint32[] ownerIds)\r\n    {\r\n        owners = new address[](lastOwnerId);\r\n        ownerIds = new uint32[](lastOwnerId);\r\n\r\n        for (uint32 i = 1; i <= lastOwnerId; i++)\r\n        {\r\n            owners[i - 1] = id_owner[i];\r\n            ownerIds[i - 1] = i;\r\n        }\r\n    }\r\n    //Set local exchange fee\r\n    function setTakerFeeRateLocal(uint8 _takerFeeRate) public\r\n    {\r\n        require (_takerFeeRate <= 100);// takerFeeRate cannot be more than 1%\r\n        uint32 ownerId = owner_id[msg.sender];\r\n        require(ownerId != 0);\r\n        ownerId_takerFeeRateLocal[ownerId] = _takerFeeRate;//bp\r\n    }\r\n    // Get fee Rate for an exchange with owner id == ownerId\r\n    function getTakerFeeRateLocal(uint32 ownerId) public view returns (uint8)\r\n    {\r\n        return ownerId_takerFeeRateLocal[ownerId];//bp\r\n    }\r\n\r\n    //Air Drop events\r\n    function airDrop(uint32 exId, uint32 prCode, uint32[] accountIds, uint104[] qtys) onlyExOwner public\r\n    {\r\n        uint32 accountId = FindOrRevertAccount();\r\n        require(accountId_freeze[accountId] == false);\r\n        uint256 n = accountIds.length;\r\n        require(n == qtys.length);\r\n\r\n        uint128 sum = 0;\r\n        for (uint32 i = 0; i < n; i++)\r\n        {\r\n            sum += qtys[i];\r\n        }\r\n\r\n        exId_prCode_AccountId_Balance[exId][prCode][accountId].available = Sub(exId_prCode_AccountId_Balance[exId][prCode][accountId].available, sum);\r\n\r\n        for (i = 0; i < n; i++)\r\n        {\r\n            exId_prCode_AccountId_Balance[exId][prCode][accountIds[i]].available += qtys[i];\r\n            // exId_prCode_AccountId_Balance[exId][prCode][accountIds[i]].available >> qtys[i]\r\n            // 2^128 >> 2^104 -> minimum 2^24 times of airdrop need for overflow (hard to imagine)\r\n            // because prCode_AccountId_Balance[prCode][accountIds[i]].available restircted by maxBalance in deposit function\r\n        }\r\n    }\r\n\r\n    //information of product\r\n    struct ProductInfo\r\n    {\r\n        uint256 divider;\r\n        bool isTradeBid;\r\n        bool isTradeAsk;\r\n        bool isDeposit;\r\n        bool isWithdraw;\r\n        uint32 ownerId;\r\n        uint104 minQty;\r\n    }\r\n\r\n    uint32 public lastProductId;\r\n    uint256 public newProductFee;\r\n    mapping (uint32 => address) prCode_product;\r\n    mapping (address => uint32) product_prCode;\r\n    mapping (uint32 => ProductInfo) prCode_productInfo;\r\n\r\n    // Add product by exchange owner\r\n    function AddProduct(uint256 decimals, address product) payable onlyExOwner public\r\n    {\r\n        require(msg.value >= newProductFee || msg.sender == operator);\r\n        require(product_prCode[product] == 0);\r\n        require(decimals <= 18);\r\n\r\n        product_prCode[product] = ++lastProductId;\r\n        prCode_product[lastProductId] = product;\r\n\r\n        ProductInfo memory productInfo;\r\n        productInfo.divider = 10 ** decimals; // max = 10 ^ 18 because of require(decimals <= 18);\r\n        productInfo.ownerId = owner_id[msg.sender];\r\n        prCode_productInfo[lastProductId] = productInfo;\r\n\r\n        exId_prCode_AccountId_Balance[1][1][ownerId_accountId[1]].available += uint128(msg.value); //eth transfer < 2^128\r\n    }\r\n    // Set Product Information\r\n    function SetProductInfo(uint32 prCode, bool isTradeBid, bool isTradeAsk, bool isDeposit, bool isWithdraw, uint104 _minQty, uint32 exId) public\r\n    {\r\n        ProductInfo storage prInfo = prCode_productInfo[prCode];\r\n\r\n        require(msg.sender == operator || owner_id[msg.sender] == prInfo.ownerId );\r\n\r\n        prInfo.isTradeBid = isTradeBid;\r\n        prInfo.isTradeAsk = isTradeAsk;\r\n        prInfo.isDeposit = isDeposit;\r\n        prInfo.isWithdraw = isWithdraw;\r\n        prInfo.minQty = _minQty;\r\n        prInfo.ownerId = exId;\r\n    }\r\n    // Set product listing fee\r\n    function SetProductFee(uint256 productFee) onlyOperator public\r\n    {\r\n        newProductFee = productFee;\r\n    }\r\n    // Get product address and id\r\n    function GetProductList() view public returns (address[] products, uint32[] productIds)\r\n    {\r\n        products = new address[](lastProductId);\r\n        productIds = new uint32[](lastProductId);\r\n\r\n        for (uint32 i = 1; i <= lastProductId; i++)\r\n        {\r\n            products[i - 1] = prCode_product[i];\r\n            productIds[i - 1] = i;\r\n        }\r\n    }\r\n    // Get infromation of product\r\n    function GetProductInfo(address product) view public returns (uint32 prCode, uint256 divider, bool isTradeBid, bool isTradeAsk, bool isDeposit, bool isWithdraw, uint32 ownerId, uint104 minQty)\r\n    {\r\n        prCode = product_prCode[product];\r\n\r\n        divider = prCode_productInfo[prCode].divider;\r\n        isTradeBid = prCode_productInfo[prCode].isTradeBid;\r\n        isTradeAsk = prCode_productInfo[prCode].isTradeAsk;\r\n        isDeposit = prCode_productInfo[prCode].isDeposit;\r\n        isWithdraw = prCode_productInfo[prCode].isWithdraw;\r\n        ownerId = prCode_productInfo[prCode].ownerId;\r\n        minQty = prCode_productInfo[prCode].minQty;\r\n    }\r\n\r\n    uint32 public lastAcccountId;\r\n    mapping (uint32 => uint8) id_announceLV;\r\n    //Each announceLV open information as\r\n    //0: None, 1: Trade, 2:Balance, 3:DepositWithdrawal, 4:OpenOrder\r\n    mapping (uint32 => address) id_account;\r\n    mapping (uint32 => bool) accountId_freeze;\r\n    mapping (address => uint32) account_id;\r\n    // Find or add account\r\n    function FindOrAddAccount(address findAddress) private returns (uint32)\r\n    {\r\n        if (account_id[findAddress] == 0)\r\n        {\r\n            account_id[findAddress] = ++lastAcccountId;\r\n            id_account[lastAcccountId] = findAddress;\r\n        }\r\n        return account_id[findAddress];\r\n    }\r\n    // Find or revert account\r\n    function FindOrRevertAccount() private view returns (uint32)\r\n    {\r\n        uint32 accountId = account_id[msg.sender];\r\n        require(accountId != 0);\r\n        return accountId;\r\n    }\r\n    // Get account id of msg sender\r\n    function GetMyAccountId() view public returns (uint32)\r\n    {\r\n        return account_id[msg.sender];\r\n    }\r\n    // Get account id of any users\r\n    function GetAccountId(address account) view public returns (uint32)\r\n    {\r\n        return account_id[account];\r\n    }\r\n    // Get account announcement level\r\n    function GetMyAnnounceLV() view public returns (uint32)\r\n    {\r\n        return id_announceLV[account_id[msg.sender]];\r\n    }\r\n    // Set account announce level\r\n    function ChangeAnnounceLV(uint8 announceLV) public\r\n    {\r\n        id_announceLV[FindOrRevertAccount()] = announceLV;\r\n    }\r\n    // Freeze or unfreez of account\r\n    function SetFreezeByAddress(bool isFreeze, address account) onlyOperator public\r\n    {\r\n        uint32 accountId = account_id[account];\r\n\r\n        if (accountId != 0)\r\n        {\r\n            accountId_freeze[accountId] = isFreeze;\r\n        }\r\n    }\r\n\r\n    // reserved: Balance held up in orderBook\r\n    // available: Balance available for trade\r\n    struct Balance\r\n    {\r\n        uint128 reserved;\r\n        uint128 available;\r\n    }\r\n\r\n    struct ListItem\r\n    {\r\n        uint32 prev;\r\n        uint32 next;\r\n    }\r\n\r\n    struct OrderLink\r\n    {\r\n        uint32 firstId;\r\n        uint32 lastId;\r\n        uint80 nextPrice;\r\n        uint80 prevPrice;\r\n        mapping (uint32 => ListItem) id_orderList;\r\n    }\r\n\r\n    struct Order\r\n    {\r\n        uint32 exId;\r\n        uint32 accountId;\r\n        uint32 prTrade;\r\n        uint32 prBase;\r\n        uint104 qty;\r\n        uint80 price;\r\n        bool isSell;\r\n    }\r\n\r\n    uint32 public lastOrderId;\r\n    mapping (uint32 => Order) id_Order;\r\n\r\n    //orderbook information\r\n    struct OrderBook\r\n    {\r\n        uint8 tickSize;\r\n\r\n        uint80 bestBidPrice;\r\n        uint80 bestAskPrice;\r\n\r\n        mapping (uint80 => OrderLink) bidPrice_Order;\r\n        mapping (uint80 => OrderLink) askPrice_Order;\r\n    }\r\n    mapping (uint32 => mapping (uint32 => OrderBook)) basePID_tradePID_orderBook;\r\n    function SetOrderBookTickSize(uint32 prTrade, uint32 prBase, uint8 _tickSize) onlyOperator public\r\n    {\r\n        basePID_tradePID_orderBook[prBase][prTrade].tickSize = _tickSize;\r\n    }\r\n\r\n    mapping (uint32 => mapping (uint32 => mapping (uint32 => Balance))) exId_prCode_AccountId_Balance;\r\n\r\n    // open order list\r\n    struct OpenOrder\r\n    {\r\n        uint32 startId;\r\n        mapping(uint32 => ListItem) id_orderList;\r\n    }\r\n    mapping(uint32 => OpenOrder) accountId_OpenOrder;\r\n    function AddOpenOrder(uint32 accountId, uint32 orderId) private\r\n    {\r\n        OpenOrder storage openOrder = accountId_OpenOrder[accountId];\r\n\r\n        if (openOrder.startId != 0)\r\n        {\r\n            openOrder.id_orderList[openOrder.startId].prev = orderId;\r\n            openOrder.id_orderList[orderId].next = openOrder.startId;\r\n        }\r\n        openOrder.startId = orderId;\r\n    }\r\n    function RemoveOpenOrder(uint32 accountId, uint32 orderId) private\r\n    {\r\n        OpenOrder storage openOrder = accountId_OpenOrder[accountId];\r\n\r\n        uint32 nextId = openOrder.id_orderList[orderId].next;\r\n        uint32 prevId = openOrder.id_orderList[orderId].prev;\r\n\r\n        if (nextId != 0)\r\n        {\r\n            openOrder.id_orderList[nextId].prev = prevId;\r\n        }\r\n\r\n        if (prevId != 0)\r\n        {\r\n            openOrder.id_orderList[prevId].next = nextId;\r\n        }\r\n\r\n        if (openOrder.startId == orderId)\r\n        {\r\n            openOrder.startId = nextId;\r\n        }\r\n    }\r\n\r\n    //withdrawal and deposit record (DW records)\r\n    struct DWrecord\r\n    {\r\n        uint32 prCode;\r\n        bool isDeposit;\r\n        uint128 qty;\r\n        uint64 timestamp;\r\n    }\r\n\r\n    struct DWrecords\r\n    {\r\n        uint32 N;\r\n        mapping (uint32 => DWrecord) N_DWrecord;\r\n    }\r\n    mapping (uint32 => mapping (uint32 => DWrecords)) exId_AccountId_DWrecords;\r\n\r\n    //record deposit and withdrawal\r\n    function RecordDW(uint32 exId, uint32 accountId, uint32 prCode, bool isDeposit, uint128 qty) private\r\n    {\r\n        DWrecord memory dW;\r\n        dW.isDeposit = isDeposit;\r\n        dW.prCode = prCode;\r\n        dW.qty = qty;\r\n        dW.timestamp = uint64(now);\r\n\r\n        exId_AccountId_DWrecords[exId][accountId].N_DWrecord[++exId_AccountId_DWrecords[exId][accountId].N] = dW;\r\n\r\n        if (isDeposit == true)\r\n            emit NewDeposit(exId, prCode, accountId, qty, dW.timestamp, lastTransferId++);\r\n        else\r\n            emit NewWithdraw(exId, prCode, accountId, qty, dW.timestamp, lastTransferId++);\r\n    }\r\n    // returns 'N', DW  records with account id, accountId, for exchange id, exId\r\n    function GetDWrecords(uint32 N, uint32 exId, uint32 accountId) view public returns (uint32[] prCode, bool[] isDeposit, uint128[] qty, uint64[] timestamp)\r\n    {\r\n        checkAnnounceLV(accountId, 3);\r\n\r\n        DWrecords storage dWrecords = exId_AccountId_DWrecords[exId][accountId];\r\n        uint32 n = dWrecords.N;\r\n\r\n        if (n > N)\r\n            n = N;\r\n\r\n        prCode = new uint32[](n);\r\n        isDeposit = new bool[](n);\r\n        qty = new uint128[](n);\r\n        timestamp = new uint64[](n);\r\n\r\n        for (uint32 i = dWrecords.N; i > dWrecords.N - n; i--)\r\n        {\r\n            N = dWrecords.N - i;\r\n            prCode[N] = dWrecords.N_DWrecord[i].prCode;\r\n            isDeposit[N] = dWrecords.N_DWrecord[i].isDeposit;\r\n            qty[N] = dWrecords.N_DWrecord[i].qty;\r\n            timestamp[N] = dWrecords.N_DWrecord[i].timestamp;\r\n        }\r\n    }\r\n\r\n    //Deposit ETH to exchange\r\n    function depositETH(uint32 exId) payable onlyContractUse public\r\n    {\r\n        require(exId <= lastOwnerId);\r\n        uint32 accountId = FindOrAddAccount(msg.sender);\r\n        exId_prCode_AccountId_Balance[exId][1][accountId].available = Add(exId_prCode_AccountId_Balance[exId][1][accountId].available, uint128(msg.value));\r\n        RecordDW(exId, accountId, 1, true, uint104(msg.value));\r\n    }\r\n    // Withdraw ETH from exchange\r\n    function withdrawETH(uint32 exId, uint104 amount) public\r\n    {\r\n        uint32 accountId = FindOrRevertAccount();\r\n        require(accountId_freeze[accountId] == false);\r\n        exId_prCode_AccountId_Balance[exId][1][accountId].available = Sub(exId_prCode_AccountId_Balance[exId][1][accountId].available, amount);\r\n        require(msg.sender.send(amount));\r\n        RecordDW(exId, accountId, 1, false,  amount);\r\n    }\r\n    // Deposit/Withdraw, ERC20's to exchange\r\n    function depositWithdrawToken(uint32 exId, uint128 amount, bool isDeposit, address prAddress) public\r\n    {\r\n        uint32 prCode = product_prCode[prAddress];\r\n        require(amount < maxBalance && prCode != 0);\r\n        uint32 accountId = FindOrAddAccount(msg.sender);\r\n        require(accountId_freeze[accountId] == false);\r\n\r\n        if (isDeposit == true)\r\n        {\r\n            require(prCode_productInfo[prCode].isDeposit == true && isContractUse == true && exId <= lastOwnerId);\r\n            require(Token(prAddress).transferFrom(msg.sender, this, amount));\r\n            exId_prCode_AccountId_Balance[exId][prCode][accountId].available = Add(exId_prCode_AccountId_Balance[exId][prCode][accountId].available, amount);\r\n            require (exId_prCode_AccountId_Balance[exId][prCode][accountId].available < maxBalance);\r\n        }\r\n        else\r\n        {\r\n            require(prCode_productInfo[prCode].isWithdraw == true);\r\n            exId_prCode_AccountId_Balance[exId][prCode][accountId].available = Sub(exId_prCode_AccountId_Balance[exId][prCode][accountId].available, amount);\r\n            require(Token(prAddress).transfer(msg.sender, amount));\r\n        }\r\n        RecordDW(exId, accountId, prCode, isDeposit, amount);\r\n    }\r\n\r\n    // This function will be never used in normal situations.\r\n    // This function is only prepared for emergency case such as smart contract hacking Vulnerability or smart contract abolishment\r\n    // Withdrawn fund by this function cannot belong to any exchange operators or owners.\r\n    // Withdrawn fund should be distributed to individual accounts having original ownership of withdrawn fund.\r\n    // After using this function, this contract cannot get any deposit or trade.\r\n    // After using this function, this contract will be abolished.\r\n    function emergencyWithdrawal(uint32 prCode, uint256 amount) onlyOwner public\r\n    {\r\n        isContractUse = false;//This cannot be return. After activating this, this contract cannot support any deposit or trade function.\r\n        if (prCode == 1)\r\n            require(msg.sender.send(amount));\r\n        else\r\n            Token(prCode_product[prCode]).transfer(msg.sender, amount);\r\n    }\r\n\r\n    // Find tick size of each price\r\n    function GetNextTick(bool isAsk, uint80 price, uint8 n) public pure returns (uint80)\r\n    {\r\n        if (price > 0)\r\n        {\r\n            uint80 tick = GetTick(price, n);\r\n\r\n            if (isAsk == true)\r\n                return (((price - 1) / tick) + 1) * tick;\r\n            else\r\n                return (price / tick) * tick;\r\n        }\r\n        else\r\n        {\r\n            return price;\r\n        }\r\n    }\r\n\r\n    function GetTick(uint80 price, uint8 n)  public pure returns  (uint80)\r\n    {\r\n        if (n < 1)\r\n            n = 1;\r\n\r\n        uint80 x = 1;\r\n\r\n        for (uint8 i=1; i <= n / 2; i++)\r\n        {\r\n            x *= 10;\r\n        }\r\n\r\n        if (price < 10 * x)\r\n            return 1;\r\n        else\r\n        {\r\n            uint80 tick = 10000;\r\n\r\n            uint80 priceTenPercent = price / 10 / x;\r\n\r\n            while (priceTenPercent > tick)\r\n            {\r\n                tick *= 10;\r\n            }\r\n\r\n            while (priceTenPercent < tick)\r\n            {\r\n                tick /= 10;\r\n            }\r\n\r\n            if (n % 2 == 1)\r\n            {\r\n                if (price >= 50 * tick * x)\r\n                {\r\n                    tick *= 5;\r\n                }\r\n            }\r\n            else\r\n            {\r\n                if (price < 50 * tick * x)\r\n                {\r\n                    tick *= 5;\r\n                }\r\n                else\r\n                {\r\n                    tick *= 10;\r\n                }\r\n\r\n            }\r\n\r\n            return tick;\r\n        }\r\n    }\r\n    // New limit order\r\n    function LimitOrder(uint32 exId, uint32 prTrade, uint32 prBase, bool isSell, uint80 price, uint104 qty) public onlyContractUse  returns  (uint32)\r\n    {\r\n        uint32 accountId = FindOrRevertAccount();\r\n        require(accountId_freeze[accountId] == false);\r\n        uint80 lastBestPrice;\r\n        OrderBook storage orderBook = basePID_tradePID_orderBook[prBase][prTrade];\r\n        require(price != 0 && price <= maxPrice && qty <= maxQty &&\r\n            ((isSell == false && prCode_productInfo[prTrade].isTradeBid == true && prCode_productInfo[prBase].isTradeAsk == true)\r\n            || (isSell == true && prCode_productInfo[prTrade].isTradeAsk == true && prCode_productInfo[prBase].isTradeBid == true))\r\n            && prCode_productInfo[prTrade].minQty <= qty);\r\n\r\n        if (isSell == true)\r\n        {\r\n            price = GetNextTick(true, price, orderBook.tickSize);\r\n            lastBestPrice = orderBook.bestAskPrice;\r\n        }\r\n        else\r\n        {\r\n            price = GetNextTick(false, price, orderBook.tickSize);\r\n            lastBestPrice = orderBook.bestBidPrice;\r\n        }\r\n\r\n        Order memory order;\r\n        order.exId = exId;\r\n        order.isSell = isSell;\r\n        order.prTrade = prTrade;\r\n        order.prBase = prBase;\r\n        order.accountId = accountId;\r\n        order.price = price;\r\n        order.qty = qty;\r\n\r\n        require (IsPossibleLimit(order));\r\n\r\n        emit NewOrder(order.prTrade, order.prBase, order.accountId, ++lastOrderId, order.isSell, order.price, order.qty, lastNewOrderId++);\r\n\r\n        BalanceUpdateByLimitAfterTrade(order, qty, matchOrder(orderBook, order, lastOrderId));\r\n\r\n        if (order.qty != 0)\r\n        {\r\n            uint80 priceNext;\r\n            uint80 price0;\r\n\r\n            if (isSell == true)\r\n            {\r\n                price0 = orderBook.bestAskPrice;\r\n                if (price0 == 0)\r\n                {\r\n                    orderBook.askPrice_Order[price].prevPrice = 0;\r\n                    orderBook.askPrice_Order[price].nextPrice = 0;\r\n                    orderBook.bestAskPrice = price;\r\n                }\r\n                else if(price < price0)\r\n                {\r\n                    orderBook.askPrice_Order[price0].prevPrice = price;\r\n                    orderBook.askPrice_Order[price].prevPrice = 0;\r\n                    orderBook.askPrice_Order[price].nextPrice = price0;\r\n                    orderBook.bestAskPrice = price;\r\n                }\r\n                else if (orderBook.askPrice_Order[price].firstId == 0)\r\n                {\r\n                    priceNext = price0;\r\n\r\n                    while (priceNext != 0 && priceNext < price)\r\n                    {\r\n                        price0 = priceNext;\r\n                        priceNext = orderBook.askPrice_Order[price0].nextPrice;\r\n                    }\r\n\r\n                    orderBook.askPrice_Order[price0].nextPrice = price;\r\n                    orderBook.askPrice_Order[price].prevPrice = price0;\r\n                    orderBook.askPrice_Order[price].nextPrice = priceNext;\r\n                    if (priceNext != 0)\r\n                    {\r\n                        orderBook.askPrice_Order[priceNext].prevPrice = price;\r\n                    }\r\n                }\r\n\r\n                OrderLink storage orderLink = orderBook.askPrice_Order[price];\r\n            }\r\n            else\r\n            {\r\n                price0 = orderBook.bestBidPrice;\r\n                if (price0 == 0)\r\n                {\r\n                    orderBook.bidPrice_Order[price].prevPrice = 0;\r\n                    orderBook.bidPrice_Order[price].nextPrice = 0;\r\n                    orderBook.bestBidPrice = price;\r\n                }\r\n                else if (price > price0)\r\n                {\r\n                    orderBook.bidPrice_Order[price0].prevPrice = price;\r\n                    orderBook.bidPrice_Order[price].prevPrice = 0;\r\n                    orderBook.bidPrice_Order[price].nextPrice = price0;\r\n                    orderBook.bestBidPrice = price;\r\n                }\r\n                else if (orderBook.bidPrice_Order[price].firstId == 0)\r\n                {\r\n                    priceNext = price0;\r\n\r\n                    while (priceNext != 0 && priceNext > price)\r\n                    {\r\n                        price0 = priceNext;\r\n                        priceNext = orderBook.bidPrice_Order[price0].nextPrice;\r\n                    }\r\n\r\n                    orderBook.bidPrice_Order[price0].nextPrice = price;\r\n                    orderBook.bidPrice_Order[price].prevPrice = price0;\r\n                    orderBook.bidPrice_Order[price].nextPrice = priceNext;\r\n                    if (priceNext != 0)\r\n                    {\r\n                        orderBook.bidPrice_Order[priceNext].prevPrice = price;\r\n                    }\r\n                }\r\n\r\n                orderLink = orderBook.bidPrice_Order[price];\r\n            }\r\n\r\n            if (lastOrderId != 0)\r\n            {\r\n                orderLink.id_orderList[lastOrderId].prev = orderLink.lastId;\r\n                if (orderLink.firstId != 0)\r\n                {\r\n                    orderLink.id_orderList[orderLink.lastId].next = lastOrderId;\r\n                }\r\n                else\r\n                {\r\n                    orderLink.id_orderList[lastOrderId].next = 0;\r\n                    orderLink.firstId = lastOrderId;\r\n                }\r\n                orderLink.lastId = lastOrderId;\r\n            }\r\n\r\n            AddOpenOrder(accountId, lastOrderId);\r\n            id_Order[lastOrderId] = order;\r\n        }\r\n\r\n        if (isSell == true && lastBestPrice != orderBook.bestAskPrice)\r\n        {\r\n            emit NewBestBidAsk(prTrade, prBase, isSell, orderBook.bestAskPrice);\r\n        }\r\n        if (isSell == false && lastBestPrice != orderBook.bestBidPrice)\r\n        {\r\n            emit NewBestBidAsk(prTrade, prBase, isSell, orderBook.bestBidPrice);\r\n        }\r\n\r\n        return lastOrderId;\r\n    }\r\n\r\n    function BalanceUpdateByLimitAfterTrade(Order order, uint104 qty, uint104 tradedQty) private\r\n    {\r\n        uint32 exId = order.exId;\r\n        uint32 accountId = order.accountId;\r\n        uint32 prTrade = order.prTrade;\r\n        uint32 prBase = order.prBase;\r\n        uint80 price = order.price;\r\n        uint104 orderQty = order.qty;\r\n\r\n        if (order.isSell)\r\n        {\r\n            Balance storage balance = exId_prCode_AccountId_Balance[exId][prTrade][accountId];\r\n            balance.available = Sub(balance.available, qty);\r\n\r\n            if (orderQty != 0)\r\n                balance.reserved = Add(balance.reserved, orderQty);\r\n        }\r\n        else\r\n        {\r\n            balance = exId_prCode_AccountId_Balance[exId][prBase][accountId];\r\n            if (orderQty != 0)\r\n            {\r\n                // prCode_productInfo[prBase].divider * qty * price < 2^60 * 2^80 * 2^104 < 2^256\r\n                \r\n                uint256 a = prCode_productInfo[prBase].divider * orderQty * price;\r\n                uint256 b = basePrice * prCode_productInfo[prTrade].divider;\r\n                uint256 temp = a / b;\r\n                \r\n                require (temp < maxQty); // temp < maxQty < 2^104\r\n                require (temp * b == a);\r\n                \r\n                balance.available = Sub(balance.available, tradedQty + uint104(temp));\r\n                balance.reserved = Add(balance.reserved, uint104(temp));\r\n            }\r\n            else\r\n            {\r\n                balance.available = Sub(balance.available, tradedQty);\r\n            }\r\n            tradedQty = qty - orderQty;\r\n\r\n            prBase = prTrade;\r\n        }\r\n        if (tradedQty != 0)\r\n        {\r\n            uint104 takeFeeLocal = tradedQty * ownerId_takerFeeRateLocal[exId] / 10000;\r\n            exId_prCode_AccountId_Balance[exId][prBase][accountId].available += tradedQty - takeFeeLocal;\r\n            exId_prCode_AccountId_Balance[exId][prBase][ownerId_accountId[exId]].available += takeFeeLocal;\r\n        }\r\n    }\r\n\r\n    function IsPossibleLimit(Order memory order) private view returns (bool)\r\n    {\r\n        if (order.isSell)\r\n        {\r\n            if (exId_prCode_AccountId_Balance[order.exId][order.prTrade][order.accountId].available >= order.qty)\r\n                return true;\r\n            else\r\n                return false;\r\n        }\r\n        else\r\n        {\r\n            if (exId_prCode_AccountId_Balance[order.exId][order.prBase][order.accountId].available >= prCode_productInfo[order.prBase].divider * order.qty * order.price / basePrice / prCode_productInfo[order.prTrade].divider)\r\n                return true;\r\n            else\r\n                return false;\r\n        }\r\n    }\r\n    // Heart of DexHI's onchain order matching algorithm\r\n    function matchOrder(OrderBook storage ob, Order memory order, uint32 id) private returns (uint104)\r\n    {\r\n        uint32 prTrade = order.prTrade;\r\n        uint32 prBase = order.prBase;\r\n        uint80 tradePrice;\r\n\r\n        if (order.isSell == true)\r\n            tradePrice = ob.bestBidPrice;\r\n        else\r\n            tradePrice = ob.bestAskPrice;\r\n\r\n        bool isBestPriceUpdate = false;\r\n\r\n        uint104 qtyBase = 0;\r\n        uint104 tradeAmount;\r\n\r\n        while (tradePrice != 0 && order.qty > 0 && ((order.isSell && order.price <= tradePrice) || (!order.isSell && order.price >= tradePrice)))\r\n        {\r\n            if (order.isSell == true)\r\n                OrderLink storage orderLink = ob.bidPrice_Order[tradePrice];\r\n            else\r\n                orderLink = ob.askPrice_Order[tradePrice];\r\n\r\n            uint32 orderId = orderLink.firstId;\r\n\r\n            while (orderLink.firstId != 0 && orderId != 0 && order.qty != 0)\r\n            {\r\n                Order storage matchingOrder = id_Order[orderId];\r\n                if (matchingOrder.qty >= order.qty)\r\n                {\r\n                    tradeAmount = order.qty;\r\n                    matchingOrder.qty -= order.qty; //matchingOrder.qty cannot be negative by (matchingOrder.qty >= order.qty\r\n                    order.qty = 0;\r\n                }\r\n                else\r\n                {\r\n                    tradeAmount = matchingOrder.qty;\r\n                    order.qty -= matchingOrder.qty;\r\n                    matchingOrder.qty = 0;\r\n                }\r\n\r\n                qtyBase += BalanceUpdateByTradeCp(order, matchingOrder, tradeAmount);\r\n                //return value of BalanceUpdateByTradeCp < maxqty < 2^100 so qtyBase < 2 * maxqty < 2 * 101 by below require(qtyBase < maxQty) -> qtyBase cannot be overflow\r\n                require(qtyBase < maxQty);\r\n\r\n                uint32 orderAccountID = order.accountId;\r\n\r\n                if (order.isSell == true)\r\n                    emit NewTrade(prTrade, prBase, orderId, id, matchingOrder.accountId, orderAccountID, true, tradePrice,  tradeAmount, lastTradeId++, uint64(now));\r\n                else\r\n                    emit NewTrade(prTrade, prBase, id, orderId, orderAccountID, matchingOrder.accountId, false, tradePrice,  tradeAmount, lastTradeId++, uint64(now));\r\n\r\n                if (matchingOrder.qty != 0)\r\n                {\r\n                    break;\r\n                }\r\n                else\r\n                {\r\n                    if (RemoveOrder(prTrade, prBase, matchingOrder.isSell, tradePrice, orderId) == true)\r\n                    {\r\n                        RemoveOpenOrder(matchingOrder.accountId, orderId);\r\n                    }\r\n                    orderId = orderLink.firstId;\r\n                }\r\n            }\r\n\r\n            if (orderLink.firstId == 0)\r\n            {\r\n                tradePrice = orderLink.nextPrice;\r\n                isBestPriceUpdate = true;\r\n            }\r\n        }\r\n\r\n        if (isBestPriceUpdate == true)\r\n        {\r\n            if (order.isSell)\r\n            {\r\n                ob.bestBidPrice = tradePrice;\r\n            }\r\n            else\r\n            {\r\n                ob.bestAskPrice = tradePrice;\r\n            }\r\n\r\n            emit NewBestBidAsk(prTrade, prBase, !order.isSell, tradePrice);\r\n        }\r\n\r\n        return qtyBase;\r\n    }\r\n\r\n    function BalanceUpdateByTradeCp(Order order, Order matchingOrder, uint104 tradeAmount) private returns (uint104)\r\n    {\r\n        uint32 accountId = matchingOrder.accountId;\r\n        uint32 prTrade = order.prTrade;\r\n        uint32 prBase = order.prBase;\r\n        require (tradeAmount < maxQty);\r\n        // qtyBase < 10 ^ 18 < 2^ 60 & tradedAmount < 2^104 & matching orderprice < 2^80 ->  prCode_productInfo[prBase].divider * tradeAmount * matchingOrder.price < 2^256\r\n        // so, below qtyBase cannot be overflow\r\n        uint256 qtyBase = prCode_productInfo[prBase].divider * tradeAmount * matchingOrder.price / basePrice / prCode_productInfo[prTrade].divider;\r\n        require (qtyBase < maxQty);\r\n\r\n        Balance storage balanceTrade = exId_prCode_AccountId_Balance[matchingOrder.exId][prTrade][accountId];\r\n        Balance storage balanceBase = exId_prCode_AccountId_Balance[matchingOrder.exId][prBase][accountId];\r\n\r\n        if (order.isSell == true)\r\n        {\r\n            balanceTrade.available = SafeMath.Add(balanceTrade.available, tradeAmount);\r\n            balanceBase.reserved = SafeMath.Sub(balanceBase.reserved, uint104(qtyBase));\r\n        }\r\n        else\r\n        {\r\n            balanceTrade.reserved = SafeMath.Sub(balanceTrade.reserved, tradeAmount);\r\n            balanceBase.available = SafeMath.Add(balanceBase.available, uint104(qtyBase));\r\n        }\r\n\r\n        return uint104(qtyBase); // return value < maxQty = 1000000000000000000000000000001 < 2^100 by require (qtyBase < maxQty);\r\n    }\r\n    // Internal functions to remove order\r\n    function RemoveOrder(uint32 prTrade, uint32 prBase, bool isSell, uint80 price, uint32 id) private returns (bool)\r\n    {\r\n        OrderBook storage ob = basePID_tradePID_orderBook[prBase][prTrade];\r\n\r\n        if (isSell == false)\r\n        {\r\n            OrderLink storage orderLink = ob.bidPrice_Order[price];\r\n        }\r\n        else\r\n        {\r\n            orderLink = ob.askPrice_Order[price];\r\n        }\r\n\r\n        if (id != 0)\r\n        {\r\n            ListItem memory removeItem = orderLink.id_orderList[id];\r\n            if (removeItem.next != 0)\r\n            {\r\n                orderLink.id_orderList[removeItem.next].prev = removeItem.prev;\r\n            }\r\n\r\n            if (removeItem.prev != 0)\r\n            {\r\n                orderLink.id_orderList[removeItem.prev].next = removeItem.next;\r\n            }\r\n\r\n            if (id == orderLink.lastId)\r\n            {\r\n                orderLink.lastId = removeItem.prev;\r\n            }\r\n\r\n            if (id == orderLink.firstId)\r\n            {\r\n                orderLink.firstId = removeItem.next;\r\n            }\r\n\r\n            delete orderLink.id_orderList[id];\r\n\r\n            if (orderLink.firstId == 0)\r\n            {\r\n                if (orderLink.nextPrice != 0)\r\n                {\r\n                    if (isSell == true)\r\n                        OrderLink storage replaceLink = ob.askPrice_Order[orderLink.nextPrice];\r\n                    else\r\n                        replaceLink = ob.bidPrice_Order[orderLink.nextPrice];\r\n\r\n                    replaceLink.prevPrice = orderLink.prevPrice;\r\n                }\r\n                if (orderLink.prevPrice != 0)\r\n                {\r\n                    if (isSell == true)\r\n                        replaceLink = ob.askPrice_Order[orderLink.prevPrice];\r\n                    else\r\n                        replaceLink = ob.bidPrice_Order[orderLink.prevPrice];\r\n\r\n                    replaceLink.nextPrice = orderLink.nextPrice;\r\n                }\r\n\r\n                if (price == ob.bestAskPrice)\r\n                {\r\n                    ob.bestAskPrice = orderLink.nextPrice;\r\n                }\r\n                if (price == ob.bestBidPrice)\r\n                {\r\n                    ob.bestBidPrice = orderLink.nextPrice;\r\n                }\r\n            }\r\n            return true;\r\n        }\r\n        else\r\n        {\r\n            return false;\r\n        }\r\n    }\r\n    // Cancel orders, keep eye on max block gas Fee\r\n    function cancelOrders(uint32[] id) public ////uint32 exId\r\n    {\r\n        for (uint32 i = 0; i < id.length; i++)\r\n        {\r\n            cancelOrder(id[i]);\r\n        }\r\n    }\r\n    //  Cancel order\r\n    function cancelOrder(uint32 id) public returns (bool)\r\n    {\r\n        Order memory order = id_Order[id];\r\n        uint32 accountId = account_id[msg.sender];\r\n        require(order.accountId == accountId);\r\n\r\n        uint32 prTrade = order.prTrade;\r\n        uint32 prBase = order.prBase;\r\n        bool isSell = order.isSell;\r\n        //uint80 price = order.price;\r\n        //uint104 qty = order.qty;\r\n\r\n        if (RemoveOrder(prTrade, prBase, isSell, order.price, id) == false)\r\n            return false;\r\n        else\r\n        {\r\n            RemoveOpenOrder(accountId, id);\r\n        }\r\n\r\n        if (isSell)\r\n        {\r\n            Balance storage balance = exId_prCode_AccountId_Balance[order.exId][prTrade][accountId];\r\n            balance.available = SafeMath.Add(balance.available, order.qty);\r\n            balance.reserved = SafeMath.Sub(balance.reserved, order.qty);\r\n        }\r\n        else\r\n        {\r\n            balance = exId_prCode_AccountId_Balance[order.exId][prBase][accountId];\r\n            // prCode_productInfo[prBase].divider * qty * price < 2^60 * 2^80 * 2^104 < 2^256\r\n            uint256 a = prCode_productInfo[prBase].divider * order.qty * order.price;\r\n            uint256 b = basePrice * prCode_productInfo[prTrade].divider;\r\n            uint256 temp = a / b;\r\n            require (temp < maxQty); // temp < maxQty < 2^104 -> temp cannot be overflow\r\n            require (temp * b == a);\r\n            balance.available = SafeMath.Add(balance.available, uint104(temp));\r\n            balance.reserved = SafeMath.Sub(balance.reserved, uint104(temp));\r\n        }\r\n\r\n        emit NewCancel(prTrade, prBase, accountId, id, isSell, order.price, order.qty, lastNewOrderId++);\r\n        return true;\r\n    }\r\n    function checkAnnounceLV(uint32 accountId, uint8 LV) private view returns (bool)\r\n    {\r\n        require(accountId == account_id[msg.sender] || id_announceLV[accountId] >= LV || msg.sender == operator || owner_id[msg.sender] != 0);\r\n    }\r\n    // Get balance by acount id\r\n    function getBalance(uint32 exId, uint32[] prCode, uint32 accountId) view public returns (uint128[] available, uint128[] reserved)\r\n    {\r\n        if (accountId == 0)\r\n            accountId = account_id[msg.sender];\r\n        checkAnnounceLV(accountId, 2);\r\n\r\n        uint256 n = prCode.length;\r\n        available = new uint128[](n);\r\n        reserved = new uint128[](n);\r\n\r\n        for (uint32 i = 0; i < n; i++)\r\n        {\r\n            available[i] = exId_prCode_AccountId_Balance[exId][prCode[i]][accountId].available;\r\n            reserved[i] = exId_prCode_AccountId_Balance[exId][prCode[i]][accountId].reserved;\r\n        }\r\n    }\r\n    // Get balance by product\r\n    function getBalanceByProduct(uint32 exId, uint32 prCode, uint128 minQty) view public returns (uint32[] accountId, uint128[] balanceSum)\r\n    {\r\n        require (owner_id[msg.sender] != 0 || msg.sender == operator);\r\n        uint32 n = 0;\r\n        for (uint32 i = 1; i <= lastAcccountId; i++)\r\n        {\r\n            if (exId_prCode_AccountId_Balance[exId][prCode][i].available + exId_prCode_AccountId_Balance[exId][prCode][i].reserved > minQty)\r\n                n++;\r\n        }\r\n        accountId = new uint32[](n);\r\n        balanceSum = new uint128[](n);\r\n\r\n        n = 0;\r\n        uint128 temp;\r\n        for (i = 1; i <= lastAcccountId; i++)\r\n        {\r\n            temp = exId_prCode_AccountId_Balance[exId][prCode][i].available + exId_prCode_AccountId_Balance[exId][prCode][i].reserved;\r\n            if (temp >= minQty)\r\n            {\r\n                accountId[n] = i;\r\n                balanceSum[n++] = temp;\r\n            }\r\n        }\r\n    }\r\n\r\n    // Get bestBidPrice and bestAskPrice of each orderbook\r\n    function getOrderBookInfo(uint32[] prTrade, uint32 prBase) view public returns (uint80[] bestBidPrice, uint80[] bestAskPrice)\r\n    {\r\n        uint256 n = prTrade.length;\r\n        bestBidPrice = new uint80[](n);\r\n        bestAskPrice = new uint80[](n);\r\n\r\n        for (uint256 i = 0; i < n; i++)\r\n        {\r\n            OrderBook memory orderBook = basePID_tradePID_orderBook[prBase][prTrade[i]];\r\n            bestBidPrice[i] = orderBook.bestBidPrice;\r\n            bestAskPrice[i] = orderBook.bestAskPrice;\r\n        }\r\n    }\r\n\r\n    // Get order information by order id\r\n    function getOrder(uint32 id) view public returns (uint32 prTrade, uint32 prBase, bool sell, uint80 price, uint104 qty, uint32 accountId, uint32 exId)\r\n    {\r\n        Order memory order = id_Order[id];\r\n\r\n        accountId = order.accountId;\r\n        checkAnnounceLV(accountId, 4);\r\n\r\n        prTrade = order.prTrade;\r\n        prBase = order.prBase;\r\n        price = order.price;\r\n        sell = order.isSell;\r\n        qty = order.qty;\r\n        exId = order.exId;\r\n    }\r\n\r\n    // Get message sender's open orders\r\n    function GetMyOrders(uint32 exId, uint32 accountId, uint16 orderN) view public returns (uint32[] orderId, uint32[] prTrade, uint32[] prBase, bool[] sells, uint80[] prices, uint104[] qtys)\r\n    {\r\n        if (accountId == 0)\r\n            accountId = account_id[msg.sender];\r\n\r\n        checkAnnounceLV(accountId, 4);\r\n\r\n        OpenOrder storage openOrder = accountId_OpenOrder[accountId];\r\n\r\n        orderId = new uint32[](orderN);\r\n        prTrade = new uint32[](orderN);\r\n        prBase = new uint32[](orderN);\r\n        qtys = new uint104[](orderN);\r\n        prices = new uint80[](orderN);\r\n        sells = new bool[](orderN);\r\n\r\n        uint32 id = openOrder.startId;\r\n        if (id != 0)\r\n        {\r\n            Order memory order;\r\n            uint32 i = 0;\r\n            while (id != 0 && i < orderN)\r\n            {\r\n                order = id_Order[id];\r\n\r\n                if (exId == order.exId)\r\n                {\r\n                    orderId[i] = id;\r\n                    prTrade[i] = order.prTrade;\r\n                    prBase[i] = order.prBase;\r\n                    qtys[i] = order.qty;\r\n                    prices[i] = order.price;\r\n                    sells[i++] = order.isSell;\r\n                }\r\n\r\n                id = openOrder.id_orderList[id].next;\r\n            }\r\n        }\r\n    }\r\n\r\n    // Get all order id in each price\r\n    function GetHogaDetail(uint32 prTrade, uint32 prBase, uint80 price, bool isSell, uint16 orderN) view public returns (uint32[] orderIds)\r\n    {\r\n        if (isSell == false)\r\n        {\r\n            OrderLink storage orderLink = basePID_tradePID_orderBook[prBase][prTrade].bidPrice_Order[price];\r\n        }\r\n        else if (isSell == true)\r\n        {\r\n            orderLink = basePID_tradePID_orderBook[prBase][prTrade].askPrice_Order[price];\r\n        }\r\n        else\r\n        {\r\n            return;\r\n        }\r\n\r\n        orderIds = new uint32[](orderN);\r\n        uint16 n = 0;\r\n        uint32 id0 = orderLink.firstId;\r\n        while (id0 != 0 && orderN > n)\r\n        {\r\n            orderIds[n++] = id0;\r\n            id0 = orderLink.id_orderList[id0].next;\r\n        }\r\n    }\r\n\r\n    // Get orderbook screen\r\n    function GetHoga(uint32 prTrade, uint32 prBase, uint32 hogaN) public view returns (uint80[] priceB, uint104[] volumeB, uint80[] priceA, uint104[] volumeA)\r\n    {\r\n        OrderBook storage ob = basePID_tradePID_orderBook[prBase][prTrade];\r\n\r\n        (priceB, volumeB) = GetHoga(ob, hogaN, false);\r\n        (priceA, volumeA) = GetHoga(ob, hogaN, true);\r\n    }\r\n\r\n    // Get orderbook screen\r\n    function GetHoga(OrderBook storage ob, uint32 hogaN, bool isSell) private view returns (uint80[] prices, uint104[] volumes)\r\n    {\r\n        prices = new uint80[](hogaN);\r\n        volumes = new uint104[](hogaN);\r\n\r\n        uint32 n;\r\n        uint32 id0;\r\n        uint80 price;\r\n        uint104 sum;\r\n\r\n        if (isSell == false)\r\n            price = ob.bestBidPrice;\r\n        else\r\n            price = ob.bestAskPrice;\r\n\r\n        if (price != 0)\r\n        {\r\n            n = 0;\r\n            while (price != 0 && n < hogaN)\r\n            {\r\n                if (isSell == false)\r\n                    OrderLink storage orderLink = ob.bidPrice_Order[price];\r\n                else\r\n                    orderLink = ob.askPrice_Order[price];\r\n\r\n                id0 = orderLink.firstId;\r\n                sum = 0;\r\n                while (id0 != 0)\r\n                {\r\n                    sum += id_Order[id0].qty;\r\n                    id0 = orderLink.id_orderList[id0].next;\r\n                }\r\n                prices[n] = price;\r\n                volumes[n] = sum;\r\n                price = orderLink.nextPrice;\r\n                n++;\r\n            }\r\n\r\n            if (n > 0)\r\n            {\r\n                while (n < hogaN)\r\n                {\r\n                    if (isSell == true)\r\n                        prices[n] = GetNextTick(true, prices[n - 1] + 1, ob.tickSize);\r\n                    else\r\n                        prices[n] = GetNextTick(false, prices[n - 1] - 1, ob.tickSize);\r\n                    n++;\r\n                }\r\n            }\r\n        }\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"a\",\"type\":\"uint128\"},{\"name\":\"b\",\"type\":\"uint128\"}],\"name\":\"Add\",\"outputs\":[{\"name\":\"\",\"type\":\"uint128\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"GetMyAccountId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"exId\",\"type\":\"uint32\"},{\"name\":\"prTrade\",\"type\":\"uint32\"},{\"name\":\"prBase\",\"type\":\"uint32\"},{\"name\":\"isSell\",\"type\":\"bool\"},{\"name\":\"price\",\"type\":\"uint80\"},{\"name\":\"qty\",\"type\":\"uint104\"}],\"name\":\"LimitOrder\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"id\",\"type\":\"uint32\"}],\"name\":\"cancelOrder\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"id\",\"type\":\"uint32[]\"}],\"name\":\"cancelOrders\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"transferOperator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastAcccountId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"N\",\"type\":\"uint32\"},{\"name\":\"exId\",\"type\":\"uint32\"},{\"name\":\"accountId\",\"type\":\"uint32\"}],\"name\":\"GetDWrecords\",\"outputs\":[{\"name\":\"prCode\",\"type\":\"uint32[]\"},{\"name\":\"isDeposit\",\"type\":\"bool[]\"},{\"name\":\"qty\",\"type\":\"uint128[]\"},{\"name\":\"timestamp\",\"type\":\"uint64[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"exId\",\"type\":\"uint32\"}],\"name\":\"DeleteOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastOwnerId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"GetMyAnnounceLV\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"newProductFee\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastNewOrderId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastTradeId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastOrderId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"operator\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"product\",\"type\":\"address\"}],\"name\":\"GetProductInfo\",\"outputs\":[{\"name\":\"prCode\",\"type\":\"uint32\"},{\"name\":\"divider\",\"type\":\"uint256\"},{\"name\":\"isTradeBid\",\"type\":\"bool\"},{\"name\":\"isTradeAsk\",\"type\":\"bool\"},{\"name\":\"isDeposit\",\"type\":\"bool\"},{\"name\":\"isWithdraw\",\"type\":\"bool\"},{\"name\":\"ownerId\",\"type\":\"uint32\"},{\"name\":\"minQty\",\"type\":\"uint104\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"announceLV\",\"type\":\"uint8\"}],\"name\":\"ChangeAnnounceLV\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"GetOwnerList\",\"outputs\":[{\"name\":\"owners\",\"type\":\"address[]\"},{\"name\":\"ownerIds\",\"type\":\"uint32[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"ownerId\",\"type\":\"uint32\"}],\"name\":\"getTakerFeeRateLocal\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_takerFeeRate\",\"type\":\"uint8\"}],\"name\":\"setTakerFeeRateLocal\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint128\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"prCode\",\"type\":\"uint32\"},{\"name\":\"isTradeBid\",\"type\":\"bool\"},{\"name\":\"isTradeAsk\",\"type\":\"bool\"},{\"name\":\"isDeposit\",\"type\":\"bool\"},{\"name\":\"isWithdraw\",\"type\":\"bool\"},{\"name\":\"_minQty\",\"type\":\"uint104\"},{\"name\":\"exId\",\"type\":\"uint32\"}],\"name\":\"SetProductInfo\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"prTrade\",\"type\":\"uint32\"},{\"name\":\"prBase\",\"type\":\"uint32\"},{\"name\":\"_tickSize\",\"type\":\"uint8\"}],\"name\":\"SetOrderBookTickSize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"id\",\"type\":\"uint32\"}],\"name\":\"getOrder\",\"outputs\":[{\"name\":\"prTrade\",\"type\":\"uint32\"},{\"name\":\"prBase\",\"type\":\"uint32\"},{\"name\":\"sell\",\"type\":\"bool\"},{\"name\":\"price\",\"type\":\"uint80\"},{\"name\":\"qty\",\"type\":\"uint104\"},{\"name\":\"accountId\",\"type\":\"uint32\"},{\"name\":\"exId\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastProductId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"productFee\",\"type\":\"uint256\"}],\"name\":\"SetProductFee\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"prTrade\",\"type\":\"uint32\"},{\"name\":\"prBase\",\"type\":\"uint32\"},{\"name\":\"price\",\"type\":\"uint80\"},{\"name\":\"isSell\",\"type\":\"bool\"},{\"name\":\"orderN\",\"type\":\"uint16\"}],\"name\":\"GetHogaDetail\",\"outputs\":[{\"name\":\"orderIds\",\"type\":\"uint32[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastTransferId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isContractUse\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"isFreeze\",\"type\":\"bool\"},{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"SetFreezeByAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"AddOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"prTrade\",\"type\":\"uint32\"},{\"name\":\"prBase\",\"type\":\"uint32\"},{\"name\":\"hogaN\",\"type\":\"uint32\"}],\"name\":\"GetHoga\",\"outputs\":[{\"name\":\"priceB\",\"type\":\"uint80[]\"},{\"name\":\"volumeB\",\"type\":\"uint104[]\"},{\"name\":\"priceA\",\"type\":\"uint80[]\"},{\"name\":\"volumeA\",\"type\":\"uint104[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"price\",\"type\":\"uint80\"},{\"name\":\"n\",\"type\":\"uint8\"}],\"name\":\"GetTick\",\"outputs\":[{\"name\":\"\",\"type\":\"uint80\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"basePrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxQty\",\"outputs\":[{\"name\":\"\",\"type\":\"uint104\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"exId\",\"type\":\"uint32\"},{\"name\":\"amount\",\"type\":\"uint104\"}],\"name\":\"withdrawETH\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"exId\",\"type\":\"uint32\"},{\"name\":\"prCode\",\"type\":\"uint32\"},{\"name\":\"accountIds\",\"type\":\"uint32[]\"},{\"name\":\"qtys\",\"type\":\"uint104[]\"}],\"name\":\"airDrop\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"GetAccountId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"a\",\"type\":\"uint128\"},{\"name\":\"b\",\"type\":\"uint128\"}],\"name\":\"Sub\",\"outputs\":[{\"name\":\"\",\"type\":\"uint128\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"exId\",\"type\":\"uint32\"},{\"name\":\"amount\",\"type\":\"uint128\"},{\"name\":\"isDeposit\",\"type\":\"bool\"},{\"name\":\"prAddress\",\"type\":\"address\"}],\"name\":\"depositWithdrawToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"exId\",\"type\":\"uint32\"},{\"name\":\"prCode\",\"type\":\"uint32[]\"},{\"name\":\"accountId\",\"type\":\"uint32\"}],\"name\":\"getBalance\",\"outputs\":[{\"name\":\"available\",\"type\":\"uint128[]\"},{\"name\":\"reserved\",\"type\":\"uint128[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"decimals\",\"type\":\"uint256\"},{\"name\":\"product\",\"type\":\"address\"}],\"name\":\"AddProduct\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"isAsk\",\"type\":\"bool\"},{\"name\":\"price\",\"type\":\"uint80\"},{\"name\":\"n\",\"type\":\"uint8\"}],\"name\":\"GetNextTick\",\"outputs\":[{\"name\":\"\",\"type\":\"uint80\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"exId\",\"type\":\"uint32\"}],\"name\":\"depositETH\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint80\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"GetProductList\",\"outputs\":[{\"name\":\"products\",\"type\":\"address[]\"},{\"name\":\"productIds\",\"type\":\"uint32[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"exId\",\"type\":\"uint32\"},{\"name\":\"prCode\",\"type\":\"uint32\"},{\"name\":\"minQty\",\"type\":\"uint128\"}],\"name\":\"getBalanceByProduct\",\"outputs\":[{\"name\":\"accountId\",\"type\":\"uint32[]\"},{\"name\":\"balanceSum\",\"type\":\"uint128[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"exId\",\"type\":\"uint32\"},{\"name\":\"accountId\",\"type\":\"uint32\"},{\"name\":\"orderN\",\"type\":\"uint16\"}],\"name\":\"GetMyOrders\",\"outputs\":[{\"name\":\"orderId\",\"type\":\"uint32[]\"},{\"name\":\"prTrade\",\"type\":\"uint32[]\"},{\"name\":\"prBase\",\"type\":\"uint32[]\"},{\"name\":\"sells\",\"type\":\"bool[]\"},{\"name\":\"prices\",\"type\":\"uint80[]\"},{\"name\":\"qtys\",\"type\":\"uint104[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"prTrade\",\"type\":\"uint32[]\"},{\"name\":\"prBase\",\"type\":\"uint32\"}],\"name\":\"getOrderBookInfo\",\"outputs\":[{\"name\":\"bestBidPrice\",\"type\":\"uint80[]\"},{\"name\":\"bestAskPrice\",\"type\":\"uint80[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"prCode\",\"type\":\"uint32\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"emergencyWithdrawal\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"exId\",\"type\":\"uint32\"},{\"indexed\":false,\"name\":\"prCode\",\"type\":\"uint32\"},{\"indexed\":true,\"name\":\"accountId\",\"type\":\"uint32\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint128\"},{\"indexed\":false,\"name\":\"timestamp\",\"type\":\"uint64\"},{\"indexed\":false,\"name\":\"lastTransferId\",\"type\":\"uint32\"}],\"name\":\"NewDeposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"exId\",\"type\":\"uint32\"},{\"indexed\":false,\"name\":\"prCode\",\"type\":\"uint32\"},{\"indexed\":true,\"name\":\"accountId\",\"type\":\"uint32\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint128\"},{\"indexed\":false,\"name\":\"timestamp\",\"type\":\"uint64\"},{\"indexed\":false,\"name\":\"lastTransferId\",\"type\":\"uint32\"}],\"name\":\"NewWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"prTrade\",\"type\":\"uint32\"},{\"indexed\":true,\"name\":\"prBase\",\"type\":\"uint32\"},{\"indexed\":true,\"name\":\"accountId\",\"type\":\"uint32\"},{\"indexed\":false,\"name\":\"id\",\"type\":\"uint32\"},{\"indexed\":false,\"name\":\"isSell\",\"type\":\"bool\"},{\"indexed\":false,\"name\":\"price\",\"type\":\"uint80\"},{\"indexed\":false,\"name\":\"qty\",\"type\":\"uint104\"},{\"indexed\":false,\"name\":\"lastNewOrderId\",\"type\":\"uint32\"}],\"name\":\"NewOrder\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"prTrade\",\"type\":\"uint32\"},{\"indexed\":true,\"name\":\"prBase\",\"type\":\"uint32\"},{\"indexed\":true,\"name\":\"accountId\",\"type\":\"uint32\"},{\"indexed\":false,\"name\":\"id\",\"type\":\"uint32\"},{\"indexed\":false,\"name\":\"isSell\",\"type\":\"bool\"},{\"indexed\":false,\"name\":\"price\",\"type\":\"uint80\"},{\"indexed\":false,\"name\":\"qty\",\"type\":\"uint104\"},{\"indexed\":false,\"name\":\"lastNewOrderId\",\"type\":\"uint32\"}],\"name\":\"NewCancel\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"prTrade\",\"type\":\"uint32\"},{\"indexed\":true,\"name\":\"prBase\",\"type\":\"uint32\"},{\"indexed\":false,\"name\":\"isBid\",\"type\":\"bool\"},{\"indexed\":false,\"name\":\"price\",\"type\":\"uint80\"}],\"name\":\"NewBestBidAsk\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"prTrade\",\"type\":\"uint32\"},{\"indexed\":false,\"name\":\"prBase\",\"type\":\"uint32\"},{\"indexed\":true,\"name\":\"bidId\",\"type\":\"uint32\"},{\"indexed\":true,\"name\":\"askId\",\"type\":\"uint32\"},{\"indexed\":false,\"name\":\"accountIdBid\",\"type\":\"uint32\"},{\"indexed\":false,\"name\":\"accountIdAsk\",\"type\":\"uint32\"},{\"indexed\":false,\"name\":\"isSell\",\"type\":\"bool\"},{\"indexed\":false,\"name\":\"price\",\"type\":\"uint80\"},{\"indexed\":false,\"name\":\"qty\",\"type\":\"uint104\"},{\"indexed\":false,\"name\":\"lastTradeId\",\"type\":\"uint32\"},{\"indexed\":false,\"name\":\"timestamp\",\"type\":\"uint64\"}],\"name\":\"NewTrade\",\"type\":\"event\"}]","ContractName":"DEX","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://05d19cce9cc41962e52921c0b8ff0b4468813eaaf3513ecf7c7e89a8dfe241d1"}]}