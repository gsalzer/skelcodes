{"status":"1","message":"OK","result":[{"SourceCode":"{\"AuctionityChainId_V1.sol\":{\"content\":\"pragma solidity ^0.5.4;\\n\\nimport \\\"./AuctionityLibrary_V1.sol\\\";\\n\\n/// @title Auctionity chainId library\\ncontract AuctionityChainId_V1 is AuctionityLibrary_V1 {\\n    /// @notice getter of ethereum network id\\n    /// @return ethereum network id\\n    function getEthereumChainId_V1() public view returns (uint8) {\\n        return ethereumChainId;\\n    }\\n\\n    /// @notice getter of auctionity network id\\n    /// @return auctionity network id\\n    function getAuctionityChainId_V1() public view returns (uint8) {\\n        return auctionityChainId;\\n    }\\n\\n    /// @notice setter of ethereum network id\\n    /// @param _ethereumChainId uint8 : ethereum network id\\n    function setEthereumChainId_V1(uint8 _ethereumChainId) public {\\n        require(\\n            delegatedSendIsContractOwner_V1(),\\n            \\\"setEthereumChainId Contract owner\\\"\\n        );\\n        ethereumChainId = _ethereumChainId;\\n    }\\n\\n    /// @notice setter of auctionity network id\\n    /// @param _auctionityChainId uint8 : auctionity network id\\n    function setAuctionityChainId_V1(uint8 _auctionityChainId) public {\\n        require(\\n            delegatedSendIsContractOwner_V1(),\\n            \\\"setAuctionityChainId Contract owner\\\"\\n        );\\n        auctionityChainId = _auctionityChainId;\\n    }\\n\\n}\\n\"},\"AuctionityDeposit_V1.sol\":{\"content\":\"pragma solidity ^0.5.4;\\n\\nimport \\\"./AuctionityStorage1.sol\\\";\\n\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./AuctionityLibrary_V1.sol\\\";\\nimport \\\"./AuctionityLibraryDecodeRawTx_V1.sol\\\";\\n\\nimport \\\"./AuctionityChainId_V1.sol\\\";\\nimport \\\"./AuctionityOracable_V1.sol\\\";\\nimport \\\"./AuctionityPausable_V1.sol\\\";\\n\\ncontract AuctionityDeposit_V1 is AuctionityStorage1, AuctionityLibrary_V1, AuctionityChainId_V1 {\\n    using SafeMath for uint256;\\n\\n    struct InfoFromCreateAuction {\\n        bytes32 tokenHash;\\n        address tokenContractAddress;\\n        address auctionSeller;\\n        uint8 rewardPercent;\\n        uint256 tokenId;\\n    }\\n\\n    struct InfoFromBidding {\\n        address auctionContractAddress;\\n        address signer;\\n        uint256 amount;\\n    }\\n\\n    // For previous compatibility\\n    event LogSentEthToWinner(address auction, address user, uint256 amount);\\n    event LogSentRewardsDepotEth(address[] user, uint256[] amount);\\n    event LogDeposed(address user, uint256 amount);\\n    event LogWithdrawalVoucherSubmitted(address user, uint256 amount, bytes32 withdrawalVoucherHash);\\n    event LogAuctionEndVoucherSubmitted(\\n        bytes32 tokenHash,\\n        address tokenContractAddress,\\n        uint256 tokenId,\\n        address indexed seller,\\n        address indexed winner,\\n        uint256 amount,\\n        bytes32 auctionEndVoucherHash\\n    );\\n\\n    // events\\n    event LogWithdrawalVoucherSubmitted_V1(\\n        address user,\\n        uint256 amount,\\n        bytes32 withdrawalVoucherHash\\n    );\\n\\n    event LogAddDepot_V1(\\n        address user,\\n        address tokenContractAddress,\\n        uint256 tokenId,\\n        uint256 amount,\\n        uint256 totalAmount\\n    );\\n\\n    event LogAuctionEndVoucherSubmitted_V1(\\n        bytes32 tokenHash,\\n        address tokenContractAddress,\\n        uint256 tokenId,\\n        address indexed seller,\\n        address indexed winner,\\n        uint256 amount,\\n        bytes32 auctionEndVoucher_V1Hash\\n    );\\n    event LogSentEthToSeller_V1(address auction, address user, uint256 amount);\\n    event LogSentRewardsDepotEth_V1(address[] user, uint256[] amount);\\n\\n    /// @notice get amount of user\\u0027s deposit\\n    /// @dev Comptability with previous \\u0027AuctionityDeposit_V1\\u0027\\n    /// @param _user address\\n    /// @return _amount uint256\\n    function getDepotEth(address _user) public view returns (uint256 _amount) {\\n        return getBalanceEth_V1(_user);\\n    }\\n\\n    /// @notice fallback payable function , with revert if is deactivated\\n    function() external payable {\\n        return receiveDepotEth_V1();\\n    }\\n\\n    /// @notice deposit Eth\\n    /// @dev Comptability with previous \\u0027AuctionityDeposit\\u0027\\n    function depositEth() public payable {\\n        receiveDepotEth_V1();\\n    }\\n\\n    /// @notice receive depot Eth\\n    function receiveDepotEth_V1()  public payable {\\n        require(!delegatedSendGetPaused_V1(), \\\"CONTRACT_PAUSED\\\");\\n\\n        address _user = msg.sender;\\n        uint256 _amount = uint256(msg.value);\\n\\n        _addDepotEth_V1(_user, _amount);\\n\\n        // For previous compatibility\\n        emit LogDeposed(_user, _amount);\\n\\n        emit LogAddDepot_V1(\\n            _user,\\n            address(0),\\n            uint256(0),\\n            _amount,\\n            getBalanceEth_V1(_user)\\n        );\\n\\n    }\\n\\n    /// @notice internal add depot Eth\\n    /// @param _user address from depot\\n    /// @param _amount uint256\\n    /// @return _success\\n    function _addDepotEth_V1(address _user, uint256 _amount)\\n        internal\\n        returns (bool)\\n    {\\n        return _addDepot_V1(_user, address(0), uint256(0), _amount);\\n    }\\n\\n    /// @notice internal add depot (compatibility ERC1155)\\n    /// @param _user address from depot\\n    /// @param _tokenContractAddress address of NFT smart contract\\n    /// @param _tokenId uint256 of ERC1155\\n    /// @param _amount uint256 of ERC1155\\n    /// @return _success\\n    function _addDepot_V1(\\n        address _user,\\n        address _tokenContractAddress,\\n        uint256 _tokenId,\\n        uint256 _amount\\n    ) internal returns (bool) {\\n        require(_amount \\u003e 0, \\\"Amount must be greater than 0\\\");\\n\\n        tokens[_tokenContractAddress][_tokenId][_user] = tokens[_tokenContractAddress][_tokenId][_user].add(\\n            _amount\\n        );\\n\\n        return true;\\n    }\\n\\n    /// @notice internal subtraction depot eth\\n    /// @param _user address\\n    /// @param _amount uint256\\n    /// @return _success\\n    function _subDepotEth_V1(address _user, uint256 _amount)\\n        internal\\n        returns (bool)\\n    {\\n        return _subDepot_V1(_user, address(0), uint256(0), _amount);\\n    }\\n\\n    /// @notice internal substration depot (compatibility ERC1155)\\n    /// @param _user address from depot\\n    /// @param _tokenContractAddress address of NFT smart contract\\n    /// @param _tokenId uint256 of ERC1155\\n    /// @param _amount uint256 of ERC1155\\n    /// @return _success\\n    function _subDepot_V1(\\n        address _user,\\n        address _tokenContractAddress,\\n        uint256 _tokenId,\\n        uint256 _amount\\n    ) internal returns (bool) {\\n        require(\\n            tokens[_tokenContractAddress][_tokenId][_user] \\u003e= _amount,\\n            \\\"Amount too low\\\"\\n        );\\n\\n        tokens[_tokenContractAddress][_tokenId][_user] = tokens[_tokenContractAddress][_tokenId][_user].sub(\\n            _amount\\n        );\\n\\n        return true;\\n    }\\n\\n    /// @notice get balance Eth for a user\\n    /// @param _user address\\n    /// @return _balanceOf uint256\\n    function getBalanceEth_V1(address _user) public view returns (uint256 _balanceOf) {\\n        return _getBalance_V1(_user, address(0), uint256(0));\\n    }\\n\\n    /// @notice get balance for a user (compatibility ERC1155)\\n    /// @param _user address from depot\\n    /// @param _tokenContractAddress address of NFT smart contract\\n    /// @param _tokenId uint256 of ERC1155\\n    /// @return _balanceOf uint256\\n    function _getBalance_V1(\\n        address _user,\\n        address _tokenContractAddress,\\n        uint256 _tokenId\\n    ) internal view returns (uint256 _balanceOf) {\\n        return tokens[_tokenContractAddress][_tokenId][_user];\\n    }\\n\\n    /// @notice withdrawal voucher\\n    /// @param _withdrawalVoucherData bytes , RSV FROM Oracle, user , amount and key (anti replay)\\n    /// @param _signedRawTxWithdrawal bytes\\n    function withdrawalVoucher_V1(\\n        bytes memory _withdrawalVoucherData,\\n        bytes memory _signedRawTxWithdrawal\\n    ) public {\\n        require(!delegatedSendGetPaused_V1(), \\\"CONTRACT_PAUSED\\\");\\n\\n        bytes32 _withdrawalVoucherHash = keccak256(_signedRawTxWithdrawal);\\n\\n        require(\\n            withdrawalVoucherSubmitted[_withdrawalVoucherHash] != true,\\n            \\\"Withdrawal voucher is already submited\\\"\\n        );\\n\\n        address _withdrawalSigner;\\n        uint _withdrawalAmount;\\n\\n        (_withdrawalSigner, _withdrawalAmount) = AuctionityLibraryDecodeRawTx_V1.decodeRawTxGetWithdrawalInfo_V1(\\n            _signedRawTxWithdrawal,\\n            getAuctionityChainId_V1()\\n        );\\n\\n        require(\\n            _withdrawalAmount != uint256(0),\\n            \\\"Withdrawal voucher amount must be greater than zero\\\"\\n        );\\n        require(\\n            _withdrawalSigner != address(0),\\n            \\\"Withdrawal voucher invalid signature of oracle\\\"\\n        );\\n\\n        // if depot is smaller than amount\\n        require(\\n            getBalanceEth_V1(_withdrawalSigner) \\u003e= _withdrawalAmount,\\n            \\\"Withdrawal voucher depot amount is too low\\\"\\n        );\\n\\n        require(\\n            withdrawalVoucherOracleSignatureVerification_V1(\\n                _withdrawalVoucherData,\\n                _withdrawalSigner,\\n                _withdrawalAmount,\\n                _withdrawalVoucherHash\\n            ),\\n            \\\"Withdrawal voucher invalid signature of oracle\\\"\\n        );\\n\\n        // send amount\\n        require(\\n            address(uint160(_withdrawalSigner)).send(_withdrawalAmount),\\n            \\\"Withdrawal voucher transfer failed\\\"\\n        );\\n\\n        _subDepotEth_V1(_withdrawalSigner, _withdrawalAmount);\\n\\n        withdrawalVoucherList.push(_withdrawalVoucherHash);\\n        withdrawalVoucherSubmitted[_withdrawalVoucherHash] = true;\\n\\n        // For previous compatibility\\n        emit LogWithdrawalVoucherSubmitted(\\n            _withdrawalSigner,\\n            _withdrawalAmount,\\n            _withdrawalVoucherHash\\n        );\\n\\n        emit LogWithdrawalVoucherSubmitted_V1(\\n            _withdrawalSigner,\\n            _withdrawalAmount,\\n            _withdrawalVoucherHash\\n        );\\n    }\\n\\n    /// @notice internal withdrawal voucher oracle signature verification\\n    /// @param _withdrawalVoucherData bytes\\n    /// @param _withdrawalSigner address\\n    /// @param _withdrawalAmount uint256\\n    /// @param _withdrawalVoucherHash bytes32 : hash of _signedRawTxWithdrawal\\n    /// @return _success\\n    function withdrawalVoucherOracleSignatureVerification_V1(\\n        bytes memory _withdrawalVoucherData,\\n        address _withdrawalSigner,\\n        uint256 _withdrawalAmount,\\n        bytes32 _withdrawalVoucherHash\\n    ) internal returns (bool) {\\n        /// @dev if oracle is the signer of this withdrawal voucher\\n        return delegatedSendGetOracle_V1(\\n\\n        ) == AuctionityLibraryDecodeRawTx_V1.ecrecoverSigner_V1(\\n            keccak256(\\n                abi.encodePacked(\\n                    \\\"\\\\x19Ethereum Signed Message:\\\\n32\\\",\\n                    keccak256(\\n                        abi.encodePacked(\\n                            address(this),\\n                            _withdrawalSigner,\\n                            _withdrawalAmount,\\n                            _withdrawalVoucherHash\\n                        )\\n                    )\\n                )\\n            ),\\n                _withdrawalVoucherData,\\n            0\\n        );\\n    }\\n\\n    /// @notice auctionEndVoucher_V1\\n    /// @param _auctionEndVoucherData is a  concatenate of : biddingHashProof, rsv ECDSA signature of oracle validation AEV and transfer token\\n    /// @param _signedRawTxCreateAuction bytes of signed transaction of create transaction on auction smart contract\\n    /// @param _signedRawTxBidding bytes of signed transaction of bidding transaction on auction smart contract\\n    /// @param _send bytes of send external and internal (rewards) amount\\n    function auctionEndVoucher_V1(\\n        bytes memory _auctionEndVoucherData,\\n        bytes memory _signedRawTxCreateAuction,\\n        bytes memory _signedRawTxBidding,\\n        bytes memory _send\\n    ) public {\\n        require(!delegatedSendGetPaused_V1(), \\\"CONTRACT_PAUSED\\\");\\n\\n        bytes32 _auctionEndVoucherHash = keccak256(_signedRawTxCreateAuction);\\n        require(\\n            auctionEndVoucherSubmitted[_auctionEndVoucherHash] != true,\\n            \\\"Auction end voucher already submited\\\"\\n        );\\n\\n        InfoFromCreateAuction memory _infoFromCreateAuction = getInfoFromCreateAuction_V1(\\n            _signedRawTxCreateAuction\\n        );\\n\\n        address _auctionContractAddress;\\n        address _winnerSigner;\\n        uint256 _winnerAmount;\\n\\n        InfoFromBidding memory _infoFromBidding;\\n\\n        if (_signedRawTxBidding.length \\u003e 1) {\\n            _infoFromBidding = getInfoFromBidding_V1(\\n                _signedRawTxBidding,\\n                _infoFromCreateAuction.tokenHash\\n            );\\n\\n            if (!verifyWinnerDepot_V1(_infoFromBidding)) {\\n                return;\\n            }\\n        }\\n\\n        require(\\n            auctionEndVoucherOracleSignatureVerification_V1(\\n                _auctionEndVoucherData,\\n                keccak256(_send),\\n                _infoFromCreateAuction,\\n                _infoFromBidding\\n            ),\\n            \\\"Auction end voucher invalid signature of oracle\\\"\\n        );\\n\\n        require(\\n            sendTransfer_V1(\\n                _infoFromCreateAuction.tokenContractAddress,\\n                _auctionEndVoucherData,\\n                97\\n            ),\\n            \\\"Auction end voucher transfer failed\\\"\\n        );\\n\\n        if (_signedRawTxBidding.length \\u003e 1) {\\n            if (!sendExchange_V1(\\n                _send,\\n                _infoFromCreateAuction,\\n                _infoFromBidding\\n            )) {\\n                return;\\n            }\\n        }\\n\\n        auctionEndVoucherList.push(_auctionEndVoucherHash);\\n        auctionEndVoucherSubmitted[_auctionEndVoucherHash] = true;\\n\\n        // For previous compatibility\\n        emit LogAuctionEndVoucherSubmitted(\\n            _infoFromCreateAuction.tokenHash,\\n            _infoFromCreateAuction.tokenContractAddress,\\n            _infoFromCreateAuction.tokenId,\\n            _infoFromCreateAuction.auctionSeller,\\n            _infoFromBidding.signer,\\n            _infoFromBidding.amount,\\n            _auctionEndVoucherHash\\n        );\\n\\n        emit LogAuctionEndVoucherSubmitted_V1(\\n            _infoFromCreateAuction.tokenHash,\\n            _infoFromCreateAuction.tokenContractAddress,\\n            _infoFromCreateAuction.tokenId,\\n            _infoFromCreateAuction.auctionSeller,\\n            _infoFromBidding.signer,\\n            _infoFromBidding.amount,\\n            _auctionEndVoucherHash\\n        );\\n    }\\n\\n    /// @notice internal get information from create auction signed transaction\\n    /// @param _signedRawTxCreateAuction bytes\\n    /// @return InfoFromCreateAuction structure\\n    function getInfoFromCreateAuction_V1(bytes memory _signedRawTxCreateAuction)\\n        internal\\n        view\\n        returns (InfoFromCreateAuction memory _infoFromCreateAuction)\\n    {\\n        (_infoFromCreateAuction.tokenHash, , _infoFromCreateAuction.auctionSeller, _infoFromCreateAuction.tokenContractAddress, _infoFromCreateAuction.tokenId, _infoFromCreateAuction.rewardPercent) = AuctionityLibraryDecodeRawTx_V1.decodeRawTxGetCreateAuctionInfo_V1(\\n            _signedRawTxCreateAuction,\\n            getAuctionityChainId_V1()\\n        );\\n    }\\n\\n    /// @notice internal get information from bidding signed transaction\\n    /// @param _signedRawTxBidding bytes\\n    /// @param _hashSignedRawTxTokenTransfer bytes32 tokenhash :  hash of _signedRawTxTokenTransfer (include into create auction transaction)\\n    /// @return InfoFromBidding structure\\n    function getInfoFromBidding_V1(\\n        bytes memory _signedRawTxBidding,\\n        bytes32 _hashSignedRawTxTokenTransfer\\n    ) internal returns (InfoFromBidding memory _infoFromBidding) {\\n        bytes32 _hashRawTxTokenTransferFromBid;\\n\\n        (_hashRawTxTokenTransferFromBid, _infoFromBidding.auctionContractAddress, _infoFromBidding.amount, _infoFromBidding.signer) = AuctionityLibraryDecodeRawTx_V1.decodeRawTxGetBiddingInfo_V1(\\n            _signedRawTxBidding,\\n            getAuctionityChainId_V1()\\n        );\\n\\n        require(\\n            _hashRawTxTokenTransferFromBid == _hashSignedRawTxTokenTransfer,\\n            \\\"Auction end voucher hashRawTxTokenTransfer is invalid\\\"\\n        );\\n\\n        require(\\n            _infoFromBidding.amount != uint256(0),\\n            \\\"Auction end voucher bidding amount must be greater than zero\\\"\\n        );\\n\\n        return _infoFromBidding;\\n\\n    }\\n\\n    /// @notice intenral verify winner have enouth depot with bidding information\\n    /// @param _infoFromBidding InfoFromBidding structure\\n    /// @return _success\\n    function verifyWinnerDepot_V1(InfoFromBidding memory _infoFromBidding)\\n        internal\\n        returns (bool)\\n    {\\n        // depot is greatuer or eqal than amount\\n        require(\\n            getBalanceEth_V1(\\n                _infoFromBidding.signer\\n            ) \\u003e= _infoFromBidding.amount,\\n            \\\"Auction end voucher depot amount is too low\\\"\\n        );\\n\\n        return true;\\n    }\\n\\n    /// @notice internal send external and internal deposit amount\\n    /// @param _send bytes of send external and internal (rewards) amount\\n    /// @param _infoFromCreateAuction InfoFromCreateAuction structure\\n    /// @param _infoFromBidding InfoFromBidding structure\\n    /// @return _success\\n    function sendExchange_V1(\\n        bytes memory _send,\\n        InfoFromCreateAuction memory _infoFromCreateAuction,\\n        InfoFromBidding memory _infoFromBidding\\n    ) internal returns (bool) {\\n        require(\\n            _subDepotEth_V1(_infoFromBidding.signer, _infoFromBidding.amount),\\n            \\\"Auction end voucher depot amout is too low\\\"\\n        );\\n\\n        uint offset;\\n        address payable _sendAddress;\\n        uint256 _sendAmount;\\n        bytes12 _sendAmountGwei;\\n        uint256 _sentAmount;\\n\\n        assembly {\\n            _sendAddress := mload(add(_send, add(offset, 0x14)))\\n            _sendAmount := mload(add(_send, add(add(offset, 20), 0x20)))\\n        }\\n\\n        require(\\n            _sendAddress == _infoFromCreateAuction.auctionSeller,\\n            \\\"Auction end voucher sender address is invalider\\\"\\n        );\\n\\n        _sentAmount += _sendAmount;\\n        offset += 52;\\n\\n        // send amount to seller\\n        if (!_sendAddress.send(_sendAmount)) {\\n            revert(\\\"Failed to send funds\\\");\\n        }\\n\\n        // emit old event for previous compatibility\\n        emit LogSentEthToWinner(_infoFromBidding.auctionContractAddress,\\n            _sendAddress,\\n            _sendAmount);\\n\\n        emit LogSentEthToSeller_V1(\\n            _infoFromBidding.auctionContractAddress,\\n            _sendAddress,\\n            _sendAmount\\n        );\\n\\n        // if community rewards is informed\\n        if (_infoFromCreateAuction.rewardPercent \\u003e 0) {\\n\\n            // get number of rewards\\n            bytes2 _numberOfSendDepositBytes2;\\n            assembly {\\n                _numberOfSendDepositBytes2 := mload(\\n                    add(_send, add(offset, 0x20))\\n                )\\n            }\\n\\n            offset += 2;\\n\\n\\n            // initiate _rewardsAddress and _rewardsAmount\\n            address[] memory _rewardsAddress = new address[](\\n                uint16(_numberOfSendDepositBytes2)\\n            );\\n            uint256[] memory _rewardsAmount = new uint256[](\\n                uint16(_numberOfSendDepositBytes2)\\n            );\\n\\n\\n            for (uint16 i = 0; i \\u003c uint16(_numberOfSendDepositBytes2); i++) {\\n\\n                // get address and amount in gwei for reward\\n                assembly {\\n                    _sendAddress := mload(add(_send, add(offset, 0x14)))\\n                    _sendAmountGwei := mload(\\n                        add(_send, add(add(offset, 20), 0x20))\\n                    )\\n                }\\n\\n                // multiply amount in gwei to wei\\n                _sendAmount = uint96(_sendAmountGwei) * 1000000000;\\n                // sum of all reward amount for verification below\\n                _sentAmount += _sendAmount;\\n                offset += 32;\\n\\n                // add internal deposit reward amount for reward address\\n                if (!_addDepotEth_V1(_sendAddress, _sendAmount)) {\\n                    revert(\\\"Can\\u0027t add deposit\\\");\\n                }\\n\\n                _rewardsAddress[i] = _sendAddress;\\n                _rewardsAmount[i] = uint256(_sendAmount);\\n            }\\n\\n            // For previous compatibility\\n            emit LogSentRewardsDepotEth(_rewardsAddress, _rewardsAmount);\\n\\n            emit LogSentRewardsDepotEth_V1(_rewardsAddress, _rewardsAmount);\\n        }\\n\\n        // verification if sum of sended amount is equal than bidding amount\\n        if (uint256(_infoFromBidding.amount) != _sentAmount) {\\n            revert(\\\"Bidding amount is not equal to sent amount\\\");\\n        }\\n\\n        return true;\\n    }\\n\\n    /// @notice internal get transfert data hash from AEV data (part of transfert token to winner)\\n    /// @param _auctionEndVoucherData bytes\\n    /// @return _transferDataHash bytes32\\n    function getTransferDataHash_V1(bytes memory _auctionEndVoucherData)\\n        internal\\n        pure\\n        returns (bytes32 _transferDataHash)\\n    {\\n        bytes memory _transferData = new bytes(_auctionEndVoucherData.length - 97);\\n\\n        for (uint i = 0; i \\u003c (_auctionEndVoucherData.length - 97); i++) {\\n            _transferData[i] = _auctionEndVoucherData[i + 97];\\n        }\\n        return keccak256(_transferData);\\n\\n    }\\n\\n    /// @notice internal auctionEndVoucher oracle signature verification\\n    /// @param _auctionEndVoucherData bytes\\n    /// @param _sendDataHash bytes32\\n    /// @param _infoFromCreateAuction InfoFromCreateAuction structure\\n    /// @param _infoFromBidding InfoFromBidding structure\\n    /// @return _success\\n    function auctionEndVoucherOracleSignatureVerification_V1(\\n        bytes memory _auctionEndVoucherData,\\n        bytes32 _sendDataHash,\\n        InfoFromCreateAuction memory _infoFromCreateAuction,\\n        InfoFromBidding memory _infoFromBidding\\n    ) internal returns (bool) {\\n        bytes32 _biddingHashProof;\\n        assembly {\\n            _biddingHashProof := mload(add(_auctionEndVoucherData, add(0, 0x20)))\\n        }\\n\\n        // get hash of transfert data\\n        bytes32 _transferDataHash = getTransferDataHash_V1(_auctionEndVoucherData);\\n\\n        // if oracle is the signer of this auction end voucher\\n        return delegatedSendGetOracle_V1() == AuctionityLibraryDecodeRawTx_V1.ecrecoverSigner_V1(\\n            keccak256(\\n                abi.encodePacked(\\n                    \\\"\\\\x19Ethereum Signed Message:\\\\n32\\\",\\n                    keccak256(\\n                        abi.encodePacked(\\n                            address(this),\\n                            _infoFromCreateAuction.tokenContractAddress,\\n                            _infoFromCreateAuction.tokenId,\\n                            _infoFromCreateAuction.auctionSeller,\\n                            _infoFromBidding.signer,\\n                            _infoFromBidding.amount,\\n                            _biddingHashProof,\\n                            _infoFromCreateAuction.rewardPercent,\\n                            _transferDataHash,\\n                            _sendDataHash\\n                        )\\n                    )\\n                )\\n            ),\\n            _auctionEndVoucherData,\\n            32\\n        );\\n\\n    }\\n\\n    /// @notice send token(s) to winner\\n    /// @param _tokenContractAddress address\\n    /// @param _auctionEndVoucherData bytes\\n    /// @param _offset of begin transfert data\\n    function sendTransfer_V1(\\n        address _tokenContractAddress,\\n        bytes memory _auctionEndVoucherData,\\n        uint _offset\\n    ) internal returns (bool) {\\n        if (!isContract_V1(_tokenContractAddress)) {\\n            return false;\\n        }\\n\\n        uint8 _numberOfTransfer = uint8(_auctionEndVoucherData[_offset]);\\n\\n        _offset += 1;\\n\\n        bool _success;\\n        for (uint8 i = 0; i \\u003c _numberOfTransfer; i++) {\\n            (_offset, _success) = decodeTransferCall_V1(\\n                _tokenContractAddress,\\n                _auctionEndVoucherData,\\n                _offset\\n            );\\n\\n            if (!_success) {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n\\n    }\\n\\n    /// @notice decode transfert and call token smart contract\\n    /// @param _tokenContractAddress address\\n    /// @param _auctionEndVoucherData bytes\\n    /// @param _offset of begin transfert data\\n    /// @return new offset, and _success\\n    function decodeTransferCall_V1(\\n        address _tokenContractAddress,\\n        bytes memory _auctionEndVoucherData,\\n        uint _offset\\n    ) internal returns (uint, bool) {\\n        bytes memory _sizeOfCallBytes;\\n        bytes memory _callData;\\n\\n        uint _sizeOfCallData;\\n\\n        if (_auctionEndVoucherData[_offset] == 0xb8) {\\n            _sizeOfCallBytes = new bytes(1);\\n            _sizeOfCallBytes[0] = bytes1(_auctionEndVoucherData[_offset + 1]);\\n\\n            _offset += 2;\\n        }\\n        if (_auctionEndVoucherData[_offset] == 0xb9) {\\n            _sizeOfCallBytes = new bytes(2);\\n            _sizeOfCallBytes[0] = bytes1(_auctionEndVoucherData[_offset + 1]);\\n            _sizeOfCallBytes[1] = bytes1(_auctionEndVoucherData[_offset + 2]);\\n            _offset += 3;\\n        }\\n        \\n        _sizeOfCallData = bytesToUint_V1(_sizeOfCallBytes);\\n\\n        _callData = new bytes(_sizeOfCallData);\\n        for (uint j = 0; j \\u003c _sizeOfCallData; j++) {\\n            _callData[j] = _auctionEndVoucherData[(j + _offset)];\\n        }\\n\\n        _offset += _sizeOfCallData;\\n\\n        return (_offset, sendCallData_V1(\\n            _tokenContractAddress,\\n            _sizeOfCallData,\\n            _callData\\n        ));\\n\\n    }\\n\\n    /// @notice call token smart contract with call data\\n    /// @param _tokenContractAddress address\\n    /// @param _sizeOfCallData uint256 , size of call data\\n    /// @param _callData bytes\\n    /// @return _success\\n    function sendCallData_V1(\\n        address _tokenContractAddress,\\n        uint256 _sizeOfCallData,\\n        bytes memory _callData\\n    ) internal returns (bool) {\\n        bool _success;\\n        bytes4 sig;\\n\\n        assembly {\\n            let _ptr := mload(0x40)\\n            sig := mload(add(_callData, 0x20))\\n\\n            mstore(_ptr, sig) //Place signature at begining of empty storage\\n            for {\\n                let i := 0x04\\n            } lt(i, _sizeOfCallData) {\\n                i := add(i, 0x20)\\n            } {\\n                mstore(add(_ptr, i), mload(add(_callData, add(0x20, i)))) //Add each param\\n            }\\n\\n            // call external smart contract with 10K de gas, return _success\\n            _success := call(\\n                //This is the critical change (Pop the top stack value)\\n                sub(gas, 10000), // gas\\n                _tokenContractAddress, //To addr\\n                0, //No value\\n                _ptr, //Inputs are stored at location _ptr\\n                _sizeOfCallData, //Inputs _size\\n                _ptr, //Store output over input (saves space)\\n                0x20\\n            ) //Outputs are 32 bytes long\\n\\n        }\\n\\n        return _success;\\n    }\\n\\n}\\n\"},\"AuctionityLibraryDecodeRawTx_V1.sol\":{\"content\":\"pragma solidity ^0.5.4;\\n\\n/**\\n * @title AuctionityLibraryDecodeRawTx\\n * @dev Library for auctionity\\n */\\n\\nimport \\\"./RLPReader.sol\\\";\\nimport \\\"./RLPWriter.sol\\\";\\n\\nlibrary AuctionityLibraryDecodeRawTx_V1 {\\n    using RLPReader for RLPReader.RLPItem;\\n    using RLPReader for bytes;\\n\\n    function decodeRawTxGetBiddingInfo_V1(\\n        bytes memory _signedRawTxBidding,\\n        uint8 _chainId\\n    )\\n        internal\\n        pure\\n        returns (\\n        bytes32 _hashRawTxTokenTransfer,\\n        address _auctionContractAddress,\\n        uint256 _bidAmount,\\n        address _signerBid\\n    )\\n    {\\n        bytes memory _auctionBidlData;\\n        RLPReader.RLPItem[] memory _signedRawTxBiddingRLPItem = _signedRawTxBidding.toRlpItem(\\n\\n        ).toList();\\n\\n        _auctionContractAddress = _signedRawTxBiddingRLPItem[3].toAddress();\\n        _auctionBidlData = _signedRawTxBiddingRLPItem[5].toBytes();\\n\\n        bytes4 _selector;\\n        assembly {\\n            _selector := mload(add(_auctionBidlData, 0x20))\\n        }\\n\\n        _signerBid = getSignerFromSignedRawTxRLPItem_V1(\\n            _signedRawTxBiddingRLPItem,\\n            _chainId\\n        );\\n\\n        // 0x1d03ae68 : bytes4(keccak256(\\u0027bid(uint256,address,bytes32)\\u0027))\\n        if (_selector == 0x1d03ae68) {\\n            assembly {\\n                _bidAmount := mload(add(_auctionBidlData, add(4, 0x20)))\\n                _hashRawTxTokenTransfer := mload(\\n                    add(_auctionBidlData, add(68, 0x20))\\n                )\\n            }\\n\\n        }\\n\\n        // 0x8470df06 : bytes4(keccak256(\\u0027bid(uint256,address,address,bytes32)\\u0027))\\n        if (_selector == 0x8470df06) {\\n            assembly {\\n                _bidAmount := mload(add(_auctionBidlData, add(4, 0x20)))\\n                _hashRawTxTokenTransfer := mload(\\n                    add(_auctionBidlData, add(100, 0x20))\\n                )\\n            }\\n\\n        }\\n\\n    }\\n\\n    function decodeRawTxGetCreateAuctionInfo_V1(\\n        bytes memory _signedRawTxCreateAuction,\\n        uint8 _chainId\\n    )\\n        internal\\n        pure\\n        returns (\\n        bytes32 _tokenHash,\\n        address _auctionFactoryContractAddress,\\n        address _signerCreate,\\n        address _tokenContractAddress,\\n        uint256 _tokenId,\\n        uint8 _rewardPercent\\n    )\\n    {\\n        bytes memory _createAuctionlData;\\n        RLPReader.RLPItem[] memory _signedRawTxCreateAuctionRLPItem = _signedRawTxCreateAuction.toRlpItem(\\n\\n        ).toList();\\n\\n        _auctionFactoryContractAddress = _signedRawTxCreateAuctionRLPItem[3].toAddress(\\n\\n        );\\n        _createAuctionlData = _signedRawTxCreateAuctionRLPItem[5].toBytes();\\n\\n        _signerCreate = getSignerFromSignedRawTxRLPItem_V1(\\n            _signedRawTxCreateAuctionRLPItem,\\n            _chainId\\n        );\\n\\n        bytes memory _signedRawTxTokenTransfer;\\n\\n        (_signedRawTxTokenTransfer, _tokenContractAddress, _tokenId, _rewardPercent) = decodeRawTxGetCreateAuctionInfoData_V1(\\n            _createAuctionlData\\n        );\\n\\n        _tokenHash = keccak256(_signedRawTxTokenTransfer);\\n\\n    }\\n\\n    function decodeRawTxGetCreateAuctionInfoData_V1(\\n        bytes memory _createAuctionlData\\n    )\\n        internal\\n        pure\\n        returns (\\n        bytes memory _signedRawTxTokenTransfer,\\n        address _tokenContractAddress,\\n        uint256 _tokenId,\\n        uint8 _rewardPercent\\n    )\\n    {\\n        bytes4 _selector;\\n        assembly {\\n            _selector := mload(add(_createAuctionlData, 0x20))\\n        }\\n\\n        uint _positionOfSignedRawTxTokenTransfer;\\n        uint _sizeOfSignedRawTxTokenTransfer;\\n        uint i;\\n\\n        // 0xffd6d828 : bytes4(keccak256(\\u0027create(bytes,address,uint256,bytes,address,uint8)\\u0027))\\n        if (_selector == 0xffd6d828) {\\n            assembly {\\n                _positionOfSignedRawTxTokenTransfer := mload(\\n                    add(_createAuctionlData, add(4, 0x20))\\n                )\\n                _sizeOfSignedRawTxTokenTransfer := mload(\\n                    add(\\n                        _createAuctionlData,\\n                        add(add(_positionOfSignedRawTxTokenTransfer, 4), 0x20)\\n                    )\\n                )\\n\\n                // tokenContractAddress : get 2th param\\n                _tokenContractAddress := mload(\\n                    add(_createAuctionlData, add(add(mul(1, 32), 4), 0x20))\\n                )\\n                // tockenId : get 3th param\\n                _tokenId := mload(\\n                    add(_createAuctionlData, add(add(mul(2, 32), 4), 0x20))\\n                )\\n                // rewardPercent : get 6th param\\n                _rewardPercent := mload(\\n                    add(_createAuctionlData, add(add(mul(5, 32), 4), 0x20))\\n                )\\n\\n            }\\n\\n            _signedRawTxTokenTransfer = new bytes(\\n                _sizeOfSignedRawTxTokenTransfer\\n            );\\n\\n            for (i = 0; i \\u003c _sizeOfSignedRawTxTokenTransfer; i++) {\\n                _signedRawTxTokenTransfer[i] = _createAuctionlData[i + _positionOfSignedRawTxTokenTransfer + 4 + 32];\\n            }\\n\\n        }\\n\\n        // 0xffd6d828 : bytes4(keccak256(\\u0027create(bytes,address,uint256,bytes,address,uint8[])\\u0027))\\n        if (_selector == 0xfe7ccebd) {\\n            uint _positionOfRewards;\\n            assembly {\\n                _positionOfSignedRawTxTokenTransfer := mload(\\n                    add(_createAuctionlData, add(4, 0x20))\\n                )\\n                _sizeOfSignedRawTxTokenTransfer := mload(\\n                    add(\\n                        _createAuctionlData,\\n                        add(add(_positionOfSignedRawTxTokenTransfer, 4), 0x20)\\n                    )\\n                )\\n\\n                // tokenContractAddress : get 2th param\\n                _tokenContractAddress := mload(\\n                    add(_createAuctionlData, add(add(mul(1, 32), 4), 0x20))\\n                )\\n                // tockenId : get 3th param\\n                _tokenId := mload(\\n                    add(_createAuctionlData, add(add(mul(2, 32), 4), 0x20))\\n                )\\n\\n                // rewardPercent : get 6th param\\n\\n                _positionOfRewards := mload(\\n                    add(_createAuctionlData, add(add(mul(5, 32), 4), 0x20))\\n                )\\n\\n                // get 1th param\\n                _rewardPercent := mload(\\n                    add(\\n                        _createAuctionlData,\\n                        add(add(_positionOfRewards, 4), 0x40)\\n                    )\\n                )\\n\\n            }\\n\\n            _signedRawTxTokenTransfer = new bytes(\\n                _sizeOfSignedRawTxTokenTransfer\\n            );\\n\\n            for (i = 0; i \\u003c _sizeOfSignedRawTxTokenTransfer; i++) {\\n                _signedRawTxTokenTransfer[i] = _createAuctionlData[i + _positionOfSignedRawTxTokenTransfer + 4 + 32];\\n            }\\n\\n        }\\n\\n    }\\n\\n    function decodeRawTxGetWithdrawalInfo_V1(\\n        bytes memory _signedRawTxWithdrawal,\\n        uint8 _chainId\\n    )\\n        internal\\n        pure\\n        returns (address withdrawalSigner, uint256 withdrawalAmount)\\n    {\\n        bytes4 _selector;\\n        bytes memory _withdrawalData;\\n        RLPReader.RLPItem[] memory _signedRawTxWithdrawalRLPItem = _signedRawTxWithdrawal.toRlpItem(\\n\\n        ).toList();\\n\\n        _withdrawalData = _signedRawTxWithdrawalRLPItem[5].toBytes();\\n\\n        assembly {\\n            _selector := mload(add(_withdrawalData, 0x20))\\n        }\\n\\n        withdrawalSigner = getSignerFromSignedRawTxRLPItem_V1(\\n            _signedRawTxWithdrawalRLPItem,\\n            _chainId\\n        );\\n\\n        // 0x47960938 : bytes4(keccak256(\\u0027withdrawalEth_V1(uint256)\\u0027))\\n        if (_selector == 0x47960938) {\\n            assembly {\\n                withdrawalAmount := mload(add(_withdrawalData, add(4, 0x20)))\\n            }\\n\\n        }\\n\\n    }\\n\\n    function ecrecoverSigner_V1(\\n        bytes32 _hashTx,\\n        bytes memory _rsvTx,\\n        uint offset\\n    ) internal pure returns (address ecrecoverAddress) {\\n        bytes32 r;\\n        bytes32 s;\\n        bytes1 v;\\n\\n        assembly {\\n            r := mload(add(_rsvTx, add(offset, 0x20)))\\n            s := mload(add(_rsvTx, add(offset, 0x40)))\\n            v := mload(add(_rsvTx, add(offset, 0x60)))\\n        }\\n\\n        ecrecoverAddress = ecrecover(_hashTx, uint8(v), r, s);\\n    }\\n\\n    function getSignerFromSignedRawTxRLPItem_V1(\\n        RLPReader.RLPItem[] memory _signedTxRLPItem,\\n        uint8 _chainId\\n    ) internal pure returns (address ecrecoverAddress) {\\n        bytes memory _rawTx;\\n        bytes memory _rsvTx;\\n\\n        (_rawTx, _rsvTx) = explodeSignedRawTxRLPItem(\\n            _signedTxRLPItem,\\n            _chainId\\n        );\\n        return ecrecoverSigner_V1(keccak256(_rawTx), _rsvTx, 0);\\n    }\\n\\n    function explodeSignedRawTxRLPItem(\\n        RLPReader.RLPItem[] memory _signedTxRLPItem,\\n        uint8 _chainId\\n    ) internal pure returns (bytes memory _rawTx, bytes memory _rsvTx) {\\n        bytes[] memory _signedTxRLPItemRaw = new bytes[](9);\\n\\n        _signedTxRLPItemRaw[0] = RLPWriter.toRlp(_signedTxRLPItem[0].toBytes());\\n        _signedTxRLPItemRaw[1] = RLPWriter.toRlp(_signedTxRLPItem[1].toBytes());\\n        _signedTxRLPItemRaw[2] = RLPWriter.toRlp(_signedTxRLPItem[2].toBytes());\\n        _signedTxRLPItemRaw[3] = RLPWriter.toRlp(_signedTxRLPItem[3].toBytes());\\n        _signedTxRLPItemRaw[4] = RLPWriter.toRlp(_signedTxRLPItem[4].toBytes());\\n        _signedTxRLPItemRaw[5] = RLPWriter.toRlp(_signedTxRLPItem[5].toBytes());\\n\\n        _signedTxRLPItemRaw[6] = RLPWriter.toRlp(_chainId);\\n        _signedTxRLPItemRaw[7] = RLPWriter.toRlp(0);\\n        _signedTxRLPItemRaw[8] = RLPWriter.toRlp(0);\\n\\n        _rawTx = RLPWriter.toRlp(_signedTxRLPItemRaw);\\n\\n        uint8 i;\\n        _rsvTx = new bytes(65);\\n\\n        bytes32 tmp = bytes32(_signedTxRLPItem[7].toUint());\\n        for (i = 0; i \\u003c 32; i++) {\\n            _rsvTx[i] = tmp[i];\\n        }\\n\\n        tmp = bytes32(_signedTxRLPItem[8].toUint());\\n\\n        for (i = 0; i \\u003c 32; i++) {\\n            _rsvTx[i + 32] = tmp[i];\\n        }\\n\\n        _rsvTx[64] = bytes1(\\n            uint8(_signedTxRLPItem[6].toUint() - uint(_chainId * 2) - 8)\\n        );\\n\\n    }\\n\\n}\\n\"},\"AuctionityLibrary_V1.sol\":{\"content\":\"pragma solidity ^0.5.4;\\n\\nimport \\\"./AuctionityStorage0.sol\\\";\\n\\n/// @title Auction library for delegate for some delegated function\\ncontract AuctionityLibrary_V1 is AuctionityStorage0 {\\n    /// @notice get delegated addrss from a selector\\n    /// @param _selector byte4\\n    /// @return _contractDelegate address\\n    function getDelegate_V1(bytes4 _selector)\\n        public\\n        view\\n        returns (address _contractDelegate)\\n    {\\n        return delegates[_selector];\\n    }\\n\\n    /// @notice call delegated function\\n    /// @param _calldata bytes : data sended to delegated contract\\n    /// @param _contractFallback address: address of fallback if selector is not exist, address(0) if no fallback\\n    /// @return uint return pointer and uint return size of callData return\\n    function _callDelegated_V1(\\n        bytes memory _calldata,\\n        address _contractFallback\\n    ) internal returns (uint returnPtr, uint returnSize) {\\n        /// @dev get selector from _calldata\\n        bytes4 _selector;\\n        assembly {\\n            _selector := mload(add(_calldata, 0x20))\\n        }\\n\\n        /// @dev get address of delegated from selector\\n        address _contractDelegate = getDelegate_V1(_selector);\\n\\n        /// @dev if _contractDelegate not found set _contractFallback into _contractFallback\\n        if (_contractDelegate == address(0)) {\\n            _contractDelegate = _contractFallback;\\n        }\\n\\n        require(\\n            _contractDelegate != address(0),\\n            \\\"Auctionity function does not exist.\\\"\\n        );\\n\\n        /// @dev delegate call and return result, or the eventual revert\\n        assembly {\\n            let result := delegatecall(\\n                gas,\\n                _contractDelegate,\\n                add(_calldata, 0x20),\\n                mload(_calldata),\\n                0,\\n                0\\n            )\\n            returnSize := returndatasize\\n            returnPtr := mload(0x40)\\n            returndatacopy(returnPtr, 0, returnSize)\\n            if eq(result, 0) {\\n                revert(returnPtr, returnSize)\\n            }\\n        }\\n\\n        /// @dev return returndatacopy\\n        return (returnPtr, returnSize);\\n\\n    }\\n\\n    /// @notice delegate IsContractOwner_V1\\n    /// @return  _isContractOwner\\n    function delegatedSendIsContractOwner_V1()\\n        public\\n        returns (bool _isContractOwner)\\n    {\\n        uint returnPtr;\\n        uint returnSize;\\n\\n        (returnPtr, returnSize) = _callDelegated_V1(\\n            abi.encodeWithSelector(\\n                bytes4(keccak256(\\\"delegatedReceiveIsContractOwner_V1()\\\"))\\n            ),\\n            address(0)\\n        );\\n\\n        assembly {\\n            _isContractOwner := mload(returnPtr)\\n        }\\n\\n        return _isContractOwner;\\n    }\\n\\n    modifier delegatedSendIsOracle_V1() {\\n        require(\\n            msg.sender == delegatedSendGetOracle_V1(),\\n            \\\"Sender must be oracle\\\"\\n        );\\n        _;\\n    }\\n\\n    /// @notice delegate getOracle_V1\\n    /// @return address _oracle\\n    function delegatedSendGetOracle_V1() public returns (address _oracle) {\\n        uint returnPtr;\\n        uint returnSize;\\n\\n        (returnPtr, returnSize) = _callDelegated_V1(\\n            abi.encodeWithSelector(\\n                bytes4(keccak256(\\\"delegatedReceiveGetOracle_V1()\\\"))\\n            ),\\n            address(0)\\n        );\\n\\n        assembly {\\n            _oracle := mload(returnPtr)\\n        }\\n        return _oracle;\\n\\n    }\\n\\n    /// @notice delegate getPaused_V1\\n    /// @return bool _isPaused\\n    function delegatedSendGetPaused_V1() public returns (bool _isPaused) {\\n        uint returnPtr;\\n        uint returnSize;\\n\\n        (returnPtr, returnSize) = _callDelegated_V1(\\n            abi.encodeWithSelector(\\n                bytes4(keccak256(\\\"delegatedReceiveGetPaused_V1()\\\"))\\n            ),\\n            address(0)\\n        );\\n        assembly {\\n            _isPaused := mload(returnPtr)\\n        }\\n        return _isPaused;\\n\\n    }\\n\\n    /// @notice delegate lockDeposit_V1\\n    /// @param _tokenContractAddress address\\n    /// @param _tokenId uint256\\n    /// @param _amount uint256\\n    /// @param _auctionId uint256\\n    /// @param _refundUser address\\n    /// @return bool _isPaused\\n    function delegatedLockDeposit_V1(\\n        address _tokenContractAddress,\\n        uint256 _tokenId,\\n        uint256 _amount,\\n        uint256 _auctionId,\\n        address _refundUser\\n    ) public returns (bool _success) {\\n        uint returnPtr;\\n        uint returnSize;\\n\\n        (returnPtr, returnSize) = _callDelegated_V1(\\n            abi.encodeWithSelector(\\n                bytes4(\\n                    keccak256(\\n                        \\\"lockDeposit_V1(address,uint256,uint256,uint256,address)\\\"\\n                    )\\n                ),\\n                _tokenContractAddress,\\n                _tokenId,\\n                _amount,\\n                _auctionId,\\n                _refundUser\\n            ),\\n            address(0)\\n        );\\n\\n        assembly {\\n            _success := mload(returnPtr)\\n        }\\n        return _success;\\n\\n    }\\n\\n    /// @notice verify if _contractAddress is a contract\\n    /// @param _contractAddress address\\n    /// @return _isContract\\n    function isContract_V1(address _contractAddress)\\n        internal\\n        view\\n        returns (bool _isContract)\\n    {\\n        uint _size;\\n        assembly {\\n            _size := extcodesize(_contractAddress)\\n        }\\n        return _size \\u003e 0;\\n    }\\n\\n    /// @notice cast a bytesmemory into a uint256\\n    /// @param b bytes\\n    /// @return uint256\\n    function bytesToUint_V1(bytes memory b) internal pure returns (uint256) {\\n        uint256 _number;\\n        for (uint i = 0; i \\u003c b.length; i++) {\\n            _number = _number + uint8(b[i]) * (2 ** (8 * (b.length - (i + 1))));\\n        }\\n        return _number;\\n    }\\n}\\n\"},\"AuctionityOracable_V1.sol\":{\"content\":\"pragma solidity ^0.5.4;\\n\\nimport \\\"./AuctionityLibrary_V1.sol\\\";\\n\\n/// @title AuctionityOracable_V1\\ncontract AuctionityOracable_V1 is AuctionityLibrary_V1 {\\n    /// @notice event LogOracleTransfered_V1\\n    event LogOracleTransfered_V1(\\n        address indexed previousOracle,\\n        address indexed newOracle\\n    );\\n\\n    /// @notice delegate receive of getOracle\\n    /// @return  _oracle address\\n    function delegatedReceiveGetOracle_V1()\\n        public\\n        payable\\n        returns (address _oracle)\\n    {\\n        return getOracle_V1();\\n    }\\n\\n    /// @notice getter oracle address\\n    /// @return  _oracle address\\n    function getOracle_V1() public view returns (address _oracle) {\\n        return oracle;\\n    }\\n\\n    /// @notice verify if msg.sender is oracle\\n    /// @return _isOracle bool\\n    function isOracle_V1() public view returns (bool _isOracle) {\\n        return msg.sender == oracle;\\n    }\\n\\n    /**\\n     * @return true if `_oracle` is the oracle of the contract.\\n     */\\n\\n    /// @notice verify oracle address\\n    /// @param _oracle address : address to compare\\n    /// @return _isOracle bool\\n    function verifyOracle_V1(address _oracle)\\n        public\\n        view\\n        returns (bool _isOracle)\\n    {\\n        return _oracle == oracle;\\n    }\\n\\n    /// @notice Allows the current oracle or owner to set a new oracle.\\n    /// @param _newOracle The address to transfer oracleship to.\\n    function transferOracle_V1(address _newOracle) public {\\n        require(\\n            isOracle_V1() || delegatedSendIsContractOwner_V1(),\\n            \\\"Is not Oracle or Owner\\\"\\n        );\\n        _transferOracle_V1(_newOracle);\\n    }\\n\\n    /// @notice Transfers control of the contract to a newOracle.\\n    /// @param _newOracle The address to transfer oracleship to.\\n    function _transferOracle_V1(address _newOracle) internal {\\n        require(_newOracle != address(0), \\\"Oracle can\\u0027t be 0x0\\\");\\n        emit LogOracleTransfered_V1(oracle, _newOracle);\\n        oracle = _newOracle;\\n    }\\n}\\n\"},\"AuctionityPausable_V1.sol\":{\"content\":\"pragma solidity ^0.5.4;\\n\\nimport \\\"./AuctionityLibrary_V1.sol\\\";\\n\\n/// @title Pausable\\n/// @dev Base contract which allows children to implement an emergency stop mechanism.\\n\\ncontract AuctionityPausable_V1 is AuctionityLibrary_V1 {\\n    event LogPaused_V1(bool paused);\\n\\n    /// @notice constructor, default is false, no incidence if called by proxy\\n    constructor() public {\\n        paused = false;\\n    }\\n\\n    /// @notice delegate receive of get Paused\\n    /// @return _isPaused bool\\n    function delegatedReceiveGetPaused_V1()\\n        public\\n        payable\\n        returns (bool _isPaused)\\n    {\\n        return getPaused_V1();\\n    }\\n\\n    /// @notice verify if is paused\\n    /// @return _isPaused bool\\n    function getPaused_V1() public returns (bool _isPaused) {\\n        if (delegatedSendIsContractOwner_V1() == true) {\\n            return false;\\n        }\\n        return paused;\\n    }\\n\\n    /// @dev Modifier to make a function callable only when the contract is not paused.\\n    modifier whenNotPaused_V1() {\\n        require(!delegatedSendGetPaused_V1(), \\\"Contrat is paused\\\");\\n        _;\\n    }\\n\\n    /// @dev Modifier to make a function callable only when the contract is paused.\\n    modifier whenPaused_V1() {\\n        require(delegatedSendGetPaused_V1(), \\\"Contrat is not paused\\\");\\n        _;\\n    }\\n\\n    /// @notice called by the owner to pause, triggers stopped state\\n    /// @param _paused bool\\n    function setPaused_V1(bool _paused) public {\\n        require(delegatedSendIsContractOwner_V1(), \\\"Not Contract owner\\\");\\n        paused = _paused;\\n        emit LogPaused_V1(_paused);\\n    }\\n}\\n\"},\"AuctionityStorage0.sol\":{\"content\":\"pragma solidity ^0.5.4;\\n\\ncontract AuctionityStorage0 {\\n    // selector =\\u003e delegate contract\\n    mapping(bytes4 =\\u003e address) internal delegates;\\n\\n    // If selector not found, fallback contract address\\n    address public proxyFallbackContract;\\n\\n    address public contractOwner;\\n    address public oracle;\\n\\n    bool public paused;\\n\\n    uint8 public ethereumChainId;\\n    uint8 public auctionityChainId;\\n}\\n\"},\"AuctionityStorage1.sol\":{\"content\":\"pragma solidity ^0.5.4;\\n\\nimport \\\"./AuctionityStorage0.sol\\\";\\n\\ncontract AuctionityStorage1 is AuctionityStorage0 {\\n    // TokenContract =\\u003e TokenIds =\\u003e Users =\\u003e amount\\n    mapping(address =\\u003e mapping(uint256 =\\u003e mapping(address =\\u003e uint256))) tokens;\\n\\n    bytes32[] public withdrawalVoucherList; // List of withdrawal voucher\\n    mapping(bytes32 =\\u003e bool) public withdrawalVoucherSubmitted; // is withdrawal voucher is already submitted\\n\\n    bytes32[] public auctionEndVoucherList; // List of auction end voucher\\n    mapping(bytes32 =\\u003e bool) public auctionEndVoucherSubmitted; // is auction end voucher is already submitted\\n\\n}\\n\"},\"RLPReader.sol\":{\"content\":\"/*\\n* @author Hamdi Allam hamdi.allam97@gmail.com\\n* Please reach our for any questions/concerns\\n*/\\npragma solidity ^0.5.4;\\n\\nlibrary RLPReader {\\n    uint8 constant STRING_SHORT_START = 0x80;\\n    uint8 constant STRING_LONG_START = 0xb8;\\n    uint8 constant LIST_SHORT_START = 0xc0;\\n    uint8 constant LIST_LONG_START = 0xf8;\\n\\n    uint8 constant WORD_SIZE = 32;\\n\\n    struct RLPItem {\\n        uint len;\\n        uint memPtr;\\n    }\\n\\n    /*\\n    * @param item RLP encoded bytes\\n    */\\n    function toRlpItem(bytes memory item)\\n        internal\\n        pure\\n        returns (RLPItem memory)\\n    {\\n        if (item.length == 0) return RLPItem(0, 0);\\n\\n        uint memPtr;\\n        assembly {\\n            memPtr := add(item, 0x20)\\n        }\\n\\n        return RLPItem(item.length, memPtr);\\n    }\\n\\n    /*\\n    * @param item RLP encoded list in bytes\\n    */\\n    function toList(RLPItem memory item)\\n        internal\\n        pure\\n        returns (RLPItem[] memory result)\\n    {\\n        require(isList(item));\\n\\n        uint items = numItems(item);\\n        result = new RLPItem[](items);\\n\\n        uint memPtr = item.memPtr + _payloadOffset(item.memPtr);\\n        uint dataLen;\\n        for (uint i = 0; i \\u003c items; i++) {\\n            dataLen = _itemLength(memPtr);\\n            result[i] = RLPItem(dataLen, memPtr);\\n            memPtr = memPtr + dataLen;\\n        }\\n    }\\n\\n    /*\\n    * Helpers\\n    */\\n\\n    // @return indicator whether encoded payload is a list. negate this function call for isData.\\n    function isList(RLPItem memory item) internal pure returns (bool) {\\n        uint8 byte0;\\n        uint memPtr = item.memPtr;\\n        assembly {\\n            byte0 := byte(0, mload(memPtr))\\n        }\\n\\n        if (byte0 \\u003c LIST_SHORT_START) return false;\\n        return true;\\n    }\\n\\n    // @return number of payload items inside an encoded list.\\n    function numItems(RLPItem memory item) internal pure returns (uint) {\\n        uint count = 0;\\n        uint currPtr = item.memPtr + _payloadOffset(item.memPtr);\\n        uint endPtr = item.memPtr + item.len;\\n        while (currPtr \\u003c endPtr) {\\n            currPtr = currPtr + _itemLength(currPtr); // skip over an item\\n            count++;\\n        }\\n\\n        return count;\\n    }\\n\\n    // @return entire rlp item byte length\\n    function _itemLength(uint memPtr) internal pure returns (uint len) {\\n        uint byte0;\\n        assembly {\\n            byte0 := byte(0, mload(memPtr))\\n        }\\n\\n        if (byte0 \\u003c STRING_SHORT_START) return 1;\\n        else if (byte0 \\u003c STRING_LONG_START) return byte0 - STRING_SHORT_START + 1;\\n        else if (byte0 \\u003c LIST_SHORT_START) {\\n            assembly {\\n                let byteLen := sub(byte0, 0xb7) // # of bytes the actual length is\\n                memPtr := add(memPtr, 1) // skip over the first byte\\n\\n                /* 32 byte word size */\\n                let dataLen := div(mload(memPtr), exp(256, sub(32, byteLen))) // right shifting to get the len\\n                len := add(dataLen, add(byteLen, 1))\\n            }\\n        } else if (byte0 \\u003c LIST_LONG_START) {\\n            return byte0 - LIST_SHORT_START + 1;\\n        } else {\\n            assembly {\\n                let byteLen := sub(byte0, 0xf7)\\n                memPtr := add(memPtr, 1)\\n\\n                let dataLen := div(mload(memPtr), exp(256, sub(32, byteLen))) // right shifting to the correct length\\n                len := add(dataLen, add(byteLen, 1))\\n            }\\n        }\\n    }\\n\\n    // @return number of bytes until the data\\n    function _payloadOffset(uint memPtr) internal pure returns (uint) {\\n        uint byte0;\\n        assembly {\\n            byte0 := byte(0, mload(memPtr))\\n        }\\n\\n        if (byte0 \\u003c STRING_SHORT_START) return 0;\\n        else if (byte0 \\u003c STRING_LONG_START || (byte0 \\u003e= LIST_SHORT_START \\u0026\\u0026 byte0 \\u003c LIST_LONG_START)) return 1;\\n        else if (byte0 \\u003c LIST_SHORT_START) // being explicit\\n        return byte0 - (STRING_LONG_START - 1) + 1;\\n        else return byte0 - (LIST_LONG_START - 1) + 1;\\n    }\\n\\n    /** RLPItem conversions into data types **/\\n\\n    function toBoolean(RLPItem memory item) internal pure returns (bool) {\\n        require(\\n            item.len == 1,\\n            \\\"Invalid RLPItem. Booleans are encoded in 1 byte\\\"\\n        );\\n        uint result;\\n        uint memPtr = item.memPtr;\\n        assembly {\\n            result := byte(0, mload(memPtr))\\n        }\\n\\n        return result == 0 ? false : true;\\n    }\\n\\n    function toAddress(RLPItem memory item) internal pure returns (address) {\\n        // 1 byte for the length prefix according to RLP spec\\n        require(\\n            item.len == 21,\\n            \\\"Invalid RLPItem. Addresses are encoded in 20 bytes\\\"\\n        );\\n\\n        uint memPtr = item.memPtr + 1; // skip the length prefix\\n        uint addr;\\n        assembly {\\n            addr := div(mload(memPtr), exp(256, 12)) // right shift 12 bytes. we want the most significant 20 bytes\\n        }\\n\\n        return address(addr);\\n    }\\n\\n    function toUint(RLPItem memory item) internal pure returns (uint) {\\n        uint offset = _payloadOffset(item.memPtr);\\n        uint len = item.len - offset;\\n        uint memPtr = item.memPtr + offset;\\n\\n        uint result;\\n        assembly {\\n            result := div(mload(memPtr), exp(256, sub(32, len))) // shift to the correct location\\n        }\\n\\n        return result;\\n    }\\n\\n    function toBytes(RLPItem memory item) internal pure returns (bytes memory) {\\n        uint offset = _payloadOffset(item.memPtr);\\n        uint len = item.len - offset; // data length\\n        bytes memory result = new bytes(len);\\n\\n        uint destPtr;\\n        assembly {\\n            destPtr := add(0x20, result)\\n        }\\n\\n        copy(item.memPtr + offset, destPtr, len);\\n        return result;\\n    }\\n\\n    /*\\n    * @param src Pointer to source\\n    * @param dest Pointer to destination\\n    * @param len Amount of memory to copy from the source\\n    */\\n    function copy(uint src, uint dest, uint len) internal pure {\\n        // copy as many word sizes as possible\\n        for (; len \\u003e= WORD_SIZE; len -= WORD_SIZE) {\\n            assembly {\\n                mstore(dest, mload(src))\\n            }\\n\\n            src += WORD_SIZE;\\n            dest += WORD_SIZE;\\n        }\\n\\n        // left over bytes\\n        uint mask = 256 ** (WORD_SIZE - len) - 1;\\n        assembly {\\n            let srcpart := and(mload(src), not(mask)) // zero out src\\n            let destpart := and(mload(dest), mask) // retrieve the bytes\\n            mstore(dest, or(destpart, srcpart))\\n        }\\n    }\\n}\\n\"},\"RLPWriter.sol\":{\"content\":\"pragma solidity ^0.5.4;\\n\\nlibrary RLPWriter {\\n    function toRlp(bytes memory _value)\\n        internal\\n        pure\\n        returns (bytes memory _bytes)\\n    {\\n        uint _valuePtr;\\n        uint _rplPtr;\\n        uint _valueLength = _value.length;\\n\\n        assembly {\\n            _valuePtr := add(_value, 0x20)\\n            _bytes := mload(0x40) // Free memory ptr\\n            _rplPtr := add(_bytes, 0x20) // RLP first byte ptr\\n        }\\n\\n        // [0x00, 0x7f]\\n        if (_valueLength == 1 \\u0026\\u0026 _value[0] \\u003c= 0x7f) {\\n            assembly {\\n                mstore(_bytes, 1) // Bytes size is 1\\n                mstore(_rplPtr, mload(_valuePtr)) // Set value as-is\\n                mstore(0x40, add(_rplPtr, 1)) // Update free ptr\\n            }\\n            return _bytes;\\n        }\\n\\n        // [0x80, 0xb7]\\n        if (_valueLength \\u003c= 55) {\\n            assembly {\\n                mstore(_bytes, add(1, _valueLength)) // Bytes size\\n                mstore8(_rplPtr, add(0x80, _valueLength)) // RLP small string size\\n                mstore(0x40, add(add(_rplPtr, 1), _valueLength)) // Update free ptr\\n            }\\n\\n            copy(_valuePtr, _rplPtr + 1, _valueLength);\\n            return _bytes;\\n        }\\n\\n        // [0xb8, 0xbf]\\n        uint _lengthSize = uintMinimalSize(_valueLength);\\n\\n        assembly {\\n            mstore(_bytes, add(add(1, _lengthSize), _valueLength)) // Bytes size\\n            mstore8(_rplPtr, add(0xb7, _lengthSize)) // RLP long string \\\"size size\\\"\\n            mstore(\\n                add(_rplPtr, 1),\\n                mul(_valueLength, exp(256, sub(32, _lengthSize)))\\n            ) // Bitshift to store the length only _lengthSize bytes\\n            mstore(0x40, add(add(add(_rplPtr, 1), _lengthSize), _valueLength)) // Update free ptr\\n        }\\n\\n        copy(_valuePtr, _rplPtr + 1 + _lengthSize, _valueLength);\\n        return _bytes;\\n    }\\n\\n    function toRlp(uint _value) internal pure returns (bytes memory _bytes) {\\n        uint _size = uintMinimalSize(_value);\\n\\n        bytes memory _valueBytes = new bytes(_size);\\n\\n        assembly {\\n            mstore(\\n                add(_valueBytes, 0x20),\\n                mul(_value, exp(256, sub(32, _size)))\\n            )\\n        }\\n\\n        return toRlp(_valueBytes);\\n    }\\n\\n    function toRlp(bytes[] memory _values)\\n        internal\\n        pure\\n        returns (bytes memory _bytes)\\n    {\\n        uint _ptr;\\n        uint _size;\\n        uint i;\\n\\n        // compute data size\\n        for (; i \\u003c _values.length; ++i) _size += _values[i].length;\\n\\n        // create rlp header\\n        assembly {\\n            _bytes := mload(0x40)\\n            _ptr := add(_bytes, 0x20)\\n        }\\n\\n        if (_size \\u003c= 55) {\\n            assembly {\\n                mstore8(_ptr, add(0xc0, _size))\\n                _ptr := add(_ptr, 1)\\n            }\\n        } else {\\n            uint _size2 = uintMinimalSize(_size);\\n\\n            assembly {\\n                mstore8(_ptr, add(0xf7, _size2))\\n                _ptr := add(_ptr, 1)\\n                mstore(_ptr, mul(_size, exp(256, sub(32, _size2))))\\n                _ptr := add(_ptr, _size2)\\n            }\\n        }\\n\\n        // copy data\\n        for (i = 0; i \\u003c _values.length; ++i) {\\n            bytes memory _val = _values[i];\\n            uint _valPtr;\\n\\n            assembly {\\n                _valPtr := add(_val, 0x20)\\n            }\\n\\n            copy(_valPtr, _ptr, _val.length);\\n\\n            _ptr += _val.length;\\n        }\\n\\n        assembly {\\n            mstore(0x40, _ptr)\\n            mstore(_bytes, sub(sub(_ptr, _bytes), 0x20))\\n        }\\n    }\\n\\n    function uintMinimalSize(uint _value) internal pure returns (uint _size) {\\n        for (; _value != 0; _size++) _value /= 256;\\n    }\\n\\n    /*\\n    * @param src Pointer to source\\n    * @param dest Pointer to destination\\n    * @param len Amount of memory to copy from the source\\n    */\\n    function copy(uint src, uint dest, uint len) internal pure {\\n        // copy as many word sizes as possible\\n        for (; len \\u003e= 32; len -= 32) {\\n            assembly {\\n                mstore(dest, mload(src))\\n            }\\n\\n            src += 32;\\n            dest += 32;\\n        }\\n\\n        // left over bytes\\n        uint mask = 256 ** (32 - len) - 1;\\n        assembly {\\n            let srcpart := and(mload(src), not(mask)) // zero out src\\n            let destpart := and(mload(dest), mask) // retrieve the bytes\\n            mstore(dest, or(destpart, srcpart))\\n        }\\n    }\\n}\\n\"},\"SafeMath.sol\":{\"content\":\"pragma solidity ^0.5.4;\\n\\n/**\\n * @title SafeMath\\n * @dev Math operations with safety checks that throw on error\\n */\\n\\nlibrary SafeMath {\\n    /**\\n  * @dev Multiplies two numbers, throws on overflow.\\n  */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\\n        // Gas optimization: this is cheaper than asserting \\u0027a\\u0027 not being zero, but the\\n        // benefit is lost if \\u0027b\\u0027 is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        c = a * b;\\n        assert(c / a == b);\\n        return c;\\n    }\\n\\n    /**\\n  * @dev Integer division of two numbers, truncating the quotient.\\n  */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // assert(b \\u003e 0); // Solidity automatically throws when dividing by 0\\n        // uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn\\u0027t hold\\n        return a / b;\\n    }\\n\\n    /**\\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\\n  */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        assert(b \\u003c= a);\\n        return a - b;\\n    }\\n\\n    /**\\n  * @dev Adds two numbers, throws on overflow.\\n  */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\\n        c = a + b;\\n        assert(c \\u003e= a);\\n        return c;\\n    }\\n}\\n\"}}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"ethereumChainId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"auctionEndVoucherSubmitted\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getDepotEth\",\"outputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getBalanceEth_V1\",\"outputs\":[{\"name\":\"_balanceOf\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_auctionityChainId\",\"type\":\"uint8\"}],\"name\":\"setAuctionityChainId_V1\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_ethereumChainId\",\"type\":\"uint8\"}],\"name\":\"setEthereumChainId_V1\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"depositEth\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"delegatedSendGetOracle_V1\",\"outputs\":[{\"name\":\"_oracle\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenContractAddress\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_auctionId\",\"type\":\"uint256\"},{\"name\":\"_refundUser\",\"type\":\"address\"}],\"name\":\"delegatedLockDeposit_V1\",\"outputs\":[{\"name\":\"_success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_auctionEndVoucherData\",\"type\":\"bytes\"},{\"name\":\"_signedRawTxCreateAuction\",\"type\":\"bytes\"},{\"name\":\"_signedRawTxBidding\",\"type\":\"bytes\"},{\"name\":\"_send\",\"type\":\"bytes\"}],\"name\":\"auctionEndVoucher_V1\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_withdrawalVoucherData\",\"type\":\"bytes\"},{\"name\":\"_signedRawTxWithdrawal\",\"type\":\"bytes\"}],\"name\":\"withdrawalVoucher_V1\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"auctionEndVoucherList\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"oracle\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"withdrawalVoucherSubmitted\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"receiveDepotEth_V1\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"auctionityChainId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"withdrawalVoucherList\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"proxyFallbackContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"contractOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getEthereumChainId_V1\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_selector\",\"type\":\"bytes4\"}],\"name\":\"getDelegate_V1\",\"outputs\":[{\"name\":\"_contractDelegate\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAuctionityChainId_V1\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"delegatedSendGetPaused_V1\",\"outputs\":[{\"name\":\"_isPaused\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"delegatedSendIsContractOwner_V1\",\"outputs\":[{\"name\":\"_isContractOwner\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"auction\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"LogSentEthToWinner\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"user\",\"type\":\"address[]\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256[]\"}],\"name\":\"LogSentRewardsDepotEth\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"LogDeposed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"withdrawalVoucherHash\",\"type\":\"bytes32\"}],\"name\":\"LogWithdrawalVoucherSubmitted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"tokenHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"tokenContractAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"seller\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"winner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"auctionEndVoucherHash\",\"type\":\"bytes32\"}],\"name\":\"LogAuctionEndVoucherSubmitted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"withdrawalVoucherHash\",\"type\":\"bytes32\"}],\"name\":\"LogWithdrawalVoucherSubmitted_V1\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokenContractAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"totalAmount\",\"type\":\"uint256\"}],\"name\":\"LogAddDepot_V1\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"tokenHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"tokenContractAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"seller\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"winner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"auctionEndVoucher_V1Hash\",\"type\":\"bytes32\"}],\"name\":\"LogAuctionEndVoucherSubmitted_V1\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"auction\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"LogSentEthToSeller_V1\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"user\",\"type\":\"address[]\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256[]\"}],\"name\":\"LogSentRewardsDepotEth_V1\",\"type\":\"event\"}]","ContractName":"AuctionityDeposit_V1","CompilerVersion":"v0.5.4+commit.9549d8ff","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://8d11637948e5fdf025a445155e8876f1423f50afd4bbea73c6c17d3fa64cdedb"}]}