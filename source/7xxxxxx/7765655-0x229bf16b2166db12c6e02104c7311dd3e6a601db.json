{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.25;\r\n\r\n/**\r\n * \r\n * World War Goo - Competitive Idle Game\r\n * \r\n * https://ethergoo.io\r\n * \r\n */\r\n\r\ninterface ERC721 {\r\n    function totalSupply() external view returns (uint256 tokens);\r\n    function balanceOf(address owner) external view returns (uint256 balance);\r\n    function ownerOf(uint256 tokenId) external view returns (address owner);\r\n    function exists(uint256 tokenId) external view returns (bool tokenExists);\r\n    function approve(address to, uint256 tokenId) external;\r\n    function getApproved(uint256 tokenId) external view returns (address approvee);\r\n\r\n    function transferFrom(address from, address to, uint256 tokenId) external;\r\n    function tokensOf(address owner) external view returns (uint256[] tokens);\r\n    //function tokenByIndex(uint256 index) external view returns (uint256 token);\r\n\r\n    // Events\r\n    event Transfer(address from, address to, uint256 tokenId);\r\n    event Approval(address owner, address approved, uint256 tokenId);\r\n}\r\n\r\ninterface ERC20 {\r\n    function totalSupply() external constant returns (uint);\r\n    function balanceOf(address tokenOwner) external constant returns (uint balance);\r\n    function allowance(address tokenOwner, address spender) external constant returns (uint remaining);\r\n    function transfer(address to, uint tokens) external returns (bool success);\r\n    function approve(address spender, uint tokens) external returns (bool success);\r\n    function approveAndCall(address spender, uint tokens, bytes data) external returns (bool success);\r\n    function transferFrom(address from, address to, uint tokens) external returns (bool success);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint tokens);\r\n    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\r\n}\r\n\r\ninterface ERC721TokenReceiver {\r\n    function onERC721Received(address operator, address from, uint256 tokenId, bytes data) external returns(bytes4);\r\n}\r\n\r\ninterface ApproveAndCallFallBack {\r\n    function receiveApproval(address from, uint256 tokens, address token, bytes data) external;\r\n}\r\n\r\ncontract Bankroll {\r\n     function depositEth(uint256 gooAllocation, uint256 tokenAllocation) payable external;\r\n}\r\n\r\ncontract Inventory {\r\n    mapping(uint256 => uint256) public tokenItems; // tokenId -> itemId\r\n}\r\n\r\ncontract Marketplace is ERC721TokenReceiver, ApproveAndCallFallBack {\r\n    \r\n    mapping(address => bool) whitelistedMaterials; // ERC20 addresses allowed to list\r\n    mapping(address => bool) whitelistedItems; // ERC721 addresses allowed to list\r\n    mapping(address => uint256) listingFees; // Just incase want different fee per type\r\n    Bankroll constant bankroll = Bankroll(0x66a9f1e53173de33bec727ef76afa84956ae1b25);\r\n \r\n    uint256 private constant removalDuration = 14 days; // Listings can be pruned from market after 14 days\r\n    \r\n    bool public paused = false;\r\n    address owner;\r\n\r\n    mapping(uint256 => Listing) public listings;\r\n    uint256[] public listingsIds;\r\n    \r\n    uint256 listingId = 1; // Start at one\r\n    \r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    struct Listing {\r\n        address tokenAddress; // Listing type (either item, premium unit, materials)\r\n        address player;\r\n        \r\n        uint128 listingPointer; // Index in the market's listings\r\n        uint128 tokenId; // Or amount listed (if it's erc20)\r\n        uint128 listTime;\r\n        uint128 price;\r\n    }\r\n    \r\n    function getMarketSize() external constant returns(uint) {\r\n        return listingsIds.length;\r\n    }\r\n    \r\n    function onERC721Received(address operator, address from, uint256 tokenId, bytes data) external returns(bytes4) {\r\n        require(whitelistedItems[msg.sender]); // Can only list items + premium units\r\n        require(canListItems(from)); // Token owner cannot be a contract (to prevent reverting payments)\r\n        require(!paused);\r\n        \r\n        uint256 price = extractUInt256(data);\r\n        require(price > 99 szabo && price <= 100 ether);\r\n        \r\n        listings[listingId] = Listing(msg.sender, from, uint128(listingsIds.push(listingId) - 1), uint128(tokenId), uint128(now), uint128(price));\r\n        listingId++;\r\n        \r\n        return bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"));\r\n    }\r\n    \r\n    function receiveApproval(address from, uint256 amount, address token, bytes data) external {\r\n        require(whitelistedMaterials[msg.sender]);\r\n        require(canListItems(from)); // Token owner cannot be a contract (to prevent reverting payments)\r\n        require(amount > 0);\r\n        require(!paused);\r\n        \r\n        uint256 price = extractUInt256(data);\r\n        require(price > 9 szabo && price <= 100 ether);\r\n        \r\n        listings[listingId] = Listing(msg.sender, from, uint128(listingsIds.push(listingId) - 1), uint128(amount), uint128(now), uint128(price));\r\n        listingId++;\r\n        \r\n        ERC20(token).transferFrom(from, this, amount);\r\n    }\r\n    \r\n    function purchaseListing(uint256 auctionId) payable external {\r\n        Listing memory listing = listings[auctionId];\r\n        require(listing.tokenId > 0);\r\n        require(listing.player != msg.sender);\r\n        require(!paused);\r\n        \r\n        uint128 price = listing.price;\r\n        require(msg.value >= price);\r\n        \r\n        if (whitelistedMaterials[listing.tokenAddress]) {\r\n            uint128 matsBought = uint128(msg.value) / price;\r\n            if (matsBought >= listing.tokenId) {\r\n                matsBought = listing.tokenId; // Max mats for sale\r\n                removeListingInternal(auctionId); // Listing sold out so remove\r\n            } else {\r\n                listings[auctionId].tokenId = listings[auctionId].tokenId - matsBought;\r\n            }\r\n            price *= matsBought;\r\n            ERC20(listing.tokenAddress).transfer(msg.sender, matsBought);\r\n        } else if (whitelistedItems[listing.tokenAddress]) {\r\n            removeListingInternal(auctionId);\r\n            ERC721(listing.tokenAddress).transferFrom(this, msg.sender, listing.tokenId);\r\n        }\r\n        \r\n        uint256 saleFee = (price * listingFees[listing.tokenAddress]) / 100;\r\n        listing.player.transfer(price - saleFee); // Pay seller\r\n        bankroll.depositEth.value(saleFee)(50, 50);\r\n        \r\n        uint256 bidExcess = msg.value - price;\r\n        if (bidExcess > 0) {\r\n            msg.sender.transfer(bidExcess);\r\n        }\r\n    }\r\n    \r\n    function removeListing(uint256 auctionId) external {\r\n        Listing memory listing = listings[auctionId];\r\n        require(listing.tokenId > 0);\r\n        require(listing.player == msg.sender || (now - listing.listTime) > removalDuration);\r\n        \r\n        // Transfer back\r\n        if (whitelistedMaterials[listing.tokenAddress]) {\r\n            ERC20(listing.tokenAddress).transfer(listing.player, listing.tokenId);\r\n        } else if (whitelistedItems[listing.tokenAddress]) {\r\n            ERC721(listing.tokenAddress).transferFrom(this, listing.player, listing.tokenId);\r\n        }\r\n        \r\n        removeListingInternal(auctionId);\r\n    }\r\n    \r\n    function removeListingInternal(uint256 auctionId) internal {\r\n        if (listingsIds.length > 1) {\r\n            uint128 rowToDelete = listings[auctionId].listingPointer;\r\n            uint256 keyToMove = listingsIds[listingsIds.length - 1];\r\n            \r\n            listingsIds[rowToDelete] = keyToMove;\r\n            listings[keyToMove].listingPointer = rowToDelete;\r\n        }\r\n        \r\n        listingsIds.length--;\r\n        delete listings[auctionId];\r\n    }\r\n    \r\n    \r\n    function getListings(uint256 startIndex, uint256 endIndex) external constant returns (uint256[], address[], uint256[], uint256[], uint256[], address[]) {\r\n        uint256 numListings = (endIndex - startIndex) + 1;\r\n        if (startIndex == 0 && endIndex == 0) {\r\n            numListings = listingsIds.length;\r\n        }\r\n        uint256[] memory itemIds = new uint256[](numListings);\r\n        address[] memory listingOwners = new address[](numListings);\r\n        uint256[] memory listTimes = new uint256[](numListings);\r\n        uint256[] memory prices = new uint256[](numListings);\r\n        address[] memory listingType = new address[](numListings);\r\n        \r\n        for (uint256 i = startIndex; i < numListings; i++) {\r\n            Listing memory listing = listings[listingsIds[i]];\r\n            listingOwners[i] = listing.player;\r\n            \r\n            if (whitelistedItems[listing.tokenAddress]) {\r\n                itemIds[i] = Inventory(listing.tokenAddress).tokenItems(listing.tokenId); // tokenId -> itemId\r\n            } else {\r\n                itemIds[i] = listing.tokenId; // Amount of tokens listed\r\n            }\r\n            \r\n            listTimes[i] = listing.listTime;\r\n            prices[i] = listing.price;\r\n            listingType[i] = listing.tokenAddress;\r\n        }\r\n        return (listingsIds, listingOwners, itemIds, listTimes, prices, listingType);\r\n    }\r\n    \r\n    function getListingAtPosition(uint256 i) external constant returns (address, uint256, uint256, uint256) {\r\n        Listing memory listing = listings[listingsIds[i]];\r\n        return (listing.player, listing.tokenId, listing.listTime, listing.price);\r\n    }\r\n    \r\n    function getListing(uint64 tokenId) external constant returns (address, uint256, uint256, uint256) {\r\n        Listing memory listing = listings[tokenId];\r\n        return (listing.player, listing.tokenId, listing.listTime, listing.price);\r\n    }\r\n    \r\n    // Contracts can't list items (avoids unbuyable listings)\r\n    function canListItems(address seller) internal constant returns (bool) {\r\n        uint size;\r\n        assembly { size := extcodesize(seller) }\r\n        return size == 0 && tx.origin == seller;\r\n    }\r\n    \r\n    function extractUInt256(bytes bs) internal pure returns (uint256 payload) {\r\n        uint256 payloadSize;\r\n        assembly {\r\n            payloadSize := mload(bs)\r\n            payload := mload(add(bs, 0x20))\r\n        }\r\n        payload = payload >> 8*(32 - payloadSize);\r\n        \r\n    }\r\n\r\n    function setPaused(bool shouldPause) external {\r\n        require(msg.sender == owner);\r\n        paused = shouldPause;\r\n    }\r\n    \r\n    function updateERC20Settings(address token, bool allowed, uint256 newFee) external {\r\n        require(msg.sender == owner);\r\n        require(newFee <= 10); // Let's not get crazy\r\n        whitelistedMaterials[token] = allowed;\r\n        listingFees[token] = newFee;\r\n    }\r\n    \r\n    function updateERC721Settings(address token, bool allowed, uint256 newFee) external {\r\n        require(msg.sender == owner);\r\n        require(newFee <= 10); // Let's not get crazy\r\n        whitelistedItems[token] = allowed;\r\n        listingFees[token] = newFee;\r\n    }\r\n\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"operator\",\"type\":\"address\"},{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"tokenId\",\"type\":\"uint256\"},{\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"onERC721Received\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes4\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"auctionId\",\"type\":\"uint256\"}],\"name\":\"purchaseListing\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"shouldPause\",\"type\":\"bool\"}],\"name\":\"setPaused\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"i\",\"type\":\"uint256\"}],\"name\":\"getListingAtPosition\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"allowed\",\"type\":\"bool\"},{\"name\":\"newFee\",\"type\":\"uint256\"}],\"name\":\"updateERC20Settings\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"listingsIds\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"auctionId\",\"type\":\"uint256\"}],\"name\":\"removeListing\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"receiveApproval\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"startIndex\",\"type\":\"uint256\"},{\"name\":\"endIndex\",\"type\":\"uint256\"}],\"name\":\"getListings\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"},{\"name\":\"\",\"type\":\"address[]\"},{\"name\":\"\",\"type\":\"uint256[]\"},{\"name\":\"\",\"type\":\"uint256[]\"},{\"name\":\"\",\"type\":\"uint256[]\"},{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"listings\",\"outputs\":[{\"name\":\"tokenAddress\",\"type\":\"address\"},{\"name\":\"player\",\"type\":\"address\"},{\"name\":\"listingPointer\",\"type\":\"uint128\"},{\"name\":\"tokenId\",\"type\":\"uint128\"},{\"name\":\"listTime\",\"type\":\"uint128\"},{\"name\":\"price\",\"type\":\"uint128\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"allowed\",\"type\":\"bool\"},{\"name\":\"newFee\",\"type\":\"uint256\"}],\"name\":\"updateERC721Settings\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenId\",\"type\":\"uint64\"}],\"name\":\"getListing\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getMarketSize\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"}]","ContractName":"Marketplace","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://0f702f201c76c5298fc3e0c73e10fc377cb51cdaac990501eea7731579e0fba6"}]}