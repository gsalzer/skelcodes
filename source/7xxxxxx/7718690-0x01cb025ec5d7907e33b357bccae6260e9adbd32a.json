{"status":"1","message":"OK","result":[{"SourceCode":"{\"AddressUtils.sol\":{\"content\":\"pragma solidity ^0.4.18;\\n\\n\\n/**\\n * Utility library of inline functions on addresses\\n */\\nlibrary AddressUtils {\\n\\n  /**\\n   * Returns whether the target address is a contract\\n   * @dev This function will return false if invoked during the constructor of a contract,\\n   *  as the code is not actually created until after the constructor finishes.\\n   * @param addr address to check\\n   * @return whether the target address is a contract\\n   */\\n  function isContract(address addr) internal view returns (bool) {\\n    uint256 size;\\n    // XXX Currently there is no better way to check if there is a contract in an address\\n    // than to check the size of the code at that address.\\n    // See https://ethereum.stackexchange.com/a/14016/36603\\n    // for more details about how this works.\\n    // TODO Check this again before the Serenity release, because all addresses will be\\n    // contracts then.\\n    assembly { size := extcodesize(addr) }  // solium-disable-line security/no-inline-assembly\\n    return size \\u003e 0;\\n  }\\n\\n}\\n\"},\"Controlled.sol\":{\"content\":\"pragma solidity ^0.4.18;\\n\\ncontract Controlled {\\n\\n  event ControllerChangedEvent(address newController);\\n\\n  /// @notice The address of the controller is the only address that can call\\n  ///  a function with this modifier\\n  modifier onlyController { require(msg.sender == controller); _; }\\n\\n  address public controller;\\n\\n  function Controlled() public { controller = msg.sender;}\\n\\n  /// @notice Changes the controller of the contract\\n  /// @param _newController The new controller of the contract\\n  function changeController(address _newController) public onlyController {\\n    controller = _newController;\\n    emit ControllerChangedEvent(_newController);\\n  }\\n}\\n\"},\"DelegateProxy.sol\":{\"content\":\"pragma solidity ^0.4.18;\\n\\ncontract DelegateProxy {\\n  /**\\n  * @dev Performs a delegatecall and returns whatever the delegatecall returned (entire context execution will return!)\\n  * @param _dst Destination address to perform the delegatecall\\n  * @param _calldata Calldata for the delegatecall\\n  */\\n  function delegatedFwd(address _dst, bytes _calldata) internal {\\n    require(isContract(_dst));\\n    assembly {\\n      let result := delegatecall(sub(gas, 10000), _dst, add(_calldata, 0x20), mload(_calldata), 0, 0)\\n      let size := returndatasize\\n\\n      let ptr := mload(0x40)\\n      returndatacopy(ptr, 0, size)\\n\\n    // revert instead of invalid() bc if the underlying call failed with invalid() it already wasted gas.\\n    // if the call returned error data, forward it\\n      switch result case 0 {revert(ptr, size)}\\n      default {return (ptr, size)}\\n    }\\n  }\\n\\n  function isContract(address _target) internal view returns (bool) {\\n    uint256 size;\\n    assembly {size := extcodesize(_target)}\\n    return size \\u003e 0;\\n  }\\n}\"},\"DistrictConfig.sol\":{\"content\":\"pragma solidity ^0.4.24;\\n\\nimport \\\"./DSAuth.sol\\\";\\n\\ncontract DistrictConfig is DSAuth {\\n  address public depositCollector;\\n  address public memeAuctionCutCollector;\\n  uint public memeAuctionCut; // Values 0-10,000 map to 0%-100%\\n\\n  function DistrictConfig(address _depositCollector, address _memeAuctionCutCollector, uint _memeAuctionCut) {\\n    require(_depositCollector != 0x0, \\\"District Config deposit collector isn\\u0027t 0x0\\\");\\n    require(_memeAuctionCutCollector != 0x0, \\\"District Config meme auction cut collector isn\\u0027t 0x0\\\");\\n    require(_memeAuctionCut \\u003c 10000, \\\"District Config meme auction cut should be \\u003c 1000\\\");\\n    depositCollector = _depositCollector;\\n    memeAuctionCutCollector = _memeAuctionCutCollector;\\n    memeAuctionCut = _memeAuctionCut;\\n  }\\n\\n  function setDepositCollector(address _depositCollector) public auth {\\n    require(_depositCollector != 0x0, \\\"District Config deposit collector isn\\u0027t 0x0\\\");\\n    depositCollector = _depositCollector;\\n  }\\n\\n  function setMemeAuctionCutCollector(address _memeAuctionCutCollector) public auth {\\n    require(_memeAuctionCutCollector != 0x0, \\\"District Config meme auction cut collector isn\\u0027t 0x0\\\");\\n    memeAuctionCutCollector = _memeAuctionCutCollector;\\n  }\\n\\n  function setCollectors(address _collector) public auth {\\n    setDepositCollector(_collector);\\n    setMemeAuctionCutCollector(_collector);\\n  }\\n\\n  function setMemeAuctionCut(uint _memeAuctionCut) public auth {\\n    require(_memeAuctionCut \\u003c 10000, \\\"District Config meme auction cut should be \\u003c 1000\\\");\\n    memeAuctionCut = _memeAuctionCut;\\n  }\\n}\\n\"},\"DSAuth.sol\":{\"content\":\"// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see \\u003chttp://www.gnu.org/licenses/\\u003e.\\n\\npragma solidity ^0.4.13;\\n\\ncontract DSAuthority {\\n  function canCall(\\n    address src, address dst, bytes4 sig\\n  ) public view returns (bool);\\n}\\n\\ncontract DSAuthEvents {\\n  event LogSetAuthority (address indexed authority);\\n  event LogSetOwner     (address indexed owner);\\n}\\n\\ncontract DSAuth is DSAuthEvents {\\n  DSAuthority  public  authority;\\n  address      public  owner;\\n\\n  function DSAuth() public {\\n    owner = msg.sender;\\n    LogSetOwner(msg.sender);\\n  }\\n\\n  function setOwner(address owner_)\\n  public\\n  auth\\n  {\\n    owner = owner_;\\n    LogSetOwner(owner);\\n  }\\n\\n  function setAuthority(DSAuthority authority_)\\n  public\\n  auth\\n  {\\n    authority = authority_;\\n    LogSetAuthority(authority);\\n  }\\n\\n  modifier auth {\\n    require(isAuthorized(msg.sender, msg.sig));\\n    _;\\n  }\\n\\n  function isAuthorized(address src, bytes4 sig) internal view returns (bool) {\\n    if (src == address(this)) {\\n      return true;\\n    } else if (src == owner) {\\n      return true;\\n    } else if (authority == DSAuthority(0)) {\\n      return false;\\n    } else {\\n      return authority.canCall(src, this, sig);\\n    }\\n  }\\n}\\n\"},\"ERC721.sol\":{\"content\":\"pragma solidity ^0.4.18;\\n\\nimport \\\"./ERC721Basic.sol\\\";\\n\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\\n * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\\n */\\ncontract ERC721Enumerable is ERC721Basic {\\n  function totalSupply() public view returns (uint256);\\n  function tokenOfOwnerByIndex(address _owner, uint256 _index) public view returns (uint256 _tokenId);\\n  function tokenByIndex(uint256 _index) public view returns (uint256);\\n}\\n\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\\n * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\\n */\\ncontract ERC721Metadata is ERC721Basic {\\n  function name() public view returns (string _name);\\n  function symbol() public view returns (string _symbol);\\n  function tokenURI(uint256 _tokenId) public view returns (address);\\n}\\n\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, full implementation interface\\n * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\\n */\\ncontract ERC721 is ERC721Basic, ERC721Enumerable, ERC721Metadata {\\n}\\n\"},\"ERC721Basic.sol\":{\"content\":\"pragma solidity ^0.4.18;\\n\\n\\n/**\\n * @title ERC721 Non-Fungible Token Standard basic interface\\n * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\\n */\\ncontract ERC721Basic {\\n  event Transfer(address indexed _from, address indexed _to, uint256 _tokenId, uint256 _timestamp);\\n  event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId);\\n  event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\\n\\n  function balanceOf(address _owner) public view returns (uint256 _balance);\\n  function ownerOf(uint256 _tokenId) public view returns (address _owner);\\n  function exists(uint256 _tokenId) public view returns (bool _exists);\\n\\n  function approve(address _to, uint256 _tokenId) public;\\n  function getApproved(uint256 _tokenId) public view returns (address _operator);\\n\\n  function setApprovalForAll(address _operator, bool _approved) public;\\n  function isApprovedForAll(address _owner, address _operator) public view returns (bool);\\n\\n  function transferFrom(address _from, address _to, uint256 _tokenId) public;\\n  function safeTransferFrom(address _from, address _to, uint256 _tokenId) public;\\n  function safeTransferFrom(\\n    address _from,\\n    address _to,\\n    uint256 _tokenId,\\n    bytes _data\\n  )\\n  public;\\n}\\n\"},\"ERC721BasicToken.sol\":{\"content\":\"pragma solidity ^0.4.18;\\n\\nimport \\\"./ERC721Basic.sol\\\";\\nimport \\\"./ERC721Receiver.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./AddressUtils.sol\\\";\\n\\n\\n/**\\n * @title ERC721 Non-Fungible Token Standard basic implementation\\n * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\\n */\\ncontract ERC721BasicToken is ERC721Basic {\\n  using SafeMath for uint256;\\n  using AddressUtils for address;\\n\\n  // Equals to `bytes4(keccak256(\\\"onERC721Received(address,uint256,bytes)\\\"))`\\n  // which can be also obtained as `ERC721Receiver(0).onERC721Received.selector`\\n  bytes4 constant ERC721_RECEIVED = 0xf0b9e5ba;\\n\\n  // Mapping from token ID to owner\\n  mapping (uint256 =\\u003e address) internal tokenOwner;\\n\\n  // Mapping from token ID to approved address\\n  mapping (uint256 =\\u003e address) internal tokenApprovals;\\n\\n  // Mapping from owner to number of owned token\\n  mapping (address =\\u003e uint256) internal ownedTokensCount;\\n\\n  // Mapping from owner to operator approvals\\n  mapping (address =\\u003e mapping (address =\\u003e bool)) internal operatorApprovals;\\n\\n  /**\\n  * @dev Guarantees msg.sender is owner of the given token\\n  * @param _tokenId uint256 ID of the token to validate its ownership belongs to msg.sender\\n  */\\n  modifier onlyOwnerOf(uint256 _tokenId) {\\n    require(ownerOf(_tokenId) == msg.sender);\\n    _;\\n  }\\n\\n  /**\\n  * @dev Checks msg.sender can transfer a token, by being owner, approved, or operator\\n  * @param _tokenId uint256 ID of the token to validate\\n  */\\n  modifier canTransfer(uint256 _tokenId) {\\n    require(isApprovedOrOwner(msg.sender, _tokenId));\\n    _;\\n  }\\n\\n  /**\\n  * @dev Gets the balance of the specified address\\n  * @param _owner address to query the balance of\\n  * @return uint256 representing the amount owned by the passed address\\n  */\\n  function balanceOf(address _owner) public view returns (uint256) {\\n    require(_owner != address(0));\\n    return ownedTokensCount[_owner];\\n  }\\n\\n  /**\\n  * @dev Gets the owner of the specified token ID\\n  * @param _tokenId uint256 ID of the token to query the owner of\\n  * @return owner address currently marked as the owner of the given token ID\\n  */\\n  function ownerOf(uint256 _tokenId) public view returns (address) {\\n    address owner = tokenOwner[_tokenId];\\n    require(owner != address(0));\\n    return owner;\\n  }\\n\\n  /**\\n  * @dev Returns whether the specified token exists\\n  * @param _tokenId uint256 ID of the token to query the existance of\\n  * @return whether the token exists\\n  */\\n  function exists(uint256 _tokenId) public view returns (bool) {\\n    address owner = tokenOwner[_tokenId];\\n    return owner != address(0);\\n  }\\n\\n  /**\\n  * @dev Approves another address to transfer the given token ID\\n  * @dev The zero address indicates there is no approved address.\\n  * @dev There can only be one approved address per token at a given time.\\n  * @dev Can only be called by the token owner or an approved operator.\\n  * @param _to address to be approved for the given token ID\\n  * @param _tokenId uint256 ID of the token to be approved\\n  */\\n  function approve(address _to, uint256 _tokenId) public {\\n    address owner = ownerOf(_tokenId);\\n    require(_to != owner);\\n    require(msg.sender == owner || isApprovedForAll(owner, msg.sender));\\n\\n    if (getApproved(_tokenId) != address(0) || _to != address(0)) {\\n      tokenApprovals[_tokenId] = _to;\\n      Approval(owner, _to, _tokenId);\\n    }\\n  }\\n\\n  /**\\n   * @dev Gets the approved address for a token ID, or zero if no address set\\n   * @param _tokenId uint256 ID of the token to query the approval of\\n   * @return address currently approved for a the given token ID\\n   */\\n  function getApproved(uint256 _tokenId) public view returns (address) {\\n    return tokenApprovals[_tokenId];\\n  }\\n\\n  /**\\n  * @dev Sets or unsets the approval of a given operator\\n  * @dev An operator is allowed to transfer all tokens of the sender on their behalf\\n  * @param _to operator address to set the approval\\n  * @param _approved representing the status of the approval to be set\\n  */\\n  function setApprovalForAll(address _to, bool _approved) public {\\n    require(_to != msg.sender);\\n    operatorApprovals[msg.sender][_to] = _approved;\\n    ApprovalForAll(msg.sender, _to, _approved);\\n  }\\n\\n  /**\\n   * @dev Tells whether an operator is approved by a given owner\\n   * @param _owner owner address which you want to query the approval of\\n   * @param _operator operator address which you want to query the approval of\\n   * @return bool whether the given operator is approved by the given owner\\n   */\\n  function isApprovedForAll(address _owner, address _operator) public view returns (bool) {\\n    return operatorApprovals[_owner][_operator];\\n  }\\n\\n  /**\\n  * @dev Transfers the ownership of a given token ID to another address\\n  * @dev Usage of this method is discouraged, use `safeTransferFrom` whenever possible\\n  * @dev Requires the msg sender to be the owner, approved, or operator\\n  * @param _from current owner of the token\\n  * @param _to address to receive the ownership of the given token ID\\n  * @param _tokenId uint256 ID of the token to be transferred\\n  */\\n  function transferFrom(address _from, address _to, uint256 _tokenId) public canTransfer(_tokenId) {\\n    require(_from != address(0));\\n    require(_to != address(0));\\n\\n    clearApproval(_from, _tokenId);\\n    removeTokenFrom(_from, _tokenId);\\n    addTokenTo(_to, _tokenId);\\n\\n    Transfer(_from, _to, _tokenId, now);\\n  }\\n\\n  /**\\n  * @dev Safely transfers the ownership of a given token ID to another address\\n  * @dev If the target address is a contract, it must implement `onERC721Received`,\\n  *  which is called upon a safe transfer, and return the magic value\\n  *  `bytes4(keccak256(\\\"onERC721Received(address,uint256,bytes)\\\"))`; otherwise,\\n  *  the transfer is reverted.\\n  * @dev Requires the msg sender to be the owner, approved, or operator\\n  * @param _from current owner of the token\\n  * @param _to address to receive the ownership of the given token ID\\n  * @param _tokenId uint256 ID of the token to be transferred\\n  */\\n  function safeTransferFrom(\\n    address _from,\\n    address _to,\\n    uint256 _tokenId\\n  )\\n  public\\n  canTransfer(_tokenId)\\n  {\\n    safeTransferFrom(_from, _to, _tokenId, \\\"\\\");\\n  }\\n\\n  /**\\n  * @dev Safely transfers the ownership of a given token ID to another address\\n  * @dev If the target address is a contract, it must implement `onERC721Received`,\\n  *  which is called upon a safe transfer, and return the magic value\\n  *  `bytes4(keccak256(\\\"onERC721Received(address,uint256,bytes)\\\"))`; otherwise,\\n  *  the transfer is reverted.\\n  * @dev Requires the msg sender to be the owner, approved, or operator\\n  * @param _from current owner of the token\\n  * @param _to address to receive the ownership of the given token ID\\n  * @param _tokenId uint256 ID of the token to be transferred\\n  * @param _data bytes data to send along with a safe transfer check\\n  */\\n  function safeTransferFrom(\\n    address _from,\\n    address _to,\\n    uint256 _tokenId,\\n    bytes _data\\n  )\\n  public\\n  canTransfer(_tokenId)\\n  {\\n    transferFrom(_from, _to, _tokenId);\\n    require(checkAndCallSafeTransfer(_from, _to, _tokenId, _data));\\n  }\\n\\n  /**\\n   * @dev Returns whether the given spender can transfer a given token ID\\n   * @param _spender address of the spender to query\\n   * @param _tokenId uint256 ID of the token to be transferred\\n   * @return bool whether the msg.sender is approved for the given token ID,\\n   *  is an operator of the owner, or is the owner of the token\\n   */\\n  function isApprovedOrOwner(address _spender, uint256 _tokenId) internal view returns (bool) {\\n    address owner = ownerOf(_tokenId);\\n    return _spender == owner || getApproved(_tokenId) == _spender || isApprovedForAll(owner, _spender);\\n  }\\n\\n  /**\\n  * @dev Internal function to mint a new token\\n  * @dev Reverts if the given token ID already exists\\n  * @param _to The address that will own the minted token\\n  * @param _tokenId uint256 ID of the token to be minted by the msg.sender\\n  */\\n  function _mint(address _to, uint256 _tokenId) internal {\\n    require(_to != address(0));\\n    addTokenTo(_to, _tokenId);\\n    Transfer(address(0), _to, _tokenId, now);\\n  }\\n\\n  /**\\n  * @dev Internal function to burn a specific token\\n  * @dev Reverts if the token does not exist\\n  * @param _tokenId uint256 ID of the token being burned by the msg.sender\\n  */\\n  function _burn(address _owner, uint256 _tokenId) internal {\\n    clearApproval(_owner, _tokenId);\\n    removeTokenFrom(_owner, _tokenId);\\n    Transfer(_owner, address(0), _tokenId, now);\\n  }\\n\\n  /**\\n  * @dev Internal function to clear current approval of a given token ID\\n  * @dev Reverts if the given address is not indeed the owner of the token\\n  * @param _owner owner of the token\\n  * @param _tokenId uint256 ID of the token to be transferred\\n  */\\n  function clearApproval(address _owner, uint256 _tokenId) internal {\\n    require(ownerOf(_tokenId) == _owner);\\n    if (tokenApprovals[_tokenId] != address(0)) {\\n      tokenApprovals[_tokenId] = address(0);\\n      Approval(_owner, address(0), _tokenId);\\n    }\\n  }\\n\\n  /**\\n  * @dev Internal function to add a token ID to the list of a given address\\n  * @param _to address representing the new owner of the given token ID\\n  * @param _tokenId uint256 ID of the token to be added to the tokens list of the given address\\n  */\\n  function addTokenTo(address _to, uint256 _tokenId) internal {\\n    require(tokenOwner[_tokenId] == address(0));\\n    tokenOwner[_tokenId] = _to;\\n    ownedTokensCount[_to] = ownedTokensCount[_to].add(1);\\n  }\\n\\n  /**\\n  * @dev Internal function to remove a token ID from the list of a given address\\n  * @param _from address representing the previous owner of the given token ID\\n  * @param _tokenId uint256 ID of the token to be removed from the tokens list of the given address\\n  */\\n  function removeTokenFrom(address _from, uint256 _tokenId) internal {\\n    require(ownerOf(_tokenId) == _from);\\n    ownedTokensCount[_from] = ownedTokensCount[_from].sub(1);\\n    tokenOwner[_tokenId] = address(0);\\n  }\\n\\n  /**\\n  * @dev Internal function to invoke `onERC721Received` on a target address\\n  * @dev The call is not executed if the target address is not a contract\\n  * @param _from address representing the previous owner of the given token ID\\n  * @param _to target address that will receive the tokens\\n  * @param _tokenId uint256 ID of the token to be transferred\\n  * @param _data bytes optional data to send along with the call\\n  * @return whether the call correctly returned the expected magic value\\n  */\\n  function checkAndCallSafeTransfer(\\n    address _from,\\n    address _to,\\n    uint256 _tokenId,\\n    bytes _data\\n  )\\n  internal\\n  returns (bool)\\n  {\\n    if (!_to.isContract()) {\\n      return true;\\n    }\\n    bytes4 retval = ERC721Receiver(_to).onERC721Received(_from, _tokenId, _data);\\n    return (retval == ERC721_RECEIVED);\\n  }\\n}\\n\"},\"ERC721Receiver.sol\":{\"content\":\"pragma solidity ^0.4.21;\\n\\n\\n/**\\n * @title ERC721 token receiver interface\\n * @dev Interface for any contract that wants to support safeTransfers\\n *  from ERC721 asset contracts.\\n */\\ncontract ERC721Receiver {\\n  /**\\n   * @dev Magic value to be returned upon successful reception of an NFT\\n   *  Equals to `bytes4(keccak256(\\\"onERC721Received(address,uint256,bytes)\\\"))`,\\n   *  which can be also obtained as `ERC721Receiver(0).onERC721Received.selector`\\n   */\\n  bytes4 constant ERC721_RECEIVED = 0xf0b9e5ba;\\n\\n  /**\\n   * @notice Handle the receipt of an NFT\\n   * @dev The ERC721 smart contract calls this function on the recipient\\n   *  after a `safetransfer`. This function MAY throw to revert and reject the\\n   *  transfer. This function MUST use 50,000 gas or less. Return of other\\n   *  than the magic value MUST result in the transaction being reverted.\\n   *  Note: the contract address is always the message sender.\\n   * @param _from The sending address\\n   * @param _tokenId The NFT identifier which is being transfered\\n   * @param _data Additional data with no specified format\\n   * @return `bytes4(keccak256(\\\"onERC721Received(address,uint256,bytes)\\\"))`\\n   */\\n  function onERC721Received(address _from, uint256 _tokenId, bytes _data) public returns(bytes4);\\n}\\n\"},\"ERC721Token.sol\":{\"content\":\"pragma solidity ^0.4.18;\\n\\nimport \\\"./ERC721.sol\\\";\\nimport \\\"./ERC721BasicToken.sol\\\";\\n\\n\\n/**\\n * @title Full ERC721 Token\\n * This implementation includes all the required and some optional functionality of the ERC721 standard\\n * Moreover, it includes approve all functionality using operator terminology\\n * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\\n */\\ncontract ERC721Token is ERC721, ERC721BasicToken {\\n  // Token name\\n  string internal name_;\\n\\n  // Token symbol\\n  string internal symbol_;\\n\\n  // Mapping from owner to list of owned token IDs\\n  mapping(address =\\u003e uint256[]) internal ownedTokens;\\n\\n  // Mapping from token ID to index of the owner tokens list\\n  mapping(uint256 =\\u003e uint256) internal ownedTokensIndex;\\n\\n  // Array with all token ids, used for enumeration\\n  uint256[] internal allTokens;\\n\\n  // Mapping from token id to position in the allTokens array\\n  mapping(uint256 =\\u003e uint256) internal allTokensIndex;\\n\\n  // Optional mapping for token URIs\\n  mapping(uint256 =\\u003e address) internal tokenURIs;\\n\\n  /**\\n  * @dev Constructor function\\n  */\\n  function ERC721Token(string _name, string _symbol) public {\\n    name_ = _name;\\n    symbol_ = _symbol;\\n  }\\n\\n  /**\\n  * @dev Gets the token name\\n  * @return string representing the token name\\n  */\\n  function name() public view returns (string) {\\n    return name_;\\n  }\\n\\n  /**\\n  * @dev Gets the token symbol\\n  * @return string representing the token symbol\\n  */\\n  function symbol() public view returns (string) {\\n    return symbol_;\\n  }\\n\\n  /**\\n  * @dev Returns an URI for a given token ID\\n  * @dev Throws if the token ID does not exist. May return an empty string.\\n  * @param _tokenId uint256 ID of the token to query\\n  */\\n  function tokenURI(uint256 _tokenId) public view returns (address) {\\n    require(exists(_tokenId));\\n    return tokenURIs[_tokenId];\\n  }\\n\\n  /**\\n  * @dev Gets the token ID at a given index of the tokens list of the requested owner\\n  * @param _owner address owning the tokens list to be accessed\\n  * @param _index uint256 representing the index to be accessed of the requested tokens list\\n  * @return uint256 token ID at the given index of the tokens list owned by the requested address\\n  */\\n  function tokenOfOwnerByIndex(address _owner, uint256 _index) public view returns (uint256) {\\n    require(_index \\u003c balanceOf(_owner));\\n    return ownedTokens[_owner][_index];\\n  }\\n\\n  /**\\n  * @dev Gets the total amount of tokens stored by the contract\\n  * @return uint256 representing the total amount of tokens\\n  */\\n  function totalSupply() public view returns (uint256) {\\n    return allTokens.length;\\n  }\\n\\n  /**\\n  * @dev Gets the token ID at a given index of all the tokens in this contract\\n  * @dev Reverts if the index is greater or equal to the total number of tokens\\n  * @param _index uint256 representing the index to be accessed of the tokens list\\n  * @return uint256 token ID at the given index of the tokens list\\n  */\\n  function tokenByIndex(uint256 _index) public view returns (uint256) {\\n    require(_index \\u003c totalSupply());\\n    return allTokens[_index];\\n  }\\n\\n  /**\\n  * @dev Internal function to set the token URI for a given token\\n  * @dev Reverts if the token ID does not exist\\n  * @param _tokenId uint256 ID of the token to set its URI\\n  * @param _uri string URI to assign\\n  */\\n  function _setTokenURI(uint256 _tokenId, address _uri) internal {\\n    require(exists(_tokenId));\\n    tokenURIs[_tokenId] = _uri;\\n  }\\n\\n  /**\\n  * @dev Internal function to add a token ID to the list of a given address\\n  * @param _to address representing the new owner of the given token ID\\n  * @param _tokenId uint256 ID of the token to be added to the tokens list of the given address\\n  */\\n  function addTokenTo(address _to, uint256 _tokenId) internal {\\n    super.addTokenTo(_to, _tokenId);\\n    uint256 length = ownedTokens[_to].length;\\n    ownedTokens[_to].push(_tokenId);\\n    ownedTokensIndex[_tokenId] = length;\\n  }\\n\\n  /**\\n  * @dev Internal function to remove a token ID from the list of a given address\\n  * @param _from address representing the previous owner of the given token ID\\n  * @param _tokenId uint256 ID of the token to be removed from the tokens list of the given address\\n  */\\n  function removeTokenFrom(address _from, uint256 _tokenId) internal {\\n    super.removeTokenFrom(_from, _tokenId);\\n\\n    uint256 tokenIndex = ownedTokensIndex[_tokenId];\\n    uint256 lastTokenIndex = ownedTokens[_from].length.sub(1);\\n    uint256 lastToken = ownedTokens[_from][lastTokenIndex];\\n\\n    ownedTokens[_from][tokenIndex] = lastToken;\\n    ownedTokens[_from][lastTokenIndex] = 0;\\n    // Note that this will handle single-element arrays. In that case, both tokenIndex and lastTokenIndex are going to\\n    // be zero. Then we can make sure that we will remove _tokenId from the ownedTokens list since we are first swapping\\n    // the lastToken to the first position, and then dropping the element placed in the last position of the list\\n\\n    ownedTokens[_from].length--;\\n    ownedTokensIndex[_tokenId] = 0;\\n    ownedTokensIndex[lastToken] = tokenIndex;\\n  }\\n\\n  /**\\n  * @dev Internal function to mint a new token\\n  * @dev Reverts if the given token ID already exists\\n  * @param _to address the beneficiary that will own the minted token\\n  * @param _tokenId uint256 ID of the token to be minted by the msg.sender\\n  */\\n  function _mint(address _to, uint256 _tokenId) internal {\\n    super._mint(_to, _tokenId);\\n\\n    allTokensIndex[_tokenId] = allTokens.length;\\n    allTokens.push(_tokenId);\\n  }\\n}\\n\"},\"EternalDb.sol\":{\"content\":\"pragma solidity ^0.4.18;\\n\\nimport \\\"./DSAuth.sol\\\";\\n\\n/**\\n * @title Contract to store arbitrary state data, decoupled from any logic related to it\\n *\\n * @dev Original implementation: https://blog.colony.io/writing-upgradeable-contracts-in-solidity-6743f0eecc88\\n * In addition to original implementation, this contract uses DSAuth for more advanced authentication options\\n * It also provides way set/get multiple values in single transaction\\n */\\n\\ncontract EternalDb is DSAuth {\\n\\n  enum Types {UInt, String, Address, Bytes, Bytes32, Boolean, Int}\\n\\n  event EternalDbEvent(bytes32[] records, uint[] values, uint timestamp);\\n\\n  function EternalDb(){\\n  }\\n\\n  ////////////\\n  //UInt\\n  ////////////\\n\\n  mapping(bytes32 =\\u003e uint) UIntStorage;\\n\\n  function getUIntValue(bytes32 record) constant returns (uint){\\n    return UIntStorage[record];\\n  }\\n\\n  function getUIntValues(bytes32[] records) constant returns (uint[] results){\\n    results = new uint[](records.length);\\n    for (uint i = 0; i \\u003c records.length; i++) {\\n      results[i] = UIntStorage[records[i]];\\n    }\\n  }\\n\\n  function setUIntValue(bytes32 record, uint value)\\n  auth\\n  {\\n    UIntStorage[record] = value;\\n    bytes32[] memory records = new bytes32[](1);\\n    records[0] = record;\\n    uint[] memory values = new uint[](1);\\n    values[0] = value;\\n    emit EternalDbEvent(records, values, now);\\n  }\\n\\n  function setUIntValues(bytes32[] records, uint[] values)\\n  auth\\n  {\\n    for (uint i = 0; i \\u003c records.length; i++) {\\n      UIntStorage[records[i]] = values[i];\\n    }\\n    emit EternalDbEvent(records, values, now);\\n  }\\n\\n  function deleteUIntValue(bytes32 record)\\n  auth\\n  {\\n    delete UIntStorage[record];\\n  }\\n\\n  ////////////\\n  //Strings\\n  ////////////\\n\\n  mapping(bytes32 =\\u003e string) StringStorage;\\n\\n  function getStringValue(bytes32 record) constant returns (string){\\n    return StringStorage[record];\\n  }\\n\\n  function setStringValue(bytes32 record, string value)\\n  auth\\n  {\\n    StringStorage[record] = value;\\n  }\\n\\n  function deleteStringValue(bytes32 record)\\n  auth\\n  {\\n    delete StringStorage[record];\\n  }\\n\\n  ////////////\\n  //Address\\n  ////////////\\n\\n  mapping(bytes32 =\\u003e address) AddressStorage;\\n\\n  function getAddressValue(bytes32 record) constant returns (address){\\n    return AddressStorage[record];\\n  }\\n\\n  function setAddressValues(bytes32[] records, address[] values)\\n  auth\\n  {\\n    for (uint i = 0; i \\u003c records.length; i++) {\\n      AddressStorage[records[i]] = values[i];\\n    }\\n  }\\n\\n  function setAddressValue(bytes32 record, address value)\\n  auth\\n  {\\n    AddressStorage[record] = value;\\n  }\\n\\n  function deleteAddressValue(bytes32 record)\\n  auth\\n  {\\n    delete AddressStorage[record];\\n  }\\n\\n  ////////////\\n  //Bytes\\n  ////////////\\n\\n  mapping(bytes32 =\\u003e bytes) BytesStorage;\\n\\n  function getBytesValue(bytes32 record) constant returns (bytes){\\n    return BytesStorage[record];\\n  }\\n\\n  function setBytesValue(bytes32 record, bytes value)\\n  auth\\n  {\\n    BytesStorage[record] = value;\\n  }\\n\\n  function deleteBytesValue(bytes32 record)\\n  auth\\n  {\\n    delete BytesStorage[record];\\n  }\\n\\n  ////////////\\n  //Bytes32\\n  ////////////\\n\\n  mapping(bytes32 =\\u003e bytes32) Bytes32Storage;\\n\\n  function getBytes32Value(bytes32 record) constant returns (bytes32){\\n    return Bytes32Storage[record];\\n  }\\n\\n  function getBytes32Values(bytes32[] records) constant returns (bytes32[] results){\\n    results = new bytes32[](records.length);\\n    for (uint i = 0; i \\u003c records.length; i++) {\\n      results[i] = Bytes32Storage[records[i]];\\n    }\\n  }\\n\\n  function setBytes32Value(bytes32 record, bytes32 value)\\n  auth\\n  {\\n    Bytes32Storage[record] = value;\\n  }\\n\\n  function setBytes32Values(bytes32[] records, bytes32[] values)\\n  auth\\n  {\\n    for (uint i = 0; i \\u003c records.length; i++) {\\n      Bytes32Storage[records[i]] = values[i];\\n    }\\n  }\\n\\n  function deleteBytes32Value(bytes32 record)\\n  auth\\n  {\\n    delete Bytes32Storage[record];\\n  }\\n\\n  ////////////\\n  //Boolean\\n  ////////////\\n\\n  mapping(bytes32 =\\u003e bool) BooleanStorage;\\n\\n  function getBooleanValue(bytes32 record) constant returns (bool){\\n    return BooleanStorage[record];\\n  }\\n\\n  function getBooleanValues(bytes32[] records) constant returns (bool[] results){\\n    results = new bool[](records.length);\\n    for (uint i = 0; i \\u003c records.length; i++) {\\n      results[i] = BooleanStorage[records[i]];\\n    }\\n  }\\n\\n  function setBooleanValue(bytes32 record, bool value)\\n  auth\\n  {\\n    BooleanStorage[record] = value;\\n  }\\n\\n  function setBooleanValues(bytes32[] records, bool[] values)\\n  auth\\n  {\\n    for (uint i = 0; i \\u003c records.length; i++) {\\n      BooleanStorage[records[i]] = values[i];\\n    }\\n  }\\n\\n  function deleteBooleanValue(bytes32 record)\\n  auth\\n  {\\n    delete BooleanStorage[record];\\n  }\\n\\n  ////////////\\n  //Int\\n  ////////////\\n  mapping(bytes32 =\\u003e int) IntStorage;\\n\\n  function getIntValue(bytes32 record) constant returns (int){\\n    return IntStorage[record];\\n  }\\n\\n  function getIntValues(bytes32[] records) constant returns (int[] results){\\n    results = new int[](records.length);\\n    for (uint i = 0; i \\u003c records.length; i++) {\\n      results[i] = IntStorage[records[i]];\\n    }\\n  }\\n\\n  function setIntValue(bytes32 record, int value)\\n  auth\\n  {\\n    IntStorage[record] = value;\\n  }\\n\\n  function setIntValues(bytes32[] records, int[] values)\\n  auth\\n  {\\n    for (uint i = 0; i \\u003c records.length; i++) {\\n      IntStorage[records[i]] = values[i];\\n    }\\n  }\\n\\n  function deleteIntValue(bytes32 record)\\n  auth\\n  {\\n    delete IntStorage[record];\\n  }\\n\\n}\\n\"},\"Forwarder.sol\":{\"content\":\"pragma solidity ^0.4.18;\\n\\nimport \\\"./DelegateProxy.sol\\\";\\n\\ncontract Forwarder is DelegateProxy {\\n  // After compiling contract, `beefbeef...` is replaced in the bytecode by the real target address\\n  address public constant target = 0x1ed7fc52ac5a37aa3ff6d9b94c894724e2f992b1; // checksumed to silence warning\\n\\n  /*\\n  * @dev Forwards all calls to target\\n  */\\n  function() payable {\\n    delegatedFwd(target, msg.data);\\n  }\\n}\"},\"Meme.sol\":{\"content\":\"pragma solidity ^0.4.24;\\n\\nimport \\\"./RegistryEntry.sol\\\";\\nimport \\\"./MemeToken.sol\\\";\\nimport \\\"./DistrictConfig.sol\\\";\\n\\n/**\\n * @title Contract created for each submitted Meme into the MemeFactory TCR.\\n *\\n * @dev It extends base RegistryEntry with additional state for storing IPFS hashes for a meme image and meta data.\\n * It also contains state and logic for handling initial meme offering.\\n * Full copy of this contract is NOT deployed with each submission in order to save gas. Only forwarder contracts\\n * pointing into single intance of it.\\n */\\n\\ncontract Meme is RegistryEntry {\\n\\n  DistrictConfig private constant districtConfig = DistrictConfig(0xABCDabcdABcDabcDaBCDAbcdABcdAbCdABcDABCd);\\n  MemeToken private constant memeToken = MemeToken(0xdaBBdABbDABbDabbDaBbDabbDaBbdaBbdaBbDAbB);\\n  bytes private metaHash;\\n  uint private tokenIdStart;\\n  uint private totalSupply;\\n  uint private totalMinted;\\n\\n  /**\\n   * @dev Constructor for this contract.\\n   * Native constructor is not used, because users create only forwarders pointing into single instance of this contract,\\n   * therefore constructor must be called explicitly.\\n\\n   * @param _creator Creator of a meme\\n   * @param _version Version of Meme contract\\n   * @param _metaHash IPFS hash of meta data related to a meme\\n   * @param _totalSupply This meme\\u0027s token total supply\\n   */\\n  function construct(\\n                     address _creator,\\n                     uint _version,\\n                     bytes _metaHash,\\n                     uint _totalSupply\\n                     )\\n    external\\n  {\\n    super.construct(_creator, _version);\\n\\n    require(_totalSupply \\u003e 0);\\n    require(_totalSupply \\u003c= registry.db().getUIntValue(registry.maxTotalSupplyKey()));\\n\\n    totalSupply = _totalSupply;\\n    metaHash = _metaHash;\\n\\n    registry.fireMemeConstructedEvent(version,\\n                                      _creator,\\n                                      metaHash,\\n                                      totalSupply,\\n                                      deposit,\\n                                      challenge.challengePeriodEnd);\\n  }\\n\\n  /**\\n   * @dev Transfers deposit to deposit collector\\n   * Must be callable only for whitelisted registry entries\\n   */\\n  function transferDeposit()\\n    external\\n    notEmergency\\n    onlyWhitelisted\\n  {\\n    require(registryToken.transfer(districtConfig.depositCollector(), deposit));\\n\\n  }\\n\\n  function mint(uint _amount)\\n    public\\n    notEmergency\\n    onlyWhitelisted\\n  {\\n    uint restSupply = totalSupply.sub(totalMinted);\\n    if (_amount == 0 || _amount \\u003e restSupply) {\\n      _amount = restSupply;\\n    }\\n\\n    require(_amount \\u003e 0);\\n\\n    tokenIdStart = memeToken.totalSupply().add(1);\\n    uint tokenIdEnd = tokenIdStart.add(_amount);\\n    for (uint i = tokenIdStart; i \\u003c tokenIdEnd; i++) {\\n      memeToken.mint(creator, i);\\n      totalMinted = totalMinted + 1;\\n    }\\n\\n    registry.fireMemeMintedEvent(version,\\n                                 creator,\\n                                 tokenIdStart,\\n                                 tokenIdEnd-1,\\n                                 totalMinted);\\n  }\\n\\n  function loadMeme() external constant returns (bytes,\\n                                                 uint,\\n                                                 uint,\\n                                                 uint){\\n    return(metaHash,\\n           totalSupply,\\n           totalMinted,\\n           tokenIdStart);\\n  }\\n\\n}\\n\"},\"MemeFactory.sol\":{\"content\":\"pragma solidity ^0.4.24;\\n\\nimport \\\"./RegistryEntryFactory.sol\\\";\\nimport \\\"./Meme.sol\\\";\\nimport \\\"./MemeToken.sol\\\";\\n\\n/**\\n * @title Factory contract for creating Meme contracts\\n *\\n * @dev Users submit new memes into this contract.\\n */\\n\\ncontract MemeFactory is RegistryEntryFactory {\\n  uint public constant version = 1;\\n  MemeToken public memeToken;\\n\\n  function MemeFactory(Registry _registry, MiniMeToken _registryToken, MemeToken _memeToken)\\n  RegistryEntryFactory(_registry, _registryToken)\\n  {\\n    memeToken = _memeToken;\\n  }\\n\\n  /**\\n   * @dev Creates new Meme forwarder contract and add it into the registry\\n   * It initializes forwarder contract with initial state. For comments on each param, see Meme::construct\\n   */\\n  function createMeme(\\n    address _creator,\\n    bytes _metaHash,\\n    uint _totalSupply\\n  )\\n  public\\n  {\\n    Meme meme = Meme(createRegistryEntry(_creator));\\n\\n    meme.construct(\\n      _creator,\\n      version,\\n      _metaHash,\\n      _totalSupply\\n    );\\n  }\\n}\\n\"},\"MemeToken.sol\":{\"content\":\"pragma solidity ^0.4.24;\\n\\nimport \\\"./ERC721Token.sol\\\";\\nimport \\\"./Registry.sol\\\";\\nimport \\\"./DSAuth.sol\\\";\\n\\n/**\\n * @title Token of a Meme. Single ERC721 instance represents all memes/cards\\n */\\n\\ncontract MemeToken is ERC721Token {\\n  Registry public registry;\\n\\n  modifier onlyRegistryEntry() {\\n    require(registry.isRegistryEntry(msg.sender),\\\"MemeToken: onlyRegistryEntry failed\\\");\\n    _;\\n  }\\n\\n  function MemeToken(Registry _registry)\\n  ERC721Token(\\\"MemeToken\\\", \\\"MEME\\\")\\n  {\\n    registry = _registry;\\n  }\\n\\n  function mint(address _to, uint256 _tokenId)\\n  onlyRegistryEntry\\n  public\\n  {\\n    super._mint(_to, _tokenId);\\n    tokenURIs[_tokenId] = msg.sender;\\n  }\\n\\n  function safeTransferFromMulti(\\n    address _from,\\n    address _to,\\n    uint256[] _tokenIds,\\n    bytes _data\\n  ) {\\n    for (uint i = 0; i \\u003c _tokenIds.length; i++) {\\n      safeTransferFrom(_from, _to, _tokenIds[i], _data);\\n    }\\n  }\\n}\\n\"},\"MiniMeToken.sol\":{\"content\":\"pragma solidity ^0.4.18;\\n\\n/*\\n    Copyright 2016, Jordi Baylina\\n\\n    This program is free software: you can redistribute it and/or modify\\n    it under the terms of the GNU General Public License as published by\\n    the Free Software Foundation, either version 3 of the License, or\\n    (at your option) any later version.\\n\\n    This program is distributed in the hope that it will be useful,\\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n    GNU General Public License for more details.\\n\\n    You should have received a copy of the GNU General Public License\\n    along with this program.  If not, see \\u003chttp://www.gnu.org/licenses/\\u003e.\\n */\\n\\n/// @title MiniMeToken Contract\\n/// @author Jordi Baylina\\n/// @dev This token contract\\u0027s goal is to make it easy for anyone to clone this\\n///  token using the token distribution at a given block, this will allow DAO\\u0027s\\n///  and DApps to upgrade their features in a decentralized manner without\\n///  affecting the original token\\n/// @dev It is ERC20 compliant, but still needs to under go further testing.\\n\\nimport \\\"./Controlled.sol\\\";\\nimport \\\"./TokenController.sol\\\";\\n\\ncontract ApproveAndCallFallBack {\\n  function receiveApproval(address from, uint256 _amount, address _token, bytes _data) public;\\n}\\n\\n/// @dev The actual token contract, the default controller is the msg.sender\\n///  that deploys the contract, so usually this token will be deployed by a\\n///  token controller contract, which Giveth will call a \\\"Campaign\\\"\\ncontract MiniMeToken is Controlled {\\n\\n  string public name;                //The Token\\u0027s name: e.g. DigixDAO Tokens\\n  uint8 public decimals;             //Number of decimals of the smallest unit\\n  string public symbol;              //An identifier: e.g. REP\\n  string public version = \\u0027MMT_0.2\\u0027; //An arbitrary versioning scheme\\n\\n\\n  /// @dev `Checkpoint` is the structure that attaches a block number to a\\n  ///  given value, the block number attached is the one that last changed the\\n  ///  value\\n  struct  Checkpoint {\\n\\n    // `fromBlock` is the block number that the value was generated from\\n    uint128 fromBlock;\\n\\n    // `value` is the amount of tokens at a specific block number\\n    uint128 value;\\n  }\\n\\n  // `parentToken` is the Token address that was cloned to produce this token;\\n  //  it will be 0x0 for a token that was not cloned\\n  MiniMeToken public parentToken;\\n\\n  // `parentSnapShotBlock` is the block number from the Parent Token that was\\n  //  used to determine the initial distribution of the Clone Token\\n  uint public parentSnapShotBlock;\\n\\n  // `creationBlock` is the block number that the Clone Token was created\\n  uint public creationBlock;\\n\\n  // `balances` is the map that tracks the balance of each address, in this\\n  //  contract when the balance changes the block number that the change\\n  //  occurred is also included in the map\\n  mapping (address =\\u003e Checkpoint[]) balances;\\n\\n  // `allowed` tracks any extra transfer rights as in all ERC20 tokens\\n  mapping (address =\\u003e mapping (address =\\u003e uint256)) allowed;\\n\\n  // Tracks the history of the `totalSupply` of the token\\n  Checkpoint[] totalSupplyHistory;\\n\\n  // Flag that determines if the token is transferable or not.\\n  bool public transfersEnabled;\\n\\n  // The factory used to create new clone tokens\\n  MiniMeTokenFactory public tokenFactory;\\n\\n  ////////////////\\n  // Constructor\\n  ////////////////\\n\\n  /// @notice Constructor to create a MiniMeToken\\n  /// @param _tokenFactory The address of the MiniMeTokenFactory contract that\\n  ///  will create the Clone token contracts, the token factory needs to be\\n  ///  deployed first\\n  /// @param _parentToken Address of the parent token, set to 0x0 if it is a\\n  ///  new token\\n  /// @param _parentSnapShotBlock Block of the parent token that will\\n  ///  determine the initial distribution of the clone token, set to 0 if it\\n  ///  is a new token\\n  /// @param _tokenName Name of the new token\\n  /// @param _decimalUnits Number of decimals of the new token\\n  /// @param _tokenSymbol Token Symbol for the new token\\n  /// @param _transfersEnabled If true, tokens will be able to be transferred\\n  function MiniMeToken(\\n    address _tokenFactory,\\n    address _parentToken,\\n    uint _parentSnapShotBlock,\\n    string _tokenName,\\n    uint8 _decimalUnits,\\n    string _tokenSymbol,\\n    bool _transfersEnabled\\n  ) public {\\n    tokenFactory = MiniMeTokenFactory(_tokenFactory);\\n    name = _tokenName;                                 // Set the name\\n    decimals = _decimalUnits;                          // Set the decimals\\n    symbol = _tokenSymbol;                             // Set the symbol\\n    parentToken = MiniMeToken(_parentToken);\\n    parentSnapShotBlock = _parentSnapShotBlock;\\n    transfersEnabled = _transfersEnabled;\\n    creationBlock = block.number;\\n  }\\n\\n\\n  ///////////////////\\n  // ERC20 Methods\\n  ///////////////////\\n\\n  /// @notice Send `_amount` tokens to `_to` from `msg.sender`\\n  /// @param _to The address of the recipient\\n  /// @param _amount The amount of tokens to be transferred\\n  /// @return Whether the transfer was successful or not\\n  function transfer(address _to, uint256 _amount) public returns (bool success) {\\n    require(transfersEnabled);\\n    doTransfer(msg.sender, _to, _amount);\\n    return true;\\n  }\\n\\n  /// @notice Send `_amount` tokens to `_to` from `_from` on the condition it\\n  ///  is approved by `_from`\\n  /// @param _from The address holding the tokens being transferred\\n  /// @param _to The address of the recipient\\n  /// @param _amount The amount of tokens to be transferred\\n  /// @return True if the transfer was successful\\n  function transferFrom(address _from, address _to, uint256 _amount\\n  ) public returns (bool success) {\\n\\n    // The controller of this contract can move tokens around at will,\\n    //  this is important to recognize! Confirm that you trust the\\n    //  controller of this contract, which in most situations should be\\n    //  another open source smart contract or 0x0\\n    if (msg.sender != controller) {\\n      require(transfersEnabled);\\n\\n      // The standard ERC 20 transferFrom functionality\\n      require(allowed[_from][msg.sender] \\u003e= _amount);\\n      allowed[_from][msg.sender] -= _amount;\\n    }\\n    doTransfer(_from, _to, _amount);\\n    return true;\\n  }\\n\\n  /// @dev This is the actual transfer function in the token contract, it can\\n  ///  only be called by other functions in this contract.\\n  /// @param _from The address holding the tokens being transferred\\n  /// @param _to The address of the recipient\\n  /// @param _amount The amount of tokens to be transferred\\n  /// @return True if the transfer was successful\\n  function doTransfer(address _from, address _to, uint _amount\\n  ) internal {\\n\\n    if (_amount == 0) {\\n      Transfer(_from, _to, _amount);    // Follow the spec to louch the event when transfer 0\\n      return;\\n    }\\n\\n    require(parentSnapShotBlock \\u003c block.number);\\n\\n    // Do not allow transfer to 0x0 or the token contract itself\\n    require((_to != 0) \\u0026\\u0026 (_to != address(this)));\\n\\n    // If the amount being transfered is more than the balance of the\\n    //  account the transfer throws\\n    var previousBalanceFrom = balanceOfAt(_from, block.number);\\n\\n    require(previousBalanceFrom \\u003e= _amount);\\n\\n    // Alerts the token controller of the transfer\\n    if (isContract(controller)) {\\n      require(TokenController(controller).onTransfer(_from, _to, _amount));\\n    }\\n\\n    // First update the balance array with the new value for the address\\n    //  sending the tokens\\n    updateValueAtNow(balances[_from], previousBalanceFrom - _amount);\\n\\n    // Then update the balance array with the new value for the address\\n    //  receiving the tokens\\n    var previousBalanceTo = balanceOfAt(_to, block.number);\\n    require(previousBalanceTo + _amount \\u003e= previousBalanceTo); // Check for overflow\\n    updateValueAtNow(balances[_to], previousBalanceTo + _amount);\\n\\n    // An event to make the transfer easy to find on the blockchain\\n    Transfer(_from, _to, _amount);\\n\\n  }\\n\\n  /// @param _owner The address that\\u0027s balance is being requested\\n  /// @return The balance of `_owner` at the current block\\n  function balanceOf(address _owner) public constant returns (uint256 balance) {\\n    return balanceOfAt(_owner, block.number);\\n  }\\n\\n  /// @notice `msg.sender` approves `_spender` to spend `_amount` tokens on\\n  ///  its behalf. This is a modified version of the ERC20 approve function\\n  ///  to be a little bit safer\\n  /// @param _spender The address of the account able to transfer the tokens\\n  /// @param _amount The amount of tokens to be approved for transfer\\n  /// @return True if the approval was successful\\n  function approve(address _spender, uint256 _amount) public returns (bool success) {\\n    require(transfersEnabled);\\n\\n    // To change the approve amount you first have to reduce the addresses`\\n    //  allowance to zero by calling `approve(_spender,0)` if it is not\\n    //  already 0 to mitigate the race condition described here:\\n    //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n    require((_amount == 0) || (allowed[msg.sender][_spender] == 0));\\n\\n    // Alerts the token controller of the approve function call\\n    if (isContract(controller)) {\\n      require(TokenController(controller).onApprove(msg.sender, _spender, _amount));\\n    }\\n\\n    allowed[msg.sender][_spender] = _amount;\\n    Approval(msg.sender, _spender, _amount);\\n    return true;\\n  }\\n\\n  /// @dev This function makes it easy to read the `allowed[]` map\\n  /// @param _owner The address of the account that owns the token\\n  /// @param _spender The address of the account able to transfer the tokens\\n  /// @return Amount of remaining tokens of _owner that _spender is allowed\\n  ///  to spend\\n  function allowance(address _owner, address _spender\\n  ) public constant returns (uint256 remaining) {\\n    return allowed[_owner][_spender];\\n  }\\n\\n  /// @notice `msg.sender` approves `_spender` to send `_amount` tokens on\\n  ///  its behalf, and then a function is triggered in the contract that is\\n  ///  being approved, `_spender`. This allows users to use their tokens to\\n  ///  interact with contracts in one function call instead of two\\n  /// @param _spender The address of the contract able to transfer the tokens\\n  /// @param _amount The amount of tokens to be approved for transfer\\n  /// @return True if the function call was successful\\n  function approveAndCall(address _spender, uint256 _amount, bytes _extraData\\n  ) public returns (bool success) {\\n    require(approve(_spender, _amount));\\n\\n    ApproveAndCallFallBack(_spender).receiveApproval(\\n      msg.sender,\\n      _amount,\\n      this,\\n      _extraData\\n    );\\n\\n    return true;\\n  }\\n\\n  /// @dev This function makes it easy to get the total number of tokens\\n  /// @return The total number of tokens\\n  function totalSupply() public constant returns (uint) {\\n    return totalSupplyAt(block.number);\\n  }\\n\\n\\n  ////////////////\\n  // Query balance and totalSupply in History\\n  ////////////////\\n\\n  /// @dev Queries the balance of `_owner` at a specific `_blockNumber`\\n  /// @param _owner The address from which the balance will be retrieved\\n  /// @param _blockNumber The block number when the balance is queried\\n  /// @return The balance at `_blockNumber`\\n  function balanceOfAt(address _owner, uint _blockNumber) public constant\\n  returns (uint) {\\n\\n    // These next few lines are used when the balance of the token is\\n    //  requested before a check point was ever created for this token, it\\n    //  requires that the `parentToken.balanceOfAt` be queried at the\\n    //  genesis block for that token as this contains initial balance of\\n    //  this token\\n    if ((balances[_owner].length == 0)\\n      || (balances[_owner][0].fromBlock \\u003e _blockNumber)) {\\n      if (address(parentToken) != 0) {\\n        return parentToken.balanceOfAt(_owner, min(_blockNumber, parentSnapShotBlock));\\n      } else {\\n        // Has no parent\\n        return 0;\\n      }\\n\\n      // This will return the expected balance during normal situations\\n    } else {\\n      return getValueAt(balances[_owner], _blockNumber);\\n    }\\n  }\\n\\n  /// @notice Total amount of tokens at a specific `_blockNumber`.\\n  /// @param _blockNumber The block number when the totalSupply is queried\\n  /// @return The total amount of tokens at `_blockNumber`\\n  function totalSupplyAt(uint _blockNumber) public constant returns(uint) {\\n\\n    // These next few lines are used when the totalSupply of the token is\\n    //  requested before a check point was ever created for this token, it\\n    //  requires that the `parentToken.totalSupplyAt` be queried at the\\n    //  genesis block for this token as that contains totalSupply of this\\n    //  token at this block number.\\n    if ((totalSupplyHistory.length == 0)\\n      || (totalSupplyHistory[0].fromBlock \\u003e _blockNumber)) {\\n      if (address(parentToken) != 0) {\\n        return parentToken.totalSupplyAt(min(_blockNumber, parentSnapShotBlock));\\n      } else {\\n        return 0;\\n      }\\n\\n      // This will return the expected totalSupply during normal situations\\n    } else {\\n      return getValueAt(totalSupplyHistory, _blockNumber);\\n    }\\n  }\\n\\n  ////////////////\\n  // Clone Token Method\\n  ////////////////\\n\\n  /// @notice Creates a new clone token with the initial distribution being\\n  ///  this token at `_snapshotBlock`\\n  /// @param _cloneTokenName Name of the clone token\\n  /// @param _cloneDecimalUnits Number of decimals of the smallest unit\\n  /// @param _cloneTokenSymbol Symbol of the clone token\\n  /// @param _snapshotBlock Block when the distribution of the parent token is\\n  ///  copied to set the initial distribution of the new clone token;\\n  ///  if the block is zero than the actual block, the current block is used\\n  /// @param _transfersEnabled True if transfers are allowed in the clone\\n  /// @return The address of the new MiniMeToken Contract\\n  function createCloneToken(\\n    string _cloneTokenName,\\n    uint8 _cloneDecimalUnits,\\n    string _cloneTokenSymbol,\\n    uint _snapshotBlock,\\n    bool _transfersEnabled\\n  ) public returns(address) {\\n    if (_snapshotBlock == 0) _snapshotBlock = block.number;\\n    MiniMeToken cloneToken = tokenFactory.createCloneToken(\\n      this,\\n      _snapshotBlock,\\n      _cloneTokenName,\\n      _cloneDecimalUnits,\\n      _cloneTokenSymbol,\\n      _transfersEnabled\\n    );\\n\\n    cloneToken.changeController(msg.sender);\\n\\n    // An event to make the token easy to find on the blockchain\\n    NewCloneToken(address(cloneToken), _snapshotBlock);\\n    return address(cloneToken);\\n  }\\n\\n  ////////////////\\n  // Generate and destroy tokens\\n  ////////////////\\n\\n  /// @notice Generates `_amount` tokens that are assigned to `_owner`\\n  /// @param _owner The address that will be assigned the new tokens\\n  /// @param _amount The quantity of tokens generated\\n  /// @return True if the tokens are generated correctly\\n  function generateTokens(address _owner, uint _amount\\n  ) public onlyController returns (bool) {\\n    uint curTotalSupply = totalSupply();\\n    require(curTotalSupply + _amount \\u003e= curTotalSupply); // Check for overflow\\n    uint previousBalanceTo = balanceOf(_owner);\\n    require(previousBalanceTo + _amount \\u003e= previousBalanceTo); // Check for overflow\\n    updateValueAtNow(totalSupplyHistory, curTotalSupply + _amount);\\n    updateValueAtNow(balances[_owner], previousBalanceTo + _amount);\\n    Transfer(0, _owner, _amount);\\n    return true;\\n  }\\n\\n\\n  /// @notice Burns `_amount` tokens from `_owner`\\n  /// @param _owner The address that will lose the tokens\\n  /// @param _amount The quantity of tokens to burn\\n  /// @return True if the tokens are burned correctly\\n  function destroyTokens(address _owner, uint _amount\\n  ) onlyController public returns (bool) {\\n    uint curTotalSupply = totalSupply();\\n    require(curTotalSupply \\u003e= _amount);\\n    uint previousBalanceFrom = balanceOf(_owner);\\n    require(previousBalanceFrom \\u003e= _amount);\\n    updateValueAtNow(totalSupplyHistory, curTotalSupply - _amount);\\n    updateValueAtNow(balances[_owner], previousBalanceFrom - _amount);\\n    Transfer(_owner, 0, _amount);\\n    return true;\\n  }\\n\\n  ////////////////\\n  // Enable tokens transfers\\n  ////////////////\\n\\n\\n  /// @notice Enables token holders to transfer their tokens freely if true\\n  /// @param _transfersEnabled True if transfers are allowed in the clone\\n  function enableTransfers(bool _transfersEnabled) public onlyController {\\n    transfersEnabled = _transfersEnabled;\\n  }\\n\\n  ////////////////\\n  // Internal helper functions to query and set a value in a snapshot array\\n  ////////////////\\n\\n  /// @dev `getValueAt` retrieves the number of tokens at a given block number\\n  /// @param checkpoints The history of values being queried\\n  /// @param _block The block number to retrieve the value at\\n  /// @return The number of tokens being queried\\n  function getValueAt(Checkpoint[] storage checkpoints, uint _block\\n  ) constant internal returns (uint) {\\n    if (checkpoints.length == 0) return 0;\\n\\n    // Shortcut for the actual value\\n    if (_block \\u003e= checkpoints[checkpoints.length-1].fromBlock)\\n      return checkpoints[checkpoints.length-1].value;\\n    if (_block \\u003c checkpoints[0].fromBlock) return 0;\\n\\n    // Binary search of the value in the array\\n    uint min = 0;\\n    uint max = checkpoints.length-1;\\n    while (max \\u003e min) {\\n      uint mid = (max + min + 1)/ 2;\\n      if (checkpoints[mid].fromBlock\\u003c=_block) {\\n        min = mid;\\n      } else {\\n        max = mid-1;\\n      }\\n    }\\n    return checkpoints[min].value;\\n  }\\n\\n  /// @dev `updateValueAtNow` used to update the `balances` map and the\\n  ///  `totalSupplyHistory`\\n  /// @param checkpoints The history of data being updated\\n  /// @param _value The new number of tokens\\n  function updateValueAtNow(Checkpoint[] storage checkpoints, uint _value\\n  ) internal  {\\n    if ((checkpoints.length == 0)\\n      || (checkpoints[checkpoints.length -1].fromBlock \\u003c block.number)) {\\n      Checkpoint storage newCheckPoint = checkpoints[ checkpoints.length++ ];\\n      newCheckPoint.fromBlock =  uint128(block.number);\\n      newCheckPoint.value = uint128(_value);\\n    } else {\\n      Checkpoint storage oldCheckPoint = checkpoints[checkpoints.length-1];\\n      oldCheckPoint.value = uint128(_value);\\n    }\\n  }\\n\\n  /// @dev Internal function to determine if an address is a contract\\n  /// @param _addr The address being queried\\n  /// @return True if `_addr` is a contract\\n  function isContract(address _addr) constant internal returns(bool) {\\n    uint size;\\n    if (_addr == 0) return false;\\n    assembly {\\n      size := extcodesize(_addr)\\n    }\\n    return size\\u003e0;\\n  }\\n\\n  /// @dev Helper function to return a min betwen the two uints\\n  function min(uint a, uint b) pure internal returns (uint) {\\n    return a \\u003c b ? a : b;\\n  }\\n\\n  /// @notice The fallback function: If the contract\\u0027s controller has not been\\n  ///  set to 0, then the `proxyPayment` method is called which relays the\\n  ///  ether and creates tokens as described in the token controller contract\\n  function () public payable {\\n    require(isContract(controller));\\n    require(TokenController(controller).proxyPayment.value(msg.value)(msg.sender));\\n  }\\n\\n  //////////\\n  // Safety Methods\\n  //////////\\n\\n  /// @notice This method can be used by the controller to extract mistakenly\\n  ///  sent tokens to this contract.\\n  /// @param _token The address of the token contract that you want to recover\\n  ///  set to 0 in case you want to extract ether.\\n  function claimTokens(address _token) public onlyController {\\n    if (_token == 0x0) {\\n      controller.transfer(this.balance);\\n      return;\\n    }\\n\\n    MiniMeToken token = MiniMeToken(_token);\\n    uint balance = token.balanceOf(this);\\n    token.transfer(controller, balance);\\n    ClaimedTokens(_token, controller, balance);\\n  }\\n\\n  ////////////////\\n  // Events\\n  ////////////////\\n  event ClaimedTokens(address indexed _token, address indexed _controller, uint _amount);\\n  event Transfer(address indexed _from, address indexed _to, uint256 _amount);\\n  event NewCloneToken(address indexed _cloneToken, uint _snapshotBlock);\\n  event Approval(\\n    address indexed _owner,\\n    address indexed _spender,\\n    uint256 _amount\\n  );\\n\\n}\\n\\n\\n////////////////\\n// MiniMeTokenFactory\\n////////////////\\n\\n/// @dev This contract is used to generate clone contracts from a contract.\\n///  In solidity this is the way to create a contract from a contract of the\\n///  same class\\ncontract MiniMeTokenFactory {\\n\\n  /// @notice Update the DApp by creating a new token with new functionalities\\n  ///  the msg.sender becomes the controller of this clone token\\n  /// @param _parentToken Address of the token being cloned\\n  /// @param _snapshotBlock Block of the parent token that will\\n  ///  determine the initial distribution of the clone token\\n  /// @param _tokenName Name of the new token\\n  /// @param _decimalUnits Number of decimals of the new token\\n  /// @param _tokenSymbol Token Symbol for the new token\\n  /// @param _transfersEnabled If true, tokens will be able to be transferred\\n  /// @return The address of the new token contract\\n  function createCloneToken(\\n    address _parentToken,\\n    uint _snapshotBlock,\\n    string _tokenName,\\n    uint8 _decimalUnits,\\n    string _tokenSymbol,\\n    bool _transfersEnabled\\n  ) public returns (MiniMeToken) {\\n    MiniMeToken newToken = new MiniMeToken(\\n      this,\\n      _parentToken,\\n      _snapshotBlock,\\n      _tokenName,\\n      _decimalUnits,\\n      _tokenSymbol,\\n      _transfersEnabled\\n    );\\n\\n    newToken.changeController(msg.sender);\\n    return newToken;\\n  }\\n}\\n\"},\"MutableForwarder.sol\":{\"content\":\"pragma solidity ^0.4.18;\\n\\nimport \\\"./DelegateProxy.sol\\\";\\nimport \\\"./DSAuth.sol\\\";\\n\\n/**\\n * @title Forwarder proxy contract with editable target\\n *\\n * @dev For TCR Registry contracts (Registry.sol, ParamChangeRegistry.sol) we use mutable forwarders instead of using\\n * contracts directly. This is for better upgradeability. Since registry contracts fire all events related to registry\\n * entries, we want to be able to access whole history of events always on the same address. Which would be address of\\n * a MutableForwarder. When a registry contract is replaced with updated one, mutable forwarder just replaces target\\n * and all events stay still accessible on the same address.\\n */\\n\\ncontract MutableForwarder is DelegateProxy, DSAuth {\\n\\n  address public target = 0xBEeFbeefbEefbeEFbeEfbEEfBEeFbeEfBeEfBeef; // checksumed to silence warning\\n\\n  /**\\n   * @dev Replaces targer forwarder contract is pointing to\\n   * Only authenticated user can replace target\\n\\n   * @param _target New target to proxy into\\n  */\\n  function setTarget(address _target) public auth {\\n    target = _target;\\n  }\\n\\n  function() payable {\\n    delegatedFwd(target, msg.data);\\n  }\\n\\n}\"},\"Registry.sol\":{\"content\":\"pragma solidity ^0.4.24;\\n\\nimport \\\"./DSAuth.sol\\\";\\nimport \\\"./EternalDb.sol\\\";\\nimport \\\"./MutableForwarder.sol\\\"; // Keep it included despite not being used (for compiler)\\n\\n/**\\n * @title Central contract for TCR registry\\n *\\n * @dev Manages state about deployed registry entries and factories\\n * Serves as a central point for firing all registry entry events\\n * This contract is not accessed directly, but through MutableForwarder. See MutableForwarder.sol for more comments.\\n */\\n\\ncontract Registry is DSAuth {\\n  address private dummyTarget; // Keep it here, because this contract is deployed as MutableForwarder\\n\\n  bytes32 public constant challengePeriodDurationKey = sha3(\\\"challengePeriodDuration\\\");\\n  bytes32 public constant commitPeriodDurationKey = sha3(\\\"commitPeriodDuration\\\");\\n  bytes32 public constant revealPeriodDurationKey = sha3(\\\"revealPeriodDuration\\\");\\n  bytes32 public constant depositKey = sha3(\\\"deposit\\\");\\n  bytes32 public constant challengeDispensationKey = sha3(\\\"challengeDispensation\\\");\\n  bytes32 public constant voteQuorumKey = sha3(\\\"voteQuorum\\\");\\n  bytes32 public constant maxTotalSupplyKey = sha3(\\\"maxTotalSupply\\\");\\n  bytes32 public constant maxAuctionDurationKey = sha3(\\\"maxAuctionDuration\\\");\\n\\n  event MemeConstructedEvent(address registryEntry, uint version, address creator, bytes metaHash, uint totalSupply, uint deposit, uint challengePeriodEnd);\\n  event MemeMintedEvent(address registryEntry, uint version, address creator, uint tokenStartId, uint tokenEndId, uint totalMinted);\\n\\n  event ChallengeCreatedEvent(address registryEntry, uint version, address challenger, uint commitPeriodEnd, uint revealPeriodEnd, uint rewardPool, bytes metahash);\\n  event VoteCommittedEvent(address registryEntry, uint version, address voter, uint amount);\\n  event VoteRevealedEvent(address registryEntry, uint version, address voter, uint option);\\n  event VoteAmountClaimedEvent(address registryEntry, uint version, address voter);\\n  event VoteRewardClaimedEvent(address registryEntry, uint version, address voter, uint amount);\\n  event ChallengeRewardClaimedEvent(address registryEntry, uint version, address challenger, uint amount);\\n\\n  event ParamChangeConstructedEvent(address registryEntry, uint version, address creator, address db, string key, uint value, uint deposit, uint challengePeriodEnd);\\n  event ParamChangeAppliedEvent(address registryEntry, uint version);\\n\\n  EternalDb public db;\\n  bool private wasConstructed;\\n\\n  /**\\n   * @dev Constructor for this contract.\\n   * Native constructor is not used, because we use a forwarder pointing to single instance of this contract,\\n   * therefore constructor must be called explicitly.\\n\\n   * @param _db Address of EternalDb related to this registry\\n   */\\n  function construct(EternalDb _db)\\n  external\\n  {\\n    require(address(_db) != 0x0, \\\"Registry: Address can\\u0027t be 0x0\\\");\\n\\n    db = _db;\\n    wasConstructed = true;\\n    owner = msg.sender;\\n  }\\n\\n  modifier onlyFactory() {\\n    require(isFactory(msg.sender), \\\"Registry: Sender should be factory\\\");\\n    _;\\n  }\\n\\n  modifier onlyRegistryEntry() {\\n    require(isRegistryEntry(msg.sender), \\\"Registry: Sender should registry entry\\\");\\n    _;\\n  }\\n\\n  modifier notEmergency() {\\n    require(!isEmergency(),\\\"Registry: Emergency mode is enable\\\");\\n    _;\\n  }\\n\\n  /**\\n   * @dev Sets whether address is factory allowed to add registry entries into registry\\n   * Must be callable only by authenticated user\\n\\n   * @param _factory Address of a factory contract\\n   * @param _isFactory Whether the address is allowed factory\\n   */\\n  function setFactory(address _factory, bool _isFactory)\\n  external\\n  auth\\n  {\\n    db.setBooleanValue(sha3(\\\"isFactory\\\", _factory), _isFactory);\\n  }\\n\\n  /**\\n   * @dev Adds address as valid registry entry into the Registry\\n   * Must be callable only by allowed factory contract\\n\\n   * @param _registryEntry Address of new registry entry\\n   */\\n  function addRegistryEntry(address _registryEntry)\\n  external\\n  onlyFactory\\n  notEmergency\\n  {\\n    db.setBooleanValue(sha3(\\\"isRegistryEntry\\\", _registryEntry), true);\\n  }\\n\\n  /**\\n   * @dev Sets emergency state to pause all trading operations\\n   * Must be callable only by authenticated user\\n\\n   * @param _isEmergency True if emergency is happening\\n   */\\n  function setEmergency(bool _isEmergency)\\n  external\\n  auth\\n  {\\n    db.setBooleanValue(\\\"isEmergency\\\", _isEmergency);\\n  }\\n\\n  function fireMemeConstructedEvent(uint version, address creator, bytes metaHash, uint totalSupply, uint deposit, uint challengePeriodEnd)\\n  public\\n  onlyRegistryEntry\\n  {\\n    emit MemeConstructedEvent(msg.sender, version, creator, metaHash, totalSupply, deposit, challengePeriodEnd);\\n  }\\n\\n  function fireMemeMintedEvent(uint version, address creator, uint tokenStartId, uint tokenEndId, uint totalMinted)\\n  public\\n  onlyRegistryEntry\\n  {\\n    emit MemeMintedEvent(msg.sender, version, creator, tokenStartId, tokenEndId, totalMinted);\\n  }\\n\\n  function fireChallengeCreatedEvent(uint version, address challenger, uint commitPeriodEnd, uint revealPeriodEnd, uint rewardPool, bytes metahash)\\n  public\\n  onlyRegistryEntry\\n  {\\n    emit ChallengeCreatedEvent(msg.sender, version,  challenger, commitPeriodEnd, revealPeriodEnd, rewardPool, metahash);\\n  }\\n\\n  function fireVoteCommittedEvent(uint version, address voter, uint amount)\\n  public\\n  onlyRegistryEntry\\n  {\\n    emit VoteCommittedEvent(msg.sender, version, voter, amount);\\n  }\\n\\n  function fireVoteRevealedEvent(uint version, address voter, uint option)\\n  public\\n  onlyRegistryEntry\\n  {\\n    emit VoteRevealedEvent(msg.sender, version, voter, option);\\n  }\\n\\n  function fireVoteAmountClaimedEvent(uint version, address voter)\\n  public\\n  onlyRegistryEntry\\n  {\\n    emit VoteAmountClaimedEvent(msg.sender, version, voter);\\n  }\\n\\n  function fireVoteRewardClaimedEvent(uint version, address voter, uint amount)\\n  public\\n  onlyRegistryEntry\\n  {\\n    emit VoteRewardClaimedEvent(msg.sender, version, voter, amount);\\n  }\\n\\n  function fireChallengeRewardClaimedEvent(uint version, address challenger, uint amount)\\n  public\\n  onlyRegistryEntry\\n  {\\n    emit ChallengeRewardClaimedEvent(msg.sender, version, challenger, amount);\\n  }\\n\\n  function fireParamChangeConstructedEvent(uint version, address creator, address db, string key, uint value, uint deposit, uint challengePeriodEnd)\\n  public\\n  onlyRegistryEntry\\n  {\\n    emit ParamChangeConstructedEvent(msg.sender, version, creator, db, key, value, deposit, challengePeriodEnd);\\n  }\\n\\n  function fireParamChangeAppliedEvent(uint version)\\n  public\\n  onlyRegistryEntry\\n  {\\n    emit ParamChangeAppliedEvent(msg.sender, version);\\n  }\\n\\n  /**\\n   * @dev Returns whether address is valid registry entry factory\\n\\n   * @return True if address is factory\\n   */\\n  function isFactory(address factory) public constant returns (bool) {\\n    return db.getBooleanValue(sha3(\\\"isFactory\\\", factory));\\n  }\\n\\n  /**\\n   * @dev Returns whether address is valid registry entry\\n\\n   * @return True if address is registry entry\\n   */\\n  function isRegistryEntry(address registryEntry) public constant returns (bool) {\\n    return db.getBooleanValue(sha3(\\\"isRegistryEntry\\\", registryEntry));\\n  }\\n\\n  /**\\n   * @dev Returns whether emergency stop is happening\\n\\n   * @return True if emergency is happening\\n   */\\n  function isEmergency() public constant returns (bool) {\\n    return db.getBooleanValue(\\\"isEmergency\\\");\\n  }\\n}\\n\"},\"RegistryEntry.sol\":{\"content\":\"pragma solidity ^0.4.24;\\n\\nimport \\\"./Registry.sol\\\";\\nimport \\\"./MiniMeToken.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./RegistryEntryLib.sol\\\";\\n\\n/**\\n * @title Contract created with each submission to a TCR\\n *\\n * @dev It contains all state and logic related to TCR challenging and voting\\n * Full copy of this contract is NOT deployed with each submission in order to save gas. Only forwarder contracts\\n * pointing into single instance of it.\\n * This contract is meant to be extended by domain specific registry entry contracts (Meme, ParamChange)\\n */\\n\\ncontract RegistryEntry is ApproveAndCallFallBack {\\n  using SafeMath for uint;\\n  using RegistryEntryLib for RegistryEntryLib.Challenge;\\n\\n  Registry internal constant registry = Registry(0xe278b85a36f6b370347d69fb4744947e2965c058);\\n  MiniMeToken internal constant registryToken = MiniMeToken(0x0cb8d0b37c7487b11d57f1f33defa2b1d3cfccfe);\\n\\n  address internal creator;\\n  uint internal version;\\n  uint internal deposit;\\n  RegistryEntryLib.Challenge internal challenge;\\n\\n  /**\\n   * @dev Modifier that disables function if registry is in emergency state\\n   */\\n  modifier notEmergency() {\\n    require(!registry.isEmergency());\\n    _;\\n  }\\n\\n  /**\\n   * @dev Modifier that disables function if challenge is not whitelisted\\n   */\\n  modifier onlyWhitelisted() {\\n    require(challenge.isWhitelisted());\\n    _;\\n  }\\n\\n  /**\\n   * @dev Constructor for this contract.\\n   * Native constructor is not used, because users create only forwarders into single instance of this contract,\\n   * therefore constructor must be called explicitly.\\n   * Must NOT be callable multiple times\\n   * Transfers TCR entry token deposit from sender into this contract\\n\\n   * @param _creator Creator of a meme\\n   * @param _version Version of Meme contract\\n   */\\n  function construct(\\n                     address _creator,\\n                     uint _version\\n                     )\\n    public\\n  {\\n    require(challenge.challengePeriodEnd == 0);\\n    deposit = registry.db().getUIntValue(registry.depositKey());\\n    require(registryToken.transferFrom(msg.sender, this, deposit));\\n\\n    challenge.challengePeriodEnd = now.add(registry.db().getUIntValue(registry.challengePeriodDurationKey()));\\n\\n    creator = _creator;\\n    version = _version;\\n  }\\n\\n  /**\\n   * @dev Creates a challenge for this TCR entry\\n   * Must be within challenge period\\n   * Entry can be challenged only once\\n   * Transfers token deposit from challenger into this contract\\n   * Forks registry token (DankToken) in order to create single purpose voting token to vote about this challenge\\n\\n   * @param _challenger Address of a challenger\\n   * @param _challengeMetaHash IPFS hash of meta data related to this challenge\\n   */\\n  function createChallenge(\\n                           address _challenger,\\n                           bytes _challengeMetaHash\\n                           )\\n    external\\n    notEmergency\\n  {\\n    require(challenge.isChallengePeriodActive());\\n    require(!challenge.wasChallenged());\\n    require(registryToken.transferFrom(_challenger, this, deposit));\\n\\n    challenge.challenger = _challenger;\\n    challenge.voteQuorum = registry.db().getUIntValue(registry.voteQuorumKey());\\n    uint commitDuration = registry.db().getUIntValue(registry.commitPeriodDurationKey());\\n    uint revealDuration = registry.db().getUIntValue(registry.revealPeriodDurationKey());\\n\\n    challenge.commitPeriodEnd = now.add(commitDuration);\\n    challenge.revealPeriodEnd = challenge.commitPeriodEnd.add(revealDuration);\\n    challenge.rewardPool = uint(100).sub(registry.db().getUIntValue(registry.challengeDispensationKey())).mul(deposit).div(uint(100));\\n    challenge.metaHash = _challengeMetaHash;\\n\\n    registry.fireChallengeCreatedEvent(version,\\n                                       challenge.challenger,\\n                                       challenge.commitPeriodEnd,\\n                                       challenge.revealPeriodEnd,\\n                                       challenge.rewardPool,\\n                                       challenge.metaHash);\\n  }\\n\\n  /**\\n   * @dev Commits encrypted vote to challenged entry\\n   * Locks voter\\u0027s tokens in this contract. Returns when vote is revealed\\n   * Must be within commit period\\n   * Same address can\\u0027t make a second vote for the same challenge\\n\\n   * @param _voter Address of a voter\\n   * @param _amount Amount of tokens to vote with\\n   * @param _secretHash Encrypted vote option with salt. sha3(voteOption, salt)\\n   */\\n  function commitVote(\\n                      address _voter,\\n                      uint _amount,\\n                      bytes32 _secretHash\\n                      )\\n    external\\n    notEmergency\\n  {\\n    require(challenge.isVoteCommitPeriodActive());\\n    require(_amount \\u003e 0);\\n    require(!challenge.hasVoted(_voter));\\n    require(registryToken.transferFrom(_voter, this, _amount));\\n\\n    challenge.vote[_voter].secretHash = _secretHash;\\n    challenge.vote[_voter].amount += _amount;\\n\\n    registry.fireVoteCommittedEvent(version,\\n                                    _voter,\\n                                    challenge.vote[_voter].amount);\\n  }\\n\\n  /**\\n   * @dev Reveals previously committed vote\\n   * Returns registryToken back to the voter\\n   * Must be within reveal period\\n\\n   * @param _voteOption Vote option voter previously voted with\\n   * @param _salt Salt with which user previously encrypted his vote option\\n   */\\n  function revealVote(\\n                      RegistryEntryLib.VoteOption _voteOption,\\n                      string _salt\\n                      )\\n    external\\n    notEmergency\\n  {\\n    address _voter=msg.sender;\\n    require(challenge.isVoteRevealPeriodActive());\\n    require(keccak256(abi.encodePacked(uint(_voteOption), _salt)) == challenge.vote[_voter].secretHash);\\n    require(!challenge.isVoteRevealed(_voter));\\n\\n    challenge.vote[_voter].revealedOn = now;\\n    uint amount = challenge.vote[_voter].amount;\\n    require(registryToken.transfer(_voter, amount));\\n    challenge.vote[_voter].option = _voteOption;\\n\\n    if (_voteOption == RegistryEntryLib.VoteOption.VoteFor) {\\n      challenge.votesFor = challenge.votesFor.add(amount);\\n    } else if (_voteOption == RegistryEntryLib.VoteOption.VoteAgainst) {\\n      challenge.votesAgainst = challenge.votesAgainst.add(amount);\\n    } else {\\n      revert();\\n    }\\n\\n    registry.fireVoteRevealedEvent(version,\\n                                   _voter,\\n                                   uint(challenge.vote[_voter].option));\\n  }\\n\\n   /**\\n   * @dev Refunds vote deposit after reveal period\\n   * Can be called by anybody, to claim voter\\u0027s reward to him\\n   * Can\\u0027t be called if vote was revealed\\n   * Can\\u0027t be called twice for the same vote\\n   * @param _voter Address of a voter\\n   */\\n  function reclaimVoteAmount(address _voter)\\n    public\\n    notEmergency {\\n\\n    require(challenge.isVoteRevealPeriodOver());\\n    require(!challenge.isVoteRevealed(_voter));\\n    require(!challenge.isVoteAmountReclaimed(_voter));\\n\\n    uint amount = challenge.vote[_voter].amount;\\n    require(registryToken.transfer(_voter, amount));\\n\\n    challenge.vote[_voter].reclaimedVoteAmountOn = now;\\n\\n    registry.fireVoteAmountClaimedEvent(version, _voter);\\n  }\\n\\n\\n  /**\\n   * @dev Claims vote reward after reveal period\\n   * Voter has reward only if voted for winning option\\n   * Voter has reward only when revealed the vote\\n   *\\n   * Claims challenger\\u0027s reward after reveal period\\n   * Challenger has reward only if winning option is VoteAgainst\\n\\n   */\\n  function claimRewards(address _user)\\n    external\\n    notEmergency\\n  {\\n    // Challenge reward\\n    if(challenge.isVoteRevealPeriodOver() \\u0026\\u0026\\n       !challenge.isChallengeRewardClaimed() \\u0026\\u0026\\n       !challenge.isWinningOptionVoteFor() \\u0026\\u0026\\n       challenge.challenger == _user){\\n\\n      registryToken.transfer(challenge.challenger, challenge.challengeReward(deposit));\\n\\n      registry.fireChallengeRewardClaimedEvent(version,\\n                                               challenge.challenger,\\n                                               challenge.challengeReward(deposit));\\n    }\\n\\n    // Votes reward\\n    if(challenge.isVoteRevealPeriodOver() \\u0026\\u0026\\n       !challenge.isVoteRewardClaimed(_user) \\u0026\\u0026\\n       challenge.isVoteRevealed(_user) \\u0026\\u0026\\n       challenge.votedWinningVoteOption(_user)){\\n\\n      uint reward = challenge.voteReward(_user);\\n\\n      if(reward \\u003e 0){\\n        registryToken.transfer(_user, reward);\\n        challenge.vote[_user].claimedRewardOn = now;\\n\\n        registry.fireVoteRewardClaimedEvent(version,\\n                                            _user,\\n                                            reward);\\n      }\\n    }\\n  }\\n\\n  /**\\n   * @dev Function returns the current status of this registry entry\\n   */\\n  function status()\\n    external\\n    constant\\n    returns (uint)\\n  {\\n    return uint(challenge.status());\\n  }\\n\\n  /**\\n   * @dev Function called by MiniMeToken when somebody calls approveAndCall on it.\\n   * This way token can be transferred to a recipient in a single transaction together with execution\\n   * of additional logic\\n\\n   * @param _from Sender of transaction approval\\n   * @param _amount Amount of approved tokens to transfer\\n   * @param _token Token that received the approval\\n   * @param _data Bytecode of a function and passed parameters, that should be called after token approval\\n   */\\n  function receiveApproval(\\n                           address _from,\\n                           uint256 _amount,\\n                           address _token,\\n                           bytes _data)\\n    public\\n  {\\n    require(address(this).call(_data));\\n  }\\n\\n  function load() external constant returns (uint,\\n                                             address,\\n                                             uint,\\n                                             address,\\n                                             uint,\\n                                             uint,\\n                                             uint,\\n                                             uint,\\n                                             bytes,\\n                                             uint){\\n    return (deposit,\\n            creator,\\n            version,\\n            challenge.challenger,\\n            challenge.voteQuorum,\\n            challenge.commitPeriodEnd,\\n            challenge.revealPeriodEnd,\\n            challenge.rewardPool,\\n            challenge.metaHash,\\n            challenge.claimedRewardOn);\\n  }\\n\\n  function loadVote(address voter) external constant returns (bytes32,\\n                                                              uint,\\n                                                              uint,\\n                                                              uint,\\n                                                              uint,\\n                                                              uint){\\n    return(challenge.vote[voter].secretHash,\\n           uint(challenge.vote[voter].option),\\n           challenge.vote[voter].amount,\\n           challenge.vote[voter].revealedOn,\\n           challenge.vote[voter].claimedRewardOn,\\n           challenge.vote[voter].reclaimedVoteAmountOn);\\n  }\\n}\\n\"},\"RegistryEntryFactory.sol\":{\"content\":\"pragma solidity ^0.4.24;\\n\\nimport \\\"./Registry.sol\\\";\\nimport \\\"./Forwarder.sol\\\";\\nimport \\\"./MiniMeToken.sol\\\";\\n\\n/**\\n * @title Base Factory contract for creating RegistryEntry contracts\\n *\\n * @dev This contract is meant to be extended by other factory contracts\\n */\\n\\ncontract RegistryEntryFactory is ApproveAndCallFallBack {\\n  Registry public registry;\\n  MiniMeToken public registryToken;\\n\\n  function RegistryEntryFactory(Registry _registry, MiniMeToken _registryToken) {\\n    registry = _registry;\\n    registryToken = _registryToken;\\n  }\\n\\n  /**\\n   * @dev Creates new forwarder contract as registry entry\\n   * Transfers required deposit from creator into this contract\\n   * Approves new registry entry address to transfer deposit to itself\\n   * Adds new registry entry address into the registry\\n\\n   * @param _creator Creator of registry entry\\n   * @return Address of a new registry entry forwarder contract\\n   */\\n  function createRegistryEntry(address _creator) internal returns (address) {\\n    uint deposit = registry.db().getUIntValue(registry.depositKey());\\n    address regEntry = new Forwarder();\\n    require(registryToken.transferFrom(_creator, this, deposit), \\\"RegistryEntryFactory: couldn\\u0027t transfer deposit\\\");\\n    require(registryToken.approve(regEntry, deposit), \\\"RegistryEntryFactory: Deposit not approved\\\");\\n    registry.addRegistryEntry(regEntry);\\n    return regEntry;\\n  }\\n\\n  /**\\n   * @dev Function called by MiniMeToken when somebody calls approveAndCall on it.\\n   * This way token can be transferred to a recipient in a single transaction together with execution\\n   * of additional logic\\n\\n   * @param _from Sender of transaction approval\\n   * @param _amount Amount of approved tokens to transfer\\n   * @param _token Token that received the approval\\n   * @param _data Bytecode of a function and passed parameters, that should be called after token approval\\n   */\\n  function receiveApproval(\\n    address _from,\\n    uint256 _amount,\\n    address _token,\\n    bytes _data)\\n  public\\n  {\\n    require(this.call(_data), \\\"RegistryEntryFactory: couldn\\u0027t call data\\\");\\n  }\\n}\\n\"},\"RegistryEntryLib.sol\":{\"content\":\"pragma solidity ^0.4.24;\\n\\nimport \\\"./Registry.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\n\\nlibrary RegistryEntryLib {\\n\\n  using SafeMath for uint;\\n\\n  enum VoteOption {NoVote, VoteFor, VoteAgainst}\\n\\n  enum Status {ChallengePeriod, CommitPeriod, RevealPeriod, Blacklisted, Whitelisted}\\n\\n  struct Vote {\\n    bytes32 secretHash;\\n    VoteOption option;\\n    uint amount;\\n    uint revealedOn;\\n    uint claimedRewardOn;\\n    uint reclaimedVoteAmountOn;\\n  }\\n\\n  struct Challenge {\\n    address challenger;\\n    uint voteQuorum;\\n    uint rewardPool;\\n    bytes metaHash;\\n    uint commitPeriodEnd;\\n    uint revealPeriodEnd;\\n    uint challengePeriodEnd;\\n    uint votesFor;\\n    uint votesAgainst;\\n    uint claimedRewardOn;\\n    mapping(address =\\u003e Vote) vote;\\n  }\\n\\n  // External functions\\n\\n  /**\\n   * @dev Returns date when registry entry was whitelisted\\n   * Since this doesn\\u0027t happen with any transaction, it\\u0027s either reveal or challenge period end\\n\\n   * @return UNIX time of whitelisting\\n   */\\n  /* function whitelistedOn(Challenge storage self) */\\n  /*   external */\\n  /*   constant */\\n  /*   returns (uint) { */\\n  /*   if (!isWhitelisted()) { */\\n  /*     return 0; */\\n  /*   } */\\n  /*   if (self.wasChallenged()) { */\\n  /*     return self.revealPeriodEnd; */\\n  /*   } else { */\\n  /*     return challengePeriodEnd; */\\n  /*   } */\\n  /* } */\\n\\n  // Internal functions\\n\\n  function isVoteRevealPeriodActive(Challenge storage self)\\n    internal\\n    constant\\n    returns (bool) {\\n    return !isVoteCommitPeriodActive(self) \\u0026\\u0026 now \\u003c= self.revealPeriodEnd;\\n  }\\n\\n  function isVoteRevealed(Challenge storage self, address _voter)\\n    internal\\n    constant\\n    returns (bool) {\\n    return self.vote[_voter].revealedOn \\u003e 0;\\n  }\\n\\n  function isVoteRewardClaimed(Challenge storage self, address _voter)\\n    internal\\n    constant\\n    returns (bool) {\\n    return self.vote[_voter].claimedRewardOn \\u003e 0;\\n  }\\n\\n  function isVoteAmountReclaimed(Challenge storage self, address _voter)\\n    internal\\n    constant\\n    returns (bool) {\\n    return self.vote[_voter].reclaimedVoteAmountOn \\u003e 0;\\n  }\\n\\n  function isChallengeRewardClaimed(Challenge storage self)\\n    internal\\n    constant\\n    returns (bool) {\\n    return self.claimedRewardOn \\u003e 0;\\n  }\\n\\n  function isChallengePeriodActive(Challenge storage self)\\n    internal\\n    constant\\n    returns (bool) {\\n    return now \\u003c= self.challengePeriodEnd;\\n  }\\n\\n  function isWhitelisted(Challenge storage self)\\n    internal\\n    constant\\n    returns (bool) {\\n    return status(self) == Status.Whitelisted;\\n  }\\n\\n  function isVoteCommitPeriodActive(Challenge storage self)\\n    internal\\n    constant\\n    returns (bool) {\\n    return now \\u003c= self.commitPeriodEnd;\\n  }\\n\\n  function isVoteRevealPeriodOver(Challenge storage self)\\n    internal\\n    constant\\n    returns (bool) {\\n    return self.revealPeriodEnd \\u003e 0 \\u0026\\u0026 now \\u003e self.revealPeriodEnd;\\n  }\\n\\n  /**\\n   * @dev Returns whether VoteFor is winning vote option\\n   *\\n   * @return True if VoteFor is winning option\\n   */\\n  function isWinningOptionVoteFor(Challenge storage self)\\n    internal\\n    constant\\n    returns (bool) {\\n    return winningVoteOption(self) == VoteOption.VoteFor;\\n  }\\n\\n  function hasVoted(Challenge storage self, address _voter)\\n    internal\\n    constant\\n    returns (bool) {\\n    return self.vote[_voter].amount != 0;\\n  }\\n\\n  function wasChallenged(Challenge storage self)\\n    internal\\n    constant\\n    returns (bool) {\\n    return self.challenger != 0x0;\\n  }\\n\\n  /**\\n   * @dev Returns whether voter voted for winning vote option\\n   * @param _voter Address of a voter\\n   *\\n   * @return True if voter voted for a winning vote option\\n   */\\n  function votedWinningVoteOption(Challenge storage self, address _voter)\\n    internal\\n    constant\\n    returns (bool) {\\n    return self.vote[_voter].option == winningVoteOption(self);\\n  }\\n\\n  /**\\n   * @dev Returns current status of a registry entry\\n\\n   * @return Status\\n   */\\n  function status(Challenge storage self)\\n    internal\\n    constant\\n    returns (Status) {\\n    if (isChallengePeriodActive(self) \\u0026\\u0026 !wasChallenged(self)) {\\n      return Status.ChallengePeriod;\\n    } else if (isVoteCommitPeriodActive(self)) {\\n      return Status.CommitPeriod;\\n    } else if (isVoteRevealPeriodActive(self)) {\\n      return Status.RevealPeriod;\\n    } else if (isVoteRevealPeriodOver(self)) {\\n      if (isWinningOptionVoteFor(self)) {\\n        return Status.Whitelisted;\\n      } else {\\n        return Status.Blacklisted;\\n      }\\n    } else {\\n      return Status.Whitelisted;\\n    }\\n  }\\n\\n  /**\\n   * @dev Returns token reward amount belonging to a challenger\\n   *\\n   * @return Amount of token\\n   */\\n  function challengeReward(Challenge storage self, uint deposit)\\n    internal\\n    constant\\n    returns (uint) {\\n    return deposit.sub(self.rewardPool);\\n  }\\n\\n  /**\\n   * @dev Returns token reward amount belonging to a voter for voting for a winning option\\n   * @param _voter Address of a voter\\n   *\\n   * @return Amount of tokens\\n   */\\n  function voteReward(Challenge storage self, address _voter)\\n    internal\\n    constant\\n    returns (uint) {\\n    uint winningAmount = winningVotesAmount(self);\\n    uint voterAmount = 0;\\n\\n    if (!votedWinningVoteOption(self, _voter)) {\\n      return voterAmount;\\n    }\\n\\n    voterAmount = self.vote[_voter].amount;\\n    return (voterAmount.mul(self.rewardPool)) / winningAmount;\\n  }\\n\\n  /**\\n   * @dev Returns true when parameter key is in a whitelisted set and the parameter\\n   * value is within the allowed set of values.\\n   */\\n  function isChangeAllowed(Registry registry, bytes32 record, uint _value)\\n    internal\\n    constant\\n    returns (bool) {\\n\\n      if(record == registry.challengePeriodDurationKey() || record == registry.commitPeriodDurationKey() ||\\n         record == registry.revealPeriodDurationKey() || record == registry.depositKey()) {\\n        if(_value \\u003e 0) {\\n          return true;\\n        }\\n      }\\n\\n      if(record == registry.challengeDispensationKey() || record == registry.voteQuorumKey() ||\\n         record == registry.maxTotalSupplyKey()) {\\n        if (_value \\u003e= 0 \\u0026\\u0026 _value \\u003c= 100) {\\n          return true;\\n        }\\n      }\\n\\n      // see MemeAuction.sol startAuction\\n      if(record == registry.maxAuctionDurationKey()) {\\n        if(_value \\u003e= 1 minutes) {\\n          return true;\\n        }\\n      }\\n\\n    return false;\\n  }\\n\\n\\n  function bytesToUint(bytes b)\\n    internal\\n    returns (uint256) {\\n    uint256 number;\\n    for(uint i = 0; i \\u003c b.length; i++){\\n      number = number + uint(b[i]) * (2 ** (8 * (b.length - (i + 1))));\\n    }\\n    return number;\\n  }\\n\\n  function stringToUint(string s)\\n    internal\\n    constant\\n    returns (uint result) {\\n    bytes memory b = bytes(s);\\n    uint i;\\n    result = 0;\\n    for (i = 0; i \\u003c b.length; i++) {\\n      uint c = uint(b[i]);\\n      if (c \\u003e= 48 \\u0026\\u0026 c \\u003c= 57) {\\n        result = result * 10 + (c - 48);\\n      }\\n    }\\n  }\\n\\n  // Private functions\\n\\n  function isBlacklisted(Challenge storage self)\\n    private\\n    constant\\n    returns (bool) {\\n    return status(self) == Status.Blacklisted;\\n  }\\n\\n  /**\\n   * @dev Returns winning vote option in held voting according to vote quorum\\n   * If voteQuorum is 50, any majority of votes will win\\n   * If voteQuorum is 24, only 25 votes out of 100 is enough to VoteFor be winning option\\n   *\\n   * @return Winning vote option\\n   */\\n  function winningVoteOption(Challenge storage self)\\n    private\\n    constant\\n    returns (VoteOption) {\\n    if (!isVoteRevealPeriodOver(self)) {\\n      return VoteOption.NoVote;\\n    }\\n\\n    if (self.votesFor.mul(100) \\u003e self.voteQuorum.mul(self.votesFor.add(self.votesAgainst))) {\\n      return VoteOption.VoteFor;\\n    } else {\\n      return VoteOption.VoteAgainst;\\n    }\\n  }\\n\\n  /**\\n   * @dev Returns amount of votes for winning vote option\\n   *\\n   * @return Amount of votes\\n   */\\n  function winningVotesAmount(Challenge storage self)\\n    private\\n    constant\\n    returns (uint) {\\n    VoteOption voteOption = winningVoteOption(self);\\n\\n    if (voteOption == VoteOption.VoteFor) {\\n      return self.votesFor;\\n    } else if (voteOption == VoteOption.VoteAgainst) {\\n      return self.votesAgainst;\\n    } else {\\n      return 0;\\n    }\\n  }\\n\\n}\\n\"},\"SafeMath.sol\":{\"content\":\"pragma solidity ^0.4.18;\\n\\n\\n/**\\n * @title SafeMath\\n * @dev Math operations with safety checks that throw on error\\n */\\nlibrary SafeMath {\\n\\n  /**\\n  * @dev Multiplies two numbers, throws on overflow.\\n  */\\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n    if (a == 0) {\\n      return 0;\\n    }\\n    uint256 c = a * b;\\n    assert(c / a == b);\\n    return c;\\n  }\\n\\n  /**\\n  * @dev Integer division of two numbers, truncating the quotient.\\n  */\\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n    // assert(b \\u003e 0); // Solidity automatically throws when dividing by 0\\n    uint256 c = a / b;\\n    // assert(a == b * c + a % b); // There is no case in which this doesn\\u0027t hold\\n    return c;\\n  }\\n\\n  /**\\n  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\\n  */\\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n    assert(b \\u003c= a);\\n    return a - b;\\n  }\\n\\n  /**\\n  * @dev Adds two numbers, throws on overflow.\\n  */\\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n    uint256 c = a + b;\\n    assert(c \\u003e= a);\\n    return c;\\n  }\\n}\\n\"},\"TokenController.sol\":{\"content\":\"pragma solidity ^0.4.18;\\n\\n/// @dev The token controller contract must implement these functions\\ncontract TokenController {\\n  /// @notice Called when `_owner` sends ether to the MiniMe Token contract\\n  /// @param _owner The address that sent the ether to create tokens\\n  /// @return True if the ether is accepted, false if it throws\\n  function proxyPayment(address _owner) public payable returns(bool);\\n\\n  /// @notice Notifies the controller about a token transfer allowing the\\n  ///  controller to react if desired\\n  /// @param _from The origin of the transfer\\n  /// @param _to The destination of the transfer\\n  /// @param _amount The amount of the transfer\\n  /// @return False if the controller does not authorize the transfer\\n  function onTransfer(address _from, address _to, uint _amount) public returns(bool);\\n\\n  /// @notice Notifies the controller about an approval allowing the\\n  ///  controller to react if desired\\n  /// @param _owner The address that calls `approve()`\\n  /// @param _spender The spender in the `approve()` call\\n  /// @param _amount The amount in the `approve()` call\\n  /// @return False if the controller does not authorize the approval\\n  function onApprove(address _owner, address _spender, uint _amount) public\\n  returns(bool);\\n}\\n\"}}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_creator\",\"type\":\"address\"},{\"name\":\"_metaHash\",\"type\":\"bytes\"},{\"name\":\"_totalSupply\",\"type\":\"uint256\"}],\"name\":\"createMeme\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"registryToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"registry\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"receiveApproval\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"memeToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_registry\",\"type\":\"address\"},{\"name\":\"_registryToken\",\"type\":\"address\"},{\"name\":\"_memeToken\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"}]","ContractName":"MemeFactory","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000e278b85a36f6b370347d69fb4744947e2965c0580000000000000000000000000cb8d0b37c7487b11d57f1f33defa2b1d3cfccfe000000000000000000000000d23043ce917ac39309f49dba82f264994d3ade76","Library":"","SwarmSource":"bzzr://7cf04a84a085e062817552fa05ee75e2f92f136ea4074f7ad7b24b265c4b7e22"}]}