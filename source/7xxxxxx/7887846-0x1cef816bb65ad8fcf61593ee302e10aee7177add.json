{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity >=0.5.4 <0.6.0;\r\n\r\ninterface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes calldata _extraData) external; }\r\n\r\n\r\ncontract TheAO {\r\n\taddress public theAO;\r\n\taddress public nameTAOPositionAddress;\r\n\r\n\t// Check whether an address is whitelisted and granted access to transact\r\n\t// on behalf of others\r\n\tmapping (address => bool) public whitelist;\r\n\r\n\tconstructor() public {\r\n\t\ttheAO = msg.sender;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Checks if msg.sender is in whitelist.\r\n\t */\r\n\tmodifier inWhitelist() {\r\n\t\trequire (whitelist[msg.sender] == true);\r\n\t\t_;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Transfer ownership of The AO to new address\r\n\t * @param _theAO The new address to be transferred\r\n\t */\r\n\tfunction transferOwnership(address _theAO) public {\r\n\t\trequire (msg.sender == theAO);\r\n\t\trequire (_theAO != address(0));\r\n\t\ttheAO = _theAO;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Whitelist `_account` address to transact on behalf of others\r\n\t * @param _account The address to whitelist\r\n\t * @param _whitelist Either to whitelist or not\r\n\t */\r\n\tfunction setWhitelist(address _account, bool _whitelist) public {\r\n\t\trequire (msg.sender == theAO);\r\n\t\trequire (_account != address(0));\r\n\t\twhitelist[_account] = _whitelist;\r\n\t}\r\n}\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n\t/**\r\n\t * @dev Multiplies two numbers, throws on overflow.\r\n\t */\r\n\tfunction mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n\t\t// Gas optimization: this is cheaper than asserting 'a' not being zero, but the\r\n\t\t// benefit is lost if 'b' is also tested.\r\n\t\t// See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n\t\tif (a == 0) {\r\n\t\t\treturn 0;\r\n\t\t}\r\n\r\n\t\tc = a * b;\r\n\t\tassert(c / a == b);\r\n\t\treturn c;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Integer division of two numbers, truncating the quotient.\r\n\t */\r\n\tfunction div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\t\t// assert(b > 0); // Solidity automatically throws when dividing by 0\r\n\t\t// uint256 c = a / b;\r\n\t\t// assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\t\treturn a / b;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n\t */\r\n\tfunction sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\t\tassert(b <= a);\r\n\t\treturn a - b;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Adds two numbers, throws on overflow.\r\n\t */\r\n\tfunction add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n\t\tc = a + b;\r\n\t\tassert(c >= a);\r\n\t\treturn c;\r\n\t}\r\n}\r\n\r\n\r\ninterface INameAccountRecovery {\r\n\tfunction isCompromised(address _id) external view returns (bool);\r\n}\r\n\r\n\r\ninterface INamePublicKey {\r\n\tfunction initialize(address _id, address _defaultKey, address _writerKey) external returns (bool);\r\n\r\n\tfunction isKeyExist(address _id, address _key) external view returns (bool);\r\n\r\n\tfunction getDefaultKey(address _id) external view returns (address);\r\n\r\n\tfunction whitelistAddKey(address _id, address _key) external returns (bool);\r\n}\r\n\r\n\r\ninterface INameTAOPosition {\r\n\tfunction senderIsAdvocate(address _sender, address _id) external view returns (bool);\r\n\tfunction senderIsListener(address _sender, address _id) external view returns (bool);\r\n\tfunction senderIsSpeaker(address _sender, address _id) external view returns (bool);\r\n\tfunction senderIsPosition(address _sender, address _id) external view returns (bool);\r\n\tfunction getAdvocate(address _id) external view returns (address);\r\n\tfunction nameIsAdvocate(address _nameId, address _id) external view returns (bool);\r\n\tfunction nameIsPosition(address _nameId, address _id) external view returns (bool);\r\n\tfunction initialize(address _id, address _advocateId, address _listenerId, address _speakerId) external returns (bool);\r\n\tfunction determinePosition(address _sender, address _id) external view returns (uint256);\r\n}\r\n\r\n\r\ninterface IAOSetting {\r\n\tfunction getSettingValuesByTAOName(address _taoId, string calldata _settingName) external view returns (uint256, bool, address, bytes32, string memory);\r\n\tfunction getSettingTypes() external view returns (uint8, uint8, uint8, uint8, uint8);\r\n\r\n\tfunction settingTypeLookup(uint256 _settingId) external view returns (uint8);\r\n}\r\n\r\n\r\ninterface IAOIonLot {\r\n\tfunction createPrimordialLot(address _account, uint256 _primordialAmount, uint256 _multiplier, uint256 _networkBonusAmount) external returns (bytes32);\r\n\r\n\tfunction createWeightedMultiplierLot(address _account, uint256 _amount, uint256 _weightedMultiplier) external returns (bytes32);\r\n\r\n\tfunction lotById(bytes32 _lotId) external view returns (bytes32, address, uint256, uint256);\r\n\r\n\tfunction totalLotsByAddress(address _lotOwner) external view returns (uint256);\r\n\r\n\tfunction createBurnLot(address _account, uint256 _amount, uint256 _multiplierAfterBurn) external returns (bool);\r\n\r\n\tfunction createConvertLot(address _account, uint256 _amount, uint256 _multiplierAfterConversion) external returns (bool);\r\n}\r\n\r\n\r\n\r\n\r\ncontract TokenERC20 {\r\n\t// Public variables of the token\r\n\tstring public name;\r\n\tstring public symbol;\r\n\tuint8 public decimals = 18;\r\n\t// 18 decimals is the strongly suggested default, avoid changing it\r\n\tuint256 public totalSupply;\r\n\r\n\t// This creates an array with all balances\r\n\tmapping (address => uint256) public balanceOf;\r\n\tmapping (address => mapping (address => uint256)) public allowance;\r\n\r\n\t// This generates a public event on the blockchain that will notify clients\r\n\tevent Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n\t// This generates a public event on the blockchain that will notify clients\r\n\tevent Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n\r\n\t// This notifies clients about the amount burnt\r\n\tevent Burn(address indexed from, uint256 value);\r\n\r\n\t/**\r\n\t * Constructor function\r\n\t *\r\n\t * Initializes contract with initial supply tokens to the creator of the contract\r\n\t */\r\n\tconstructor (uint256 initialSupply, string memory tokenName, string memory tokenSymbol) public {\r\n\t\ttotalSupply = initialSupply * 10 ** uint256(decimals);  // Update total supply with the decimal amount\r\n\t\tbalanceOf[msg.sender] = totalSupply;                // Give the creator all initial tokens\r\n\t\tname = tokenName;                                   // Set the name for display purposes\r\n\t\tsymbol = tokenSymbol;                               // Set the symbol for display purposes\r\n\t}\r\n\r\n\t/**\r\n\t * Internal transfer, only can be called by this contract\r\n\t */\r\n\tfunction _transfer(address _from, address _to, uint _value) internal {\r\n\t\t// Prevent transfer to 0x0 address. Use burn() instead\r\n\t\trequire(_to != address(0));\r\n\t\t// Check if the sender has enough\r\n\t\trequire(balanceOf[_from] >= _value);\r\n\t\t// Check for overflows\r\n\t\trequire(balanceOf[_to] + _value > balanceOf[_to]);\r\n\t\t// Save this for an assertion in the future\r\n\t\tuint previousBalances = balanceOf[_from] + balanceOf[_to];\r\n\t\t// Subtract from the sender\r\n\t\tbalanceOf[_from] -= _value;\r\n\t\t// Add the same to the recipient\r\n\t\tbalanceOf[_to] += _value;\r\n\t\temit Transfer(_from, _to, _value);\r\n\t\t// Asserts are used to use static analysis to find bugs in your code. They should never fail\r\n\t\tassert(balanceOf[_from] + balanceOf[_to] == previousBalances);\r\n\t}\r\n\r\n\t/**\r\n\t * Transfer tokens\r\n\t *\r\n\t * Send `_value` tokens to `_to` from your account\r\n\t *\r\n\t * @param _to The address of the recipient\r\n\t * @param _value the amount to send\r\n\t */\r\n\tfunction transfer(address _to, uint256 _value) public returns (bool success) {\r\n\t\t_transfer(msg.sender, _to, _value);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * Transfer tokens from other address\r\n\t *\r\n\t * Send `_value` tokens to `_to` in behalf of `_from`\r\n\t *\r\n\t * @param _from The address of the sender\r\n\t * @param _to The address of the recipient\r\n\t * @param _value the amount to send\r\n\t */\r\n\tfunction transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\r\n\t\trequire(_value <= allowance[_from][msg.sender]);     // Check allowance\r\n\t\tallowance[_from][msg.sender] -= _value;\r\n\t\t_transfer(_from, _to, _value);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * Set allowance for other address\r\n\t *\r\n\t * Allows `_spender` to spend no more than `_value` tokens in your behalf\r\n\t *\r\n\t * @param _spender The address authorized to spend\r\n\t * @param _value the max amount they can spend\r\n\t */\r\n\tfunction approve(address _spender, uint256 _value) public returns (bool success) {\r\n\t\tallowance[msg.sender][_spender] = _value;\r\n\t\temit Approval(msg.sender, _spender, _value);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * Set allowance for other address and notify\r\n\t *\r\n\t * Allows `_spender` to spend no more than `_value` tokens in your behalf, and then ping the contract about it\r\n\t *\r\n\t * @param _spender The address authorized to spend\r\n\t * @param _value the max amount they can spend\r\n\t * @param _extraData some extra information to send to the approved contract\r\n\t */\r\n\tfunction approveAndCall(address _spender, uint256 _value, bytes memory _extraData) public returns (bool success) {\r\n\t\ttokenRecipient spender = tokenRecipient(_spender);\r\n\t\tif (approve(_spender, _value)) {\r\n\t\t\tspender.receiveApproval(msg.sender, _value, address(this), _extraData);\r\n\t\t\treturn true;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Destroy tokens\r\n\t *\r\n\t * Remove `_value` tokens from the system irreversibly\r\n\t *\r\n\t * @param _value the amount of money to burn\r\n\t */\r\n\tfunction burn(uint256 _value) public returns (bool success) {\r\n\t\trequire(balanceOf[msg.sender] >= _value);   // Check if the sender has enough\r\n\t\tbalanceOf[msg.sender] -= _value;            // Subtract from the sender\r\n\t\ttotalSupply -= _value;                      // Updates totalSupply\r\n\t\temit Burn(msg.sender, _value);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * Destroy tokens from other account\r\n\t *\r\n\t * Remove `_value` tokens from the system irreversibly on behalf of `_from`.\r\n\t *\r\n\t * @param _from the address of the sender\r\n\t * @param _value the amount of money to burn\r\n\t */\r\n\tfunction burnFrom(address _from, uint256 _value) public returns (bool success) {\r\n\t\trequire(balanceOf[_from] >= _value);                // Check if the targeted balance is enough\r\n\t\trequire(_value <= allowance[_from][msg.sender]);    // Check allowance\r\n\t\tbalanceOf[_from] -= _value;                         // Subtract from the targeted balance\r\n\t\tallowance[_from][msg.sender] -= _value;             // Subtract from the sender's allowance\r\n\t\ttotalSupply -= _value;                              // Update totalSupply\r\n\t\temit Burn(_from, _value);\r\n\t\treturn true;\r\n\t}\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title TAO\r\n */\r\ncontract TAO {\r\n\tusing SafeMath for uint256;\r\n\r\n\taddress public vaultAddress;\r\n\tstring public name;\t\t\t\t// the name for this TAO\r\n\taddress public originId;\t\t// the ID of the Name that created this TAO. If Name, it's the eth address\r\n\r\n\t// TAO's data\r\n\tstring public datHash;\r\n\tstring public database;\r\n\tstring public keyValue;\r\n\tbytes32 public contentId;\r\n\r\n\t/**\r\n\t * 0 = TAO\r\n\t * 1 = Name\r\n\t */\r\n\tuint8 public typeId;\r\n\r\n\t/**\r\n\t * @dev Constructor function\r\n\t */\r\n\tconstructor (string memory _name,\r\n\t\taddress _originId,\r\n\t\tstring memory _datHash,\r\n\t\tstring memory _database,\r\n\t\tstring memory _keyValue,\r\n\t\tbytes32 _contentId,\r\n\t\taddress _vaultAddress\r\n\t) public {\r\n\t\tname = _name;\r\n\t\toriginId = _originId;\r\n\t\tdatHash = _datHash;\r\n\t\tdatabase = _database;\r\n\t\tkeyValue = _keyValue;\r\n\t\tcontentId = _contentId;\r\n\r\n\t\t// Creating TAO\r\n\t\ttypeId = 0;\r\n\r\n\t\tvaultAddress = _vaultAddress;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Checks if calling address is Vault contract\r\n\t */\r\n\tmodifier onlyVault {\r\n\t\trequire (msg.sender == vaultAddress);\r\n\t\t_;\r\n\t}\r\n\r\n\t/**\r\n\t * Will receive any ETH sent\r\n\t */\r\n\tfunction () external payable {\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Allows Vault to transfer `_amount` of ETH from this TAO to `_recipient`\r\n\t * @param _recipient The recipient address\r\n\t * @param _amount The amount to transfer\r\n\t * @return true on success\r\n\t */\r\n\tfunction transferEth(address payable _recipient, uint256 _amount) public onlyVault returns (bool) {\r\n\t\t_recipient.transfer(_amount);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Allows Vault to transfer `_amount` of ERC20 Token from this TAO to `_recipient`\r\n\t * @param _erc20TokenAddress The address of ERC20 Token\r\n\t * @param _recipient The recipient address\r\n\t * @param _amount The amount to transfer\r\n\t * @return true on success\r\n\t */\r\n\tfunction transferERC20(address _erc20TokenAddress, address _recipient, uint256 _amount) public onlyVault returns (bool) {\r\n\t\tTokenERC20 _erc20 = TokenERC20(_erc20TokenAddress);\r\n\t\t_erc20.transfer(_recipient, _amount);\r\n\t\treturn true;\r\n\t}\r\n}\r\n\r\n\r\n\r\n\r\n/**\r\n * @title Name\r\n */\r\ncontract Name is TAO {\r\n\t/**\r\n\t * @dev Constructor function\r\n\t */\r\n\tconstructor (string memory _name, address _originId, string memory _datHash, string memory _database, string memory _keyValue, bytes32 _contentId, address _vaultAddress)\r\n\t\tTAO (_name, _originId, _datHash, _database, _keyValue, _contentId, _vaultAddress) public {\r\n\t\t// Creating Name\r\n\t\ttypeId = 1;\r\n\t}\r\n}\r\n\r\n\r\n\r\n\r\n/**\r\n * @title AOLibrary\r\n */\r\nlibrary AOLibrary {\r\n\tusing SafeMath for uint256;\r\n\r\n\tuint256 constant private _MULTIPLIER_DIVISOR = 10 ** 6; // 1000000 = 1\r\n\tuint256 constant private _PERCENTAGE_DIVISOR = 10 ** 6; // 100% = 1000000\r\n\r\n\t/**\r\n\t * @dev Check whether or not the given TAO ID is a TAO\r\n\t * @param _taoId The ID of the TAO\r\n\t * @return true if yes. false otherwise\r\n\t */\r\n\tfunction isTAO(address _taoId) public view returns (bool) {\r\n\t\treturn (_taoId != address(0) && bytes(TAO(address(uint160(_taoId))).name()).length > 0 && TAO(address(uint160(_taoId))).originId() != address(0) && TAO(address(uint160(_taoId))).typeId() == 0);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Check whether or not the given Name ID is a Name\r\n\t * @param _nameId The ID of the Name\r\n\t * @return true if yes. false otherwise\r\n\t */\r\n\tfunction isName(address _nameId) public view returns (bool) {\r\n\t\treturn (_nameId != address(0) && bytes(TAO(address(uint160(_nameId))).name()).length > 0 && Name(address(uint160(_nameId))).originId() != address(0) && Name(address(uint160(_nameId))).typeId() == 1);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Check if `_tokenAddress` is a valid ERC20 Token address\r\n\t * @param _tokenAddress The ERC20 Token address to check\r\n\t */\r\n\tfunction isValidERC20TokenAddress(address _tokenAddress) public view returns (bool) {\r\n\t\tif (_tokenAddress == address(0)) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tTokenERC20 _erc20 = TokenERC20(_tokenAddress);\r\n\t\treturn (_erc20.totalSupply() >= 0 && bytes(_erc20.name()).length > 0 && bytes(_erc20.symbol()).length > 0);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Checks if the calling contract address is The AO\r\n\t *\t\tOR\r\n\t *\t\tIf The AO is set to a Name/TAO, then check if calling address is the Advocate\r\n\t * @param _sender The address to check\r\n\t * @param _theAO The AO address\r\n\t * @param _nameTAOPositionAddress The address of NameTAOPosition\r\n\t * @return true if yes, false otherwise\r\n\t */\r\n\tfunction isTheAO(address _sender, address _theAO, address _nameTAOPositionAddress) public view returns (bool) {\r\n\t\treturn (_sender == _theAO ||\r\n\t\t\t(\r\n\t\t\t\t(isTAO(_theAO) || isName(_theAO)) &&\r\n\t\t\t\t_nameTAOPositionAddress != address(0) &&\r\n\t\t\t\tINameTAOPosition(_nameTAOPositionAddress).senderIsAdvocate(_sender, _theAO)\r\n\t\t\t)\r\n\t\t);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Return the divisor used to correctly calculate percentage.\r\n\t *\t\tPercentage stored throughout AO contracts covers 4 decimals,\r\n\t *\t\tso 1% is 10000, 1.25% is 12500, etc\r\n\t */\r\n\tfunction PERCENTAGE_DIVISOR() public pure returns (uint256) {\r\n\t\treturn _PERCENTAGE_DIVISOR;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Return the divisor used to correctly calculate multiplier.\r\n\t *\t\tMultiplier stored throughout AO contracts covers 6 decimals,\r\n\t *\t\tso 1 is 1000000, 0.023 is 23000, etc\r\n\t */\r\n\tfunction MULTIPLIER_DIVISOR() public pure returns (uint256) {\r\n\t\treturn _MULTIPLIER_DIVISOR;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev deploy a TAO\r\n\t * @param _name The name of the TAO\r\n\t * @param _originId The Name ID the creates the TAO\r\n\t * @param _datHash The datHash of this TAO\r\n\t * @param _database The database for this TAO\r\n\t * @param _keyValue The key/value pair to be checked on the database\r\n\t * @param _contentId The contentId related to this TAO\r\n\t * @param _nameTAOVaultAddress The address of NameTAOVault\r\n\t */\r\n\tfunction deployTAO(string memory _name,\r\n\t\taddress _originId,\r\n\t\tstring memory _datHash,\r\n\t\tstring memory _database,\r\n\t\tstring memory _keyValue,\r\n\t\tbytes32 _contentId,\r\n\t\taddress _nameTAOVaultAddress\r\n\t\t) public returns (TAO _tao) {\r\n\t\t_tao = new TAO(_name, _originId, _datHash, _database, _keyValue, _contentId, _nameTAOVaultAddress);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev deploy a Name\r\n\t * @param _name The name of the Name\r\n\t * @param _originId The eth address the creates the Name\r\n\t * @param _datHash The datHash of this Name\r\n\t * @param _database The database for this Name\r\n\t * @param _keyValue The key/value pair to be checked on the database\r\n\t * @param _contentId The contentId related to this Name\r\n\t * @param _nameTAOVaultAddress The address of NameTAOVault\r\n\t */\r\n\tfunction deployName(string memory _name,\r\n\t\taddress _originId,\r\n\t\tstring memory _datHash,\r\n\t\tstring memory _database,\r\n\t\tstring memory _keyValue,\r\n\t\tbytes32 _contentId,\r\n\t\taddress _nameTAOVaultAddress\r\n\t\t) public returns (Name _myName) {\r\n\t\t_myName = new Name(_name, _originId, _datHash, _database, _keyValue, _contentId, _nameTAOVaultAddress);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Calculate the new weighted multiplier when adding `_additionalPrimordialAmount` at `_additionalWeightedMultiplier` to the current `_currentPrimordialBalance` at `_currentWeightedMultiplier`\r\n\t * @param _currentWeightedMultiplier Account's current weighted multiplier\r\n\t * @param _currentPrimordialBalance Account's current primordial ion balance\r\n\t * @param _additionalWeightedMultiplier The weighted multiplier to be added\r\n\t * @param _additionalPrimordialAmount The primordial ion amount to be added\r\n\t * @return the new primordial weighted multiplier\r\n\t */\r\n\tfunction calculateWeightedMultiplier(uint256 _currentWeightedMultiplier, uint256 _currentPrimordialBalance, uint256 _additionalWeightedMultiplier, uint256 _additionalPrimordialAmount) public pure returns (uint256) {\r\n\t\tif (_currentWeightedMultiplier > 0) {\r\n\t\t\tuint256 _totalWeightedIons = (_currentWeightedMultiplier.mul(_currentPrimordialBalance)).add(_additionalWeightedMultiplier.mul(_additionalPrimordialAmount));\r\n\t\t\tuint256 _totalIons = _currentPrimordialBalance.add(_additionalPrimordialAmount);\r\n\t\t\treturn _totalWeightedIons.div(_totalIons);\r\n\t\t} else {\r\n\t\t\treturn _additionalWeightedMultiplier;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Calculate the primordial ion multiplier on a given lot\r\n\t *\t\tTotal Primordial Mintable = T\r\n\t *\t\tTotal Primordial Minted = M\r\n\t *\t\tStarting Multiplier = S\r\n\t *\t\tEnding Multiplier = E\r\n\t *\t\tTo Purchase = P\r\n\t *\t\tMultiplier for next Lot of Amount = (1 - ((M + P/2) / T)) x (S-E)\r\n\t *\r\n\t * @param _purchaseAmount The amount of primordial ion intended to be purchased\r\n\t * @param _totalPrimordialMintable Total Primordial ion mintable\r\n\t * @param _totalPrimordialMinted Total Primordial ion minted so far\r\n\t * @param _startingMultiplier The starting multiplier in (10 ** 6)\r\n\t * @param _endingMultiplier The ending multiplier in (10 ** 6)\r\n\t * @return The multiplier in (10 ** 6)\r\n\t */\r\n\tfunction calculatePrimordialMultiplier(uint256 _purchaseAmount, uint256 _totalPrimordialMintable, uint256 _totalPrimordialMinted, uint256 _startingMultiplier, uint256 _endingMultiplier) public pure returns (uint256) {\r\n\t\tif (_purchaseAmount > 0 && _purchaseAmount <= _totalPrimordialMintable.sub(_totalPrimordialMinted)) {\r\n\t\t\t/**\r\n\t\t\t * Let temp = M + (P/2)\r\n\t\t\t * Multiplier = (1 - (temp / T)) x (S-E)\r\n\t\t\t */\r\n\t\t\tuint256 temp = _totalPrimordialMinted.add(_purchaseAmount.div(2));\r\n\r\n\t\t\t/**\r\n\t\t\t * Multiply multiplier with _MULTIPLIER_DIVISOR/_MULTIPLIER_DIVISOR to account for 6 decimals\r\n\t\t\t * so, Multiplier = (_MULTIPLIER_DIVISOR/_MULTIPLIER_DIVISOR) * (1 - (temp / T)) * (S-E)\r\n\t\t\t * Multiplier = ((_MULTIPLIER_DIVISOR * (1 - (temp / T))) * (S-E)) / _MULTIPLIER_DIVISOR\r\n\t\t\t * Multiplier = ((_MULTIPLIER_DIVISOR - ((_MULTIPLIER_DIVISOR * temp) / T)) * (S-E)) / _MULTIPLIER_DIVISOR\r\n\t\t\t * Take out the division by _MULTIPLIER_DIVISOR for now and include in later calculation\r\n\t\t\t * Multiplier = (_MULTIPLIER_DIVISOR - ((_MULTIPLIER_DIVISOR * temp) / T)) * (S-E)\r\n\t\t\t */\r\n\t\t\tuint256 multiplier = (_MULTIPLIER_DIVISOR.sub(_MULTIPLIER_DIVISOR.mul(temp).div(_totalPrimordialMintable))).mul(_startingMultiplier.sub(_endingMultiplier));\r\n\t\t\t/**\r\n\t\t\t * Since _startingMultiplier and _endingMultiplier are in 6 decimals\r\n\t\t\t * Need to divide multiplier by _MULTIPLIER_DIVISOR\r\n\t\t\t */\r\n\t\t\treturn multiplier.div(_MULTIPLIER_DIVISOR);\r\n\t\t} else {\r\n\t\t\treturn 0;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Calculate the bonus percentage of network ion on a given lot\r\n\t *\t\tTotal Primordial Mintable = T\r\n\t *\t\tTotal Primordial Minted = M\r\n\t *\t\tStarting Network Bonus Multiplier = Bs\r\n\t *\t\tEnding Network Bonus Multiplier = Be\r\n\t *\t\tTo Purchase = P\r\n\t *\t\tAO Bonus % = B% = (1 - ((M + P/2) / T)) x (Bs-Be)\r\n\t *\r\n\t * @param _purchaseAmount The amount of primordial ion intended to be purchased\r\n\t * @param _totalPrimordialMintable Total Primordial ion intable\r\n\t * @param _totalPrimordialMinted Total Primordial ion minted so far\r\n\t * @param _startingMultiplier The starting Network ion bonus multiplier\r\n\t * @param _endingMultiplier The ending Network ion bonus multiplier\r\n\t * @return The bonus percentage\r\n\t */\r\n\tfunction calculateNetworkBonusPercentage(uint256 _purchaseAmount, uint256 _totalPrimordialMintable, uint256 _totalPrimordialMinted, uint256 _startingMultiplier, uint256 _endingMultiplier) public pure returns (uint256) {\r\n\t\tif (_purchaseAmount > 0 && _purchaseAmount <= _totalPrimordialMintable.sub(_totalPrimordialMinted)) {\r\n\t\t\t/**\r\n\t\t\t * Let temp = M + (P/2)\r\n\t\t\t * B% = (1 - (temp / T)) x (Bs-Be)\r\n\t\t\t */\r\n\t\t\tuint256 temp = _totalPrimordialMinted.add(_purchaseAmount.div(2));\r\n\r\n\t\t\t/**\r\n\t\t\t * Multiply B% with _PERCENTAGE_DIVISOR/_PERCENTAGE_DIVISOR to account for 6 decimals\r\n\t\t\t * so, B% = (_PERCENTAGE_DIVISOR/_PERCENTAGE_DIVISOR) * (1 - (temp / T)) * (Bs-Be)\r\n\t\t\t * B% = ((_PERCENTAGE_DIVISOR * (1 - (temp / T))) * (Bs-Be)) / _PERCENTAGE_DIVISOR\r\n\t\t\t * B% = ((_PERCENTAGE_DIVISOR - ((_PERCENTAGE_DIVISOR * temp) / T)) * (Bs-Be)) / _PERCENTAGE_DIVISOR\r\n\t\t\t * Take out the division by _PERCENTAGE_DIVISOR for now and include in later calculation\r\n\t\t\t * B% = (_PERCENTAGE_DIVISOR - ((_PERCENTAGE_DIVISOR * temp) / T)) * (Bs-Be)\r\n\t\t\t * But since Bs and Be are in 6 decimals, need to divide by _PERCENTAGE_DIVISOR\r\n\t\t\t * B% = (_PERCENTAGE_DIVISOR - ((_PERCENTAGE_DIVISOR * temp) / T)) * (Bs-Be) / _PERCENTAGE_DIVISOR\r\n\t\t\t */\r\n\t\t\tuint256 bonusPercentage = (_PERCENTAGE_DIVISOR.sub(_PERCENTAGE_DIVISOR.mul(temp).div(_totalPrimordialMintable))).mul(_startingMultiplier.sub(_endingMultiplier)).div(_PERCENTAGE_DIVISOR);\r\n\t\t\treturn bonusPercentage;\r\n\t\t} else {\r\n\t\t\treturn 0;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Calculate the bonus amount of network ion on a given lot\r\n\t *\t\tAO Bonus Amount = B% x P\r\n\t *\r\n\t * @param _purchaseAmount The amount of primordial ion intended to be purchased\r\n\t * @param _totalPrimordialMintable Total Primordial ion intable\r\n\t * @param _totalPrimordialMinted Total Primordial ion minted so far\r\n\t * @param _startingMultiplier The starting Network ion bonus multiplier\r\n\t * @param _endingMultiplier The ending Network ion bonus multiplier\r\n\t * @return The bonus percentage\r\n\t */\r\n\tfunction calculateNetworkBonusAmount(uint256 _purchaseAmount, uint256 _totalPrimordialMintable, uint256 _totalPrimordialMinted, uint256 _startingMultiplier, uint256 _endingMultiplier) public pure returns (uint256) {\r\n\t\tuint256 bonusPercentage = calculateNetworkBonusPercentage(_purchaseAmount, _totalPrimordialMintable, _totalPrimordialMinted, _startingMultiplier, _endingMultiplier);\r\n\t\t/**\r\n\t\t * Since bonusPercentage is in _PERCENTAGE_DIVISOR format, need to divide it with _PERCENTAGE DIVISOR\r\n\t\t * when calculating the network ion bonus amount\r\n\t\t */\r\n\t\tuint256 networkBonus = bonusPercentage.mul(_purchaseAmount).div(_PERCENTAGE_DIVISOR);\r\n\t\treturn networkBonus;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Calculate the maximum amount of Primordial an account can burn\r\n\t *\t\t_primordialBalance = P\r\n\t *\t\t_currentWeightedMultiplier = M\r\n\t *\t\t_maximumMultiplier = S\r\n\t *\t\t_amountToBurn = B\r\n\t *\t\tB = ((S x P) - (P x M)) / S\r\n\t *\r\n\t * @param _primordialBalance Account's primordial ion balance\r\n\t * @param _currentWeightedMultiplier Account's current weighted multiplier\r\n\t * @param _maximumMultiplier The maximum multiplier of this account\r\n\t * @return The maximum burn amount\r\n\t */\r\n\tfunction calculateMaximumBurnAmount(uint256 _primordialBalance, uint256 _currentWeightedMultiplier, uint256 _maximumMultiplier) public pure returns (uint256) {\r\n\t\treturn (_maximumMultiplier.mul(_primordialBalance).sub(_primordialBalance.mul(_currentWeightedMultiplier))).div(_maximumMultiplier);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Calculate the new multiplier after burning primordial ion\r\n\t *\t\t_primordialBalance = P\r\n\t *\t\t_currentWeightedMultiplier = M\r\n\t *\t\t_amountToBurn = B\r\n\t *\t\t_newMultiplier = E\r\n\t *\t\tE = (P x M) / (P - B)\r\n\t *\r\n\t * @param _primordialBalance Account's primordial ion balance\r\n\t * @param _currentWeightedMultiplier Account's current weighted multiplier\r\n\t * @param _amountToBurn The amount of primordial ion to burn\r\n\t * @return The new multiplier\r\n\t */\r\n\tfunction calculateMultiplierAfterBurn(uint256 _primordialBalance, uint256 _currentWeightedMultiplier, uint256 _amountToBurn) public pure returns (uint256) {\r\n\t\treturn _primordialBalance.mul(_currentWeightedMultiplier).div(_primordialBalance.sub(_amountToBurn));\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Calculate the new multiplier after converting network ion to primordial ion\r\n\t *\t\t_primordialBalance = P\r\n\t *\t\t_currentWeightedMultiplier = M\r\n\t *\t\t_amountToConvert = C\r\n\t *\t\t_newMultiplier = E\r\n\t *\t\tE = (P x M) / (P + C)\r\n\t *\r\n\t * @param _primordialBalance Account's primordial ion balance\r\n\t * @param _currentWeightedMultiplier Account's current weighted multiplier\r\n\t * @param _amountToConvert The amount of network ion to convert\r\n\t * @return The new multiplier\r\n\t */\r\n\tfunction calculateMultiplierAfterConversion(uint256 _primordialBalance, uint256 _currentWeightedMultiplier, uint256 _amountToConvert) public pure returns (uint256) {\r\n\t\treturn _primordialBalance.mul(_currentWeightedMultiplier).div(_primordialBalance.add(_amountToConvert));\r\n\t}\r\n\r\n\t/**\r\n\t * @dev count num of digits\r\n\t * @param number uint256 of the nuumber to be checked\r\n\t * @return uint8 num of digits\r\n\t */\r\n\tfunction numDigits(uint256 number) public pure returns (uint8) {\r\n\t\tuint8 digits = 0;\r\n\t\twhile(number != 0) {\r\n\t\t\tnumber = number.div(10);\r\n\t\t\tdigits++;\r\n\t\t}\r\n\t\treturn digits;\r\n\t}\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ninterface ionRecipient {\r\n\tfunction receiveApproval(address _from, uint256 _value, address _token, bytes calldata _extraData) external;\r\n}\r\n\r\n/**\r\n * @title AOIonInterface\r\n */\r\ncontract AOIonInterface is TheAO {\r\n\tusing SafeMath for uint256;\r\n\r\n\taddress public namePublicKeyAddress;\r\n\taddress public nameAccountRecoveryAddress;\r\n\r\n\tINameTAOPosition internal _nameTAOPosition;\r\n\tINamePublicKey internal _namePublicKey;\r\n\tINameAccountRecovery internal _nameAccountRecovery;\r\n\r\n\t// Public variables of the contract\r\n\tstring public name;\r\n\tstring public symbol;\r\n\tuint8 public decimals;\r\n\tuint256 public totalSupply;\r\n\r\n\t// To differentiate denomination of AO\r\n\tuint256 public powerOfTen;\r\n\r\n\t/***** NETWORK ION VARIABLES *****/\r\n\tuint256 public sellPrice;\r\n\tuint256 public buyPrice;\r\n\r\n\t// This creates an array with all balances\r\n\tmapping (address => uint256) public balanceOf;\r\n\tmapping (address => mapping (address => uint256)) public allowance;\r\n\tmapping (address => bool) public frozenAccount;\r\n\tmapping (address => uint256) public stakedBalance;\r\n\tmapping (address => uint256) public escrowedBalance;\r\n\r\n\t// This generates a public event on the blockchain that will notify clients\r\n\tevent FrozenFunds(address target, bool frozen);\r\n\tevent Stake(address indexed from, uint256 value);\r\n\tevent Unstake(address indexed from, uint256 value);\r\n\tevent Escrow(address indexed from, address indexed to, uint256 value);\r\n\tevent Unescrow(address indexed from, uint256 value);\r\n\r\n\t// This generates a public event on the blockchain that will notify clients\r\n\tevent Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n\t// This generates a public event on the blockchain that will notify clients\r\n\tevent Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n\r\n\t// This notifies clients about the amount burnt\r\n\tevent Burn(address indexed from, uint256 value);\r\n\r\n\t/**\r\n\t * @dev Constructor function\r\n\t */\r\n\tconstructor(string memory _name, string memory _symbol, address _nameTAOPositionAddress, address _namePublicKeyAddress, address _nameAccountRecoveryAddress) public {\r\n\t\tsetNameTAOPositionAddress(_nameTAOPositionAddress);\r\n\t\tsetNamePublicKeyAddress(_namePublicKeyAddress);\r\n\t\tsetNameAccountRecoveryAddress(_nameAccountRecoveryAddress);\r\n\t\tname = _name;           // Set the name for display purposes\r\n\t\tsymbol = _symbol;       // Set the symbol for display purposes\r\n\t\tpowerOfTen = 0;\r\n\t\tdecimals = 0;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Checks if the calling contract address is The AO\r\n\t *\t\tOR\r\n\t *\t\tIf The AO is set to a Name/TAO, then check if calling address is the Advocate\r\n\t */\r\n\tmodifier onlyTheAO {\r\n\t\trequire (AOLibrary.isTheAO(msg.sender, theAO, nameTAOPositionAddress));\r\n\t\t_;\r\n\t}\r\n\r\n\t/***** The AO ONLY METHODS *****/\r\n\t/**\r\n\t * @dev Transfer ownership of The AO to new address\r\n\t * @param _theAO The new address to be transferred\r\n\t */\r\n\tfunction transferOwnership(address _theAO) public onlyTheAO {\r\n\t\trequire (_theAO != address(0));\r\n\t\ttheAO = _theAO;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Whitelist `_account` address to transact on behalf of others\r\n\t * @param _account The address to whitelist\r\n\t * @param _whitelist Either to whitelist or not\r\n\t */\r\n\tfunction setWhitelist(address _account, bool _whitelist) public onlyTheAO {\r\n\t\trequire (_account != address(0));\r\n\t\twhitelist[_account] = _whitelist;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev The AO set the NameTAOPosition Address\r\n\t * @param _nameTAOPositionAddress The address of NameTAOPosition\r\n\t */\r\n\tfunction setNameTAOPositionAddress(address _nameTAOPositionAddress) public onlyTheAO {\r\n\t\trequire (_nameTAOPositionAddress != address(0));\r\n\t\tnameTAOPositionAddress = _nameTAOPositionAddress;\r\n\t\t_nameTAOPosition = INameTAOPosition(nameTAOPositionAddress);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev The AO set the NamePublicKey Address\r\n\t * @param _namePublicKeyAddress The address of NamePublicKey\r\n\t */\r\n\tfunction setNamePublicKeyAddress(address _namePublicKeyAddress) public onlyTheAO {\r\n\t\trequire (_namePublicKeyAddress != address(0));\r\n\t\tnamePublicKeyAddress = _namePublicKeyAddress;\r\n\t\t_namePublicKey = INamePublicKey(namePublicKeyAddress);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev The AO set the NameAccountRecovery Address\r\n\t * @param _nameAccountRecoveryAddress The address of NameAccountRecovery\r\n\t */\r\n\tfunction setNameAccountRecoveryAddress(address _nameAccountRecoveryAddress) public onlyTheAO {\r\n\t\trequire (_nameAccountRecoveryAddress != address(0));\r\n\t\tnameAccountRecoveryAddress = _nameAccountRecoveryAddress;\r\n\t\t_nameAccountRecovery = INameAccountRecovery(nameAccountRecoveryAddress);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Allows TheAO to transfer `_amount` of ETH from this address to `_recipient`\r\n\t * @param _recipient The recipient address\r\n\t * @param _amount The amount to transfer\r\n\t */\r\n\tfunction transferEth(address payable _recipient, uint256 _amount) public onlyTheAO {\r\n\t\trequire (_recipient != address(0));\r\n\t\t_recipient.transfer(_amount);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Prevent/Allow target from sending & receiving ions\r\n\t * @param target Address to be frozen\r\n\t * @param freeze Either to freeze it or not\r\n\t */\r\n\tfunction freezeAccount(address target, bool freeze) public onlyTheAO {\r\n\t\tfrozenAccount[target] = freeze;\r\n\t\temit FrozenFunds(target, freeze);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Allow users to buy ions for `newBuyPrice` eth and sell ions for `newSellPrice` eth\r\n\t * @param newSellPrice Price users can sell to the contract\r\n\t * @param newBuyPrice Price users can buy from the contract\r\n\t */\r\n\tfunction setPrices(uint256 newSellPrice, uint256 newBuyPrice) public onlyTheAO {\r\n\t\tsellPrice = newSellPrice;\r\n\t\tbuyPrice = newBuyPrice;\r\n\t}\r\n\r\n\t/***** NETWORK ION WHITELISTED ADDRESS ONLY METHODS *****/\r\n\t/**\r\n\t * @dev Create `mintedAmount` ions and send it to `target`\r\n\t * @param target Address to receive the ions\r\n\t * @param mintedAmount The amount of ions it will receive\r\n\t * @return true on success\r\n\t */\r\n\tfunction mint(address target, uint256 mintedAmount) public inWhitelist returns (bool) {\r\n\t\t_mint(target, mintedAmount);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Stake `_value` ions on behalf of `_from`\r\n\t * @param _from The address of the target\r\n\t * @param _value The amount to stake\r\n\t * @return true on success\r\n\t */\r\n\tfunction stakeFrom(address _from, uint256 _value) public inWhitelist returns (bool) {\r\n\t\trequire (balanceOf[_from] >= _value);\t\t\t\t\t\t// Check if the targeted balance is enough\r\n\t\tbalanceOf[_from] = balanceOf[_from].sub(_value);\t\t\t// Subtract from the targeted balance\r\n\t\tstakedBalance[_from] = stakedBalance[_from].add(_value);\t// Add to the targeted staked balance\r\n\t\temit Stake(_from, _value);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Unstake `_value` ions on behalf of `_from`\r\n\t * @param _from The address of the target\r\n\t * @param _value The amount to unstake\r\n\t * @return true on success\r\n\t */\r\n\tfunction unstakeFrom(address _from, uint256 _value) public inWhitelist returns (bool) {\r\n\t\trequire (stakedBalance[_from] >= _value);\t\t\t\t\t// Check if the targeted staked balance is enough\r\n\t\tstakedBalance[_from] = stakedBalance[_from].sub(_value);\t// Subtract from the targeted staked balance\r\n\t\tbalanceOf[_from] = balanceOf[_from].add(_value);\t\t\t// Add to the targeted balance\r\n\t\temit Unstake(_from, _value);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Store `_value` from `_from` to `_to` in escrow\r\n\t * @param _from The address of the sender\r\n\t * @param _to The address of the recipient\r\n\t * @param _value The amount of network ions to put in escrow\r\n\t * @return true on success\r\n\t */\r\n\tfunction escrowFrom(address _from, address _to, uint256 _value) public inWhitelist returns (bool) {\r\n\t\trequire (balanceOf[_from] >= _value);\t\t\t\t\t\t// Check if the targeted balance is enough\r\n\t\tbalanceOf[_from] = balanceOf[_from].sub(_value);\t\t\t// Subtract from the targeted balance\r\n\t\tescrowedBalance[_to] = escrowedBalance[_to].add(_value);\t// Add to the targeted escrowed balance\r\n\t\temit Escrow(_from, _to, _value);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Create `mintedAmount` ions and send it to `target` escrow balance\r\n\t * @param target Address to receive ions\r\n\t * @param mintedAmount The amount of ions it will receive in escrow\r\n\t */\r\n\tfunction mintEscrow(address target, uint256 mintedAmount) public inWhitelist returns (bool) {\r\n\t\tescrowedBalance[target] = escrowedBalance[target].add(mintedAmount);\r\n\t\ttotalSupply = totalSupply.add(mintedAmount);\r\n\t\temit Escrow(address(this), target, mintedAmount);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Release escrowed `_value` from `_from`\r\n\t * @param _from The address of the sender\r\n\t * @param _value The amount of escrowed network ions to be released\r\n\t * @return true on success\r\n\t */\r\n\tfunction unescrowFrom(address _from, uint256 _value) public inWhitelist returns (bool) {\r\n\t\trequire (escrowedBalance[_from] >= _value);\t\t\t\t\t\t// Check if the targeted escrowed balance is enough\r\n\t\tescrowedBalance[_from] = escrowedBalance[_from].sub(_value);\t// Subtract from the targeted escrowed balance\r\n\t\tbalanceOf[_from] = balanceOf[_from].add(_value);\t\t\t\t// Add to the targeted balance\r\n\t\temit Unescrow(_from, _value);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t *\r\n\t * @dev Whitelisted address remove `_value` ions from the system irreversibly on behalf of `_from`.\r\n\t *\r\n\t * @param _from the address of the sender\r\n\t * @param _value the amount of money to burn\r\n\t */\r\n\tfunction whitelistBurnFrom(address _from, uint256 _value) public inWhitelist returns (bool success) {\r\n\t\trequire(balanceOf[_from] >= _value);                // Check if the targeted balance is enough\r\n\t\tbalanceOf[_from] = balanceOf[_from].sub(_value);    // Subtract from the targeted balance\r\n\t\ttotalSupply = totalSupply.sub(_value);              // Update totalSupply\r\n\t\temit Burn(_from, _value);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Whitelisted address transfer ions from other address\r\n\t *\r\n\t * Send `_value` ions to `_to` on behalf of `_from`\r\n\t *\r\n\t * @param _from The address of the sender\r\n\t * @param _to The address of the recipient\r\n\t * @param _value the amount to send\r\n\t */\r\n\tfunction whitelistTransferFrom(address _from, address _to, uint256 _value) public inWhitelist returns (bool success) {\r\n\t\t_transfer(_from, _to, _value);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/***** PUBLIC METHODS *****/\r\n\t/**\r\n\t * Transfer ions\r\n\t *\r\n\t * Send `_value` ions to `_to` from your account\r\n\t *\r\n\t * @param _to The address of the recipient\r\n\t * @param _value the amount to send\r\n\t */\r\n\tfunction transfer(address _to, uint256 _value) public returns (bool success) {\r\n\t\t_transfer(msg.sender, _to, _value);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * Transfer ions from other address\r\n\t *\r\n\t * Send `_value` ions to `_to` in behalf of `_from`\r\n\t *\r\n\t * @param _from The address of the sender\r\n\t * @param _to The address of the recipient\r\n\t * @param _value the amount to send\r\n\t */\r\n\tfunction transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\r\n\t\trequire(_value <= allowance[_from][msg.sender]);     // Check allowance\r\n\t\tallowance[_from][msg.sender] -= _value;\r\n\t\t_transfer(_from, _to, _value);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * Transfer ions between public key addresses in a Name\r\n\t * @param _nameId The ID of the Name\r\n\t * @param _from The address of the sender\r\n\t * @param _to The address of the recipient\r\n\t * @param _value the amount to send\r\n\t */\r\n\tfunction transferBetweenPublicKeys(address _nameId, address _from, address _to, uint256 _value) public returns (bool success) {\r\n\t\trequire (AOLibrary.isName(_nameId));\r\n\t\trequire (_nameTAOPosition.senderIsAdvocate(msg.sender, _nameId));\r\n\t\trequire (!_nameAccountRecovery.isCompromised(_nameId));\r\n\t\t// Make sure _from exist in the Name's Public Keys\r\n\t\trequire (_namePublicKey.isKeyExist(_nameId, _from));\r\n\t\t// Make sure _to exist in the Name's Public Keys\r\n\t\trequire (_namePublicKey.isKeyExist(_nameId, _to));\r\n\t\t_transfer(_from, _to, _value);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * Set allowance for other address\r\n\t *\r\n\t * Allows `_spender` to spend no more than `_value` ions in your behalf\r\n\t *\r\n\t * @param _spender The address authorized to spend\r\n\t * @param _value the max amount they can spend\r\n\t */\r\n\tfunction approve(address _spender, uint256 _value) public returns (bool success) {\r\n\t\tallowance[msg.sender][_spender] = _value;\r\n\t\temit Approval(msg.sender, _spender, _value);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * Set allowance for other address and notify\r\n\t *\r\n\t * Allows `_spender` to spend no more than `_value` ions in your behalf, and then ping the contract about it\r\n\t *\r\n\t * @param _spender The address authorized to spend\r\n\t * @param _value the max amount they can spend\r\n\t * @param _extraData some extra information to send to the approved contract\r\n\t */\r\n\tfunction approveAndCall(address _spender, uint256 _value, bytes memory _extraData) public returns (bool success) {\r\n\t\tionRecipient spender = ionRecipient(_spender);\r\n\t\tif (approve(_spender, _value)) {\r\n\t\t\tspender.receiveApproval(msg.sender, _value, address(this), _extraData);\r\n\t\t\treturn true;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Destroy ions\r\n\t *\r\n\t * Remove `_value` ions from the system irreversibly\r\n\t *\r\n\t * @param _value the amount of money to burn\r\n\t */\r\n\tfunction burn(uint256 _value) public returns (bool success) {\r\n\t\trequire(balanceOf[msg.sender] >= _value);   // Check if the sender has enough\r\n\t\tbalanceOf[msg.sender] -= _value;            // Subtract from the sender\r\n\t\ttotalSupply -= _value;                      // Updates totalSupply\r\n\t\temit Burn(msg.sender, _value);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * Destroy ions from other account\r\n\t *\r\n\t * Remove `_value` ions from the system irreversibly on behalf of `_from`.\r\n\t *\r\n\t * @param _from the address of the sender\r\n\t * @param _value the amount of money to burn\r\n\t */\r\n\tfunction burnFrom(address _from, uint256 _value) public returns (bool success) {\r\n\t\trequire(balanceOf[_from] >= _value);                // Check if the targeted balance is enough\r\n\t\trequire(_value <= allowance[_from][msg.sender]);    // Check allowance\r\n\t\tbalanceOf[_from] -= _value;                         // Subtract from the targeted balance\r\n\t\tallowance[_from][msg.sender] -= _value;             // Subtract from the sender's allowance\r\n\t\ttotalSupply -= _value;                              // Update totalSupply\r\n\t\temit Burn(_from, _value);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Buy ions from contract by sending ether\r\n\t */\r\n\tfunction buy() public payable {\r\n\t\trequire (buyPrice > 0);\r\n\t\tuint256 amount = msg.value.div(buyPrice);\r\n\t\t_transfer(address(this), msg.sender, amount);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Sell `amount` ions to contract\r\n\t * @param amount The amount of ions to be sold\r\n\t */\r\n\tfunction sell(uint256 amount) public {\r\n\t\trequire (sellPrice > 0);\r\n\t\taddress myAddress = address(this);\r\n\t\trequire (myAddress.balance >= amount.mul(sellPrice));\r\n\t\t_transfer(msg.sender, address(this), amount);\r\n\t\tmsg.sender.transfer(amount.mul(sellPrice));\r\n\t}\r\n\r\n\t/***** INTERNAL METHODS *****/\r\n\t/**\r\n\t * @dev Send `_value` ions from `_from` to `_to`\r\n\t * @param _from The address of sender\r\n\t * @param _to The address of the recipient\r\n\t * @param _value The amount to send\r\n\t */\r\n\tfunction _transfer(address _from, address _to, uint256 _value) internal {\r\n\t\trequire (_to != address(0));\t\t\t\t\t\t\t// Prevent transfer to 0x0 address. Use burn() instead\r\n\t\trequire (balanceOf[_from] >= _value);\t\t\t\t\t// Check if the sender has enough\r\n\t\trequire (balanceOf[_to].add(_value) >= balanceOf[_to]); // Check for overflows\r\n\t\trequire (!frozenAccount[_from]);\t\t\t\t\t\t// Check if sender is frozen\r\n\t\trequire (!frozenAccount[_to]);\t\t\t\t\t\t\t// Check if recipient is frozen\r\n\t\tuint256 previousBalances = balanceOf[_from].add(balanceOf[_to]);\r\n\t\tbalanceOf[_from] = balanceOf[_from].sub(_value);        // Subtract from the sender\r\n\t\tbalanceOf[_to] = balanceOf[_to].add(_value);            // Add the same to the recipient\r\n\t\temit Transfer(_from, _to, _value);\r\n\t\tassert(balanceOf[_from].add(balanceOf[_to]) == previousBalances);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Create `mintedAmount` ions and send it to `target`\r\n\t * @param target Address to receive the ions\r\n\t * @param mintedAmount The amount of ions it will receive\r\n\t */\r\n\tfunction _mint(address target, uint256 mintedAmount) internal {\r\n\t\tbalanceOf[target] = balanceOf[target].add(mintedAmount);\r\n\t\ttotalSupply = totalSupply.add(mintedAmount);\r\n\t\temit Transfer(address(0), address(this), mintedAmount);\r\n\t\temit Transfer(address(this), target, mintedAmount);\r\n\t}\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title AOETH\r\n */\r\ncontract AOETH is TheAO, TokenERC20, tokenRecipient {\r\n\tusing SafeMath for uint256;\r\n\r\n\taddress public aoIonAddress;\r\n\r\n\tAOIon internal _aoIon;\r\n\r\n\tuint256 public totalERC20Tokens;\r\n\tuint256 public totalTokenExchanges;\r\n\r\n\tstruct ERC20Token {\r\n\t\taddress tokenAddress;\r\n\t\tuint256 price;\t\t\t// price of this ERC20 Token to AOETH\r\n\t\tuint256 maxQuantity;\t// To prevent too much exposure to a given asset\r\n\t\tuint256 exchangedQuantity;\t// Running total (total AOETH exchanged from this specific ERC20 Token)\r\n\t\tbool active;\r\n\t}\r\n\r\n\tstruct TokenExchange {\r\n\t\tbytes32 exchangeId;\r\n\t\taddress buyer;\t\t\t// The buyer address\r\n\t\taddress tokenAddress;\t// The address of ERC20 Token\r\n\t\tuint256 price;\t\t\t// price of ERC20 Token to AOETH\r\n\t\tuint256 sentAmount;\t\t// Amount of ERC20 Token sent\r\n\t\tuint256 receivedAmount;\t// Amount of AOETH received\r\n\t\tbytes extraData; // Extra data\r\n\t}\r\n\r\n\t// Mapping from id to ERC20Token object\r\n\tmapping (uint256 => ERC20Token) internal erc20Tokens;\r\n\tmapping (address => uint256) internal erc20TokenIdLookup;\r\n\r\n\t// Mapping from id to TokenExchange object\r\n\tmapping (uint256 => TokenExchange) internal tokenExchanges;\r\n\tmapping (bytes32 => uint256) internal tokenExchangeIdLookup;\r\n\tmapping (address => uint256) public totalAddressTokenExchanges;\r\n\r\n\t// Event to be broadcasted to public when TheAO adds an ERC20 Token\r\n\tevent AddERC20Token(address indexed tokenAddress, uint256 price, uint256 maxQuantity);\r\n\r\n\t// Event to be broadcasted to public when TheAO sets price for ERC20 Token\r\n\tevent SetPrice(address indexed tokenAddress, uint256 price);\r\n\r\n\t// Event to be broadcasted to public when TheAO sets max quantity for ERC20 Token\r\n\tevent SetMaxQuantity(address indexed tokenAddress, uint256 maxQuantity);\r\n\r\n\t// Event to be broadcasted to public when TheAO sets active status for ERC20 Token\r\n\tevent SetActive(address indexed tokenAddress, bool active);\r\n\r\n\t// Event to be broadcasted to public when user exchanges ERC20 Token for AOETH\r\n\tevent ExchangeToken(bytes32 indexed exchangeId, address indexed from, address tokenAddress, string tokenName, string tokenSymbol, uint256 sentTokenAmount, uint256 receivedAOETHAmount, bytes extraData);\r\n\r\n\t/**\r\n\t * @dev Constructor function\r\n\t */\r\n\tconstructor(uint256 initialSupply, string memory tokenName, string memory tokenSymbol, address _aoIonAddress, address _nameTAOPositionAddress)\r\n\t\tTokenERC20(initialSupply, tokenName, tokenSymbol) public {\r\n\t\tsetAOIonAddress(_aoIonAddress);\r\n\t\tsetNameTAOPositionAddress(_nameTAOPositionAddress);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Checks if the calling contract address is The AO\r\n\t *\t\tOR\r\n\t *\t\tIf The AO is set to a Name/TAO, then check if calling address is the Advocate\r\n\t */\r\n\tmodifier onlyTheAO {\r\n\t\trequire (AOLibrary.isTheAO(msg.sender, theAO, nameTAOPositionAddress));\r\n\t\t_;\r\n\t}\r\n\r\n\t/***** The AO ONLY METHODS *****/\r\n\t/**\r\n\t * @dev Transfer ownership of The AO to new address\r\n\t * @param _theAO The new address to be transferred\r\n\t */\r\n\tfunction transferOwnership(address _theAO) public onlyTheAO {\r\n\t\trequire (_theAO != address(0));\r\n\t\ttheAO = _theAO;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Whitelist `_account` address to transact on behalf of others\r\n\t * @param _account The address to whitelist\r\n\t * @param _whitelist Either to whitelist or not\r\n\t */\r\n\tfunction setWhitelist(address _account, bool _whitelist) public onlyTheAO {\r\n\t\trequire (_account != address(0));\r\n\t\twhitelist[_account] = _whitelist;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev The AO set the AOIon Address\r\n\t * @param _aoIonAddress The address of AOIon\r\n\t */\r\n\tfunction setAOIonAddress(address _aoIonAddress) public onlyTheAO {\r\n\t\trequire (_aoIonAddress != address(0));\r\n\t\taoIonAddress = _aoIonAddress;\r\n\t\t_aoIon = AOIon(_aoIonAddress);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev The AO set the NameTAOPosition Address\r\n\t * @param _nameTAOPositionAddress The address of NameTAOPosition\r\n\t */\r\n\tfunction setNameTAOPositionAddress(address _nameTAOPositionAddress) public onlyTheAO {\r\n\t\trequire (_nameTAOPositionAddress != address(0));\r\n\t\tnameTAOPositionAddress = _nameTAOPositionAddress;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Allows TheAO to transfer `_amount` of ERC20 Token from this address to `_recipient`\r\n\t * @param _erc20TokenAddress The address of ERC20 Token\r\n\t * @param _recipient The recipient address\r\n\t * @param _amount The amount to transfer\r\n\t */\r\n\tfunction transferERC20(address _erc20TokenAddress, address _recipient, uint256 _amount) public onlyTheAO {\r\n\t\tTokenERC20 _erc20 = TokenERC20(_erc20TokenAddress);\r\n\t\trequire (_erc20.transfer(_recipient, _amount));\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Add an ERC20 Token to the list\r\n\t * @param _tokenAddress The address of the ERC20 Token\r\n\t * @param _price The price of this token to AOETH\r\n\t * @param _maxQuantity Maximum quantity allowed for exchange\r\n\t */\r\n\tfunction addERC20Token(address _tokenAddress, uint256 _price, uint256 _maxQuantity) public onlyTheAO {\r\n\t\trequire (_tokenAddress != address(0) && _price > 0 && _maxQuantity > 0);\r\n\t\trequire (AOLibrary.isValidERC20TokenAddress(_tokenAddress));\r\n\t\trequire (erc20TokenIdLookup[_tokenAddress] == 0);\r\n\r\n\t\ttotalERC20Tokens++;\r\n\t\terc20TokenIdLookup[_tokenAddress] = totalERC20Tokens;\r\n\t\tERC20Token storage _erc20Token = erc20Tokens[totalERC20Tokens];\r\n\t\t_erc20Token.tokenAddress = _tokenAddress;\r\n\t\t_erc20Token.price = _price;\r\n\t\t_erc20Token.maxQuantity = _maxQuantity;\r\n\t\t_erc20Token.active = true;\r\n\t\temit AddERC20Token(_erc20Token.tokenAddress, _erc20Token.price, _erc20Token.maxQuantity);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Set price for existing ERC20 Token\r\n\t * @param _tokenAddress The address of the ERC20 Token\r\n\t * @param _price The price of this token to AOETH\r\n\t */\r\n\tfunction setPrice(address _tokenAddress, uint256 _price) public onlyTheAO {\r\n\t\trequire (erc20TokenIdLookup[_tokenAddress] > 0);\r\n\t\trequire (_price > 0);\r\n\r\n\t\tERC20Token storage _erc20Token = erc20Tokens[erc20TokenIdLookup[_tokenAddress]];\r\n\t\t_erc20Token.price = _price;\r\n\t\temit SetPrice(_erc20Token.tokenAddress, _erc20Token.price);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Set max quantity for existing ERC20 Token\r\n\t * @param _tokenAddress The address of the ERC20 Token\r\n\t * @param _maxQuantity The max exchange quantity for this token\r\n\t */\r\n\tfunction setMaxQuantity(address _tokenAddress, uint256 _maxQuantity) public onlyTheAO {\r\n\t\trequire (erc20TokenIdLookup[_tokenAddress] > 0);\r\n\r\n\t\tERC20Token storage _erc20Token = erc20Tokens[erc20TokenIdLookup[_tokenAddress]];\r\n\t\trequire (_maxQuantity > _erc20Token.exchangedQuantity);\r\n\t\t_erc20Token.maxQuantity = _maxQuantity;\r\n\t\temit SetMaxQuantity(_erc20Token.tokenAddress, _erc20Token.maxQuantity);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Set active status for existing ERC20 Token\r\n\t * @param _tokenAddress The address of the ERC20 Token\r\n\t * @param _active The active status for this token\r\n\t */\r\n\tfunction setActive(address _tokenAddress, bool _active) public onlyTheAO {\r\n\t\trequire (erc20TokenIdLookup[_tokenAddress] > 0);\r\n\r\n\t\tERC20Token storage _erc20Token = erc20Tokens[erc20TokenIdLookup[_tokenAddress]];\r\n\t\t_erc20Token.active = _active;\r\n\t\temit SetActive(_erc20Token.tokenAddress, _erc20Token.active);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Whitelisted address transfer tokens from other address\r\n\t *\r\n\t * Send `_value` tokens to `_to` on behalf of `_from`\r\n\t *\r\n\t * @param _from The address of the sender\r\n\t * @param _to The address of the recipient\r\n\t * @param _value the amount to send\r\n\t */\r\n\tfunction whitelistTransferFrom(address _from, address _to, uint256 _value) public inWhitelist returns (bool success) {\r\n\t\t_transfer(_from, _to, _value);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/***** PUBLIC METHODS *****/\r\n\t/**\r\n\t * @dev Get an ERC20 Token information given an ID\r\n\t * @param _id The internal ID of the ERC20 Token\r\n\t * @return The ERC20 Token address\r\n\t * @return The name of the token\r\n\t * @return The symbol of the token\r\n\t * @return The price of this token to AOETH\r\n\t * @return The max quantity for exchange\r\n\t * @return The total AOETH exchanged from this token\r\n\t * @return The status of this token\r\n\t */\r\n\tfunction getById(uint256 _id) public view returns (address, string memory, string memory, uint256, uint256, uint256, bool) {\r\n\t\trequire (erc20Tokens[_id].tokenAddress != address(0));\r\n\t\tERC20Token memory _erc20Token = erc20Tokens[_id];\r\n\t\treturn (\r\n\t\t\t_erc20Token.tokenAddress,\r\n\t\t\tTokenERC20(_erc20Token.tokenAddress).name(),\r\n\t\t\tTokenERC20(_erc20Token.tokenAddress).symbol(),\r\n\t\t\t_erc20Token.price,\r\n\t\t\t_erc20Token.maxQuantity,\r\n\t\t\t_erc20Token.exchangedQuantity,\r\n\t\t\t_erc20Token.active\r\n\t\t);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Get an ERC20 Token information given an address\r\n\t * @param _tokenAddress The address of the ERC20 Token\r\n\t * @return The ERC20 Token address\r\n\t * @return The name of the token\r\n\t * @return The symbol of the token\r\n\t * @return The price of this token to AOETH\r\n\t * @return The max quantity for exchange\r\n\t * @return The total AOETH exchanged from this token\r\n\t * @return The status of this token\r\n\t */\r\n\tfunction getByAddress(address _tokenAddress) public view returns (address, string memory, string memory, uint256, uint256, uint256, bool) {\r\n\t\trequire (erc20TokenIdLookup[_tokenAddress] > 0);\r\n\t\treturn getById(erc20TokenIdLookup[_tokenAddress]);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev When a user approves AOETH to spend on his/her behalf (i.e exchange to AOETH)\r\n\t * @param _from The user address that approved AOETH\r\n\t * @param _value The amount that the user approved\r\n\t * @param _token The address of the ERC20 Token\r\n\t * @param _extraData The extra data sent during the approval\r\n\t */\r\n\tfunction receiveApproval(address _from, uint256 _value, address _token, bytes calldata _extraData) external {\r\n\t\trequire (_from != address(0));\r\n\t\trequire (AOLibrary.isValidERC20TokenAddress(_token));\r\n\r\n\t\t// Check if the token is supported\r\n\t\trequire (erc20TokenIdLookup[_token] > 0);\r\n\t\tERC20Token storage _erc20Token = erc20Tokens[erc20TokenIdLookup[_token]];\r\n\t\trequire (_erc20Token.active && _erc20Token.price > 0 && _erc20Token.exchangedQuantity < _erc20Token.maxQuantity);\r\n\r\n\t\tuint256 amountToTransfer = _value.div(_erc20Token.price);\r\n\t\trequire (_erc20Token.maxQuantity.sub(_erc20Token.exchangedQuantity) >= amountToTransfer);\r\n\t\trequire (_aoIon.availableETH() >= amountToTransfer);\r\n\r\n\t\t// Transfer the ERC20 Token from the `_from` address to here\r\n\t\trequire (TokenERC20(_token).transferFrom(_from, address(this), _value));\r\n\r\n\t\t_erc20Token.exchangedQuantity = _erc20Token.exchangedQuantity.add(amountToTransfer);\r\n\t\tbalanceOf[_from] = balanceOf[_from].add(amountToTransfer);\r\n\t\ttotalSupply = totalSupply.add(amountToTransfer);\r\n\r\n\t\t// Store the TokenExchange information\r\n\t\ttotalTokenExchanges++;\r\n\t\ttotalAddressTokenExchanges[_from]++;\r\n\t\tbytes32 _exchangeId = keccak256(abi.encodePacked(this, _from, totalTokenExchanges));\r\n\t\ttokenExchangeIdLookup[_exchangeId] = totalTokenExchanges;\r\n\r\n\t\tTokenExchange storage _tokenExchange = tokenExchanges[totalTokenExchanges];\r\n\t\t_tokenExchange.exchangeId = _exchangeId;\r\n\t\t_tokenExchange.buyer = _from;\r\n\t\t_tokenExchange.tokenAddress = _token;\r\n\t\t_tokenExchange.price = _erc20Token.price;\r\n\t\t_tokenExchange.sentAmount = _value;\r\n\t\t_tokenExchange.receivedAmount = amountToTransfer;\r\n\t\t_tokenExchange.extraData = _extraData;\r\n\r\n\t\temit ExchangeToken(_tokenExchange.exchangeId, _tokenExchange.buyer, _tokenExchange.tokenAddress, TokenERC20(_token).name(), TokenERC20(_token).symbol(), _tokenExchange.sentAmount, _tokenExchange.receivedAmount, _tokenExchange.extraData);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Get TokenExchange information given an exchange ID\r\n\t * @param _exchangeId The exchange ID to query\r\n\t * @return The buyer address\r\n\t * @return The sent ERC20 Token address\r\n\t * @return The ERC20 Token name\r\n\t * @return The ERC20 Token symbol\r\n\t * @return The price of ERC20 Token to AOETH\r\n\t * @return The amount of ERC20 Token sent\r\n\t * @return The amount of AOETH received\r\n\t * @return Extra data during the transaction\r\n\t */\r\n\tfunction getTokenExchangeById(bytes32 _exchangeId) public view returns (address, address, string memory, string memory, uint256, uint256,  uint256, bytes memory) {\r\n\t\trequire (tokenExchangeIdLookup[_exchangeId] > 0);\r\n\t\tTokenExchange memory _tokenExchange = tokenExchanges[tokenExchangeIdLookup[_exchangeId]];\r\n\t\treturn (\r\n\t\t\t_tokenExchange.buyer,\r\n\t\t\t_tokenExchange.tokenAddress,\r\n\t\t\tTokenERC20(_tokenExchange.tokenAddress).name(),\r\n\t\t\tTokenERC20(_tokenExchange.tokenAddress).symbol(),\r\n\t\t\t_tokenExchange.price,\r\n\t\t\t_tokenExchange.sentAmount,\r\n\t\t\t_tokenExchange.receivedAmount,\r\n\t\t\t_tokenExchange.extraData\r\n\t\t);\r\n\t}\r\n}\r\n\r\n\r\n/**\r\n * @title AOIon\r\n */\r\ncontract AOIon is AOIonInterface {\r\n\tusing SafeMath for uint256;\r\n\r\n\taddress public aoIonLotAddress;\r\n\taddress public settingTAOId;\r\n\taddress public aoSettingAddress;\r\n\taddress public aoethAddress;\r\n\r\n\t// AO Dev Team addresses to receive Primordial/Network Ions\r\n\taddress public aoDevTeam1 = 0x146CbD9821e6A42c8ff6DC903fe91CB69625A105;\r\n\taddress public aoDevTeam2 = 0x4810aF1dA3aC827259eEa72ef845F4206C703E8D;\r\n\r\n\tIAOIonLot internal _aoIonLot;\r\n\tIAOSetting internal _aoSetting;\r\n\tAOETH internal _aoeth;\r\n\r\n\t/***** PRIMORDIAL ION VARIABLES *****/\r\n\tuint256 public primordialTotalSupply;\r\n\tuint256 public primordialTotalBought;\r\n\tuint256 public primordialSellPrice;\r\n\tuint256 public primordialBuyPrice;\r\n\tuint256 public totalEthForPrimordial;\t// Total ETH sent for Primordial AO+\r\n\tuint256 public totalRedeemedAOETH;\t\t// Total AOETH redeemed for Primordial AO+\r\n\r\n\t// Total available primordial ion for sale 3,377,699,720,527,872 AO+\r\n\tuint256 constant public TOTAL_PRIMORDIAL_FOR_SALE = 3377699720527872;\r\n\r\n\tmapping (address => uint256) public primordialBalanceOf;\r\n\tmapping (address => mapping (address => uint256)) public primordialAllowance;\r\n\r\n\t// Mapping from owner's lot weighted multiplier to the amount of staked ions\r\n\tmapping (address => mapping (uint256 => uint256)) public primordialStakedBalance;\r\n\r\n\tevent PrimordialTransfer(address indexed from, address indexed to, uint256 value);\r\n\tevent PrimordialApproval(address indexed _owner, address indexed _spender, uint256 _value);\r\n\tevent PrimordialBurn(address indexed from, uint256 value);\r\n\tevent PrimordialStake(address indexed from, uint256 value, uint256 weightedMultiplier);\r\n\tevent PrimordialUnstake(address indexed from, uint256 value, uint256 weightedMultiplier);\r\n\r\n\tevent NetworkExchangeEnded();\r\n\r\n\tbool public networkExchangeEnded;\r\n\r\n\t// Mapping from owner to his/her current weighted multiplier\r\n\tmapping (address => uint256) internal ownerWeightedMultiplier;\r\n\r\n\t// Mapping from owner to his/her max multiplier (multiplier of account's first Lot)\r\n\tmapping (address => uint256) internal ownerMaxMultiplier;\r\n\r\n\t// Event to be broadcasted to public when user buys primordial ion\r\n\t// payWith 1 == with Ethereum\r\n\t// payWith 2 == with AOETH\r\n\tevent BuyPrimordial(address indexed lotOwner, bytes32 indexed lotId, uint8 payWith, uint256 sentAmount, uint256 refundedAmount);\r\n\r\n\t/**\r\n\t * @dev Constructor function\r\n\t */\r\n\tconstructor(string memory _name, string memory _symbol, address _settingTAOId, address _aoSettingAddress, address _nameTAOPositionAddress, address _namePublicKeyAddress, address _nameAccountRecoveryAddress)\r\n\t\tAOIonInterface(_name, _symbol, _nameTAOPositionAddress, _namePublicKeyAddress, _nameAccountRecoveryAddress) public {\r\n\t\tsetSettingTAOId(_settingTAOId);\r\n\t\tsetAOSettingAddress(_aoSettingAddress);\r\n\r\n\t\tpowerOfTen = 0;\r\n\t\tdecimals = 0;\r\n\t\tsetPrimordialPrices(0, 10 ** 8); // Set Primordial buy price to 0.1 gwei/ion\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Checks if buyer can buy primordial ion\r\n\t */\r\n\tmodifier canBuyPrimordial(uint256 _sentAmount, bool _withETH) {\r\n\t\trequire (networkExchangeEnded == false &&\r\n\t\t\tprimordialTotalBought < TOTAL_PRIMORDIAL_FOR_SALE &&\r\n\t\t\tprimordialBuyPrice > 0 &&\r\n\t\t\t_sentAmount > 0 &&\r\n\t\t\tavailablePrimordialForSaleInETH() > 0 &&\r\n\t\t\t(\r\n\t\t\t\t(_withETH && availableETH() > 0) ||\r\n\t\t\t\t(!_withETH && totalRedeemedAOETH < _aoeth.totalSupply())\r\n\t\t\t)\r\n\t\t);\r\n\t\t_;\r\n\t}\r\n\r\n\t/***** The AO ONLY METHODS *****/\r\n\t/**\r\n\t * @dev The AO sets AOIonLot address\r\n\t * @param _aoIonLotAddress The address of AOIonLot\r\n\t */\r\n\tfunction setAOIonLotAddress(address _aoIonLotAddress) public onlyTheAO {\r\n\t\trequire (_aoIonLotAddress != address(0));\r\n\t\taoIonLotAddress = _aoIonLotAddress;\r\n\t\t_aoIonLot = IAOIonLot(_aoIonLotAddress);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev The AO sets setting TAO ID\r\n\t * @param _settingTAOId The new setting TAO ID to set\r\n\t */\r\n\tfunction setSettingTAOId(address _settingTAOId) public onlyTheAO {\r\n\t\trequire (AOLibrary.isTAO(_settingTAOId));\r\n\t\tsettingTAOId = _settingTAOId;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev The AO sets AO Setting address\r\n\t * @param _aoSettingAddress The address of AOSetting\r\n\t */\r\n\tfunction setAOSettingAddress(address _aoSettingAddress) public onlyTheAO {\r\n\t\trequire (_aoSettingAddress != address(0));\r\n\t\taoSettingAddress = _aoSettingAddress;\r\n\t\t_aoSetting = IAOSetting(_aoSettingAddress);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Set AO Dev team addresses to receive Primordial/Network ions during network exchange\r\n\t * @param _aoDevTeam1 The first AO dev team address\r\n\t * @param _aoDevTeam2 The second AO dev team address\r\n\t */\r\n\tfunction setAODevTeamAddresses(address _aoDevTeam1, address _aoDevTeam2) public onlyTheAO {\r\n\t\taoDevTeam1 = _aoDevTeam1;\r\n\t\taoDevTeam2 = _aoDevTeam2;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Set AOETH address\r\n\t * @param _aoethAddress The address of AOETH\r\n\t */\r\n\tfunction setAOETHAddress(address _aoethAddress) public onlyTheAO {\r\n\t\trequire (_aoethAddress != address(0));\r\n\t\taoethAddress = _aoethAddress;\r\n\t\t_aoeth = AOETH(_aoethAddress);\r\n\t}\r\n\r\n\t/***** PRIMORDIAL ION THE AO ONLY METHODS *****/\r\n\t/**\r\n\t * @dev Allow users to buy Primordial ions for `newBuyPrice` eth and sell Primordial ions for `newSellPrice` eth\r\n\t * @param newPrimordialSellPrice Price users can sell to the contract\r\n\t * @param newPrimordialBuyPrice Price users can buy from the contract\r\n\t */\r\n\tfunction setPrimordialPrices(uint256 newPrimordialSellPrice, uint256 newPrimordialBuyPrice) public onlyTheAO {\r\n\t\tprimordialSellPrice = newPrimordialSellPrice;\r\n\t\tprimordialBuyPrice = newPrimordialBuyPrice;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Only the AO can force end network exchange\r\n\t */\r\n\tfunction endNetworkExchange() public onlyTheAO {\r\n\t\trequire (!networkExchangeEnded);\r\n\t\tnetworkExchangeEnded = true;\r\n\t\temit NetworkExchangeEnded();\r\n\t}\r\n\r\n\t/***** PRIMORDIAL ION WHITELISTED ADDRESS ONLY METHODS *****/\r\n\t/**\r\n\t * @dev Stake `_value` Primordial ions at `_weightedMultiplier ` multiplier on behalf of `_from`\r\n\t * @param _from The address of the target\r\n\t * @param _value The amount of Primordial ions to stake\r\n\t * @param _weightedMultiplier The weighted multiplier of the Primordial ions\r\n\t * @return true on success\r\n\t */\r\n\tfunction stakePrimordialFrom(address _from, uint256 _value, uint256 _weightedMultiplier) public inWhitelist returns (bool) {\r\n\t\t// Check if the targeted balance is enough\r\n\t\trequire (primordialBalanceOf[_from] >= _value);\r\n\t\t// Make sure the weighted multiplier is the same as account's current weighted multiplier\r\n\t\trequire (_weightedMultiplier == ownerWeightedMultiplier[_from]);\r\n\t\t// Subtract from the targeted balance\r\n\t\tprimordialBalanceOf[_from] = primordialBalanceOf[_from].sub(_value);\r\n\t\t// Add to the targeted staked balance\r\n\t\tprimordialStakedBalance[_from][_weightedMultiplier] = primordialStakedBalance[_from][_weightedMultiplier].add(_value);\r\n\t\temit PrimordialStake(_from, _value, _weightedMultiplier);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Unstake `_value` Primordial ions at `_weightedMultiplier` on behalf of `_from`\r\n\t * @param _from The address of the target\r\n\t * @param _value The amount to unstake\r\n\t * @param _weightedMultiplier The weighted multiplier of the Primordial ions\r\n\t * @return true on success\r\n\t */\r\n\tfunction unstakePrimordialFrom(address _from, uint256 _value, uint256 _weightedMultiplier) public inWhitelist returns (bool) {\r\n\t\t// Check if the targeted staked balance is enough\r\n\t\trequire (primordialStakedBalance[_from][_weightedMultiplier] >= _value);\r\n\t\t// Subtract from the targeted staked balance\r\n\t\tprimordialStakedBalance[_from][_weightedMultiplier] = primordialStakedBalance[_from][_weightedMultiplier].sub(_value);\r\n\t\t// Add to the targeted balance\r\n\t\tprimordialBalanceOf[_from] = primordialBalanceOf[_from].add(_value);\r\n\t\temit PrimordialUnstake(_from, _value, _weightedMultiplier);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Send `_value` primordial ions to `_to` on behalf of `_from`\r\n\t * @param _from The address of the sender\r\n\t * @param _to The address of the recipient\r\n\t * @param _value The amount to send\r\n\t * @return true on success\r\n\t */\r\n\tfunction whitelistTransferPrimordialFrom(address _from, address _to, uint256 _value) public inWhitelist returns (bool) {\r\n\t\treturn _createLotAndTransferPrimordial(_from, _to, _value);\r\n\t}\r\n\r\n\t/***** PUBLIC METHODS *****/\r\n\t/***** PRIMORDIAL ION PUBLIC METHODS *****/\r\n\t/**\r\n\t * @dev Buy Primordial ions from contract by sending ether\r\n\t */\r\n\tfunction buyPrimordial() public payable canBuyPrimordial(msg.value, true) {\r\n\t\t(uint256 amount, uint256 remainderBudget, bool shouldEndNetworkExchange) = _calculateAmountAndRemainderBudget(msg.value, true);\r\n\t\trequire (amount > 0);\r\n\r\n\t\t// Ends network exchange if necessary\r\n\t\tif (shouldEndNetworkExchange) {\r\n\t\t\tnetworkExchangeEnded = true;\r\n\t\t\temit NetworkExchangeEnded();\r\n\t\t}\r\n\r\n\t\t// Update totalEthForPrimordial\r\n\t\ttotalEthForPrimordial = totalEthForPrimordial.add(msg.value.sub(remainderBudget));\r\n\r\n\t\t// Send the primordial ion to buyer and reward AO devs\r\n\t\tbytes32 _lotId = _sendPrimordialAndRewardDev(amount, msg.sender);\r\n\r\n\t\temit BuyPrimordial(msg.sender, _lotId, 1, msg.value, remainderBudget);\r\n\r\n\t\t// Send remainder budget back to buyer if exist\r\n\t\tif (remainderBudget > 0) {\r\n\t\t\tmsg.sender.transfer(remainderBudget);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Buy Primordial ion from contract by sending AOETH\r\n\t */\r\n\tfunction buyPrimordialWithAOETH(uint256 _aoethAmount) public canBuyPrimordial(_aoethAmount, false) {\r\n\t\t(uint256 amount, uint256 remainderBudget, bool shouldEndNetworkExchange) = _calculateAmountAndRemainderBudget(_aoethAmount, false);\r\n\t\trequire (amount > 0);\r\n\r\n\t\t// Ends network exchange if necessary\r\n\t\tif (shouldEndNetworkExchange) {\r\n\t\t\tnetworkExchangeEnded = true;\r\n\t\t\temit NetworkExchangeEnded();\r\n\t\t}\r\n\r\n\t\t// Calculate the actual AOETH that was charged for this transaction\r\n\t\tuint256 actualCharge = _aoethAmount.sub(remainderBudget);\r\n\r\n\t\t// Update totalRedeemedAOETH\r\n\t\ttotalRedeemedAOETH = totalRedeemedAOETH.add(actualCharge);\r\n\r\n\t\t// Transfer AOETH from buyer to here\r\n\t\trequire (_aoeth.whitelistTransferFrom(msg.sender, address(this), actualCharge));\r\n\r\n\t\t// Send the primordial ion to buyer and reward AO devs\r\n\t\tbytes32 _lotId = _sendPrimordialAndRewardDev(amount, msg.sender);\r\n\r\n\t\temit BuyPrimordial(msg.sender, _lotId, 2, _aoethAmount, remainderBudget);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Send `_value` Primordial ions to `_to` from your account\r\n\t * @param _to The address of the recipient\r\n\t * @param _value The amount to send\r\n\t * @return true on success\r\n\t */\r\n\tfunction transferPrimordial(address _to, uint256 _value) public returns (bool) {\r\n\t\treturn _createLotAndTransferPrimordial(msg.sender, _to, _value);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Send `_value` Primordial ions to `_to` from `_from`\r\n\t * @param _from The address of the sender\r\n\t * @param _to The address of the recipient\r\n\t * @param _value The amount to send\r\n\t * @return true on success\r\n\t */\r\n\tfunction transferPrimordialFrom(address _from, address _to, uint256 _value) public returns (bool) {\r\n\t\trequire (_value <= primordialAllowance[_from][msg.sender]);\r\n\t\tprimordialAllowance[_from][msg.sender] = primordialAllowance[_from][msg.sender].sub(_value);\r\n\r\n\t\treturn _createLotAndTransferPrimordial(_from, _to, _value);\r\n\t}\r\n\r\n\t/**\r\n\t * Transfer primordial ions between public key addresses in a Name\r\n\t * @param _nameId The ID of the Name\r\n\t * @param _from The address of the sender\r\n\t * @param _to The address of the recipient\r\n\t * @param _value the amount to send\r\n\t */\r\n\tfunction transferPrimordialBetweenPublicKeys(address _nameId, address _from, address _to, uint256 _value) public returns (bool) {\r\n\t\trequire (AOLibrary.isName(_nameId));\r\n\t\trequire (_nameTAOPosition.senderIsAdvocate(msg.sender, _nameId));\r\n\t\trequire (!_nameAccountRecovery.isCompromised(_nameId));\r\n\t\t// Make sure _from exist in the Name's Public Keys\r\n\t\trequire (_namePublicKey.isKeyExist(_nameId, _from));\r\n\t\t// Make sure _to exist in the Name's Public Keys\r\n\t\trequire (_namePublicKey.isKeyExist(_nameId, _to));\r\n\t\treturn _createLotAndTransferPrimordial(_from, _to, _value);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Allows `_spender` to spend no more than `_value` Primordial ions in your behalf\r\n\t * @param _spender The address authorized to spend\r\n\t * @param _value The max amount they can spend\r\n\t * @return true on success\r\n\t */\r\n\tfunction approvePrimordial(address _spender, uint256 _value) public returns (bool) {\r\n\t\tprimordialAllowance[msg.sender][_spender] = _value;\r\n\t\temit PrimordialApproval(msg.sender, _spender, _value);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Allows `_spender` to spend no more than `_value` Primordial ions in your behalf, and then ping the contract about it\r\n\t * @param _spender The address authorized to spend\r\n\t * @param _value The max amount they can spend\r\n\t * @param _extraData some extra information to send to the approved contract\r\n\t * @return true on success\r\n\t */\r\n\tfunction approvePrimordialAndCall(address _spender, uint256 _value, bytes memory _extraData) public returns (bool) {\r\n\t\ttokenRecipient spender = tokenRecipient(_spender);\r\n\t\tif (approvePrimordial(_spender, _value)) {\r\n\t\t\tspender.receiveApproval(msg.sender, _value, address(this), _extraData);\r\n\t\t\treturn true;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Remove `_value` Primordial ions from the system irreversibly\r\n\t *\t\tand re-weight the account's multiplier after burn\r\n\t * @param _value The amount to burn\r\n\t * @return true on success\r\n\t */\r\n\tfunction burnPrimordial(uint256 _value) public returns (bool) {\r\n\t\trequire (primordialBalanceOf[msg.sender] >= _value);\r\n\t\trequire (calculateMaximumBurnAmount(msg.sender) >= _value);\r\n\r\n\t\t// Update the account's multiplier\r\n\t\townerWeightedMultiplier[msg.sender] = calculateMultiplierAfterBurn(msg.sender, _value);\r\n\t\tprimordialBalanceOf[msg.sender] = primordialBalanceOf[msg.sender].sub(_value);\r\n\t\tprimordialTotalSupply = primordialTotalSupply.sub(_value);\r\n\r\n\t\t// Store burn lot info\r\n\t\trequire (_aoIonLot.createBurnLot(msg.sender, _value, ownerWeightedMultiplier[msg.sender]));\r\n\t\temit PrimordialBurn(msg.sender, _value);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Remove `_value` Primordial ions from the system irreversibly on behalf of `_from`\r\n\t *\t\tand re-weight `_from`'s multiplier after burn\r\n\t * @param _from The address of sender\r\n\t * @param _value The amount to burn\r\n\t * @return true on success\r\n\t */\r\n\tfunction burnPrimordialFrom(address _from, uint256 _value) public returns (bool) {\r\n\t\trequire (primordialBalanceOf[_from] >= _value);\r\n\t\trequire (primordialAllowance[_from][msg.sender] >= _value);\r\n\t\trequire (calculateMaximumBurnAmount(_from) >= _value);\r\n\r\n\t\t// Update `_from`'s multiplier\r\n\t\townerWeightedMultiplier[_from] = calculateMultiplierAfterBurn(_from, _value);\r\n\t\tprimordialBalanceOf[_from] = primordialBalanceOf[_from].sub(_value);\r\n\t\tprimordialAllowance[_from][msg.sender] = primordialAllowance[_from][msg.sender].sub(_value);\r\n\t\tprimordialTotalSupply = primordialTotalSupply.sub(_value);\r\n\r\n\t\t// Store burn lot info\r\n\t\trequire (_aoIonLot.createBurnLot(_from, _value, ownerWeightedMultiplier[_from]));\r\n\t\temit PrimordialBurn(_from, _value);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Return the average weighted multiplier of all lots owned by an address\r\n\t * @param _lotOwner The address of the lot owner\r\n\t * @return the weighted multiplier of the address (in 10 ** 6)\r\n\t */\r\n\tfunction weightedMultiplierByAddress(address _lotOwner) public view returns (uint256) {\r\n\t\treturn ownerWeightedMultiplier[_lotOwner];\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Return the max multiplier of an address\r\n\t * @param _target The address to query\r\n\t * @return the max multiplier of the address (in 10 ** 6)\r\n\t */\r\n\tfunction maxMultiplierByAddress(address _target) public view returns (uint256) {\r\n\t\treturn (_aoIonLot.totalLotsByAddress(_target) > 0) ? ownerMaxMultiplier[_target] : 0;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Calculate the primordial ion multiplier, bonus network ion percentage, and the\r\n\t *\t\tbonus network ion amount on a given lot when someone purchases primordial ion\r\n\t *\t\tduring network exchange\r\n\t * @param _purchaseAmount The amount of primordial ion intended to be purchased\r\n\t * @return The multiplier in (10 ** 6)\r\n\t * @return The bonus percentage\r\n\t * @return The amount of network ion as bonus\r\n\t */\r\n\tfunction calculateMultiplierAndBonus(uint256 _purchaseAmount) public view returns (uint256, uint256, uint256) {\r\n\t\t(uint256 startingPrimordialMultiplier, uint256 endingPrimordialMultiplier, uint256 startingNetworkBonusMultiplier, uint256 endingNetworkBonusMultiplier) = _getSettingVariables();\r\n\t\treturn (\r\n\t\t\tAOLibrary.calculatePrimordialMultiplier(_purchaseAmount, TOTAL_PRIMORDIAL_FOR_SALE, primordialTotalBought, startingPrimordialMultiplier, endingPrimordialMultiplier),\r\n\t\t\tAOLibrary.calculateNetworkBonusPercentage(_purchaseAmount, TOTAL_PRIMORDIAL_FOR_SALE, primordialTotalBought, startingNetworkBonusMultiplier, endingNetworkBonusMultiplier),\r\n\t\t\tAOLibrary.calculateNetworkBonusAmount(_purchaseAmount, TOTAL_PRIMORDIAL_FOR_SALE, primordialTotalBought, startingNetworkBonusMultiplier, endingNetworkBonusMultiplier)\r\n\t\t);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Calculate the maximum amount of Primordial an account can burn\r\n\t * @param _account The address of the account\r\n\t * @return The maximum primordial ion amount to burn\r\n\t */\r\n\tfunction calculateMaximumBurnAmount(address _account) public view returns (uint256) {\r\n\t\treturn AOLibrary.calculateMaximumBurnAmount(primordialBalanceOf[_account], ownerWeightedMultiplier[_account], ownerMaxMultiplier[_account]);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Calculate account's new multiplier after burn `_amountToBurn` primordial ions\r\n\t * @param _account The address of the account\r\n\t * @param _amountToBurn The amount of primordial ion to burn\r\n\t * @return The new multiplier in (10 ** 6)\r\n\t */\r\n\tfunction calculateMultiplierAfterBurn(address _account, uint256 _amountToBurn) public view returns (uint256) {\r\n\t\trequire (calculateMaximumBurnAmount(_account) >= _amountToBurn);\r\n\t\treturn AOLibrary.calculateMultiplierAfterBurn(primordialBalanceOf[_account], ownerWeightedMultiplier[_account], _amountToBurn);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Calculate account's new multiplier after converting `amountToConvert` network ion to primordial ion\r\n\t * @param _account The address of the account\r\n\t * @param _amountToConvert The amount of network ion to convert\r\n\t * @return The new multiplier in (10 ** 6)\r\n\t */\r\n\tfunction calculateMultiplierAfterConversion(address _account, uint256 _amountToConvert) public view returns (uint256) {\r\n\t\treturn AOLibrary.calculateMultiplierAfterConversion(primordialBalanceOf[_account], ownerWeightedMultiplier[_account], _amountToConvert);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Convert `_value` of network ions to primordial ions\r\n\t *\t\tand re-weight the account's multiplier after conversion\r\n\t * @param _value The amount to convert\r\n\t * @return true on success\r\n\t */\r\n\tfunction convertToPrimordial(uint256 _value) public returns (bool) {\r\n\t\trequire (balanceOf[msg.sender] >= _value);\r\n\r\n\t\t// Update the account's multiplier\r\n\t\townerWeightedMultiplier[msg.sender] = calculateMultiplierAfterConversion(msg.sender, _value);\r\n\t\t// Burn network ion\r\n\t\tburn(_value);\r\n\t\t// mint primordial ion\r\n\t\t_mintPrimordial(msg.sender, _value);\r\n\r\n\t\trequire (_aoIonLot.createConvertLot(msg.sender, _value, ownerWeightedMultiplier[msg.sender]));\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Get quantity of AO+ left in Network Exchange\r\n\t * @return The quantity of AO+ left in Network Exchange\r\n\t */\r\n\tfunction availablePrimordialForSale() public view returns (uint256) {\r\n\t\treturn TOTAL_PRIMORDIAL_FOR_SALE.sub(primordialTotalBought);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Get quantity of AO+ in ETH left in Network Exchange (i.e How much ETH is there total that can be\r\n\t *\t\texchanged for AO+\r\n\t * @return The quantity of AO+ in ETH left in Network Exchange\r\n\t */\r\n\tfunction availablePrimordialForSaleInETH() public view returns (uint256) {\r\n\t\treturn availablePrimordialForSale().mul(primordialBuyPrice);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Get maximum quantity of AOETH or ETH that can still be sold\r\n\t * @return The maximum quantity of AOETH or ETH that can still be sold\r\n\t */\r\n\tfunction availableETH() public view returns (uint256) {\r\n\t\tif (availablePrimordialForSaleInETH() > 0) {\r\n\t\t\tuint256 _availableETH = availablePrimordialForSaleInETH().sub(_aoeth.totalSupply().sub(totalRedeemedAOETH));\r\n\t\t\tif (availablePrimordialForSale() == 1 && _availableETH < primordialBuyPrice) {\r\n\t\t\t\treturn primordialBuyPrice;\r\n\t\t\t} else {\r\n\t\t\t\treturn _availableETH;\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\treturn 0;\r\n\t\t}\r\n\t}\r\n\r\n\t/***** INTERNAL METHODS *****/\r\n\t/***** PRIMORDIAL ION INTERNAL METHODS *****/\r\n\t/**\r\n\t * @dev Calculate the amount of ion the buyer will receive and remaining budget if exist\r\n\t *\t\twhen he/she buys primordial ion\r\n\t * @param _budget The amount of ETH sent by buyer\r\n\t * @param _withETH Whether or not buyer is paying with ETH\r\n\t * @return uint256 of the amount the buyer will receiver\r\n\t * @return uint256 of the remaining budget, if exist\r\n\t * @return bool whether or not the network exchange should end\r\n\t */\r\n\tfunction _calculateAmountAndRemainderBudget(uint256 _budget, bool _withETH) internal view returns (uint256, uint256, bool) {\r\n\t\t// Calculate the amount of ion\r\n\t\tuint256 amount = _budget.div(primordialBuyPrice);\r\n\r\n\t\t// If we need to return ETH to the buyer, in the case\r\n\t\t// where the buyer sends more ETH than available primordial ion to be purchased\r\n\t\tuint256 remainderEth = _budget.sub(amount.mul(primordialBuyPrice));\r\n\r\n\t\tuint256 _availableETH = availableETH();\r\n\t\t// If paying with ETH, it can't exceed availableETH\r\n\t\tif (_withETH && _budget > availableETH()) {\r\n\t\t\t// Calculate the amount of ions\r\n\t\t\tamount = _availableETH.div(primordialBuyPrice);\r\n\t\t\tremainderEth = _budget.sub(amount.mul(primordialBuyPrice));\r\n\t\t}\r\n\r\n\t\t// Make sure primordialTotalBought is not overflowing\r\n\t\tbool shouldEndNetworkExchange = false;\r\n\t\tif (primordialTotalBought.add(amount) >= TOTAL_PRIMORDIAL_FOR_SALE) {\r\n\t\t\tamount = TOTAL_PRIMORDIAL_FOR_SALE.sub(primordialTotalBought);\r\n\t\t\tshouldEndNetworkExchange = true;\r\n\t\t\tremainderEth = _budget.sub(amount.mul(primordialBuyPrice));\r\n\t\t}\r\n\t\treturn (amount, remainderEth, shouldEndNetworkExchange);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Actually sending the primordial ion to buyer and reward AO devs accordingly\r\n\t * @param amount The amount of primordial ion to be sent to buyer\r\n\t * @param to The recipient of ion\r\n\t * @return the lot Id of the buyer\r\n\t */\r\n\tfunction _sendPrimordialAndRewardDev(uint256 amount, address to) internal returns (bytes32) {\r\n\t\t(uint256 startingPrimordialMultiplier,, uint256 startingNetworkBonusMultiplier, uint256 endingNetworkBonusMultiplier) = _getSettingVariables();\r\n\r\n\t\t// Update primordialTotalBought\r\n\t\t(uint256 multiplier, uint256 networkBonusPercentage, uint256 networkBonusAmount) = calculateMultiplierAndBonus(amount);\r\n\t\tprimordialTotalBought = primordialTotalBought.add(amount);\r\n\t\tbytes32 _lotId = _createPrimordialLot(to, amount, multiplier, networkBonusAmount);\r\n\r\n\t\t// Calculate The AO and AO Dev Team's portion of Primordial and Network ion Bonus\r\n\t\tuint256 inverseMultiplier = startingPrimordialMultiplier.sub(multiplier); // Inverse of the buyer's multiplier\r\n\t\tuint256 theAONetworkBonusAmount = (startingNetworkBonusMultiplier.sub(networkBonusPercentage).add(endingNetworkBonusMultiplier)).mul(amount).div(AOLibrary.PERCENTAGE_DIVISOR());\r\n\t\tif (aoDevTeam1 != address(0)) {\r\n\t\t\t_createPrimordialLot(aoDevTeam1, amount.div(2), inverseMultiplier, theAONetworkBonusAmount.div(2));\r\n\t\t}\r\n\t\tif (aoDevTeam2 != address(0)) {\r\n\t\t\t_createPrimordialLot(aoDevTeam2, amount.div(2), inverseMultiplier, theAONetworkBonusAmount.div(2));\r\n\t\t}\r\n\t\t_mint(theAO, theAONetworkBonusAmount);\r\n\t\treturn _lotId;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Create a lot with `primordialAmount` of primordial ions with `_multiplier` for an `account`\r\n\t *\t\tduring network exchange, and reward `_networkBonusAmount` if exist\r\n\t * @param _account Address of the lot owner\r\n\t * @param _primordialAmount The amount of primordial ions to be stored in the lot\r\n\t * @param _multiplier The multiplier for this lot in (10 ** 6)\r\n\t * @param _networkBonusAmount The network ion bonus amount\r\n\t * @return Created lot Id\r\n\t */\r\n\tfunction _createPrimordialLot(address _account, uint256 _primordialAmount, uint256 _multiplier, uint256 _networkBonusAmount) internal returns (bytes32) {\r\n\t\tbytes32 lotId = _aoIonLot.createPrimordialLot(_account, _primordialAmount, _multiplier, _networkBonusAmount);\r\n\r\n\t\townerWeightedMultiplier[_account] = AOLibrary.calculateWeightedMultiplier(ownerWeightedMultiplier[_account], primordialBalanceOf[_account], _multiplier, _primordialAmount);\r\n\r\n\t\t// If this is the first lot, set this as the max multiplier of the account\r\n\t\tif (_aoIonLot.totalLotsByAddress(_account) == 1) {\r\n\t\t\townerMaxMultiplier[_account] = _multiplier;\r\n\t\t}\r\n\t\t_mintPrimordial(_account, _primordialAmount);\r\n\t\t_mint(_account, _networkBonusAmount);\r\n\r\n\t\treturn lotId;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Create `mintedAmount` Primordial ions and send it to `target`\r\n\t * @param target Address to receive the Primordial ions\r\n\t * @param mintedAmount The amount of Primordial ions it will receive\r\n\t */\r\n\tfunction _mintPrimordial(address target, uint256 mintedAmount) internal {\r\n\t\tprimordialBalanceOf[target] = primordialBalanceOf[target].add(mintedAmount);\r\n\t\tprimordialTotalSupply = primordialTotalSupply.add(mintedAmount);\r\n\t\temit PrimordialTransfer(address(0), address(this), mintedAmount);\r\n\t\temit PrimordialTransfer(address(this), target, mintedAmount);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Create a lot with `amount` of ions at `weightedMultiplier` for an `account`\r\n\t * @param _account Address of lot owner\r\n\t * @param _amount The amount of ions\r\n\t * @param _weightedMultiplier The multiplier of the lot (in 10^6)\r\n\t * @return bytes32 of new created lot ID\r\n\t */\r\n\tfunction _createWeightedMultiplierLot(address _account, uint256 _amount, uint256 _weightedMultiplier) internal returns (bytes32) {\r\n\t\trequire (_account != address(0));\r\n\t\trequire (_amount > 0);\r\n\r\n\t\tbytes32 lotId = _aoIonLot.createWeightedMultiplierLot(_account, _amount, _weightedMultiplier);\r\n\t\t// If this is the first lot, set this as the max multiplier of the account\r\n\t\tif (_aoIonLot.totalLotsByAddress(_account) == 1) {\r\n\t\t\townerMaxMultiplier[_account] = _weightedMultiplier;\r\n\t\t}\r\n\t\treturn lotId;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Create Lot and send `_value` Primordial ions from `_from` to `_to`\r\n\t * @param _from The address of sender\r\n\t * @param _to The address of the recipient\r\n\t * @param _value The amount to send\r\n\t * @return true on success\r\n\t */\r\n\tfunction _createLotAndTransferPrimordial(address _from, address _to, uint256 _value) internal returns (bool) {\r\n\t\tbytes32 _createdLotId = _createWeightedMultiplierLot(_to, _value, ownerWeightedMultiplier[_from]);\r\n\t\t(, address _lotOwner,,) = _aoIonLot.lotById(_createdLotId);\r\n\r\n\t\t// Make sure the new lot is created successfully\r\n\t\trequire (_lotOwner == _to);\r\n\r\n\t\t// Update the weighted multiplier of the recipient\r\n\t\townerWeightedMultiplier[_to] = AOLibrary.calculateWeightedMultiplier(ownerWeightedMultiplier[_to], primordialBalanceOf[_to], ownerWeightedMultiplier[_from], _value);\r\n\r\n\t\t// Transfer the Primordial ions\r\n\t\trequire (_transferPrimordial(_from, _to, _value));\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Send `_value` Primordial ions from `_from` to `_to`\r\n\t * @param _from The address of sender\r\n\t * @param _to The address of the recipient\r\n\t * @param _value The amount to send\r\n\t */\r\n\tfunction _transferPrimordial(address _from, address _to, uint256 _value) internal returns (bool) {\r\n\t\trequire (_to != address(0));\t\t\t\t\t\t\t\t\t// Prevent transfer to 0x0 address. Use burn() instead\r\n\t\trequire (primordialBalanceOf[_from] >= _value);\t\t\t\t\t\t// Check if the sender has enough\r\n\t\trequire (primordialBalanceOf[_to].add(_value) >= primordialBalanceOf[_to]);\t// Check for overflows\r\n\t\trequire (!frozenAccount[_from]);\t\t\t\t\t\t\t\t// Check if sender is frozen\r\n\t\trequire (!frozenAccount[_to]);\t\t\t\t\t\t\t\t\t// Check if recipient is frozen\r\n\t\tuint256 previousBalances = primordialBalanceOf[_from].add(primordialBalanceOf[_to]);\r\n\t\tprimordialBalanceOf[_from] = primordialBalanceOf[_from].sub(_value);\t\t\t// Subtract from the sender\r\n\t\tprimordialBalanceOf[_to] = primordialBalanceOf[_to].add(_value);\t\t\t\t// Add the same to the recipient\r\n\t\temit PrimordialTransfer(_from, _to, _value);\r\n\t\tassert(primordialBalanceOf[_from].add(primordialBalanceOf[_to]) == previousBalances);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Get setting variables\r\n\t * @return startingPrimordialMultiplier The starting multiplier used to calculate primordial ion\r\n\t * @return endingPrimordialMultiplier The ending multiplier used to calculate primordial ion\r\n\t * @return startingNetworkBonusMultiplier The starting multiplier used to calculate network ion bonus\r\n\t * @return endingNetworkBonusMultiplier The ending multiplier used to calculate network ion bonus\r\n\t */\r\n\tfunction _getSettingVariables() internal view returns (uint256, uint256, uint256, uint256) {\r\n\t\t(uint256 startingPrimordialMultiplier,,,,) = _aoSetting.getSettingValuesByTAOName(settingTAOId, 'startingPrimordialMultiplier');\r\n\t\t(uint256 endingPrimordialMultiplier,,,,) = _aoSetting.getSettingValuesByTAOName(settingTAOId, 'endingPrimordialMultiplier');\r\n\r\n\t\t(uint256 startingNetworkBonusMultiplier,,,,) = _aoSetting.getSettingValuesByTAOName(settingTAOId, 'startingNetworkBonusMultiplier');\r\n\t\t(uint256 endingNetworkBonusMultiplier,,,,) = _aoSetting.getSettingValuesByTAOName(settingTAOId, 'endingNetworkBonusMultiplier');\r\n\r\n\t\treturn (startingPrimordialMultiplier, endingPrimordialMultiplier, startingNetworkBonusMultiplier, endingNetworkBonusMultiplier);\r\n\t}\r\n}\r\n\r\n\r\n/**\r\n * @title AOPool\r\n *\r\n * This contract acts as the exchange between AO and ETH/ERC-20 compatible tokens\r\n */\r\ncontract AOPool is TheAO {\r\n\tusing SafeMath for uint256;\r\n\r\n\taddress public aoIonAddress;\r\n\tAOIon internal _aoIon;\r\n\r\n\tstruct Pool {\r\n\t\tuint256 price;\t// Flat price of AO\r\n\r\n\t\t/**\r\n\t\t * If true, Pool is live and can be sold into.\r\n\t\t * Otherwise, Pool cannot be sold into.\r\n\t\t */\r\n\t\tbool status;\r\n\r\n\t\t/**\r\n\t\t * If true, has sell cap. Otherwise, no sell cap.\r\n\t\t */\r\n\t\tbool sellCapStatus;\r\n\r\n\t\t/**\r\n\t\t * Denominated in AO, creates a cap for the amount of AO that can be\r\n\t\t * put up for sale in this pool at `price`\r\n\t\t */\r\n\t\tuint256 sellCapAmount;\r\n\r\n\t\t/**\r\n\t\t * If true, has quantity cap. Otherwise, no quantity cap.\r\n\t\t */\r\n\t\tbool quantityCapStatus;\r\n\r\n\t\t/**\r\n\t\t * Denominated in AO, creates a cap for the amount of AO at any given time\r\n\t\t * that can be available for sale in this pool\r\n\t\t */\r\n\t\tuint256 quantityCapAmount;\r\n\r\n\t\t/**\r\n\t\t * If true, the Pool is priced in an ERC20 compatible token.\r\n\t\t * Otherwise, the Pool is priced in Ethereum\r\n\t\t */\r\n\t\tbool erc20CounterAsset;\r\n\r\n\t\taddress erc20TokenAddress;\t\t\t// The address of the ERC20 Token\r\n\r\n\t\t/**\r\n\t\t * Used if ERC20 token needs to deviate from Ethereum in multiplication/division\r\n\t\t */\r\n\t\tuint256 erc20TokenMultiplier;\r\n\r\n\t\taddress adminAddress;\t\t\t\t// defaults to TheAO address, but can be modified\r\n\t}\r\n\r\n\tstruct Lot {\r\n\t\tbytes32 lotId;\t\t\t\t\t\t// The ID of this Lot\r\n\t\taddress seller;\t\t\t\t\t\t// Ethereum address of the seller\r\n\t\tuint256 lotQuantity;\t\t\t\t// Amount of AO being added to the Pool from this Lot\r\n\t\tuint256 poolId;\t\t\t\t\t\t// Identifier for the Pool this Lot is adding to\r\n\t\tuint256 poolPreSellSnapshot;\t\t// Amount of contributed to the Pool prior to this Lot Number\r\n\t\tuint256 poolSellLotSnapshot;\t\t// poolPreSellSnapshot + lotQuantity\r\n\t\tuint256 lotValueInCounterAsset;\t\t// Amount of AO x Pool Price\r\n\t\tuint256 counterAssetWithdrawn;\t\t// Amount of Counter-Asset withdrawn from this Lot\r\n\t\tuint256 ionWithdrawn;\t\t\t\t// Amount of AO withdrawn from this Lot\r\n\t\tuint256 timestamp;\r\n\t}\r\n\r\n\t// Contract variables\r\n\tuint256 public totalPool;\r\n\tuint256 public contractTotalLot;\t\t// Total lot from all pools\r\n\tuint256 public contractTotalSell;\t\t// Quantity of AO that has been contributed to all Pools\r\n\tuint256 public contractTotalBuy;\t\t// Quantity of AO that has been bought from all Pools\r\n\tuint256 public contractTotalQuantity;\t// Quantity of AO available to buy from all Pools\r\n\tuint256 public contractTotalWithdrawn;\t// Quantity of AO that has been withdrawn from all Pools\r\n\tuint256 public contractEthereumBalance;\t// Total Ethereum in contract\r\n\tuint256 public contractTotalEthereumWithdrawn; // Total Ethereum withdrawn from selling AO in contract\r\n\r\n\t// Mapping from Pool ID to Pool\r\n\tmapping (uint256 => Pool) public pools;\r\n\r\n\t// Mapping from Lot ID to Lot\r\n\tmapping (bytes32 => Lot) public lots;\r\n\r\n\t// Mapping from Pool ID to total Lots in the Pool\r\n\tmapping (uint256 => uint256) public poolTotalLot;\r\n\r\n\t// Mapping from Pool ID to quantity of AO available to buy at `price`\r\n\tmapping (uint256 => uint256) public poolTotalQuantity;\r\n\r\n\t// Mapping from Pool ID to quantity of AO that has been contributed to the Pool\r\n\tmapping (uint256 => uint256) public poolTotalSell;\r\n\r\n\t// Mapping from Pool ID to quantity of AO that has been bought from the Pool\r\n\tmapping (uint256 => uint256) public poolTotalBuy;\r\n\r\n\t// Mapping from Pool ID to quantity of AO that has been withdrawn from the Pool\r\n\tmapping (uint256 => uint256) public poolTotalWithdrawn;\r\n\r\n\t// Mapping from Pool ID to total Ethereum available to withdraw\r\n\tmapping (uint256 => uint256) public poolEthereumBalance;\r\n\r\n\t// Mapping from Pool ID to quantity of ERC20 token available to withdraw\r\n\tmapping (uint256 => uint256) public poolERC20TokenBalance;\r\n\r\n\t// Mapping from Pool ID to amount of Ethereum withdrawn from selling AO\r\n\tmapping (uint256 => uint256) public poolTotalEthereumWithdrawn;\r\n\r\n\t// Mapping from an address to quantity of AO put on sale from all sell lots\r\n\tmapping (address => uint256) public totalPutOnSale;\r\n\r\n\t// Mapping from an address to quantity of AO sold and redeemed from all sell lots\r\n\tmapping (address => uint256) public totalSold;\r\n\r\n\t// Mapping from an address to quantity of AO bought from all pool\r\n\tmapping (address => uint256) public totalBought;\r\n\r\n\t// Mapping from an address to amount of Ethereum withdrawn from selling AO\r\n\tmapping (address => uint256) public totalEthereumWithdrawn;\r\n\r\n\t// Mapping from an address to its Lots\r\n\tmapping (address => bytes32[]) internal ownerLots;\r\n\r\n\t// Mapping from Pool's Lot ID to Lot internal ID\r\n\tmapping (uint256 => mapping (bytes32 => uint256)) internal poolLotInternalIdLookup;\r\n\r\n\t// Mapping from Pool's Lot internal ID to total ion withdrawn\r\n\tmapping (uint256 => mapping (uint256 => uint256)) internal poolLotIonWithdrawn;\r\n\r\n\t// Mapping from Pool's tenth Lot to total ion withdrawn\r\n\t// This is to help optimize calculating the total ion withdrawn before certain Lot\r\n\tmapping (uint256 => mapping (uint256 => uint256)) internal poolTenthLotIonWithdrawnSnapshot;\r\n\r\n\t// Mapping from Pool's hundredth Lot to total ion withdrawn\r\n\t// This is to help optimize calculating the total ion withdrawn before certain Lot\r\n\tmapping (uint256 => mapping (uint256 => uint256)) internal poolHundredthLotIonWithdrawnSnapshot;\r\n\r\n\t// Mapping from Pool's thousandth Lot to total ion withdrawn\r\n\t// This is to help optimize calculating the total ion withdrawn before certain Lot\r\n\tmapping (uint256 => mapping (uint256 => uint256)) internal poolThousandthLotIonWithdrawnSnapshot;\r\n\r\n\t// Mapping from Pool's ten thousandth Lot to total ion withdrawn\r\n\t// This is to help optimize calculating the total ion withdrawn before certain Lot\r\n\tmapping (uint256 => mapping (uint256 => uint256)) internal poolTenThousandthLotIonWithdrawnSnapshot;\r\n\r\n\t// Mapping from Pool's hundred thousandth Lot to total ion withdrawn\r\n\t// This is to help optimize calculating the total ion withdrawn before certain Lot\r\n\tmapping (uint256 => mapping (uint256 => uint256)) internal poolHundredThousandthLotIonWithdrawnSnapshot;\r\n\r\n\t// Mapping from Pool's millionth Lot to total ion withdrawn\r\n\t// This is to help optimize calculating the total ion withdrawn before certain Lot\r\n\tmapping (uint256 => mapping (uint256 => uint256)) internal poolMillionthLotIonWithdrawnSnapshot;\r\n\r\n\t// Event to be broadcasted to public when Pool is created\r\n\tevent CreatePool(uint256 indexed poolId, address indexed adminAddress, uint256 price, bool status, bool sellCapStatus, uint256 sellCapAmount, bool quantityCapStatus, uint256 quantityCapAmount, bool erc20CounterAsset, address erc20TokenAddress, uint256 erc20TokenMultiplier);\r\n\r\n\t// Event to be broadcasted to public when Pool's status is updated\r\n\t// If status == true, start Pool\r\n\t// Otherwise, stop Pool\r\n\tevent UpdatePoolStatus(uint256 indexed poolId, bool status);\r\n\r\n\t// Event to be broadcasted to public when Pool's admin address is changed\r\n\tevent ChangeAdminAddress(uint256 indexed poolId, address newAdminAddress);\r\n\r\n\t/**\r\n\t * Event to be broadcasted to public when a seller sells AO\r\n\t *\r\n\t * If erc20CounterAsset is true, the Lot is priced in an ERC20 compatible token.\r\n\t * Otherwise, the Lot is priced in Ethereum\r\n\t */\r\n\tevent LotCreation(uint256 indexed poolId, bytes32 indexed lotId, address indexed seller, uint256 lotQuantity, uint256 price, uint256 poolPreSellSnapshot, uint256 poolSellLotSnapshot, uint256 lotValueInCounterAsset, bool erc20CounterAsset, uint256 timestamp);\r\n\r\n\t// Event to be broadcasted to public when a buyer buys AO\r\n\tevent BuyWithEth(uint256 indexed poolId, address indexed buyer, uint256 buyQuantity, uint256 price, uint256 currentPoolTotalBuy);\r\n\r\n\t// Event to be broadcasted to public when a buyer withdraw ETH from Lot\r\n\tevent WithdrawEth(address indexed seller, bytes32 indexed lotId, uint256 indexed poolId, uint256 withdrawnAmount, uint256 currentLotValueInCounterAsset, uint256 currentLotCounterAssetWithdrawn);\r\n\r\n\t// Event to be broadcasted to public when a seller withdraw ion from Lot\r\n\tevent WithdrawIon(address indexed seller, bytes32 indexed lotId, uint256 indexed poolId, uint256 withdrawnAmount, uint256 currentlotValueInCounterAsset, uint256 currentLotIonWithdrawn);\r\n\r\n\t/**\r\n\t * @dev Constructor function\r\n\t */\r\n\tconstructor(address _aoIonAddress, address _nameTAOPositionAddress) public {\r\n\t\tsetAOIonAddress(_aoIonAddress);\r\n\t\tsetNameTAOPositionAddress(_nameTAOPositionAddress);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Checks if the calling contract address is The AO\r\n\t *\t\tOR\r\n\t *\t\tIf The AO is set to a Name/TAO, then check if calling address is the Advocate\r\n\t */\r\n\tmodifier onlyTheAO {\r\n\t\trequire (AOLibrary.isTheAO(msg.sender, theAO, nameTAOPositionAddress));\r\n\t\t_;\r\n\t}\r\n\r\n\t/***** THE AO ONLY METHODS *****/\r\n\t/**\r\n\t * @dev Transfer ownership of The AO to new address\r\n\t * @param _theAO The new address to be transferred\r\n\t */\r\n\tfunction transferOwnership(address _theAO) public onlyTheAO {\r\n\t\trequire (_theAO != address(0));\r\n\t\ttheAO = _theAO;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Whitelist `_account` address to transact on behalf of others\r\n\t * @param _account The address to whitelist\r\n\t * @param _whitelist Either to whitelist or not\r\n\t */\r\n\tfunction setWhitelist(address _account, bool _whitelist) public onlyTheAO {\r\n\t\trequire (_account != address(0));\r\n\t\twhitelist[_account] = _whitelist;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev The AO set the AOIonAddress Address\r\n\t * @param _aoIonAddress The address of AOIonAddress\r\n\t */\r\n\tfunction setAOIonAddress(address _aoIonAddress) public onlyTheAO {\r\n\t\trequire (_aoIonAddress != address(0));\r\n\t\taoIonAddress = _aoIonAddress;\r\n\t\t_aoIon = AOIon(_aoIonAddress);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev The AO sets NameTAOPosition address\r\n\t * @param _nameTAOPositionAddress The address of NameTAOPosition\r\n\t */\r\n\tfunction setNameTAOPositionAddress(address _nameTAOPositionAddress) public onlyTheAO {\r\n\t\trequire (_nameTAOPositionAddress != address(0));\r\n\t\tnameTAOPositionAddress = _nameTAOPositionAddress;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Allows TheAO to transfer `_amount` of ETH from this address to `_recipient`\r\n\t * @param _recipient The recipient address\r\n\t * @param _amount The amount to transfer\r\n\t */\r\n\tfunction transferEth(address payable _recipient, uint256 _amount) public onlyTheAO {\r\n\t\t_recipient.transfer(_amount);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Allows TheAO to transfer `_amount` of ERC20 Token from this address to `_recipient`\r\n\t * @param _erc20TokenAddress The address of ERC20 Token\r\n\t * @param _recipient The recipient address\r\n\t * @param _amount The amount to transfer\r\n\t */\r\n\tfunction transferERC20(address _erc20TokenAddress, address _recipient, uint256 _amount) public onlyTheAO {\r\n\t\tTokenERC20 _erc20 = TokenERC20(_erc20TokenAddress);\r\n\t\trequire (_erc20.transfer(_recipient, _amount));\r\n\t}\r\n\r\n\t/**\r\n\t * @dev TheAO creates a Pool\r\n\t * @param _price The flat price of AO\r\n\t * @param _status The status of the Pool\r\n\t *\t\t\t\t\ttrue = Pool is live and can be sold into\r\n\t *\t\t\t\t\tfalse = Pool cannot be sold into\r\n\t * @param _sellCapStatus Whether or not the Pool has sell cap\r\n\t *\t\t\t\t\ttrue = has sell cap\r\n\t *\t\t\t\t\tfalse = no sell cap\r\n\t * @param _sellCapAmount Cap for the amount of AO that can be put up for sale in this Pool at `_price`\r\n\t * @param _quantityCapStatus Whether or not the Pool has quantity cap\r\n\t *\t\t\t\t\ttrue = has quantity cap\r\n\t *\t\t\t\t\tfalse = no quantity cap\r\n\t * @param _quantityCapAmount Cap for the amount of AO at any given time that can be available for sale in this Pool\r\n\t * @param _erc20CounterAsset Type of the Counter-Asset\r\n\t *\t\t\t\t\ttrue = Pool is priced in ERC20 compatible Token\r\n\t *\t\t\t\t\tfalse = Pool is priced in Ethereum\r\n\t * @param _erc20TokenAddress The address of the ERC20 Token\r\n\t * @param _erc20TokenMultiplier Used if ERC20 Token needs to deviate from Ethereum in multiplication/division\r\n\t */\r\n\tfunction createPool(\r\n\t\tuint256 _price,\r\n\t\tbool _status,\r\n\t\tbool _sellCapStatus,\r\n\t\tuint256 _sellCapAmount,\r\n\t\tbool _quantityCapStatus,\r\n\t\tuint256 _quantityCapAmount,\r\n\t\tbool _erc20CounterAsset,\r\n\t\taddress _erc20TokenAddress,\r\n\t\tuint256 _erc20TokenMultiplier) public onlyTheAO {\r\n\t\trequire (_price > 0);\r\n\t\t// Make sure sell cap amount is provided if sell cap is enabled\r\n\t\tif (_sellCapStatus == true) {\r\n\t\t\trequire (_sellCapAmount > 0);\r\n\t\t}\r\n\t\t// Make sure quantity cap amount is provided if quantity cap is enabled\r\n\t\tif (_quantityCapStatus == true) {\r\n\t\t\trequire (_quantityCapAmount > 0);\r\n\t\t}\r\n\t\t// Make sure the ERC20 token address and multiplier are provided\r\n\t\t// if this Pool is priced in ERC20 compatible Token\r\n\t\tif (_erc20CounterAsset == true) {\r\n\t\t\trequire (AOLibrary.isValidERC20TokenAddress(_erc20TokenAddress));\r\n\t\t\trequire (_erc20TokenMultiplier > 0);\r\n\t\t}\r\n\r\n\t\ttotalPool++;\r\n\t\tPool storage _pool = pools[totalPool];\r\n\t\t_pool.price = _price;\r\n\t\t_pool.status = _status;\r\n\t\t_pool.sellCapStatus = _sellCapStatus;\r\n\t\tif (_sellCapStatus) {\r\n\t\t\t_pool.sellCapAmount = _sellCapAmount;\r\n\t\t}\r\n\t\t_pool.quantityCapStatus = _quantityCapStatus;\r\n\t\tif (_quantityCapStatus) {\r\n\t\t\t_pool.quantityCapAmount = _quantityCapAmount;\r\n\t\t}\r\n\t\t_pool.erc20CounterAsset = _erc20CounterAsset;\r\n\t\tif (_erc20CounterAsset) {\r\n\t\t\t_pool.erc20TokenAddress = _erc20TokenAddress;\r\n\t\t\t_pool.erc20TokenMultiplier = _erc20TokenMultiplier;\r\n\t\t}\r\n\t\t_pool.adminAddress = msg.sender;\r\n\r\n\t\temit CreatePool(totalPool, _pool.adminAddress, _pool.price, _pool.status, _pool.sellCapStatus, _pool.sellCapAmount, _pool.quantityCapStatus, _pool.quantityCapAmount, _pool.erc20CounterAsset, _pool.erc20TokenAddress, _pool.erc20TokenMultiplier);\r\n\t}\r\n\r\n\t/***** Pool's Admin Only Methods *****/\r\n\t/**\r\n\t * @dev Start/Stop a Pool\r\n\t * @param _poolId The ID of the Pool\r\n\t * @param _status The status to set. true = start. false = stop\r\n\t */\r\n\tfunction updatePoolStatus(uint256 _poolId, bool _status) public {\r\n\t\t// Check pool existence by requiring price > 0\r\n\t\trequire (pools[_poolId].price > 0 && (pools[_poolId].adminAddress == msg.sender || AOLibrary.isTheAO(msg.sender, theAO, nameTAOPositionAddress)));\r\n\t\tpools[_poolId].status = _status;\r\n\t\temit UpdatePoolStatus(_poolId, _status);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Change Admin Address\r\n\t * @param _poolId The ID of the Pool\r\n\t * @param _adminAddress The new admin address to set\r\n\t */\r\n\tfunction changeAdminAddress(uint256 _poolId, address _adminAddress) public {\r\n\t\t// Check pool existence by requiring price > 0\r\n\t\trequire (pools[_poolId].price > 0 && (pools[_poolId].adminAddress == msg.sender || AOLibrary.isTheAO(msg.sender, theAO, nameTAOPositionAddress)));\r\n\t\trequire (_adminAddress != address(0));\r\n\t\tpools[_poolId].adminAddress = _adminAddress;\r\n\t\temit ChangeAdminAddress(_poolId, _adminAddress);\r\n\t}\r\n\r\n\t/***** Public Methods *****/\r\n\t/**\r\n\t * @dev Seller sells AO in Pool `_poolId` - create a Lot to be added to a Pool for a seller.\r\n\t * @param _poolId The ID of the Pool\r\n\t * @param _quantity The amount of AO to be sold\r\n\t * @param _price The price supplied by seller\r\n\t */\r\n\tfunction sell(uint256 _poolId, uint256 _quantity, uint256 _price) public {\r\n\t\tPool memory _pool = pools[_poolId];\r\n\t\trequire (_pool.status == true && _pool.price == _price && _quantity > 0 && _aoIon.balanceOf(msg.sender) >= _quantity);\r\n\r\n\t\t// If there is a sell cap\r\n\t\tif (_pool.sellCapStatus == true) {\r\n\t\t\trequire (poolTotalSell[_poolId].add(_quantity) <= _pool.sellCapAmount);\r\n\t\t}\r\n\r\n\t\t// If there is a quantity cap\r\n\t\tif (_pool.quantityCapStatus == true) {\r\n\t\t\trequire (poolTotalQuantity[_poolId].add(_quantity) <= _pool.quantityCapAmount);\r\n\t\t}\r\n\r\n\t\t// Create Lot for this sell transaction\r\n\t\tcontractTotalLot++;\r\n\t\tpoolTotalLot[_poolId]++;\r\n\r\n\t\t// Generate Lot ID\r\n\t\tbytes32 _lotId = keccak256(abi.encodePacked(this, msg.sender, contractTotalLot));\r\n\r\n\t\tLot storage _lot = lots[_lotId];\r\n\t\t_lot.lotId = _lotId;\r\n\t\t_lot.seller = msg.sender;\r\n\t\t_lot.lotQuantity = _quantity;\r\n\t\t_lot.poolId = _poolId;\r\n\t\t_lot.poolPreSellSnapshot = poolTotalSell[_poolId];\r\n\t\t_lot.poolSellLotSnapshot = poolTotalSell[_poolId].add(_quantity);\r\n\t\t_lot.lotValueInCounterAsset = _quantity.mul(_pool.price);\r\n\t\t_lot.timestamp = now;\r\n\t\tpoolLotInternalIdLookup[_poolId][_lotId] = poolTotalLot[_poolId];\r\n\t\townerLots[msg.sender].push(_lotId);\r\n\r\n\t\t// Update contract variables\r\n\t\tpoolTotalQuantity[_poolId] = poolTotalQuantity[_poolId].add(_quantity);\r\n\t\tpoolTotalSell[_poolId] = poolTotalSell[_poolId].add(_quantity);\r\n\t\ttotalPutOnSale[msg.sender] = totalPutOnSale[msg.sender].add(_quantity);\r\n\t\tcontractTotalQuantity = contractTotalQuantity.add(_quantity);\r\n\t\tcontractTotalSell = contractTotalSell.add(_quantity);\r\n\r\n\t\trequire (_aoIon.whitelistTransferFrom(msg.sender, address(this), _quantity));\r\n\r\n\t\temit LotCreation(_lot.poolId, _lot.lotId, _lot.seller, _lot.lotQuantity, _pool.price, _lot.poolPreSellSnapshot, _lot.poolSellLotSnapshot, _lot.lotValueInCounterAsset, _pool.erc20CounterAsset, _lot.timestamp);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Retrieve number of Lots an `_account` has\r\n\t * @param _account The address of the Lot's owner\r\n\t * @return Total Lots the owner has\r\n\t */\r\n\tfunction ownerTotalLot(address _account) public view returns (uint256) {\r\n\t\treturn ownerLots[_account].length;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Get list of owner's Lot IDs from `_from` to `_to` index\r\n\t * @param _account The address of the Lot's owner\r\n\t * @param _from The starting index, (i.e 0)\r\n\t * @param _to The ending index, (i.e total - 1)\r\n\t * @return list of owner's Lot IDs\r\n\t */\r\n\tfunction ownerLotIds(address _account, uint256 _from, uint256 _to) public view returns (bytes32[] memory) {\r\n\t\trequire (_from >= 0 && _to >= _from && ownerLots[_account].length > _to);\r\n\t\tbytes32[] memory _lotIds = new bytes32[](_to.sub(_from).add(1));\r\n\t\tfor (uint256 i = _from; i <= _to; i++) {\r\n\t\t\t_lotIds[i.sub(_from)] = ownerLots[_account][i];\r\n\t\t}\r\n\t\treturn _lotIds;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Buyer buys AO from Pool `_poolId` with Ethereum\r\n\t * @param _poolId The ID of the Pool\r\n\t * @param _quantity The amount of AO to be bought\r\n\t * @param _price The price supplied by buyer\r\n\t */\r\n\tfunction buyWithEth(uint256 _poolId, uint256 _quantity, uint256 _price) public payable {\r\n\t\tPool memory _pool = pools[_poolId];\r\n\t\trequire (_pool.status == true && _pool.price == _price && _pool.erc20CounterAsset == false);\r\n\t\trequire (_quantity > 0 && _quantity <= poolTotalQuantity[_poolId]);\r\n\t\trequire (msg.value > 0 && msg.value.div(_pool.price) == _quantity);\r\n\r\n\t\t// Update contract variables\r\n\t\tpoolTotalQuantity[_poolId] = poolTotalQuantity[_poolId].sub(_quantity);\r\n\t\tpoolTotalBuy[_poolId] = poolTotalBuy[_poolId].add(_quantity);\r\n\t\tpoolEthereumBalance[_poolId] = poolEthereumBalance[_poolId].add(msg.value);\r\n\r\n\t\tcontractTotalQuantity = contractTotalQuantity.sub(_quantity);\r\n\t\tcontractTotalBuy = contractTotalBuy.add(_quantity);\r\n\t\tcontractEthereumBalance = contractEthereumBalance.add(msg.value);\r\n\r\n\t\ttotalBought[msg.sender] = totalBought[msg.sender].add(_quantity);\r\n\r\n\t\trequire (_aoIon.whitelistTransferFrom(address(this), msg.sender, _quantity));\r\n\r\n\t\temit BuyWithEth(_poolId, msg.sender, _quantity, _price, poolTotalBuy[_poolId]);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Seller withdraw Ethereum from Lot `_lotId`\r\n\t * @param _lotId The ID of the Lot\r\n\t */\r\n\tfunction withdrawEth(bytes32 _lotId) public {\r\n\t\tLot storage _lot = lots[_lotId];\r\n\t\trequire (_lot.seller == msg.sender && _lot.lotValueInCounterAsset > 0);\r\n\t\t(uint256 soldQuantity, uint256 ethAvailableToWithdraw,) = lotEthAvailableToWithdraw(_lotId);\r\n\r\n\t\trequire (ethAvailableToWithdraw > 0 && ethAvailableToWithdraw <= _lot.lotValueInCounterAsset && ethAvailableToWithdraw <= poolEthereumBalance[_lot.poolId] && ethAvailableToWithdraw <= contractEthereumBalance && soldQuantity <= _lot.lotQuantity.sub(_lot.ionWithdrawn));\r\n\r\n\t\t// Update lot variables\r\n\t\t_lot.counterAssetWithdrawn = _lot.counterAssetWithdrawn.add(ethAvailableToWithdraw);\r\n\t\t_lot.lotValueInCounterAsset = _lot.lotValueInCounterAsset.sub(ethAvailableToWithdraw);\r\n\r\n\t\t// Update contract variables\r\n\t\tpoolEthereumBalance[_lot.poolId] = poolEthereumBalance[_lot.poolId].sub(ethAvailableToWithdraw);\r\n\t\tpoolTotalEthereumWithdrawn[_lot.poolId] = poolTotalEthereumWithdrawn[_lot.poolId].add(ethAvailableToWithdraw);\r\n\t\tcontractEthereumBalance = contractEthereumBalance.sub(ethAvailableToWithdraw);\r\n\t\tcontractTotalEthereumWithdrawn = contractTotalEthereumWithdrawn.add(ethAvailableToWithdraw);\r\n\r\n\t\ttotalSold[msg.sender] = totalSold[msg.sender].add(soldQuantity);\r\n\t\ttotalEthereumWithdrawn[msg.sender] = totalEthereumWithdrawn[msg.sender].add(ethAvailableToWithdraw);\r\n\r\n\t\t// Send eth to seller\r\n\t\taddress(uint160(_lot.seller)).transfer(ethAvailableToWithdraw);\r\n\t\t//_lot.seller.transfer(ethAvailableToWithdraw);\r\n\r\n\t\temit WithdrawEth(_lot.seller, _lot.lotId, _lot.poolId, ethAvailableToWithdraw, _lot.lotValueInCounterAsset, _lot.counterAssetWithdrawn);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Seller gets Lot `_lotId` (priced in ETH) available to withdraw info\r\n\t * @param _lotId The ID of the Lot\r\n\t * @return The amount of ion sold\r\n\t * @return Ethereum available to withdraw from the Lot\r\n\t * @return Current Ethereum withdrawn from the Lot\r\n\t */\r\n\tfunction lotEthAvailableToWithdraw(bytes32 _lotId) public view returns (uint256, uint256, uint256) {\r\n\t\tLot memory _lot = lots[_lotId];\r\n\t\trequire (_lot.seller != address(0));\r\n\r\n\t\tPool memory _pool = pools[_lot.poolId];\r\n\t\trequire (_pool.erc20CounterAsset == false);\r\n\r\n\t\tuint256 soldQuantity = 0;\r\n\t\tuint256 ethAvailableToWithdraw = 0;\r\n\r\n\t\t// Check whether or not there are ions withdrawn from Lots before this Lot\r\n\t\tuint256 lotAdjustment = totalIonWithdrawnBeforeLot(_lotId);\r\n\r\n\t\tif (poolTotalBuy[_lot.poolId] > _lot.poolPreSellSnapshot.sub(lotAdjustment) && _lot.lotValueInCounterAsset > 0) {\r\n\t\t\tsoldQuantity = (poolTotalBuy[_lot.poolId] >= _lot.poolSellLotSnapshot.sub(lotAdjustment)) ? _lot.lotQuantity : poolTotalBuy[_lot.poolId].sub(_lot.poolPreSellSnapshot.sub(lotAdjustment));\r\n\t\t\tif (soldQuantity > 0) {\r\n\t\t\t\tif (soldQuantity > _lot.ionWithdrawn) {\r\n\t\t\t\t\tsoldQuantity = soldQuantity.sub(_lot.ionWithdrawn);\r\n\t\t\t\t}\r\n\t\t\t\tsoldQuantity = soldQuantity.sub(_lot.counterAssetWithdrawn.div(_pool.price));\r\n\t\t\t\tethAvailableToWithdraw = soldQuantity.mul(_pool.price);\r\n\t\t\t\tassert (soldQuantity <= _lot.lotValueInCounterAsset.div(_pool.price));\r\n\t\t\t\tassert (soldQuantity.add(_lot.ionWithdrawn) <= _lot.lotQuantity);\r\n\t\t\t\tassert (ethAvailableToWithdraw <= _lot.lotValueInCounterAsset);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn (soldQuantity, ethAvailableToWithdraw, _lot.counterAssetWithdrawn);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Seller withdraw ion from Lot `_lotId`\r\n\t * @param _lotId The ID of the Lot\r\n\t * @param _quantity The amount of ion to withdraw\r\n\t */\r\n\tfunction withdrawIon(bytes32 _lotId, uint256 _quantity) public {\r\n\t\tLot storage _lot = lots[_lotId];\r\n\t\trequire (_lot.seller == msg.sender && _lot.lotValueInCounterAsset > 0);\r\n\r\n\t\tPool memory _pool = pools[_lot.poolId];\r\n\t\trequire (_quantity > 0 && _quantity <= _lot.lotValueInCounterAsset.div(_pool.price));\r\n\r\n\t\t// Update lot variables\r\n\t\t_lot.ionWithdrawn = _lot.ionWithdrawn.add(_quantity);\r\n\t\t_lot.lotValueInCounterAsset = _lot.lotValueInCounterAsset.sub(_quantity.mul(_pool.price));\r\n\t\tpoolLotIonWithdrawn[_lot.poolId][poolLotInternalIdLookup[_lot.poolId][_lotId]] = poolLotIonWithdrawn[_lot.poolId][poolLotInternalIdLookup[_lot.poolId][_lotId]].add(_quantity);\r\n\r\n\t\t// Store Pool's millionth Lot snapshot\r\n\t\tuint256 millionth = poolLotInternalIdLookup[_lot.poolId][_lotId].div(1000000);\r\n\t\tif (poolLotInternalIdLookup[_lot.poolId][_lotId].sub(millionth.mul(1000000)) != 0) {\r\n\t\t\tmillionth++;\r\n\t\t}\r\n\t\tpoolMillionthLotIonWithdrawnSnapshot[_lot.poolId][millionth] = poolMillionthLotIonWithdrawnSnapshot[_lot.poolId][millionth].add(_quantity);\r\n\r\n\t\t// Store Pool's hundred thousandth Lot snapshot\r\n\t\tuint256 hundredThousandth = poolLotInternalIdLookup[_lot.poolId][_lotId].div(100000);\r\n\t\tif (poolLotInternalIdLookup[_lot.poolId][_lotId].sub(hundredThousandth.mul(100000)) != 0) {\r\n\t\t\thundredThousandth++;\r\n\t\t}\r\n\t\tpoolHundredThousandthLotIonWithdrawnSnapshot[_lot.poolId][hundredThousandth] = poolHundredThousandthLotIonWithdrawnSnapshot[_lot.poolId][hundredThousandth].add(_quantity);\r\n\r\n\t\t// Store Pool's ten thousandth Lot snapshot\r\n\t\tuint256 tenThousandth = poolLotInternalIdLookup[_lot.poolId][_lotId].div(10000);\r\n\t\tif (poolLotInternalIdLookup[_lot.poolId][_lotId].sub(tenThousandth.mul(10000)) != 0) {\r\n\t\t\ttenThousandth++;\r\n\t\t}\r\n\t\tpoolTenThousandthLotIonWithdrawnSnapshot[_lot.poolId][tenThousandth] = poolTenThousandthLotIonWithdrawnSnapshot[_lot.poolId][tenThousandth].add(_quantity);\r\n\r\n\t\t// Store Pool's thousandth Lot snapshot\r\n\t\tuint256 thousandth = poolLotInternalIdLookup[_lot.poolId][_lotId].div(1000);\r\n\t\tif (poolLotInternalIdLookup[_lot.poolId][_lotId].sub(thousandth.mul(1000)) != 0) {\r\n\t\t\tthousandth++;\r\n\t\t}\r\n\t\tpoolThousandthLotIonWithdrawnSnapshot[_lot.poolId][thousandth] = poolThousandthLotIonWithdrawnSnapshot[_lot.poolId][thousandth].add(_quantity);\r\n\r\n\t\t// Store Pool's hundredth Lot snapshot\r\n\t\tuint256 hundredth = poolLotInternalIdLookup[_lot.poolId][_lotId].div(100);\r\n\t\tif (poolLotInternalIdLookup[_lot.poolId][_lotId].sub(hundredth.mul(100)) != 0) {\r\n\t\t\thundredth++;\r\n\t\t}\r\n\t\tpoolHundredthLotIonWithdrawnSnapshot[_lot.poolId][hundredth] = poolHundredthLotIonWithdrawnSnapshot[_lot.poolId][hundredth].add(_quantity);\r\n\r\n\t\t// Store Pool's tenth Lot snapshot\r\n\t\tuint256 tenth = poolLotInternalIdLookup[_lot.poolId][_lotId].div(10);\r\n\t\tif (poolLotInternalIdLookup[_lot.poolId][_lotId].sub(tenth.mul(10)) != 0) {\r\n\t\t\ttenth++;\r\n\t\t}\r\n\t\tpoolTenthLotIonWithdrawnSnapshot[_lot.poolId][tenth] = poolTenthLotIonWithdrawnSnapshot[_lot.poolId][tenth].add(_quantity);\r\n\r\n\t\t// Update contract variables\r\n\t\tpoolTotalQuantity[_lot.poolId] = poolTotalQuantity[_lot.poolId].sub(_quantity);\r\n\t\tcontractTotalQuantity = contractTotalQuantity.sub(_quantity);\r\n\t\tpoolTotalWithdrawn[_lot.poolId] = poolTotalWithdrawn[_lot.poolId].add(_quantity);\r\n\t\tcontractTotalWithdrawn = contractTotalWithdrawn.add(_quantity);\r\n\r\n\t\ttotalPutOnSale[msg.sender] = totalPutOnSale[msg.sender].sub(_quantity);\r\n\r\n\t\tassert (_lot.ionWithdrawn.add(_lot.lotValueInCounterAsset.div(_pool.price)).add(_lot.counterAssetWithdrawn.div(_pool.price)) == _lot.lotQuantity);\r\n\r\n\t\trequire (_aoIon.whitelistTransferFrom(address(this), msg.sender, _quantity));\r\n\r\n\t\temit WithdrawIon(_lot.seller, _lot.lotId, _lot.poolId, _quantity, _lot.lotValueInCounterAsset, _lot.ionWithdrawn);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Get total ion withdrawn from all Lots before Lot `_lotId`\r\n\t * @param _lotId The ID of the Lot\r\n\t * @return Total ion withdrawn from all Lots before Lot `_lotId`\r\n\t */\r\n\tfunction totalIonWithdrawnBeforeLot(bytes32 _lotId) public view returns (uint256) {\r\n\t\tLot memory _lot = lots[_lotId];\r\n\t\trequire (_lot.seller != address(0) && poolLotInternalIdLookup[_lot.poolId][_lotId] > 0);\r\n\r\n\t\tuint256 totalIonWithdrawn = 0;\r\n\t\tuint256 lotInternalId = poolLotInternalIdLookup[_lot.poolId][_lotId];\r\n\t\tuint256 lowerBound = 0;\r\n\r\n\t\tuint256 millionth = lotInternalId.div(1000000);\r\n\t\tif (millionth > 0) {\r\n\t\t\tfor (uint256 i=1; i<=millionth; i++) {\r\n\t\t\t\tif (poolMillionthLotIonWithdrawnSnapshot[_lot.poolId][i] > 0) {\r\n\t\t\t\t\ttotalIonWithdrawn = totalIonWithdrawn.add(poolMillionthLotIonWithdrawnSnapshot[_lot.poolId][i]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tlowerBound = millionth.mul(1000000);\r\n\t\t\tif (lowerBound == lotInternalId) {\r\n\t\t\t\ttotalIonWithdrawn = totalIonWithdrawn.sub(poolLotIonWithdrawn[_lot.poolId][lotInternalId]);\r\n\t\t\t\treturn totalIonWithdrawn;\r\n\t\t\t} else {\r\n\t\t\t\tlowerBound = lowerBound.div(100000);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tuint256 hundredThousandth = lotInternalId.div(100000);\r\n\t\tif (hundredThousandth > 0) {\r\n\t\t\tfor (uint256 i=lowerBound.add(1); i<=hundredThousandth; i++) {\r\n\t\t\t\tif (poolHundredThousandthLotIonWithdrawnSnapshot[_lot.poolId][i] > 0) {\r\n\t\t\t\t\ttotalIonWithdrawn = totalIonWithdrawn.add(poolHundredThousandthLotIonWithdrawnSnapshot[_lot.poolId][i]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tlowerBound = hundredThousandth.mul(100000);\r\n\t\t\tif (lowerBound == lotInternalId) {\r\n\t\t\t\ttotalIonWithdrawn = totalIonWithdrawn.sub(poolLotIonWithdrawn[_lot.poolId][lotInternalId]);\r\n\t\t\t\treturn totalIonWithdrawn;\r\n\t\t\t} else {\r\n\t\t\t\tlowerBound = lowerBound.div(10000);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tuint256 tenThousandth = lotInternalId.div(10000);\r\n\t\tif (tenThousandth > 0) {\r\n\t\t\tfor (uint256 i=lowerBound.add(1); i<=tenThousandth; i++) {\r\n\t\t\t\tif (poolTenThousandthLotIonWithdrawnSnapshot[_lot.poolId][i] > 0) {\r\n\t\t\t\t\ttotalIonWithdrawn = totalIonWithdrawn.add(poolTenThousandthLotIonWithdrawnSnapshot[_lot.poolId][i]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tlowerBound = tenThousandth.mul(10000);\r\n\t\t\tif (lowerBound == lotInternalId) {\r\n\t\t\t\ttotalIonWithdrawn = totalIonWithdrawn.sub(poolLotIonWithdrawn[_lot.poolId][lotInternalId]);\r\n\t\t\t\treturn totalIonWithdrawn;\r\n\t\t\t} else {\r\n\t\t\t\tlowerBound = lowerBound.div(1000);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tuint256 thousandth = lotInternalId.div(1000);\r\n\t\tif (thousandth > 0) {\r\n\t\t\tfor (uint256 i=lowerBound.add(1); i<=thousandth; i++) {\r\n\t\t\t\tif (poolThousandthLotIonWithdrawnSnapshot[_lot.poolId][i] > 0) {\r\n\t\t\t\t\ttotalIonWithdrawn = totalIonWithdrawn.add(poolThousandthLotIonWithdrawnSnapshot[_lot.poolId][i]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tlowerBound = thousandth.mul(1000);\r\n\t\t\tif (lowerBound == lotInternalId) {\r\n\t\t\t\ttotalIonWithdrawn = totalIonWithdrawn.sub(poolLotIonWithdrawn[_lot.poolId][lotInternalId]);\r\n\t\t\t\treturn totalIonWithdrawn;\r\n\t\t\t} else {\r\n\t\t\t\tlowerBound = lowerBound.div(100);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tuint256 hundredth = lotInternalId.div(100);\r\n\t\tif (hundredth > 0) {\r\n\t\t\tfor (uint256 i=lowerBound.add(1); i<=hundredth; i++) {\r\n\t\t\t\tif (poolHundredthLotIonWithdrawnSnapshot[_lot.poolId][i] > 0) {\r\n\t\t\t\t\ttotalIonWithdrawn = totalIonWithdrawn.add(poolHundredthLotIonWithdrawnSnapshot[_lot.poolId][i]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tlowerBound = hundredth.mul(100);\r\n\t\t\tif (lowerBound == lotInternalId) {\r\n\t\t\t\ttotalIonWithdrawn = totalIonWithdrawn.sub(poolLotIonWithdrawn[_lot.poolId][lotInternalId]);\r\n\t\t\t\treturn totalIonWithdrawn;\r\n\t\t\t} else {\r\n\t\t\t\tlowerBound = lowerBound.div(10);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tuint256 tenth = lotInternalId.div(10);\r\n\t\tif (tenth > 0) {\r\n\t\t\tfor (uint256 i=lowerBound.add(1); i<=tenth; i++) {\r\n\t\t\t\tif (poolTenthLotIonWithdrawnSnapshot[_lot.poolId][i] > 0) {\r\n\t\t\t\t\ttotalIonWithdrawn = totalIonWithdrawn.add(poolTenthLotIonWithdrawnSnapshot[_lot.poolId][i]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tlowerBound = tenth.mul(10);\r\n\t\t\tif (lowerBound == lotInternalId) {\r\n\t\t\t\ttotalIonWithdrawn = totalIonWithdrawn.sub(poolLotIonWithdrawn[_lot.poolId][lotInternalId]);\r\n\t\t\t\treturn totalIonWithdrawn;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfor (uint256 i=lowerBound.add(1); i<lotInternalId; i++) {\r\n\t\t\tif (poolLotIonWithdrawn[_lot.poolId][i] > 0) {\r\n\t\t\t\ttotalIonWithdrawn = totalIonWithdrawn.add(poolLotIonWithdrawn[_lot.poolId][i]);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn totalIonWithdrawn;\r\n\t}\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"poolERC20TokenBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_poolId\",\"type\":\"uint256\"},{\"name\":\"_quantity\",\"type\":\"uint256\"},{\"name\":\"_price\",\"type\":\"uint256\"}],\"name\":\"buyWithEth\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"contractTotalQuantity\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"contractTotalBuy\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_poolId\",\"type\":\"uint256\"},{\"name\":\"_adminAddress\",\"type\":\"address\"}],\"name\":\"changeAdminAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_lotId\",\"type\":\"bytes32\"},{\"name\":\"_quantity\",\"type\":\"uint256\"}],\"name\":\"withdrawIon\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"contractTotalSell\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"aoIonAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"totalBought\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"poolTotalQuantity\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nameTAOPositionAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"contractTotalLot\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_account\",\"type\":\"address\"},{\"name\":\"_whitelist\",\"type\":\"bool\"}],\"name\":\"setWhitelist\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_poolId\",\"type\":\"uint256\"},{\"name\":\"_status\",\"type\":\"bool\"}],\"name\":\"updatePoolStatus\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_nameTAOPositionAddress\",\"type\":\"address\"}],\"name\":\"setNameTAOPositionAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"ownerTotalLot\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"poolTotalBuy\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"contractEthereumBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"whitelist\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_erc20TokenAddress\",\"type\":\"address\"},{\"name\":\"_recipient\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transferERC20\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"theAO\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"pools\",\"outputs\":[{\"name\":\"price\",\"type\":\"uint256\"},{\"name\":\"status\",\"type\":\"bool\"},{\"name\":\"sellCapStatus\",\"type\":\"bool\"},{\"name\":\"sellCapAmount\",\"type\":\"uint256\"},{\"name\":\"quantityCapStatus\",\"type\":\"bool\"},{\"name\":\"quantityCapAmount\",\"type\":\"uint256\"},{\"name\":\"erc20CounterAsset\",\"type\":\"bool\"},{\"name\":\"erc20TokenAddress\",\"type\":\"address\"},{\"name\":\"erc20TokenMultiplier\",\"type\":\"uint256\"},{\"name\":\"adminAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"poolEthereumBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"totalPutOnSale\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"poolTotalLot\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"poolTotalEthereumWithdrawn\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_lotId\",\"type\":\"bytes32\"}],\"name\":\"lotEthAvailableToWithdraw\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"poolTotalWithdrawn\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"contractTotalWithdrawn\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_lotId\",\"type\":\"bytes32\"}],\"name\":\"withdrawEth\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"totalEthereumWithdrawn\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_poolId\",\"type\":\"uint256\"},{\"name\":\"_quantity\",\"type\":\"uint256\"},{\"name\":\"_price\",\"type\":\"uint256\"}],\"name\":\"sell\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"contractTotalEthereumWithdrawn\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"poolTotalSell\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"lots\",\"outputs\":[{\"name\":\"lotId\",\"type\":\"bytes32\"},{\"name\":\"seller\",\"type\":\"address\"},{\"name\":\"lotQuantity\",\"type\":\"uint256\"},{\"name\":\"poolId\",\"type\":\"uint256\"},{\"name\":\"poolPreSellSnapshot\",\"type\":\"uint256\"},{\"name\":\"poolSellLotSnapshot\",\"type\":\"uint256\"},{\"name\":\"lotValueInCounterAsset\",\"type\":\"uint256\"},{\"name\":\"counterAssetWithdrawn\",\"type\":\"uint256\"},{\"name\":\"ionWithdrawn\",\"type\":\"uint256\"},{\"name\":\"timestamp\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_price\",\"type\":\"uint256\"},{\"name\":\"_status\",\"type\":\"bool\"},{\"name\":\"_sellCapStatus\",\"type\":\"bool\"},{\"name\":\"_sellCapAmount\",\"type\":\"uint256\"},{\"name\":\"_quantityCapStatus\",\"type\":\"bool\"},{\"name\":\"_quantityCapAmount\",\"type\":\"uint256\"},{\"name\":\"_erc20CounterAsset\",\"type\":\"bool\"},{\"name\":\"_erc20TokenAddress\",\"type\":\"address\"},{\"name\":\"_erc20TokenMultiplier\",\"type\":\"uint256\"}],\"name\":\"createPool\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"totalSold\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_recipient\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transferEth\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalPool\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_theAO\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_account\",\"type\":\"address\"},{\"name\":\"_from\",\"type\":\"uint256\"},{\"name\":\"_to\",\"type\":\"uint256\"}],\"name\":\"ownerLotIds\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_aoIonAddress\",\"type\":\"address\"}],\"name\":\"setAOIonAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_lotId\",\"type\":\"bytes32\"}],\"name\":\"totalIonWithdrawnBeforeLot\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_aoIonAddress\",\"type\":\"address\"},{\"name\":\"_nameTAOPositionAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"poolId\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"adminAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"price\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"status\",\"type\":\"bool\"},{\"indexed\":false,\"name\":\"sellCapStatus\",\"type\":\"bool\"},{\"indexed\":false,\"name\":\"sellCapAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"quantityCapStatus\",\"type\":\"bool\"},{\"indexed\":false,\"name\":\"quantityCapAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"erc20CounterAsset\",\"type\":\"bool\"},{\"indexed\":false,\"name\":\"erc20TokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"erc20TokenMultiplier\",\"type\":\"uint256\"}],\"name\":\"CreatePool\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"poolId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"UpdatePoolStatus\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"poolId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"newAdminAddress\",\"type\":\"address\"}],\"name\":\"ChangeAdminAddress\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"poolId\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"lotId\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"seller\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"lotQuantity\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"price\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"poolPreSellSnapshot\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"poolSellLotSnapshot\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"lotValueInCounterAsset\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"erc20CounterAsset\",\"type\":\"bool\"},{\"indexed\":false,\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"LotCreation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"poolId\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"buyQuantity\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"price\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"currentPoolTotalBuy\",\"type\":\"uint256\"}],\"name\":\"BuyWithEth\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"seller\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"lotId\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"poolId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"withdrawnAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"currentLotValueInCounterAsset\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"currentLotCounterAssetWithdrawn\",\"type\":\"uint256\"}],\"name\":\"WithdrawEth\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"seller\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"lotId\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"poolId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"withdrawnAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"currentlotValueInCounterAsset\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"currentLotIonWithdrawn\",\"type\":\"uint256\"}],\"name\":\"WithdrawIon\",\"type\":\"event\"}]","ContractName":"AOPool","CompilerVersion":"v0.5.4+commit.9549d8ff","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000007fea965a502f3f17851a57bcc57e95e03d83e98a0000000000000000000000001f7f65b220a0f2d48b28390380f57468e7a382fe","Library":"AOLibrary:1150d53299Abb7DE27464D01B626728f5c840229","SwarmSource":"bzzr://586352516fa7197f48593cbbe0b6d2fb7b3794c4e39c936f8bd343c92353f8d5"}]}