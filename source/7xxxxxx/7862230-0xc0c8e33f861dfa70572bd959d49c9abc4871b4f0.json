{"status":"1","message":"OK","result":[{"SourceCode":"// File: contracts/ignored_contracts/Ownable.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\ncontract Ownable {\r\n\r\n  address public owner_;\r\n\r\n  event TransferApproved(address indexed _previousOwner, address indexed _newOwner);\r\n  event TransferRequested(address indexed _currentOwner, address indexed _requestedOwner);\r\n  event RequestRevoked(address indexed _currentOwner, address indexed _requestOwner);\r\n\r\n  mapping(bytes32 => bool) public requesters_; // keccak256 hashes of requester addresses\r\n\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner_);\r\n    _;\r\n  }\r\n\r\n  modifier hasNotRequested() {\r\n    require(!requesters_[keccak256(abi.encodePacked(msg.sender))],\r\n      \"Ownership request already active.\");\r\n    _;\r\n  }\r\n\r\n  modifier hasRequested(address _newOwner) {\r\n    require(requesters_[keccak256(abi.encodePacked(_newOwner))], \r\n      \"Owner request has not been sent.\");\r\n    _;\r\n  }\r\n\r\n  function requestOwnership() public hasNotRequested {\r\n    bytes32 hashedAddress = keccak256(abi.encodePacked(msg.sender));\r\n    requesters_[hashedAddress] = true;\r\n    emit TransferRequested(owner_, msg.sender);\r\n  }\r\n\r\n  function revokeOwnershipRequest() public hasRequested(msg.sender) {\r\n    bytes32 hashedAddress = keccak256(abi.encodePacked(msg.sender));\r\n    requesters_[hashedAddress] = false;\r\n    emit RequestRevoked(owner_, msg.sender);\r\n  }\r\n\r\n  function approveOwnershipTransfer(address _newOwner) public onlyOwner hasRequested(_newOwner) {\r\n    owner_ = _newOwner;\r\n    bytes32 hashedAddress = keccak256(abi.encodePacked(msg.sender));\r\n    requesters_[hashedAddress] = false;\r\n  }\r\n\r\n}\r\n\r\n// File: contracts/SafeMath32.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\nlibrary SafeMath32 {\r\n\r\n  function mul(uint32 a, uint32 b) internal pure returns (uint32) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    uint32 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint32 a, uint32 b) internal pure returns (uint32) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint32 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesnâ€™t hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint32 a, uint32 b) internal pure returns (uint32) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint32 a, uint32 b) internal pure returns (uint32) {\r\n    uint32 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n// File: contracts/AraProxy.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\n/**\r\n * @title AraProxy\r\n * @dev Gives the possibility to delegate any call to a foreign implementation.\r\n */\r\ncontract AraProxy {\r\n\r\n  bytes32 private constant registryPosition_ = keccak256(\"io.ara.proxy.registry\");\r\n  bytes32 private constant implementationPosition_ = keccak256(\"io.ara.proxy.implementation\");\r\n\r\n  modifier restricted() {\r\n    bytes32 registryPosition = registryPosition_;\r\n    address registryAddress;\r\n    assembly {\r\n      registryAddress := sload(registryPosition)\r\n    }\r\n    require(\r\n      msg.sender == registryAddress,\r\n      \"Only the AraRegistry can upgrade this proxy.\"\r\n    );\r\n    _;\r\n  }\r\n\r\n  /**\r\n  * @dev the constructor sets the AraRegistry address\r\n  */\r\n  constructor(address _registryAddress, address _implementationAddress) public {\r\n    bytes32 registryPosition = registryPosition_;\r\n    bytes32 implementationPosition = implementationPosition_;\r\n    assembly {\r\n      sstore(registryPosition, _registryAddress)\r\n      sstore(implementationPosition, _implementationAddress)\r\n    }\r\n  }\r\n\r\n  function setImplementation(address _newImplementation) public restricted {\r\n    require(_newImplementation != address(0));\r\n    bytes32 implementationPosition = implementationPosition_;\r\n    assembly {\r\n      sstore(implementationPosition, _newImplementation)\r\n    }\r\n  }\r\n\r\n  /**\r\n  * @dev Fallback function allowing to perform a delegatecall to the given implementation.\r\n  * This function will return whatever the implementation call returns\r\n  */\r\n  function () payable public {\r\n    bytes32 implementationPosition = implementationPosition_;\r\n    address _impl;\r\n    assembly {\r\n      _impl := sload(implementationPosition)\r\n    }\r\n\r\n    assembly {\r\n      let ptr := mload(0x40)\r\n      calldatacopy(ptr, 0, calldatasize)\r\n      let result := delegatecall(gas, _impl, ptr, calldatasize, 0, 0)\r\n      let size := returndatasize\r\n      returndatacopy(ptr, 0, size)\r\n\r\n      switch result\r\n      case 0 { revert(ptr, size) }\r\n      default { return(ptr, size) }\r\n    }\r\n  }\r\n}\r\n\r\n// File: contracts/ignored_contracts/Registry.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\ncontract Registry {\r\n  address public owner_;\r\n  mapping (bytes32 => address) private proxies_; // contentId (unhashed) => proxy\r\n  mapping (bytes32 => address) private proxyOwners_; // contentId (unhashed) => owner\r\n  mapping (string => address) private versions_; // version => implementation\r\n  mapping (address => string) public proxyImpls_; // proxy => version\r\n  string public latestVersion_;\r\n\r\n  event ProxyDeployed(address indexed _owner, bytes32 indexed _contentId, address _address);\r\n  event ProxyUpgraded(bytes32 indexed _contentId, string indexed _version);\r\n  event StandardAdded(string indexed _version, address _address);\r\n\r\n  function init(bytes _data) public {\r\n    require(owner_ == address(0), 'Registry has already been initialized.');\r\n\r\n    uint256 btsptr;\r\n    address ownerAddr;\r\n    assembly {\r\n      btsptr := add(_data, 32)\r\n      ownerAddr := mload(btsptr)\r\n    }\r\n    owner_ = ownerAddr;\r\n  }\r\n\r\n  modifier restricted() {\r\n    require (\r\n      msg.sender == owner_,\r\n      \"Sender not authorized.\"\r\n    );\r\n    _;\r\n  }\r\n\r\n  modifier onlyProxyOwner(bytes32 _contentId) {\r\n    require(\r\n      proxyOwners_[_contentId] == msg.sender,\r\n      \"Sender not authorized.\"\r\n    );\r\n    _;\r\n  }\r\n\r\n  function getProxyAddress(bytes32 _contentId) public view returns (address) {\r\n    return proxies_[_contentId];\r\n  }\r\n\r\n  function getProxyOwner(bytes32 _contentId) public view returns (address) {\r\n    return proxyOwners_[_contentId];\r\n  }\r\n\r\n  function getImplementation(string _version) public view returns (address) {\r\n    return versions_[_version];\r\n  }\r\n\r\n  function getProxyVersion(bytes32 _contentId) public view returns (string) {\r\n    return proxyImpls_[getProxyAddress(_contentId)];\r\n  }\r\n  \r\n  /**\r\n   * @dev AFS Proxy Factory\r\n   * @param _contentId The unhashed methodless content DID\r\n   * @param _version The implementation version to use with this Proxy\r\n   * @param _data AFS initialization data\r\n   * @return address of the newly deployed Proxy\r\n   */\r\n  function createAFS(bytes32 _contentId, string _version, bytes _data) public {\r\n    require(proxies_[_contentId] == address(0), \"Proxy already exists for this content.\");\r\n    require(versions_[_version] != address(0), \"Version does not exist.\");\r\n    AraProxy proxy = new AraProxy(address(this), versions_[_version]);\r\n    proxies_[_contentId] = proxy;\r\n    proxyOwners_[_contentId] = msg.sender;\r\n    upgradeProxyAndCall(_contentId, _version, _data);\r\n    emit ProxyDeployed(msg.sender, _contentId, address(proxy));\r\n  }\r\n\r\n  /**\r\n   * @dev Upgrades proxy implementation version\r\n   * @param _contentId The unhashed methodless content DID\r\n   * @param _version The implementation version to upgrade this Proxy to\r\n   */\r\n  function upgradeProxy(bytes32 _contentId, string _version) public onlyProxyOwner(_contentId) {\r\n    require(versions_[_version] != address(0), \"Version does not exist.\");\r\n    AraProxy proxy = AraProxy(proxies_[_contentId]);\r\n    proxy.setImplementation(versions_[_version]);\r\n    proxyImpls_[proxies_[_contentId]] = _version;\r\n    emit ProxyUpgraded(_contentId, _version);\r\n  }\r\n\r\n  /**\r\n   * @dev Upgrades proxy implementation version with initialization\r\n   * @param _contentId The unhashed methodless content DID\r\n   * @param _version The implementation version to upgrade this Proxy to\r\n   * @param _data AFS initialization data\r\n   */\r\n  function upgradeProxyAndCall(bytes32 _contentId, string _version, bytes _data) public onlyProxyOwner(_contentId) {\r\n    require(versions_[_version] != address(0), \"Version does not exist.\");\r\n    require(keccak256(abi.encodePacked(proxyImpls_[proxy])) != keccak256(abi.encodePacked(_version)), \"Proxy is already on this version.\");\r\n    AraProxy proxy = AraProxy(proxies_[_contentId]);\r\n    proxy.setImplementation(versions_[_version]);\r\n    proxyImpls_[proxy] = _version;\r\n    require(address(proxy).call(abi.encodeWithSignature(\"init(bytes)\", _data)), \"Init failed.\");\r\n    emit ProxyUpgraded(_contentId, _version);\r\n  }\r\n\r\n  /**\r\n   * @dev Adds a new AFS implementation standard\r\n   * @param _version The implementation version name\r\n   * @param _address The address of the new AFS implementation\r\n   */\r\n  function addStandardVersion(string _version, address _address) public restricted {\r\n    require(versions_[_version] == address(0), \"Version already exists.\");\r\n    versions_[_version] = _address;\r\n    latestVersion_ = _version;\r\n    emit StandardAdded(_version, _address);\r\n  }\r\n}\r\n\r\n// File: contracts/ignored_contracts/Library.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\n\r\ncontract Library {\r\n  using SafeMath32 for uint32;\r\n\r\n  address public owner_;\r\n  mapping (bytes32 => Lib) private libraries_; // hashed methodless owner did => library\r\n  Registry registry_;\r\n\r\n  struct Lib {\r\n    uint32 size;\r\n    mapping (uint32 => bytes32) content; // index => contentId (unhashed)\r\n  }\r\n\r\n  event AddedToLib(bytes32 indexed _identity, bytes32 indexed _contentId);\r\n\r\n  function init(bytes _data) public {\r\n    require(owner_ == address(0), 'Library has already been initialized.');\r\n\r\n    uint256 btsptr;\r\n    address ownerAddr;\r\n    address registryAddr;\r\n    assembly {\r\n      btsptr := add(_data, 32)\r\n      ownerAddr := mload(btsptr)\r\n      btsptr := add(_data, 64)\r\n      registryAddr := mload(btsptr)\r\n    }\r\n    owner_ = ownerAddr;\r\n    registry_ = Registry(registryAddr);\r\n  }\r\n\r\n  modifier restricted() {\r\n    require (msg.sender == owner_, \"Sender not authorized.\");\r\n     _;\r\n  }\r\n\r\n  modifier fromProxy(bytes32 _contentId) {\r\n    require (msg.sender == registry_.getProxyAddress(_contentId), \"Proxy not authorized.\");\r\n     _;\r\n  }\r\n\r\n  function getLibrarySize(bytes32 _identity) public view returns (uint32 size) {\r\n    return libraries_[_identity].size;\r\n  }\r\n\r\n  function getLibraryItem(bytes32 _identity, uint32 _index) public view returns (bytes32 contentId) {\r\n    require (_index < libraries_[_identity].size, \"Index does not exist.\");\r\n    return libraries_[_identity].content[_index];\r\n  }\r\n\r\n  function addLibraryItem(bytes32 _identity, bytes32 _contentId) public fromProxy(_contentId) {\r\n    uint32 libSize = libraries_[_identity].size;\r\n    assert (libraries_[_identity].content[libSize] == bytes32(0));\r\n    libraries_[_identity].content[libSize] = _contentId;\r\n    libraries_[_identity].size++;\r\n    emit AddedToLib(_identity, _contentId);\r\n  }\r\n}\r\n\r\n// File: contracts/ignored_contracts/ERC20.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\n/**\r\n * NOTE: This contract will be removed once openzeppelin-solidity releases this code as an official release.\r\n */\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 {\r\n  function totalSupply() public view returns (uint256);\r\n\r\n  function balanceOf(address _who) public view returns (uint256);\r\n\r\n  function allowance(address _owner, address _spender)\r\n    public view returns (uint256);\r\n\r\n  function transfer(address _to, uint256 _value) public returns (bool);\r\n\r\n  function approve(address _spender, uint256 _value)\r\n    public returns (bool);\r\n\r\n  function transferFrom(address _from, address _to, uint256 _value)\r\n    public returns (bool);\r\n\r\n  event Transfer(\r\n    address indexed from,\r\n    address indexed to,\r\n    uint256 value\r\n  );\r\n\r\n  event Approval(\r\n    address indexed owner,\r\n    address indexed spender,\r\n    uint256 value\r\n  );\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/math/SafeMath.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, reverts on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    uint256 c = a * b;\r\n    require(c / a == b);\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b > 0); // Solidity only automatically asserts when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b <= a);\r\n    uint256 c = a - b;\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, reverts on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    require(c >= a);\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\r\n  * reverts when dividing by zero.\r\n  */\r\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b != 0);\r\n    return a % b;\r\n  }\r\n}\r\n\r\n// File: contracts/ignored_contracts/StandardToken.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\n/**\r\n * NOTE: This contract will be removed once openzeppelin-solidity releases this code as an official release.\r\n * -Charles \r\n */\r\n\r\n\r\n\r\n/**\r\n * @title Standard ERC20 token\r\n *\r\n * @dev Implementation of the basic standard token.\r\n * https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md\r\n * Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\r\n */\r\ncontract StandardToken is ERC20 {\r\n  using SafeMath for uint256;\r\n\r\n  mapping (address => uint256) private balances_;\r\n\r\n  mapping (address => mapping (address => uint256)) private allowed_;\r\n\r\n  uint256 private totalSupply_;\r\n\r\n  /**\r\n  * @dev Total number of tokens in existence\r\n  */\r\n  function totalSupply() public view returns (uint256) {\r\n    return totalSupply_;\r\n  }\r\n\r\n  /**\r\n  * @dev Gets the balance of the specified address.\r\n  * @param _owner The address to query the the balance of.\r\n  * @return An uint256 representing the amount owned by the passed address.\r\n  */\r\n  function balanceOf(address _owner) public view returns (uint256) {\r\n    return balances_[_owner];\r\n  }\r\n\r\n  /**\r\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n   * @param _owner address The address which owns the funds.\r\n   * @param _spender address The address which will spend the funds.\r\n   * @return A uint256 specifying the amount of tokens still available for the spender.\r\n   */\r\n  function allowance(\r\n    address _owner,\r\n    address _spender\r\n   )\r\n    public\r\n    view\r\n    returns (uint256)\r\n  {\r\n    return allowed_[_owner][_spender];\r\n  }\r\n\r\n  /**\r\n  * @dev Transfer token for a specified address\r\n  * @param _to The address to transfer to.\r\n  * @param _value The amount to be transferred.\r\n  */\r\n  function transfer(address _to, uint256 _value) public returns (bool) {\r\n    require(_value <= balances_[msg.sender]);\r\n    require(_to != address(0));\r\n\r\n    balances_[msg.sender] = balances_[msg.sender].sub(_value);\r\n    balances_[_to] = balances_[_to].add(_value);\r\n    emit Transfer(msg.sender, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\r\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\r\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\r\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _value The amount of tokens to be spent.\r\n   */\r\n  function approve(address _spender, uint256 _value) public returns (bool) {\r\n    allowed_[msg.sender][_spender] = _value;\r\n    emit Approval(msg.sender, _spender, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Transfer tokens from one address to another\r\n   * @param _from address The address which you want to send tokens from\r\n   * @param _to address The address which you want to transfer to\r\n   * @param _value uint256 the amount of tokens to be transferred\r\n   */\r\n  function transferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _value\r\n  )\r\n    public\r\n    returns (bool)\r\n  {\r\n    require(_value <= balances_[_from]);\r\n    require(_value <= allowed_[_from][msg.sender]);\r\n    require(_to != address(0));\r\n\r\n    balances_[_from] = balances_[_from].sub(_value);\r\n    balances_[_to] = balances_[_to].add(_value);\r\n    allowed_[_from][msg.sender] = allowed_[_from][msg.sender].sub(_value);\r\n    emit Transfer(_from, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Increase the amount of tokens that an owner allowed to a spender.\r\n   * approve should be called when allowed_[_spender] == 0. To increment\r\n   * allowed value is better to use this function to avoid 2 calls (and wait until\r\n   * the first transaction is mined)\r\n   * From MonolithDAO Token.sol\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _addedValue The amount of tokens to increase the allowance by.\r\n   */\r\n  function increaseApproval(\r\n    address _spender,\r\n    uint256 _addedValue\r\n  )\r\n    public\r\n    returns (bool)\r\n  {\r\n    allowed_[msg.sender][_spender] = (\r\n      allowed_[msg.sender][_spender].add(_addedValue));\r\n    emit Approval(msg.sender, _spender, allowed_[msg.sender][_spender]);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Decrease the amount of tokens that an owner allowed to a spender.\r\n   * approve should be called when allowed_[_spender] == 0. To decrement\r\n   * allowed value is better to use this function to avoid 2 calls (and wait until\r\n   * the first transaction is mined)\r\n   * From MonolithDAO Token.sol\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _subtractedValue The amount of tokens to decrease the allowance by.\r\n   */\r\n  function decreaseApproval(\r\n    address _spender,\r\n    uint256 _subtractedValue\r\n  )\r\n    public\r\n    returns (bool)\r\n  {\r\n    uint256 oldValue = allowed_[msg.sender][_spender];\r\n    if (_subtractedValue >= oldValue) {\r\n      allowed_[msg.sender][_spender] = 0;\r\n    } else {\r\n      allowed_[msg.sender][_spender] = oldValue.sub(_subtractedValue);\r\n    }\r\n    emit Approval(msg.sender, _spender, allowed_[msg.sender][_spender]);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Internal function that mints an amount of the token and assigns it to\r\n   * an account. This encapsulates the modification of balances such that the\r\n   * proper events are emitted.\r\n   * @param _account The account that will receive the created tokens.\r\n   * @param _amount The amount that will be created.\r\n   */\r\n  function _mint(address _account, uint256 _amount) internal {\r\n    require(_account != 0);\r\n    totalSupply_ = totalSupply_.add(_amount);\r\n    balances_[_account] = balances_[_account].add(_amount);\r\n    emit Transfer(address(0), _account, _amount);\r\n  }\r\n\r\n  /**\r\n   * @dev Internal function that burns an amount of the token of a given\r\n   * account.\r\n   * @param _account The account whose tokens will be burnt.\r\n   * @param _amount The amount that will be burnt.\r\n   */\r\n  function _burn(address _account, uint256 _amount) internal {\r\n    require(_account != 0);\r\n    require(_amount <= balances_[_account]);\r\n\r\n    totalSupply_ = totalSupply_.sub(_amount);\r\n    balances_[_account] = balances_[_account].sub(_amount);\r\n    emit Transfer(_account, address(0), _amount);\r\n  }\r\n\r\n  /**\r\n   * @dev Internal function that burns an amount of the token of a given\r\n   * account, deducting from the sender's allowance for said account. Uses the\r\n   * internal _burn function.\r\n   * @param _account The account whose tokens will be burnt.\r\n   * @param _amount The amount that will be burnt.\r\n   */\r\n  function _burnFrom(address _account, uint256 _amount) internal {\r\n    require(_amount <= allowed_[_account][msg.sender]);\r\n\r\n    // Should https://github.com/OpenZeppelin/zeppelin-solidity/issues/707 be accepted,\r\n    // this function needs to emit an event with the updated approval.\r\n    allowed_[_account][msg.sender] = allowed_[_account][msg.sender].sub(\r\n      _amount);\r\n    _burn(_account, _amount);\r\n  }\r\n}\r\n\r\n// File: contracts/ignored_contracts/AraToken.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\ncontract AraToken is StandardToken {\r\n\r\n  // metadata\r\n  bool    private initialized;\r\n  string  public constant name = \"Ara Token\";\r\n  string  public constant symbol = \"ARA\";\r\n  uint256 public constant decimals = 18;\r\n  string  public version = \"1.0\";\r\n\r\n\r\n  mapping (address => uint256) private deposits_;\r\n\r\n  event Deposit(address indexed from, uint256 value, uint256 total);\r\n  event Withdraw(address indexed to, uint256 value, uint256 total);\r\n\r\n  function init(bytes _data) public {\r\n    require(!initialized, 'Ara Token has already been initialized.');\r\n    initialized = true;\r\n    \r\n    uint256 btsptr;\r\n    address ownerAddr;\r\n    assembly {\r\n      btsptr := add(_data, 32)\r\n      ownerAddr := mload(btsptr)\r\n    }\r\n    _mint(ownerAddr, formatDecimals(1000000000)); // 1,000,000,000\r\n  }\r\n\r\n  function formatDecimals(uint256 _value) internal pure returns (uint256) {\r\n    return _value * 10 ** decimals;\r\n  }\r\n\r\n  function amountDeposited(address _owner) public view returns (uint256) {\r\n    return deposits_[_owner];\r\n  }\r\n\r\n  function deposit(uint256 _value) external returns (bool) {\r\n    require(_value <= balanceOf(msg.sender));\r\n\r\n    deposits_[msg.sender] = deposits_[msg.sender].add(_value);\r\n    emit Deposit(msg.sender, _value, deposits_[msg.sender]);\r\n    return true;\r\n  }\r\n\r\n  function withdraw(uint256 _value) external returns (bool) {\r\n    require(_value <= deposits_[msg.sender]);\r\n\r\n    deposits_[msg.sender] = deposits_[msg.sender].sub(_value);\r\n    emit Withdraw(msg.sender, _value, deposits_[msg.sender]);\r\n    return true;\r\n  }\r\n\r\n  function transfer(address _to, uint256 _value) public returns (bool) {\r\n    require(balanceOf(msg.sender) - _value >= deposits_[msg.sender]);\r\n    return super.transfer(_to, _value);\r\n  }\r\n\r\n  function approve(address _spender, uint256 _value) public returns (bool) {\r\n    require(balanceOf(msg.sender) - _value >= deposits_[msg.sender]);\r\n    return super.approve(_spender, _value);\r\n  }\r\n\r\n  function transferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _value\r\n  )\r\n    public\r\n    returns (bool)\r\n  {\r\n    require(balanceOf(_from) - _value >= deposits_[_from]);\r\n    return super.transferFrom(_from, _to, _value);\r\n  }\r\n\r\n  function increaseApproval(\r\n    address _spender,\r\n    uint256 _addedValue\r\n  )\r\n    public\r\n    returns (bool)\r\n  {\r\n    require(balanceOf(msg.sender) - (_addedValue + allowance(msg.sender, _spender)) >= deposits_[msg.sender]);\r\n    return super.increaseApproval(_spender, _addedValue);\r\n  }\r\n}\r\n\r\n// File: installed_contracts/bytes/contracts/BytesLib.sol\r\n\r\n/*\r\n * @title Solidity Bytes Arrays Utils\r\n * @author Nick Johnson <arachnid@notdot.net>\r\n *\r\n * @dev Bytes tightly packed arrays utility library for ethereum contracts written in Solidity.\r\n *      The library lets you concatenate, slice and type cast bytes arrays both in memory and storage.\r\n */\r\n\r\npragma solidity ^0.4.19;\r\n\r\n\r\nlibrary BytesLib {\r\n    function concat(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bytes) {\r\n        bytes memory tempBytes;\r\n\r\n        assembly {\r\n            // Get a location of some free memory and store it in tempBytes as\r\n            // Solidity does for memory variables.\r\n            tempBytes := mload(0x40)\r\n\r\n            // Store the length of the first bytes array at the beginning of\r\n            // the memory for tempBytes.\r\n            let length := mload(_preBytes)\r\n            mstore(tempBytes, length)\r\n\r\n            // Maintain a memory counter for the current write location in the\r\n            // temp bytes array by adding the 32 bytes for the array length to\r\n            // the starting location.\r\n            let mc := add(tempBytes, 0x20)\r\n            // Stop copying when the memory counter reaches the length of the\r\n            // first bytes array.\r\n            let end := add(mc, length)\r\n\r\n            for {\r\n                // Initialize a copy counter to the start of the _preBytes data,\r\n                // 32 bytes into its memory.\r\n                let cc := add(_preBytes, 0x20)\r\n            } lt(mc, end) {\r\n                // Increase both counters by 32 bytes each iteration.\r\n                mc := add(mc, 0x20)\r\n                cc := add(cc, 0x20)\r\n            } {\r\n                // Write the _preBytes data into the tempBytes memory 32 bytes\r\n                // at a time.\r\n                mstore(mc, mload(cc))\r\n            }\r\n\r\n            // Add the length of _postBytes to the current length of tempBytes\r\n            // and store it as the new length in the first 32 bytes of the\r\n            // tempBytes memory.\r\n            length := mload(_postBytes)\r\n            mstore(tempBytes, add(length, mload(tempBytes)))\r\n\r\n            // Move the memory counter back from a multiple of 0x20 to the\r\n            // actual end of the _preBytes data.\r\n            mc := end\r\n            // Stop copying when the memory counter reaches the new combined\r\n            // length of the arrays.\r\n            end := add(mc, length)\r\n\r\n            for {\r\n                let cc := add(_postBytes, 0x20)\r\n            } lt(mc, end) {\r\n                mc := add(mc, 0x20)\r\n                cc := add(cc, 0x20)\r\n            } {\r\n                mstore(mc, mload(cc))\r\n            }\r\n\r\n            // Update the free-memory pointer by padding our last write location\r\n            // to 32 bytes: add 31 bytes to the end of tempBytes to move to the\r\n            // next 32 byte block, then round down to the nearest multiple of\r\n            // 32. If the sum of the length of the two arrays is zero then add \r\n            // one before rounding down to leave a blank 32 bytes (the length block with 0).\r\n            mstore(0x40, and(\r\n              add(add(end, iszero(add(length, mload(_preBytes)))), 31),\r\n              not(31) // Round down to the nearest 32 bytes.\r\n            ))\r\n        }\r\n\r\n        return tempBytes;\r\n    }\r\n\r\n    function concatStorage(bytes storage _preBytes, bytes memory _postBytes) internal {\r\n        assembly {\r\n            // Read the first 32 bytes of _preBytes storage, which is the length\r\n            // of the array. (We don't need to use the offset into the slot\r\n            // because arrays use the entire slot.)\r\n            let fslot := sload(_preBytes_slot)\r\n            // Arrays of 31 bytes or less have an even value in their slot,\r\n            // while longer arrays have an odd value. The actual length is\r\n            // the slot divided by two for odd values, and the lowest order\r\n            // byte divided by two for even values.\r\n            // If the slot is even, bitwise and the slot with 255 and divide by\r\n            // two to get the length. If the slot is odd, bitwise and the slot\r\n            // with -1 and divide by two.\r\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\r\n            let mlength := mload(_postBytes)\r\n            let newlength := add(slength, mlength)\r\n            // slength can contain both the length and contents of the array\r\n            // if length < 32 bytes so let's prepare for that\r\n            // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\r\n            switch add(lt(slength, 32), lt(newlength, 32))\r\n            case 2 {\r\n                // Since the new array still fits in the slot, we just need to\r\n                // update the contents of the slot.\r\n                // uint256(bytes_storage) = uint256(bytes_storage) + uint256(bytes_memory) + new_length\r\n                sstore(\r\n                    _preBytes_slot,\r\n                    // all the modifications to the slot are inside this\r\n                    // next block\r\n                    add(\r\n                        // we can just add to the slot contents because the\r\n                        // bytes we want to change are the LSBs\r\n                        fslot,\r\n                        add(\r\n                            mul(\r\n                                div(\r\n                                    // load the bytes from memory\r\n                                    mload(add(_postBytes, 0x20)),\r\n                                    // zero all bytes to the right\r\n                                    exp(0x100, sub(32, mlength))\r\n                                ),\r\n                                // and now shift left the number of bytes to\r\n                                // leave space for the length in the slot\r\n                                exp(0x100, sub(32, newlength))\r\n                            ),\r\n                            // increase length by the double of the memory\r\n                            // bytes length\r\n                            mul(mlength, 2)\r\n                        )\r\n                    )\r\n                )\r\n            }\r\n            case 1 {\r\n                // The stored value fits in the slot, but the combined value\r\n                // will exceed it.\r\n                // get the keccak hash to get the contents of the array\r\n                mstore(0x0, _preBytes_slot)\r\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\r\n\r\n                // save new length\r\n                sstore(_preBytes_slot, add(mul(newlength, 2), 1))\r\n\r\n                // The contents of the _postBytes array start 32 bytes into\r\n                // the structure. Our first read should obtain the `submod`\r\n                // bytes that can fit into the unused space in the last word\r\n                // of the stored array. To get this, we read 32 bytes starting\r\n                // from `submod`, so the data we read overlaps with the array\r\n                // contents by `submod` bytes. Masking the lowest-order\r\n                // `submod` bytes allows us to add that value directly to the\r\n                // stored value.\r\n\r\n                let submod := sub(32, slength)\r\n                let mc := add(_postBytes, submod)\r\n                let end := add(_postBytes, mlength)\r\n                let mask := sub(exp(0x100, submod), 1)\r\n\r\n                sstore(\r\n                    sc,\r\n                    add(\r\n                        and(\r\n                            fslot,\r\n                            0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00\r\n                        ),\r\n                        and(mload(mc), mask)\r\n                    )\r\n                )\r\n\r\n                for {\r\n                    mc := add(mc, 0x20)\r\n                    sc := add(sc, 1)\r\n                } lt(mc, end) {\r\n                    sc := add(sc, 1)\r\n                    mc := add(mc, 0x20)\r\n                } {\r\n                    sstore(sc, mload(mc))\r\n                }\r\n\r\n                mask := exp(0x100, sub(mc, end))\r\n\r\n                sstore(sc, mul(div(mload(mc), mask), mask))\r\n            }\r\n            default {\r\n                // get the keccak hash to get the contents of the array\r\n                mstore(0x0, _preBytes_slot)\r\n                // Start copying to the last used word of the stored array.\r\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\r\n\r\n                // save new length\r\n                sstore(_preBytes_slot, add(mul(newlength, 2), 1))\r\n\r\n                // Copy over the first `submod` bytes of the new data as in\r\n                // case 1 above.\r\n                let slengthmod := mod(slength, 32)\r\n                let mlengthmod := mod(mlength, 32)\r\n                let submod := sub(32, slengthmod)\r\n                let mc := add(_postBytes, submod)\r\n                let end := add(_postBytes, mlength)\r\n                let mask := sub(exp(0x100, submod), 1)\r\n\r\n                sstore(sc, add(sload(sc), and(mload(mc), mask)))\r\n                \r\n                for { \r\n                    sc := add(sc, 1)\r\n                    mc := add(mc, 0x20)\r\n                } lt(mc, end) {\r\n                    sc := add(sc, 1)\r\n                    mc := add(mc, 0x20)\r\n                } {\r\n                    sstore(sc, mload(mc))\r\n                }\r\n\r\n                mask := exp(0x100, sub(mc, end))\r\n\r\n                sstore(sc, mul(div(mload(mc), mask), mask))\r\n            }\r\n        }\r\n    }\r\n\r\n    function slice(bytes _bytes, uint _start, uint _length) internal  pure returns (bytes) {\r\n        require(_bytes.length >= (_start + _length));\r\n\r\n        bytes memory tempBytes;\r\n\r\n        assembly {\r\n            switch iszero(_length)\r\n            case 0 {\r\n                // Get a location of some free memory and store it in tempBytes as\r\n                // Solidity does for memory variables.\r\n                tempBytes := mload(0x40)\r\n\r\n                // The first word of the slice result is potentially a partial\r\n                // word read from the original array. To read it, we calculate\r\n                // the length of that partial word and start copying that many\r\n                // bytes into the array. The first word we copy will start with\r\n                // data we don't care about, but the last `lengthmod` bytes will\r\n                // land at the beginning of the contents of the new array. When\r\n                // we're done copying, we overwrite the full first word with\r\n                // the actual length of the slice.\r\n                let lengthmod := and(_length, 31)\r\n\r\n                // The multiplication in the next line is necessary\r\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\r\n                // the following copy loop was copying the origin's length\r\n                // and then ending prematurely not copying everything it should.\r\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\r\n                let end := add(mc, _length)\r\n\r\n                for {\r\n                    // The multiplication in the next line has the same exact purpose\r\n                    // as the one above.\r\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\r\n                } lt(mc, end) {\r\n                    mc := add(mc, 0x20)\r\n                    cc := add(cc, 0x20)\r\n                } {\r\n                    mstore(mc, mload(cc))\r\n                }\r\n\r\n                mstore(tempBytes, _length)\r\n\r\n                //update free-memory pointer\r\n                //allocating the array padded to 32 bytes like the compiler does now\r\n                mstore(0x40, and(add(mc, 31), not(31)))\r\n            }\r\n            //if we want a zero-length slice let's just return a zero-length array\r\n            default {\r\n                tempBytes := mload(0x40)\r\n\r\n                mstore(0x40, add(tempBytes, 0x20))\r\n            }\r\n        }\r\n\r\n        return tempBytes;\r\n    }\r\n\r\n    function toAddress(bytes _bytes, uint _start) internal  pure returns (address) {\r\n        require(_bytes.length >= (_start + 20));\r\n        address tempAddress;\r\n\r\n        assembly {\r\n            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\r\n        }\r\n\r\n        return tempAddress;\r\n    }\r\n\r\n    function toUint(bytes _bytes, uint _start) internal  pure returns (uint256) {\r\n        require(_bytes.length >= (_start + 32));\r\n        uint256 tempUint;\r\n\r\n        assembly {\r\n            tempUint := mload(add(add(_bytes, 0x20), _start))\r\n        }\r\n\r\n        return tempUint;\r\n    }\r\n\r\n    function toBytes32(bytes _bytes, uint _start) internal  pure returns (bytes32) {\r\n        require(_bytes.length >= (_start + 32));\r\n        bytes32 tempBytes32;\r\n\r\n        assembly {\r\n            tempBytes32 := mload(add(add(_bytes, 0x20), _start))\r\n        }\r\n\r\n        return tempBytes32;\r\n    }\r\n\r\n    function equal(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bool) {\r\n        bool success = true;\r\n\r\n        assembly {\r\n            let length := mload(_preBytes)\r\n\r\n            // if lengths don't match the arrays are not equal\r\n            switch eq(length, mload(_postBytes))\r\n            case 1 {\r\n                // cb is a circuit breaker in the for loop since there's\r\n                //  no said feature for inline assembly loops\r\n                // cb = 1 - don't breaker\r\n                // cb = 0 - break\r\n                let cb := 1\r\n\r\n                let mc := add(_preBytes, 0x20)\r\n                let end := add(mc, length)\r\n\r\n                for {\r\n                    let cc := add(_postBytes, 0x20)\r\n                // the next line is the loop condition:\r\n                // while(uint(mc < end) + cb == 2)\r\n                } eq(add(lt(mc, end), cb), 2) {\r\n                    mc := add(mc, 0x20)\r\n                    cc := add(cc, 0x20)\r\n                } {\r\n                    // if any of these checks fails then arrays are not equal\r\n                    if iszero(eq(mload(mc), mload(cc))) {\r\n                        // unsuccess:\r\n                        success := 0\r\n                        cb := 0\r\n                    }\r\n                }\r\n            }\r\n            default {\r\n                // unsuccess:\r\n                success := 0\r\n            }\r\n        }\r\n\r\n        return success;\r\n    }\r\n\r\n    function equalStorage(bytes storage _preBytes, bytes memory _postBytes) internal view returns (bool) {\r\n        bool success = true;\r\n\r\n        assembly {\r\n            // we know _preBytes_offset is 0\r\n            let fslot := sload(_preBytes_slot)\r\n            // Decode the length of the stored array like in concatStorage().\r\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\r\n            let mlength := mload(_postBytes)\r\n\r\n            // if lengths don't match the arrays are not equal\r\n            switch eq(slength, mlength)\r\n            case 1 {\r\n                // slength can contain both the length and contents of the array\r\n                // if length < 32 bytes so let's prepare for that\r\n                // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\r\n                if iszero(iszero(slength)) {\r\n                    switch lt(slength, 32)\r\n                    case 1 {\r\n                        // blank the last byte which is the length\r\n                        fslot := mul(div(fslot, 0x100), 0x100)\r\n\r\n                        if iszero(eq(fslot, mload(add(_postBytes, 0x20)))) {\r\n                            // unsuccess:\r\n                            success := 0\r\n                        }\r\n                    }\r\n                    default {\r\n                        // cb is a circuit breaker in the for loop since there's\r\n                        //  no said feature for inline assembly loops\r\n                        // cb = 1 - don't breaker\r\n                        // cb = 0 - break\r\n                        let cb := 1\r\n\r\n                        // get the keccak hash to get the contents of the array\r\n                        mstore(0x0, _preBytes_slot)\r\n                        let sc := keccak256(0x0, 0x20)\r\n\r\n                        let mc := add(_postBytes, 0x20)\r\n                        let end := add(mc, mlength)\r\n\r\n                        // the next line is the loop condition:\r\n                        // while(uint(mc < end) + cb == 2)\r\n                        for {} eq(add(lt(mc, end), cb), 2) {\r\n                            sc := add(sc, 1)\r\n                            mc := add(mc, 0x20)\r\n                        } {\r\n                            if iszero(eq(sload(sc), mload(mc))) {\r\n                                // unsuccess:\r\n                                success := 0\r\n                                cb := 0\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            default {\r\n                // unsuccess:\r\n                success := 0\r\n            }\r\n        }\r\n\r\n        return success;\r\n    }\r\n}\r\n\r\n// File: contracts/ignored_contracts/AFS_estimate.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract AFSestimate is Ownable {\r\n  using SafeMath for uint256;\r\n  using BytesLib for bytes;\r\n\r\n  string   public version_ = \"1\";\r\n\r\n  AraToken public token_;\r\n  Library  public lib_;\r\n\r\n  bytes32  public did_;\r\n  bool     public listed_;\r\n  uint256  public price_;\r\n\r\n  uint256  public depositRequirement_;\r\n\r\n  mapping(bytes32 => Job)     public jobs_; // jobId => job { budget, sender }\r\n  mapping(bytes32 => uint256) public rewards_;    // farmer => rewards\r\n  mapping(bytes32 => bool)    public purchasers_; // keccak256 hashes of buyer addresses\r\n  mapping(uint8 => mapping (uint256 => bytes))   public metadata_;\r\n\r\n  struct Job {\r\n    address sender;\r\n    uint256 budget;\r\n  }\r\n\r\n  event Commit(bytes32 _did);\r\n  event Unlisted(bytes32 _did);\r\n  event PriceSet(uint256 _price);\r\n  event BudgetSubmitted(address indexed _sender, bytes32 indexed _jobId, uint256 _budget);\r\n  event RewardsAllocated(address indexed _farmer, bytes32 indexed _jobId, uint256 _allocated, uint256 _remaining);\r\n  event InsufficientDeposit(address indexed _farmer);\r\n  event Purchased(bytes32 indexed _purchaser, uint256 _price);\r\n  event Redeemed(address indexed _sender, uint256 _amount);\r\n\r\n  uint8 constant mtBufferSize_ = 40;\r\n  uint8 constant msBufferSize_ = 64;\r\n\r\n  modifier purchaseRequired()\r\n  {\r\n    require(\r\n      purchasers_[keccak256(abi.encodePacked(msg.sender))],\r\n      \"Content was never purchased.\"\r\n    );\r\n    _;\r\n  }\r\n\r\n  modifier budgetSubmitted(bytes32 _jobId)\r\n  {\r\n    require(\r\n      jobs_[_jobId].sender == msg.sender && jobs_[_jobId].budget > 0,\r\n      \"Job is invalid.\"\r\n    );\r\n    _;\r\n  }\r\n\r\n  function init(bytes _data) public {\r\n    require(owner_ == address(0), 'This AFS standard has already been initialized.');\r\n  \r\n    uint256 btsptr;\r\n    address ownerAddr;\r\n    address tokenAddr;\r\n    address libAddr;\r\n    bytes32 did;\r\n    /* solium-disable-next-line security/no-inline-assembly */\r\n    assembly {\r\n      btsptr := add(_data, 32)\r\n      ownerAddr := mload(btsptr)\r\n      btsptr := add(_data, 64)\r\n      tokenAddr := mload(btsptr)\r\n      btsptr := add(_data, 96)\r\n      libAddr := mload(btsptr)\r\n      btsptr := add(_data, 128)\r\n      did := mload(btsptr)\r\n    }\r\n    owner_    = ownerAddr;\r\n    token_    = AraToken(tokenAddr);\r\n    lib_      = Library(libAddr);\r\n    did_      = did;\r\n    listed_   = true;\r\n    price_    = 0;\r\n    depositRequirement_  = 100 * 10 ** token_.decimals();\r\n  }\r\n\r\n  function setPrice(uint256 _price) external {\r\n    price_ = _price;\r\n    emit PriceSet(price_);\r\n  }\r\n\r\n  function submitBudget(bytes32 _jobId, uint256 _budget) public purchaseRequired {\r\n    uint256 allowance = token_.allowance(msg.sender, address(this));\r\n    require(_jobId != bytes32(0) && _budget > 0 && allowance >= _budget\r\n      && (jobs_[_jobId].sender == address(0) || jobs_[_jobId].sender == msg.sender), \"Job submission invalid.\");\r\n\r\n    if (token_.transferFrom(msg.sender, address(this), _budget)) {\r\n      jobs_[_jobId].budget = jobs_[_jobId].budget.add(_budget);\r\n      jobs_[_jobId].sender = msg.sender;\r\n      assert(jobs_[_jobId].budget <= token_.balanceOf(address(this)));\r\n      emit BudgetSubmitted(msg.sender, _jobId, _budget);\r\n    }\r\n  }\r\n\r\n  function allocateRewards(bytes32 _jobId, address[] _farmers, uint256[] _rewards) public budgetSubmitted(_jobId) {\r\n    require(_farmers.length > 0, \"Must allocate to at least one farmer.\");\r\n    require(_farmers.length == _rewards.length, \"Unequal number of farmers and rewards.\");\r\n    uint256 totalRewards;\r\n    for (uint256 i = 0; i < _rewards.length; i++) {\r\n      address farmer = _farmers[i];\r\n      require(farmer != msg.sender, \"Cannot allocate rewards to job creator.\");\r\n      require(purchasers_[keccak256(abi.encodePacked(farmer))] || token_.amountDeposited(farmer) >= depositRequirement_, \"Farmer must be a purchaser of this AFS or have sufficient token deposit.\");\r\n      totalRewards = totalRewards.add(_rewards[i]);\r\n    }\r\n    require(totalRewards <= jobs_[_jobId].budget, \"Insufficient budget.\");\r\n    for (uint256 j = 0; j < _farmers.length; j++) {\r\n      assert(jobs_[_jobId].budget >= _rewards[j]);\r\n      bytes32 hashedFarmer = keccak256(abi.encodePacked(_farmers[j]));\r\n      rewards_[hashedFarmer] = rewards_[hashedFarmer].add(_rewards[j]);\r\n      jobs_[_jobId].budget = jobs_[_jobId].budget.sub(_rewards[j]);\r\n      emit RewardsAllocated(_farmers[j], _jobId, _rewards[j], jobs_[_jobId].budget);\r\n    }\r\n  }\r\n\r\n  function redeemBalance() public {\r\n    if (msg.sender == owner_ || token_.amountDeposited(msg.sender) >= depositRequirement_ || purchasers_[keccak256(abi.encodePacked(msg.sender))]) {\r\n      bytes32 hashedAddress = keccak256(abi.encodePacked(msg.sender));\r\n      require(rewards_[hashedAddress] > 0, \"No balance to redeem.\");\r\n      if (token_.transfer(msg.sender, rewards_[hashedAddress])) {\r\n        emit Redeemed(msg.sender, rewards_[hashedAddress]);\r\n        rewards_[hashedAddress] = 0;\r\n      }\r\n    } else {\r\n      emit InsufficientDeposit(msg.sender);\r\n    }\r\n  }\r\n\r\n  function getRewardsBalance(address _farmer) public view returns (uint256) {\r\n    return rewards_[keccak256(abi.encodePacked(_farmer))];\r\n  }\r\n\r\n  function getBudget(bytes32 _jobId) public view returns (uint256) {\r\n    return jobs_[_jobId].budget;\r\n  }\r\n\r\n  /**\r\n   * @dev Purchases this AFS and adds it to _purchaser's library. \r\n   *      If _download is true, deposits any remaining allowance \r\n   *      as rewards for this purchase\r\n   * @param _purchaser The hashed methodless did of the purchaser\r\n   * @param _jobId The jobId of the download, or 0x00000000000000000000000000000000 if N/A\r\n   * @param _budget The reward budget for jobId, or 0 if N/A\r\n   */\r\n  function purchase(bytes32 _purchaser, bytes32 _jobId, uint256 _budget) external {\r\n    require(listed_, \"Content is not listed for purchase.\");\r\n    uint256 allowance = token_.allowance(msg.sender, address(this));\r\n    bytes32 hashedAddress = keccak256(abi.encodePacked(msg.sender));\r\n    require (!purchasers_[hashedAddress] && allowance >= price_.add(_budget), \"Unable to purchase.\");\r\n\r\n    if (token_.transferFrom(msg.sender, owner_, price_)) {\r\n      purchasers_[hashedAddress] = true;\r\n      lib_.addLibraryItem(_purchaser, did_);\r\n      emit Purchased(_purchaser, price_);\r\n\r\n      if (_jobId != bytes32(0) && _budget > 0) {\r\n        submitBudget(_jobId, _budget);\r\n      }\r\n    }\r\n  }\r\n\r\n  function append(uint256[] _mtOffsets, uint256[] _msOffsets, bytes _mtBuffer, \r\n    bytes _msBuffer) external {\r\n    \r\n    require(listed_, \"AFS is unlisted.\");\r\n    \r\n    uint256 maxOffsetLength = _mtOffsets.length > _msOffsets.length \r\n      ? _mtOffsets.length \r\n      : _msOffsets.length;\r\n\r\n    for (uint i = 0; i < maxOffsetLength; i++) {\r\n      // metadata/tree\r\n      if (i <= _mtOffsets.length - 1) {\r\n        metadata_[0][_mtOffsets[i]] = _mtBuffer.slice(i * mtBufferSize_, mtBufferSize_);\r\n      }\r\n\r\n      // metadata/signatures\r\n      if (i <= _msOffsets.length - 1) {\r\n        metadata_[1][_msOffsets[i]] = _msBuffer.slice(i * msBufferSize_, msBufferSize_);\r\n      }\r\n    }\r\n\r\n    emit Commit(did_);\r\n  }\r\n\r\n  function write(uint256[] _mtOffsets, uint256[] _msOffsets, bytes _mtBuffer, \r\n    bytes _msBuffer) public {\r\n\r\n    require(listed_, \"AFS is unlisted.\");\r\n\r\n    uint256 maxOffsetLength = _mtOffsets.length > _msOffsets.length \r\n      ? _mtOffsets.length \r\n      : _msOffsets.length;\r\n\r\n    // add headers\r\n    metadata_[0][0] = _mtBuffer.slice(0, 32);\r\n    metadata_[1][0] = _msBuffer.slice(0, 32);\r\n\r\n    for (uint i = 1; i < maxOffsetLength; i++) {\r\n      // metadata/tree\r\n      if (i <= _mtOffsets.length - 1) {\r\n        metadata_[0][_mtOffsets[i]] = _mtBuffer.slice(_mtOffsets[i], mtBufferSize_);\r\n      }\r\n      \r\n      // metadata/signatures\r\n      if (i <= _msOffsets.length - 1) {\r\n        metadata_[1][_msOffsets[i]] = _msBuffer.slice(_msOffsets[i], msBufferSize_);\r\n      }\r\n    }\r\n\r\n    emit Commit(did_);\r\n  }\r\n\r\n  function read(uint8 _file, uint256 _offset) public view returns (bytes buffer) {\r\n    if (!listed_) {\r\n      return \"\"; // empty bytes\r\n    }\r\n    return metadata_[_file][_offset];\r\n  }\r\n\r\n  function hasBuffer(uint8 _file, uint256 _offset, bytes _buffer) public view returns (bool exists) {\r\n    return metadata_[_file][_offset].equal(_buffer);\r\n  }\r\n\r\n  function unlist() public returns (bool success) {\r\n    listed_ = false;\r\n    emit Unlisted(did_);\r\n    return true;\r\n  }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"jobs_\",\"outputs\":[{\"name\":\"sender\",\"type\":\"address\"},{\"name\":\"budget\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"listed_\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_jobId\",\"type\":\"bytes32\"},{\"name\":\"_farmers\",\"type\":\"address[]\"},{\"name\":\"_rewards\",\"type\":\"uint256[]\"}],\"name\":\"allocateRewards\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint8\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"metadata_\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"redeemBalance\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lib_\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"did_\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"init\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"approveOwnershipTransfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_jobId\",\"type\":\"bytes32\"}],\"name\":\"getBudget\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"rewards_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"depositRequirement_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_mtOffsets\",\"type\":\"uint256[]\"},{\"name\":\"_msOffsets\",\"type\":\"uint256[]\"},{\"name\":\"_mtBuffer\",\"type\":\"bytes\"},{\"name\":\"_msBuffer\",\"type\":\"bytes\"}],\"name\":\"append\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_farmer\",\"type\":\"address\"}],\"name\":\"getRewardsBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"requestOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_price\",\"type\":\"uint256\"}],\"name\":\"setPrice\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"requesters_\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unlist\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_file\",\"type\":\"uint8\"},{\"name\":\"_offset\",\"type\":\"uint256\"}],\"name\":\"read\",\"outputs\":[{\"name\":\"buffer\",\"type\":\"bytes\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_mtOffsets\",\"type\":\"uint256[]\"},{\"name\":\"_msOffsets\",\"type\":\"uint256[]\"},{\"name\":\"_mtBuffer\",\"type\":\"bytes\"},{\"name\":\"_msBuffer\",\"type\":\"bytes\"}],\"name\":\"write\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"price_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token_\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"version_\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner_\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_file\",\"type\":\"uint8\"},{\"name\":\"_offset\",\"type\":\"uint256\"},{\"name\":\"_buffer\",\"type\":\"bytes\"}],\"name\":\"hasBuffer\",\"outputs\":[{\"name\":\"exists\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_purchaser\",\"type\":\"bytes32\"},{\"name\":\"_jobId\",\"type\":\"bytes32\"},{\"name\":\"_budget\",\"type\":\"uint256\"}],\"name\":\"purchase\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_jobId\",\"type\":\"bytes32\"},{\"name\":\"_budget\",\"type\":\"uint256\"}],\"name\":\"submitBudget\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"purchasers_\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"revokeOwnershipRequest\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_did\",\"type\":\"bytes32\"}],\"name\":\"Commit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_did\",\"type\":\"bytes32\"}],\"name\":\"Unlisted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_price\",\"type\":\"uint256\"}],\"name\":\"PriceSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_sender\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_jobId\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"_budget\",\"type\":\"uint256\"}],\"name\":\"BudgetSubmitted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_farmer\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_jobId\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"_allocated\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_remaining\",\"type\":\"uint256\"}],\"name\":\"RewardsAllocated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_farmer\",\"type\":\"address\"}],\"name\":\"InsufficientDeposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_purchaser\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"_price\",\"type\":\"uint256\"}],\"name\":\"Purchased\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_sender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"Redeemed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"TransferApproved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_currentOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_requestedOwner\",\"type\":\"address\"}],\"name\":\"TransferRequested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_currentOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_requestOwner\",\"type\":\"address\"}],\"name\":\"RequestRevoked\",\"type\":\"event\"}]","ContractName":"AFSestimate","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://7c63735b80b6aa88dbca064602d91188c95d40752f24c0ab7b63a962e28f60e0"}]}