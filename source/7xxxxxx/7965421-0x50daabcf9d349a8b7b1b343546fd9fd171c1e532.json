{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity >=0.4.25 <0.6.0;\n\npragma experimental ABIEncoderV2;\n\n/*\n * Hubii Nahmii\n *\n * Compliant with the Hubii Nahmii specification v0.12.\n *\n * Copyright (C) 2017-2018 Hubii AS\n */\n\n/**\n * @title Modifiable\n * @notice A contract with basic modifiers\n */\ncontract Modifiable {\n    //\n    // Modifiers\n    // -----------------------------------------------------------------------------------------------------------------\n    modifier notNullAddress(address _address) {\n        require(_address != address(0));\n        _;\n    }\n\n    modifier notThisAddress(address _address) {\n        require(_address != address(this));\n        _;\n    }\n\n    modifier notNullOrThisAddress(address _address) {\n        require(_address != address(0));\n        require(_address != address(this));\n        _;\n    }\n\n    modifier notSameAddresses(address _address1, address _address2) {\n        if (_address1 != _address2)\n            _;\n    }\n}\n\n/*\n * Hubii Nahmii\n *\n * Compliant with the Hubii Nahmii specification v0.12.\n *\n * Copyright (C) 2017-2018 Hubii AS\n */\n\n/**\n * @title SelfDestructible\n * @notice Contract that allows for self-destruction\n */\ncontract SelfDestructible {\n    //\n    // Variables\n    // -----------------------------------------------------------------------------------------------------------------\n    bool public selfDestructionDisabled;\n\n    //\n    // Events\n    // -----------------------------------------------------------------------------------------------------------------\n    event SelfDestructionDisabledEvent(address wallet);\n    event TriggerSelfDestructionEvent(address wallet);\n\n    //\n    // Functions\n    // -----------------------------------------------------------------------------------------------------------------\n    /// @notice Get the address of the destructor role\n    function destructor()\n    public\n    view\n    returns (address);\n\n    /// @notice Disable self-destruction of this contract\n    /// @dev This operation can not be undone\n    function disableSelfDestruction()\n    public\n    {\n        // Require that sender is the assigned destructor\n        require(destructor() == msg.sender);\n\n        // Disable self-destruction\n        selfDestructionDisabled = true;\n\n        // Emit event\n        emit SelfDestructionDisabledEvent(msg.sender);\n    }\n\n    /// @notice Destroy this contract\n    function triggerSelfDestruction()\n    public\n    {\n        // Require that sender is the assigned destructor\n        require(destructor() == msg.sender);\n\n        // Require that self-destruction has not been disabled\n        require(!selfDestructionDisabled);\n\n        // Emit event\n        emit TriggerSelfDestructionEvent(msg.sender);\n\n        // Self-destruct and reward destructor\n        selfdestruct(msg.sender);\n    }\n}\n\n/*\n * Hubii Nahmii\n *\n * Compliant with the Hubii Nahmii specification v0.12.\n *\n * Copyright (C) 2017-2018 Hubii AS\n */\n\n/**\n * @title Ownable\n * @notice A modifiable that has ownership roles\n */\ncontract Ownable is Modifiable, SelfDestructible {\n    //\n    // Variables\n    // -----------------------------------------------------------------------------------------------------------------\n    address public deployer;\n    address public operator;\n\n    //\n    // Events\n    // -----------------------------------------------------------------------------------------------------------------\n    event SetDeployerEvent(address oldDeployer, address newDeployer);\n    event SetOperatorEvent(address oldOperator, address newOperator);\n\n    //\n    // Constructor\n    // -----------------------------------------------------------------------------------------------------------------\n    constructor(address _deployer) internal notNullOrThisAddress(_deployer) {\n        deployer = _deployer;\n        operator = _deployer;\n    }\n\n    //\n    // Functions\n    // -----------------------------------------------------------------------------------------------------------------\n    /// @notice Return the address that is able to initiate self-destruction\n    function destructor()\n    public\n    view\n    returns (address)\n    {\n        return deployer;\n    }\n\n    /// @notice Set the deployer of this contract\n    /// @param newDeployer The address of the new deployer\n    function setDeployer(address newDeployer)\n    public\n    onlyDeployer\n    notNullOrThisAddress(newDeployer)\n    {\n        if (newDeployer != deployer) {\n            // Set new deployer\n            address oldDeployer = deployer;\n            deployer = newDeployer;\n\n            // Emit event\n            emit SetDeployerEvent(oldDeployer, newDeployer);\n        }\n    }\n\n    /// @notice Set the operator of this contract\n    /// @param newOperator The address of the new operator\n    function setOperator(address newOperator)\n    public\n    onlyOperator\n    notNullOrThisAddress(newOperator)\n    {\n        if (newOperator != operator) {\n            // Set new operator\n            address oldOperator = operator;\n            operator = newOperator;\n\n            // Emit event\n            emit SetOperatorEvent(oldOperator, newOperator);\n        }\n    }\n\n    /// @notice Gauge whether message sender is deployer or not\n    /// @return true if msg.sender is deployer, else false\n    function isDeployer()\n    internal\n    view\n    returns (bool)\n    {\n        return msg.sender == deployer;\n    }\n\n    /// @notice Gauge whether message sender is operator or not\n    /// @return true if msg.sender is operator, else false\n    function isOperator()\n    internal\n    view\n    returns (bool)\n    {\n        return msg.sender == operator;\n    }\n\n    /// @notice Gauge whether message sender is operator or deployer on the one hand, or none of these on these on\n    /// on the other hand\n    /// @return true if msg.sender is operator, else false\n    function isDeployerOrOperator()\n    internal\n    view\n    returns (bool)\n    {\n        return isDeployer() || isOperator();\n    }\n\n    // Modifiers\n    // -----------------------------------------------------------------------------------------------------------------\n    modifier onlyDeployer() {\n        require(isDeployer());\n        _;\n    }\n\n    modifier notDeployer() {\n        require(!isDeployer());\n        _;\n    }\n\n    modifier onlyOperator() {\n        require(isOperator());\n        _;\n    }\n\n    modifier notOperator() {\n        require(!isOperator());\n        _;\n    }\n\n    modifier onlyDeployerOrOperator() {\n        require(isDeployerOrOperator());\n        _;\n    }\n\n    modifier notDeployerOrOperator() {\n        require(!isDeployerOrOperator());\n        _;\n    }\n}\n\n/*\n * Hubii Nahmii\n *\n * Compliant with the Hubii Nahmii specification v0.12.\n *\n * Copyright (C) 2017-2018 Hubii AS\n */\n\n/**\n * @title Servable\n * @notice An ownable that contains registered services and their actions\n */\ncontract Servable is Ownable {\n    //\n    // Types\n    // -----------------------------------------------------------------------------------------------------------------\n    struct ServiceInfo {\n        bool registered;\n        uint256 activationTimestamp;\n        mapping(bytes32 => bool) actionsEnabledMap;\n        bytes32[] actionsList;\n    }\n\n    //\n    // Variables\n    // -----------------------------------------------------------------------------------------------------------------\n    mapping(address => ServiceInfo) internal registeredServicesMap;\n    uint256 public serviceActivationTimeout;\n\n    //\n    // Events\n    // -----------------------------------------------------------------------------------------------------------------\n    event ServiceActivationTimeoutEvent(uint256 timeoutInSeconds);\n    event RegisterServiceEvent(address service);\n    event RegisterServiceDeferredEvent(address service, uint256 timeout);\n    event DeregisterServiceEvent(address service);\n    event EnableServiceActionEvent(address service, string action);\n    event DisableServiceActionEvent(address service, string action);\n\n    //\n    // Functions\n    // -----------------------------------------------------------------------------------------------------------------\n    /// @notice Set the service activation timeout\n    /// @param timeoutInSeconds The set timeout in unit of seconds\n    function setServiceActivationTimeout(uint256 timeoutInSeconds)\n    public\n    onlyDeployer\n    {\n        serviceActivationTimeout = timeoutInSeconds;\n\n        // Emit event\n        emit ServiceActivationTimeoutEvent(timeoutInSeconds);\n    }\n\n    /// @notice Register a service contract whose activation is immediate\n    /// @param service The address of the service contract to be registered\n    function registerService(address service)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        _registerService(service, 0);\n\n        // Emit event\n        emit RegisterServiceEvent(service);\n    }\n\n    /// @notice Register a service contract whose activation is deferred by the service activation timeout\n    /// @param service The address of the service contract to be registered\n    function registerServiceDeferred(address service)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        _registerService(service, serviceActivationTimeout);\n\n        // Emit event\n        emit RegisterServiceDeferredEvent(service, serviceActivationTimeout);\n    }\n\n    /// @notice Deregister a service contract\n    /// @param service The address of the service contract to be deregistered\n    function deregisterService(address service)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        require(registeredServicesMap[service].registered);\n\n        registeredServicesMap[service].registered = false;\n\n        // Emit event\n        emit DeregisterServiceEvent(service);\n    }\n\n    /// @notice Enable a named action in an already registered service contract\n    /// @param service The address of the registered service contract\n    /// @param action The name of the action to be enabled\n    function enableServiceAction(address service, string memory action)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        require(registeredServicesMap[service].registered);\n\n        bytes32 actionHash = hashString(action);\n\n        require(!registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        registeredServicesMap[service].actionsEnabledMap[actionHash] = true;\n        registeredServicesMap[service].actionsList.push(actionHash);\n\n        // Emit event\n        emit EnableServiceActionEvent(service, action);\n    }\n\n    /// @notice Enable a named action in a service contract\n    /// @param service The address of the service contract\n    /// @param action The name of the action to be disabled\n    function disableServiceAction(address service, string memory action)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        bytes32 actionHash = hashString(action);\n\n        require(registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        registeredServicesMap[service].actionsEnabledMap[actionHash] = false;\n\n        // Emit event\n        emit DisableServiceActionEvent(service, action);\n    }\n\n    /// @notice Gauge whether a service contract is registered\n    /// @param service The address of the service contract\n    /// @return true if service is registered, else false\n    function isRegisteredService(address service)\n    public\n    view\n    returns (bool)\n    {\n        return registeredServicesMap[service].registered;\n    }\n\n    /// @notice Gauge whether a service contract is registered and active\n    /// @param service The address of the service contract\n    /// @return true if service is registered and activate, else false\n    function isRegisteredActiveService(address service)\n    public\n    view\n    returns (bool)\n    {\n        return isRegisteredService(service) && block.timestamp >= registeredServicesMap[service].activationTimestamp;\n    }\n\n    /// @notice Gauge whether a service contract action is enabled which implies also registered and active\n    /// @param service The address of the service contract\n    /// @param action The name of action\n    function isEnabledServiceAction(address service, string memory action)\n    public\n    view\n    returns (bool)\n    {\n        bytes32 actionHash = hashString(action);\n        return isRegisteredActiveService(service) && registeredServicesMap[service].actionsEnabledMap[actionHash];\n    }\n\n    //\n    // Internal functions\n    // -----------------------------------------------------------------------------------------------------------------\n    function hashString(string memory _string)\n    internal\n    pure\n    returns (bytes32)\n    {\n        return keccak256(abi.encodePacked(_string));\n    }\n\n    //\n    // Private functions\n    // -----------------------------------------------------------------------------------------------------------------\n    function _registerService(address service, uint256 timeout)\n    private\n    {\n        if (!registeredServicesMap[service].registered) {\n            registeredServicesMap[service].registered = true;\n            registeredServicesMap[service].activationTimestamp = block.timestamp + timeout;\n        }\n    }\n\n    //\n    // Modifiers\n    // -----------------------------------------------------------------------------------------------------------------\n    modifier onlyActiveService() {\n        require(isRegisteredActiveService(msg.sender));\n        _;\n    }\n\n    modifier onlyEnabledServiceAction(string memory action) {\n        require(isEnabledServiceAction(msg.sender, action));\n        _;\n    }\n}\n\n/*\n * Hubii Nahmii\n *\n * Compliant with the Hubii Nahmii specification v0.12.\n *\n * Copyright (C) 2017-2018 Hubii AS based on Open-Zeppelin's SafeMath library\n */\n\n/**\n * @title     SafeMathIntLib\n * @dev       Math operations with safety checks that throw on error\n */\nlibrary SafeMathIntLib {\n    int256 constant INT256_MIN = int256((uint256(1) << 255));\n    int256 constant INT256_MAX = int256(~((uint256(1) << 255)));\n\n    //\n    //Functions below accept positive and negative integers and result must not overflow.\n    //\n    function div(int256 a, int256 b)\n    internal\n    pure\n    returns (int256)\n    {\n        require(a != INT256_MIN || b != - 1);\n        return a / b;\n    }\n\n    function mul(int256 a, int256 b)\n    internal\n    pure\n    returns (int256)\n    {\n        require(a != - 1 || b != INT256_MIN);\n        // overflow\n        require(b != - 1 || a != INT256_MIN);\n        // overflow\n        int256 c = a * b;\n        require((b == 0) || (c / b == a));\n        return c;\n    }\n\n    function sub(int256 a, int256 b)\n    internal\n    pure\n    returns (int256)\n    {\n        require((b >= 0 && a - b <= a) || (b < 0 && a - b > a));\n        return a - b;\n    }\n\n    function add(int256 a, int256 b)\n    internal\n    pure\n    returns (int256)\n    {\n        int256 c = a + b;\n        require((b >= 0 && c >= a) || (b < 0 && c < a));\n        return c;\n    }\n\n    //\n    //Functions below only accept positive integers and result must be greater or equal to zero too.\n    //\n    function div_nn(int256 a, int256 b)\n    internal\n    pure\n    returns (int256)\n    {\n        require(a >= 0 && b > 0);\n        return a / b;\n    }\n\n    function mul_nn(int256 a, int256 b)\n    internal\n    pure\n    returns (int256)\n    {\n        require(a >= 0 && b >= 0);\n        int256 c = a * b;\n        require(a == 0 || c / a == b);\n        require(c >= 0);\n        return c;\n    }\n\n    function sub_nn(int256 a, int256 b)\n    internal\n    pure\n    returns (int256)\n    {\n        require(a >= 0 && b >= 0 && b <= a);\n        return a - b;\n    }\n\n    function add_nn(int256 a, int256 b)\n    internal\n    pure\n    returns (int256)\n    {\n        require(a >= 0 && b >= 0);\n        int256 c = a + b;\n        require(c >= a);\n        return c;\n    }\n\n    //\n    //Conversion and validation functions.\n    //\n    function abs(int256 a)\n    public\n    pure\n    returns (int256)\n    {\n        return a < 0 ? neg(a) : a;\n    }\n\n    function neg(int256 a)\n    public\n    pure\n    returns (int256)\n    {\n        return mul(a, - 1);\n    }\n\n    function toNonZeroInt256(uint256 a)\n    public\n    pure\n    returns (int256)\n    {\n        require(a > 0 && a < (uint256(1) << 255));\n        return int256(a);\n    }\n\n    function toInt256(uint256 a)\n    public\n    pure\n    returns (int256)\n    {\n        require(a >= 0 && a < (uint256(1) << 255));\n        return int256(a);\n    }\n\n    function toUInt256(int256 a)\n    public\n    pure\n    returns (uint256)\n    {\n        require(a >= 0);\n        return uint256(a);\n    }\n\n    function isNonZeroPositiveInt256(int256 a)\n    public\n    pure\n    returns (bool)\n    {\n        return (a > 0);\n    }\n\n    function isPositiveInt256(int256 a)\n    public\n    pure\n    returns (bool)\n    {\n        return (a >= 0);\n    }\n\n    function isNonZeroNegativeInt256(int256 a)\n    public\n    pure\n    returns (bool)\n    {\n        return (a < 0);\n    }\n\n    function isNegativeInt256(int256 a)\n    public\n    pure\n    returns (bool)\n    {\n        return (a <= 0);\n    }\n\n    //\n    //Clamping functions.\n    //\n    function clamp(int256 a, int256 min, int256 max)\n    public\n    pure\n    returns (int256)\n    {\n        if (a < min)\n            return min;\n        return (a > max) ? max : a;\n    }\n\n    function clampMin(int256 a, int256 min)\n    public\n    pure\n    returns (int256)\n    {\n        return (a < min) ? min : a;\n    }\n\n    function clampMax(int256 a, int256 max)\n    public\n    pure\n    returns (int256)\n    {\n        return (a > max) ? max : a;\n    }\n}\n\n/*\n * Hubii Nahmii\n *\n * Compliant with the Hubii Nahmii specification v0.12.\n *\n * Copyright (C) 2017-2018 Hubii AS\n */\n\nlibrary BlockNumbUintsLib {\n    //\n    // Structures\n    // -----------------------------------------------------------------------------------------------------------------\n    struct Entry {\n        uint256 blockNumber;\n        uint256 value;\n    }\n\n    struct BlockNumbUints {\n        Entry[] entries;\n    }\n\n    //\n    // Functions\n    // -----------------------------------------------------------------------------------------------------------------\n    function currentValue(BlockNumbUints storage self)\n    internal\n    view\n    returns (uint256)\n    {\n        return valueAt(self, block.number);\n    }\n\n    function currentEntry(BlockNumbUints storage self)\n    internal\n    view\n    returns (Entry memory)\n    {\n        return entryAt(self, block.number);\n    }\n\n    function valueAt(BlockNumbUints storage self, uint256 _blockNumber)\n    internal\n    view\n    returns (uint256)\n    {\n        return entryAt(self, _blockNumber).value;\n    }\n\n    function entryAt(BlockNumbUints storage self, uint256 _blockNumber)\n    internal\n    view\n    returns (Entry memory)\n    {\n        return self.entries[indexByBlockNumber(self, _blockNumber)];\n    }\n\n    function addEntry(BlockNumbUints storage self, uint256 blockNumber, uint256 value)\n    internal\n    {\n        require(\n            0 == self.entries.length ||\n        blockNumber > self.entries[self.entries.length - 1].blockNumber,\n            \"Later entry found [BlockNumbUintsLib.sol:62]\"\n        );\n\n        self.entries.push(Entry(blockNumber, value));\n    }\n\n    function count(BlockNumbUints storage self)\n    internal\n    view\n    returns (uint256)\n    {\n        return self.entries.length;\n    }\n\n    function entries(BlockNumbUints storage self)\n    internal\n    view\n    returns (Entry[] memory)\n    {\n        return self.entries;\n    }\n\n    function indexByBlockNumber(BlockNumbUints storage self, uint256 blockNumber)\n    internal\n    view\n    returns (uint256)\n    {\n        require(0 < self.entries.length, \"No entries found [BlockNumbUintsLib.sol:92]\");\n        for (uint256 i = self.entries.length - 1; i >= 0; i--)\n            if (blockNumber >= self.entries[i].blockNumber)\n                return i;\n        revert();\n    }\n}\n\n/*\n * Hubii Nahmii\n *\n * Compliant with the Hubii Nahmii specification v0.12.\n *\n * Copyright (C) 2017-2018 Hubii AS\n */\n\nlibrary BlockNumbIntsLib {\n    //\n    // Structures\n    // -----------------------------------------------------------------------------------------------------------------\n    struct Entry {\n        uint256 blockNumber;\n        int256 value;\n    }\n\n    struct BlockNumbInts {\n        Entry[] entries;\n    }\n\n    //\n    // Functions\n    // -----------------------------------------------------------------------------------------------------------------\n    function currentValue(BlockNumbInts storage self)\n    internal\n    view\n    returns (int256)\n    {\n        return valueAt(self, block.number);\n    }\n\n    function currentEntry(BlockNumbInts storage self)\n    internal\n    view\n    returns (Entry memory)\n    {\n        return entryAt(self, block.number);\n    }\n\n    function valueAt(BlockNumbInts storage self, uint256 _blockNumber)\n    internal\n    view\n    returns (int256)\n    {\n        return entryAt(self, _blockNumber).value;\n    }\n\n    function entryAt(BlockNumbInts storage self, uint256 _blockNumber)\n    internal\n    view\n    returns (Entry memory)\n    {\n        return self.entries[indexByBlockNumber(self, _blockNumber)];\n    }\n\n    function addEntry(BlockNumbInts storage self, uint256 blockNumber, int256 value)\n    internal\n    {\n        require(\n            0 == self.entries.length ||\n        blockNumber > self.entries[self.entries.length - 1].blockNumber,\n            \"Later entry found [BlockNumbIntsLib.sol:62]\"\n        );\n\n        self.entries.push(Entry(blockNumber, value));\n    }\n\n    function count(BlockNumbInts storage self)\n    internal\n    view\n    returns (uint256)\n    {\n        return self.entries.length;\n    }\n\n    function entries(BlockNumbInts storage self)\n    internal\n    view\n    returns (Entry[] memory)\n    {\n        return self.entries;\n    }\n\n    function indexByBlockNumber(BlockNumbInts storage self, uint256 blockNumber)\n    internal\n    view\n    returns (uint256)\n    {\n        require(0 < self.entries.length, \"No entries found [BlockNumbIntsLib.sol:92]\");\n        for (uint256 i = self.entries.length - 1; i >= 0; i--)\n            if (blockNumber >= self.entries[i].blockNumber)\n                return i;\n        revert();\n    }\n}\n\n/*\n * Hubii Nahmii\n *\n * Compliant with the Hubii Nahmii specification v0.12.\n *\n * Copyright (C) 2017-2018 Hubii AS\n */\n\nlibrary ConstantsLib {\n    // Get the fraction that represents the entirety, equivalent of 100%\n    function PARTS_PER()\n    public\n    pure\n    returns (int256)\n    {\n        return 1e18;\n    }\n}\n\n/*\n * Hubii Nahmii\n *\n * Compliant with the Hubii Nahmii specification v0.12.\n *\n * Copyright (C) 2017-2018 Hubii AS\n */\n\nlibrary BlockNumbDisdIntsLib {\n    using SafeMathIntLib for int256;\n\n    //\n    // Structures\n    // -----------------------------------------------------------------------------------------------------------------\n    struct Discount {\n        int256 tier;\n        int256 value;\n    }\n\n    struct Entry {\n        uint256 blockNumber;\n        int256 nominal;\n        Discount[] discounts;\n    }\n\n    struct BlockNumbDisdInts {\n        Entry[] entries;\n    }\n\n    //\n    // Functions\n    // -----------------------------------------------------------------------------------------------------------------\n    function currentNominalValue(BlockNumbDisdInts storage self)\n    internal\n    view\n    returns (int256)\n    {\n        return nominalValueAt(self, block.number);\n    }\n\n    function currentDiscountedValue(BlockNumbDisdInts storage self, int256 tier)\n    internal\n    view\n    returns (int256)\n    {\n        return discountedValueAt(self, block.number, tier);\n    }\n\n    function currentEntry(BlockNumbDisdInts storage self)\n    internal\n    view\n    returns (Entry memory)\n    {\n        return entryAt(self, block.number);\n    }\n\n    function nominalValueAt(BlockNumbDisdInts storage self, uint256 _blockNumber)\n    internal\n    view\n    returns (int256)\n    {\n        return entryAt(self, _blockNumber).nominal;\n    }\n\n    function discountedValueAt(BlockNumbDisdInts storage self, uint256 _blockNumber, int256 tier)\n    internal\n    view\n    returns (int256)\n    {\n        Entry memory entry = entryAt(self, _blockNumber);\n        if (0 < entry.discounts.length) {\n            uint256 index = indexByTier(entry.discounts, tier);\n            if (0 < index)\n                return entry.nominal.mul(\n                    ConstantsLib.PARTS_PER().sub(entry.discounts[index - 1].value)\n                ).div(\n                    ConstantsLib.PARTS_PER()\n                );\n            else\n                return entry.nominal;\n        } else\n            return entry.nominal;\n    }\n\n    function entryAt(BlockNumbDisdInts storage self, uint256 _blockNumber)\n    internal\n    view\n    returns (Entry memory)\n    {\n        return self.entries[indexByBlockNumber(self, _blockNumber)];\n    }\n\n    function addNominalEntry(BlockNumbDisdInts storage self, uint256 blockNumber, int256 nominal)\n    internal\n    {\n        require(\n            0 == self.entries.length ||\n        blockNumber > self.entries[self.entries.length - 1].blockNumber,\n            \"Later entry found [BlockNumbDisdIntsLib.sol:101]\"\n        );\n\n        self.entries.length++;\n        Entry storage entry = self.entries[self.entries.length - 1];\n\n        entry.blockNumber = blockNumber;\n        entry.nominal = nominal;\n    }\n\n    function addDiscountedEntry(BlockNumbDisdInts storage self, uint256 blockNumber, int256 nominal,\n        int256[] memory discountTiers, int256[] memory discountValues)\n    internal\n    {\n        require(discountTiers.length == discountValues.length, \"Parameter array lengths mismatch [BlockNumbDisdIntsLib.sol:118]\");\n\n        addNominalEntry(self, blockNumber, nominal);\n\n        Entry storage entry = self.entries[self.entries.length - 1];\n        for (uint256 i = 0; i < discountTiers.length; i++)\n            entry.discounts.push(Discount(discountTiers[i], discountValues[i]));\n    }\n\n    function count(BlockNumbDisdInts storage self)\n    internal\n    view\n    returns (uint256)\n    {\n        return self.entries.length;\n    }\n\n    function entries(BlockNumbDisdInts storage self)\n    internal\n    view\n    returns (Entry[] memory)\n    {\n        return self.entries;\n    }\n\n    function indexByBlockNumber(BlockNumbDisdInts storage self, uint256 blockNumber)\n    internal\n    view\n    returns (uint256)\n    {\n        require(0 < self.entries.length, \"No entries found [BlockNumbDisdIntsLib.sol:148]\");\n        for (uint256 i = self.entries.length - 1; i >= 0; i--)\n            if (blockNumber >= self.entries[i].blockNumber)\n                return i;\n        revert();\n    }\n\n    /// @dev The index returned here is 1-based\n    function indexByTier(Discount[] memory discounts, int256 tier)\n    internal\n    pure\n    returns (uint256)\n    {\n        require(0 < discounts.length, \"No discounts found [BlockNumbDisdIntsLib.sol:161]\");\n        for (uint256 i = discounts.length; i > 0; i--)\n            if (tier >= discounts[i - 1].tier)\n                return i;\n        return 0;\n    }\n}\n\n/*\n * Hubii Nahmii\n *\n * Compliant with the Hubii Nahmii specification v0.12.\n *\n * Copyright (C) 2017-2018 Hubii AS\n */\n\n/**\n * @title     MonetaryTypesLib\n * @dev       Monetary data types\n */\nlibrary MonetaryTypesLib {\n    //\n    // Structures\n    // -----------------------------------------------------------------------------------------------------------------\n    struct Currency {\n        address ct;\n        uint256 id;\n    }\n\n    struct Figure {\n        int256 amount;\n        Currency currency;\n    }\n\n    struct NoncedAmount {\n        uint256 nonce;\n        int256 amount;\n    }\n}\n\n/*\n * Hubii Nahmii\n *\n * Compliant with the Hubii Nahmii specification v0.12.\n *\n * Copyright (C) 2017-2018 Hubii AS\n */\n\nlibrary BlockNumbReferenceCurrenciesLib {\n    //\n    // Structures\n    // -----------------------------------------------------------------------------------------------------------------\n    struct Entry {\n        uint256 blockNumber;\n        MonetaryTypesLib.Currency currency;\n    }\n\n    struct BlockNumbReferenceCurrencies {\n        mapping(address => mapping(uint256 => Entry[])) entriesByCurrency;\n    }\n\n    //\n    // Functions\n    // -----------------------------------------------------------------------------------------------------------------\n    function currentCurrency(BlockNumbReferenceCurrencies storage self, MonetaryTypesLib.Currency memory referenceCurrency)\n    internal\n    view\n    returns (MonetaryTypesLib.Currency storage)\n    {\n        return currencyAt(self, referenceCurrency, block.number);\n    }\n\n    function currentEntry(BlockNumbReferenceCurrencies storage self, MonetaryTypesLib.Currency memory referenceCurrency)\n    internal\n    view\n    returns (Entry storage)\n    {\n        return entryAt(self, referenceCurrency, block.number);\n    }\n\n    function currencyAt(BlockNumbReferenceCurrencies storage self, MonetaryTypesLib.Currency memory referenceCurrency,\n        uint256 _blockNumber)\n    internal\n    view\n    returns (MonetaryTypesLib.Currency storage)\n    {\n        return entryAt(self, referenceCurrency, _blockNumber).currency;\n    }\n\n    function entryAt(BlockNumbReferenceCurrencies storage self, MonetaryTypesLib.Currency memory referenceCurrency,\n        uint256 _blockNumber)\n    internal\n    view\n    returns (Entry storage)\n    {\n        return self.entriesByCurrency[referenceCurrency.ct][referenceCurrency.id][indexByBlockNumber(self, referenceCurrency, _blockNumber)];\n    }\n\n    function addEntry(BlockNumbReferenceCurrencies storage self, uint256 blockNumber,\n        MonetaryTypesLib.Currency memory referenceCurrency, MonetaryTypesLib.Currency memory currency)\n    internal\n    {\n        require(\n            0 == self.entriesByCurrency[referenceCurrency.ct][referenceCurrency.id].length ||\n        blockNumber > self.entriesByCurrency[referenceCurrency.ct][referenceCurrency.id][self.entriesByCurrency[referenceCurrency.ct][referenceCurrency.id].length - 1].blockNumber,\n            \"Later entry found for currency [BlockNumbReferenceCurrenciesLib.sol:67]\"\n        );\n\n        self.entriesByCurrency[referenceCurrency.ct][referenceCurrency.id].push(Entry(blockNumber, currency));\n    }\n\n    function count(BlockNumbReferenceCurrencies storage self, MonetaryTypesLib.Currency memory referenceCurrency)\n    internal\n    view\n    returns (uint256)\n    {\n        return self.entriesByCurrency[referenceCurrency.ct][referenceCurrency.id].length;\n    }\n\n    function entriesByCurrency(BlockNumbReferenceCurrencies storage self, MonetaryTypesLib.Currency memory referenceCurrency)\n    internal\n    view\n    returns (Entry[] storage)\n    {\n        return self.entriesByCurrency[referenceCurrency.ct][referenceCurrency.id];\n    }\n\n    function indexByBlockNumber(BlockNumbReferenceCurrencies storage self, MonetaryTypesLib.Currency memory referenceCurrency, uint256 blockNumber)\n    internal\n    view\n    returns (uint256)\n    {\n        require(0 < self.entriesByCurrency[referenceCurrency.ct][referenceCurrency.id].length, \"No entries found for currency [BlockNumbReferenceCurrenciesLib.sol:97]\");\n        for (uint256 i = self.entriesByCurrency[referenceCurrency.ct][referenceCurrency.id].length - 1; i >= 0; i--)\n            if (blockNumber >= self.entriesByCurrency[referenceCurrency.ct][referenceCurrency.id][i].blockNumber)\n                return i;\n        revert();\n    }\n}\n\n/*\n * Hubii Nahmii\n *\n * Compliant with the Hubii Nahmii specification v0.12.\n *\n * Copyright (C) 2017-2018 Hubii AS\n */\n\nlibrary BlockNumbFiguresLib {\n    //\n    // Structures\n    // -----------------------------------------------------------------------------------------------------------------\n    struct Entry {\n        uint256 blockNumber;\n        MonetaryTypesLib.Figure value;\n    }\n\n    struct BlockNumbFigures {\n        Entry[] entries;\n    }\n\n    //\n    // Functions\n    // -----------------------------------------------------------------------------------------------------------------\n    function currentValue(BlockNumbFigures storage self)\n    internal\n    view\n    returns (MonetaryTypesLib.Figure storage)\n    {\n        return valueAt(self, block.number);\n    }\n\n    function currentEntry(BlockNumbFigures storage self)\n    internal\n    view\n    returns (Entry storage)\n    {\n        return entryAt(self, block.number);\n    }\n\n    function valueAt(BlockNumbFigures storage self, uint256 _blockNumber)\n    internal\n    view\n    returns (MonetaryTypesLib.Figure storage)\n    {\n        return entryAt(self, _blockNumber).value;\n    }\n\n    function entryAt(BlockNumbFigures storage self, uint256 _blockNumber)\n    internal\n    view\n    returns (Entry storage)\n    {\n        return self.entries[indexByBlockNumber(self, _blockNumber)];\n    }\n\n    function addEntry(BlockNumbFigures storage self, uint256 blockNumber, MonetaryTypesLib.Figure memory value)\n    internal\n    {\n        require(\n            0 == self.entries.length ||\n        blockNumber > self.entries[self.entries.length - 1].blockNumber,\n            \"Later entry found [BlockNumbFiguresLib.sol:65]\"\n        );\n\n        self.entries.push(Entry(blockNumber, value));\n    }\n\n    function count(BlockNumbFigures storage self)\n    internal\n    view\n    returns (uint256)\n    {\n        return self.entries.length;\n    }\n\n    function entries(BlockNumbFigures storage self)\n    internal\n    view\n    returns (Entry[] storage)\n    {\n        return self.entries;\n    }\n\n    function indexByBlockNumber(BlockNumbFigures storage self, uint256 blockNumber)\n    internal\n    view\n    returns (uint256)\n    {\n        require(0 < self.entries.length, \"No entries found [BlockNumbFiguresLib.sol:95]\");\n        for (uint256 i = self.entries.length - 1; i >= 0; i--)\n            if (blockNumber >= self.entries[i].blockNumber)\n                return i;\n        revert();\n    }\n}\n\n/*\n * Hubii Nahmii\n *\n * Compliant with the Hubii Nahmii specification v0.12.\n *\n * Copyright (C) 2017-2018 Hubii AS\n */\n\n/**\n * @title Configuration\n * @notice An oracle for configurations values\n */\ncontract Configuration is Modifiable, Ownable, Servable {\n    using SafeMathIntLib for int256;\n    using BlockNumbUintsLib for BlockNumbUintsLib.BlockNumbUints;\n    using BlockNumbIntsLib for BlockNumbIntsLib.BlockNumbInts;\n    using BlockNumbDisdIntsLib for BlockNumbDisdIntsLib.BlockNumbDisdInts;\n    using BlockNumbReferenceCurrenciesLib for BlockNumbReferenceCurrenciesLib.BlockNumbReferenceCurrencies;\n    using BlockNumbFiguresLib for BlockNumbFiguresLib.BlockNumbFigures;\n\n    //\n    // Constants\n    // -----------------------------------------------------------------------------------------------------------------\n    string constant public OPERATIONAL_MODE_ACTION = \"operational_mode\";\n\n    //\n    // Enums\n    // -----------------------------------------------------------------------------------------------------------------\n    enum OperationalMode {Normal, Exit}\n\n    //\n    // Variables\n    // -----------------------------------------------------------------------------------------------------------------\n    OperationalMode public operationalMode = OperationalMode.Normal;\n\n    BlockNumbUintsLib.BlockNumbUints private updateDelayBlocksByBlockNumber;\n    BlockNumbUintsLib.BlockNumbUints private confirmationBlocksByBlockNumber;\n\n    BlockNumbDisdIntsLib.BlockNumbDisdInts private tradeMakerFeeByBlockNumber;\n    BlockNumbDisdIntsLib.BlockNumbDisdInts private tradeTakerFeeByBlockNumber;\n    BlockNumbDisdIntsLib.BlockNumbDisdInts private paymentFeeByBlockNumber;\n    mapping(address => mapping(uint256 => BlockNumbDisdIntsLib.BlockNumbDisdInts)) private currencyPaymentFeeByBlockNumber;\n\n    BlockNumbIntsLib.BlockNumbInts private tradeMakerMinimumFeeByBlockNumber;\n    BlockNumbIntsLib.BlockNumbInts private tradeTakerMinimumFeeByBlockNumber;\n    BlockNumbIntsLib.BlockNumbInts private paymentMinimumFeeByBlockNumber;\n    mapping(address => mapping(uint256 => BlockNumbIntsLib.BlockNumbInts)) private currencyPaymentMinimumFeeByBlockNumber;\n\n    BlockNumbReferenceCurrenciesLib.BlockNumbReferenceCurrencies private feeCurrencyByCurrencyBlockNumber;\n\n    BlockNumbUintsLib.BlockNumbUints private walletLockTimeoutByBlockNumber;\n    BlockNumbUintsLib.BlockNumbUints private cancelOrderChallengeTimeoutByBlockNumber;\n    BlockNumbUintsLib.BlockNumbUints private settlementChallengeTimeoutByBlockNumber;\n\n    BlockNumbUintsLib.BlockNumbUints private fraudStakeFractionByBlockNumber;\n    BlockNumbUintsLib.BlockNumbUints private walletSettlementStakeFractionByBlockNumber;\n    BlockNumbUintsLib.BlockNumbUints private operatorSettlementStakeFractionByBlockNumber;\n\n    BlockNumbFiguresLib.BlockNumbFigures private operatorSettlementStakeByBlockNumber;\n\n    uint256 public earliestSettlementBlockNumber;\n    bool public earliestSettlementBlockNumberUpdateDisabled;\n\n    //\n    // Events\n    // -----------------------------------------------------------------------------------------------------------------\n    event SetOperationalModeExitEvent();\n    event SetUpdateDelayBlocksEvent(uint256 fromBlockNumber, uint256 newBlocks);\n    event SetConfirmationBlocksEvent(uint256 fromBlockNumber, uint256 newBlocks);\n    event SetTradeMakerFeeEvent(uint256 fromBlockNumber, int256 nominal, int256[] discountTiers, int256[] discountValues);\n    event SetTradeTakerFeeEvent(uint256 fromBlockNumber, int256 nominal, int256[] discountTiers, int256[] discountValues);\n    event SetPaymentFeeEvent(uint256 fromBlockNumber, int256 nominal, int256[] discountTiers, int256[] discountValues);\n    event SetCurrencyPaymentFeeEvent(uint256 fromBlockNumber, address currencyCt, uint256 currencyId, int256 nominal,\n        int256[] discountTiers, int256[] discountValues);\n    event SetTradeMakerMinimumFeeEvent(uint256 fromBlockNumber, int256 nominal);\n    event SetTradeTakerMinimumFeeEvent(uint256 fromBlockNumber, int256 nominal);\n    event SetPaymentMinimumFeeEvent(uint256 fromBlockNumber, int256 nominal);\n    event SetCurrencyPaymentMinimumFeeEvent(uint256 fromBlockNumber, address currencyCt, uint256 currencyId, int256 nominal);\n    event SetFeeCurrencyEvent(uint256 fromBlockNumber, address referenceCurrencyCt, uint256 referenceCurrencyId,\n        address feeCurrencyCt, uint256 feeCurrencyId);\n    event SetWalletLockTimeoutEvent(uint256 fromBlockNumber, uint256 timeoutInSeconds);\n    event SetCancelOrderChallengeTimeoutEvent(uint256 fromBlockNumber, uint256 timeoutInSeconds);\n    event SetSettlementChallengeTimeoutEvent(uint256 fromBlockNumber, uint256 timeoutInSeconds);\n    event SetWalletSettlementStakeFractionEvent(uint256 fromBlockNumber, uint256 stakeFraction);\n    event SetOperatorSettlementStakeFractionEvent(uint256 fromBlockNumber, uint256 stakeFraction);\n    event SetOperatorSettlementStakeEvent(uint256 fromBlockNumber, int256 stakeAmount, address stakeCurrencyCt,\n        uint256 stakeCurrencyId);\n    event SetFraudStakeFractionEvent(uint256 fromBlockNumber, uint256 stakeFraction);\n    event SetEarliestSettlementBlockNumberEvent(uint256 earliestSettlementBlockNumber);\n    event DisableEarliestSettlementBlockNumberUpdateEvent();\n\n    //\n    // Constructor\n    // -----------------------------------------------------------------------------------------------------------------\n    constructor(address deployer) Ownable(deployer) public {\n        updateDelayBlocksByBlockNumber.addEntry(block.number, 0);\n    }\n\n    //\n    // Public functions\n    // -----------------------------------------------------------------------------------------------------------------\n    /// @notice Set operational mode to Exit\n    /// @dev Once operational mode is set to Exit it may not be set back to Normal\n    function setOperationalModeExit()\n    public\n    onlyEnabledServiceAction(OPERATIONAL_MODE_ACTION)\n    {\n        operationalMode = OperationalMode.Exit;\n        emit SetOperationalModeExitEvent();\n    }\n\n    /// @notice Return true if operational mode is Normal\n    function isOperationalModeNormal()\n    public\n    view\n    returns (bool)\n    {\n        return OperationalMode.Normal == operationalMode;\n    }\n\n    /// @notice Return true if operational mode is Exit\n    function isOperationalModeExit()\n    public\n    view\n    returns (bool)\n    {\n        return OperationalMode.Exit == operationalMode;\n    }\n\n    /// @notice Get the current value of update delay blocks\n    /// @return The value of update delay blocks\n    function updateDelayBlocks()\n    public\n    view\n    returns (uint256)\n    {\n        return updateDelayBlocksByBlockNumber.currentValue();\n    }\n\n    /// @notice Get the count of update delay blocks values\n    /// @return The count of update delay blocks values\n    function updateDelayBlocksCount()\n    public\n    view\n    returns (uint256)\n    {\n        return updateDelayBlocksByBlockNumber.count();\n    }\n\n    /// @notice Set the number of update delay blocks\n    /// @param fromBlockNumber Block number from which the update applies\n    /// @param newUpdateDelayBlocks The new update delay blocks value\n    function setUpdateDelayBlocks(uint256 fromBlockNumber, uint256 newUpdateDelayBlocks)\n    public\n    onlyOperator\n    onlyDelayedBlockNumber(fromBlockNumber)\n    {\n        updateDelayBlocksByBlockNumber.addEntry(fromBlockNumber, newUpdateDelayBlocks);\n        emit SetUpdateDelayBlocksEvent(fromBlockNumber, newUpdateDelayBlocks);\n    }\n\n    /// @notice Get the current value of confirmation blocks\n    /// @return The value of confirmation blocks\n    function confirmationBlocks()\n    public\n    view\n    returns (uint256)\n    {\n        return confirmationBlocksByBlockNumber.currentValue();\n    }\n\n    /// @notice Get the count of confirmation blocks values\n    /// @return The count of confirmation blocks values\n    function confirmationBlocksCount()\n    public\n    view\n    returns (uint256)\n    {\n        return confirmationBlocksByBlockNumber.count();\n    }\n\n    /// @notice Set the number of confirmation blocks\n    /// @param fromBlockNumber Block number from which the update applies\n    /// @param newConfirmationBlocks The new confirmation blocks value\n    function setConfirmationBlocks(uint256 fromBlockNumber, uint256 newConfirmationBlocks)\n    public\n    onlyOperator\n    onlyDelayedBlockNumber(fromBlockNumber)\n    {\n        confirmationBlocksByBlockNumber.addEntry(fromBlockNumber, newConfirmationBlocks);\n        emit SetConfirmationBlocksEvent(fromBlockNumber, newConfirmationBlocks);\n    }\n\n    /// @notice Get number of trade maker fee block number tiers\n    function tradeMakerFeesCount()\n    public\n    view\n    returns (uint256)\n    {\n        return tradeMakerFeeByBlockNumber.count();\n    }\n\n    /// @notice Get trade maker relative fee at given block number, possibly discounted by discount tier value\n    /// @param blockNumber The concerned block number\n    /// @param discountTier The concerned discount tier\n    function tradeMakerFee(uint256 blockNumber, int256 discountTier)\n    public\n    view\n    returns (int256)\n    {\n        return tradeMakerFeeByBlockNumber.discountedValueAt(blockNumber, discountTier);\n    }\n\n    /// @notice Set trade maker nominal relative fee and discount tiers and values at given block number tier\n    /// @param fromBlockNumber Block number from which the update applies\n    /// @param nominal Nominal relative fee\n    /// @param nominal Discount tier levels\n    /// @param nominal Discount values\n    function setTradeMakerFee(uint256 fromBlockNumber, int256 nominal, int256[] memory discountTiers, int256[] memory discountValues)\n    public\n    onlyOperator\n    onlyDelayedBlockNumber(fromBlockNumber)\n    {\n        tradeMakerFeeByBlockNumber.addDiscountedEntry(fromBlockNumber, nominal, discountTiers, discountValues);\n        emit SetTradeMakerFeeEvent(fromBlockNumber, nominal, discountTiers, discountValues);\n    }\n\n    /// @notice Get number of trade taker fee block number tiers\n    function tradeTakerFeesCount()\n    public\n    view\n    returns (uint256)\n    {\n        return tradeTakerFeeByBlockNumber.count();\n    }\n\n    /// @notice Get trade taker relative fee at given block number, possibly discounted by discount tier value\n    /// @param blockNumber The concerned block number\n    /// @param discountTier The concerned discount tier\n    function tradeTakerFee(uint256 blockNumber, int256 discountTier)\n    public\n    view\n    returns (int256)\n    {\n        return tradeTakerFeeByBlockNumber.discountedValueAt(blockNumber, discountTier);\n    }\n\n    /// @notice Set trade taker nominal relative fee and discount tiers and values at given block number tier\n    /// @param fromBlockNumber Block number from which the update applies\n    /// @param nominal Nominal relative fee\n    /// @param nominal Discount tier levels\n    /// @param nominal Discount values\n    function setTradeTakerFee(uint256 fromBlockNumber, int256 nominal, int256[] memory discountTiers, int256[] memory discountValues)\n    public\n    onlyOperator\n    onlyDelayedBlockNumber(fromBlockNumber)\n    {\n        tradeTakerFeeByBlockNumber.addDiscountedEntry(fromBlockNumber, nominal, discountTiers, discountValues);\n        emit SetTradeTakerFeeEvent(fromBlockNumber, nominal, discountTiers, discountValues);\n    }\n\n    /// @notice Get number of payment fee block number tiers\n    function paymentFeesCount()\n    public\n    view\n    returns (uint256)\n    {\n        return paymentFeeByBlockNumber.count();\n    }\n\n    /// @notice Get payment relative fee at given block number, possibly discounted by discount tier value\n    /// @param blockNumber The concerned block number\n    /// @param discountTier The concerned discount tier\n    function paymentFee(uint256 blockNumber, int256 discountTier)\n    public\n    view\n    returns (int256)\n    {\n        return paymentFeeByBlockNumber.discountedValueAt(blockNumber, discountTier);\n    }\n\n    /// @notice Set payment nominal relative fee and discount tiers and values at given block number tier\n    /// @param fromBlockNumber Block number from which the update applies\n    /// @param nominal Nominal relative fee\n    /// @param nominal Discount tier levels\n    /// @param nominal Discount values\n    function setPaymentFee(uint256 fromBlockNumber, int256 nominal, int256[] memory discountTiers, int256[] memory discountValues)\n    public\n    onlyOperator\n    onlyDelayedBlockNumber(fromBlockNumber)\n    {\n        paymentFeeByBlockNumber.addDiscountedEntry(fromBlockNumber, nominal, discountTiers, discountValues);\n        emit SetPaymentFeeEvent(fromBlockNumber, nominal, discountTiers, discountValues);\n    }\n\n    /// @notice Get number of payment fee block number tiers of given currency\n    /// @param currencyCt The address of the concerned currency contract (address(0) == ETH)\n    /// @param currencyId The ID of the concerned currency (0 for ETH and ERC20)\n    function currencyPaymentFeesCount(address currencyCt, uint256 currencyId)\n    public\n    view\n    returns (uint256)\n    {\n        return currencyPaymentFeeByBlockNumber[currencyCt][currencyId].count();\n    }\n\n    /// @notice Get payment relative fee for given currency at given block number, possibly discounted by\n    /// discount tier value\n    /// @param blockNumber The concerned block number\n    /// @param currencyCt The address of the concerned currency contract (address(0) == ETH)\n    /// @param currencyId The ID of the concerned currency (0 for ETH and ERC20)\n    /// @param discountTier The concerned discount tier\n    function currencyPaymentFee(uint256 blockNumber, address currencyCt, uint256 currencyId, int256 discountTier)\n    public\n    view\n    returns (int256)\n    {\n        if (0 < currencyPaymentFeeByBlockNumber[currencyCt][currencyId].count())\n            return currencyPaymentFeeByBlockNumber[currencyCt][currencyId].discountedValueAt(\n                blockNumber, discountTier\n            );\n        else\n            return paymentFee(blockNumber, discountTier);\n    }\n\n    /// @notice Set payment nominal relative fee and discount tiers and values for given currency at given\n    /// block number tier\n    /// @param fromBlockNumber Block number from which the update applies\n    /// @param currencyCt The address of the concerned currency contract (address(0) == ETH)\n    /// @param currencyId The ID of the concerned currency (0 for ETH and ERC20)\n    /// @param nominal Nominal relative fee\n    /// @param nominal Discount tier levels\n    /// @param nominal Discount values\n    function setCurrencyPaymentFee(uint256 fromBlockNumber, address currencyCt, uint256 currencyId, int256 nominal,\n        int256[] memory discountTiers, int256[] memory discountValues)\n    public\n    onlyOperator\n    onlyDelayedBlockNumber(fromBlockNumber)\n    {\n        currencyPaymentFeeByBlockNumber[currencyCt][currencyId].addDiscountedEntry(\n            fromBlockNumber, nominal, discountTiers, discountValues\n        );\n        emit SetCurrencyPaymentFeeEvent(\n            fromBlockNumber, currencyCt, currencyId, nominal, discountTiers, discountValues\n        );\n    }\n\n    /// @notice Get number of minimum trade maker fee block number tiers\n    function tradeMakerMinimumFeesCount()\n    public\n    view\n    returns (uint256)\n    {\n        return tradeMakerMinimumFeeByBlockNumber.count();\n    }\n\n    /// @notice Get trade maker minimum relative fee at given block number\n    /// @param blockNumber The concerned block number\n    function tradeMakerMinimumFee(uint256 blockNumber)\n    public\n    view\n    returns (int256)\n    {\n        return tradeMakerMinimumFeeByBlockNumber.valueAt(blockNumber);\n    }\n\n    /// @notice Set trade maker minimum relative fee at given block number tier\n    /// @param fromBlockNumber Block number from which the update applies\n    /// @param nominal Minimum relative fee\n    function setTradeMakerMinimumFee(uint256 fromBlockNumber, int256 nominal)\n    public\n    onlyOperator\n    onlyDelayedBlockNumber(fromBlockNumber)\n    {\n        tradeMakerMinimumFeeByBlockNumber.addEntry(fromBlockNumber, nominal);\n        emit SetTradeMakerMinimumFeeEvent(fromBlockNumber, nominal);\n    }\n\n    /// @notice Get number of minimum trade taker fee block number tiers\n    function tradeTakerMinimumFeesCount()\n    public\n    view\n    returns (uint256)\n    {\n        return tradeTakerMinimumFeeByBlockNumber.count();\n    }\n\n    /// @notice Get trade taker minimum relative fee at given block number\n    /// @param blockNumber The concerned block number\n    function tradeTakerMinimumFee(uint256 blockNumber)\n    public\n    view\n    returns (int256)\n    {\n        return tradeTakerMinimumFeeByBlockNumber.valueAt(blockNumber);\n    }\n\n    /// @notice Set trade taker minimum relative fee at given block number tier\n    /// @param fromBlockNumber Block number from which the update applies\n    /// @param nominal Minimum relative fee\n    function setTradeTakerMinimumFee(uint256 fromBlockNumber, int256 nominal)\n    public\n    onlyOperator\n    onlyDelayedBlockNumber(fromBlockNumber)\n    {\n        tradeTakerMinimumFeeByBlockNumber.addEntry(fromBlockNumber, nominal);\n        emit SetTradeTakerMinimumFeeEvent(fromBlockNumber, nominal);\n    }\n\n    /// @notice Get number of minimum payment fee block number tiers\n    function paymentMinimumFeesCount()\n    public\n    view\n    returns (uint256)\n    {\n        return paymentMinimumFeeByBlockNumber.count();\n    }\n\n    /// @notice Get payment minimum relative fee at given block number\n    /// @param blockNumber The concerned block number\n    function paymentMinimumFee(uint256 blockNumber)\n    public\n    view\n    returns (int256)\n    {\n        return paymentMinimumFeeByBlockNumber.valueAt(blockNumber);\n    }\n\n    /// @notice Set payment minimum relative fee at given block number tier\n    /// @param fromBlockNumber Block number from which the update applies\n    /// @param nominal Minimum relative fee\n    function setPaymentMinimumFee(uint256 fromBlockNumber, int256 nominal)\n    public\n    onlyOperator\n    onlyDelayedBlockNumber(fromBlockNumber)\n    {\n        paymentMinimumFeeByBlockNumber.addEntry(fromBlockNumber, nominal);\n        emit SetPaymentMinimumFeeEvent(fromBlockNumber, nominal);\n    }\n\n    /// @notice Get number of minimum payment fee block number tiers for given currency\n    /// @param currencyCt The address of the concerned currency contract (address(0) == ETH)\n    /// @param currencyId The ID of the concerned currency (0 for ETH and ERC20)\n    function currencyPaymentMinimumFeesCount(address currencyCt, uint256 currencyId)\n    public\n    view\n    returns (uint256)\n    {\n        return currencyPaymentMinimumFeeByBlockNumber[currencyCt][currencyId].count();\n    }\n\n    /// @notice Get payment minimum relative fee for given currency at given block number\n    /// @param blockNumber The concerned block number\n    /// @param currencyCt The address of the concerned currency contract (address(0) == ETH)\n    /// @param currencyId The ID of the concerned currency (0 for ETH and ERC20)\n    function currencyPaymentMinimumFee(uint256 blockNumber, address currencyCt, uint256 currencyId)\n    public\n    view\n    returns (int256)\n    {\n        if (0 < currencyPaymentMinimumFeeByBlockNumber[currencyCt][currencyId].count())\n            return currencyPaymentMinimumFeeByBlockNumber[currencyCt][currencyId].valueAt(blockNumber);\n        else\n            return paymentMinimumFee(blockNumber);\n    }\n\n    /// @notice Set payment minimum relative fee for given currency at given block number tier\n    /// @param fromBlockNumber Block number from which the update applies\n    /// @param currencyCt The address of the concerned currency contract (address(0) == ETH)\n    /// @param currencyId The ID of the concerned currency (0 for ETH and ERC20)\n    /// @param nominal Minimum relative fee\n    function setCurrencyPaymentMinimumFee(uint256 fromBlockNumber, address currencyCt, uint256 currencyId, int256 nominal)\n    public\n    onlyOperator\n    onlyDelayedBlockNumber(fromBlockNumber)\n    {\n        currencyPaymentMinimumFeeByBlockNumber[currencyCt][currencyId].addEntry(fromBlockNumber, nominal);\n        emit SetCurrencyPaymentMinimumFeeEvent(fromBlockNumber, currencyCt, currencyId, nominal);\n    }\n\n    /// @notice Get number of fee currencies for the given reference currency\n    /// @param currencyCt The address of the concerned reference currency contract (address(0) == ETH)\n    /// @param currencyId The ID of the concerned reference currency (0 for ETH and ERC20)\n    function feeCurrenciesCount(address currencyCt, uint256 currencyId)\n    public\n    view\n    returns (uint256)\n    {\n        return feeCurrencyByCurrencyBlockNumber.count(MonetaryTypesLib.Currency(currencyCt, currencyId));\n    }\n\n    /// @notice Get the fee currency for the given reference currency at given block number\n    /// @param blockNumber The concerned block number\n    /// @param currencyCt The address of the concerned reference currency contract (address(0) == ETH)\n    /// @param currencyId The ID of the concerned reference currency (0 for ETH and ERC20)\n    function feeCurrency(uint256 blockNumber, address currencyCt, uint256 currencyId)\n    public\n    view\n    returns (address ct, uint256 id)\n    {\n        MonetaryTypesLib.Currency storage _feeCurrency = feeCurrencyByCurrencyBlockNumber.currencyAt(\n            MonetaryTypesLib.Currency(currencyCt, currencyId), blockNumber\n        );\n        ct = _feeCurrency.ct;\n        id = _feeCurrency.id;\n    }\n\n    /// @notice Set the fee currency for the given reference currency at given block number\n    /// @param fromBlockNumber Block number from which the update applies\n    /// @param referenceCurrencyCt The address of the concerned reference currency contract (address(0) == ETH)\n    /// @param referenceCurrencyId The ID of the concerned reference currency (0 for ETH and ERC20)\n    /// @param feeCurrencyCt The address of the concerned fee currency contract (address(0) == ETH)\n    /// @param feeCurrencyId The ID of the concerned fee currency (0 for ETH and ERC20)\n    function setFeeCurrency(uint256 fromBlockNumber, address referenceCurrencyCt, uint256 referenceCurrencyId,\n        address feeCurrencyCt, uint256 feeCurrencyId)\n    public\n    onlyOperator\n    onlyDelayedBlockNumber(fromBlockNumber)\n    {\n        feeCurrencyByCurrencyBlockNumber.addEntry(\n            fromBlockNumber,\n            MonetaryTypesLib.Currency(referenceCurrencyCt, referenceCurrencyId),\n            MonetaryTypesLib.Currency(feeCurrencyCt, feeCurrencyId)\n        );\n        emit SetFeeCurrencyEvent(fromBlockNumber, referenceCurrencyCt, referenceCurrencyId,\n            feeCurrencyCt, feeCurrencyId);\n    }\n\n    /// @notice Get the current value of wallet lock timeout\n    /// @return The value of wallet lock timeout\n    function walletLockTimeout()\n    public\n    view\n    returns (uint256)\n    {\n        return walletLockTimeoutByBlockNumber.currentValue();\n    }\n\n    /// @notice Set timeout of wallet lock\n    /// @param fromBlockNumber Block number from which the update applies\n    /// @param timeoutInSeconds Timeout duration in seconds\n    function setWalletLockTimeout(uint256 fromBlockNumber, uint256 timeoutInSeconds)\n    public\n    onlyOperator\n    onlyDelayedBlockNumber(fromBlockNumber)\n    {\n        walletLockTimeoutByBlockNumber.addEntry(fromBlockNumber, timeoutInSeconds);\n        emit SetWalletLockTimeoutEvent(fromBlockNumber, timeoutInSeconds);\n    }\n\n    /// @notice Get the current value of cancel order challenge timeout\n    /// @return The value of cancel order challenge timeout\n    function cancelOrderChallengeTimeout()\n    public\n    view\n    returns (uint256)\n    {\n        return cancelOrderChallengeTimeoutByBlockNumber.currentValue();\n    }\n\n    /// @notice Set timeout of cancel order challenge\n    /// @param fromBlockNumber Block number from which the update applies\n    /// @param timeoutInSeconds Timeout duration in seconds\n    function setCancelOrderChallengeTimeout(uint256 fromBlockNumber, uint256 timeoutInSeconds)\n    public\n    onlyOperator\n    onlyDelayedBlockNumber(fromBlockNumber)\n    {\n        cancelOrderChallengeTimeoutByBlockNumber.addEntry(fromBlockNumber, timeoutInSeconds);\n        emit SetCancelOrderChallengeTimeoutEvent(fromBlockNumber, timeoutInSeconds);\n    }\n\n    /// @notice Get the current value of settlement challenge timeout\n    /// @return The value of settlement challenge timeout\n    function settlementChallengeTimeout()\n    public\n    view\n    returns (uint256)\n    {\n        return settlementChallengeTimeoutByBlockNumber.currentValue();\n    }\n\n    /// @notice Set timeout of settlement challenges\n    /// @param fromBlockNumber Block number from which the update applies\n    /// @param timeoutInSeconds Timeout duration in seconds\n    function setSettlementChallengeTimeout(uint256 fromBlockNumber, uint256 timeoutInSeconds)\n    public\n    onlyOperator\n    onlyDelayedBlockNumber(fromBlockNumber)\n    {\n        settlementChallengeTimeoutByBlockNumber.addEntry(fromBlockNumber, timeoutInSeconds);\n        emit SetSettlementChallengeTimeoutEvent(fromBlockNumber, timeoutInSeconds);\n    }\n\n    /// @notice Get the current value of fraud stake fraction\n    /// @return The value of fraud stake fraction\n    function fraudStakeFraction()\n    public\n    view\n    returns (uint256)\n    {\n        return fraudStakeFractionByBlockNumber.currentValue();\n    }\n\n    /// @notice Set fraction of security bond that will be gained from successfully challenging\n    /// in fraud challenge\n    /// @param fromBlockNumber Block number from which the update applies\n    /// @param stakeFraction The fraction gained\n    function setFraudStakeFraction(uint256 fromBlockNumber, uint256 stakeFraction)\n    public\n    onlyOperator\n    onlyDelayedBlockNumber(fromBlockNumber)\n    {\n        fraudStakeFractionByBlockNumber.addEntry(fromBlockNumber, stakeFraction);\n        emit SetFraudStakeFractionEvent(fromBlockNumber, stakeFraction);\n    }\n\n    /// @notice Get the current value of wallet settlement stake fraction\n    /// @return The value of wallet settlement stake fraction\n    function walletSettlementStakeFraction()\n    public\n    view\n    returns (uint256)\n    {\n        return walletSettlementStakeFractionByBlockNumber.currentValue();\n    }\n\n    /// @notice Set fraction of security bond that will be gained from successfully challenging\n    /// in settlement challenge triggered by wallet\n    /// @param fromBlockNumber Block number from which the update applies\n    /// @param stakeFraction The fraction gained\n    function setWalletSettlementStakeFraction(uint256 fromBlockNumber, uint256 stakeFraction)\n    public\n    onlyOperator\n    onlyDelayedBlockNumber(fromBlockNumber)\n    {\n        walletSettlementStakeFractionByBlockNumber.addEntry(fromBlockNumber, stakeFraction);\n        emit SetWalletSettlementStakeFractionEvent(fromBlockNumber, stakeFraction);\n    }\n\n    /// @notice Get the current value of operator settlement stake fraction\n    /// @return The value of operator settlement stake fraction\n    function operatorSettlementStakeFraction()\n    public\n    view\n    returns (uint256)\n    {\n        return operatorSettlementStakeFractionByBlockNumber.currentValue();\n    }\n\n    /// @notice Set fraction of security bond that will be gained from successfully challenging\n    /// in settlement challenge triggered by operator\n    /// @param fromBlockNumber Block number from which the update applies\n    /// @param stakeFraction The fraction gained\n    function setOperatorSettlementStakeFraction(uint256 fromBlockNumber, uint256 stakeFraction)\n    public\n    onlyOperator\n    onlyDelayedBlockNumber(fromBlockNumber)\n    {\n        operatorSettlementStakeFractionByBlockNumber.addEntry(fromBlockNumber, stakeFraction);\n        emit SetOperatorSettlementStakeFractionEvent(fromBlockNumber, stakeFraction);\n    }\n\n    /// @notice Get the current value of operator settlement stake\n    /// @return The value of operator settlement stake\n    function operatorSettlementStake()\n    public\n    view\n    returns (int256 amount, address currencyCt, uint256 currencyId)\n    {\n        MonetaryTypesLib.Figure storage stake = operatorSettlementStakeByBlockNumber.currentValue();\n        amount = stake.amount;\n        currencyCt = stake.currency.ct;\n        currencyId = stake.currency.id;\n    }\n\n    /// @notice Set figure of security bond that will be gained from successfully challenging\n    /// in settlement challenge triggered by operator\n    /// @param fromBlockNumber Block number from which the update applies\n    /// @param stakeAmount The amount gained\n    /// @param stakeCurrencyCt The address of currency gained\n    /// @param stakeCurrencyId The ID of currency gained\n    function setOperatorSettlementStake(uint256 fromBlockNumber, int256 stakeAmount,\n        address stakeCurrencyCt, uint256 stakeCurrencyId)\n    public\n    onlyOperator\n    onlyDelayedBlockNumber(fromBlockNumber)\n    {\n        MonetaryTypesLib.Figure memory stake = MonetaryTypesLib.Figure(stakeAmount, MonetaryTypesLib.Currency(stakeCurrencyCt, stakeCurrencyId));\n        operatorSettlementStakeByBlockNumber.addEntry(fromBlockNumber, stake);\n        emit SetOperatorSettlementStakeEvent(fromBlockNumber, stakeAmount, stakeCurrencyCt, stakeCurrencyId);\n    }\n\n    /// @notice Set the block number of the earliest settlement initiation\n    /// @param _earliestSettlementBlockNumber The block number of the earliest settlement\n    function setEarliestSettlementBlockNumber(uint256 _earliestSettlementBlockNumber)\n    public\n    onlyOperator\n    {\n        require(!earliestSettlementBlockNumberUpdateDisabled, \"Earliest settlement block number update disabled [Configuration.sol:715]\");\n\n        earliestSettlementBlockNumber = _earliestSettlementBlockNumber;\n        emit SetEarliestSettlementBlockNumberEvent(earliestSettlementBlockNumber);\n    }\n\n    /// @notice Disable further updates to the earliest settlement block number\n    /// @dev This operation can not be undone\n    function disableEarliestSettlementBlockNumberUpdate()\n    public\n    onlyOperator\n    {\n        earliestSettlementBlockNumberUpdateDisabled = true;\n        emit DisableEarliestSettlementBlockNumberUpdateEvent();\n    }\n\n    //\n    // Modifiers\n    // -----------------------------------------------------------------------------------------------------------------\n    modifier onlyDelayedBlockNumber(uint256 blockNumber) {\n        require(\n            0 == updateDelayBlocksByBlockNumber.count() ||\n        blockNumber >= block.number + updateDelayBlocksByBlockNumber.currentValue(),\n            \"Block number not sufficiently delayed [Configuration.sol:735]\"\n        );\n        _;\n    }\n}\n\n/*\n * Hubii Nahmii\n *\n * Compliant with the Hubii Nahmii specification v0.12.\n *\n * Copyright (C) 2017-2018 Hubii AS\n */\n\n/**\n * @title Benefactor\n * @notice An ownable that has a client fund property\n */\ncontract Configurable is Ownable {\n    //\n    // Variables\n    // -----------------------------------------------------------------------------------------------------------------\n    Configuration public configuration;\n\n    //\n    // Events\n    // -----------------------------------------------------------------------------------------------------------------\n    event SetConfigurationEvent(Configuration oldConfiguration, Configuration newConfiguration);\n\n    //\n    // Functions\n    // -----------------------------------------------------------------------------------------------------------------\n    /// @notice Set the configuration contract\n    /// @param newConfiguration The (address of) Configuration contract instance\n    function setConfiguration(Configuration newConfiguration)\n    public\n    onlyDeployer\n    notNullAddress(address(newConfiguration))\n    notSameAddresses(address(newConfiguration), address(configuration))\n    {\n        // Set new configuration\n        Configuration oldConfiguration = configuration;\n        configuration = newConfiguration;\n\n        // Emit event\n        emit SetConfigurationEvent(oldConfiguration, newConfiguration);\n    }\n\n    //\n    // Modifiers\n    // -----------------------------------------------------------------------------------------------------------------\n    modifier configurationInitialized() {\n        require(address(configuration) != address(0), \"Configuration not initialized [Configurable.sol:52]\");\n        _;\n    }\n}\n\n/*\n * Hubii Nahmii\n *\n * Compliant with the Hubii Nahmii specification v0.12.\n *\n * Copyright (C) 2017-2018 Hubii AS\n */\n\n/**\n * @title ConfigurableOperational\n * @notice A configurable with modifiers for operational mode state validation\n */\ncontract ConfigurableOperational is Configurable {\n    //\n    // Modifiers\n    // -----------------------------------------------------------------------------------------------------------------\n    modifier onlyOperationalModeNormal() {\n        require(configuration.isOperationalModeNormal(), \"Operational mode is not normal [ConfigurableOperational.sol:22]\");\n        _;\n    }\n}\n\n/*\n * Hubii Nahmii\n *\n * Compliant with the Hubii Nahmii specification v0.12.\n *\n * Copyright (C) 2017-2018 Hubii AS based on Open-Zeppelin's SafeMath library\n */\n\n/**\n * @title     SafeMathUintLib\n * @dev       Math operations with safety checks that throw on error\n */\nlibrary SafeMathUintLib {\n    function mul(uint256 a, uint256 b)\n    internal\n    pure\n    returns (uint256)\n    {\n        uint256 c = a * b;\n        assert(a == 0 || c / a == b);\n        return c;\n    }\n\n    function div(uint256 a, uint256 b)\n    internal\n    pure\n    returns (uint256)\n    {\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n        return c;\n    }\n\n    function sub(uint256 a, uint256 b)\n    internal\n    pure\n    returns (uint256)\n    {\n        assert(b <= a);\n        return a - b;\n    }\n\n    function add(uint256 a, uint256 b)\n    internal\n    pure\n    returns (uint256)\n    {\n        uint256 c = a + b;\n        assert(c >= a);\n        return c;\n    }\n\n    //\n    //Clamping functions.\n    //\n    function clamp(uint256 a, uint256 min, uint256 max)\n    public\n    pure\n    returns (uint256)\n    {\n        return (a > max) ? max : ((a < min) ? min : a);\n    }\n\n    function clampMin(uint256 a, uint256 min)\n    public\n    pure\n    returns (uint256)\n    {\n        return (a < min) ? min : a;\n    }\n\n    function clampMax(uint256 a, uint256 max)\n    public\n    pure\n    returns (uint256)\n    {\n        return (a > max) ? max : a;\n    }\n}\n\n/*\n * Hubii Nahmii\n *\n * Compliant with the Hubii Nahmii specification v0.12.\n *\n * Copyright (C) 2017-2018 Hubii AS\n */\n\n/**\n * @title     NahmiiTypesLib\n * @dev       Data types of general nahmii character\n */\nlibrary NahmiiTypesLib {\n    //\n    // Enums\n    // -----------------------------------------------------------------------------------------------------------------\n    enum ChallengePhase {Dispute, Closed}\n\n    //\n    // Structures\n    // -----------------------------------------------------------------------------------------------------------------\n    struct OriginFigure {\n        uint256 originId;\n        MonetaryTypesLib.Figure figure;\n    }\n\n    struct IntendedConjugateCurrency {\n        MonetaryTypesLib.Currency intended;\n        MonetaryTypesLib.Currency conjugate;\n    }\n\n    struct SingleFigureTotalOriginFigures {\n        MonetaryTypesLib.Figure single;\n        OriginFigure[] total;\n    }\n\n    struct TotalOriginFigures {\n        OriginFigure[] total;\n    }\n\n    struct CurrentPreviousInt256 {\n        int256 current;\n        int256 previous;\n    }\n\n    struct SingleTotalInt256 {\n        int256 single;\n        int256 total;\n    }\n\n    struct IntendedConjugateCurrentPreviousInt256 {\n        CurrentPreviousInt256 intended;\n        CurrentPreviousInt256 conjugate;\n    }\n\n    struct IntendedConjugateSingleTotalInt256 {\n        SingleTotalInt256 intended;\n        SingleTotalInt256 conjugate;\n    }\n\n    struct WalletOperatorHashes {\n        bytes32 wallet;\n        bytes32 operator;\n    }\n\n    struct Signature {\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n    }\n\n    struct Seal {\n        bytes32 hash;\n        Signature signature;\n    }\n\n    struct WalletOperatorSeal {\n        Seal wallet;\n        Seal operator;\n    }\n}\n\n/*\n * Hubii Nahmii\n *\n * Compliant with the Hubii Nahmii specification v0.12.\n *\n * Copyright (C) 2017-2018 Hubii AS\n */\n\n/**\n * @title     PaymentTypesLib\n * @dev       Data types centered around payment\n */\nlibrary PaymentTypesLib {\n    //\n    // Enums\n    // -----------------------------------------------------------------------------------------------------------------\n    enum PaymentPartyRole {Sender, Recipient}\n\n    //\n    // Structures\n    // -----------------------------------------------------------------------------------------------------------------\n    struct PaymentSenderParty {\n        uint256 nonce;\n        address wallet;\n\n        NahmiiTypesLib.CurrentPreviousInt256 balances;\n\n        NahmiiTypesLib.SingleFigureTotalOriginFigures fees;\n\n        string data;\n    }\n\n    struct PaymentRecipientParty {\n        uint256 nonce;\n        address wallet;\n\n        NahmiiTypesLib.CurrentPreviousInt256 balances;\n\n        NahmiiTypesLib.TotalOriginFigures fees;\n    }\n\n    struct Operator {\n        uint256 id;\n        string data;\n    }\n\n    struct Payment {\n        int256 amount;\n        MonetaryTypesLib.Currency currency;\n\n        PaymentSenderParty sender;\n        PaymentRecipientParty recipient;\n\n        // Positive transfer is always in direction from sender to recipient\n        NahmiiTypesLib.SingleTotalInt256 transfers;\n\n        NahmiiTypesLib.WalletOperatorSeal seals;\n        uint256 blockNumber;\n\n        Operator operator;\n    }\n\n    //\n    // Functions\n    // -----------------------------------------------------------------------------------------------------------------\n    function PAYMENT_KIND()\n    public\n    pure\n    returns (string memory)\n    {\n        return \"payment\";\n    }\n}\n\n/*\n * Hubii Nahmii\n *\n * Compliant with the Hubii Nahmii specification v0.12.\n *\n * Copyright (C) 2017-2018 Hubii AS\n */\n\n/**\n * @title PaymentHasher\n * @notice Contract that hashes types related to payment\n */\ncontract PaymentHasher is Ownable {\n    //\n    // Constructor\n    // -----------------------------------------------------------------------------------------------------------------\n    constructor(address deployer) Ownable(deployer) public {\n    }\n\n    //\n    // Functions\n    // -----------------------------------------------------------------------------------------------------------------\n    function hashPaymentAsWallet(PaymentTypesLib.Payment memory payment)\n    public\n    pure\n    returns (bytes32)\n    {\n        bytes32 amountCurrencyHash = hashPaymentAmountCurrency(payment);\n        bytes32 senderHash = hashPaymentSenderPartyAsWallet(payment.sender);\n        bytes32 recipientHash = hashAddress(payment.recipient.wallet);\n\n        return keccak256(abi.encodePacked(amountCurrencyHash, senderHash, recipientHash));\n    }\n\n    function hashPaymentAsOperator(PaymentTypesLib.Payment memory payment)\n    public\n    pure\n    returns (bytes32)\n    {\n        bytes32 walletSignatureHash = hashSignature(payment.seals.wallet.signature);\n        bytes32 senderHash = hashPaymentSenderPartyAsOperator(payment.sender);\n        bytes32 recipientHash = hashPaymentRecipientPartyAsOperator(payment.recipient);\n        bytes32 transfersHash = hashSingleTotalInt256(payment.transfers);\n        bytes32 operatorHash = hashString(payment.operator.data);\n\n        return keccak256(abi.encodePacked(\n                walletSignatureHash, senderHash, recipientHash, transfersHash, operatorHash\n            ));\n    }\n\n    function hashPaymentAmountCurrency(PaymentTypesLib.Payment memory payment)\n    public\n    pure\n    returns (bytes32)\n    {\n        return keccak256(abi.encodePacked(\n                payment.amount,\n                payment.currency.ct,\n                payment.currency.id\n            ));\n    }\n\n    function hashPaymentSenderPartyAsWallet(\n        PaymentTypesLib.PaymentSenderParty memory paymentSenderParty)\n    public\n    pure\n    returns (bytes32)\n    {\n        return keccak256(abi.encodePacked(\n                paymentSenderParty.wallet,\n                paymentSenderParty.data\n            ));\n    }\n\n    function hashPaymentSenderPartyAsOperator(\n        PaymentTypesLib.PaymentSenderParty memory paymentSenderParty)\n    public\n    pure\n    returns (bytes32)\n    {\n        bytes32 rootHash = hashUint256(paymentSenderParty.nonce);\n        bytes32 balancesHash = hashCurrentPreviousInt256(paymentSenderParty.balances);\n        bytes32 singleFeeHash = hashFigure(paymentSenderParty.fees.single);\n        bytes32 totalFeesHash = hashOriginFigures(paymentSenderParty.fees.total);\n\n        return keccak256(abi.encodePacked(\n                rootHash, balancesHash, singleFeeHash, totalFeesHash\n            ));\n    }\n\n    function hashPaymentRecipientPartyAsOperator(\n        PaymentTypesLib.PaymentRecipientParty memory paymentRecipientParty)\n    public\n    pure\n    returns (bytes32)\n    {\n        bytes32 rootHash = hashUint256(paymentRecipientParty.nonce);\n        bytes32 balancesHash = hashCurrentPreviousInt256(paymentRecipientParty.balances);\n        bytes32 totalFeesHash = hashOriginFigures(paymentRecipientParty.fees.total);\n\n        return keccak256(abi.encodePacked(\n                rootHash, balancesHash, totalFeesHash\n            ));\n    }\n\n    function hashCurrentPreviousInt256(\n        NahmiiTypesLib.CurrentPreviousInt256 memory currentPreviousInt256)\n    public\n    pure\n    returns (bytes32)\n    {\n        return keccak256(abi.encodePacked(\n                currentPreviousInt256.current,\n                currentPreviousInt256.previous\n            ));\n    }\n\n    function hashSingleTotalInt256(\n        NahmiiTypesLib.SingleTotalInt256 memory singleTotalInt256)\n    public\n    pure\n    returns (bytes32)\n    {\n        return keccak256(abi.encodePacked(\n                singleTotalInt256.single,\n                singleTotalInt256.total\n            ));\n    }\n\n    function hashFigure(MonetaryTypesLib.Figure memory figure)\n    public\n    pure\n    returns (bytes32)\n    {\n        return keccak256(abi.encodePacked(\n                figure.amount,\n                figure.currency.ct,\n                figure.currency.id\n            ));\n    }\n\n    function hashOriginFigures(NahmiiTypesLib.OriginFigure[] memory originFigures)\n    public\n    pure\n    returns (bytes32)\n    {\n        bytes32 hash;\n        for (uint256 i = 0; i < originFigures.length; i++) {\n            hash = keccak256(abi.encodePacked(\n                    hash,\n                    originFigures[i].originId,\n                    originFigures[i].figure.amount,\n                    originFigures[i].figure.currency.ct,\n                    originFigures[i].figure.currency.id\n                )\n            );\n        }\n        return hash;\n    }\n\n    function hashUint256(uint256 _uint256)\n    public\n    pure\n    returns (bytes32)\n    {\n        return keccak256(abi.encodePacked(_uint256));\n    }\n\n    function hashString(string memory _string)\n    public\n    pure\n    returns (bytes32)\n    {\n        return keccak256(abi.encodePacked(_string));\n    }\n\n    function hashAddress(address _address)\n    public\n    pure\n    returns (bytes32)\n    {\n        return keccak256(abi.encodePacked(_address));\n    }\n\n    function hashSignature(NahmiiTypesLib.Signature memory signature)\n    public\n    pure\n    returns (bytes32)\n    {\n        return keccak256(abi.encodePacked(\n                signature.v,\n                signature.r,\n                signature.s\n            ));\n    }\n}\n\n/*\n * Hubii Nahmii\n *\n * Compliant with the Hubii Nahmii specification v0.12.\n *\n * Copyright (C) 2017-2018 Hubii AS\n */\n\n/**\n * @title PaymentHashable\n * @notice An ownable that has a payment hasher property\n */\ncontract PaymentHashable is Ownable {\n    //\n    // Variables\n    // -----------------------------------------------------------------------------------------------------------------\n    PaymentHasher public paymentHasher;\n\n    //\n    // Events\n    // -----------------------------------------------------------------------------------------------------------------\n    event SetPaymentHasherEvent(PaymentHasher oldPaymentHasher, PaymentHasher newPaymentHasher);\n\n    //\n    // Functions\n    // -----------------------------------------------------------------------------------------------------------------\n    /// @notice Set the payment hasher contract\n    /// @param newPaymentHasher The (address of) PaymentHasher contract instance\n    function setPaymentHasher(PaymentHasher newPaymentHasher)\n    public\n    onlyDeployer\n    notNullAddress(address(newPaymentHasher))\n    notSameAddresses(address(newPaymentHasher), address(paymentHasher))\n    {\n        // Set new payment hasher\n        PaymentHasher oldPaymentHasher = paymentHasher;\n        paymentHasher = newPaymentHasher;\n\n        // Emit event\n        emit SetPaymentHasherEvent(oldPaymentHasher, newPaymentHasher);\n    }\n\n    //\n    // Modifiers\n    // -----------------------------------------------------------------------------------------------------------------\n    modifier paymentHasherInitialized() {\n        require(address(paymentHasher) != address(0), \"Payment hasher not initialized [PaymentHashable.sol:52]\");\n        _;\n    }\n}\n\n/*\n * Hubii Nahmii\n *\n * Compliant with the Hubii Nahmii specification v0.12.\n *\n * Copyright (C) 2017-2018 Hubii AS\n */\n\n/**\n * @title SignerManager\n * @notice A contract to control who can execute some specific actions\n */\ncontract SignerManager is Ownable {\n    using SafeMathUintLib for uint256;\n\n    //\n    // Variables\n    // -----------------------------------------------------------------------------------------------------------------\n    mapping(address => uint256) public signerIndicesMap; // 1 based internally\n    address[] public signers;\n\n    //\n    // Events\n    // -----------------------------------------------------------------------------------------------------------------\n    event RegisterSignerEvent(address signer);\n\n    //\n    // Constructor\n    // -----------------------------------------------------------------------------------------------------------------\n    constructor(address deployer) Ownable(deployer) public {\n        registerSigner(deployer);\n    }\n\n    //\n    // Functions\n    // -----------------------------------------------------------------------------------------------------------------\n    /// @notice Gauge whether an address is registered signer\n    /// @param _address The concerned address\n    /// @return true if address is registered signer, else false\n    function isSigner(address _address)\n    public\n    view\n    returns (bool)\n    {\n        return 0 < signerIndicesMap[_address];\n    }\n\n    /// @notice Get the count of registered signers\n    /// @return The count of registered signers\n    function signersCount()\n    public\n    view\n    returns (uint256)\n    {\n        return signers.length;\n    }\n\n    /// @notice Get the 0 based index of the given address in the list of signers\n    /// @param _address The concerned address\n    /// @return The index of the signer address\n    function signerIndex(address _address)\n    public\n    view\n    returns (uint256)\n    {\n        require(isSigner(_address), \"Address not signer [SignerManager.sol:71]\");\n        return signerIndicesMap[_address] - 1;\n    }\n\n    /// @notice Registers a signer\n    /// @param newSigner The address of the signer to register\n    function registerSigner(address newSigner)\n    public\n    onlyOperator\n    notNullOrThisAddress(newSigner)\n    {\n        if (0 == signerIndicesMap[newSigner]) {\n            // Set new operator\n            signers.push(newSigner);\n            signerIndicesMap[newSigner] = signers.length;\n\n            // Emit event\n            emit RegisterSignerEvent(newSigner);\n        }\n    }\n\n    /// @notice Get the subset of registered signers in the given 0 based index range\n    /// @param low The lower inclusive index\n    /// @param up The upper inclusive index\n    /// @return The subset of registered signers\n    function signersByIndices(uint256 low, uint256 up)\n    public\n    view\n    returns (address[] memory)\n    {\n        require(0 < signers.length, \"No signers found [SignerManager.sol:101]\");\n        require(low <= up, \"Bounds parameters mismatch [SignerManager.sol:102]\");\n\n        up = up.clampMax(signers.length - 1);\n        address[] memory _signers = new address[](up - low + 1);\n        for (uint256 i = low; i <= up; i++)\n            _signers[i - low] = signers[i];\n\n        return _signers;\n    }\n}\n\n/*\n * Hubii Nahmii\n *\n * Compliant with the Hubii Nahmii specification v0.12.\n *\n * Copyright (C) 2017-2018 Hubii AS\n */\n\n/**\n * @title SignerManageable\n * @notice A contract to interface ACL\n */\ncontract SignerManageable is Ownable {\n    //\n    // Variables\n    // -----------------------------------------------------------------------------------------------------------------\n    SignerManager public signerManager;\n\n    //\n    // Events\n    // -----------------------------------------------------------------------------------------------------------------\n    event SetSignerManagerEvent(address oldSignerManager, address newSignerManager);\n\n    //\n    // Constructor\n    // -----------------------------------------------------------------------------------------------------------------\n    constructor(address manager) public notNullAddress(manager) {\n        signerManager = SignerManager(manager);\n    }\n\n    //\n    // Functions\n    // -----------------------------------------------------------------------------------------------------------------\n    /// @notice Set the signer manager of this contract\n    /// @param newSignerManager The address of the new signer\n    function setSignerManager(address newSignerManager)\n    public\n    onlyDeployer\n    notNullOrThisAddress(newSignerManager)\n    {\n        if (newSignerManager != address(signerManager)) {\n            //set new signer\n            address oldSignerManager = address(signerManager);\n            signerManager = SignerManager(newSignerManager);\n\n            // Emit event\n            emit SetSignerManagerEvent(oldSignerManager, newSignerManager);\n        }\n    }\n\n    /// @notice Prefix input hash and do ecrecover on prefixed hash\n    /// @param hash The hash message that was signed\n    /// @param v The v property of the ECDSA signature\n    /// @param r The r property of the ECDSA signature\n    /// @param s The s property of the ECDSA signature\n    /// @return The address recovered\n    function ethrecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s)\n    public\n    pure\n    returns (address)\n    {\n        bytes memory prefix = \"\\x19Ethereum Signed Message:\\n32\";\n        bytes32 prefixedHash = keccak256(abi.encodePacked(prefix, hash));\n        return ecrecover(prefixedHash, v, r, s);\n    }\n\n    /// @notice Gauge whether a signature of a hash has been signed by a registered signer\n    /// @param hash The hash message that was signed\n    /// @param v The v property of the ECDSA signature\n    /// @param r The r property of the ECDSA signature\n    /// @param s The s property of the ECDSA signature\n    /// @return true if the recovered signer is one of the registered signers, else false\n    function isSignedByRegisteredSigner(bytes32 hash, uint8 v, bytes32 r, bytes32 s)\n    public\n    view\n    returns (bool)\n    {\n        return signerManager.isSigner(ethrecover(hash, v, r, s));\n    }\n\n    /// @notice Gauge whether a signature of a hash has been signed by the claimed signer\n    /// @param hash The hash message that was signed\n    /// @param v The v property of the ECDSA signature\n    /// @param r The r property of the ECDSA signature\n    /// @param s The s property of the ECDSA signature\n    /// @param signer The claimed signer\n    /// @return true if the recovered signer equals the input signer, else false\n    function isSignedBy(bytes32 hash, uint8 v, bytes32 r, bytes32 s, address signer)\n    public\n    pure\n    returns (bool)\n    {\n        return signer == ethrecover(hash, v, r, s);\n    }\n\n    // Modifiers\n    // -----------------------------------------------------------------------------------------------------------------\n    modifier signerManagerInitialized() {\n        require(address(signerManager) != address(0), \"Signer manager not initialized [SignerManageable.sol:105]\");\n        _;\n    }\n}\n\n/*\n * Hubii Nahmii\n *\n * Compliant with the Hubii Nahmii specification v0.12.\n *\n * Copyright (C) 2017-2018 Hubii AS\n */\n\n/**\n * @title Validator\n * @notice An ownable that validates valuable types (e.g. payment)\n */\ncontract Validator is Ownable, SignerManageable, Configurable, PaymentHashable {\n    using SafeMathIntLib for int256;\n    using SafeMathUintLib for uint256;\n\n    //\n    // Constructor\n    // -----------------------------------------------------------------------------------------------------------------\n    constructor(address deployer, address signerManager) Ownable(deployer) SignerManageable(signerManager) public {\n    }\n\n    //\n    // Functions\n    // -----------------------------------------------------------------------------------------------------------------\n    function isGenuineOperatorSignature(bytes32 hash, NahmiiTypesLib.Signature memory signature)\n    public\n    view\n    returns (bool)\n    {\n        return isSignedByRegisteredSigner(hash, signature.v, signature.r, signature.s);\n    }\n\n    function isGenuineWalletSignature(bytes32 hash, NahmiiTypesLib.Signature memory signature, address wallet)\n    public\n    pure\n    returns (bool)\n    {\n        return isSignedBy(hash, signature.v, signature.r, signature.s, wallet);\n    }\n\n    function isGenuinePaymentWalletHash(PaymentTypesLib.Payment memory payment)\n    public\n    view\n    returns (bool)\n    {\n        return paymentHasher.hashPaymentAsWallet(payment) == payment.seals.wallet.hash;\n    }\n\n    function isGenuinePaymentOperatorHash(PaymentTypesLib.Payment memory payment)\n    public\n    view\n    returns (bool)\n    {\n        return paymentHasher.hashPaymentAsOperator(payment) == payment.seals.operator.hash;\n    }\n\n    function isGenuinePaymentWalletSeal(PaymentTypesLib.Payment memory payment)\n    public\n    view\n    returns (bool)\n    {\n        return isGenuinePaymentWalletHash(payment)\n        && isGenuineWalletSignature(payment.seals.wallet.hash, payment.seals.wallet.signature, payment.sender.wallet);\n    }\n\n    function isGenuinePaymentOperatorSeal(PaymentTypesLib.Payment memory payment)\n    public\n    view\n    returns (bool)\n    {\n        return isGenuinePaymentOperatorHash(payment)\n        && isGenuineOperatorSignature(payment.seals.operator.hash, payment.seals.operator.signature);\n    }\n\n    function isGenuinePaymentSeals(PaymentTypesLib.Payment memory payment)\n    public\n    view\n    returns (bool)\n    {\n        return isGenuinePaymentWalletSeal(payment) && isGenuinePaymentOperatorSeal(payment);\n    }\n\n    /// @dev Logics of this function only applies to FT\n    function isGenuinePaymentFeeOfFungible(PaymentTypesLib.Payment memory payment)\n    public\n    view\n    returns (bool)\n    {\n        int256 feePartsPer = int256(ConstantsLib.PARTS_PER());\n\n        int256 feeAmount = payment.amount\n        .mul(\n            configuration.currencyPaymentFee(\n                payment.blockNumber, payment.currency.ct, payment.currency.id, payment.amount\n            )\n        ).div(feePartsPer);\n\n        if (1 > feeAmount)\n            feeAmount = 1;\n\n        return (payment.sender.fees.single.amount == feeAmount);\n    }\n\n    /// @dev Logics of this function only applies to NFT\n    function isGenuinePaymentFeeOfNonFungible(PaymentTypesLib.Payment memory payment)\n    public\n    view\n    returns (bool)\n    {\n        (address feeCurrencyCt, uint256 feeCurrencyId) = configuration.feeCurrency(\n            payment.blockNumber, payment.currency.ct, payment.currency.id\n        );\n\n        return feeCurrencyCt == payment.sender.fees.single.currency.ct\n        && feeCurrencyId == payment.sender.fees.single.currency.id;\n    }\n\n    /// @dev Logics of this function only applies to FT\n    function isGenuinePaymentSenderOfFungible(PaymentTypesLib.Payment memory payment)\n    public\n    view\n    returns (bool)\n    {\n        return (payment.sender.wallet != payment.recipient.wallet)\n        && (!signerManager.isSigner(payment.sender.wallet))\n        && (payment.sender.balances.current == payment.sender.balances.previous.sub(payment.transfers.single).sub(payment.sender.fees.single.amount));\n    }\n\n    /// @dev Logics of this function only applies to FT\n    function isGenuinePaymentRecipientOfFungible(PaymentTypesLib.Payment memory payment)\n    public\n    pure\n    returns (bool)\n    {\n        return (payment.sender.wallet != payment.recipient.wallet)\n        && (payment.recipient.balances.current == payment.recipient.balances.previous.add(payment.transfers.single));\n    }\n\n    /// @dev Logics of this function only applies to NFT\n    function isGenuinePaymentSenderOfNonFungible(PaymentTypesLib.Payment memory payment)\n    public\n    view\n    returns (bool)\n    {\n        return (payment.sender.wallet != payment.recipient.wallet)\n        && (!signerManager.isSigner(payment.sender.wallet));\n    }\n\n    /// @dev Logics of this function only applies to NFT\n    function isGenuinePaymentRecipientOfNonFungible(PaymentTypesLib.Payment memory payment)\n    public\n    pure\n    returns (bool)\n    {\n        return (payment.sender.wallet != payment.recipient.wallet);\n    }\n\n    function isSuccessivePaymentsPartyNonces(\n        PaymentTypesLib.Payment memory firstPayment,\n        PaymentTypesLib.PaymentPartyRole firstPaymentPartyRole,\n        PaymentTypesLib.Payment memory lastPayment,\n        PaymentTypesLib.PaymentPartyRole lastPaymentPartyRole\n    )\n    public\n    pure\n    returns (bool)\n    {\n        uint256 firstNonce = (PaymentTypesLib.PaymentPartyRole.Sender == firstPaymentPartyRole ? firstPayment.sender.nonce : firstPayment.recipient.nonce);\n        uint256 lastNonce = (PaymentTypesLib.PaymentPartyRole.Sender == lastPaymentPartyRole ? lastPayment.sender.nonce : lastPayment.recipient.nonce);\n        return lastNonce == firstNonce.add(1);\n    }\n\n    function isGenuineSuccessivePaymentsBalances(\n        PaymentTypesLib.Payment memory firstPayment,\n        PaymentTypesLib.PaymentPartyRole firstPaymentPartyRole,\n        PaymentTypesLib.Payment memory lastPayment,\n        PaymentTypesLib.PaymentPartyRole lastPaymentPartyRole,\n        int256 delta\n    )\n    public\n    pure\n    returns (bool)\n    {\n        NahmiiTypesLib.CurrentPreviousInt256 memory firstCurrentPreviousBalances = (PaymentTypesLib.PaymentPartyRole.Sender == firstPaymentPartyRole ? firstPayment.sender.balances : firstPayment.recipient.balances);\n        NahmiiTypesLib.CurrentPreviousInt256 memory lastCurrentPreviousBalances = (PaymentTypesLib.PaymentPartyRole.Sender == lastPaymentPartyRole ? lastPayment.sender.balances : lastPayment.recipient.balances);\n\n        return lastCurrentPreviousBalances.previous == firstCurrentPreviousBalances.current.add(delta);\n    }\n\n    function isGenuineSuccessivePaymentsTotalFees(\n        PaymentTypesLib.Payment memory firstPayment,\n        PaymentTypesLib.Payment memory lastPayment\n    )\n    public\n    pure\n    returns (bool)\n    {\n        MonetaryTypesLib.Figure memory firstTotalFee = getProtocolFigureByCurrency(firstPayment.sender.fees.total, lastPayment.sender.fees.single.currency);\n        MonetaryTypesLib.Figure memory lastTotalFee = getProtocolFigureByCurrency(lastPayment.sender.fees.total, lastPayment.sender.fees.single.currency);\n        return lastTotalFee.amount == firstTotalFee.amount.add(lastPayment.sender.fees.single.amount);\n    }\n\n    function isPaymentParty(PaymentTypesLib.Payment memory payment, address wallet)\n    public\n    pure\n    returns (bool)\n    {\n        return wallet == payment.sender.wallet || wallet == payment.recipient.wallet;\n    }\n\n    function isPaymentSender(PaymentTypesLib.Payment memory payment, address wallet)\n    public\n    pure\n    returns (bool)\n    {\n        return wallet == payment.sender.wallet;\n    }\n\n    function isPaymentRecipient(PaymentTypesLib.Payment memory payment, address wallet)\n    public\n    pure\n    returns (bool)\n    {\n        return wallet == payment.recipient.wallet;\n    }\n\n    function isPaymentCurrency(PaymentTypesLib.Payment memory payment, MonetaryTypesLib.Currency memory currency)\n    public\n    pure\n    returns (bool)\n    {\n        return currency.ct == payment.currency.ct && currency.id == payment.currency.id;\n    }\n\n    function isPaymentCurrencyNonFungible(PaymentTypesLib.Payment memory payment)\n    public\n    pure\n    returns (bool)\n    {\n        return payment.currency.ct != payment.sender.fees.single.currency.ct\n        || payment.currency.id != payment.sender.fees.single.currency.id;\n    }\n\n    //\n    // Private unctions\n    // -----------------------------------------------------------------------------------------------------------------\n    function getProtocolFigureByCurrency(NahmiiTypesLib.OriginFigure[] memory originFigures, MonetaryTypesLib.Currency memory currency)\n    private\n    pure\n    returns (MonetaryTypesLib.Figure memory) {\n        for (uint256 i = 0; i < originFigures.length; i++)\n            if (originFigures[i].figure.currency.ct == currency.ct && originFigures[i].figure.currency.id == currency.id\n            && originFigures[i].originId == 0)\n                return originFigures[i].figure;\n        return MonetaryTypesLib.Figure(0, currency);\n    }\n}\n\n/*\n * Hubii Nahmii\n *\n * Compliant with the Hubii Nahmii specification v0.12.\n *\n * Copyright (C) 2017-2018 Hubii AS\n */\n\n/**\n * @title     TradeTypesLib\n * @dev       Data types centered around trade\n */\nlibrary TradeTypesLib {\n    //\n    // Enums\n    // -----------------------------------------------------------------------------------------------------------------\n    enum CurrencyRole {Intended, Conjugate}\n    enum LiquidityRole {Maker, Taker}\n    enum Intention {Buy, Sell}\n    enum TradePartyRole {Buyer, Seller}\n\n    //\n    // Structures\n    // -----------------------------------------------------------------------------------------------------------------\n    struct OrderPlacement {\n        Intention intention;\n\n        int256 amount;\n        NahmiiTypesLib.IntendedConjugateCurrency currencies;\n        int256 rate;\n\n        NahmiiTypesLib.CurrentPreviousInt256 residuals;\n    }\n\n    struct Order {\n        uint256 nonce;\n        address wallet;\n\n        OrderPlacement placement;\n\n        NahmiiTypesLib.WalletOperatorSeal seals;\n        uint256 blockNumber;\n        uint256 operatorId;\n    }\n\n    struct TradeOrder {\n        int256 amount;\n        NahmiiTypesLib.WalletOperatorHashes hashes;\n        NahmiiTypesLib.CurrentPreviousInt256 residuals;\n    }\n\n    struct TradeParty {\n        uint256 nonce;\n        address wallet;\n\n        uint256 rollingVolume;\n\n        LiquidityRole liquidityRole;\n\n        TradeOrder order;\n\n        NahmiiTypesLib.IntendedConjugateCurrentPreviousInt256 balances;\n\n        NahmiiTypesLib.SingleFigureTotalOriginFigures fees;\n    }\n\n    struct Trade {\n        uint256 nonce;\n\n        int256 amount;\n        NahmiiTypesLib.IntendedConjugateCurrency currencies;\n        int256 rate;\n\n        TradeParty buyer;\n        TradeParty seller;\n\n        // Positive intended transfer is always in direction from seller to buyer\n        // Positive conjugate transfer is always in direction from buyer to seller\n        NahmiiTypesLib.IntendedConjugateSingleTotalInt256 transfers;\n\n        NahmiiTypesLib.Seal seal;\n        uint256 blockNumber;\n        uint256 operatorId;\n    }\n\n    //\n    // Functions\n    // -----------------------------------------------------------------------------------------------------------------\n    function TRADE_KIND()\n    public\n    pure\n    returns (string memory)\n    {\n        return \"trade\";\n    }\n\n    function ORDER_KIND()\n    public\n    pure\n    returns (string memory)\n    {\n        return \"order\";\n    }\n}\n\n/*\n * Hubii Nahmii\n *\n * Compliant with the Hubii Nahmii specification v0.12.\n *\n * Copyright (C) 2017-2018 Hubii AS\n */\n\n/**\n * @title Validatable\n * @notice An ownable that has a validator property\n */\ncontract Validatable is Ownable {\n    //\n    // Variables\n    // -----------------------------------------------------------------------------------------------------------------\n    Validator public validator;\n\n    //\n    // Events\n    // -----------------------------------------------------------------------------------------------------------------\n    event SetValidatorEvent(Validator oldValidator, Validator newValidator);\n\n    //\n    // Functions\n    // -----------------------------------------------------------------------------------------------------------------\n    /// @notice Set the validator contract\n    /// @param newValidator The (address of) Validator contract instance\n    function setValidator(Validator newValidator)\n    public\n    onlyDeployer\n    notNullAddress(address(newValidator))\n    notSameAddresses(address(newValidator), address(validator))\n    {\n        //set new validator\n        Validator oldValidator = validator;\n        validator = newValidator;\n\n        // Emit event\n        emit SetValidatorEvent(oldValidator, newValidator);\n    }\n\n    //\n    // Modifiers\n    // -----------------------------------------------------------------------------------------------------------------\n    modifier validatorInitialized() {\n        require(address(validator) != address(0), \"Validator not initialized [Validatable.sol:55]\");\n        _;\n    }\n\n    modifier onlyOperatorSealedPayment(PaymentTypesLib.Payment memory payment) {\n        require(validator.isGenuinePaymentOperatorSeal(payment), \"Payment operator seal not genuine [Validatable.sol:60]\");\n        _;\n    }\n\n    modifier onlySealedPayment(PaymentTypesLib.Payment memory payment) {\n        require(validator.isGenuinePaymentSeals(payment), \"Payment seals not genuine [Validatable.sol:65]\");\n        _;\n    }\n\n    modifier onlyPaymentParty(PaymentTypesLib.Payment memory payment, address wallet) {\n        require(validator.isPaymentParty(payment, wallet), \"Wallet not payment party [Validatable.sol:70]\");\n        _;\n    }\n\n    modifier onlyPaymentSender(PaymentTypesLib.Payment memory payment, address wallet) {\n        require(validator.isPaymentSender(payment, wallet), \"Wallet not payment sender [Validatable.sol:75]\");\n        _;\n    }\n}\n\n/*\n * Hubii Nahmii\n *\n * Compliant with the Hubii Nahmii specification v0.12.\n *\n * Copyright (C) 2017-2018 Hubii AS\n */\n\n/**\n * @title AuthorizableServable\n * @notice A servable that may be authorized and unauthorized\n */\ncontract AuthorizableServable is Servable {\n    //\n    // Variables\n    // -----------------------------------------------------------------------------------------------------------------\n    bool public initialServiceAuthorizationDisabled;\n\n    mapping(address => bool) public initialServiceAuthorizedMap;\n    mapping(address => mapping(address => bool)) public initialServiceWalletUnauthorizedMap;\n\n    mapping(address => mapping(address => bool)) public serviceWalletAuthorizedMap;\n\n    mapping(address => mapping(bytes32 => mapping(address => bool))) public serviceActionWalletAuthorizedMap;\n    mapping(address => mapping(bytes32 => mapping(address => bool))) public serviceActionWalletTouchedMap;\n    mapping(address => mapping(address => bytes32[])) public serviceWalletActionList;\n\n    //\n    // Events\n    // -----------------------------------------------------------------------------------------------------------------\n    event AuthorizeInitialServiceEvent(address wallet, address service);\n    event AuthorizeRegisteredServiceEvent(address wallet, address service);\n    event AuthorizeRegisteredServiceActionEvent(address wallet, address service, string action);\n    event UnauthorizeRegisteredServiceEvent(address wallet, address service);\n    event UnauthorizeRegisteredServiceActionEvent(address wallet, address service, string action);\n\n    //\n    // Functions\n    // -----------------------------------------------------------------------------------------------------------------\n    /// @notice Add service to initial whitelist of services\n    /// @dev The service must be registered already\n    /// @param service The address of the concerned registered service\n    function authorizeInitialService(address service)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        require(!initialServiceAuthorizationDisabled);\n        require(msg.sender != service);\n\n        // Ensure service is registered\n        require(registeredServicesMap[service].registered);\n\n        // Enable all actions for given wallet\n        initialServiceAuthorizedMap[service] = true;\n\n        // Emit event\n        emit AuthorizeInitialServiceEvent(msg.sender, service);\n    }\n\n    /// @notice Disable further initial authorization of services\n    /// @dev This operation can not be undone\n    function disableInitialServiceAuthorization()\n    public\n    onlyDeployer\n    {\n        initialServiceAuthorizationDisabled = true;\n    }\n\n    /// @notice Authorize the given registered service by enabling all of actions\n    /// @dev The service must be registered already\n    /// @param service The address of the concerned registered service\n    function authorizeRegisteredService(address service)\n    public\n    notNullOrThisAddress(service)\n    {\n        require(msg.sender != service);\n\n        // Ensure service is registered\n        require(registeredServicesMap[service].registered);\n\n        // Ensure service is not initial. Initial services are not authorized per action.\n        require(!initialServiceAuthorizedMap[service]);\n\n        // Enable all actions for given wallet\n        serviceWalletAuthorizedMap[service][msg.sender] = true;\n\n        // Emit event\n        emit AuthorizeRegisteredServiceEvent(msg.sender, service);\n    }\n\n    /// @notice Unauthorize the given registered service by enabling all of actions\n    /// @dev The service must be registered already\n    /// @param service The address of the concerned registered service\n    function unauthorizeRegisteredService(address service)\n    public\n    notNullOrThisAddress(service)\n    {\n        require(msg.sender != service);\n\n        // Ensure service is registered\n        require(registeredServicesMap[service].registered);\n\n        // If initial service then disable it\n        if (initialServiceAuthorizedMap[service])\n            initialServiceWalletUnauthorizedMap[service][msg.sender] = true;\n\n        // Else disable all actions for given wallet\n        else {\n            serviceWalletAuthorizedMap[service][msg.sender] = false;\n            for (uint256 i = 0; i < serviceWalletActionList[service][msg.sender].length; i++)\n                serviceActionWalletAuthorizedMap[service][serviceWalletActionList[service][msg.sender][i]][msg.sender] = true;\n        }\n\n        // Emit event\n        emit UnauthorizeRegisteredServiceEvent(msg.sender, service);\n    }\n\n    /// @notice Gauge whether the given service is authorized for the given wallet\n    /// @param service The address of the concerned registered service\n    /// @param wallet The address of the concerned wallet\n    /// @return true if service is authorized for the given wallet, else false\n    function isAuthorizedRegisteredService(address service, address wallet)\n    public\n    view\n    returns (bool)\n    {\n        return isRegisteredActiveService(service) &&\n        (isInitialServiceAuthorizedForWallet(service, wallet) || serviceWalletAuthorizedMap[service][wallet]);\n    }\n\n    /// @notice Authorize the given registered service action\n    /// @dev The service must be registered already\n    /// @param service The address of the concerned registered service\n    /// @param action The concerned service action\n    function authorizeRegisteredServiceAction(address service, string memory action)\n    public\n    notNullOrThisAddress(service)\n    {\n        require(msg.sender != service);\n\n        bytes32 actionHash = hashString(action);\n\n        // Ensure service action is registered\n        require(registeredServicesMap[service].registered && registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        // Ensure service is not initial\n        require(!initialServiceAuthorizedMap[service]);\n\n        // Enable service action for given wallet\n        serviceWalletAuthorizedMap[service][msg.sender] = false;\n        serviceActionWalletAuthorizedMap[service][actionHash][msg.sender] = true;\n        if (!serviceActionWalletTouchedMap[service][actionHash][msg.sender]) {\n            serviceActionWalletTouchedMap[service][actionHash][msg.sender] = true;\n            serviceWalletActionList[service][msg.sender].push(actionHash);\n        }\n\n        // Emit event\n        emit AuthorizeRegisteredServiceActionEvent(msg.sender, service, action);\n    }\n\n    /// @notice Unauthorize the given registered service action\n    /// @dev The service must be registered already\n    /// @param service The address of the concerned registered service\n    /// @param action The concerned service action\n    function unauthorizeRegisteredServiceAction(address service, string memory action)\n    public\n    notNullOrThisAddress(service)\n    {\n        require(msg.sender != service);\n\n        bytes32 actionHash = hashString(action);\n\n        // Ensure service is registered and action enabled\n        require(registeredServicesMap[service].registered && registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        // Ensure service is not initial as it can not be unauthorized per action\n        require(!initialServiceAuthorizedMap[service]);\n\n        // Disable service action for given wallet\n        serviceActionWalletAuthorizedMap[service][actionHash][msg.sender] = false;\n\n        // Emit event\n        emit UnauthorizeRegisteredServiceActionEvent(msg.sender, service, action);\n    }\n\n    /// @notice Gauge whether the given service action is authorized for the given wallet\n    /// @param service The address of the concerned registered service\n    /// @param action The concerned service action\n    /// @param wallet The address of the concerned wallet\n    /// @return true if service action is authorized for the given wallet, else false\n    function isAuthorizedRegisteredServiceAction(address service, string memory action, address wallet)\n    public\n    view\n    returns (bool)\n    {\n        bytes32 actionHash = hashString(action);\n\n        return isEnabledServiceAction(service, action) &&\n        (\n        isInitialServiceAuthorizedForWallet(service, wallet) ||\n        serviceWalletAuthorizedMap[service][wallet] ||\n        serviceActionWalletAuthorizedMap[service][actionHash][wallet]\n        );\n    }\n\n    function isInitialServiceAuthorizedForWallet(address service, address wallet)\n    private\n    view\n    returns (bool)\n    {\n        return initialServiceAuthorizedMap[service] ? !initialServiceWalletUnauthorizedMap[service][wallet] : false;\n    }\n\n    //\n    // Modifiers\n    // -----------------------------------------------------------------------------------------------------------------\n    modifier onlyAuthorizedService(address wallet) {\n        require(isAuthorizedRegisteredService(msg.sender, wallet));\n        _;\n    }\n\n    modifier onlyAuthorizedServiceAction(string memory action, address wallet) {\n        require(isAuthorizedRegisteredServiceAction(msg.sender, action, wallet));\n        _;\n    }\n}\n\n/*\n * Hubii Nahmii\n *\n * Compliant with the Hubii Nahmii specification v0.12.\n *\n * Copyright (C) 2017-2018 Hubii AS\n */\n\n/**\n * @title Wallet locker\n * @notice An ownable to lock and unlock wallets' balance holdings of specific currency(ies)\n */\ncontract WalletLocker is Ownable, Configurable, AuthorizableServable {\n    using SafeMathUintLib for uint256;\n\n    //\n    // Structures\n    // -----------------------------------------------------------------------------------------------------------------\n    struct FungibleLock {\n        address locker;\n        address currencyCt;\n        uint256 currencyId;\n        int256 amount;\n        uint256 visibleTime;\n        uint256 unlockTime;\n    }\n\n    struct NonFungibleLock {\n        address locker;\n        address currencyCt;\n        uint256 currencyId;\n        int256[] ids;\n        uint256 visibleTime;\n        uint256 unlockTime;\n    }\n\n    //\n    // Variables\n    // -----------------------------------------------------------------------------------------------------------------\n    mapping(address => FungibleLock[]) public walletFungibleLocks;\n    mapping(address => mapping(address => mapping(uint256 => mapping(address => uint256)))) public lockedCurrencyLockerFungibleLockIndex;\n    mapping(address => mapping(address => mapping(uint256 => uint256))) public walletCurrencyFungibleLockCount;\n\n    mapping(address => NonFungibleLock[]) public walletNonFungibleLocks;\n    mapping(address => mapping(address => mapping(uint256 => mapping(address => uint256)))) public lockedCurrencyLockerNonFungibleLockIndex;\n    mapping(address => mapping(address => mapping(uint256 => uint256))) public walletCurrencyNonFungibleLockCount;\n\n    //\n    // Events\n    // -----------------------------------------------------------------------------------------------------------------\n    event LockFungibleByProxyEvent(address lockedWallet, address lockerWallet, int256 amount,\n        address currencyCt, uint256 currencyId, uint256 visibleTimeoutInSeconds);\n    event LockNonFungibleByProxyEvent(address lockedWallet, address lockerWallet, int256[] ids,\n        address currencyCt, uint256 currencyId, uint256 visibleTimeoutInSeconds);\n    event UnlockFungibleEvent(address lockedWallet, address lockerWallet, int256 amount, address currencyCt,\n        uint256 currencyId);\n    event UnlockFungibleByProxyEvent(address lockedWallet, address lockerWallet, int256 amount, address currencyCt,\n        uint256 currencyId);\n    event UnlockNonFungibleEvent(address lockedWallet, address lockerWallet, int256[] ids, address currencyCt,\n        uint256 currencyId);\n    event UnlockNonFungibleByProxyEvent(address lockedWallet, address lockerWallet, int256[] ids, address currencyCt,\n        uint256 currencyId);\n\n    //\n    // Constructor\n    // -----------------------------------------------------------------------------------------------------------------\n    constructor(address deployer) Ownable(deployer)\n    public\n    {\n    }\n\n    //\n    // Functions\n    // -----------------------------------------------------------------------------------------------------------------\n\n    /// @notice Lock the given locked wallet's fungible amount of currency on behalf of the given locker wallet\n    /// @param lockedWallet The address of wallet that will be locked\n    /// @param lockerWallet The address of wallet that locks\n    /// @param amount The amount to be locked\n    /// @param currencyCt The address of the concerned currency contract (address(0) == ETH)\n    /// @param currencyId The ID of the concerned currency (0 for ETH and ERC20)\n    /// @param visibleTimeoutInSeconds The number of seconds until the locked amount is visible, a.o. for seizure\n    function lockFungibleByProxy(address lockedWallet, address lockerWallet, int256 amount,\n        address currencyCt, uint256 currencyId, uint256 visibleTimeoutInSeconds)\n    public\n    onlyAuthorizedService(lockedWallet)\n    {\n        // Require that locked and locker wallets are not identical\n        require(lockedWallet != lockerWallet);\n\n        // Get index of lock\n        uint256 lockIndex = lockedCurrencyLockerFungibleLockIndex[lockedWallet][currencyCt][currencyId][lockedWallet];\n\n        // Require that there is no existing conflicting lock\n        require(\n            (0 == lockIndex) ||\n            (block.timestamp >= walletFungibleLocks[lockedWallet][lockIndex - 1].unlockTime)\n        );\n\n        // Add lock object for this triplet of locked wallet, currency and locker wallet if it does not exist\n        if (0 == lockIndex) {\n            lockIndex = ++(walletFungibleLocks[lockedWallet].length);\n            lockedCurrencyLockerFungibleLockIndex[lockedWallet][currencyCt][currencyId][lockerWallet] = lockIndex;\n            walletCurrencyFungibleLockCount[lockedWallet][currencyCt][currencyId]++;\n        }\n\n        // Update lock parameters\n        walletFungibleLocks[lockedWallet][lockIndex - 1].locker = lockerWallet;\n        walletFungibleLocks[lockedWallet][lockIndex - 1].amount = amount;\n        walletFungibleLocks[lockedWallet][lockIndex - 1].currencyCt = currencyCt;\n        walletFungibleLocks[lockedWallet][lockIndex - 1].currencyId = currencyId;\n        walletFungibleLocks[lockedWallet][lockIndex - 1].visibleTime =\n        block.timestamp.add(visibleTimeoutInSeconds);\n        walletFungibleLocks[lockedWallet][lockIndex - 1].unlockTime =\n        block.timestamp.add(configuration.walletLockTimeout());\n\n        // Emit event\n        emit LockFungibleByProxyEvent(lockedWallet, lockerWallet, amount, currencyCt, currencyId, visibleTimeoutInSeconds);\n    }\n\n    /// @notice Lock the given locked wallet's non-fungible IDs of currency on behalf of the given locker wallet\n    /// @param lockedWallet The address of wallet that will be locked\n    /// @param lockerWallet The address of wallet that locks\n    /// @param ids The IDs to be locked\n    /// @param currencyCt The address of the concerned currency contract (address(0) == ETH)\n    /// @param currencyId The ID of the concerned currency (0 for ETH and ERC20)\n    /// @param visibleTimeoutInSeconds The number of seconds until the locked ids are visible, a.o. for seizure\n    function lockNonFungibleByProxy(address lockedWallet, address lockerWallet, int256[] memory ids,\n        address currencyCt, uint256 currencyId, uint256 visibleTimeoutInSeconds)\n    public\n    onlyAuthorizedService(lockedWallet)\n    {\n        // Require that locked and locker wallets are not identical\n        require(lockedWallet != lockerWallet);\n\n        // Get index of lock\n        uint256 lockIndex = lockedCurrencyLockerNonFungibleLockIndex[lockedWallet][currencyCt][currencyId][lockedWallet];\n\n        // Require that there is no existing conflicting lock\n        require(\n            (0 == lockIndex) ||\n            (block.timestamp >= walletNonFungibleLocks[lockedWallet][lockIndex - 1].unlockTime)\n        );\n\n        // Add lock object for this triplet of locked wallet, currency and locker wallet if it does not exist\n        if (0 == lockIndex) {\n            lockIndex = ++(walletNonFungibleLocks[lockedWallet].length);\n            lockedCurrencyLockerNonFungibleLockIndex[lockedWallet][currencyCt][currencyId][lockerWallet] = lockIndex;\n            walletCurrencyNonFungibleLockCount[lockedWallet][currencyCt][currencyId]++;\n        }\n\n        // Update lock parameters\n        walletNonFungibleLocks[lockedWallet][lockIndex - 1].locker = lockerWallet;\n        walletNonFungibleLocks[lockedWallet][lockIndex - 1].ids = ids;\n        walletNonFungibleLocks[lockedWallet][lockIndex - 1].currencyCt = currencyCt;\n        walletNonFungibleLocks[lockedWallet][lockIndex - 1].currencyId = currencyId;\n        walletNonFungibleLocks[lockedWallet][lockIndex - 1].visibleTime =\n        block.timestamp.add(visibleTimeoutInSeconds);\n        walletNonFungibleLocks[lockedWallet][lockIndex - 1].unlockTime =\n        block.timestamp.add(configuration.walletLockTimeout());\n\n        // Emit event\n        emit LockNonFungibleByProxyEvent(lockedWallet, lockerWallet, ids, currencyCt, currencyId, visibleTimeoutInSeconds);\n    }\n\n    /// @notice Unlock the given locked wallet's fungible amount of currency previously\n    /// locked by the given locker wallet\n    /// @param lockedWallet The address of the locked wallet\n    /// @param lockerWallet The address of the locker wallet\n    /// @param currencyCt The address of the concerned currency contract (address(0) == ETH)\n    /// @param currencyId The ID of the concerned currency (0 for ETH and ERC20)\n    function unlockFungible(address lockedWallet, address lockerWallet, address currencyCt, uint256 currencyId)\n    public\n    {\n        // Get index of lock\n        uint256 lockIndex = lockedCurrencyLockerFungibleLockIndex[lockedWallet][currencyCt][currencyId][lockerWallet];\n\n        // Return if no lock exists\n        if (0 == lockIndex)\n            return;\n\n        // Require that unlock timeout has expired\n        require(\n            block.timestamp >= walletFungibleLocks[lockedWallet][lockIndex - 1].unlockTime\n        );\n\n        // Unlock\n        int256 amount = _unlockFungible(lockedWallet, lockerWallet, currencyCt, currencyId, lockIndex);\n\n        // Emit event\n        emit UnlockFungibleEvent(lockedWallet, lockerWallet, amount, currencyCt, currencyId);\n    }\n\n    /// @notice Unlock by proxy the given locked wallet's fungible amount of currency previously\n    /// locked by the given locker wallet\n    /// @param lockedWallet The address of the locked wallet\n    /// @param lockerWallet The address of the locker wallet\n    /// @param currencyCt The address of the concerned currency contract (address(0) == ETH)\n    /// @param currencyId The ID of the concerned currency (0 for ETH and ERC20)\n    function unlockFungibleByProxy(address lockedWallet, address lockerWallet, address currencyCt, uint256 currencyId)\n    public\n    onlyAuthorizedService(lockedWallet)\n    {\n        // Get index of lock\n        uint256 lockIndex = lockedCurrencyLockerFungibleLockIndex[lockedWallet][currencyCt][currencyId][lockerWallet];\n\n        // Return if no lock exists\n        if (0 == lockIndex)\n            return;\n\n        // Unlock\n        int256 amount = _unlockFungible(lockedWallet, lockerWallet, currencyCt, currencyId, lockIndex);\n\n        // Emit event\n        emit UnlockFungibleByProxyEvent(lockedWallet, lockerWallet, amount, currencyCt, currencyId);\n    }\n\n    /// @notice Unlock the given locked wallet's non-fungible IDs of currency previously\n    /// locked by the given locker wallet\n    /// @param lockedWallet The address of the locked wallet\n    /// @param lockerWallet The address of the locker wallet\n    /// @param currencyCt The address of the concerned currency contract (address(0) == ETH)\n    /// @param currencyId The ID of the concerned currency (0 for ETH and ERC20)\n    function unlockNonFungible(address lockedWallet, address lockerWallet, address currencyCt, uint256 currencyId)\n    public\n    {\n        // Get index of lock\n        uint256 lockIndex = lockedCurrencyLockerNonFungibleLockIndex[lockedWallet][currencyCt][currencyId][lockerWallet];\n\n        // Return if no lock exists\n        if (0 == lockIndex)\n            return;\n\n        // Require that unlock timeout has expired\n        require(\n            block.timestamp >= walletNonFungibleLocks[lockedWallet][lockIndex - 1].unlockTime\n        );\n\n        // Unlock\n        int256[] memory ids = _unlockNonFungible(lockedWallet, lockerWallet, currencyCt, currencyId, lockIndex);\n\n        // Emit event\n        emit UnlockNonFungibleEvent(lockedWallet, lockerWallet, ids, currencyCt, currencyId);\n    }\n\n    /// @notice Unlock by proxy the given locked wallet's non-fungible IDs of currency previously\n    /// locked by the given locker wallet\n    /// @param lockedWallet The address of the locked wallet\n    /// @param lockerWallet The address of the locker wallet\n    /// @param currencyCt The address of the concerned currency contract (address(0) == ETH)\n    /// @param currencyId The ID of the concerned currency (0 for ETH and ERC20)\n    function unlockNonFungibleByProxy(address lockedWallet, address lockerWallet, address currencyCt, uint256 currencyId)\n    public\n    onlyAuthorizedService(lockedWallet)\n    {\n        // Get index of lock\n        uint256 lockIndex = lockedCurrencyLockerNonFungibleLockIndex[lockedWallet][currencyCt][currencyId][lockerWallet];\n\n        // Return if no lock exists\n        if (0 == lockIndex)\n            return;\n\n        // Unlock\n        int256[] memory ids = _unlockNonFungible(lockedWallet, lockerWallet, currencyCt, currencyId, lockIndex);\n\n        // Emit event\n        emit UnlockNonFungibleByProxyEvent(lockedWallet, lockerWallet, ids, currencyCt, currencyId);\n    }\n\n    /// @notice Get the number of fungible locks for the given wallet\n    /// @param wallet The address of the locked wallet\n    /// @return The number of fungible locks\n    function fungibleLocksCount(address wallet)\n    public\n    view\n    returns (uint256)\n    {\n        return walletFungibleLocks[wallet].length;\n    }\n\n    /// @notice Get the number of non-fungible locks for the given wallet\n    /// @param wallet The address of the locked wallet\n    /// @return The number of non-fungible locks\n    function nonFungibleLocksCount(address wallet)\n    public\n    view\n    returns (uint256)\n    {\n        return walletNonFungibleLocks[wallet].length;\n    }\n\n    /// @notice Get the fungible amount of the given currency held by locked wallet that is\n    /// locked by locker wallet\n    /// @param lockedWallet The address of the locked wallet\n    /// @param lockerWallet The address of the locker wallet\n    /// @param currencyCt The address of the concerned currency contract (address(0) == ETH)\n    /// @param currencyId The ID of the concerned currency (0 for ETH and ERC20)\n    function lockedAmount(address lockedWallet, address lockerWallet, address currencyCt, uint256 currencyId)\n    public\n    view\n    returns (int256)\n    {\n        uint256 lockIndex = lockedCurrencyLockerFungibleLockIndex[lockedWallet][currencyCt][currencyId][lockerWallet];\n\n        if (0 == lockIndex || block.timestamp < walletFungibleLocks[lockedWallet][lockIndex - 1].visibleTime)\n            return 0;\n\n        return walletFungibleLocks[lockedWallet][lockIndex - 1].amount;\n    }\n\n    /// @notice Get the count of non-fungible IDs of the given currency held by locked wallet that is\n    /// locked by locker wallet\n    /// @param lockedWallet The address of the locked wallet\n    /// @param lockerWallet The address of the locker wallet\n    /// @param currencyCt The address of the concerned currency contract (address(0) == ETH)\n    /// @param currencyId The ID of the concerned currency (0 for ETH and ERC20)\n    function lockedIdsCount(address lockedWallet, address lockerWallet, address currencyCt, uint256 currencyId)\n    public\n    view\n    returns (uint256)\n    {\n        uint256 lockIndex = lockedCurrencyLockerNonFungibleLockIndex[lockedWallet][currencyCt][currencyId][lockerWallet];\n\n        if (0 == lockIndex || block.timestamp < walletNonFungibleLocks[lockedWallet][lockIndex - 1].visibleTime)\n            return 0;\n\n        return walletNonFungibleLocks[lockedWallet][lockIndex - 1].ids.length;\n    }\n\n    /// @notice Get the set of non-fungible IDs of the given currency held by locked wallet that is\n    /// locked by locker wallet and whose indices are in the given range of indices\n    /// @param lockedWallet The address of the locked wallet\n    /// @param lockerWallet The address of the locker wallet\n    /// @param currencyCt The address of the concerned currency contract (address(0) == ETH)\n    /// @param currencyId The ID of the concerned currency (0 for ETH and ERC20)\n    /// @param low The lower ID index\n    /// @param up The upper ID index\n    function lockedIdsByIndices(address lockedWallet, address lockerWallet, address currencyCt, uint256 currencyId,\n        uint256 low, uint256 up)\n    public\n    view\n    returns (int256[] memory)\n    {\n        uint256 lockIndex = lockedCurrencyLockerNonFungibleLockIndex[lockedWallet][currencyCt][currencyId][lockerWallet];\n\n        if (0 == lockIndex || block.timestamp < walletNonFungibleLocks[lockedWallet][lockIndex - 1].visibleTime)\n            return new int256[](0);\n\n        NonFungibleLock storage lock = walletNonFungibleLocks[lockedWallet][lockIndex - 1];\n\n        if (0 == lock.ids.length)\n            return new int256[](0);\n\n        up = up.clampMax(lock.ids.length - 1);\n        int256[] memory _ids = new int256[](up - low + 1);\n        for (uint256 i = low; i <= up; i++)\n            _ids[i - low] = lock.ids[i];\n\n        return _ids;\n    }\n\n    /// @notice Gauge whether the given wallet is locked\n    /// @param wallet The address of the concerned wallet\n    /// @return true if wallet is locked, else false\n    function isLocked(address wallet)\n    public\n    view\n    returns (bool)\n    {\n        return 0 < walletFungibleLocks[wallet].length ||\n        0 < walletNonFungibleLocks[wallet].length;\n    }\n\n    /// @notice Gauge whether the given wallet and currency is locked\n    /// @param wallet The address of the concerned wallet\n    /// @param currencyCt The address of the concerned currency contract (address(0) == ETH)\n    /// @param currencyId The ID of the concerned currency (0 for ETH and ERC20)\n    /// @return true if wallet/currency pair is locked, else false\n    function isLocked(address wallet, address currencyCt, uint256 currencyId)\n    public\n    view\n    returns (bool)\n    {\n        return 0 < walletCurrencyFungibleLockCount[wallet][currencyCt][currencyId] ||\n        0 < walletCurrencyNonFungibleLockCount[wallet][currencyCt][currencyId];\n    }\n\n    /// @notice Gauge whether the given locked wallet and currency is locked by the given locker wallet\n    /// @param lockedWallet The address of the concerned locked wallet\n    /// @param lockerWallet The address of the concerned locker wallet\n    /// @return true if lockedWallet is locked by lockerWallet, else false\n    function isLocked(address lockedWallet, address lockerWallet, address currencyCt, uint256 currencyId)\n    public\n    view\n    returns (bool)\n    {\n        return 0 < lockedCurrencyLockerFungibleLockIndex[lockedWallet][currencyCt][currencyId][lockerWallet] ||\n        0 < lockedCurrencyLockerNonFungibleLockIndex[lockedWallet][currencyCt][currencyId][lockerWallet];\n    }\n\n    //\n    //\n    // Private functions\n    // -----------------------------------------------------------------------------------------------------------------\n    function _unlockFungible(address lockedWallet, address lockerWallet, address currencyCt, uint256 currencyId, uint256 lockIndex)\n    private\n    returns (int256)\n    {\n        int256 amount = walletFungibleLocks[lockedWallet][lockIndex - 1].amount;\n\n        if (lockIndex < walletFungibleLocks[lockedWallet].length) {\n            walletFungibleLocks[lockedWallet][lockIndex - 1] =\n            walletFungibleLocks[lockedWallet][walletFungibleLocks[lockedWallet].length - 1];\n\n            lockedCurrencyLockerFungibleLockIndex[lockedWallet][currencyCt][currencyId][walletFungibleLocks[lockedWallet][lockIndex - 1].locker] = lockIndex;\n        }\n        walletFungibleLocks[lockedWallet].length--;\n\n        lockedCurrencyLockerFungibleLockIndex[lockedWallet][currencyCt][currencyId][lockerWallet] = 0;\n\n        walletCurrencyFungibleLockCount[lockedWallet][currencyCt][currencyId]--;\n\n        return amount;\n    }\n\n    function _unlockNonFungible(address lockedWallet, address lockerWallet, address currencyCt, uint256 currencyId, uint256 lockIndex)\n    private\n    returns (int256[] memory)\n    {\n        int256[] memory ids = walletNonFungibleLocks[lockedWallet][lockIndex - 1].ids;\n\n        if (lockIndex < walletNonFungibleLocks[lockedWallet].length) {\n            walletNonFungibleLocks[lockedWallet][lockIndex - 1] =\n            walletNonFungibleLocks[lockedWallet][walletNonFungibleLocks[lockedWallet].length - 1];\n\n            lockedCurrencyLockerNonFungibleLockIndex[lockedWallet][currencyCt][currencyId][walletNonFungibleLocks[lockedWallet][lockIndex - 1].locker] = lockIndex;\n        }\n        walletNonFungibleLocks[lockedWallet].length--;\n\n        lockedCurrencyLockerNonFungibleLockIndex[lockedWallet][currencyCt][currencyId][lockerWallet] = 0;\n\n        walletCurrencyNonFungibleLockCount[lockedWallet][currencyCt][currencyId]--;\n\n        return ids;\n    }\n}\n\n/*\n * Hubii Nahmii\n *\n * Compliant with the Hubii Nahmii specification v0.12.\n *\n * Copyright (C) 2017-2018 Hubii AS\n */\n\n/**\n * @title WalletLockable\n * @notice An ownable that has a wallet locker property\n */\ncontract WalletLockable is Ownable {\n    //\n    // Variables\n    // -----------------------------------------------------------------------------------------------------------------\n    WalletLocker public walletLocker;\n    bool public walletLockerFrozen;\n\n    //\n    // Events\n    // -----------------------------------------------------------------------------------------------------------------\n    event SetWalletLockerEvent(WalletLocker oldWalletLocker, WalletLocker newWalletLocker);\n    event FreezeWalletLockerEvent();\n\n    //\n    // Functions\n    // -----------------------------------------------------------------------------------------------------------------\n    /// @notice Set the wallet locker contract\n    /// @param newWalletLocker The (address of) WalletLocker contract instance\n    function setWalletLocker(WalletLocker newWalletLocker)\n    public\n    onlyDeployer\n    notNullAddress(address(newWalletLocker))\n    notSameAddresses(address(newWalletLocker), address(walletLocker))\n    {\n        // Require that this contract has not been frozen\n        require(!walletLockerFrozen, \"Wallet locker frozen [WalletLockable.sol:43]\");\n\n        // Update fields\n        WalletLocker oldWalletLocker = walletLocker;\n        walletLocker = newWalletLocker;\n\n        // Emit event\n        emit SetWalletLockerEvent(oldWalletLocker, newWalletLocker);\n    }\n\n    /// @notice Freeze the balance tracker from further updates\n    /// @dev This operation can not be undone\n    function freezeWalletLocker()\n    public\n    onlyDeployer\n    {\n        walletLockerFrozen = true;\n\n        // Emit event\n        emit FreezeWalletLockerEvent();\n    }\n\n    //\n    // Modifiers\n    // -----------------------------------------------------------------------------------------------------------------\n    modifier walletLockerInitialized() {\n        require(address(walletLocker) != address(0), \"Wallet locker not initialized [WalletLockable.sol:69]\");\n        _;\n    }\n}\n\n/*\n * Hubii Nahmii\n *\n * Compliant with the Hubii Nahmii specification v0.12.\n *\n * Copyright (C) 2017-2018 Hubii AS\n */\n\nlibrary CurrenciesLib {\n    using SafeMathUintLib for uint256;\n\n    //\n    // Structures\n    // -----------------------------------------------------------------------------------------------------------------\n    struct Currencies {\n        MonetaryTypesLib.Currency[] currencies;\n        mapping(address => mapping(uint256 => uint256)) indexByCurrency;\n    }\n\n    //\n    // Functions\n    // -----------------------------------------------------------------------------------------------------------------\n    function add(Currencies storage self, address currencyCt, uint256 currencyId)\n    internal\n    {\n        // Index is 1-based\n        if (0 == self.indexByCurrency[currencyCt][currencyId]) {\n            self.currencies.push(MonetaryTypesLib.Currency(currencyCt, currencyId));\n            self.indexByCurrency[currencyCt][currencyId] = self.currencies.length;\n        }\n    }\n\n    function removeByCurrency(Currencies storage self, address currencyCt, uint256 currencyId)\n    internal\n    {\n        // Index is 1-based\n        uint256 index = self.indexByCurrency[currencyCt][currencyId];\n        if (0 < index)\n            removeByIndex(self, index - 1);\n    }\n\n    function removeByIndex(Currencies storage self, uint256 index)\n    internal\n    {\n        require(index < self.currencies.length, \"Index out of bounds [CurrenciesLib.sol:51]\");\n\n        address currencyCt = self.currencies[index].ct;\n        uint256 currencyId = self.currencies[index].id;\n\n        if (index < self.currencies.length - 1) {\n            self.currencies[index] = self.currencies[self.currencies.length - 1];\n            self.indexByCurrency[self.currencies[index].ct][self.currencies[index].id] = index + 1;\n        }\n        self.currencies.length--;\n        self.indexByCurrency[currencyCt][currencyId] = 0;\n    }\n\n    function count(Currencies storage self)\n    internal\n    view\n    returns (uint256)\n    {\n        return self.currencies.length;\n    }\n\n    function has(Currencies storage self, address currencyCt, uint256 currencyId)\n    internal\n    view\n    returns (bool)\n    {\n        return 0 != self.indexByCurrency[currencyCt][currencyId];\n    }\n\n    function getByIndex(Currencies storage self, uint256 index)\n    internal\n    view\n    returns (MonetaryTypesLib.Currency memory)\n    {\n        require(index < self.currencies.length, \"Index out of bounds [CurrenciesLib.sol:85]\");\n        return self.currencies[index];\n    }\n\n    function getByIndices(Currencies storage self, uint256 low, uint256 up)\n    internal\n    view\n    returns (MonetaryTypesLib.Currency[] memory)\n    {\n        require(0 < self.currencies.length, \"No currencies found [CurrenciesLib.sol:94]\");\n        require(low <= up, \"Bounds parameters mismatch [CurrenciesLib.sol:95]\");\n\n        up = up.clampMax(self.currencies.length - 1);\n        MonetaryTypesLib.Currency[] memory _currencies = new MonetaryTypesLib.Currency[](up - low + 1);\n        for (uint256 i = low; i <= up; i++)\n            _currencies[i - low] = self.currencies[i];\n\n        return _currencies;\n    }\n}\n\n/*\n * Hubii Nahmii\n *\n * Compliant with the Hubii Nahmii specification v0.12.\n *\n * Copyright (C) 2017-2018 Hubii AS\n */\n\nlibrary FungibleBalanceLib {\n    using SafeMathIntLib for int256;\n    using SafeMathUintLib for uint256;\n    using CurrenciesLib for CurrenciesLib.Currencies;\n\n    //\n    // Structures\n    // -----------------------------------------------------------------------------------------------------------------\n    struct Record {\n        int256 amount;\n        uint256 blockNumber;\n    }\n\n    struct Balance {\n        mapping(address => mapping(uint256 => int256)) amountByCurrency;\n        mapping(address => mapping(uint256 => Record[])) recordsByCurrency;\n\n        CurrenciesLib.Currencies inUseCurrencies;\n        CurrenciesLib.Currencies everUsedCurrencies;\n    }\n\n    //\n    // Functions\n    // -----------------------------------------------------------------------------------------------------------------\n    function get(Balance storage self, address currencyCt, uint256 currencyId)\n    internal\n    view\n    returns (int256)\n    {\n        return self.amountByCurrency[currencyCt][currencyId];\n    }\n\n    function getByBlockNumber(Balance storage self, address currencyCt, uint256 currencyId, uint256 blockNumber)\n    internal\n    view\n    returns (int256)\n    {\n        (int256 amount,) = recordByBlockNumber(self, currencyCt, currencyId, blockNumber);\n        return amount;\n    }\n\n    function set(Balance storage self, int256 amount, address currencyCt, uint256 currencyId)\n    internal\n    {\n        self.amountByCurrency[currencyCt][currencyId] = amount;\n\n        self.recordsByCurrency[currencyCt][currencyId].push(\n            Record(self.amountByCurrency[currencyCt][currencyId], block.number)\n        );\n\n        updateCurrencies(self, currencyCt, currencyId);\n    }\n\n    function add(Balance storage self, int256 amount, address currencyCt, uint256 currencyId)\n    internal\n    {\n        self.amountByCurrency[currencyCt][currencyId] = self.amountByCurrency[currencyCt][currencyId].add(amount);\n\n        self.recordsByCurrency[currencyCt][currencyId].push(\n            Record(self.amountByCurrency[currencyCt][currencyId], block.number)\n        );\n\n        updateCurrencies(self, currencyCt, currencyId);\n    }\n\n    function sub(Balance storage self, int256 amount, address currencyCt, uint256 currencyId)\n    internal\n    {\n        self.amountByCurrency[currencyCt][currencyId] = self.amountByCurrency[currencyCt][currencyId].sub(amount);\n\n        self.recordsByCurrency[currencyCt][currencyId].push(\n            Record(self.amountByCurrency[currencyCt][currencyId], block.number)\n        );\n\n        updateCurrencies(self, currencyCt, currencyId);\n    }\n\n    function transfer(Balance storage _from, Balance storage _to, int256 amount,\n        address currencyCt, uint256 currencyId)\n    internal\n    {\n        sub(_from, amount, currencyCt, currencyId);\n        add(_to, amount, currencyCt, currencyId);\n    }\n\n    function add_nn(Balance storage self, int256 amount, address currencyCt, uint256 currencyId)\n    internal\n    {\n        self.amountByCurrency[currencyCt][currencyId] = self.amountByCurrency[currencyCt][currencyId].add_nn(amount);\n\n        self.recordsByCurrency[currencyCt][currencyId].push(\n            Record(self.amountByCurrency[currencyCt][currencyId], block.number)\n        );\n\n        updateCurrencies(self, currencyCt, currencyId);\n    }\n\n    function sub_nn(Balance storage self, int256 amount, address currencyCt, uint256 currencyId)\n    internal\n    {\n        self.amountByCurrency[currencyCt][currencyId] = self.amountByCurrency[currencyCt][currencyId].sub_nn(amount);\n\n        self.recordsByCurrency[currencyCt][currencyId].push(\n            Record(self.amountByCurrency[currencyCt][currencyId], block.number)\n        );\n\n        updateCurrencies(self, currencyCt, currencyId);\n    }\n\n    function transfer_nn(Balance storage _from, Balance storage _to, int256 amount,\n        address currencyCt, uint256 currencyId)\n    internal\n    {\n        sub_nn(_from, amount, currencyCt, currencyId);\n        add_nn(_to, amount, currencyCt, currencyId);\n    }\n\n    function recordsCount(Balance storage self, address currencyCt, uint256 currencyId)\n    internal\n    view\n    returns (uint256)\n    {\n        return self.recordsByCurrency[currencyCt][currencyId].length;\n    }\n\n    function recordByBlockNumber(Balance storage self, address currencyCt, uint256 currencyId, uint256 blockNumber)\n    internal\n    view\n    returns (int256, uint256)\n    {\n        uint256 index = indexByBlockNumber(self, currencyCt, currencyId, blockNumber);\n        return 0 < index ? recordByIndex(self, currencyCt, currencyId, index - 1) : (0, 0);\n    }\n\n    function recordByIndex(Balance storage self, address currencyCt, uint256 currencyId, uint256 index)\n    internal\n    view\n    returns (int256, uint256)\n    {\n        if (0 == self.recordsByCurrency[currencyCt][currencyId].length)\n            return (0, 0);\n\n        index = index.clampMax(self.recordsByCurrency[currencyCt][currencyId].length - 1);\n        Record storage record = self.recordsByCurrency[currencyCt][currencyId][index];\n        return (record.amount, record.blockNumber);\n    }\n\n    function lastRecord(Balance storage self, address currencyCt, uint256 currencyId)\n    internal\n    view\n    returns (int256, uint256)\n    {\n        if (0 == self.recordsByCurrency[currencyCt][currencyId].length)\n            return (0, 0);\n\n        Record storage record = self.recordsByCurrency[currencyCt][currencyId][self.recordsByCurrency[currencyCt][currencyId].length - 1];\n        return (record.amount, record.blockNumber);\n    }\n\n    function hasInUseCurrency(Balance storage self, address currencyCt, uint256 currencyId)\n    internal\n    view\n    returns (bool)\n    {\n        return self.inUseCurrencies.has(currencyCt, currencyId);\n    }\n\n    function hasEverUsedCurrency(Balance storage self, address currencyCt, uint256 currencyId)\n    internal\n    view\n    returns (bool)\n    {\n        return self.everUsedCurrencies.has(currencyCt, currencyId);\n    }\n\n    function updateCurrencies(Balance storage self, address currencyCt, uint256 currencyId)\n    internal\n    {\n        if (0 == self.amountByCurrency[currencyCt][currencyId] && self.inUseCurrencies.has(currencyCt, currencyId))\n            self.inUseCurrencies.removeByCurrency(currencyCt, currencyId);\n        else if (!self.inUseCurrencies.has(currencyCt, currencyId)) {\n            self.inUseCurrencies.add(currencyCt, currencyId);\n            self.everUsedCurrencies.add(currencyCt, currencyId);\n        }\n    }\n\n    function indexByBlockNumber(Balance storage self, address currencyCt, uint256 currencyId, uint256 blockNumber)\n    internal\n    view\n    returns (uint256)\n    {\n        if (0 == self.recordsByCurrency[currencyCt][currencyId].length)\n            return 0;\n        for (uint256 i = self.recordsByCurrency[currencyCt][currencyId].length; i > 0; i--)\n            if (self.recordsByCurrency[currencyCt][currencyId][i - 1].blockNumber <= blockNumber)\n                return i;\n        return 0;\n    }\n}\n\n/*\n * Hubii Nahmii\n *\n * Compliant with the Hubii Nahmii specification v0.12.\n *\n * Copyright (C) 2017-2018 Hubii AS\n */\n\nlibrary NonFungibleBalanceLib {\n    using SafeMathIntLib for int256;\n    using SafeMathUintLib for uint256;\n    using CurrenciesLib for CurrenciesLib.Currencies;\n\n    //\n    // Structures\n    // -----------------------------------------------------------------------------------------------------------------\n    struct Record {\n        int256[] ids;\n        uint256 blockNumber;\n    }\n\n    struct Balance {\n        mapping(address => mapping(uint256 => int256[])) idsByCurrency;\n        mapping(address => mapping(uint256 => mapping(int256 => uint256))) idIndexById;\n        mapping(address => mapping(uint256 => Record[])) recordsByCurrency;\n\n        CurrenciesLib.Currencies inUseCurrencies;\n        CurrenciesLib.Currencies everUsedCurrencies;\n    }\n\n    //\n    // Functions\n    // -----------------------------------------------------------------------------------------------------------------\n    function get(Balance storage self, address currencyCt, uint256 currencyId)\n    internal\n    view\n    returns (int256[] memory)\n    {\n        return self.idsByCurrency[currencyCt][currencyId];\n    }\n\n    function getByIndices(Balance storage self, address currencyCt, uint256 currencyId, uint256 indexLow, uint256 indexUp)\n    internal\n    view\n    returns (int256[] memory)\n    {\n        if (0 == self.idsByCurrency[currencyCt][currencyId].length)\n            return new int256[](0);\n\n        indexUp = indexUp.clampMax(self.idsByCurrency[currencyCt][currencyId].length - 1);\n\n        int256[] memory idsByCurrency = new int256[](indexUp - indexLow + 1);\n        for (uint256 i = indexLow; i < indexUp; i++)\n            idsByCurrency[i - indexLow] = self.idsByCurrency[currencyCt][currencyId][i];\n\n        return idsByCurrency;\n    }\n\n    function idsCount(Balance storage self, address currencyCt, uint256 currencyId)\n    internal\n    view\n    returns (uint256)\n    {\n        return self.idsByCurrency[currencyCt][currencyId].length;\n    }\n\n    function hasId(Balance storage self, int256 id, address currencyCt, uint256 currencyId)\n    internal\n    view\n    returns (bool)\n    {\n        return 0 < self.idIndexById[currencyCt][currencyId][id];\n    }\n\n    function recordByBlockNumber(Balance storage self, address currencyCt, uint256 currencyId, uint256 blockNumber)\n    internal\n    view\n    returns (int256[] memory, uint256)\n    {\n        uint256 index = indexByBlockNumber(self, currencyCt, currencyId, blockNumber);\n        return 0 < index ? recordByIndex(self, currencyCt, currencyId, index - 1) : (new int256[](0), 0);\n    }\n\n    function recordByIndex(Balance storage self, address currencyCt, uint256 currencyId, uint256 index)\n    internal\n    view\n    returns (int256[] memory, uint256)\n    {\n        if (0 == self.recordsByCurrency[currencyCt][currencyId].length)\n            return (new int256[](0), 0);\n\n        index = index.clampMax(self.recordsByCurrency[currencyCt][currencyId].length - 1);\n        Record storage record = self.recordsByCurrency[currencyCt][currencyId][index];\n        return (record.ids, record.blockNumber);\n    }\n\n    function lastRecord(Balance storage self, address currencyCt, uint256 currencyId)\n    internal\n    view\n    returns (int256[] memory, uint256)\n    {\n        if (0 == self.recordsByCurrency[currencyCt][currencyId].length)\n            return (new int256[](0), 0);\n\n        Record storage record = self.recordsByCurrency[currencyCt][currencyId][self.recordsByCurrency[currencyCt][currencyId].length - 1];\n        return (record.ids, record.blockNumber);\n    }\n\n    function recordsCount(Balance storage self, address currencyCt, uint256 currencyId)\n    internal\n    view\n    returns (uint256)\n    {\n        return self.recordsByCurrency[currencyCt][currencyId].length;\n    }\n\n    function set(Balance storage self, int256 id, address currencyCt, uint256 currencyId)\n    internal\n    {\n        int256[] memory ids = new int256[](1);\n        ids[0] = id;\n        set(self, ids, currencyCt, currencyId);\n    }\n\n    function set(Balance storage self, int256[] memory ids, address currencyCt, uint256 currencyId)\n    internal\n    {\n        uint256 i;\n        for (i = 0; i < self.idsByCurrency[currencyCt][currencyId].length; i++)\n            self.idIndexById[currencyCt][currencyId][self.idsByCurrency[currencyCt][currencyId][i]] = 0;\n\n        self.idsByCurrency[currencyCt][currencyId] = ids;\n\n        for (i = 0; i < self.idsByCurrency[currencyCt][currencyId].length; i++)\n            self.idIndexById[currencyCt][currencyId][self.idsByCurrency[currencyCt][currencyId][i]] = i + 1;\n\n        self.recordsByCurrency[currencyCt][currencyId].push(\n            Record(self.idsByCurrency[currencyCt][currencyId], block.number)\n        );\n\n        updateInUseCurrencies(self, currencyCt, currencyId);\n    }\n\n    function reset(Balance storage self, address currencyCt, uint256 currencyId)\n    internal\n    {\n        for (uint256 i = 0; i < self.idsByCurrency[currencyCt][currencyId].length; i++)\n            self.idIndexById[currencyCt][currencyId][self.idsByCurrency[currencyCt][currencyId][i]] = 0;\n\n        self.idsByCurrency[currencyCt][currencyId].length = 0;\n\n        self.recordsByCurrency[currencyCt][currencyId].push(\n            Record(self.idsByCurrency[currencyCt][currencyId], block.number)\n        );\n\n        updateInUseCurrencies(self, currencyCt, currencyId);\n    }\n\n    function add(Balance storage self, int256 id, address currencyCt, uint256 currencyId)\n    internal\n    returns (bool)\n    {\n        if (0 < self.idIndexById[currencyCt][currencyId][id])\n            return false;\n\n        self.idsByCurrency[currencyCt][currencyId].push(id);\n\n        self.idIndexById[currencyCt][currencyId][id] = self.idsByCurrency[currencyCt][currencyId].length;\n\n        self.recordsByCurrency[currencyCt][currencyId].push(\n            Record(self.idsByCurrency[currencyCt][currencyId], block.number)\n        );\n\n        updateInUseCurrencies(self, currencyCt, currencyId);\n\n        return true;\n    }\n\n    function sub(Balance storage self, int256 id, address currencyCt, uint256 currencyId)\n    internal\n    returns (bool)\n    {\n        uint256 index = self.idIndexById[currencyCt][currencyId][id];\n\n        if (0 == index)\n            return false;\n\n        if (index < self.idsByCurrency[currencyCt][currencyId].length) {\n            self.idsByCurrency[currencyCt][currencyId][index - 1] = self.idsByCurrency[currencyCt][currencyId][self.idsByCurrency[currencyCt][currencyId].length - 1];\n            self.idIndexById[currencyCt][currencyId][self.idsByCurrency[currencyCt][currencyId][index - 1]] = index;\n        }\n        self.idsByCurrency[currencyCt][currencyId].length--;\n        self.idIndexById[currencyCt][currencyId][id] = 0;\n\n        self.recordsByCurrency[currencyCt][currencyId].push(\n            Record(self.idsByCurrency[currencyCt][currencyId], block.number)\n        );\n\n        updateInUseCurrencies(self, currencyCt, currencyId);\n\n        return true;\n    }\n\n    function transfer(Balance storage _from, Balance storage _to, int256 id,\n        address currencyCt, uint256 currencyId)\n    internal\n    returns (bool)\n    {\n        return sub(_from, id, currencyCt, currencyId) && add(_to, id, currencyCt, currencyId);\n    }\n\n    function hasInUseCurrency(Balance storage self, address currencyCt, uint256 currencyId)\n    internal\n    view\n    returns (bool)\n    {\n        return self.inUseCurrencies.has(currencyCt, currencyId);\n    }\n\n    function hasEverUsedCurrency(Balance storage self, address currencyCt, uint256 currencyId)\n    internal\n    view\n    returns (bool)\n    {\n        return self.everUsedCurrencies.has(currencyCt, currencyId);\n    }\n\n    function updateInUseCurrencies(Balance storage self, address currencyCt, uint256 currencyId)\n    internal\n    {\n        if (0 == self.idsByCurrency[currencyCt][currencyId].length && self.inUseCurrencies.has(currencyCt, currencyId))\n            self.inUseCurrencies.removeByCurrency(currencyCt, currencyId);\n        else if (!self.inUseCurrencies.has(currencyCt, currencyId)) {\n            self.inUseCurrencies.add(currencyCt, currencyId);\n            self.everUsedCurrencies.add(currencyCt, currencyId);\n        }\n    }\n\n    function indexByBlockNumber(Balance storage self, address currencyCt, uint256 currencyId, uint256 blockNumber)\n    internal\n    view\n    returns (uint256)\n    {\n        if (0 == self.recordsByCurrency[currencyCt][currencyId].length)\n            return 0;\n        for (uint256 i = self.recordsByCurrency[currencyCt][currencyId].length; i > 0; i--)\n            if (self.recordsByCurrency[currencyCt][currencyId][i - 1].blockNumber <= blockNumber)\n                return i;\n        return 0;\n    }\n}\n\n/*\n * Hubii Nahmii\n *\n * Compliant with the Hubii Nahmii specification v0.12.\n *\n * Copyright (C) 2017-2018 Hubii AS\n */\n\n/**\n * @title Balance tracker\n * @notice An ownable to track balances of generic types\n */\ncontract BalanceTracker is Ownable, Servable {\n    using SafeMathIntLib for int256;\n    using SafeMathUintLib for uint256;\n    using FungibleBalanceLib for FungibleBalanceLib.Balance;\n    using NonFungibleBalanceLib for NonFungibleBalanceLib.Balance;\n\n    //\n    // Constants\n    // -----------------------------------------------------------------------------------------------------------------\n    string constant public DEPOSITED_BALANCE_TYPE = \"deposited\";\n    string constant public SETTLED_BALANCE_TYPE = \"settled\";\n    string constant public STAGED_BALANCE_TYPE = \"staged\";\n\n    //\n    // Structures\n    // -----------------------------------------------------------------------------------------------------------------\n    struct Wallet {\n        mapping(bytes32 => FungibleBalanceLib.Balance) fungibleBalanceByType;\n        mapping(bytes32 => NonFungibleBalanceLib.Balance) nonFungibleBalanceByType;\n    }\n\n    //\n    // Variables\n    // -----------------------------------------------------------------------------------------------------------------\n    bytes32 public depositedBalanceType;\n    bytes32 public settledBalanceType;\n    bytes32 public stagedBalanceType;\n\n    bytes32[] public _allBalanceTypes;\n    bytes32[] public _activeBalanceTypes;\n\n    bytes32[] public trackedBalanceTypes;\n    mapping(bytes32 => bool) public trackedBalanceTypeMap;\n\n    mapping(address => Wallet) private walletMap;\n\n    address[] public trackedWallets;\n    mapping(address => uint256) public trackedWalletIndexByWallet;\n\n    //\n    // Constructor\n    // -----------------------------------------------------------------------------------------------------------------\n    constructor(address deployer) Ownable(deployer)\n    public\n    {\n        depositedBalanceType = keccak256(abi.encodePacked(DEPOSITED_BALANCE_TYPE));\n        settledBalanceType = keccak256(abi.encodePacked(SETTLED_BALANCE_TYPE));\n        stagedBalanceType = keccak256(abi.encodePacked(STAGED_BALANCE_TYPE));\n\n        _allBalanceTypes.push(settledBalanceType);\n        _allBalanceTypes.push(depositedBalanceType);\n        _allBalanceTypes.push(stagedBalanceType);\n\n        _activeBalanceTypes.push(settledBalanceType);\n        _activeBalanceTypes.push(depositedBalanceType);\n    }\n\n    //\n    // Functions\n    // -----------------------------------------------------------------------------------------------------------------\n    /// @notice Get the fungible balance (amount) of the given wallet, type and currency\n    /// @param wallet The address of the concerned wallet\n    /// @param _type The balance type\n    /// @param currencyCt The address of the concerned currency contract (address(0) == ETH)\n    /// @param currencyId The ID of the concerned currency (0 for ETH and ERC20)\n    /// @return The stored balance\n    function get(address wallet, bytes32 _type, address currencyCt, uint256 currencyId)\n    public\n    view\n    returns (int256)\n    {\n        return walletMap[wallet].fungibleBalanceByType[_type].get(currencyCt, currencyId);\n    }\n\n    /// @notice Get the non-fungible balance (IDs) of the given wallet, type, currency and index range\n    /// @param wallet The address of the concerned wallet\n    /// @param _type The balance type\n    /// @param currencyCt The address of the concerned currency contract (address(0) == ETH)\n    /// @param currencyId The ID of the concerned currency (0 for ETH and ERC20)\n    /// @param indexLow The lower index of IDs\n    /// @param indexUp The upper index of IDs\n    /// @return The stored balance\n    function getByIndices(address wallet, bytes32 _type, address currencyCt, uint256 currencyId,\n        uint256 indexLow, uint256 indexUp)\n    public\n    view\n    returns (int256[] memory)\n    {\n        return walletMap[wallet].nonFungibleBalanceByType[_type].getByIndices(\n            currencyCt, currencyId, indexLow, indexUp\n        );\n    }\n\n    /// @notice Get all the non-fungible balance (IDs) of the given wallet, type and currency\n    /// @param wallet The address of the concerned wallet\n    /// @param _type The balance type\n    /// @param currencyCt The address of the concerned currency contract (address(0) == ETH)\n    /// @param currencyId The ID of the concerned currency (0 for ETH and ERC20)\n    /// @return The stored balance\n    function getAll(address wallet, bytes32 _type, address currencyCt, uint256 currencyId)\n    public\n    view\n    returns (int256[] memory)\n    {\n        return walletMap[wallet].nonFungibleBalanceByType[_type].get(\n            currencyCt, currencyId\n        );\n    }\n\n    /// @notice Get the count of non-fungible IDs of the given wallet, type and currency\n    /// @param wallet The address of the concerned wallet\n    /// @param _type The balance type\n    /// @param currencyCt The address of the concerned currency contract (address(0) == ETH)\n    /// @param currencyId The ID of the concerned currency (0 for ETH and ERC20)\n    /// @return The count of IDs\n    function idsCount(address wallet, bytes32 _type, address currencyCt, uint256 currencyId)\n    public\n    view\n    returns (uint256)\n    {\n        return walletMap[wallet].nonFungibleBalanceByType[_type].idsCount(\n            currencyCt, currencyId\n        );\n    }\n\n    /// @notice Gauge whether the ID is included in the given wallet, type and currency\n    /// @param wallet The address of the concerned wallet\n    /// @param _type The balance type\n    /// @param id The ID of the concerned unit\n    /// @param currencyCt The address of the concerned currency contract (address(0) == ETH)\n    /// @param currencyId The ID of the concerned currency (0 for ETH and ERC20)\n    /// @return true if ID is included, else false\n    function hasId(address wallet, bytes32 _type, int256 id, address currencyCt, uint256 currencyId)\n    public\n    view\n    returns (bool)\n    {\n        return walletMap[wallet].nonFungibleBalanceByType[_type].hasId(\n            id, currencyCt, currencyId\n        );\n    }\n\n    /// @notice Set the balance of the given wallet, type and currency to the given value\n    /// @param wallet The address of the concerned wallet\n    /// @param _type The balance type\n    /// @param value The value (amount of fungible, id of non-fungible) to set\n    /// @param currencyCt The address of the concerned currency contract (address(0) == ETH)\n    /// @param currencyId The ID of the concerned currency (0 for ETH and ERC20)\n    /// @param fungible True if setting fungible balance, else false\n    function set(address wallet, bytes32 _type, int256 value, address currencyCt, uint256 currencyId, bool fungible)\n    public\n    onlyActiveService\n    {\n        // Update the balance\n        if (fungible)\n            walletMap[wallet].fungibleBalanceByType[_type].set(\n                value, currencyCt, currencyId\n            );\n\n        else\n            walletMap[wallet].nonFungibleBalanceByType[_type].set(\n                value, currencyCt, currencyId\n            );\n\n        // Update balance type hashes\n        _updateTrackedBalanceTypes(_type);\n\n        // Update tracked wallets\n        _updateTrackedWallets(wallet);\n    }\n\n    /// @notice Set the non-fungible balance IDs of the given wallet, type and currency to the given value\n    /// @param wallet The address of the concerned wallet\n    /// @param _type The balance type\n    /// @param ids The ids of non-fungible) to set\n    /// @param currencyCt The address of the concerned currency contract (address(0) == ETH)\n    /// @param currencyId The ID of the concerned currency (0 for ETH and ERC20)\n    function setIds(address wallet, bytes32 _type, int256[] memory ids, address currencyCt, uint256 currencyId)\n    public\n    onlyActiveService\n    {\n        // Update the balance\n        walletMap[wallet].nonFungibleBalanceByType[_type].set(\n            ids, currencyCt, currencyId\n        );\n\n        // Update balance type hashes\n        _updateTrackedBalanceTypes(_type);\n\n        // Update tracked wallets\n        _updateTrackedWallets(wallet);\n    }\n\n    /// @notice Add the given value to the balance of the given wallet, type and currency\n    /// @param wallet The address of the concerned wallet\n    /// @param _type The balance type\n    /// @param value The value (amount of fungible, id of non-fungible) to add\n    /// @param currencyCt The address of the concerned currency contract (address(0) == ETH)\n    /// @param currencyId The ID of the concerned currency (0 for ETH and ERC20)\n    /// @param fungible True if adding fungible balance, else false\n    function add(address wallet, bytes32 _type, int256 value, address currencyCt, uint256 currencyId,\n        bool fungible)\n    public\n    onlyActiveService\n    {\n        // Update the balance\n        if (fungible)\n            walletMap[wallet].fungibleBalanceByType[_type].add(\n                value, currencyCt, currencyId\n            );\n        else\n            walletMap[wallet].nonFungibleBalanceByType[_type].add(\n                value, currencyCt, currencyId\n            );\n\n        // Update balance type hashes\n        _updateTrackedBalanceTypes(_type);\n\n        // Update tracked wallets\n        _updateTrackedWallets(wallet);\n    }\n\n    /// @notice Subtract the given value from the balance of the given wallet, type and currency\n    /// @param wallet The address of the concerned wallet\n    /// @param _type The balance type\n    /// @param value The value (amount of fungible, id of non-fungible) to subtract\n    /// @param currencyCt The address of the concerned currency contract (address(0) == ETH)\n    /// @param currencyId The ID of the concerned currency (0 for ETH and ERC20)\n    /// @param fungible True if subtracting fungible balance, else false\n    function sub(address wallet, bytes32 _type, int256 value, address currencyCt, uint256 currencyId,\n        bool fungible)\n    public\n    onlyActiveService\n    {\n        // Update the balance\n        if (fungible)\n            walletMap[wallet].fungibleBalanceByType[_type].sub(\n                value, currencyCt, currencyId\n            );\n        else\n            walletMap[wallet].nonFungibleBalanceByType[_type].sub(\n                value, currencyCt, currencyId\n            );\n\n        // Update tracked wallets\n        _updateTrackedWallets(wallet);\n    }\n\n    /// @notice Gauge whether this tracker has in-use data for the given wallet, type and currency\n    /// @param wallet The address of the concerned wallet\n    /// @param _type The balance type\n    /// @param currencyCt The address of the concerned currency contract (address(0) == ETH)\n    /// @param currencyId The ID of the concerned currency (0 for ETH and ERC20)\n    /// @return true if data is stored, else false\n    function hasInUseCurrency(address wallet, bytes32 _type, address currencyCt, uint256 currencyId)\n    public\n    view\n    returns (bool)\n    {\n        return walletMap[wallet].fungibleBalanceByType[_type].hasInUseCurrency(currencyCt, currencyId)\n        || walletMap[wallet].nonFungibleBalanceByType[_type].hasInUseCurrency(currencyCt, currencyId);\n    }\n\n    /// @notice Gauge whether this tracker has ever-used data for the given wallet, type and currency\n    /// @param wallet The address of the concerned wallet\n    /// @param _type The balance type\n    /// @param currencyCt The address of the concerned currency contract (address(0) == ETH)\n    /// @param currencyId The ID of the concerned currency (0 for ETH and ERC20)\n    /// @return true if data is stored, else false\n    function hasEverUsedCurrency(address wallet, bytes32 _type, address currencyCt, uint256 currencyId)\n    public\n    view\n    returns (bool)\n    {\n        return walletMap[wallet].fungibleBalanceByType[_type].hasEverUsedCurrency(currencyCt, currencyId)\n        || walletMap[wallet].nonFungibleBalanceByType[_type].hasEverUsedCurrency(currencyCt, currencyId);\n    }\n\n    /// @notice Get the count of fungible balance records for the given wallet, type and currency\n    /// @param wallet The address of the concerned wallet\n    /// @param _type The balance type\n    /// @param currencyCt The address of the concerned currency contract (address(0) == ETH)\n    /// @param currencyId The ID of the concerned currency (0 for ETH and ERC20)\n    /// @return The count of balance log entries\n    function fungibleRecordsCount(address wallet, bytes32 _type, address currencyCt, uint256 currencyId)\n    public\n    view\n    returns (uint256)\n    {\n        return walletMap[wallet].fungibleBalanceByType[_type].recordsCount(currencyCt, currencyId);\n    }\n\n    /// @notice Get the fungible balance record for the given wallet, type, currency\n    /// log entry index\n    /// @param wallet The address of the concerned wallet\n    /// @param _type The balance type\n    /// @param currencyCt The address of the concerned currency contract (address(0) == ETH)\n    /// @param currencyId The ID of the concerned currency (0 for ETH and ERC20)\n    /// @param index The concerned record index\n    /// @return The balance record\n    function fungibleRecordByIndex(address wallet, bytes32 _type, address currencyCt, uint256 currencyId,\n        uint256 index)\n    public\n    view\n    returns (int256 amount, uint256 blockNumber)\n    {\n        return walletMap[wallet].fungibleBalanceByType[_type].recordByIndex(currencyCt, currencyId, index);\n    }\n\n    /// @notice Get the non-fungible balance record for the given wallet, type, currency\n    /// block number\n    /// @param wallet The address of the concerned wallet\n    /// @param _type The balance type\n    /// @param currencyCt The address of the concerned currency contract (address(0) == ETH)\n    /// @param currencyId The ID of the concerned currency (0 for ETH and ERC20)\n    /// @param _blockNumber The concerned block number\n    /// @return The balance record\n    function fungibleRecordByBlockNumber(address wallet, bytes32 _type, address currencyCt, uint256 currencyId,\n        uint256 _blockNumber)\n    public\n    view\n    returns (int256 amount, uint256 blockNumber)\n    {\n        return walletMap[wallet].fungibleBalanceByType[_type].recordByBlockNumber(currencyCt, currencyId, _blockNumber);\n    }\n\n    /// @notice Get the last (most recent) non-fungible balance record for the given wallet, type and currency\n    /// @param wallet The address of the concerned wallet\n    /// @param _type The balance type\n    /// @param currencyCt The address of the concerned currency contract (address(0) == ETH)\n    /// @param currencyId The ID of the concerned currency (0 for ETH and ERC20)\n    /// @return The last log entry\n    function lastFungibleRecord(address wallet, bytes32 _type, address currencyCt, uint256 currencyId)\n    public\n    view\n    returns (int256 amount, uint256 blockNumber)\n    {\n        return walletMap[wallet].fungibleBalanceByType[_type].lastRecord(currencyCt, currencyId);\n    }\n\n    /// @notice Get the count of non-fungible balance records for the given wallet, type and currency\n    /// @param wallet The address of the concerned wallet\n    /// @param _type The balance type\n    /// @param currencyCt The address of the concerned currency contract (address(0) == ETH)\n    /// @param currencyId The ID of the concerned currency (0 for ETH and ERC20)\n    /// @return The count of balance log entries\n    function nonFungibleRecordsCount(address wallet, bytes32 _type, address currencyCt, uint256 currencyId)\n    public\n    view\n    returns (uint256)\n    {\n        return walletMap[wallet].nonFungibleBalanceByType[_type].recordsCount(currencyCt, currencyId);\n    }\n\n    /// @notice Get the non-fungible balance record for the given wallet, type, currency\n    /// and record index\n    /// @param wallet The address of the concerned wallet\n    /// @param _type The balance type\n    /// @param currencyCt The address of the concerned currency contract (address(0) == ETH)\n    /// @param currencyId The ID of the concerned currency (0 for ETH and ERC20)\n    /// @param index The concerned record index\n    /// @return The balance record\n    function nonFungibleRecordByIndex(address wallet, bytes32 _type, address currencyCt, uint256 currencyId,\n        uint256 index)\n    public\n    view\n    returns (int256[] memory ids, uint256 blockNumber)\n    {\n        return walletMap[wallet].nonFungibleBalanceByType[_type].recordByIndex(currencyCt, currencyId, index);\n    }\n\n    /// @notice Get the non-fungible balance record for the given wallet, type, currency\n    /// and block number\n    /// @param wallet The address of the concerned wallet\n    /// @param _type The balance type\n    /// @param currencyCt The address of the concerned currency contract (address(0) == ETH)\n    /// @param currencyId The ID of the concerned currency (0 for ETH and ERC20)\n    /// @param _blockNumber The concerned block number\n    /// @return The balance record\n    function nonFungibleRecordByBlockNumber(address wallet, bytes32 _type, address currencyCt, uint256 currencyId,\n        uint256 _blockNumber)\n    public\n    view\n    returns (int256[] memory ids, uint256 blockNumber)\n    {\n        return walletMap[wallet].nonFungibleBalanceByType[_type].recordByBlockNumber(currencyCt, currencyId, _blockNumber);\n    }\n\n    /// @notice Get the last (most recent) non-fungible balance record for the given wallet, type and currency\n    /// @param wallet The address of the concerned wallet\n    /// @param _type The balance type\n    /// @param currencyCt The address of the concerned currency contract (address(0) == ETH)\n    /// @param currencyId The ID of the concerned currency (0 for ETH and ERC20)\n    /// @return The last log entry\n    function lastNonFungibleRecord(address wallet, bytes32 _type, address currencyCt, uint256 currencyId)\n    public\n    view\n    returns (int256[] memory ids, uint256 blockNumber)\n    {\n        return walletMap[wallet].nonFungibleBalanceByType[_type].lastRecord(currencyCt, currencyId);\n    }\n\n    /// @notice Get the count of tracked balance types\n    /// @return The count of tracked balance types\n    function trackedBalanceTypesCount()\n    public\n    view\n    returns (uint256)\n    {\n        return trackedBalanceTypes.length;\n    }\n\n    /// @notice Get the count of tracked wallets\n    /// @return The count of tracked wallets\n    function trackedWalletsCount()\n    public\n    view\n    returns (uint256)\n    {\n        return trackedWallets.length;\n    }\n\n    /// @notice Get the default full set of balance types\n    /// @return The set of all balance types\n    function allBalanceTypes()\n    public\n    view\n    returns (bytes32[] memory)\n    {\n        return _allBalanceTypes;\n    }\n\n    /// @notice Get the default set of active balance types\n    /// @return The set of active balance types\n    function activeBalanceTypes()\n    public\n    view\n    returns (bytes32[] memory)\n    {\n        return _activeBalanceTypes;\n    }\n\n    /// @notice Get the subset of tracked wallets in the given index range\n    /// @param low The lower index\n    /// @param up The upper index\n    /// @return The subset of tracked wallets\n    function trackedWalletsByIndices(uint256 low, uint256 up)\n    public\n    view\n    returns (address[] memory)\n    {\n        require(0 < trackedWallets.length, \"No tracked wallets found [BalanceTracker.sol:473]\");\n        require(low <= up, \"Bounds parameters mismatch [BalanceTracker.sol:474]\");\n\n        up = up.clampMax(trackedWallets.length - 1);\n        address[] memory _trackedWallets = new address[](up - low + 1);\n        for (uint256 i = low; i <= up; i++)\n            _trackedWallets[i - low] = trackedWallets[i];\n\n        return _trackedWallets;\n    }\n\n    //\n    // Private functions\n    // -----------------------------------------------------------------------------------------------------------------\n    function _updateTrackedBalanceTypes(bytes32 _type)\n    private\n    {\n        if (!trackedBalanceTypeMap[_type]) {\n            trackedBalanceTypeMap[_type] = true;\n            trackedBalanceTypes.push(_type);\n        }\n    }\n\n    function _updateTrackedWallets(address wallet)\n    private\n    {\n        if (0 == trackedWalletIndexByWallet[wallet]) {\n            trackedWallets.push(wallet);\n            trackedWalletIndexByWallet[wallet] = trackedWallets.length;\n        }\n    }\n}\n\n/*\n * Hubii Nahmii\n *\n * Compliant with the Hubii Nahmii specification v0.12.\n *\n * Copyright (C) 2017-2018 Hubii AS\n */\n\n/**\n * @title BalanceTrackable\n * @notice An ownable that has a balance tracker property\n */\ncontract BalanceTrackable is Ownable {\n    //\n    // Variables\n    // -----------------------------------------------------------------------------------------------------------------\n    BalanceTracker public balanceTracker;\n    bool public balanceTrackerFrozen;\n\n    //\n    // Events\n    // -----------------------------------------------------------------------------------------------------------------\n    event SetBalanceTrackerEvent(BalanceTracker oldBalanceTracker, BalanceTracker newBalanceTracker);\n    event FreezeBalanceTrackerEvent();\n\n    //\n    // Functions\n    // -----------------------------------------------------------------------------------------------------------------\n    /// @notice Set the balance tracker contract\n    /// @param newBalanceTracker The (address of) BalanceTracker contract instance\n    function setBalanceTracker(BalanceTracker newBalanceTracker)\n    public\n    onlyDeployer\n    notNullAddress(address(newBalanceTracker))\n    notSameAddresses(address(newBalanceTracker), address(balanceTracker))\n    {\n        // Require that this contract has not been frozen\n        require(!balanceTrackerFrozen, \"Balance tracker frozen [BalanceTrackable.sol:43]\");\n\n        // Update fields\n        BalanceTracker oldBalanceTracker = balanceTracker;\n        balanceTracker = newBalanceTracker;\n\n        // Emit event\n        emit SetBalanceTrackerEvent(oldBalanceTracker, newBalanceTracker);\n    }\n\n    /// @notice Freeze the balance tracker from further updates\n    /// @dev This operation can not be undone\n    function freezeBalanceTracker()\n    public\n    onlyDeployer\n    {\n        balanceTrackerFrozen = true;\n\n        // Emit event\n        emit FreezeBalanceTrackerEvent();\n    }\n\n    //\n    // Modifiers\n    // -----------------------------------------------------------------------------------------------------------------\n    modifier balanceTrackerInitialized() {\n        require(address(balanceTracker) != address(0), \"Balance tracker not initialized [BalanceTrackable.sol:69]\");\n        _;\n    }\n}\n\n/*\n * Hubii Nahmii\n *\n * Compliant with the Hubii Nahmii specification v0.12.\n *\n * Copyright (C) 2017-2018 Hubii AS\n */\n\n/**\n * @title Beneficiary\n * @notice A recipient of ethers and tokens\n */\ncontract Beneficiary {\n    /// @notice Receive ethers to the given wallet's given balance type\n    /// @param wallet The address of the concerned wallet\n    /// @param balanceType The target balance type of the wallet\n    function receiveEthersTo(address wallet, string memory balanceType)\n    public\n    payable;\n\n    /// @notice Receive token to the given wallet's given balance type\n    /// @dev The wallet must approve of the token transfer prior to calling this function\n    /// @param wallet The address of the concerned wallet\n    /// @param balanceType The target balance type of the wallet\n    /// @param amount The amount to deposit\n    /// @param currencyCt The address of the concerned currency contract (address(0) == ETH)\n    /// @param currencyId The ID of the concerned currency (0 for ETH and ERC20)\n    /// @param standard The standard of the token (\"\" for default registered, \"ERC20\", \"ERC721\")\n    function receiveTokensTo(address wallet, string memory balanceType, int256 amount, address currencyCt,\n        uint256 currencyId, string memory standard)\n    public;\n}\n\n/*\n * Hubii Nahmii\n *\n * Compliant with the Hubii Nahmii specification v0.12.\n *\n * Copyright (C) 2017-2018 Hubii AS\n */\n\n/**\n * @title AccrualBeneficiary\n * @notice A beneficiary of accruals\n */\ncontract AccrualBeneficiary is Beneficiary {\n    //\n    // Functions\n    // -----------------------------------------------------------------------------------------------------------------\n    event CloseAccrualPeriodEvent();\n\n    //\n    // Functions\n    // -----------------------------------------------------------------------------------------------------------------\n    function closeAccrualPeriod(MonetaryTypesLib.Currency[] memory)\n    public\n    {\n        emit CloseAccrualPeriodEvent();\n    }\n}\n\n/*\n * Hubii Nahmii\n *\n * Compliant with the Hubii Nahmii specification v0.12.\n *\n * Copyright (C) 2017-2018 Hubii AS\n */\n\n/**\n * @title TransferController\n * @notice A base contract to handle transfers of different currency types\n */\ncontract TransferController {\n    //\n    // Events\n    // -----------------------------------------------------------------------------------------------------------------\n    event CurrencyTransferred(address from, address to, uint256 value,\n        address currencyCt, uint256 currencyId);\n\n    //\n    // Functions\n    // -----------------------------------------------------------------------------------------------------------------\n    function isFungible()\n    public\n    view\n    returns (bool);\n\n    function standard()\n    public\n    view\n    returns (string memory);\n\n    /// @notice MUST be called with DELEGATECALL\n    function receive(address from, address to, uint256 value, address currencyCt, uint256 currencyId)\n    public;\n\n    /// @notice MUST be called with DELEGATECALL\n    function approve(address to, uint256 value, address currencyCt, uint256 currencyId)\n    public;\n\n    /// @notice MUST be called with DELEGATECALL\n    function dispatch(address from, address to, uint256 value, address currencyCt, uint256 currencyId)\n    public;\n\n    //----------------------------------------\n\n    function getReceiveSignature()\n    public\n    pure\n    returns (bytes4)\n    {\n        return bytes4(keccak256(\"receive(address,address,uint256,address,uint256)\"));\n    }\n\n    function getApproveSignature()\n    public\n    pure\n    returns (bytes4)\n    {\n        return bytes4(keccak256(\"approve(address,uint256,address,uint256)\"));\n    }\n\n    function getDispatchSignature()\n    public\n    pure\n    returns (bytes4)\n    {\n        return bytes4(keccak256(\"dispatch(address,address,uint256,address,uint256)\"));\n    }\n}\n\n/*\n * Hubii Nahmii\n *\n * Compliant with the Hubii Nahmii specification v0.12.\n *\n * Copyright (C) 2017-2018 Hubii AS\n */\n\n/**\n * @title TransferControllerManager\n * @notice Handles the management of transfer controllers\n */\ncontract TransferControllerManager is Ownable {\n    //\n    // Constants\n    // -----------------------------------------------------------------------------------------------------------------\n    struct CurrencyInfo {\n        bytes32 standard;\n        bool blacklisted;\n    }\n\n    //\n    // Variables\n    // -----------------------------------------------------------------------------------------------------------------\n    mapping(bytes32 => address) public registeredTransferControllers;\n    mapping(address => CurrencyInfo) public registeredCurrencies;\n\n    //\n    // Events\n    // -----------------------------------------------------------------------------------------------------------------\n    event RegisterTransferControllerEvent(string standard, address controller);\n    event ReassociateTransferControllerEvent(string oldStandard, string newStandard, address controller);\n\n    event RegisterCurrencyEvent(address currencyCt, string standard);\n    event DeregisterCurrencyEvent(address currencyCt);\n    event BlacklistCurrencyEvent(address currencyCt);\n    event WhitelistCurrencyEvent(address currencyCt);\n\n    //\n    // Constructor\n    // -----------------------------------------------------------------------------------------------------------------\n    constructor(address deployer) Ownable(deployer) public {\n    }\n\n    //\n    // Functions\n    // -----------------------------------------------------------------------------------------------------------------\n    function registerTransferController(string calldata standard, address controller)\n    external\n    onlyDeployer\n    notNullAddress(controller)\n    {\n        require(bytes(standard).length > 0, \"Empty standard not supported [TransferControllerManager.sol:58]\");\n        bytes32 standardHash = keccak256(abi.encodePacked(standard));\n\n        registeredTransferControllers[standardHash] = controller;\n\n        // Emit event\n        emit RegisterTransferControllerEvent(standard, controller);\n    }\n\n    function reassociateTransferController(string calldata oldStandard, string calldata newStandard, address controller)\n    external\n    onlyDeployer\n    notNullAddress(controller)\n    {\n        require(bytes(newStandard).length > 0, \"Empty new standard not supported [TransferControllerManager.sol:72]\");\n        bytes32 oldStandardHash = keccak256(abi.encodePacked(oldStandard));\n        bytes32 newStandardHash = keccak256(abi.encodePacked(newStandard));\n\n        require(registeredTransferControllers[oldStandardHash] != address(0), \"Old standard not registered [TransferControllerManager.sol:76]\");\n        require(registeredTransferControllers[newStandardHash] == address(0), \"New standard previously registered [TransferControllerManager.sol:77]\");\n\n        registeredTransferControllers[newStandardHash] = registeredTransferControllers[oldStandardHash];\n        registeredTransferControllers[oldStandardHash] = address(0);\n\n        // Emit event\n        emit ReassociateTransferControllerEvent(oldStandard, newStandard, controller);\n    }\n\n    function registerCurrency(address currencyCt, string calldata standard)\n    external\n    onlyOperator\n    notNullAddress(currencyCt)\n    {\n        require(bytes(standard).length > 0, \"Empty standard not supported [TransferControllerManager.sol:91]\");\n        bytes32 standardHash = keccak256(abi.encodePacked(standard));\n\n        require(registeredCurrencies[currencyCt].standard == bytes32(0), \"Currency previously registered [TransferControllerManager.sol:94]\");\n\n        registeredCurrencies[currencyCt].standard = standardHash;\n\n        // Emit event\n        emit RegisterCurrencyEvent(currencyCt, standard);\n    }\n\n    function deregisterCurrency(address currencyCt)\n    external\n    onlyOperator\n    {\n        require(registeredCurrencies[currencyCt].standard != 0, \"Currency not registered [TransferControllerManager.sol:106]\");\n\n        registeredCurrencies[currencyCt].standard = bytes32(0);\n        registeredCurrencies[currencyCt].blacklisted = false;\n\n        // Emit event\n        emit DeregisterCurrencyEvent(currencyCt);\n    }\n\n    function blacklistCurrency(address currencyCt)\n    external\n    onlyOperator\n    {\n        require(registeredCurrencies[currencyCt].standard != bytes32(0), \"Currency not registered [TransferControllerManager.sol:119]\");\n\n        registeredCurrencies[currencyCt].blacklisted = true;\n\n        // Emit event\n        emit BlacklistCurrencyEvent(currencyCt);\n    }\n\n    function whitelistCurrency(address currencyCt)\n    external\n    onlyOperator\n    {\n        require(registeredCurrencies[currencyCt].standard != bytes32(0), \"Currency not registered [TransferControllerManager.sol:131]\");\n\n        registeredCurrencies[currencyCt].blacklisted = false;\n\n        // Emit event\n        emit WhitelistCurrencyEvent(currencyCt);\n    }\n\n    /**\n    @notice The provided standard takes priority over assigned interface to currency\n    */\n    function transferController(address currencyCt, string memory standard)\n    public\n    view\n    returns (TransferController)\n    {\n        if (bytes(standard).length > 0) {\n            bytes32 standardHash = keccak256(abi.encodePacked(standard));\n\n            require(registeredTransferControllers[standardHash] != address(0), \"Standard not registered [TransferControllerManager.sol:150]\");\n            return TransferController(registeredTransferControllers[standardHash]);\n        }\n\n        require(registeredCurrencies[currencyCt].standard != bytes32(0), \"Currency not registered [TransferControllerManager.sol:154]\");\n        require(!registeredCurrencies[currencyCt].blacklisted, \"Currency blacklisted [TransferControllerManager.sol:155]\");\n\n        address controllerAddress = registeredTransferControllers[registeredCurrencies[currencyCt].standard];\n        require(controllerAddress != address(0), \"No matching transfer controller [TransferControllerManager.sol:158]\");\n\n        return TransferController(controllerAddress);\n    }\n}\n\n/*\n * Hubii Nahmii\n *\n * Compliant with the Hubii Nahmii specification v0.12.\n *\n * Copyright (C) 2017-2018 Hubii AS\n */\n\n/**\n * @title TransferControllerManageable\n * @notice An ownable with a transfer controller manager\n */\ncontract TransferControllerManageable is Ownable {\n    //\n    // Variables\n    // -----------------------------------------------------------------------------------------------------------------\n    TransferControllerManager public transferControllerManager;\n\n    //\n    // Events\n    // -----------------------------------------------------------------------------------------------------------------\n    event SetTransferControllerManagerEvent(TransferControllerManager oldTransferControllerManager,\n        TransferControllerManager newTransferControllerManager);\n\n    //\n    // Functions\n    // -----------------------------------------------------------------------------------------------------------------\n    /// @notice Set the currency manager contract\n    /// @param newTransferControllerManager The (address of) TransferControllerManager contract instance\n    function setTransferControllerManager(TransferControllerManager newTransferControllerManager)\n    public\n    onlyDeployer\n    notNullAddress(address(newTransferControllerManager))\n    notSameAddresses(address(newTransferControllerManager), address(transferControllerManager))\n    {\n        //set new currency manager\n        TransferControllerManager oldTransferControllerManager = transferControllerManager;\n        transferControllerManager = newTransferControllerManager;\n\n        // Emit event\n        emit SetTransferControllerManagerEvent(oldTransferControllerManager, newTransferControllerManager);\n    }\n\n    /// @notice Get the transfer controller of the given currency contract address and standard\n    function transferController(address currencyCt, string memory standard)\n    internal\n    view\n    returns (TransferController)\n    {\n        return transferControllerManager.transferController(currencyCt, standard);\n    }\n\n    //\n    // Modifiers\n    // -----------------------------------------------------------------------------------------------------------------\n    modifier transferControllerManagerInitialized() {\n        require(address(transferControllerManager) != address(0), \"Transfer controller manager not initialized [TransferControllerManageable.sol:63]\");\n        _;\n    }\n}\n\n/*\n * Hubii Nahmii\n *\n * Compliant with the Hubii Nahmii specification v0.12.\n *\n * Copyright (C) 2017-2018 Hubii AS\n */\n\nlibrary TxHistoryLib {\n    //\n    // Structures\n    // -----------------------------------------------------------------------------------------------------------------\n    struct AssetEntry {\n        int256 amount;\n        uint256 blockNumber;\n        address currencyCt;      //0 for ethers\n        uint256 currencyId;\n    }\n\n    struct TxHistory {\n        AssetEntry[] deposits;\n        mapping(address => mapping(uint256 => AssetEntry[])) currencyDeposits;\n\n        AssetEntry[] withdrawals;\n        mapping(address => mapping(uint256 => AssetEntry[])) currencyWithdrawals;\n    }\n\n    //\n    // Functions\n    // -----------------------------------------------------------------------------------------------------------------\n    function addDeposit(TxHistory storage self, int256 amount, address currencyCt, uint256 currencyId)\n    internal\n    {\n        AssetEntry memory deposit = AssetEntry(amount, block.number, currencyCt, currencyId);\n        self.deposits.push(deposit);\n        self.currencyDeposits[currencyCt][currencyId].push(deposit);\n    }\n\n    function addWithdrawal(TxHistory storage self, int256 amount, address currencyCt, uint256 currencyId)\n    internal\n    {\n        AssetEntry memory withdrawal = AssetEntry(amount, block.number, currencyCt, currencyId);\n        self.withdrawals.push(withdrawal);\n        self.currencyWithdrawals[currencyCt][currencyId].push(withdrawal);\n    }\n\n    //----\n\n    function deposit(TxHistory storage self, uint index)\n    internal\n    view\n    returns (int256 amount, uint256 blockNumber, address currencyCt, uint256 currencyId)\n    {\n        require(index < self.deposits.length, \"Index ouf of bounds [TxHistoryLib.sol:56]\");\n\n        amount = self.deposits[index].amount;\n        blockNumber = self.deposits[index].blockNumber;\n        currencyCt = self.deposits[index].currencyCt;\n        currencyId = self.deposits[index].currencyId;\n    }\n\n    function depositsCount(TxHistory storage self)\n    internal\n    view\n    returns (uint256)\n    {\n        return self.deposits.length;\n    }\n\n    function currencyDeposit(TxHistory storage self, address currencyCt, uint256 currencyId, uint index)\n    internal\n    view\n    returns (int256 amount, uint256 blockNumber)\n    {\n        require(index < self.currencyDeposits[currencyCt][currencyId].length, \"Index out of bounds [TxHistoryLib.sol:77]\");\n\n        amount = self.currencyDeposits[currencyCt][currencyId][index].amount;\n        blockNumber = self.currencyDeposits[currencyCt][currencyId][index].blockNumber;\n    }\n\n    function currencyDepositsCount(TxHistory storage self, address currencyCt, uint256 currencyId)\n    internal\n    view\n    returns (uint256)\n    {\n        return self.currencyDeposits[currencyCt][currencyId].length;\n    }\n\n    //----\n\n    function withdrawal(TxHistory storage self, uint index)\n    internal\n    view\n    returns (int256 amount, uint256 blockNumber, address currencyCt, uint256 currencyId)\n    {\n        require(index < self.withdrawals.length, \"Index out of bounds [TxHistoryLib.sol:98]\");\n\n        amount = self.withdrawals[index].amount;\n        blockNumber = self.withdrawals[index].blockNumber;\n        currencyCt = self.withdrawals[index].currencyCt;\n        currencyId = self.withdrawals[index].currencyId;\n    }\n\n    function withdrawalsCount(TxHistory storage self)\n    internal\n    view\n    returns (uint256)\n    {\n        return self.withdrawals.length;\n    }\n\n    function currencyWithdrawal(TxHistory storage self, address currencyCt, uint256 currencyId, uint index)\n    internal\n    view\n    returns (int256 amount, uint256 blockNumber)\n    {\n        require(index < self.currencyWithdrawals[currencyCt][currencyId].length, \"Index out of bounds [TxHistoryLib.sol:119]\");\n\n        amount = self.currencyWithdrawals[currencyCt][currencyId][index].amount;\n        blockNumber = self.currencyWithdrawals[currencyCt][currencyId][index].blockNumber;\n    }\n\n    function currencyWithdrawalsCount(TxHistory storage self, address currencyCt, uint256 currencyId)\n    internal\n    view\n    returns (uint256)\n    {\n        return self.currencyWithdrawals[currencyCt][currencyId].length;\n    }\n}\n\n/*\n * Hubii Nahmii\n *\n * Compliant with the Hubii Nahmii specification v0.12.\n *\n * Copyright (C) 2017-2018 Hubii AS\n */\n\n/**\n * @title SecurityBond\n * @notice Fund that contains crypto incentive for challenging operator fraud.\n */\ncontract SecurityBond is Ownable, Configurable, AccrualBeneficiary, Servable, TransferControllerManageable {\n    using SafeMathIntLib for int256;\n    using SafeMathUintLib for uint256;\n    using FungibleBalanceLib for FungibleBalanceLib.Balance;\n    using TxHistoryLib for TxHistoryLib.TxHistory;\n    using CurrenciesLib for CurrenciesLib.Currencies;\n\n    //\n    // Constants\n    // -----------------------------------------------------------------------------------------------------------------\n    string constant public REWARD_ACTION = \"reward\";\n    string constant public DEPRIVE_ACTION = \"deprive\";\n\n    //\n    // Types\n    // -----------------------------------------------------------------------------------------------------------------\n    struct FractionalReward {\n        uint256 fraction;\n        uint256 nonce;\n        uint256 unlockTime;\n    }\n\n    struct AbsoluteReward {\n        int256 amount;\n        uint256 nonce;\n        uint256 unlockTime;\n    }\n\n    //\n    // Variables\n    // -----------------------------------------------------------------------------------------------------------------\n    FungibleBalanceLib.Balance private deposited;\n    TxHistoryLib.TxHistory private txHistory;\n    CurrenciesLib.Currencies private inUseCurrencies;\n\n    mapping(address => FractionalReward) public fractionalRewardByWallet;\n\n    mapping(address => mapping(address => mapping(uint256 => AbsoluteReward))) public absoluteRewardByWallet;\n\n    mapping(address => mapping(address => mapping(uint256 => uint256))) public claimNonceByWalletCurrency;\n\n    mapping(address => FungibleBalanceLib.Balance) private stagedByWallet;\n\n    mapping(address => uint256) public nonceByWallet;\n\n    //\n    // Events\n    // -----------------------------------------------------------------------------------------------------------------\n    event ReceiveEvent(address from, int256 amount, address currencyCt, uint256 currencyId);\n    event RewardFractionalEvent(address wallet, uint256 fraction, uint256 unlockTimeoutInSeconds);\n    event RewardAbsoluteEvent(address wallet, int256 amount, address currencyCt, uint256 currencyId,\n        uint256 unlockTimeoutInSeconds);\n    event DepriveFractionalEvent(address wallet);\n    event DepriveAbsoluteEvent(address wallet, address currencyCt, uint256 currencyId);\n    event ClaimAndTransferToBeneficiaryEvent(address from, Beneficiary beneficiary, string balanceType, int256 amount,\n        address currencyCt, uint256 currencyId, string standard);\n    event ClaimAndStageEvent(address from, int256 amount, address currencyCt, uint256 currencyId);\n    event WithdrawEvent(address from, int256 amount, address currencyCt, uint256 currencyId, string standard);\n\n    //\n    // Constructor\n    // -----------------------------------------------------------------------------------------------------------------\n    constructor(address deployer) Ownable(deployer) Servable() public {\n    }\n\n    //\n    // Functions\n    // -----------------------------------------------------------------------------------------------------------------\n    /// @notice Fallback function that deposits ethers\n    function() external payable {\n        receiveEthersTo(msg.sender, \"\");\n    }\n\n    /// @notice Receive ethers to\n    /// @param wallet The concerned wallet address\n    function receiveEthersTo(address wallet, string memory)\n    public\n    payable\n    {\n        int256 amount = SafeMathIntLib.toNonZeroInt256(msg.value);\n\n        // Add to balance\n        deposited.add(amount, address(0), 0);\n        txHistory.addDeposit(amount, address(0), 0);\n\n        // Add currency to in-use list\n        inUseCurrencies.add(address(0), 0);\n\n        // Emit event\n        emit ReceiveEvent(wallet, amount, address(0), 0);\n    }\n\n    /// @notice Receive tokens\n    /// @param amount The concerned amount\n    /// @param currencyCt The address of the concerned currency contract (address(0) == ETH)\n    /// @param currencyId The ID of the concerned currency (0 for ETH and ERC20)\n    /// @param standard The standard of token (\"ERC20\", \"ERC721\")\n    function receiveTokens(string memory, int256 amount, address currencyCt,\n        uint256 currencyId, string memory standard)\n    public\n    {\n        receiveTokensTo(msg.sender, \"\", amount, currencyCt, currencyId, standard);\n    }\n\n    /// @notice Receive tokens to\n    /// @param wallet The address of the concerned wallet\n    /// @param amount The concerned amount\n    /// @param currencyCt The address of the concerned currency contract (address(0) == ETH)\n    /// @param currencyId The ID of the concerned currency (0 for ETH and ERC20)\n    /// @param standard The standard of token (\"ERC20\", \"ERC721\")\n    function receiveTokensTo(address wallet, string memory, int256 amount, address currencyCt,\n        uint256 currencyId, string memory standard)\n    public\n    {\n        require(amount.isNonZeroPositiveInt256(), \"Amount not strictly positive [SecurityBond.sol:145]\");\n\n        // Execute transfer\n        TransferController controller = transferController(currencyCt, standard);\n        (bool success,) = address(controller).delegatecall(\n            abi.encodeWithSelector(\n                controller.getReceiveSignature(), msg.sender, this, uint256(amount), currencyCt, currencyId\n            )\n        );\n        require(success, \"Reception by controller failed [SecurityBond.sol:154]\");\n\n        // Add to balance\n        deposited.add(amount, currencyCt, currencyId);\n        txHistory.addDeposit(amount, currencyCt, currencyId);\n\n        // Add currency to in-use list\n        inUseCurrencies.add(currencyCt, currencyId);\n\n        // Emit event\n        emit ReceiveEvent(wallet, amount, currencyCt, currencyId);\n    }\n\n    /// @notice Get the count of deposits\n    /// @return The count of deposits\n    function depositsCount()\n    public\n    view\n    returns (uint256)\n    {\n        return txHistory.depositsCount();\n    }\n\n    /// @notice Get the deposit at the given index\n    /// @return The deposit at the given index\n    function deposit(uint index)\n    public\n    view\n    returns (int256 amount, uint256 blockNumber, address currencyCt, uint256 currencyId)\n    {\n        return txHistory.deposit(index);\n    }\n\n    /// @notice Get the deposited balance of the given currency\n    /// @param currencyCt The address of the concerned currency contract (address(0) == ETH)\n    /// @param currencyId The ID of the concerned currency (0 for ETH and ERC20)\n    /// @return The deposited balance\n    function depositedBalance(address currencyCt, uint256 currencyId)\n    public\n    view\n    returns (int256)\n    {\n        return deposited.get(currencyCt, currencyId);\n    }\n\n    /// @notice Get the fractional amount deposited balance of the given currency\n    /// @param currencyCt The contract address of the currency that the wallet is deprived\n    /// @param currencyId The ID of the currency that the wallet is deprived\n    /// @param fraction The fraction of sums that the wallet is rewarded\n    /// @return The fractional amount of deposited balance\n    function depositedFractionalBalance(address currencyCt, uint256 currencyId, uint256 fraction)\n    public\n    view\n    returns (int256)\n    {\n        return deposited.get(currencyCt, currencyId)\n        .mul(SafeMathIntLib.toInt256(fraction))\n        .div(ConstantsLib.PARTS_PER());\n    }\n\n    /// @notice Get the staged balance of the given currency\n    /// @param currencyCt The address of the concerned currency contract (address(0) == ETH)\n    /// @param currencyId The ID of the concerned currency (0 for ETH and ERC20)\n    /// @return The deposited balance\n    function stagedBalance(address wallet, address currencyCt, uint256 currencyId)\n    public\n    view\n    returns (int256)\n    {\n        return stagedByWallet[wallet].get(currencyCt, currencyId);\n    }\n\n    /// @notice Get the count of currencies recorded\n    /// @return The number of currencies\n    function inUseCurrenciesCount()\n    public\n    view\n    returns (uint256)\n    {\n        return inUseCurrencies.count();\n    }\n\n    /// @notice Get the currencies recorded with indices in the given range\n    /// @param low The lower currency index\n    /// @param up The upper currency index\n    /// @return The currencies of the given index range\n    function inUseCurrenciesByIndices(uint256 low, uint256 up)\n    public\n    view\n    returns (MonetaryTypesLib.Currency[] memory)\n    {\n        return inUseCurrencies.getByIndices(low, up);\n    }\n\n    /// @notice Reward the given wallet the given fraction of funds, where the reward is locked\n    /// for the given number of seconds\n    /// @param wallet The concerned wallet\n    /// @param fraction The fraction of sums that the wallet is rewarded\n    /// @param unlockTimeoutInSeconds The number of seconds for which the reward is locked and should\n    /// be claimed\n    function rewardFractional(address wallet, uint256 fraction, uint256 unlockTimeoutInSeconds)\n    public\n    notNullAddress(wallet)\n    onlyEnabledServiceAction(REWARD_ACTION)\n    {\n        // Update fractional reward\n        fractionalRewardByWallet[wallet].fraction = fraction.clampMax(uint256(ConstantsLib.PARTS_PER()));\n        fractionalRewardByWallet[wallet].nonce = ++nonceByWallet[wallet];\n        fractionalRewardByWallet[wallet].unlockTime = block.timestamp.add(unlockTimeoutInSeconds);\n\n        // Emit event\n        emit RewardFractionalEvent(wallet, fraction, unlockTimeoutInSeconds);\n    }\n\n    /// @notice Reward the given wallet the given amount of funds, where the reward is locked\n    /// for the given number of seconds\n    /// @param wallet The concerned wallet\n    /// @param amount The amount that the wallet is rewarded\n    /// @param currencyCt The contract address of the currency that the wallet is rewarded\n    /// @param currencyId The ID of the currency that the wallet is rewarded\n    /// @param unlockTimeoutInSeconds The number of seconds for which the reward is locked and should\n    /// be claimed\n    function rewardAbsolute(address wallet, int256 amount, address currencyCt, uint256 currencyId,\n        uint256 unlockTimeoutInSeconds)\n    public\n    notNullAddress(wallet)\n    onlyEnabledServiceAction(REWARD_ACTION)\n    {\n        // Update absolute reward\n        absoluteRewardByWallet[wallet][currencyCt][currencyId].amount = amount;\n        absoluteRewardByWallet[wallet][currencyCt][currencyId].nonce = ++nonceByWallet[wallet];\n        absoluteRewardByWallet[wallet][currencyCt][currencyId].unlockTime = block.timestamp.add(unlockTimeoutInSeconds);\n\n        // Emit event\n        emit RewardAbsoluteEvent(wallet, amount, currencyCt, currencyId, unlockTimeoutInSeconds);\n    }\n\n    /// @notice Deprive the given wallet of any fractional reward it has been granted\n    /// @param wallet The concerned wallet\n    function depriveFractional(address wallet)\n    public\n    onlyEnabledServiceAction(DEPRIVE_ACTION)\n    {\n        // Update fractional reward\n        fractionalRewardByWallet[wallet].fraction = 0;\n        fractionalRewardByWallet[wallet].nonce = ++nonceByWallet[wallet];\n        fractionalRewardByWallet[wallet].unlockTime = 0;\n\n        // Emit event\n        emit DepriveFractionalEvent(wallet);\n    }\n\n    /// @notice Deprive the given wallet of any absolute reward it has been granted in the given currency\n    /// @param wallet The concerned wallet\n    /// @param currencyCt The contract address of the currency that the wallet is deprived\n    /// @param currencyId The ID of the currency that the wallet is deprived\n    function depriveAbsolute(address wallet, address currencyCt, uint256 currencyId)\n    public\n    onlyEnabledServiceAction(DEPRIVE_ACTION)\n    {\n        // Update absolute reward\n        absoluteRewardByWallet[wallet][currencyCt][currencyId].amount = 0;\n        absoluteRewardByWallet[wallet][currencyCt][currencyId].nonce = ++nonceByWallet[wallet];\n        absoluteRewardByWallet[wallet][currencyCt][currencyId].unlockTime = 0;\n\n        // Emit event\n        emit DepriveAbsoluteEvent(wallet, currencyCt, currencyId);\n    }\n\n    /// @notice Claim reward and transfer to beneficiary\n    /// @param beneficiary The concerned beneficiary\n    /// @param balanceType The target balance type\n    /// @param currencyCt The address of the concerned currency contract (address(0) == ETH)\n    /// @param currencyId The ID of the concerned currency (0 for ETH and ERC20)\n    /// @param standard The standard of the token (\"\" for default registered, \"ERC20\", \"ERC721\")\n    function claimAndTransferToBeneficiary(Beneficiary beneficiary, string memory balanceType, address currencyCt,\n        uint256 currencyId, string memory standard)\n    public\n    {\n        // Claim reward\n        int256 claimedAmount = _claim(msg.sender, currencyCt, currencyId);\n\n        // Subtract from deposited balance\n        deposited.sub(claimedAmount, currencyCt, currencyId);\n\n        // Execute transfer\n        if (address(0) == currencyCt && 0 == currencyId)\n            beneficiary.receiveEthersTo.value(uint256(claimedAmount))(msg.sender, balanceType);\n\n        else {\n            TransferController controller = transferController(currencyCt, standard);\n            (bool success,) = address(controller).delegatecall(\n                abi.encodeWithSelector(\n                    controller.getApproveSignature(), address(beneficiary), uint256(claimedAmount), currencyCt, currencyId\n                )\n            );\n            require(success, \"Approval by controller failed [SecurityBond.sol:350]\");\n            beneficiary.receiveTokensTo(msg.sender, balanceType, claimedAmount, currencyCt, currencyId, standard);\n        }\n\n        // Emit event\n        emit ClaimAndTransferToBeneficiaryEvent(msg.sender, beneficiary, balanceType, claimedAmount, currencyCt, currencyId, standard);\n    }\n\n    /// @notice Claim reward and stage for later withdrawal\n    /// @param currencyCt The address of the concerned currency contract (address(0) == ETH)\n    /// @param currencyId The ID of the concerned currency (0 for ETH and ERC20)\n    function claimAndStage(address currencyCt, uint256 currencyId)\n    public\n    {\n        // Claim reward\n        int256 claimedAmount = _claim(msg.sender, currencyCt, currencyId);\n\n        // Subtract from deposited balance\n        deposited.sub(claimedAmount, currencyCt, currencyId);\n\n        // Add to staged balance\n        stagedByWallet[msg.sender].add(claimedAmount, currencyCt, currencyId);\n\n        // Emit event\n        emit ClaimAndStageEvent(msg.sender, claimedAmount, currencyCt, currencyId);\n    }\n\n    /// @notice Withdraw from staged balance of msg.sender\n    /// @param amount The concerned amount\n    /// @param currencyCt The address of the concerned currency contract (address(0) == ETH)\n    /// @param currencyId The ID of the concerned currency (0 for ETH and ERC20)\n    /// @param standard The standard of the token (\"\" for default registered, \"ERC20\", \"ERC721\")\n    function withdraw(int256 amount, address currencyCt, uint256 currencyId, string memory standard)\n    public\n    {\n        // Require that amount is strictly positive\n        require(amount.isNonZeroPositiveInt256(), \"Amount not strictly positive [SecurityBond.sol:386]\");\n\n        // Clamp amount to the max given by staged balance\n        amount = amount.clampMax(stagedByWallet[msg.sender].get(currencyCt, currencyId));\n\n        // Subtract to per-wallet staged balance\n        stagedByWallet[msg.sender].sub(amount, currencyCt, currencyId);\n\n        // Execute transfer\n        if (address(0) == currencyCt && 0 == currencyId)\n            msg.sender.transfer(uint256(amount));\n\n        else {\n            TransferController controller = transferController(currencyCt, standard);\n            (bool success,) = address(controller).delegatecall(\n                abi.encodeWithSelector(\n                    controller.getDispatchSignature(), address(this), msg.sender, uint256(amount), currencyCt, currencyId\n                )\n            );\n            require(success, \"Dispatch by controller failed [SecurityBond.sol:405]\");\n        }\n\n        // Emit event\n        emit WithdrawEvent(msg.sender, amount, currencyCt, currencyId, standard);\n    }\n\n    //\n    // Private functions\n    // -----------------------------------------------------------------------------------------------------------------\n    function _claim(address wallet, address currencyCt, uint256 currencyId)\n    private\n    returns (int256)\n    {\n        // Combine claim nonce from rewards\n        uint256 claimNonce = fractionalRewardByWallet[wallet].nonce.clampMin(\n            absoluteRewardByWallet[wallet][currencyCt][currencyId].nonce\n        );\n\n        // Require that new claim nonce is strictly greater than current stored one\n        require(\n            claimNonce > claimNonceByWalletCurrency[wallet][currencyCt][currencyId],\n            \"Claim nonce not strictly greater than previously claimed nonce [SecurityBond.sol:425]\"\n        );\n\n        // Combine claim amount from rewards\n        int256 claimAmount = _fractionalRewardAmountByWalletCurrency(wallet, currencyCt, currencyId).add(\n            _absoluteRewardAmountByWalletCurrency(wallet, currencyCt, currencyId)\n        ).clampMax(\n            deposited.get(currencyCt, currencyId)\n        );\n\n        // Require that claim amount is strictly positive, indicating that there is an amount to claim\n        require(claimAmount.isNonZeroPositiveInt256(), \"Claim amount not strictly positive [SecurityBond.sol:438]\");\n\n        // Update stored claim nonce for wallet and currency\n        claimNonceByWalletCurrency[wallet][currencyCt][currencyId] = claimNonce;\n\n        return claimAmount;\n    }\n\n    function _fractionalRewardAmountByWalletCurrency(address wallet, address currencyCt, uint256 currencyId)\n    private\n    view\n    returns (int256)\n    {\n        if (\n            claimNonceByWalletCurrency[wallet][currencyCt][currencyId] < fractionalRewardByWallet[wallet].nonce &&\n            block.timestamp >= fractionalRewardByWallet[wallet].unlockTime\n        )\n            return deposited.get(currencyCt, currencyId)\n            .mul(SafeMathIntLib.toInt256(fractionalRewardByWallet[wallet].fraction))\n            .div(ConstantsLib.PARTS_PER());\n\n        else\n            return 0;\n    }\n\n    function _absoluteRewardAmountByWalletCurrency(address wallet, address currencyCt, uint256 currencyId)\n    private\n    view\n    returns (int256)\n    {\n        if (\n            claimNonceByWalletCurrency[wallet][currencyCt][currencyId] < absoluteRewardByWallet[wallet][currencyCt][currencyId].nonce &&\n            block.timestamp >= absoluteRewardByWallet[wallet][currencyCt][currencyId].unlockTime\n        )\n            return absoluteRewardByWallet[wallet][currencyCt][currencyId].amount.clampMax(\n                deposited.get(currencyCt, currencyId)\n            );\n\n        else\n            return 0;\n    }\n}\n\n/*\n * Hubii Nahmii\n *\n * Compliant with the Hubii Nahmii specification v0.12.\n *\n * Copyright (C) 2017-2018 Hubii AS\n */\n\n/**\n * @title SecurityBondable\n * @notice An ownable that has a security bond property\n */\ncontract SecurityBondable is Ownable {\n    //\n    // Variables\n    // -----------------------------------------------------------------------------------------------------------------\n    SecurityBond public securityBond;\n\n    //\n    // Events\n    // -----------------------------------------------------------------------------------------------------------------\n    event SetSecurityBondEvent(SecurityBond oldSecurityBond, SecurityBond newSecurityBond);\n\n    //\n    // Functions\n    // -----------------------------------------------------------------------------------------------------------------\n    /// @notice Set the security bond contract\n    /// @param newSecurityBond The (address of) SecurityBond contract instance\n    function setSecurityBond(SecurityBond newSecurityBond)\n    public\n    onlyDeployer\n    notNullAddress(address(newSecurityBond))\n    notSameAddresses(address(newSecurityBond), address(securityBond))\n    {\n        //set new security bond\n        SecurityBond oldSecurityBond = securityBond;\n        securityBond = newSecurityBond;\n\n        // Emit event\n        emit SetSecurityBondEvent(oldSecurityBond, newSecurityBond);\n    }\n\n    //\n    // Modifiers\n    // -----------------------------------------------------------------------------------------------------------------\n    modifier securityBondInitialized() {\n        require(address(securityBond) != address(0), \"Security bond not initialized [SecurityBondable.sol:52]\");\n        _;\n    }\n}\n\n/*\n * Hubii Nahmii\n *\n * Compliant with the Hubii Nahmii specification v0.12.\n *\n * Copyright (C) 2017-2018 Hubii AS\n */\n\n/**\n * @title FraudChallenge\n * @notice Where fraud challenge results are found\n */\ncontract FraudChallenge is Ownable, Servable {\n    //\n    // Constants\n    // -----------------------------------------------------------------------------------------------------------------\n    string constant public ADD_SEIZED_WALLET_ACTION = \"add_seized_wallet\";\n    string constant public ADD_DOUBLE_SPENDER_WALLET_ACTION = \"add_double_spender_wallet\";\n    string constant public ADD_FRAUDULENT_ORDER_ACTION = \"add_fraudulent_order\";\n    string constant public ADD_FRAUDULENT_TRADE_ACTION = \"add_fraudulent_trade\";\n    string constant public ADD_FRAUDULENT_PAYMENT_ACTION = \"add_fraudulent_payment\";\n\n    //\n    // Variables\n    // -----------------------------------------------------------------------------------------------------------------\n    address[] public doubleSpenderWallets;\n    mapping(address => bool) public doubleSpenderByWallet;\n\n    bytes32[] public fraudulentOrderHashes;\n    mapping(bytes32 => bool) public fraudulentByOrderHash;\n\n    bytes32[] public fraudulentTradeHashes;\n    mapping(bytes32 => bool) public fraudulentByTradeHash;\n\n    bytes32[] public fraudulentPaymentHashes;\n    mapping(bytes32 => bool) public fraudulentByPaymentHash;\n\n    //\n    // Events\n    // -----------------------------------------------------------------------------------------------------------------\n    event AddDoubleSpenderWalletEvent(address wallet);\n    event AddFraudulentOrderHashEvent(bytes32 hash);\n    event AddFraudulentTradeHashEvent(bytes32 hash);\n    event AddFraudulentPaymentHashEvent(bytes32 hash);\n\n    //\n    // Constructor\n    // -----------------------------------------------------------------------------------------------------------------\n    constructor(address deployer) Ownable(deployer) public {\n    }\n\n    //\n    // Functions\n    // -----------------------------------------------------------------------------------------------------------------\n    /// @notice Get the double spender status of given wallet\n    /// @param wallet The wallet address for which to check double spender status\n    /// @return true if wallet is double spender, false otherwise\n    function isDoubleSpenderWallet(address wallet)\n    public\n    view\n    returns (bool)\n    {\n        return doubleSpenderByWallet[wallet];\n    }\n\n    /// @notice Get the number of wallets tagged as double spenders\n    /// @return Number of double spender wallets\n    function doubleSpenderWalletsCount()\n    public\n    view\n    returns (uint256)\n    {\n        return doubleSpenderWallets.length;\n    }\n\n    /// @notice Add given wallets to store of double spender wallets if not already present\n    /// @param wallet The first wallet to add\n    function addDoubleSpenderWallet(address wallet)\n    public\n    onlyEnabledServiceAction(ADD_DOUBLE_SPENDER_WALLET_ACTION) {\n        if (!doubleSpenderByWallet[wallet]) {\n            doubleSpenderWallets.push(wallet);\n            doubleSpenderByWallet[wallet] = true;\n            emit AddDoubleSpenderWalletEvent(wallet);\n        }\n    }\n\n    /// @notice Get the number of fraudulent order hashes\n    function fraudulentOrderHashesCount()\n    public\n    view\n    returns (uint256)\n    {\n        return fraudulentOrderHashes.length;\n    }\n\n    /// @notice Get the state about whether the given hash equals the hash of a fraudulent order\n    /// @param hash The hash to be tested\n    function isFraudulentOrderHash(bytes32 hash)\n    public\n    view returns (bool) {\n        return fraudulentByOrderHash[hash];\n    }\n\n    /// @notice Add given order hash to store of fraudulent order hashes if not already present\n    function addFraudulentOrderHash(bytes32 hash)\n    public\n    onlyEnabledServiceAction(ADD_FRAUDULENT_ORDER_ACTION)\n    {\n        if (!fraudulentByOrderHash[hash]) {\n            fraudulentByOrderHash[hash] = true;\n            fraudulentOrderHashes.push(hash);\n            emit AddFraudulentOrderHashEvent(hash);\n        }\n    }\n\n    /// @notice Get the number of fraudulent trade hashes\n    function fraudulentTradeHashesCount()\n    public\n    view\n    returns (uint256)\n    {\n        return fraudulentTradeHashes.length;\n    }\n\n    /// @notice Get the state about whether the given hash equals the hash of a fraudulent trade\n    /// @param hash The hash to be tested\n    /// @return true if hash is the one of a fraudulent trade, else false\n    function isFraudulentTradeHash(bytes32 hash)\n    public\n    view\n    returns (bool)\n    {\n        return fraudulentByTradeHash[hash];\n    }\n\n    /// @notice Add given trade hash to store of fraudulent trade hashes if not already present\n    function addFraudulentTradeHash(bytes32 hash)\n    public\n    onlyEnabledServiceAction(ADD_FRAUDULENT_TRADE_ACTION)\n    {\n        if (!fraudulentByTradeHash[hash]) {\n            fraudulentByTradeHash[hash] = true;\n            fraudulentTradeHashes.push(hash);\n            emit AddFraudulentTradeHashEvent(hash);\n        }\n    }\n\n    /// @notice Get the number of fraudulent payment hashes\n    function fraudulentPaymentHashesCount()\n    public\n    view\n    returns (uint256)\n    {\n        return fraudulentPaymentHashes.length;\n    }\n\n    /// @notice Get the state about whether the given hash equals the hash of a fraudulent payment\n    /// @param hash The hash to be tested\n    /// @return true if hash is the one of a fraudulent payment, else null\n    function isFraudulentPaymentHash(bytes32 hash)\n    public\n    view\n    returns (bool)\n    {\n        return fraudulentByPaymentHash[hash];\n    }\n\n    /// @notice Add given payment hash to store of fraudulent payment hashes if not already present\n    function addFraudulentPaymentHash(bytes32 hash)\n    public\n    onlyEnabledServiceAction(ADD_FRAUDULENT_PAYMENT_ACTION)\n    {\n        if (!fraudulentByPaymentHash[hash]) {\n            fraudulentByPaymentHash[hash] = true;\n            fraudulentPaymentHashes.push(hash);\n            emit AddFraudulentPaymentHashEvent(hash);\n        }\n    }\n}\n\n/*\n * Hubii Nahmii\n *\n * Compliant with the Hubii Nahmii specification v0.12.\n *\n * Copyright (C) 2017-2018 Hubii AS\n */\n\n/**\n * @title FraudChallengable\n * @notice An ownable that has a fraud challenge property\n */\ncontract FraudChallengable is Ownable {\n    //\n    // Variables\n    // -----------------------------------------------------------------------------------------------------------------\n    FraudChallenge public fraudChallenge;\n\n    //\n    // Events\n    // -----------------------------------------------------------------------------------------------------------------\n    event SetFraudChallengeEvent(FraudChallenge oldFraudChallenge, FraudChallenge newFraudChallenge);\n\n    //\n    // Functions\n    // -----------------------------------------------------------------------------------------------------------------\n    /// @notice Set the fraud challenge contract\n    /// @param newFraudChallenge The (address of) FraudChallenge contract instance\n    function setFraudChallenge(FraudChallenge newFraudChallenge)\n    public\n    onlyDeployer\n    notNullAddress(address(newFraudChallenge))\n    notSameAddresses(address(newFraudChallenge), address(fraudChallenge))\n    {\n        // Set new fraud challenge\n        FraudChallenge oldFraudChallenge = fraudChallenge;\n        fraudChallenge = newFraudChallenge;\n\n        // Emit event\n        emit SetFraudChallengeEvent(oldFraudChallenge, newFraudChallenge);\n    }\n\n    //\n    // Modifiers\n    // -----------------------------------------------------------------------------------------------------------------\n    modifier fraudChallengeInitialized() {\n        require(address(fraudChallenge) != address(0), \"Fraud challenge not initialized [FraudChallengable.sol:52]\");\n        _;\n    }\n}\n\n/*\n * Hubii Nahmii\n *\n * Compliant with the Hubii Nahmii specification v0.12.\n *\n * Copyright (C) 2017-2018 Hubii AS\n */\n\n/**\n * @title     SettlementChallengeTypesLib\n * @dev       Types for settlement challenges\n */\nlibrary SettlementChallengeTypesLib {\n    //\n    // Structures\n    // -----------------------------------------------------------------------------------------------------------------\n    enum Status {Qualified, Disqualified}\n\n    struct Proposal {\n        address wallet;\n        uint256 nonce;\n        uint256 referenceBlockNumber;\n        uint256 definitionBlockNumber;\n\n        uint256 expirationTime;\n\n        // Status\n        Status status;\n\n        // Amounts\n        Amounts amounts;\n\n        // Currency\n        MonetaryTypesLib.Currency currency;\n\n        // Info on challenged driip\n        Driip challenged;\n\n        // True is equivalent to reward coming from wallet's balance\n        bool walletInitiated;\n\n        // True if proposal has been terminated\n        bool terminated;\n\n        // Disqualification\n        Disqualification disqualification;\n    }\n\n    struct Amounts {\n        // Cumulative (relative) transfer info\n        int256 cumulativeTransfer;\n\n        // Stage info\n        int256 stage;\n\n        // Balances after amounts have been staged\n        int256 targetBalance;\n    }\n\n    struct Driip {\n        // Kind (\"payment\", \"trade\", ...)\n        string kind;\n\n        // Hash (of operator)\n        bytes32 hash;\n    }\n\n    struct Disqualification {\n        // Challenger\n        address challenger;\n        uint256 nonce;\n        uint256 blockNumber;\n\n        // Info on candidate driip\n        Driip candidate;\n    }\n}\n\n/*\n * Hubii Nahmii\n *\n * Compliant with the Hubii Nahmii specification v0.12.\n *\n * Copyright (C) 2017-2018 Hubii AS\n */\n\n/**\n * @title DriipSettlementChallengeState\n * @notice Where driip settlement challenge state is managed\n */\ncontract DriipSettlementChallengeState is Ownable, Servable, Configurable {\n    using SafeMathIntLib for int256;\n    using SafeMathUintLib for uint256;\n\n    //\n    // Constants\n    // -----------------------------------------------------------------------------------------------------------------\n    string constant public INITIATE_PROPOSAL_ACTION = \"initiate_proposal\";\n    string constant public TERMINATE_PROPOSAL_ACTION = \"terminate_proposal\";\n    string constant public REMOVE_PROPOSAL_ACTION = \"remove_proposal\";\n    string constant public DISQUALIFY_PROPOSAL_ACTION = \"disqualify_proposal\";\n    string constant public QUALIFY_PROPOSAL_ACTION = \"qualify_proposal\";\n\n    //\n    // Variables\n    // -----------------------------------------------------------------------------------------------------------------\n    SettlementChallengeTypesLib.Proposal[] public proposals;\n    mapping(address => mapping(address => mapping(uint256 => uint256))) public proposalIndexByWalletCurrency;\n    mapping(address => mapping(uint256 => mapping(address => mapping(uint256 => uint256)))) public proposalIndexByWalletNonceCurrency;\n\n    //\n    // Events\n    // -----------------------------------------------------------------------------------------------------------------\n    event InitiateProposalEvent(address wallet, uint256 nonce, int256 cumulativeTransferAmount, int256 stageAmount,\n        int256 targetBalanceAmount, MonetaryTypesLib.Currency currency, uint256 blockNumber, bool walletInitiated,\n        bytes32 challengedHash, string challengedKind);\n    event TerminateProposalEvent(address wallet, uint256 nonce, int256 cumulativeTransferAmount, int256 stageAmount,\n        int256 targetBalanceAmount, MonetaryTypesLib.Currency currency, uint256 blockNumber, bool walletInitiated,\n        bytes32 challengedHash, string challengedKind);\n    event RemoveProposalEvent(address wallet, uint256 nonce, int256 cumulativeTransferAmount, int256 stageAmount,\n        int256 targetBalanceAmount, MonetaryTypesLib.Currency currency, uint256 blockNumber, bool walletInitiated,\n        bytes32 challengedHash, string challengedKind);\n    event DisqualifyProposalEvent(address challengedWallet, uint256 challengedNonce, int256 cumulativeTransferAmount,\n        int256 stageAmount, int256 targetBalanceAmount, MonetaryTypesLib.Currency currency, uint256 blockNumber,\n        bool walletInitiated, address challengerWallet, uint256 candidateNonce, bytes32 candidateHash,\n        string candidateKind);\n    event QualifyProposalEvent(address challengedWallet, uint256 challengedNonce, int256 cumulativeTransferAmount,\n        int256 stageAmount, int256 targetBalanceAmount, MonetaryTypesLib.Currency currency, uint256 blockNumber,\n        bool walletInitiated, address challengerWallet, uint256 candidateNonce, bytes32 candidateHash,\n        string candidateKind);\n\n    //\n    // Constructor\n    // -----------------------------------------------------------------------------------------------------------------\n    constructor(address deployer) Ownable(deployer) public {\n    }\n\n    //\n    // Functions\n    // -----------------------------------------------------------------------------------------------------------------\n    /// @notice Get the number of proposals\n    /// @return The number of proposals\n    function proposalsCount()\n    public\n    view\n    returns (uint256)\n    {\n        return proposals.length;\n    }\n\n    /// @notice Initiate proposal\n    /// @param wallet The address of the concerned challenged wallet\n    /// @param nonce The wallet nonce\n    /// @param cumulativeTransferAmount The proposal cumulative transfer amount\n    /// @param stageAmount The proposal stage amount\n    /// @param targetBalanceAmount The proposal target balance amount\n    /// @param currency The concerned currency\n    /// @param blockNumber The proposal block number\n    /// @param walletInitiated True if reward from candidate balance\n    /// @param challengedHash The candidate driip hash\n    /// @param challengedKind The candidate driip kind\n    function initiateProposal(address wallet, uint256 nonce, int256 cumulativeTransferAmount, int256 stageAmount,\n        int256 targetBalanceAmount, MonetaryTypesLib.Currency memory currency, uint256 blockNumber, bool walletInitiated,\n        bytes32 challengedHash, string memory challengedKind)\n    public\n    onlyEnabledServiceAction(INITIATE_PROPOSAL_ACTION)\n    {\n        // Initiate proposal\n        _initiateProposal(\n            wallet, nonce, cumulativeTransferAmount, stageAmount, targetBalanceAmount,\n            currency, blockNumber, walletInitiated, challengedHash, challengedKind\n        );\n\n        // Emit event\n        emit InitiateProposalEvent(\n            wallet, nonce, cumulativeTransferAmount, stageAmount, targetBalanceAmount, currency,\n            blockNumber, walletInitiated, challengedHash, challengedKind\n        );\n    }\n\n    /// @notice Terminate a proposal\n    /// @param wallet The address of the concerned challenged wallet\n    /// @param currency The concerned currency\n    function terminateProposal(address wallet, MonetaryTypesLib.Currency memory currency, bool clearNonce)\n    public\n    onlyEnabledServiceAction(TERMINATE_PROPOSAL_ACTION)\n    {\n        // Get the proposal index\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n\n        // Return gracefully if there is no proposal to terminate\n        if (0 == index)\n            return;\n\n        // Clear wallet-nonce-currency triplet entry, which enables reinitiation of proposal for that triplet\n        if (clearNonce)\n            proposalIndexByWalletNonceCurrency[wallet][proposals[index - 1].nonce][currency.ct][currency.id] = 0;\n\n        // Terminate proposal\n        proposals[index - 1].terminated = true;\n\n        // Emit event\n        emit TerminateProposalEvent(\n            wallet, proposals[index - 1].nonce, proposals[index - 1].amounts.cumulativeTransfer,\n            proposals[index - 1].amounts.stage, proposals[index - 1].amounts.targetBalance, currency,\n            proposals[index - 1].referenceBlockNumber, proposals[index - 1].walletInitiated,\n            proposals[index - 1].challenged.hash, proposals[index - 1].challenged.kind\n        );\n    }\n\n    /// @notice Terminate a proposal\n    /// @param wallet The address of the concerned challenged wallet\n    /// @param currency The concerned currency\n    /// @param clearNonce Clear wallet-nonce-currency triplet entry\n    /// @param walletTerminated True if wallet terminated\n    function terminateProposal(address wallet, MonetaryTypesLib.Currency memory currency, bool clearNonce,\n        bool walletTerminated)\n    public\n    onlyEnabledServiceAction(TERMINATE_PROPOSAL_ACTION)\n    {\n        // Get the proposal index\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n\n        // Return gracefully if there is no proposal to terminate\n        if (0 == index)\n            return;\n\n        // Require that role that initialized (wallet or operator) can only cancel its own proposal\n        require(walletTerminated == proposals[index - 1].walletInitiated, \"Wallet initiation and termination mismatch [DriipSettlementChallengeState.sol:163]\");\n\n        // Clear wallet-nonce-currency triplet entry, which enables reinitiation of proposal for that triplet\n        if (clearNonce)\n            proposalIndexByWalletNonceCurrency[wallet][proposals[index - 1].nonce][currency.ct][currency.id] = 0;\n\n        // Terminate proposal\n        proposals[index - 1].terminated = true;\n\n        // Emit event\n        emit TerminateProposalEvent(\n            wallet, proposals[index - 1].nonce, proposals[index - 1].amounts.cumulativeTransfer,\n            proposals[index - 1].amounts.stage, proposals[index - 1].amounts.targetBalance, currency,\n            proposals[index - 1].referenceBlockNumber, proposals[index - 1].walletInitiated,\n            proposals[index - 1].challenged.hash, proposals[index - 1].challenged.kind\n        );\n    }\n\n    /// @notice Remove a proposal\n    /// @param wallet The address of the concerned challenged wallet\n    /// @param currency The concerned currency\n    function removeProposal(address wallet, MonetaryTypesLib.Currency memory currency)\n    public\n    onlyEnabledServiceAction(REMOVE_PROPOSAL_ACTION)\n    {\n        // Get the proposal index\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n\n        // Return gracefully if there is no proposal to remove\n        if (0 == index)\n            return;\n\n        // Emit event\n        emit RemoveProposalEvent(\n            wallet, proposals[index - 1].nonce, proposals[index - 1].amounts.cumulativeTransfer,\n            proposals[index - 1].amounts.stage, proposals[index - 1].amounts.targetBalance, currency,\n            proposals[index - 1].referenceBlockNumber, proposals[index - 1].walletInitiated,\n            proposals[index - 1].challenged.hash, proposals[index - 1].challenged.kind\n        );\n\n        // Remove proposal\n        _removeProposal(index);\n    }\n\n    /// @notice Remove a proposal\n    /// @param wallet The address of the concerned challenged wallet\n    /// @param currency The concerned currency\n    /// @param walletTerminated True if wallet terminated\n    function removeProposal(address wallet, MonetaryTypesLib.Currency memory currency, bool walletTerminated)\n    public\n    onlyEnabledServiceAction(REMOVE_PROPOSAL_ACTION)\n    {\n        // Get the proposal index\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n\n        // Return gracefully if there is no proposal to remove\n        if (0 == index)\n            return;\n\n        // Require that role that initialized (wallet or operator) can only cancel its own proposal\n        require(walletTerminated == proposals[index - 1].walletInitiated, \"Wallet initiation and termination mismatch [DriipSettlementChallengeState.sol:223]\");\n\n        // Emit event\n        emit RemoveProposalEvent(\n            wallet, proposals[index - 1].nonce, proposals[index - 1].amounts.cumulativeTransfer,\n            proposals[index - 1].amounts.stage, proposals[index - 1].amounts.targetBalance, currency,\n            proposals[index - 1].referenceBlockNumber, proposals[index - 1].walletInitiated,\n            proposals[index - 1].challenged.hash, proposals[index - 1].challenged.kind\n        );\n\n        // Remove proposal\n        _removeProposal(index);\n    }\n\n    /// @notice Disqualify a proposal\n    /// @dev A call to this function will intentionally override previous disqualifications if existent\n    /// @param challengedWallet The address of the concerned challenged wallet\n    /// @param currency The concerned currency\n    /// @param challengerWallet The address of the concerned challenger wallet\n    /// @param blockNumber The disqualification block number\n    /// @param candidateNonce The candidate nonce\n    /// @param candidateHash The candidate hash\n    /// @param candidateKind The candidate kind\n    function disqualifyProposal(address challengedWallet, MonetaryTypesLib.Currency memory currency, address challengerWallet,\n        uint256 blockNumber, uint256 candidateNonce, bytes32 candidateHash, string memory candidateKind)\n    public\n    onlyEnabledServiceAction(DISQUALIFY_PROPOSAL_ACTION)\n    {\n        // Get the proposal index\n        uint256 index = proposalIndexByWalletCurrency[challengedWallet][currency.ct][currency.id];\n        require(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:253]\");\n\n        // Update proposal\n        proposals[index - 1].status = SettlementChallengeTypesLib.Status.Disqualified;\n        proposals[index - 1].expirationTime = block.timestamp.add(configuration.settlementChallengeTimeout());\n        proposals[index - 1].disqualification.challenger = challengerWallet;\n        proposals[index - 1].disqualification.nonce = candidateNonce;\n        proposals[index - 1].disqualification.blockNumber = blockNumber;\n        proposals[index - 1].disqualification.candidate.hash = candidateHash;\n        proposals[index - 1].disqualification.candidate.kind = candidateKind;\n\n        // Emit event\n        emit DisqualifyProposalEvent(\n            challengedWallet, proposals[index - 1].nonce, proposals[index - 1].amounts.cumulativeTransfer,\n            proposals[index - 1].amounts.stage, proposals[index - 1].amounts.targetBalance,\n            currency, proposals[index - 1].referenceBlockNumber, proposals[index - 1].walletInitiated,\n            challengerWallet, candidateNonce, candidateHash, candidateKind\n        );\n    }\n\n    /// @notice (Re)Qualify a proposal\n    /// @param wallet The address of the concerned challenged wallet\n    /// @param currency The concerned currency\n    function qualifyProposal(address wallet, MonetaryTypesLib.Currency memory currency)\n    public\n    onlyEnabledServiceAction(QUALIFY_PROPOSAL_ACTION)\n    {\n        // Get the proposal index\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n        require(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:282]\");\n\n        // Emit event\n        emit QualifyProposalEvent(\n            wallet, proposals[index - 1].nonce, proposals[index - 1].amounts.cumulativeTransfer,\n            proposals[index - 1].amounts.stage, proposals[index - 1].amounts.targetBalance, currency,\n            proposals[index - 1].referenceBlockNumber, proposals[index - 1].walletInitiated,\n            proposals[index - 1].disqualification.challenger,\n            proposals[index - 1].disqualification.nonce,\n            proposals[index - 1].disqualification.candidate.hash,\n            proposals[index - 1].disqualification.candidate.kind\n        );\n\n        // Update proposal\n        proposals[index - 1].status = SettlementChallengeTypesLib.Status.Qualified;\n        proposals[index - 1].expirationTime = block.timestamp.add(configuration.settlementChallengeTimeout());\n        delete proposals[index - 1].disqualification;\n    }\n\n    /// @notice Gauge whether a driip settlement challenge for the given wallet-nonce-currency\n    /// triplet has been proposed and not later removed\n    /// @param wallet The address of the concerned wallet\n    /// @param nonce The wallet nonce\n    /// @param currency The concerned currency\n    /// @return true if driip settlement challenge has been, else false\n    function hasProposal(address wallet, uint256 nonce, MonetaryTypesLib.Currency memory currency)\n    public\n    view\n    returns (bool)\n    {\n        // 1-based index\n        return 0 != proposalIndexByWalletNonceCurrency[wallet][nonce][currency.ct][currency.id];\n    }\n\n    /// @notice Gauge whether the proposal for the given wallet and currency has expired\n    /// @param wallet The address of the concerned wallet\n    /// @param currency The concerned currency\n    /// @return true if proposal has expired, else false\n    function hasProposal(address wallet, MonetaryTypesLib.Currency memory currency)\n    public\n    view\n    returns (bool)\n    {\n        // 1-based index\n        return 0 != proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n    }\n\n    /// @notice Gauge whether the proposal for the given wallet and currency has terminated\n    /// @param wallet The address of the concerned wallet\n    /// @param currency The concerned currency\n    /// @return true if proposal has terminated, else false\n    function hasProposalTerminated(address wallet, MonetaryTypesLib.Currency memory currency)\n    public\n    view\n    returns (bool)\n    {\n        // 1-based index\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n        require(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:340]\");\n        return proposals[index - 1].terminated;\n    }\n\n    /// @notice Gauge whether the proposal for the given wallet and currency has expired\n    /// @param wallet The address of the concerned wallet\n    /// @param currency The concerned currency\n    /// @return true if proposal has expired, else false\n    function hasProposalExpired(address wallet, MonetaryTypesLib.Currency memory currency)\n    public\n    view\n    returns (bool)\n    {\n        // 1-based index\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n        require(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:355]\");\n        return block.timestamp >= proposals[index - 1].expirationTime;\n    }\n\n    /// @notice Get the proposal nonce of the given wallet and currency\n    /// @param wallet The address of the concerned wallet\n    /// @param currency The concerned currency\n    /// @return The settlement proposal nonce\n    function proposalNonce(address wallet, MonetaryTypesLib.Currency memory currency)\n    public\n    view\n    returns (uint256)\n    {\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n        require(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:369]\");\n        return proposals[index - 1].nonce;\n    }\n\n    /// @notice Get the proposal reference block number of the given wallet and currency\n    /// @param wallet The address of the concerned wallet\n    /// @param currency The concerned currency\n    /// @return The settlement proposal reference block number\n    function proposalReferenceBlockNumber(address wallet, MonetaryTypesLib.Currency memory currency)\n    public\n    view\n    returns (uint256)\n    {\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n        require(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:383]\");\n        return proposals[index - 1].referenceBlockNumber;\n    }\n\n    /// @notice Get the proposal definition block number of the given wallet and currency\n    /// @param wallet The address of the concerned wallet\n    /// @param currency The concerned currency\n    /// @return The settlement proposal definition block number\n    function proposalDefinitionBlockNumber(address wallet, MonetaryTypesLib.Currency memory currency)\n    public\n    view\n    returns (uint256)\n    {\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n        require(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:397]\");\n        return proposals[index - 1].definitionBlockNumber;\n    }\n\n    /// @notice Get the proposal expiration time of the given wallet and currency\n    /// @param wallet The address of the concerned wallet\n    /// @param currency The concerned currency\n    /// @return The settlement proposal expiration time\n    function proposalExpirationTime(address wallet, MonetaryTypesLib.Currency memory currency)\n    public\n    view\n    returns (uint256)\n    {\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n        require(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:411]\");\n        return proposals[index - 1].expirationTime;\n    }\n\n    /// @notice Get the proposal status of the given wallet and currency\n    /// @param wallet The address of the concerned wallet\n    /// @param currency The concerned currency\n    /// @return The settlement proposal status\n    function proposalStatus(address wallet, MonetaryTypesLib.Currency memory currency)\n    public\n    view\n    returns (SettlementChallengeTypesLib.Status)\n    {\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n        require(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:425]\");\n        return proposals[index - 1].status;\n    }\n\n    /// @notice Get the proposal cumulative transfer amount of the given wallet and currency\n    /// @param wallet The address of the concerned wallet\n    /// @param currency The concerned currency\n    /// @return The settlement proposal cumulative transfer amount\n    function proposalCumulativeTransferAmount(address wallet, MonetaryTypesLib.Currency memory currency)\n    public\n    view\n    returns (int256)\n    {\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n        require(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:439]\");\n        return proposals[index - 1].amounts.cumulativeTransfer;\n    }\n\n    /// @notice Get the proposal stage amount of the given wallet and currency\n    /// @param wallet The address of the concerned wallet\n    /// @param currency The concerned currency\n    /// @return The settlement proposal stage amount\n    function proposalStageAmount(address wallet, MonetaryTypesLib.Currency memory currency)\n    public\n    view\n    returns (int256)\n    {\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n        require(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:453]\");\n        return proposals[index - 1].amounts.stage;\n    }\n\n    /// @notice Get the proposal target balance amount of the given wallet and currency\n    /// @param wallet The address of the concerned wallet\n    /// @param currency The concerned currency\n    /// @return The settlement proposal target balance amount\n    function proposalTargetBalanceAmount(address wallet, MonetaryTypesLib.Currency memory currency)\n    public\n    view\n    returns (int256)\n    {\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n        require(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:467]\");\n        return proposals[index - 1].amounts.targetBalance;\n    }\n\n    /// @notice Get the proposal challenged hash of the given wallet and currency\n    /// @param wallet The address of the concerned wallet\n    /// @param currency The concerned currency\n    /// @return The settlement proposal challenged hash\n    function proposalChallengedHash(address wallet, MonetaryTypesLib.Currency memory currency)\n    public\n    view\n    returns (bytes32)\n    {\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n        require(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:481]\");\n        return proposals[index - 1].challenged.hash;\n    }\n\n    /// @notice Get the proposal challenged kind of the given wallet and currency\n    /// @param wallet The address of the concerned wallet\n    /// @param currency The concerned currency\n    /// @return The settlement proposal challenged kind\n    function proposalChallengedKind(address wallet, MonetaryTypesLib.Currency memory currency)\n    public\n    view\n    returns (string memory)\n    {\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n        require(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:495]\");\n        return proposals[index - 1].challenged.kind;\n    }\n\n    /// @notice Get the proposal balance reward of the given wallet and currency\n    /// @param wallet The address of the concerned wallet\n    /// @param currency The concerned currency\n    /// @return The settlement proposal balance reward\n    function proposalWalletInitiated(address wallet, MonetaryTypesLib.Currency memory currency)\n    public\n    view\n    returns (bool)\n    {\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n        require(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:509]\");\n        return proposals[index - 1].walletInitiated;\n    }\n\n    /// @notice Get the proposal disqualification challenger of the given wallet and currency\n    /// @param wallet The address of the concerned wallet\n    /// @param currency The concerned currency\n    /// @return The settlement proposal disqualification challenger\n    function proposalDisqualificationChallenger(address wallet, MonetaryTypesLib.Currency memory currency)\n    public\n    view\n    returns (address)\n    {\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n        require(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:523]\");\n        return proposals[index - 1].disqualification.challenger;\n    }\n\n    /// @notice Get the proposal disqualification nonce of the given wallet and currency\n    /// @param wallet The address of the concerned wallet\n    /// @param currency The concerned currency\n    /// @return The settlement proposal disqualification nonce\n    function proposalDisqualificationNonce(address wallet, MonetaryTypesLib.Currency memory currency)\n    public\n    view\n    returns (uint256)\n    {\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n        require(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:537]\");\n        return proposals[index - 1].disqualification.nonce;\n    }\n\n    /// @notice Get the proposal disqualification block number of the given wallet and currency\n    /// @param wallet The address of the concerned wallet\n    /// @param currency The concerned currency\n    /// @return The settlement proposal disqualification block number\n    function proposalDisqualificationBlockNumber(address wallet, MonetaryTypesLib.Currency memory currency)\n    public\n    view\n    returns (uint256)\n    {\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n        require(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:551]\");\n        return proposals[index - 1].disqualification.blockNumber;\n    }\n\n    /// @notice Get the proposal disqualification candidate hash of the given wallet and currency\n    /// @param wallet The address of the concerned wallet\n    /// @param currency The concerned currency\n    /// @return The settlement proposal disqualification candidate hash\n    function proposalDisqualificationCandidateHash(address wallet, MonetaryTypesLib.Currency memory currency)\n    public\n    view\n    returns (bytes32)\n    {\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n        require(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:565]\");\n        return proposals[index - 1].disqualification.candidate.hash;\n    }\n\n    /// @notice Get the proposal disqualification candidate kind of the given wallet and currency\n    /// @param wallet The address of the concerned wallet\n    /// @param currency The concerned currency\n    /// @return The settlement proposal disqualification candidate kind\n    function proposalDisqualificationCandidateKind(address wallet, MonetaryTypesLib.Currency memory currency)\n    public\n    view\n    returns (string memory)\n    {\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n        require(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:579]\");\n        return proposals[index - 1].disqualification.candidate.kind;\n    }\n\n    //\n    // Private functions\n    // -----------------------------------------------------------------------------------------------------------------\n    function _initiateProposal(address wallet, uint256 nonce, int256 cumulativeTransferAmount, int256 stageAmount,\n        int256 targetBalanceAmount, MonetaryTypesLib.Currency memory currency, uint256 referenceBlockNumber, bool walletInitiated,\n        bytes32 challengedHash, string memory challengedKind)\n    private\n    {\n        // Require that there is no other proposal on the given wallet-nonce-currency triplet\n        require(\n            0 == proposalIndexByWalletNonceCurrency[wallet][nonce][currency.ct][currency.id],\n            \"Existing proposal found for wallet, nonce and currency [DriipSettlementChallengeState.sol:592]\"\n        );\n\n        // Require that stage and target balance amounts are positive\n        require(stageAmount.isPositiveInt256(), \"Stage amount not positive [DriipSettlementChallengeState.sol:598]\");\n        require(targetBalanceAmount.isPositiveInt256(), \"Target balance amount not positive [DriipSettlementChallengeState.sol:599]\");\n\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n\n        // Create proposal if needed\n        if (0 == index) {\n            index = ++(proposals.length);\n            proposalIndexByWalletCurrency[wallet][currency.ct][currency.id] = index;\n        }\n\n        // Populate proposal\n        proposals[index - 1].wallet = wallet;\n        proposals[index - 1].nonce = nonce;\n        proposals[index - 1].referenceBlockNumber = referenceBlockNumber;\n        proposals[index - 1].definitionBlockNumber = block.number;\n        proposals[index - 1].expirationTime = block.timestamp.add(configuration.settlementChallengeTimeout());\n        proposals[index - 1].status = SettlementChallengeTypesLib.Status.Qualified;\n        proposals[index - 1].currency = currency;\n        proposals[index - 1].amounts.cumulativeTransfer = cumulativeTransferAmount;\n        proposals[index - 1].amounts.stage = stageAmount;\n        proposals[index - 1].amounts.targetBalance = targetBalanceAmount;\n        proposals[index - 1].walletInitiated = walletInitiated;\n        proposals[index - 1].terminated = false;\n        proposals[index - 1].challenged.hash = challengedHash;\n        proposals[index - 1].challenged.kind = challengedKind;\n\n        // Update index of wallet-nonce-currency triplet\n        proposalIndexByWalletNonceCurrency[wallet][nonce][currency.ct][currency.id] = index;\n    }\n\n    function _removeProposal(uint256 index)\n    private\n    {\n        // Remove the proposal and clear references to it\n        proposalIndexByWalletCurrency[proposals[index - 1].wallet][proposals[index - 1].currency.ct][proposals[index - 1].currency.id] = 0;\n        proposalIndexByWalletNonceCurrency[proposals[index - 1].wallet][proposals[index - 1].nonce][proposals[index - 1].currency.ct][proposals[index - 1].currency.id] = 0;\n        if (index < proposals.length) {\n            proposals[index - 1] = proposals[proposals.length - 1];\n            proposalIndexByWalletCurrency[proposals[index - 1].wallet][proposals[index - 1].currency.ct][proposals[index - 1].currency.id] = index;\n            proposalIndexByWalletNonceCurrency[proposals[index - 1].wallet][proposals[index - 1].nonce][proposals[index - 1].currency.ct][proposals[index - 1].currency.id] = index;\n        }\n        proposals.length--;\n    }\n}\n\n/*\n * Hubii Nahmii\n *\n * Compliant with the Hubii Nahmii specification v0.12.\n *\n * Copyright (C) 2017-2018 Hubii AS\n */\n\n/**\n * @title NullSettlementChallengeState\n * @notice Where null settlements challenge state is managed\n */\ncontract NullSettlementChallengeState is Ownable, Servable, Configurable, BalanceTrackable {\n    using SafeMathIntLib for int256;\n    using SafeMathUintLib for uint256;\n\n    //\n    // Constants\n    // -----------------------------------------------------------------------------------------------------------------\n    string constant public INITIATE_PROPOSAL_ACTION = \"initiate_proposal\";\n    string constant public TERMINATE_PROPOSAL_ACTION = \"terminate_proposal\";\n    string constant public REMOVE_PROPOSAL_ACTION = \"remove_proposal\";\n    string constant public DISQUALIFY_PROPOSAL_ACTION = \"disqualify_proposal\";\n\n    //\n    // Variables\n    // -----------------------------------------------------------------------------------------------------------------\n    SettlementChallengeTypesLib.Proposal[] public proposals;\n    mapping(address => mapping(address => mapping(uint256 => uint256))) public proposalIndexByWalletCurrency;\n\n    //\n    // Events\n    // -----------------------------------------------------------------------------------------------------------------\n    event InitiateProposalEvent(address wallet, uint256 nonce, int256 stageAmount, int256 targetBalanceAmount,\n        MonetaryTypesLib.Currency currency, uint256 blockNumber, bool walletInitiated);\n    event TerminateProposalEvent(address wallet, uint256 nonce, int256 stageAmount, int256 targetBalanceAmount,\n        MonetaryTypesLib.Currency currency, uint256 blockNumber, bool walletInitiated);\n    event RemoveProposalEvent(address wallet, uint256 nonce, int256 stageAmount, int256 targetBalanceAmount,\n        MonetaryTypesLib.Currency currency, uint256 blockNumber, bool walletInitiated);\n    event DisqualifyProposalEvent(address challengedWallet, uint256 challangedNonce, int256 stageAmount,\n        int256 targetBalanceAmount, MonetaryTypesLib.Currency currency, uint256 blockNumber, bool walletInitiated,\n        address challengerWallet, uint256 candidateNonce, bytes32 candidateHash, string candidateKind);\n\n    //\n    // Constructor\n    // -----------------------------------------------------------------------------------------------------------------\n    constructor(address deployer) Ownable(deployer) public {\n    }\n\n    //\n    // Functions\n    // -----------------------------------------------------------------------------------------------------------------\n    /// @notice Get the number of proposals\n    /// @return The number of proposals\n    function proposalsCount()\n    public\n    view\n    returns (uint256)\n    {\n        return proposals.length;\n    }\n\n    /// @notice Initiate a proposal\n    /// @param wallet The address of the concerned challenged wallet\n    /// @param nonce The wallet nonce\n    /// @param stageAmount The proposal stage amount\n    /// @param targetBalanceAmount The proposal target balance amount\n    /// @param currency The concerned currency\n    /// @param blockNumber The proposal block number\n    /// @param walletInitiated True if initiated by the concerned challenged wallet\n    function initiateProposal(address wallet, uint256 nonce, int256 stageAmount, int256 targetBalanceAmount,\n        MonetaryTypesLib.Currency memory currency, uint256 blockNumber, bool walletInitiated)\n    public\n    onlyEnabledServiceAction(INITIATE_PROPOSAL_ACTION)\n    {\n        // Initiate proposal\n        _initiateProposal(\n            wallet, nonce, stageAmount, targetBalanceAmount,\n            currency, blockNumber, walletInitiated\n        );\n\n        // Emit event\n        emit InitiateProposalEvent(\n            wallet, nonce, stageAmount, targetBalanceAmount, currency,\n            blockNumber, walletInitiated\n        );\n    }\n\n    /// @notice Terminate a proposal\n    /// @param wallet The address of the concerned challenged wallet\n    /// @param currency The concerned currency\n    function terminateProposal(address wallet, MonetaryTypesLib.Currency memory currency)\n    public\n    onlyEnabledServiceAction(TERMINATE_PROPOSAL_ACTION)\n    {\n        // Get the proposal index\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n\n        // Return gracefully if there is no proposal to terminate\n        if (0 == index)\n            return;\n\n        // Terminate proposal\n        proposals[index - 1].terminated = true;\n\n        // Emit event\n        emit TerminateProposalEvent(\n            wallet, proposals[index - 1].nonce, proposals[index - 1].amounts.stage,\n            proposals[index - 1].amounts.targetBalance, currency,\n            proposals[index - 1].referenceBlockNumber, proposals[index - 1].walletInitiated\n        );\n    }\n\n    /// @notice Terminate a proposal\n    /// @param wallet The address of the concerned challenged wallet\n    /// @param currency The concerned currency\n    /// @param walletTerminated True if wallet terminated\n    function terminateProposal(address wallet, MonetaryTypesLib.Currency memory currency, bool walletTerminated)\n    public\n    onlyEnabledServiceAction(TERMINATE_PROPOSAL_ACTION)\n    {\n        // Get the proposal index\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n\n        // Return gracefully if there is no proposal to terminate\n        if (0 == index)\n            return;\n\n        // Require that role that initialized (wallet or operator) can only cancel its own proposal\n        require(walletTerminated == proposals[index - 1].walletInitiated, \"Wallet initiation and termination mismatch [NullSettlementChallengeState.sol:143]\");\n\n        // Terminate proposal\n        proposals[index - 1].terminated = true;\n\n        // Emit event\n        emit TerminateProposalEvent(\n            wallet, proposals[index - 1].nonce, proposals[index - 1].amounts.stage,\n            proposals[index - 1].amounts.targetBalance, currency,\n            proposals[index - 1].referenceBlockNumber, proposals[index - 1].walletInitiated\n        );\n    }\n\n    /// @notice Remove a proposal\n    /// @param wallet The address of the concerned challenged wallet\n    /// @param currency The concerned currency\n    function removeProposal(address wallet, MonetaryTypesLib.Currency memory currency)\n    public\n    onlyEnabledServiceAction(REMOVE_PROPOSAL_ACTION)\n    {\n        // Get the proposal index\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n\n        // Return gracefully if there is no proposal to remove\n        if (0 == index)\n            return;\n\n        // Emit event\n        emit RemoveProposalEvent(\n            wallet, proposals[index - 1].nonce, proposals[index - 1].amounts.stage,\n            proposals[index - 1].amounts.targetBalance, currency,\n            proposals[index - 1].referenceBlockNumber, proposals[index - 1].walletInitiated\n        );\n\n        // Remove proposal\n        _removeProposal(index);\n    }\n\n    /// @notice Remove a proposal\n    /// @param wallet The address of the concerned challenged wallet\n    /// @param currency The concerned currency\n    /// @param walletTerminated True if wallet terminated\n    function removeProposal(address wallet, MonetaryTypesLib.Currency memory currency, bool walletTerminated)\n    public\n    onlyEnabledServiceAction(REMOVE_PROPOSAL_ACTION)\n    {\n        // Get the proposal index\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n\n        // Return gracefully if there is no proposal to remove\n        if (0 == index)\n            return;\n\n        // Require that role that initialized (wallet or operator) can only cancel its own proposal\n        require(walletTerminated == proposals[index - 1].walletInitiated, \"Wallet initiation and termination mismatch [NullSettlementChallengeState.sol:197]\");\n\n        // Emit event\n        emit RemoveProposalEvent(\n            wallet, proposals[index - 1].nonce, proposals[index - 1].amounts.stage,\n            proposals[index - 1].amounts.targetBalance, currency,\n            proposals[index - 1].referenceBlockNumber, proposals[index - 1].walletInitiated\n        );\n\n        // Remove proposal\n        _removeProposal(index);\n    }\n\n    /// @notice Disqualify a proposal\n    /// @dev A call to this function will intentionally override previous disqualifications if existent\n    /// @param challengedWallet The address of the concerned challenged wallet\n    /// @param currency The concerned currency\n    /// @param challengerWallet The address of the concerned challenger wallet\n    /// @param blockNumber The disqualification block number\n    /// @param candidateNonce The candidate nonce\n    /// @param candidateHash The candidate hash\n    /// @param candidateKind The candidate kind\n    function disqualifyProposal(address challengedWallet, MonetaryTypesLib.Currency memory currency, address challengerWallet,\n        uint256 blockNumber, uint256 candidateNonce, bytes32 candidateHash, string memory candidateKind)\n    public\n    onlyEnabledServiceAction(DISQUALIFY_PROPOSAL_ACTION)\n    {\n        // Get the proposal index\n        uint256 index = proposalIndexByWalletCurrency[challengedWallet][currency.ct][currency.id];\n        require(0 != index, \"No settlement found for wallet and currency [NullSettlementChallengeState.sol:226]\");\n\n        // Update proposal\n        proposals[index - 1].status = SettlementChallengeTypesLib.Status.Disqualified;\n        proposals[index - 1].expirationTime = block.timestamp.add(configuration.settlementChallengeTimeout());\n        proposals[index - 1].disqualification.challenger = challengerWallet;\n        proposals[index - 1].disqualification.nonce = candidateNonce;\n        proposals[index - 1].disqualification.blockNumber = blockNumber;\n        proposals[index - 1].disqualification.candidate.hash = candidateHash;\n        proposals[index - 1].disqualification.candidate.kind = candidateKind;\n\n        // Emit event\n        emit DisqualifyProposalEvent(\n            challengedWallet, proposals[index - 1].nonce, proposals[index - 1].amounts.stage,\n            proposals[index - 1].amounts.targetBalance, currency, proposals[index - 1].referenceBlockNumber,\n            proposals[index - 1].walletInitiated, challengerWallet, candidateNonce, candidateHash, candidateKind\n        );\n    }\n\n    /// @notice Gauge whether the proposal for the given wallet and currency has expired\n    /// @param wallet The address of the concerned wallet\n    /// @param currency The concerned currency\n    /// @return true if proposal has expired, else false\n    function hasProposal(address wallet, MonetaryTypesLib.Currency memory currency)\n    public\n    view\n    returns (bool)\n    {\n        // 1-based index\n        return 0 != proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n    }\n\n    /// @notice Gauge whether the proposal for the given wallet and currency has terminated\n    /// @param wallet The address of the concerned wallet\n    /// @param currency The concerned currency\n    /// @return true if proposal has terminated, else false\n    function hasProposalTerminated(address wallet, MonetaryTypesLib.Currency memory currency)\n    public\n    view\n    returns (bool)\n    {\n        // 1-based index\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n        require(0 != index, \"No proposal found for wallet and currency [NullSettlementChallengeState.sol:269]\");\n        return proposals[index - 1].terminated;\n    }\n\n    /// @notice Gauge whether the proposal for the given wallet and currency has expired\n    /// @param wallet The address of the concerned wallet\n    /// @param currency The concerned currency\n    /// @return true if proposal has expired, else false\n    function hasProposalExpired(address wallet, MonetaryTypesLib.Currency memory currency)\n    public\n    view\n    returns (bool)\n    {\n        // 1-based index\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n        require(0 != index, \"No proposal found for wallet and currency [NullSettlementChallengeState.sol:284]\");\n        return block.timestamp >= proposals[index - 1].expirationTime;\n    }\n\n    /// @notice Get the settlement proposal challenge nonce of the given wallet and currency\n    /// @param wallet The address of the concerned wallet\n    /// @param currency The concerned currency\n    /// @return The settlement proposal nonce\n    function proposalNonce(address wallet, MonetaryTypesLib.Currency memory currency)\n    public\n    view\n    returns (uint256)\n    {\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n        require(0 != index, \"No proposal found for wallet and currency [NullSettlementChallengeState.sol:298]\");\n        return proposals[index - 1].nonce;\n    }\n\n    /// @notice Get the settlement proposal reference block number of the given wallet and currency\n    /// @param wallet The address of the concerned wallet\n    /// @param currency The concerned currency\n    /// @return The settlement proposal reference block number\n    function proposalReferenceBlockNumber(address wallet, MonetaryTypesLib.Currency memory currency)\n    public\n    view\n    returns (uint256)\n    {\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n        require(0 != index, \"No proposal found for wallet and currency [NullSettlementChallengeState.sol:312]\");\n        return proposals[index - 1].referenceBlockNumber;\n    }\n\n    /// @notice Get the settlement proposal definition block number of the given wallet and currency\n    /// @param wallet The address of the concerned wallet\n    /// @param currency The concerned currency\n    /// @return The settlement proposal reference block number\n    function proposalDefinitionBlockNumber(address wallet, MonetaryTypesLib.Currency memory currency)\n    public\n    view\n    returns (uint256)\n    {\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n        require(0 != index, \"No proposal found for wallet and currency [NullSettlementChallengeState.sol:326]\");\n        return proposals[index - 1].definitionBlockNumber;\n    }\n\n    /// @notice Get the settlement proposal expiration time of the given wallet and currency\n    /// @param wallet The address of the concerned wallet\n    /// @param currency The concerned currency\n    /// @return The settlement proposal expiration time\n    function proposalExpirationTime(address wallet, MonetaryTypesLib.Currency memory currency)\n    public\n    view\n    returns (uint256)\n    {\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n        require(0 != index, \"No proposal found for wallet and currency [NullSettlementChallengeState.sol:340]\");\n        return proposals[index - 1].expirationTime;\n    }\n\n    /// @notice Get the settlement proposal status of the given wallet and currency\n    /// @param wallet The address of the concerned wallet\n    /// @param currency The concerned currency\n    /// @return The settlement proposal status\n    function proposalStatus(address wallet, MonetaryTypesLib.Currency memory currency)\n    public\n    view\n    returns (SettlementChallengeTypesLib.Status)\n    {\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n        require(0 != index, \"No proposal found for wallet and currency [NullSettlementChallengeState.sol:354]\");\n        return proposals[index - 1].status;\n    }\n\n    /// @notice Get the settlement proposal stage amount of the given wallet and currency\n    /// @param wallet The address of the concerned wallet\n    /// @param currency The concerned currency\n    /// @return The settlement proposal stage amount\n    function proposalStageAmount(address wallet, MonetaryTypesLib.Currency memory currency)\n    public\n    view\n    returns (int256)\n    {\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n        require(0 != index, \"No proposal found for wallet and currency [NullSettlementChallengeState.sol:368]\");\n        return proposals[index - 1].amounts.stage;\n    }\n\n    /// @notice Get the settlement proposal target balance amount of the given wallet and currency\n    /// @param wallet The address of the concerned wallet\n    /// @param currency The concerned currency\n    /// @return The settlement proposal target balance amount\n    function proposalTargetBalanceAmount(address wallet, MonetaryTypesLib.Currency memory currency)\n    public\n    view\n    returns (int256)\n    {\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n        require(0 != index, \"No proposal found for wallet and currency [NullSettlementChallengeState.sol:382]\");\n        return proposals[index - 1].amounts.targetBalance;\n    }\n\n    /// @notice Get the settlement proposal balance reward of the given wallet and currency\n    /// @param wallet The address of the concerned wallet\n    /// @param currency The concerned currency\n    /// @return The settlement proposal balance reward\n    function proposalWalletInitiated(address wallet, MonetaryTypesLib.Currency memory currency)\n    public\n    view\n    returns (bool)\n    {\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n        require(0 != index, \"No proposal found for wallet and currency [NullSettlementChallengeState.sol:396]\");\n        return proposals[index - 1].walletInitiated;\n    }\n\n    /// @notice Get the settlement proposal disqualification challenger of the given wallet and currency\n    /// @param wallet The address of the concerned wallet\n    /// @param currency The concerned currency\n    /// @return The settlement proposal disqualification challenger\n    function proposalDisqualificationChallenger(address wallet, MonetaryTypesLib.Currency memory currency)\n    public\n    view\n    returns (address)\n    {\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n        require(0 != index, \"No proposal found for wallet and currency [NullSettlementChallengeState.sol:410]\");\n        return proposals[index - 1].disqualification.challenger;\n    }\n\n    /// @notice Get the settlement proposal disqualification block number of the given wallet and currency\n    /// @param wallet The address of the concerned wallet\n    /// @param currency The concerned currency\n    /// @return The settlement proposal disqualification block number\n    function proposalDisqualificationBlockNumber(address wallet, MonetaryTypesLib.Currency memory currency)\n    public\n    view\n    returns (uint256)\n    {\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n        require(0 != index, \"No proposal found for wallet and currency [NullSettlementChallengeState.sol:424]\");\n        return proposals[index - 1].disqualification.blockNumber;\n    }\n\n    /// @notice Get the settlement proposal disqualification nonce of the given wallet and currency\n    /// @param wallet The address of the concerned wallet\n    /// @param currency The concerned currency\n    /// @return The settlement proposal disqualification nonce\n    function proposalDisqualificationNonce(address wallet, MonetaryTypesLib.Currency memory currency)\n    public\n    view\n    returns (uint256)\n    {\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n        require(0 != index, \"No proposal found for wallet and currency [NullSettlementChallengeState.sol:438]\");\n        return proposals[index - 1].disqualification.nonce;\n    }\n\n    /// @notice Get the settlement proposal disqualification candidate hash of the given wallet and currency\n    /// @param wallet The address of the concerned wallet\n    /// @param currency The concerned currency\n    /// @return The settlement proposal disqualification candidate hash\n    function proposalDisqualificationCandidateHash(address wallet, MonetaryTypesLib.Currency memory currency)\n    public\n    view\n    returns (bytes32)\n    {\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n        require(0 != index, \"No proposal found for wallet and currency [NullSettlementChallengeState.sol:452]\");\n        return proposals[index - 1].disqualification.candidate.hash;\n    }\n\n    /// @notice Get the settlement proposal disqualification candidate kind of the given wallet and currency\n    /// @param wallet The address of the concerned wallet\n    /// @param currency The concerned currency\n    /// @return The settlement proposal disqualification candidate kind\n    function proposalDisqualificationCandidateKind(address wallet, MonetaryTypesLib.Currency memory currency)\n    public\n    view\n    returns (string memory)\n    {\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n        require(0 != index, \"No proposal found for wallet and currency [NullSettlementChallengeState.sol:466]\");\n        return proposals[index - 1].disqualification.candidate.kind;\n    }\n\n    //\n    // Private functions\n    // -----------------------------------------------------------------------------------------------------------------\n    function _initiateProposal(address wallet, uint256 nonce, int256 stageAmount, int256 targetBalanceAmount,\n        MonetaryTypesLib.Currency memory currency, uint256 referenceBlockNumber, bool walletInitiated)\n    private\n    {\n        // Require that stage and target balance amounts are positive\n        require(stageAmount.isPositiveInt256(), \"Stage amount not positive [NullSettlementChallengeState.sol:478]\");\n        require(targetBalanceAmount.isPositiveInt256(), \"Target balance amount not positive [NullSettlementChallengeState.sol:479]\");\n\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n\n        // Create proposal if needed\n        if (0 == index) {\n            index = ++(proposals.length);\n            proposalIndexByWalletCurrency[wallet][currency.ct][currency.id] = index;\n        }\n\n        // Populate proposal\n        proposals[index - 1].wallet = wallet;\n        proposals[index - 1].nonce = nonce;\n        proposals[index - 1].referenceBlockNumber = referenceBlockNumber;\n        proposals[index - 1].definitionBlockNumber = block.number;\n        proposals[index - 1].expirationTime = block.timestamp.add(configuration.settlementChallengeTimeout());\n        proposals[index - 1].status = SettlementChallengeTypesLib.Status.Qualified;\n        proposals[index - 1].currency = currency;\n        proposals[index - 1].amounts.stage = stageAmount;\n        proposals[index - 1].amounts.targetBalance = targetBalanceAmount;\n        proposals[index - 1].walletInitiated = walletInitiated;\n        proposals[index - 1].terminated = false;\n    }\n\n    function _removeProposal(uint256 index)\n    private\n    returns (bool)\n    {\n        // Remove the proposal and clear references to it\n        proposalIndexByWalletCurrency[proposals[index - 1].wallet][proposals[index - 1].currency.ct][proposals[index - 1].currency.id] = 0;\n        if (index < proposals.length) {\n            proposals[index - 1] = proposals[proposals.length - 1];\n            proposalIndexByWalletCurrency[proposals[index - 1].wallet][proposals[index - 1].currency.ct][proposals[index - 1].currency.id] = index;\n        }\n        proposals.length--;\n    }\n\n    function _activeBalanceLogEntry(address wallet, address currencyCt, uint256 currencyId)\n    private\n    view\n    returns (int256 amount, uint256 blockNumber)\n    {\n        // Get last log record of deposited and settled balances\n        (int256 depositedAmount, uint256 depositedBlockNumber) = balanceTracker.lastFungibleRecord(\n            wallet, balanceTracker.depositedBalanceType(), currencyCt, currencyId\n        );\n        (int256 settledAmount, uint256 settledBlockNumber) = balanceTracker.lastFungibleRecord(\n            wallet, balanceTracker.settledBalanceType(), currencyCt, currencyId\n        );\n\n        // Set amount as the sum of deposited and settled\n        amount = depositedAmount.add(settledAmount);\n\n        // Set block number as the latest of deposited and settled\n        blockNumber = depositedBlockNumber > settledBlockNumber ? depositedBlockNumber : settledBlockNumber;\n    }\n}\n\n/*\n * Hubii Nahmii\n *\n * Compliant with the Hubii Nahmii specification v0.12.\n *\n * Copyright (C) 2017-2018 Hubii AS\n */\n\nlibrary BalanceTrackerLib {\n    using SafeMathIntLib for int256;\n    using SafeMathUintLib for uint256;\n\n    function fungibleActiveRecordByBlockNumber(BalanceTracker self, address wallet,\n        MonetaryTypesLib.Currency memory currency, uint256 _blockNumber)\n    internal\n    view\n    returns (int256 amount, uint256 blockNumber)\n    {\n        // Get log records of deposited and settled balances\n        (int256 depositedAmount, uint256 depositedBlockNumber) = self.fungibleRecordByBlockNumber(\n            wallet, self.depositedBalanceType(), currency.ct, currency.id, _blockNumber\n        );\n        (int256 settledAmount, uint256 settledBlockNumber) = self.fungibleRecordByBlockNumber(\n            wallet, self.settledBalanceType(), currency.ct, currency.id, _blockNumber\n        );\n\n        // Return the sum of amounts and highest of block numbers\n        amount = depositedAmount.add(settledAmount);\n        blockNumber = depositedBlockNumber.clampMin(settledBlockNumber);\n    }\n\n    function fungibleActiveBalanceAmountByBlockNumber(BalanceTracker self, address wallet,\n        MonetaryTypesLib.Currency memory currency, uint256 blockNumber)\n    internal\n    view\n    returns (int256)\n    {\n        (int256 amount,) = fungibleActiveRecordByBlockNumber(self, wallet, currency, blockNumber);\n        return amount;\n    }\n\n    function fungibleActiveDeltaBalanceAmountByBlockNumbers(BalanceTracker self, address wallet,\n        MonetaryTypesLib.Currency memory currency, uint256 fromBlockNumber, uint256 toBlockNumber)\n    internal\n    view\n    returns (int256)\n    {\n        return fungibleActiveBalanceAmountByBlockNumber(self, wallet, currency, toBlockNumber) -\n        fungibleActiveBalanceAmountByBlockNumber(self, wallet, currency, fromBlockNumber);\n    }\n\n    // TODO Rename?\n    function fungibleActiveRecord(BalanceTracker self, address wallet,\n        MonetaryTypesLib.Currency memory currency)\n    internal\n    view\n    returns (int256 amount, uint256 blockNumber)\n    {\n        // Get last log records of deposited and settled balances\n        (int256 depositedAmount, uint256 depositedBlockNumber) = self.lastFungibleRecord(\n            wallet, self.depositedBalanceType(), currency.ct, currency.id\n        );\n        (int256 settledAmount, uint256 settledBlockNumber) = self.lastFungibleRecord(\n            wallet, self.settledBalanceType(), currency.ct, currency.id\n        );\n\n        // Return the sum of amounts and highest of block numbers\n        amount = depositedAmount.add(settledAmount);\n        blockNumber = depositedBlockNumber.clampMin(settledBlockNumber);\n    }\n\n    // TODO Rename?\n    function fungibleActiveBalanceAmount(BalanceTracker self, address wallet, MonetaryTypesLib.Currency memory currency)\n    internal\n    view\n    returns (int256)\n    {\n        return self.get(wallet, self.depositedBalanceType(), currency.ct, currency.id).add(\n            self.get(wallet, self.settledBalanceType(), currency.ct, currency.id)\n        );\n    }\n}\n\n/*\n * Hubii Nahmii\n *\n * Compliant with the Hubii Nahmii specification v0.12.\n *\n * Copyright (C) 2017-2018 Hubii AS\n */\n\n/**\n * @title DriipSettlementDisputeByPayment\n * @notice The where payment related disputes of driip settlement challenge happens\n */\ncontract DriipSettlementDisputeByPayment is Ownable, Configurable, Validatable, SecurityBondable, WalletLockable,\nBalanceTrackable, FraudChallengable, Servable {\n    using SafeMathIntLib for int256;\n    using SafeMathUintLib for uint256;\n    using BalanceTrackerLib for BalanceTracker;\n\n    //\n    // Constants\n    // -----------------------------------------------------------------------------------------------------------------\n    string constant public CHALLENGE_BY_PAYMENT_ACTION = \"challenge_by_payment\";\n\n    //\n    // Variables\n    // -----------------------------------------------------------------------------------------------------------------\n    DriipSettlementChallengeState public driipSettlementChallengeState;\n    NullSettlementChallengeState public nullSettlementChallengeState;\n\n    //\n    // Events\n    // -----------------------------------------------------------------------------------------------------------------\n    event SetDriipSettlementChallengeStateEvent(DriipSettlementChallengeState oldDriipSettlementChallengeState,\n        DriipSettlementChallengeState newDriipSettlementChallengeState);\n    event SetNullSettlementChallengeStateEvent(NullSettlementChallengeState oldNullSettlementChallengeState,\n        NullSettlementChallengeState newNullSettlementChallengeState);\n    event ChallengeByPaymentEvent(address wallet, uint256 nonce, PaymentTypesLib.Payment payment,\n        address challenger);\n\n    //\n    // Constructor\n    // -----------------------------------------------------------------------------------------------------------------\n    constructor(address deployer) Ownable(deployer) public {\n    }\n\n    /// @notice Set the driip settlement state contract\n    /// @param newDriipSettlementChallengeState The (address of) DriipSettlementChallengeState contract instance\n    function setDriipSettlementChallengeState(DriipSettlementChallengeState newDriipSettlementChallengeState) public\n    onlyDeployer\n    notNullAddress(address(newDriipSettlementChallengeState))\n    {\n        DriipSettlementChallengeState oldDriipSettlementChallengeState = driipSettlementChallengeState;\n        driipSettlementChallengeState = newDriipSettlementChallengeState;\n        emit SetDriipSettlementChallengeStateEvent(oldDriipSettlementChallengeState, driipSettlementChallengeState);\n    }\n\n    /// @notice Set the null settlement state contract\n    /// @param newNullSettlementChallengeState The (address of) NullSettlementChallengeState contract instance\n    function setNullSettlementChallengeState(NullSettlementChallengeState newNullSettlementChallengeState) public\n    onlyDeployer\n    notNullAddress(address(newNullSettlementChallengeState))\n    {\n        NullSettlementChallengeState oldNullSettlementChallengeState = nullSettlementChallengeState;\n        nullSettlementChallengeState = newNullSettlementChallengeState;\n        emit SetNullSettlementChallengeStateEvent(oldNullSettlementChallengeState, nullSettlementChallengeState);\n    }\n\n    /// @notice Challenge the driip settlement by providing payment candidate\n    /// @dev This challenges the payment sender's side of things\n    /// @param wallet The concerned party\n    /// @param payment The payment candidate that challenges the challenged driip\n    /// @param challenger The address of the challenger\n    function challengeByPayment(address wallet, PaymentTypesLib.Payment memory payment, address challenger)\n    public\n    onlyEnabledServiceAction(CHALLENGE_BY_PAYMENT_ACTION)\n    onlySealedPayment(payment)\n    onlyPaymentSender(payment, wallet)\n    {\n        // Require that payment candidate is not labelled fraudulent\n        require(!fraudChallenge.isFraudulentPaymentHash(payment.seals.operator.hash), \"Payment deemed fraudulent [DriipSettlementDisputeByPayment.sol:102]\");\n\n        // Require that proposal has been initiated\n        require(driipSettlementChallengeState.hasProposal(wallet, payment.currency), \"No proposal found [DriipSettlementDisputeByPayment.sol:105]\");\n\n        // Require that proposal has not expired\n        require(!driipSettlementChallengeState.hasProposalExpired(wallet, payment.currency), \"Proposal found expired [DriipSettlementDisputeByPayment.sol:108]\");\n\n        // Require that payment party's nonce is strictly greater than proposal's nonce and its current\n        // disqualification nonce\n        require(payment.sender.nonce > driipSettlementChallengeState.proposalNonce(\n            wallet, payment.currency\n        ), \"Payment nonce not strictly greater than proposal nonce [DriipSettlementDisputeByPayment.sol:112]\");\n        require(payment.sender.nonce > driipSettlementChallengeState.proposalDisqualificationNonce(\n            wallet, payment.currency\n        ), \"Payment nonce not strictly greater than proposal disqualification nonce [DriipSettlementDisputeByPayment.sol:115]\");\n\n        // Require overrun for this payment to be a valid challenge candidate\n        require(_overrun(wallet, payment), \"No overrun found [DriipSettlementDisputeByPayment.sol:120]\");\n\n        // Reward challenger\n        _settleRewards(wallet, payment.sender.balances.current, payment.currency, challenger);\n\n        // Disqualify proposal, effectively overriding any previous disqualification\n        driipSettlementChallengeState.disqualifyProposal(\n            wallet, payment.currency, challenger, payment.blockNumber,\n            payment.sender.nonce, payment.seals.operator.hash, PaymentTypesLib.PAYMENT_KIND()\n        );\n\n        // Cancel dependent null settlement challenge if existent\n        nullSettlementChallengeState.terminateProposal(wallet, payment.currency);\n\n        // Emit event\n        emit ChallengeByPaymentEvent(\n            wallet, driipSettlementChallengeState.proposalNonce(wallet, payment.currency), payment, challenger\n        );\n    }\n\n    //\n    // Private functions\n    // -----------------------------------------------------------------------------------------------------------------\n    function _overrun(address wallet, PaymentTypesLib.Payment memory payment)\n    private\n    view\n    returns (bool)\n    {\n        // Get the target balance amount from the proposal\n        int targetBalanceAmount = driipSettlementChallengeState.proposalTargetBalanceAmount(\n            wallet, payment.currency\n        );\n\n        // Get the change in active balance since the start of the challenge\n        int256 deltaBalanceSinceStart = balanceTracker.fungibleActiveBalanceAmount(\n            wallet, payment.currency\n        ).sub(\n            balanceTracker.fungibleActiveBalanceAmountByBlockNumber(\n                wallet, payment.currency,\n                driipSettlementChallengeState.proposalReferenceBlockNumber(wallet, payment.currency)\n            )\n        );\n\n        // Get the cumulative transfer of the payment\n        int256 paymentCumulativeTransfer = balanceTracker.fungibleActiveBalanceAmountByBlockNumber(\n            wallet, payment.currency, payment.blockNumber\n        ).sub(payment.sender.balances.current);\n\n        // Get the cumulative transfer of the proposal (i.e. of challenged payment)\n        int proposalCumulativeTransfer = driipSettlementChallengeState.proposalCumulativeTransferAmount(\n            wallet, payment.currency\n        );\n\n        return targetBalanceAmount.add(deltaBalanceSinceStart) < paymentCumulativeTransfer.sub(proposalCumulativeTransfer);\n    }\n\n    // Lock wallet's balances or reward challenger by stake fraction\n    function _settleRewards(address wallet, int256 walletAmount, MonetaryTypesLib.Currency memory currency,\n        address challenger)\n    private\n    {\n        if (driipSettlementChallengeState.proposalWalletInitiated(wallet, currency))\n            _settleBalanceReward(wallet, walletAmount, currency, challenger);\n\n        else\n            _settleSecurityBondReward(wallet, walletAmount, currency, challenger);\n    }\n\n    function _settleBalanceReward(address wallet, int256 walletAmount, MonetaryTypesLib.Currency memory currency,\n        address challenger)\n    private\n    {\n        // Unlock wallet/currency for existing challenger if previously locked\n        if (SettlementChallengeTypesLib.Status.Disqualified == driipSettlementChallengeState.proposalStatus(\n            wallet, currency\n        ))\n            walletLocker.unlockFungibleByProxy(\n                wallet,\n                driipSettlementChallengeState.proposalDisqualificationChallenger(\n                    wallet, currency\n                ),\n                currency.ct, currency.id\n            );\n\n        // Lock wallet for new challenger\n        walletLocker.lockFungibleByProxy(\n            wallet, challenger, walletAmount, currency.ct, currency.id, configuration.settlementChallengeTimeout()\n        );\n    }\n\n    // Settle the two-component reward from security bond.\n    // The first component is flat figure as obtained from Configuration\n    // The second component is progressive and calculated as\n    //    min(walletAmount, fraction of SecurityBond's deposited balance)\n    // both amounts for the given currency\n    function _settleSecurityBondReward(address wallet, int256 walletAmount, MonetaryTypesLib.Currency memory currency,\n        address challenger)\n    private\n    {\n        // Deprive existing challenger of reward if previously locked\n        if (SettlementChallengeTypesLib.Status.Disqualified == driipSettlementChallengeState.proposalStatus(\n            wallet, currency\n        ))\n            securityBond.depriveAbsolute(\n                driipSettlementChallengeState.proposalDisqualificationChallenger(\n                    wallet, currency\n                ),\n                currency.ct, currency.id\n            );\n\n        // Reward the flat component\n        MonetaryTypesLib.Figure memory flatReward = _flatReward();\n        securityBond.rewardAbsolute(\n            challenger, flatReward.amount, flatReward.currency.ct, flatReward.currency.id, 0\n        );\n\n        // Reward the progressive component\n        int256 progressiveRewardAmount = walletAmount.clampMax(\n            securityBond.depositedFractionalBalance(\n                currency.ct, currency.id, configuration.operatorSettlementStakeFraction()\n            )\n        );\n        securityBond.rewardAbsolute(\n            challenger, progressiveRewardAmount, currency.ct, currency.id, 0\n        );\n    }\n\n    function _flatReward()\n    private\n    view\n    returns (MonetaryTypesLib.Figure memory)\n    {\n        (int256 amount, address currencyCt, uint256 currencyId) = configuration.operatorSettlementStake();\n        return MonetaryTypesLib.Figure(amount, MonetaryTypesLib.Currency(currencyCt, currencyId));\n    }\n}\n\n/*\n * Hubii Nahmii\n *\n * Compliant with the Hubii Nahmii specification v0.12.\n *\n * Copyright (C) 2017-2018 Hubii AS\n */\n\n/**\n * @title Community vote\n * @notice An oracle for relevant decisions made by the community.\n */\ncontract CommunityVote is Ownable {\n    //\n    // Variables\n    // -----------------------------------------------------------------------------------------------------------------\n    mapping(address => bool) doubleSpenderByWallet;\n    uint256 maxDriipNonce;\n    uint256 maxNullNonce;\n    bool dataAvailable;\n\n    //\n    // Constructor\n    // -----------------------------------------------------------------------------------------------------------------\n    constructor(address deployer) Ownable(deployer) public {\n        dataAvailable = true;\n    }\n\n    //\n    // Results functions\n    // -----------------------------------------------------------------------------------------------------------------\n    /// @notice Get the double spender status of given wallet\n    /// @param wallet The wallet address for which to check double spender status\n    /// @return true if wallet is double spender, false otherwise\n    function isDoubleSpenderWallet(address wallet)\n    public\n    view\n    returns (bool)\n    {\n        return doubleSpenderByWallet[wallet];\n    }\n\n    /// @notice Get the max driip nonce to be accepted in settlements\n    /// @return the max driip nonce\n    function getMaxDriipNonce()\n    public\n    view\n    returns (uint256)\n    {\n        return maxDriipNonce;\n    }\n\n    /// @notice Get the max null settlement nonce to be accepted in settlements\n    /// @return the max driip nonce\n    function getMaxNullNonce()\n    public\n    view\n    returns (uint256)\n    {\n        return maxNullNonce;\n    }\n\n    /// @notice Get the data availability status\n    /// @return true if data is available\n    function isDataAvailable()\n    public\n    view\n    returns (bool)\n    {\n        return dataAvailable;\n    }\n}\n\n/*\n * Hubii Nahmii\n *\n * Compliant with the Hubii Nahmii specification v0.12.\n *\n * Copyright (C) 2017-2018 Hubii AS\n */\n\n/**\n * @title CommunityVotable\n * @notice An ownable that has a community vote property\n */\ncontract CommunityVotable is Ownable {\n    //\n    // Variables\n    // -----------------------------------------------------------------------------------------------------------------\n    CommunityVote public communityVote;\n    bool public communityVoteFrozen;\n\n    //\n    // Events\n    // -----------------------------------------------------------------------------------------------------------------\n    event SetCommunityVoteEvent(CommunityVote oldCommunityVote, CommunityVote newCommunityVote);\n    event FreezeCommunityVoteEvent();\n\n    //\n    // Functions\n    // -----------------------------------------------------------------------------------------------------------------\n    /// @notice Set the community vote contract\n    /// @param newCommunityVote The (address of) CommunityVote contract instance\n    function setCommunityVote(CommunityVote newCommunityVote) \n    public \n    onlyDeployer\n    notNullAddress(address(newCommunityVote))\n    notSameAddresses(address(newCommunityVote), address(communityVote))\n    {\n        require(!communityVoteFrozen, \"Community vote frozen [CommunityVotable.sol:41]\");\n\n        // Set new community vote\n        CommunityVote oldCommunityVote = communityVote;\n        communityVote = newCommunityVote;\n\n        // Emit event\n        emit SetCommunityVoteEvent(oldCommunityVote, newCommunityVote);\n    }\n\n    /// @notice Freeze the community vote from further updates\n    /// @dev This operation can not be undone\n    function freezeCommunityVote()\n    public\n    onlyDeployer\n    {\n        communityVoteFrozen = true;\n\n        // Emit event\n        emit FreezeCommunityVoteEvent();\n    }\n\n    //\n    // Modifiers\n    // -----------------------------------------------------------------------------------------------------------------\n    modifier communityVoteInitialized() {\n        require(address(communityVote) != address(0), \"Community vote not initialized [CommunityVotable.sol:67]\");\n        _;\n    }\n}\n\n/*\n * Hubii Nahmii\n *\n * Compliant with the Hubii Nahmii specification v0.12.\n *\n * Copyright (C) 2017-2018 Hubii AS\n */\n\n/**\n * @title Benefactor\n * @notice An ownable that contains registered beneficiaries\n */\ncontract Benefactor is Ownable {\n    //\n    // Variables\n    // -----------------------------------------------------------------------------------------------------------------\n    Beneficiary[] public beneficiaries;\n    mapping(address => uint256) public beneficiaryIndexByAddress;\n\n    //\n    // Events\n    // -----------------------------------------------------------------------------------------------------------------\n    event RegisterBeneficiaryEvent(Beneficiary beneficiary);\n    event DeregisterBeneficiaryEvent(Beneficiary beneficiary);\n\n    //\n    // Functions\n    // -----------------------------------------------------------------------------------------------------------------\n    /// @notice Register the given beneficiary\n    /// @param beneficiary Address of beneficiary to be registered\n    function registerBeneficiary(Beneficiary beneficiary)\n    public\n    onlyDeployer\n    notNullAddress(address(beneficiary))\n    returns (bool)\n    {\n        address _beneficiary = address(beneficiary);\n\n        if (beneficiaryIndexByAddress[_beneficiary] > 0)\n            return false;\n\n        beneficiaries.push(beneficiary);\n        beneficiaryIndexByAddress[_beneficiary] = beneficiaries.length;\n\n        // Emit event\n        emit RegisterBeneficiaryEvent(beneficiary);\n\n        return true;\n    }\n\n    /// @notice Deregister the given beneficiary\n    /// @param beneficiary Address of beneficiary to be deregistered\n    function deregisterBeneficiary(Beneficiary beneficiary)\n    public\n    onlyDeployer\n    notNullAddress(address(beneficiary))\n    returns (bool)\n    {\n        address _beneficiary = address(beneficiary);\n\n        if (beneficiaryIndexByAddress[_beneficiary] == 0)\n            return false;\n\n        uint256 idx = beneficiaryIndexByAddress[_beneficiary] - 1;\n        if (idx < beneficiaries.length - 1) {\n            // Remap the last item in the array to this index\n            beneficiaries[idx] = beneficiaries[beneficiaries.length - 1];\n            beneficiaryIndexByAddress[address(beneficiaries[idx])] = idx + 1;\n        }\n        beneficiaries.length--;\n        beneficiaryIndexByAddress[_beneficiary] = 0;\n\n        // Emit event\n        emit DeregisterBeneficiaryEvent(beneficiary);\n\n        return true;\n    }\n\n    /// @notice Gauge whether the given address is the one of a registered beneficiary\n    /// @param beneficiary Address of beneficiary\n    /// @return true if beneficiary is registered, else false\n    function isRegisteredBeneficiary(Beneficiary beneficiary)\n    public\n    view\n    returns (bool)\n    {\n        return beneficiaryIndexByAddress[address(beneficiary)] > 0;\n    }\n\n    /// @notice Get the count of registered beneficiaries\n    /// @return The count of registered beneficiaries\n    function registeredBeneficiariesCount()\n    public\n    view\n    returns (uint256)\n    {\n        return beneficiaries.length;\n    }\n}\n\n/*\n * Hubii Nahmii\n *\n * Compliant with the Hubii Nahmii specification v0.12.\n *\n * Copyright (C) 2017-2018 Hubii AS\n */\n\n/**\n * @title AccrualBenefactor\n * @notice A benefactor whose registered beneficiaries obtain a predefined fraction of total amount\n */\ncontract AccrualBenefactor is Benefactor {\n    using SafeMathIntLib for int256;\n\n    //\n    // Variables\n    // -----------------------------------------------------------------------------------------------------------------\n    mapping(address => int256) private _beneficiaryFractionMap;\n    int256 public totalBeneficiaryFraction;\n\n    //\n    // Events\n    // -----------------------------------------------------------------------------------------------------------------\n    event RegisterAccrualBeneficiaryEvent(Beneficiary beneficiary, int256 fraction);\n    event DeregisterAccrualBeneficiaryEvent(Beneficiary beneficiary);\n\n    //\n    // Functions\n    // -----------------------------------------------------------------------------------------------------------------\n    /// @notice Register the given accrual beneficiary for the entirety fraction\n    /// @param beneficiary Address of accrual beneficiary to be registered\n    function registerBeneficiary(Beneficiary beneficiary)\n    public\n    onlyDeployer\n    notNullAddress(address(beneficiary))\n    returns (bool)\n    {\n        return registerFractionalBeneficiary(AccrualBeneficiary(address(beneficiary)), ConstantsLib.PARTS_PER());\n    }\n\n    /// @notice Register the given accrual beneficiary for the given fraction\n    /// @param beneficiary Address of accrual beneficiary to be registered\n    /// @param fraction Fraction of benefits to be given\n    function registerFractionalBeneficiary(AccrualBeneficiary beneficiary, int256 fraction)\n    public\n    onlyDeployer\n    notNullAddress(address(beneficiary))\n    returns (bool)\n    {\n        require(fraction > 0, \"Fraction not strictly positive [AccrualBenefactor.sol:59]\");\n        require(\n            totalBeneficiaryFraction.add(fraction) <= ConstantsLib.PARTS_PER(),\n            \"Total beneficiary fraction out of bounds [AccrualBenefactor.sol:60]\"\n        );\n\n        if (!super.registerBeneficiary(beneficiary))\n            return false;\n\n        _beneficiaryFractionMap[address(beneficiary)] = fraction;\n        totalBeneficiaryFraction = totalBeneficiaryFraction.add(fraction);\n\n        // Emit event\n        emit RegisterAccrualBeneficiaryEvent(beneficiary, fraction);\n\n        return true;\n    }\n\n    /// @notice Deregister the given accrual beneficiary\n    /// @param beneficiary Address of accrual beneficiary to be deregistered\n    function deregisterBeneficiary(Beneficiary beneficiary)\n    public\n    onlyDeployer\n    notNullAddress(address(beneficiary))\n    returns (bool)\n    {\n        if (!super.deregisterBeneficiary(beneficiary))\n            return false;\n\n        address _beneficiary = address(beneficiary);\n\n        totalBeneficiaryFraction = totalBeneficiaryFraction.sub(_beneficiaryFractionMap[_beneficiary]);\n        _beneficiaryFractionMap[_beneficiary] = 0;\n\n        // Emit event\n        emit DeregisterAccrualBeneficiaryEvent(beneficiary);\n\n        return true;\n    }\n\n    /// @notice Get the fraction of benefits that is granted the given accrual beneficiary\n    /// @param beneficiary Address of accrual beneficiary\n    /// @return The beneficiary's fraction\n    function beneficiaryFraction(AccrualBeneficiary beneficiary)\n    public\n    view\n    returns (int256)\n    {\n        return _beneficiaryFractionMap[address(beneficiary)];\n    }\n}\n\n/*\n * Hubii Nahmii\n *\n * Compliant with the Hubii Nahmii specification v0.12.\n *\n * Copyright (C) 2017-2018 Hubii AS\n */\n\n/**\n * @title RevenueFund\n * @notice The target of all revenue earned in driip settlements and from which accrued revenue is split amongst\n *   accrual beneficiaries.\n */\ncontract RevenueFund is Ownable, AccrualBeneficiary, AccrualBenefactor, TransferControllerManageable {\n    using FungibleBalanceLib for FungibleBalanceLib.Balance;\n    using TxHistoryLib for TxHistoryLib.TxHistory;\n    using SafeMathIntLib for int256;\n    using SafeMathUintLib for uint256;\n    using CurrenciesLib for CurrenciesLib.Currencies;\n\n    //\n    // Variables\n    // -----------------------------------------------------------------------------------------------------------------\n    FungibleBalanceLib.Balance periodAccrual;\n    CurrenciesLib.Currencies periodCurrencies;\n\n    FungibleBalanceLib.Balance aggregateAccrual;\n    CurrenciesLib.Currencies aggregateCurrencies;\n\n    TxHistoryLib.TxHistory private txHistory;\n\n    //\n    // Events\n    // -----------------------------------------------------------------------------------------------------------------\n    event ReceiveEvent(address from, int256 amount, address currencyCt, uint256 currencyId);\n    event CloseAccrualPeriodEvent();\n    event RegisterServiceEvent(address service);\n    event DeregisterServiceEvent(address service);\n\n    //\n    // Constructor\n    // -----------------------------------------------------------------------------------------------------------------\n    constructor(address deployer) Ownable(deployer) public {\n    }\n\n    //\n    // Functions\n    // -----------------------------------------------------------------------------------------------------------------\n    /// @notice Fallback function that deposits ethers\n    function() external payable {\n        receiveEthersTo(msg.sender, \"\");\n    }\n\n    /// @notice Receive ethers to\n    /// @param wallet The concerned wallet address\n    function receiveEthersTo(address wallet, string memory)\n    public\n    payable\n    {\n        int256 amount = SafeMathIntLib.toNonZeroInt256(msg.value);\n\n        // Add to balances\n        periodAccrual.add(amount, address(0), 0);\n        aggregateAccrual.add(amount, address(0), 0);\n\n        // Add currency to stores of currencies\n        periodCurrencies.add(address(0), 0);\n        aggregateCurrencies.add(address(0), 0);\n\n        // Add to transaction history\n        txHistory.addDeposit(amount, address(0), 0);\n\n        // Emit event\n        emit ReceiveEvent(wallet, amount, address(0), 0);\n    }\n\n    /// @notice Receive tokens\n    /// @param amount The concerned amount\n    /// @param currencyCt The address of the concerned currency contract (address(0) == ETH)\n    /// @param currencyId The ID of the concerned currency (0 for ETH and ERC20)\n    /// @param standard The standard of token (\"ERC20\", \"ERC721\")\n    function receiveTokens(string memory balanceType, int256 amount, address currencyCt,\n        uint256 currencyId, string memory standard)\n    public\n    {\n        receiveTokensTo(msg.sender, balanceType, amount, currencyCt, currencyId, standard);\n    }\n\n    /// @notice Receive tokens to\n    /// @param wallet The address of the concerned wallet\n    /// @param amount The concerned amount\n    /// @param currencyCt The address of the concerned currency contract (address(0) == ETH)\n    /// @param currencyId The ID of the concerned currency (0 for ETH and ERC20)\n    /// @param standard The standard of token (\"ERC20\", \"ERC721\")\n    function receiveTokensTo(address wallet, string memory, int256 amount,\n        address currencyCt, uint256 currencyId, string memory standard)\n    public\n    {\n        require(amount.isNonZeroPositiveInt256(), \"Amount not strictly positive [RevenueFund.sol:115]\");\n\n        // Execute transfer\n        TransferController controller = transferController(currencyCt, standard);\n        (bool success,) = address(controller).delegatecall(\n            abi.encodeWithSelector(\n                controller.getReceiveSignature(), msg.sender, this, uint256(amount), currencyCt, currencyId\n            )\n        );\n        require(success, \"Reception by controller failed [RevenueFund.sol:124]\");\n\n        // Add to balances\n        periodAccrual.add(amount, currencyCt, currencyId);\n        aggregateAccrual.add(amount, currencyCt, currencyId);\n\n        // Add currency to stores of currencies\n        periodCurrencies.add(currencyCt, currencyId);\n        aggregateCurrencies.add(currencyCt, currencyId);\n\n        // Add to transaction history\n        txHistory.addDeposit(amount, currencyCt, currencyId);\n\n        // Emit event\n        emit ReceiveEvent(wallet, amount, currencyCt, currencyId);\n    }\n\n    /// @notice Get the period accrual balance of the given currency\n    /// @param currencyCt The address of the concerned currency contract (address(0) == ETH)\n    /// @param currencyId The ID of the concerned currency (0 for ETH and ERC20)\n    /// @return The current period's accrual balance\n    function periodAccrualBalance(address currencyCt, uint256 currencyId)\n    public\n    view\n    returns (int256)\n    {\n        return periodAccrual.get(currencyCt, currencyId);\n    }\n\n    /// @notice Get the aggregate accrual balance of the given currency, including contribution from the\n    /// current accrual period\n    /// @param currencyCt The address of the concerned currency contract (address(0) == ETH)\n    /// @param currencyId The ID of the concerned currency (0 for ETH and ERC20)\n    /// @return The aggregate accrual balance\n    function aggregateAccrualBalance(address currencyCt, uint256 currencyId)\n    public\n    view\n    returns (int256)\n    {\n        return aggregateAccrual.get(currencyCt, currencyId);\n    }\n\n    /// @notice Get the count of currencies recorded in the accrual period\n    /// @return The number of currencies in the current accrual period\n    function periodCurrenciesCount()\n    public\n    view\n    returns (uint256)\n    {\n        return periodCurrencies.count();\n    }\n\n    /// @notice Get the currencies with indices in the given range that have been recorded in the current accrual period\n    /// @param low The lower currency index\n    /// @param up The upper currency index\n    /// @return The currencies of the given index range in the current accrual period\n    function periodCurrenciesByIndices(uint256 low, uint256 up)\n    public\n    view\n    returns (MonetaryTypesLib.Currency[] memory)\n    {\n        return periodCurrencies.getByIndices(low, up);\n    }\n\n    /// @notice Get the count of currencies ever recorded\n    /// @return The number of currencies ever recorded\n    function aggregateCurrenciesCount()\n    public\n    view\n    returns (uint256)\n    {\n        return aggregateCurrencies.count();\n    }\n\n    /// @notice Get the currencies with indices in the given range that have ever been recorded\n    /// @param low The lower currency index\n    /// @param up The upper currency index\n    /// @return The currencies of the given index range ever recorded\n    function aggregateCurrenciesByIndices(uint256 low, uint256 up)\n    public\n    view\n    returns (MonetaryTypesLib.Currency[] memory)\n    {\n        return aggregateCurrencies.getByIndices(low, up);\n    }\n\n    /// @notice Get the count of deposits\n    /// @return The count of deposits\n    function depositsCount()\n    public\n    view\n    returns (uint256)\n    {\n        return txHistory.depositsCount();\n    }\n\n    /// @notice Get the deposit at the given index\n    /// @return The deposit at the given index\n    function deposit(uint index)\n    public\n    view\n    returns (int256 amount, uint256 blockNumber, address currencyCt, uint256 currencyId)\n    {\n        return txHistory.deposit(index);\n    }\n\n    /// @notice Close the current accrual period of the given currencies\n    /// @param currencies The concerned currencies\n    function closeAccrualPeriod(MonetaryTypesLib.Currency[] memory currencies)\n    public\n    onlyOperator\n    {\n        require(\n            ConstantsLib.PARTS_PER() == totalBeneficiaryFraction,\n            \"Total beneficiary fraction out of bounds [RevenueFund.sol:236]\"\n        );\n\n        // Execute transfer\n        for (uint256 i = 0; i < currencies.length; i++) {\n            MonetaryTypesLib.Currency memory currency = currencies[i];\n\n            int256 remaining = periodAccrual.get(currency.ct, currency.id);\n\n            if (0 >= remaining)\n                continue;\n\n            for (uint256 j = 0; j < beneficiaries.length; j++) {\n                AccrualBeneficiary beneficiary = AccrualBeneficiary(address(beneficiaries[j]));\n\n                if (beneficiaryFraction(beneficiary) > 0) {\n                    int256 transferable = periodAccrual.get(currency.ct, currency.id)\n                    .mul(beneficiaryFraction(beneficiary))\n                    .div(ConstantsLib.PARTS_PER());\n\n                    if (transferable > remaining)\n                        transferable = remaining;\n\n                    if (transferable > 0) {\n                        // Transfer ETH to the beneficiary\n                        if (currency.ct == address(0))\n                            beneficiary.receiveEthersTo.value(uint256(transferable))(address(0), \"\");\n\n                        // Transfer token to the beneficiary\n                        else {\n                            TransferController controller = transferController(currency.ct, \"\");\n                            (bool success,) = address(controller).delegatecall(\n                                abi.encodeWithSelector(\n                                    controller.getApproveSignature(), address(beneficiary), uint256(transferable), currency.ct, currency.id\n                                )\n                            );\n                            require(success, \"Approval by controller failed [RevenueFund.sol:274]\");\n\n                            beneficiary.receiveTokensTo(address(0), \"\", transferable, currency.ct, currency.id, \"\");\n                        }\n\n                        remaining = remaining.sub(transferable);\n                    }\n                }\n            }\n\n            // Roll over remaining to next accrual period\n            periodAccrual.set(remaining, currency.ct, currency.id);\n        }\n\n        // Close accrual period of accrual beneficiaries\n        for (uint256 j = 0; j < beneficiaries.length; j++) {\n            AccrualBeneficiary beneficiary = AccrualBeneficiary(address(beneficiaries[j]));\n\n            // Require that beneficiary fraction is strictly positive\n            if (0 >= beneficiaryFraction(beneficiary))\n                continue;\n\n            // Close accrual period\n            beneficiary.closeAccrualPeriod(currencies);\n        }\n\n        // Emit event\n        emit CloseAccrualPeriodEvent();\n    }\n}\n\n/**\n * Strings Library\n * \n * In summary this is a simple library of string functions which make simple \n * string operations less tedious in solidity.\n * \n * Please be aware these functions can be quite gas heavy so use them only when\n * necessary not to clog the blockchain with expensive transactions.\n * \n * @author James Lockhart <james@n3tw0rk.co.uk>\n */\nlibrary Strings {\n\n    /**\n     * Concat (High gas cost)\n     * \n     * Appends two strings together and returns a new value\n     * \n     * @param _base When being used for a data type this is the extended object\n     *              otherwise this is the string which will be the concatenated\n     *              prefix\n     * @param _value The value to be the concatenated suffix\n     * @return string The resulting string from combinging the base and value\n     */\n    function concat(string memory _base, string memory _value)\n        internal\n        pure\n        returns (string memory) {\n        bytes memory _baseBytes = bytes(_base);\n        bytes memory _valueBytes = bytes(_value);\n\n        assert(_valueBytes.length > 0);\n\n        string memory _tmpValue = new string(_baseBytes.length +\n            _valueBytes.length);\n        bytes memory _newValue = bytes(_tmpValue);\n\n        uint i;\n        uint j;\n\n        for (i = 0; i < _baseBytes.length; i++) {\n            _newValue[j++] = _baseBytes[i];\n        }\n\n        for (i = 0; i < _valueBytes.length; i++) {\n            _newValue[j++] = _valueBytes[i];\n        }\n\n        return string(_newValue);\n    }\n\n    /**\n     * Index Of\n     *\n     * Locates and returns the position of a character within a string\n     * \n     * @param _base When being used for a data type this is the extended object\n     *              otherwise this is the string acting as the haystack to be\n     *              searched\n     * @param _value The needle to search for, at present this is currently\n     *               limited to one character\n     * @return int The position of the needle starting from 0 and returning -1\n     *             in the case of no matches found\n     */\n    function indexOf(string memory _base, string memory _value)\n        internal\n        pure\n        returns (int) {\n        return _indexOf(_base, _value, 0);\n    }\n\n    /**\n     * Index Of\n     *\n     * Locates and returns the position of a character within a string starting\n     * from a defined offset\n     * \n     * @param _base When being used for a data type this is the extended object\n     *              otherwise this is the string acting as the haystack to be\n     *              searched\n     * @param _value The needle to search for, at present this is currently\n     *               limited to one character\n     * @param _offset The starting point to start searching from which can start\n     *                from 0, but must not exceed the length of the string\n     * @return int The position of the needle starting from 0 and returning -1\n     *             in the case of no matches found\n     */\n    function _indexOf(string memory _base, string memory _value, uint _offset)\n        internal\n        pure\n        returns (int) {\n        bytes memory _baseBytes = bytes(_base);\n        bytes memory _valueBytes = bytes(_value);\n\n        assert(_valueBytes.length == 1);\n\n        for (uint i = _offset; i < _baseBytes.length; i++) {\n            if (_baseBytes[i] == _valueBytes[0]) {\n                return int(i);\n            }\n        }\n\n        return -1;\n    }\n\n    /**\n     * Length\n     * \n     * Returns the length of the specified string\n     * \n     * @param _base When being used for a data type this is the extended object\n     *              otherwise this is the string to be measured\n     * @return uint The length of the passed string\n     */\n    function length(string memory _base)\n        internal\n        pure\n        returns (uint) {\n        bytes memory _baseBytes = bytes(_base);\n        return _baseBytes.length;\n    }\n\n    /**\n     * Sub String\n     * \n     * Extracts the beginning part of a string based on the desired length\n     * \n     * @param _base When being used for a data type this is the extended object\n     *              otherwise this is the string that will be used for \n     *              extracting the sub string from\n     * @param _length The length of the sub string to be extracted from the base\n     * @return string The extracted sub string\n     */\n    function substring(string memory _base, int _length)\n        internal\n        pure\n        returns (string memory) {\n        return _substring(_base, _length, 0);\n    }\n\n    /**\n     * Sub String\n     * \n     * Extracts the part of a string based on the desired length and offset. The\n     * offset and length must not exceed the lenth of the base string.\n     * \n     * @param _base When being used for a data type this is the extended object\n     *              otherwise this is the string that will be used for \n     *              extracting the sub string from\n     * @param _length The length of the sub string to be extracted from the base\n     * @param _offset The starting point to extract the sub string from\n     * @return string The extracted sub string\n     */\n    function _substring(string memory _base, int _length, int _offset)\n        internal\n        pure\n        returns (string memory) {\n        bytes memory _baseBytes = bytes(_base);\n\n        assert(uint(_offset + _length) <= _baseBytes.length);\n\n        string memory _tmp = new string(uint(_length));\n        bytes memory _tmpBytes = bytes(_tmp);\n\n        uint j = 0;\n        for (uint i = uint(_offset); i < uint(_offset + _length); i++) {\n            _tmpBytes[j++] = _baseBytes[i];\n        }\n\n        return string(_tmpBytes);\n    }\n\n    /**\n     * String Split (Very high gas cost)\n     *\n     * Splits a string into an array of strings based off the delimiter value.\n     * Please note this can be quite a gas expensive function due to the use of\n     * storage so only use if really required.\n     *\n     * @param _base When being used for a data type this is the extended object\n     *               otherwise this is the string value to be split.\n     * @param _value The delimiter to split the string on which must be a single\n     *               character\n     * @return string[] An array of values split based off the delimiter, but\n     *                  do not container the delimiter.\n     */\n    function split(string memory _base, string memory _value)\n        internal\n        pure\n        returns (string[] memory splitArr) {\n        bytes memory _baseBytes = bytes(_base);\n\n        uint _offset = 0;\n        uint _splitsCount = 1;\n        while (_offset < _baseBytes.length - 1) {\n            int _limit = _indexOf(_base, _value, _offset);\n            if (_limit == -1)\n                break;\n            else {\n                _splitsCount++;\n                _offset = uint(_limit) + 1;\n            }\n        }\n\n        splitArr = new string[](_splitsCount);\n\n        _offset = 0;\n        _splitsCount = 0;\n        while (_offset < _baseBytes.length - 1) {\n\n            int _limit = _indexOf(_base, _value, _offset);\n            if (_limit == - 1) {\n                _limit = int(_baseBytes.length);\n            }\n\n            string memory _tmp = new string(uint(_limit) - _offset);\n            bytes memory _tmpBytes = bytes(_tmp);\n\n            uint j = 0;\n            for (uint i = _offset; i < uint(_limit); i++) {\n                _tmpBytes[j++] = _baseBytes[i];\n            }\n            _offset = uint(_limit) + 1;\n            splitArr[_splitsCount++] = string(_tmpBytes);\n        }\n        return splitArr;\n    }\n\n    /**\n     * Compare To\n     * \n     * Compares the characters of two strings, to ensure that they have an \n     * identical footprint\n     * \n     * @param _base When being used for a data type this is the extended object\n     *               otherwise this is the string base to compare against\n     * @param _value The string the base is being compared to\n     * @return bool Simply notates if the two string have an equivalent\n     */\n    function compareTo(string memory _base, string memory _value)\n        internal\n        pure\n        returns (bool) {\n        bytes memory _baseBytes = bytes(_base);\n        bytes memory _valueBytes = bytes(_value);\n\n        if (_baseBytes.length != _valueBytes.length) {\n            return false;\n        }\n\n        for (uint i = 0; i < _baseBytes.length; i++) {\n            if (_baseBytes[i] != _valueBytes[i]) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    /**\n     * Compare To Ignore Case (High gas cost)\n     * \n     * Compares the characters of two strings, converting them to the same case\n     * where applicable to alphabetic characters to distinguish if the values\n     * match.\n     * \n     * @param _base When being used for a data type this is the extended object\n     *               otherwise this is the string base to compare against\n     * @param _value The string the base is being compared to\n     * @return bool Simply notates if the two string have an equivalent value\n     *              discarding case\n     */\n    function compareToIgnoreCase(string memory _base, string memory _value)\n        internal\n        pure\n        returns (bool) {\n        bytes memory _baseBytes = bytes(_base);\n        bytes memory _valueBytes = bytes(_value);\n\n        if (_baseBytes.length != _valueBytes.length) {\n            return false;\n        }\n\n        for (uint i = 0; i < _baseBytes.length; i++) {\n            if (_baseBytes[i] != _valueBytes[i] &&\n            _upper(_baseBytes[i]) != _upper(_valueBytes[i])) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    /**\n     * Upper\n     * \n     * Converts all the values of a string to their corresponding upper case\n     * value.\n     * \n     * @param _base When being used for a data type this is the extended object\n     *              otherwise this is the string base to convert to upper case\n     * @return string \n     */\n    function upper(string memory _base)\n        internal\n        pure\n        returns (string memory) {\n        bytes memory _baseBytes = bytes(_base);\n        for (uint i = 0; i < _baseBytes.length; i++) {\n            _baseBytes[i] = _upper(_baseBytes[i]);\n        }\n        return string(_baseBytes);\n    }\n\n    /**\n     * Lower\n     * \n     * Converts all the values of a string to their corresponding lower case\n     * value.\n     * \n     * @param _base When being used for a data type this is the extended object\n     *              otherwise this is the string base to convert to lower case\n     * @return string \n     */\n    function lower(string memory _base)\n        internal\n        pure\n        returns (string memory) {\n        bytes memory _baseBytes = bytes(_base);\n        for (uint i = 0; i < _baseBytes.length; i++) {\n            _baseBytes[i] = _lower(_baseBytes[i]);\n        }\n        return string(_baseBytes);\n    }\n\n    /**\n     * Upper\n     * \n     * Convert an alphabetic character to upper case and return the original\n     * value when not alphabetic\n     * \n     * @param _b1 The byte to be converted to upper case\n     * @return bytes1 The converted value if the passed value was alphabetic\n     *                and in a lower case otherwise returns the original value\n     */\n    function _upper(bytes1 _b1)\n        private\n        pure\n        returns (bytes1) {\n\n        if (_b1 >= 0x61 && _b1 <= 0x7A) {\n            return bytes1(uint8(_b1) - 32);\n        }\n\n        return _b1;\n    }\n\n    /**\n     * Lower\n     * \n     * Convert an alphabetic character to lower case and return the original\n     * value when not alphabetic\n     * \n     * @param _b1 The byte to be converted to lower case\n     * @return bytes1 The converted value if the passed value was alphabetic\n     *                and in a upper case otherwise returns the original value\n     */\n    function _lower(bytes1 _b1)\n        private\n        pure\n        returns (bytes1) {\n\n        if (_b1 >= 0x41 && _b1 <= 0x5A) {\n            return bytes1(uint8(_b1) + 32);\n        }\n\n        return _b1;\n    }\n}\n\n/*\n * Hubii Nahmii\n *\n * Compliant with the Hubii Nahmii specification v0.12.\n *\n * Copyright (C) 2017-2018 Hubii AS\n */\n\n/**\n * @title PartnerFund\n * @notice Where partners’ fees are managed\n */\ncontract PartnerFund is Ownable, Beneficiary, TransferControllerManageable {\n    using FungibleBalanceLib for FungibleBalanceLib.Balance;\n    using TxHistoryLib for TxHistoryLib.TxHistory;\n    using SafeMathIntLib for int256;\n    using Strings for string;\n\n    //\n    // Structures\n    // -----------------------------------------------------------------------------------------------------------------\n    struct Partner {\n        bytes32 nameHash;\n\n        uint256 fee;\n        address wallet;\n        uint256 index;\n\n        bool operatorCanUpdate;\n        bool partnerCanUpdate;\n\n        FungibleBalanceLib.Balance active;\n        FungibleBalanceLib.Balance staged;\n\n        TxHistoryLib.TxHistory txHistory;\n        FullBalanceHistory[] fullBalanceHistory;\n    }\n\n    struct FullBalanceHistory {\n        uint256 listIndex;\n        int256 balance;\n        uint256 blockNumber;\n    }\n\n    //\n    // Variables\n    // -----------------------------------------------------------------------------------------------------------------\n    Partner[] private partners;\n\n    mapping(bytes32 => uint256) private _indexByNameHash;\n    mapping(address => uint256) private _indexByWallet;\n\n    //\n    // Events\n    // -----------------------------------------------------------------------------------------------------------------\n    event ReceiveEvent(address from, int256 amount, address currencyCt, uint256 currencyId);\n    event RegisterPartnerByNameEvent(string name, uint256 fee, address wallet);\n    event RegisterPartnerByNameHashEvent(bytes32 nameHash, uint256 fee, address wallet);\n    event SetFeeByIndexEvent(uint256 index, uint256 oldFee, uint256 newFee);\n    event SetFeeByNameEvent(string name, uint256 oldFee, uint256 newFee);\n    event SetFeeByNameHashEvent(bytes32 nameHash, uint256 oldFee, uint256 newFee);\n    event SetFeeByWalletEvent(address wallet, uint256 oldFee, uint256 newFee);\n    event SetPartnerWalletByIndexEvent(uint256 index, address oldWallet, address newWallet);\n    event SetPartnerWalletByNameEvent(string name, address oldWallet, address newWallet);\n    event SetPartnerWalletByNameHashEvent(bytes32 nameHash, address oldWallet, address newWallet);\n    event SetPartnerWalletByWalletEvent(address oldWallet, address newWallet);\n    event StageEvent(address from, int256 amount, address currencyCt, uint256 currencyId);\n    event WithdrawEvent(address to, int256 amount, address currencyCt, uint256 currencyId);\n\n    //\n    // Constructor\n    // -----------------------------------------------------------------------------------------------------------------\n    constructor(address deployer) Ownable(deployer) public {\n    }\n\n    //\n    // Functions\n    // -----------------------------------------------------------------------------------------------------------------\n    /// @notice Fallback function that deposits ethers\n    function() external payable {\n        _receiveEthersTo(\n            indexByWallet(msg.sender) - 1, SafeMathIntLib.toNonZeroInt256(msg.value)\n        );\n    }\n\n    /// @notice Receive ethers to\n    /// @param tag The tag of the concerned partner\n    function receiveEthersTo(address tag, string memory)\n    public\n    payable\n    {\n        _receiveEthersTo(\n            uint256(tag) - 1, SafeMathIntLib.toNonZeroInt256(msg.value)\n        );\n    }\n\n    /// @notice Receive tokens\n    /// @param amount The concerned amount\n    /// @param currencyCt The address of the concerned currency contract (address(0) == ETH)\n    /// @param currencyId The ID of the concerned currency (0 for ETH and ERC20)\n    /// @param standard The standard of token (\"ERC20\", \"ERC721\")\n    function receiveTokens(string memory, int256 amount, address currencyCt,\n        uint256 currencyId, string memory standard)\n    public\n    {\n        _receiveTokensTo(\n            indexByWallet(msg.sender) - 1, amount, currencyCt, currencyId, standard\n        );\n    }\n\n    /// @notice Receive tokens to\n    /// @param tag The tag of the concerned partner\n    /// @param amount The concerned amount\n    /// @param currencyCt The address of the concerned currency contract (address(0) == ETH)\n    /// @param currencyId The ID of the concerned currency (0 for ETH and ERC20)\n    /// @param standard The standard of token (\"ERC20\", \"ERC721\")\n    function receiveTokensTo(address tag, string memory, int256 amount, address currencyCt,\n        uint256 currencyId, string memory standard)\n    public\n    {\n        _receiveTokensTo(\n            uint256(tag) - 1, amount, currencyCt, currencyId, standard\n        );\n    }\n\n    /// @notice Hash name\n    /// @param name The name to be hashed\n    /// @return The hash value\n    function hashName(string memory name)\n    public\n    pure\n    returns (bytes32)\n    {\n        return keccak256(abi.encodePacked(name.upper()));\n    }\n\n    /// @notice Get deposit by partner and deposit indices\n    /// @param partnerIndex The index of the concerned partner\n    /// @param depositIndex The index of the concerned deposit\n    /// return The deposit parameters\n    function depositByIndices(uint256 partnerIndex, uint256 depositIndex)\n    public\n    view\n    returns (int256 balance, uint256 blockNumber, address currencyCt, uint256 currencyId)\n    {\n        // Require partner index is one of registered partner\n        require(0 < partnerIndex && partnerIndex <= partners.length, \"Some error message when require fails [PartnerFund.sol:160]\");\n\n        return _depositByIndices(partnerIndex - 1, depositIndex);\n    }\n\n    /// @notice Get deposit by partner name and deposit indices\n    /// @param name The name of the concerned partner\n    /// @param depositIndex The index of the concerned deposit\n    /// return The deposit parameters\n    function depositByName(string memory name, uint depositIndex)\n    public\n    view\n    returns (int256 balance, uint256 blockNumber, address currencyCt, uint256 currencyId)\n    {\n        // Implicitly require that partner name is registered\n        return _depositByIndices(indexByName(name) - 1, depositIndex);\n    }\n\n    /// @notice Get deposit by partner name hash and deposit indices\n    /// @param nameHash The hashed name of the concerned partner\n    /// @param depositIndex The index of the concerned deposit\n    /// return The deposit parameters\n    function depositByNameHash(bytes32 nameHash, uint depositIndex)\n    public\n    view\n    returns (int256 balance, uint256 blockNumber, address currencyCt, uint256 currencyId)\n    {\n        // Implicitly require that partner name hash is registered\n        return _depositByIndices(indexByNameHash(nameHash) - 1, depositIndex);\n    }\n\n    /// @notice Get deposit by partner wallet and deposit indices\n    /// @param wallet The wallet of the concerned partner\n    /// @param depositIndex The index of the concerned deposit\n    /// return The deposit parameters\n    function depositByWallet(address wallet, uint depositIndex)\n    public\n    view\n    returns (int256 balance, uint256 blockNumber, address currencyCt, uint256 currencyId)\n    {\n        // Implicitly require that partner wallet is registered\n        return _depositByIndices(indexByWallet(wallet) - 1, depositIndex);\n    }\n\n    /// @notice Get deposits count by partner index\n    /// @param index The index of the concerned partner\n    /// return The deposits count\n    function depositsCountByIndex(uint256 index)\n    public\n    view\n    returns (uint256)\n    {\n        // Require partner index is one of registered partner\n        require(0 < index && index <= partners.length, \"Some error message when require fails [PartnerFund.sol:213]\");\n\n        return _depositsCountByIndex(index - 1);\n    }\n\n    /// @notice Get deposits count by partner name\n    /// @param name The name of the concerned partner\n    /// return The deposits count\n    function depositsCountByName(string memory name)\n    public\n    view\n    returns (uint256)\n    {\n        // Implicitly require that partner name is registered\n        return _depositsCountByIndex(indexByName(name) - 1);\n    }\n\n    /// @notice Get deposits count by partner name hash\n    /// @param nameHash The hashed name of the concerned partner\n    /// return The deposits count\n    function depositsCountByNameHash(bytes32 nameHash)\n    public\n    view\n    returns (uint256)\n    {\n        // Implicitly require that partner name hash is registered\n        return _depositsCountByIndex(indexByNameHash(nameHash) - 1);\n    }\n\n    /// @notice Get deposits count by partner wallet\n    /// @param wallet The wallet of the concerned partner\n    /// return The deposits count\n    function depositsCountByWallet(address wallet)\n    public\n    view\n    returns (uint256)\n    {\n        // Implicitly require that partner wallet is registered\n        return _depositsCountByIndex(indexByWallet(wallet) - 1);\n    }\n\n    /// @notice Get active balance by partner index and currency\n    /// @param index The index of the concerned partner\n    /// @param currencyCt The address of the concerned currency contract (address(0) == ETH)\n    /// @param currencyId The ID of the concerned currency (0 for ETH and ERC20)\n    /// return The active balance\n    function activeBalanceByIndex(uint256 index, address currencyCt, uint256 currencyId)\n    public\n    view\n    returns (int256)\n    {\n        // Require partner index is one of registered partner\n        require(0 < index && index <= partners.length, \"Some error message when require fails [PartnerFund.sol:265]\");\n\n        return _activeBalanceByIndex(index - 1, currencyCt, currencyId);\n    }\n\n    /// @notice Get active balance by partner name and currency\n    /// @param name The name of the concerned partner\n    /// @param currencyCt The address of the concerned currency contract (address(0) == ETH)\n    /// @param currencyId The ID of the concerned currency (0 for ETH and ERC20)\n    /// return The active balance\n    function activeBalanceByName(string memory name, address currencyCt, uint256 currencyId)\n    public\n    view\n    returns (int256)\n    {\n        // Implicitly require that partner name is registered\n        return _activeBalanceByIndex(indexByName(name) - 1, currencyCt, currencyId);\n    }\n\n    /// @notice Get active balance by partner name hash and currency\n    /// @param nameHash The hashed name of the concerned partner\n    /// @param currencyCt The address of the concerned currency contract (address(0) == ETH)\n    /// @param currencyId The ID of the concerned currency (0 for ETH and ERC20)\n    /// return The active balance\n    function activeBalanceByNameHash(bytes32 nameHash, address currencyCt, uint256 currencyId)\n    public\n    view\n    returns (int256)\n    {\n        // Implicitly require that partner name hash is registered\n        return _activeBalanceByIndex(indexByNameHash(nameHash) - 1, currencyCt, currencyId);\n    }\n\n    /// @notice Get active balance by partner wallet and currency\n    /// @param wallet The wallet of the concerned partner\n    /// @param currencyCt The address of the concerned currency contract (address(0) == ETH)\n    /// @param currencyId The ID of the concerned currency (0 for ETH and ERC20)\n    /// return The active balance\n    function activeBalanceByWallet(address wallet, address currencyCt, uint256 currencyId)\n    public\n    view\n    returns (int256)\n    {\n        // Implicitly require that partner wallet is registered\n        return _activeBalanceByIndex(indexByWallet(wallet) - 1, currencyCt, currencyId);\n    }\n\n    /// @notice Get staged balance by partner index and currency\n    /// @param index The index of the concerned partner\n    /// @param currencyCt The address of the concerned currency contract (address(0) == ETH)\n    /// @param currencyId The ID of the concerned currency (0 for ETH and ERC20)\n    /// return The staged balance\n    function stagedBalanceByIndex(uint256 index, address currencyCt, uint256 currencyId)\n    public\n    view\n    returns (int256)\n    {\n        // Require partner index is one of registered partner\n        require(0 < index && index <= partners.length, \"Some error message when require fails [PartnerFund.sol:323]\");\n\n        return _stagedBalanceByIndex(index - 1, currencyCt, currencyId);\n    }\n\n    /// @notice Get staged balance by partner name and currency\n    /// @param name The name of the concerned partner\n    /// @param currencyCt The address of the concerned currency contract (address(0) == ETH)\n    /// @param currencyId The ID of the concerned currency (0 for ETH and ERC20)\n    /// return The staged balance\n    function stagedBalanceByName(string memory name, address currencyCt, uint256 currencyId)\n    public\n    view\n    returns (int256)\n    {\n        // Implicitly require that partner name is registered\n        return _stagedBalanceByIndex(indexByName(name) - 1, currencyCt, currencyId);\n    }\n\n    /// @notice Get staged balance by partner name hash and currency\n    /// @param nameHash The hashed name of the concerned partner\n    /// @param currencyCt The address of the concerned currency contract (address(0) == ETH)\n    /// @param currencyId The ID of the concerned currency (0 for ETH and ERC20)\n    /// return The staged balance\n    function stagedBalanceByNameHash(bytes32 nameHash, address currencyCt, uint256 currencyId)\n    public\n    view\n    returns (int256)\n    {\n        // Implicitly require that partner name is registered\n        return _stagedBalanceByIndex(indexByNameHash(nameHash) - 1, currencyCt, currencyId);\n    }\n\n    /// @notice Get staged balance by partner wallet and currency\n    /// @param wallet The wallet of the concerned partner\n    /// @param currencyCt The address of the concerned currency contract (address(0) == ETH)\n    /// @param currencyId The ID of the concerned currency (0 for ETH and ERC20)\n    /// return The staged balance\n    function stagedBalanceByWallet(address wallet, address currencyCt, uint256 currencyId)\n    public\n    view\n    returns (int256)\n    {\n        // Implicitly require that partner wallet is registered\n        return _stagedBalanceByIndex(indexByWallet(wallet) - 1, currencyCt, currencyId);\n    }\n\n    /// @notice Get the number of partners\n    /// @return The number of partners\n    function partnersCount()\n    public\n    view\n    returns (uint256)\n    {\n        return partners.length;\n    }\n\n    /// @notice Register a partner by name\n    /// @param name The name of the concerned partner\n    /// @param fee The partner's fee fraction\n    /// @param wallet The partner's wallet\n    /// @param partnerCanUpdate Indicator of whether partner can update fee and wallet\n    /// @param operatorCanUpdate Indicator of whether operator can update fee and wallet\n    function registerByName(string memory name, uint256 fee, address wallet,\n        bool partnerCanUpdate, bool operatorCanUpdate)\n    public\n    onlyOperator\n    {\n        // Require not empty name string\n        require(bytes(name).length > 0, \"Some error message when require fails [PartnerFund.sol:392]\");\n\n        // Hash name\n        bytes32 nameHash = hashName(name);\n\n        // Register partner\n        _registerPartnerByNameHash(nameHash, fee, wallet, partnerCanUpdate, operatorCanUpdate);\n\n        // Emit event\n        emit RegisterPartnerByNameEvent(name, fee, wallet);\n    }\n\n    /// @notice Register a partner by name hash\n    /// @param nameHash The hashed name of the concerned partner\n    /// @param fee The partner's fee fraction\n    /// @param wallet The partner's wallet\n    /// @param partnerCanUpdate Indicator of whether partner can update fee and wallet\n    /// @param operatorCanUpdate Indicator of whether operator can update fee and wallet\n    function registerByNameHash(bytes32 nameHash, uint256 fee, address wallet,\n        bool partnerCanUpdate, bool operatorCanUpdate)\n    public\n    onlyOperator\n    {\n        // Register partner\n        _registerPartnerByNameHash(nameHash, fee, wallet, partnerCanUpdate, operatorCanUpdate);\n\n        // Emit event\n        emit RegisterPartnerByNameHashEvent(nameHash, fee, wallet);\n    }\n\n    /// @notice Gets the 1-based index of partner by its name\n    /// @dev Reverts if name does not correspond to registered partner\n    /// @return Index of partner by given name\n    function indexByNameHash(bytes32 nameHash)\n    public\n    view\n    returns (uint256)\n    {\n        uint256 index = _indexByNameHash[nameHash];\n        require(0 < index, \"Some error message when require fails [PartnerFund.sol:431]\");\n        return index;\n    }\n\n    /// @notice Gets the 1-based index of partner by its name\n    /// @dev Reverts if name does not correspond to registered partner\n    /// @return Index of partner by given name\n    function indexByName(string memory name)\n    public\n    view\n    returns (uint256)\n    {\n        return indexByNameHash(hashName(name));\n    }\n\n    /// @notice Gets the 1-based index of partner by its wallet\n    /// @dev Reverts if wallet does not correspond to registered partner\n    /// @return Index of partner by given wallet\n    function indexByWallet(address wallet)\n    public\n    view\n    returns (uint256)\n    {\n        uint256 index = _indexByWallet[wallet];\n        require(0 < index, \"Some error message when require fails [PartnerFund.sol:455]\");\n        return index;\n    }\n\n    /// @notice Gauge whether a partner by the given name is registered\n    /// @param name The name of the concerned partner\n    /// @return true if partner is registered, else false\n    function isRegisteredByName(string memory name)\n    public\n    view\n    returns (bool)\n    {\n        return (0 < _indexByNameHash[hashName(name)]);\n    }\n\n    /// @notice Gauge whether a partner by the given name hash is registered\n    /// @param nameHash The hashed name of the concerned partner\n    /// @return true if partner is registered, else false\n    function isRegisteredByNameHash(bytes32 nameHash)\n    public\n    view\n    returns (bool)\n    {\n        return (0 < _indexByNameHash[nameHash]);\n    }\n\n    /// @notice Gauge whether a partner by the given wallet is registered\n    /// @param wallet The wallet of the concerned partner\n    /// @return true if partner is registered, else false\n    function isRegisteredByWallet(address wallet)\n    public\n    view\n    returns (bool)\n    {\n        return (0 < _indexByWallet[wallet]);\n    }\n\n    /// @notice Get the partner fee fraction by the given partner index\n    /// @param index The index of the concerned partner\n    /// @return The fee fraction\n    function feeByIndex(uint256 index)\n    public\n    view\n    returns (uint256)\n    {\n        // Require partner index is one of registered partner\n        require(0 < index && index <= partners.length, \"Some error message when require fails [PartnerFund.sol:501]\");\n\n        return _partnerFeeByIndex(index - 1);\n    }\n\n    /// @notice Get the partner fee fraction by the given partner name\n    /// @param name The name of the concerned partner\n    /// @return The fee fraction\n    function feeByName(string memory name)\n    public\n    view\n    returns (uint256)\n    {\n        // Get fee, implicitly requiring that partner name is registered\n        return _partnerFeeByIndex(indexByName(name) - 1);\n    }\n\n    /// @notice Get the partner fee fraction by the given partner name hash\n    /// @param nameHash The hashed name of the concerned partner\n    /// @return The fee fraction\n    function feeByNameHash(bytes32 nameHash)\n    public\n    view\n    returns (uint256)\n    {\n        // Get fee, implicitly requiring that partner name hash is registered\n        return _partnerFeeByIndex(indexByNameHash(nameHash) - 1);\n    }\n\n    /// @notice Get the partner fee fraction by the given partner wallet\n    /// @param wallet The wallet of the concerned partner\n    /// @return The fee fraction\n    function feeByWallet(address wallet)\n    public\n    view\n    returns (uint256)\n    {\n        // Get fee, implicitly requiring that partner wallet is registered\n        return _partnerFeeByIndex(indexByWallet(wallet) - 1);\n    }\n\n    /// @notice Set the partner fee fraction by the given partner index\n    /// @param index The index of the concerned partner\n    /// @param newFee The partner's fee fraction\n    function setFeeByIndex(uint256 index, uint256 newFee)\n    public\n    {\n        // Require partner index is one of registered partner\n        require(0 < index && index <= partners.length, \"Some error message when require fails [PartnerFund.sol:549]\");\n\n        // Update fee\n        uint256 oldFee = _setPartnerFeeByIndex(index - 1, newFee);\n\n        // Emit event\n        emit SetFeeByIndexEvent(index, oldFee, newFee);\n    }\n\n    /// @notice Set the partner fee fraction by the given partner name\n    /// @param name The name of the concerned partner\n    /// @param newFee The partner's fee fraction\n    function setFeeByName(string memory name, uint256 newFee)\n    public\n    {\n        // Update fee, implicitly requiring that partner name is registered\n        uint256 oldFee = _setPartnerFeeByIndex(indexByName(name) - 1, newFee);\n\n        // Emit event\n        emit SetFeeByNameEvent(name, oldFee, newFee);\n    }\n\n    /// @notice Set the partner fee fraction by the given partner name hash\n    /// @param nameHash The hashed name of the concerned partner\n    /// @param newFee The partner's fee fraction\n    function setFeeByNameHash(bytes32 nameHash, uint256 newFee)\n    public\n    {\n        // Update fee, implicitly requiring that partner name hash is registered\n        uint256 oldFee = _setPartnerFeeByIndex(indexByNameHash(nameHash) - 1, newFee);\n\n        // Emit event\n        emit SetFeeByNameHashEvent(nameHash, oldFee, newFee);\n    }\n\n    /// @notice Set the partner fee fraction by the given partner wallet\n    /// @param wallet The wallet of the concerned partner\n    /// @param newFee The partner's fee fraction\n    function setFeeByWallet(address wallet, uint256 newFee)\n    public\n    {\n        // Update fee, implicitly requiring that partner wallet is registered\n        uint256 oldFee = _setPartnerFeeByIndex(indexByWallet(wallet) - 1, newFee);\n\n        // Emit event\n        emit SetFeeByWalletEvent(wallet, oldFee, newFee);\n    }\n\n    /// @notice Get the partner wallet by the given partner index\n    /// @param index The index of the concerned partner\n    /// @return The wallet\n    function walletByIndex(uint256 index)\n    public\n    view\n    returns (address)\n    {\n        // Require partner index is one of registered partner\n        require(0 < index && index <= partners.length, \"Some error message when require fails [PartnerFund.sol:606]\");\n\n        return partners[index - 1].wallet;\n    }\n\n    /// @notice Get the partner wallet by the given partner name\n    /// @param name The name of the concerned partner\n    /// @return The wallet\n    function walletByName(string memory name)\n    public\n    view\n    returns (address)\n    {\n        // Get wallet, implicitly requiring that partner name is registered\n        return partners[indexByName(name) - 1].wallet;\n    }\n\n    /// @notice Get the partner wallet by the given partner name hash\n    /// @param nameHash The hashed name of the concerned partner\n    /// @return The wallet\n    function walletByNameHash(bytes32 nameHash)\n    public\n    view\n    returns (address)\n    {\n        // Get wallet, implicitly requiring that partner name hash is registered\n        return partners[indexByNameHash(nameHash) - 1].wallet;\n    }\n\n    /// @notice Set the partner wallet by the given partner index\n    /// @param index The index of the concerned partner\n    /// @return newWallet The partner's wallet\n    function setWalletByIndex(uint256 index, address newWallet)\n    public\n    {\n        // Require partner index is one of registered partner\n        require(0 < index && index <= partners.length, \"Some error message when require fails [PartnerFund.sol:642]\");\n\n        // Update wallet\n        address oldWallet = _setPartnerWalletByIndex(index - 1, newWallet);\n\n        // Emit event\n        emit SetPartnerWalletByIndexEvent(index, oldWallet, newWallet);\n    }\n\n    /// @notice Set the partner wallet by the given partner name\n    /// @param name The name of the concerned partner\n    /// @return newWallet The partner's wallet\n    function setWalletByName(string memory name, address newWallet)\n    public\n    {\n        // Update wallet\n        address oldWallet = _setPartnerWalletByIndex(indexByName(name) - 1, newWallet);\n\n        // Emit event\n        emit SetPartnerWalletByNameEvent(name, oldWallet, newWallet);\n    }\n\n    /// @notice Set the partner wallet by the given partner name hash\n    /// @param nameHash The hashed name of the concerned partner\n    /// @return newWallet The partner's wallet\n    function setWalletByNameHash(bytes32 nameHash, address newWallet)\n    public\n    {\n        // Update wallet\n        address oldWallet = _setPartnerWalletByIndex(indexByNameHash(nameHash) - 1, newWallet);\n\n        // Emit event\n        emit SetPartnerWalletByNameHashEvent(nameHash, oldWallet, newWallet);\n    }\n\n    /// @notice Set the new partner wallet by the given old partner wallet\n    /// @param oldWallet The old wallet of the concerned partner\n    /// @return newWallet The partner's new wallet\n    function setWalletByWallet(address oldWallet, address newWallet)\n    public\n    {\n        // Update wallet\n        _setPartnerWalletByIndex(indexByWallet(oldWallet) - 1, newWallet);\n\n        // Emit event\n        emit SetPartnerWalletByWalletEvent(oldWallet, newWallet);\n    }\n\n    /// @notice Stage the amount for subsequent withdrawal\n    /// @param amount The concerned amount to stage\n    /// @param currencyCt The address of the concerned currency contract (address(0) == ETH)\n    /// @param currencyId The ID of the concerned currency (0 for ETH and ERC20)\n    function stage(int256 amount, address currencyCt, uint256 currencyId)\n    public\n    {\n        // Get index, implicitly requiring that msg.sender is wallet of registered partner\n        uint256 index = indexByWallet(msg.sender);\n\n        // Require positive amount\n        require(amount.isPositiveInt256(), \"Some error message when require fails [PartnerFund.sol:701]\");\n\n        // Clamp amount to move\n        amount = amount.clampMax(partners[index - 1].active.get(currencyCt, currencyId));\n\n        partners[index - 1].active.sub(amount, currencyCt, currencyId);\n        partners[index - 1].staged.add(amount, currencyCt, currencyId);\n\n        partners[index - 1].txHistory.addDeposit(amount, currencyCt, currencyId);\n\n        // Add to full deposit history\n        partners[index - 1].fullBalanceHistory.push(\n            FullBalanceHistory(\n                partners[index - 1].txHistory.depositsCount() - 1,\n                partners[index - 1].active.get(currencyCt, currencyId),\n                block.number\n            )\n        );\n\n        // Emit event\n        emit StageEvent(msg.sender, amount, currencyCt, currencyId);\n    }\n\n    /// @notice Withdraw the given amount from staged balance\n    /// @param amount The concerned amount to withdraw\n    /// @param currencyCt The address of the concerned currency contract (address(0) == ETH)\n    /// @param currencyId The ID of the concerned currency (0 for ETH and ERC20)\n    /// @param standard The standard of the token (\"\" for default registered, \"ERC20\", \"ERC721\")\n    function withdraw(int256 amount, address currencyCt, uint256 currencyId, string memory standard)\n    public\n    {\n        // Get index, implicitly requiring that msg.sender is wallet of registered partner\n        uint256 index = indexByWallet(msg.sender);\n\n        // Require positive amount\n        require(amount.isPositiveInt256(), \"Some error message when require fails [PartnerFund.sol:736]\");\n\n        // Clamp amount to move\n        amount = amount.clampMax(partners[index - 1].staged.get(currencyCt, currencyId));\n\n        partners[index - 1].staged.sub(amount, currencyCt, currencyId);\n\n        // Execute transfer\n        if (address(0) == currencyCt && 0 == currencyId)\n            msg.sender.transfer(uint256(amount));\n\n        else {\n            TransferController controller = transferController(currencyCt, standard);\n            (bool success,) = address(controller).delegatecall(\n                abi.encodeWithSelector(\n                    controller.getDispatchSignature(), address(this), msg.sender, uint256(amount), currencyCt, currencyId\n                )\n            );\n            require(success, \"Some error message when require fails [PartnerFund.sol:754]\");\n        }\n\n        // Emit event\n        emit WithdrawEvent(msg.sender, amount, currencyCt, currencyId);\n    }\n\n    //\n    // Private functions\n    // -----------------------------------------------------------------------------------------------------------------\n    /// @dev index is 0-based\n    function _receiveEthersTo(uint256 index, int256 amount)\n    private\n    {\n        // Require that index is within bounds\n        require(index < partners.length, \"Some error message when require fails [PartnerFund.sol:769]\");\n\n        // Add to active\n        partners[index].active.add(amount, address(0), 0);\n        partners[index].txHistory.addDeposit(amount, address(0), 0);\n\n        // Add to full deposit history\n        partners[index].fullBalanceHistory.push(\n            FullBalanceHistory(\n                partners[index].txHistory.depositsCount() - 1,\n                partners[index].active.get(address(0), 0),\n                block.number\n            )\n        );\n\n        // Emit event\n        emit ReceiveEvent(msg.sender, amount, address(0), 0);\n    }\n\n    /// @dev index is 0-based\n    function _receiveTokensTo(uint256 index, int256 amount, address currencyCt,\n        uint256 currencyId, string memory standard)\n    private\n    {\n        // Require that index is within bounds\n        require(index < partners.length, \"Some error message when require fails [PartnerFund.sol:794]\");\n\n        require(amount.isNonZeroPositiveInt256(), \"Some error message when require fails [PartnerFund.sol:796]\");\n\n        // Execute transfer\n        TransferController controller = transferController(currencyCt, standard);\n        (bool success,) = address(controller).delegatecall(\n            abi.encodeWithSelector(\n                controller.getReceiveSignature(), msg.sender, this, uint256(amount), currencyCt, currencyId\n            )\n        );\n        require(success, \"Some error message when require fails [PartnerFund.sol:805]\");\n\n        // Add to active\n        partners[index].active.add(amount, currencyCt, currencyId);\n        partners[index].txHistory.addDeposit(amount, currencyCt, currencyId);\n\n        // Add to full deposit history\n        partners[index].fullBalanceHistory.push(\n            FullBalanceHistory(\n                partners[index].txHistory.depositsCount() - 1,\n                partners[index].active.get(currencyCt, currencyId),\n                block.number\n            )\n        );\n\n        // Emit event\n        emit ReceiveEvent(msg.sender, amount, currencyCt, currencyId);\n    }\n\n    /// @dev partnerIndex is 0-based\n    function _depositByIndices(uint256 partnerIndex, uint256 depositIndex)\n    private\n    view\n    returns (int256 balance, uint256 blockNumber, address currencyCt, uint256 currencyId)\n    {\n        require(depositIndex < partners[partnerIndex].fullBalanceHistory.length, \"Some error message when require fails [PartnerFund.sol:830]\");\n\n        FullBalanceHistory storage entry = partners[partnerIndex].fullBalanceHistory[depositIndex];\n        (,, currencyCt, currencyId) = partners[partnerIndex].txHistory.deposit(entry.listIndex);\n\n        balance = entry.balance;\n        blockNumber = entry.blockNumber;\n    }\n\n    /// @dev index is 0-based\n    function _depositsCountByIndex(uint256 index)\n    private\n    view\n    returns (uint256)\n    {\n        return partners[index].fullBalanceHistory.length;\n    }\n\n    /// @dev index is 0-based\n    function _activeBalanceByIndex(uint256 index, address currencyCt, uint256 currencyId)\n    private\n    view\n    returns (int256)\n    {\n        return partners[index].active.get(currencyCt, currencyId);\n    }\n\n    /// @dev index is 0-based\n    function _stagedBalanceByIndex(uint256 index, address currencyCt, uint256 currencyId)\n    private\n    view\n    returns (int256)\n    {\n        return partners[index].staged.get(currencyCt, currencyId);\n    }\n\n    function _registerPartnerByNameHash(bytes32 nameHash, uint256 fee, address wallet,\n        bool partnerCanUpdate, bool operatorCanUpdate)\n    private\n    {\n        // Require that the name is not previously registered\n        require(0 == _indexByNameHash[nameHash], \"Some error message when require fails [PartnerFund.sol:871]\");\n\n        // Require possibility to update\n        require(partnerCanUpdate || operatorCanUpdate, \"Some error message when require fails [PartnerFund.sol:874]\");\n\n        // Add new partner\n        partners.length++;\n\n        // Reference by 1-based index\n        uint256 index = partners.length;\n\n        // Update partner map\n        partners[index - 1].nameHash = nameHash;\n        partners[index - 1].fee = fee;\n        partners[index - 1].wallet = wallet;\n        partners[index - 1].partnerCanUpdate = partnerCanUpdate;\n        partners[index - 1].operatorCanUpdate = operatorCanUpdate;\n        partners[index - 1].index = index;\n\n        // Update name hash to index map\n        _indexByNameHash[nameHash] = index;\n\n        // Update wallet to index map\n        _indexByWallet[wallet] = index;\n    }\n\n    /// @dev index is 0-based\n    function _setPartnerFeeByIndex(uint256 index, uint256 fee)\n    private\n    returns (uint256)\n    {\n        uint256 oldFee = partners[index].fee;\n\n        // If operator tries to change verify that operator has access\n        if (isOperator())\n            require(partners[index].operatorCanUpdate, \"Some error message when require fails [PartnerFund.sol:906]\");\n\n        else {\n            // Require that msg.sender is partner\n            require(msg.sender == partners[index].wallet, \"Some error message when require fails [PartnerFund.sol:910]\");\n\n            // If partner tries to change verify that partner has access\n            require(partners[index].partnerCanUpdate, \"Some error message when require fails [PartnerFund.sol:913]\");\n        }\n\n        // Update stored fee\n        partners[index].fee = fee;\n\n        return oldFee;\n    }\n\n    // @dev index is 0-based\n    function _setPartnerWalletByIndex(uint256 index, address newWallet)\n    private\n    returns (address)\n    {\n        address oldWallet = partners[index].wallet;\n\n        // If address has not been set operator is the only allowed to change it\n        if (oldWallet == address(0))\n            require(isOperator(), \"Some error message when require fails [PartnerFund.sol:931]\");\n\n        // Else if operator tries to change verify that operator has access\n        else if (isOperator())\n            require(partners[index].operatorCanUpdate, \"Some error message when require fails [PartnerFund.sol:935]\");\n\n        else {\n            // Require that msg.sender is partner\n            require(msg.sender == oldWallet, \"Some error message when require fails [PartnerFund.sol:939]\");\n\n            // If partner tries to change verify that partner has access\n            require(partners[index].partnerCanUpdate, \"Some error message when require fails [PartnerFund.sol:942]\");\n\n            // Require that new wallet is not zero-address if it can not be changed by operator\n            require(partners[index].operatorCanUpdate || newWallet != address(0), \"Some error message when require fails [PartnerFund.sol:945]\");\n        }\n\n        // Update stored wallet\n        partners[index].wallet = newWallet;\n\n        // Update address to tag map\n        if (oldWallet != address(0))\n            _indexByWallet[oldWallet] = 0;\n        if (newWallet != address(0))\n            _indexByWallet[newWallet] = index;\n\n        return oldWallet;\n    }\n\n    // @dev index is 0-based\n    function _partnerFeeByIndex(uint256 index)\n    private\n    view\n    returns (uint256)\n    {\n        return partners[index].fee;\n    }\n}\n\n/*\n * Hubii Nahmii\n *\n * Compliant with the Hubii Nahmii specification v0.12.\n *\n * Copyright (C) 2017-2018 Hubii AS\n */\n\n/**\n * @title     DriipSettlementTypesLib\n * @dev       Types for driip settlements\n */\nlibrary DriipSettlementTypesLib {\n    //\n    // Structures\n    // -----------------------------------------------------------------------------------------------------------------\n    enum SettlementRole {Origin, Target}\n\n    struct SettlementParty {\n        uint256 nonce;\n        address wallet;\n        bool done;\n        uint256 doneBlockNumber;\n    }\n\n    struct Settlement {\n        string settledKind;\n        bytes32 settledHash;\n        SettlementParty origin;\n        SettlementParty target;\n    }\n}\n\n/*\n * Hubii Nahmii\n *\n * Compliant with the Hubii Nahmii specification v0.12.\n *\n * Copyright (C) 2017-2018 Hubii AS\n */\n\n/**\n * @title DriipSettlementState\n * @notice Where driip settlement state is managed\n */\ncontract DriipSettlementState is Ownable, Servable, CommunityVotable {\n    using SafeMathIntLib for int256;\n    using SafeMathUintLib for uint256;\n\n    //\n    // Constants\n    // -----------------------------------------------------------------------------------------------------------------\n    string constant public INIT_SETTLEMENT_ACTION = \"init_settlement\";\n    string constant public SET_SETTLEMENT_ROLE_DONE_ACTION = \"set_settlement_role_done\";\n    string constant public SET_MAX_NONCE_ACTION = \"set_max_nonce\";\n    string constant public SET_FEE_TOTAL_ACTION = \"set_fee_total\";\n\n    //\n    // Variables\n    // -----------------------------------------------------------------------------------------------------------------\n    uint256 public maxDriipNonce;\n\n    DriipSettlementTypesLib.Settlement[] public settlements;\n    mapping(address => uint256[]) public walletSettlementIndices;\n    mapping(address => mapping(uint256 => uint256)) public walletNonceSettlementIndex;\n    mapping(address => mapping(address => mapping(uint256 => uint256))) public walletCurrencyMaxNonce;\n\n    mapping(address => mapping(address => mapping(address => mapping(address => mapping(uint256 => MonetaryTypesLib.NoncedAmount))))) public totalFeesMap;\n\n    bool public upgradesFrozen;\n\n    //\n    // Events\n    // -----------------------------------------------------------------------------------------------------------------\n    event InitSettlementEvent(DriipSettlementTypesLib.Settlement settlement);\n    event CompleteSettlementPartyEvent(address wallet, uint256 nonce, DriipSettlementTypesLib.SettlementRole settlementRole,\n        bool done, uint256 doneBlockNumber);\n    event SetMaxNonceByWalletAndCurrencyEvent(address wallet, MonetaryTypesLib.Currency currency,\n        uint256 maxNonce);\n    event SetMaxDriipNonceEvent(uint256 maxDriipNonce);\n    event UpdateMaxDriipNonceFromCommunityVoteEvent(uint256 maxDriipNonce);\n    event SetTotalFeeEvent(address wallet, Beneficiary beneficiary, address destination,\n        MonetaryTypesLib.Currency currency, MonetaryTypesLib.NoncedAmount totalFee);\n    event FreezeUpgradesEvent();\n    event UpgradeSettlementEvent(DriipSettlementTypesLib.Settlement settlement);\n\n    //\n    // Constructor\n    // -----------------------------------------------------------------------------------------------------------------\n    constructor(address deployer) Ownable(deployer) public {\n    }\n\n    //\n    // Functions\n    // -----------------------------------------------------------------------------------------------------------------\n    /// @notice Get the count of settlements\n    function settlementsCount()\n    public\n    view\n    returns (uint256)\n    {\n        return settlements.length;\n    }\n\n    /// @notice Get the count of settlements for given wallet\n    /// @param wallet The address for which to return settlement count\n    /// @return count of settlements for the provided wallet\n    function settlementsCountByWallet(address wallet)\n    public\n    view\n    returns (uint256)\n    {\n        return walletSettlementIndices[wallet].length;\n    }\n\n    /// @notice Get settlement of given wallet and index\n    /// @param wallet The address for which to return settlement\n    /// @param index The wallet's settlement index\n    /// @return settlement for the provided wallet and index\n    function settlementByWalletAndIndex(address wallet, uint256 index)\n    public\n    view\n    returns (DriipSettlementTypesLib.Settlement memory)\n    {\n        require(walletSettlementIndices[wallet].length > index, \"Index out of bounds [DriipSettlementState.sol:107]\");\n        return settlements[walletSettlementIndices[wallet][index] - 1];\n    }\n\n    /// @notice Get settlement of given wallet and wallet nonce\n    /// @param wallet The address for which to return settlement\n    /// @param nonce The wallet's nonce\n    /// @return settlement for the provided wallet and index\n    function settlementByWalletAndNonce(address wallet, uint256 nonce)\n    public\n    view\n    returns (DriipSettlementTypesLib.Settlement memory)\n    {\n        require(0 != walletNonceSettlementIndex[wallet][nonce], \"No settlement found for wallet and nonce [DriipSettlementState.sol:120]\");\n        return settlements[walletNonceSettlementIndex[wallet][nonce] - 1];\n    }\n\n    /// @notice Initialize settlement, i.e. create one if no such settlement exists\n    /// for the double pair of wallets and nonces\n    /// @param settledKind The kind of driip of the settlement\n    /// @param settledHash The hash of driip of the settlement\n    /// @param originWallet The address of the origin wallet\n    /// @param originNonce The wallet nonce of the origin wallet\n    /// @param targetWallet The address of the target wallet\n    /// @param targetNonce The wallet nonce of the target wallet\n    function initSettlement(string memory settledKind, bytes32 settledHash, address originWallet,\n        uint256 originNonce, address targetWallet, uint256 targetNonce)\n    public\n    onlyEnabledServiceAction(INIT_SETTLEMENT_ACTION)\n    {\n        if (\n            0 == walletNonceSettlementIndex[originWallet][originNonce] &&\n            0 == walletNonceSettlementIndex[targetWallet][targetNonce]\n        ) {\n            // Create new settlement\n            settlements.length++;\n\n            // Get the 0-based index\n            uint256 index = settlements.length - 1;\n\n            // Update settlement\n            settlements[index].settledKind = settledKind;\n            settlements[index].settledHash = settledHash;\n            settlements[index].origin.nonce = originNonce;\n            settlements[index].origin.wallet = originWallet;\n            settlements[index].target.nonce = targetNonce;\n            settlements[index].target.wallet = targetWallet;\n\n            // Emit event\n            emit InitSettlementEvent(settlements[index]);\n\n            // Store 1-based index value\n            index++;\n            walletSettlementIndices[originWallet].push(index);\n            walletSettlementIndices[targetWallet].push(index);\n            walletNonceSettlementIndex[originWallet][originNonce] = index;\n            walletNonceSettlementIndex[targetWallet][targetNonce] = index;\n        }\n    }\n\n    /// @notice Set the done of the given settlement role in the given settlement\n    /// @param wallet The address of the concerned wallet\n    /// @param nonce The nonce of the concerned wallet\n    /// @param settlementRole The settlement role\n    /// @param done The done flag\n    function completeSettlementParty(address wallet, uint256 nonce,\n        DriipSettlementTypesLib.SettlementRole settlementRole, bool done)\n    public\n    onlyEnabledServiceAction(SET_SETTLEMENT_ROLE_DONE_ACTION)\n    {\n        // Get the 1-based index of the settlement\n        uint256 index = walletNonceSettlementIndex[wallet][nonce];\n\n        // Require the existence of settlement\n        require(0 != index, \"No settlement found for wallet and nonce [DriipSettlementState.sol:181]\");\n\n        // Get the settlement party\n        DriipSettlementTypesLib.SettlementParty storage party =\n        DriipSettlementTypesLib.SettlementRole.Origin == settlementRole ?\n        settlements[index - 1].origin :\n        settlements[index - 1].target;\n\n        // Update party done and done block number properties\n        party.done = done;\n        party.doneBlockNumber = done ? block.number : 0;\n\n        // Emit event\n        emit CompleteSettlementPartyEvent(wallet, nonce, settlementRole, done, party.doneBlockNumber);\n    }\n\n    /// @notice Gauge whether the settlement is done wrt the given wallet and nonce\n    /// @param wallet The address of the concerned wallet\n    /// @param nonce The nonce of the concerned wallet\n    /// @return True if settlement is done for role, else false\n    function isSettlementPartyDone(address wallet, uint256 nonce)\n    public\n    view\n    returns (bool)\n    {\n        // Get the 1-based index of the settlement\n        uint256 index = walletNonceSettlementIndex[wallet][nonce];\n\n        // Return false if settlement does not exist\n        if (0 == index)\n            return false;\n\n        // Return done\n        return (\n        wallet == settlements[index - 1].origin.wallet ?\n        settlements[index - 1].origin.done :\n        settlements[index - 1].target.done\n        );\n    }\n\n    /// @notice Gauge whether the settlement is done wrt the given wallet, nonce\n    /// and settlement role\n    /// @param wallet The address of the concerned wallet\n    /// @param nonce The nonce of the concerned wallet\n    /// @param settlementRole The settlement role\n    /// @return True if settlement is done for role, else false\n    function isSettlementPartyDone(address wallet, uint256 nonce,\n        DriipSettlementTypesLib.SettlementRole settlementRole)\n    public\n    view\n    returns (bool)\n    {\n        // Get the 1-based index of the settlement\n        uint256 index = walletNonceSettlementIndex[wallet][nonce];\n\n        // Return false if settlement does not exist\n        if (0 == index)\n            return false;\n\n        // Get the settlement party\n        DriipSettlementTypesLib.SettlementParty storage settlementParty =\n        DriipSettlementTypesLib.SettlementRole.Origin == settlementRole ?\n        settlements[index - 1].origin : settlements[index - 1].target;\n\n        // Require that wallet is party of the right role\n        require(wallet == settlementParty.wallet, \"Wallet has wrong settlement role [DriipSettlementState.sol:246]\");\n\n        // Return done\n        return settlementParty.done;\n    }\n\n    /// @notice Get the done block number of the settlement party with the given wallet and nonce\n    /// @param wallet The address of the concerned wallet\n    /// @param nonce The nonce of the concerned wallet\n    /// @return The done block number of the settlement wrt the given settlement role\n    function settlementPartyDoneBlockNumber(address wallet, uint256 nonce)\n    public\n    view\n    returns (uint256)\n    {\n        // Get the 1-based index of the settlement\n        uint256 index = walletNonceSettlementIndex[wallet][nonce];\n\n        // Require the existence of settlement\n        require(0 != index, \"No settlement found for wallet and nonce [DriipSettlementState.sol:265]\");\n\n        // Return done block number\n        return (\n        wallet == settlements[index - 1].origin.wallet ?\n        settlements[index - 1].origin.doneBlockNumber :\n        settlements[index - 1].target.doneBlockNumber\n        );\n    }\n\n    /// @notice Get the done block number of the settlement party with the given wallet, nonce and settlement role\n    /// @param wallet The address of the concerned wallet\n    /// @param nonce The nonce of the concerned wallet\n    /// @param settlementRole The settlement role\n    /// @return The done block number of the settlement wrt the given settlement role\n    function settlementPartyDoneBlockNumber(address wallet, uint256 nonce,\n        DriipSettlementTypesLib.SettlementRole settlementRole)\n    public\n    view\n    returns (uint256)\n    {\n        // Get the 1-based index of the settlement\n        uint256 index = walletNonceSettlementIndex[wallet][nonce];\n\n        // Require the existence of settlement\n        require(0 != index, \"No settlement found for wallet and nonce [DriipSettlementState.sol:290]\");\n\n        // Get the settlement party\n        DriipSettlementTypesLib.SettlementParty storage settlementParty =\n        DriipSettlementTypesLib.SettlementRole.Origin == settlementRole ?\n        settlements[index - 1].origin : settlements[index - 1].target;\n\n        // Require that wallet is party of the right role\n        require(wallet == settlementParty.wallet, \"Wallet has wrong settlement role [DriipSettlementState.sol:298]\");\n\n        // Return done block number\n        return settlementParty.doneBlockNumber;\n    }\n\n    /// @notice Set the max (driip) nonce\n    /// @param _maxDriipNonce The max nonce\n    function setMaxDriipNonce(uint256 _maxDriipNonce)\n    public\n    onlyEnabledServiceAction(SET_MAX_NONCE_ACTION)\n    {\n        maxDriipNonce = _maxDriipNonce;\n\n        // Emit event\n        emit SetMaxDriipNonceEvent(maxDriipNonce);\n    }\n\n    /// @notice Update the max driip nonce property from CommunityVote contract\n    function updateMaxDriipNonceFromCommunityVote()\n    public\n    {\n        uint256 _maxDriipNonce = communityVote.getMaxDriipNonce();\n        if (0 == _maxDriipNonce)\n            return;\n\n        maxDriipNonce = _maxDriipNonce;\n\n        // Emit event\n        emit UpdateMaxDriipNonceFromCommunityVoteEvent(maxDriipNonce);\n    }\n\n    /// @notice Get the max nonce of the given wallet and currency\n    /// @param wallet The address of the concerned wallet\n    /// @param currency The concerned currency\n    /// @return The max nonce\n    function maxNonceByWalletAndCurrency(address wallet, MonetaryTypesLib.Currency memory currency)\n    public\n    view\n    returns (uint256)\n    {\n        return walletCurrencyMaxNonce[wallet][currency.ct][currency.id];\n    }\n\n    /// @notice Set the max nonce of the given wallet and currency\n    /// @param wallet The address of the concerned wallet\n    /// @param currency The concerned currency\n    /// @param maxNonce The max nonce\n    function setMaxNonceByWalletAndCurrency(address wallet, MonetaryTypesLib.Currency memory currency,\n        uint256 maxNonce)\n    public\n    onlyEnabledServiceAction(SET_MAX_NONCE_ACTION)\n    {\n        // Update max nonce value\n        walletCurrencyMaxNonce[wallet][currency.ct][currency.id] = maxNonce;\n\n        // Emit event\n        emit SetMaxNonceByWalletAndCurrencyEvent(wallet, currency, maxNonce);\n    }\n\n    /// @notice Get the total fee payed by the given wallet to the given beneficiary and destination\n    /// in the given currency\n    /// @param wallet The address of the concerned wallet\n    /// @param beneficiary The concerned beneficiary\n    /// @param destination The concerned destination\n    /// @param currency The concerned currency\n    /// @return The total fee\n    function totalFee(address wallet, Beneficiary beneficiary, address destination,\n        MonetaryTypesLib.Currency memory currency)\n    public\n    view\n    returns (MonetaryTypesLib.NoncedAmount memory)\n    {\n        return totalFeesMap[wallet][address(beneficiary)][destination][currency.ct][currency.id];\n    }\n\n    /// @notice Set the total fee payed by the given wallet to the given beneficiary and destination\n    /// in the given currency\n    /// @param wallet The address of the concerned wallet\n    /// @param beneficiary The concerned beneficiary\n    /// @param destination The concerned destination\n    /// @param _totalFee The total fee\n    function setTotalFee(address wallet, Beneficiary beneficiary, address destination,\n        MonetaryTypesLib.Currency memory currency, MonetaryTypesLib.NoncedAmount memory _totalFee)\n    public\n    onlyEnabledServiceAction(SET_FEE_TOTAL_ACTION)\n    {\n        // Update total fees value\n        totalFeesMap[wallet][address(beneficiary)][destination][currency.ct][currency.id] = _totalFee;\n\n        // Emit event\n        emit SetTotalFeeEvent(wallet, beneficiary, destination, currency, _totalFee);\n    }\n\n    /// @notice Freeze all future settlement upgrades\n    /// @dev This operation can not be undone\n    function freezeUpgrades()\n    public\n    onlyDeployer\n    {\n        // Freeze upgrade\n        upgradesFrozen = true;\n\n        // Emit event\n        emit FreezeUpgradesEvent();\n    }\n\n    /// @notice Upgrade settlement from other driip settlement state instance\n    function upgradeSettlement(string memory settledKind, bytes32 settledHash,\n        address originWallet, uint256 originNonce, bool originDone, uint256 originDoneBlockNumber,\n        address targetWallet, uint256 targetNonce, bool targetDone, uint256 targetDoneBlockNumber)\n    public\n    onlyDeployer\n    {\n        // Require that upgrades have not been frozen\n        require(!upgradesFrozen, \"Upgrades have been frozen [DriipSettlementState.sol:413]\");\n\n        // Require that settlement has not been initialized/upgraded already\n        require(0 == walletNonceSettlementIndex[originWallet][originNonce], \"Settlement exists for origin wallet and nonce [DriipSettlementState.sol:416]\");\n        require(0 == walletNonceSettlementIndex[targetWallet][targetNonce], \"Settlement exists for target wallet and nonce [DriipSettlementState.sol:417]\");\n\n        // Create new settlement\n        settlements.length++;\n\n        // Get the 0-based index\n        uint256 index = settlements.length - 1;\n\n        // Update settlement\n        settlements[index].settledKind = settledKind;\n        settlements[index].settledHash = settledHash;\n        settlements[index].origin.nonce = originNonce;\n        settlements[index].origin.wallet = originWallet;\n        settlements[index].origin.done = originDone;\n        settlements[index].origin.doneBlockNumber = originDoneBlockNumber;\n        settlements[index].target.nonce = targetNonce;\n        settlements[index].target.wallet = targetWallet;\n        settlements[index].target.done = targetDone;\n        settlements[index].target.doneBlockNumber = targetDoneBlockNumber;\n\n        // Emit event\n        emit UpgradeSettlementEvent(settlements[index]);\n\n        // Store 1-based index value\n        index++;\n        walletSettlementIndices[originWallet].push(index);\n        walletSettlementIndices[targetWallet].push(index);\n        walletNonceSettlementIndex[originWallet][originNonce] = index;\n        walletNonceSettlementIndex[targetWallet][targetNonce] = index;\n    }\n}\n\n/*\n * Hubii Nahmii\n *\n * Compliant with the Hubii Nahmii specification v0.12.\n *\n * Copyright (C) 2017-2018 Hubii AS\n */\n\n/**\n * @title DriipSettlementChallengeByPayment\n * @notice Where driip settlements pertaining to payments are started and disputed\n */\ncontract DriipSettlementChallengeByPayment is Ownable, ConfigurableOperational, Validatable, WalletLockable,\nBalanceTrackable {\n    using SafeMathIntLib for int256;\n    using SafeMathUintLib for uint256;\n    using BalanceTrackerLib for BalanceTracker;\n\n    //\n    // Variables\n    // -----------------------------------------------------------------------------------------------------------------\n    DriipSettlementDisputeByPayment public driipSettlementDisputeByPayment;\n    DriipSettlementChallengeState public driipSettlementChallengeState;\n    NullSettlementChallengeState public nullSettlementChallengeState;\n    DriipSettlementState public driipSettlementState;\n\n    //\n    // Events\n    // -----------------------------------------------------------------------------------------------------------------\n    event SetDriipSettlementDisputeByPaymentEvent(DriipSettlementDisputeByPayment oldDriipSettlementDisputeByPayment,\n        DriipSettlementDisputeByPayment newDriipSettlementDisputeByPayment);\n    event SetDriipSettlementChallengeStateEvent(DriipSettlementChallengeState oldDriipSettlementChallengeState,\n        DriipSettlementChallengeState newDriipSettlementChallengeState);\n    event SetNullSettlementChallengeStateEvent(NullSettlementChallengeState oldNullSettlementChallengeState,\n        NullSettlementChallengeState newNullSettlementChallengeState);\n    event SetDriipSettlementStateEvent(DriipSettlementState oldDriipSettlementState,\n        DriipSettlementState newDriipSettlementState);\n    event StartChallengeFromPaymentEvent(address wallet, uint256 nonce, int256 cumulativeTransferAmount, int256 stageAmount,\n        int256 targetBalanceAmount, address currencyCt, uint256 currencyId);\n    event StartChallengeFromPaymentByProxyEvent(address wallet, uint256 nonce, int256 cumulativeTransferAmount, int256 stageAmount,\n        int256 targetBalanceAmount, address currencyCt, uint256 currencyId, address proxy);\n    event StopChallengeEvent(address wallet, uint256 nonce, int256 cumulativeTransferAmount, int256 stageAmount,\n        int256 targetBalanceAmount, address currencyCt, uint256 currencyId);\n    event StopChallengeByProxyEvent(address wallet, uint256 nonce, int256 cumulativeTransferAmount, int256 stageAmount,\n        int256 targetBalanceAmount, address currencyCt, uint256 currencyId, address proxy);\n    event ChallengeByPaymentEvent(address challengedWallet, uint256 nonce, int256 cumulativeTransferAmount, int256 stageAmount,\n        int256 targetBalanceAmount, address currencyCt, uint256 currencyId, address challengerWallet);\n\n    //\n    // Constructor\n    // -----------------------------------------------------------------------------------------------------------------\n    constructor(address deployer) Ownable(deployer) public {\n    }\n\n    //\n    // Functions\n    // -----------------------------------------------------------------------------------------------------------------\n    /// @notice Set the settlement dispute contract\n    /// @param newDriipSettlementDisputeByPayment The (address of) DriipSettlementDisputeByPayment contract instance\n    function setDriipSettlementDisputeByPayment(DriipSettlementDisputeByPayment newDriipSettlementDisputeByPayment)\n    public\n    onlyDeployer\n    notNullAddress(address(newDriipSettlementDisputeByPayment))\n    {\n        DriipSettlementDisputeByPayment oldDriipSettlementDisputeByPayment = driipSettlementDisputeByPayment;\n        driipSettlementDisputeByPayment = newDriipSettlementDisputeByPayment;\n        emit SetDriipSettlementDisputeByPaymentEvent(oldDriipSettlementDisputeByPayment, driipSettlementDisputeByPayment);\n    }\n\n    /// @notice Set the driip settlement challenge state contract\n    /// @param newDriipSettlementChallengeState The (address of) DriipSettlementChallengeState contract instance\n    function setDriipSettlementChallengeState(DriipSettlementChallengeState newDriipSettlementChallengeState)\n    public\n    onlyDeployer\n    notNullAddress(address(newDriipSettlementChallengeState))\n    {\n        DriipSettlementChallengeState oldDriipSettlementChallengeState = driipSettlementChallengeState;\n        driipSettlementChallengeState = newDriipSettlementChallengeState;\n        emit SetDriipSettlementChallengeStateEvent(oldDriipSettlementChallengeState, driipSettlementChallengeState);\n    }\n\n    /// @notice Set the null settlement challenge state contract\n    /// @param newNullSettlementChallengeState The (address of) NullSettlementChallengeState contract instance\n    function setNullSettlementChallengeState(NullSettlementChallengeState newNullSettlementChallengeState)\n    public\n    onlyDeployer\n    notNullAddress(address(newNullSettlementChallengeState))\n    {\n        NullSettlementChallengeState oldNullSettlementChallengeState = nullSettlementChallengeState;\n        nullSettlementChallengeState = newNullSettlementChallengeState;\n        emit SetNullSettlementChallengeStateEvent(oldNullSettlementChallengeState, nullSettlementChallengeState);\n    }\n\n    /// @notice Set the driip settlement state contract\n    /// @param newDriipSettlementState The (address of) DriipSettlementState contract instance\n    function setDriipSettlementState(DriipSettlementState newDriipSettlementState)\n    public\n    onlyDeployer\n    notNullAddress(address(newDriipSettlementState))\n    {\n        DriipSettlementState oldDriipSettlementState = driipSettlementState;\n        driipSettlementState = newDriipSettlementState;\n        emit SetDriipSettlementStateEvent(oldDriipSettlementState, driipSettlementState);\n    }\n\n    /// @notice Start settlement challenge on payment\n    /// @param payment The challenged payment\n    /// @param stageAmount Amount of payment currency to be staged\n    function startChallengeFromPayment(PaymentTypesLib.Payment memory payment, int256 stageAmount)\n    public\n    {\n        // Require that wallet is not temporarily disqualified\n        require(!walletLocker.isLocked(msg.sender), \"Wallet found locked [DriipSettlementChallengeByPayment.sol:134]\");\n\n        // Start challenge for wallet\n        _startChallengeFromPayment(msg.sender, payment, stageAmount, true);\n\n        // Emit event\n        emit StartChallengeFromPaymentEvent(\n            msg.sender,\n            driipSettlementChallengeState.proposalNonce(msg.sender, payment.currency),\n            driipSettlementChallengeState.proposalCumulativeTransferAmount(msg.sender, payment.currency),\n            stageAmount,\n            driipSettlementChallengeState.proposalTargetBalanceAmount(msg.sender, payment.currency),\n            payment.currency.ct, payment.currency.id\n        );\n    }\n\n    /// @notice Start settlement challenge on payment\n    /// @param wallet The concerned party\n    /// @param payment The challenged payment\n    /// @param stageAmount Amount of payment currency to be staged\n    function startChallengeFromPaymentByProxy(address wallet, PaymentTypesLib.Payment memory payment, int256 stageAmount)\n    public\n    onlyOperator\n    {\n        // Start challenge for wallet\n        _startChallengeFromPayment(wallet, payment, stageAmount, false);\n\n        // Emit event\n        emit StartChallengeFromPaymentByProxyEvent(\n            wallet,\n            driipSettlementChallengeState.proposalNonce(wallet, payment.currency),\n            driipSettlementChallengeState.proposalCumulativeTransferAmount(wallet, payment.currency),\n            stageAmount,\n            driipSettlementChallengeState.proposalTargetBalanceAmount(wallet, payment.currency),\n            payment.currency.ct, payment.currency.id, msg.sender\n        );\n    }\n\n    /// @notice Stop settlement challenge\n    /// @param currencyCt The address of the concerned currency contract (address(0) == ETH)\n    /// @param currencyId The ID of the concerned currency (0 for ETH and ERC20)\n    function stopChallenge(address currencyCt, uint256 currencyId)\n    public\n    {\n        // Define currency\n        MonetaryTypesLib.Currency memory currency = MonetaryTypesLib.Currency(currencyCt, currencyId);\n\n        // Stop challenge\n        _stopChallenge(msg.sender, currency, true, true);\n\n        // Emit event\n        emit StopChallengeEvent(\n            msg.sender,\n            driipSettlementChallengeState.proposalNonce(msg.sender, currency),\n            driipSettlementChallengeState.proposalCumulativeTransferAmount(msg.sender, currency),\n            driipSettlementChallengeState.proposalStageAmount(msg.sender, currency),\n            driipSettlementChallengeState.proposalTargetBalanceAmount(msg.sender, currency),\n            currencyCt, currencyId\n        );\n    }\n\n    /// @notice Stop settlement challenge\n    /// @param wallet The concerned wallet\n    /// @param currencyCt The address of the concerned currency contract (address(0) == ETH)\n    /// @param currencyId The ID of the concerned currency (0 for ETH and ERC20)\n    function stopChallengeByProxy(address wallet, address currencyCt, uint256 currencyId)\n    public\n    onlyOperator\n    {\n        // Define currency\n        MonetaryTypesLib.Currency memory currency = MonetaryTypesLib.Currency(currencyCt, currencyId);\n\n        // Terminate driip settlement challenge proposal\n        _stopChallenge(wallet, currency, true, false);\n\n        // Emit event\n        emit StopChallengeByProxyEvent(\n            wallet,\n            driipSettlementChallengeState.proposalNonce(wallet, currency),\n            driipSettlementChallengeState.proposalCumulativeTransferAmount(wallet, currency),\n            driipSettlementChallengeState.proposalStageAmount(wallet, currency),\n            driipSettlementChallengeState.proposalTargetBalanceAmount(wallet, currency),\n            currencyCt, currencyId, msg.sender\n        );\n    }\n\n    /// @notice Gauge whether the proposal for the given wallet and currency has been defined\n    /// @param wallet The address of the concerned wallet\n    /// @param currencyCt The address of the concerned currency contract (address(0) == ETH)\n    /// @param currencyId The ID of the concerned currency (0 for ETH and ERC20)\n    /// @return true if proposal has been initiated, else false\n    function hasProposal(address wallet, address currencyCt, uint256 currencyId)\n    public\n    view\n    returns (bool)\n    {\n        return driipSettlementChallengeState.hasProposal(\n            wallet, MonetaryTypesLib.Currency(currencyCt, currencyId)\n        );\n    }\n\n    /// @notice Gauge whether the proposal for the given wallet and currency has terminated\n    /// @param wallet The address of the concerned wallet\n    /// @param currencyCt The address of the concerned currency contract (address(0) == ETH)\n    /// @param currencyId The ID of the concerned currency (0 for ETH and ERC20)\n    /// @return true if proposal has terminated, else false\n    function hasProposalTerminated(address wallet, address currencyCt, uint256 currencyId)\n    public\n    view\n    returns (bool)\n    {\n        return driipSettlementChallengeState.hasProposalTerminated(\n            wallet, MonetaryTypesLib.Currency(currencyCt, currencyId)\n        );\n    }\n\n    /// @notice Gauge whether the proposal for the given wallet and currency has expired\n    /// @param wallet The address of the concerned wallet\n    /// @param currencyCt The address of the concerned currency contract (address(0) == ETH)\n    /// @param currencyId The ID of the concerned currency (0 for ETH and ERC20)\n    /// @return true if proposal has expired, else false\n    function hasProposalExpired(address wallet, address currencyCt, uint256 currencyId)\n    public\n    view\n    returns (bool)\n    {\n        return driipSettlementChallengeState.hasProposalExpired(\n            wallet, MonetaryTypesLib.Currency(currencyCt, currencyId)\n        );\n    }\n\n    /// @notice Get the challenge nonce of the given wallet\n    /// @param wallet The address of the concerned wallet\n    /// @param currencyCt The address of the concerned currency contract (address(0) == ETH)\n    /// @param currencyId The ID of the concerned currency (0 for ETH and ERC20)\n    /// @return The challenge nonce\n    function proposalNonce(address wallet, address currencyCt, uint256 currencyId)\n    public\n    view\n    returns (uint256)\n    {\n        return driipSettlementChallengeState.proposalNonce(\n            wallet, MonetaryTypesLib.Currency(currencyCt, currencyId)\n        );\n    }\n\n    /// @notice Get the settlement proposal block number of the given wallet\n    /// @param wallet The address of the concerned wallet\n    /// @param currencyCt The address of the concerned currency contract (address(0) == ETH)\n    /// @param currencyId The ID of the concerned currency (0 for ETH and ERC20)\n    /// @return The settlement proposal block number\n    function proposalReferenceBlockNumber(address wallet, address currencyCt, uint256 currencyId)\n    public\n    view\n    returns (uint256)\n    {\n        return driipSettlementChallengeState.proposalReferenceBlockNumber(\n            wallet, MonetaryTypesLib.Currency(currencyCt, currencyId)\n        );\n    }\n\n    /// @notice Get the settlement proposal end time of the given wallet\n    /// @param wallet The address of the concerned wallet\n    /// @param currencyCt The address of the concerned currency contract (address(0) == ETH)\n    /// @param currencyId The ID of the concerned currency (0 for ETH and ERC20)\n    /// @return The settlement proposal end time\n    function proposalExpirationTime(address wallet, address currencyCt, uint256 currencyId)\n    public\n    view\n    returns (uint256)\n    {\n        return driipSettlementChallengeState.proposalExpirationTime(\n            wallet, MonetaryTypesLib.Currency(currencyCt, currencyId)\n        );\n    }\n\n    /// @notice Get the challenge status of the given wallet\n    /// @param wallet The address of the concerned wallet\n    /// @param currencyCt The address of the concerned currency contract (address(0) == ETH)\n    /// @param currencyId The ID of the concerned currency (0 for ETH and ERC20)\n    /// @return The challenge status\n    function proposalStatus(address wallet, address currencyCt, uint256 currencyId)\n    public\n    view\n    returns (SettlementChallengeTypesLib.Status)\n    {\n        return driipSettlementChallengeState.proposalStatus(\n            wallet, MonetaryTypesLib.Currency(currencyCt, currencyId)\n        );\n    }\n\n    /// @notice Get the settlement proposal stage amount of the given wallet and currency\n    /// @param wallet The address of the concerned wallet\n    /// @param currencyCt The address of the concerned currency contract (address(0) == ETH)\n    /// @param currencyId The ID of the concerned currency (0 for ETH and ERC20)\n    /// @return The settlement proposal stage amount\n    function proposalStageAmount(address wallet, address currencyCt, uint256 currencyId)\n    public\n    view\n    returns (int256)\n    {\n        return driipSettlementChallengeState.proposalStageAmount(\n            wallet, MonetaryTypesLib.Currency(currencyCt, currencyId)\n        );\n    }\n\n    /// @notice Get the settlement proposal target balance amount of the given wallet and currency\n    /// @param wallet The address of the concerned wallet\n    /// @param currencyCt The address of the concerned currency contract (address(0) == ETH)\n    /// @param currencyId The ID of the concerned currency (0 for ETH and ERC20)\n    /// @return The settlement proposal target balance amount\n    function proposalTargetBalanceAmount(address wallet, address currencyCt, uint256 currencyId)\n    public\n    view\n    returns (int256)\n    {\n        return driipSettlementChallengeState.proposalTargetBalanceAmount(\n            wallet, MonetaryTypesLib.Currency(currencyCt, currencyId)\n        );\n    }\n\n    /// @notice Get the settlement proposal driip hash of the given wallet and currency\n    /// @param wallet The address of the concerned wallet\n    /// @param currencyCt The address of the concerned currency contract (address(0) == ETH)\n    /// @param currencyId The ID of the concerned currency (0 for ETH and ERC20)\n    /// @return The settlement proposal driip hash\n    function proposalChallengedHash(address wallet, address currencyCt, uint256 currencyId)\n    public\n    view\n    returns (bytes32)\n    {\n        return driipSettlementChallengeState.proposalChallengedHash(\n            wallet, MonetaryTypesLib.Currency(currencyCt, currencyId)\n        );\n    }\n\n    /// @notice Get the settlement proposal driip type of the given wallet and currency\n    /// @param wallet The address of the concerned wallet\n    /// @param currencyCt The address of the concerned currency contract (address(0) == ETH)\n    /// @param currencyId The ID of the concerned currency (0 for ETH and ERC20)\n    /// @return The settlement proposal driip type\n    function proposalChallengedKind(address wallet, address currencyCt, uint256 currencyId)\n    public\n    view\n    returns (string memory)\n    {\n        return driipSettlementChallengeState.proposalChallengedKind(\n            wallet, MonetaryTypesLib.Currency(currencyCt, currencyId)\n        );\n    }\n\n    /// @notice Get the balance reward of the given wallet's settlement proposal\n    /// @param wallet The address of the concerned wallet\n    /// @param currencyCt The address of the concerned currency contract (address(0) == ETH)\n    /// @param currencyId The ID of the concerned currency (0 for ETH and ERC20)\n    /// @return The balance reward of the settlement proposal\n    function proposalWalletInitiated(address wallet, address currencyCt, uint256 currencyId)\n    public\n    view\n    returns (bool)\n    {\n        return driipSettlementChallengeState.proposalWalletInitiated(\n            wallet, MonetaryTypesLib.Currency(currencyCt, currencyId)\n        );\n    }\n\n    /// @notice Get the disqualification challenger of the given wallet and currency\n    /// @param wallet The address of the concerned wallet\n    /// @param currencyCt The address of the concerned currency contract (address(0) == ETH)\n    /// @param currencyId The ID of the concerned currency (0 for ETH and ERC20)\n    /// @return The challenger of the settlement disqualification\n    function proposalDisqualificationChallenger(address wallet, address currencyCt, uint256 currencyId)\n    public\n    view\n    returns (address)\n    {\n        return driipSettlementChallengeState.proposalDisqualificationChallenger(\n            wallet, MonetaryTypesLib.Currency(currencyCt, currencyId)\n        );\n    }\n    /// @notice Get the disqualification block number of the given wallet and currency\n    /// @param wallet The address of the concerned wallet\n    /// @param currencyCt The address of the concerned currency contract (address(0) == ETH)\n    /// @param currencyId The ID of the concerned currency (0 for ETH and ERC20)\n    /// @return The block number of the settlement disqualification\n    function proposalDisqualificationBlockNumber(address wallet, address currencyCt, uint256 currencyId)\n    public\n    view\n    returns (uint256)\n    {\n        return driipSettlementChallengeState.proposalDisqualificationBlockNumber(\n            wallet, MonetaryTypesLib.Currency(currencyCt, currencyId)\n        );\n    }\n\n    /// @notice Get the disqualification candidate kind of the given wallet and currency\n    /// @param wallet The address of the concerned wallet\n    /// @param currencyCt The address of the concerned currency contract (address(0) == ETH)\n    /// @param currencyId The ID of the concerned currency (0 for ETH and ERC20)\n    /// @return The candidate kind of the settlement disqualification\n    function proposalDisqualificationCandidateKind(address wallet, address currencyCt, uint256 currencyId)\n    public\n    view\n    returns (string memory)\n    {\n        return driipSettlementChallengeState.proposalDisqualificationCandidateKind(\n            wallet, MonetaryTypesLib.Currency(currencyCt, currencyId)\n        );\n    }\n\n    /// @notice Get the disqualification candidate hash of the given wallet and currency\n    /// @param wallet The address of the concerned wallet\n    /// @param currencyCt The address of the concerned currency contract (address(0) == ETH)\n    /// @param currencyId The ID of the concerned currency (0 for ETH and ERC20)\n    /// @return The candidate hash of the settlement disqualification\n    function proposalDisqualificationCandidateHash(address wallet, address currencyCt, uint256 currencyId)\n    public\n    view\n    returns (bytes32)\n    {\n        return driipSettlementChallengeState.proposalDisqualificationCandidateHash(\n            wallet, MonetaryTypesLib.Currency(currencyCt, currencyId)\n        );\n    }\n\n    /// @notice Challenge the settlement by providing payment candidate\n    /// @param wallet The wallet whose settlement is being challenged\n    /// @param payment The payment candidate that challenges the challenged driip\n    function challengeByPayment(address wallet, PaymentTypesLib.Payment memory payment)\n    public\n    onlyOperationalModeNormal\n    {\n        // Challenge by payment\n        driipSettlementDisputeByPayment.challengeByPayment(wallet, payment, msg.sender);\n\n        // Emit event\n        emit ChallengeByPaymentEvent(\n            wallet,\n            driipSettlementChallengeState.proposalNonce(wallet, payment.currency),\n            driipSettlementChallengeState.proposalCumulativeTransferAmount(wallet, payment.currency),\n            driipSettlementChallengeState.proposalStageAmount(wallet, payment.currency),\n            driipSettlementChallengeState.proposalTargetBalanceAmount(wallet, payment.currency),\n            payment.currency.ct, payment.currency.id, msg.sender\n        );\n    }\n\n    //\n    // Private functions\n    // -----------------------------------------------------------------------------------------------------------------\n    function _startChallengeFromPayment(address wallet, PaymentTypesLib.Payment memory payment,\n        int256 stageAmount, bool walletInitiated)\n    private\n    onlySealedPayment(payment)\n    {\n        // Require that current block number is beyond the earliest settlement challenge block number\n        require(\n            block.number >= configuration.earliestSettlementBlockNumber(),\n            \"Current block number below earliest settlement block number [DriipSettlementChallengeByPayment.sol:489]\"\n        );\n\n        // Require that given wallet is a payment party\n        require(validator.isPaymentParty(payment, wallet), \"Wallet is not payment party [DriipSettlementChallengeByPayment.sol:495]\");\n\n        // Require that there is no ongoing overlapping driip settlement challenge\n        require(\n            !driipSettlementChallengeState.hasProposal(wallet, payment.currency) ||\n        driipSettlementChallengeState.hasProposalTerminated(wallet, payment.currency),\n            \"Overlapping driip settlement challenge proposal found [DriipSettlementChallengeByPayment.sol:498]\"\n        );\n\n        // Require that there is no ongoing overlapping null settlement challenge\n        require(\n            !nullSettlementChallengeState.hasProposal(wallet, payment.currency) ||\n        nullSettlementChallengeState.hasProposalTerminated(wallet, payment.currency),\n            \"Overlapping null settlement challenge proposal found [DriipSettlementChallengeByPayment.sol:505]\"\n        );\n\n        // Deduce the concerned nonce and cumulative relative transfer\n        (uint256 nonce, int256 cumulativeTransferAmount) = _paymentPartyProperties(payment, wallet);\n\n        // Require that the wallet nonce of the payment is higher than the highest settled wallet nonce\n        require(\n            driipSettlementState.maxNonceByWalletAndCurrency(wallet, payment.currency) < nonce,\n            \"Wallet's nonce below highest settled nonce [DriipSettlementChallengeByPayment.sol:515]\"\n        );\n\n        // Initiate proposal, including assurance that there is no overlap with active proposal\n        // Target balance amount is calculated as current balance - cumulativeTransferAmount - stageAmount\n        driipSettlementChallengeState.initiateProposal(\n            wallet, nonce, cumulativeTransferAmount, stageAmount,\n            balanceTracker.fungibleActiveBalanceAmount(wallet, payment.currency).sub(\n                cumulativeTransferAmount.add(stageAmount)\n            ),\n            payment.currency, payment.blockNumber,\n            walletInitiated, payment.seals.operator.hash, PaymentTypesLib.PAYMENT_KIND()\n        );\n    }\n\n    function _stopChallenge(address wallet, MonetaryTypesLib.Currency memory currency, bool clearNonce, bool walletTerminated)\n    private\n    {\n        // Require that there is an unterminated driip settlement challenge proposal\n        require(driipSettlementChallengeState.hasProposal(wallet, currency), \"No proposal found [DriipSettlementChallengeByPayment.sol:536]\");\n        require(!driipSettlementChallengeState.hasProposalTerminated(wallet, currency), \"Proposal found terminated [DriipSettlementChallengeByPayment.sol:537]\");\n\n        // Terminate driip settlement challenge proposal\n        driipSettlementChallengeState.terminateProposal(wallet, currency, clearNonce, walletTerminated);\n\n        // Terminate dependent null settlement challenge proposal if existent\n        nullSettlementChallengeState.terminateProposal(wallet, currency);\n    }\n\n    function _paymentPartyProperties(PaymentTypesLib.Payment memory payment, address wallet)\n    private\n    view\n    returns (uint256 nonce, int256 correctedCumulativeTransferAmount)\n    {\n        // Obtain unsynchronized stage amount from previous driip settlement if existent.\n        int256 unsynchronizedStageAmount = 0;\n        if (driipSettlementChallengeState.hasProposal(wallet, payment.currency)) {\n            uint256 previousChallengeNonce = driipSettlementChallengeState.proposalNonce(wallet, payment.currency);\n\n            // Get settlement party done block number. The function returns 0 if the settlement party has not effectuated\n            // its side of the settlement.\n            uint256 settlementPartyDoneBlockNumber = driipSettlementState.settlementPartyDoneBlockNumber(\n                wallet, previousChallengeNonce\n            );\n\n            // If payment is not up to date wrt events affecting the wallet's balance then obtain\n            // the unsynchronized stage amount from the previous driip settlement challenge.\n            if (payment.blockNumber < settlementPartyDoneBlockNumber)\n                unsynchronizedStageAmount = driipSettlementChallengeState.proposalStageAmount(\n                    wallet, payment.currency\n                );\n        }\n\n        // Obtain the active balance amount at the payment block\n        int256 balanceAmountAtPaymentBlock = balanceTracker.fungibleActiveBalanceAmountByBlockNumber(\n            wallet, payment.currency, payment.blockNumber\n        );\n\n        // Obtain nonce and cumulative (relative) transfer amount.\n        // Correct the cumulative transfer amount for wrong value occurring from\n        // race condition of off-chain wallet rebalance resulting from completed settlement\n        if (validator.isPaymentSender(payment, wallet)) {\n            nonce = payment.sender.nonce;\n            correctedCumulativeTransferAmount = balanceAmountAtPaymentBlock\n            .sub(payment.sender.balances.current)\n            .add(unsynchronizedStageAmount);\n        } else {\n            nonce = payment.recipient.nonce;\n            correctedCumulativeTransferAmount = balanceAmountAtPaymentBlock\n            .sub(payment.recipient.balances.current)\n            .add(unsynchronizedStageAmount);\n        }\n    }\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"wallet\",\"type\":\"address\"},{\"name\":\"currencyCt\",\"type\":\"address\"},{\"name\":\"currencyId\",\"type\":\"uint256\"}],\"name\":\"proposalChallengedKind\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"wallet\",\"type\":\"address\"},{\"name\":\"currencyCt\",\"type\":\"address\"},{\"name\":\"currencyId\",\"type\":\"uint256\"}],\"name\":\"proposalStatus\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"driipSettlementDisputeByPayment\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newValidator\",\"type\":\"address\"}],\"name\":\"setValidator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"wallet\",\"type\":\"address\"},{\"name\":\"currencyCt\",\"type\":\"address\"},{\"name\":\"currencyId\",\"type\":\"uint256\"}],\"name\":\"proposalTargetBalanceAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"balanceTracker\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"walletLockerFrozen\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"driipSettlementState\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"triggerSelfDestruction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newDriipSettlementChallengeState\",\"type\":\"address\"}],\"name\":\"setDriipSettlementChallengeState\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"selfDestructionDisabled\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"wallet\",\"type\":\"address\"},{\"components\":[{\"name\":\"amount\",\"type\":\"int256\"},{\"components\":[{\"name\":\"ct\",\"type\":\"address\"},{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"currency\",\"type\":\"tuple\"},{\"components\":[{\"name\":\"nonce\",\"type\":\"uint256\"},{\"name\":\"wallet\",\"type\":\"address\"},{\"components\":[{\"name\":\"current\",\"type\":\"int256\"},{\"name\":\"previous\",\"type\":\"int256\"}],\"name\":\"balances\",\"type\":\"tuple\"},{\"components\":[{\"components\":[{\"name\":\"amount\",\"type\":\"int256\"},{\"components\":[{\"name\":\"ct\",\"type\":\"address\"},{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"currency\",\"type\":\"tuple\"}],\"name\":\"single\",\"type\":\"tuple\"},{\"components\":[{\"name\":\"originId\",\"type\":\"uint256\"},{\"components\":[{\"name\":\"amount\",\"type\":\"int256\"},{\"components\":[{\"name\":\"ct\",\"type\":\"address\"},{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"currency\",\"type\":\"tuple\"}],\"name\":\"figure\",\"type\":\"tuple\"}],\"name\":\"total\",\"type\":\"tuple[]\"}],\"name\":\"fees\",\"type\":\"tuple\"},{\"name\":\"data\",\"type\":\"string\"}],\"name\":\"sender\",\"type\":\"tuple\"},{\"components\":[{\"name\":\"nonce\",\"type\":\"uint256\"},{\"name\":\"wallet\",\"type\":\"address\"},{\"components\":[{\"name\":\"current\",\"type\":\"int256\"},{\"name\":\"previous\",\"type\":\"int256\"}],\"name\":\"balances\",\"type\":\"tuple\"},{\"components\":[{\"components\":[{\"name\":\"originId\",\"type\":\"uint256\"},{\"components\":[{\"name\":\"amount\",\"type\":\"int256\"},{\"components\":[{\"name\":\"ct\",\"type\":\"address\"},{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"currency\",\"type\":\"tuple\"}],\"name\":\"figure\",\"type\":\"tuple\"}],\"name\":\"total\",\"type\":\"tuple[]\"}],\"name\":\"fees\",\"type\":\"tuple\"}],\"name\":\"recipient\",\"type\":\"tuple\"},{\"components\":[{\"name\":\"single\",\"type\":\"int256\"},{\"name\":\"total\",\"type\":\"int256\"}],\"name\":\"transfers\",\"type\":\"tuple\"},{\"components\":[{\"components\":[{\"name\":\"hash\",\"type\":\"bytes32\"},{\"components\":[{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"},{\"name\":\"v\",\"type\":\"uint8\"}],\"name\":\"signature\",\"type\":\"tuple\"}],\"name\":\"wallet\",\"type\":\"tuple\"},{\"components\":[{\"name\":\"hash\",\"type\":\"bytes32\"},{\"components\":[{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"},{\"name\":\"v\",\"type\":\"uint8\"}],\"name\":\"signature\",\"type\":\"tuple\"}],\"name\":\"operator\",\"type\":\"tuple\"}],\"name\":\"seals\",\"type\":\"tuple\"},{\"name\":\"blockNumber\",\"type\":\"uint256\"},{\"components\":[{\"name\":\"id\",\"type\":\"uint256\"},{\"name\":\"data\",\"type\":\"string\"}],\"name\":\"operator\",\"type\":\"tuple\"}],\"name\":\"payment\",\"type\":\"tuple\"},{\"name\":\"stageAmount\",\"type\":\"int256\"}],\"name\":\"startChallengeFromPaymentByProxy\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"validator\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"wallet\",\"type\":\"address\"},{\"name\":\"currencyCt\",\"type\":\"address\"},{\"name\":\"currencyId\",\"type\":\"uint256\"}],\"name\":\"hasProposalExpired\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"balanceTrackerFrozen\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newDriipSettlementState\",\"type\":\"address\"}],\"name\":\"setDriipSettlementState\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"wallet\",\"type\":\"address\"},{\"name\":\"currencyCt\",\"type\":\"address\"},{\"name\":\"currencyId\",\"type\":\"uint256\"}],\"name\":\"proposalStageAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"destructor\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"wallet\",\"type\":\"address\"},{\"name\":\"currencyCt\",\"type\":\"address\"},{\"name\":\"currencyId\",\"type\":\"uint256\"}],\"name\":\"hasProposalTerminated\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"components\":[{\"name\":\"amount\",\"type\":\"int256\"},{\"components\":[{\"name\":\"ct\",\"type\":\"address\"},{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"currency\",\"type\":\"tuple\"},{\"components\":[{\"name\":\"nonce\",\"type\":\"uint256\"},{\"name\":\"wallet\",\"type\":\"address\"},{\"components\":[{\"name\":\"current\",\"type\":\"int256\"},{\"name\":\"previous\",\"type\":\"int256\"}],\"name\":\"balances\",\"type\":\"tuple\"},{\"components\":[{\"components\":[{\"name\":\"amount\",\"type\":\"int256\"},{\"components\":[{\"name\":\"ct\",\"type\":\"address\"},{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"currency\",\"type\":\"tuple\"}],\"name\":\"single\",\"type\":\"tuple\"},{\"components\":[{\"name\":\"originId\",\"type\":\"uint256\"},{\"components\":[{\"name\":\"amount\",\"type\":\"int256\"},{\"components\":[{\"name\":\"ct\",\"type\":\"address\"},{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"currency\",\"type\":\"tuple\"}],\"name\":\"figure\",\"type\":\"tuple\"}],\"name\":\"total\",\"type\":\"tuple[]\"}],\"name\":\"fees\",\"type\":\"tuple\"},{\"name\":\"data\",\"type\":\"string\"}],\"name\":\"sender\",\"type\":\"tuple\"},{\"components\":[{\"name\":\"nonce\",\"type\":\"uint256\"},{\"name\":\"wallet\",\"type\":\"address\"},{\"components\":[{\"name\":\"current\",\"type\":\"int256\"},{\"name\":\"previous\",\"type\":\"int256\"}],\"name\":\"balances\",\"type\":\"tuple\"},{\"components\":[{\"components\":[{\"name\":\"originId\",\"type\":\"uint256\"},{\"components\":[{\"name\":\"amount\",\"type\":\"int256\"},{\"components\":[{\"name\":\"ct\",\"type\":\"address\"},{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"currency\",\"type\":\"tuple\"}],\"name\":\"figure\",\"type\":\"tuple\"}],\"name\":\"total\",\"type\":\"tuple[]\"}],\"name\":\"fees\",\"type\":\"tuple\"}],\"name\":\"recipient\",\"type\":\"tuple\"},{\"components\":[{\"name\":\"single\",\"type\":\"int256\"},{\"name\":\"total\",\"type\":\"int256\"}],\"name\":\"transfers\",\"type\":\"tuple\"},{\"components\":[{\"components\":[{\"name\":\"hash\",\"type\":\"bytes32\"},{\"components\":[{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"},{\"name\":\"v\",\"type\":\"uint8\"}],\"name\":\"signature\",\"type\":\"tuple\"}],\"name\":\"wallet\",\"type\":\"tuple\"},{\"components\":[{\"name\":\"hash\",\"type\":\"bytes32\"},{\"components\":[{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"},{\"name\":\"v\",\"type\":\"uint8\"}],\"name\":\"signature\",\"type\":\"tuple\"}],\"name\":\"operator\",\"type\":\"tuple\"}],\"name\":\"seals\",\"type\":\"tuple\"},{\"name\":\"blockNumber\",\"type\":\"uint256\"},{\"components\":[{\"name\":\"id\",\"type\":\"uint256\"},{\"name\":\"data\",\"type\":\"string\"}],\"name\":\"operator\",\"type\":\"tuple\"}],\"name\":\"payment\",\"type\":\"tuple\"},{\"name\":\"stageAmount\",\"type\":\"int256\"}],\"name\":\"startChallengeFromPayment\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newDriipSettlementDisputeByPayment\",\"type\":\"address\"}],\"name\":\"setDriipSettlementDisputeByPayment\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"driipSettlementChallengeState\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"operator\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newBalanceTracker\",\"type\":\"address\"}],\"name\":\"setBalanceTracker\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"freezeWalletLocker\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newConfiguration\",\"type\":\"address\"}],\"name\":\"setConfiguration\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"configuration\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newNullSettlementChallengeState\",\"type\":\"address\"}],\"name\":\"setNullSettlementChallengeState\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"wallet\",\"type\":\"address\"},{\"name\":\"currencyCt\",\"type\":\"address\"},{\"name\":\"currencyId\",\"type\":\"uint256\"}],\"name\":\"proposalReferenceBlockNumber\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"disableSelfDestruction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"wallet\",\"type\":\"address\"},{\"name\":\"currencyCt\",\"type\":\"address\"},{\"name\":\"currencyId\",\"type\":\"uint256\"}],\"name\":\"proposalWalletInitiated\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newWalletLocker\",\"type\":\"address\"}],\"name\":\"setWalletLocker\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"wallet\",\"type\":\"address\"},{\"components\":[{\"name\":\"amount\",\"type\":\"int256\"},{\"components\":[{\"name\":\"ct\",\"type\":\"address\"},{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"currency\",\"type\":\"tuple\"},{\"components\":[{\"name\":\"nonce\",\"type\":\"uint256\"},{\"name\":\"wallet\",\"type\":\"address\"},{\"components\":[{\"name\":\"current\",\"type\":\"int256\"},{\"name\":\"previous\",\"type\":\"int256\"}],\"name\":\"balances\",\"type\":\"tuple\"},{\"components\":[{\"components\":[{\"name\":\"amount\",\"type\":\"int256\"},{\"components\":[{\"name\":\"ct\",\"type\":\"address\"},{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"currency\",\"type\":\"tuple\"}],\"name\":\"single\",\"type\":\"tuple\"},{\"components\":[{\"name\":\"originId\",\"type\":\"uint256\"},{\"components\":[{\"name\":\"amount\",\"type\":\"int256\"},{\"components\":[{\"name\":\"ct\",\"type\":\"address\"},{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"currency\",\"type\":\"tuple\"}],\"name\":\"figure\",\"type\":\"tuple\"}],\"name\":\"total\",\"type\":\"tuple[]\"}],\"name\":\"fees\",\"type\":\"tuple\"},{\"name\":\"data\",\"type\":\"string\"}],\"name\":\"sender\",\"type\":\"tuple\"},{\"components\":[{\"name\":\"nonce\",\"type\":\"uint256\"},{\"name\":\"wallet\",\"type\":\"address\"},{\"components\":[{\"name\":\"current\",\"type\":\"int256\"},{\"name\":\"previous\",\"type\":\"int256\"}],\"name\":\"balances\",\"type\":\"tuple\"},{\"components\":[{\"components\":[{\"name\":\"originId\",\"type\":\"uint256\"},{\"components\":[{\"name\":\"amount\",\"type\":\"int256\"},{\"components\":[{\"name\":\"ct\",\"type\":\"address\"},{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"currency\",\"type\":\"tuple\"}],\"name\":\"figure\",\"type\":\"tuple\"}],\"name\":\"total\",\"type\":\"tuple[]\"}],\"name\":\"fees\",\"type\":\"tuple\"}],\"name\":\"recipient\",\"type\":\"tuple\"},{\"components\":[{\"name\":\"single\",\"type\":\"int256\"},{\"name\":\"total\",\"type\":\"int256\"}],\"name\":\"transfers\",\"type\":\"tuple\"},{\"components\":[{\"components\":[{\"name\":\"hash\",\"type\":\"bytes32\"},{\"components\":[{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"},{\"name\":\"v\",\"type\":\"uint8\"}],\"name\":\"signature\",\"type\":\"tuple\"}],\"name\":\"wallet\",\"type\":\"tuple\"},{\"components\":[{\"name\":\"hash\",\"type\":\"bytes32\"},{\"components\":[{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"},{\"name\":\"v\",\"type\":\"uint8\"}],\"name\":\"signature\",\"type\":\"tuple\"}],\"name\":\"operator\",\"type\":\"tuple\"}],\"name\":\"seals\",\"type\":\"tuple\"},{\"name\":\"blockNumber\",\"type\":\"uint256\"},{\"components\":[{\"name\":\"id\",\"type\":\"uint256\"},{\"name\":\"data\",\"type\":\"string\"}],\"name\":\"operator\",\"type\":\"tuple\"}],\"name\":\"payment\",\"type\":\"tuple\"}],\"name\":\"challengeByPayment\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newDeployer\",\"type\":\"address\"}],\"name\":\"setDeployer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"wallet\",\"type\":\"address\"},{\"name\":\"currencyCt\",\"type\":\"address\"},{\"name\":\"currencyId\",\"type\":\"uint256\"}],\"name\":\"stopChallengeByProxy\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"wallet\",\"type\":\"address\"},{\"name\":\"currencyCt\",\"type\":\"address\"},{\"name\":\"currencyId\",\"type\":\"uint256\"}],\"name\":\"proposalChallengedHash\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"wallet\",\"type\":\"address\"},{\"name\":\"currencyCt\",\"type\":\"address\"},{\"name\":\"currencyId\",\"type\":\"uint256\"}],\"name\":\"proposalDisqualificationCandidateHash\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOperator\",\"type\":\"address\"}],\"name\":\"setOperator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"freezeBalanceTracker\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"wallet\",\"type\":\"address\"},{\"name\":\"currencyCt\",\"type\":\"address\"},{\"name\":\"currencyId\",\"type\":\"uint256\"}],\"name\":\"hasProposal\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"currencyCt\",\"type\":\"address\"},{\"name\":\"currencyId\",\"type\":\"uint256\"}],\"name\":\"stopChallenge\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"wallet\",\"type\":\"address\"},{\"name\":\"currencyCt\",\"type\":\"address\"},{\"name\":\"currencyId\",\"type\":\"uint256\"}],\"name\":\"proposalDisqualificationCandidateKind\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"wallet\",\"type\":\"address\"},{\"name\":\"currencyCt\",\"type\":\"address\"},{\"name\":\"currencyId\",\"type\":\"uint256\"}],\"name\":\"proposalNonce\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"wallet\",\"type\":\"address\"},{\"name\":\"currencyCt\",\"type\":\"address\"},{\"name\":\"currencyId\",\"type\":\"uint256\"}],\"name\":\"proposalDisqualificationBlockNumber\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"deployer\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"walletLocker\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nullSettlementChallengeState\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"wallet\",\"type\":\"address\"},{\"name\":\"currencyCt\",\"type\":\"address\"},{\"name\":\"currencyId\",\"type\":\"uint256\"}],\"name\":\"proposalExpirationTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"wallet\",\"type\":\"address\"},{\"name\":\"currencyCt\",\"type\":\"address\"},{\"name\":\"currencyId\",\"type\":\"uint256\"}],\"name\":\"proposalDisqualificationChallenger\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"deployer\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldDriipSettlementDisputeByPayment\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newDriipSettlementDisputeByPayment\",\"type\":\"address\"}],\"name\":\"SetDriipSettlementDisputeByPaymentEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldDriipSettlementChallengeState\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newDriipSettlementChallengeState\",\"type\":\"address\"}],\"name\":\"SetDriipSettlementChallengeStateEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldNullSettlementChallengeState\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newNullSettlementChallengeState\",\"type\":\"address\"}],\"name\":\"SetNullSettlementChallengeStateEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldDriipSettlementState\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newDriipSettlementState\",\"type\":\"address\"}],\"name\":\"SetDriipSettlementStateEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"wallet\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"nonce\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"cumulativeTransferAmount\",\"type\":\"int256\"},{\"indexed\":false,\"name\":\"stageAmount\",\"type\":\"int256\"},{\"indexed\":false,\"name\":\"targetBalanceAmount\",\"type\":\"int256\"},{\"indexed\":false,\"name\":\"currencyCt\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"currencyId\",\"type\":\"uint256\"}],\"name\":\"StartChallengeFromPaymentEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"wallet\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"nonce\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"cumulativeTransferAmount\",\"type\":\"int256\"},{\"indexed\":false,\"name\":\"stageAmount\",\"type\":\"int256\"},{\"indexed\":false,\"name\":\"targetBalanceAmount\",\"type\":\"int256\"},{\"indexed\":false,\"name\":\"currencyCt\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"currencyId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"proxy\",\"type\":\"address\"}],\"name\":\"StartChallengeFromPaymentByProxyEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"wallet\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"nonce\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"cumulativeTransferAmount\",\"type\":\"int256\"},{\"indexed\":false,\"name\":\"stageAmount\",\"type\":\"int256\"},{\"indexed\":false,\"name\":\"targetBalanceAmount\",\"type\":\"int256\"},{\"indexed\":false,\"name\":\"currencyCt\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"currencyId\",\"type\":\"uint256\"}],\"name\":\"StopChallengeEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"wallet\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"nonce\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"cumulativeTransferAmount\",\"type\":\"int256\"},{\"indexed\":false,\"name\":\"stageAmount\",\"type\":\"int256\"},{\"indexed\":false,\"name\":\"targetBalanceAmount\",\"type\":\"int256\"},{\"indexed\":false,\"name\":\"currencyCt\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"currencyId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"proxy\",\"type\":\"address\"}],\"name\":\"StopChallengeByProxyEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"challengedWallet\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"nonce\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"cumulativeTransferAmount\",\"type\":\"int256\"},{\"indexed\":false,\"name\":\"stageAmount\",\"type\":\"int256\"},{\"indexed\":false,\"name\":\"targetBalanceAmount\",\"type\":\"int256\"},{\"indexed\":false,\"name\":\"currencyCt\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"currencyId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"challengerWallet\",\"type\":\"address\"}],\"name\":\"ChallengeByPaymentEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldBalanceTracker\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newBalanceTracker\",\"type\":\"address\"}],\"name\":\"SetBalanceTrackerEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"FreezeBalanceTrackerEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldWalletLocker\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newWalletLocker\",\"type\":\"address\"}],\"name\":\"SetWalletLockerEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"FreezeWalletLockerEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldValidator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newValidator\",\"type\":\"address\"}],\"name\":\"SetValidatorEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldConfiguration\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newConfiguration\",\"type\":\"address\"}],\"name\":\"SetConfigurationEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldDeployer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newDeployer\",\"type\":\"address\"}],\"name\":\"SetDeployerEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldOperator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newOperator\",\"type\":\"address\"}],\"name\":\"SetOperatorEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"SelfDestructionDisabledEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"TriggerSelfDestructionEvent\",\"type\":\"event\"}]","ContractName":"DriipSettlementChallengeByPayment","CompilerVersion":"v0.5.9+commit.e560f70d","OptimizationUsed":"1","Runs":"0","ConstructorArguments":"000000000000000000000000f05179bac3d1fbef58a2fcd7ad0f769840027cc6","Library":"PaymentTypesLib:b99f3f4aacb6e1197a623919103b99f4b41aaef0;SafeMathUintLib:0ff948c236c8d4dfcd0168bf243314c8ff8ec967","SwarmSource":"bzzr://fbc4412089a7bb23fda26d157a99480d24b9a6b4c85a95a3700f844f71a46c12"}]}