{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.24;\r\npragma experimental \"v0.5.0\";\r\n/******************************************************************************\\\r\n* Author: Nick Mudge, nick@mokens.io\r\n* Mokens\r\n* Copyright (c) 2018\r\n*\r\n* This delegate contract contains functions related to moken categories.\r\n/******************************************************************************/\r\n\r\n///////////////////////////////////////////////////////////////////////////////////\r\n//Storage contracts\r\n////////////\r\n//Some delegate contracts are listed with storage contracts they inherit.\r\n///////////////////////////////////////////////////////////////////////////////////\r\n\r\n///////////////////////////////////////////////////////////////////////////////////\r\n//Mokens\r\n///////////////////////////////////////////////////////////////////////////////////\r\ncontract Storage0 {\r\n    // funcId => delegate contract\r\n    mapping(bytes4 => address) internal delegates;\r\n}\r\n///////////////////////////////////////////////////////////////////////////////////\r\n//MokenUpdates\r\n//MokenOwner\r\n//QueryMokenDelegates\r\n///////////////////////////////////////////////////////////////////////////////////\r\ncontract Storage1 is Storage0 {\r\n    address internal contractOwner;\r\n    bytes[] internal funcSignatures;\r\n    // signature => index+1\r\n    mapping(bytes => uint256) internal funcSignatureToIndex;\r\n}\r\n///////////////////////////////////////////////////////////////////////////////////\r\n//MokensSupportsInterfaces\r\n///////////////////////////////////////////////////////////////////////////////////\r\ncontract Storage2 is Storage1 {\r\n    mapping(bytes4 => bool) internal supportedInterfaces;\r\n}\r\n///////////////////////////////////////////////////////////////////////////////////\r\n//MokenRootOwnerOf\r\n//MokenERC721Metadata\r\n///////////////////////////////////////////////////////////////////////////////////\r\ncontract Storage3 is Storage2 {\r\n    struct Moken {\r\n        string name;\r\n        uint256 data;\r\n        uint256 parentTokenId;\r\n    }\r\n    //tokenId => moken\r\n    mapping(uint256 => Moken) internal mokens;\r\n    uint256 internal mokensLength;\r\n    // child address => child tokenId => tokenId+1\r\n    mapping(address => mapping(uint256 => uint256)) internal childTokenOwner;\r\n}\r\n///////////////////////////////////////////////////////////////////////////////////\r\n//MokenERC721Enumerable\r\n//MokenLinkHash\r\n///////////////////////////////////////////////////////////////////////////////////\r\ncontract Storage4 is Storage3 {\r\n    // root token owner address => (tokenId => approved address)\r\n    mapping(address => mapping(uint256 => address)) internal rootOwnerAndTokenIdToApprovedAddress;\r\n    // token owner => (operator address => bool)\r\n    mapping(address => mapping(address => bool)) internal tokenOwnerToOperators;\r\n    // Mapping from owner to list of owned token IDs\r\n    mapping(address => uint32[]) internal ownedTokens;\r\n}\r\n///////////////////////////////////////////////////////////////////////////////////\r\n//MokenERC998ERC721TopDown\r\n//MokenERC998ERC721TopDownBatch\r\n//MokenERC721\r\n//MokenERC721Batch\r\n///////////////////////////////////////////////////////////////////////////////////\r\ncontract Storage5 is Storage4 {\r\n    // tokenId => (child address => array of child tokens)\r\n    mapping(uint256 => mapping(address => uint256[])) internal childTokens;\r\n    // tokenId => (child address => (child token => child index)\r\n    mapping(uint256 => mapping(address => mapping(uint256 => uint256))) internal childTokenIndex;\r\n    // tokenId => (child address => contract index)\r\n    mapping(uint256 => mapping(address => uint256)) internal childContractIndex;\r\n    // tokenId => child contract\r\n    mapping(uint256 => address[]) internal childContracts;\r\n}\r\n///////////////////////////////////////////////////////////////////////////////////\r\n//MokenERC998ERC20TopDown\r\n//MokenStateChange\r\n///////////////////////////////////////////////////////////////////////////////////\r\ncontract Storage6 is Storage5 {\r\n    // tokenId => token contract\r\n    mapping(uint256 => address[]) internal erc20Contracts;\r\n    // tokenId => (token contract => token contract index)\r\n    mapping(uint256 => mapping(address => uint256)) erc20ContractIndex;\r\n    // tokenId => (token contract => balance)\r\n    mapping(uint256 => mapping(address => uint256)) internal erc20Balances;\r\n}\r\n///////////////////////////////////////////////////////////////////////////////////\r\n//MokenERC998ERC721BottomUp\r\n//MokenERC998ERC721BottomUpBatch\r\n///////////////////////////////////////////////////////////////////////////////////\r\ncontract Storage7 is Storage6 {\r\n    // parent address => (parent tokenId => array of child tokenIds)\r\n    mapping(address => mapping(uint256 => uint32[])) internal parentToChildTokenIds;\r\n    // tokenId => position in childTokens array\r\n    mapping(uint256 => uint256) internal tokenIdToChildTokenIdsIndex;\r\n}\r\n///////////////////////////////////////////////////////////////////////////////////\r\n//MokenMinting\r\n//MokenMintContractManagement\r\n//MokenEras\r\n//QueryMokenData\r\n///////////////////////////////////////////////////////////////////////////////////\r\ncontract Storage8 is Storage7 {\r\n    // index => category\r\n    mapping(uint256 => bytes32) internal categories;\r\n    uint256 internal categoryLength;\r\n    // category => index+1\r\n    mapping(bytes32 => uint256) internal categoryIndex;\r\n    uint256 internal mintPriceOffset; // = 0 szabo;\r\n    uint256 internal mintStepPrice; // = 500 szabo;\r\n    uint256 internal mintPriceBuffer; // = 5000 szabo;\r\n    address[] internal mintContracts;\r\n    mapping(address => uint256) internal mintContractIndex;\r\n    //moken name => tokenId+1\r\n    mapping(string => uint256) internal tokenByName_;\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////////////\r\n// MokenCredit\r\n///////////////////////////////////////////////////////////////////////////////////\r\ncontract Storage9 is Storage8 {\r\n    // molder => wei\r\n    mapping(address => uint256) internal credit;\r\n\r\n    // categoryIndex >> mint price\r\n    mapping(uint256 => uint256) internal categoryMintPrice;\r\n}\r\n\r\ncontract MokenCategories is Storage9 {\r\n\r\n    event NewCategory(\r\n        uint256 index,\r\n        bytes32 name,\r\n        uint256 mintPrice\r\n    );\r\n\r\n    function addCategory(bytes32 _categoryName, uint256 _mintPrice) external returns (uint256 index) {\r\n        require(msg.sender == contractOwner, \"Must own Mokens contract.\");\r\n        index = categoryLength++;\r\n        categories[index] = _categoryName;\r\n        categoryIndex[_categoryName] = index + 1;\r\n        categoryMintPrice[index] = _mintPrice;\r\n        emit NewCategory(index, _categoryName, _mintPrice);\r\n    }\r\n\r\n    function setCategoryMintPrice(uint256 _index, uint256 _mintPrice) external  {\r\n        require(msg.sender == contractOwner, \"Must own Mokens contract.\");\r\n        categoryMintPrice[_index] = _mintPrice;\r\n    }\r\n\r\n    function categoryByIndex(uint256 _index) external view returns (bytes32 category) {\r\n        require(_index < categoryLength, \"No category at this index.\");\r\n        category = categories[_index];\r\n    }\r\n\r\n    function categoryByName(bytes32 _categoryName) external view returns (uint256 indexOfCategory) {\r\n        uint256 index = categoryIndex[_categoryName];\r\n        require(index != 0, \"No era exists with this name.\");\r\n        indexOfCategory = index - 1;\r\n    }\r\n\r\n    function categoryExists(bytes32 _categoryName) external view returns (bool) {\r\n        return categoryIndex[_categoryName] != 0;\r\n    }\r\n\r\n    function categoryMintPriceByIndex(uint256 _categoryIndex) external view returns (uint256){\r\n        require(_categoryIndex < categoryLength, \"No category at this index.\");\r\n        return categoryMintPrice[_categoryIndex];\r\n    }\r\n\r\n    function categoryNames() external view returns (bytes32[] memory names){\r\n        uint256 categoryLength_ = categoryLength;\r\n        names = new bytes32[](categoryLength_);\r\n        for(uint256 i; i < categoryLength_; i++) {\r\n            names[i] = categories[i];\r\n        }\r\n    }\r\n\r\n    function categoryMintPrices() external view returns (uint256[] memory prices){\r\n        uint256 categoryLength_ = categoryLength;\r\n        prices = new uint256[](categoryLength_);\r\n        for(uint256 i; i < categoryLength_; i++) {\r\n            prices[i] = categoryMintPrice[i];\r\n        }\r\n    }\r\n\r\n    function totalCategories() external view returns (uint256) {\r\n        return categoryLength;\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_categoryName\",\"type\":\"bytes32\"},{\"name\":\"_mintPrice\",\"type\":\"uint256\"}],\"name\":\"addCategory\",\"outputs\":[{\"name\":\"index\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"categoryNames\",\"outputs\":[{\"name\":\"names\",\"type\":\"bytes32[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_categoryName\",\"type\":\"bytes32\"}],\"name\":\"categoryExists\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalCategories\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"categoryMintPrices\",\"outputs\":[{\"name\":\"prices\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"categoryByIndex\",\"outputs\":[{\"name\":\"category\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_index\",\"type\":\"uint256\"},{\"name\":\"_mintPrice\",\"type\":\"uint256\"}],\"name\":\"setCategoryMintPrice\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_categoryName\",\"type\":\"bytes32\"}],\"name\":\"categoryByName\",\"outputs\":[{\"name\":\"indexOfCategory\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_categoryIndex\",\"type\":\"uint256\"}],\"name\":\"categoryMintPriceByIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"index\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"name\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"mintPrice\",\"type\":\"uint256\"}],\"name\":\"NewCategory\",\"type\":\"event\"}]","ContractName":"MokenCategories","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"999","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://3b25c8f8438de3c526742558ba8e95130b97484e19c85a1563bdcfa4e9b63991"}]}