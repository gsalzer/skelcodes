{"status":"1","message":"OK","result":[{"SourceCode":"// File: contracts/Set.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\nlibrary Set {\r\n    // We define a new struct datatype that will be used to\r\n    // hold its data in the calling contract.\r\n    struct Data { \r\n        mapping(address => bool) flags;\r\n    }\r\n\r\n    // Note that the first parameter is of type \"storage\r\n    // reference\" and thus only its storage address and not\r\n    // its contents is passed as part of the call.  This is a\r\n    // special feature of library functions.  It is idiomatic\r\n    // to call the first parameter `self`, if the function can\r\n    // be seen as a method of that object.\r\n    function insert(Data storage self, address value)\r\n        public\r\n        returns (bool)\r\n    {\r\n        if (self.flags[value])\r\n            return false; // already there\r\n        self.flags[value] = true;\r\n        return true;\r\n    }\r\n\r\n    function remove(Data storage self, address value)\r\n        public\r\n        returns (bool)\r\n    {\r\n        if (!self.flags[value])\r\n            return false; // not there\r\n        self.flags[value] = false;\r\n        return true;\r\n    }\r\n\r\n    function contains(Data storage self, address value)\r\n        public\r\n        view\r\n        returns (bool)\r\n    {\r\n        return self.flags[value];\r\n    }\r\n}\r\n\r\n// File: contracts/Crowdsourcing.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\ncontract Crowdsourcing {\r\n    address public _owner;\r\n    string task;\r\n    uint private _total;\r\n    uint private _amount;\r\n    string private _content;\r\n    uint private _current  = 0;\r\n    address[] private workersArr;\r\n    uint private workerCount;\r\n    mapping(address => bool) public paid;\r\n    mapping(address => string) private answers;\r\n    Set.Data workers;\r\n    \r\n    event toVerification (\r\n        address indexed id\r\n    );\r\n    \r\n    event rejection (\r\n        address indexed rejected\r\n    );\r\n    \r\n    constructor(address owner, uint total, string memory content, uint money) public payable{\r\n        require(money % total == 0);\r\n        _owner = owner;\r\n        _total = total;\r\n        _amount = money;\r\n        _content = content;\r\n\r\n    }\r\n    \r\n    function getTotal() public view returns (uint) {\r\n        return _total;\r\n    }\r\n    \r\n    function getAmount() public view returns (uint) {\r\n        return _amount;\r\n    }\r\n    \r\n    function getContent() public view returns (string memory) {\r\n        return _content;\r\n    }\r\n\r\n    function isPaying() public view returns (bool) {\r\n        return _current  < _total;\r\n    }\r\n    \r\n    function getAnswers(address f) public view returns (string memory) {\r\n        require (msg.sender == _owner);\r\n        return answers[f];\r\n    }\r\n    \r\n    function addMoney() public payable {\r\n        require((msg.value + _amount) % _total == 0);\r\n        _amount += msg.value;\r\n    }\r\n    \r\n    // fallback function\r\n    function() external payable { }\r\n    \r\n    function stop() public {\r\n        require (msg.sender == _owner);\r\n        selfdestruct(msg.sender);\r\n    }\r\n    \r\n    function accept(address payable target) public payable {\r\n        require(msg.sender == _owner);\r\n        require(!paid[target]);\r\n        require(Set.contains(workers, target));\r\n        require(_current  < _total);\r\n        paid[target] = true;\r\n        _current ++;\r\n        target.transfer(_amount / _total);\r\n    }\r\n    \r\n    function reject(address payable target) public payable {\r\n        require(msg.sender == _owner);\r\n        require(!paid[target]);\r\n        require(Set.contains(workers, target));\r\n        require(_current  < _total);\r\n        emit rejection(target);\r\n        answers[target] = '';\r\n    }\r\n    \r\n    function answer(string calldata ans) external {\r\n        answers[msg.sender] = ans;\r\n        workersArr.push(msg.sender);\r\n        if (Set.insert(workers, msg.sender))\r\n        {\r\n            workerCount++;\r\n        }\r\n        emit toVerification(msg.sender);\r\n    }\r\n\r\n    function getWorkers(uint number) public view returns (address) {\r\n        require(msg.sender == _owner);\r\n        require(number < workerCount);\r\n        return workersArr[number];\r\n    }\r\n\r\n    function getNumberOfWorkers() public view returns (uint) {\r\n        require(msg.sender == _owner);\r\n        return workerCount;\r\n    }\r\n\r\n    function isPaid(address a) public view returns (bool) {\r\n        return paid[a];\r\n    }\r\n    \r\n    function myPay() public view returns (bool) {\r\n        return paid[msg.sender];\r\n    }\r\n    \r\n    function myAnswer() public view returns (string memory) {\r\n        if (bytes(answers[msg.sender]).length == 0) return \"\";\r\n        return answers[msg.sender];\r\n    }\r\n}\r\n\r\n// File: contracts/CrdSet-dev.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\ncontract CrdSet {\r\n    Crowdsourcing[] public list;\r\n    event newContract(Crowdsourcing indexed c);\r\n\r\n    function createCC(uint total, string memory content) public payable returns (Crowdsourcing){\r\n        require(msg.value % total == 0, \"Amount of money need to be dividable by the total number of answers\");\r\n        Crowdsourcing a = new Crowdsourcing(msg.sender, total, content, msg.value);\r\n        list.push(a);\r\n        address(a).transfer(msg.value);\r\n        emit newContract(a);\r\n        return a;\r\n    }\r\n    \r\n    function getContracCount() public view returns (uint) {\r\n        return list.length;\r\n    }\r\n    \r\n}","ABI":"[]","ContractName":"Set","CompilerVersion":"v0.5.6+commit.b259423e","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://3a6ddf780cb0756395d44937af1d16e7ba8825600213c38bbd4173ccd97593be"}]}