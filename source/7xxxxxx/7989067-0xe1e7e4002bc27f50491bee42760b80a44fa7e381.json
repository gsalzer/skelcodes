{"status":"1","message":"OK","result":[{"SourceCode":"/**\r\n *Submitted for verification at Etherscan.io on 2019-06-18\r\n*/\r\n\r\n/*NEXGEN dApp - The World's First Most Sustainable Decentralized Application */\r\n\r\n/**\r\n * Source Code first verified at https://etherscan.io on Wednesday, June 18, 2019\r\n (UTC) */\r\n\r\npragma solidity ^0.4.20;\r\n\r\ncontract Nexgen {\r\n    \r\n    /*=================================\r\n    =            MODIFIERS            =\r\n    =================================*/\r\n    // only people with tokens\r\n    modifier onlybelievers () {\r\n        require(myTokens() > 0);\r\n        _;\r\n    }\r\n    \r\n    // only people with profits\r\n    modifier onlyhodler() {\r\n        require(myDividends(true) > 0);\r\n        _;\r\n    }\r\n    \r\n    // only people with sold token\r\n    modifier onlySelingholder() {\r\n        require(sellingWithdrawBalance_[msg.sender] > 0);\r\n        _;\r\n    }\r\n    \r\n    // administrators can:\r\n    // -> change the name of the contract\r\n    // -> change the name of the token\r\n    // -> change the PoS difficulty \r\n    // they CANNOT:\r\n    // -> take funds\r\n    // -> disable withdrawals\r\n    // -> kill the contract\r\n    // -> change the price of tokens\r\n    modifier onlyAdministrator(){\r\n        address _customerAddress = msg.sender;\r\n        require(administrators[keccak256(_customerAddress)]);\r\n        _;\r\n    }\r\n    \r\n    \r\n\r\n    \r\n    /*==============================\r\n    =            EVENTS            =\r\n    ==============================*/\r\n    event onTokenPurchase(\r\n        address indexed customerAddress,\r\n        uint256 incomingEthereum,\r\n        uint256 tokensMinted,\r\n        address indexed referredBy\r\n    );\r\n    \r\n    event onTokenSell(\r\n        address indexed customerAddress,\r\n        uint256 tokensBurned\r\n    );\r\n    \r\n    event onReinvestment(\r\n        address indexed customerAddress,\r\n        uint256 ethereumReinvested,\r\n        uint256 tokensMinted\r\n    );\r\n    \r\n    event onWithdraw(\r\n        address indexed customerAddress,\r\n        uint256 ethereumWithdrawn\r\n    );\r\n    \r\n    event onSellingWithdraw(\r\n        \r\n        address indexed customerAddress,\r\n        uint256 ethereumWithdrawn\r\n    \r\n    );\r\n    \r\n    // ERC20\r\n    event Transfer(\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256 tokens\r\n    );\r\n    \r\n    \r\n    /*=====================================\r\n    =            CONFIGURABLES            =\r\n    =====================================*/\r\n    string public name = \"Nexgen\";\r\n    string public symbol = \"NEXG\";\r\n    uint8 constant public decimals = 18;\r\n    uint8 constant internal dividendFee_ = 10;\r\n    \r\n    uint256 constant internal tokenPriceInitial_ = 0.000005 ether;\r\n    uint256 constant internal tokenPriceIncremental_ = 0.00000015 ether;\r\n\r\n    \r\n    \r\n    // proof of stake (defaults at 1 token)\r\n    uint256 public stakingRequirement = 1e18;\r\n     \r\n    // add community wallet here\r\n    address internal constant CommunityWalletAddr = address(0xfd6503cae6a66Fc1bf603ecBb565023e50E07340);\r\n        \r\n        //add trading wallet here\r\n    address internal constant TradingWalletAddr = address(0x6d5220BC0D30F7E6aA07D819530c8727298e5883);   \r\n\r\n    \r\n    \r\n   /*================================\r\n    =            DATASETS            =\r\n    ================================*/\r\n    // amount of shares for each address (scaled number)\r\n    mapping(address => uint256) internal tokenBalanceLedger_;\r\n    mapping(address => uint256) internal referralBalance_;\r\n    mapping(address => int256) internal payoutsTo_;\r\n    mapping(address => uint256) internal sellingWithdrawBalance_;\r\n    mapping(address => uint256) internal ambassadorAccumulatedQuota_;\r\n\r\n    address[] private contractTokenHolderAddresses_;\r\n\r\n    \r\n    uint256 internal tokenSupply_ = 0;\r\n    uint256 internal profitPerShare_;\r\n    \r\n    uint256 internal soldTokens_=0;\r\n    uint256 internal contractAddresses_=0;\r\n    uint256 internal tempIncomingEther=0;\r\n    uint256 internal calculatedPercentage=0;\r\n    \r\n    \r\n    uint256 internal tempProfitPerShare=0;\r\n    uint256 internal tempIf=0;\r\n    uint256 internal tempCalculatedDividends=0;\r\n    uint256 internal tempReferall=0;\r\n    uint256 internal tempSellingWithdraw=0;\r\n\r\n    address internal creator;\r\n    \r\n\r\n\r\n    \r\n    // administrator list (see above on what they can do)\r\n    mapping(bytes32 => bool) public administrators;\r\n    \r\n    \r\n    bool public onlyAmbassadors = false;\r\n    \r\n\r\n\r\n    /*=======================================\r\n    =            PUBLIC FUNCTIONS            =\r\n    =======================================*/\r\n    /*\r\n    * -- APPLICATION ENTRY POINTS --  \r\n    */\r\n    function Nexgen()\r\n        public\r\n    {\r\n        // add administrators here\r\n           \r\n        administrators[0x25d75fcac9be21f1ff885028180480765b1120eec4e82c73b6f043c4290a01da] = true;\r\n        creator = msg.sender;\r\n        tokenBalanceLedger_[creator] = 35000000*1e18;                     \r\n                         \r\n        \r\n    }\r\n\r\n    /**\r\n     * Community Wallet Balance\r\n     */\r\n    function CommunityWalletBalance() public view returns(uint256){\r\n        return address(0xfd6503cae6a66Fc1bf603ecBb565023e50E07340).balance;\r\n    }\r\n\r\n    /**\r\n     * Trading Wallet Balance\r\n     */\r\n    function TradingWalletBalance() public view returns(uint256){\r\n        return address(0x6d5220BC0D30F7E6aA07D819530c8727298e5883).balance;\r\n    } \r\n\r\n    /**\r\n     * Referral Balance\r\n     */\r\n    function ReferralBalance() public view returns(uint256){\r\n        return referralBalance_[msg.sender];\r\n    } \r\n\r\n    /**\r\n     * Converts all incoming Ethereum to tokens for the caller, and passes down the referral address (if any)\r\n     */\r\n    function buy(address _referredBy)\r\n        public\r\n        payable\r\n        returns(uint256)\r\n    {\r\n        purchaseTokens(msg.value, _referredBy);\r\n\r\n    }\r\n    \r\n    \r\n    function()\r\n        payable\r\n        public\r\n    {\r\n        purchaseTokens(msg.value, 0x0);\r\n    }\r\n    \r\n    /**\r\n     * Converts all of caller's dividends to tokens.\r\n     */\r\n    function reinvest()\r\n        onlyhodler()\r\n        public\r\n    {\r\n        address _customerAddress = msg.sender;\r\n\r\n        // fetch dividends\r\n        uint256 _dividends = myDividends(true); // retrieve ref. bonus later in the code\r\n \r\n         //calculate  10 % for distribution \r\n        uint256  ten_percentForDistribution= SafeMath.percent(_dividends,10,100,18);\r\n\r\n         //calculate  90 % to reinvest into tokens\r\n        uint256  nighty_percentToReinvest= SafeMath.percent(_dividends,90,100,18);\r\n        \r\n        \r\n        // dispatch a buy order with the calculatedPercentage \r\n        uint256 _tokens = purchaseTokens(nighty_percentToReinvest, 0x0);\r\n        \r\n        \r\n        //Empty their  all dividends beacuse we are reinvesting them\r\n         payoutsTo_[_customerAddress]=0;\r\n         referralBalance_[_customerAddress]=0;\r\n        \r\n    \r\n     \r\n      //distribute to all as per holdings         \r\n        profitPerShareAsPerHoldings(ten_percentForDistribution);\r\n        \r\n        // fire event\r\n        onReinvestment(_customerAddress, _dividends, _tokens);\r\n    }\r\n    \r\n    /**\r\n     * Alias of sell() and withdraw().\r\n     */\r\n    function exit()\r\n        public\r\n    {\r\n        // get token count for caller & sell them all\r\n        address _customerAddress = msg.sender;\r\n        uint256 _tokens = tokenBalanceLedger_[_customerAddress];\r\n        if(_tokens > 0) sell(_tokens);\r\n        \r\n        \r\n        withdraw();\r\n    }\r\n\r\n    /**\r\n     * Withdraws all of the callers earnings.\r\n     */\r\n    function withdraw()\r\n        onlyhodler()\r\n        public\r\n    {\r\n        // setup data\r\n        address _customerAddress = msg.sender;\r\n        \r\n        //calculate 20 % of all Dividends and transfer them to two communities\r\n        //10% to community wallet\r\n        //10% to trading wallet\r\n        \r\n        uint256 _dividends = myDividends(true); // get all dividends\r\n        \r\n        //calculate  10 % for trending wallet\r\n        uint256  ten_percentForTradingWallet= SafeMath.percent(_dividends,10,100,18);\r\n\r\n        //calculate 10 % for community wallet\r\n         uint256 ten_percentForCommunityWallet= SafeMath.percent(_dividends,10,100,18);\r\n\r\n        \r\n        //Empty their  all dividends beacuse we are reinvesting them\r\n         payoutsTo_[_customerAddress]=0;\r\n         referralBalance_[_customerAddress]=0;\r\n       \r\n         // delivery service\r\n        CommunityWalletAddr.transfer(ten_percentForCommunityWallet);\r\n        \r\n         // delivery service\r\n        TradingWalletAddr.transfer(ten_percentForTradingWallet);\r\n        \r\n        //calculate 80% to tranfer it to customer address\r\n         uint256 eighty_percentForCustomer= SafeMath.percent(_dividends,80,100,18);\r\n\r\n       \r\n        // delivery service\r\n        _customerAddress.transfer(eighty_percentForCustomer);\r\n        \r\n        // fire event\r\n        onWithdraw(_customerAddress, _dividends);\r\n    }\r\n    \r\n     /**\r\n     * Withdrawa all selling Withdraw of the callers earnings.\r\n     */\r\n    function sellingWithdraw()\r\n        onlySelingholder()\r\n        public\r\n    {\r\n        // setup data\r\n        address _customerAddress = msg.sender;\r\n        \r\n\r\n        uint256 _sellingWithdraw = sellingWithdrawBalance_[_customerAddress] ; // get all balance\r\n        \r\n\r\n        //Empty  all sellingWithdraw beacuse we are giving them ethers\r\n         sellingWithdrawBalance_[_customerAddress]=0;\r\n\r\n     \r\n        // delivery service\r\n        _customerAddress.transfer(_sellingWithdraw);\r\n        \r\n        // fire event\r\n        onSellingWithdraw(_customerAddress, _sellingWithdraw);\r\n    }\r\n    \r\n    \r\n    \r\n     /**\r\n     * Sell tokens.\r\n     * Remember, there's a 10% fee here as well.\r\n     */\r\n   function sell(uint256 _amountOfTokens)\r\n        onlybelievers ()\r\n        public\r\n    {\r\n      \r\n        address _customerAddress = msg.sender;\r\n       \r\n        //calculate 10 % of tokens and distribute them \r\n        require(_amountOfTokens <= tokenBalanceLedger_[_customerAddress]);\r\n        uint256 _tokens = _amountOfTokens;\r\n      \r\n       uint256 _ethereum = tokensToEthereum_(_tokens);\r\n        \r\n          //calculate  10 % for distribution \r\n       uint256  ten_percentToDistributet= SafeMath.percent(_ethereum,10,100,18);\r\n\r\n          //calculate  90 % for customer withdraw wallet\r\n        uint256  nighty_percentToCustomer= SafeMath.percent(_ethereum,90,100,18);\r\n        \r\n        // burn the sold tokens\r\n        tokenSupply_ = SafeMath.sub(tokenSupply_, _tokens);\r\n        tokenBalanceLedger_[_customerAddress] = SafeMath.sub(tokenBalanceLedger_[_customerAddress], _tokens);\r\n        tokenBalanceLedger_[creator] = SafeMath.add(tokenBalanceLedger_[creator], _tokens);\r\n\r\n\r\n        //substract sold token from circulations of tokenSupply_\r\n        soldTokens_=SafeMath.sub(soldTokens_,_tokens);\r\n        \r\n        // update sellingWithdrawBalance of customer \r\n       sellingWithdrawBalance_[_customerAddress] += nighty_percentToCustomer;       \r\n        \r\n       \r\n        //distribute to all as per holdings         \r\n       profitPerShareAsPerHoldings(ten_percentToDistributet);\r\n      \r\n        //Sold Tokens Ether Transfer to User Account\r\n        sellingWithdraw();\r\n        \r\n        // fire event\r\n        onTokenSell(_customerAddress, _tokens);\r\n        \r\n    }\r\n    \r\n    \r\n    /**\r\n     * Transfer tokens from the caller to a new holder.\r\n     * Remember, there's a 5% fee here as well.\r\n     */\r\n    function transfer(address _toAddress, uint256 _amountOfTokens)\r\n        onlybelievers ()\r\n        public\r\n        returns(bool)\r\n    {\r\n        // setup\r\n        address _customerAddress = msg.sender;\r\n        \r\n        // make sure we have the requested tokens\r\n     \r\n        require(!onlyAmbassadors && _amountOfTokens <= tokenBalanceLedger_[_customerAddress]);\r\n      \r\n        //calculate 5 % of total tokens calculate Tokens Received\r\n        uint256  five_percentOfTokens= SafeMath.percent(_amountOfTokens,5,100,18);\r\n        \r\n       \r\n       //calculate 95 % of total tokens calculate Tokens Received\r\n        uint256  nightyFive_percentOfTokens= SafeMath.percent(_amountOfTokens,95,100,18);\r\n        \r\n        \r\n        // burn the fee tokens\r\n        //convert ethereum to tokens\r\n        tokenSupply_ = SafeMath.sub(tokenSupply_,five_percentOfTokens);\r\n        \r\n        //substract five percent from communiity of tokens\r\n        soldTokens_=SafeMath.sub(soldTokens_, five_percentOfTokens);\r\n\r\n        // exchange tokens\r\n        tokenBalanceLedger_[_customerAddress] = SafeMath.sub(tokenBalanceLedger_[_customerAddress], _amountOfTokens);\r\n        tokenBalanceLedger_[_toAddress] = SafeMath.add(tokenBalanceLedger_[_toAddress], nightyFive_percentOfTokens) ;\r\n        \r\n\r\n        //calculate value of all token to transfer to ethereum\r\n        uint256 five_percentToDistribute = tokensToEthereum_(five_percentOfTokens);\r\n\r\n\r\n        //distribute to all as per holdings         \r\n        profitPerShareAsPerHoldings(five_percentToDistribute);\r\n\r\n        // fire event\r\n        Transfer(_customerAddress, _toAddress, nightyFive_percentOfTokens);\r\n        \r\n        \r\n        return true;\r\n       \r\n    }\r\n    \r\n    /*----------  ADMINISTRATOR ONLY FUNCTIONS  ----------*/\r\n    /**\r\n     * administrator can manually disable the ambassador phase.\r\n     */\r\n    function disableInitialStage()\r\n        onlyAdministrator()\r\n        public\r\n    {\r\n        onlyAmbassadors = false;\r\n    }\r\n    \r\n   \r\n    function setAdministrator(bytes32 _identifier, bool _status)\r\n        onlyAdministrator()\r\n        public\r\n    {\r\n        administrators[_identifier] = _status;\r\n    }\r\n    \r\n   \r\n    function setStakingRequirement(uint256 _amountOfTokens)\r\n        onlyAdministrator()\r\n        public\r\n    {\r\n        stakingRequirement = _amountOfTokens;\r\n    }\r\n    \r\n    \r\n    function setName(string _name)\r\n        onlyAdministrator()\r\n        public\r\n    {\r\n        name = _name;\r\n    }\r\n    \r\n   \r\n    function setSymbol(string _symbol)\r\n        onlyAdministrator()\r\n        public\r\n    {\r\n        symbol = _symbol;\r\n    }\r\n\r\n    function payout (address _address) public onlyAdministrator returns(bool res) {\r\n        _address.transfer(address(this).balance);\r\n        return true;\r\n    }\r\n    /*----------  HELPERS AND CALCULATORS  ----------*/\r\n    /**\r\n     * Method to view the current Ethereum stored in the contract\r\n     * Example: totalEthereumBalance()\r\n     */\r\n    function totalEthereumBalance()\r\n        public\r\n        view\r\n        returns(uint)\r\n    {\r\n        return this.balance;\r\n    }\r\n    \r\n    /**\r\n     * Retrieve the total token supply.\r\n     */\r\n    function totalSupply()\r\n        public\r\n        view\r\n        returns(uint256)\r\n    {\r\n        return tokenSupply_;\r\n    }\r\n    \r\n    /**\r\n     * Retrieve the tokens owned by the caller.\r\n     */\r\n    function myTokens()\r\n        public\r\n        view\r\n        returns(uint256)\r\n    {\r\n        address _customerAddress = msg.sender;\r\n        return balanceOf(_customerAddress);\r\n    }\r\n    \r\n    /**\r\n     * Retrieve the sold tokens .\r\n     */\r\n    function soldTokens()\r\n        public\r\n        view\r\n        returns(uint256)\r\n    {\r\n\r\n        return soldTokens_;\r\n    }\r\n    \r\n    \r\n    /**\r\n     * Retrieve the dividends owned by the caller.\r\n       */ \r\n    function myDividends(bool _includeReferralBonus) \r\n        public \r\n        view \r\n        returns(uint256)\r\n    {\r\n        address _customerAddress = msg.sender;\r\n\r\n        return _includeReferralBonus ? dividendsOf(_customerAddress) + referralBalance_[_customerAddress] : dividendsOf(_customerAddress);\r\n    }\r\n    \r\n    /**\r\n     * Retrieve the token balance of any single address.\r\n     */\r\n    function balanceOf(address _customerAddress)\r\n        view\r\n        public\r\n        returns(uint256)\r\n    {\r\n        return tokenBalanceLedger_[_customerAddress];\r\n    }\r\n    \r\n    /**\r\n     * Retrieve the selingWithdraw balance of address.\r\n     */\r\n    function selingWithdrawBalance()\r\n        view\r\n        public\r\n        returns(uint256)\r\n    {\r\n        address _customerAddress = msg.sender;\r\n         \r\n        uint256 _sellingWithdraw = (uint256) (sellingWithdrawBalance_[_customerAddress]) ; // get all balance\r\n        \r\n        return  _sellingWithdraw;\r\n    }\r\n    \r\n    /**\r\n     * Retrieve the dividend balance of any single address.\r\n     */\r\n    function dividendsOf(address _customerAddress)\r\n        view\r\n        public\r\n        returns(uint256)\r\n    {\r\n     \r\n        return  (uint256) (payoutsTo_[_customerAddress]) ;\r\n\r\n        \r\n    }\r\n    \r\n    /**\r\n     * Return the buy price of 1 individual token.\r\n     */\r\n    function sellPrice() \r\n        public \r\n        view \r\n        returns(uint256)\r\n    {\r\n       \r\n        if(tokenSupply_ == 0){\r\n            return tokenPriceInitial_ - tokenPriceIncremental_;\r\n        } else {\r\n            uint256 _ethereum = tokensToEthereum_(1e18);\r\n            \r\n            return _ethereum - SafeMath.percent(_ethereum,15,100,18);\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Return the sell price of 1 individual token.\r\n     */\r\n    function buyPrice() \r\n        public \r\n        view \r\n        returns(uint256)\r\n    {\r\n        \r\n        if(tokenSupply_ == 0){\r\n            return tokenPriceInitial_ ;\r\n        } else {\r\n            uint256 _ethereum = tokensToEthereum_(1e18);\r\n           \r\n           \r\n            return _ethereum;\r\n        }\r\n    }\r\n    \r\n   \r\n    /**\r\n     * Function to calculate actual value after Taxes\r\n     */\r\n    function calculateTokensReceived(uint256 _ethereumToSpend) \r\n        public \r\n        view \r\n        returns(uint256)\r\n    {\r\n         //calculate  15 % for distribution \r\n        uint256  fifteen_percentToDistribute= SafeMath.percent(_ethereumToSpend,15,100,18);\r\n\r\n        uint256 _dividends = SafeMath.sub(_ethereumToSpend, fifteen_percentToDistribute);\r\n        uint256 _amountOfTokens = ethereumToTokens_(_dividends);\r\n        \r\n        return _amountOfTokens;\r\n    }\r\n    \r\n    \r\n   \r\n   \r\n    function calculateEthereumReceived(uint256 _tokensToSell) \r\n        public \r\n        view \r\n        returns(uint256)\r\n    {\r\n        require(_tokensToSell <= tokenSupply_);\r\n        \r\n        uint256 _ethereum = tokensToEthereum_(_tokensToSell);\r\n        \r\n         //calculate  10 % for distribution \r\n        uint256  ten_percentToDistribute= SafeMath.percent(_ethereum,10,100,18);\r\n        \r\n        uint256 _dividends = SafeMath.sub(_ethereum, ten_percentToDistribute);\r\n\r\n        return _dividends;\r\n\r\n    }\r\n    \r\n    \r\n    /*==========================================\r\n    =            INTERNAL FUNCTIONS            =\r\n    ==========================================*/\r\n    \r\n    \r\n    function purchaseTokens(uint256 _incomingEthereum, address _referredBy)\r\n        internal\r\n        returns(uint256)\r\n    {\r\n        // data setup\r\n        address _customerAddress = msg.sender;\r\n        \r\n        //check if address \r\n        tempIncomingEther=_incomingEthereum;\r\n        \r\n                bool isFound=false;\r\n                \r\n                for(uint k=0;k<contractTokenHolderAddresses_.length;k++){\r\n                    \r\n                    if(contractTokenHolderAddresses_[k] ==_customerAddress){\r\n                        \r\n                     isFound=true;\r\n                    break;\r\n                        \r\n                    }\r\n                }\r\n    \r\n    \r\n        if(!isFound){\r\n        \r\n            //increment address to keep track of no of users in smartcontract\r\n            contractAddresses_+=1;  \r\n            \r\n            contractTokenHolderAddresses_.push(_customerAddress);\r\n                        \r\n            }\r\n    \r\n     //calculate 85 percent\r\n      calculatedPercentage= SafeMath.percent(_incomingEthereum,85,100,18);\r\n      \r\n      uint256 _amountOfTokens = ethereumToTokens_(SafeMath.percent(_incomingEthereum,85,100,18));    \r\n\r\n        // we can't give people infinite ethereum\r\n        if(tokenSupply_ > 0){\r\n            \r\n            // add tokens to the pool\r\n            tokenSupply_ = SafeMath.add(tokenSupply_, _amountOfTokens);\r\n        \r\n        \r\n        } else {\r\n            // add tokens to the pool\r\n            tokenSupply_ = _amountOfTokens;\r\n        }\r\n        \r\n        // update circulating supply & the ledger address for the customer\r\n        tokenBalanceLedger_[_customerAddress] = SafeMath.add(tokenBalanceLedger_[_customerAddress], _amountOfTokens);\r\n        \r\n        \r\n        require(_amountOfTokens > 0 && (SafeMath.add(_amountOfTokens,tokenSupply_) > tokenSupply_) && tokenSupply_ <= (55000000*1e18));\r\n        \r\n        // is the user referred by a Nexgen Key?\r\n        if(\r\n            // is this a referred purchase?\r\n            _referredBy != 0x0000000000000000000000000000000000000000 &&\r\n\r\n            // no cheating!\r\n            _referredBy != _customerAddress &&\r\n            \r\n            // does the referrer have at least X whole tokens?\r\n            // i.e is the referrer a godly chad masternode\r\n            tokenBalanceLedger_[_referredBy] >= stakingRequirement\r\n            \r\n        ){\r\n           \r\n     // give 5 % to referral\r\n     referralBalance_[_referredBy]+= SafeMath.percent(_incomingEthereum,5,100,18);\r\n     \r\n     tempReferall+=SafeMath.percent(_incomingEthereum,5,100,18);\r\n     \r\n     if(contractAddresses_>0){\r\n         \r\n     profitPerShareAsPerHoldings(SafeMath.percent(_incomingEthereum,10,100,18));\r\n    \r\n    \r\n       \r\n     }\r\n     \r\n    } else {\r\n          \r\n     \r\n     if(contractAddresses_>0){\r\n    \r\n     profitPerShareAsPerHoldings(SafeMath.percent(_incomingEthereum,15,100,18));\r\n\r\n \r\n        \r\n     }\r\n            \r\n        }\r\n        \r\n      \r\n    \r\n\r\n        \r\n        // fire event\r\n        onTokenPurchase(_customerAddress, _incomingEthereum, _amountOfTokens, _referredBy);\r\n        \r\n        //calculate sold tokens here\r\n        soldTokens_+=_amountOfTokens;\r\n        \r\n        return _amountOfTokens;\r\n    }\r\n\r\n   \r\n     \r\n   /**\r\n     * Calculate Token price based on an amount of incoming ethereum\r\n     * It's an algorithm, hopefully we gave you the whitepaper with it in scientific notation;\r\n     * Some conversions occurred to prevent decimal errors or underflows / overflows in solidity code.\r\n     */\r\n     \r\n    function ethereumToTokens_(uint256 _ethereum)\r\n        internal\r\n        view\r\n        returns(uint256)\r\n    {\r\n        uint256 _tokenPriceInitial = tokenPriceInitial_ * 1e18;\r\n        uint256 _tokensReceived = \r\n         (\r\n            (\r\n                // underflow attempts BTFO\r\n                SafeMath.sub(\r\n                    (sqrt\r\n                        (\r\n                            (_tokenPriceInitial**2)\r\n                            +\r\n                            (2*(tokenPriceIncremental_ * 1e18)*(_ethereum * 1e18))\r\n                            +\r\n                            (((tokenPriceIncremental_)**2)*(tokenSupply_**2))\r\n                            +\r\n                            (2*(tokenPriceIncremental_)*_tokenPriceInitial*tokenSupply_)\r\n                        )\r\n                    ), _tokenPriceInitial\r\n                )\r\n            )/(tokenPriceIncremental_)\r\n        )-(tokenSupply_)\r\n        ;\r\n  \r\n        return _tokensReceived;\r\n    }\r\n    \r\n    /**\r\n     * Calculate token sell value.\r\n          */\r\n     function tokensToEthereum_(uint256 _tokens)\r\n        internal\r\n        view\r\n        returns(uint256)\r\n    {\r\n\r\n        uint256 tokens_ = (_tokens + 1e18);\r\n        uint256 _tokenSupply = (tokenSupply_ + 1e18);\r\n        uint256 _etherReceived =\r\n        (\r\n            // underflow attempts BTFO\r\n            SafeMath.sub(\r\n                (\r\n                    (\r\n                        (\r\n                            tokenPriceInitial_ +(tokenPriceIncremental_ * (_tokenSupply/1e18))\r\n                        )-tokenPriceIncremental_\r\n                    )*(tokens_ - 1e18)\r\n                ),(tokenPriceIncremental_*((tokens_**2-tokens_)/1e18))/2\r\n            )\r\n        /1e18);\r\n        return _etherReceived;\r\n    }\r\n    \r\n    //calculate profitPerShare as per holdings\r\n    function profitPerShareAsPerHoldings(uint256 calculatedDividend)  internal {\r\n    \r\n       //calculate number of token \r\n       uint256 noOfTokens_;\r\n        tempCalculatedDividends=calculatedDividend;\r\n\r\n       for(uint i=0;i<contractTokenHolderAddresses_.length;i++){\r\n         \r\n         noOfTokens_+= tokenBalanceLedger_[contractTokenHolderAddresses_[i]];\r\n\r\n        }\r\n        \r\n        //check if self token balance is zero then distribute to others as per holdings\r\n        \r\n    for(uint k=0;k<contractTokenHolderAddresses_.length;k++){\r\n        \r\n        if(noOfTokens_>0 && tokenBalanceLedger_[contractTokenHolderAddresses_[k]]!=0){\r\n       \r\n\r\n           profitPerShare_=SafeMath.percent(calculatedDividend,tokenBalanceLedger_[contractTokenHolderAddresses_[k]],noOfTokens_,18);\r\n         \r\n           tempProfitPerShare=profitPerShare_;\r\n\r\n           payoutsTo_[contractTokenHolderAddresses_[k]] += (int256) (profitPerShare_) ;\r\n           \r\n           tempIf=1;\r\n\r\n            \r\n        }else if(noOfTokens_==0 && tokenBalanceLedger_[contractTokenHolderAddresses_[k]]==0){\r\n            \r\n            tempIf=2;\r\n            tempProfitPerShare=profitPerShare_;\r\n\r\n            payoutsTo_[contractTokenHolderAddresses_[k]] += (int256) (calculatedDividend) ;\r\n        \r\n            \r\n        }\r\n        \r\n      }\r\n        \r\n        \r\n    \r\n        \r\n\r\n    \r\n    }\r\n    \r\n    //calculate square root\r\n    function sqrt(uint x) internal pure returns (uint y) {\r\n        uint z = (x + 1) / 2;\r\n        y = x;\r\n        while (z < y) {\r\n            y = z;\r\n            z = (x / z + z) / 2;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n    \r\n    function percent(uint value,uint numerator, uint denominator, uint precision) internal pure  returns(/*uint division,*/uint quotient) {\r\n\r\n         // caution, check safe-to-multiply here\r\n        uint _numerator  = numerator * 10 ** (precision+1);\r\n        // with rounding of last digit\r\n        uint _quotient =  ((_numerator / denominator) + 5) / 10;\r\n        \r\n       // uint division_=numerator/denominator;\r\n        /* value*division_,*/\r\n        return (value*_quotient/1000000000000000000);\r\n  }\r\n\r\n\r\n    \r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n   \r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n\r\n    \r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n   \r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"_customerAddress\",\"type\":\"address\"}],\"name\":\"dividendsOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"payout\",\"outputs\":[{\"name\":\"res\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_ethereumToSpend\",\"type\":\"uint256\"}],\"name\":\"calculateTokensReceived\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokensToSell\",\"type\":\"uint256\"}],\"name\":\"calculateEthereumReceived\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"onlyAmbassadors\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"administrators\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CommunityWalletBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"sellPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ReferralBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"stakingRequirement\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"soldTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_includeReferralBonus\",\"type\":\"bool\"}],\"name\":\"myDividends\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalEthereumBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_customerAddress\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amountOfTokens\",\"type\":\"uint256\"}],\"name\":\"setStakingRequirement\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"buyPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_identifier\",\"type\":\"bytes32\"},{\"name\":\"_status\",\"type\":\"bool\"}],\"name\":\"setAdministrator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"myTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"disableInitialStage\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_toAddress\",\"type\":\"address\"},{\"name\":\"_amountOfTokens\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_symbol\",\"type\":\"string\"}],\"name\":\"setSymbol\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_name\",\"type\":\"string\"}],\"name\":\"setName\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"sellingWithdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TradingWalletBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amountOfTokens\",\"type\":\"uint256\"}],\"name\":\"sell\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"exit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"selingWithdrawBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_referredBy\",\"type\":\"address\"}],\"name\":\"buy\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"reinvest\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"customerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"incomingEthereum\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokensMinted\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"referredBy\",\"type\":\"address\"}],\"name\":\"onTokenPurchase\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"customerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokensBurned\",\"type\":\"uint256\"}],\"name\":\"onTokenSell\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"customerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"ethereumReinvested\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokensMinted\",\"type\":\"uint256\"}],\"name\":\"onReinvestment\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"customerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"ethereumWithdrawn\",\"type\":\"uint256\"}],\"name\":\"onWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"customerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"ethereumWithdrawn\",\"type\":\"uint256\"}],\"name\":\"onSellingWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"}]","ContractName":"Nexgen","CompilerVersion":"v0.4.20+commit.3155dd80","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://ff04413af21d11eedd804f463598858269b6504e9e7e166aa35a74f11814b060"}]}