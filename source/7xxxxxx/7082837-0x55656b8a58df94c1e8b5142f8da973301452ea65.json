{"status":"1","message":"OK","result":[{"SourceCode":"// File: contracts/installed_contracts/DLL.sol\r\n\r\npragma solidity^0.4.11;\r\n\r\nlibrary DLL {\r\n\r\n  uint constant NULL_NODE_ID = 0;\r\n\r\n  struct Node {\r\n    uint next;\r\n    uint prev;\r\n  }\r\n\r\n  struct Data {\r\n    mapping(uint => Node) dll;\r\n  }\r\n\r\n  function isEmpty(Data storage self) public view returns (bool) {\r\n    return getStart(self) == NULL_NODE_ID;\r\n  }\r\n\r\n  function contains(Data storage self, uint _curr) public view returns (bool) {\r\n    if (isEmpty(self) || _curr == NULL_NODE_ID) {\r\n      return false;\r\n    }\r\n\r\n    bool isSingleNode = (getStart(self) == _curr) && (getEnd(self) == _curr);\r\n    bool isNullNode = (getNext(self, _curr) == NULL_NODE_ID) && (getPrev(self, _curr) == NULL_NODE_ID);\r\n    return isSingleNode || !isNullNode;\r\n  }\r\n\r\n  function getNext(Data storage self, uint _curr) public view returns (uint) {\r\n    return self.dll[_curr].next;\r\n  }\r\n\r\n  function getPrev(Data storage self, uint _curr) public view returns (uint) {\r\n    return self.dll[_curr].prev;\r\n  }\r\n\r\n  function getStart(Data storage self) public view returns (uint) {\r\n    return getNext(self, NULL_NODE_ID);\r\n  }\r\n\r\n  function getEnd(Data storage self) public view returns (uint) {\r\n    return getPrev(self, NULL_NODE_ID);\r\n  }\r\n\r\n  /**\r\n  @dev Inserts a new node between _prev and _next. When inserting a node already existing in\r\n  the list it will be automatically removed from the old position.\r\n  @param _prev the node which _new will be inserted after\r\n  @param _curr the id of the new node being inserted\r\n  @param _next the node which _new will be inserted before\r\n  */\r\n  function insert(Data storage self, uint _prev, uint _curr, uint _next) public {\r\n    require(_curr != NULL_NODE_ID);\r\n\r\n    remove(self, _curr);\r\n\r\n    require(_prev == NULL_NODE_ID || contains(self, _prev));\r\n    require(_next == NULL_NODE_ID || contains(self, _next));\r\n\r\n    require(getNext(self, _prev) == _next);\r\n    require(getPrev(self, _next) == _prev);\r\n\r\n    self.dll[_curr].prev = _prev;\r\n    self.dll[_curr].next = _next;\r\n\r\n    self.dll[_prev].next = _curr;\r\n    self.dll[_next].prev = _curr;\r\n  }\r\n\r\n  function remove(Data storage self, uint _curr) public {\r\n    if (!contains(self, _curr)) {\r\n      return;\r\n    }\r\n\r\n    uint next = getNext(self, _curr);\r\n    uint prev = getPrev(self, _curr);\r\n\r\n    self.dll[next].prev = prev;\r\n    self.dll[prev].next = next;\r\n\r\n    delete self.dll[_curr];\r\n  }\r\n}\r\n\r\n// File: contracts/installed_contracts/AttributeStore.sol\r\n\r\n/* solium-disable */\r\npragma solidity^0.4.11;\r\n\r\nlibrary AttributeStore {\r\n    struct Data {\r\n        mapping(bytes32 => uint) store;\r\n    }\r\n\r\n    function getAttribute(Data storage self, bytes32 _UUID, string _attrName)\r\n    public view returns (uint) {\r\n        bytes32 key = keccak256(_UUID, _attrName);\r\n        return self.store[key];\r\n    }\r\n\r\n    function setAttribute(Data storage self, bytes32 _UUID, string _attrName, uint _attrVal)\r\n    public {\r\n        bytes32 key = keccak256(_UUID, _attrName);\r\n        self.store[key] = _attrVal;\r\n    }\r\n}\r\n\r\n// File: contracts/zeppelin-solidity/token/ERC20/IERC20.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address who) external view returns (uint256);\r\n\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n\r\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: contracts/zeppelin-solidity/math/SafeMath.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\r\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (_a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    c = _a * _b;\r\n    assert(c / _a == _b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    // assert(_b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = _a / _b;\r\n    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\r\n    return _a / _b;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    assert(_b <= _a);\r\n    return _a - _b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\r\n    c = _a + _b;\r\n    assert(c >= _a);\r\n    return c;\r\n  }\r\n}\r\n\r\n// File: contracts/installed_contracts/PLCRVoting.sol\r\n\r\npragma solidity ^0.4.8;\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n@title Partial-Lock-Commit-Reveal Voting scheme with ERC20 tokens\r\n@author Team: Aspyn Palatnick, Cem Ozer, Yorke Rhodes\r\n*/\r\ncontract PLCRVoting {\r\n\r\n    // ============\r\n    // EVENTS:\r\n    // ============\r\n\r\n    event _VoteCommitted(uint indexed pollID, uint numTokens, address indexed voter);\r\n    event _VoteRevealed(uint indexed pollID, uint numTokens, uint votesFor, uint votesAgainst, uint indexed choice, address indexed voter, uint salt);\r\n    event _PollCreated(uint voteQuorum, uint commitEndDate, uint revealEndDate, uint indexed pollID, address indexed creator);\r\n    event _VotingRightsGranted(uint numTokens, address indexed voter);\r\n    event _VotingRightsWithdrawn(uint numTokens, address indexed voter);\r\n    event _TokensRescued(uint indexed pollID, address indexed voter);\r\n\r\n    // ============\r\n    // DATA STRUCTURES:\r\n    // ============\r\n\r\n    using AttributeStore for AttributeStore.Data;\r\n    using DLL for DLL.Data;\r\n    using SafeMath for uint;\r\n\r\n    struct Poll {\r\n        uint commitEndDate;     /// expiration date of commit period for poll\r\n        uint revealEndDate;     /// expiration date of reveal period for poll\r\n        uint voteQuorum;\t    /// number of votes required for a proposal to pass\r\n        uint votesFor;\t\t    /// tally of votes supporting proposal\r\n        uint votesAgainst;      /// tally of votes countering proposal\r\n        mapping(address => bool) didCommit;  /// indicates whether an address committed a vote for this poll\r\n        mapping(address => bool) didReveal;   /// indicates whether an address revealed a vote for this poll\r\n    }\r\n\r\n    // ============\r\n    // STATE VARIABLES:\r\n    // ============\r\n\r\n    uint constant public INITIAL_POLL_NONCE = 0;\r\n    uint public pollNonce;\r\n\r\n    mapping(uint => Poll) public pollMap; // maps pollID to Poll struct\r\n    mapping(address => uint) public voteTokenBalance; // maps user's address to voteToken balance\r\n\r\n    mapping(address => DLL.Data) dllMap;\r\n    AttributeStore.Data store;\r\n\r\n    IERC20 public token;\r\n\r\n    /**\r\n    @param _token The address where the ERC20 token contract is deployed\r\n    */\r\n    constructor(address _token) public {\r\n        require(_token != 0);\r\n\r\n        token = IERC20(_token);\r\n        pollNonce = INITIAL_POLL_NONCE;\r\n    }\r\n\r\n    // ================\r\n    // TOKEN INTERFACE:\r\n    // ================\r\n\r\n    /**\r\n    @notice Loads _numTokens ERC20 tokens into the voting contract for one-to-one voting rights\r\n    @dev Assumes that msg.sender has approved voting contract to spend on their behalf\r\n    @param _numTokens The number of votingTokens desired in exchange for ERC20 tokens\r\n    */\r\n    function requestVotingRights(uint _numTokens) public {\r\n        require(token.balanceOf(msg.sender) >= _numTokens);\r\n        voteTokenBalance[msg.sender] += _numTokens;\r\n        require(token.transferFrom(msg.sender, this, _numTokens));\r\n        emit _VotingRightsGranted(_numTokens, msg.sender);\r\n    }\r\n\r\n    /**\r\n    @notice Withdraw _numTokens ERC20 tokens from the voting contract, revoking these voting rights\r\n    @param _numTokens The number of ERC20 tokens desired in exchange for voting rights\r\n    */\r\n    function withdrawVotingRights(uint _numTokens) external {\r\n        uint availableTokens = voteTokenBalance[msg.sender].sub(getLockedTokens(msg.sender));\r\n        require(availableTokens >= _numTokens);\r\n        voteTokenBalance[msg.sender] -= _numTokens;\r\n        require(token.transfer(msg.sender, _numTokens));\r\n        emit _VotingRightsWithdrawn(_numTokens, msg.sender);\r\n    }\r\n\r\n    /**\r\n    @dev Unlocks tokens locked in unrevealed vote where poll has ended\r\n    @param _pollID Integer identifier associated with the target poll\r\n    */\r\n    function rescueTokens(uint _pollID) public {\r\n        require(isExpired(pollMap[_pollID].revealEndDate));\r\n        require(dllMap[msg.sender].contains(_pollID));\r\n\r\n        dllMap[msg.sender].remove(_pollID);\r\n        emit _TokensRescued(_pollID, msg.sender);\r\n    }\r\n\r\n    /**\r\n    @dev Unlocks tokens locked in unrevealed votes where polls have ended\r\n    @param _pollIDs Array of integer identifiers associated with the target polls\r\n    */\r\n    function rescueTokensInMultiplePolls(uint[] _pollIDs) public {\r\n        // loop through arrays, rescuing tokens from all\r\n        for (uint i = 0; i < _pollIDs.length; i++) {\r\n            rescueTokens(_pollIDs[i]);\r\n        }\r\n    }\r\n\r\n    // =================\r\n    // VOTING INTERFACE:\r\n    // =================\r\n\r\n    /**\r\n    @notice Commits vote using hash of choice and secret salt to conceal vote until reveal\r\n    @param _pollID Integer identifier associated with target poll\r\n    @param _secretHash Commit keccak256 hash of voter's choice and salt (tightly packed in this order)\r\n    @param _numTokens The number of tokens to be committed towards the target poll\r\n    @param _prevPollID The ID of the poll that the user has voted the maximum number of tokens in which is still less than or equal to numTokens\r\n    */\r\n    function commitVote(uint _pollID, bytes32 _secretHash, uint _numTokens, uint _prevPollID) public {\r\n        require(commitPeriodActive(_pollID));\r\n\r\n        // if msg.sender doesn't have enough voting rights,\r\n        // request for enough voting rights\r\n        if (voteTokenBalance[msg.sender] < _numTokens) {\r\n            uint remainder = _numTokens.sub(voteTokenBalance[msg.sender]);\r\n            requestVotingRights(remainder);\r\n        }\r\n\r\n        // make sure msg.sender has enough voting rights\r\n        require(voteTokenBalance[msg.sender] >= _numTokens);\r\n        // prevent user from committing to zero node placeholder\r\n        require(_pollID != 0);\r\n        // prevent user from committing a secretHash of 0\r\n        require(_secretHash != 0);\r\n\r\n        // Check if _prevPollID exists in the user's DLL or if _prevPollID is 0\r\n        require(_prevPollID == 0 || dllMap[msg.sender].contains(_prevPollID));\r\n\r\n        uint nextPollID = dllMap[msg.sender].getNext(_prevPollID);\r\n\r\n        // edge case: in-place update\r\n        if (nextPollID == _pollID) {\r\n            nextPollID = dllMap[msg.sender].getNext(_pollID);\r\n        }\r\n\r\n        require(validPosition(_prevPollID, nextPollID, msg.sender, _numTokens));\r\n        dllMap[msg.sender].insert(_prevPollID, _pollID, nextPollID);\r\n\r\n        bytes32 UUID = attrUUID(msg.sender, _pollID);\r\n\r\n        store.setAttribute(UUID, \"numTokens\", _numTokens);\r\n        store.setAttribute(UUID, \"commitHash\", uint(_secretHash));\r\n\r\n        pollMap[_pollID].didCommit[msg.sender] = true;\r\n        emit _VoteCommitted(_pollID, _numTokens, msg.sender);\r\n    }\r\n\r\n    /**\r\n    @notice                 Commits votes using hashes of choices and secret salts to conceal votes until reveal\r\n    @param _pollIDs         Array of integer identifiers associated with target polls\r\n    @param _secretHashes    Array of commit keccak256 hashes of voter's choices and salts (tightly packed in this order)\r\n    @param _numsTokens      Array of numbers of tokens to be committed towards the target polls\r\n    @param _prevPollIDs     Array of IDs of the polls that the user has voted the maximum number of tokens in which is still less than or equal to numTokens\r\n    */\r\n    function commitVotes(uint[] _pollIDs, bytes32[] _secretHashes, uint[] _numsTokens, uint[] _prevPollIDs) external {\r\n        // make sure the array lengths are all the same\r\n        require(_pollIDs.length == _secretHashes.length);\r\n        require(_pollIDs.length == _numsTokens.length);\r\n        require(_pollIDs.length == _prevPollIDs.length);\r\n\r\n        // loop through arrays, committing each individual vote values\r\n        for (uint i = 0; i < _pollIDs.length; i++) {\r\n            commitVote(_pollIDs[i], _secretHashes[i], _numsTokens[i], _prevPollIDs[i]);\r\n        }\r\n    }\r\n\r\n    /**\r\n    @dev Compares previous and next poll's committed tokens for sorting purposes\r\n    @param _prevID Integer identifier associated with previous poll in sorted order\r\n    @param _nextID Integer identifier associated with next poll in sorted order\r\n    @param _voter Address of user to check DLL position for\r\n    @param _numTokens The number of tokens to be committed towards the poll (used for sorting)\r\n    @return valid Boolean indication of if the specified position maintains the sort\r\n    */\r\n    function validPosition(uint _prevID, uint _nextID, address _voter, uint _numTokens) public constant returns (bool valid) {\r\n        bool prevValid = (_numTokens >= getNumTokens(_voter, _prevID));\r\n        // if next is zero node, _numTokens does not need to be greater\r\n        bool nextValid = (_numTokens <= getNumTokens(_voter, _nextID) || _nextID == 0);\r\n        return prevValid && nextValid;\r\n    }\r\n\r\n    /**\r\n    @notice Reveals vote with choice and secret salt used in generating commitHash to attribute committed tokens\r\n    @param _pollID Integer identifier associated with target poll\r\n    @param _voteOption Vote choice used to generate commitHash for associated poll\r\n    @param _salt Secret number used to generate commitHash for associated poll\r\n    */\r\n    function revealVote(uint _pollID, uint _voteOption, uint _salt) public {\r\n        // Make sure the reveal period is active\r\n        require(revealPeriodActive(_pollID));\r\n        require(pollMap[_pollID].didCommit[msg.sender]);                         // make sure user has committed a vote for this poll\r\n        require(!pollMap[_pollID].didReveal[msg.sender]);                        // prevent user from revealing multiple times\r\n        require(keccak256(_voteOption, _salt) == getCommitHash(msg.sender, _pollID)); // compare resultant hash from inputs to original commitHash\r\n\r\n        uint numTokens = getNumTokens(msg.sender, _pollID);\r\n\r\n        if (_voteOption == 1) {// apply numTokens to appropriate poll choice\r\n            pollMap[_pollID].votesFor += numTokens;\r\n        } else {\r\n            pollMap[_pollID].votesAgainst += numTokens;\r\n        }\r\n\r\n        dllMap[msg.sender].remove(_pollID); // remove the node referring to this vote upon reveal\r\n        pollMap[_pollID].didReveal[msg.sender] = true;\r\n\r\n        emit _VoteRevealed(_pollID, numTokens, pollMap[_pollID].votesFor, pollMap[_pollID].votesAgainst, _voteOption, msg.sender, _salt);\r\n    }\r\n\r\n    /**\r\n    @notice             Reveals multiple votes with choices and secret salts used in generating commitHashes to attribute committed tokens\r\n    @param _pollIDs     Array of integer identifiers associated with target polls\r\n    @param _voteOptions Array of vote choices used to generate commitHashes for associated polls\r\n    @param _salts       Array of secret numbers used to generate commitHashes for associated polls\r\n    */\r\n    function revealVotes(uint[] _pollIDs, uint[] _voteOptions, uint[] _salts) external {\r\n        // make sure the array lengths are all the same\r\n        require(_pollIDs.length == _voteOptions.length);\r\n        require(_pollIDs.length == _salts.length);\r\n\r\n        // loop through arrays, revealing each individual vote values\r\n        for (uint i = 0; i < _pollIDs.length; i++) {\r\n            revealVote(_pollIDs[i], _voteOptions[i], _salts[i]);\r\n        }\r\n    }\r\n\r\n    /**\r\n    @param _pollID Integer identifier associated with target poll\r\n    @param _salt Arbitrarily chosen integer used to generate secretHash\r\n    @return correctVotes Number of tokens voted for winning option\r\n    */\r\n    function getNumPassingTokens(address _voter, uint _pollID, uint _salt) public constant returns (uint correctVotes) {\r\n        require(pollEnded(_pollID));\r\n        require(pollMap[_pollID].didReveal[_voter]);\r\n\r\n        uint winningChoice = isPassed(_pollID) ? 1 : 0;\r\n        bytes32 winnerHash = keccak256(winningChoice, _salt);\r\n        bytes32 commitHash = getCommitHash(_voter, _pollID);\r\n\r\n        require(winnerHash == commitHash);\r\n\r\n        return getNumTokens(_voter, _pollID);\r\n    }\r\n\r\n    // ==================\r\n    // POLLING INTERFACE:\r\n    // ==================\r\n\r\n    /**\r\n    @dev Initiates a poll with canonical configured parameters at pollID emitted by PollCreated event\r\n    @param _voteQuorum Type of majority (out of 100) that is necessary for poll to be successful\r\n    @param _commitDuration Length of desired commit period in seconds\r\n    @param _revealDuration Length of desired reveal period in seconds\r\n    */\r\n    function startPoll(uint _voteQuorum, uint _commitDuration, uint _revealDuration) public returns (uint pollID) {\r\n        pollNonce = pollNonce + 1;\r\n\r\n        uint commitEndDate = block.timestamp.add(_commitDuration);\r\n        uint revealEndDate = commitEndDate.add(_revealDuration);\r\n\r\n        pollMap[pollNonce] = Poll({\r\n            voteQuorum: _voteQuorum,\r\n            commitEndDate: commitEndDate,\r\n            revealEndDate: revealEndDate,\r\n            votesFor: 0,\r\n            votesAgainst: 0\r\n        });\r\n\r\n        emit _PollCreated(_voteQuorum, commitEndDate, revealEndDate, pollNonce, msg.sender);\r\n        return pollNonce;\r\n    }\r\n\r\n    /**\r\n    @notice Determines if proposal has passed\r\n    @dev Check if votesFor out of totalVotes exceeds votesQuorum (requires pollEnded)\r\n    @param _pollID Integer identifier associated with target poll\r\n    */\r\n    function isPassed(uint _pollID) constant public returns (bool passed) {\r\n        require(pollEnded(_pollID));\r\n\r\n        Poll memory poll = pollMap[_pollID];\r\n        return (100 * poll.votesFor) > (poll.voteQuorum * (poll.votesFor + poll.votesAgainst));\r\n    }\r\n\r\n    // ----------------\r\n    // POLLING HELPERS:\r\n    // ----------------\r\n\r\n    /**\r\n    @dev Gets the total winning votes for reward distribution purposes\r\n    @param _pollID Integer identifier associated with target poll\r\n    @return Total number of votes committed to the winning option for specified poll\r\n    */\r\n    function getTotalNumberOfTokensForWinningOption(uint _pollID) constant public returns (uint numTokens) {\r\n        require(pollEnded(_pollID));\r\n\r\n        if (isPassed(_pollID))\r\n            return pollMap[_pollID].votesFor;\r\n        else\r\n            return pollMap[_pollID].votesAgainst;\r\n    }\r\n\r\n    /**\r\n    @notice Determines if poll is over\r\n    @dev Checks isExpired for specified poll's revealEndDate\r\n    @return Boolean indication of whether polling period is over\r\n    */\r\n    function pollEnded(uint _pollID) constant public returns (bool ended) {\r\n        require(pollExists(_pollID));\r\n\r\n        return isExpired(pollMap[_pollID].revealEndDate);\r\n    }\r\n\r\n    /**\r\n    @notice Checks if the commit period is still active for the specified poll\r\n    @dev Checks isExpired for the specified poll's commitEndDate\r\n    @param _pollID Integer identifier associated with target poll\r\n    @return Boolean indication of isCommitPeriodActive for target poll\r\n    */\r\n    function commitPeriodActive(uint _pollID) constant public returns (bool active) {\r\n        require(pollExists(_pollID));\r\n\r\n        return !isExpired(pollMap[_pollID].commitEndDate);\r\n    }\r\n\r\n    /**\r\n    @notice Checks if the reveal period is still active for the specified poll\r\n    @dev Checks isExpired for the specified poll's revealEndDate\r\n    @param _pollID Integer identifier associated with target poll\r\n    */\r\n    function revealPeriodActive(uint _pollID) constant public returns (bool active) {\r\n        require(pollExists(_pollID));\r\n\r\n        return !isExpired(pollMap[_pollID].revealEndDate) && !commitPeriodActive(_pollID);\r\n    }\r\n\r\n    /**\r\n    @dev Checks if user has committed for specified poll\r\n    @param _voter Address of user to check against\r\n    @param _pollID Integer identifier associated with target poll\r\n    @return Boolean indication of whether user has committed\r\n    */\r\n    function didCommit(address _voter, uint _pollID) constant public returns (bool committed) {\r\n        require(pollExists(_pollID));\r\n\r\n        return pollMap[_pollID].didCommit[_voter];\r\n    }\r\n\r\n    /**\r\n    @dev Checks if user has revealed for specified poll\r\n    @param _voter Address of user to check against\r\n    @param _pollID Integer identifier associated with target poll\r\n    @return Boolean indication of whether user has revealed\r\n    */\r\n    function didReveal(address _voter, uint _pollID) constant public returns (bool revealed) {\r\n        require(pollExists(_pollID));\r\n\r\n        return pollMap[_pollID].didReveal[_voter];\r\n    }\r\n\r\n    /**\r\n    @dev Checks if a poll exists\r\n    @param _pollID The pollID whose existance is to be evaluated.\r\n    @return Boolean Indicates whether a poll exists for the provided pollID\r\n    */\r\n    function pollExists(uint _pollID) constant public returns (bool exists) {\r\n        return (_pollID != 0 && _pollID <= pollNonce);\r\n    }\r\n\r\n    // ---------------------------\r\n    // DOUBLE-LINKED-LIST HELPERS:\r\n    // ---------------------------\r\n\r\n    /**\r\n    @dev Gets the bytes32 commitHash property of target poll\r\n    @param _voter Address of user to check against\r\n    @param _pollID Integer identifier associated with target poll\r\n    @return Bytes32 hash property attached to target poll\r\n    */\r\n    function getCommitHash(address _voter, uint _pollID) constant public returns (bytes32 commitHash) {\r\n        return bytes32(store.getAttribute(attrUUID(_voter, _pollID), \"commitHash\"));\r\n    }\r\n\r\n    /**\r\n    @dev Wrapper for getAttribute with attrName=\"numTokens\"\r\n    @param _voter Address of user to check against\r\n    @param _pollID Integer identifier associated with target poll\r\n    @return Number of tokens committed to poll in sorted poll-linked-list\r\n    */\r\n    function getNumTokens(address _voter, uint _pollID) constant public returns (uint numTokens) {\r\n        return store.getAttribute(attrUUID(_voter, _pollID), \"numTokens\");\r\n    }\r\n\r\n    /**\r\n    @dev Gets top element of sorted poll-linked-list\r\n    @param _voter Address of user to check against\r\n    @return Integer identifier to poll with maximum number of tokens committed to it\r\n    */\r\n    function getLastNode(address _voter) constant public returns (uint pollID) {\r\n        return dllMap[_voter].getPrev(0);\r\n    }\r\n\r\n    /**\r\n    @dev Gets the numTokens property of getLastNode\r\n    @param _voter Address of user to check against\r\n    @return Maximum number of tokens committed in poll specified\r\n    */\r\n    function getLockedTokens(address _voter) constant public returns (uint numTokens) {\r\n        return getNumTokens(_voter, getLastNode(_voter));\r\n    }\r\n\r\n    /*\r\n    @dev Takes the last node in the user's DLL and iterates backwards through the list searching\r\n    for a node with a value less than or equal to the provided _numTokens value. When such a node\r\n    is found, if the provided _pollID matches the found nodeID, this operation is an in-place\r\n    update. In that case, return the previous node of the node being updated. Otherwise return the\r\n    first node that was found with a value less than or equal to the provided _numTokens.\r\n    @param _voter The voter whose DLL will be searched\r\n    @param _numTokens The value for the numTokens attribute in the node to be inserted\r\n    @return the node which the propoded node should be inserted after\r\n    */\r\n    function getInsertPointForNumTokens(address _voter, uint _numTokens, uint _pollID)\r\n    constant public returns (uint prevNode) {\r\n      // Get the last node in the list and the number of tokens in that node\r\n      uint nodeID = getLastNode(_voter);\r\n      uint tokensInNode = getNumTokens(_voter, nodeID);\r\n\r\n      // Iterate backwards through the list until reaching the root node\r\n      while(nodeID != 0) {\r\n        // Get the number of tokens in the current node\r\n        tokensInNode = getNumTokens(_voter, nodeID);\r\n        if(tokensInNode <= _numTokens) { // We found the insert point!\r\n          if(nodeID == _pollID) {\r\n            // This is an in-place update. Return the prev node of the node being updated\r\n            nodeID = dllMap[_voter].getPrev(nodeID);\r\n          }\r\n          // Return the insert point\r\n          return nodeID;\r\n        }\r\n        // We did not find the insert point. Continue iterating backwards through the list\r\n        nodeID = dllMap[_voter].getPrev(nodeID);\r\n      }\r\n\r\n      // The list is empty, or a smaller value than anything else in the list is being inserted\r\n      return nodeID;\r\n    }\r\n\r\n    // ----------------\r\n    // GENERAL HELPERS:\r\n    // ----------------\r\n\r\n    /**\r\n    @dev Checks if an expiration date has been reached\r\n    @param _terminationDate Integer timestamp of date to compare current timestamp with\r\n    @return expired Boolean indication of whether the terminationDate has passed\r\n    */\r\n    function isExpired(uint _terminationDate) constant public returns (bool expired) {\r\n        return (block.timestamp > _terminationDate);\r\n    }\r\n\r\n    /**\r\n    @dev Generates an identifier which associates a user and a poll together\r\n    @param _pollID Integer identifier associated with target poll\r\n    @return UUID Hash which is deterministic from _user and _pollID\r\n    */\r\n    function attrUUID(address _user, uint _pollID) public pure returns (bytes32 UUID) {\r\n        return keccak256(_user, _pollID);\r\n    }\r\n}\r\n\r\n// File: contracts/proof-of-use/telemetry/TokenTelemetryI.sol\r\n\r\npragma solidity ^0.4.23;\r\n\r\ninterface TokenTelemetryI {\r\n  function onRequestVotingRights(address user, uint tokenAmount) external;\r\n}\r\n\r\n// File: contracts/tcr/CivilPLCRVoting.sol\r\n\r\npragma solidity ^0.4.23;\r\n\r\n\r\n\r\n/**\r\n@title Partial-Lock-Commit-Reveal Voting scheme with ERC20 tokens\r\n*/\r\ncontract CivilPLCRVoting is PLCRVoting {\r\n\r\n  TokenTelemetryI public telemetry;\r\n\r\n  /**\r\n  @dev Initializer. Can only be called once.\r\n  @param tokenAddr The address where the ERC20 token contract is deployed\r\n  @param telemetryAddr The address where the TokenTelemetry contract is deployed\r\n  */\r\n  constructor(address tokenAddr, address telemetryAddr) public PLCRVoting(tokenAddr) {\r\n    require(telemetryAddr != 0);\r\n    telemetry = TokenTelemetryI(telemetryAddr);\r\n  }\r\n\r\n  /**\r\n    @notice Loads _numTokens ERC20 tokens into the voting contract for one-to-one voting rights\r\n    @dev Assumes that msg.sender has approved voting contract to spend on their behalf\r\n    @param _numTokens The number of votingTokens desired in exchange for ERC20 tokens\r\n    @dev Differs from base implementation in that it records use of token in mapping for \"proof of use\"\r\n  */\r\n  function requestVotingRights(uint _numTokens) public {\r\n    super.requestVotingRights(_numTokens);\r\n    telemetry.onRequestVotingRights(msg.sender, voteTokenBalance[msg.sender]);\r\n  }\r\n\r\n  /**\r\n  @param _pollID Integer identifier associated with target poll\r\n  @param _salt Arbitrarily chosen integer used to generate secretHash\r\n  @return correctVotes Number of tokens voted for losing option\r\n  */\r\n  function getNumLosingTokens(address _voter, uint _pollID, uint _salt) public view returns (uint correctVotes) {\r\n    require(pollEnded(_pollID));\r\n    require(pollMap[_pollID].didReveal[_voter]);\r\n\r\n    uint losingChoice = isPassed(_pollID) ? 0 : 1;\r\n    bytes32 loserHash = keccak256(losingChoice, _salt);\r\n    bytes32 commitHash = getCommitHash(_voter, _pollID);\r\n\r\n    require(loserHash == commitHash);\r\n\r\n    return getNumTokens(_voter, _pollID);\r\n  }\r\n\r\n  /**\r\n  @dev Gets the total losing votes for reward distribution purposes\r\n  @param _pollID Integer identifier associated with target poll\r\n  @return Total number of votes committed to the losing option for specified poll\r\n  */\r\n  function getTotalNumberOfTokensForLosingOption(uint _pollID) public view returns (uint numTokens) {\r\n    require(pollEnded(_pollID));\r\n\r\n    if (isPassed(_pollID))\r\n      return pollMap[_pollID].votesAgainst;\r\n    else\r\n      return pollMap[_pollID].votesFor;\r\n  }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"_pollID\",\"type\":\"uint256\"}],\"name\":\"getTotalNumberOfTokensForWinningOption\",\"outputs\":[{\"name\":\"numTokens\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"INITIAL_POLL_NONCE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_voter\",\"type\":\"address\"},{\"name\":\"_numTokens\",\"type\":\"uint256\"},{\"name\":\"_pollID\",\"type\":\"uint256\"}],\"name\":\"getInsertPointForNumTokens\",\"outputs\":[{\"name\":\"prevNode\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_voteQuorum\",\"type\":\"uint256\"},{\"name\":\"_commitDuration\",\"type\":\"uint256\"},{\"name\":\"_revealDuration\",\"type\":\"uint256\"}],\"name\":\"startPoll\",\"outputs\":[{\"name\":\"pollID\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"voteTokenBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_pollIDs\",\"type\":\"uint256[]\"},{\"name\":\"_secretHashes\",\"type\":\"bytes32[]\"},{\"name\":\"_numsTokens\",\"type\":\"uint256[]\"},{\"name\":\"_prevPollIDs\",\"type\":\"uint256[]\"}],\"name\":\"commitVotes\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"telemetry\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_voter\",\"type\":\"address\"}],\"name\":\"getLastNode\",\"outputs\":[{\"name\":\"pollID\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_pollID\",\"type\":\"uint256\"}],\"name\":\"revealPeriodActive\",\"outputs\":[{\"name\":\"active\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_pollID\",\"type\":\"uint256\"}],\"name\":\"isPassed\",\"outputs\":[{\"name\":\"passed\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"pollMap\",\"outputs\":[{\"name\":\"commitEndDate\",\"type\":\"uint256\"},{\"name\":\"revealEndDate\",\"type\":\"uint256\"},{\"name\":\"voteQuorum\",\"type\":\"uint256\"},{\"name\":\"votesFor\",\"type\":\"uint256\"},{\"name\":\"votesAgainst\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_voter\",\"type\":\"address\"},{\"name\":\"_pollID\",\"type\":\"uint256\"},{\"name\":\"_salt\",\"type\":\"uint256\"}],\"name\":\"getNumLosingTokens\",\"outputs\":[{\"name\":\"correctVotes\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_voter\",\"type\":\"address\"}],\"name\":\"getLockedTokens\",\"outputs\":[{\"name\":\"numTokens\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_pollID\",\"type\":\"uint256\"},{\"name\":\"_secretHash\",\"type\":\"bytes32\"},{\"name\":\"_numTokens\",\"type\":\"uint256\"},{\"name\":\"_prevPollID\",\"type\":\"uint256\"}],\"name\":\"commitVote\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_voter\",\"type\":\"address\"},{\"name\":\"_pollID\",\"type\":\"uint256\"}],\"name\":\"didCommit\",\"outputs\":[{\"name\":\"committed\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_pollIDs\",\"type\":\"uint256[]\"},{\"name\":\"_voteOptions\",\"type\":\"uint256[]\"},{\"name\":\"_salts\",\"type\":\"uint256[]\"}],\"name\":\"revealVotes\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_prevID\",\"type\":\"uint256\"},{\"name\":\"_nextID\",\"type\":\"uint256\"},{\"name\":\"_voter\",\"type\":\"address\"},{\"name\":\"_numTokens\",\"type\":\"uint256\"}],\"name\":\"validPosition\",\"outputs\":[{\"name\":\"valid\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_pollID\",\"type\":\"uint256\"}],\"name\":\"pollExists\",\"outputs\":[{\"name\":\"exists\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pollNonce\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_pollID\",\"type\":\"uint256\"}],\"name\":\"rescueTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_user\",\"type\":\"address\"},{\"name\":\"_pollID\",\"type\":\"uint256\"}],\"name\":\"attrUUID\",\"outputs\":[{\"name\":\"UUID\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_numTokens\",\"type\":\"uint256\"}],\"name\":\"requestVotingRights\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_pollID\",\"type\":\"uint256\"}],\"name\":\"commitPeriodActive\",\"outputs\":[{\"name\":\"active\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_voter\",\"type\":\"address\"},{\"name\":\"_pollID\",\"type\":\"uint256\"}],\"name\":\"didReveal\",\"outputs\":[{\"name\":\"revealed\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_pollID\",\"type\":\"uint256\"},{\"name\":\"_voteOption\",\"type\":\"uint256\"},{\"name\":\"_salt\",\"type\":\"uint256\"}],\"name\":\"revealVote\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_voter\",\"type\":\"address\"},{\"name\":\"_pollID\",\"type\":\"uint256\"},{\"name\":\"_salt\",\"type\":\"uint256\"}],\"name\":\"getNumPassingTokens\",\"outputs\":[{\"name\":\"correctVotes\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_pollIDs\",\"type\":\"uint256[]\"}],\"name\":\"rescueTokensInMultiplePolls\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_voter\",\"type\":\"address\"},{\"name\":\"_pollID\",\"type\":\"uint256\"}],\"name\":\"getNumTokens\",\"outputs\":[{\"name\":\"numTokens\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_voter\",\"type\":\"address\"},{\"name\":\"_pollID\",\"type\":\"uint256\"}],\"name\":\"getCommitHash\",\"outputs\":[{\"name\":\"commitHash\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_terminationDate\",\"type\":\"uint256\"}],\"name\":\"isExpired\",\"outputs\":[{\"name\":\"expired\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_numTokens\",\"type\":\"uint256\"}],\"name\":\"withdrawVotingRights\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_pollID\",\"type\":\"uint256\"}],\"name\":\"getTotalNumberOfTokensForLosingOption\",\"outputs\":[{\"name\":\"numTokens\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_pollID\",\"type\":\"uint256\"}],\"name\":\"pollEnded\",\"outputs\":[{\"name\":\"ended\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"tokenAddr\",\"type\":\"address\"},{\"name\":\"telemetryAddr\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"pollID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"numTokens\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"voter\",\"type\":\"address\"}],\"name\":\"_VoteCommitted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"pollID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"numTokens\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"votesFor\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"votesAgainst\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"choice\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"voter\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"salt\",\"type\":\"uint256\"}],\"name\":\"_VoteRevealed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"voteQuorum\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"commitEndDate\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"revealEndDate\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"pollID\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"creator\",\"type\":\"address\"}],\"name\":\"_PollCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"numTokens\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"voter\",\"type\":\"address\"}],\"name\":\"_VotingRightsGranted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"numTokens\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"voter\",\"type\":\"address\"}],\"name\":\"_VotingRightsWithdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"pollID\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"voter\",\"type\":\"address\"}],\"name\":\"_TokensRescued\",\"type\":\"event\"}]","ContractName":"CivilPLCRVoting","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000001fa555c97d7958fa6f771f3bbd5ccd508f81e220000000000000000000000006d3dc15e04dd1d8968556d02cf209a4fb4ab8736","Library":"DLL:739f1745e415782861373c5ff1a6dc56d2d41451;AttributeStore:393e69e7ae7addcfd744b71d209b1f04800d89e5","SwarmSource":"bzzr://dfb0bd5ea70ad6f1df929d57bad9a8a3a61facd419e162e3168c26c446d29926"}]}