{"status":"1","message":"OK","result":[{"SourceCode":"// Verified using https://dapp.tools\n\n// hevm: flattened sources of src/EqualizerProxy.sol\npragma solidity ^0.4.24;\n\n////// lib/ds-math/src/math.sol\n/// math.sol -- mixin for inline numerical wizardry\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n/* pragma solidity >0.4.13; */\n\ncontract DSMath {\n    function add(uint x, uint y) internal pure returns (uint z) {\n        require((z = x + y) >= x, \"ds-math-add-overflow\");\n    }\n    function sub(uint x, uint y) internal pure returns (uint z) {\n        require((z = x - y) <= x, \"ds-math-sub-underflow\");\n    }\n    function mul(uint x, uint y) internal pure returns (uint z) {\n        require(y == 0 || (z = x * y) / y == x, \"ds-math-mul-overflow\");\n    }\n\n    function min(uint x, uint y) internal pure returns (uint z) {\n        return x <= y ? x : y;\n    }\n    function max(uint x, uint y) internal pure returns (uint z) {\n        return x >= y ? x : y;\n    }\n    function imin(int x, int y) internal pure returns (int z) {\n        return x <= y ? x : y;\n    }\n    function imax(int x, int y) internal pure returns (int z) {\n        return x >= y ? x : y;\n    }\n\n    uint constant WAD = 10 ** 18;\n    uint constant RAY = 10 ** 27;\n\n    function wmul(uint x, uint y) internal pure returns (uint z) {\n        z = add(mul(x, y), WAD / 2) / WAD;\n    }\n    function rmul(uint x, uint y) internal pure returns (uint z) {\n        z = add(mul(x, y), RAY / 2) / RAY;\n    }\n    function wdiv(uint x, uint y) internal pure returns (uint z) {\n        z = add(mul(x, WAD), y / 2) / y;\n    }\n    function rdiv(uint x, uint y) internal pure returns (uint z) {\n        z = add(mul(x, RAY), y / 2) / y;\n    }\n\n    // This famous algorithm is called \"exponentiation by squaring\"\n    // and calculates x^n with x as fixed-point and n as regular unsigned.\n    //\n    // It's O(log n), instead of O(n) for naive repeated multiplication.\n    //\n    // These facts are why it works:\n    //\n    //  If n is even, then x^n = (x^2)^(n/2).\n    //  If n is odd,  then x^n = x * x^(n-1),\n    //   and applying the equation for even x gives\n    //    x^n = x * (x^2)^((n-1) / 2).\n    //\n    //  Also, EVM division is flooring and\n    //    floor[(n-1) / 2] = floor[n / 2].\n    //\n    function rpow(uint x, uint n) internal pure returns (uint z) {\n        z = n % 2 != 0 ? x : RAY;\n\n        for (n /= 2; n != 0; n /= 2) {\n            x = rmul(x, x);\n\n            if (n % 2 != 0) {\n                z = rmul(z, x);\n            }\n        }\n    }\n}\n\n////// src/EqualizerProxy.sol\n/* pragma solidity ^0.4.24; */\n\n/* import \"ds-math/math.sol\"; */\n\ncontract TubInterface {\n  function open() public returns (bytes32);\n  function join(uint) public;\n  function exit(uint) public;\n  function lock(bytes32, uint) public;\n  function free(bytes32, uint) public;\n  function draw(bytes32, uint) public;\n  function wipe(bytes32, uint) public;\n  function give(bytes32, address) public;\n  function shut(bytes32) public;\n  function bite(bytes32) public;\n  function cups(bytes32) public returns (address, uint, uint, uint);\n  function gem() public returns (TokenInterface);\n  function gov() public returns (TokenInterface);\n  function skr() public returns (TokenInterface);\n  function sai() public returns (TokenInterface);\n  function vox() public returns (VoxInterface);\n  function ask(uint) public returns (uint);\n  function mat() public returns (uint);\n  function chi() public returns (uint);\n  function ink(bytes32) public returns (uint);\n  function tab(bytes32) public returns (uint);\n  function rap(bytes32) public returns (uint);\n  function per() public returns (uint);\n  function pip() public returns (PipInterface);\n  function pep() public returns (PepInterface);\n  function tag() public returns (uint);\n  function drip() public;\n}\n\ncontract TapInterface {\n  function skr() public returns (TokenInterface);\n  function sai() public returns (TokenInterface);\n  function tub() public returns (TubInterface);\n  function bust(uint) public;\n  function boom(uint) public;\n  function cash(uint) public;\n  function mock(uint) public;\n  function heal() public;\n}\n\ncontract TokenInterface {\n  function allowance(address, address) public returns (uint);\n  function balanceOf(address) public returns (uint);\n  function approve(address, uint) public;\n  function transfer(address, uint) public returns (bool);\n  function transferFrom(address, address, uint) public returns (bool);\n  function deposit() public payable;\n  function withdraw(uint) public;\n}\n\ncontract VoxInterface {\n  function par() public returns (uint);\n}\n\ncontract PipInterface {\n  function read() public returns (bytes32);\n}\n\ncontract PepInterface {\n  function peek() public returns (bytes32, bool);\n}\n\ncontract OtcInterface {\n  function sellAllAmount(address, uint, address, uint) public returns (uint);\n  function buyAllAmount(address, uint, address, uint) public returns (uint);\n  function getPayAmount(address, address, uint) public constant returns (uint);\n}\n\ncontract EqualizerProxy is DSMath {\n\n  function drawSellLock(TubInterface tub, OtcInterface otc, bytes32 cup, TokenInterface sai, uint drawAmt, TokenInterface weth, uint minLockAmt) public {\n    // Borrow some SAI tokens\n    tub.draw(cup, drawAmt);\n\n    // Sell SAI tokens for WETH tokens\n    if (sai.allowance(this, otc) < drawAmt) {\n      sai.approve(otc, uint(-1));\n    }\n    uint buyAmt = otc.sellAllAmount(sai, drawAmt, weth, minLockAmt);\n    require(buyAmt >= minLockAmt);\n\n    // Convert WETH to PETH\n    uint ink = rdiv(buyAmt, tub.per());\n    if (tub.gem().allowance(this, tub) != uint(-1)) {\n      tub.gem().approve(tub, uint(-1));\n    }\n    tub.join(ink);\n\n    // LOCK PETH\n    if (tub.skr().allowance(this, tub) != uint(-1)) {\n      tub.skr().approve(tub, uint(-1));\n    }\n    tub.lock(cup, ink);\n  }\n\n  function freeSellWipe(TubInterface tub, OtcInterface otc, bytes32 cup, TokenInterface sai, uint freeAmt, TokenInterface weth, uint minWipeAmt) public {\n    if (freeAmt > 0) {\n      // Free some PETH tokens\n      uint ink = rdiv(freeAmt, tub.per());\n      tub.free(cup, ink);\n      if (tub.skr().allowance(this, tub) != uint(-1)) {\n        tub.skr().approve(tub, uint(-1));\n      }\n\n      // Convert PETH to WETH\n      tub.exit(ink);\n\n      // Sell WETH tokens for SAI tokens\n      if (weth.allowance(this, otc) < freeAmt) {\n        weth.approve(otc, uint(-1));\n      }\n      uint wipeAmt = otc.sellAllAmount(weth, freeAmt, sai, minWipeAmt);\n      require(wipeAmt >= minWipeAmt);\n\n      // Wipe SAI\n      if (tub.sai().allowance(this, tub) != uint(-1)) {\n        tub.sai().approve(tub, uint(-1));\n      }\n      if (tub.gov().allowance(this, tub) != uint(-1)) {\n        tub.gov().approve(tub, uint(-1));\n      }\n      tub.wipe(cup, wipeAmt);\n    }\n  }\n\n}\n","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"tub\",\"type\":\"address\"},{\"name\":\"otc\",\"type\":\"address\"},{\"name\":\"cup\",\"type\":\"bytes32\"},{\"name\":\"sai\",\"type\":\"address\"},{\"name\":\"freeAmt\",\"type\":\"uint256\"},{\"name\":\"weth\",\"type\":\"address\"},{\"name\":\"minWipeAmt\",\"type\":\"uint256\"}],\"name\":\"freeSellWipe\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tub\",\"type\":\"address\"},{\"name\":\"otc\",\"type\":\"address\"},{\"name\":\"cup\",\"type\":\"bytes32\"},{\"name\":\"sai\",\"type\":\"address\"},{\"name\":\"drawAmt\",\"type\":\"uint256\"},{\"name\":\"weth\",\"type\":\"address\"},{\"name\":\"minLockAmt\",\"type\":\"uint256\"}],\"name\":\"drawSellLock\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"EqualizerProxy","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://896c4ca995d45bc8aa6993a8320191e7f2c6cc12a0496c22088a236a69862163"}]}