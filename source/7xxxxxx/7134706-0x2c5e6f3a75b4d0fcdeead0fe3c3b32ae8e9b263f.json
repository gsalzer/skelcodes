{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\n// File: contracts/token/interfaces/IERC20Token.sol\r\n\r\n/*\r\n    ERC20 Standard Token interface\r\n*/\r\ncontract IERC20Token {\r\n    // these functions aren't abstract since the compiler emits automatically generated getter functions as external\r\n    function name() public view returns (string) {}\r\n    function symbol() public view returns (string) {}\r\n    function decimals() public view returns (uint8) {}\r\n    function totalSupply() public view returns (uint256) {}\r\n    function balanceOf(address _owner) public view returns (uint256) { _owner; }\r\n    function allowance(address _owner, address _spender) public view returns (uint256) { _owner; _spender; }\r\n\r\n    function transfer(address _to, uint256 _value) public returns (bool success);\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\r\n    function approve(address _spender, uint256 _value) public returns (bool success);\r\n}\r\n\r\n// File: contracts/IBancorNetwork.sol\r\n\r\n/*\r\n    Bancor Network interface\r\n*/\r\ncontract IBancorNetwork {\r\n    function convert(IERC20Token[] _path, uint256 _amount, uint256 _minReturn) public payable returns (uint256);\r\n    function convertFor(IERC20Token[] _path, uint256 _amount, uint256 _minReturn, address _for) public payable returns (uint256);\r\n    \r\n    function convertForPrioritized3(\r\n        IERC20Token[] _path,\r\n        uint256 _amount,\r\n        uint256 _minReturn,\r\n        address _for,\r\n        uint256 _customVal,\r\n        uint256 _block,\r\n        uint8 _v,\r\n        bytes32 _r,\r\n        bytes32 _s\r\n    ) public payable returns (uint256);\r\n    \r\n    // deprecated, backward compatibility\r\n    function convertForPrioritized2(\r\n        IERC20Token[] _path,\r\n        uint256 _amount,\r\n        uint256 _minReturn,\r\n        address _for,\r\n        uint256 _block,\r\n        uint8 _v,\r\n        bytes32 _r,\r\n        bytes32 _s\r\n    ) public payable returns (uint256);\r\n\r\n    // deprecated, backward compatibility\r\n    function convertForPrioritized(\r\n        IERC20Token[] _path,\r\n        uint256 _amount,\r\n        uint256 _minReturn,\r\n        address _for,\r\n        uint256 _block,\r\n        uint256 _nonce,\r\n        uint8 _v,\r\n        bytes32 _r,\r\n        bytes32 _s\r\n    ) public payable returns (uint256);\r\n}\r\n\r\n// File: contracts/ContractIds.sol\r\n\r\n/**\r\n    Id definitions for bancor contracts\r\n\r\n    Can be used in conjunction with the contract registry to get contract addresses\r\n*/\r\ncontract ContractIds {\r\n    // generic\r\n    bytes32 public constant CONTRACT_FEATURES = \"ContractFeatures\";\r\n    bytes32 public constant CONTRACT_REGISTRY = \"ContractRegistry\";\r\n\r\n    // bancor logic\r\n    bytes32 public constant BANCOR_NETWORK = \"BancorNetwork\";\r\n    bytes32 public constant BANCOR_FORMULA = \"BancorFormula\";\r\n    bytes32 public constant BANCOR_GAS_PRICE_LIMIT = \"BancorGasPriceLimit\";\r\n    bytes32 public constant BANCOR_CONVERTER_UPGRADER = \"BancorConverterUpgrader\";\r\n    bytes32 public constant BANCOR_CONVERTER_FACTORY = \"BancorConverterFactory\";\r\n\r\n    // BNT core\r\n    bytes32 public constant BNT_TOKEN = \"BNTToken\";\r\n    bytes32 public constant BNT_CONVERTER = \"BNTConverter\";\r\n\r\n    // BancorX\r\n    bytes32 public constant BANCOR_X = \"BancorX\";\r\n    bytes32 public constant BANCOR_X_UPGRADER = \"BancorXUpgrader\";\r\n}\r\n\r\n// File: contracts/FeatureIds.sol\r\n\r\n/**\r\n    Id definitions for bancor contract features\r\n\r\n    Can be used to query the ContractFeatures contract to check whether a certain feature is supported by a contract\r\n*/\r\ncontract FeatureIds {\r\n    // converter features\r\n    uint256 public constant CONVERTER_CONVERSION_WHITELIST = 1 << 0;\r\n}\r\n\r\n// File: contracts/utility/interfaces/IWhitelist.sol\r\n\r\n/*\r\n    Whitelist interface\r\n*/\r\ncontract IWhitelist {\r\n    function isWhitelisted(address _address) public view returns (bool);\r\n}\r\n\r\n// File: contracts/converter/interfaces/IBancorConverter.sol\r\n\r\n/*\r\n    Bancor Converter interface\r\n*/\r\ncontract IBancorConverter {\r\n    function getReturn(IERC20Token _fromToken, IERC20Token _toToken, uint256 _amount) public view returns (uint256, uint256);\r\n    function convert(IERC20Token _fromToken, IERC20Token _toToken, uint256 _amount, uint256 _minReturn) public returns (uint256);\r\n    function conversionWhitelist() public view returns (IWhitelist) {}\r\n    function conversionFee() public view returns (uint32) {}\r\n    function connectors(address _address) public view returns (uint256, uint32, bool, bool, bool) { _address; }\r\n    function getConnectorBalance(IERC20Token _connectorToken) public view returns (uint256);\r\n    function claimTokens(address _from, uint256 _amount) public;\r\n    // deprecated, backward compatibility\r\n    function change(IERC20Token _fromToken, IERC20Token _toToken, uint256 _amount, uint256 _minReturn) public returns (uint256);\r\n}\r\n\r\n// File: contracts/converter/interfaces/IBancorFormula.sol\r\n\r\n/*\r\n    Bancor Formula interface\r\n*/\r\ncontract IBancorFormula {\r\n    function calculatePurchaseReturn(uint256 _supply, uint256 _connectorBalance, uint32 _connectorWeight, uint256 _depositAmount) public view returns (uint256);\r\n    function calculateSaleReturn(uint256 _supply, uint256 _connectorBalance, uint32 _connectorWeight, uint256 _sellAmount) public view returns (uint256);\r\n    function calculateCrossConnectorReturn(uint256 _fromConnectorBalance, uint32 _fromConnectorWeight, uint256 _toConnectorBalance, uint32 _toConnectorWeight, uint256 _amount) public view returns (uint256);\r\n}\r\n\r\n// File: contracts/converter/interfaces/IBancorGasPriceLimit.sol\r\n\r\n/*\r\n    Bancor Gas Price Limit interface\r\n*/\r\ncontract IBancorGasPriceLimit {\r\n    function gasPrice() public view returns (uint256) {}\r\n    function validateGasPrice(uint256) public view;\r\n}\r\n\r\n// File: contracts/utility/interfaces/IOwned.sol\r\n\r\n/*\r\n    Owned contract interface\r\n*/\r\ncontract IOwned {\r\n    // this function isn't abstract since the compiler emits automatically generated getter functions as external\r\n    function owner() public view returns (address) {}\r\n\r\n    function transferOwnership(address _newOwner) public;\r\n    function acceptOwnership() public;\r\n}\r\n\r\n// File: contracts/utility/Owned.sol\r\n\r\n/*\r\n    Provides support and utilities for contract ownership\r\n*/\r\ncontract Owned is IOwned {\r\n    address public owner;\r\n    address public newOwner;\r\n\r\n    event OwnerUpdate(address indexed _prevOwner, address indexed _newOwner);\r\n\r\n    /**\r\n        @dev constructor\r\n    */\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    // allows execution by the owner only\r\n    modifier ownerOnly {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    /**\r\n        @dev allows transferring the contract ownership\r\n        the new owner still needs to accept the transfer\r\n        can only be called by the contract owner\r\n\r\n        @param _newOwner    new contract owner\r\n    */\r\n    function transferOwnership(address _newOwner) public ownerOnly {\r\n        require(_newOwner != owner);\r\n        newOwner = _newOwner;\r\n    }\r\n\r\n    /**\r\n        @dev used by a new owner to accept an ownership transfer\r\n    */\r\n    function acceptOwnership() public {\r\n        require(msg.sender == newOwner);\r\n        emit OwnerUpdate(owner, newOwner);\r\n        owner = newOwner;\r\n        newOwner = address(0);\r\n    }\r\n}\r\n\r\n// File: contracts/utility/Utils.sol\r\n\r\n/*\r\n    Utilities & Common Modifiers\r\n*/\r\ncontract Utils {\r\n    /**\r\n        constructor\r\n    */\r\n    constructor() public {\r\n    }\r\n\r\n    // verifies that an amount is greater than zero\r\n    modifier greaterThanZero(uint256 _amount) {\r\n        require(_amount > 0);\r\n        _;\r\n    }\r\n\r\n    // validates an address - currently only checks that it isn't null\r\n    modifier validAddress(address _address) {\r\n        require(_address != address(0));\r\n        _;\r\n    }\r\n\r\n    // verifies that the address is different than this contract address\r\n    modifier notThis(address _address) {\r\n        require(_address != address(this));\r\n        _;\r\n    }\r\n\r\n}\r\n\r\n// File: contracts/utility/interfaces/ITokenHolder.sol\r\n\r\n/*\r\n    Token Holder interface\r\n*/\r\ncontract ITokenHolder is IOwned {\r\n    function withdrawTokens(IERC20Token _token, address _to, uint256 _amount) public;\r\n}\r\n\r\n// File: contracts/utility/TokenHolder.sol\r\n\r\n/*\r\n    We consider every contract to be a 'token holder' since it's currently not possible\r\n    for a contract to deny receiving tokens.\r\n\r\n    The TokenHolder's contract sole purpose is to provide a safety mechanism that allows\r\n    the owner to send tokens that were sent to the contract by mistake back to their sender.\r\n*/\r\ncontract TokenHolder is ITokenHolder, Owned, Utils {\r\n    /**\r\n        @dev constructor\r\n    */\r\n    constructor() public {\r\n    }\r\n\r\n    /**\r\n        @dev withdraws tokens held by the contract and sends them to an account\r\n        can only be called by the owner\r\n\r\n        @param _token   ERC20 token contract address\r\n        @param _to      account to receive the new amount\r\n        @param _amount  amount to withdraw\r\n    */\r\n    function withdrawTokens(IERC20Token _token, address _to, uint256 _amount)\r\n        public\r\n        ownerOnly\r\n        validAddress(_token)\r\n        validAddress(_to)\r\n        notThis(_to)\r\n    {\r\n        assert(_token.transfer(_to, _amount));\r\n    }\r\n}\r\n\r\n// File: contracts/utility/SafeMath.sol\r\n\r\n/*\r\n    Library for basic math operations with overflow/underflow protection\r\n*/\r\nlibrary SafeMath {\r\n    /**\r\n        @dev returns the sum of _x and _y, reverts if the calculation overflows\r\n\r\n        @param _x   value 1\r\n        @param _y   value 2\r\n\r\n        @return sum\r\n    */\r\n    function add(uint256 _x, uint256 _y) internal pure returns (uint256) {\r\n        uint256 z = _x + _y;\r\n        require(z >= _x);\r\n        return z;\r\n    }\r\n\r\n    /**\r\n        @dev returns the difference of _x minus _y, reverts if the calculation underflows\r\n\r\n        @param _x   minuend\r\n        @param _y   subtrahend\r\n\r\n        @return difference\r\n    */\r\n    function sub(uint256 _x, uint256 _y) internal pure returns (uint256) {\r\n        require(_x >= _y);\r\n        return _x - _y;\r\n    }\r\n\r\n    /**\r\n        @dev returns the product of multiplying _x by _y, reverts if the calculation overflows\r\n\r\n        @param _x   factor 1\r\n        @param _y   factor 2\r\n\r\n        @return product\r\n    */\r\n    function mul(uint256 _x, uint256 _y) internal pure returns (uint256) {\r\n        // gas optimization\r\n        if (_x == 0)\r\n            return 0;\r\n\r\n        uint256 z = _x * _y;\r\n        require(z / _x == _y);\r\n        return z;\r\n    }\r\n\r\n      /**\r\n        @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\r\n\r\n        @param _x   dividend\r\n        @param _y   divisor\r\n\r\n        @return quotient\r\n    */\r\n    function div(uint256 _x, uint256 _y) internal pure returns (uint256) {\r\n        require(_y > 0);\r\n        uint256 c = _x / _y;\r\n\r\n        return c;\r\n    }\r\n}\r\n\r\n// File: contracts/utility/interfaces/IContractRegistry.sol\r\n\r\n/*\r\n    Contract Registry interface\r\n*/\r\ncontract IContractRegistry {\r\n    function addressOf(bytes32 _contractName) public view returns (address);\r\n\r\n    // deprecated, backward compatibility\r\n    function getAddress(bytes32 _contractName) public view returns (address);\r\n}\r\n\r\n// File: contracts/utility/interfaces/IContractFeatures.sol\r\n\r\n/*\r\n    Contract Features interface\r\n*/\r\ncontract IContractFeatures {\r\n    function isSupported(address _contract, uint256 _features) public view returns (bool);\r\n    function enableFeatures(uint256 _features, bool _enable) public;\r\n}\r\n\r\n// File: contracts/token/interfaces/IEtherToken.sol\r\n\r\n/*\r\n    Ether Token interface\r\n*/\r\ncontract IEtherToken is ITokenHolder, IERC20Token {\r\n    function deposit() public payable;\r\n    function withdraw(uint256 _amount) public;\r\n    function withdrawTo(address _to, uint256 _amount) public;\r\n}\r\n\r\n// File: contracts/token/interfaces/ISmartToken.sol\r\n\r\n/*\r\n    Smart Token interface\r\n*/\r\ncontract ISmartToken is IOwned, IERC20Token {\r\n    function disableTransfers(bool _disable) public;\r\n    function issue(address _to, uint256 _amount) public;\r\n    function destroy(address _from, uint256 _amount) public;\r\n}\r\n\r\n// File: contracts/bancorx/interfaces/IBancorX.sol\r\n\r\ncontract IBancorX {\r\n    function xTransfer(bytes32 _toBlockchain, bytes32 _to, uint256 _amount, uint256 _id) public;\r\n    function getXTransferAmount(uint256 _xTransferId, address _for) public view returns (uint256);\r\n}\r\n\r\n// File: contracts/BancorNetwork.sol\r\n\r\n/*\r\n    The BancorNetwork contract is the main entry point for bancor token conversions.\r\n    It also allows converting between any token in the bancor network to any other token\r\n    in a single transaction by providing a conversion path.\r\n\r\n    A note on conversion path -\r\n    Conversion path is a data structure that's used when converting a token to another token in the bancor network\r\n    when the conversion cannot necessarily be done by single converter and might require multiple 'hops'.\r\n    The path defines which converters should be used and what kind of conversion should be done in each step.\r\n\r\n    The path format doesn't include complex structure and instead, it is represented by a single array\r\n    in which each 'hop' is represented by a 2-tuple - smart token & to token.\r\n    In addition, the first element is always the source token.\r\n    The smart token is only used as a pointer to a converter (since converter addresses are more likely to change).\r\n\r\n    Format:\r\n    [source token, smart token, to token, smart token, to token...]\r\n*/\r\ncontract BancorNetwork is IBancorNetwork, TokenHolder, ContractIds, FeatureIds {\r\n    using SafeMath for uint256;\r\n\r\n    \r\n    uint64 private constant MAX_CONVERSION_FEE = 1000000;\r\n\r\n    address public signerAddress = 0x0;         // verified address that allows conversions with higher gas price\r\n    IContractRegistry public registry;          // contract registry contract address\r\n\r\n    mapping (address => bool) public etherTokens;       // list of all supported ether tokens\r\n    mapping (bytes32 => bool) public conversionHashes;  // list of conversion hashes, to prevent re-use of the same hash\r\n\r\n    /**\r\n        @dev constructor\r\n\r\n        @param _registry    address of a contract registry contract\r\n    */\r\n    constructor(IContractRegistry _registry) public validAddress(_registry) {\r\n        registry = _registry;\r\n    }\r\n\r\n    // validates a conversion path - verifies that the number of elements is odd and that maximum number of 'hops' is 10\r\n    modifier validConversionPath(IERC20Token[] _path) {\r\n        require(_path.length > 2 && _path.length <= (1 + 2 * 10) && _path.length % 2 == 1);\r\n        _;\r\n    }\r\n\r\n    /*\r\n        @dev allows the owner to update the contract registry contract address\r\n\r\n        @param _registry   address of a contract registry contract\r\n    */\r\n    function setRegistry(IContractRegistry _registry)\r\n        public\r\n        ownerOnly\r\n        validAddress(_registry)\r\n        notThis(_registry)\r\n    {\r\n        registry = _registry;\r\n    }\r\n\r\n    /*\r\n        @dev allows the owner to update the signer address\r\n\r\n        @param _signerAddress    new signer address\r\n    */\r\n    function setSignerAddress(address _signerAddress)\r\n        public\r\n        ownerOnly\r\n        validAddress(_signerAddress)\r\n        notThis(_signerAddress)\r\n    {\r\n        signerAddress = _signerAddress;\r\n    }\r\n\r\n    /**\r\n        @dev allows the owner to register/unregister ether tokens\r\n\r\n        @param _token       ether token contract address\r\n        @param _register    true to register, false to unregister\r\n    */\r\n    function registerEtherToken(IEtherToken _token, bool _register)\r\n        public\r\n        ownerOnly\r\n        validAddress(_token)\r\n        notThis(_token)\r\n    {\r\n        etherTokens[_token] = _register;\r\n    }\r\n\r\n    /**\r\n        @dev verifies that the signer address is trusted by recovering \r\n        the address associated with the public key from elliptic \r\n        curve signature, returns zero on error.\r\n        notice that the signature is valid only for one conversion\r\n        and expires after the give block.\r\n\r\n        @return true if the signer is verified\r\n    */\r\n    function verifyTrustedSender(IERC20Token[] _path, uint256 _customVal, uint256 _block, address _addr, uint8 _v, bytes32 _r, bytes32 _s) private returns(bool) {\r\n        bytes32 hash = keccak256(_block, tx.gasprice, _addr, msg.sender, _customVal, _path);\r\n\r\n        // checking that it is the first conversion with the given signature\r\n        // and that the current block number doesn't exceeded the maximum block\r\n        // number that's allowed with the current signature\r\n        require(!conversionHashes[hash] && block.number <= _block);\r\n\r\n        // recovering the signing address and comparing it to the trusted signer\r\n        // address that was set in the contract\r\n        bytes32 prefixedHash = keccak256(\"\\x19Ethereum Signed Message:\\n32\", hash);\r\n        bool verified = ecrecover(prefixedHash, _v, _r, _s) == signerAddress;\r\n\r\n        // if the signer is the trusted signer - mark the hash so that it can't\r\n        // be used multiple times\r\n        if (verified)\r\n            conversionHashes[hash] = true;\r\n        return verified;\r\n    }\r\n\r\n    /**\r\n        @dev validates xConvert call by verifying the path format, claiming the callers tokens (if not ETH),\r\n        and verifying the gas price limit\r\n\r\n        @param _path        conversion path, see conversion path format above\r\n        @param _amount      amount to convert from (in the initial source token)\r\n        @param _block       if the current block exceeded the given parameter - it is cancelled\r\n        @param _v           (signature[128:130]) associated with the signer address and helps to validate if the signature is legit\r\n        @param _r           (signature[0:64]) associated with the signer address and helps to validate if the signature is legit\r\n        @param _s           (signature[64:128]) associated with the signer address and helps to validate if the signature is legit\r\n    */\r\n    function validateXConversion(\r\n        IERC20Token[] _path,\r\n        uint256 _amount,\r\n        uint256 _block,\r\n        uint8 _v,\r\n        bytes32 _r,\r\n        bytes32 _s\r\n    ) \r\n        private \r\n        validConversionPath(_path)    \r\n    {\r\n        // if ETH is provided, ensure that the amount is identical to _amount and verify that the source token is an ether token\r\n        IERC20Token fromToken = _path[0];\r\n        require(msg.value == 0 || (_amount == msg.value && etherTokens[fromToken]));\r\n\r\n        // require that the dest token is BNT\r\n        require(_path[_path.length - 1] == registry.addressOf(ContractIds.BNT_TOKEN));\r\n\r\n        // if ETH was sent with the call, the source is an ether token - deposit the ETH in it\r\n        // otherwise, we claim the tokens from the sender\r\n        if (msg.value > 0) {\r\n            IEtherToken(fromToken).deposit.value(msg.value)();\r\n        } else {\r\n            assert(fromToken.transferFrom(msg.sender, this, _amount));\r\n        }\r\n\r\n        // verify gas price limit\r\n        if (_v == 0x0 && _r == 0x0 && _s == 0x0) {\r\n            IBancorGasPriceLimit gasPriceLimit = IBancorGasPriceLimit(registry.addressOf(ContractIds.BANCOR_GAS_PRICE_LIMIT));\r\n            gasPriceLimit.validateGasPrice(tx.gasprice);\r\n        } else {\r\n            require(verifyTrustedSender(_path, _amount, _block, msg.sender, _v, _r, _s));\r\n        }\r\n    }\r\n\r\n    /**\r\n        @dev converts the token to any other token in the bancor network by following\r\n        a predefined conversion path and transfers the result tokens to a target account\r\n        note that the converter should already own the source tokens\r\n\r\n        @param _path        conversion path, see conversion path format above\r\n        @param _amount      amount to convert from (in the initial source token)\r\n        @param _minReturn   if the conversion results in an amount smaller than the minimum return - it is cancelled, must be nonzero\r\n        @param _for         account that will receive the conversion result\r\n\r\n        @return tokens issued in return\r\n    */\r\n    function convertFor(IERC20Token[] _path, uint256 _amount, uint256 _minReturn, address _for) public payable returns (uint256) {\r\n        return convertForPrioritized3(_path, _amount, _minReturn, _for, _amount, 0x0, 0x0, 0x0, 0x0);\r\n    }\r\n\r\n    /**\r\n        @dev converts the token to any other token in the bancor network\r\n        by following a predefined conversion path and transfers the result\r\n        tokens to a target account.\r\n        this version of the function also allows the verified signer\r\n        to bypass the universal gas price limit.\r\n        note that the converter should already own the source tokens\r\n\r\n        @param _path        conversion path, see conversion path format above\r\n        @param _amount      amount to convert from (in the initial source token)\r\n        @param _minReturn   if the conversion results in an amount smaller than the minimum return - it is cancelled, must be nonzero\r\n        @param _for         account that will receive the conversion result\r\n        @param _customVal   custom value that was signed for prioritized conversion\r\n        @param _block       if the current block exceeded the given parameter - it is cancelled\r\n        @param _v           (signature[128:130]) associated with the signer address and helps to validate if the signature is legit\r\n        @param _r           (signature[0:64]) associated with the signer address and helps to validate if the signature is legit\r\n        @param _s           (signature[64:128]) associated with the signer address and helps to validate if the signature is legit\r\n\r\n        @return tokens issued in return\r\n    */\r\n    function convertForPrioritized3(\r\n        IERC20Token[] _path,\r\n        uint256 _amount,\r\n        uint256 _minReturn,\r\n        address _for,\r\n        uint256 _customVal,\r\n        uint256 _block,\r\n        uint8 _v,\r\n        bytes32 _r,\r\n        bytes32 _s\r\n    )\r\n        public\r\n        payable\r\n        returns (uint256)\r\n    {\r\n        // if ETH is provided, ensure that the amount is identical to _amount and verify that the source token is an ether token\r\n        IERC20Token fromToken = _path[0];\r\n        require(msg.value == 0 || (_amount == msg.value && etherTokens[fromToken]));\r\n\r\n        // if ETH was sent with the call, the source is an ether token - deposit the ETH in it\r\n        // otherwise, we assume we already have the tokens\r\n        if (msg.value > 0)\r\n            IEtherToken(fromToken).deposit.value(msg.value)();\r\n\r\n        return convertForInternal(_path, _amount, _minReturn, _for, _customVal, _block, _v, _r, _s);\r\n    }\r\n\r\n    /**\r\n        @dev converts any other token to BNT in the bancor network\r\n        by following a predefined conversion path and transfers the resulting\r\n        tokens to BancorX.\r\n        note that the network should already have been given allowance of the source token (if not ETH)\r\n\r\n        @param _path             conversion path, see conversion path format above\r\n        @param _amount           amount to convert from (in the initial source token)\r\n        @param _minReturn        if the conversion results in an amount smaller than the minimum return - it is cancelled, must be nonzero\r\n        @param _toBlockchain     blockchain BNT will be issued on\r\n        @param _to               address/account on _toBlockchain to send the BNT to\r\n        @param _conversionId     pre-determined unique (if non zero) id which refers to this transaction \r\n\r\n        @return the amount of BNT received from this conversion\r\n    */\r\n    function xConvert(\r\n        IERC20Token[] _path,\r\n        uint256 _amount,\r\n        uint256 _minReturn,\r\n        bytes32 _toBlockchain,\r\n        bytes32 _to,\r\n        uint256 _conversionId\r\n    )\r\n        public\r\n        payable\r\n        returns (uint256)\r\n    {\r\n        return xConvertPrioritized(_path, _amount, _minReturn, _toBlockchain, _to, _conversionId, 0x0, 0x0, 0x0, 0x0);\r\n    }\r\n\r\n    /**\r\n        @dev converts any other token to BNT in the bancor network\r\n        by following a predefined conversion path and transfers the resulting\r\n        tokens to BancorX.\r\n        this version of the function also allows the verified signer\r\n        to bypass the universal gas price limit.\r\n        note that the network should already have been given allowance of the source token (if not ETH)\r\n\r\n        @param _path            conversion path, see conversion path format above\r\n        @param _amount          amount to convert from (in the initial source token)\r\n        @param _minReturn       if the conversion results in an amount smaller than the minimum return - it is cancelled, must be nonzero\r\n        @param _toBlockchain    blockchain BNT will be issued on\r\n        @param _to              address/account on _toBlockchain to send the BNT to\r\n        @param _conversionId    pre-determined unique (if non zero) id which refers to this transaction \r\n        @param _block           if the current block exceeded the given parameter - it is cancelled\r\n        @param _v               (signature[128:130]) associated with the signer address and helps to validate if the signature is legit\r\n        @param _r               (signature[0:64]) associated with the signer address and helps to validate if the signature is legit\r\n        @param _s               (signature[64:128]) associated with the signer address and helps to validate if the signature is legit\r\n\r\n        @return the amount of BNT received from this conversion\r\n    */\r\n    function xConvertPrioritized(\r\n        IERC20Token[] _path,\r\n        uint256 _amount,\r\n        uint256 _minReturn,\r\n        bytes32 _toBlockchain,\r\n        bytes32 _to,\r\n        uint256 _conversionId,\r\n        uint256 _block,\r\n        uint8 _v,\r\n        bytes32 _r,\r\n        bytes32 _s\r\n    )\r\n        public\r\n        payable\r\n        returns (uint256)\r\n    {\r\n        // do a lot of validation and transfers in separate function to work around 16 variable limit\r\n        validateXConversion(_path, _amount, _block, _v, _r, _s);\r\n\r\n        // convert to BNT and get the resulting amount\r\n        (, uint256 retAmount) = convertByPath(_path, _amount, _minReturn, _path[0], this);\r\n\r\n        // transfer the resulting amount to BancorX, and return the amount\r\n        IBancorX(registry.addressOf(ContractIds.BANCOR_X)).xTransfer(_toBlockchain, _to, retAmount, _conversionId);\r\n\r\n        return retAmount;\r\n    }\r\n\r\n    /**\r\n        @dev converts token to any other token in the bancor network\r\n        by following the predefined conversion paths and transfers the result\r\n        tokens to a targeted account.\r\n        this version of the function also allows multiple conversions\r\n        in a single atomic transaction.\r\n        note that the converter should already own the source tokens\r\n\r\n        @param _paths           merged conversion paths, i.e. [path1, path2, ...]. see conversion path format above\r\n        @param _pathStartIndex  each item in the array is the start index of the nth path in _paths\r\n        @param _amounts         amount to convert from (in the initial source token) for each path\r\n        @param _minReturns      minimum return for each path. if the conversion results in an amount \r\n                                smaller than the minimum return - it is cancelled, must be nonzero\r\n        @param _for             account that will receive the conversions result\r\n\r\n        @return amount of conversion result for each path\r\n    */\r\n    function convertForMultiple(IERC20Token[] _paths, uint256[] _pathStartIndex, uint256[] _amounts, uint256[] _minReturns, address _for)\r\n        public\r\n        payable\r\n        returns (uint256[])\r\n    {\r\n        // if ETH is provided, ensure that the total amount was converted into other tokens\r\n        uint256 convertedValue = 0;\r\n        uint256 pathEndIndex;\r\n        \r\n        // iterate over the conversion paths\r\n        for (uint256 i = 0; i < _pathStartIndex.length; i += 1) {\r\n            pathEndIndex = i == (_pathStartIndex.length - 1) ? _paths.length : _pathStartIndex[i + 1];\r\n\r\n            // copy a single path from _paths into an array\r\n            IERC20Token[] memory path = new IERC20Token[](pathEndIndex - _pathStartIndex[i]);\r\n            for (uint256 j = _pathStartIndex[i]; j < pathEndIndex; j += 1) {\r\n                path[j - _pathStartIndex[i]] = _paths[j];\r\n            }\r\n\r\n            // if ETH is provided, ensure that the amount is lower than the path amount and\r\n            // verify that the source token is an ether token. otherwise ensure that \r\n            // the source is not an ether token\r\n            IERC20Token fromToken = path[0];\r\n            require(msg.value == 0 || (_amounts[i] <= msg.value && etherTokens[fromToken]) || !etherTokens[fromToken]);\r\n\r\n            // if ETH was sent with the call, the source is an ether token - deposit the ETH path amount in it.\r\n            // otherwise, we assume we already have the tokens\r\n            if (msg.value > 0 && etherTokens[fromToken]) {\r\n                IEtherToken(fromToken).deposit.value(_amounts[i])();\r\n                convertedValue += _amounts[i];\r\n            }\r\n            _amounts[i] = convertForInternal(path, _amounts[i], _minReturns[i], _for, 0x0, 0x0, 0x0, 0x0, 0x0);\r\n        }\r\n\r\n        // if ETH was provided, ensure that the full amount was converted\r\n        require(convertedValue == msg.value);\r\n\r\n        return _amounts;\r\n    }\r\n\r\n    /**\r\n        @dev converts token to any other token in the bancor network\r\n        by following a predefined conversion paths and transfers the result\r\n        tokens to a target account.\r\n\r\n        @param _path        conversion path, see conversion path format above\r\n        @param _amount      amount to convert from (in the initial source token)\r\n        @param _minReturn   if the conversion results in an amount smaller than the minimum return - it is cancelled, must be nonzero\r\n        @param _for         account that will receive the conversion result\r\n        @param _block       if the current block exceeded the given parameter - it is cancelled\r\n        @param _v           (signature[128:130]) associated with the signer address and helps to validate if the signature is legit\r\n        @param _r           (signature[0:64]) associated with the signer address and helps to validate if the signature is legit\r\n        @param _s           (signature[64:128]) associated with the signer address and helps to validate if the signature is legit\r\n\r\n        @return tokens issued in return\r\n    */\r\n    function convertForInternal(\r\n        IERC20Token[] _path, \r\n        uint256 _amount, \r\n        uint256 _minReturn, \r\n        address _for, \r\n        uint256 _customVal,\r\n        uint256 _block,\r\n        uint8 _v, \r\n        bytes32 _r, \r\n        bytes32 _s\r\n    )\r\n        private\r\n        validConversionPath(_path)\r\n        returns (uint256)\r\n    {\r\n        if (_v == 0x0 && _r == 0x0 && _s == 0x0) {\r\n            IBancorGasPriceLimit gasPriceLimit = IBancorGasPriceLimit(registry.addressOf(ContractIds.BANCOR_GAS_PRICE_LIMIT));\r\n            gasPriceLimit.validateGasPrice(tx.gasprice);\r\n        }\r\n        else {\r\n            require(verifyTrustedSender(_path, _customVal, _block, _for, _v, _r, _s));\r\n        }\r\n\r\n        // if ETH is provided, ensure that the amount is identical to _amount and verify that the source token is an ether token\r\n        IERC20Token fromToken = _path[0];\r\n\r\n        IERC20Token toToken;\r\n        \r\n        (toToken, _amount) = convertByPath(_path, _amount, _minReturn, fromToken, _for);\r\n\r\n        // finished the conversion, transfer the funds to the target account\r\n        // if the target token is an ether token, withdraw the tokens and send them as ETH\r\n        // otherwise, transfer the tokens as is\r\n        if (etherTokens[toToken])\r\n            IEtherToken(toToken).withdrawTo(_for, _amount);\r\n        else\r\n            assert(toToken.transfer(_for, _amount));\r\n\r\n        return _amount;\r\n    }\r\n\r\n    /**\r\n        @dev executes the actual conversion by following the conversion path\r\n\r\n        @param _path        conversion path, see conversion path format above\r\n        @param _amount      amount to convert from (in the initial source token)\r\n        @param _minReturn   if the conversion results in an amount smaller than the minimum return - it is cancelled, must be nonzero\r\n        @param _fromToken   ERC20 token to convert from (the first element in the path)\r\n        @param _for         account that will receive the conversion result\r\n\r\n        @return ERC20 token to convert to (the last element in the path) & tokens issued in return\r\n    */\r\n    function convertByPath(\r\n        IERC20Token[] _path,\r\n        uint256 _amount,\r\n        uint256 _minReturn,\r\n        IERC20Token _fromToken,\r\n        address _for\r\n    ) private returns (IERC20Token, uint256) {\r\n        ISmartToken smartToken;\r\n        IERC20Token toToken;\r\n        IBancorConverter converter;\r\n\r\n        // get the contract features address from the registry\r\n        IContractFeatures features = IContractFeatures(registry.addressOf(ContractIds.CONTRACT_FEATURES));\r\n\r\n        // iterate over the conversion path\r\n        uint256 pathLength = _path.length;\r\n        for (uint256 i = 1; i < pathLength; i += 2) {\r\n            smartToken = ISmartToken(_path[i]);\r\n            toToken = _path[i + 1];\r\n            converter = IBancorConverter(smartToken.owner());\r\n            checkWhitelist(converter, _for, features);\r\n\r\n            // if the smart token isn't the source (from token), the converter doesn't have control over it and thus we need to approve the request\r\n            if (smartToken != _fromToken)\r\n                ensureAllowance(_fromToken, converter, _amount);\r\n\r\n            // make the conversion - if it's the last one, also provide the minimum return value\r\n            _amount = converter.change(_fromToken, toToken, _amount, i == pathLength - 2 ? _minReturn : 1);\r\n            _fromToken = toToken;\r\n        }\r\n        return (toToken, _amount);\r\n    }\r\n\r\n    /**\r\n        @dev returns the expected return amount for converting a specific amount by following\r\n        a given conversion path.\r\n        notice that there is no support for circular paths.\r\n\r\n        @param _path        conversion path, see conversion path format above\r\n        @param _amount      amount to convert from (in the initial source token)\r\n\r\n        @return expected conversion return amount and conversion fee\r\n    */\r\n    function getReturnByPath(IERC20Token[] _path, uint256 _amount) public view returns (uint256, uint256) {\r\n        IERC20Token fromToken;\r\n        ISmartToken smartToken; \r\n        IERC20Token toToken;\r\n        IBancorConverter converter;\r\n        uint256 amount;\r\n        uint256 fee;\r\n        uint256 supply;\r\n        uint256 balance;\r\n        uint32 weight;\r\n        ISmartToken prevSmartToken;\r\n        IBancorFormula formula = IBancorFormula(registry.getAddress(ContractIds.BANCOR_FORMULA));\r\n\r\n        amount = _amount;\r\n        fromToken = _path[0];\r\n\r\n        // iterate over the conversion path\r\n        for (uint256 i = 1; i < _path.length; i += 2) {\r\n            smartToken = ISmartToken(_path[i]);\r\n            toToken = _path[i + 1];\r\n            converter = IBancorConverter(smartToken.owner());\r\n\r\n            if (toToken == smartToken) { // buy the smart token\r\n                // check if the current smart token supply was changed in the previous iteration\r\n                supply = smartToken == prevSmartToken ? supply : smartToken.totalSupply();\r\n\r\n                // validate input\r\n                require(getConnectorSaleEnabled(converter, fromToken));\r\n\r\n                // calculate the amount & the conversion fee\r\n                balance = converter.getConnectorBalance(fromToken);\r\n                weight = getConnectorWeight(converter, fromToken);\r\n                amount = formula.calculatePurchaseReturn(supply, balance, weight, amount);\r\n                fee = amount.mul(converter.conversionFee()).div(MAX_CONVERSION_FEE);\r\n                amount -= fee;\r\n\r\n                // update the smart token supply for the next iteration\r\n                supply = smartToken.totalSupply() + amount;\r\n            }\r\n            else if (fromToken == smartToken) { // sell the smart token\r\n                // check if the current smart token supply was changed in the previous iteration\r\n                supply = smartToken == prevSmartToken ? supply : smartToken.totalSupply();\r\n\r\n                // calculate the amount & the conversion fee\r\n                balance = converter.getConnectorBalance(toToken);\r\n                weight = getConnectorWeight(converter, toToken);\r\n                amount = formula.calculateSaleReturn(supply, balance, weight, amount);\r\n                fee = amount.mul(converter.conversionFee()).div(MAX_CONVERSION_FEE);\r\n                amount -= fee;\r\n\r\n                // update the smart token supply for the next iteration\r\n                supply = smartToken.totalSupply() - amount;\r\n            }\r\n            else { // cross connector conversion\r\n                (amount, fee) = converter.getReturn(fromToken, toToken, amount);\r\n            }\r\n\r\n            prevSmartToken = smartToken;\r\n            fromToken = toToken;\r\n        }\r\n\r\n        return (amount, fee);\r\n    }\r\n\r\n    /**\r\n        @dev checks whether the given converter supports a whitelist and if so, ensures that\r\n        the account that should receive the conversion result is actually whitelisted\r\n\r\n        @param _converter   converter to check for whitelist\r\n        @param _for         account that will receive the conversion result\r\n        @param _features    contract features contract address\r\n    */\r\n    function checkWhitelist(IBancorConverter _converter, address _for, IContractFeatures _features) private view {\r\n        IWhitelist whitelist;\r\n\r\n        // check if the converter supports the conversion whitelist feature\r\n        if (!_features.isSupported(_converter, FeatureIds.CONVERTER_CONVERSION_WHITELIST))\r\n            return;\r\n\r\n        // get the whitelist contract from the converter\r\n        whitelist = _converter.conversionWhitelist();\r\n        if (whitelist == address(0))\r\n            return;\r\n\r\n        // check if the account that should receive the conversion result is actually whitelisted\r\n        require(whitelist.isWhitelisted(_for));\r\n    }\r\n\r\n    /**\r\n        @dev claims the caller's tokens, converts them to any other token in the bancor network\r\n        by following a predefined conversion path and transfers the result tokens to a target account\r\n        note that allowance must be set beforehand\r\n\r\n        @param _path        conversion path, see conversion path format above\r\n        @param _amount      amount to convert from (in the initial source token)\r\n        @param _minReturn   if the conversion results in an amount smaller than the minimum return - it is cancelled, must be nonzero\r\n        @param _for         account that will receive the conversion result\r\n\r\n        @return tokens issued in return\r\n    */\r\n    function claimAndConvertFor(IERC20Token[] _path, uint256 _amount, uint256 _minReturn, address _for) public returns (uint256) {\r\n        // we need to transfer the tokens from the caller to the converter before we follow\r\n        // the conversion path, to allow it to execute the conversion on behalf of the caller\r\n        // note: we assume we already have allowance\r\n        IERC20Token fromToken = _path[0];\r\n        assert(fromToken.transferFrom(msg.sender, this, _amount));\r\n        return convertFor(_path, _amount, _minReturn, _for);\r\n    }\r\n\r\n    /**\r\n        @dev converts the token to any other token in the bancor network by following\r\n        a predefined conversion path and transfers the result tokens back to the sender\r\n        note that the converter should already own the source tokens\r\n\r\n        @param _path        conversion path, see conversion path format above\r\n        @param _amount      amount to convert from (in the initial source token)\r\n        @param _minReturn   if the conversion results in an amount smaller than the minimum return - it is cancelled, must be nonzero\r\n\r\n        @return tokens issued in return\r\n    */\r\n    function convert(IERC20Token[] _path, uint256 _amount, uint256 _minReturn) public payable returns (uint256) {\r\n        return convertFor(_path, _amount, _minReturn, msg.sender);\r\n    }\r\n\r\n    /**\r\n        @dev claims the caller's tokens, converts them to any other token in the bancor network\r\n        by following a predefined conversion path and transfers the result tokens back to the sender\r\n        note that allowance must be set beforehand\r\n\r\n        @param _path        conversion path, see conversion path format above\r\n        @param _amount      amount to convert from (in the initial source token)\r\n        @param _minReturn   if the conversion results in an amount smaller than the minimum return - it is cancelled, must be nonzero\r\n\r\n        @return tokens issued in return\r\n    */\r\n    function claimAndConvert(IERC20Token[] _path, uint256 _amount, uint256 _minReturn) public returns (uint256) {\r\n        return claimAndConvertFor(_path, _amount, _minReturn, msg.sender);\r\n    }\r\n\r\n    /**\r\n        @dev utility, checks whether allowance for the given spender exists and approves one if it doesn't\r\n\r\n        @param _token   token to check the allowance in\r\n        @param _spender approved address\r\n        @param _value   allowance amount\r\n    */\r\n    function ensureAllowance(IERC20Token _token, address _spender, uint256 _value) private {\r\n        // check if allowance for the given amount already exists\r\n        if (_token.allowance(this, _spender) >= _value)\r\n            return;\r\n\r\n        // if the allowance is nonzero, must reset it to 0 first\r\n        if (_token.allowance(this, _spender) != 0)\r\n            assert(_token.approve(_spender, 0));\r\n\r\n        // approve the new allowance\r\n        assert(_token.approve(_spender, _value));\r\n    }\r\n\r\n    /**\r\n        @dev returns the connector weight\r\n\r\n        @param _converter       converter contract address\r\n        @param _connector       connector's address to read from\r\n\r\n        @return connector's weight\r\n    */\r\n    function getConnectorWeight(IBancorConverter _converter, IERC20Token _connector) \r\n        private\r\n        view\r\n        returns(uint32)\r\n    {\r\n        uint256 virtualBalance;\r\n        uint32 weight;\r\n        bool isVirtualBalanceEnabled;\r\n        bool isSaleEnabled;\r\n        bool isSet;\r\n        (virtualBalance, weight, isVirtualBalanceEnabled, isSaleEnabled, isSet) = _converter.connectors(_connector);\r\n        return weight;\r\n    }\r\n\r\n    /**\r\n        @dev returns true if connector sale is enabled\r\n\r\n        @param _converter       converter contract address\r\n        @param _connector       connector's address to read from\r\n\r\n        @return true if connector sale is enabled, otherwise - false\r\n    */\r\n    function getConnectorSaleEnabled(IBancorConverter _converter, IERC20Token _connector) \r\n        private\r\n        view\r\n        returns(bool)\r\n    {\r\n        uint256 virtualBalance;\r\n        uint32 weight;\r\n        bool isVirtualBalanceEnabled;\r\n        bool isSaleEnabled;\r\n        bool isSet;\r\n        (virtualBalance, weight, isVirtualBalanceEnabled, isSaleEnabled, isSet) = _converter.connectors(_connector);\r\n        return isSaleEnabled;\r\n    }\r\n\r\n    // deprecated, backward compatibility\r\n    function convertForPrioritized2(\r\n        IERC20Token[] _path,\r\n        uint256 _amount,\r\n        uint256 _minReturn,\r\n        address _for,\r\n        uint256 _block,\r\n        uint8 _v,\r\n        bytes32 _r,\r\n        bytes32 _s\r\n    )\r\n        public\r\n        payable\r\n        returns (uint256)\r\n    {\r\n        return convertForPrioritized3(_path, _amount, _minReturn, _for, _amount, _block, _v, _r, _s);\r\n    }\r\n\r\n    // deprecated, backward compatibility\r\n    function convertForPrioritized(\r\n        IERC20Token[] _path,\r\n        uint256 _amount,\r\n        uint256 _minReturn,\r\n        address _for,\r\n        uint256 _block,\r\n        uint256 _nonce,\r\n        uint8 _v,\r\n        bytes32 _r,\r\n        bytes32 _s)\r\n        public payable returns (uint256)\r\n    {\r\n        _nonce;\r\n        return convertForPrioritized3(_path, _amount, _minReturn, _for, _amount, _block, _v, _r, _s);\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_register\",\"type\":\"bool\"}],\"name\":\"registerEtherToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_signerAddress\",\"type\":\"address\"}],\"name\":\"setSignerAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_path\",\"type\":\"address[]\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"getReturnByPath\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"BANCOR_CONVERTER_UPGRADER\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_path\",\"type\":\"address[]\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_minReturn\",\"type\":\"uint256\"},{\"name\":\"_for\",\"type\":\"address\"},{\"name\":\"_block\",\"type\":\"uint256\"},{\"name\":\"_nonce\",\"type\":\"uint256\"},{\"name\":\"_v\",\"type\":\"uint8\"},{\"name\":\"_r\",\"type\":\"bytes32\"},{\"name\":\"_s\",\"type\":\"bytes32\"}],\"name\":\"convertForPrioritized\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"BNT_TOKEN\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CONTRACT_REGISTRY\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"BANCOR_CONVERTER_FACTORY\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"signerAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdrawTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"BNT_CONVERTER\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_path\",\"type\":\"address[]\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_minReturn\",\"type\":\"uint256\"},{\"name\":\"_toBlockchain\",\"type\":\"bytes32\"},{\"name\":\"_to\",\"type\":\"bytes32\"},{\"name\":\"_conversionId\",\"type\":\"uint256\"},{\"name\":\"_block\",\"type\":\"uint256\"},{\"name\":\"_v\",\"type\":\"uint8\"},{\"name\":\"_r\",\"type\":\"bytes32\"},{\"name\":\"_s\",\"type\":\"bytes32\"}],\"name\":\"xConvertPrioritized\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_path\",\"type\":\"address[]\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_minReturn\",\"type\":\"uint256\"},{\"name\":\"_for\",\"type\":\"address\"},{\"name\":\"_block\",\"type\":\"uint256\"},{\"name\":\"_v\",\"type\":\"uint8\"},{\"name\":\"_r\",\"type\":\"bytes32\"},{\"name\":\"_s\",\"type\":\"bytes32\"}],\"name\":\"convertForPrioritized2\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"BANCOR_FORMULA\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"registry\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"etherTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CONTRACT_FEATURES\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"conversionHashes\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"BANCOR_NETWORK\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"BANCOR_GAS_PRICE_LIMIT\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CONVERTER_CONVERSION_WHITELIST\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_registry\",\"type\":\"address\"}],\"name\":\"setRegistry\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_path\",\"type\":\"address[]\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_minReturn\",\"type\":\"uint256\"},{\"name\":\"_for\",\"type\":\"address\"}],\"name\":\"claimAndConvertFor\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_path\",\"type\":\"address[]\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_minReturn\",\"type\":\"uint256\"},{\"name\":\"_for\",\"type\":\"address\"},{\"name\":\"_customVal\",\"type\":\"uint256\"},{\"name\":\"_block\",\"type\":\"uint256\"},{\"name\":\"_v\",\"type\":\"uint8\"},{\"name\":\"_r\",\"type\":\"bytes32\"},{\"name\":\"_s\",\"type\":\"bytes32\"}],\"name\":\"convertForPrioritized3\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_paths\",\"type\":\"address[]\"},{\"name\":\"_pathStartIndex\",\"type\":\"uint256[]\"},{\"name\":\"_amounts\",\"type\":\"uint256[]\"},{\"name\":\"_minReturns\",\"type\":\"uint256[]\"},{\"name\":\"_for\",\"type\":\"address\"}],\"name\":\"convertForMultiple\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"BANCOR_X\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_path\",\"type\":\"address[]\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_minReturn\",\"type\":\"uint256\"},{\"name\":\"_toBlockchain\",\"type\":\"bytes32\"},{\"name\":\"_to\",\"type\":\"bytes32\"},{\"name\":\"_conversionId\",\"type\":\"uint256\"}],\"name\":\"xConvert\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_path\",\"type\":\"address[]\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_minReturn\",\"type\":\"uint256\"}],\"name\":\"claimAndConvert\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_path\",\"type\":\"address[]\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_minReturn\",\"type\":\"uint256\"},{\"name\":\"_for\",\"type\":\"address\"}],\"name\":\"convertFor\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"BANCOR_X_UPGRADER\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"newOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_path\",\"type\":\"address[]\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_minReturn\",\"type\":\"uint256\"}],\"name\":\"convert\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_registry\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_prevOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"OwnerUpdate\",\"type\":\"event\"}]","ContractName":"BancorNetwork","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000052ae12abe5d8bd778bd5397f99ca900624cfadd4","Library":"","SwarmSource":"bzzr://61186cca32c3e2a6034d0833a2ab4e5b30759f22b0c2f3a572f7abbe027e96b0"}]}