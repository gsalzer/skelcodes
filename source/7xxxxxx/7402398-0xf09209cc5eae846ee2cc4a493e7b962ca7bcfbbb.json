{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.8;\r\n\r\ncontract ERC20 {\r\n  uint public totalSupply;\r\n  function balanceOf(address who) constant returns (uint);\r\n  function allowance(address owner, address spender) constant returns (uint);\r\n\r\n  function transfer(address to, uint value) returns (bool ok);\r\n  function transferFrom(address from, address to, uint value) returns (bool ok);\r\n  function approve(address spender, uint value) returns (bool ok);\r\n  event Transfer(address indexed from, address indexed to, uint value);\r\n  event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\n\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n  function Ownable() {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  modifier onlyOwner() {\r\n    if (msg.sender == owner)\r\n      _;\r\n  }\r\n\r\n  function transferOwnership(address newOwner) onlyOwner {\r\n    if (newOwner != address(0)) owner = newOwner;\r\n  }\r\n\r\n}\r\n\r\ncontract TokenSpender {\r\n    function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData);\r\n}\r\n\r\ncontract SafeMath {\r\n  function safeMul(uint a, uint b) internal returns (uint) {\r\n    uint c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function safeDiv(uint a, uint b) internal returns (uint) {\r\n    assert(b > 0);\r\n    uint c = a / b;\r\n    assert(a == b * c + a % b);\r\n    return c;\r\n  }\r\n\r\n  function safeSub(uint a, uint b) internal returns (uint) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function safeAdd(uint a, uint b) internal returns (uint) {\r\n    uint c = a + b;\r\n    assert(c>=a && c>=b);\r\n    return c;\r\n  }\r\n\r\n  function max64(uint64 a, uint64 b) internal constant returns (uint64) {\r\n    return a >= b ? a : b;\r\n  }\r\n\r\n  function min64(uint64 a, uint64 b) internal constant returns (uint64) {\r\n    return a < b ? a : b;\r\n  }\r\n\r\n  function max256(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    return a >= b ? a : b;\r\n  }\r\n\r\n  function min256(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    return a < b ? a : b;\r\n  }\r\n\r\n  function assert(bool assertion) internal {\r\n    if (!assertion) {\r\n      throw;\r\n    }\r\n  }\r\n}\r\n\r\ncontract PullPayment {\r\n  mapping(address => uint) public payments;\r\n  event RefundETH(address to, uint value);\r\n  // store sent amount as credit to be pulled, called by payer\r\n  function asyncSend(address dest, uint amount) internal {\r\n    payments[dest] += amount;\r\n  }\r\n\r\n  // withdraw accumulated balance, called by payee\r\n  function withdrawPayments() {\r\n    address payee = msg.sender;\r\n    uint payment = payments[payee];\r\n    \r\n    if (payment == 0) {\r\n      throw;\r\n    }\r\n\r\n    if (this.balance < payment) {\r\n      throw;\r\n    }\r\n\r\n    payments[payee] = 0;\r\n\r\n    if (!payee.send(payment)) {\r\n      throw;\r\n    }\r\n    RefundETH(payee,payment);\r\n  }\r\n}\r\n\r\ncontract Pausable is Ownable {\r\n  bool public stopped;\r\n\r\n  modifier stopInEmergency {\r\n    if (stopped) {\r\n      throw;\r\n    }\r\n    _;\r\n  }\r\n  \r\n  modifier onlyInEmergency {\r\n    if (!stopped) {\r\n      throw;\r\n    }\r\n    _;\r\n  }\r\n\r\n  // called by the owner on emergency, triggers stopped state\r\n  function emergencyStop() external onlyOwner {\r\n    stopped = true;\r\n  }\r\n\r\n  // called by the owner on end of emergency, returns to normal state\r\n  function release() external onlyOwner onlyInEmergency {\r\n    stopped = false;\r\n  }\r\n\r\n}\r\n\r\n\r\ncontract RLC is ERC20, SafeMath, Ownable {\r\n\r\n    /* Public variables of the token */\r\n  string public name;       //fancy name\r\n  string public symbol;\r\n  uint8 public decimals;    //How many decimals to show.\r\n  string public version = 'v0.1'; \r\n  uint public initialSupply;\r\n  uint public totalSupply;\r\n  bool public locked;\r\n  //uint public unlockBlock;\r\n\r\n  mapping(address => uint) balances;\r\n  mapping (address => mapping (address => uint)) allowed;\r\n\r\n  // lock transfer during the ICO\r\n  modifier onlyUnlocked() {\r\n    if (msg.sender != owner && locked) throw;\r\n    _;\r\n  }\r\n\r\n  /*\r\n   *  The RLC Token created with the time at which the crowdsale end\r\n   */\r\n\r\n  function RLC() {\r\n    // lock the transfer function during the crowdsale\r\n    locked = true;\r\n    //unlockBlock=  now + 45 days; // (testnet) - for mainnet put the block number\r\n\r\n    initialSupply = 87000000000000000;\r\n    totalSupply = initialSupply;\r\n    balances[msg.sender] = initialSupply;// Give the creator all initial tokens                    \r\n    name = 'iEx.ec Network Token';        // Set the name for display purposes     \r\n    symbol = 'RLC';                       // Set the symbol for display purposes  \r\n    decimals = 9;                        // Amount of decimals for display purposes\r\n  }\r\n\r\n  function unlock() onlyOwner {\r\n    locked = false;\r\n  }\r\n\r\n  function burn(uint256 _value) returns (bool){\r\n    balances[msg.sender] = safeSub(balances[msg.sender], _value) ;\r\n    totalSupply = safeSub(totalSupply, _value);\r\n    Transfer(msg.sender, 0x0, _value);\r\n    return true;\r\n  }\r\n\r\n  function transfer(address _to, uint _value) onlyUnlocked returns (bool) {\r\n    balances[msg.sender] = safeSub(balances[msg.sender], _value);\r\n    balances[_to] = safeAdd(balances[_to], _value);\r\n    Transfer(msg.sender, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  function transferFrom(address _from, address _to, uint _value) onlyUnlocked returns (bool) {\r\n    var _allowance = allowed[_from][msg.sender];\r\n    \r\n    balances[_to] = safeAdd(balances[_to], _value);\r\n    balances[_from] = safeSub(balances[_from], _value);\r\n    allowed[_from][msg.sender] = safeSub(_allowance, _value);\r\n    Transfer(_from, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  function balanceOf(address _owner) constant returns (uint balance) {\r\n    return balances[_owner];\r\n  }\r\n\r\n  function approve(address _spender, uint _value) returns (bool) {\r\n    allowed[msg.sender][_spender] = _value;\r\n    Approval(msg.sender, _spender, _value);\r\n    return true;\r\n  }\r\n\r\n    /* Approve and then comunicate the approved contract in a single tx */\r\n  function approveAndCall(address _spender, uint256 _value, bytes _extraData){    \r\n      TokenSpender spender = TokenSpender(_spender);\r\n      if (approve(_spender, _value)) {\r\n          spender.receiveApproval(msg.sender, _value, this, _extraData);\r\n      }\r\n  }\r\n\r\n  function allowance(address _owner, address _spender) constant returns (uint remaining) {\r\n    return allowed[_owner][_spender];\r\n  }\r\n  \r\n}\r\n\r\n\r\n\r\n\r\ncontract Crowdsale is SafeMath, PullPayment, Pausable {\r\n\r\n  \tstruct Backer {\r\n\t\tuint weiReceived;\t// Amount of ETH given\r\n\t\tstring btc_address;  //store the btc address for full traceability\r\n\t\tuint satoshiReceived;\t// Amount of BTC given\r\n\t\tuint rlcSent;\r\n\t}\r\n\r\n\tRLC \tpublic rlc;         // RLC contract reference\r\n\taddress public owner;       // Contract owner (iEx.ec team)\r\n\taddress public multisigETH; // Multisig contract that will receive the ETH\r\n\taddress public BTCproxy;\t// address of the BTC Proxy\r\n\r\n\tuint public RLCPerETH;      // Number of RLC per ETH\r\n\tuint public RLCPerSATOSHI;  // Number of RLC per SATOSHI\r\n\tuint public ETHReceived;    // Number of ETH received\r\n\tuint public BTCReceived;    // Number of BTC received\r\n\tuint public RLCSentToETH;   // Number of RLC sent to ETH contributors\r\n\tuint public RLCSentToBTC;   // Number of RLC sent to BTC contributors\r\n\tuint public startBlock;     // Crowdsale start block\r\n\tuint public endBlock;       // Crowdsale end block\r\n\tuint public minCap;         // Minimum number of RLC to sell\r\n\tuint public maxCap;         // Maximum number of RLC to sell\r\n\tbool public maxCapReached;  // Max cap has been reached\r\n\tuint public minInvestETH;   // Minimum amount to invest\r\n\tuint public minInvestBTC;   // Minimum amount to invest\r\n\tbool public crowdsaleClosed;// Is crowdsale still on going\r\n\r\n\taddress public bounty;\t\t// address at which the bounty RLC will be sent\r\n\taddress public reserve; \t// address at which the contingency reserve will be sent\r\n\taddress public team;\t\t// address at which the team RLC will be sent\r\n\r\n\tuint public rlc_bounty;\t\t// amount of bounties RLC\r\n\tuint public rlc_reserve;\t// amount of the contingency reserve\r\n\tuint public rlc_team;\t\t// amount of the team RLC \r\n\tmapping(address => Backer) public backers; //backersETH indexed by their ETH address\r\n\r\n\tmodifier onlyBy(address a){\r\n\t\tif (msg.sender != a) throw;  \r\n\t\t_;\r\n\t}\r\n\r\n\tmodifier minCapNotReached() {\r\n\t\tif ((now<endBlock) || RLCSentToETH + RLCSentToBTC >= minCap ) throw;\r\n\t\t_;\r\n\t}\r\n\r\n\tmodifier respectTimeFrame() {\r\n\t\tif ((now < startBlock) || (now > endBlock )) throw;\r\n\t\t_;\r\n\t}\r\n\r\n\t/*\r\n\t* Event\r\n\t*/\r\n\tevent ReceivedETH(address addr, uint value);\r\n\tevent ReceivedBTC(address addr, string from, uint value, string txid);\r\n\tevent RefundBTC(string to, uint value);\r\n\tevent Logs(address indexed from, uint amount, string value);\r\n\r\n\t/*\r\n\t*\tConstructor\r\n\t*/\r\n\t//function Crowdsale() {\r\n\tfunction Crowdsale() {\r\n\t\towner = msg.sender;\r\n\t\tBTCproxy = 0x75c6cceb1a33f177369053f8a0e840de96b4ed0e;\r\n\t\trlc = RLC(0x6031203f6D83A674a43528A1eBd4b4129F5526CC);\r\n\t\tmultisigETH = 0xAe307e3871E5A321c0559FBf0233A38c937B826A;\r\n\t\tteam = 0xd65380D773208a6Aa49472Bf55186b855B393298;\r\n\t\treserve = 0x24F6b37770C6067D05ACc2aD2C42d1Bafde95d48;\r\n\t\tbounty = 0x8226a24dA0870Fb8A128E4Fc15228a9c4a5baC29;\r\n\t\tRLCSentToETH = 0;\r\n\t\tRLCSentToBTC = 0;\r\n\t\tminInvestETH = 1 ether;\r\n\t\tminInvestBTC = 5000000;\t\t\t// approx 50 USD or 0.05000000 BTC\r\n\t\tstartBlock = 0 ;            \t// should wait for the call of the function start\r\n\t\tendBlock =  0;  \t\t\t\t// should wait for the call of the function start\r\n\t\tRLCPerETH = 200000000000;\t\t// will be update every 10min based on the kraken ETHBTC\r\n\t\tRLCPerSATOSHI = 50000;\t\t\t// 5000 RLC par BTC == 50,000 RLC per satoshi\r\n\t\tminCap=12000000000000000;\r\n\t\tmaxCap=60000000000000000;\r\n\t\trlc_bounty=1700000000000000;\t// max 6000000 RLC\r\n\t\trlc_reserve=1700000000000000;\t// max 6000000 RLC\r\n\t\trlc_team=12000000000000000;\r\n\t}\r\n\r\n\t/* \r\n\t * The fallback function corresponds to a donation in ETH\r\n\t */\r\n\tfunction() payable {\r\n\t\tif (now > endBlock) throw;\r\n\t\treceiveETH(msg.sender);\r\n\t}\r\n\r\n\t/* \r\n\t * To call to start the crowdsale\r\n\t */\r\n\tfunction start() onlyBy(owner) {\r\n\t\tstartBlock = now ;            \r\n\t\tendBlock =  now + 30 days;    \r\n\t}\r\n\r\n\t/*\r\n\t*\tReceives a donation in ETH\r\n\t*/\r\n\tfunction receiveETH(address beneficiary) internal stopInEmergency  respectTimeFrame  {\r\n\t\tif (msg.value < minInvestETH) throw;\t\t\t\t\t\t\t\t//don't accept funding under a predefined threshold\r\n\t\tuint rlcToSend = bonus(safeMul(msg.value,RLCPerETH)/(1 ether));\t\t//compute the number of RLC to send\r\n\t\tif (safeAdd(rlcToSend, safeAdd(RLCSentToETH, RLCSentToBTC)) > maxCap) throw;\t\r\n\r\n\t\tBacker backer = backers[beneficiary];\r\n\t\tif (!rlc.transfer(beneficiary, rlcToSend)) throw;     \t\t\t\t// Do the RLC transfer right now \r\n\t\tbacker.rlcSent = safeAdd(backer.rlcSent, rlcToSend);\r\n\t\tbacker.weiReceived = safeAdd(backer.weiReceived, msg.value);\t\t// Update the total wei collected during the crowdfunding for this backer    \r\n\t\tETHReceived = safeAdd(ETHReceived, msg.value);\t\t\t\t\t\t// Update the total wei collected during the crowdfunding\r\n\t\tRLCSentToETH = safeAdd(RLCSentToETH, rlcToSend);\r\n\r\n\t\temitRLC(rlcToSend);\t\t\t\t\t\t\t\t\t\t\t\t\t// compute the variable part \r\n\t\tReceivedETH(beneficiary,ETHReceived);\t\t\t\t\t\t\t\t// send the corresponding contribution event\r\n\t}\r\n\t\r\n\t/*\r\n\t* receives a donation in BTC\r\n\t*/\r\n\tfunction receiveBTC(address beneficiary, string btc_address, uint value, string txid) stopInEmergency respectTimeFrame onlyBy(BTCproxy) returns (bool res){\r\n\t\tif (value < minInvestBTC) throw;\t\t\t\t\t\t\t\t\t\t\t// this verif is also made on the btcproxy\r\n\r\n\t\tuint rlcToSend = bonus(safeMul(value,RLCPerSATOSHI));\t\t\t\t\t\t//compute the number of RLC to send\r\n\t\tif (safeAdd(rlcToSend, safeAdd(RLCSentToETH, RLCSentToBTC)) > maxCap) {\t\t// check if we are not reaching the maxCap by accepting this donation\r\n\t\t\tRefundBTC(btc_address , value);\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\tBacker backer = backers[beneficiary];\r\n\t\tif (!rlc.transfer(beneficiary, rlcToSend)) throw;\t\t\t\t\t\t\t// Do the transfer right now \r\n\t\tbacker.rlcSent = safeAdd(backer.rlcSent , rlcToSend);\r\n\t\tbacker.btc_address = btc_address;\r\n\t\tbacker.satoshiReceived = safeAdd(backer.satoshiReceived, value);\r\n\t\tBTCReceived =  safeAdd(BTCReceived, value);\t\t\t\t\t\t\t\t\t// Update the total satoshi collected during the crowdfunding for this backer\r\n\t\tRLCSentToBTC = safeAdd(RLCSentToBTC, rlcToSend);\t\t\t\t\t\t\t// Update the total satoshi collected during the crowdfunding\r\n\t\temitRLC(rlcToSend);\r\n\t\tReceivedBTC(beneficiary, btc_address, BTCReceived, txid);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/*\r\n\t *Compute the variable part\r\n\t */\r\n\tfunction emitRLC(uint amount) internal {\r\n\t\trlc_bounty = safeAdd(rlc_bounty, amount/10);\r\n\t\trlc_team = safeAdd(rlc_team, amount/20);\r\n\t\trlc_reserve = safeAdd(rlc_reserve, amount/10);\r\n\t\tLogs(msg.sender ,amount, \"emitRLC\");\r\n\t}\r\n\r\n\t/*\r\n\t *Compute the RLC bonus according to the investment period\r\n\t */\r\n\tfunction bonus(uint amount) internal constant returns (uint) {\r\n\t\tif (now < safeAdd(startBlock, 10 days)) return (safeAdd(amount, amount/5));   // bonus 20%\r\n\t\tif (now < safeAdd(startBlock, 20 days)) return (safeAdd(amount, amount/10));  // bonus 10%\r\n\t\treturn amount;\r\n\t}\r\n\r\n\t/* \r\n\t * When mincap is not reach backer can call the approveAndCall function of the RLC token contract\r\n\t * with this crowdsale contract on parameter with all the RLC they get in order to be refund\r\n\t */\r\n\tfunction receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) minCapNotReached public {\r\n\t\tif (msg.sender != address(rlc)) throw; \r\n\t\tif (_extraData.length != 0) throw;\t\t\t\t\t\t\t\t// no extradata needed\r\n\t\tif (_value != backers[_from].rlcSent) throw;\t\t\t\t\t// compare value from backer balance\r\n\t\tif (!rlc.transferFrom(_from, address(this), _value)) throw ;\t// get the token back to the crowdsale contract\r\n\t\tif (!rlc.burn(_value)) throw ;\t\t\t\t\t\t\t\t\t// token sent for refund are burnt\r\n\t\tuint ETHToSend = backers[_from].weiReceived;\r\n\t\tbackers[_from].weiReceived=0;\r\n\t\tuint BTCToSend = backers[_from].satoshiReceived;\r\n\t\tbackers[_from].satoshiReceived = 0;\r\n\t\tif (ETHToSend > 0) {\r\n\t\t\tasyncSend(_from,ETHToSend);\t\t\t\t\t\t\t\t\t// pull payment to get refund in ETH\r\n\t\t}\r\n\t\tif (BTCToSend > 0)\r\n\t\t\tRefundBTC(backers[_from].btc_address ,BTCToSend);\t\t\t// event message to manually refund BTC\r\n\t}\r\n\r\n\t/*\r\n\t* Update the rate RLC per ETH, computed externally by using the ETHBTC index on kraken every 10min\r\n\t*/\r\n\tfunction setRLCPerETH(uint rate) onlyBy(BTCproxy) {\r\n\t\tRLCPerETH=rate;\r\n\t}\r\n\t\r\n\t/*\t\r\n\t* Finalize the crowdsale, should be called after the refund period\r\n\t*/\r\n\tfunction finalize() onlyBy(owner) {\r\n\t\t// check\r\n\t\tif (RLCSentToETH + RLCSentToBTC < maxCap - 5000000000000 && now < endBlock) throw;\t// cannot finalise before 30 day until maxcap is reached minus 1BTC\r\n\t\tif (RLCSentToETH + RLCSentToBTC < minCap && now < endBlock + 15 days) throw ;\t\t// if mincap is not reached donors have 15days to get refund before we can finalise\r\n\t\tif (!multisigETH.send(this.balance)) throw;\t\t\t\t\t\t\t\t\t\t\t// moves the remaining ETH to the multisig address\r\n\t\tif (rlc_reserve > 6000000000000000){\t\t\t\t\t\t\t\t\t\t\t\t// moves RLC to the team, reserve and bounty address\r\n\t\t\tif(!rlc.transfer(reserve,6000000000000000)) throw;\t\t\t\t\t\t\t\t// max cap 6000000RLC\r\n\t\t\trlc_reserve = 6000000000000000;\r\n\t\t} else {\r\n\t\t\tif(!rlc.transfer(reserve,rlc_reserve)) throw;  \r\n\t\t}\r\n\t\tif (rlc_bounty > 6000000000000000){\r\n\t\t\tif(!rlc.transfer(bounty,6000000000000000)) throw;\t\t\t\t\t\t\t\t// max cap 6000000RLC\r\n\t\t\trlc_bounty = 6000000000000000;\r\n\t\t} else {\r\n\t\t\tif(!rlc.transfer(bounty,rlc_bounty)) throw;\r\n\t\t}\r\n\t\tif (!rlc.transfer(team,rlc_team)) throw;\r\n\t\tuint RLCEmitted = rlc_reserve + rlc_bounty + rlc_team + RLCSentToBTC + RLCSentToETH;\r\n\t\tif (RLCEmitted < rlc.totalSupply())\t\t\t\t\t\t\t\t\t\t\t\t\t// burn the rest of RLC\r\n\t\t\t  rlc.burn(rlc.totalSupply() - RLCEmitted);\r\n\t\trlc.unlock();\r\n\t\tcrowdsaleClosed = true;\r\n\t}\r\n\r\n\t/*\t\r\n\t* Failsafe drain\r\n\t*/\r\n\tfunction drain() onlyBy(owner) {\r\n\t\tif (!owner.send(this.balance)) throw;\r\n\t}\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"initialSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unlock\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_extraData\",\"type\":\"bytes\"}],\"name\":\"approveAndCall\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"locked\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"RLC","CompilerVersion":"v0.4.12+commit.194ff033","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://663fae0502006a8c744274ff13aa9047a951788032dc9aec964d87b5ad3a6338"}]}