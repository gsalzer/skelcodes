{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.24;\r\n\r\n/**\r\n * @title LinkedListLib\r\n * @author Darryl Morris (o0ragman0o) and Modular.network\r\n *\r\n * This utility library was forked from https://github.com/o0ragman0o/LibCLL\r\n * into the Modular-Network ethereum-libraries repo at https://github.com/Modular-Network/ethereum-libraries\r\n * It has been updated to add additional functionality and be more compatible with solidity 0.4.18\r\n * coding patterns.\r\n *\r\n * version 1.1.1\r\n * Copyright (c) 2017 Modular Inc.\r\n * The MIT License (MIT)\r\n * https://github.com/Modular-network/ethereum-libraries/blob/master/LICENSE\r\n *\r\n * The LinkedListLib provides functionality for implementing data indexing using\r\n * a circlular linked list\r\n *\r\n * Modular provides smart contract services and security reviews for contract\r\n * deployments in addition to working on open source projects in the Ethereum\r\n * community. Our purpose is to test, document, and deploy reusable code onto the\r\n * blockchain and improve both security and usability. We also educate non-profits,\r\n * schools, and other community members about the application of blockchain\r\n * technology. For further information: modular.network\r\n *\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\r\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\r\n * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\r\n * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\r\n * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\r\n * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n*/\r\n\r\n\r\nlibrary LinkedListLib {\r\n\r\n    uint256 constant NULL = 0;\r\n    uint256 constant HEAD = 0;\r\n    bool constant PREV = false;\r\n    bool constant NEXT = true;\r\n\r\n    struct LinkedList{\r\n        mapping (uint256 => mapping (bool => uint256)) list;\r\n    }\r\n\r\n    /// @dev returns true if the list exists\r\n    /// @param self stored linked list from contract\r\n    function listExists(LinkedList storage self)\r\n        public\r\n        view returns (bool)\r\n    {\r\n        // if the head nodes previous or next pointers both point to itself, then there are no items in the list\r\n        if (self.list[HEAD][PREV] != HEAD || self.list[HEAD][NEXT] != HEAD) {\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /// @dev returns true if the node exists\r\n    /// @param self stored linked list from contract\r\n    /// @param _node a node to search for\r\n    function nodeExists(LinkedList storage self, uint256 _node)\r\n        public\r\n        view returns (bool)\r\n    {\r\n        if (self.list[_node][PREV] == HEAD && self.list[_node][NEXT] == HEAD) {\r\n            if (self.list[HEAD][NEXT] == _node) {\r\n                return true;\r\n            } else {\r\n                return false;\r\n            }\r\n        } else {\r\n            return true;\r\n        }\r\n    }\r\n\r\n    /// @dev Returns the number of elements in the list\r\n    /// @param self stored linked list from contract\r\n    function sizeOf(LinkedList storage self) public view returns (uint256 numElements) {\r\n        bool exists;\r\n        uint256 i;\r\n        (exists,i) = getAdjacent(self, HEAD, NEXT);\r\n        while (i != HEAD) {\r\n            (exists,i) = getAdjacent(self, i, NEXT);\r\n            numElements++;\r\n        }\r\n        return;\r\n    }\r\n\r\n    /// @dev Returns the links of a node as a tuple\r\n    /// @param self stored linked list from contract\r\n    /// @param _node id of the node to get\r\n    function getNode(LinkedList storage self, uint256 _node)\r\n        public view returns (bool,uint256,uint256)\r\n    {\r\n        if (!nodeExists(self,_node)) {\r\n            return (false,0,0);\r\n        } else {\r\n            return (true,self.list[_node][PREV], self.list[_node][NEXT]);\r\n        }\r\n    }\r\n\r\n    /// @dev Returns the link of a node `_node` in direction `_direction`.\r\n    /// @param self stored linked list from contract\r\n    /// @param _node id of the node to step from\r\n    /// @param _direction direction to step in\r\n    function getAdjacent(LinkedList storage self, uint256 _node, bool _direction)\r\n        public view returns (bool,uint256)\r\n    {\r\n        if (!nodeExists(self,_node)) {\r\n            return (false,0);\r\n        } else {\r\n            return (true,self.list[_node][_direction]);\r\n        }\r\n    }\r\n\r\n    /// @dev Can be used before `insert` to build an ordered list\r\n    /// @param self stored linked list from contract\r\n    /// @param _node an existing node to search from, e.g. HEAD.\r\n    /// @param _value value to seek\r\n    /// @param _direction direction to seek in\r\n    //  @return next first node beyond '_node' in direction `_direction`\r\n    function getSortedSpot(LinkedList storage self, uint256 _node, uint256 _value, bool _direction)\r\n        public view returns (uint256)\r\n    {\r\n        if (sizeOf(self) == 0) { return 0; }\r\n        require((_node == 0) || nodeExists(self,_node));\r\n        bool exists;\r\n        uint256 next;\r\n        (exists,next) = getAdjacent(self, _node, _direction);\r\n        while  ((next != 0) && (_value != next) && ((_value < next) != _direction)) next = self.list[next][_direction];\r\n        return next;\r\n    }\r\n\r\n    /// @dev Creates a bidirectional link between two nodes on direction `_direction`\r\n    /// @param self stored linked list from contract\r\n    /// @param _node first node for linking\r\n    /// @param _link  node to link to in the _direction\r\n    function createLink(LinkedList storage self, uint256 _node, uint256 _link, bool _direction) private  {\r\n        self.list[_link][!_direction] = _node;\r\n        self.list[_node][_direction] = _link;\r\n    }\r\n\r\n    /// @dev Insert node `_new` beside existing node `_node` in direction `_direction`.\r\n    /// @param self stored linked list from contract\r\n    /// @param _node existing node\r\n    /// @param _new  new node to insert\r\n    /// @param _direction direction to insert node in\r\n    function insert(LinkedList storage self, uint256 _node, uint256 _new, bool _direction) internal returns (bool) {\r\n        if(!nodeExists(self,_new) && nodeExists(self,_node)) {\r\n            uint256 c = self.list[_node][_direction];\r\n            createLink(self, _node, _new, _direction);\r\n            createLink(self, _new, c, _direction);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /// @dev removes an entry from the linked list\r\n    /// @param self stored linked list from contract\r\n    /// @param _node node to remove from the list\r\n    function remove(LinkedList storage self, uint256 _node) internal returns (uint256) {\r\n        if ((_node == NULL) || (!nodeExists(self,_node))) { return 0; }\r\n        createLink(self, self.list[_node][PREV], self.list[_node][NEXT], NEXT);\r\n        delete self.list[_node][PREV];\r\n        delete self.list[_node][NEXT];\r\n        return _node;\r\n    }\r\n\r\n    /// @dev pushes an enrty to the head of the linked list\r\n    /// @param self stored linked list from contract\r\n    /// @param _node new entry to push to the head\r\n    /// @param _direction push to the head (NEXT) or tail (PREV)\r\n    function push(LinkedList storage self, uint256 _node, bool _direction) internal  {\r\n        insert(self, HEAD, _node, _direction);\r\n    }\r\n\r\n    /// @dev pops the first entry from the linked list\r\n    /// @param self stored linked list from contract\r\n    /// @param _direction pop from the head (NEXT) or the tail (PREV)\r\n    function pop(LinkedList storage self, bool _direction) internal returns (uint256) {\r\n        bool exists;\r\n        uint256 adj;\r\n\r\n        (exists,adj) = getAdjacent(self, HEAD, _direction);\r\n\r\n        return remove(self, adj);\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"self\",\"type\":\"LinkedListLib.LinkedList storage\"},{\"name\":\"_node\",\"type\":\"uint256\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_direction\",\"type\":\"bool\"}],\"name\":\"getSortedSpot\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"self\",\"type\":\"LinkedListLib.LinkedList storage\"}],\"name\":\"listExists\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"self\",\"type\":\"LinkedListLib.LinkedList storage\"},{\"name\":\"_node\",\"type\":\"uint256\"},{\"name\":\"_direction\",\"type\":\"bool\"}],\"name\":\"getAdjacent\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"self\",\"type\":\"LinkedListLib.LinkedList storage\"}],\"name\":\"sizeOf\",\"outputs\":[{\"name\":\"numElements\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"self\",\"type\":\"LinkedListLib.LinkedList storage\"},{\"name\":\"_node\",\"type\":\"uint256\"}],\"name\":\"getNode\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"self\",\"type\":\"LinkedListLib.LinkedList storage\"},{\"name\":\"_node\",\"type\":\"uint256\"}],\"name\":\"nodeExists\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"LinkedListLib","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://c46855bcc5640424d42853c424c0ced61de7419375ddf6859413745fa9d6985f"}]}