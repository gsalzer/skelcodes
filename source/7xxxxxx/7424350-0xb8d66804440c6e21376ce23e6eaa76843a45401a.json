{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.5.3; /*\r\n\r\n___________________________________________________________________\r\n  _      _                                        ______           \r\n  |  |  /          /                                /              \r\n--|-/|-/-----__---/----__----__---_--_----__-------/-------__------\r\n  |/ |/    /___) /   /   ' /   ) / /  ) /___)     /      /   )     \r\n__/__|____(___ _/___(___ _(___/_/_/__/_(___ _____/______(___/__o_o_\r\n\r\n\r\n\r\n██████╗ ███████╗██████╗  ██████╗ ███████╗██╗████████╗ ██████╗ ██╗  ██╗███████╗███╗   ██╗\r\n██╔══██╗██╔════╝██╔══██╗██╔═══██╗██╔════╝██║╚══██╔══╝██╔═══██╗██║ ██╔╝██╔════╝████╗  ██║\r\n██║  ██║█████╗  ██████╔╝██║   ██║███████╗██║   ██║   ██║   ██║█████╔╝ █████╗  ██╔██╗ ██║\r\n██║  ██║██╔══╝  ██╔═══╝ ██║   ██║╚════██║██║   ██║   ██║   ██║██╔═██╗ ██╔══╝  ██║╚██╗██║\r\n██████╔╝███████╗██║     ╚██████╔╝███████║██║   ██║   ╚██████╔╝██║  ██╗███████╗██║ ╚████║\r\n╚═════╝ ╚══════╝╚═╝      ╚═════╝ ╚══════╝╚═╝   ╚═╝    ╚═════╝ ╚═╝  ╚═╝╚══════╝╚═╝  ╚═══╝\r\n                                                                                        \r\n\r\n\r\n\r\n// ----------------------------------------------------------------------------\r\n// 'DeposiToken (DT10)' contract with following functionalities:\r\n//      => Higher control of owner\r\n//      => SafeMath implementation \r\n//      => Referral system - 3 level\r\n//\r\n// Name             : DeposiToken\r\n// Symbol           : DT10\r\n// Decimals         : 15\r\n//\r\n// Copyright (c) 2018 FIRST DECENTRALIZED DEPOSIT PLATFORM ( https://fddp.io )\r\n// Contract designed by: EtherAuthority ( https://EtherAuthority.io ) \r\n// ----------------------------------------------------------------------------\r\n*/ \r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n    \r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function subsafe(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if(b <= a){\r\n        return a - b;\r\n    }else{\r\n        return 0;\r\n    }\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n  \r\n}\r\n\r\n\r\ncontract DepositToken_10 {\r\n    \r\n    using SafeMath for uint;\r\n    \r\n    string public constant name = \"DeposiToken\";\r\n    \r\n    string public constant symbol = \"DT10\";\r\n    \r\n    uint32 public constant decimals = 15;\r\n    \r\n    uint public _money = 0;\r\n    uint public _tokens = 0;\r\n    uint public _sellprice;\r\n    \r\n    // Адрес контракта Акций\r\n    address payable public theStocksTokenContract;\r\n    \r\n    // сохранить баланс на счетах пользователя\r\n    \r\n    mapping (address => uint) private balances;\r\n    \r\n    event FullEventLog(\r\n        address indexed user,\r\n        bytes32 status,\r\n        uint sellprice,\r\n        uint buyprice, \r\n        uint time,\r\n        uint tokens,\r\n        uint ethers);\r\n        \r\n    \r\n    event Transfer(\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256 value);\r\n        \r\n    // OK\r\n    constructor (address payable _tstc) public {\r\n        uint s = 10**13; // start price\r\n        _sellprice = s.mul(90).div(100);\r\n        theStocksTokenContract = _tstc;\r\n        \r\n        /* 1000 token belongs to the contract */\r\n        uint _value = 1000 * 10**15; \r\n        \r\n        _tokens += _value;\r\n        balances[address(this)] += _value;\r\n        \r\n        emit Transfer(address(0x0), address(this), _value);\r\n    }\r\n    \r\n    // OK\r\n    function totalSupply () public view returns (uint256 tokens) {\r\n        return _tokens;\r\n    }\r\n    \r\n    // OK\r\n    function balanceOf(address addr) public view returns(uint){\r\n        return balances[addr];\r\n    }\r\n    \r\n    // OK\r\n    function transfer(address _to, uint256 _value) public returns (bool success) {\r\n        address addressContract = address(this);\r\n        require(_to == addressContract);\r\n        sell(_value);\r\n        success = true;\r\n    }\r\n    \r\n    // OK\r\n    function () external payable {\r\n        buy(address(0x0));\r\n    }\r\n    \r\n    \r\n    //***************************************************//\r\n    //--------------- REFERAL SYSTEM CODE ---------------//\r\n    //***************************************************//\r\n    \r\n    /** TECHNICAL SPECIFICATIONS\r\n     * \r\n     * Because this is multi-level (3 level) referral system, we have to fix referrals.\r\n     * Which means once a user is fixed under someone as referral, then that can not be changed.\r\n     * Referral will be fixed at their first deposit.\r\n     * This also means. If a person have used referral link to deposit and got fixed. Then if he does not use any links to deposit again, referral bonus paid to their referrers.\r\n     * \r\n     * \r\n     * USE CASES\r\n     * \r\n     * Case 1: depositor have used referral links, as well as depositor has existing direct referrer.\r\n     * In this case, ether will be sent to existing referrer, it will ignore the new link he used.\r\n     * \r\n     * Case 2: depositor has existing referrer/up-line/direct sponsor, but he did not use any referrer link or sent ether directly to smart contract.\r\n     * In this case, ether will be sent to existing referrer.\r\n     * \r\n     * Case 3: depositor does not have any existing direct referrer, but used referral link.\r\n     * In this case, referral bonus will be paid to address in the referral link.\r\n     * \r\n     * All other cases apart from above, referral bonus will not be paid to anyone.\r\n     * And Entire platform fee (5% of deposit) will be sent to stock contract.\r\n     */\r\n    \r\n    /* Mapping to track referrer. The second address is the address of referrer, the Up-line/ Sponsor */\r\n    mapping (address => address payable) public referrers;\r\n    \r\n    /* Mapping to track referrer bonus for all the referrers */\r\n    mapping (address => uint) public referrerBonusBalance;\r\n    \r\n    /* Events to track ether transfer to referrers */\r\n    event ReferrerBonus(address indexed referer, address indexed depositor, uint256 depositAmount , uint256 etherReceived, uint256 timestamp );\r\n    \r\n    /* Events to track referral bonus claims */\r\n    event ReferralBonusClaim(address indexed referrar, uint256 bonus, uint256 timestamp);\r\n    /* Function to distribute bonuses to referrers, as well as calculating finaPlatformFee */\r\n    function distributeReferrerBonus(address payable _directReferrer, uint platformFee) internal returns (uint){\r\n        \r\n        // 60% of the Platform fee will be distributed to referrers, which is 3% of deposited ether\r\n        uint finaPlatformFee = platformFee;\r\n        \r\n        // Sending ether to level 1 (direct) referrer and deducting that amount from platformFee\r\n        uint _valueLevel1 = platformFee.mul(40).div(100);\r\n        referrerBonusBalance[_directReferrer] += _valueLevel1;  //40% of Platform Fee, equivilent to 2% of deposited ether\r\n        finaPlatformFee = finaPlatformFee.sub(_valueLevel1);\r\n        emit ReferrerBonus(_directReferrer, msg.sender, msg.value , _valueLevel1, now );\r\n    \r\n        \r\n        // If there is level 2 referrer, then sending ether to him/her as well\r\n        if(referrers[_directReferrer] != address(0x0)){\r\n            // Sending ether to level 2 referrer and deducting that amount from platformFee\r\n            uint _valueLevel2 = platformFee.mul(10).div(100);\r\n            referrerBonusBalance[referrers[_directReferrer]] += _valueLevel2;  //10% of Platform Fee, equivilent to 0.5% of deposited ether\r\n            finaPlatformFee = finaPlatformFee.sub(_valueLevel2);\r\n            emit ReferrerBonus(referrers[_directReferrer], msg.sender, msg.value , _valueLevel2, now );\r\n        }\r\n        \r\n        // If there is level 3 referrer, then sending ether to him/her as well\r\n        if(referrers[referrers[_directReferrer]] != address(0x0)){\r\n            // Sending ether to level 2 referrer and deducting that amount from platformFee\r\n            uint _valueLevel3 = platformFee.mul(10).div(100);\r\n            referrerBonusBalance[referrers[referrers[_directReferrer]]] += _valueLevel3;  //10% of Platform Fee, equivilent to 0.5% of deposited ether\r\n            finaPlatformFee = finaPlatformFee.sub(_valueLevel3);\r\n            emit ReferrerBonus(referrers[referrers[_directReferrer]], msg.sender, msg.value , _valueLevel3, now );\r\n        }\r\n        \r\n        // Returns final platform fee which would be sent to stock contract\r\n        return finaPlatformFee;\r\n    }\r\n    \r\n    /* Function will allow users to withdraw their referrer bonus  */\r\n    function claimReferrerBonus() public {\r\n        uint256 referralBonus = referrerBonusBalance[msg.sender];\r\n        require(referralBonus > 0, 'Insufficient referrer bonus');\r\n        referrerBonusBalance[msg.sender] = 0;\r\n        msg.sender.transfer(referralBonus);\r\n        emit ReferralBonusClaim(msg.sender,referralBonus,now);\r\n    }\r\n    \r\n    \r\n    // OK\r\n    function buy(address payable _referrer) public payable {\r\n        uint _value = msg.value.mul(10**15).div(_sellprice.mul(100).div(90));\r\n        \r\n        // общий баланс Эфиров на контракте\r\n        _money = _money.add(msg.value.mul(95).div(100));\r\n        \r\n        // Platform fee - 5% of the ether deposit\r\n        uint platformFee = msg.value.mul(50).div(1000);\r\n        \r\n        // Final platform Fee, is after all the referrer payout deductions (as many as applicable).\r\n        uint finaPlatformFee; \r\n        \r\n        \r\n        /** Processing referral system fund distribution **/\r\n        // Case 1: depositor have used referral links, as well as depositor has existing direct referrer\r\n        // In this case, ether will be sent to existing referrer, it will ignore the new link he used.\r\n        if(_referrer != address(0x0) && referrers[msg.sender] != address(0x0)){\r\n            finaPlatformFee = distributeReferrerBonus(referrers[msg.sender], platformFee);\r\n        }\r\n        \r\n        // Case 2: depositor has existing referrer/up-line/direct sponsor, but he did not use any referrer link or sent ether directly to smart contract\r\n        // In this case, ether will be sent to existing referrer\r\n        else if(_referrer == address(0x0) && referrers[msg.sender] != address(0x0)){\r\n            finaPlatformFee = distributeReferrerBonus(referrers[msg.sender], platformFee);\r\n        }\r\n        \r\n        // Case 3: depositor does not have any existing direct referrer, but used referral link\r\n        // In this case, referral bonus will be paid to address in the referral link\r\n        else if(_referrer != address(0x0) && referrers[msg.sender] == address(0x0)){\r\n            finaPlatformFee = distributeReferrerBonus(_referrer, platformFee);\r\n            //adding referral details in both the mappings\r\n            referrers[msg.sender]=_referrer;\r\n        }\r\n        \r\n        // All other cases apart from above, referral bonus will not be paid to anyone\r\n        // And Entire platform fee (5% of deposit) will be sent to stock contract\r\n        else {\r\n            finaPlatformFee = platformFee;\r\n        }\r\n        \r\n        // отправить прибыль на контракт собствеников системы\r\n        (bool success, ) =    theStocksTokenContract.call.value(finaPlatformFee).gas(53000)(\"\");\r\n        \r\n        // This checks if ether transfer to stock contract is successful, otherwise revert\r\n        require(success, 'Ether transfer to DA Token contract failed');\r\n        \r\n        // всего токенов в системе\r\n        _tokens = _tokens.add(_value);\r\n        \r\n        // добавить токены, на баланс пользователя\r\n        balances[msg.sender] = balances[msg.sender].add(_value);\r\n        \r\n        // Логируем событие с курсом / датой / \r\n        emit FullEventLog(msg.sender, \"buy\", _sellprice, _sellprice.mul(100).div(90), now, _value, msg.value);\r\n        \r\n        _sellprice = _money.mul(10**15).mul(98).div(_tokens).div(100);\r\n        \r\n        \r\n        emit Transfer(address(this), msg.sender, _value);\r\n    }\r\n\r\n    // OK\r\n    function sell (uint256 countTokens) public {\r\n        // проверка на отрицательный баланс\r\n        require(balances[msg.sender] >= countTokens);\r\n        \r\n        uint _value = countTokens.mul(_sellprice).div(10**15);\r\n        \r\n        _money = _money.sub(_value);\r\n        \r\n        _tokens = _tokens.subsafe(countTokens);\r\n        \r\n        balances[msg.sender] = balances[msg.sender].subsafe(countTokens);\r\n        \r\n        emit FullEventLog(msg.sender, \"sell\", _sellprice, _sellprice.mul(100).div(90), now, countTokens, _value);\r\n        \r\n        if(_tokens > 0) {\r\n            _sellprice = _money.mul(10**15).mul(98).div(_tokens).div(100);\r\n        }\r\n\r\n    \temit Transfer(msg.sender, address(this), countTokens);\r\n        msg.sender.transfer(_value);\r\n    }\r\n    // OK\r\n    function getPrice() public view returns (uint bid, uint ask) {\r\n        bid = _sellprice.mul(100).div(90);\r\n        ask = _sellprice;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"tokens\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"referrers\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_money\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"theStocksTokenContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"referrerBonusBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_tokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getPrice\",\"outputs\":[{\"name\":\"bid\",\"type\":\"uint256\"},{\"name\":\"ask\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claimReferrerBonus\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_sellprice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"countTokens\",\"type\":\"uint256\"}],\"name\":\"sell\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_referrer\",\"type\":\"address\"}],\"name\":\"buy\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_tstc\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"status\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"sellprice\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"buyprice\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"time\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"ethers\",\"type\":\"uint256\"}],\"name\":\"FullEventLog\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"referer\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"depositor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"depositAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"etherReceived\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"ReferrerBonus\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"referrar\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"bonus\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"ReferralBonusClaim\",\"type\":\"event\"}]","ContractName":"DepositToken_10","CompilerVersion":"v0.5.3+commit.10d17f24","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000003896fcffff3a48c24ad1b2c2a0ba9e9a32ae982d","Library":"","SwarmSource":"bzzr://fd27ea9a87d53314e16cb832560095d743e933be5136a7bd0795143656240c79"}]}