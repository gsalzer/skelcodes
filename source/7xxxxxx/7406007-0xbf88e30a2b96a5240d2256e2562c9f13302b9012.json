{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.5.6;\r\n\r\n/*\r\n* @dev Crowdsal contract\r\n*/\r\ncontract Sale {\r\n\r\n    GameWave public GWContract;\r\n    uint256 public buyPrice;\r\n    address public owner;\r\n    uint balance;\r\n\r\n    bool crowdSaleClosed = false;\r\n\r\n    constructor(\r\n        address payable _GWContract\r\n    ) payable public {\r\n        owner = msg.sender;\r\n        GWContract = GameWave(_GWContract);\r\n        GWContract.approve(owner, 9999999999999999999000000000000000000);\r\n    }\r\n\r\n    /**\r\n     * @notice Allow users to buy tokens for `newBuyPrice`\r\n     * @param newBuyPrice Price users can buy from the contract.\r\n     */\r\n\r\n    function setPrice(uint256 newBuyPrice) public {\r\n        buyPrice = newBuyPrice;\r\n    }\r\n\r\n    /**\r\n     * Fallback function\r\n     *\r\n     * The function without name is the default function that is called whenever anyone sends funds to a contract and\r\n     * sends tokens to the buyer.\r\n     */\r\n\r\n    function () payable external {\r\n        uint amount = msg.value;\r\n        balance = (amount / buyPrice) * 10 ** 18;\r\n        GWContract.transfer(msg.sender, balance);\r\n        address(GWContract).transfer(amount);\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ninterface IERC20 {\r\n  function totalSupply() external view returns (uint256);\r\n\r\n  function balanceOf(address who) external view returns (uint256);\r\n\r\n  function allowance(address owner, address spender)\r\n  external view returns (uint256);\r\n\r\n  function transfer(address to, uint256 value) external returns (bool);\r\n\r\n  function approve(address spender, uint256 value)\r\n  external returns (bool);\r\n\r\n  function transferFrom(address from, address to, uint256 value)\r\n  external returns (bool);\r\n\r\n  event Transfer(\r\n    address indexed from,\r\n    address indexed to,\r\n    uint256 value\r\n  );\r\n\r\n  event Approval(\r\n    address indexed owner,\r\n    address indexed spender,\r\n    uint256 value\r\n  );\r\n}\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Unsigned math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n  /**\r\n   * @dev Multiplies two unsigned integers, reverts on overflow.\r\n   */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    uint256 c = a * b;\r\n    require(c / a == b);\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n   * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\r\n   */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // Solidity only automatically asserts when dividing by 0\r\n    require(b > 0);\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n   * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n   */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b <= a);\r\n    uint256 c = a - b;\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n   * @dev Adds two unsigned integers, reverts on overflow.\r\n   */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    require(c >= a);\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n   * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\r\n   * reverts when dividing by zero.\r\n   */\r\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b != 0);\r\n    return a % b;\r\n  }\r\n}\r\n\r\n/**\r\n * @title Standard ERC20 token\r\n *\r\n * @dev Implementation of the basic standard token.\r\n * https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md\r\n * Originally based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\r\n */\r\ncontract ERC20 is IERC20 {\r\n  using SafeMath for uint256;\r\n\r\n  mapping (address => uint256) private _balances;\r\n\r\n  mapping (address => mapping (address => uint256)) private _allowed;\r\n\r\n  uint256 private _totalSupply;\r\n\r\n  /**\r\n  * @dev Total number of tokens in existence\r\n  */\r\n  function totalSupply() public view returns (uint256) {\r\n    return _totalSupply;\r\n  }\r\n\r\n  /**\r\n  * @dev Gets the balance of the specified address.\r\n  * @param owner The address to query the balance of.\r\n  * @return An uint256 representing the amount owned by the passed address.\r\n  */\r\n  function balanceOf(address owner) public view returns (uint256) {\r\n    return _balances[owner];\r\n  }\r\n\r\n  /**\r\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n   * @param owner address The address which owns the funds.\r\n   * @param spender address The address which will spend the funds.\r\n   * @return A uint256 specifying the amount of tokens still available for the spender.\r\n   */\r\n  function allowance(\r\n    address owner,\r\n    address spender\r\n  )\r\n  public\r\n  view\r\n  returns (uint256)\r\n  {\r\n    return _allowed[owner][spender];\r\n  }\r\n\r\n  /**\r\n  * @dev Transfer token for a specified address\r\n  * @param to The address to transfer to.\r\n  * @param value The amount to be transferred.\r\n  */\r\n  function transfer(address to, uint256 value) public returns (bool) {\r\n    _transfer(msg.sender, to, value);\r\n\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\r\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\r\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\r\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n   * @param spender The address which will spend the funds.\r\n   * @param value The amount of tokens to be spent.\r\n   */\r\n  function approve(address spender, uint256 value) public returns (bool) {\r\n    require(spender != address(0));\r\n\r\n    _allowed[msg.sender][spender] = value;\r\n\r\n    emit Approval(msg.sender, spender, value);\r\n\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Transfer tokens from one address to another\r\n   * @param from address The address which you want to send tokens from\r\n   * @param to address The address which you want to transfer to\r\n   * @param value uint256 the amount of tokens to be transferred\r\n   */\r\n  function transferFrom(\r\n    address from,\r\n    address to,\r\n    uint256 value\r\n  )\r\n  public\r\n  returns (bool)\r\n  {\r\n    _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);\r\n    _transfer(from, to, value);\r\n\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Increase the amount of tokens that an owner allowed to a spender.\r\n   * approve should be called when allowed_[_spender] == 0. To increment\r\n   * allowed value is better to use this function to avoid 2 calls (and wait until\r\n   * the first transaction is mined)\r\n   * From MonolithDAO Token.sol\r\n   * @param spender The address which will spend the funds.\r\n   * @param addedValue The amount of tokens to increase the allowance by.\r\n   */\r\n  function increaseAllowance(\r\n    address spender,\r\n    uint256 addedValue\r\n  )\r\n  public\r\n  returns (bool)\r\n  {\r\n    require(spender != address(0));\r\n\r\n    _allowed[msg.sender][spender] = (\r\n    _allowed[msg.sender][spender].add(addedValue));\r\n\r\n    emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\r\n\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Decrease the amount of tokens that an owner allowed to a spender.\r\n   * approve should be called when allowed_[_spender] == 0. To decrement\r\n   * allowed value is better to use this function to avoid 2 calls (and wait until\r\n   * the first transaction is mined)\r\n   * From MonolithDAO Token.sol\r\n   * @param spender The address which will spend the funds.\r\n   * @param subtractedValue The amount of tokens to decrease the allowance by.\r\n   */\r\n  function decreaseAllowance(\r\n    address spender,\r\n    uint256 subtractedValue\r\n  )\r\n  public\r\n  returns (bool)\r\n  {\r\n    require(spender != address(0));\r\n\r\n    _allowed[msg.sender][spender] = (\r\n    _allowed[msg.sender][spender].sub(subtractedValue));\r\n\r\n    emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\r\n\r\n    return true;\r\n  }\r\n\r\n  /**\r\n  * @dev Transfer token for a specified addresses\r\n  * @param from The address to transfer from.\r\n  * @param to The address to transfer to.\r\n  * @param value The amount to be transferred.\r\n  */\r\n  function _transfer(address from, address to, uint256 value) internal {\r\n    require(to != address(0));\r\n\r\n    _balances[from] = _balances[from].sub(value);\r\n    _balances[to] = _balances[to].add(value);\r\n\r\n    emit Transfer(from, to, value);\r\n  }\r\n\r\n  /**\r\n   * @dev Internal function that mints an amount of the token and assigns it to\r\n   * an account. This encapsulates the modification of balances such that the\r\n   * proper events are emitted.\r\n   * @param account The account that will receive the created tokens.\r\n   * @param value The amount that will be created.\r\n   */\r\n  function _mint(address account, uint256 value) internal {\r\n    require(account != address(0));\r\n\r\n    _totalSupply = _totalSupply.add(value);\r\n    _balances[account] = _balances[account].add(value);\r\n\r\n    emit Transfer(address(0), account, value);\r\n  }\r\n\r\n  /**\r\n   * @dev Internal function that burns an amount of the token of a given\r\n   * account.\r\n   * @param account The account whose tokens will be burnt.\r\n   * @param value The amount that will be burnt.\r\n   */\r\n  function _burn(address account, uint256 value) internal {\r\n    require(account != address(0));\r\n\r\n    _totalSupply = _totalSupply.sub(value);\r\n    _balances[account] = _balances[account].sub(value);\r\n\r\n    emit Transfer(account, address(0), value);\r\n  }\r\n\r\n  /**\r\n   * @dev Internal function that burns an amount of the token of a given\r\n   * account, deducting from the sender's allowance for said account. Uses the\r\n   * internal burn function.\r\n   * @param account The account whose tokens will be burnt.\r\n   * @param value The amount that will be burnt.\r\n   */\r\n  function _burnFrom(address account, uint256 value) internal {\r\n    // Should https://github.com/OpenZeppelin/zeppelin-solidity/issues/707 be accepted,\r\n    // this function needs to emit an event with the updated approval.\r\n    _allowed[account][msg.sender] = _allowed[account][msg.sender].sub(\r\n      value);\r\n    _burn(account, value);\r\n  }\r\n}\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure.\r\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n\r\n  using SafeMath for uint256;\r\n\r\n  function safeTransfer(\r\n    IERC20 token,\r\n    address to,\r\n    uint256 value\r\n  )\r\n  internal\r\n  {\r\n    require(token.transfer(to, value));\r\n  }\r\n\r\n  function safeTransferFrom(\r\n    IERC20 token,\r\n    address from,\r\n    address to,\r\n    uint256 value\r\n  )\r\n  internal\r\n  {\r\n    require(token.transferFrom(from, to, value));\r\n  }\r\n\r\n  function safeApprove(\r\n    IERC20 token,\r\n    address spender,\r\n    uint256 value\r\n  )\r\n  internal\r\n  {\r\n    // safeApprove should only be called when setting an initial allowance,\r\n    // or when resetting it to zero. To increase and decrease it, use\r\n    // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\r\n    require((value == 0) || (token.allowance(msg.sender, spender) == 0));\r\n    require(token.approve(spender, value));\r\n  }\r\n\r\n  function safeIncreaseAllowance(\r\n    IERC20 token,\r\n    address spender,\r\n    uint256 value\r\n  )\r\n  internal\r\n  {\r\n    uint256 newAllowance = token.allowance(address(this), spender).add(value);\r\n    require(token.approve(spender, newAllowance));\r\n  }\r\n\r\n  function safeDecreaseAllowance(\r\n    IERC20 token,\r\n    address spender,\r\n    uint256 value\r\n  )\r\n  internal\r\n  {\r\n    uint256 newAllowance = token.allowance(address(this), spender).sub(value);\r\n    require(token.approve(spender, newAllowance));\r\n  }\r\n}\r\n\r\n/**\r\n * @title ERC20Detailed token\r\n * @dev The decimals are only for visualization purposes.\r\n * All the operations are done using the smallest and indivisible token unit,\r\n * just as on Ethereum all the operations are done in wei.\r\n */\r\ncontract ERC20Detailed is IERC20 {\r\n  string private _name;\r\n  string private _symbol;\r\n  uint8 private _decimals;\r\n\r\n  constructor(string memory name, string memory symbol, uint8 decimals) public {\r\n    _name = name;\r\n    _symbol = symbol;\r\n    _decimals = decimals;\r\n  }\r\n\r\n  /**\r\n   * @return the name of the token.\r\n   */\r\n  function name() public view returns(string memory) {\r\n    return _name;\r\n  }\r\n\r\n  /**\r\n   * @return the symbol of the token.\r\n   */\r\n  function symbol() public view returns(string memory) {\r\n    return _symbol;\r\n  }\r\n\r\n  /**\r\n   * @return the number of decimals of the token.\r\n   */\r\n  function decimals() public view returns(uint8) {\r\n    return _decimals;\r\n  }\r\n}\r\n\r\ncontract Ownable {\r\n  address payable public owner;\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  constructor() public {\r\n    owner = msg.sender;\r\n  }\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n  function transferOwnership(address payable newOwner) public onlyOwner {\r\n    require(newOwner != address(0));\r\n    owner = newOwner;\r\n  }\r\n}\r\n\r\n\r\n\r\ncontract GameWave is ERC20, ERC20Detailed, Ownable {\r\n\r\n  uint paymentsTime = block.timestamp;\r\n  uint totalPaymentAmount;\r\n  uint lastTotalPaymentAmount;\r\n  uint minted = 20000000;\r\n\r\n  mapping (address => uint256) lastWithdrawTime;\r\n\r\n  /**\r\n   * @dev The GW constructor sets the original variables\r\n   * specified in the contract ERC20Detailed.\r\n   */\r\n  constructor() public ERC20Detailed(\"Game wave token\", \"GWT\", 18) {\r\n    _mint(msg.sender, minted * (10 ** uint256(decimals())));\r\n  }\r\n\r\n  /**\r\n    * Fallback function\r\n    *\r\n    * The function without name is the default function that is called whenever anyone sends funds to a contract.\r\n    */\r\n  function () payable external {\r\n    if (msg.value == 0){\r\n      withdrawDividends(msg.sender);\r\n    }\r\n  }\r\n\r\n  /**\r\n    * @notice This function allows the investor to see the amount of dividends available for withdrawal.\r\n    * @param _holder this is the address of the investor, where you can see the number of diverders available for withdrawal.\r\n    * @return An uint the value available for the removal of dividends.\r\n    */\r\n  function getDividends(address _holder) view public returns(uint) {\r\n    if (paymentsTime >= lastWithdrawTime[_holder]){\r\n      return totalPaymentAmount.mul(balanceOf(_holder)).div(minted * (10 ** uint256(decimals())));\r\n    } else {\r\n      return 0;\r\n    }\r\n  }\r\n\r\n  /**\r\n    * @notice This function allows the investor to withdraw dividends available for withdrawal.\r\n    * @param _holder this is the address of the investor, by which there is a withdrawal available to dividend.\r\n    * @return An uint value of removed dividends.\r\n    */\r\n  function withdrawDividends(address payable _holder) public returns(uint) {\r\n    uint dividends = getDividends(_holder);\r\n    lastWithdrawTime[_holder] = block.timestamp;\r\n    lastTotalPaymentAmount = lastTotalPaymentAmount.add(dividends);\r\n    _holder.transfer(dividends);\r\n  }\r\n\r\n  /**\r\n  * @notice This function initializes payments with a period of 30 days.\r\n  *\r\n  */\r\n\r\n  function startPayments() public {\r\n    require(block.timestamp >= paymentsTime + 30 days);\r\n    owner.transfer(totalPaymentAmount.sub(lastTotalPaymentAmount));\r\n    totalPaymentAmount = address(this).balance;\r\n    paymentsTime = block.timestamp;\r\n    lastTotalPaymentAmount = 0;\r\n  }\r\n}\r\n\r\n/*\r\n* @title Bank\r\n* @dev Bank contract which contained all ETH from Dragons and Hamsters teams.\r\n* When time in blockchain will be grater then current deadline or last deadline need call getWinner function\r\n* then participants able get prizes.\r\n*\r\n* Last participant(last hero) win 10% from all bank\r\n*\r\n* - To get prize send 0 ETH to this contract\r\n*/\r\ncontract Bank is Ownable {\r\n\r\n    using SafeMath for uint256;\r\n\r\n    mapping (uint256 => mapping (address => uint256)) public depositBears;\r\n    mapping (uint256 => mapping (address => uint256)) public depositBulls;\r\n\r\n    uint256 public currentDeadline;\r\n    uint256 public currentRound = 1;\r\n    uint256 public lastDeadline;\r\n    uint256 public defaultCurrentDeadlineInHours = 24;\r\n    uint256 public defaultLastDeadlineInHours = 48;\r\n    uint256 public countOfBears;\r\n    uint256 public countOfBulls;\r\n    uint256 public totalSupplyOfBulls;\r\n    uint256 public totalSupplyOfBears;\r\n    uint256 public totalGWSupplyOfBulls;\r\n    uint256 public totalGWSupplyOfBears;\r\n    uint256 public probabilityOfBulls;\r\n    uint256 public probabilityOfBears;\r\n    address public lastHero;\r\n    address public lastHeroHistory;\r\n    uint256 public jackPot;\r\n    uint256 public winner;\r\n    uint256 public withdrawn;\r\n    uint256 public withdrawnGW;\r\n    uint256 public remainder;\r\n    uint256 public remainderGW;\r\n    uint256 public rate = 1;\r\n    uint256 public rateModifier = 0;\r\n    uint256 public tokenReturn;\r\n    address crowdSale;\r\n\r\n    uint256 public lastTotalSupplyOfBulls;\r\n    uint256 public lastTotalSupplyOfBears;\r\n    uint256 public lastTotalGWSupplyOfBulls;\r\n    uint256 public lastTotalGWSupplyOfBears;\r\n    uint256 public lastProbabilityOfBulls;\r\n    uint256 public lastProbabilityOfBears;\r\n    address public lastRoundHero;\r\n    uint256 public lastJackPot;\r\n    uint256 public lastWinner;\r\n    uint256 public lastBalance;\r\n    uint256 public lastBalanceGW;\r\n    uint256 public lastCountOfBears;\r\n    uint256 public lastCountOfBulls;\r\n    uint256 public lastWithdrawn;\r\n    uint256 public lastWithdrawnGW;\r\n\r\n\r\n    bool public finished = false;\r\n\r\n    Bears public BearsContract;\r\n    Bulls public BullsContract;\r\n    GameWave public GameWaveContract;\r\n\r\n    /*\r\n    * @dev Constructor create first deadline\r\n    */\r\n    constructor(address _crowdSale) public {\r\n        _setRoundTime(6, 8);\r\n        crowdSale = _crowdSale;\r\n    }\r\n\r\n    /**\r\n    * @dev Setter token rate.\r\n    * @param _rate this value for change percent relation rate to count of tokens.\r\n    * @param _rateModifier this value for change math operation under tokens.\r\n    */\r\n    function setRateToken(uint256 _rate, uint256 _rateModifier) public onlyOwner returns(uint256){\r\n        rate = _rate;\r\n        rateModifier = _rateModifier;\r\n    }\r\n\r\n    /**\r\n    * @dev Setter crowd sale address.\r\n    * @param _crowdSale Address of the crowd sale contract.\r\n    */\r\n    function setCrowdSale(address _crowdSale) public onlyOwner{\r\n        crowdSale = _crowdSale;\r\n    }\r\n\r\n    /**\r\n    * @dev Setter round time.\r\n    * @param _currentDeadlineInHours this value current deadline in hours.\r\n    * @param _lastDeadlineInHours this value last deadline in hours.\r\n    */\r\n    function _setRoundTime(uint _currentDeadlineInHours, uint _lastDeadlineInHours) internal {\r\n        defaultCurrentDeadlineInHours = _currentDeadlineInHours;\r\n        defaultLastDeadlineInHours = _lastDeadlineInHours;\r\n        currentDeadline = block.timestamp + 60 * 60 * _currentDeadlineInHours;\r\n        lastDeadline = block.timestamp + 60 * 60 * _lastDeadlineInHours;\r\n    }\r\n\r\n    /**\r\n    * @dev Setter round time.\r\n    * @param _currentDeadlineInHours this value current deadline in hours.\r\n    * @param _lastDeadlineInHours this value last deadline in hours.\r\n    */\r\n    function setRoundTime(uint _currentDeadlineInHours, uint _lastDeadlineInHours) public onlyOwner {\r\n        _setRoundTime(_currentDeadlineInHours, _lastDeadlineInHours);\r\n    }\r\n\r\n\r\n    /**\r\n    * @dev Setter the GameWave contract address. Address can be set at once.\r\n    * @param _GameWaveAddress Address of the GameWave contract\r\n    */\r\n    function setGameWaveAddress(address payable _GameWaveAddress) public {\r\n        require(address(GameWaveContract) == address(0x0));\r\n        GameWaveContract = GameWave(_GameWaveAddress);\r\n    }\r\n\r\n    /**\r\n    * @dev Setter the Bears contract address. Address can be set at once.\r\n    * @param _bearsAddress Address of the Bears contract\r\n    */\r\n    function setBearsAddress(address payable _bearsAddress) external {\r\n        require(address(BearsContract) == address(0x0));\r\n        BearsContract = Bears(_bearsAddress);\r\n    }\r\n\r\n    /**\r\n    * @dev Setter the Bulls contract address. Address can be set at once.\r\n    * @param _bullsAddress Address of the Bulls contract\r\n    */\r\n    function setBullsAddress(address payable _bullsAddress) external {\r\n        require(address(BullsContract) == address(0x0));\r\n        BullsContract = Bulls(_bullsAddress);\r\n    }\r\n\r\n    /**\r\n    * @dev Getting time from blockchain for timer\r\n    */\r\n    function getNow() view public returns(uint){\r\n        return block.timestamp;\r\n    }\r\n\r\n    /**\r\n    * @dev Getting state of game. True - game continue, False - game stopped\r\n    */\r\n    function getState() view public returns(bool) {\r\n        if (block.timestamp > currentDeadline) {\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev Setting info about participant from Bears or Bulls contract\r\n    * @param _lastHero Address of participant\r\n    * @param _deposit Amount of deposit\r\n    */\r\n    function setInfo(address _lastHero, uint256 _deposit) public {\r\n        require(address(BearsContract) == msg.sender || address(BullsContract) == msg.sender);\r\n\r\n        if (address(BearsContract) == msg.sender) {\r\n            require(depositBulls[currentRound][_lastHero] == 0, \"You are already in bulls team\");\r\n            if (depositBears[currentRound][_lastHero] == 0)\r\n                countOfBears++;\r\n            totalSupplyOfBears = totalSupplyOfBears.add(_deposit.mul(90).div(100));\r\n            depositBears[currentRound][_lastHero] = depositBears[currentRound][_lastHero].add(_deposit.mul(90).div(100));\r\n        }\r\n\r\n        if (address(BullsContract) == msg.sender) {\r\n            require(depositBears[currentRound][_lastHero] == 0, \"You are already in bears team\");\r\n            if (depositBulls[currentRound][_lastHero] == 0)\r\n                countOfBulls++;\r\n            totalSupplyOfBulls = totalSupplyOfBulls.add(_deposit.mul(90).div(100));\r\n            depositBulls[currentRound][_lastHero] = depositBulls[currentRound][_lastHero].add(_deposit.mul(90).div(100));\r\n        }\r\n\r\n        lastHero = _lastHero;\r\n\r\n        if (currentDeadline.add(120) <= lastDeadline) {\r\n            currentDeadline = currentDeadline.add(120);\r\n        } else {\r\n            currentDeadline = lastDeadline;\r\n        }\r\n\r\n        jackPot += _deposit.mul(10).div(100);\r\n\r\n        calculateProbability();\r\n    }\r\n\r\n    function estimateTokenPercent(uint256 _difference) public view returns(uint256){\r\n        if (rateModifier == 0) {\r\n            return _difference.mul(rate);\r\n        } else {\r\n            return _difference.div(rate);\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Calculation probability for team's win\r\n    */\r\n    function calculateProbability() public {\r\n        require(winner == 0 && getState());\r\n\r\n        totalGWSupplyOfBulls = GameWaveContract.balanceOf(address(BullsContract));\r\n        totalGWSupplyOfBears = GameWaveContract.balanceOf(address(BearsContract));\r\n        uint256 percent = (totalSupplyOfBulls.add(totalSupplyOfBears)).div(100);\r\n\r\n        if (totalGWSupplyOfBulls < 1 ether) {\r\n            totalGWSupplyOfBulls = 0;\r\n        }\r\n\r\n        if (totalGWSupplyOfBears < 1 ether) {\r\n            totalGWSupplyOfBears = 0;\r\n        }\r\n\r\n        if (totalGWSupplyOfBulls <= totalGWSupplyOfBears) {\r\n            uint256 difference = totalGWSupplyOfBears.sub(totalGWSupplyOfBulls).div(0.01 ether);\r\n\r\n            probabilityOfBears = totalSupplyOfBears.mul(100).div(percent).add(estimateTokenPercent(difference));\r\n\r\n            if (probabilityOfBears > 8000) {\r\n                probabilityOfBears = 8000;\r\n            }\r\n            if (probabilityOfBears < 2000) {\r\n                probabilityOfBears = 2000;\r\n            }\r\n            probabilityOfBulls = 10000 - probabilityOfBears;\r\n        } else {\r\n            uint256 difference = totalGWSupplyOfBulls.sub(totalGWSupplyOfBears).div(0.01 ether);\r\n            probabilityOfBulls = totalSupplyOfBulls.mul(100).div(percent).add(estimateTokenPercent(difference));\r\n\r\n            if (probabilityOfBulls > 8000) {\r\n                probabilityOfBulls = 8000;\r\n            }\r\n            if (probabilityOfBulls < 2000) {\r\n                probabilityOfBulls = 2000;\r\n            }\r\n            probabilityOfBears = 10000 - probabilityOfBulls;\r\n        }\r\n\r\n        totalGWSupplyOfBulls = GameWaveContract.balanceOf(address(BullsContract));\r\n        totalGWSupplyOfBears = GameWaveContract.balanceOf(address(BearsContract));\r\n    }\r\n\r\n    /**\r\n    * @dev Getting winner team\r\n    */\r\n    function getWinners() public {\r\n        require(winner == 0 && !getState());\r\n        uint256 seed1 = address(this).balance;\r\n        uint256 seed2 = totalSupplyOfBulls;\r\n        uint256 seed3 = totalSupplyOfBears;\r\n        uint256 seed4 = totalGWSupplyOfBulls;\r\n        uint256 seed5 = totalGWSupplyOfBulls;\r\n        uint256 seed6 = block.difficulty;\r\n        uint256 seed7 = block.timestamp;\r\n\r\n        bytes32 randomHash = keccak256(abi.encodePacked(seed1, seed2, seed3, seed4, seed5, seed6, seed7));\r\n        uint randomNumber = uint(randomHash);\r\n\r\n        if (randomNumber == 0){\r\n            randomNumber = 1;\r\n        }\r\n\r\n        uint winningNumber = randomNumber % 10000;\r\n\r\n        if (1 <= winningNumber && winningNumber <= probabilityOfBears){\r\n            winner = 1;\r\n        }\r\n\r\n        if (probabilityOfBears < winningNumber && winningNumber <= 10000){\r\n            winner = 2;\r\n        }\r\n\r\n        if (GameWaveContract.balanceOf(address(BullsContract)) > 0)\r\n            GameWaveContract.transferFrom(\r\n                address(BullsContract),\r\n                address(this),\r\n                GameWaveContract.balanceOf(address(BullsContract))\r\n            );\r\n\r\n        if (GameWaveContract.balanceOf(address(BearsContract)) > 0)\r\n            GameWaveContract.transferFrom(\r\n                address(BearsContract),\r\n                address(this),\r\n                GameWaveContract.balanceOf(address(BearsContract))\r\n            );\r\n\r\n        lastTotalSupplyOfBulls = totalSupplyOfBulls;\r\n        lastTotalSupplyOfBears = totalSupplyOfBears;\r\n        lastTotalGWSupplyOfBears = totalGWSupplyOfBears;\r\n        lastTotalGWSupplyOfBulls = totalGWSupplyOfBulls;\r\n        lastRoundHero = lastHero;\r\n        lastJackPot = jackPot;\r\n        lastWinner = winner;\r\n        lastCountOfBears = countOfBears;\r\n        lastCountOfBulls = countOfBulls;\r\n        lastWithdrawn = withdrawn;\r\n        lastWithdrawnGW = withdrawnGW;\r\n\r\n        if (lastBalance > lastWithdrawn){\r\n            remainder = lastBalance.sub(lastWithdrawn);\r\n            address(GameWaveContract).transfer(remainder);\r\n        }\r\n\r\n        lastBalance = lastTotalSupplyOfBears.add(lastTotalSupplyOfBulls).add(lastJackPot);\r\n\r\n        if (lastBalanceGW > lastWithdrawnGW){\r\n            remainderGW = lastBalanceGW.sub(lastWithdrawnGW);\r\n            tokenReturn = (totalGWSupplyOfBears.add(totalGWSupplyOfBulls)).mul(20).div(100).add(remainderGW);\r\n            GameWaveContract.transfer(crowdSale, tokenReturn);\r\n        }\r\n\r\n        lastBalanceGW = GameWaveContract.balanceOf(address(this));\r\n\r\n        totalSupplyOfBulls = 0;\r\n        totalSupplyOfBears = 0;\r\n        totalGWSupplyOfBulls = 0;\r\n        totalGWSupplyOfBears = 0;\r\n        remainder = 0;\r\n        remainderGW = 0;\r\n        jackPot = 0;\r\n\r\n        withdrawn = 0;\r\n        winner = 0;\r\n        withdrawnGW = 0;\r\n        countOfBears = 0;\r\n        countOfBulls = 0;\r\n        probabilityOfBulls = 0;\r\n        probabilityOfBears = 0;\r\n\r\n        _setRoundTime(defaultCurrentDeadlineInHours, defaultLastDeadlineInHours);\r\n        currentRound++;\r\n    }\r\n\r\n    /**\r\n    * @dev Payable function for take prize\r\n    */\r\n    function () external payable {\r\n        if (msg.value == 0){\r\n            require(depositBears[currentRound - 1][msg.sender] > 0 || depositBulls[currentRound - 1][msg.sender] > 0);\r\n\r\n            uint payout = 0;\r\n            uint payoutGW = 0;\r\n\r\n            if (lastWinner == 1 && depositBears[currentRound - 1][msg.sender] > 0) {\r\n                payout = calculateLastETHPrize(msg.sender);\r\n            }\r\n            if (lastWinner == 2 && depositBulls[currentRound - 1][msg.sender] > 0) {\r\n                payout = calculateLastETHPrize(msg.sender);\r\n            }\r\n\r\n            if (payout > 0) {\r\n                depositBears[currentRound - 1][msg.sender] = 0;\r\n                depositBulls[currentRound - 1][msg.sender] = 0;\r\n                withdrawn = withdrawn.add(payout);\r\n                msg.sender.transfer(payout);\r\n            }\r\n\r\n            if ((lastWinner == 1 && depositBears[currentRound - 1][msg.sender] == 0) || (lastWinner == 2 && depositBulls[currentRound - 1][msg.sender] == 0)) {\r\n                payoutGW = calculateLastGWPrize(msg.sender);\r\n                withdrawnGW = withdrawnGW.add(payoutGW);\r\n                GameWaveContract.transfer(msg.sender, payoutGW);\r\n            }\r\n\r\n            if (msg.sender == lastRoundHero) {\r\n                lastHeroHistory = lastRoundHero;\r\n                lastRoundHero = address(0x0);\r\n                withdrawn = withdrawn.add(lastJackPot);\r\n                msg.sender.transfer(lastJackPot);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Getting ETH prize of participant\r\n    * @param participant Address of participant\r\n    */\r\n    function calculateETHPrize(address participant) public view returns(uint) {\r\n\r\n        uint payout = 0;\r\n        uint256 totalSupply = (totalSupplyOfBears.add(totalSupplyOfBulls));\r\n\r\n        if (depositBears[currentRound][participant] > 0) {\r\n            payout = totalSupply.mul(depositBears[currentRound][participant]).div(totalSupplyOfBears);\r\n        }\r\n\r\n        if (depositBulls[currentRound][participant] > 0) {\r\n            payout = totalSupply.mul(depositBulls[currentRound][participant]).div(totalSupplyOfBulls);\r\n        }\r\n\r\n        return payout;\r\n    }\r\n\r\n    /**\r\n    * @dev Getting GW Token prize of participant\r\n    * @param participant Address of participant\r\n    */\r\n    function calculateGWPrize(address participant) public view returns(uint) {\r\n\r\n        uint payout = 0;\r\n        uint totalSupply = (totalGWSupplyOfBears.add(totalGWSupplyOfBulls)).mul(80).div(100);\r\n\r\n        if (depositBears[currentRound][participant] > 0) {\r\n            payout = totalSupply.mul(depositBears[currentRound][participant]).div(totalSupplyOfBears);\r\n        }\r\n\r\n        if (depositBulls[currentRound][participant] > 0) {\r\n            payout = totalSupply.mul(depositBulls[currentRound][participant]).div(totalSupplyOfBulls);\r\n        }\r\n\r\n        return payout;\r\n    }\r\n\r\n    /**\r\n    * @dev Getting ETH prize of _lastParticipant\r\n    * @param _lastParticipant Address of _lastParticipant\r\n    */\r\n    function calculateLastETHPrize(address _lastParticipant) public view returns(uint) {\r\n\r\n        uint payout = 0;\r\n        uint256 totalSupply = (lastTotalSupplyOfBears.add(lastTotalSupplyOfBulls));\r\n\r\n        if (depositBears[currentRound - 1][_lastParticipant] > 0) {\r\n            payout = totalSupply.mul(depositBears[currentRound - 1][_lastParticipant]).div(lastTotalSupplyOfBears);\r\n        }\r\n\r\n        if (depositBulls[currentRound - 1][_lastParticipant] > 0) {\r\n            payout = totalSupply.mul(depositBulls[currentRound - 1][_lastParticipant]).div(lastTotalSupplyOfBulls);\r\n        }\r\n\r\n        return payout;\r\n    }\r\n\r\n    /**\r\n    * @dev Getting GW Token prize of _lastParticipant\r\n    * @param _lastParticipant Address of _lastParticipant\r\n    */\r\n    function calculateLastGWPrize(address _lastParticipant) public view returns(uint) {\r\n\r\n        uint payout = 0;\r\n        uint totalSupply = (lastTotalGWSupplyOfBears.add(lastTotalGWSupplyOfBulls)).mul(80).div(100);\r\n\r\n        if (depositBears[currentRound - 1][_lastParticipant] > 0) {\r\n            payout = totalSupply.mul(depositBears[currentRound - 1][_lastParticipant]).div(lastTotalSupplyOfBears);\r\n        }\r\n\r\n        if (depositBulls[currentRound - 1][_lastParticipant] > 0) {\r\n            payout = totalSupply.mul(depositBulls[currentRound - 1][_lastParticipant]).div(lastTotalSupplyOfBulls);\r\n        }\r\n\r\n        return payout;\r\n    }\r\n}\r\n\r\n/**\r\n* @dev Base contract for teams\r\n*/\r\ncontract CryptoTeam {\r\n    using SafeMath for uint256;\r\n\r\n    //Developers fund\r\n    address payable public owner;\r\n\r\n    Bank public BankContract;\r\n    GameWave public GameWaveContract;\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n    \r\n    /**\r\n    * @dev Payable function. 10% will send to Developers fund and 90% will send to JackPot contract.\r\n    * Also setting info about player.\r\n    */\r\n    function () external payable {\r\n        require(BankContract.getState() && msg.value >= 0.05 ether);\r\n\r\n        BankContract.setInfo(msg.sender, msg.value.mul(90).div(100));\r\n\r\n        owner.transfer(msg.value.mul(10).div(100));\r\n        \r\n        address(BankContract).transfer(msg.value.mul(90).div(100));\r\n    }\r\n}\r\n\r\n/*\r\n* @dev Bears contract. To play game with Bears send ETH to this contract\r\n*/\r\ncontract Bears is CryptoTeam {\r\n    constructor(address payable _bankAddress, address payable _GameWaveAddress) public {\r\n        BankContract = Bank(_bankAddress);\r\n        BankContract.setBearsAddress(address(this));\r\n        GameWaveContract = GameWave(_GameWaveAddress);\r\n        GameWaveContract.approve(_bankAddress, 9999999999999999999000000000000000000);\r\n    }\r\n}\r\n\r\n/*\r\n* @dev Bulls contract. To play game with Bulls send ETH to this contract\r\n*/\r\ncontract Bulls is CryptoTeam {\r\n    constructor(address payable _bankAddress, address payable _GameWaveAddress) public {\r\n        BankContract = Bank(_bankAddress);\r\n        BankContract.setBullsAddress(address(this));\r\n        GameWaveContract = GameWave(_GameWaveAddress);\r\n        GameWaveContract.approve(_bankAddress, 9999999999999999999000000000000000000);\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"buyPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newBuyPrice\",\"type\":\"uint256\"}],\"name\":\"setPrice\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"GWContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_GWContract\",\"type\":\"address\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"}]","ContractName":"Sale","CompilerVersion":"v0.5.6+commit.b259423e","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000008a807d6061ac959ad32415bfa8e01e0980a6d696","Library":"","SwarmSource":"bzzr://e1d492a6ebdcd54e09599e59c181fdd91107f00a5bb90202abe543b60855648b"}]}