{"status":"1","message":"OK","result":[{"SourceCode":"// File: contracts/IFeed.sol\r\n\r\npragma solidity ^0.4.18;\r\n\r\ninterface IFeed {\r\n    function get(address base, address quote) external view returns (uint128 xrt, uint64 when);\r\n}\r\n\r\n// File: contracts/open-zeppelin/ECRecovery.sol\r\n\r\npragma solidity 0.4.24;\r\n\r\n// Using ECRecovery from open-zeppelin@ad12381549c4c0711c2f3310e9fb1f65d51c299c + added personalRecover function\r\n// See https://github.com/OpenZeppelin/openzeppelin-solidity/blob/ad12381549c4c0711c2f3310e9fb1f65d51c299c/contracts/ECRecovery.sol\r\n\r\nlibrary ECRecovery {\r\n  /**\r\n   * @dev Recover signer address from a personal signed message by using his signature\r\n   * @param hash bytes32 message, the hash is the signed message. What is recovered is the signer address.\r\n   * @param sig bytes signature, the signature is generated using web3.personal.sign()\r\n   */\r\n  function personalRecover(bytes32 hash, bytes sig) internal pure returns (address) {\r\n    return recover(toEthSignedMessageHash(hash), sig);\r\n  }\r\n\r\n  /**\r\n   * @dev Recover signer address from a message by using his signature\r\n   * @param hash bytes32 message, the hash is the signed message. What is recovered is the signer address.\r\n   * @param sig bytes signature, the signature is generated using web3.eth.sign()\r\n   */\r\n  function recover(bytes32 hash, bytes sig) internal pure returns (address) {\r\n    bytes32 r;\r\n    bytes32 s;\r\n    uint8 v;\r\n\r\n    //Check the signature length\r\n    if (sig.length != 65) {\r\n      return (address(0));\r\n    }\r\n\r\n    // Divide the signature in r, s and v variables\r\n    assembly {\r\n      r := mload(add(sig, 32))\r\n      s := mload(add(sig, 64))\r\n      v := byte(0, mload(add(sig, 96)))\r\n    }\r\n\r\n    // Version of signature should be 27 or 28, but 0 and 1 are also possible versions\r\n    if (v < 27) {\r\n      v += 27;\r\n    }\r\n\r\n    // If the version is correct return the signer address\r\n    if (v != 27 && v != 28) {\r\n      return (address(0));\r\n    } else {\r\n      return ecrecover(hash, v, r, s);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * toEthSignedMessageHash\r\n   * @dev prefix a bytes32 value with \"\\x19Ethereum Signed Message:\"\r\n   * @dev and hash the result\r\n   */\r\n  function toEthSignedMessageHash(bytes32 hash)\r\n    internal\r\n    pure\r\n    returns (bytes32)\r\n  {\r\n    // 32 is the length in bytes of hash,\r\n    // enforced by the type signature above\r\n    return keccak256(abi.encodePacked(\r\n      \"\\x19Ethereum Signed Message:\\n32\",\r\n      hash\r\n    ));\r\n  }\r\n}\r\n\r\n// File: @aragon/os/contracts/common/Uint256Helpers.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\nlibrary Uint256Helpers {\r\n    uint256 private constant MAX_UINT64 = uint64(-1);\r\n\r\n    string private constant ERROR_NUMBER_TOO_BIG = \"UINT64_NUMBER_TOO_BIG\";\r\n\r\n    function toUint64(uint256 a) internal pure returns (uint64) {\r\n        require(a <= MAX_UINT64, ERROR_NUMBER_TOO_BIG);\r\n        return uint64(a);\r\n    }\r\n}\r\n\r\n// File: @aragon/os/contracts/common/TimeHelpers.sol\r\n\r\n/*\r\n * SPDX-License-Identitifer:    MIT\r\n */\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\n\r\ncontract TimeHelpers {\r\n    using Uint256Helpers for uint256;\r\n\r\n    /**\r\n    * @dev Returns the current block number.\r\n    *      Using a function rather than `block.number` allows us to easily mock the block number in\r\n    *      tests.\r\n    */\r\n    function getBlockNumber() internal view returns (uint256) {\r\n        return block.number;\r\n    }\r\n\r\n    /**\r\n    * @dev Returns the current block number, converted to uint64.\r\n    *      Using a function rather than `block.number` allows us to easily mock the block number in\r\n    *      tests.\r\n    */\r\n    function getBlockNumber64() internal view returns (uint64) {\r\n        return getBlockNumber().toUint64();\r\n    }\r\n\r\n    /**\r\n    * @dev Returns the current timestamp.\r\n    *      Using a function rather than `block.timestamp` allows us to easily mock it in\r\n    *      tests.\r\n    */\r\n    function getTimestamp() internal view returns (uint256) {\r\n        return block.timestamp; // solium-disable-line security/no-block-members\r\n    }\r\n\r\n    /**\r\n    * @dev Returns the current timestamp, converted to uint64.\r\n    *      Using a function rather than `block.timestamp` allows us to easily mock it in\r\n    *      tests.\r\n    */\r\n    function getTimestamp64() internal view returns (uint64) {\r\n        return getTimestamp().toUint64();\r\n    }\r\n}\r\n\r\n// File: contracts/PPF.sol\r\n\r\npragma solidity 0.4.24;\r\n\r\n\r\n\r\n\r\n\r\ncontract PPF is IFeed, TimeHelpers {\r\n    using ECRecovery for bytes32;\r\n\r\n    uint256 constant public ONE = 10 ** 18; // 10^18 is considered 1 in the price feed to allow for decimal calculations\r\n    bytes32 constant public PPF_v1_ID = 0x33a8ba7202230fa1cee2aac7bac322939edc7ba0a48b0989335a5f87a5770369; // keccak256(\"PPF-v1\");\r\n\r\n    string private constant ERROR_BAD_SIGNATURE = \"PPF_BAD_SIGNATURE\";\r\n    string private constant ERROR_BAD_RATE_TIMESTAMP = \"PPF_BAD_RATE_TIMESTAMP\";\r\n    string private constant ERROR_INVALID_RATE_VALUE = \"PPF_INVALID_RATE_VALUE\";\r\n    string private constant ERROR_EQUAL_BASE_QUOTE_ADDRESSES = \"PPF_EQUAL_BASE_QUOTE_ADDRESSES\";\r\n    string private constant ERROR_BASE_ADDRESSES_LENGTH_ZERO = \"PPF_BASE_ADDRESSES_LEN_ZERO\";\r\n    string private constant ERROR_QUOTE_ADDRESSES_LENGTH_MISMATCH = \"PPF_QUOTE_ADDRESSES_LEN_MISMATCH\";\r\n    string private constant ERROR_RATE_VALUES_LENGTH_MISMATCH = \"PPF_RATE_VALUES_LEN_MISMATCH\";\r\n    string private constant ERROR_RATE_TIMESTAMPS_LENGTH_MISMATCH = \"PPF_RATE_TIMESTAMPS_LEN_MISMATCH\";\r\n    string private constant ERROR_SIGNATURES_LENGTH_MISMATCH = \"PPF_SIGNATURES_LEN_MISMATCH\";\r\n    string private constant ERROR_CAN_NOT_SET_OPERATOR = \"PPF_CAN_NOT_SET_OPERATOR\";\r\n    string private constant ERROR_CAN_NOT_SET_OPERATOR_OWNER = \"PPF_CAN_NOT_SET_OPERATOR_OWNER\";\r\n    string private constant ERROR_OPERATOR_ADDRESS_ZERO = \"PPF_OPERATOR_ADDRESS_ZERO\";\r\n    string private constant ERROR_OPERATOR_OWNER_ADDRESS_ZERO = \"PPF_OPERATOR_OWNER_ADDRESS_ZERO\";\r\n\r\n    struct Price {\r\n        uint128 xrt;\r\n        uint64 when;\r\n    }\r\n\r\n    mapping (bytes32 => Price) internal feed;\r\n    address public operator;\r\n    address public operatorOwner;\r\n\r\n    event SetRate(address indexed base, address indexed quote, uint256 xrt, uint64 when);\r\n    event SetOperator(address indexed operator);\r\n    event SetOperatorOwner(address indexed operatorOwner);\r\n\r\n    /**\r\n    * @param _operator Public key allowed to sign messages to update the pricefeed\r\n    * @param _operatorOwner Address of an account that can change the operator\r\n    */\r\n    constructor (address _operator, address _operatorOwner) public {\r\n        _setOperator(_operator);\r\n        _setOperatorOwner(_operatorOwner);\r\n    }\r\n\r\n    /**\r\n    * @notice Update the price for the `base + ':' + quote` feed with an exchange rate of `xrt / ONE` for time `when`\r\n    * @dev If the number representation of base is lower than the one for quote, and update is cheaper, as less manipulation is required.\r\n    * @param base Address for the base token in the feed\r\n    * @param quote Address for the quote token the base is denominated in\r\n    * @param xrt Exchange rate for base denominated in quote. 10^18 is considered 1 to allow for decimal calculations\r\n    * @param when Timestamp for the exchange rate value\r\n    * @param sig Signature payload (EIP191) from operator, concatenated [  r  ][  s  ][v]. See setHash function for the hash calculation.\r\n    */\r\n    function update(address base, address quote, uint128 xrt, uint64 when, bytes sig) public {\r\n        bytes32 pair = pairId(base, quote);\r\n\r\n        // Ensure it is more recent than the current value (implicit check for > 0) and not a future date\r\n        require(when > feed[pair].when && when <= getTimestamp(), ERROR_BAD_RATE_TIMESTAMP);\r\n        require(xrt > 0, ERROR_INVALID_RATE_VALUE); // Make sure xrt is not 0, as the math would break (Dividing by 0 sucks big time)\r\n        require(base != quote, ERROR_EQUAL_BASE_QUOTE_ADDRESSES); // Assumption that currency units are fungible and xrt should always be 1\r\n\r\n        bytes32 h = setHash(base, quote, xrt, when);\r\n        require(h.personalRecover(sig) == operator, ERROR_BAD_SIGNATURE); // Make sure the update was signed by the operator\r\n\r\n        feed[pair] = Price(pairXRT(base, quote, xrt), when);\r\n\r\n        emit SetRate(base, quote, xrt, when);\r\n    }\r\n\r\n    /**\r\n    * @notice Update the price for many pairs\r\n    * @dev If the number representation of bases is lower than the one for quotes, and update is cheaper, as less manipulation is required.\r\n    * @param bases Array of addresses for the base tokens in the feed\r\n    * @param quotes Array of addresses for the quote tokens bases are denominated in\r\n    * @param xrts Array of the exchange rates for bases denominated in quotes. 10^18 is considered 1 to allow for decimal calculations\r\n    * @param whens Array of timestamps for the exchange rate value\r\n    * @param sigs Bytes array with the ordered concatenated signatures for the updates\r\n    */\r\n    function updateMany(address[] bases, address[] quotes, uint128[] xrts, uint64[] whens, bytes sigs) public {\r\n        require(bases.length != 0, ERROR_BASE_ADDRESSES_LENGTH_ZERO);\r\n        require(bases.length == quotes.length, ERROR_QUOTE_ADDRESSES_LENGTH_MISMATCH);\r\n        require(bases.length == xrts.length, ERROR_RATE_VALUES_LENGTH_MISMATCH);\r\n        require(bases.length == whens.length, ERROR_RATE_TIMESTAMPS_LENGTH_MISMATCH);\r\n        require(bases.length == sigs.length / 65, ERROR_SIGNATURES_LENGTH_MISMATCH);\r\n        require(sigs.length % 65 == 0, ERROR_SIGNATURES_LENGTH_MISMATCH);\r\n\r\n        for (uint256 i = 0; i < bases.length; i++) {\r\n            // Extract the signature for the update from the concatenated sigs\r\n            bytes memory sig = new bytes(65);\r\n            uint256 needle = 32 + 65 * i; // where to start copying from sigs\r\n            assembly {\r\n                // copy 32 bytes at a time and just the last byte at the end\r\n                mstore(add(sig, 0x20), mload(add(sigs, needle)))\r\n                mstore(add(sig, 0x40), mload(add(sigs, add(needle, 0x20))))\r\n                // we have to mload the last 32 bytes of the sig, and mstore8 just gets the LSB for the word\r\n                mstore8(add(sig, 0x60), mload(add(sigs, add(needle, 0x21))))\r\n            }\r\n\r\n            update(bases[i], quotes[i], xrts[i], whens[i], sig);\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @param base Address for the base token in the feed\r\n    * @param quote Address for the quote token the base is denominated in\r\n    * @return XRT for base:quote and the timestamp when it was updated\r\n    */\r\n    function get(address base, address quote) public view returns (uint128, uint64) {\r\n        if (base == quote) {\r\n            return (uint128(ONE), getTimestamp64());\r\n        }\r\n\r\n        Price storage price = feed[pairId(base, quote)];\r\n\r\n        // if never set, return 0.\r\n        if (price.when == 0) {\r\n            return (0, 0);\r\n        }\r\n\r\n        return (pairXRT(base, quote, price.xrt), price.when);\r\n    }\r\n\r\n    /**\r\n    * @notice Set operator public key to `_operator`\r\n    * @param _operator Public key allowed to sign messages to update the pricefeed\r\n    */\r\n    function setOperator(address _operator) external {\r\n        // Allow the current operator to change the operator to avoid having to hassle the\r\n        // operatorOwner in cases where a node just wants to rotate its public key\r\n        require(msg.sender == operator || msg.sender == operatorOwner, ERROR_CAN_NOT_SET_OPERATOR);\r\n        _setOperator(_operator);\r\n    }\r\n\r\n    /**\r\n    * @notice Set operator owner to `_operatorOwner`\r\n    * @param _operatorOwner Address of an account that can change the operator\r\n    */\r\n    function setOperatorOwner(address _operatorOwner) external {\r\n        require(msg.sender == operatorOwner, ERROR_CAN_NOT_SET_OPERATOR_OWNER);\r\n        _setOperatorOwner(_operatorOwner);\r\n    }\r\n\r\n    function _setOperator(address _operator) internal {\r\n        require(_operator != address(0), ERROR_OPERATOR_ADDRESS_ZERO);\r\n        operator = _operator;\r\n        emit SetOperator(_operator);\r\n    }\r\n\r\n    function _setOperatorOwner(address _operatorOwner) internal {\r\n        require(_operatorOwner != address(0), ERROR_OPERATOR_OWNER_ADDRESS_ZERO);\r\n        operatorOwner = _operatorOwner;\r\n        emit SetOperatorOwner(_operatorOwner);\r\n    }\r\n\r\n    /**\r\n    * @dev pairId returns a unique id for each pair, regardless of the order of base and quote\r\n    */\r\n    function pairId(address base, address quote) internal pure returns (bytes32) {\r\n        bool pairOrdered = isPairOrdered(base, quote);\r\n        address orderedBase = pairOrdered ? base : quote;\r\n        address orderedQuote = pairOrdered ? quote : base;\r\n\r\n        return keccak256(abi.encodePacked(orderedBase, orderedQuote));\r\n    }\r\n\r\n    /**\r\n    * @dev Compute xrt depending on base and quote order.\r\n    */\r\n    function pairXRT(address base, address quote, uint128 xrt) internal pure returns (uint128) {\r\n        bool pairOrdered = isPairOrdered(base, quote);\r\n\r\n        return pairOrdered ? xrt : uint128((ONE**2 / uint256(xrt))); // If pair is not ordered, return the inverse\r\n    }\r\n\r\n    function setHash(address base, address quote, uint128 xrt, uint64 when) internal pure returns (bytes32) {\r\n        return keccak256(abi.encodePacked(PPF_v1_ID, base, quote, xrt, when));\r\n    }\r\n\r\n    function isPairOrdered(address base, address quote) private pure returns (bool) {\r\n        return base < quote;\r\n    }\r\n}\r\n\r\n// File: contracts/IPPFFactory.sol\r\n\r\npragma solidity ^0.4.18;\r\n\r\n\r\n\r\ninterface IPPFFactory {\r\n  event NewPPF(address ppf, address indexed operator, address indexed operatorOwner);\r\n\r\n  function newPPF(address operator, address operatorOwner) external returns (IFeed);\r\n}\r\n\r\n// File: contracts/PPFFactory.sol\r\n\r\npragma solidity 0.4.24;\r\n\r\n\r\n\r\n\r\ncontract PPFFactory is IPPFFactory {\r\n    function newPPF(address operator, address operatorOwner) external returns (IFeed) {\r\n        PPF ppf = new PPF(operator, operatorOwner);\r\n        emit NewPPF(address(ppf), operator, operatorOwner);\r\n\r\n        return IFeed(ppf);\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"operator\",\"type\":\"address\"},{\"name\":\"operatorOwner\",\"type\":\"address\"}],\"name\":\"newPPF\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"ppf\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"operatorOwner\",\"type\":\"address\"}],\"name\":\"NewPPF\",\"type\":\"event\"}]","ContractName":"PPFFactory","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"10000","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://f20523b7bd9c7abe03973912df26eb67d317dace370dc336b73d47b7727c8784"}]}