{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.25;\r\n\r\n\r\n/**\r\n* @title ThorMutual\r\n* @author Leo\r\n* @dev Thor Mutual for TRX, WAVES, ADA, ERC20 and so on\r\n*/\r\n\r\n\r\ncontract Utils {\r\n\r\n    uint constant DAILY_PERIOD = 1;\r\n    uint constant WEEKLY_PERIOD = 7;\r\n\r\n    int constant PRICE_DECIMALS = 10 ** 8;\r\n\r\n    int constant INT_MAX = 2 ** 255 - 1;\r\n\r\n    uint constant UINT_MAX = 2 ** 256 - 1;\r\n\r\n}\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n     * account.\r\n     */\r\n    constructor () internal {\r\n        _owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), _owner);\r\n    }\r\n\r\n    /**\r\n     * @return the address of the owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner());\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @return true if `msg.sender` is the owner of the contract.\r\n     */\r\n    function isOwner() public view returns (bool) {\r\n        return msg.sender == _owner;\r\n    }\r\n\r\n    // /**\r\n    //  * @dev Allows the current owner to relinquish control of the contract.\r\n    //  * @notice Renouncing to ownership will leave the contract without an owner.\r\n    //  * It will not be possible to call the functions with the `onlyOwner`\r\n    //  * modifier anymore.\r\n    //  */\r\n    // function renounceOwnership() public onlyOwner {\r\n    //     emit OwnershipTransferred(_owner, address(0));\r\n    //     _owner = address(0);\r\n    // }\r\n\r\n    /**\r\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0));\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\n\r\ninterface ThorMutualInterface {\r\n    function getCurrentPeriod() external view returns(uint);\r\n    function settle() external;\r\n}\r\n\r\n\r\n/**\r\n * @title ThorMutualToken\r\n * @dev Every ThorMutualToken contract is related with a specific token such as BTC/ETH/EOS/ERC20\r\n * functions, participants send ETH to this contract to take part in the Thor Mutual activity.\r\n */\r\ncontract ThorMutualToken is Ownable, Utils {\r\n    string public thorMutualToken;\r\n\r\n    // total deposit for a specific period\r\n    mapping(uint => uint) amountOfDailyPeriod;\r\n\r\n    // total deposit for a specific period\r\n    mapping(uint => uint) amountOfWeeklyPeriod;\r\n\r\n    // participant's total deposit fund\r\n    mapping(address => uint) participantAmount;\r\n\r\n    // participants\r\n    address[] participants;\r\n\r\n    // deposit info\r\n    struct DepositInfo {\r\n        uint blockTimeStamp;\r\n        uint period;\r\n        string token;\r\n        uint amount;\r\n    }\r\n\r\n    // participant's total deposit history\r\n    //mapping(address => DepositInfo[]) participantsHistory;\r\n    mapping(address => uint[]) participantsHistoryTime;\r\n    mapping(address => uint[]) participantsHistoryPeriod;\r\n    mapping(address => uint[]) participantsHistoryAmount;\r\n\r\n    // participant's total deposit fund for a specific period\r\n    mapping(uint => mapping(address => uint)) participantAmountOfDailyPeriod;\r\n\r\n    // participant's total deposit fund for a weekly period\r\n    mapping(uint => mapping(address => uint)) participantAmountOfWeeklyPeriod;\r\n\r\n    // participants for the daily period\r\n    mapping(uint => address[]) participantsDaily;\r\n\r\n    // participants for the weekly period\r\n    mapping(uint => address[]) participantsWeekly;\r\n\r\n    ThorMutualInterface public thorMutualContract;\r\n\r\n    constructor(string _thorMutualToken, ThorMutualInterface _thorMutual) public {\r\n        thorMutualToken = _thorMutualToken;\r\n        thorMutualContract = _thorMutual;\r\n    }\r\n\r\n    event ThorDepositToken(address sender, uint256 amount);\r\n    function() external payable {\r\n        require(msg.value >= 0.001 ether);\r\n        \r\n        require(address(thorMutualContract) != address(0));\r\n        address(thorMutualContract).transfer(msg.value);\r\n\r\n        //uint currentPeriod;\r\n        uint actualPeriod = 0;\r\n        uint actualPeriodWeek = 0;\r\n\r\n        actualPeriod = thorMutualContract.getCurrentPeriod();\r\n\r\n        actualPeriodWeek = actualPeriod / WEEKLY_PERIOD;\r\n\r\n        if (participantAmount[msg.sender] == 0) {\r\n            participants.push(msg.sender);\r\n        }\r\n\r\n        if (participantAmountOfDailyPeriod[actualPeriod][msg.sender] == 0) {\r\n            participantsDaily[actualPeriod].push(msg.sender);\r\n        }\r\n\r\n        if (participantAmountOfWeeklyPeriod[actualPeriodWeek][msg.sender] == 0) {\r\n            participantsWeekly[actualPeriodWeek].push(msg.sender);\r\n        }\r\n\r\n        participantAmountOfDailyPeriod[actualPeriod][msg.sender] += msg.value;\r\n\r\n        participantAmount[msg.sender] += msg.value;\r\n        \r\n        participantAmountOfWeeklyPeriod[actualPeriodWeek][msg.sender] += msg.value;\r\n\r\n        amountOfDailyPeriod[actualPeriod] += msg.value;\r\n\r\n        amountOfWeeklyPeriod[actualPeriodWeek] += msg.value;\r\n\r\n        // DepositInfo memory depositInfo = DepositInfo(block.timestamp, actualPeriod, thorMutualToken, msg.value);\r\n\r\n        // participantsHistory[msg.sender].push(depositInfo);\r\n\r\n        participantsHistoryTime[msg.sender].push(block.timestamp);\r\n        participantsHistoryPeriod[msg.sender].push(actualPeriod);\r\n        participantsHistoryAmount[msg.sender].push(msg.value);\r\n\r\n        emit ThorDepositToken(msg.sender, msg.value);\r\n    }\r\n\r\n    function setThorMutualContract(ThorMutualInterface _thorMutualContract) public onlyOwner{\r\n        require(address(_thorMutualContract) != address(0));\r\n        thorMutualContract = _thorMutualContract;\r\n    }\r\n\r\n    function getThorMutualContract() public view returns(address) {\r\n        return thorMutualContract;\r\n    }\r\n\r\n    function setThorMutualToken(string _thorMutualToken) public onlyOwner {\r\n        thorMutualToken = _thorMutualToken;\r\n    }\r\n\r\n    function getDepositDailyAmountofPeriod(uint period) external view returns(uint) {\r\n        require(period >= 0);\r\n\r\n        return amountOfDailyPeriod[period];\r\n    }\r\n\r\n    function getDepositWeeklyAmountofPeriod(uint period) external view returns(uint) {\r\n        require(period >= 0);\r\n        uint periodWeekly = period / WEEKLY_PERIOD;\r\n        return amountOfWeeklyPeriod[periodWeekly];\r\n    }\r\n\r\n    function getParticipantsDaily(uint period) external view returns(address[], uint) {\r\n        require(period >= 0);\r\n\r\n        return (participantsDaily[period], participantsDaily[period].length);\r\n    }\r\n\r\n    function getParticipantsWeekly(uint period) external view returns(address[], uint) {\r\n        require(period >= 0);\r\n\r\n        uint periodWeekly = period / WEEKLY_PERIOD;\r\n        return (participantsWeekly[periodWeekly], participantsWeekly[period].length);\r\n    }\r\n\r\n    function getParticipantAmountDailyPeriod(uint period, address participant) external view returns(uint) {\r\n        require(period >= 0);\r\n\r\n        return participantAmountOfDailyPeriod[period][participant];\r\n    }\r\n\r\n    function getParticipantAmountWeeklyPeriod(uint period, address participant) external view returns(uint) {\r\n        require(period >= 0);\r\n\r\n        uint periodWeekly = period / WEEKLY_PERIOD;\r\n        return participantAmountOfWeeklyPeriod[periodWeekly][participant];\r\n    }\r\n\r\n    //function getParticipantHistory(address participant) public view returns(DepositInfo[]) {\r\n    function getParticipantHistory(address participant) public view returns(uint[], uint[], uint[]) {\r\n\r\n        return (participantsHistoryTime[participant], participantsHistoryPeriod[participant], participantsHistoryAmount[participant]);\r\n        //return participantsHistory[participant];\r\n    }\r\n\r\n    function getSelfBalance() public view returns(uint) {\r\n        return address(this).balance;\r\n    }\r\n\r\n    function withdraw(address receiver, uint amount) public onlyOwner {\r\n        require(receiver != address(0));\r\n\r\n        receiver.transfer(amount);\r\n    }\r\n\r\n}\r\n\r\n\r\ninterface ThorMutualTokenInterface {\r\n    function getParticipantsDaily(uint period) external view returns(address[], uint);\r\n    function getParticipantsWeekly(uint period) external view returns(address[], uint);\r\n    function getDepositDailyAmountofPeriod(uint period) external view returns(uint);\r\n    function getDepositWeeklyAmountofPeriod(uint period) external view returns(uint);\r\n    function getParticipantAmountDailyPeriod(uint period, address participant) external view returns(uint);\r\n    function getParticipantAmountWeeklyPeriod(uint period, address participant) external view returns(uint);\r\n}\r\n\r\ninterface ThorMutualTokenPriceInterface {\r\n    function getMaxDailyDrawdown(uint period) external view returns(address);\r\n    function getMaxWeeklyDrawdown(uint period) external view returns(address);\r\n}\r\n\r\ninterface ThorMutualWeeklyRewardInterface {\r\n    function settleWeekly(address winner, uint amountWinner) external; \r\n}\r\n\r\ncontract ThorMutual is Ownable, Utils {\r\n\r\n    string public thorMutual;\r\n\r\n    // period update daily\r\n    uint internal periodUpdateIndex = 0;\r\n\r\n    // initial flag\r\n    bool internal initialFlag = false;\r\n\r\n    ThorMutualTokenPriceInterface public thorMutualTokenPrice;\r\n\r\n    ThorMutualTokenInterface[] thorMutualTokens;\r\n\r\n    ThorMutualWeeklyReward public thorMutualWeeklyReward;\r\n\r\n    mapping(uint => address) winnerDailyTokens;\r\n    mapping(uint => address) winnerWeeklyTokens;\r\n\r\n    mapping(uint => uint) winnerDailyParticipantAmounts;\r\n    mapping(uint => uint) winnerWeeklyParticipantAmounts;\r\n\r\n    mapping(uint => uint) winnerDailyDepositAmounts;\r\n\r\n    mapping(uint => address) winnerWeeklyAccounts;\r\n\r\n    // daily winners' award\r\n    mapping(uint => mapping(address => uint)) winnerDailyParticipantInfos;\r\n\r\n    // weekly winners' award\r\n    mapping(uint => mapping(address => uint)) winnerWeeklyParticipantInfos;\r\n\r\n    // struct AwardInfo {\r\n    //     address winner;\r\n    //     uint awardAmount;\r\n    // }\r\n\r\n    // daily winners' address\r\n    mapping(uint => address[]) winnerDailyParticipantAddrs;\r\n    mapping(uint => uint[]) winnerDailyParticipantAwards;\r\n\r\n    // weekly winners' info\r\n    mapping(uint => address) winnerWeeklyParticipantAddrs;\r\n    mapping(uint => uint) winnerWeeklyParticipantAwards;\r\n\r\n    // 0.001 eth = 1 finney \r\n    // uint internal threadReward = 1 * 10 ** 15;\r\n\r\n    // \r\n    uint internal distributeRatioOfDaily = 70;\r\n    uint internal distributeRatioOfWeekly = 20;\r\n    uint internal distributeRatioOfPlatform = 10;\r\n\r\n    uint internal ratioWeekly = 5;\r\n\r\n    // address of platform\r\n    address internal rewardAddressOfPlatfrom;\r\n\r\n    constructor() public {\r\n        thorMutual = \"ThorMutual\";\r\n    }\r\n\r\n    event DepositToken(address token, uint256 amount);\r\n    function() external payable {\r\n        emit DepositToken(msg.sender, msg.value);\r\n    }\r\n\r\n    function setThorMutualParms(uint _distributeRatioOfDaily, uint _distributeRatioOfWeekly, uint _distributeRatioOfPlatform, uint _ratioWeekly) public onlyOwner {\r\n        require(_distributeRatioOfDaily + _distributeRatioOfWeekly + _distributeRatioOfPlatform == 100);\r\n        require(_ratioWeekly >= 0 && _ratioWeekly <= 10);\r\n\r\n        distributeRatioOfDaily = _distributeRatioOfDaily;\r\n        distributeRatioOfWeekly = _distributeRatioOfWeekly;\r\n        distributeRatioOfPlatform = _distributeRatioOfPlatform;\r\n        ratioWeekly = _ratioWeekly;\r\n    }\r\n\r\n    function getThorMutualParms() public view returns(uint, uint, uint, uint){\r\n        return (distributeRatioOfDaily, distributeRatioOfWeekly, distributeRatioOfPlatform, ratioWeekly);\r\n    }\r\n\r\n    /**\r\n     * @dev set thorMutualTokens' contract address\r\n     * @param _thorMutualTokens _thorMutualTokens\r\n     * @param _length _length\r\n     */\r\n    function setThorMutualTokenContracts(ThorMutualTokenInterface[] memory _thorMutualTokens, uint _length) public onlyOwner {\r\n        require(_thorMutualTokens.length == _length);\r\n\r\n        for (uint i = 0; i < _length; i++) {\r\n            thorMutualTokens.push(_thorMutualTokens[i]);\r\n        }\r\n    }\r\n\r\n    function initialPeriod() internal {\r\n        periodUpdateIndex++;\r\n    }\r\n\r\n    /**\r\n     * @dev return periodUpdateIndex, periodActual\r\n     * @return the index return periodUpdateIndex, periodActual\r\n     */\r\n    function getCurrentPeriod() public view returns(uint) {\r\n        return periodUpdateIndex;\r\n    }\r\n\r\n    function settle() external {\r\n\r\n        require(address(thorMutualTokenPrice) == msg.sender);\r\n\r\n        if(initialFlag == false) {\r\n            initialFlag = true;\r\n\r\n            initialPeriod();\r\n\r\n            return;\r\n        }\r\n\r\n        dailySettle();\r\n\r\n        if(periodUpdateIndex % WEEKLY_PERIOD == 0){\r\n            weeklySettle();\r\n        }\r\n\r\n        periodUpdateIndex++;\r\n    }\r\n\r\n    event ThorMutualRewardOfPlatfrom(address, uint256);\r\n\r\n    function dailySettle() internal {\r\n\r\n        require(periodUpdateIndex >= 1);\r\n\r\n        address maxDrawdownThorMutualTokenAddress;\r\n\r\n        maxDrawdownThorMutualTokenAddress = thorMutualTokenPrice.getMaxDailyDrawdown(periodUpdateIndex);\r\n\r\n        if (maxDrawdownThorMutualTokenAddress == address(0)) {\r\n            return;\r\n        }\r\n\r\n        winnerDailyTokens[periodUpdateIndex-1] = maxDrawdownThorMutualTokenAddress;\r\n\r\n        ThorMutualTokenInterface maxDrawdownThorMutualToken = ThorMutualTokenInterface(maxDrawdownThorMutualTokenAddress);\r\n\r\n        address[] memory winners;\r\n        (winners, ) = maxDrawdownThorMutualToken.getParticipantsDaily(periodUpdateIndex - 1);\r\n        uint winnersLength = winners.length;\r\n\r\n        winnerDailyParticipantAmounts[periodUpdateIndex-1] = winnersLength;\r\n\r\n        uint amountOfPeriod = 0;\r\n        uint i = 0;\r\n        for (i = 0; i < thorMutualTokens.length; i++) {\r\n            amountOfPeriod += thorMutualTokens[i].getDepositDailyAmountofPeriod(periodUpdateIndex - 1);\r\n        }\r\n\r\n        winnerDailyDepositAmounts[periodUpdateIndex-1] = amountOfPeriod;\r\n\r\n        uint rewardAmountOfDaily = amountOfPeriod * distributeRatioOfDaily / 100;\r\n        uint rewardAmountOfPlatform = amountOfPeriod * distributeRatioOfPlatform / 100;\r\n        uint rewardAmountOfWeekly = amountOfPeriod - rewardAmountOfDaily - rewardAmountOfPlatform;\r\n        \r\n        uint amountOfTokenAndPeriod = maxDrawdownThorMutualToken.getDepositDailyAmountofPeriod(periodUpdateIndex - 1);\r\n\r\n        for (i = 0; i < winnersLength; i++) {\r\n            address rewardParticipant = winners[i];\r\n\r\n            uint depositAmountOfParticipant = maxDrawdownThorMutualToken.getParticipantAmountDailyPeriod(periodUpdateIndex - 1, rewardParticipant);\r\n\r\n            uint rewardAmountOfParticipant = depositAmountOfParticipant * rewardAmountOfDaily / amountOfTokenAndPeriod;\r\n\r\n            // if (rewardAmountOfParticipant > threadReward) {\r\n            rewardParticipant.transfer(rewardAmountOfParticipant);\r\n\r\n            // record winner's info\r\n            winnerDailyParticipantInfos[periodUpdateIndex - 1][rewardParticipant] = rewardAmountOfParticipant;\r\n\r\n            winnerDailyParticipantAddrs[periodUpdateIndex - 1].push(rewardParticipant);\r\n            winnerDailyParticipantAwards[periodUpdateIndex - 1].push(rewardAmountOfParticipant);\r\n\r\n            // }\r\n        }\r\n\r\n        rewardAddressOfPlatfrom.transfer(rewardAmountOfPlatform);\r\n        emit ThorMutualRewardOfPlatfrom(rewardAddressOfPlatfrom, rewardAmountOfPlatform);\r\n\r\n        address(thorMutualWeeklyReward).transfer(rewardAmountOfWeekly);\r\n\r\n    }\r\n\r\n    function weeklySettle() internal {\r\n\r\n        require(periodUpdateIndex >= WEEKLY_PERIOD);\r\n\r\n        address maxDrawdownThorMutualTokenAddress;\r\n\r\n        maxDrawdownThorMutualTokenAddress = thorMutualTokenPrice.getMaxWeeklyDrawdown(periodUpdateIndex);\r\n\r\n        if (maxDrawdownThorMutualTokenAddress == address(0)) {\r\n            return;\r\n        }\r\n\r\n        uint weeklyPeriod = (periodUpdateIndex - 1) / WEEKLY_PERIOD;\r\n\r\n        winnerWeeklyTokens[weeklyPeriod] = maxDrawdownThorMutualTokenAddress;\r\n\r\n        ThorMutualTokenInterface maxDrawdownThorMutualToken = ThorMutualTokenInterface(maxDrawdownThorMutualTokenAddress);\r\n\r\n        address[] memory participants;\r\n        (participants, ) = maxDrawdownThorMutualToken.getParticipantsWeekly(periodUpdateIndex - 1);\r\n        uint winnersLength = participants.length;\r\n\r\n        winnerWeeklyParticipantAmounts[weeklyPeriod] = winnersLength;\r\n\r\n        //address[] winners;\r\n        address winner;\r\n        uint maxDeposit = 0;\r\n\r\n        for (uint i = 0; i < winnersLength; i++) {\r\n            address rewardParticipant = participants[i];\r\n\r\n            uint depositAmountOfParticipant = maxDrawdownThorMutualToken.getParticipantAmountWeeklyPeriod(periodUpdateIndex - 1, rewardParticipant);\r\n\r\n            if(depositAmountOfParticipant > maxDeposit) {\r\n                winner = rewardParticipant;\r\n                maxDeposit = depositAmountOfParticipant;\r\n            }\r\n\r\n        }\r\n\r\n        winnerWeeklyAccounts[weeklyPeriod] = winner;\r\n\r\n        uint thorMutualWeeklyRewardFund = address(thorMutualWeeklyReward).balance;\r\n\r\n        uint winnerWeeklyAward = thorMutualWeeklyRewardFund * ratioWeekly / 10;\r\n\r\n        thorMutualWeeklyReward.settleWeekly(winner, winnerWeeklyAward);\r\n\r\n        // record winner's info\r\n\r\n        winnerWeeklyParticipantInfos[weeklyPeriod][winner] = winnerWeeklyAward;\r\n\r\n        winnerWeeklyParticipantAddrs[weeklyPeriod] = winner;\r\n        winnerWeeklyParticipantAwards[weeklyPeriod] = winnerWeeklyAward;\r\n\r\n    }\r\n\r\n    function getDailyWinnerTokenInfo(uint period) public view returns(address, uint, uint, address[], uint[]) {\r\n        require(period >= 0 && period < periodUpdateIndex);\r\n\r\n        address token = winnerDailyTokens[period];\r\n\r\n        uint participantAmount = winnerDailyParticipantAmounts[period];\r\n\r\n        uint depositAmount = winnerDailyDepositAmounts[period];\r\n\r\n        return (token, participantAmount, depositAmount, winnerDailyParticipantAddrs[period], winnerDailyParticipantAwards[period]);\r\n    }\r\n\r\n    function getWeeklyWinnerTokenInfo(uint period) public view returns(address, uint, address, address, uint) {\r\n        require(period >= 0 && period < periodUpdateIndex);\r\n\r\n        uint actualPeriod = period / WEEKLY_PERIOD;\r\n\r\n        address token = winnerWeeklyTokens[actualPeriod];\r\n\r\n        uint participantAmount = winnerWeeklyParticipantAmounts[actualPeriod];\r\n\r\n        address winner = winnerWeeklyAccounts[actualPeriod];\r\n\r\n        return (token, participantAmount, winner, winnerWeeklyParticipantAddrs[actualPeriod], winnerWeeklyParticipantAwards[actualPeriod]);\r\n    }\r\n\r\n    function getDailyAndWeeklyWinnerInfo(uint period, address winner) public view returns(uint, uint){\r\n        require(period >= 0 && period < periodUpdateIndex);\r\n\r\n        uint periodWeekly = period / WEEKLY_PERIOD;\r\n\r\n        return (winnerDailyParticipantInfos[period][winner], winnerWeeklyParticipantInfos[periodWeekly][winner]);\r\n    }\r\n\r\n    /**\r\n     * @dev set thorMutualTokenPrice's contract address\r\n     * @param _thorMutualTokenPrice _thorMutualTokenPrice\r\n     */\r\n    function setThorMutualTokenPrice(ThorMutualTokenPriceInterface _thorMutualTokenPrice) public onlyOwner {\r\n        require(address(_thorMutualTokenPrice) != address(0));\r\n        thorMutualTokenPrice = _thorMutualTokenPrice;\r\n    }\r\n\r\n    function setRewardAddressOfPlatfrom(address _rewardAddressOfPlatfrom) public onlyOwner {\r\n        require(_rewardAddressOfPlatfrom != address(0));\r\n        rewardAddressOfPlatfrom = _rewardAddressOfPlatfrom;\r\n    }\r\n\r\n    function setThorMutualWeeklyReward(address _thorMutualWeeklyReward) public onlyOwner {\r\n        require(_thorMutualWeeklyReward != address(0));\r\n        thorMutualWeeklyReward = ThorMutualWeeklyReward(_thorMutualWeeklyReward);\r\n    }\r\n\r\n    function getSelfBalance() public view returns(uint) {\r\n        return address(this).balance;\r\n    }\r\n\r\n    function withdraw(address receiver, uint amount) public onlyOwner {\r\n        require(receiver != address(0));\r\n\r\n        receiver.transfer(amount);\r\n    }\r\n\r\n}\r\n\r\ncontract ThorMutualWeeklyReward is Ownable, Utils {\r\n\r\n    string public thorMutualWeeklyReward;\r\n\r\n    address public thorMutual;\r\n\r\n    constructor(ThorMutualInterface _thorMutual) public {\r\n        thorMutualWeeklyReward = \"ThorMutualWeeklyReward\";\r\n        thorMutual = address(_thorMutual);\r\n    }\r\n\r\n    event ThorMutualWeeklyRewardDeposit(uint256 amount);\r\n    function() external payable {\r\n        emit ThorMutualWeeklyRewardDeposit(msg.value);\r\n    }\r\n\r\n    event SettleWeekly(address winner, uint256 amount);\r\n    function settleWeekly(address winner, uint amountWinner) external {\r\n\r\n        require(msg.sender == thorMutual);\r\n        require(winner != address(0));\r\n\r\n        winner.transfer(amountWinner);\r\n\r\n        emit SettleWeekly(winner, amountWinner);\r\n    }\r\n\r\n    function setThorMutualContract(address _thorMutualContract) public onlyOwner{\r\n        require(_thorMutualContract != address(0));\r\n        thorMutual = _thorMutualContract;\r\n    }\r\n\r\n    function getSelfBalance() public view returns(uint) {\r\n        return address(this).balance;\r\n    }\r\n\r\n    function withdraw(address receiver, uint amount) public onlyOwner {\r\n        require(receiver != address(0));\r\n\r\n        receiver.transfer(amount);\r\n    }\r\n\r\n}\r\n\r\ncontract ThorMutualTokenPrice is Ownable, Utils {\r\n\r\n    string public thorMutualTokenPrice;\r\n\r\n    address[] internal tokensIncluded;\r\n    mapping(address => bool) isTokenIncluded;\r\n\r\n    ThorMutualInterface public thorMutualContract;\r\n\r\n    struct TokenPrice{\r\n        uint blockTimeStamp;\r\n        uint price;\r\n    }\r\n    // mapping(address => TokenPrice) tokensPrice;\r\n\r\n    mapping(uint => mapping(address => TokenPrice)) dailyTokensPrices;\r\n\r\n    constructor(ThorMutualInterface _thorMutual) public {\r\n        thorMutualTokenPrice = \"ThorMutualTokenPrice\";\r\n        thorMutualContract = _thorMutual;\r\n    }\r\n\r\n    mapping(uint => int[]) dailyTokensPricesDrawdown;\r\n    mapping(uint => int[]) weeklyTokensPricesDrawdown;\r\n\r\n    mapping(uint =>ThorMutualTokenInterface) dailyTokenWinners;\r\n    mapping(uint =>ThorMutualTokenInterface) weeklyTokenWinners;\r\n\r\n    /**\r\n     * @dev return all tokens included\r\n     * @return string[], a list of tokens\r\n     */\r\n    function getTokensIncluded() public view returns(address[]) {\r\n        return tokensIncluded;\r\n    }\r\n\r\n    function addTokensAndPrices(address[] _newTokens, uint[] _prices, uint _length) public onlyOwner {\r\n        require(_length == _newTokens.length);\r\n        require(_length == _prices.length);\r\n\r\n        uint actualPeriod;\r\n        actualPeriod = thorMutualContract.getCurrentPeriod();\r\n\r\n        for (uint i = 0; i < _length; i++) {\r\n            require(!isTokenIncluded[_newTokens[i]]);\r\n            isTokenIncluded[_newTokens[i]] = true;\r\n            tokensIncluded.push(_newTokens[i]);\r\n            TokenPrice memory tokenPrice = TokenPrice(block.timestamp, _prices[i]);\r\n            dailyTokensPrices[actualPeriod][_newTokens[i]] = tokenPrice;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev set prices of a list of tokens\r\n     * @param _tokens a list of tokens\r\n     * @param _prices a list of prices, actual price * (10 ** 8)\r\n     */\r\n    function setTokensPrice(address[] memory _tokens, uint[] memory _prices, bool isSettle) public onlyOwner {\r\n\r\n        uint length = _tokens.length;\r\n\r\n        uint actualPeriod;\r\n        actualPeriod = thorMutualContract.getCurrentPeriod();\r\n\r\n        require(length == _prices.length);\r\n        require(length == tokensIncluded.length);\r\n\r\n        for (uint i = 0; i < length; i++) {\r\n            address token = _tokens[i];\r\n            require(isTokenIncluded[token]);\r\n            TokenPrice memory tokenPrice = TokenPrice(block.timestamp, _prices[i]);\r\n            // tokensPrice[token] = tokenPrice;\r\n\r\n            dailyTokensPrices[actualPeriod][token] = tokenPrice;\r\n        }\r\n\r\n        // calculate tokens' maxDrawdown\r\n        if (isSettle == true && actualPeriod >= 1) {\r\n            //thorMutualContract.settle();\r\n            calculateMaxDrawdown(actualPeriod);\r\n        }\r\n    }\r\n\r\n    function calculateMaxDrawdown(uint period) internal {\r\n        ThorMutualTokenInterface dailyWinnerToken;\r\n        ThorMutualTokenInterface weeklyWinnerToken;\r\n        (dailyWinnerToken,) = _getMaxDrawdown(DAILY_PERIOD, period);\r\n\r\n        if(period % WEEKLY_PERIOD == 0) {\r\n            (weeklyWinnerToken,) = _getMaxDrawdown(WEEKLY_PERIOD, period);\r\n            weeklyTokenWinners[period / WEEKLY_PERIOD] = weeklyWinnerToken;\r\n        }\r\n\r\n        dailyTokenWinners[period] = dailyWinnerToken;\r\n        \r\n    }\r\n\r\n    function settle() public onlyOwner {\r\n        require(address(thorMutualContract) != address(0));\r\n        thorMutualContract.settle();\r\n    }\r\n\r\n    /**\r\n     * @dev get prices of a list of tokens\r\n     * @param period period\r\n     */\r\n\r\n    function getTokenPriceOfPeriod(address token, uint period) public view returns(uint) {\r\n        require(isTokenIncluded[token]);\r\n        require(period >= 0);\r\n\r\n        return dailyTokensPrices[period][token].price;\r\n\r\n    }\r\n\r\n    function setThorMutualContract(ThorMutualInterface _thorMutualContract) public onlyOwner {\r\n        require(address(_thorMutualContract) != address(0));\r\n        thorMutualContract = _thorMutualContract;\r\n    }\r\n\r\n    /**\r\n     * @dev return the index of token with daily maximum drawdown\r\n     * @return the index of token with maximum drawdown\r\n     */\r\n    function getMaxDailyDrawdown(uint period) external view returns(ThorMutualTokenInterface) {\r\n\r\n        return dailyTokenWinners[period];\r\n    }\r\n\r\n    /**\r\n     * @dev return the index of token with weekly maximum drawdown\r\n     * @return the index of token with maximum drawdown\r\n     */\r\n    function getMaxWeeklyDrawdown(uint period) external view returns(ThorMutualTokenInterface) {\r\n\r\n        return weeklyTokenWinners[period / WEEKLY_PERIOD];\r\n    }\r\n\r\n    /**\r\n     * @dev return the index of token with maximum drawdown\r\n     * @param period period\r\n     * @return the index of token with maximum drawdown\r\n     */\r\n    function _getMaxDrawdown(uint period, uint actualPeriod) internal returns(ThorMutualTokenInterface, int) {\r\n\r\n        uint currentPeriod = actualPeriod;\r\n        uint oldPeriod = (actualPeriod - period);\r\n\r\n        uint periodDrawdownMaxIndex = UINT_MAX;\r\n\r\n        uint settlePeriod;\r\n\r\n        int maxDrawdown = INT_MAX;\r\n        // address[] memory particpantsOfToken;\r\n        uint amountOfParticipant;\r\n\r\n        for (uint i = 0; i < tokensIncluded.length; i++) {\r\n            address token = tokensIncluded[i];\r\n\r\n            \r\n            if (period == DAILY_PERIOD) {\r\n                settlePeriod = currentPeriod - 1;\r\n                (, amountOfParticipant) = ThorMutualTokenInterface(token).getParticipantsDaily(settlePeriod);\r\n            } else if (period == WEEKLY_PERIOD) {\r\n                settlePeriod = (currentPeriod - 1) / WEEKLY_PERIOD;\r\n                (, amountOfParticipant) = ThorMutualTokenInterface(token).getParticipantsWeekly(settlePeriod);\r\n            }\r\n\r\n            int currentPeriodPrice = int(dailyTokensPrices[currentPeriod][token].price);\r\n            int oldPeriodPrice = int(dailyTokensPrices[oldPeriod][token].price);\r\n\r\n            int drawdown = (currentPeriodPrice - oldPeriodPrice) * PRICE_DECIMALS / oldPeriodPrice;\r\n\r\n            if (amountOfParticipant > 0) {\r\n                if (drawdown < maxDrawdown) {\r\n                    maxDrawdown = drawdown;\r\n                    periodDrawdownMaxIndex = i;\r\n                }\r\n            }\r\n\r\n            // daily drawdown data\r\n            if (period == DAILY_PERIOD) {\r\n                settlePeriod = currentPeriod - 1;\r\n                dailyTokensPricesDrawdown[settlePeriod].push(drawdown);\r\n            } else if(period == WEEKLY_PERIOD) {\r\n                settlePeriod = (currentPeriod - 1) / WEEKLY_PERIOD;\r\n                weeklyTokensPricesDrawdown[settlePeriod].push(drawdown);\r\n            }\r\n\r\n        }\r\n\r\n        if (periodDrawdownMaxIndex == UINT_MAX) {\r\n            return (ThorMutualTokenInterface(address(0)), maxDrawdown);\r\n        }\r\n\r\n        return (ThorMutualTokenInterface(tokensIncluded[periodDrawdownMaxIndex]), maxDrawdown);\r\n    }\r\n    \r\n    function getDailyAndWeeklyPriceDrawdownInfo(uint period) public view returns(address[], int[], int[]) {\r\n        uint periodWeekly = period / WEEKLY_PERIOD;\r\n        return (tokensIncluded, dailyTokensPricesDrawdown[period], weeklyTokensPricesDrawdown[periodWeekly]);\r\n    }\r\n\r\n    function withdraw(address receiver, uint amount) public onlyOwner {\r\n        require(receiver != address(0));\r\n\r\n        receiver.transfer(amount);\r\n    }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"getSelfBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCurrentPeriod\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"settle\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_rewardAddressOfPlatfrom\",\"type\":\"address\"}],\"name\":\"setRewardAddressOfPlatfrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"thorMutual\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_thorMutualTokens\",\"type\":\"address[]\"},{\"name\":\"_length\",\"type\":\"uint256\"}],\"name\":\"setThorMutualTokenContracts\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_thorMutualWeeklyReward\",\"type\":\"address\"}],\"name\":\"setThorMutualWeeklyReward\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_distributeRatioOfDaily\",\"type\":\"uint256\"},{\"name\":\"_distributeRatioOfWeekly\",\"type\":\"uint256\"},{\"name\":\"_distributeRatioOfPlatform\",\"type\":\"uint256\"},{\"name\":\"_ratioWeekly\",\"type\":\"uint256\"}],\"name\":\"setThorMutualParms\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"period\",\"type\":\"uint256\"}],\"name\":\"getWeeklyWinnerTokenInfo\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"thorMutualTokenPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"thorMutualWeeklyReward\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getThorMutualParms\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_thorMutualTokenPrice\",\"type\":\"address\"}],\"name\":\"setThorMutualTokenPrice\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"period\",\"type\":\"uint256\"},{\"name\":\"winner\",\"type\":\"address\"}],\"name\":\"getDailyAndWeeklyWinnerInfo\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"period\",\"type\":\"uint256\"}],\"name\":\"getDailyWinnerTokenInfo\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"address[]\"},{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"receiver\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"DepositToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"ThorMutualRewardOfPlatfrom\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"ThorMutual","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://4d0d71d4108f27c643390de2183d0ad0a13a004dc6958fdc6bbd1211e74b8a09"}]}