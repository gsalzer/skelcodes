{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.1;\r\n\r\n// Interface for interacting with Compound\r\ninterface CompoundContract {\r\n    function  supply (address asset, uint256 amount) external returns (uint256);\r\n    function withdraw (address asset, uint256 requestedAmount) external returns (uint256);\r\n}\r\n\r\n// Interface for interacting with tokens\r\ninterface token {\r\n    function transfer(address _to, uint256 _value) external returns (bool success) ;\r\n    function approve(address _spender, uint256 _value) external returns (bool);\r\n    function balanceOf(address owner) external returns (uint256);\r\n}\r\n\r\n// Basic ownership library\r\n contract owned {\r\n        address public owner;\r\n\r\n        constructor() public {\r\n            owner = msg.sender;\r\n        }\r\n\r\n        modifier onlyOwner {\r\n            require(msg.sender == owner);\r\n            _;\r\n        }\r\n\r\n        function transferOwnership(address newOwner) onlyOwner public {\r\n            owner = newOwner;\r\n        }\r\n    }\r\n\r\n// Here we start\r\ncontract CompoundPayroll is owned {\r\n    // first, let's define the contracts we'll be interacting with\r\n    address compoundAddress = 0x3FDA67f7583380E67ef93072294a7fAc882FD7E7;\r\n    address daiAddress = 0x89d24A6b4CcB1B6fAA2625fE562bDD9a23260359;\r\n    CompoundContract compound = CompoundContract(compoundAddress);\r\n    token dai = token(daiAddress);\r\n    \r\n    // Now let's create a payroll object\r\n    Salary[] public payroll;\r\n    mapping (address => uint) public salaryId;\r\n    uint public payrollLength;\r\n    \r\n    struct Salary {\r\n        address recipient;\r\n        uint payRate;\r\n        uint lastPaid;\r\n        string name;\r\n    }\r\n    \r\n    // An event for easier accounting\r\n    event MemberPaid(address recipient, uint amount, string justification);\r\n\r\n    // The constructor is called when you init the contract    \r\n    constructor() public {\r\n        owner = msg.sender;\r\n        dai.approve(compoundAddress, 2 ** 128);\r\n        changePay(address(0), 0, now, '');\r\n    }\r\n    \r\n    // Sends all the current balance to Compound\r\n    function putInSavings() public  {\r\n        compound.supply(daiAddress, dai.balanceOf(address(this)));\r\n    }\r\n    \r\n    // Allows owner to make specific payments\r\n    function cashOut (uint256 amount, address recipient, string memory justification) public onlyOwner {\r\n        compound.withdraw(daiAddress, amount);\r\n        dai.transfer(recipient, amount);\r\n        emit MemberPaid( recipient,  amount, justification);\r\n\r\n    }\r\n\r\n    // Allows you to add or change a salary\r\n    function changePay(address recipient, uint yearlyPay, uint startingDate, string memory initials) onlyOwner public {\r\n        // check someone's salary ID\r\n        uint id = salaryId[recipient];\r\n        // if it returns 0 then create a new one\r\n        if (id == 0) {\r\n            salaryId[recipient] = payroll.length;\r\n            id = payroll.length++;\r\n        }\r\n        payroll[id] = Salary({\r\n            recipient: recipient, \r\n            payRate: yearlyPay / 365.25 days, \r\n            lastPaid:  startingDate >  0 ? startingDate : now, \r\n            name: initials});\r\n            \r\n        payrollLength = payroll.length;\r\n    }\r\n\r\n    // Removes a salary from the list\r\n    function removePay(address recipient) onlyOwner public {\r\n        require(salaryId[recipient] != 0);\r\n\r\n        for (uint i = salaryId[recipient]; i<payroll.length-1; i++){\r\n            payroll[i] = payroll[i+1];\r\n            salaryId[payroll[i].recipient] = i;\r\n        }\r\n        \r\n        salaryId[recipient] = 0;\r\n        delete payroll[payroll.length-1];\r\n        payroll.length--;\r\n        payrollLength = payroll.length;\r\n    }\r\n    \r\n    // How much are you owed right now?\r\n    function getAmountOwed(address recipient) view public returns (uint256) {\r\n        // get salary ID\r\n        uint id = salaryId[recipient];\r\n        if (id > 0) {\r\n            // If it exists, calculate how much you're owed right now\r\n            return (now - payroll[id].lastPaid) * payroll[id].payRate;\r\n        } else {\r\n            return 0;\r\n        }\r\n    }\r\n    \r\n    //Make one salary payment\r\n    function paySalary(address recipient, string memory justification) public {\r\n        // How much are you owed right now?\r\n        uint amount = getAmountOwed(recipient);\r\n        if (amount == 0) return;\r\n        \r\n        // Take it out from savings\r\n        compound.withdraw(daiAddress, amount);\r\n        \r\n        // Pay it out\r\n        payroll[salaryId[recipient]].lastPaid = now;\r\n        dai.transfer(recipient, amount);\r\n        emit MemberPaid( recipient,  amount, justification);\r\n    }\r\n    \r\n    // Pay all salaries\r\n    function payEveryone() public {\r\n        for (uint i = 1; i<payroll.length; i++){\r\n            paySalary(payroll[i].recipient, 'payAll');\r\n        }\r\n    }\r\n    \r\n    // pay everyone!\r\n    function payAll() public  {\r\n        uint totalToPay = 0;\r\n        uint[] memory payments = new uint[](payrollLength);\r\n        uint amount; \r\n       \r\n        for (uint i = 1; i<payrollLength; i++){\r\n            amount = (now - payroll[i].lastPaid) * payroll[i].payRate;\r\n            totalToPay += amount;\r\n            payments[i] = amount;\r\n        } \r\n        \r\n        compound.withdraw(daiAddress, totalToPay);\r\n                \r\n        for (uint i = 1; i<payrollLength; i++){\r\n            payroll[i].lastPaid = now;\r\n            dai.transfer(payroll[i].recipient, payments[i]);\r\n            emit MemberPaid(payroll[i].recipient, payments[i], 'payAll');\r\n        }  \r\n                \r\n    }\r\n    \r\n    // If pinged, save and pay everyone\r\n    function () external payable {\r\n        putInSavings();\r\n        payAll();\r\n        msg.sender.transfer(msg.value);\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"payroll\",\"outputs\":[{\"name\":\"recipient\",\"type\":\"address\"},{\"name\":\"payRate\",\"type\":\"uint256\"},{\"name\":\"lastPaid\",\"type\":\"uint256\"},{\"name\":\"name\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"getAmountOwed\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"salaryId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"payAll\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"recipient\",\"type\":\"address\"},{\"name\":\"yearlyPay\",\"type\":\"uint256\"},{\"name\":\"startingDate\",\"type\":\"uint256\"},{\"name\":\"initials\",\"type\":\"string\"}],\"name\":\"changePay\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"putInSavings\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"payrollLength\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"recipient\",\"type\":\"address\"},{\"name\":\"justification\",\"type\":\"string\"}],\"name\":\"cashOut\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"removePay\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"recipient\",\"type\":\"address\"},{\"name\":\"justification\",\"type\":\"string\"}],\"name\":\"paySalary\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"payEveryone\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"justification\",\"type\":\"string\"}],\"name\":\"MemberPaid\",\"type\":\"event\"}]","ContractName":"CompoundPayroll","CompilerVersion":"v0.5.3+commit.10d17f24","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://de90ed775da9371f88d693bdebc530505fa4653b6743af4180ddba894cb7974c"}]}