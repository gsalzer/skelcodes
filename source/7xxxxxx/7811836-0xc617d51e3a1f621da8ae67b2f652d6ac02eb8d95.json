{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.8;\r\n\r\n\r\n/// @title ERC20 Token Interface\r\n/// @author Hoard Team\r\n/// @notice See https://github.com/ethereum/EIPs/issues/20\r\ncontract ERC20Token {\r\n\r\n    // PUBLIC INTERFACE\r\n\r\n    // /// @dev Returns total amount of tokens\r\n    // /// @notice params -> (uint256 totalSupply)\r\n    // It's implamented as a variable which doesn't override this method. Commented to prevent compilation error.\r\n    // function totalSupply    () constant public returns (uint256);\r\n\r\n    /// @dev Returns balance of specified account\r\n    /// @notice params -> (address _owner)\r\n    function balanceOf      (address) view public returns (uint256);\r\n\r\n    /// @dev  Transfers tokens from msg.sender to a specified address\r\n    /// @notice params -> (address _to, uint256 _value)\r\n    function transfer       (address, uint256) public returns (bool);\r\n\r\n    /// @dev  Allowance mechanism - delegated transfer\r\n    /// @notice params -> (address _from, address _to, uint256 _value)\r\n    function transferFrom   (address, address, uint256) public returns (bool);\r\n\r\n    /// @dev  Allowance mechanism - approve delegated transfer\r\n    /// @notice params -> (address _spender, uint256 _value)\r\n    function approve        (address, uint256) public returns (bool);\r\n\r\n    /// @dev  Allowance mechanism - set allowance for specified address\r\n    /// @notice params -> (address _owner, address _spender)\r\n    function allowance      (address, address) public view returns (uint256);\r\n\r\n\r\n    // EVENTS\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n\r\n}\r\n\r\n\r\n/// @title Safe Math\r\n/// @author Open Zeppelin\r\n/// @notice implementation from - https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts/math/SafeMath.sol\r\nlibrary SafeMath {\r\n  function safeMul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function safeDiv(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function safeSub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function safeAdd(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n  \r\n  function max256(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    return a >= b ? a : b;\r\n  }\r\n\r\n  function min256(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    return a < b ? a : b;\r\n  }\r\n\r\n}\r\n\r\n\r\n\r\n/// @title Standard ERC20 compliant token\r\n/// @author Hoard Team\r\n/// @notice Original taken from https://github.com/ethereum/EIPs/issues/20\r\n/// @notice SafeMath used as specified by OpenZeppelin\r\n/// @notice Comments and additional approval code from https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts/token\r\ncontract StandardToken is ERC20Token {\r\n\r\n    using SafeMath for uint256;\r\n\r\n    mapping (address => uint256) balances;\r\n\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n\r\n    uint256 public totalSupply;\r\n\r\n   /// @dev transfer token for a specified address\r\n   /// @param _to The address to transfer to.\r\n   /// @param _value The amount to be transferred.\r\n   function transfer(address _to, uint256 _value) public returns (bool) {\r\n        balances[msg.sender] = balances[msg.sender].safeSub(_value);\r\n        balances[_to] = balances[_to].safeAdd(_value);\r\n\r\n        emit Transfer(msg.sender, _to, _value);            \r\n\r\n        return true;\r\n    }\r\n\r\n    /// @dev Transfer tokens from one address to another\r\n    /// @param _from address The address which you want to send tokens from\r\n    /// @param _to address The address which you want to transfer to\r\n    /// @param _value uint256 the amount of tokens to be transferred\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\r\n        uint256 _allowance = allowed[_from][msg.sender];\r\n\r\n        // Check is not needed because sub(_allowance, _value) will already throw if this condition is not met\r\n        // require (_value <= _allowance);        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n\r\n        balances[_to] = balances[_to].safeAdd(_value);\r\n        balances[_from] = balances[_from].safeSub(_value);\r\n        allowed[_from][msg.sender] = _allowance.safeSub(_value);\r\n\r\n        emit Transfer(_from, _to, _value);\r\n            \r\n        return true;\r\n    }\r\n\r\n    /// @dev Gets the balance of the specified address.\r\n    /// @param _owner The address to query the the balance of. \r\n    /// @return An uint256 representing the amount owned by the passed address.\r\n    function balanceOf(address _owner) view public returns (uint256) {\r\n        return balances[_owner];\r\n    }\r\n\r\n   /// @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n   /// @param _spender The address which will spend the funds.\r\n   /// @param _value The amount of tokens to be spent.\r\n   function approve(address _spender, uint256 _value) public returns (bool) {\r\n        // To change the approve amount you first have to reduce the addresses`\r\n        //  allowance to zero by calling `approve(_spender, 0)` if it is not\r\n        //  already 0 to mitigate the race condition described here:\r\n        //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n        require((_value == 0) || (allowed[msg.sender][_spender] == 0));\r\n        \r\n        allowed[msg.sender][_spender] = _value;\r\n\r\n        emit Approval(msg.sender, _spender, _value);\r\n\r\n        return true;\r\n    }\r\n\r\n   /// @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n   /// @param _owner address The address which owns the funds.\r\n   /// @param _spender address The address which will spend the funds.\r\n   /// @return A uint256 specifying the amount of tokens still available for the spender.\r\n   function allowance(address _owner, address _spender) view public returns (uint256) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n    /// @notice approve should be called when allowed[_spender] == 0. To increment\r\n    /// allowed value it is better to use this function to avoid 2 calls (and wait until \r\n    /// the first transaction is mined)\r\n    function increaseApproval (address _spender, uint256 _addedValue) public returns (bool) {\r\n        allowed[msg.sender][_spender] = allowed[msg.sender][_spender].safeAdd(_addedValue);\r\n\r\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n\r\n        return true;\r\n    }\r\n\r\n    /// @notice approve should be called when allowed[_spender] == 0. To decrement\r\n    /// allowed value it is better to use this function to avoid 2 calls (and wait until \r\n    /// the first transaction is mined)\r\n    function decreaseApproval (address _spender, uint256 _subtractedValue) public returns (bool) {\r\n        uint256 oldValue = allowed[msg.sender][_spender];\r\n        \r\n        if (_subtractedValue > oldValue) {\r\n            allowed[msg.sender][_spender] = 0;\r\n        } else {\r\n            allowed[msg.sender][_spender] = oldValue - _subtractedValue;\r\n        }\r\n\r\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n\r\n        return true;\r\n    }\r\n\r\n}\r\n\r\n\r\n/// @title Migration Agent interface\r\n/// @author Hoard Team\r\n/// @notice Based on GNT implementation - https://github.com/golemfactory/golem-crowdfunding/blob/master/contracts/Token.sol\r\ncontract MigrationAgent {\r\n\r\n    /// @dev migrates tokens or other \"assets\" from one contract to another (not yet specified)\r\n    /// @notice parameters -> (address _from, uint _value)\r\n    function migrateFrom(address, uint256) public;\r\n}\r\n\r\n\r\n/// @title Mintable token interface\r\n/// @author Hoard Team\r\ncontract Mintable {\r\n\r\n    /// @dev Mint new tokens  \r\n    /// @notice params -> (address _recipient, uint256 _amount)\r\n    function mintTokens         (address, uint256) public;\r\n}\r\n\r\n\r\n/// @title Migratable entity interface\r\n/// @author Hoard Team\r\ncontract Migratable {\r\n\r\n    /// @dev Migrates tokens for msg.sender  \r\n    /// @notice params -> (uint256 _value)\r\n    function migrate            (uint256) public;\r\n\r\n\r\n    // EVENTS\r\n\r\n    event Migrate               (address indexed _from, address indexed _to, uint256 _value);\r\n}\r\n\r\n\r\n/// @title Standard ERC20 compliant token\r\n/// @author Hoard Team\r\ncontract ExtendedStandardToken is StandardToken, Migratable, Mintable {\r\n\r\n    address public migrationAgent;\r\n    uint256 public totalMigrated;\r\n\r\n\r\n    // MODIFIERS\r\n\r\n    modifier migrationAgentSet {\r\n        require(migrationAgent != address(0));\r\n        _;\r\n    }\r\n\r\n    modifier migrationAgentNotSet {\r\n        require(migrationAgent == address(0));\r\n        _;\r\n    }\r\n\r\n    /// @dev Internal constructor to prevent bare instances of this contract\r\n    constructor () internal {\r\n    }\r\n\r\n    // MIGRATION LOGIC\r\n\r\n    /// @dev Migrates tokens for msg.sender and burns them\r\n    /// @param _value amount of tokens to migrate\r\n    function migrate            (uint256 _value) public {\r\n\r\n        // Validate input value\r\n        require(_value > 0);\r\n    \r\n        //require(_value <= balances[msg.sender]);\r\n        //not necessary as safeSub throws in case the above condition does not hold\r\n    \r\n        balances[msg.sender] = balances[msg.sender].safeSub(_value);\r\n        totalSupply = totalSupply.safeSub(_value);\r\n        totalMigrated = totalMigrated.safeAdd(_value);\r\n\r\n        MigrationAgent(migrationAgent).migrateFrom(msg.sender, _value);\r\n\r\n        emit Migrate(msg.sender, migrationAgent, _value);\r\n    }\r\n\r\n\r\n    // MINTING LOGIC\r\n\r\n    /// @dev Mints additional tokens\r\n    /// @param _recipient owner of new tokens \r\n    /// @param _amount amount of tokens to mint\r\n    function mintTokens         (address _recipient, uint256 _amount) public {\r\n        require(_amount > 0);\r\n\r\n        balances[_recipient] = balances[_recipient].safeAdd(_amount);\r\n        totalSupply = totalSupply.safeAdd(_amount);\r\n\r\n        // Log token creation event\r\n        emit Transfer(address(0), msg.sender, _amount);\r\n    }\r\n\r\n\r\n    // CONTROL LOGIC\r\n\r\n    /// @dev Sets address of a new migration agent\r\n    /// @param _address address of new migration agent \r\n    function setMigrationAgent  (address _address) public {\r\n        migrationAgent = _address; \r\n    }\r\n\r\n}\r\n\r\n\r\n\r\n/// @title Hoard Token (HRD) - crowdfunding code for Hoard token\r\n/// @author Hoard Team\r\n/// @notice Based on MLN implementation - https://github.com/melonproject/melon/blob/master/contracts/tokens/MelonToken.sol\r\n/// @notice Based on GNT implementation - https://github.com/golemfactory/golem-crowdfunding/blob/master/contracts/Token.sol\r\ncontract HoardToken is ExtendedStandardToken {\r\n\r\n    // Token description fields\r\n    string public constant name = \"Hoard Token\";\r\n    string public constant symbol = \"HRD\";\r\n    uint256 public constant decimals = 18;  // 18 decimal places, the same as ETH\r\n\r\n    // contract supervision variables\r\n    address public creator;\r\n    address public hoard;\r\n    address public migrationMaster;\r\n\r\n\r\n    // MODIFIERS\r\n\r\n    modifier onlyCreator {\r\n        require(msg.sender == creator);\r\n        _;\r\n    }\r\n\r\n    modifier onlyHoard {\r\n        require(msg.sender == hoard);\r\n        _;\r\n    }\r\n\r\n    modifier onlyMigrationMaster {\r\n        require(msg.sender == migrationMaster);\r\n        _;\r\n    }\r\n\r\n    // CONSTRUCTION\r\n\r\n    /// @param _hoard Hoard multisig contract\r\n    /// @param _migrationMaster migration master\r\n    constructor (address _hoard, address _migrationMaster) public {\r\n        require(_hoard != address(0));\r\n        require(_migrationMaster != address(0));\r\n\r\n        creator = msg.sender;\r\n        hoard = _hoard;\r\n        migrationMaster = _migrationMaster;\r\n    }\r\n\r\n\r\n    // BASE CLASS IMPLEMENTATION\r\n\r\n    /// @notice ExtendedStandardToken is StandardToken\r\n    function transfer               (address _to, uint256 _value) public\r\n        returns (bool) \r\n    {\r\n        return super.transfer(_to, _value);\r\n    }\r\n\r\n\r\n    /// @notice ExtendedStandardToken is StandardToken\r\n    function transferFrom           (address _from, address _to, uint256 _value) public \r\n        returns (bool)\r\n    {\r\n        return super.transferFrom(_from, _to, _value);\r\n    }\r\n\r\n\r\n    /// @notice ExtendedStandardToken is Migratable\r\n    function migrate                (uint256 _value) public migrationAgentSet {\r\n        super.migrate(_value);    \r\n    }\r\n\r\n    /// @notice ExtendedStandardToken\r\n    function setMigrationAgent      (address _address) public onlyMigrationMaster migrationAgentNotSet {\r\n        require(_address != address(0));\r\n\r\n        super.setMigrationAgent(_address);\r\n    }\r\n\r\n    /// @notice ExtendedStandardToken is Mintable\r\n    function mintTokens             (address _recipient, uint256 _amount) public onlyCreator {\r\n        super.mintTokens(_recipient, _amount);\r\n    }\r\n\r\n    // CONTROL LOGIC\r\n\r\n    /// @dev changes Hoard multisig address to another one\r\n    function changeHoardAddress     (address _address) onlyHoard external { hoard = _address; }\r\n\r\n    /// @dev changes migration master address to another one\r\n    function changeMigrationMaster  (address _address) onlyHoard external { migrationMaster = _address; }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"creator\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"migrate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"changeMigrationMaster\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseApproval\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"migrationMaster\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"setMigrationAgent\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"changeHoardAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"migrationAgent\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalMigrated\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"hoard\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseApproval\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_recipient\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"mintTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_hoard\",\"type\":\"address\"},{\"name\":\"_migrationMaster\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Migrate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"HoardToken","CompilerVersion":"v0.5.8+commit.23d335f2","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000c14f6e197f8116e5ee3dd5d6049635ba6d7060df000000000000000000000000c14f6e197f8116e5ee3dd5d6049635ba6d7060df","Library":"","SwarmSource":"bzzr://773aa0e6bb1a136488e3a52befd47cf69ae3e4674aeaf6b20f9d5f520dca97fc"}]}