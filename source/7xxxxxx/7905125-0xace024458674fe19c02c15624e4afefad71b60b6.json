{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n// pragma experimental ABIEncoderV2;\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n    int256 constant private INT256_MIN = -2**255;\r\n\r\n    /**\r\n    * @dev Multiplies two unsigned integers, reverts on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Multiplies two signed integers, reverts on overflow.\r\n    */\r\n    function mul(int256 a, int256 b) internal pure returns (int256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        require(!(a == -1 && b == INT256_MIN)); // This is the only case of overflow not detected by the check below\r\n\r\n        int256 c = a * b;\r\n        require(c / a == b);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two signed integers truncating the quotient, reverts on division by zero.\r\n    */\r\n    function div(int256 a, int256 b) internal pure returns (int256) {\r\n        require(b != 0); // Solidity only automatically asserts when dividing by 0\r\n        require(!(b == -1 && a == INT256_MIN)); // This is the only case of overflow\r\n\r\n        int256 c = a / b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two signed integers, reverts on overflow.\r\n    */\r\n    function sub(int256 a, int256 b) internal pure returns (int256) {\r\n        int256 c = a - b;\r\n        require((b >= 0 && c <= a) || (b < 0 && c > a));\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two unsigned integers, reverts on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two signed integers, reverts on overflow.\r\n    */\r\n    function add(int256 a, int256 b) internal pure returns (int256) {\r\n        int256 c = a + b;\r\n        require((b >= 0 && c >= a) || (b < 0 && c < a));\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\r\n    * reverts when dividing by zero.\r\n    */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n\r\nlibrary Helper {\r\n    using SafeMath for uint256;\r\n    \r\n        \r\n    function bytes32ToUint(bytes32 n) \r\n        public\r\n        pure\r\n        returns (uint256) \r\n    {\r\n        return uint256(n);\r\n    }\r\n    \r\n    function stringToBytes32(string memory source) \r\n        public\r\n        pure\r\n        returns (bytes32 result) \r\n    {\r\n        bytes memory tempEmptyStringTest = bytes(source);\r\n        if (tempEmptyStringTest.length == 0) {\r\n            return 0x0;\r\n        }\r\n\r\n        assembly {\r\n            result := mload(add(source, 32))\r\n        }\r\n    }\r\n    \r\n    function stringToUint(string memory source) \r\n        public\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return bytes32ToUint(stringToBytes32(source));\r\n    }\r\n    \r\n    function validUsername(string _username)\r\n        public\r\n        pure\r\n        returns(bool)\r\n    {\r\n        bytes memory b = bytes(_username);\r\n        // Im Raum [4, 18]\r\n        if ((b.length < 4) || (b.length > 18)) return false;\r\n        // Letzte Char != ' '\r\n        \r\n        for(uint i; i<b.length; i++){\r\n            bytes1 char = b[i];\r\n            if(\r\n                !(char >= 0x30 && char <= 0x39) &&\r\n                !(char >= 0x41 && char <= 0x5A) //A-Z\r\n            )\r\n                return false;\r\n        }\r\n        \r\n        if (b[0] >= 0x30 && b[0] <= 0x39) return false;\r\n        \r\n        return true;\r\n    }   \r\n}\r\n\r\ninterface DAAInterface {\r\n    function citizenMintToken(address _buyer, uint256 _buyPrice, int8 _is_win) external returns(uint256);\r\n    function transfer(address _to, uint256 _value) external returns(bool);\r\n    function transferFrom(address _from, address _to, uint256 _tokenAmount) external returns(bool);\r\n    function balanceOf(address _from) external returns(uint256);\r\n    function currentRoundDividend() external;\r\n    function getDividendView(address _sender) external returns(uint256);\r\n    function getDividendPull(address _sender, uint256 _value) external returns(uint256);\r\n    function payOut(address _winner, uint256 _unit, uint256 _value, uint256 _valuebet) external;\r\n    function getCitizenBalanceEth(address _sender) external returns(uint256);\r\n    function totalSupplyByAddress(address _sender) external returns(uint256);\r\n}\r\n\r\ninterface TicketInterface{\r\n    function getEarlyIncomePull(address _sender) external returns(uint256);\r\n    function getEarlyIncomeView(address _sender, bool _current) external returns(uint256); \r\n    function getEarlyIncomeByRound(address _buyer, uint256 _round) external returns(uint256);\r\n    function currentRound() external returns(uint256);\r\n    function ticketSumByAddress(address _sender) external returns(uint256);\r\n}\r\n\r\ncontract CitizenStorage{\r\n    using SafeMath for uint256;\r\n    \r\n    address controller; \r\n    modifier onlyCoreContract() {\r\n        require(msg.sender == controller, \"admin required\");\r\n        _;\r\n    }\r\n    \r\n    mapping (address => uint256) public citizenWinIncome;\r\n    mapping (address => uint256) public citizenGameWinIncome;\r\n    mapping (address => uint256) public citizenWithdrawed;\r\n    \r\n    function addWinIncome(address _citizen, uint256 _value) public onlyCoreContract() {\r\n         citizenWinIncome[_citizen] = _value.add(citizenWinIncome[_citizen]);\r\n         citizenWithdrawed[_citizen] = citizenWithdrawed[_citizen].add(_value);\r\n    }\r\n    function addGameWinIncome(address _citizen, uint256 _value, bool _enough) public onlyCoreContract() {\r\n        citizenGameWinIncome[_citizen] = _value.add(citizenGameWinIncome[_citizen]);\r\n        if (_enough){\r\n            citizenWithdrawed[_citizen] = citizenWithdrawed[_citizen].add(_value);\r\n        }\r\n    }\r\n    function pushCitizenWithdrawed(address _sender, uint256 _value) public onlyCoreContract(){\r\n        citizenWithdrawed[_sender] = citizenWithdrawed[_sender].add(_value);\r\n    }\r\n    constructor (address _contract)\r\n        public\r\n    {\r\n        require(controller== 0x0, \"require setup\");\r\n        controller = _contract;\r\n    }\r\n}\r\n\r\ncontract Citizen{\r\n    using SafeMath for uint256;\r\n    \r\n    // event Register(uint256 id, uint256 username, address indexed citizen, address indexed ref,\r\n    //                 uint256 ticket, uint256 ticketSpend, uint256 totalGameSpend, uint256 totalMined,\r\n    //                 uint256 dateJoin, uint256 totalWithdraw);\r\n                    \r\n    event Register(uint256 id, uint256 username, address indexed citizen, address indexed ref, uint256 ticketSpend, uint256 totalGameSpend, uint256 dateJoin);\r\n    modifier onlyAdmin() {\r\n        require(msg.sender == devTeam1, \"admin required\");\r\n        _;\r\n    }\r\n    \r\n    modifier onlyCoreContract() {\r\n        require(isCoreContract[msg.sender], \"admin required\");\r\n        _;\r\n    }\r\n\r\n    modifier notRegistered(){\r\n        require(!isCitizen[msg.sender], \"already exist\");\r\n        _;\r\n    }\r\n\r\n    modifier registered(){\r\n        require(isCitizen[msg.sender], \"must be a citizen\");\r\n        _;\r\n    }\r\n    \r\n    uint8[10] public TICKET_LEVEL_REF = [uint8(60),40,20,10,10,10,5,5,5,5];// 3 demical\r\n    uint8[10] public GAME_LEVEL_REF = [uint8(5),2,1,1,1,1,1,1,1,1];// 3 demical\r\n    \r\n    \r\n    struct Profile{\r\n        uint256 id;\r\n        uint256 username;\r\n        address ref;\r\n        mapping(uint => address[]) refTo;\r\n        mapping(address => uint256) payOut;\r\n        uint256 totalChild;\r\n        uint256 treeLevel;\r\n        \r\n        uint256 citizenBalanceEth;\r\n        uint256 citizenBalanceEthBackup;\r\n        \r\n        uint256 citizenTicketSpend;\r\n        uint256 citizenGameEthSpend;\r\n        uint256 citizenGameTokenSpend;\r\n        \r\n        \r\n        uint256 citizenEarlyIncomeRevenue;\r\n        uint256 citizenTicketRevenue;\r\n        uint256 citizenGameEthRevenue;\r\n        uint256 citizenGameTokenRevenue;\r\n    }\r\n\r\n\r\n    \r\n    mapping (address => uint256) public citizenEthDividend;\r\n\r\n    address[21] public mostTotalSpender;\r\n    mapping (address => uint256) public mostTotalSpenderId;\r\n    mapping (address => mapping(uint256 => uint256)) public payOutByLevel;\r\n    \r\n    mapping (address => Profile) public citizen;\r\n    mapping (address => bool) public isCitizen;\r\n    mapping (uint256 => address) public idAddress;\r\n    mapping (uint256 => address) public usernameAddress;\r\n    mapping (uint256 => address[]) public levelCitizen;\r\n\r\n\r\n    address devTeam1; \r\n    address devTeam2; \r\n    address devTeam3; \r\n    address devTeam4;\r\n    \r\n    uint256 public citizenNr;\r\n    uint256 lastLevel;\r\n    \r\n    uint256 earlyIncomeBalanceEth;\r\n    \r\n    DAAInterface public DAAContract;\r\n    TicketInterface public TicketContract;\r\n    CitizenStorage public CitizenStorageContract;\r\n    mapping (address => bool) public isCoreContract;\r\n    uint256 public coreContractSum;\r\n    address[] public coreContracts;\r\n    \r\n\r\n    constructor (address[4] _devTeam)\r\n        public\r\n    {\r\n        devTeam1 = _devTeam[0];\r\n        devTeam2 = _devTeam[1];\r\n        devTeam3 = _devTeam[2];\r\n        devTeam4 = _devTeam[3];\r\n\r\n        // first citizen is the development team\r\n        citizenNr = 1;\r\n        idAddress[1] = devTeam3;\r\n        isCitizen[devTeam3] = true;\r\n        //root => self ref\r\n        citizen[devTeam3].ref = devTeam3;\r\n        // username rules bypass\r\n        uint256 _username = Helper.stringToUint(\"GLOBAL\");\r\n        citizen[devTeam3].username = _username;\r\n        usernameAddress[_username] = devTeam3; \r\n        citizen[devTeam3].id = 1;\r\n        citizen[devTeam3].treeLevel = 1;\r\n        levelCitizen[1].push(devTeam3);\r\n        lastLevel = 1;\r\n    }\r\n    \r\n    // DAAContract, TicketContract, CitizenContract, CitizenStorage \r\n    function joinNetwork(address[4] _contract)\r\n        public\r\n    {\r\n        require(address(DAAContract) == 0x0,\"already setup\");\r\n        DAAContract = DAAInterface(_contract[0]);\r\n        TicketContract = TicketInterface(_contract[1]);\r\n        CitizenStorageContract = CitizenStorage(_contract[3]);\r\n        for(uint256 i =0; i<3; i++){\r\n            isCoreContract[_contract[i]]=true;\r\n            coreContracts.push(_contract[i]);\r\n        }\r\n        coreContractSum = 3;\r\n    }\r\n\r\n    function updateTotalChild(address _address)\r\n        private\r\n    {\r\n        address _member = _address;\r\n        while(_member != devTeam3) {\r\n            _member = getRef(_member);\r\n            citizen[_member].totalChild ++;\r\n        }\r\n    }\r\n    \r\n    function addCoreContract(address _address) public  // [dev1]\r\n        onlyAdmin()\r\n    {\r\n        require(_address!=0x0,\"Invalid address\");\r\n        isCoreContract[_address] = true;\r\n        coreContracts.push(_address);\r\n        coreContractSum+=1;\r\n    }\r\n    \r\n    function updateRefTo(address _address) private {\r\n        address _member = _address;\r\n        uint256 level =1;\r\n        while (_member != devTeam3 && level<11){\r\n            _member = getRef(_member);\r\n            citizen[_member].refTo[level].push(_address);\r\n            level = level+1;\r\n        }\r\n    }\r\n\r\n    function register(string _sUsername, address _ref)\r\n        public\r\n        notRegistered()\r\n    {\r\n        require(Helper.validUsername(_sUsername), \"invalid username\");\r\n        address sender = msg.sender;\r\n        uint256 _username = Helper.stringToUint(_sUsername);\r\n        require(usernameAddress[_username] == 0x0, \"username already exist\");\r\n        usernameAddress[_username] = sender;\r\n        //ref must be a citizen, else ref = devTeam\r\n        address validRef = isCitizen[_ref] ? _ref : devTeam3;\r\n\r\n        //Welcome new Citizen\r\n        isCitizen[sender] = true;\r\n        citizen[sender].username = _username;\r\n        citizen[sender].ref = validRef;\r\n        citizenNr++;\r\n\r\n        idAddress[citizenNr] = sender;\r\n        citizen[sender].id = citizenNr;\r\n        \r\n        uint256 refLevel = citizen[validRef].treeLevel;\r\n        if (refLevel == lastLevel) lastLevel++;\r\n        citizen[sender].treeLevel = refLevel + 1;\r\n        levelCitizen[refLevel + 1].push(sender);\r\n        //add child\r\n        updateRefTo(sender);\r\n        updateTotalChild(sender);\r\n        emit Register(citizenNr,_username, sender, validRef, citizen[sender].citizenTicketSpend, citizen[sender].citizenGameEthSpend, now);\r\n    }\r\n    \r\n    // function updateUsername(string _sNewUsername)\r\n    //     public\r\n    //     registered()\r\n    // {\r\n    //     require(Helper.validUsername(_sNewUsername), \"invalid username\");\r\n    //     address sender = msg.sender;\r\n    //     uint256 _newUsername = Helper.stringToUint(_sNewUsername);\r\n    //     require(usernameAddress[_newUsername] == 0x0, \"username already exist\");\r\n    //     uint256 _oldUsername = citizen[sender].username;\r\n    //     citizen[sender].username = _newUsername;\r\n    //     usernameAddress[_oldUsername] = 0x0;\r\n    //     usernameAddress[_newUsername] = sender;\r\n    // }\r\n\r\n    function getRef(address _address)\r\n        public\r\n        view\r\n        returns (address)\r\n    {\r\n        return citizen[_address].ref == 0x0 ? devTeam3 : citizen[_address].ref;\r\n    }\r\n    \r\n    function getUsername(address _address)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return citizen[_address].username;\r\n    }\r\n    \r\n    function isDev() public view returns(bool){\r\n        if (msg.sender == devTeam1) return true;\r\n        return false;\r\n    }\r\n    \r\n    function getAddressById(uint256 _id)\r\n        public\r\n        view\r\n        returns (address)\r\n    {\r\n        return idAddress[_id];\r\n    }\r\n\r\n    function getAddressByUserName(string _username)\r\n        public\r\n        view\r\n        returns (address)\r\n    {\r\n        return usernameAddress[Helper.stringToUint(_username)];\r\n    }\r\n    \r\n    function pushTicketRefIncome(address _sender)\r\n        public\r\n        payable\r\n        onlyCoreContract() \r\n    {\r\n        uint256 _amount = msg.value; // 17%\r\n        _amount = _amount.div(170);\r\n        address sender = _sender;\r\n        address ref = getRef(sender);\r\n        uint256 money;\r\n        uint8 level;\r\n        \r\n        for (level=0; level<10; level++){\r\n            money = _amount.mul(TICKET_LEVEL_REF[level]);\r\n            citizen[ref].citizenBalanceEth = money.add(citizen[ref].citizenBalanceEth);\r\n            citizen[ref].citizenTicketRevenue = money.add(citizen[ref].citizenTicketRevenue);\r\n            citizen[ref].payOut[_sender] = money.add(citizen[ref].payOut[_sender]);\r\n            payOutByLevel[ref][level+1] = money.add(payOutByLevel[ref][level+1]);\r\n            sender = ref;\r\n            ref = getRef(sender);\r\n        }\r\n    }    \r\n    \r\n    function pushGametRefIncome(address _sender)\r\n        public\r\n        payable\r\n        onlyCoreContract() \r\n    {\r\n        uint256 _amount =  msg.value; // 1.5%\r\n        _amount = _amount.div(15);\r\n        address sender = _sender;\r\n        address ref = getRef(sender);\r\n        uint256 level;\r\n        uint256 money;\r\n        uint256 forDaa;\r\n        for (level=0; level<10; level++){\r\n            forDaa=0;\r\n            money = _amount.mul(GAME_LEVEL_REF[level]);\r\n            if (citizen[ref].citizenGameEthRevenue<citizen[ref].citizenGameEthSpend.div(10)){\r\n                if (citizen[ref].citizenGameEthRevenue+money>citizen[ref].citizenGameEthSpend.div(10)){\r\n                    forDaa = citizen[ref].citizenGameEthRevenue+money-citizen[ref].citizenGameEthSpend.div(10);\r\n                    money = money.sub(forDaa);\r\n                }\r\n            } else {\r\n                forDaa = money;\r\n                money = 0;\r\n            }\r\n            \r\n            citizen[ref].citizenBalanceEth = money.add(citizen[ref].citizenBalanceEth);\r\n            citizen[ref].citizenGameEthRevenue = money.add(citizen[ref].citizenGameEthRevenue);\r\n            citizen[ref].payOut[_sender] = money.add(citizen[ref].payOut[_sender]);\r\n            payOutByLevel[ref][level+1] = money.add(payOutByLevel[ref][level+1]);\r\n            \r\n            citizen[devTeam3].citizenBalanceEth = forDaa.add(citizen[devTeam3].citizenBalanceEth);\r\n            citizen[devTeam3].citizenGameEthRevenue = forDaa.add(citizen[devTeam3].citizenGameEthRevenue);\r\n            \r\n            sender = ref;\r\n            ref = getRef(sender);\r\n        }\r\n    }    \r\n    function pushGametRefIncomeToken(address _sender, uint256 _amount)\r\n        public\r\n        payable\r\n        onlyCoreContract() \r\n    {\r\n        _amount = _amount.div(15);\r\n        address sender = _sender;\r\n        address ref = getRef(sender);\r\n        uint256 level;\r\n        uint256 money;\r\n        uint256 forDaa;\r\n        \r\n        for (level=0; level<10; level++){\r\n            forDaa=0;\r\n            money = _amount.mul(GAME_LEVEL_REF[level]);\r\n            if (citizen[ref].citizenGameTokenRevenue<citizen[ref].citizenGameTokenSpend.div(10)){\r\n                if (citizen[ref].citizenGameTokenRevenue+money>citizen[ref].citizenGameTokenSpend.div(10)){\r\n                    forDaa = citizen[ref].citizenGameTokenRevenue+money-citizen[ref].citizenGameTokenSpend.div(10);\r\n                    money = money.sub(forDaa);\r\n                }\r\n            } else {\r\n                forDaa = money;\r\n                money = 0;\r\n            }\r\n            \r\n            DAAContract.payOut(ref,1,money,0);\r\n            citizen[ref].citizenGameTokenRevenue=money.add(citizen[ref].citizenGameTokenRevenue);\r\n            \r\n            DAAContract.payOut(devTeam3,1,forDaa,0);\r\n            citizen[devTeam3].citizenGameTokenRevenue = forDaa.add(citizen[devTeam3].citizenGameTokenRevenue);\r\n            \r\n            sender = ref;\r\n            ref = getRef(sender);\r\n        }\r\n    }\r\n    \r\n    function pushEarlyIncome() public payable{\r\n        uint256 _value = msg.value;\r\n        earlyIncomeBalanceEth = earlyIncomeBalanceEth.add(_value);\r\n    }\r\n    \r\n    function sortMostSpend(address _citizen) private {\r\n        uint256 citizen_spender = getTotalSpend(_citizen);\r\n        uint256 i=1;\r\n        while (i<21) {\r\n            if (mostTotalSpender[i]==0x0||(mostTotalSpender[i]!=0x0&&getTotalSpend(mostTotalSpender[i])<citizen_spender)){\r\n                if (mostTotalSpenderId[_citizen]!=0&&mostTotalSpenderId[_citizen]<i){\r\n                    break;\r\n                }\r\n                if (mostTotalSpenderId[_citizen]!=0){\r\n                    mostTotalSpender[mostTotalSpenderId[_citizen]]=0x0;\r\n                }\r\n                address temp1 = mostTotalSpender[i];\r\n                address temp2;\r\n                uint256 j=i+1;\r\n                while (j<21&&temp1!=0x0){\r\n                    temp2 = mostTotalSpender[j];\r\n                    mostTotalSpender[j]=temp1;\r\n                    mostTotalSpenderId[temp1]=j;\r\n                    temp1 = temp2;\r\n                    j++;\r\n                }\r\n                mostTotalSpender[i]=_citizen;\r\n                mostTotalSpenderId[_citizen]=i;\r\n                break;\r\n            }\r\n            i++;\r\n        }\r\n    }\r\n    \r\n    function addTicketEthSpend(address _citizen, uint256 _value) onlyCoreContract() public {\r\n        citizen[_citizen].citizenTicketSpend = citizen[_citizen].citizenTicketSpend.add(_value);\r\n        DAAContract.citizenMintToken(_citizen,_value,0);// buy ticket 0, win 1, lose -1;\r\n        sortMostSpend(_citizen);\r\n    }   \r\n    \r\n    // Game spend \r\n    function addGameEthSpendWin(address _citizen, uint256 _value, uint256 _valuewin, bool _enough) onlyCoreContract() public {\r\n        citizen[_citizen].citizenGameEthSpend = citizen[_citizen].citizenGameEthSpend.add(_value);\r\n        // DAAContract.citizenMintToken(_citizen,_value,1);// buy ticket 0, win 1, lose -1;\r\n        CitizenStorageContract.addGameWinIncome(_citizen, _valuewin, _enough);\r\n        sortMostSpend(_citizen);\r\n    }     \r\n    function addGameEthSpendLose(address _citizen, uint256 _value) onlyCoreContract() public {\r\n        citizen[_citizen].citizenGameEthSpend = citizen[_citizen].citizenGameEthSpend.add(_value);\r\n        DAAContract.citizenMintToken(_citizen,_value,-1);// buy ticket 0, win 1, lose -1;\r\n        sortMostSpend(_citizen);\r\n    }    \r\n    function addGameTokenSpend(address _citizen, uint256 _value) onlyCoreContract() public {\r\n        citizen[_citizen].citizenGameTokenSpend = citizen[_citizen].citizenGameTokenSpend.add(_value);\r\n    }\r\n    \r\n    function withdrawEth() public registered() {\r\n        address _sender = msg.sender;\r\n        uint256 _earlyIncome = TicketContract.getEarlyIncomePull(_sender);\r\n        uint256 _devidend = DAAContract.getDividendView(msg.sender);\r\n        uint256 _citizenBalanceEth = citizen[_sender].citizenBalanceEth;\r\n        uint256 _total = _earlyIncome.add(_devidend).add(_citizenBalanceEth).add(DAAContract.getCitizenBalanceEth(_sender));\r\n        require(_total>0,\"Balance none\");\r\n        CitizenStorageContract.pushCitizenWithdrawed(_sender,_total);\r\n        DAAContract.getDividendPull(_sender,_citizenBalanceEth+_earlyIncome);\r\n        _sender.transfer(_citizenBalanceEth+_earlyIncome);\r\n        citizen[_sender].citizenBalanceEthBackup = citizen[_sender].citizenBalanceEthBackup.add(_citizenBalanceEth).add(_earlyIncome).add(_devidend);\r\n        citizen[_sender].citizenEarlyIncomeRevenue = citizen[_sender].citizenEarlyIncomeRevenue.add(_earlyIncome);\r\n        citizenEthDividend[_sender] = citizenEthDividend[_sender].add(_devidend);\r\n        earlyIncomeBalanceEth= earlyIncomeBalanceEth.sub(_earlyIncome);\r\n        citizen[_sender].citizenBalanceEth = 0;\r\n    }\r\n    \r\n    function addWinIncome(address _citizen, uint256 _value)  onlyCoreContract()  public {\r\n        CitizenStorageContract.addWinIncome(_citizen, _value); \r\n    }\r\n    // function addGameWinIncome(address _citizen, uint256 _value, bool _enough) public {\r\n    //     CitizenStorageContract.addGameWinIncome(_citizen, _value, _enough);\r\n    // }\r\n    \r\n    // function getInWallet() public view returns (uint256){\r\n    //     uint256 _sum;\r\n    //     address _sender = msg.sender;\r\n    //     _sum = _sum.add(citizen[_sender].citizenBalanceEth);\r\n    //     _sum = _sum.add(TicketContract.getEarlyIncomeView(_sender));\r\n    //     _sum = _sum.add(DAAContract.getDividendView(_sender));\r\n    //     _sum = _sum.add(DAAContract.getCitizenBalanceEth(_sender));\r\n    //     return _sum;\r\n    // }  \r\n    \r\n    function getTotalEth() public registered() view returns(uint256){\r\n        uint256 _sum;\r\n        address _sender = msg.sender;\r\n        _sum = _sum.add(citizen[_sender].citizenBalanceEth);\r\n        _sum = _sum.add(citizen[_sender].citizenBalanceEthBackup);\r\n        _sum = _sum.add(CitizenStorageContract.citizenWinIncome(_sender));\r\n        _sum = _sum.add(TicketContract.getEarlyIncomeView(_sender, false));\r\n        _sum = _sum.add(DAAContract.getDividendView(_sender));\r\n        return _sum;\r\n    }\r\n    \r\n    function getTotalDividend(address _sender) public registered() view returns(uint256){\r\n        return citizenEthDividend[_sender].add(DAAContract.getDividendView(_sender));\r\n    }\r\n    \r\n    function getTotalEarlyIncome(address _sender) public registered() view returns(uint256){\r\n        uint256 _sum;\r\n        _sum = citizen[_sender].citizenEarlyIncomeRevenue;\r\n        _sum = _sum.add(TicketContract.getEarlyIncomeView(_sender, true));\r\n        return _sum;\r\n    }\r\n    \r\n    function getTotalSpend(address _sender) public view returns(uint256){\r\n        return citizen[_sender].citizenGameEthSpend+citizen[_sender].citizenTicketSpend;\r\n    }\r\n    \r\n    function getMemberByLevelToTal(uint256 _level) public view returns(uint256, uint256){\r\n        address _sender = msg.sender;\r\n        return(citizen[_sender].refTo[_level].length,payOutByLevel[_sender][_level]);\r\n    }\r\n    \r\n    function getMemberByLevel(uint256 _level, address _sender, uint256 _id) public view returns(address){\r\n        return citizen[_sender].refTo[_level][_id];\r\n    }\r\n    \r\n    function citizenPayForRef(address _citizen, address _ref) public view returns(uint256){\r\n        return citizen[_ref].payOut[_citizen];\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"_level\",\"type\":\"uint256\"}],\"name\":\"getMemberByLevelToTal\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_sender\",\"type\":\"address\"}],\"name\":\"getTotalEarlyIncome\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_citizen\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"addGameTokenSpend\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTotalEth\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"citizenEthDividend\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_sUsername\",\"type\":\"string\"},{\"name\":\"_ref\",\"type\":\"address\"}],\"name\":\"register\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"DAAContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TicketContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_citizen\",\"type\":\"address\"},{\"name\":\"_ref\",\"type\":\"address\"}],\"name\":\"citizenPayForRef\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_sender\",\"type\":\"address\"}],\"name\":\"getTotalDividend\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"payOutByLevel\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_username\",\"type\":\"string\"}],\"name\":\"getAddressByUserName\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"mostTotalSpenderId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getRef\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_contract\",\"type\":\"address[4]\"}],\"name\":\"joinNetwork\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_citizen\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"addGameEthSpendLose\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CitizenStorageContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pushEarlyIncome\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"coreContracts\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_level\",\"type\":\"uint256\"},{\"name\":\"_sender\",\"type\":\"address\"},{\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"getMemberByLevel\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_sender\",\"type\":\"address\"}],\"name\":\"pushTicketRefIncome\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_sender\",\"type\":\"address\"}],\"name\":\"pushGametRefIncome\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"addCoreContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_sender\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"pushGametRefIncomeToken\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"getAddressById\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_citizen\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"addTicketEthSpend\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_citizen\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_valuewin\",\"type\":\"uint256\"},{\"name\":\"_enough\",\"type\":\"bool\"}],\"name\":\"addGameEthSpendWin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"citizen\",\"outputs\":[{\"name\":\"id\",\"type\":\"uint256\"},{\"name\":\"username\",\"type\":\"uint256\"},{\"name\":\"ref\",\"type\":\"address\"},{\"name\":\"totalChild\",\"type\":\"uint256\"},{\"name\":\"treeLevel\",\"type\":\"uint256\"},{\"name\":\"citizenBalanceEth\",\"type\":\"uint256\"},{\"name\":\"citizenBalanceEthBackup\",\"type\":\"uint256\"},{\"name\":\"citizenTicketSpend\",\"type\":\"uint256\"},{\"name\":\"citizenGameEthSpend\",\"type\":\"uint256\"},{\"name\":\"citizenGameTokenSpend\",\"type\":\"uint256\"},{\"name\":\"citizenEarlyIncomeRevenue\",\"type\":\"uint256\"},{\"name\":\"citizenTicketRevenue\",\"type\":\"uint256\"},{\"name\":\"citizenGameEthRevenue\",\"type\":\"uint256\"},{\"name\":\"citizenGameTokenRevenue\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawEth\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_sender\",\"type\":\"address\"}],\"name\":\"getTotalSpend\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_citizen\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"addWinIncome\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"usernameAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getUsername\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"isCoreContract\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"levelCitizen\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"mostTotalSpender\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"citizenNr\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"idAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"coreContractSum\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isDev\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"isCitizen\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"GAME_LEVEL_REF\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"TICKET_LEVEL_REF\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_devTeam\",\"type\":\"address[4]\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"username\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"citizen\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"ref\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"ticketSpend\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"totalGameSpend\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"dateJoin\",\"type\":\"uint256\"}],\"name\":\"Register\",\"type\":\"event\"}]","ContractName":"Citizen","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"00000000000000000000000062dcd99f4a4439223e1735f4290f55852e1ab78500000000000000000000000062dcd99f4a4439223e1735f4290f55852e1ab785000000000000000000000000a06cd23aa37c39095d8cfe3a0fd2654331e631230000000000000000000000001bdf504b2ecf7a43c3ec5847ae950292ca2883c1","Library":"Helper:08f7f4d7ebeebe590162151934d4df1bad1bd619","SwarmSource":"bzzr://c7133a4e6c8efbca686851c39583ceab185039cf441fb95abe5f74fabc29aaf8"}]}