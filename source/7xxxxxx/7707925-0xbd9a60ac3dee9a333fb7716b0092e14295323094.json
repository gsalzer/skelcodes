{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.0;\r\n\r\ninterface TubInterface {\r\n    function open() external returns (bytes32);\r\n    function join(uint) external;\r\n    function exit(uint) external;\r\n    function lock(bytes32, uint) external;\r\n    function free(bytes32, uint) external;\r\n    function draw(bytes32, uint) external;\r\n    function wipe(bytes32, uint) external;\r\n    function give(bytes32, address) external;\r\n    function shut(bytes32) external;\r\n    function cups(bytes32) external view returns (address, uint, uint, uint);\r\n    function gem() external view returns (TokenInterface);\r\n    function gov() external view returns (TokenInterface);\r\n    function skr() external view returns (TokenInterface);\r\n    function sai() external view returns (TokenInterface);\r\n    function ink(bytes32) external view returns (uint);\r\n    function tab(bytes32) external returns (uint);\r\n    function rap(bytes32) external returns (uint);\r\n    function per() external view returns (uint);\r\n    function pep() external view returns (PepInterface);\r\n}\r\n\r\ninterface PepInterface {\r\n    function peek() external returns (bytes32, bool);\r\n}\r\n\r\n\r\ninterface oracleInterface {\r\n    function read() external view returns (bytes32);\r\n}\r\n\r\ninterface UniswapExchange {\r\n    function getEthToTokenOutputPrice(uint256 tokensBought) external view returns (uint256 ethSold);\r\n    function getTokenToEthOutputPrice(uint256 ethBought) external view returns (uint256 tokensSold);\r\n    function tokenToTokenSwapOutput(\r\n        uint256 tokensBought,\r\n        uint256 maxTokensSold,\r\n        uint256 maxEthSold,\r\n        uint256 deadline,\r\n        address tokenAddr\r\n        ) external returns (uint256  tokensSold);\r\n}\r\n\r\n\r\ninterface TokenInterface {\r\n    function allowance(address, address) external view returns (uint);\r\n    function balanceOf(address) external view returns (uint);\r\n    function approve(address, uint) external;\r\n    function transfer(address, uint) external returns (bool);\r\n    function transferFrom(address, address, uint) external returns (bool);\r\n    function deposit() external payable;\r\n    function withdraw(uint) external;\r\n}\r\n\r\ninterface KyberInterface {\r\n    function trade(\r\n        address src,\r\n        uint srcAmount,\r\n        address dest,\r\n        address destAddress,\r\n        uint maxDestAmount,\r\n        uint minConversionRate,\r\n        address walletId\r\n        ) external payable returns (uint);\r\n\r\n    function getExpectedRate(\r\n        address src,\r\n        address dest,\r\n        uint srcQty\r\n        ) external view returns (uint, uint);\r\n}\r\n\r\n\r\ncontract DSMath {\r\n\r\n    function add(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x + y) >= x, \"math-not-safe\");\r\n    }\r\n\r\n    function sub(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x - y) <= x, \"ds-math-sub-underflow\");\r\n    }\r\n\r\n    function mul(uint x, uint y) internal pure returns (uint z) {\r\n        require(y == 0 || (z = x * y) / y == x, \"math-not-safe\");\r\n    }\r\n\r\n    uint constant WAD = 10 ** 18;\r\n    uint constant RAY = 10 ** 27;\r\n\r\n    function rmul(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, y), RAY / 2) / RAY;\r\n    }\r\n\r\n    function rdiv(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, RAY), y / 2) / y;\r\n    }\r\n\r\n    function wmul(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, y), WAD / 2) / WAD;\r\n    }\r\n\r\n    function wdiv(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, WAD), y / 2) / y;\r\n    }\r\n\r\n}\r\n\r\n\r\ncontract Helpers is DSMath {\r\n\r\n    /**\r\n     * @dev get MakerDAO CDP engine\r\n     */\r\n    function getSaiTubAddress() public pure returns (address sai) {\r\n        sai = 0x448a5065aeBB8E423F0896E6c5D525C040f59af3;\r\n    }\r\n\r\n    /**\r\n     * @dev get MakerDAO Oracle for ETH price\r\n     */\r\n    function getOracleAddress() public pure returns (address oracle) {\r\n        oracle = 0x729D19f657BD0614b4985Cf1D82531c67569197B;\r\n    }\r\n\r\n    /**\r\n     * @dev get uniswap MKR exchange\r\n     */\r\n    function getUniswapMKRExchange() public pure returns (address ume) {\r\n        ume = 0x2C4Bd064b998838076fa341A83d007FC2FA50957;\r\n    }\r\n\r\n    /**\r\n     * @dev get uniswap DAI exchange\r\n     */\r\n    function getUniswapDAIExchange() public pure returns (address ude) {\r\n        ude = 0x09cabEC1eAd1c0Ba254B09efb3EE13841712bE14;\r\n    }\r\n\r\n    /**\r\n     * @dev get ethereum address for trade\r\n     */\r\n    function getAddressETH() public pure returns (address eth) {\r\n        eth = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\r\n    }\r\n\r\n    /**\r\n     * @dev get ethereum address for trade\r\n     */\r\n    function getAddressDAI() public pure returns (address dai) {\r\n        dai = 0x89d24A6b4CcB1B6fAA2625fE562bDD9a23260359;\r\n    }\r\n\r\n    /**\r\n     * @dev get kyber proxy address\r\n     */\r\n    function getAddressKyber() public pure returns (address kyber) {\r\n        kyber = 0x818E6FECD516Ecc3849DAf6845e3EC868087B755;\r\n    }\r\n\r\n    /**\r\n     * @dev get admin address\r\n     */\r\n    function getAddressAdmin() public pure returns (address payable admin) {\r\n        admin = 0x7284a8451d9a0e7Dc62B3a71C0593eA2eC5c5638;\r\n    }\r\n\r\n    function getCDPStats(bytes32 cup) internal view returns (uint ethCol, uint daiDebt, uint usdPerEth) {\r\n        TubInterface tub = TubInterface(getSaiTubAddress());\r\n        usdPerEth = uint(oracleInterface(getOracleAddress()).read());\r\n        (, uint pethCol, uint debt,) = tub.cups(cup);\r\n        ethCol = rmul(pethCol, tub.per()); // get ETH col from PETH col\r\n        daiDebt = debt;\r\n    }\r\n\r\n}\r\n\r\n\r\ncontract MakerHelpers is Helpers {\r\n\r\n    event LogLock(uint cdpNum, uint amtETH, uint amtPETH, address owner);\r\n    event LogFree(uint cdpNum, uint amtETH, uint amtPETH, address owner);\r\n    event LogDraw(uint cdpNum, uint amtDAI, address owner);\r\n    event LogWipe(uint cdpNum, uint daiAmt, uint mkrFee, uint daiFee, address owner);\r\n\r\n    function setAllowance(TokenInterface _token, address _spender) internal {\r\n        if (_token.allowance(address(this), _spender) != uint(-1)) {\r\n            _token.approve(_spender, uint(-1));\r\n        }\r\n    }\r\n\r\n    function lock(uint cdpNum, uint ethAmt) internal {\r\n        if (ethAmt > 0) {\r\n            bytes32 cup = bytes32(cdpNum);\r\n            address tubAddr = getSaiTubAddress();\r\n\r\n            TubInterface tub = TubInterface(tubAddr);\r\n            TokenInterface weth = tub.gem();\r\n            TokenInterface peth = tub.skr();\r\n\r\n            (address lad,,,) = tub.cups(cup);\r\n            require(lad == address(this), \"cup-not-owned\");\r\n\r\n            weth.deposit.value(ethAmt)();\r\n\r\n            uint ink = rdiv(ethAmt, tub.per());\r\n            ink = rmul(ink, tub.per()) <= ethAmt ? ink : ink - 1;\r\n\r\n            setAllowance(weth, tubAddr);\r\n            tub.join(ink);\r\n\r\n            setAllowance(peth, tubAddr);\r\n            tub.lock(cup, ink);\r\n\r\n            emit LogLock(\r\n                cdpNum,\r\n                ethAmt,\r\n                ink,\r\n                address(this)\r\n            );\r\n        }\r\n    }\r\n\r\n    function free(uint cdpNum, uint jam) internal {\r\n        if (jam > 0) {\r\n            bytes32 cup = bytes32(cdpNum);\r\n            address tubAddr = getSaiTubAddress();\r\n\r\n            TubInterface tub = TubInterface(tubAddr);\r\n            TokenInterface peth = tub.skr();\r\n            TokenInterface weth = tub.gem();\r\n\r\n            uint ink = rdiv(jam, tub.per());\r\n            ink = rmul(ink, tub.per()) <= jam ? ink : ink - 1;\r\n            tub.free(cup, ink);\r\n\r\n            setAllowance(peth, tubAddr);\r\n\r\n            tub.exit(ink);\r\n            uint freeJam = weth.balanceOf(address(this)); // withdraw possible previous stuck WETH as well\r\n            weth.withdraw(freeJam);\r\n\r\n            emit LogFree(\r\n                cdpNum,\r\n                freeJam,\r\n                ink,\r\n                address(this)\r\n            );\r\n        }\r\n    }\r\n\r\n    function draw(uint cdpNum, uint _wad) internal {\r\n        bytes32 cup = bytes32(cdpNum);\r\n        if (_wad > 0) {\r\n            TubInterface tub = TubInterface(getSaiTubAddress());\r\n\r\n            tub.draw(cup, _wad);\r\n\r\n            emit LogDraw(cdpNum, _wad, address(this));\r\n        }\r\n    }\r\n\r\n    function wipe(uint cdpNum, uint _wad) internal {\r\n        if (_wad > 0) {\r\n            TubInterface tub = TubInterface(getSaiTubAddress());\r\n            UniswapExchange daiEx = UniswapExchange(getUniswapDAIExchange());\r\n            UniswapExchange mkrEx = UniswapExchange(getUniswapMKRExchange());\r\n            TokenInterface dai = tub.sai();\r\n            TokenInterface mkr = tub.gov();\r\n\r\n            bytes32 cup = bytes32(cdpNum);\r\n\r\n            (address lad,,,) = tub.cups(cup);\r\n            require(lad == address(this), \"cup-not-owned\");\r\n\r\n            setAllowance(dai, getSaiTubAddress());\r\n            setAllowance(mkr, getSaiTubAddress());\r\n            setAllowance(dai, getUniswapDAIExchange());\r\n\r\n            (bytes32 val, bool ok) = tub.pep().peek();\r\n\r\n            // tub.rap(cup) = stability fee in $, tub.tab(cup) = total DAI debt\r\n            uint mkrFee = wdiv(rmul(_wad, rdiv(tub.rap(cup), tub.tab(cup))), uint(val));\r\n            // uint mkrFee = wdiv(rmul(_wad, rdiv(tub.rap(cup), add(tub.rap(cup), tub.tab(cup)))), uint(val));\r\n\r\n            uint daiFeeAmt = daiEx.getTokenToEthOutputPrice(mkrEx.getEthToTokenOutputPrice(mkrFee));\r\n            uint daiAmt = sub(_wad, daiFeeAmt);\r\n\r\n            if (ok && val != 0) {\r\n                daiEx.tokenToTokenSwapOutput(\r\n                    mkrFee,\r\n                    daiFeeAmt,\r\n                    uint(999000000000000000000),\r\n                    uint(1899063809), // 6th March 2030 GMT // no logic\r\n                    address(mkr)\r\n                );\r\n            }\r\n\r\n            tub.wipe(cup, daiAmt);\r\n\r\n            emit LogWipe(\r\n                cdpNum,\r\n                _wad,\r\n                mkrFee,\r\n                daiFeeAmt,\r\n                address(this)\r\n            );\r\n\r\n        }\r\n    }\r\n\r\n}\r\n\r\n\r\ncontract GetDetails is MakerHelpers {\r\n\r\n    function getMax(uint cdpID) public view returns (uint maxColToFree, uint maxDaiToDraw, uint ethInUSD) {\r\n        bytes32 cup = bytes32(cdpID);\r\n        (uint ethCol, uint daiDebt, uint usdPerEth) = getCDPStats(cup);\r\n        uint colToUSD = wmul(ethCol, usdPerEth) - 10;\r\n        uint minColNeeded = wmul(daiDebt, 1500000000000000000) + 10;\r\n        maxColToFree = wdiv(sub(colToUSD, minColNeeded), usdPerEth);\r\n        uint maxDebtLimit = wdiv(colToUSD, 1500000000000000000) - 10;\r\n        maxDaiToDraw = sub(maxDebtLimit, daiDebt);\r\n        ethInUSD = usdPerEth;\r\n\r\n        (uint expectedRate,) = KyberInterface(getAddressKyber()).getExpectedRate(getAddressETH(), getAddressDAI(), maxColToFree);\r\n        uint expectedDai = wmul(maxColToFree, expectedRate);\r\n        if (expectedDai > maxDaiToDraw) {\r\n            maxColToFree = wmul(maxColToFree, wdiv(maxDaiToDraw, expectedDai));\r\n        }\r\n\r\n    }\r\n\r\n    function getSave(uint cdpID, uint ethToSwap) public view returns (uint finalEthCol, uint finalDaiDebt, uint finalColToUSD, bool canSave) {\r\n        bytes32 cup = bytes32(cdpID);\r\n        (uint ethCol, uint daiDebt, uint usdPerEth) = getCDPStats(cup);\r\n        (finalEthCol, finalDaiDebt, finalColToUSD, canSave) = checkSave(\r\n            ethCol,\r\n            daiDebt,\r\n            usdPerEth,\r\n            ethToSwap\r\n        );\r\n    }\r\n\r\n    function getLeverage(\r\n        uint cdpID,\r\n        uint daiToSwap\r\n    ) public view returns (\r\n        uint finalEthCol,\r\n        uint finalDaiDebt,\r\n        uint finalColToUSD,\r\n        bool canLeverage\r\n    )\r\n    {\r\n        bytes32 cup = bytes32(cdpID);\r\n        (uint ethCol, uint daiDebt, uint usdPerEth) = getCDPStats(cup);\r\n        (finalEthCol, finalDaiDebt, finalColToUSD, canLeverage) = checkLeverage(\r\n            ethCol,\r\n            daiDebt,\r\n            usdPerEth,\r\n            daiToSwap\r\n        );\r\n    }\r\n\r\n    function checkSave(\r\n        uint ethCol,\r\n        uint daiDebt,\r\n        uint usdPerEth,\r\n        uint ethToSwap\r\n    ) internal view returns\r\n    (\r\n        uint finalEthCol,\r\n        uint finalDaiDebt,\r\n        uint finalColToUSD,\r\n        bool canSave\r\n    )\r\n    {\r\n        uint colToUSD = wmul(ethCol, usdPerEth) - 10;\r\n        uint minColNeeded = wmul(daiDebt, 1500000000000000000) + 10;\r\n        uint colToFree = wdiv(sub(colToUSD, minColNeeded), usdPerEth);\r\n        if (ethToSwap < colToFree) {\r\n            colToFree = ethToSwap;\r\n        }\r\n        (uint expectedRate,) = KyberInterface(getAddressKyber()).getExpectedRate(getAddressETH(), getAddressDAI(), colToFree);\r\n        uint expectedDAI = wmul(colToFree, expectedRate);\r\n        if (expectedDAI < daiDebt) {\r\n            finalEthCol = sub(ethCol, colToFree);\r\n            finalDaiDebt = sub(daiDebt, expectedDAI);\r\n            finalColToUSD = wmul(finalEthCol, usdPerEth);\r\n            canSave = true;\r\n        } else {\r\n            finalEthCol = 0;\r\n            finalDaiDebt = 0;\r\n            finalColToUSD = 0;\r\n            canSave = false;\r\n        }\r\n    }\r\n\r\n    function checkLeverage(\r\n        uint ethCol,\r\n        uint daiDebt,\r\n        uint usdPerEth,\r\n        uint daiToSwap\r\n    ) internal view returns\r\n    (\r\n        uint finalEthCol,\r\n        uint finalDaiDebt,\r\n        uint finalColToUSD,\r\n        bool canLeverage\r\n    )\r\n    {\r\n        uint colToUSD = wmul(ethCol, usdPerEth) - 10;\r\n        uint maxDebtLimit = wdiv(colToUSD, 1500000000000000000) - 10;\r\n        uint debtToBorrow = sub(maxDebtLimit, daiDebt);\r\n        if (daiToSwap < debtToBorrow) {\r\n            debtToBorrow = daiToSwap;\r\n        }\r\n        (uint expectedRate,) = KyberInterface(getAddressKyber()).getExpectedRate(getAddressDAI(), getAddressETH(), debtToBorrow);\r\n        uint expectedETH = wmul(debtToBorrow, expectedRate);\r\n        if (ethCol != 0) {\r\n            finalEthCol = add(ethCol, expectedETH);\r\n            finalDaiDebt = add(daiDebt, debtToBorrow);\r\n            finalColToUSD = wmul(finalEthCol, usdPerEth);\r\n            canLeverage = true;\r\n        } else {\r\n            finalEthCol = 0;\r\n            finalDaiDebt = 0;\r\n            finalColToUSD = 0;\r\n            canLeverage = false;\r\n        }\r\n    }\r\n\r\n}\r\n\r\n\r\ncontract Save is GetDetails {\r\n\r\n    /**\r\n     * @param what 2 for SAVE & 3 for LEVERAGE\r\n     */\r\n    event LogTrade(\r\n        uint what, // 0 for BUY & 1 for SELL\r\n        address src,\r\n        uint srcAmt,\r\n        address dest,\r\n        uint destAmt,\r\n        address beneficiary,\r\n        uint minConversionRate,\r\n        address affiliate\r\n    );\r\n\r\n    event LogSaveCDP(\r\n        uint cdpID,\r\n        uint srcETH,\r\n        uint destDAI\r\n    );\r\n\r\n    event LogLeverageCDP(\r\n        uint cdpID,\r\n        uint srcDAI,\r\n        uint destETH\r\n    );\r\n\r\n\r\n    function save(uint cdpID, uint colToSwap) public {\r\n        bytes32 cup = bytes32(cdpID);\r\n        (uint ethCol, uint daiDebt, uint usdPerEth) = getCDPStats(cup);\r\n        uint colToFree = getColToFree(ethCol, daiDebt, usdPerEth);\r\n        require(colToFree != 0, \"no-collatral-to-free\");\r\n        if (colToSwap < colToFree) {\r\n            colToFree = colToSwap;\r\n        }\r\n        uint thisBalance = address(this).balance;\r\n        free(cdpID, colToFree);\r\n        uint destAmt = KyberInterface(getAddressKyber()).trade.value(colToFree)(\r\n            getAddressETH(),\r\n            colToFree,\r\n            getAddressDAI(),\r\n            address(this),\r\n            daiDebt,\r\n            0,\r\n            getAddressAdmin()\r\n        );\r\n        wipe(cdpID, destAmt);\r\n\r\n        if (thisBalance < address(this).balance) {\r\n            uint balToLock = address(this).balance - thisBalance;\r\n            lock(cdpID, balToLock);\r\n        }\r\n\r\n        emit LogSaveCDP(cdpID, colToFree, destAmt);\r\n\r\n        emit LogTrade(\r\n            0,\r\n            getAddressETH(),\r\n            colToFree,\r\n            getAddressDAI(),\r\n            destAmt,\r\n            address(this),\r\n            0,\r\n            getAddressAdmin()\r\n        );\r\n    }\r\n\r\n    function leverage(uint cdpID, uint daiToSwap) public {\r\n        bytes32 cup = bytes32(cdpID);\r\n        (uint ethCol, uint daiDebt, uint usdPerEth) = getCDPStats(cup);\r\n        uint debtToBorrow = getDebtToBorrow(ethCol, daiDebt, usdPerEth);\r\n        require(debtToBorrow != 0, \"No-debt-to-borrow\");\r\n        if (daiToSwap < debtToBorrow) {\r\n            debtToBorrow = daiToSwap;\r\n        }\r\n        draw(cdpID, debtToBorrow);\r\n        setAllowance(TokenInterface(getAddressDAI()), getAddressKyber());\r\n        uint destAmt = KyberInterface(getAddressKyber()).trade.value(0)(\r\n            getAddressDAI(),\r\n            debtToBorrow,\r\n            getAddressETH(),\r\n            address(this),\r\n            2**255,\r\n            0,\r\n            getAddressAdmin()\r\n        );\r\n        lock(cdpID, destAmt);\r\n\r\n        emit LogLeverageCDP(cdpID, debtToBorrow, destAmt);\r\n\r\n        emit LogTrade(\r\n            1,\r\n            getAddressDAI(),\r\n            debtToBorrow,\r\n            getAddressETH(),\r\n            destAmt,\r\n            address(this),\r\n            0,\r\n            getAddressAdmin()\r\n        );\r\n    }\r\n\r\n    function getColToFree(uint ethCol, uint daiDebt, uint usdPerEth) internal pure returns (uint colToFree) {\r\n        uint colToUSD = sub(wmul(ethCol, usdPerEth), 10);\r\n        uint minColNeeded = add(wmul(daiDebt, 1500000000000000000), 10);\r\n        colToFree = sub(wdiv(sub(colToUSD, minColNeeded), usdPerEth), 10);\r\n    }\r\n\r\n    function getDebtToBorrow(uint ethCol, uint daiDebt, uint usdPerEth) internal pure returns (uint debtToBorrow) {\r\n        uint colToUSD = sub(wmul(ethCol, usdPerEth), 10);\r\n        uint maxDebtLimit = sub(wdiv(colToUSD, 1500000000000000000), 10);\r\n        debtToBorrow = sub(maxDebtLimit, daiDebt);\r\n    }\r\n\r\n}\r\n\r\n\r\ncontract InstaSave is Save {\r\n\r\n    uint public version;\r\n\r\n    /**\r\n     * @dev setting up variables on deployment\r\n     * 1...2...3 versioning in each subsequent deployments\r\n     */\r\n    constructor(uint _version) public {\r\n        version = _version;\r\n    }\r\n\r\n    function() external payable {}\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"cdpID\",\"type\":\"uint256\"},{\"name\":\"colToSwap\",\"type\":\"uint256\"}],\"name\":\"save\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"cdpID\",\"type\":\"uint256\"},{\"name\":\"daiToSwap\",\"type\":\"uint256\"}],\"name\":\"leverage\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"cdpID\",\"type\":\"uint256\"},{\"name\":\"ethToSwap\",\"type\":\"uint256\"}],\"name\":\"getSave\",\"outputs\":[{\"name\":\"finalEthCol\",\"type\":\"uint256\"},{\"name\":\"finalDaiDebt\",\"type\":\"uint256\"},{\"name\":\"finalColToUSD\",\"type\":\"uint256\"},{\"name\":\"canSave\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAddressKyber\",\"outputs\":[{\"name\":\"kyber\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getUniswapMKRExchange\",\"outputs\":[{\"name\":\"ume\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAddressETH\",\"outputs\":[{\"name\":\"eth\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAddressAdmin\",\"outputs\":[{\"name\":\"admin\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getOracleAddress\",\"outputs\":[{\"name\":\"oracle\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAddressDAI\",\"outputs\":[{\"name\":\"dai\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getUniswapDAIExchange\",\"outputs\":[{\"name\":\"ude\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"cdpID\",\"type\":\"uint256\"},{\"name\":\"daiToSwap\",\"type\":\"uint256\"}],\"name\":\"getLeverage\",\"outputs\":[{\"name\":\"finalEthCol\",\"type\":\"uint256\"},{\"name\":\"finalDaiDebt\",\"type\":\"uint256\"},{\"name\":\"finalColToUSD\",\"type\":\"uint256\"},{\"name\":\"canLeverage\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"cdpID\",\"type\":\"uint256\"}],\"name\":\"getMax\",\"outputs\":[{\"name\":\"maxColToFree\",\"type\":\"uint256\"},{\"name\":\"maxDaiToDraw\",\"type\":\"uint256\"},{\"name\":\"ethInUSD\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getSaiTubAddress\",\"outputs\":[{\"name\":\"sai\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_version\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"what\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"src\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"srcAmt\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"dest\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"destAmt\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"minConversionRate\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"affiliate\",\"type\":\"address\"}],\"name\":\"LogTrade\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"cdpID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"srcETH\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"destDAI\",\"type\":\"uint256\"}],\"name\":\"LogSaveCDP\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"cdpID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"srcDAI\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"destETH\",\"type\":\"uint256\"}],\"name\":\"LogLeverageCDP\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"cdpNum\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amtETH\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amtPETH\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"LogLock\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"cdpNum\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amtETH\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amtPETH\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"LogFree\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"cdpNum\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amtDAI\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"LogDraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"cdpNum\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"daiAmt\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"mkrFee\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"daiFee\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"LogWipe\",\"type\":\"event\"}]","ContractName":"InstaSave","CompilerVersion":"v0.5.1+commit.c8a2cb62","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"0000000000000000000000000000000000000000000000000000000000000002","Library":"","SwarmSource":"bzzr://74acb65f735e76dd32c38d53324ee7755bb9d996493efe604c62030853b423a2"}]}