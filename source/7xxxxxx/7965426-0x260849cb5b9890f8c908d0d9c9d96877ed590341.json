{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity >=0.4.25 <0.6.0;\n\npragma experimental ABIEncoderV2;\n\n/*\n * Hubii Nahmii\n *\n * Compliant with the Hubii Nahmii specification v0.12.\n *\n * Copyright (C) 2017-2018 Hubii AS\n */\n\n\n/**\n * @title Modifiable\n * @notice A contract with basic modifiers\n */\ncontract Modifiable {\n    //\n    // Modifiers\n    // -----------------------------------------------------------------------------------------------------------------\n    modifier notNullAddress(address _address) {\n        require(_address != address(0));\n        _;\n    }\n\n    modifier notThisAddress(address _address) {\n        require(_address != address(this));\n        _;\n    }\n\n    modifier notNullOrThisAddress(address _address) {\n        require(_address != address(0));\n        require(_address != address(this));\n        _;\n    }\n\n    modifier notSameAddresses(address _address1, address _address2) {\n        if (_address1 != _address2)\n            _;\n    }\n}\n\n/*\n * Hubii Nahmii\n *\n * Compliant with the Hubii Nahmii specification v0.12.\n *\n * Copyright (C) 2017-2018 Hubii AS\n */\n\n\n\n/**\n * @title SelfDestructible\n * @notice Contract that allows for self-destruction\n */\ncontract SelfDestructible {\n    //\n    // Variables\n    // -----------------------------------------------------------------------------------------------------------------\n    bool public selfDestructionDisabled;\n\n    //\n    // Events\n    // -----------------------------------------------------------------------------------------------------------------\n    event SelfDestructionDisabledEvent(address wallet);\n    event TriggerSelfDestructionEvent(address wallet);\n\n    //\n    // Functions\n    // -----------------------------------------------------------------------------------------------------------------\n    /// @notice Get the address of the destructor role\n    function destructor()\n    public\n    view\n    returns (address);\n\n    /// @notice Disable self-destruction of this contract\n    /// @dev This operation can not be undone\n    function disableSelfDestruction()\n    public\n    {\n        // Require that sender is the assigned destructor\n        require(destructor() == msg.sender);\n\n        // Disable self-destruction\n        selfDestructionDisabled = true;\n\n        // Emit event\n        emit SelfDestructionDisabledEvent(msg.sender);\n    }\n\n    /// @notice Destroy this contract\n    function triggerSelfDestruction()\n    public\n    {\n        // Require that sender is the assigned destructor\n        require(destructor() == msg.sender);\n\n        // Require that self-destruction has not been disabled\n        require(!selfDestructionDisabled);\n\n        // Emit event\n        emit TriggerSelfDestructionEvent(msg.sender);\n\n        // Self-destruct and reward destructor\n        selfdestruct(msg.sender);\n    }\n}\n\n/*\n * Hubii Nahmii\n *\n * Compliant with the Hubii Nahmii specification v0.12.\n *\n * Copyright (C) 2017-2018 Hubii AS\n */\n\n\n\n\n\n\n/**\n * @title Ownable\n * @notice A modifiable that has ownership roles\n */\ncontract Ownable is Modifiable, SelfDestructible {\n    //\n    // Variables\n    // -----------------------------------------------------------------------------------------------------------------\n    address public deployer;\n    address public operator;\n\n    //\n    // Events\n    // -----------------------------------------------------------------------------------------------------------------\n    event SetDeployerEvent(address oldDeployer, address newDeployer);\n    event SetOperatorEvent(address oldOperator, address newOperator);\n\n    //\n    // Constructor\n    // -----------------------------------------------------------------------------------------------------------------\n    constructor(address _deployer) internal notNullOrThisAddress(_deployer) {\n        deployer = _deployer;\n        operator = _deployer;\n    }\n\n    //\n    // Functions\n    // -----------------------------------------------------------------------------------------------------------------\n    /// @notice Return the address that is able to initiate self-destruction\n    function destructor()\n    public\n    view\n    returns (address)\n    {\n        return deployer;\n    }\n\n    /// @notice Set the deployer of this contract\n    /// @param newDeployer The address of the new deployer\n    function setDeployer(address newDeployer)\n    public\n    onlyDeployer\n    notNullOrThisAddress(newDeployer)\n    {\n        if (newDeployer != deployer) {\n            // Set new deployer\n            address oldDeployer = deployer;\n            deployer = newDeployer;\n\n            // Emit event\n            emit SetDeployerEvent(oldDeployer, newDeployer);\n        }\n    }\n\n    /// @notice Set the operator of this contract\n    /// @param newOperator The address of the new operator\n    function setOperator(address newOperator)\n    public\n    onlyOperator\n    notNullOrThisAddress(newOperator)\n    {\n        if (newOperator != operator) {\n            // Set new operator\n            address oldOperator = operator;\n            operator = newOperator;\n\n            // Emit event\n            emit SetOperatorEvent(oldOperator, newOperator);\n        }\n    }\n\n    /// @notice Gauge whether message sender is deployer or not\n    /// @return true if msg.sender is deployer, else false\n    function isDeployer()\n    internal\n    view\n    returns (bool)\n    {\n        return msg.sender == deployer;\n    }\n\n    /// @notice Gauge whether message sender is operator or not\n    /// @return true if msg.sender is operator, else false\n    function isOperator()\n    internal\n    view\n    returns (bool)\n    {\n        return msg.sender == operator;\n    }\n\n    /// @notice Gauge whether message sender is operator or deployer on the one hand, or none of these on these on\n    /// on the other hand\n    /// @return true if msg.sender is operator, else false\n    function isDeployerOrOperator()\n    internal\n    view\n    returns (bool)\n    {\n        return isDeployer() || isOperator();\n    }\n\n    // Modifiers\n    // -----------------------------------------------------------------------------------------------------------------\n    modifier onlyDeployer() {\n        require(isDeployer());\n        _;\n    }\n\n    modifier notDeployer() {\n        require(!isDeployer());\n        _;\n    }\n\n    modifier onlyOperator() {\n        require(isOperator());\n        _;\n    }\n\n    modifier notOperator() {\n        require(!isOperator());\n        _;\n    }\n\n    modifier onlyDeployerOrOperator() {\n        require(isDeployerOrOperator());\n        _;\n    }\n\n    modifier notDeployerOrOperator() {\n        require(!isDeployerOrOperator());\n        _;\n    }\n}\n\n/*\n * Hubii Nahmii\n *\n * Compliant with the Hubii Nahmii specification v0.12.\n *\n * Copyright (C) 2017-2018 Hubii AS\n */\n\n\n\n\n\n/**\n * @title Servable\n * @notice An ownable that contains registered services and their actions\n */\ncontract Servable is Ownable {\n    //\n    // Types\n    // -----------------------------------------------------------------------------------------------------------------\n    struct ServiceInfo {\n        bool registered;\n        uint256 activationTimestamp;\n        mapping(bytes32 => bool) actionsEnabledMap;\n        bytes32[] actionsList;\n    }\n\n    //\n    // Variables\n    // -----------------------------------------------------------------------------------------------------------------\n    mapping(address => ServiceInfo) internal registeredServicesMap;\n    uint256 public serviceActivationTimeout;\n\n    //\n    // Events\n    // -----------------------------------------------------------------------------------------------------------------\n    event ServiceActivationTimeoutEvent(uint256 timeoutInSeconds);\n    event RegisterServiceEvent(address service);\n    event RegisterServiceDeferredEvent(address service, uint256 timeout);\n    event DeregisterServiceEvent(address service);\n    event EnableServiceActionEvent(address service, string action);\n    event DisableServiceActionEvent(address service, string action);\n\n    //\n    // Functions\n    // -----------------------------------------------------------------------------------------------------------------\n    /// @notice Set the service activation timeout\n    /// @param timeoutInSeconds The set timeout in unit of seconds\n    function setServiceActivationTimeout(uint256 timeoutInSeconds)\n    public\n    onlyDeployer\n    {\n        serviceActivationTimeout = timeoutInSeconds;\n\n        // Emit event\n        emit ServiceActivationTimeoutEvent(timeoutInSeconds);\n    }\n\n    /// @notice Register a service contract whose activation is immediate\n    /// @param service The address of the service contract to be registered\n    function registerService(address service)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        _registerService(service, 0);\n\n        // Emit event\n        emit RegisterServiceEvent(service);\n    }\n\n    /// @notice Register a service contract whose activation is deferred by the service activation timeout\n    /// @param service The address of the service contract to be registered\n    function registerServiceDeferred(address service)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        _registerService(service, serviceActivationTimeout);\n\n        // Emit event\n        emit RegisterServiceDeferredEvent(service, serviceActivationTimeout);\n    }\n\n    /// @notice Deregister a service contract\n    /// @param service The address of the service contract to be deregistered\n    function deregisterService(address service)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        require(registeredServicesMap[service].registered);\n\n        registeredServicesMap[service].registered = false;\n\n        // Emit event\n        emit DeregisterServiceEvent(service);\n    }\n\n    /// @notice Enable a named action in an already registered service contract\n    /// @param service The address of the registered service contract\n    /// @param action The name of the action to be enabled\n    function enableServiceAction(address service, string memory action)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        require(registeredServicesMap[service].registered);\n\n        bytes32 actionHash = hashString(action);\n\n        require(!registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        registeredServicesMap[service].actionsEnabledMap[actionHash] = true;\n        registeredServicesMap[service].actionsList.push(actionHash);\n\n        // Emit event\n        emit EnableServiceActionEvent(service, action);\n    }\n\n    /// @notice Enable a named action in a service contract\n    /// @param service The address of the service contract\n    /// @param action The name of the action to be disabled\n    function disableServiceAction(address service, string memory action)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        bytes32 actionHash = hashString(action);\n\n        require(registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        registeredServicesMap[service].actionsEnabledMap[actionHash] = false;\n\n        // Emit event\n        emit DisableServiceActionEvent(service, action);\n    }\n\n    /// @notice Gauge whether a service contract is registered\n    /// @param service The address of the service contract\n    /// @return true if service is registered, else false\n    function isRegisteredService(address service)\n    public\n    view\n    returns (bool)\n    {\n        return registeredServicesMap[service].registered;\n    }\n\n    /// @notice Gauge whether a service contract is registered and active\n    /// @param service The address of the service contract\n    /// @return true if service is registered and activate, else false\n    function isRegisteredActiveService(address service)\n    public\n    view\n    returns (bool)\n    {\n        return isRegisteredService(service) && block.timestamp >= registeredServicesMap[service].activationTimestamp;\n    }\n\n    /// @notice Gauge whether a service contract action is enabled which implies also registered and active\n    /// @param service The address of the service contract\n    /// @param action The name of action\n    function isEnabledServiceAction(address service, string memory action)\n    public\n    view\n    returns (bool)\n    {\n        bytes32 actionHash = hashString(action);\n        return isRegisteredActiveService(service) && registeredServicesMap[service].actionsEnabledMap[actionHash];\n    }\n\n    //\n    // Internal functions\n    // -----------------------------------------------------------------------------------------------------------------\n    function hashString(string memory _string)\n    internal\n    pure\n    returns (bytes32)\n    {\n        return keccak256(abi.encodePacked(_string));\n    }\n\n    //\n    // Private functions\n    // -----------------------------------------------------------------------------------------------------------------\n    function _registerService(address service, uint256 timeout)\n    private\n    {\n        if (!registeredServicesMap[service].registered) {\n            registeredServicesMap[service].registered = true;\n            registeredServicesMap[service].activationTimestamp = block.timestamp + timeout;\n        }\n    }\n\n    //\n    // Modifiers\n    // -----------------------------------------------------------------------------------------------------------------\n    modifier onlyActiveService() {\n        require(isRegisteredActiveService(msg.sender));\n        _;\n    }\n\n    modifier onlyEnabledServiceAction(string memory action) {\n        require(isEnabledServiceAction(msg.sender, action));\n        _;\n    }\n}\n\n/*\n * Hubii Nahmii\n *\n * Compliant with the Hubii Nahmii specification v0.12.\n *\n * Copyright (C) 2017-2018 Hubii AS\n */\n\n\n\n\n\n/**\n * @title Community vote\n * @notice An oracle for relevant decisions made by the community.\n */\ncontract CommunityVote is Ownable {\n    //\n    // Variables\n    // -----------------------------------------------------------------------------------------------------------------\n    mapping(address => bool) doubleSpenderByWallet;\n    uint256 maxDriipNonce;\n    uint256 maxNullNonce;\n    bool dataAvailable;\n\n    //\n    // Constructor\n    // -----------------------------------------------------------------------------------------------------------------\n    constructor(address deployer) Ownable(deployer) public {\n        dataAvailable = true;\n    }\n\n    //\n    // Results functions\n    // -----------------------------------------------------------------------------------------------------------------\n    /// @notice Get the double spender status of given wallet\n    /// @param wallet The wallet address for which to check double spender status\n    /// @return true if wallet is double spender, false otherwise\n    function isDoubleSpenderWallet(address wallet)\n    public\n    view\n    returns (bool)\n    {\n        return doubleSpenderByWallet[wallet];\n    }\n\n    /// @notice Get the max driip nonce to be accepted in settlements\n    /// @return the max driip nonce\n    function getMaxDriipNonce()\n    public\n    view\n    returns (uint256)\n    {\n        return maxDriipNonce;\n    }\n\n    /// @notice Get the max null settlement nonce to be accepted in settlements\n    /// @return the max driip nonce\n    function getMaxNullNonce()\n    public\n    view\n    returns (uint256)\n    {\n        return maxNullNonce;\n    }\n\n    /// @notice Get the data availability status\n    /// @return true if data is available\n    function isDataAvailable()\n    public\n    view\n    returns (bool)\n    {\n        return dataAvailable;\n    }\n}\n\n/*\n * Hubii Nahmii\n *\n * Compliant with the Hubii Nahmii specification v0.12.\n *\n * Copyright (C) 2017-2018 Hubii AS\n */\n\n\n\n\n\n/**\n * @title CommunityVotable\n * @notice An ownable that has a community vote property\n */\ncontract CommunityVotable is Ownable {\n    //\n    // Variables\n    // -----------------------------------------------------------------------------------------------------------------\n    CommunityVote public communityVote;\n    bool public communityVoteFrozen;\n\n    //\n    // Events\n    // -----------------------------------------------------------------------------------------------------------------\n    event SetCommunityVoteEvent(CommunityVote oldCommunityVote, CommunityVote newCommunityVote);\n    event FreezeCommunityVoteEvent();\n\n    //\n    // Functions\n    // -----------------------------------------------------------------------------------------------------------------\n    /// @notice Set the community vote contract\n    /// @param newCommunityVote The (address of) CommunityVote contract instance\n    function setCommunityVote(CommunityVote newCommunityVote) \n    public \n    onlyDeployer\n    notNullAddress(address(newCommunityVote))\n    notSameAddresses(address(newCommunityVote), address(communityVote))\n    {\n        require(!communityVoteFrozen, \"Community vote frozen [CommunityVotable.sol:41]\");\n\n        // Set new community vote\n        CommunityVote oldCommunityVote = communityVote;\n        communityVote = newCommunityVote;\n\n        // Emit event\n        emit SetCommunityVoteEvent(oldCommunityVote, newCommunityVote);\n    }\n\n    /// @notice Freeze the community vote from further updates\n    /// @dev This operation can not be undone\n    function freezeCommunityVote()\n    public\n    onlyDeployer\n    {\n        communityVoteFrozen = true;\n\n        // Emit event\n        emit FreezeCommunityVoteEvent();\n    }\n\n    //\n    // Modifiers\n    // -----------------------------------------------------------------------------------------------------------------\n    modifier communityVoteInitialized() {\n        require(address(communityVote) != address(0), \"Community vote not initialized [CommunityVotable.sol:67]\");\n        _;\n    }\n}\n\n/*\n * Hubii Nahmii\n *\n * Compliant with the Hubii Nahmii specification v0.12.\n *\n * Copyright (C) 2017-2018 Hubii AS\n */\n\n\n\n/**\n * @title Beneficiary\n * @notice A recipient of ethers and tokens\n */\ncontract Beneficiary {\n    /// @notice Receive ethers to the given wallet's given balance type\n    /// @param wallet The address of the concerned wallet\n    /// @param balanceType The target balance type of the wallet\n    function receiveEthersTo(address wallet, string memory balanceType)\n    public\n    payable;\n\n    /// @notice Receive token to the given wallet's given balance type\n    /// @dev The wallet must approve of the token transfer prior to calling this function\n    /// @param wallet The address of the concerned wallet\n    /// @param balanceType The target balance type of the wallet\n    /// @param amount The amount to deposit\n    /// @param currencyCt The address of the concerned currency contract (address(0) == ETH)\n    /// @param currencyId The ID of the concerned currency (0 for ETH and ERC20)\n    /// @param standard The standard of the token (\"\" for default registered, \"ERC20\", \"ERC721\")\n    function receiveTokensTo(address wallet, string memory balanceType, int256 amount, address currencyCt,\n        uint256 currencyId, string memory standard)\n    public;\n}\n\n/*\n * Hubii Nahmii\n *\n * Compliant with the Hubii Nahmii specification v0.12.\n *\n * Copyright (C) 2017-2018 Hubii AS\n */\n\n\n\n\n/**\n * @title     MonetaryTypesLib\n * @dev       Monetary data types\n */\nlibrary MonetaryTypesLib {\n    //\n    // Structures\n    // -----------------------------------------------------------------------------------------------------------------\n    struct Currency {\n        address ct;\n        uint256 id;\n    }\n\n    struct Figure {\n        int256 amount;\n        Currency currency;\n    }\n\n    struct NoncedAmount {\n        uint256 nonce;\n        int256 amount;\n    }\n}\n\n/*\n * Hubii Nahmii\n *\n * Compliant with the Hubii Nahmii specification v0.12.\n *\n * Copyright (C) 2017-2018 Hubii AS\n */\n\n\n\n\n\n\n\n/**\n * @title AccrualBeneficiary\n * @notice A beneficiary of accruals\n */\ncontract AccrualBeneficiary is Beneficiary {\n    //\n    // Functions\n    // -----------------------------------------------------------------------------------------------------------------\n    event CloseAccrualPeriodEvent();\n\n    //\n    // Functions\n    // -----------------------------------------------------------------------------------------------------------------\n    function closeAccrualPeriod(MonetaryTypesLib.Currency[] memory)\n    public\n    {\n        emit CloseAccrualPeriodEvent();\n    }\n}\n\n/*\n * Hubii Nahmii\n *\n * Compliant with the Hubii Nahmii specification v0.12.\n *\n * Copyright (C) 2017-2018 Hubii AS\n */\n\n\n\n\n\n\n/**\n * @title Benefactor\n * @notice An ownable that contains registered beneficiaries\n */\ncontract Benefactor is Ownable {\n    //\n    // Variables\n    // -----------------------------------------------------------------------------------------------------------------\n    Beneficiary[] public beneficiaries;\n    mapping(address => uint256) public beneficiaryIndexByAddress;\n\n    //\n    // Events\n    // -----------------------------------------------------------------------------------------------------------------\n    event RegisterBeneficiaryEvent(Beneficiary beneficiary);\n    event DeregisterBeneficiaryEvent(Beneficiary beneficiary);\n\n    //\n    // Functions\n    // -----------------------------------------------------------------------------------------------------------------\n    /// @notice Register the given beneficiary\n    /// @param beneficiary Address of beneficiary to be registered\n    function registerBeneficiary(Beneficiary beneficiary)\n    public\n    onlyDeployer\n    notNullAddress(address(beneficiary))\n    returns (bool)\n    {\n        address _beneficiary = address(beneficiary);\n\n        if (beneficiaryIndexByAddress[_beneficiary] > 0)\n            return false;\n\n        beneficiaries.push(beneficiary);\n        beneficiaryIndexByAddress[_beneficiary] = beneficiaries.length;\n\n        // Emit event\n        emit RegisterBeneficiaryEvent(beneficiary);\n\n        return true;\n    }\n\n    /// @notice Deregister the given beneficiary\n    /// @param beneficiary Address of beneficiary to be deregistered\n    function deregisterBeneficiary(Beneficiary beneficiary)\n    public\n    onlyDeployer\n    notNullAddress(address(beneficiary))\n    returns (bool)\n    {\n        address _beneficiary = address(beneficiary);\n\n        if (beneficiaryIndexByAddress[_beneficiary] == 0)\n            return false;\n\n        uint256 idx = beneficiaryIndexByAddress[_beneficiary] - 1;\n        if (idx < beneficiaries.length - 1) {\n            // Remap the last item in the array to this index\n            beneficiaries[idx] = beneficiaries[beneficiaries.length - 1];\n            beneficiaryIndexByAddress[address(beneficiaries[idx])] = idx + 1;\n        }\n        beneficiaries.length--;\n        beneficiaryIndexByAddress[_beneficiary] = 0;\n\n        // Emit event\n        emit DeregisterBeneficiaryEvent(beneficiary);\n\n        return true;\n    }\n\n    /// @notice Gauge whether the given address is the one of a registered beneficiary\n    /// @param beneficiary Address of beneficiary\n    /// @return true if beneficiary is registered, else false\n    function isRegisteredBeneficiary(Beneficiary beneficiary)\n    public\n    view\n    returns (bool)\n    {\n        return beneficiaryIndexByAddress[address(beneficiary)] > 0;\n    }\n\n    /// @notice Get the count of registered beneficiaries\n    /// @return The count of registered beneficiaries\n    function registeredBeneficiariesCount()\n    public\n    view\n    returns (uint256)\n    {\n        return beneficiaries.length;\n    }\n}\n\n/*\n * Hubii Nahmii\n *\n * Compliant with the Hubii Nahmii specification v0.12.\n *\n * Copyright (C) 2017-2018 Hubii AS based on Open-Zeppelin's SafeMath library\n */\n\n\n\n/**\n * @title     SafeMathIntLib\n * @dev       Math operations with safety checks that throw on error\n */\nlibrary SafeMathIntLib {\n    int256 constant INT256_MIN = int256((uint256(1) << 255));\n    int256 constant INT256_MAX = int256(~((uint256(1) << 255)));\n\n    //\n    //Functions below accept positive and negative integers and result must not overflow.\n    //\n    function div(int256 a, int256 b)\n    internal\n    pure\n    returns (int256)\n    {\n        require(a != INT256_MIN || b != - 1);\n        return a / b;\n    }\n\n    function mul(int256 a, int256 b)\n    internal\n    pure\n    returns (int256)\n    {\n        require(a != - 1 || b != INT256_MIN);\n        // overflow\n        require(b != - 1 || a != INT256_MIN);\n        // overflow\n        int256 c = a * b;\n        require((b == 0) || (c / b == a));\n        return c;\n    }\n\n    function sub(int256 a, int256 b)\n    internal\n    pure\n    returns (int256)\n    {\n        require((b >= 0 && a - b <= a) || (b < 0 && a - b > a));\n        return a - b;\n    }\n\n    function add(int256 a, int256 b)\n    internal\n    pure\n    returns (int256)\n    {\n        int256 c = a + b;\n        require((b >= 0 && c >= a) || (b < 0 && c < a));\n        return c;\n    }\n\n    //\n    //Functions below only accept positive integers and result must be greater or equal to zero too.\n    //\n    function div_nn(int256 a, int256 b)\n    internal\n    pure\n    returns (int256)\n    {\n        require(a >= 0 && b > 0);\n        return a / b;\n    }\n\n    function mul_nn(int256 a, int256 b)\n    internal\n    pure\n    returns (int256)\n    {\n        require(a >= 0 && b >= 0);\n        int256 c = a * b;\n        require(a == 0 || c / a == b);\n        require(c >= 0);\n        return c;\n    }\n\n    function sub_nn(int256 a, int256 b)\n    internal\n    pure\n    returns (int256)\n    {\n        require(a >= 0 && b >= 0 && b <= a);\n        return a - b;\n    }\n\n    function add_nn(int256 a, int256 b)\n    internal\n    pure\n    returns (int256)\n    {\n        require(a >= 0 && b >= 0);\n        int256 c = a + b;\n        require(c >= a);\n        return c;\n    }\n\n    //\n    //Conversion and validation functions.\n    //\n    function abs(int256 a)\n    public\n    pure\n    returns (int256)\n    {\n        return a < 0 ? neg(a) : a;\n    }\n\n    function neg(int256 a)\n    public\n    pure\n    returns (int256)\n    {\n        return mul(a, - 1);\n    }\n\n    function toNonZeroInt256(uint256 a)\n    public\n    pure\n    returns (int256)\n    {\n        require(a > 0 && a < (uint256(1) << 255));\n        return int256(a);\n    }\n\n    function toInt256(uint256 a)\n    public\n    pure\n    returns (int256)\n    {\n        require(a >= 0 && a < (uint256(1) << 255));\n        return int256(a);\n    }\n\n    function toUInt256(int256 a)\n    public\n    pure\n    returns (uint256)\n    {\n        require(a >= 0);\n        return uint256(a);\n    }\n\n    function isNonZeroPositiveInt256(int256 a)\n    public\n    pure\n    returns (bool)\n    {\n        return (a > 0);\n    }\n\n    function isPositiveInt256(int256 a)\n    public\n    pure\n    returns (bool)\n    {\n        return (a >= 0);\n    }\n\n    function isNonZeroNegativeInt256(int256 a)\n    public\n    pure\n    returns (bool)\n    {\n        return (a < 0);\n    }\n\n    function isNegativeInt256(int256 a)\n    public\n    pure\n    returns (bool)\n    {\n        return (a <= 0);\n    }\n\n    //\n    //Clamping functions.\n    //\n    function clamp(int256 a, int256 min, int256 max)\n    public\n    pure\n    returns (int256)\n    {\n        if (a < min)\n            return min;\n        return (a > max) ? max : a;\n    }\n\n    function clampMin(int256 a, int256 min)\n    public\n    pure\n    returns (int256)\n    {\n        return (a < min) ? min : a;\n    }\n\n    function clampMax(int256 a, int256 max)\n    public\n    pure\n    returns (int256)\n    {\n        return (a > max) ? max : a;\n    }\n}\n\n/*\n * Hubii Nahmii\n *\n * Compliant with the Hubii Nahmii specification v0.12.\n *\n * Copyright (C) 2017-2018 Hubii AS\n */\n\n\n\nlibrary ConstantsLib {\n    // Get the fraction that represents the entirety, equivalent of 100%\n    function PARTS_PER()\n    public\n    pure\n    returns (int256)\n    {\n        return 1e18;\n    }\n}\n\n/*\n * Hubii Nahmii\n *\n * Compliant with the Hubii Nahmii specification v0.12.\n *\n * Copyright (C) 2017-2018 Hubii AS\n */\n\n\n\n\n\n\n\n\n\n/**\n * @title AccrualBenefactor\n * @notice A benefactor whose registered beneficiaries obtain a predefined fraction of total amount\n */\ncontract AccrualBenefactor is Benefactor {\n    using SafeMathIntLib for int256;\n\n    //\n    // Variables\n    // -----------------------------------------------------------------------------------------------------------------\n    mapping(address => int256) private _beneficiaryFractionMap;\n    int256 public totalBeneficiaryFraction;\n\n    //\n    // Events\n    // -----------------------------------------------------------------------------------------------------------------\n    event RegisterAccrualBeneficiaryEvent(Beneficiary beneficiary, int256 fraction);\n    event DeregisterAccrualBeneficiaryEvent(Beneficiary beneficiary);\n\n    //\n    // Functions\n    // -----------------------------------------------------------------------------------------------------------------\n    /// @notice Register the given accrual beneficiary for the entirety fraction\n    /// @param beneficiary Address of accrual beneficiary to be registered\n    function registerBeneficiary(Beneficiary beneficiary)\n    public\n    onlyDeployer\n    notNullAddress(address(beneficiary))\n    returns (bool)\n    {\n        return registerFractionalBeneficiary(AccrualBeneficiary(address(beneficiary)), ConstantsLib.PARTS_PER());\n    }\n\n    /// @notice Register the given accrual beneficiary for the given fraction\n    /// @param beneficiary Address of accrual beneficiary to be registered\n    /// @param fraction Fraction of benefits to be given\n    function registerFractionalBeneficiary(AccrualBeneficiary beneficiary, int256 fraction)\n    public\n    onlyDeployer\n    notNullAddress(address(beneficiary))\n    returns (bool)\n    {\n        require(fraction > 0, \"Fraction not strictly positive [AccrualBenefactor.sol:59]\");\n        require(\n            totalBeneficiaryFraction.add(fraction) <= ConstantsLib.PARTS_PER(),\n            \"Total beneficiary fraction out of bounds [AccrualBenefactor.sol:60]\"\n        );\n\n        if (!super.registerBeneficiary(beneficiary))\n            return false;\n\n        _beneficiaryFractionMap[address(beneficiary)] = fraction;\n        totalBeneficiaryFraction = totalBeneficiaryFraction.add(fraction);\n\n        // Emit event\n        emit RegisterAccrualBeneficiaryEvent(beneficiary, fraction);\n\n        return true;\n    }\n\n    /// @notice Deregister the given accrual beneficiary\n    /// @param beneficiary Address of accrual beneficiary to be deregistered\n    function deregisterBeneficiary(Beneficiary beneficiary)\n    public\n    onlyDeployer\n    notNullAddress(address(beneficiary))\n    returns (bool)\n    {\n        if (!super.deregisterBeneficiary(beneficiary))\n            return false;\n\n        address _beneficiary = address(beneficiary);\n\n        totalBeneficiaryFraction = totalBeneficiaryFraction.sub(_beneficiaryFractionMap[_beneficiary]);\n        _beneficiaryFractionMap[_beneficiary] = 0;\n\n        // Emit event\n        emit DeregisterAccrualBeneficiaryEvent(beneficiary);\n\n        return true;\n    }\n\n    /// @notice Get the fraction of benefits that is granted the given accrual beneficiary\n    /// @param beneficiary Address of accrual beneficiary\n    /// @return The beneficiary's fraction\n    function beneficiaryFraction(AccrualBeneficiary beneficiary)\n    public\n    view\n    returns (int256)\n    {\n        return _beneficiaryFractionMap[address(beneficiary)];\n    }\n}\n\n/*\n * Hubii Nahmii\n *\n * Compliant with the Hubii Nahmii specification v0.12.\n *\n * Copyright (C) 2017-2018 Hubii AS\n */\n\n\n\n/**\n * @title TransferController\n * @notice A base contract to handle transfers of different currency types\n */\ncontract TransferController {\n    //\n    // Events\n    // -----------------------------------------------------------------------------------------------------------------\n    event CurrencyTransferred(address from, address to, uint256 value,\n        address currencyCt, uint256 currencyId);\n\n    //\n    // Functions\n    // -----------------------------------------------------------------------------------------------------------------\n    function isFungible()\n    public\n    view\n    returns (bool);\n\n    function standard()\n    public\n    view\n    returns (string memory);\n\n    /// @notice MUST be called with DELEGATECALL\n    function receive(address from, address to, uint256 value, address currencyCt, uint256 currencyId)\n    public;\n\n    /// @notice MUST be called with DELEGATECALL\n    function approve(address to, uint256 value, address currencyCt, uint256 currencyId)\n    public;\n\n    /// @notice MUST be called with DELEGATECALL\n    function dispatch(address from, address to, uint256 value, address currencyCt, uint256 currencyId)\n    public;\n\n    //----------------------------------------\n\n    function getReceiveSignature()\n    public\n    pure\n    returns (bytes4)\n    {\n        return bytes4(keccak256(\"receive(address,address,uint256,address,uint256)\"));\n    }\n\n    function getApproveSignature()\n    public\n    pure\n    returns (bytes4)\n    {\n        return bytes4(keccak256(\"approve(address,uint256,address,uint256)\"));\n    }\n\n    function getDispatchSignature()\n    public\n    pure\n    returns (bytes4)\n    {\n        return bytes4(keccak256(\"dispatch(address,address,uint256,address,uint256)\"));\n    }\n}\n\n/*\n * Hubii Nahmii\n *\n * Compliant with the Hubii Nahmii specification v0.12.\n *\n * Copyright (C) 2017-2018 Hubii AS\n */\n\n\n\n\n\n\n/**\n * @title TransferControllerManager\n * @notice Handles the management of transfer controllers\n */\ncontract TransferControllerManager is Ownable {\n    //\n    // Constants\n    // -----------------------------------------------------------------------------------------------------------------\n    struct CurrencyInfo {\n        bytes32 standard;\n        bool blacklisted;\n    }\n\n    //\n    // Variables\n    // -----------------------------------------------------------------------------------------------------------------\n    mapping(bytes32 => address) public registeredTransferControllers;\n    mapping(address => CurrencyInfo) public registeredCurrencies;\n\n    //\n    // Events\n    // -----------------------------------------------------------------------------------------------------------------\n    event RegisterTransferControllerEvent(string standard, address controller);\n    event ReassociateTransferControllerEvent(string oldStandard, string newStandard, address controller);\n\n    event RegisterCurrencyEvent(address currencyCt, string standard);\n    event DeregisterCurrencyEvent(address currencyCt);\n    event BlacklistCurrencyEvent(address currencyCt);\n    event WhitelistCurrencyEvent(address currencyCt);\n\n    //\n    // Constructor\n    // -----------------------------------------------------------------------------------------------------------------\n    constructor(address deployer) Ownable(deployer) public {\n    }\n\n    //\n    // Functions\n    // -----------------------------------------------------------------------------------------------------------------\n    function registerTransferController(string calldata standard, address controller)\n    external\n    onlyDeployer\n    notNullAddress(controller)\n    {\n        require(bytes(standard).length > 0, \"Empty standard not supported [TransferControllerManager.sol:58]\");\n        bytes32 standardHash = keccak256(abi.encodePacked(standard));\n\n        registeredTransferControllers[standardHash] = controller;\n\n        // Emit event\n        emit RegisterTransferControllerEvent(standard, controller);\n    }\n\n    function reassociateTransferController(string calldata oldStandard, string calldata newStandard, address controller)\n    external\n    onlyDeployer\n    notNullAddress(controller)\n    {\n        require(bytes(newStandard).length > 0, \"Empty new standard not supported [TransferControllerManager.sol:72]\");\n        bytes32 oldStandardHash = keccak256(abi.encodePacked(oldStandard));\n        bytes32 newStandardHash = keccak256(abi.encodePacked(newStandard));\n\n        require(registeredTransferControllers[oldStandardHash] != address(0), \"Old standard not registered [TransferControllerManager.sol:76]\");\n        require(registeredTransferControllers[newStandardHash] == address(0), \"New standard previously registered [TransferControllerManager.sol:77]\");\n\n        registeredTransferControllers[newStandardHash] = registeredTransferControllers[oldStandardHash];\n        registeredTransferControllers[oldStandardHash] = address(0);\n\n        // Emit event\n        emit ReassociateTransferControllerEvent(oldStandard, newStandard, controller);\n    }\n\n    function registerCurrency(address currencyCt, string calldata standard)\n    external\n    onlyOperator\n    notNullAddress(currencyCt)\n    {\n        require(bytes(standard).length > 0, \"Empty standard not supported [TransferControllerManager.sol:91]\");\n        bytes32 standardHash = keccak256(abi.encodePacked(standard));\n\n        require(registeredCurrencies[currencyCt].standard == bytes32(0), \"Currency previously registered [TransferControllerManager.sol:94]\");\n\n        registeredCurrencies[currencyCt].standard = standardHash;\n\n        // Emit event\n        emit RegisterCurrencyEvent(currencyCt, standard);\n    }\n\n    function deregisterCurrency(address currencyCt)\n    external\n    onlyOperator\n    {\n        require(registeredCurrencies[currencyCt].standard != 0, \"Currency not registered [TransferControllerManager.sol:106]\");\n\n        registeredCurrencies[currencyCt].standard = bytes32(0);\n        registeredCurrencies[currencyCt].blacklisted = false;\n\n        // Emit event\n        emit DeregisterCurrencyEvent(currencyCt);\n    }\n\n    function blacklistCurrency(address currencyCt)\n    external\n    onlyOperator\n    {\n        require(registeredCurrencies[currencyCt].standard != bytes32(0), \"Currency not registered [TransferControllerManager.sol:119]\");\n\n        registeredCurrencies[currencyCt].blacklisted = true;\n\n        // Emit event\n        emit BlacklistCurrencyEvent(currencyCt);\n    }\n\n    function whitelistCurrency(address currencyCt)\n    external\n    onlyOperator\n    {\n        require(registeredCurrencies[currencyCt].standard != bytes32(0), \"Currency not registered [TransferControllerManager.sol:131]\");\n\n        registeredCurrencies[currencyCt].blacklisted = false;\n\n        // Emit event\n        emit WhitelistCurrencyEvent(currencyCt);\n    }\n\n    /**\n    @notice The provided standard takes priority over assigned interface to currency\n    */\n    function transferController(address currencyCt, string memory standard)\n    public\n    view\n    returns (TransferController)\n    {\n        if (bytes(standard).length > 0) {\n            bytes32 standardHash = keccak256(abi.encodePacked(standard));\n\n            require(registeredTransferControllers[standardHash] != address(0), \"Standard not registered [TransferControllerManager.sol:150]\");\n            return TransferController(registeredTransferControllers[standardHash]);\n        }\n\n        require(registeredCurrencies[currencyCt].standard != bytes32(0), \"Currency not registered [TransferControllerManager.sol:154]\");\n        require(!registeredCurrencies[currencyCt].blacklisted, \"Currency blacklisted [TransferControllerManager.sol:155]\");\n\n        address controllerAddress = registeredTransferControllers[registeredCurrencies[currencyCt].standard];\n        require(controllerAddress != address(0), \"No matching transfer controller [TransferControllerManager.sol:158]\");\n\n        return TransferController(controllerAddress);\n    }\n}\n\n/*\n * Hubii Nahmii\n *\n * Compliant with the Hubii Nahmii specification v0.12.\n *\n * Copyright (C) 2017-2018 Hubii AS\n */\n\n\n\n\n\n\n\n/**\n * @title TransferControllerManageable\n * @notice An ownable with a transfer controller manager\n */\ncontract TransferControllerManageable is Ownable {\n    //\n    // Variables\n    // -----------------------------------------------------------------------------------------------------------------\n    TransferControllerManager public transferControllerManager;\n\n    //\n    // Events\n    // -----------------------------------------------------------------------------------------------------------------\n    event SetTransferControllerManagerEvent(TransferControllerManager oldTransferControllerManager,\n        TransferControllerManager newTransferControllerManager);\n\n    //\n    // Functions\n    // -----------------------------------------------------------------------------------------------------------------\n    /// @notice Set the currency manager contract\n    /// @param newTransferControllerManager The (address of) TransferControllerManager contract instance\n    function setTransferControllerManager(TransferControllerManager newTransferControllerManager)\n    public\n    onlyDeployer\n    notNullAddress(address(newTransferControllerManager))\n    notSameAddresses(address(newTransferControllerManager), address(transferControllerManager))\n    {\n        //set new currency manager\n        TransferControllerManager oldTransferControllerManager = transferControllerManager;\n        transferControllerManager = newTransferControllerManager;\n\n        // Emit event\n        emit SetTransferControllerManagerEvent(oldTransferControllerManager, newTransferControllerManager);\n    }\n\n    /// @notice Get the transfer controller of the given currency contract address and standard\n    function transferController(address currencyCt, string memory standard)\n    internal\n    view\n    returns (TransferController)\n    {\n        return transferControllerManager.transferController(currencyCt, standard);\n    }\n\n    //\n    // Modifiers\n    // -----------------------------------------------------------------------------------------------------------------\n    modifier transferControllerManagerInitialized() {\n        require(address(transferControllerManager) != address(0), \"Transfer controller manager not initialized [TransferControllerManageable.sol:63]\");\n        _;\n    }\n}\n\n/*\n * Hubii Nahmii\n *\n * Compliant with the Hubii Nahmii specification v0.12.\n *\n * Copyright (C) 2017-2018 Hubii AS based on Open-Zeppelin's SafeMath library\n */\n\n\n\n/**\n * @title     SafeMathUintLib\n * @dev       Math operations with safety checks that throw on error\n */\nlibrary SafeMathUintLib {\n    function mul(uint256 a, uint256 b)\n    internal\n    pure\n    returns (uint256)\n    {\n        uint256 c = a * b;\n        assert(a == 0 || c / a == b);\n        return c;\n    }\n\n    function div(uint256 a, uint256 b)\n    internal\n    pure\n    returns (uint256)\n    {\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n        return c;\n    }\n\n    function sub(uint256 a, uint256 b)\n    internal\n    pure\n    returns (uint256)\n    {\n        assert(b <= a);\n        return a - b;\n    }\n\n    function add(uint256 a, uint256 b)\n    internal\n    pure\n    returns (uint256)\n    {\n        uint256 c = a + b;\n        assert(c >= a);\n        return c;\n    }\n\n    //\n    //Clamping functions.\n    //\n    function clamp(uint256 a, uint256 min, uint256 max)\n    public\n    pure\n    returns (uint256)\n    {\n        return (a > max) ? max : ((a < min) ? min : a);\n    }\n\n    function clampMin(uint256 a, uint256 min)\n    public\n    pure\n    returns (uint256)\n    {\n        return (a < min) ? min : a;\n    }\n\n    function clampMax(uint256 a, uint256 max)\n    public\n    pure\n    returns (uint256)\n    {\n        return (a > max) ? max : a;\n    }\n}\n\n/*\n * Hubii Nahmii\n *\n * Compliant with the Hubii Nahmii specification v0.12.\n *\n * Copyright (C) 2017-2018 Hubii AS\n */\n\n\n\n\n\n\n\nlibrary CurrenciesLib {\n    using SafeMathUintLib for uint256;\n\n    //\n    // Structures\n    // -----------------------------------------------------------------------------------------------------------------\n    struct Currencies {\n        MonetaryTypesLib.Currency[] currencies;\n        mapping(address => mapping(uint256 => uint256)) indexByCurrency;\n    }\n\n    //\n    // Functions\n    // -----------------------------------------------------------------------------------------------------------------\n    function add(Currencies storage self, address currencyCt, uint256 currencyId)\n    internal\n    {\n        // Index is 1-based\n        if (0 == self.indexByCurrency[currencyCt][currencyId]) {\n            self.currencies.push(MonetaryTypesLib.Currency(currencyCt, currencyId));\n            self.indexByCurrency[currencyCt][currencyId] = self.currencies.length;\n        }\n    }\n\n    function removeByCurrency(Currencies storage self, address currencyCt, uint256 currencyId)\n    internal\n    {\n        // Index is 1-based\n        uint256 index = self.indexByCurrency[currencyCt][currencyId];\n        if (0 < index)\n            removeByIndex(self, index - 1);\n    }\n\n    function removeByIndex(Currencies storage self, uint256 index)\n    internal\n    {\n        require(index < self.currencies.length, \"Index out of bounds [CurrenciesLib.sol:51]\");\n\n        address currencyCt = self.currencies[index].ct;\n        uint256 currencyId = self.currencies[index].id;\n\n        if (index < self.currencies.length - 1) {\n            self.currencies[index] = self.currencies[self.currencies.length - 1];\n            self.indexByCurrency[self.currencies[index].ct][self.currencies[index].id] = index + 1;\n        }\n        self.currencies.length--;\n        self.indexByCurrency[currencyCt][currencyId] = 0;\n    }\n\n    function count(Currencies storage self)\n    internal\n    view\n    returns (uint256)\n    {\n        return self.currencies.length;\n    }\n\n    function has(Currencies storage self, address currencyCt, uint256 currencyId)\n    internal\n    view\n    returns (bool)\n    {\n        return 0 != self.indexByCurrency[currencyCt][currencyId];\n    }\n\n    function getByIndex(Currencies storage self, uint256 index)\n    internal\n    view\n    returns (MonetaryTypesLib.Currency memory)\n    {\n        require(index < self.currencies.length, \"Index out of bounds [CurrenciesLib.sol:85]\");\n        return self.currencies[index];\n    }\n\n    function getByIndices(Currencies storage self, uint256 low, uint256 up)\n    internal\n    view\n    returns (MonetaryTypesLib.Currency[] memory)\n    {\n        require(0 < self.currencies.length, \"No currencies found [CurrenciesLib.sol:94]\");\n        require(low <= up, \"Bounds parameters mismatch [CurrenciesLib.sol:95]\");\n\n        up = up.clampMax(self.currencies.length - 1);\n        MonetaryTypesLib.Currency[] memory _currencies = new MonetaryTypesLib.Currency[](up - low + 1);\n        for (uint256 i = low; i <= up; i++)\n            _currencies[i - low] = self.currencies[i];\n\n        return _currencies;\n    }\n}\n\n/*\n * Hubii Nahmii\n *\n * Compliant with the Hubii Nahmii specification v0.12.\n *\n * Copyright (C) 2017-2018 Hubii AS\n */\n\n\n\n\n\n\n\nlibrary FungibleBalanceLib {\n    using SafeMathIntLib for int256;\n    using SafeMathUintLib for uint256;\n    using CurrenciesLib for CurrenciesLib.Currencies;\n\n    //\n    // Structures\n    // -----------------------------------------------------------------------------------------------------------------\n    struct Record {\n        int256 amount;\n        uint256 blockNumber;\n    }\n\n    struct Balance {\n        mapping(address => mapping(uint256 => int256)) amountByCurrency;\n        mapping(address => mapping(uint256 => Record[])) recordsByCurrency;\n\n        CurrenciesLib.Currencies inUseCurrencies;\n        CurrenciesLib.Currencies everUsedCurrencies;\n    }\n\n    //\n    // Functions\n    // -----------------------------------------------------------------------------------------------------------------\n    function get(Balance storage self, address currencyCt, uint256 currencyId)\n    internal\n    view\n    returns (int256)\n    {\n        return self.amountByCurrency[currencyCt][currencyId];\n    }\n\n    function getByBlockNumber(Balance storage self, address currencyCt, uint256 currencyId, uint256 blockNumber)\n    internal\n    view\n    returns (int256)\n    {\n        (int256 amount,) = recordByBlockNumber(self, currencyCt, currencyId, blockNumber);\n        return amount;\n    }\n\n    function set(Balance storage self, int256 amount, address currencyCt, uint256 currencyId)\n    internal\n    {\n        self.amountByCurrency[currencyCt][currencyId] = amount;\n\n        self.recordsByCurrency[currencyCt][currencyId].push(\n            Record(self.amountByCurrency[currencyCt][currencyId], block.number)\n        );\n\n        updateCurrencies(self, currencyCt, currencyId);\n    }\n\n    function add(Balance storage self, int256 amount, address currencyCt, uint256 currencyId)\n    internal\n    {\n        self.amountByCurrency[currencyCt][currencyId] = self.amountByCurrency[currencyCt][currencyId].add(amount);\n\n        self.recordsByCurrency[currencyCt][currencyId].push(\n            Record(self.amountByCurrency[currencyCt][currencyId], block.number)\n        );\n\n        updateCurrencies(self, currencyCt, currencyId);\n    }\n\n    function sub(Balance storage self, int256 amount, address currencyCt, uint256 currencyId)\n    internal\n    {\n        self.amountByCurrency[currencyCt][currencyId] = self.amountByCurrency[currencyCt][currencyId].sub(amount);\n\n        self.recordsByCurrency[currencyCt][currencyId].push(\n            Record(self.amountByCurrency[currencyCt][currencyId], block.number)\n        );\n\n        updateCurrencies(self, currencyCt, currencyId);\n    }\n\n    function transfer(Balance storage _from, Balance storage _to, int256 amount,\n        address currencyCt, uint256 currencyId)\n    internal\n    {\n        sub(_from, amount, currencyCt, currencyId);\n        add(_to, amount, currencyCt, currencyId);\n    }\n\n    function add_nn(Balance storage self, int256 amount, address currencyCt, uint256 currencyId)\n    internal\n    {\n        self.amountByCurrency[currencyCt][currencyId] = self.amountByCurrency[currencyCt][currencyId].add_nn(amount);\n\n        self.recordsByCurrency[currencyCt][currencyId].push(\n            Record(self.amountByCurrency[currencyCt][currencyId], block.number)\n        );\n\n        updateCurrencies(self, currencyCt, currencyId);\n    }\n\n    function sub_nn(Balance storage self, int256 amount, address currencyCt, uint256 currencyId)\n    internal\n    {\n        self.amountByCurrency[currencyCt][currencyId] = self.amountByCurrency[currencyCt][currencyId].sub_nn(amount);\n\n        self.recordsByCurrency[currencyCt][currencyId].push(\n            Record(self.amountByCurrency[currencyCt][currencyId], block.number)\n        );\n\n        updateCurrencies(self, currencyCt, currencyId);\n    }\n\n    function transfer_nn(Balance storage _from, Balance storage _to, int256 amount,\n        address currencyCt, uint256 currencyId)\n    internal\n    {\n        sub_nn(_from, amount, currencyCt, currencyId);\n        add_nn(_to, amount, currencyCt, currencyId);\n    }\n\n    function recordsCount(Balance storage self, address currencyCt, uint256 currencyId)\n    internal\n    view\n    returns (uint256)\n    {\n        return self.recordsByCurrency[currencyCt][currencyId].length;\n    }\n\n    function recordByBlockNumber(Balance storage self, address currencyCt, uint256 currencyId, uint256 blockNumber)\n    internal\n    view\n    returns (int256, uint256)\n    {\n        uint256 index = indexByBlockNumber(self, currencyCt, currencyId, blockNumber);\n        return 0 < index ? recordByIndex(self, currencyCt, currencyId, index - 1) : (0, 0);\n    }\n\n    function recordByIndex(Balance storage self, address currencyCt, uint256 currencyId, uint256 index)\n    internal\n    view\n    returns (int256, uint256)\n    {\n        if (0 == self.recordsByCurrency[currencyCt][currencyId].length)\n            return (0, 0);\n\n        index = index.clampMax(self.recordsByCurrency[currencyCt][currencyId].length - 1);\n        Record storage record = self.recordsByCurrency[currencyCt][currencyId][index];\n        return (record.amount, record.blockNumber);\n    }\n\n    function lastRecord(Balance storage self, address currencyCt, uint256 currencyId)\n    internal\n    view\n    returns (int256, uint256)\n    {\n        if (0 == self.recordsByCurrency[currencyCt][currencyId].length)\n            return (0, 0);\n\n        Record storage record = self.recordsByCurrency[currencyCt][currencyId][self.recordsByCurrency[currencyCt][currencyId].length - 1];\n        return (record.amount, record.blockNumber);\n    }\n\n    function hasInUseCurrency(Balance storage self, address currencyCt, uint256 currencyId)\n    internal\n    view\n    returns (bool)\n    {\n        return self.inUseCurrencies.has(currencyCt, currencyId);\n    }\n\n    function hasEverUsedCurrency(Balance storage self, address currencyCt, uint256 currencyId)\n    internal\n    view\n    returns (bool)\n    {\n        return self.everUsedCurrencies.has(currencyCt, currencyId);\n    }\n\n    function updateCurrencies(Balance storage self, address currencyCt, uint256 currencyId)\n    internal\n    {\n        if (0 == self.amountByCurrency[currencyCt][currencyId] && self.inUseCurrencies.has(currencyCt, currencyId))\n            self.inUseCurrencies.removeByCurrency(currencyCt, currencyId);\n        else if (!self.inUseCurrencies.has(currencyCt, currencyId)) {\n            self.inUseCurrencies.add(currencyCt, currencyId);\n            self.everUsedCurrencies.add(currencyCt, currencyId);\n        }\n    }\n\n    function indexByBlockNumber(Balance storage self, address currencyCt, uint256 currencyId, uint256 blockNumber)\n    internal\n    view\n    returns (uint256)\n    {\n        if (0 == self.recordsByCurrency[currencyCt][currencyId].length)\n            return 0;\n        for (uint256 i = self.recordsByCurrency[currencyCt][currencyId].length; i > 0; i--)\n            if (self.recordsByCurrency[currencyCt][currencyId][i - 1].blockNumber <= blockNumber)\n                return i;\n        return 0;\n    }\n}\n\n/*\n * Hubii Nahmii\n *\n * Compliant with the Hubii Nahmii specification v0.12.\n *\n * Copyright (C) 2017-2018 Hubii AS\n */\n\n\n\nlibrary TxHistoryLib {\n    //\n    // Structures\n    // -----------------------------------------------------------------------------------------------------------------\n    struct AssetEntry {\n        int256 amount;\n        uint256 blockNumber;\n        address currencyCt;      //0 for ethers\n        uint256 currencyId;\n    }\n\n    struct TxHistory {\n        AssetEntry[] deposits;\n        mapping(address => mapping(uint256 => AssetEntry[])) currencyDeposits;\n\n        AssetEntry[] withdrawals;\n        mapping(address => mapping(uint256 => AssetEntry[])) currencyWithdrawals;\n    }\n\n    //\n    // Functions\n    // -----------------------------------------------------------------------------------------------------------------\n    function addDeposit(TxHistory storage self, int256 amount, address currencyCt, uint256 currencyId)\n    internal\n    {\n        AssetEntry memory deposit = AssetEntry(amount, block.number, currencyCt, currencyId);\n        self.deposits.push(deposit);\n        self.currencyDeposits[currencyCt][currencyId].push(deposit);\n    }\n\n    function addWithdrawal(TxHistory storage self, int256 amount, address currencyCt, uint256 currencyId)\n    internal\n    {\n        AssetEntry memory withdrawal = AssetEntry(amount, block.number, currencyCt, currencyId);\n        self.withdrawals.push(withdrawal);\n        self.currencyWithdrawals[currencyCt][currencyId].push(withdrawal);\n    }\n\n    //----\n\n    function deposit(TxHistory storage self, uint index)\n    internal\n    view\n    returns (int256 amount, uint256 blockNumber, address currencyCt, uint256 currencyId)\n    {\n        require(index < self.deposits.length, \"Index ouf of bounds [TxHistoryLib.sol:56]\");\n\n        amount = self.deposits[index].amount;\n        blockNumber = self.deposits[index].blockNumber;\n        currencyCt = self.deposits[index].currencyCt;\n        currencyId = self.deposits[index].currencyId;\n    }\n\n    function depositsCount(TxHistory storage self)\n    internal\n    view\n    returns (uint256)\n    {\n        return self.deposits.length;\n    }\n\n    function currencyDeposit(TxHistory storage self, address currencyCt, uint256 currencyId, uint index)\n    internal\n    view\n    returns (int256 amount, uint256 blockNumber)\n    {\n        require(index < self.currencyDeposits[currencyCt][currencyId].length, \"Index out of bounds [TxHistoryLib.sol:77]\");\n\n        amount = self.currencyDeposits[currencyCt][currencyId][index].amount;\n        blockNumber = self.currencyDeposits[currencyCt][currencyId][index].blockNumber;\n    }\n\n    function currencyDepositsCount(TxHistory storage self, address currencyCt, uint256 currencyId)\n    internal\n    view\n    returns (uint256)\n    {\n        return self.currencyDeposits[currencyCt][currencyId].length;\n    }\n\n    //----\n\n    function withdrawal(TxHistory storage self, uint index)\n    internal\n    view\n    returns (int256 amount, uint256 blockNumber, address currencyCt, uint256 currencyId)\n    {\n        require(index < self.withdrawals.length, \"Index out of bounds [TxHistoryLib.sol:98]\");\n\n        amount = self.withdrawals[index].amount;\n        blockNumber = self.withdrawals[index].blockNumber;\n        currencyCt = self.withdrawals[index].currencyCt;\n        currencyId = self.withdrawals[index].currencyId;\n    }\n\n    function withdrawalsCount(TxHistory storage self)\n    internal\n    view\n    returns (uint256)\n    {\n        return self.withdrawals.length;\n    }\n\n    function currencyWithdrawal(TxHistory storage self, address currencyCt, uint256 currencyId, uint index)\n    internal\n    view\n    returns (int256 amount, uint256 blockNumber)\n    {\n        require(index < self.currencyWithdrawals[currencyCt][currencyId].length, \"Index out of bounds [TxHistoryLib.sol:119]\");\n\n        amount = self.currencyWithdrawals[currencyCt][currencyId][index].amount;\n        blockNumber = self.currencyWithdrawals[currencyCt][currencyId][index].blockNumber;\n    }\n\n    function currencyWithdrawalsCount(TxHistory storage self, address currencyCt, uint256 currencyId)\n    internal\n    view\n    returns (uint256)\n    {\n        return self.currencyWithdrawals[currencyCt][currencyId].length;\n    }\n}\n\n/*\n * Hubii Nahmii\n *\n * Compliant with the Hubii Nahmii specification v0.12.\n *\n * Copyright (C) 2017-2018 Hubii AS\n */\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * @title RevenueFund\n * @notice The target of all revenue earned in driip settlements and from which accrued revenue is split amongst\n *   accrual beneficiaries.\n */\ncontract RevenueFund is Ownable, AccrualBeneficiary, AccrualBenefactor, TransferControllerManageable {\n    using FungibleBalanceLib for FungibleBalanceLib.Balance;\n    using TxHistoryLib for TxHistoryLib.TxHistory;\n    using SafeMathIntLib for int256;\n    using SafeMathUintLib for uint256;\n    using CurrenciesLib for CurrenciesLib.Currencies;\n\n    //\n    // Variables\n    // -----------------------------------------------------------------------------------------------------------------\n    FungibleBalanceLib.Balance periodAccrual;\n    CurrenciesLib.Currencies periodCurrencies;\n\n    FungibleBalanceLib.Balance aggregateAccrual;\n    CurrenciesLib.Currencies aggregateCurrencies;\n\n    TxHistoryLib.TxHistory private txHistory;\n\n    //\n    // Events\n    // -----------------------------------------------------------------------------------------------------------------\n    event ReceiveEvent(address from, int256 amount, address currencyCt, uint256 currencyId);\n    event CloseAccrualPeriodEvent();\n    event RegisterServiceEvent(address service);\n    event DeregisterServiceEvent(address service);\n\n    //\n    // Constructor\n    // -----------------------------------------------------------------------------------------------------------------\n    constructor(address deployer) Ownable(deployer) public {\n    }\n\n    //\n    // Functions\n    // -----------------------------------------------------------------------------------------------------------------\n    /// @notice Fallback function that deposits ethers\n    function() external payable {\n        receiveEthersTo(msg.sender, \"\");\n    }\n\n    /// @notice Receive ethers to\n    /// @param wallet The concerned wallet address\n    function receiveEthersTo(address wallet, string memory)\n    public\n    payable\n    {\n        int256 amount = SafeMathIntLib.toNonZeroInt256(msg.value);\n\n        // Add to balances\n        periodAccrual.add(amount, address(0), 0);\n        aggregateAccrual.add(amount, address(0), 0);\n\n        // Add currency to stores of currencies\n        periodCurrencies.add(address(0), 0);\n        aggregateCurrencies.add(address(0), 0);\n\n        // Add to transaction history\n        txHistory.addDeposit(amount, address(0), 0);\n\n        // Emit event\n        emit ReceiveEvent(wallet, amount, address(0), 0);\n    }\n\n    /// @notice Receive tokens\n    /// @param amount The concerned amount\n    /// @param currencyCt The address of the concerned currency contract (address(0) == ETH)\n    /// @param currencyId The ID of the concerned currency (0 for ETH and ERC20)\n    /// @param standard The standard of token (\"ERC20\", \"ERC721\")\n    function receiveTokens(string memory balanceType, int256 amount, address currencyCt,\n        uint256 currencyId, string memory standard)\n    public\n    {\n        receiveTokensTo(msg.sender, balanceType, amount, currencyCt, currencyId, standard);\n    }\n\n    /// @notice Receive tokens to\n    /// @param wallet The address of the concerned wallet\n    /// @param amount The concerned amount\n    /// @param currencyCt The address of the concerned currency contract (address(0) == ETH)\n    /// @param currencyId The ID of the concerned currency (0 for ETH and ERC20)\n    /// @param standard The standard of token (\"ERC20\", \"ERC721\")\n    function receiveTokensTo(address wallet, string memory, int256 amount,\n        address currencyCt, uint256 currencyId, string memory standard)\n    public\n    {\n        require(amount.isNonZeroPositiveInt256(), \"Amount not strictly positive [RevenueFund.sol:115]\");\n\n        // Execute transfer\n        TransferController controller = transferController(currencyCt, standard);\n        (bool success,) = address(controller).delegatecall(\n            abi.encodeWithSelector(\n                controller.getReceiveSignature(), msg.sender, this, uint256(amount), currencyCt, currencyId\n            )\n        );\n        require(success, \"Reception by controller failed [RevenueFund.sol:124]\");\n\n        // Add to balances\n        periodAccrual.add(amount, currencyCt, currencyId);\n        aggregateAccrual.add(amount, currencyCt, currencyId);\n\n        // Add currency to stores of currencies\n        periodCurrencies.add(currencyCt, currencyId);\n        aggregateCurrencies.add(currencyCt, currencyId);\n\n        // Add to transaction history\n        txHistory.addDeposit(amount, currencyCt, currencyId);\n\n        // Emit event\n        emit ReceiveEvent(wallet, amount, currencyCt, currencyId);\n    }\n\n    /// @notice Get the period accrual balance of the given currency\n    /// @param currencyCt The address of the concerned currency contract (address(0) == ETH)\n    /// @param currencyId The ID of the concerned currency (0 for ETH and ERC20)\n    /// @return The current period's accrual balance\n    function periodAccrualBalance(address currencyCt, uint256 currencyId)\n    public\n    view\n    returns (int256)\n    {\n        return periodAccrual.get(currencyCt, currencyId);\n    }\n\n    /// @notice Get the aggregate accrual balance of the given currency, including contribution from the\n    /// current accrual period\n    /// @param currencyCt The address of the concerned currency contract (address(0) == ETH)\n    /// @param currencyId The ID of the concerned currency (0 for ETH and ERC20)\n    /// @return The aggregate accrual balance\n    function aggregateAccrualBalance(address currencyCt, uint256 currencyId)\n    public\n    view\n    returns (int256)\n    {\n        return aggregateAccrual.get(currencyCt, currencyId);\n    }\n\n    /// @notice Get the count of currencies recorded in the accrual period\n    /// @return The number of currencies in the current accrual period\n    function periodCurrenciesCount()\n    public\n    view\n    returns (uint256)\n    {\n        return periodCurrencies.count();\n    }\n\n    /// @notice Get the currencies with indices in the given range that have been recorded in the current accrual period\n    /// @param low The lower currency index\n    /// @param up The upper currency index\n    /// @return The currencies of the given index range in the current accrual period\n    function periodCurrenciesByIndices(uint256 low, uint256 up)\n    public\n    view\n    returns (MonetaryTypesLib.Currency[] memory)\n    {\n        return periodCurrencies.getByIndices(low, up);\n    }\n\n    /// @notice Get the count of currencies ever recorded\n    /// @return The number of currencies ever recorded\n    function aggregateCurrenciesCount()\n    public\n    view\n    returns (uint256)\n    {\n        return aggregateCurrencies.count();\n    }\n\n    /// @notice Get the currencies with indices in the given range that have ever been recorded\n    /// @param low The lower currency index\n    /// @param up The upper currency index\n    /// @return The currencies of the given index range ever recorded\n    function aggregateCurrenciesByIndices(uint256 low, uint256 up)\n    public\n    view\n    returns (MonetaryTypesLib.Currency[] memory)\n    {\n        return aggregateCurrencies.getByIndices(low, up);\n    }\n\n    /// @notice Get the count of deposits\n    /// @return The count of deposits\n    function depositsCount()\n    public\n    view\n    returns (uint256)\n    {\n        return txHistory.depositsCount();\n    }\n\n    /// @notice Get the deposit at the given index\n    /// @return The deposit at the given index\n    function deposit(uint index)\n    public\n    view\n    returns (int256 amount, uint256 blockNumber, address currencyCt, uint256 currencyId)\n    {\n        return txHistory.deposit(index);\n    }\n\n    /// @notice Close the current accrual period of the given currencies\n    /// @param currencies The concerned currencies\n    function closeAccrualPeriod(MonetaryTypesLib.Currency[] memory currencies)\n    public\n    onlyOperator\n    {\n        require(\n            ConstantsLib.PARTS_PER() == totalBeneficiaryFraction,\n            \"Total beneficiary fraction out of bounds [RevenueFund.sol:236]\"\n        );\n\n        // Execute transfer\n        for (uint256 i = 0; i < currencies.length; i++) {\n            MonetaryTypesLib.Currency memory currency = currencies[i];\n\n            int256 remaining = periodAccrual.get(currency.ct, currency.id);\n\n            if (0 >= remaining)\n                continue;\n\n            for (uint256 j = 0; j < beneficiaries.length; j++) {\n                AccrualBeneficiary beneficiary = AccrualBeneficiary(address(beneficiaries[j]));\n\n                if (beneficiaryFraction(beneficiary) > 0) {\n                    int256 transferable = periodAccrual.get(currency.ct, currency.id)\n                    .mul(beneficiaryFraction(beneficiary))\n                    .div(ConstantsLib.PARTS_PER());\n\n                    if (transferable > remaining)\n                        transferable = remaining;\n\n                    if (transferable > 0) {\n                        // Transfer ETH to the beneficiary\n                        if (currency.ct == address(0))\n                            beneficiary.receiveEthersTo.value(uint256(transferable))(address(0), \"\");\n\n                        // Transfer token to the beneficiary\n                        else {\n                            TransferController controller = transferController(currency.ct, \"\");\n                            (bool success,) = address(controller).delegatecall(\n                                abi.encodeWithSelector(\n                                    controller.getApproveSignature(), address(beneficiary), uint256(transferable), currency.ct, currency.id\n                                )\n                            );\n                            require(success, \"Approval by controller failed [RevenueFund.sol:274]\");\n\n                            beneficiary.receiveTokensTo(address(0), \"\", transferable, currency.ct, currency.id, \"\");\n                        }\n\n                        remaining = remaining.sub(transferable);\n                    }\n                }\n            }\n\n            // Roll over remaining to next accrual period\n            periodAccrual.set(remaining, currency.ct, currency.id);\n        }\n\n        // Close accrual period of accrual beneficiaries\n        for (uint256 j = 0; j < beneficiaries.length; j++) {\n            AccrualBeneficiary beneficiary = AccrualBeneficiary(address(beneficiaries[j]));\n\n            // Require that beneficiary fraction is strictly positive\n            if (0 >= beneficiaryFraction(beneficiary))\n                continue;\n\n            // Close accrual period\n            beneficiary.closeAccrualPeriod(currencies);\n        }\n\n        // Emit event\n        emit CloseAccrualPeriodEvent();\n    }\n}\n\n/**\n * Strings Library\n * \n * In summary this is a simple library of string functions which make simple \n * string operations less tedious in solidity.\n * \n * Please be aware these functions can be quite gas heavy so use them only when\n * necessary not to clog the blockchain with expensive transactions.\n * \n * @author James Lockhart <james@n3tw0rk.co.uk>\n */\nlibrary Strings {\n\n    /**\n     * Concat (High gas cost)\n     * \n     * Appends two strings together and returns a new value\n     * \n     * @param _base When being used for a data type this is the extended object\n     *              otherwise this is the string which will be the concatenated\n     *              prefix\n     * @param _value The value to be the concatenated suffix\n     * @return string The resulting string from combinging the base and value\n     */\n    function concat(string memory _base, string memory _value)\n        internal\n        pure\n        returns (string memory) {\n        bytes memory _baseBytes = bytes(_base);\n        bytes memory _valueBytes = bytes(_value);\n\n        assert(_valueBytes.length > 0);\n\n        string memory _tmpValue = new string(_baseBytes.length +\n            _valueBytes.length);\n        bytes memory _newValue = bytes(_tmpValue);\n\n        uint i;\n        uint j;\n\n        for (i = 0; i < _baseBytes.length; i++) {\n            _newValue[j++] = _baseBytes[i];\n        }\n\n        for (i = 0; i < _valueBytes.length; i++) {\n            _newValue[j++] = _valueBytes[i];\n        }\n\n        return string(_newValue);\n    }\n\n    /**\n     * Index Of\n     *\n     * Locates and returns the position of a character within a string\n     * \n     * @param _base When being used for a data type this is the extended object\n     *              otherwise this is the string acting as the haystack to be\n     *              searched\n     * @param _value The needle to search for, at present this is currently\n     *               limited to one character\n     * @return int The position of the needle starting from 0 and returning -1\n     *             in the case of no matches found\n     */\n    function indexOf(string memory _base, string memory _value)\n        internal\n        pure\n        returns (int) {\n        return _indexOf(_base, _value, 0);\n    }\n\n    /**\n     * Index Of\n     *\n     * Locates and returns the position of a character within a string starting\n     * from a defined offset\n     * \n     * @param _base When being used for a data type this is the extended object\n     *              otherwise this is the string acting as the haystack to be\n     *              searched\n     * @param _value The needle to search for, at present this is currently\n     *               limited to one character\n     * @param _offset The starting point to start searching from which can start\n     *                from 0, but must not exceed the length of the string\n     * @return int The position of the needle starting from 0 and returning -1\n     *             in the case of no matches found\n     */\n    function _indexOf(string memory _base, string memory _value, uint _offset)\n        internal\n        pure\n        returns (int) {\n        bytes memory _baseBytes = bytes(_base);\n        bytes memory _valueBytes = bytes(_value);\n\n        assert(_valueBytes.length == 1);\n\n        for (uint i = _offset; i < _baseBytes.length; i++) {\n            if (_baseBytes[i] == _valueBytes[0]) {\n                return int(i);\n            }\n        }\n\n        return -1;\n    }\n\n    /**\n     * Length\n     * \n     * Returns the length of the specified string\n     * \n     * @param _base When being used for a data type this is the extended object\n     *              otherwise this is the string to be measured\n     * @return uint The length of the passed string\n     */\n    function length(string memory _base)\n        internal\n        pure\n        returns (uint) {\n        bytes memory _baseBytes = bytes(_base);\n        return _baseBytes.length;\n    }\n\n    /**\n     * Sub String\n     * \n     * Extracts the beginning part of a string based on the desired length\n     * \n     * @param _base When being used for a data type this is the extended object\n     *              otherwise this is the string that will be used for \n     *              extracting the sub string from\n     * @param _length The length of the sub string to be extracted from the base\n     * @return string The extracted sub string\n     */\n    function substring(string memory _base, int _length)\n        internal\n        pure\n        returns (string memory) {\n        return _substring(_base, _length, 0);\n    }\n\n    /**\n     * Sub String\n     * \n     * Extracts the part of a string based on the desired length and offset. The\n     * offset and length must not exceed the lenth of the base string.\n     * \n     * @param _base When being used for a data type this is the extended object\n     *              otherwise this is the string that will be used for \n     *              extracting the sub string from\n     * @param _length The length of the sub string to be extracted from the base\n     * @param _offset The starting point to extract the sub string from\n     * @return string The extracted sub string\n     */\n    function _substring(string memory _base, int _length, int _offset)\n        internal\n        pure\n        returns (string memory) {\n        bytes memory _baseBytes = bytes(_base);\n\n        assert(uint(_offset + _length) <= _baseBytes.length);\n\n        string memory _tmp = new string(uint(_length));\n        bytes memory _tmpBytes = bytes(_tmp);\n\n        uint j = 0;\n        for (uint i = uint(_offset); i < uint(_offset + _length); i++) {\n            _tmpBytes[j++] = _baseBytes[i];\n        }\n\n        return string(_tmpBytes);\n    }\n\n    /**\n     * String Split (Very high gas cost)\n     *\n     * Splits a string into an array of strings based off the delimiter value.\n     * Please note this can be quite a gas expensive function due to the use of\n     * storage so only use if really required.\n     *\n     * @param _base When being used for a data type this is the extended object\n     *               otherwise this is the string value to be split.\n     * @param _value The delimiter to split the string on which must be a single\n     *               character\n     * @return string[] An array of values split based off the delimiter, but\n     *                  do not container the delimiter.\n     */\n    function split(string memory _base, string memory _value)\n        internal\n        pure\n        returns (string[] memory splitArr) {\n        bytes memory _baseBytes = bytes(_base);\n\n        uint _offset = 0;\n        uint _splitsCount = 1;\n        while (_offset < _baseBytes.length - 1) {\n            int _limit = _indexOf(_base, _value, _offset);\n            if (_limit == -1)\n                break;\n            else {\n                _splitsCount++;\n                _offset = uint(_limit) + 1;\n            }\n        }\n\n        splitArr = new string[](_splitsCount);\n\n        _offset = 0;\n        _splitsCount = 0;\n        while (_offset < _baseBytes.length - 1) {\n\n            int _limit = _indexOf(_base, _value, _offset);\n            if (_limit == - 1) {\n                _limit = int(_baseBytes.length);\n            }\n\n            string memory _tmp = new string(uint(_limit) - _offset);\n            bytes memory _tmpBytes = bytes(_tmp);\n\n            uint j = 0;\n            for (uint i = _offset; i < uint(_limit); i++) {\n                _tmpBytes[j++] = _baseBytes[i];\n            }\n            _offset = uint(_limit) + 1;\n            splitArr[_splitsCount++] = string(_tmpBytes);\n        }\n        return splitArr;\n    }\n\n    /**\n     * Compare To\n     * \n     * Compares the characters of two strings, to ensure that they have an \n     * identical footprint\n     * \n     * @param _base When being used for a data type this is the extended object\n     *               otherwise this is the string base to compare against\n     * @param _value The string the base is being compared to\n     * @return bool Simply notates if the two string have an equivalent\n     */\n    function compareTo(string memory _base, string memory _value)\n        internal\n        pure\n        returns (bool) {\n        bytes memory _baseBytes = bytes(_base);\n        bytes memory _valueBytes = bytes(_value);\n\n        if (_baseBytes.length != _valueBytes.length) {\n            return false;\n        }\n\n        for (uint i = 0; i < _baseBytes.length; i++) {\n            if (_baseBytes[i] != _valueBytes[i]) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    /**\n     * Compare To Ignore Case (High gas cost)\n     * \n     * Compares the characters of two strings, converting them to the same case\n     * where applicable to alphabetic characters to distinguish if the values\n     * match.\n     * \n     * @param _base When being used for a data type this is the extended object\n     *               otherwise this is the string base to compare against\n     * @param _value The string the base is being compared to\n     * @return bool Simply notates if the two string have an equivalent value\n     *              discarding case\n     */\n    function compareToIgnoreCase(string memory _base, string memory _value)\n        internal\n        pure\n        returns (bool) {\n        bytes memory _baseBytes = bytes(_base);\n        bytes memory _valueBytes = bytes(_value);\n\n        if (_baseBytes.length != _valueBytes.length) {\n            return false;\n        }\n\n        for (uint i = 0; i < _baseBytes.length; i++) {\n            if (_baseBytes[i] != _valueBytes[i] &&\n            _upper(_baseBytes[i]) != _upper(_valueBytes[i])) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    /**\n     * Upper\n     * \n     * Converts all the values of a string to their corresponding upper case\n     * value.\n     * \n     * @param _base When being used for a data type this is the extended object\n     *              otherwise this is the string base to convert to upper case\n     * @return string \n     */\n    function upper(string memory _base)\n        internal\n        pure\n        returns (string memory) {\n        bytes memory _baseBytes = bytes(_base);\n        for (uint i = 0; i < _baseBytes.length; i++) {\n            _baseBytes[i] = _upper(_baseBytes[i]);\n        }\n        return string(_baseBytes);\n    }\n\n    /**\n     * Lower\n     * \n     * Converts all the values of a string to their corresponding lower case\n     * value.\n     * \n     * @param _base When being used for a data type this is the extended object\n     *              otherwise this is the string base to convert to lower case\n     * @return string \n     */\n    function lower(string memory _base)\n        internal\n        pure\n        returns (string memory) {\n        bytes memory _baseBytes = bytes(_base);\n        for (uint i = 0; i < _baseBytes.length; i++) {\n            _baseBytes[i] = _lower(_baseBytes[i]);\n        }\n        return string(_baseBytes);\n    }\n\n    /**\n     * Upper\n     * \n     * Convert an alphabetic character to upper case and return the original\n     * value when not alphabetic\n     * \n     * @param _b1 The byte to be converted to upper case\n     * @return bytes1 The converted value if the passed value was alphabetic\n     *                and in a lower case otherwise returns the original value\n     */\n    function _upper(bytes1 _b1)\n        private\n        pure\n        returns (bytes1) {\n\n        if (_b1 >= 0x61 && _b1 <= 0x7A) {\n            return bytes1(uint8(_b1) - 32);\n        }\n\n        return _b1;\n    }\n\n    /**\n     * Lower\n     * \n     * Convert an alphabetic character to lower case and return the original\n     * value when not alphabetic\n     * \n     * @param _b1 The byte to be converted to lower case\n     * @return bytes1 The converted value if the passed value was alphabetic\n     *                and in a upper case otherwise returns the original value\n     */\n    function _lower(bytes1 _b1)\n        private\n        pure\n        returns (bytes1) {\n\n        if (_b1 >= 0x41 && _b1 <= 0x5A) {\n            return bytes1(uint8(_b1) + 32);\n        }\n\n        return _b1;\n    }\n}\n\n/*\n * Hubii Nahmii\n *\n * Compliant with the Hubii Nahmii specification v0.12.\n *\n * Copyright (C) 2017-2018 Hubii AS\n */\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * @title PartnerFund\n * @notice Where partners’ fees are managed\n */\ncontract PartnerFund is Ownable, Beneficiary, TransferControllerManageable {\n    using FungibleBalanceLib for FungibleBalanceLib.Balance;\n    using TxHistoryLib for TxHistoryLib.TxHistory;\n    using SafeMathIntLib for int256;\n    using Strings for string;\n\n    //\n    // Structures\n    // -----------------------------------------------------------------------------------------------------------------\n    struct Partner {\n        bytes32 nameHash;\n\n        uint256 fee;\n        address wallet;\n        uint256 index;\n\n        bool operatorCanUpdate;\n        bool partnerCanUpdate;\n\n        FungibleBalanceLib.Balance active;\n        FungibleBalanceLib.Balance staged;\n\n        TxHistoryLib.TxHistory txHistory;\n        FullBalanceHistory[] fullBalanceHistory;\n    }\n\n    struct FullBalanceHistory {\n        uint256 listIndex;\n        int256 balance;\n        uint256 blockNumber;\n    }\n\n    //\n    // Variables\n    // -----------------------------------------------------------------------------------------------------------------\n    Partner[] private partners;\n\n    mapping(bytes32 => uint256) private _indexByNameHash;\n    mapping(address => uint256) private _indexByWallet;\n\n    //\n    // Events\n    // -----------------------------------------------------------------------------------------------------------------\n    event ReceiveEvent(address from, int256 amount, address currencyCt, uint256 currencyId);\n    event RegisterPartnerByNameEvent(string name, uint256 fee, address wallet);\n    event RegisterPartnerByNameHashEvent(bytes32 nameHash, uint256 fee, address wallet);\n    event SetFeeByIndexEvent(uint256 index, uint256 oldFee, uint256 newFee);\n    event SetFeeByNameEvent(string name, uint256 oldFee, uint256 newFee);\n    event SetFeeByNameHashEvent(bytes32 nameHash, uint256 oldFee, uint256 newFee);\n    event SetFeeByWalletEvent(address wallet, uint256 oldFee, uint256 newFee);\n    event SetPartnerWalletByIndexEvent(uint256 index, address oldWallet, address newWallet);\n    event SetPartnerWalletByNameEvent(string name, address oldWallet, address newWallet);\n    event SetPartnerWalletByNameHashEvent(bytes32 nameHash, address oldWallet, address newWallet);\n    event SetPartnerWalletByWalletEvent(address oldWallet, address newWallet);\n    event StageEvent(address from, int256 amount, address currencyCt, uint256 currencyId);\n    event WithdrawEvent(address to, int256 amount, address currencyCt, uint256 currencyId);\n\n    //\n    // Constructor\n    // -----------------------------------------------------------------------------------------------------------------\n    constructor(address deployer) Ownable(deployer) public {\n    }\n\n    //\n    // Functions\n    // -----------------------------------------------------------------------------------------------------------------\n    /// @notice Fallback function that deposits ethers\n    function() external payable {\n        _receiveEthersTo(\n            indexByWallet(msg.sender) - 1, SafeMathIntLib.toNonZeroInt256(msg.value)\n        );\n    }\n\n    /// @notice Receive ethers to\n    /// @param tag The tag of the concerned partner\n    function receiveEthersTo(address tag, string memory)\n    public\n    payable\n    {\n        _receiveEthersTo(\n            uint256(tag) - 1, SafeMathIntLib.toNonZeroInt256(msg.value)\n        );\n    }\n\n    /// @notice Receive tokens\n    /// @param amount The concerned amount\n    /// @param currencyCt The address of the concerned currency contract (address(0) == ETH)\n    /// @param currencyId The ID of the concerned currency (0 for ETH and ERC20)\n    /// @param standard The standard of token (\"ERC20\", \"ERC721\")\n    function receiveTokens(string memory, int256 amount, address currencyCt,\n        uint256 currencyId, string memory standard)\n    public\n    {\n        _receiveTokensTo(\n            indexByWallet(msg.sender) - 1, amount, currencyCt, currencyId, standard\n        );\n    }\n\n    /// @notice Receive tokens to\n    /// @param tag The tag of the concerned partner\n    /// @param amount The concerned amount\n    /// @param currencyCt The address of the concerned currency contract (address(0) == ETH)\n    /// @param currencyId The ID of the concerned currency (0 for ETH and ERC20)\n    /// @param standard The standard of token (\"ERC20\", \"ERC721\")\n    function receiveTokensTo(address tag, string memory, int256 amount, address currencyCt,\n        uint256 currencyId, string memory standard)\n    public\n    {\n        _receiveTokensTo(\n            uint256(tag) - 1, amount, currencyCt, currencyId, standard\n        );\n    }\n\n    /// @notice Hash name\n    /// @param name The name to be hashed\n    /// @return The hash value\n    function hashName(string memory name)\n    public\n    pure\n    returns (bytes32)\n    {\n        return keccak256(abi.encodePacked(name.upper()));\n    }\n\n    /// @notice Get deposit by partner and deposit indices\n    /// @param partnerIndex The index of the concerned partner\n    /// @param depositIndex The index of the concerned deposit\n    /// return The deposit parameters\n    function depositByIndices(uint256 partnerIndex, uint256 depositIndex)\n    public\n    view\n    returns (int256 balance, uint256 blockNumber, address currencyCt, uint256 currencyId)\n    {\n        // Require partner index is one of registered partner\n        require(0 < partnerIndex && partnerIndex <= partners.length, \"Some error message when require fails [PartnerFund.sol:160]\");\n\n        return _depositByIndices(partnerIndex - 1, depositIndex);\n    }\n\n    /// @notice Get deposit by partner name and deposit indices\n    /// @param name The name of the concerned partner\n    /// @param depositIndex The index of the concerned deposit\n    /// return The deposit parameters\n    function depositByName(string memory name, uint depositIndex)\n    public\n    view\n    returns (int256 balance, uint256 blockNumber, address currencyCt, uint256 currencyId)\n    {\n        // Implicitly require that partner name is registered\n        return _depositByIndices(indexByName(name) - 1, depositIndex);\n    }\n\n    /// @notice Get deposit by partner name hash and deposit indices\n    /// @param nameHash The hashed name of the concerned partner\n    /// @param depositIndex The index of the concerned deposit\n    /// return The deposit parameters\n    function depositByNameHash(bytes32 nameHash, uint depositIndex)\n    public\n    view\n    returns (int256 balance, uint256 blockNumber, address currencyCt, uint256 currencyId)\n    {\n        // Implicitly require that partner name hash is registered\n        return _depositByIndices(indexByNameHash(nameHash) - 1, depositIndex);\n    }\n\n    /// @notice Get deposit by partner wallet and deposit indices\n    /// @param wallet The wallet of the concerned partner\n    /// @param depositIndex The index of the concerned deposit\n    /// return The deposit parameters\n    function depositByWallet(address wallet, uint depositIndex)\n    public\n    view\n    returns (int256 balance, uint256 blockNumber, address currencyCt, uint256 currencyId)\n    {\n        // Implicitly require that partner wallet is registered\n        return _depositByIndices(indexByWallet(wallet) - 1, depositIndex);\n    }\n\n    /// @notice Get deposits count by partner index\n    /// @param index The index of the concerned partner\n    /// return The deposits count\n    function depositsCountByIndex(uint256 index)\n    public\n    view\n    returns (uint256)\n    {\n        // Require partner index is one of registered partner\n        require(0 < index && index <= partners.length, \"Some error message when require fails [PartnerFund.sol:213]\");\n\n        return _depositsCountByIndex(index - 1);\n    }\n\n    /// @notice Get deposits count by partner name\n    /// @param name The name of the concerned partner\n    /// return The deposits count\n    function depositsCountByName(string memory name)\n    public\n    view\n    returns (uint256)\n    {\n        // Implicitly require that partner name is registered\n        return _depositsCountByIndex(indexByName(name) - 1);\n    }\n\n    /// @notice Get deposits count by partner name hash\n    /// @param nameHash The hashed name of the concerned partner\n    /// return The deposits count\n    function depositsCountByNameHash(bytes32 nameHash)\n    public\n    view\n    returns (uint256)\n    {\n        // Implicitly require that partner name hash is registered\n        return _depositsCountByIndex(indexByNameHash(nameHash) - 1);\n    }\n\n    /// @notice Get deposits count by partner wallet\n    /// @param wallet The wallet of the concerned partner\n    /// return The deposits count\n    function depositsCountByWallet(address wallet)\n    public\n    view\n    returns (uint256)\n    {\n        // Implicitly require that partner wallet is registered\n        return _depositsCountByIndex(indexByWallet(wallet) - 1);\n    }\n\n    /// @notice Get active balance by partner index and currency\n    /// @param index The index of the concerned partner\n    /// @param currencyCt The address of the concerned currency contract (address(0) == ETH)\n    /// @param currencyId The ID of the concerned currency (0 for ETH and ERC20)\n    /// return The active balance\n    function activeBalanceByIndex(uint256 index, address currencyCt, uint256 currencyId)\n    public\n    view\n    returns (int256)\n    {\n        // Require partner index is one of registered partner\n        require(0 < index && index <= partners.length, \"Some error message when require fails [PartnerFund.sol:265]\");\n\n        return _activeBalanceByIndex(index - 1, currencyCt, currencyId);\n    }\n\n    /// @notice Get active balance by partner name and currency\n    /// @param name The name of the concerned partner\n    /// @param currencyCt The address of the concerned currency contract (address(0) == ETH)\n    /// @param currencyId The ID of the concerned currency (0 for ETH and ERC20)\n    /// return The active balance\n    function activeBalanceByName(string memory name, address currencyCt, uint256 currencyId)\n    public\n    view\n    returns (int256)\n    {\n        // Implicitly require that partner name is registered\n        return _activeBalanceByIndex(indexByName(name) - 1, currencyCt, currencyId);\n    }\n\n    /// @notice Get active balance by partner name hash and currency\n    /// @param nameHash The hashed name of the concerned partner\n    /// @param currencyCt The address of the concerned currency contract (address(0) == ETH)\n    /// @param currencyId The ID of the concerned currency (0 for ETH and ERC20)\n    /// return The active balance\n    function activeBalanceByNameHash(bytes32 nameHash, address currencyCt, uint256 currencyId)\n    public\n    view\n    returns (int256)\n    {\n        // Implicitly require that partner name hash is registered\n        return _activeBalanceByIndex(indexByNameHash(nameHash) - 1, currencyCt, currencyId);\n    }\n\n    /// @notice Get active balance by partner wallet and currency\n    /// @param wallet The wallet of the concerned partner\n    /// @param currencyCt The address of the concerned currency contract (address(0) == ETH)\n    /// @param currencyId The ID of the concerned currency (0 for ETH and ERC20)\n    /// return The active balance\n    function activeBalanceByWallet(address wallet, address currencyCt, uint256 currencyId)\n    public\n    view\n    returns (int256)\n    {\n        // Implicitly require that partner wallet is registered\n        return _activeBalanceByIndex(indexByWallet(wallet) - 1, currencyCt, currencyId);\n    }\n\n    /// @notice Get staged balance by partner index and currency\n    /// @param index The index of the concerned partner\n    /// @param currencyCt The address of the concerned currency contract (address(0) == ETH)\n    /// @param currencyId The ID of the concerned currency (0 for ETH and ERC20)\n    /// return The staged balance\n    function stagedBalanceByIndex(uint256 index, address currencyCt, uint256 currencyId)\n    public\n    view\n    returns (int256)\n    {\n        // Require partner index is one of registered partner\n        require(0 < index && index <= partners.length, \"Some error message when require fails [PartnerFund.sol:323]\");\n\n        return _stagedBalanceByIndex(index - 1, currencyCt, currencyId);\n    }\n\n    /// @notice Get staged balance by partner name and currency\n    /// @param name The name of the concerned partner\n    /// @param currencyCt The address of the concerned currency contract (address(0) == ETH)\n    /// @param currencyId The ID of the concerned currency (0 for ETH and ERC20)\n    /// return The staged balance\n    function stagedBalanceByName(string memory name, address currencyCt, uint256 currencyId)\n    public\n    view\n    returns (int256)\n    {\n        // Implicitly require that partner name is registered\n        return _stagedBalanceByIndex(indexByName(name) - 1, currencyCt, currencyId);\n    }\n\n    /// @notice Get staged balance by partner name hash and currency\n    /// @param nameHash The hashed name of the concerned partner\n    /// @param currencyCt The address of the concerned currency contract (address(0) == ETH)\n    /// @param currencyId The ID of the concerned currency (0 for ETH and ERC20)\n    /// return The staged balance\n    function stagedBalanceByNameHash(bytes32 nameHash, address currencyCt, uint256 currencyId)\n    public\n    view\n    returns (int256)\n    {\n        // Implicitly require that partner name is registered\n        return _stagedBalanceByIndex(indexByNameHash(nameHash) - 1, currencyCt, currencyId);\n    }\n\n    /// @notice Get staged balance by partner wallet and currency\n    /// @param wallet The wallet of the concerned partner\n    /// @param currencyCt The address of the concerned currency contract (address(0) == ETH)\n    /// @param currencyId The ID of the concerned currency (0 for ETH and ERC20)\n    /// return The staged balance\n    function stagedBalanceByWallet(address wallet, address currencyCt, uint256 currencyId)\n    public\n    view\n    returns (int256)\n    {\n        // Implicitly require that partner wallet is registered\n        return _stagedBalanceByIndex(indexByWallet(wallet) - 1, currencyCt, currencyId);\n    }\n\n    /// @notice Get the number of partners\n    /// @return The number of partners\n    function partnersCount()\n    public\n    view\n    returns (uint256)\n    {\n        return partners.length;\n    }\n\n    /// @notice Register a partner by name\n    /// @param name The name of the concerned partner\n    /// @param fee The partner's fee fraction\n    /// @param wallet The partner's wallet\n    /// @param partnerCanUpdate Indicator of whether partner can update fee and wallet\n    /// @param operatorCanUpdate Indicator of whether operator can update fee and wallet\n    function registerByName(string memory name, uint256 fee, address wallet,\n        bool partnerCanUpdate, bool operatorCanUpdate)\n    public\n    onlyOperator\n    {\n        // Require not empty name string\n        require(bytes(name).length > 0, \"Some error message when require fails [PartnerFund.sol:392]\");\n\n        // Hash name\n        bytes32 nameHash = hashName(name);\n\n        // Register partner\n        _registerPartnerByNameHash(nameHash, fee, wallet, partnerCanUpdate, operatorCanUpdate);\n\n        // Emit event\n        emit RegisterPartnerByNameEvent(name, fee, wallet);\n    }\n\n    /// @notice Register a partner by name hash\n    /// @param nameHash The hashed name of the concerned partner\n    /// @param fee The partner's fee fraction\n    /// @param wallet The partner's wallet\n    /// @param partnerCanUpdate Indicator of whether partner can update fee and wallet\n    /// @param operatorCanUpdate Indicator of whether operator can update fee and wallet\n    function registerByNameHash(bytes32 nameHash, uint256 fee, address wallet,\n        bool partnerCanUpdate, bool operatorCanUpdate)\n    public\n    onlyOperator\n    {\n        // Register partner\n        _registerPartnerByNameHash(nameHash, fee, wallet, partnerCanUpdate, operatorCanUpdate);\n\n        // Emit event\n        emit RegisterPartnerByNameHashEvent(nameHash, fee, wallet);\n    }\n\n    /// @notice Gets the 1-based index of partner by its name\n    /// @dev Reverts if name does not correspond to registered partner\n    /// @return Index of partner by given name\n    function indexByNameHash(bytes32 nameHash)\n    public\n    view\n    returns (uint256)\n    {\n        uint256 index = _indexByNameHash[nameHash];\n        require(0 < index, \"Some error message when require fails [PartnerFund.sol:431]\");\n        return index;\n    }\n\n    /// @notice Gets the 1-based index of partner by its name\n    /// @dev Reverts if name does not correspond to registered partner\n    /// @return Index of partner by given name\n    function indexByName(string memory name)\n    public\n    view\n    returns (uint256)\n    {\n        return indexByNameHash(hashName(name));\n    }\n\n    /// @notice Gets the 1-based index of partner by its wallet\n    /// @dev Reverts if wallet does not correspond to registered partner\n    /// @return Index of partner by given wallet\n    function indexByWallet(address wallet)\n    public\n    view\n    returns (uint256)\n    {\n        uint256 index = _indexByWallet[wallet];\n        require(0 < index, \"Some error message when require fails [PartnerFund.sol:455]\");\n        return index;\n    }\n\n    /// @notice Gauge whether a partner by the given name is registered\n    /// @param name The name of the concerned partner\n    /// @return true if partner is registered, else false\n    function isRegisteredByName(string memory name)\n    public\n    view\n    returns (bool)\n    {\n        return (0 < _indexByNameHash[hashName(name)]);\n    }\n\n    /// @notice Gauge whether a partner by the given name hash is registered\n    /// @param nameHash The hashed name of the concerned partner\n    /// @return true if partner is registered, else false\n    function isRegisteredByNameHash(bytes32 nameHash)\n    public\n    view\n    returns (bool)\n    {\n        return (0 < _indexByNameHash[nameHash]);\n    }\n\n    /// @notice Gauge whether a partner by the given wallet is registered\n    /// @param wallet The wallet of the concerned partner\n    /// @return true if partner is registered, else false\n    function isRegisteredByWallet(address wallet)\n    public\n    view\n    returns (bool)\n    {\n        return (0 < _indexByWallet[wallet]);\n    }\n\n    /// @notice Get the partner fee fraction by the given partner index\n    /// @param index The index of the concerned partner\n    /// @return The fee fraction\n    function feeByIndex(uint256 index)\n    public\n    view\n    returns (uint256)\n    {\n        // Require partner index is one of registered partner\n        require(0 < index && index <= partners.length, \"Some error message when require fails [PartnerFund.sol:501]\");\n\n        return _partnerFeeByIndex(index - 1);\n    }\n\n    /// @notice Get the partner fee fraction by the given partner name\n    /// @param name The name of the concerned partner\n    /// @return The fee fraction\n    function feeByName(string memory name)\n    public\n    view\n    returns (uint256)\n    {\n        // Get fee, implicitly requiring that partner name is registered\n        return _partnerFeeByIndex(indexByName(name) - 1);\n    }\n\n    /// @notice Get the partner fee fraction by the given partner name hash\n    /// @param nameHash The hashed name of the concerned partner\n    /// @return The fee fraction\n    function feeByNameHash(bytes32 nameHash)\n    public\n    view\n    returns (uint256)\n    {\n        // Get fee, implicitly requiring that partner name hash is registered\n        return _partnerFeeByIndex(indexByNameHash(nameHash) - 1);\n    }\n\n    /// @notice Get the partner fee fraction by the given partner wallet\n    /// @param wallet The wallet of the concerned partner\n    /// @return The fee fraction\n    function feeByWallet(address wallet)\n    public\n    view\n    returns (uint256)\n    {\n        // Get fee, implicitly requiring that partner wallet is registered\n        return _partnerFeeByIndex(indexByWallet(wallet) - 1);\n    }\n\n    /// @notice Set the partner fee fraction by the given partner index\n    /// @param index The index of the concerned partner\n    /// @param newFee The partner's fee fraction\n    function setFeeByIndex(uint256 index, uint256 newFee)\n    public\n    {\n        // Require partner index is one of registered partner\n        require(0 < index && index <= partners.length, \"Some error message when require fails [PartnerFund.sol:549]\");\n\n        // Update fee\n        uint256 oldFee = _setPartnerFeeByIndex(index - 1, newFee);\n\n        // Emit event\n        emit SetFeeByIndexEvent(index, oldFee, newFee);\n    }\n\n    /// @notice Set the partner fee fraction by the given partner name\n    /// @param name The name of the concerned partner\n    /// @param newFee The partner's fee fraction\n    function setFeeByName(string memory name, uint256 newFee)\n    public\n    {\n        // Update fee, implicitly requiring that partner name is registered\n        uint256 oldFee = _setPartnerFeeByIndex(indexByName(name) - 1, newFee);\n\n        // Emit event\n        emit SetFeeByNameEvent(name, oldFee, newFee);\n    }\n\n    /// @notice Set the partner fee fraction by the given partner name hash\n    /// @param nameHash The hashed name of the concerned partner\n    /// @param newFee The partner's fee fraction\n    function setFeeByNameHash(bytes32 nameHash, uint256 newFee)\n    public\n    {\n        // Update fee, implicitly requiring that partner name hash is registered\n        uint256 oldFee = _setPartnerFeeByIndex(indexByNameHash(nameHash) - 1, newFee);\n\n        // Emit event\n        emit SetFeeByNameHashEvent(nameHash, oldFee, newFee);\n    }\n\n    /// @notice Set the partner fee fraction by the given partner wallet\n    /// @param wallet The wallet of the concerned partner\n    /// @param newFee The partner's fee fraction\n    function setFeeByWallet(address wallet, uint256 newFee)\n    public\n    {\n        // Update fee, implicitly requiring that partner wallet is registered\n        uint256 oldFee = _setPartnerFeeByIndex(indexByWallet(wallet) - 1, newFee);\n\n        // Emit event\n        emit SetFeeByWalletEvent(wallet, oldFee, newFee);\n    }\n\n    /// @notice Get the partner wallet by the given partner index\n    /// @param index The index of the concerned partner\n    /// @return The wallet\n    function walletByIndex(uint256 index)\n    public\n    view\n    returns (address)\n    {\n        // Require partner index is one of registered partner\n        require(0 < index && index <= partners.length, \"Some error message when require fails [PartnerFund.sol:606]\");\n\n        return partners[index - 1].wallet;\n    }\n\n    /// @notice Get the partner wallet by the given partner name\n    /// @param name The name of the concerned partner\n    /// @return The wallet\n    function walletByName(string memory name)\n    public\n    view\n    returns (address)\n    {\n        // Get wallet, implicitly requiring that partner name is registered\n        return partners[indexByName(name) - 1].wallet;\n    }\n\n    /// @notice Get the partner wallet by the given partner name hash\n    /// @param nameHash The hashed name of the concerned partner\n    /// @return The wallet\n    function walletByNameHash(bytes32 nameHash)\n    public\n    view\n    returns (address)\n    {\n        // Get wallet, implicitly requiring that partner name hash is registered\n        return partners[indexByNameHash(nameHash) - 1].wallet;\n    }\n\n    /// @notice Set the partner wallet by the given partner index\n    /// @param index The index of the concerned partner\n    /// @return newWallet The partner's wallet\n    function setWalletByIndex(uint256 index, address newWallet)\n    public\n    {\n        // Require partner index is one of registered partner\n        require(0 < index && index <= partners.length, \"Some error message when require fails [PartnerFund.sol:642]\");\n\n        // Update wallet\n        address oldWallet = _setPartnerWalletByIndex(index - 1, newWallet);\n\n        // Emit event\n        emit SetPartnerWalletByIndexEvent(index, oldWallet, newWallet);\n    }\n\n    /// @notice Set the partner wallet by the given partner name\n    /// @param name The name of the concerned partner\n    /// @return newWallet The partner's wallet\n    function setWalletByName(string memory name, address newWallet)\n    public\n    {\n        // Update wallet\n        address oldWallet = _setPartnerWalletByIndex(indexByName(name) - 1, newWallet);\n\n        // Emit event\n        emit SetPartnerWalletByNameEvent(name, oldWallet, newWallet);\n    }\n\n    /// @notice Set the partner wallet by the given partner name hash\n    /// @param nameHash The hashed name of the concerned partner\n    /// @return newWallet The partner's wallet\n    function setWalletByNameHash(bytes32 nameHash, address newWallet)\n    public\n    {\n        // Update wallet\n        address oldWallet = _setPartnerWalletByIndex(indexByNameHash(nameHash) - 1, newWallet);\n\n        // Emit event\n        emit SetPartnerWalletByNameHashEvent(nameHash, oldWallet, newWallet);\n    }\n\n    /// @notice Set the new partner wallet by the given old partner wallet\n    /// @param oldWallet The old wallet of the concerned partner\n    /// @return newWallet The partner's new wallet\n    function setWalletByWallet(address oldWallet, address newWallet)\n    public\n    {\n        // Update wallet\n        _setPartnerWalletByIndex(indexByWallet(oldWallet) - 1, newWallet);\n\n        // Emit event\n        emit SetPartnerWalletByWalletEvent(oldWallet, newWallet);\n    }\n\n    /// @notice Stage the amount for subsequent withdrawal\n    /// @param amount The concerned amount to stage\n    /// @param currencyCt The address of the concerned currency contract (address(0) == ETH)\n    /// @param currencyId The ID of the concerned currency (0 for ETH and ERC20)\n    function stage(int256 amount, address currencyCt, uint256 currencyId)\n    public\n    {\n        // Get index, implicitly requiring that msg.sender is wallet of registered partner\n        uint256 index = indexByWallet(msg.sender);\n\n        // Require positive amount\n        require(amount.isPositiveInt256(), \"Some error message when require fails [PartnerFund.sol:701]\");\n\n        // Clamp amount to move\n        amount = amount.clampMax(partners[index - 1].active.get(currencyCt, currencyId));\n\n        partners[index - 1].active.sub(amount, currencyCt, currencyId);\n        partners[index - 1].staged.add(amount, currencyCt, currencyId);\n\n        partners[index - 1].txHistory.addDeposit(amount, currencyCt, currencyId);\n\n        // Add to full deposit history\n        partners[index - 1].fullBalanceHistory.push(\n            FullBalanceHistory(\n                partners[index - 1].txHistory.depositsCount() - 1,\n                partners[index - 1].active.get(currencyCt, currencyId),\n                block.number\n            )\n        );\n\n        // Emit event\n        emit StageEvent(msg.sender, amount, currencyCt, currencyId);\n    }\n\n    /// @notice Withdraw the given amount from staged balance\n    /// @param amount The concerned amount to withdraw\n    /// @param currencyCt The address of the concerned currency contract (address(0) == ETH)\n    /// @param currencyId The ID of the concerned currency (0 for ETH and ERC20)\n    /// @param standard The standard of the token (\"\" for default registered, \"ERC20\", \"ERC721\")\n    function withdraw(int256 amount, address currencyCt, uint256 currencyId, string memory standard)\n    public\n    {\n        // Get index, implicitly requiring that msg.sender is wallet of registered partner\n        uint256 index = indexByWallet(msg.sender);\n\n        // Require positive amount\n        require(amount.isPositiveInt256(), \"Some error message when require fails [PartnerFund.sol:736]\");\n\n        // Clamp amount to move\n        amount = amount.clampMax(partners[index - 1].staged.get(currencyCt, currencyId));\n\n        partners[index - 1].staged.sub(amount, currencyCt, currencyId);\n\n        // Execute transfer\n        if (address(0) == currencyCt && 0 == currencyId)\n            msg.sender.transfer(uint256(amount));\n\n        else {\n            TransferController controller = transferController(currencyCt, standard);\n            (bool success,) = address(controller).delegatecall(\n                abi.encodeWithSelector(\n                    controller.getDispatchSignature(), address(this), msg.sender, uint256(amount), currencyCt, currencyId\n                )\n            );\n            require(success, \"Some error message when require fails [PartnerFund.sol:754]\");\n        }\n\n        // Emit event\n        emit WithdrawEvent(msg.sender, amount, currencyCt, currencyId);\n    }\n\n    //\n    // Private functions\n    // -----------------------------------------------------------------------------------------------------------------\n    /// @dev index is 0-based\n    function _receiveEthersTo(uint256 index, int256 amount)\n    private\n    {\n        // Require that index is within bounds\n        require(index < partners.length, \"Some error message when require fails [PartnerFund.sol:769]\");\n\n        // Add to active\n        partners[index].active.add(amount, address(0), 0);\n        partners[index].txHistory.addDeposit(amount, address(0), 0);\n\n        // Add to full deposit history\n        partners[index].fullBalanceHistory.push(\n            FullBalanceHistory(\n                partners[index].txHistory.depositsCount() - 1,\n                partners[index].active.get(address(0), 0),\n                block.number\n            )\n        );\n\n        // Emit event\n        emit ReceiveEvent(msg.sender, amount, address(0), 0);\n    }\n\n    /// @dev index is 0-based\n    function _receiveTokensTo(uint256 index, int256 amount, address currencyCt,\n        uint256 currencyId, string memory standard)\n    private\n    {\n        // Require that index is within bounds\n        require(index < partners.length, \"Some error message when require fails [PartnerFund.sol:794]\");\n\n        require(amount.isNonZeroPositiveInt256(), \"Some error message when require fails [PartnerFund.sol:796]\");\n\n        // Execute transfer\n        TransferController controller = transferController(currencyCt, standard);\n        (bool success,) = address(controller).delegatecall(\n            abi.encodeWithSelector(\n                controller.getReceiveSignature(), msg.sender, this, uint256(amount), currencyCt, currencyId\n            )\n        );\n        require(success, \"Some error message when require fails [PartnerFund.sol:805]\");\n\n        // Add to active\n        partners[index].active.add(amount, currencyCt, currencyId);\n        partners[index].txHistory.addDeposit(amount, currencyCt, currencyId);\n\n        // Add to full deposit history\n        partners[index].fullBalanceHistory.push(\n            FullBalanceHistory(\n                partners[index].txHistory.depositsCount() - 1,\n                partners[index].active.get(currencyCt, currencyId),\n                block.number\n            )\n        );\n\n        // Emit event\n        emit ReceiveEvent(msg.sender, amount, currencyCt, currencyId);\n    }\n\n    /// @dev partnerIndex is 0-based\n    function _depositByIndices(uint256 partnerIndex, uint256 depositIndex)\n    private\n    view\n    returns (int256 balance, uint256 blockNumber, address currencyCt, uint256 currencyId)\n    {\n        require(depositIndex < partners[partnerIndex].fullBalanceHistory.length, \"Some error message when require fails [PartnerFund.sol:830]\");\n\n        FullBalanceHistory storage entry = partners[partnerIndex].fullBalanceHistory[depositIndex];\n        (,, currencyCt, currencyId) = partners[partnerIndex].txHistory.deposit(entry.listIndex);\n\n        balance = entry.balance;\n        blockNumber = entry.blockNumber;\n    }\n\n    /// @dev index is 0-based\n    function _depositsCountByIndex(uint256 index)\n    private\n    view\n    returns (uint256)\n    {\n        return partners[index].fullBalanceHistory.length;\n    }\n\n    /// @dev index is 0-based\n    function _activeBalanceByIndex(uint256 index, address currencyCt, uint256 currencyId)\n    private\n    view\n    returns (int256)\n    {\n        return partners[index].active.get(currencyCt, currencyId);\n    }\n\n    /// @dev index is 0-based\n    function _stagedBalanceByIndex(uint256 index, address currencyCt, uint256 currencyId)\n    private\n    view\n    returns (int256)\n    {\n        return partners[index].staged.get(currencyCt, currencyId);\n    }\n\n    function _registerPartnerByNameHash(bytes32 nameHash, uint256 fee, address wallet,\n        bool partnerCanUpdate, bool operatorCanUpdate)\n    private\n    {\n        // Require that the name is not previously registered\n        require(0 == _indexByNameHash[nameHash], \"Some error message when require fails [PartnerFund.sol:871]\");\n\n        // Require possibility to update\n        require(partnerCanUpdate || operatorCanUpdate, \"Some error message when require fails [PartnerFund.sol:874]\");\n\n        // Add new partner\n        partners.length++;\n\n        // Reference by 1-based index\n        uint256 index = partners.length;\n\n        // Update partner map\n        partners[index - 1].nameHash = nameHash;\n        partners[index - 1].fee = fee;\n        partners[index - 1].wallet = wallet;\n        partners[index - 1].partnerCanUpdate = partnerCanUpdate;\n        partners[index - 1].operatorCanUpdate = operatorCanUpdate;\n        partners[index - 1].index = index;\n\n        // Update name hash to index map\n        _indexByNameHash[nameHash] = index;\n\n        // Update wallet to index map\n        _indexByWallet[wallet] = index;\n    }\n\n    /// @dev index is 0-based\n    function _setPartnerFeeByIndex(uint256 index, uint256 fee)\n    private\n    returns (uint256)\n    {\n        uint256 oldFee = partners[index].fee;\n\n        // If operator tries to change verify that operator has access\n        if (isOperator())\n            require(partners[index].operatorCanUpdate, \"Some error message when require fails [PartnerFund.sol:906]\");\n\n        else {\n            // Require that msg.sender is partner\n            require(msg.sender == partners[index].wallet, \"Some error message when require fails [PartnerFund.sol:910]\");\n\n            // If partner tries to change verify that partner has access\n            require(partners[index].partnerCanUpdate, \"Some error message when require fails [PartnerFund.sol:913]\");\n        }\n\n        // Update stored fee\n        partners[index].fee = fee;\n\n        return oldFee;\n    }\n\n    // @dev index is 0-based\n    function _setPartnerWalletByIndex(uint256 index, address newWallet)\n    private\n    returns (address)\n    {\n        address oldWallet = partners[index].wallet;\n\n        // If address has not been set operator is the only allowed to change it\n        if (oldWallet == address(0))\n            require(isOperator(), \"Some error message when require fails [PartnerFund.sol:931]\");\n\n        // Else if operator tries to change verify that operator has access\n        else if (isOperator())\n            require(partners[index].operatorCanUpdate, \"Some error message when require fails [PartnerFund.sol:935]\");\n\n        else {\n            // Require that msg.sender is partner\n            require(msg.sender == oldWallet, \"Some error message when require fails [PartnerFund.sol:939]\");\n\n            // If partner tries to change verify that partner has access\n            require(partners[index].partnerCanUpdate, \"Some error message when require fails [PartnerFund.sol:942]\");\n\n            // Require that new wallet is not zero-address if it can not be changed by operator\n            require(partners[index].operatorCanUpdate || newWallet != address(0), \"Some error message when require fails [PartnerFund.sol:945]\");\n        }\n\n        // Update stored wallet\n        partners[index].wallet = newWallet;\n\n        // Update address to tag map\n        if (oldWallet != address(0))\n            _indexByWallet[oldWallet] = 0;\n        if (newWallet != address(0))\n            _indexByWallet[newWallet] = index;\n\n        return oldWallet;\n    }\n\n    // @dev index is 0-based\n    function _partnerFeeByIndex(uint256 index)\n    private\n    view\n    returns (uint256)\n    {\n        return partners[index].fee;\n    }\n}\n\n/*\n * Hubii Nahmii\n *\n * Compliant with the Hubii Nahmii specification v0.12.\n *\n * Copyright (C) 2017-2018 Hubii AS\n */\n\n\n\n\n\n/**\n * @title     NahmiiTypesLib\n * @dev       Data types of general nahmii character\n */\nlibrary NahmiiTypesLib {\n    //\n    // Enums\n    // -----------------------------------------------------------------------------------------------------------------\n    enum ChallengePhase {Dispute, Closed}\n\n    //\n    // Structures\n    // -----------------------------------------------------------------------------------------------------------------\n    struct OriginFigure {\n        uint256 originId;\n        MonetaryTypesLib.Figure figure;\n    }\n\n    struct IntendedConjugateCurrency {\n        MonetaryTypesLib.Currency intended;\n        MonetaryTypesLib.Currency conjugate;\n    }\n\n    struct SingleFigureTotalOriginFigures {\n        MonetaryTypesLib.Figure single;\n        OriginFigure[] total;\n    }\n\n    struct TotalOriginFigures {\n        OriginFigure[] total;\n    }\n\n    struct CurrentPreviousInt256 {\n        int256 current;\n        int256 previous;\n    }\n\n    struct SingleTotalInt256 {\n        int256 single;\n        int256 total;\n    }\n\n    struct IntendedConjugateCurrentPreviousInt256 {\n        CurrentPreviousInt256 intended;\n        CurrentPreviousInt256 conjugate;\n    }\n\n    struct IntendedConjugateSingleTotalInt256 {\n        SingleTotalInt256 intended;\n        SingleTotalInt256 conjugate;\n    }\n\n    struct WalletOperatorHashes {\n        bytes32 wallet;\n        bytes32 operator;\n    }\n\n    struct Signature {\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n    }\n\n    struct Seal {\n        bytes32 hash;\n        Signature signature;\n    }\n\n    struct WalletOperatorSeal {\n        Seal wallet;\n        Seal operator;\n    }\n}\n\n/*\n * Hubii Nahmii\n *\n * Compliant with the Hubii Nahmii specification v0.12.\n *\n * Copyright (C) 2017-2018 Hubii AS\n */\n\n\n\n\n/**\n * @title     DriipSettlementTypesLib\n * @dev       Types for driip settlements\n */\nlibrary DriipSettlementTypesLib {\n    //\n    // Structures\n    // -----------------------------------------------------------------------------------------------------------------\n    enum SettlementRole {Origin, Target}\n\n    struct SettlementParty {\n        uint256 nonce;\n        address wallet;\n        bool done;\n        uint256 doneBlockNumber;\n    }\n\n    struct Settlement {\n        string settledKind;\n        bytes32 settledHash;\n        SettlementParty origin;\n        SettlementParty target;\n    }\n}\n\n/*\n * Hubii Nahmii\n *\n * Compliant with the Hubii Nahmii specification v0.12.\n *\n * Copyright (C) 2017-2018 Hubii AS\n */\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * @title DriipSettlementState\n * @notice Where driip settlement state is managed\n */\ncontract DriipSettlementState is Ownable, Servable, CommunityVotable {\n    using SafeMathIntLib for int256;\n    using SafeMathUintLib for uint256;\n\n    //\n    // Constants\n    // -----------------------------------------------------------------------------------------------------------------\n    string constant public INIT_SETTLEMENT_ACTION = \"init_settlement\";\n    string constant public SET_SETTLEMENT_ROLE_DONE_ACTION = \"set_settlement_role_done\";\n    string constant public SET_MAX_NONCE_ACTION = \"set_max_nonce\";\n    string constant public SET_FEE_TOTAL_ACTION = \"set_fee_total\";\n\n    //\n    // Variables\n    // -----------------------------------------------------------------------------------------------------------------\n    uint256 public maxDriipNonce;\n\n    DriipSettlementTypesLib.Settlement[] public settlements;\n    mapping(address => uint256[]) public walletSettlementIndices;\n    mapping(address => mapping(uint256 => uint256)) public walletNonceSettlementIndex;\n    mapping(address => mapping(address => mapping(uint256 => uint256))) public walletCurrencyMaxNonce;\n\n    mapping(address => mapping(address => mapping(address => mapping(address => mapping(uint256 => MonetaryTypesLib.NoncedAmount))))) public totalFeesMap;\n\n    bool public upgradesFrozen;\n\n    //\n    // Events\n    // -----------------------------------------------------------------------------------------------------------------\n    event InitSettlementEvent(DriipSettlementTypesLib.Settlement settlement);\n    event CompleteSettlementPartyEvent(address wallet, uint256 nonce, DriipSettlementTypesLib.SettlementRole settlementRole,\n        bool done, uint256 doneBlockNumber);\n    event SetMaxNonceByWalletAndCurrencyEvent(address wallet, MonetaryTypesLib.Currency currency,\n        uint256 maxNonce);\n    event SetMaxDriipNonceEvent(uint256 maxDriipNonce);\n    event UpdateMaxDriipNonceFromCommunityVoteEvent(uint256 maxDriipNonce);\n    event SetTotalFeeEvent(address wallet, Beneficiary beneficiary, address destination,\n        MonetaryTypesLib.Currency currency, MonetaryTypesLib.NoncedAmount totalFee);\n    event FreezeUpgradesEvent();\n    event UpgradeSettlementEvent(DriipSettlementTypesLib.Settlement settlement);\n\n    //\n    // Constructor\n    // -----------------------------------------------------------------------------------------------------------------\n    constructor(address deployer) Ownable(deployer) public {\n    }\n\n    //\n    // Functions\n    // -----------------------------------------------------------------------------------------------------------------\n    /// @notice Get the count of settlements\n    function settlementsCount()\n    public\n    view\n    returns (uint256)\n    {\n        return settlements.length;\n    }\n\n    /// @notice Get the count of settlements for given wallet\n    /// @param wallet The address for which to return settlement count\n    /// @return count of settlements for the provided wallet\n    function settlementsCountByWallet(address wallet)\n    public\n    view\n    returns (uint256)\n    {\n        return walletSettlementIndices[wallet].length;\n    }\n\n    /// @notice Get settlement of given wallet and index\n    /// @param wallet The address for which to return settlement\n    /// @param index The wallet's settlement index\n    /// @return settlement for the provided wallet and index\n    function settlementByWalletAndIndex(address wallet, uint256 index)\n    public\n    view\n    returns (DriipSettlementTypesLib.Settlement memory)\n    {\n        require(walletSettlementIndices[wallet].length > index, \"Index out of bounds [DriipSettlementState.sol:107]\");\n        return settlements[walletSettlementIndices[wallet][index] - 1];\n    }\n\n    /// @notice Get settlement of given wallet and wallet nonce\n    /// @param wallet The address for which to return settlement\n    /// @param nonce The wallet's nonce\n    /// @return settlement for the provided wallet and index\n    function settlementByWalletAndNonce(address wallet, uint256 nonce)\n    public\n    view\n    returns (DriipSettlementTypesLib.Settlement memory)\n    {\n        require(0 != walletNonceSettlementIndex[wallet][nonce], \"No settlement found for wallet and nonce [DriipSettlementState.sol:120]\");\n        return settlements[walletNonceSettlementIndex[wallet][nonce] - 1];\n    }\n\n    /// @notice Initialize settlement, i.e. create one if no such settlement exists\n    /// for the double pair of wallets and nonces\n    /// @param settledKind The kind of driip of the settlement\n    /// @param settledHash The hash of driip of the settlement\n    /// @param originWallet The address of the origin wallet\n    /// @param originNonce The wallet nonce of the origin wallet\n    /// @param targetWallet The address of the target wallet\n    /// @param targetNonce The wallet nonce of the target wallet\n    function initSettlement(string memory settledKind, bytes32 settledHash, address originWallet,\n        uint256 originNonce, address targetWallet, uint256 targetNonce)\n    public\n    onlyEnabledServiceAction(INIT_SETTLEMENT_ACTION)\n    {\n        if (\n            0 == walletNonceSettlementIndex[originWallet][originNonce] &&\n            0 == walletNonceSettlementIndex[targetWallet][targetNonce]\n        ) {\n            // Create new settlement\n            settlements.length++;\n\n            // Get the 0-based index\n            uint256 index = settlements.length - 1;\n\n            // Update settlement\n            settlements[index].settledKind = settledKind;\n            settlements[index].settledHash = settledHash;\n            settlements[index].origin.nonce = originNonce;\n            settlements[index].origin.wallet = originWallet;\n            settlements[index].target.nonce = targetNonce;\n            settlements[index].target.wallet = targetWallet;\n\n            // Emit event\n            emit InitSettlementEvent(settlements[index]);\n\n            // Store 1-based index value\n            index++;\n            walletSettlementIndices[originWallet].push(index);\n            walletSettlementIndices[targetWallet].push(index);\n            walletNonceSettlementIndex[originWallet][originNonce] = index;\n            walletNonceSettlementIndex[targetWallet][targetNonce] = index;\n        }\n    }\n\n    /// @notice Set the done of the given settlement role in the given settlement\n    /// @param wallet The address of the concerned wallet\n    /// @param nonce The nonce of the concerned wallet\n    /// @param settlementRole The settlement role\n    /// @param done The done flag\n    function completeSettlementParty(address wallet, uint256 nonce,\n        DriipSettlementTypesLib.SettlementRole settlementRole, bool done)\n    public\n    onlyEnabledServiceAction(SET_SETTLEMENT_ROLE_DONE_ACTION)\n    {\n        // Get the 1-based index of the settlement\n        uint256 index = walletNonceSettlementIndex[wallet][nonce];\n\n        // Require the existence of settlement\n        require(0 != index, \"No settlement found for wallet and nonce [DriipSettlementState.sol:181]\");\n\n        // Get the settlement party\n        DriipSettlementTypesLib.SettlementParty storage party =\n        DriipSettlementTypesLib.SettlementRole.Origin == settlementRole ?\n        settlements[index - 1].origin :\n        settlements[index - 1].target;\n\n        // Update party done and done block number properties\n        party.done = done;\n        party.doneBlockNumber = done ? block.number : 0;\n\n        // Emit event\n        emit CompleteSettlementPartyEvent(wallet, nonce, settlementRole, done, party.doneBlockNumber);\n    }\n\n    /// @notice Gauge whether the settlement is done wrt the given wallet and nonce\n    /// @param wallet The address of the concerned wallet\n    /// @param nonce The nonce of the concerned wallet\n    /// @return True if settlement is done for role, else false\n    function isSettlementPartyDone(address wallet, uint256 nonce)\n    public\n    view\n    returns (bool)\n    {\n        // Get the 1-based index of the settlement\n        uint256 index = walletNonceSettlementIndex[wallet][nonce];\n\n        // Return false if settlement does not exist\n        if (0 == index)\n            return false;\n\n        // Return done\n        return (\n        wallet == settlements[index - 1].origin.wallet ?\n        settlements[index - 1].origin.done :\n        settlements[index - 1].target.done\n        );\n    }\n\n    /// @notice Gauge whether the settlement is done wrt the given wallet, nonce\n    /// and settlement role\n    /// @param wallet The address of the concerned wallet\n    /// @param nonce The nonce of the concerned wallet\n    /// @param settlementRole The settlement role\n    /// @return True if settlement is done for role, else false\n    function isSettlementPartyDone(address wallet, uint256 nonce,\n        DriipSettlementTypesLib.SettlementRole settlementRole)\n    public\n    view\n    returns (bool)\n    {\n        // Get the 1-based index of the settlement\n        uint256 index = walletNonceSettlementIndex[wallet][nonce];\n\n        // Return false if settlement does not exist\n        if (0 == index)\n            return false;\n\n        // Get the settlement party\n        DriipSettlementTypesLib.SettlementParty storage settlementParty =\n        DriipSettlementTypesLib.SettlementRole.Origin == settlementRole ?\n        settlements[index - 1].origin : settlements[index - 1].target;\n\n        // Require that wallet is party of the right role\n        require(wallet == settlementParty.wallet, \"Wallet has wrong settlement role [DriipSettlementState.sol:246]\");\n\n        // Return done\n        return settlementParty.done;\n    }\n\n    /// @notice Get the done block number of the settlement party with the given wallet and nonce\n    /// @param wallet The address of the concerned wallet\n    /// @param nonce The nonce of the concerned wallet\n    /// @return The done block number of the settlement wrt the given settlement role\n    function settlementPartyDoneBlockNumber(address wallet, uint256 nonce)\n    public\n    view\n    returns (uint256)\n    {\n        // Get the 1-based index of the settlement\n        uint256 index = walletNonceSettlementIndex[wallet][nonce];\n\n        // Require the existence of settlement\n        require(0 != index, \"No settlement found for wallet and nonce [DriipSettlementState.sol:265]\");\n\n        // Return done block number\n        return (\n        wallet == settlements[index - 1].origin.wallet ?\n        settlements[index - 1].origin.doneBlockNumber :\n        settlements[index - 1].target.doneBlockNumber\n        );\n    }\n\n    /// @notice Get the done block number of the settlement party with the given wallet, nonce and settlement role\n    /// @param wallet The address of the concerned wallet\n    /// @param nonce The nonce of the concerned wallet\n    /// @param settlementRole The settlement role\n    /// @return The done block number of the settlement wrt the given settlement role\n    function settlementPartyDoneBlockNumber(address wallet, uint256 nonce,\n        DriipSettlementTypesLib.SettlementRole settlementRole)\n    public\n    view\n    returns (uint256)\n    {\n        // Get the 1-based index of the settlement\n        uint256 index = walletNonceSettlementIndex[wallet][nonce];\n\n        // Require the existence of settlement\n        require(0 != index, \"No settlement found for wallet and nonce [DriipSettlementState.sol:290]\");\n\n        // Get the settlement party\n        DriipSettlementTypesLib.SettlementParty storage settlementParty =\n        DriipSettlementTypesLib.SettlementRole.Origin == settlementRole ?\n        settlements[index - 1].origin : settlements[index - 1].target;\n\n        // Require that wallet is party of the right role\n        require(wallet == settlementParty.wallet, \"Wallet has wrong settlement role [DriipSettlementState.sol:298]\");\n\n        // Return done block number\n        return settlementParty.doneBlockNumber;\n    }\n\n    /// @notice Set the max (driip) nonce\n    /// @param _maxDriipNonce The max nonce\n    function setMaxDriipNonce(uint256 _maxDriipNonce)\n    public\n    onlyEnabledServiceAction(SET_MAX_NONCE_ACTION)\n    {\n        maxDriipNonce = _maxDriipNonce;\n\n        // Emit event\n        emit SetMaxDriipNonceEvent(maxDriipNonce);\n    }\n\n    /// @notice Update the max driip nonce property from CommunityVote contract\n    function updateMaxDriipNonceFromCommunityVote()\n    public\n    {\n        uint256 _maxDriipNonce = communityVote.getMaxDriipNonce();\n        if (0 == _maxDriipNonce)\n            return;\n\n        maxDriipNonce = _maxDriipNonce;\n\n        // Emit event\n        emit UpdateMaxDriipNonceFromCommunityVoteEvent(maxDriipNonce);\n    }\n\n    /// @notice Get the max nonce of the given wallet and currency\n    /// @param wallet The address of the concerned wallet\n    /// @param currency The concerned currency\n    /// @return The max nonce\n    function maxNonceByWalletAndCurrency(address wallet, MonetaryTypesLib.Currency memory currency)\n    public\n    view\n    returns (uint256)\n    {\n        return walletCurrencyMaxNonce[wallet][currency.ct][currency.id];\n    }\n\n    /// @notice Set the max nonce of the given wallet and currency\n    /// @param wallet The address of the concerned wallet\n    /// @param currency The concerned currency\n    /// @param maxNonce The max nonce\n    function setMaxNonceByWalletAndCurrency(address wallet, MonetaryTypesLib.Currency memory currency,\n        uint256 maxNonce)\n    public\n    onlyEnabledServiceAction(SET_MAX_NONCE_ACTION)\n    {\n        // Update max nonce value\n        walletCurrencyMaxNonce[wallet][currency.ct][currency.id] = maxNonce;\n\n        // Emit event\n        emit SetMaxNonceByWalletAndCurrencyEvent(wallet, currency, maxNonce);\n    }\n\n    /// @notice Get the total fee payed by the given wallet to the given beneficiary and destination\n    /// in the given currency\n    /// @param wallet The address of the concerned wallet\n    /// @param beneficiary The concerned beneficiary\n    /// @param destination The concerned destination\n    /// @param currency The concerned currency\n    /// @return The total fee\n    function totalFee(address wallet, Beneficiary beneficiary, address destination,\n        MonetaryTypesLib.Currency memory currency)\n    public\n    view\n    returns (MonetaryTypesLib.NoncedAmount memory)\n    {\n        return totalFeesMap[wallet][address(beneficiary)][destination][currency.ct][currency.id];\n    }\n\n    /// @notice Set the total fee payed by the given wallet to the given beneficiary and destination\n    /// in the given currency\n    /// @param wallet The address of the concerned wallet\n    /// @param beneficiary The concerned beneficiary\n    /// @param destination The concerned destination\n    /// @param _totalFee The total fee\n    function setTotalFee(address wallet, Beneficiary beneficiary, address destination,\n        MonetaryTypesLib.Currency memory currency, MonetaryTypesLib.NoncedAmount memory _totalFee)\n    public\n    onlyEnabledServiceAction(SET_FEE_TOTAL_ACTION)\n    {\n        // Update total fees value\n        totalFeesMap[wallet][address(beneficiary)][destination][currency.ct][currency.id] = _totalFee;\n\n        // Emit event\n        emit SetTotalFeeEvent(wallet, beneficiary, destination, currency, _totalFee);\n    }\n\n    /// @notice Freeze all future settlement upgrades\n    /// @dev This operation can not be undone\n    function freezeUpgrades()\n    public\n    onlyDeployer\n    {\n        // Freeze upgrade\n        upgradesFrozen = true;\n\n        // Emit event\n        emit FreezeUpgradesEvent();\n    }\n\n    /// @notice Upgrade settlement from other driip settlement state instance\n    function upgradeSettlement(string memory settledKind, bytes32 settledHash,\n        address originWallet, uint256 originNonce, bool originDone, uint256 originDoneBlockNumber,\n        address targetWallet, uint256 targetNonce, bool targetDone, uint256 targetDoneBlockNumber)\n    public\n    onlyDeployer\n    {\n        // Require that upgrades have not been frozen\n        require(!upgradesFrozen, \"Upgrades have been frozen [DriipSettlementState.sol:413]\");\n\n        // Require that settlement has not been initialized/upgraded already\n        require(0 == walletNonceSettlementIndex[originWallet][originNonce], \"Settlement exists for origin wallet and nonce [DriipSettlementState.sol:416]\");\n        require(0 == walletNonceSettlementIndex[targetWallet][targetNonce], \"Settlement exists for target wallet and nonce [DriipSettlementState.sol:417]\");\n\n        // Create new settlement\n        settlements.length++;\n\n        // Get the 0-based index\n        uint256 index = settlements.length - 1;\n\n        // Update settlement\n        settlements[index].settledKind = settledKind;\n        settlements[index].settledHash = settledHash;\n        settlements[index].origin.nonce = originNonce;\n        settlements[index].origin.wallet = originWallet;\n        settlements[index].origin.done = originDone;\n        settlements[index].origin.doneBlockNumber = originDoneBlockNumber;\n        settlements[index].target.nonce = targetNonce;\n        settlements[index].target.wallet = targetWallet;\n        settlements[index].target.done = targetDone;\n        settlements[index].target.doneBlockNumber = targetDoneBlockNumber;\n\n        // Emit event\n        emit UpgradeSettlementEvent(settlements[index]);\n\n        // Store 1-based index value\n        index++;\n        walletSettlementIndices[originWallet].push(index);\n        walletSettlementIndices[targetWallet].push(index);\n        walletNonceSettlementIndex[originWallet][originNonce] = index;\n        walletNonceSettlementIndex[targetWallet][targetNonce] = index;\n    }\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"settlements\",\"outputs\":[{\"name\":\"settledKind\",\"type\":\"string\"},{\"name\":\"settledHash\",\"type\":\"bytes32\"},{\"components\":[{\"name\":\"nonce\",\"type\":\"uint256\"},{\"name\":\"wallet\",\"type\":\"address\"},{\"name\":\"done\",\"type\":\"bool\"},{\"name\":\"doneBlockNumber\",\"type\":\"uint256\"}],\"name\":\"origin\",\"type\":\"tuple\"},{\"components\":[{\"name\":\"nonce\",\"type\":\"uint256\"},{\"name\":\"wallet\",\"type\":\"address\"},{\"name\":\"done\",\"type\":\"bool\"},{\"name\":\"doneBlockNumber\",\"type\":\"uint256\"}],\"name\":\"target\",\"type\":\"tuple\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"SET_MAX_NONCE_ACTION\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"SET_FEE_TOTAL_ACTION\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"wallet\",\"type\":\"address\"},{\"components\":[{\"name\":\"ct\",\"type\":\"address\"},{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"currency\",\"type\":\"tuple\"},{\"name\":\"maxNonce\",\"type\":\"uint256\"}],\"name\":\"setMaxNonceByWalletAndCurrency\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"freezeUpgrades\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"service\",\"type\":\"address\"}],\"name\":\"isRegisteredActiveService\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"triggerSelfDestruction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"service\",\"type\":\"address\"},{\"name\":\"action\",\"type\":\"string\"}],\"name\":\"enableServiceAction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"service\",\"type\":\"address\"}],\"name\":\"isRegisteredService\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"selfDestructionDisabled\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"wallet\",\"type\":\"address\"},{\"components\":[{\"name\":\"ct\",\"type\":\"address\"},{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"currency\",\"type\":\"tuple\"}],\"name\":\"maxNonceByWalletAndCurrency\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"service\",\"type\":\"address\"},{\"name\":\"action\",\"type\":\"string\"}],\"name\":\"disableServiceAction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"serviceActivationTimeout\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"totalFeesMap\",\"outputs\":[{\"name\":\"nonce\",\"type\":\"uint256\"},{\"name\":\"amount\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"destructor\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_maxDriipNonce\",\"type\":\"uint256\"}],\"name\":\"setMaxDriipNonce\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"wallet\",\"type\":\"address\"},{\"name\":\"nonce\",\"type\":\"uint256\"}],\"name\":\"settlementPartyDoneBlockNumber\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"service\",\"type\":\"address\"}],\"name\":\"deregisterService\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"operator\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"updateMaxDriipNonceFromCommunityVote\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"service\",\"type\":\"address\"},{\"name\":\"action\",\"type\":\"string\"}],\"name\":\"isEnabledServiceAction\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"freezeCommunityVote\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"upgradesFrozen\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"wallet\",\"type\":\"address\"},{\"name\":\"beneficiary\",\"type\":\"address\"},{\"name\":\"destination\",\"type\":\"address\"},{\"components\":[{\"name\":\"ct\",\"type\":\"address\"},{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"currency\",\"type\":\"tuple\"}],\"name\":\"totalFee\",\"outputs\":[{\"components\":[{\"name\":\"nonce\",\"type\":\"uint256\"},{\"name\":\"amount\",\"type\":\"int256\"}],\"name\":\"\",\"type\":\"tuple\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"SET_SETTLEMENT_ROLE_DONE_ACTION\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"disableSelfDestruction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"wallet\",\"type\":\"address\"},{\"name\":\"beneficiary\",\"type\":\"address\"},{\"name\":\"destination\",\"type\":\"address\"},{\"components\":[{\"name\":\"ct\",\"type\":\"address\"},{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"currency\",\"type\":\"tuple\"},{\"components\":[{\"name\":\"nonce\",\"type\":\"uint256\"},{\"name\":\"amount\",\"type\":\"int256\"}],\"name\":\"_totalFee\",\"type\":\"tuple\"}],\"name\":\"setTotalFee\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"timeoutInSeconds\",\"type\":\"uint256\"}],\"name\":\"setServiceActivationTimeout\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"settledKind\",\"type\":\"string\"},{\"name\":\"settledHash\",\"type\":\"bytes32\"},{\"name\":\"originWallet\",\"type\":\"address\"},{\"name\":\"originNonce\",\"type\":\"uint256\"},{\"name\":\"targetWallet\",\"type\":\"address\"},{\"name\":\"targetNonce\",\"type\":\"uint256\"}],\"name\":\"initSettlement\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxDriipNonce\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"settlementsCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"service\",\"type\":\"address\"}],\"name\":\"registerServiceDeferred\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"communityVoteFrozen\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"walletSettlementIndices\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newDeployer\",\"type\":\"address\"}],\"name\":\"setDeployer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"wallet\",\"type\":\"address\"},{\"name\":\"nonce\",\"type\":\"uint256\"},{\"name\":\"settlementRole\",\"type\":\"uint8\"}],\"name\":\"isSettlementPartyDone\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"wallet\",\"type\":\"address\"},{\"name\":\"nonce\",\"type\":\"uint256\"},{\"name\":\"settlementRole\",\"type\":\"uint8\"}],\"name\":\"settlementPartyDoneBlockNumber\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOperator\",\"type\":\"address\"}],\"name\":\"setOperator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"communityVote\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"wallet\",\"type\":\"address\"},{\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"settlementByWalletAndIndex\",\"outputs\":[{\"components\":[{\"name\":\"settledKind\",\"type\":\"string\"},{\"name\":\"settledHash\",\"type\":\"bytes32\"},{\"components\":[{\"name\":\"nonce\",\"type\":\"uint256\"},{\"name\":\"wallet\",\"type\":\"address\"},{\"name\":\"done\",\"type\":\"bool\"},{\"name\":\"doneBlockNumber\",\"type\":\"uint256\"}],\"name\":\"origin\",\"type\":\"tuple\"},{\"components\":[{\"name\":\"nonce\",\"type\":\"uint256\"},{\"name\":\"wallet\",\"type\":\"address\"},{\"name\":\"done\",\"type\":\"bool\"},{\"name\":\"doneBlockNumber\",\"type\":\"uint256\"}],\"name\":\"target\",\"type\":\"tuple\"}],\"name\":\"\",\"type\":\"tuple\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"settledKind\",\"type\":\"string\"},{\"name\":\"settledHash\",\"type\":\"bytes32\"},{\"name\":\"originWallet\",\"type\":\"address\"},{\"name\":\"originNonce\",\"type\":\"uint256\"},{\"name\":\"originDone\",\"type\":\"bool\"},{\"name\":\"originDoneBlockNumber\",\"type\":\"uint256\"},{\"name\":\"targetWallet\",\"type\":\"address\"},{\"name\":\"targetNonce\",\"type\":\"uint256\"},{\"name\":\"targetDone\",\"type\":\"bool\"},{\"name\":\"targetDoneBlockNumber\",\"type\":\"uint256\"}],\"name\":\"upgradeSettlement\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"wallet\",\"type\":\"address\"},{\"name\":\"nonce\",\"type\":\"uint256\"}],\"name\":\"isSettlementPartyDone\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"wallet\",\"type\":\"address\"},{\"name\":\"nonce\",\"type\":\"uint256\"}],\"name\":\"settlementByWalletAndNonce\",\"outputs\":[{\"components\":[{\"name\":\"settledKind\",\"type\":\"string\"},{\"name\":\"settledHash\",\"type\":\"bytes32\"},{\"components\":[{\"name\":\"nonce\",\"type\":\"uint256\"},{\"name\":\"wallet\",\"type\":\"address\"},{\"name\":\"done\",\"type\":\"bool\"},{\"name\":\"doneBlockNumber\",\"type\":\"uint256\"}],\"name\":\"origin\",\"type\":\"tuple\"},{\"components\":[{\"name\":\"nonce\",\"type\":\"uint256\"},{\"name\":\"wallet\",\"type\":\"address\"},{\"name\":\"done\",\"type\":\"bool\"},{\"name\":\"doneBlockNumber\",\"type\":\"uint256\"}],\"name\":\"target\",\"type\":\"tuple\"}],\"name\":\"\",\"type\":\"tuple\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"deployer\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"walletNonceSettlementIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"wallet\",\"type\":\"address\"},{\"name\":\"nonce\",\"type\":\"uint256\"},{\"name\":\"settlementRole\",\"type\":\"uint8\"},{\"name\":\"done\",\"type\":\"bool\"}],\"name\":\"completeSettlementParty\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"INIT_SETTLEMENT_ACTION\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newCommunityVote\",\"type\":\"address\"}],\"name\":\"setCommunityVote\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"walletCurrencyMaxNonce\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"settlementsCountByWallet\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"service\",\"type\":\"address\"}],\"name\":\"registerService\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"deployer\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"components\":[{\"name\":\"settledKind\",\"type\":\"string\"},{\"name\":\"settledHash\",\"type\":\"bytes32\"},{\"components\":[{\"name\":\"nonce\",\"type\":\"uint256\"},{\"name\":\"wallet\",\"type\":\"address\"},{\"name\":\"done\",\"type\":\"bool\"},{\"name\":\"doneBlockNumber\",\"type\":\"uint256\"}],\"name\":\"origin\",\"type\":\"tuple\"},{\"components\":[{\"name\":\"nonce\",\"type\":\"uint256\"},{\"name\":\"wallet\",\"type\":\"address\"},{\"name\":\"done\",\"type\":\"bool\"},{\"name\":\"doneBlockNumber\",\"type\":\"uint256\"}],\"name\":\"target\",\"type\":\"tuple\"}],\"indexed\":false,\"name\":\"settlement\",\"type\":\"tuple\"}],\"name\":\"InitSettlementEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"wallet\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"nonce\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"settlementRole\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"done\",\"type\":\"bool\"},{\"indexed\":false,\"name\":\"doneBlockNumber\",\"type\":\"uint256\"}],\"name\":\"CompleteSettlementPartyEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"wallet\",\"type\":\"address\"},{\"components\":[{\"name\":\"ct\",\"type\":\"address\"},{\"name\":\"id\",\"type\":\"uint256\"}],\"indexed\":false,\"name\":\"currency\",\"type\":\"tuple\"},{\"indexed\":false,\"name\":\"maxNonce\",\"type\":\"uint256\"}],\"name\":\"SetMaxNonceByWalletAndCurrencyEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"maxDriipNonce\",\"type\":\"uint256\"}],\"name\":\"SetMaxDriipNonceEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"maxDriipNonce\",\"type\":\"uint256\"}],\"name\":\"UpdateMaxDriipNonceFromCommunityVoteEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"wallet\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"destination\",\"type\":\"address\"},{\"components\":[{\"name\":\"ct\",\"type\":\"address\"},{\"name\":\"id\",\"type\":\"uint256\"}],\"indexed\":false,\"name\":\"currency\",\"type\":\"tuple\"},{\"components\":[{\"name\":\"nonce\",\"type\":\"uint256\"},{\"name\":\"amount\",\"type\":\"int256\"}],\"indexed\":false,\"name\":\"totalFee\",\"type\":\"tuple\"}],\"name\":\"SetTotalFeeEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"FreezeUpgradesEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"components\":[{\"name\":\"settledKind\",\"type\":\"string\"},{\"name\":\"settledHash\",\"type\":\"bytes32\"},{\"components\":[{\"name\":\"nonce\",\"type\":\"uint256\"},{\"name\":\"wallet\",\"type\":\"address\"},{\"name\":\"done\",\"type\":\"bool\"},{\"name\":\"doneBlockNumber\",\"type\":\"uint256\"}],\"name\":\"origin\",\"type\":\"tuple\"},{\"components\":[{\"name\":\"nonce\",\"type\":\"uint256\"},{\"name\":\"wallet\",\"type\":\"address\"},{\"name\":\"done\",\"type\":\"bool\"},{\"name\":\"doneBlockNumber\",\"type\":\"uint256\"}],\"name\":\"target\",\"type\":\"tuple\"}],\"indexed\":false,\"name\":\"settlement\",\"type\":\"tuple\"}],\"name\":\"UpgradeSettlementEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldCommunityVote\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newCommunityVote\",\"type\":\"address\"}],\"name\":\"SetCommunityVoteEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"FreezeCommunityVoteEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"timeoutInSeconds\",\"type\":\"uint256\"}],\"name\":\"ServiceActivationTimeoutEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"service\",\"type\":\"address\"}],\"name\":\"RegisterServiceEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"service\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"timeout\",\"type\":\"uint256\"}],\"name\":\"RegisterServiceDeferredEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"service\",\"type\":\"address\"}],\"name\":\"DeregisterServiceEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"service\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"action\",\"type\":\"string\"}],\"name\":\"EnableServiceActionEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"service\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"action\",\"type\":\"string\"}],\"name\":\"DisableServiceActionEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldDeployer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newDeployer\",\"type\":\"address\"}],\"name\":\"SetDeployerEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldOperator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newOperator\",\"type\":\"address\"}],\"name\":\"SetOperatorEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"SelfDestructionDisabledEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"TriggerSelfDestructionEvent\",\"type\":\"event\"}]","ContractName":"DriipSettlementState","CompilerVersion":"v0.5.9+commit.e560f70d","OptimizationUsed":"1","Runs":"0","ConstructorArguments":"000000000000000000000000f05179bac3d1fbef58a2fcd7ad0f769840027cc6","Library":"","SwarmSource":"bzzr://f9472f509f1702569f1b3d4a6ca01396fe3916233deacac3136dc545ed0cf042"}]}