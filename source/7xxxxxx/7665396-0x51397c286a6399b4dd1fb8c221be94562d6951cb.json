{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.25;\r\n\r\n// File: contracts/LinkedListLib.sol\r\n\r\n/**\r\n * @title LinkedListLib\r\n * @author Darryl Morris (o0ragman0o) and Modular.network\r\n *\r\n * This utility library was forked from https://github.com/o0ragman0o/LibCLL\r\n * into the Modular-Network ethereum-libraries repo at https://github.com/Modular-Network/ethereum-libraries\r\n * It has been updated to add additional functionality and be more compatible with solidity 0.4.18\r\n * coding patterns.\r\n *\r\n * version 1.1.1\r\n * Copyright (c) 2017 Modular Inc.\r\n * The MIT License (MIT)\r\n * https://github.com/Modular-network/ethereum-libraries/blob/master/LICENSE\r\n *\r\n * The LinkedListLib provides functionality for implementing data indexing using\r\n * a circlular linked list\r\n *\r\n * Modular provides smart contract services and security reviews for contract\r\n * deployments in addition to working on open source projects in the Ethereum\r\n * community. Our purpose is to test, document, and deploy reusable code onto the\r\n * blockchain and improve both security and usability. We also educate non-profits,\r\n * schools, and other community members about the application of blockchain\r\n * technology. For further information: modular.network\r\n *\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\r\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\r\n * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\r\n * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\r\n * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\r\n * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n*/\r\n\r\n\r\nlibrary LinkedListLib {\r\n\r\n    uint256 constant NULL = 0;\r\n    uint256 constant HEAD = 0;\r\n    bool constant PREV = false;\r\n    bool constant NEXT = true;\r\n\r\n    struct LinkedList{\r\n        mapping (uint256 => mapping (bool => uint256)) list;\r\n    }\r\n\r\n    /// @dev returns true if the list exists\r\n    /// @param self stored linked list from contract\r\n    function listExists(LinkedList storage self)\r\n        public\r\n        view returns (bool)\r\n    {\r\n        // if the head nodes previous or next pointers both point to itself, then there are no items in the list\r\n        if (self.list[HEAD][PREV] != HEAD || self.list[HEAD][NEXT] != HEAD) {\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /// @dev returns true if the node exists\r\n    /// @param self stored linked list from contract\r\n    /// @param _node a node to search for\r\n    function nodeExists(LinkedList storage self, uint256 _node)\r\n        public\r\n        view returns (bool)\r\n    {\r\n        if (self.list[_node][PREV] == HEAD && self.list[_node][NEXT] == HEAD) {\r\n            if (self.list[HEAD][NEXT] == _node) {\r\n                return true;\r\n            } else {\r\n                return false;\r\n            }\r\n        } else {\r\n            return true;\r\n        }\r\n    }\r\n\r\n    /// @dev Returns the number of elements in the list\r\n    /// @param self stored linked list from contract\r\n    function sizeOf(LinkedList storage self) public view returns (uint256 numElements) {\r\n        bool exists;\r\n        uint256 i;\r\n        (exists,i) = getAdjacent(self, HEAD, NEXT);\r\n        while (i != HEAD) {\r\n            (exists,i) = getAdjacent(self, i, NEXT);\r\n            numElements++;\r\n        }\r\n        return;\r\n    }\r\n\r\n    /// @dev Returns the links of a node as a tuple\r\n    /// @param self stored linked list from contract\r\n    /// @param _node id of the node to get\r\n    function getNode(LinkedList storage self, uint256 _node)\r\n        public view returns (bool,uint256,uint256)\r\n    {\r\n        if (!nodeExists(self,_node)) {\r\n            return (false,0,0);\r\n        } else {\r\n            return (true,self.list[_node][PREV], self.list[_node][NEXT]);\r\n        }\r\n    }\r\n\r\n    /// @dev Returns the link of a node `_node` in direction `_direction`.\r\n    /// @param self stored linked list from contract\r\n    /// @param _node id of the node to step from\r\n    /// @param _direction direction to step in\r\n    function getAdjacent(LinkedList storage self, uint256 _node, bool _direction)\r\n        public view returns (bool,uint256)\r\n    {\r\n        if (!nodeExists(self,_node)) {\r\n            return (false,0);\r\n        } else {\r\n            return (true,self.list[_node][_direction]);\r\n        }\r\n    }\r\n\r\n    /// @dev Can be used before `insert` to build an ordered list\r\n    /// @param self stored linked list from contract\r\n    /// @param _node an existing node to search from, e.g. HEAD.\r\n    /// @param _value value to seek\r\n    /// @param _direction direction to seek in\r\n    //  @return next first node beyond '_node' in direction `_direction`\r\n    function getSortedSpot(LinkedList storage self, uint256 _node, uint256 _value, bool _direction)\r\n        public view returns (uint256)\r\n    {\r\n        if (sizeOf(self) == 0) { return 0; }\r\n        require((_node == 0) || nodeExists(self,_node));\r\n        bool exists;\r\n        uint256 next;\r\n        (exists,next) = getAdjacent(self, _node, _direction);\r\n        while  ((next != 0) && (_value != next) && ((_value < next) != _direction)) next = self.list[next][_direction];\r\n        return next;\r\n    }\r\n\r\n    /// @dev Creates a bidirectional link between two nodes on direction `_direction`\r\n    /// @param self stored linked list from contract\r\n    /// @param _node first node for linking\r\n    /// @param _link  node to link to in the _direction\r\n    function createLink(LinkedList storage self, uint256 _node, uint256 _link, bool _direction) private  {\r\n        self.list[_link][!_direction] = _node;\r\n        self.list[_node][_direction] = _link;\r\n    }\r\n\r\n    /// @dev Insert node `_new` beside existing node `_node` in direction `_direction`.\r\n    /// @param self stored linked list from contract\r\n    /// @param _node existing node\r\n    /// @param _new  new node to insert\r\n    /// @param _direction direction to insert node in\r\n    function insert(LinkedList storage self, uint256 _node, uint256 _new, bool _direction) internal returns (bool) {\r\n        if(!nodeExists(self,_new) && nodeExists(self,_node)) {\r\n            uint256 c = self.list[_node][_direction];\r\n            createLink(self, _node, _new, _direction);\r\n            createLink(self, _new, c, _direction);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /// @dev removes an entry from the linked list\r\n    /// @param self stored linked list from contract\r\n    /// @param _node node to remove from the list\r\n    function remove(LinkedList storage self, uint256 _node) internal returns (uint256) {\r\n        if ((_node == NULL) || (!nodeExists(self,_node))) { return 0; }\r\n        createLink(self, self.list[_node][PREV], self.list[_node][NEXT], NEXT);\r\n        delete self.list[_node][PREV];\r\n        delete self.list[_node][NEXT];\r\n        return _node;\r\n    }\r\n\r\n    /// @dev pushes an enrty to the head of the linked list\r\n    /// @param self stored linked list from contract\r\n    /// @param _node new entry to push to the head\r\n    /// @param _direction push to the head (NEXT) or tail (PREV)\r\n    function push(LinkedList storage self, uint256 _node, bool _direction) internal  {\r\n        insert(self, HEAD, _node, _direction);\r\n    }\r\n\r\n    /// @dev pops the first entry from the linked list\r\n    /// @param self stored linked list from contract\r\n    /// @param _direction pop from the head (NEXT) or the tail (PREV)\r\n    function pop(LinkedList storage self, bool _direction) internal returns (uint256) {\r\n        bool exists;\r\n        uint256 adj;\r\n\r\n        (exists,adj) = getAdjacent(self, HEAD, _direction);\r\n\r\n        return remove(self, adj);\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/math/SafeMath.sol\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return a / b;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipRenounced(address indexed previousOwner);\r\n  event OwnershipTransferred(\r\n    address indexed previousOwner,\r\n    address indexed newOwner\r\n  );\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  constructor() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to relinquish control of the contract.\r\n   */\r\n  function renounceOwnership() public onlyOwner {\r\n    emit OwnershipRenounced(owner);\r\n    owner = address(0);\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address _newOwner) public onlyOwner {\r\n    _transferOwnership(_newOwner);\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function _transferOwnership(address _newOwner) internal {\r\n    require(_newOwner != address(0));\r\n    emit OwnershipTransferred(owner, _newOwner);\r\n    owner = _newOwner;\r\n  }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/ownership/rbac/Roles.sol\r\n\r\n/**\r\n * @title Roles\r\n * @author Francisco Giordano (@frangio)\r\n * @dev Library for managing addresses assigned to a Role.\r\n *      See RBAC.sol for example usage.\r\n */\r\nlibrary Roles {\r\n  struct Role {\r\n    mapping (address => bool) bearer;\r\n  }\r\n\r\n  /**\r\n   * @dev give an address access to this role\r\n   */\r\n  function add(Role storage role, address addr)\r\n    internal\r\n  {\r\n    role.bearer[addr] = true;\r\n  }\r\n\r\n  /**\r\n   * @dev remove an address' access to this role\r\n   */\r\n  function remove(Role storage role, address addr)\r\n    internal\r\n  {\r\n    role.bearer[addr] = false;\r\n  }\r\n\r\n  /**\r\n   * @dev check if an address has this role\r\n   * // reverts\r\n   */\r\n  function check(Role storage role, address addr)\r\n    view\r\n    internal\r\n  {\r\n    require(has(role, addr));\r\n  }\r\n\r\n  /**\r\n   * @dev check if an address has this role\r\n   * @return bool\r\n   */\r\n  function has(Role storage role, address addr)\r\n    view\r\n    internal\r\n    returns (bool)\r\n  {\r\n    return role.bearer[addr];\r\n  }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/ownership/rbac/RBAC.sol\r\n\r\n/**\r\n * @title RBAC (Role-Based Access Control)\r\n * @author Matt Condon (@Shrugs)\r\n * @dev Stores and provides setters and getters for roles and addresses.\r\n * @dev Supports unlimited numbers of roles and addresses.\r\n * @dev See //contracts/mocks/RBACMock.sol for an example of usage.\r\n * This RBAC method uses strings to key roles. It may be beneficial\r\n *  for you to write your own implementation of this interface using Enums or similar.\r\n * It's also recommended that you define constants in the contract, like ROLE_ADMIN below,\r\n *  to avoid typos.\r\n */\r\ncontract RBAC {\r\n  using Roles for Roles.Role;\r\n\r\n  mapping (string => Roles.Role) private roles;\r\n\r\n  event RoleAdded(address addr, string roleName);\r\n  event RoleRemoved(address addr, string roleName);\r\n\r\n  /**\r\n   * @dev reverts if addr does not have role\r\n   * @param addr address\r\n   * @param roleName the name of the role\r\n   * // reverts\r\n   */\r\n  function checkRole(address addr, string roleName)\r\n    view\r\n    public\r\n  {\r\n    roles[roleName].check(addr);\r\n  }\r\n\r\n  /**\r\n   * @dev determine if addr has role\r\n   * @param addr address\r\n   * @param roleName the name of the role\r\n   * @return bool\r\n   */\r\n  function hasRole(address addr, string roleName)\r\n    view\r\n    public\r\n    returns (bool)\r\n  {\r\n    return roles[roleName].has(addr);\r\n  }\r\n\r\n  /**\r\n   * @dev add a role to an address\r\n   * @param addr address\r\n   * @param roleName the name of the role\r\n   */\r\n  function addRole(address addr, string roleName)\r\n    internal\r\n  {\r\n    roles[roleName].add(addr);\r\n    emit RoleAdded(addr, roleName);\r\n  }\r\n\r\n  /**\r\n   * @dev remove a role from an address\r\n   * @param addr address\r\n   * @param roleName the name of the role\r\n   */\r\n  function removeRole(address addr, string roleName)\r\n    internal\r\n  {\r\n    roles[roleName].remove(addr);\r\n    emit RoleRemoved(addr, roleName);\r\n  }\r\n\r\n  /**\r\n   * @dev modifier to scope access to a single role (uses msg.sender as addr)\r\n   * @param roleName the name of the role\r\n   * // reverts\r\n   */\r\n  modifier onlyRole(string roleName)\r\n  {\r\n    checkRole(msg.sender, roleName);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev modifier to scope access to a set of roles (uses msg.sender as addr)\r\n   * @param roleNames the names of the roles to scope access to\r\n   * // reverts\r\n   *\r\n   * @TODO - when solidity supports dynamic arrays as arguments to modifiers, provide this\r\n   *  see: https://github.com/ethereum/solidity/issues/2467\r\n   */\r\n  // modifier onlyRoles(string[] roleNames) {\r\n  //     bool hasAnyRole = false;\r\n  //     for (uint8 i = 0; i < roleNames.length; i++) {\r\n  //         if (hasRole(msg.sender, roleNames[i])) {\r\n  //             hasAnyRole = true;\r\n  //             break;\r\n  //         }\r\n  //     }\r\n\r\n  //     require(hasAnyRole);\r\n\r\n  //     _;\r\n  // }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/ownership/Whitelist.sol\r\n\r\n/**\r\n * @title Whitelist\r\n * @dev The Whitelist contract has a whitelist of addresses, and provides basic authorization control functions.\r\n * @dev This simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Whitelist is Ownable, RBAC {\r\n  event WhitelistedAddressAdded(address addr);\r\n  event WhitelistedAddressRemoved(address addr);\r\n\r\n  string public constant ROLE_WHITELISTED = \"whitelist\";\r\n\r\n  /**\r\n   * @dev Throws if called by any account that's not whitelisted.\r\n   */\r\n  modifier onlyWhitelisted() {\r\n    checkRole(msg.sender, ROLE_WHITELISTED);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev add an address to the whitelist\r\n   * @param addr address\r\n   * @return true if the address was added to the whitelist, false if the address was already in the whitelist\r\n   */\r\n  function addAddressToWhitelist(address addr)\r\n    onlyOwner\r\n    public\r\n  {\r\n    addRole(addr, ROLE_WHITELISTED);\r\n    emit WhitelistedAddressAdded(addr);\r\n  }\r\n\r\n  /**\r\n   * @dev getter to determine if address is in whitelist\r\n   */\r\n  function whitelist(address addr)\r\n    public\r\n    view\r\n    returns (bool)\r\n  {\r\n    return hasRole(addr, ROLE_WHITELISTED);\r\n  }\r\n\r\n  /**\r\n   * @dev add addresses to the whitelist\r\n   * @param addrs addresses\r\n   * @return true if at least one address was added to the whitelist,\r\n   * false if all addresses were already in the whitelist\r\n   */\r\n  function addAddressesToWhitelist(address[] addrs)\r\n    onlyOwner\r\n    public\r\n  {\r\n    for (uint256 i = 0; i < addrs.length; i++) {\r\n      addAddressToWhitelist(addrs[i]);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev remove an address from the whitelist\r\n   * @param addr address\r\n   * @return true if the address was removed from the whitelist,\r\n   * false if the address wasn't in the whitelist in the first place\r\n   */\r\n  function removeAddressFromWhitelist(address addr)\r\n    onlyOwner\r\n    public\r\n  {\r\n    removeRole(addr, ROLE_WHITELISTED);\r\n    emit WhitelistedAddressRemoved(addr);\r\n  }\r\n\r\n  /**\r\n   * @dev remove addresses from the whitelist\r\n   * @param addrs addresses\r\n   * @return true if at least one address was removed from the whitelist,\r\n   * false if all addresses weren't in the whitelist in the first place\r\n   */\r\n  function removeAddressesFromWhitelist(address[] addrs)\r\n    onlyOwner\r\n    public\r\n  {\r\n    for (uint256 i = 0; i < addrs.length; i++) {\r\n      removeAddressFromWhitelist(addrs[i]);\r\n    }\r\n  }\r\n\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC20/ERC20Basic.sol\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/179\r\n */\r\ncontract ERC20Basic {\r\n  function totalSupply() public view returns (uint256);\r\n  function balanceOf(address who) public view returns (uint256);\r\n  function transfer(address to, uint256 value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC20/ERC20.sol\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address owner, address spender)\r\n    public view returns (uint256);\r\n\r\n  function transferFrom(address from, address to, uint256 value)\r\n    public returns (bool);\r\n\r\n  function approve(address spender, uint256 value) public returns (bool);\r\n  event Approval(\r\n    address indexed owner,\r\n    address indexed spender,\r\n    uint256 value\r\n  );\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC20/SafeERC20.sol\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure.\r\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n  function safeTransfer(ERC20Basic token, address to, uint256 value) internal {\r\n    require(token.transfer(to, value));\r\n  }\r\n\r\n  function safeTransferFrom(\r\n    ERC20 token,\r\n    address from,\r\n    address to,\r\n    uint256 value\r\n  )\r\n    internal\r\n  {\r\n    require(token.transferFrom(from, to, value));\r\n  }\r\n\r\n  function safeApprove(ERC20 token, address spender, uint256 value) internal {\r\n    require(token.approve(spender, value));\r\n  }\r\n}\r\n\r\n// File: contracts/token_escrow/TokenEscrow.sol\r\n\r\n/**\r\n * NOTE: All contracts in this directory were taken from a non-master branch of openzeppelin-solidity.\r\n * This contract was modified to be a whitelist.\r\n * Commit: ed451a8688d1fa7c927b27cec299a9726667d9b1\r\n */\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title TokenEscrow\r\n * @dev Holds tokens destinated to a payee until they withdraw them.\r\n * The contract that uses the TokenEscrow as its payment method\r\n * should be its owner, and provide public methods redirecting\r\n * to the TokenEscrow's deposit and withdraw.\r\n * Moreover, the TokenEscrow should also be allowed to transfer\r\n * tokens from the payer to itself.\r\n */\r\ncontract TokenEscrow is Ownable, Whitelist {\r\n  using SafeMath for uint256;\r\n  using SafeERC20 for ERC20;\r\n\r\n  event Deposited(address indexed payee, uint256 tokenAmount);\r\n  event Withdrawn(address indexed payee, uint256 tokenAmount);\r\n\r\n  mapping(address => uint256) public deposits;\r\n\r\n  ERC20 public token;\r\n\r\n  constructor (ERC20 _token) public {\r\n    require(_token != address(0));\r\n    token = _token;\r\n  }\r\n\r\n  function depositsOf(address _payee) public view returns (uint256) {\r\n    return deposits[_payee];\r\n  }\r\n\r\n  /**\r\n  * @dev Puts in escrow a certain amount of tokens as credit to be withdrawn.\r\n  * @param _payee The destination address of the tokens.\r\n  * @param _amount The amount of tokens to deposit in escrow.\r\n  */\r\n  function deposit(address _payee, uint256 _amount) public onlyWhitelisted {\r\n    deposits[_payee] = deposits[_payee].add(_amount);\r\n\r\n    token.safeTransferFrom(msg.sender, address(this), _amount);\r\n\r\n    emit Deposited(_payee, _amount);\r\n  }\r\n\r\n  /**\r\n  * @dev Withdraw accumulated tokens for a payee.\r\n  * @param _payee The address whose tokens will be withdrawn and transferred to.\r\n  */\r\n  function withdraw(address _payee) public onlyWhitelisted {\r\n    uint256 payment = deposits[_payee];\r\n    assert(token.balanceOf(address(this)) >= payment);\r\n\r\n    deposits[_payee] = 0;\r\n\r\n    token.safeTransfer(_payee, payment);\r\n\r\n    emit Withdrawn(_payee, payment);\r\n  }\r\n}\r\n\r\n// File: contracts/token_escrow/ConditionalTokenEscrow.sol\r\n\r\n/**\r\n * NOTE: All contracts in this directory were taken from a non-master branch of openzeppelin-solidity.\r\n * Commit: ed451a8688d1fa7c927b27cec299a9726667d9b1\r\n */\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\n\r\n/**\r\n * @title ConditionalTokenEscrow\r\n * @dev Base abstract escrow to only allow withdrawal of tokens\r\n * if a condition is met.\r\n */\r\ncontract ConditionalTokenEscrow is TokenEscrow {\r\n  /**\r\n  * @dev Returns whether an address is allowed to withdraw their tokens.\r\n  * To be implemented by derived contracts.\r\n  * @param _payee The destination address of the tokens.\r\n  */\r\n  function withdrawalAllowed(address _payee) public view returns (bool);\r\n\r\n  function withdraw(address _payee) public {\r\n    require(withdrawalAllowed(_payee));\r\n    super.withdraw(_payee);\r\n  }\r\n}\r\n\r\n// File: contracts/QuantstampAuditTokenEscrow.sol\r\n\r\ncontract QuantstampAuditTokenEscrow is ConditionalTokenEscrow {\r\n\r\n  // the escrow maintains the list of staked addresses\r\n  using LinkedListLib for LinkedListLib.LinkedList;\r\n\r\n  // constants used by LinkedListLib\r\n  uint256 constant internal NULL = 0;\r\n  uint256 constant internal HEAD = 0;\r\n  bool constant internal PREV = false;\r\n  bool constant internal NEXT = true;\r\n\r\n  // maintain the number of staked nodes\r\n  // saves gas cost over needing to call stakedNodesList.sizeOf()\r\n  uint256 public stakedNodesCount = 0;\r\n\r\n  // the minimum amount of wei-QSP that must be staked in order to be a node\r\n  uint256 public minAuditStake = 10000 * (10 ** 18);\r\n\r\n  // if true, the payee cannot currently withdraw their funds\r\n  mapping(address => bool) public lockedFunds;\r\n\r\n  // if funds are locked, they may be retrieved after this block\r\n  // if funds are unlocked, the number should be ignored\r\n  mapping(address => uint256) public unlockBlockNumber;\r\n\r\n  // staked audit nodes -- needed to inquire about audit node statistics, such as min price\r\n  // this list contains all nodes that have *ANY* stake, however when getNextStakedNode is called,\r\n  // it skips nodes that do not meet the minimum stake.\r\n  // the reason for this approach is that if the owner lowers the minAuditStake,\r\n  // we must be aware of any node with a stake.\r\n  LinkedListLib.LinkedList internal stakedNodesList;\r\n\r\n  event Slashed(address addr, uint256 amount);\r\n  event StakedNodeAdded(address addr);\r\n  event StakedNodeRemoved(address addr);\r\n\r\n  // the constructor of TokenEscrow requires an ERC20, not an address\r\n  constructor(address tokenAddress) public TokenEscrow(ERC20(tokenAddress)) {} // solhint-disable no-empty-blocks\r\n\r\n  /**\r\n  * @dev Puts in escrow a certain amount of tokens as credit to be withdrawn.\r\n  *      Overrides the function in TokenEscrow.sol to add the payee to the staked list.\r\n  * @param _payee The destination address of the tokens.\r\n  * @param _amount The amount of tokens to deposit in escrow.\r\n  */\r\n  function deposit(address _payee, uint256 _amount) public onlyWhitelisted {\r\n    super.deposit(_payee, _amount);\r\n    if (_amount > 0) {\r\n      // fails gracefully if the node already exists\r\n      addNodeToStakedList(_payee);\r\n    }\r\n  }\r\n\r\n /**\r\n  * @dev Withdraw accumulated tokens for a payee.\r\n  *      Overrides the function in TokenEscrow.sol to remove the payee from the staked list.\r\n  * @param _payee The address whose tokens will be withdrawn and transferred to.\r\n  */\r\n  function withdraw(address _payee) public onlyWhitelisted {\r\n    super.withdraw(_payee);\r\n    removeNodeFromStakedList(_payee);\r\n  }\r\n\r\n  /**\r\n   * @dev Sets the minimum stake to a new value.\r\n   * @param _value The new value. _value must be greater than zero in order for the linked list to be maintained correctly.\r\n   */\r\n  function setMinAuditStake(uint256 _value) public onlyOwner {\r\n    require(_value > 0);\r\n    minAuditStake = _value;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns true if the sender staked enough.\r\n   * @param addr The address to check.\r\n   */\r\n  function hasEnoughStake(address addr) public view returns(bool) {\r\n    return depositsOf(addr) >= minAuditStake;\r\n  }\r\n\r\n  /**\r\n   * @dev Overrides ConditionalTokenEscrow function. If true, funds may be withdrawn.\r\n   * @param _payee The address that wants to withdraw funds.\r\n   */\r\n  function withdrawalAllowed(address _payee) public view returns (bool) {\r\n    return !lockedFunds[_payee] || unlockBlockNumber[_payee] < block.number;\r\n  }\r\n\r\n  /**\r\n   * @dev Prevents the payee from withdrawing funds.\r\n   * @param _payee The address that will be locked.\r\n   */\r\n  function lockFunds(address _payee, uint256 _unlockBlockNumber) public onlyWhitelisted returns (bool) {\r\n    lockedFunds[_payee] = true;\r\n    unlockBlockNumber[_payee] = _unlockBlockNumber;\r\n    return true;\r\n  }\r\n\r\n    /**\r\n   * @dev Slash a percentage of the stake of an address.\r\n   *      The percentage is taken from the minAuditStake, not the total stake of the address.\r\n   *      The caller of this function receives the slashed QSP.\r\n   *      If the current stake does not cover the slash amount, the full stake is taken.\r\n   *\r\n   * @param addr The address that will be slashed.\r\n   * @param percentage The percent of the minAuditStake that should be slashed.\r\n   */\r\n  function slash(address addr, uint256 percentage) public onlyWhitelisted returns (uint256) {\r\n    require(0 <= percentage && percentage <= 100);\r\n\r\n    uint256 slashAmount = getSlashAmount(percentage);\r\n    uint256 balance = depositsOf(addr);\r\n    if (balance < slashAmount) {\r\n      slashAmount = balance;\r\n    }\r\n\r\n    // subtract from the deposits amount of the addr\r\n    deposits[addr] = deposits[addr].sub(slashAmount);\r\n\r\n    emit Slashed(addr, slashAmount);\r\n\r\n    // if the deposits of the address are now zero, remove from the list\r\n    if (depositsOf(addr) == 0) {\r\n      removeNodeFromStakedList(addr);\r\n    }\r\n\r\n    // transfer the slashAmount to the police contract\r\n    token.safeTransfer(msg.sender, slashAmount);\r\n\r\n    return slashAmount;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the slash amount for a given percentage.\r\n   * @param percentage The percent of the minAuditStake that should be slashed.\r\n   */\r\n  function getSlashAmount(uint256 percentage) public view returns (uint256) {\r\n    return (minAuditStake.mul(percentage)).div(100);\r\n  }\r\n\r\n  /**\r\n   * @dev Given a staked address, returns the next address from the list that meets the minAuditStake.\r\n   * @param addr The staked address.\r\n   * @return The next address in the list.\r\n   */\r\n  function getNextStakedNode(address addr) public view returns(address) {\r\n    bool exists;\r\n    uint256 next;\r\n    (exists, next) = stakedNodesList.getAdjacent(uint256(addr), NEXT);\r\n    // only return addresses that meet the minAuditStake\r\n    while (exists && next != HEAD && !hasEnoughStake(address(next))) {\r\n      (exists, next) = stakedNodesList.getAdjacent(next, NEXT);\r\n    }\r\n    return address(next);\r\n  }\r\n\r\n  /**\r\n   * @dev Adds an address to the stakedNodesList.\r\n   * @param addr The address to be added to the list.\r\n   * @return true if the address was added to the list.\r\n   */\r\n  function addNodeToStakedList(address addr) internal returns(bool success) {\r\n    if (stakedNodesList.insert(HEAD, uint256(addr), PREV)) {\r\n      stakedNodesCount++;\r\n      emit StakedNodeAdded(addr);\r\n      success = true;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Removes an address from the stakedNodesList.\r\n   * @param addr The address to be removed from the list.\r\n   * @return true if the address was removed from the list.\r\n   */\r\n  function removeNodeFromStakedList(address addr) internal returns(bool success) {\r\n    if (stakedNodesList.remove(uint256(addr)) != 0) {\r\n      stakedNodesCount--;\r\n      emit StakedNodeRemoved(addr);\r\n      success = true;\r\n    }\r\n  }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"percentage\",\"type\":\"uint256\"}],\"name\":\"slash\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"roleName\",\"type\":\"string\"}],\"name\":\"checkRole\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_payee\",\"type\":\"address\"},{\"name\":\"_unlockBlockNumber\",\"type\":\"uint256\"}],\"name\":\"lockFunds\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ROLE_WHITELISTED\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"unlockBlockNumber\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"roleName\",\"type\":\"string\"}],\"name\":\"hasRole\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addrs\",\"type\":\"address[]\"}],\"name\":\"removeAddressesFromWhitelist\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"removeAddressFromWhitelist\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"percentage\",\"type\":\"uint256\"}],\"name\":\"getSlashAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_payee\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_payee\",\"type\":\"address\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_payee\",\"type\":\"address\"}],\"name\":\"withdrawalAllowed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"hasEnoughStake\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"addAddressToWhitelist\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"whitelist\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"setMinAuditStake\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"lockedFunds\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"getNextStakedNode\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minAuditStake\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"stakedNodesCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addrs\",\"type\":\"address[]\"}],\"name\":\"addAddressesToWhitelist\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_payee\",\"type\":\"address\"}],\"name\":\"depositsOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"deposits\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"tokenAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Slashed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"StakedNodeAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"StakedNodeRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"payee\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"Deposited\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"payee\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"Withdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"WhitelistedAddressAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"WhitelistedAddressRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"roleName\",\"type\":\"string\"}],\"name\":\"RoleAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"roleName\",\"type\":\"string\"}],\"name\":\"RoleRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"}],\"name\":\"OwnershipRenounced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"QuantstampAuditTokenEscrow","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000099ea4db9ee77acd40b119bd1dc4e33e1c070b80d","Library":"LinkedListLib:697E2033BA28C1cC9E28d94ca910cA53a978aaD0","SwarmSource":"bzzr://af03876851d6691d43a118503e9fda84147ba6d56fc48897441fc114d6de8920"}]}