{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.5.6;\r\n\r\n\r\n\r\n/*\r\n*  deex.exchange pre-ICO tokens smart contract\r\n*  implements [ERC-20 Token Standard](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md)\r\n*\r\n*  Style\r\n*  1) before start coding, run Python and type 'import this' in Python console.\r\n*  2) we avoid using inheritance (contract B is A) as it makes code less clear for observer\r\n*  (\"Flat is better than nested\", \"Readability counts\")\r\n*  3) we avoid using -= ; =- ; +=; =+\r\n*  see: https://github.com/ether-camp/virtual-accelerator/issues/8\r\n*  https://www.ethnews.com/ethercamps-hkg-token-has-a-bug-and-needs-to-be-reissued\r\n*  4) always explicitly mark variables and functions visibility (\"Explicit is better than implicit\")\r\n*  5) every function except constructor should trigger at leas one event.\r\n*  6) smart contracts have to be audited and reviewed, comment your code.\r\n*\r\n*  Code is published on https://github.com/thedeex/thedeex.github.io\r\n*/\r\n\r\n\r\n/* \"Interfaces\" */\r\n\r\n//  this is expected from another contracts\r\n//  if it wants to spend tokens of behalf of the token owner in our contract\r\n//  this can be used in many situations, for example to convert pre-ICO tokens to ICO tokens\r\n//  see 'approveAndCall' function\r\ncontract allowanceRecipient {\r\n    function receiveApproval(address _from, uint256 _value, address _inContract, bytes memory _extraData) public returns (bool success);\r\n}\r\n\r\n\r\n// see:\r\n// https://github.com/ethereum/EIPs/issues/677\r\ncontract tokenRecipient {\r\n    function tokenFallback(address _from, uint256 _value, bytes memory _extraData) public returns (bool success);\r\n}\r\n\r\n\r\ncontract DEEX {\r\n\r\n    // ver. 2.0\r\n\r\n    /* ---------- Variables */\r\n\r\n    /* --- ERC-20 variables */\r\n\r\n    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md#name\r\n    // function name() constant returns (string name)\r\n    string public name = \"deex\";\r\n\r\n    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md#symbol\r\n    // function symbol() constant returns (string symbol)\r\n    string public symbol = \"deex\";\r\n\r\n    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md#decimals\r\n    // function decimals() constant returns (uint8 decimals)\r\n    uint8 public decimals = 0;\r\n\r\n    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md#totalsupply\r\n    // function totalSupply() constant returns (uint256 totalSupply)\r\n    // we start with zero and will create tokens as SC receives ETH\r\n    uint256 public totalSupply;\r\n\r\n    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md#balanceof\r\n    // function balanceOf(address _owner) constant returns (uint256 balance)\r\n    mapping (address => uint256) public balanceOf;\r\n\r\n    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md#allowance\r\n    // function allowance(address _owner, address _spender) constant returns (uint256 remaining)\r\n    mapping (address => mapping (address => uint256)) public allowance;\r\n\r\n    /* ----- For tokens sale */\r\n\r\n    uint256 public salesCounter = 0;\r\n\r\n    uint256 public maxSalesAllowed;\r\n\r\n    bool private transfersBetweenSalesAllowed;\r\n\r\n    // initial value should be changed by the owner\r\n    uint256 public tokenPriceInWei = 0;\r\n\r\n    uint256 public saleStartUnixTime = 0; // block.timestamp\r\n    uint256 public saleEndUnixTime = 0;  // block.timestamp\r\n\r\n    /* --- administrative */\r\n    address public owner;\r\n\r\n    // account that can set prices\r\n    address public priceSetter;\r\n\r\n    // 0 - not set\r\n    uint256 private priceMaxWei = 0;\r\n    // 0 - not set\r\n    uint256 private priceMinWei = 0;\r\n\r\n    // accounts holding tokens for for the team, for advisers and for the bounty campaign\r\n    mapping (address => bool) public isPreferredTokensAccount;\r\n\r\n    bool public contractInitialized = false;\r\n\r\n\r\n    /* ---------- Constructor */\r\n    // do not forget about:\r\n    // https://medium.com/@codetractio/a-look-into-paritys-multisig-wallet-bug-affecting-100-million-in-ether-and-tokens-356f5ba6e90a\r\n    constructor () public {\r\n        owner = msg.sender;\r\n\r\n        // for testNet can be more than 2\r\n        // --------------------------------2------------------------------------------------------change  in production!\r\n        maxSalesAllowed = 2;\r\n        //\r\n        transfersBetweenSalesAllowed = true;\r\n    }\r\n\r\n\r\n    function initContract(address team, address advisers, address bounty) public onlyBy(owner) returns (bool){\r\n\r\n        require(contractInitialized == false);\r\n        contractInitialized = true;\r\n\r\n        priceSetter = msg.sender;\r\n\r\n        totalSupply = 100000000;\r\n\r\n        // tokens for sale go SC own account\r\n        balanceOf[address(this)] = 75000000;\r\n\r\n        // for the team\r\n        balanceOf[team] = balanceOf[team] + 15000000;\r\n        isPreferredTokensAccount[team] = true;\r\n\r\n        // for advisers\r\n        balanceOf[advisers] = balanceOf[advisers] + 7000000;\r\n        isPreferredTokensAccount[advisers] = true;\r\n\r\n        // for the bounty campaign\r\n        balanceOf[bounty] = balanceOf[bounty] + 3000000;\r\n        isPreferredTokensAccount[bounty] = true;\r\n\r\n    }\r\n\r\n    /* ---------- Events */\r\n\r\n    /* --- ERC-20 events */\r\n    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md#events\r\n\r\n    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md#transfer-1\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md#approval\r\n    event Approval(address indexed _owner, address indexed spender, uint256 value);\r\n\r\n    /* --- Administrative events:  */\r\n    event OwnerChanged(address indexed oldOwner, address indexed newOwner);\r\n\r\n    /* ---- Tokens creation and sale events  */\r\n\r\n    event PriceChanged(uint256 indexed newTokenPriceInWei);\r\n\r\n    event SaleStarted(uint256 startUnixTime, uint256 endUnixTime, uint256 indexed saleNumber);\r\n\r\n    event NewTokensSold(uint256 numberOfTokens, address indexed purchasedBy, uint256 indexed priceInWei);\r\n\r\n    event Withdrawal(address indexed to, uint sumInWei);\r\n\r\n    /* --- Interaction with other contracts events  */\r\n    event DataSentToAnotherContract(address indexed _from, address indexed _toContract, bytes _extraData);\r\n\r\n    /* ---------- Functions */\r\n\r\n    /* --- Modifiers  */\r\n    modifier onlyBy(address _account){\r\n        require(msg.sender == _account);\r\n\r\n        _;\r\n    }\r\n\r\n    /* --- ERC-20 Functions */\r\n    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md#methods\r\n\r\n    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md#transfer\r\n    function transfer(address _to, uint256 _value) public returns (bool){\r\n        return transferFrom(msg.sender, _to, _value);\r\n    }\r\n\r\n    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md#transferfrom\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool){\r\n\r\n        // transfers are possible only after sale is finished\r\n        // except for manager and preferred accounts\r\n\r\n        bool saleFinished = saleIsFinished();\r\n        require(saleFinished || msg.sender == owner || isPreferredTokensAccount[msg.sender]);\r\n\r\n        // transfers can be forbidden until final ICO is finished\r\n        // except for manager and preferred accounts\r\n        require(transfersBetweenSalesAllowed || salesCounter == maxSalesAllowed || msg.sender == owner || isPreferredTokensAccount[msg.sender]);\r\n\r\n        // Transfers of 0 values MUST be treated as normal transfers and fire the Transfer event (ERC-20)\r\n        require(_value >= 0);\r\n\r\n        // The function SHOULD throw unless the _from account has deliberately authorized the sender of the message via some mechanism\r\n        require(msg.sender == _from || _value <= allowance[_from][msg.sender]);\r\n\r\n        // check if _from account have required amount\r\n        require(_value <= balanceOf[_from]);\r\n\r\n        // Subtract from the sender\r\n        balanceOf[_from] = balanceOf[_from] - _value;\r\n        //\r\n        // Add the same to the recipient\r\n        balanceOf[_to] = balanceOf[_to] + _value;\r\n\r\n        // If allowance used, change allowances correspondingly\r\n        if (_from != msg.sender) {\r\n            allowance[_from][msg.sender] = allowance[_from][msg.sender] - _value;\r\n        }\r\n\r\n        // event\r\n        emit Transfer(_from, _to, _value);\r\n\r\n        return true;\r\n    }\r\n\r\n    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md#approve\r\n    // there is and attack, see:\r\n    // https://github.com/CORIONplatform/solidity/issues/6,\r\n    // https://drive.google.com/file/d/0ByMtMw2hul0EN3NCaVFHSFdxRzA/view\r\n    // but this function is required by ERC-20\r\n    function approve(address _spender, uint256 _value) public returns (bool success){\r\n\r\n        require(_value >= 0);\r\n\r\n        allowance[msg.sender][_spender] = _value;\r\n\r\n        // event\r\n        emit Approval(msg.sender, _spender, _value);\r\n\r\n        return true;\r\n    }\r\n\r\n    /*  ---------- Interaction with other contracts  */\r\n\r\n    /* User can allow another smart contract to spend some shares in his behalf\r\n    *  (this function should be called by user itself)\r\n    *  @param _spender another contract's address\r\n    *  @param _value number of tokens\r\n    *  @param _extraData Data that can be sent from user to another contract to be processed\r\n    *  bytes - dynamically-sized byte array,\r\n    *  see http://solidity.readthedocs.io/en/v0.4.15/types.html#dynamically-sized-byte-array\r\n    *  see possible attack information in comments to function 'approve'\r\n    *  > this may be used to convert pre-ICO tokens to ICO tokens\r\n    */\r\n    function approveAndCall(address _spender, uint256 _value, bytes memory _extraData) public returns (bool success) {\r\n\r\n        approve(_spender, _value);\r\n\r\n        // 'spender' is another contract that implements code as prescribed in 'allowanceRecipient' above\r\n        allowanceRecipient spender = allowanceRecipient(_spender);\r\n\r\n        // our contract calls 'receiveApproval' function of another contract ('allowanceRecipient') to send information about\r\n        // allowance and data sent by user\r\n        // 'this' is this (our) contract address\r\n        if (spender.receiveApproval(msg.sender, _value, address(this), _extraData)) {\r\n            emit DataSentToAnotherContract(msg.sender, _spender, _extraData);\r\n            return true;\r\n        }\r\n        else return false;\r\n    }\r\n\r\n    function approveAllAndCall(address _spender, bytes memory _extraData) public returns (bool success) {\r\n        return approveAndCall(_spender, balanceOf[msg.sender], _extraData);\r\n    }\r\n\r\n    /* https://github.com/ethereum/EIPs/issues/677\r\n    * transfer tokens with additional info to another smart contract, and calls its correspondent function\r\n    * @param address _to - another smart contract address\r\n    * @param uint256 _value - number of tokens\r\n    * @param bytes _extraData - data to send to another contract\r\n    * > this may be used to convert pre-ICO tokens to ICO tokens\r\n    */\r\n    function transferAndCall(address _to, uint256 _value, bytes memory _extraData) public returns (bool success){\r\n\r\n        transferFrom(msg.sender, _to, _value);\r\n\r\n        tokenRecipient receiver = tokenRecipient(_to);\r\n\r\n        if (receiver.tokenFallback(msg.sender, _value, _extraData)) {\r\n            emit DataSentToAnotherContract(msg.sender, _to, _extraData);\r\n            return true;\r\n        }\r\n        else return false;\r\n    }\r\n\r\n    // for example for conveting ALL tokens of user account to another tokens\r\n    function transferAllAndCall(address _to, bytes memory _extraData) public returns (bool success){\r\n        return transferAndCall(_to, balanceOf[msg.sender], _extraData);\r\n    }\r\n\r\n    /* --- Administrative functions */\r\n\r\n    function changeOwner(address _newOwner) public onlyBy(owner) returns (bool success){\r\n        //\r\n        require(_newOwner != address(0));\r\n\r\n        address oldOwner = owner;\r\n        owner = _newOwner;\r\n\r\n        emit OwnerChanged(oldOwner, _newOwner);\r\n\r\n        return true;\r\n    }\r\n\r\n    /* ---------- Create and sell tokens  */\r\n\r\n    /* set time for start and time for end pre-ICO\r\n    * time is integer representing block timestamp\r\n    * in UNIX Time,\r\n    * see: https://www.epochconverter.com\r\n    * @param uint256 startTime - time to start\r\n    * @param uint256 endTime - time to end\r\n    * should be taken into account that\r\n    * \"block.timestamp\" can be influenced by miners to a certain degree.\r\n    * That means that a miner can \"choose\" the block.timestamp, to a certain degree,\r\n    * to change the outcome of a transaction in the mined block.\r\n    * see:\r\n    * http://solidity.readthedocs.io/en/v0.4.15/frequently-asked-questions.html#are-timestamps-now-block-timestamp-reliable\r\n    */\r\n\r\n    function startSale(uint256 _startUnixTime, uint256 _endUnixTime) public onlyBy(owner) returns (bool success){\r\n\r\n        require(balanceOf[address(this)] > 0);\r\n        require(salesCounter < maxSalesAllowed);\r\n\r\n        // time for sale can be set only if:\r\n        // this is first sale (saleStartUnixTime == 0 && saleEndUnixTime == 0) , or:\r\n        // previous sale finished ( saleIsFinished() )\r\n        require(\r\n            (saleStartUnixTime == 0 && saleEndUnixTime == 0) || saleIsFinished()\r\n        );\r\n        // time can be set only for future\r\n        require(_startUnixTime > now && _endUnixTime > now);\r\n        // end time should be later than start time\r\n        require(_endUnixTime - _startUnixTime > 0);\r\n\r\n        saleStartUnixTime = _startUnixTime;\r\n        saleEndUnixTime = _endUnixTime;\r\n        salesCounter = salesCounter + 1;\r\n\r\n        emit SaleStarted(_startUnixTime, _endUnixTime, salesCounter);\r\n\r\n        return true;\r\n    }\r\n\r\n    function saleIsRunning() public view returns (bool){\r\n\r\n        if (balanceOf[address(this)] == 0) {\r\n            return false;\r\n        }\r\n\r\n        if (saleStartUnixTime == 0 && saleEndUnixTime == 0) {\r\n            return false;\r\n        }\r\n\r\n        if (now > saleStartUnixTime && now < saleEndUnixTime) {\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    function saleIsFinished() public view returns (bool){\r\n\r\n        if (balanceOf[address(this)] == 0) {\r\n            return true;\r\n        }\r\n\r\n        else if (\r\n            (saleStartUnixTime > 0 && saleEndUnixTime > 0)\r\n            && now > saleEndUnixTime) {\r\n\r\n            return true;\r\n        }\r\n\r\n        // <<<\r\n        return true;\r\n    }\r\n\r\n    function changePriceSetter(address _priceSetter) public onlyBy(owner) returns (bool success) {\r\n        priceSetter = _priceSetter;\r\n        return true;\r\n    }\r\n\r\n    function setMinMaxPriceInWei(uint256 _priceMinWei, uint256 _priceMaxWei) public onlyBy(owner) returns (bool success){\r\n        require(_priceMinWei >= 0 && _priceMaxWei >= 0);\r\n        priceMinWei = _priceMinWei;\r\n        priceMaxWei = _priceMaxWei;\r\n        return true;\r\n    }\r\n\r\n\r\n    function setTokenPriceInWei(uint256 _priceInWei) public onlyBy(priceSetter) returns (bool success){\r\n\r\n        require(_priceInWei >= 0);\r\n\r\n        // if 0 - not set\r\n        if (priceMinWei != 0 && _priceInWei < priceMinWei) {\r\n            tokenPriceInWei = priceMinWei;\r\n        }\r\n        else if (priceMaxWei != 0 && _priceInWei > priceMaxWei) {\r\n            tokenPriceInWei = priceMaxWei;\r\n        }\r\n        else {\r\n            tokenPriceInWei = _priceInWei;\r\n        }\r\n\r\n        emit PriceChanged(tokenPriceInWei);\r\n\r\n        return true;\r\n    }\r\n\r\n    // allows sending ether and receiving tokens just using contract address\r\n    // warning:\r\n    // 'If the fallback function requires more than 2300 gas, the contract cannot receive Ether'\r\n    // see:\r\n    // https://ethereum.stackexchange.com/questions/21643/fallback-function-best-practices-when-registering-information\r\n    function() external payable {\r\n        buyTokens();\r\n    }\r\n\r\n    //\r\n    function buyTokens() public payable returns (bool success){\r\n\r\n        if (saleIsRunning() && tokenPriceInWei > 0) {\r\n\r\n            uint256 numberOfTokens = msg.value / tokenPriceInWei;\r\n\r\n            if (numberOfTokens <= balanceOf[address(this)]) {\r\n\r\n                balanceOf[msg.sender] = balanceOf[msg.sender] + numberOfTokens;\r\n                balanceOf[address(this)] = balanceOf[address(this)] - numberOfTokens;\r\n\r\n                emit NewTokensSold(numberOfTokens, msg.sender, tokenPriceInWei);\r\n\r\n                return true;\r\n            }\r\n            else {\r\n                // (payable)\r\n                revert();\r\n            }\r\n        }\r\n        else {\r\n            // (payable)\r\n            revert();\r\n        }\r\n    }\r\n\r\n    /*  After sale contract owner\r\n    *  (can be another contract or account)\r\n    *  can withdraw all collected Ether\r\n    */\r\n    function withdrawAllToOwner() public onlyBy(owner) returns (bool) {\r\n\r\n        // only after sale is finished:\r\n        require(saleIsFinished());\r\n        uint256 sumInWei = address(this).balance;\r\n\r\n        if (\r\n        // makes withdrawal and returns true or false\r\n            !msg.sender.send(address(this).balance)\r\n        ) {\r\n            return false;\r\n        }\r\n        else {\r\n            // event\r\n            emit Withdrawal(msg.sender, sumInWei);\r\n            return true;\r\n        }\r\n    }\r\n\r\n    /* ---------- Referral System */\r\n\r\n    // list of registered referrers\r\n    // represented by keccak256(address) (returns bytes32)\r\n    // ! referrers can not be removed !\r\n    mapping (bytes32 => bool) private isReferrer;\r\n\r\n    uint256 private referralBonus = 0;\r\n\r\n    uint256 private referrerBonus = 0;\r\n    // tokens owned by referrers:\r\n    mapping (bytes32 => uint256) public referrerBalanceOf;\r\n\r\n    mapping (bytes32 => uint) public referrerLinkedSales;\r\n\r\n    function addReferrer(bytes32 _referrer) public onlyBy(owner) returns (bool success){\r\n        isReferrer[_referrer] = true;\r\n        return true;\r\n    }\r\n\r\n    function removeReferrer(bytes32 _referrer) public onlyBy(owner) returns (bool success){\r\n        isReferrer[_referrer] = false;\r\n        return true;\r\n    }\r\n\r\n    // bonuses are set in as integers (20%, 30%), initial 0%\r\n    function setReferralBonuses(uint256 _referralBonus, uint256 _referrerBonus) public onlyBy(owner) returns (bool success){\r\n        require(_referralBonus > 0 && _referrerBonus > 0);\r\n        referralBonus = _referralBonus;\r\n        referrerBonus = _referrerBonus;\r\n        return true;\r\n    }\r\n\r\n    function buyTokensWithReferrerAddress(address _referrer) public payable returns (bool success){\r\n\r\n        bytes32 referrer = keccak256(abi.encodePacked(_referrer));\r\n\r\n        if (saleIsRunning() && tokenPriceInWei > 0) {\r\n\r\n            if (isReferrer[referrer]) {\r\n\r\n                uint256 numberOfTokens = msg.value / tokenPriceInWei;\r\n\r\n                if (numberOfTokens <= balanceOf[address(this)]) {\r\n\r\n                    referrerLinkedSales[referrer] = referrerLinkedSales[referrer] + numberOfTokens;\r\n\r\n                    uint256 referralBonusTokens = (numberOfTokens * (100 + referralBonus) / 100) - numberOfTokens;\r\n                    uint256 referrerBonusTokens = (numberOfTokens * (100 + referrerBonus) / 100) - numberOfTokens;\r\n\r\n                    balanceOf[address(this)] = balanceOf[address(this)] - numberOfTokens - referralBonusTokens - referrerBonusTokens;\r\n\r\n                    balanceOf[msg.sender] = balanceOf[msg.sender] + (numberOfTokens + referralBonusTokens);\r\n\r\n                    referrerBalanceOf[referrer] = referrerBalanceOf[referrer] + referrerBonusTokens;\r\n\r\n                    emit NewTokensSold(numberOfTokens + referralBonusTokens, msg.sender, tokenPriceInWei);\r\n\r\n                    return true;\r\n                }\r\n                else {\r\n                    // (payable)\r\n                    revert();\r\n                }\r\n            }\r\n            else {\r\n                // (payable)\r\n                buyTokens();\r\n            }\r\n        }\r\n        else {\r\n            // (payable)\r\n            revert();\r\n        }\r\n    }\r\n\r\n    event ReferrerBonusTokensTaken(address referrer, uint256 bonusTokensValue);\r\n\r\n    function getReferrerBonusTokens() public returns (bool success){\r\n        require(saleIsFinished());\r\n        uint256 bonusTokens = referrerBalanceOf[keccak256(abi.encodePacked(msg.sender))];\r\n        balanceOf[msg.sender] = balanceOf[msg.sender] + bonusTokens;\r\n        emit ReferrerBonusTokensTaken(msg.sender, bonusTokens);\r\n        return true;\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Unsigned math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Multiplies two unsigned integers, reverts on overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Adds two unsigned integers, reverts on overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\r\n     * reverts when dividing by zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n\r\ncontract Ownable {\r\n    address payable public owner;\r\n    /**\r\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n     * account.\r\n     */\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n    function transferOwnership(address payable newOwner) public onlyOwner {\r\n        require(newOwner != address(0));\r\n        owner = newOwner;\r\n    }\r\n}\r\n\r\n\r\n/*\r\n* @title Bank\r\n* @dev Bank contract which contained all ETH from Dragons and Hamsters teams.\r\n* When time in blockchain will be grater then current deadline or last deadline need call getWinner function\r\n* then participants able get prizes.\r\n*\r\n* Last participant(last hero) win 10% from all bank\r\n*\r\n* - To get prize send 0 ETH to this contract\r\n*/\r\ncontract Bank is Ownable {\r\n\r\n    using SafeMath for uint256;\r\n\r\n    mapping (uint256 => mapping (address => uint256)) public depositDragons;\r\n    mapping (uint256 => mapping (address => uint256)) public depositHamsters;\r\n\r\n    address payable public team = 0x7De1eFb9E5035784FB931433c8a884588929338E;\r\n\r\n    uint256 public currentDeadline;\r\n    uint256 public currentRound = 1;\r\n    uint256 public lastDeadline;\r\n    uint256 public defaultCurrentDeadlineInHours = 24;\r\n    uint256 public defaultLastDeadlineInHours = 48;\r\n    uint256 public countOfDragons;\r\n    uint256 public countOfHamsters;\r\n    uint256 public totalSupplyOfHamsters;\r\n    uint256 public totalSupplyOfDragons;\r\n    uint256 public totalDeexSupplyOfHamsters;\r\n    uint256 public totalDeexSupplyOfDragons;\r\n    uint256 public probabilityOfHamsters;\r\n    uint256 public probabilityOfDragons;\r\n    address public lastHero;\r\n    address public lastHeroHistory;\r\n    uint256 public jackPot;\r\n    uint256 public winner;\r\n    uint256 public withdrawn;\r\n    uint256 public withdrawnDeex;\r\n    uint256 public remainder;\r\n    uint256 public remainderDeex;\r\n    uint256 public rate = 1;\r\n    uint256 public rateModifier = 0;\r\n    uint256 public tokenReturn;\r\n\r\n    uint256 public lastTotalSupplyOfHamsters;\r\n    uint256 public lastTotalSupplyOfDragons;\r\n    uint256 public lastTotalDeexSupplyOfHamsters;\r\n    uint256 public lastTotalDeexSupplyOfDragons;\r\n    uint256 public lastProbabilityOfHamsters;\r\n    uint256 public lastProbabilityOfDragons;\r\n    address public lastRoundHero;\r\n    uint256 public lastJackPot;\r\n    uint256 public lastWinner;\r\n    uint256 public lastBalance;\r\n    uint256 public lastBalanceDeex;\r\n    uint256 public lastCountOfDragons;\r\n    uint256 public lastCountOfHamsters;\r\n    uint256 public lastWithdrawn;\r\n    uint256 public lastWithdrawnDeex;\r\n\r\n\r\n    bool public finished = false;\r\n\r\n    Dragons public DragonsContract;\r\n    Hamsters public HamstersContract;\r\n    DEEX public DEEXContract;\r\n\r\n    /**\r\n    * @dev Setter token rate.\r\n    * @param _rate this value for change percent relation rate to count of tokens.\r\n    * @param _rateModifier this value for change math operation under tokens.\r\n    */\r\n    function setRateToken(uint256 _rate, uint256 _rateModifier) public onlyOwner returns(uint256){\r\n        rate = _rate;\r\n        rateModifier = _rateModifier;\r\n    }\r\n\r\n    /**\r\n    * @dev Setter round time.\r\n    * @param _currentDeadlineInHours this value current deadline in hours.\r\n    * @param _lastDeadlineInHours this value last deadline in hours.\r\n    */\r\n    function _setRoundTime(uint _currentDeadlineInHours, uint _lastDeadlineInHours) internal {\r\n        defaultCurrentDeadlineInHours = _currentDeadlineInHours;\r\n        defaultLastDeadlineInHours = _lastDeadlineInHours;\r\n        currentDeadline = block.timestamp + 60 * 60 * _currentDeadlineInHours;\r\n        lastDeadline = block.timestamp + 60 * 60 * _lastDeadlineInHours;\r\n    }\r\n\r\n    /**\r\n    * @dev Setter round time.\r\n    * @param _currentDeadlineInHours this value current deadline in hours.\r\n    * @param _lastDeadlineInHours this value last deadline in hours.\r\n    */\r\n    function setRoundTime(uint _currentDeadlineInHours, uint _lastDeadlineInHours) public onlyOwner {\r\n        _setRoundTime(_currentDeadlineInHours, _lastDeadlineInHours);\r\n    }\r\n\r\n\r\n    /**\r\n    * @dev Setter the DEEX contract address. Address can be set at once.\r\n    * @param _DEEXAddress Address of the DEEX contract\r\n    */\r\n    function setDEEXAddress(address payable _DEEXAddress) public {\r\n        require(address(DEEXContract) == address(0x0));\r\n        DEEXContract = DEEX(_DEEXAddress);\r\n    }\r\n\r\n    /**\r\n    * @dev Setter the Dragons contract address. Address can be set at once.\r\n    * @param _DragonsAddress Address of the Dragons contract\r\n    */\r\n    function setDragonsAddress(address payable _DragonsAddress) external {\r\n        require(address(DragonsContract) == address(0x0));\r\n        DragonsContract = Dragons(_DragonsAddress);\r\n    }\r\n\r\n    /**\r\n    * @dev Setter the Hamsters contract address. Address can be set at once.\r\n    * @param _HamstersAddress Address of the Hamsters contract\r\n    */\r\n    function setHamstersAddress(address payable _HamstersAddress) external {\r\n        require(address(HamstersContract) == address(0x0));\r\n        HamstersContract = Hamsters(_HamstersAddress);\r\n    }\r\n\r\n    /**\r\n    * @dev Getting time from blockchain for timer\r\n    */\r\n    function getNow() view public returns(uint){\r\n        return block.timestamp;\r\n    }\r\n\r\n    /**\r\n    * @dev Getting state of game. True - game continue, False - game stopped\r\n    */\r\n    function getState() view public returns(bool) {\r\n        if (block.timestamp > currentDeadline) {\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev Setting info about participant from Dragons or Hamsters contract\r\n    * @param _lastHero Address of participant\r\n    * @param _deposit Amount of deposit\r\n    */\r\n    function setInfo(address _lastHero, uint256 _deposit) public {\r\n        require(address(DragonsContract) == msg.sender || address(HamstersContract) == msg.sender);\r\n\r\n        if (address(DragonsContract) == msg.sender) {\r\n            require(depositHamsters[currentRound][_lastHero] == 0, \"You are already in Hamsters team\");\r\n            if (depositDragons[currentRound][_lastHero] == 0)\r\n                countOfDragons++;\r\n            totalSupplyOfDragons = totalSupplyOfDragons.add(_deposit.mul(90).div(100));\r\n            depositDragons[currentRound][_lastHero] = depositDragons[currentRound][_lastHero].add(_deposit.mul(90).div(100));\r\n        }\r\n\r\n        if (address(HamstersContract) == msg.sender) {\r\n            require(depositDragons[currentRound][_lastHero] == 0, \"You are already in Dragons team\");\r\n            if (depositHamsters[currentRound][_lastHero] == 0)\r\n                countOfHamsters++;\r\n            totalSupplyOfHamsters = totalSupplyOfHamsters.add(_deposit.mul(90).div(100));\r\n            depositHamsters[currentRound][_lastHero] = depositHamsters[currentRound][_lastHero].add(_deposit.mul(90).div(100));\r\n        }\r\n\r\n        lastHero = _lastHero;\r\n\r\n        if (currentDeadline.add(120) <= lastDeadline) {\r\n            currentDeadline = currentDeadline.add(120);\r\n        } else {\r\n            currentDeadline = lastDeadline;\r\n        }\r\n\r\n        jackPot += _deposit.mul(10).div(100);\r\n\r\n        calculateProbability();\r\n    }\r\n\r\n    function estimateTokenPercent(uint256 _difference) public view returns(uint256){\r\n        if (rateModifier == 0) {\r\n            return _difference.mul(rate);\r\n        } else {\r\n            return _difference.div(rate);\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Calculation probability for team's win\r\n    */\r\n    function calculateProbability() public {\r\n        require(winner == 0 && getState());\r\n\r\n        totalDeexSupplyOfHamsters = DEEXContract.balanceOf(address(HamstersContract));\r\n        totalDeexSupplyOfDragons = DEEXContract.balanceOf(address(DragonsContract));\r\n        uint256 percent = (totalSupplyOfHamsters.add(totalSupplyOfDragons)).div(100);\r\n\r\n        if (totalDeexSupplyOfHamsters < 1) {\r\n            totalDeexSupplyOfHamsters = 0;\r\n        }\r\n\r\n        if (totalDeexSupplyOfDragons < 1) {\r\n            totalDeexSupplyOfDragons = 0;\r\n        }\r\n\r\n        if (totalDeexSupplyOfHamsters <= totalDeexSupplyOfDragons) {\r\n            uint256 difference = totalDeexSupplyOfDragons.sub(totalDeexSupplyOfHamsters).mul(100);\r\n            probabilityOfDragons = totalSupplyOfDragons.mul(100).div(percent).add(estimateTokenPercent(difference));\r\n  \r\n            if (probabilityOfDragons > 8000) {\r\n                probabilityOfDragons = 8000;\r\n            }\r\n            if (probabilityOfDragons < 2000) {\r\n                probabilityOfDragons = 2000;\r\n            }\r\n            probabilityOfHamsters = 10000 - probabilityOfDragons;\r\n        } else {\r\n            uint256 difference = totalDeexSupplyOfHamsters.sub(totalDeexSupplyOfDragons).mul(100);\r\n            probabilityOfHamsters = totalSupplyOfHamsters.mul(100).div(percent).add(estimateTokenPercent(difference));\r\n\r\n            if (probabilityOfHamsters > 8000) {\r\n                probabilityOfHamsters = 8000;\r\n            }\r\n            if (probabilityOfHamsters < 2000) {\r\n                probabilityOfHamsters = 2000;\r\n            }\r\n            probabilityOfDragons = 10000 - probabilityOfHamsters;\r\n        }\r\n\r\n        totalDeexSupplyOfHamsters = DEEXContract.balanceOf(address(HamstersContract));\r\n        totalDeexSupplyOfDragons = DEEXContract.balanceOf(address(DragonsContract));\r\n    }\r\n\r\n    /**\r\n    * @dev Getting winner team\r\n    */\r\n    function getWinners() public {\r\n        require(winner == 0 && !getState());\r\n        uint256 seed1 = address(this).balance;\r\n        uint256 seed2 = totalSupplyOfHamsters;\r\n        uint256 seed3 = totalSupplyOfDragons;\r\n        uint256 seed4 = totalDeexSupplyOfHamsters;\r\n        uint256 seed5 = totalDeexSupplyOfHamsters;\r\n        uint256 seed6 = block.difficulty;\r\n        uint256 seed7 = block.timestamp;\r\n\r\n        bytes32 randomHash = keccak256(abi.encodePacked(seed1, seed2, seed3, seed4, seed5, seed6, seed7));\r\n        uint randomNumber = uint(randomHash);\r\n\r\n        if (randomNumber == 0){\r\n            randomNumber = 1;\r\n        }\r\n\r\n        uint winningNumber = randomNumber % 10000;\r\n\r\n        if (1 <= winningNumber && winningNumber <= probabilityOfDragons){\r\n            winner = 1;\r\n        }\r\n\r\n        if (probabilityOfDragons < winningNumber && winningNumber <= 10000){\r\n            winner = 2;\r\n        }\r\n\r\n        if (DEEXContract.balanceOf(address(HamstersContract)) > 0)\r\n            DEEXContract.transferFrom(\r\n                address(HamstersContract),\r\n                address(this),\r\n                DEEXContract.balanceOf(address(HamstersContract))\r\n            );\r\n\r\n        if (DEEXContract.balanceOf(address(DragonsContract)) > 0)\r\n            DEEXContract.transferFrom(\r\n                address(DragonsContract),\r\n                address(this),\r\n                DEEXContract.balanceOf(address(DragonsContract))\r\n            );\r\n\r\n        lastTotalSupplyOfHamsters = totalSupplyOfHamsters;\r\n        lastTotalSupplyOfDragons = totalSupplyOfDragons;\r\n        lastTotalDeexSupplyOfDragons = totalDeexSupplyOfDragons;\r\n        lastTotalDeexSupplyOfHamsters = totalDeexSupplyOfHamsters;\r\n        lastRoundHero = lastHero;\r\n        lastJackPot = jackPot;\r\n        lastWinner = winner;\r\n        lastCountOfDragons = countOfDragons;\r\n        lastCountOfHamsters = countOfHamsters;\r\n        lastWithdrawn = withdrawn;\r\n        lastWithdrawnDeex = withdrawnDeex;\r\n\r\n        if (lastBalance > lastWithdrawn){\r\n            remainder = lastBalance.sub(lastWithdrawn);\r\n           team.transfer(remainder);\r\n        }\r\n\r\n        lastBalance = lastTotalSupplyOfDragons.add(lastTotalSupplyOfHamsters).add(lastJackPot);\r\n\r\n        if (lastBalanceDeex > lastWithdrawnDeex){\r\n            remainderDeex = lastBalanceDeex.sub(lastWithdrawnDeex);\r\n            tokenReturn = (totalDeexSupplyOfDragons.add(totalDeexSupplyOfHamsters)).mul(20).div(100).add(remainderDeex);\r\n            DEEXContract.transfer(team, tokenReturn);\r\n        }\r\n\r\n        lastBalanceDeex = DEEXContract.balanceOf(address(this));\r\n\r\n        totalSupplyOfHamsters = 0;\r\n        totalSupplyOfDragons = 0;\r\n        totalDeexSupplyOfHamsters = 0;\r\n        totalDeexSupplyOfDragons = 0;\r\n        remainder = 0;\r\n        remainderDeex = 0;\r\n        jackPot = 0;\r\n\r\n        withdrawn = 0;\r\n        winner = 0;\r\n        withdrawnDeex = 0;\r\n        countOfDragons = 0;\r\n        countOfHamsters = 0;\r\n        probabilityOfHamsters = 0;\r\n        probabilityOfDragons = 0;\r\n\r\n        _setRoundTime(defaultCurrentDeadlineInHours, defaultLastDeadlineInHours);\r\n        currentRound++;\r\n    }\r\n\r\n    /**\r\n    * @dev Payable function for take prize\r\n    */\r\n    function () external payable {\r\n        if (msg.value == 0){\r\n            require(depositDragons[currentRound - 1][msg.sender] > 0 || depositHamsters[currentRound - 1][msg.sender] > 0);\r\n\r\n            uint payout = 0;\r\n            uint payoutDeex = 0;\r\n\r\n            if (lastWinner == 1 && depositDragons[currentRound - 1][msg.sender] > 0) {\r\n                payout = calculateLastETHPrize(msg.sender);\r\n            }\r\n            if (lastWinner == 2 && depositHamsters[currentRound - 1][msg.sender] > 0) {\r\n                payout = calculateLastETHPrize(msg.sender);\r\n            }\r\n\r\n            if (payout > 0) {\r\n                depositDragons[currentRound - 1][msg.sender] = 0;\r\n                depositHamsters[currentRound - 1][msg.sender] = 0;\r\n                withdrawn = withdrawn.add(payout);\r\n                msg.sender.transfer(payout);\r\n            }\r\n\r\n            if ((lastWinner == 1 && depositDragons[currentRound - 1][msg.sender] == 0) || (lastWinner == 2 && depositHamsters[currentRound - 1][msg.sender] == 0)) {\r\n                payoutDeex = calculateLastDeexPrize(msg.sender);\r\n                withdrawnDeex = withdrawnDeex.add(payoutDeex);\r\n                DEEXContract.transfer(msg.sender, payoutDeex);\r\n            }\r\n\r\n            if (msg.sender == lastRoundHero) {\r\n                lastHeroHistory = lastRoundHero;\r\n                lastRoundHero = address(0x0);\r\n                withdrawn = withdrawn.add(lastJackPot);\r\n                msg.sender.transfer(lastJackPot);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Getting ETH prize of participant\r\n    * @param participant Address of participant\r\n    */\r\n    function calculateETHPrize(address participant) public view returns(uint) {\r\n\r\n        uint payout = 0;\r\n        uint256 totalSupply = (totalSupplyOfDragons.add(totalSupplyOfHamsters));\r\n\r\n        if (depositDragons[currentRound][participant] > 0) {\r\n            payout = totalSupply.mul(depositDragons[currentRound][participant]).div(totalSupplyOfDragons);\r\n        }\r\n\r\n        if (depositHamsters[currentRound][participant] > 0) {\r\n            payout = totalSupply.mul(depositHamsters[currentRound][participant]).div(totalSupplyOfHamsters);\r\n        }\r\n\r\n        return payout;\r\n    }\r\n\r\n    /**\r\n    * @dev Getting Deex Token prize of participant\r\n    * @param participant Address of participant\r\n    */\r\n    function calculateDeexPrize(address participant) public view returns(uint) {\r\n\r\n        uint payout = 0;\r\n        uint totalSupply = (totalDeexSupplyOfDragons.add(totalDeexSupplyOfHamsters)).mul(80).div(100);\r\n\r\n        if (depositDragons[currentRound][participant] > 0) {\r\n            payout = totalSupply.mul(depositDragons[currentRound][participant]).div(totalSupplyOfDragons);\r\n        }\r\n\r\n        if (depositHamsters[currentRound][participant] > 0) {\r\n            payout = totalSupply.mul(depositHamsters[currentRound][participant]).div(totalSupplyOfHamsters);\r\n        }\r\n\r\n        return payout;\r\n    }\r\n\r\n    /**\r\n    * @dev Getting ETH prize of _lastParticipant\r\n    * @param _lastParticipant Address of _lastParticipant\r\n    */\r\n    function calculateLastETHPrize(address _lastParticipant) public view returns(uint) {\r\n\r\n        uint payout = 0;\r\n        uint256 totalSupply = (lastTotalSupplyOfDragons.add(lastTotalSupplyOfHamsters));\r\n\r\n        if (depositDragons[currentRound - 1][_lastParticipant] > 0) {\r\n            payout = totalSupply.mul(depositDragons[currentRound - 1][_lastParticipant]).div(lastTotalSupplyOfDragons);\r\n        }\r\n\r\n        if (depositHamsters[currentRound - 1][_lastParticipant] > 0) {\r\n            payout = totalSupply.mul(depositHamsters[currentRound - 1][_lastParticipant]).div(lastTotalSupplyOfHamsters);\r\n        }\r\n\r\n        return payout;\r\n    }\r\n\r\n    /**\r\n    * @dev Getting Deex Token prize of _lastParticipant\r\n    * @param _lastParticipant Address of _lastParticipant\r\n    */\r\n    function calculateLastDeexPrize(address _lastParticipant) public view returns(uint) {\r\n\r\n        uint payout = 0;\r\n        uint totalSupply = (lastTotalDeexSupplyOfDragons.add(lastTotalDeexSupplyOfHamsters)).mul(80).div(100);\r\n\r\n        if (depositDragons[currentRound - 1][_lastParticipant] > 0) {\r\n            payout = totalSupply.mul(depositDragons[currentRound - 1][_lastParticipant]).div(lastTotalSupplyOfDragons);\r\n        }\r\n\r\n        if (depositHamsters[currentRound - 1][_lastParticipant] > 0) {\r\n            payout = totalSupply.mul(depositHamsters[currentRound - 1][_lastParticipant]).div(lastTotalSupplyOfHamsters);\r\n        }\r\n\r\n        return payout;\r\n    }\r\n}\r\n\r\n/**\r\n* @dev Base contract for teams\r\n*/\r\ncontract CryptoTeam {\r\n    using SafeMath for uint256;\r\n\r\n    Bank public BankContract;\r\n    DEEX public DEEXContract;\r\n    address payable public team = 0x7De1eFb9E5035784FB931433c8a884588929338E;\r\n\r\n    /**\r\n    * @dev Payable function. 10% will send to Developers fund and 90% will send to JackPot contract.\r\n    * Also setting info about player.\r\n    */\r\n    function () external payable {\r\n        require(BankContract.getState() && msg.value >= 0.05 ether);\r\n\r\n        BankContract.setInfo(msg.sender, msg.value.mul(90).div(100));\r\n\r\n        team.transfer(msg.value.mul(10).div(100));\r\n\r\n        address(BankContract).transfer(msg.value.mul(90).div(100));\r\n    }\r\n}\r\n\r\n/*\r\n* @dev Dragons contract. To play game with Dragons send ETH to this contract\r\n*/\r\ncontract Dragons is CryptoTeam {\r\n    constructor(address payable _bankAddress, address payable _DEEXAddress) public {\r\n        BankContract = Bank(_bankAddress);\r\n        BankContract.setDragonsAddress(address(this));\r\n        DEEXContract = DEEX(_DEEXAddress);\r\n        DEEXContract.approve(_bankAddress, 9999999999999999999000000000000000000);\r\n    }\r\n}\r\n\r\n/*\r\n* @dev Hamsters contract. To play game with Hamsters send ETH to this contract\r\n*/\r\ncontract Hamsters is CryptoTeam {\r\n    constructor(address payable _bankAddress, address payable _DEEXAddress) public {\r\n        BankContract = Bank(_bankAddress);\r\n        BankContract.setHamstersAddress(address(this));\r\n        DEEXContract = DEEX(_DEEXAddress);\r\n        DEEXContract.approve(_bankAddress, 9999999999999999999000000000000000000);\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"depositHamsters\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastTotalDeexSupplyOfDragons\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastCountOfDragons\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rateModifier\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"defaultCurrentDeadlineInHours\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getState\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastTotalDeexSupplyOfHamsters\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_HamstersAddress\",\"type\":\"address\"}],\"name\":\"setHamstersAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastCountOfHamsters\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"remainderDeex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"countOfDragons\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastRoundHero\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"probabilityOfDragons\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_difference\",\"type\":\"uint256\"}],\"name\":\"estimateTokenPercent\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_DragonsAddress\",\"type\":\"address\"}],\"name\":\"setDragonsAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"depositDragons\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupplyOfDragons\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalDeexSupplyOfDragons\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastWithdrawn\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_lastParticipant\",\"type\":\"address\"}],\"name\":\"calculateLastDeexPrize\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastWithdrawnDeex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"jackPot\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"participant\",\"type\":\"address\"}],\"name\":\"calculateDeexPrize\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"HamstersContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastHero\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"countOfHamsters\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastTotalSupplyOfHamsters\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentDeadline\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"DragonsContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"withdrawnDeex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"DEEXContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"team\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_DEEXAddress\",\"type\":\"address\"}],\"name\":\"setDEEXAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastDeadline\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentRound\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"participant\",\"type\":\"address\"}],\"name\":\"calculateETHPrize\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_lastHero\",\"type\":\"address\"},{\"name\":\"_deposit\",\"type\":\"uint256\"}],\"name\":\"setInfo\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"probabilityOfHamsters\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"remainder\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastProbabilityOfDragons\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"defaultLastDeadlineInHours\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastHeroHistory\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastProbabilityOfHamsters\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupplyOfHamsters\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_rate\",\"type\":\"uint256\"},{\"name\":\"_rateModifier\",\"type\":\"uint256\"}],\"name\":\"setRateToken\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getNow\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"finished\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"withdrawn\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"calculateProbability\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalDeexSupplyOfHamsters\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastTotalSupplyOfDragons\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastBalanceDeex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastJackPot\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenReturn\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"getWinners\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"winner\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_lastParticipant\",\"type\":\"address\"}],\"name\":\"calculateLastETHPrize\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_currentDeadlineInHours\",\"type\":\"uint256\"},{\"name\":\"_lastDeadlineInHours\",\"type\":\"uint256\"}],\"name\":\"setRoundTime\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastWinner\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"}]","ContractName":"Bank","CompilerVersion":"v0.5.6+commit.b259423e","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://120cb13c13253e6b43ed7b782bc7d7946bf1a80ce6ecab1335e399786f6807c9"}]}