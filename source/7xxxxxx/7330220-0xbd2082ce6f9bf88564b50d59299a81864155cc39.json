{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5;\r\n\r\ncontract ERC20xVariables {\r\n    address public creator;\r\n    address public lib;\r\n\r\n    uint256 constant public MAX_UINT256 = 2**256 - 1;\r\n    mapping(address => uint) public balances;\r\n    mapping(address => mapping(address => uint)) public allowed;\r\n\r\n    uint8 public constant decimals = 18;\r\n    string public name;\r\n    string public symbol;\r\n    uint public totalSupply;\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n\r\n    event Created(address creator, uint supply);\r\n\r\n    function balanceOf(address _owner) public view returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n}\r\n\r\ncontract ERC20x is ERC20xVariables {\r\n\r\n    function transfer(address _to, uint256 _value) public returns (bool success) {\r\n        _transferBalance(msg.sender, _to, _value);\r\n        emit Transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\r\n        uint256 allowance = allowed[_from][msg.sender];\r\n        require(allowance >= _value);\r\n        _transferBalance(_from, _to, _value);\r\n        if (allowance < MAX_UINT256) {\r\n            allowed[_from][msg.sender] -= _value;\r\n        }\r\n        emit Transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) public returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        emit Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function transferToContract(address _to, uint256 _value, bytes memory data) public returns (bool) {\r\n        _transferBalance(msg.sender, _to, _value);\r\n        bytes4 sig = bytes4(keccak256(\"receiveTokens(address,uint256,bytes)\"));\r\n        (bool result,) = _to.call(abi.encodePacked(sig, msg.sender, _value, data));\r\n        require(result);\r\n        emit Transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    function _transferBalance(address _from, address _to, uint _value) internal {\r\n        require(balances[_from] >= _value);\r\n        balances[_from] -= _value;\r\n        balances[_to] += _value;\r\n    }\r\n}\r\n\r\ncontract BidderInterface {\r\n    function receiveETH(address series, uint256 amount) public;\r\n    function receiveUSD(address series, uint256 amount) public;\r\n}\r\n\r\ncontract VariableSupplyToken is ERC20x {\r\n    function grant(address to, uint256 amount) public returns (bool) {\r\n        require(msg.sender == creator);\r\n        require(balances[to] + amount >= amount);\r\n        balances[to] += amount;\r\n        totalSupply += amount;\r\n        return true;\r\n    }\r\n\r\n    function burn(address from, uint amount) public returns (bool) {\r\n        require(msg.sender == creator);\r\n        require(balances[from] >= amount);\r\n        balances[from] -= amount;\r\n        totalSupply -= amount;\r\n        return true;\r\n    }\r\n}\r\n\r\ncontract OptionToken is VariableSupplyToken {\r\n    constructor(string memory _name, string memory _symbol) public {\r\n        creator = msg.sender;\r\n        name = _name;\r\n        symbol = _symbol;\r\n    }\r\n}\r\n\r\ncontract Protocol {\r\n    \r\n    address public lib;\r\n    ERC20x public usdERC20;\r\n    ERC20x public protocolToken;\r\n\r\n    // We use \"flavor\" because type is a reserved word in many programming languages\r\n    enum Flavor {\r\n        Call,\r\n        Put\r\n    }\r\n\r\n    struct OptionSeries {\r\n        uint expiration;\r\n        Flavor flavor;\r\n        uint strike;\r\n    }\r\n\r\n    uint public constant DURATION = 12 hours;\r\n    uint public constant HALF_DURATION = DURATION / 2;\r\n\r\n    mapping(address => uint) public openInterest;\r\n    mapping(address => uint) public earlyExercised;\r\n    mapping(address => uint) public totalInterest;\r\n    mapping(address => mapping(address => uint)) public writers;\r\n    mapping(address => OptionSeries) public seriesInfo;\r\n    mapping(address => uint) public holdersSettlement;\r\n\r\n    mapping(address => uint) public expectValue;\r\n    bool isAuction;\r\n\r\n    uint public constant ONE_MILLION = 1000000;\r\n\r\n    // maximum token holder rights capped at 3.7% of total supply?\r\n    // Why 3.7%?\r\n    // I could make up some fancy explanation\r\n    // and use the phrase \"byzantine fault tolerance\" somehow\r\n    // Or I could just say that 3.7% allows for a total of 27 independent actors\r\n    // that are all receiving the maximum benefit, and it solves all the other\r\n    // issues of disincentivizing centralization and \"rich get richer\" mechanics, so I chose 27 'cause it just has a nice \"decentralized\" feel to it.\r\n    // 21 would have been fine, as few as ten probably would have been ok 'cause people can just pool anyways\r\n    // up to a thousand or so probably wouldn't have hurt either.\r\n    // In the end it really doesn't matter as long as the game ends up being played fairly.\r\n\r\n    // I'm sure someone will take my system and parameterize it differently at some point and bill it as a totally new product.\r\n    uint public constant PREFERENCE_MAX = 0.037 ether;\r\n\r\n    constructor(address _token, address _usd) public {\r\n        lib = address(new VariableSupplyToken());\r\n        protocolToken = ERC20x(_token);\r\n        usdERC20 = ERC20x(_usd);\r\n    }\r\n\r\n    function() external payable {\r\n        revert();\r\n    }\r\n\r\n    event SeriesIssued(address series);\r\n\r\n    function issue(string memory name, string memory symbol, uint expiration, Flavor flavor, uint strike) public returns (address) {\r\n        address series = address(new OptionToken(name, symbol));\r\n        seriesInfo[series] = OptionSeries(expiration, flavor, strike);\r\n        emit SeriesIssued(series);\r\n        return series;\r\n    }\r\n\r\n    function open(address _series, uint amount) public payable returns (bool) {\r\n        OptionSeries memory series = seriesInfo[_series];\r\n        require(now < series.expiration);\r\n\r\n        VariableSupplyToken(_series).grant(msg.sender, amount);\r\n\r\n        if (series.flavor == Flavor.Call) {\r\n            require(msg.value == amount);\r\n        } else {\r\n            require(msg.value == 0);\r\n            uint escrow = amount * series.strike;\r\n            require(escrow / amount == series.strike);\r\n            escrow /= 1 ether;\r\n            require(usdERC20.transferFrom(msg.sender, address(this), escrow));\r\n        }\r\n        \r\n        openInterest[_series] += amount;\r\n        totalInterest[_series] += amount;\r\n        writers[_series][msg.sender] += amount;\r\n\r\n        return true;\r\n    }\r\n\r\n    function close(address _series, uint amount) public returns (bool) {\r\n        OptionSeries memory series = seriesInfo[_series];\r\n\r\n        require(now < series.expiration);\r\n        require(openInterest[_series] >= amount);\r\n        VariableSupplyToken(_series).burn(msg.sender, amount);\r\n\r\n        require(writers[_series][msg.sender] >= amount);\r\n        writers[_series][msg.sender] -= amount;\r\n        openInterest[_series] -= amount;\r\n        totalInterest[_series] -= amount;\r\n        \r\n        if (series.flavor == Flavor.Call) {\r\n            msg.sender.transfer(amount);\r\n        } else {\r\n            usdERC20.transfer(msg.sender, amount * series.strike / 1 ether);\r\n        }\r\n        return true;\r\n    }\r\n    \r\n    function exercise(address _series, uint amount) public payable {\r\n        OptionSeries memory series = seriesInfo[_series];\r\n\r\n        require(now < series.expiration);\r\n        require(openInterest[_series] >= amount);\r\n        VariableSupplyToken(_series).burn(msg.sender, amount);\r\n\r\n        uint usd = amount * series.strike;\r\n        require(usd / amount == series.strike);\r\n        usd /= 1 ether;\r\n\r\n        openInterest[_series] -= amount;\r\n        earlyExercised[_series] += amount;\r\n\r\n        if (series.flavor == Flavor.Call) {\r\n            msg.sender.transfer(amount);\r\n            require(msg.value == 0);\r\n            usdERC20.transferFrom(msg.sender, address(this), usd);\r\n        } else {\r\n            require(msg.value == amount);\r\n            usdERC20.transfer(msg.sender, usd);\r\n        }\r\n    }\r\n    \r\n    function receive() public payable returns (bool) {\r\n        require(expectValue[msg.sender] == msg.value);\r\n        expectValue[msg.sender] = 0;\r\n        return true;\r\n    }\r\n\r\n    function bid(address _series, uint amount) public payable returns (bool) {\r\n\r\n        require(isAuction == false);\r\n        isAuction = true;\r\n\r\n        OptionSeries memory series = seriesInfo[_series];\r\n\r\n        uint start = series.expiration;\r\n        uint time = now + _timePreference(msg.sender);\r\n\r\n        require(time > start);\r\n        require(time < start + DURATION);\r\n\r\n        uint elapsed = time - start;\r\n\r\n        amount = _min(amount, openInterest[_series]);\r\n\r\n        openInterest[_series] -= amount;\r\n\r\n        uint offer;\r\n        uint givGet;\r\n        \r\n        BidderInterface bidder = BidderInterface(msg.sender);\r\n\r\n        if (series.flavor == Flavor.Call) {\r\n            require(msg.value == 0);\r\n\r\n            offer = (series.strike * DURATION) / elapsed;\r\n            givGet = offer * amount / 1 ether;\r\n            holdersSettlement[_series] += givGet - amount * series.strike / 1 ether;\r\n\r\n            bool hasFunds = usdERC20.balanceOf(msg.sender) >= givGet && usdERC20.allowance(msg.sender, address(this)) >= givGet;\r\n\r\n            if (hasFunds) {\r\n                msg.sender.transfer(amount);\r\n            } else {\r\n                bidder.receiveETH(_series, amount);\r\n            }\r\n\r\n            require(usdERC20.transferFrom(msg.sender, address(this), givGet));\r\n        } else {\r\n            offer = (DURATION * 1 ether * 1 ether) / (series.strike * elapsed);\r\n            givGet = (amount * 1 ether) / offer;\r\n\r\n            holdersSettlement[_series] += amount * series.strike / 1 ether - givGet;\r\n            usdERC20.transfer(msg.sender, givGet);\r\n\r\n            if (msg.value == 0) {\r\n                require(expectValue[msg.sender] == 0);\r\n                expectValue[msg.sender] = amount;\r\n                \r\n                bidder.receiveUSD(_series, givGet);\r\n                require(expectValue[msg.sender] == 0);\r\n            } else {\r\n                require(msg.value >= amount);\r\n                msg.sender.transfer(msg.value - amount);\r\n            }\r\n        }\r\n\r\n        isAuction = false;\r\n        return true;\r\n    }\r\n\r\n    function redeem(address _series) public returns (bool) {\r\n        OptionSeries memory series = seriesInfo[_series];\r\n\r\n        require(now > series.expiration + DURATION);\r\n\r\n        uint unsettledPercent = openInterest[_series] * 1 ether / totalInterest[_series];\r\n        uint exercisedPercent = (totalInterest[_series] - openInterest[_series]) * 1 ether / totalInterest[_series];\r\n        uint owed;\r\n\r\n        if (series.flavor == Flavor.Call) {\r\n            owed = writers[_series][msg.sender] * unsettledPercent / 1 ether;\r\n            if (owed > 0) {\r\n                msg.sender.transfer(owed);\r\n            }\r\n\r\n            owed = writers[_series][msg.sender] * exercisedPercent / 1 ether;\r\n            owed = owed * series.strike / 1 ether;\r\n            if (owed > 0) {\r\n                usdERC20.transfer(msg.sender, owed);\r\n            }\r\n        } else {\r\n            owed = writers[_series][msg.sender] * unsettledPercent / 1 ether;\r\n            owed = owed * series.strike / 1 ether;\r\n            if (owed > 0) {\r\n                usdERC20.transfer(msg.sender, owed);\r\n            }\r\n\r\n            owed = writers[_series][msg.sender] * exercisedPercent / 1 ether;\r\n            if (owed > 0) {\r\n                msg.sender.transfer(owed);\r\n            }\r\n        }\r\n\r\n        writers[_series][msg.sender] = 0;\r\n        return true;\r\n    }\r\n\r\n    function settle(address _series) public returns (bool) {\r\n        OptionSeries memory series = seriesInfo[_series];\r\n        require(now > series.expiration + DURATION);\r\n\r\n        uint bal = ERC20x(_series).balanceOf(msg.sender);\r\n        VariableSupplyToken(_series).burn(msg.sender, bal);\r\n\r\n        uint percent = bal * 1 ether / (totalInterest[_series] - earlyExercised[_series]);\r\n        uint owed = holdersSettlement[_series] * percent / 1 ether;\r\n        usdERC20.transfer(msg.sender, owed);\r\n        return true;\r\n    }\r\n\r\n    function _timePreference(address from) public view returns (uint) {\r\n        return (_unsLn(_preference(from) * 1000000 + 1 ether) * 171) / 1 ether;\r\n    }\r\n\r\n    function _preference(address from) public view returns (uint) {\r\n        return _min(\r\n            protocolToken.balanceOf(from) * 1 ether / protocolToken.totalSupply(),\r\n            PREFERENCE_MAX\r\n        );\r\n    }\r\n\r\n    function _min(uint a, uint b) pure public returns (uint) {\r\n        if (a > b)\r\n            return b;\r\n        return a;\r\n    }\r\n\r\n    function _max(uint a, uint b) pure public returns (uint) {\r\n        if (a > b)\r\n            return a;\r\n        return b;\r\n    }\r\n    \r\n    function _unsLn(uint x) pure public returns (uint log) {\r\n        log = 0;\r\n        \r\n        // not a true ln function, we can't represent the negatives\r\n        if (x < 1 ether)\r\n            return 0;\r\n\r\n        while (x >= 1.5 ether) {\r\n            log += 0.405465 ether;\r\n            x = x * 2 / 3;\r\n        }\r\n        \r\n        x = x - 1 ether;\r\n        uint y = x;\r\n        uint i = 1;\r\n\r\n        while (i < 10) {\r\n            log += (y / i);\r\n            i = i + 1;\r\n            y = y * x / 1 ether;\r\n            log -= (y / i);\r\n            i = i + 1;\r\n            y = y * x / 1 ether;\r\n        }\r\n         \r\n        return(log);\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"name\",\"type\":\"string\"},{\"name\":\"symbol\",\"type\":\"string\"},{\"name\":\"expiration\",\"type\":\"uint256\"},{\"name\":\"flavor\",\"type\":\"uint8\"},{\"name\":\"strike\",\"type\":\"uint256\"}],\"name\":\"issue\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_series\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"open\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"protocolToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"DURATION\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"x\",\"type\":\"uint256\"}],\"name\":\"_unsLn\",\"outputs\":[{\"name\":\"log\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"earlyExercised\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"writers\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_series\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"bid\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_series\",\"type\":\"address\"}],\"name\":\"settle\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"HALF_DURATION\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"usdERC20\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"}],\"name\":\"_preference\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"a\",\"type\":\"uint256\"},{\"name\":\"b\",\"type\":\"uint256\"}],\"name\":\"_max\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lib\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_series\",\"type\":\"address\"}],\"name\":\"redeem\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ONE_MILLION\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"receive\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"a\",\"type\":\"uint256\"},{\"name\":\"b\",\"type\":\"uint256\"}],\"name\":\"_min\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"expectValue\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"}],\"name\":\"_timePreference\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"PREFERENCE_MAX\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"totalInterest\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"seriesInfo\",\"outputs\":[{\"name\":\"expiration\",\"type\":\"uint256\"},{\"name\":\"flavor\",\"type\":\"uint8\"},{\"name\":\"strike\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"holdersSettlement\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_series\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"exercise\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_series\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"close\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"openInterest\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_usd\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"series\",\"type\":\"address\"}],\"name\":\"SeriesIssued\",\"type\":\"event\"}]","ContractName":"Protocol","CompilerVersion":"v0.5.1+commit.c8a2cb62","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000b471c695dd5ea02035275d4b88077490c1e380ba00000000000000000000000089d24a6b4ccb1b6faa2625fe562bdd9a23260359","Library":"","SwarmSource":"bzzr://797b5a5c981c36c97511ca8cc94fbfffebde901a6801a96b9df5c85bd74283fd"}]}