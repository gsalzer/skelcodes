{"status":"1","message":"OK","result":[{"SourceCode":"// File: contracts/Ownable.sol\r\n\r\npragma solidity 0.5.0;\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n\r\n    address private _owner;\r\n    address private _pendingOwner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n    \r\n    /**\r\n     * @dev The constructor sets the original owner of the contract to the sender account.\r\n     */\r\n    constructor() public {\r\n        setOwner(msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier throws if called by any account other than the pendingOwner.\r\n     */\r\n    modifier onlyPendingOwner() {\r\n        require(msg.sender == _pendingOwner, \"msg.sender should be onlyPendingOwner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(msg.sender == _owner, \"msg.sender should be owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Tells the address of the pendingOwner\r\n     * @return The address of the pendingOwner\r\n     */\r\n    function pendingOwner() public view returns (address) {\r\n        return _pendingOwner;\r\n    }\r\n    \r\n    /**\r\n     * @dev Tells the address of the owner\r\n     * @return the address of the owner\r\n     */\r\n    function owner() public view returns (address ) {\r\n        return _owner;\r\n    }\r\n    \r\n    /**\r\n    * @dev Sets a new owner address\r\n    * @param _newOwner The newOwner to set\r\n    */\r\n    function setOwner(address _newOwner) internal {\r\n        _owner = _newOwner;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to set the pendingOwner address.\r\n     * @param _newOwner The address to transfer ownership to.\r\n     */\r\n    function transferOwnership(address _newOwner) public onlyOwner {\r\n        _pendingOwner = _newOwner;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the pendingOwner address to finalize the transfer.\r\n     */\r\n    function claimOwnership() public onlyPendingOwner {\r\n        emit OwnershipTransferred(_owner, _pendingOwner);\r\n        _owner = _pendingOwner;\r\n        _pendingOwner = address(0); \r\n    }\r\n    \r\n}\r\n\r\n// File: contracts/Operable.sol\r\n\r\npragma solidity 0.5.0;\r\n\r\n\r\ncontract Operable is Ownable {\r\n\r\n    address private _operator; \r\n\r\n    event OperatorChanged(address indexed previousOperator, address indexed newOperator);\r\n\r\n    /**\r\n     * @dev Tells the address of the operator\r\n     * @return the address of the operator\r\n     */\r\n    function operator() external view returns (address) {\r\n        return _operator;\r\n    }\r\n    \r\n    /**\r\n     * @dev Only the operator can operate store\r\n     */\r\n    modifier onlyOperator() {\r\n        require(msg.sender == _operator, \"msg.sender should be operator\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev update the storgeOperator\r\n     * @param _newOperator The newOperator to update  \r\n     */\r\n    function updateOperator(address _newOperator) public onlyOwner {\r\n        require(_newOperator != address(0), \"Cannot change the newOperator to the zero address\");\r\n        emit OperatorChanged(_operator, _newOperator);\r\n        _operator = _newOperator;\r\n    }\r\n\r\n}\r\n\r\n// File: contracts/utils/SafeMath.sol\r\n\r\npragma solidity 0.5.0;\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Unsigned math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Multiplies two unsigned integers, reverts on overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Adds two unsigned integers, reverts on overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\r\n     * reverts when dividing by zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: contracts/TokenStore.sol\r\n\r\npragma solidity 0.5.0;\r\n\r\n\r\n\r\ncontract TokenStore is Operable {\r\n\r\n    using SafeMath for uint256;\r\n\r\n    uint256 public totalSupply;\r\n    \r\n    string  public name = \"PingAnToken\";\r\n    string  public symbol = \"PAT\";\r\n    uint8 public decimals = 18;\r\n\r\n    mapping (address => uint256) public balances;\r\n    mapping (address => mapping (address => uint256)) public allowed;\r\n\r\n    function changeTokenName(string memory _name, string memory _symbol) public onlyOperator {\r\n        name = _name;\r\n        symbol = _symbol;\r\n    }\r\n\r\n    function addBalance(address _holder, uint256 _value) public onlyOperator {\r\n        balances[_holder] = balances[_holder].add(_value);\r\n    }\r\n\r\n    function subBalance(address _holder, uint256 _value) public onlyOperator {\r\n        balances[_holder] = balances[_holder].sub(_value);\r\n    }\r\n\r\n    function setBalance(address _holder, uint256 _value) public onlyOperator {\r\n        balances[_holder] = _value;\r\n    }\r\n\r\n    function addAllowance(address _holder, address _spender, uint256 _value) public onlyOperator {\r\n        allowed[_holder][_spender] = allowed[_holder][_spender].add(_value);\r\n    }\r\n\r\n    function subAllowance(address _holder, address _spender, uint256 _value) public onlyOperator {\r\n        allowed[_holder][_spender] = allowed[_holder][_spender].sub(_value);\r\n    }\r\n\r\n    function setAllowance(address _holder, address _spender, uint256 _value) public onlyOperator {\r\n        allowed[_holder][_spender] = _value;\r\n    }\r\n\r\n    function addTotalSupply(uint256 _value) public onlyOperator {\r\n        totalSupply = totalSupply.add(_value);\r\n    }\r\n\r\n    function subTotalSupply(uint256 _value) public onlyOperator {\r\n        totalSupply = totalSupply.sub(_value);\r\n    }\r\n\r\n    function setTotalSupply(uint256 _value) public onlyOperator {\r\n        totalSupply = _value;\r\n    }\r\n\r\n}\r\n\r\n// File: contracts/ERC20Interface.sol\r\n\r\npragma solidity 0.5.0;\r\n\r\n\r\ninterface ERC20Interface {  \r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address holder) external view returns (uint256);\r\n\r\n    function allowance(address holder, address spender) external view returns (uint256);\r\n\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n\r\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    event Approval(address indexed holder, address indexed spender, uint256 value);\r\n\r\n}\r\n\r\n// File: contracts/ERC20StandardToken.sol\r\n\r\npragma solidity 0.5.0;\r\n\r\n\r\n\r\n\r\ncontract ERC20StandardToken is ERC20Interface, Ownable {\r\n\r\n\r\n    TokenStore public tokenStore;\r\n    \r\n    event TokenStoreSet(address indexed previousTokenStore, address indexed newTokenStore);\r\n    event ChangeTokenName(string newName, string newSymbol);\r\n\r\n    /**\r\n     * @dev ownership of the TokenStore contract\r\n     * @param _newTokenStore The address to of the TokenStore to set.\r\n     */\r\n    function setTokenStore(address _newTokenStore) public onlyOwner returns (bool) {\r\n        emit TokenStoreSet(address(tokenStore), _newTokenStore);\r\n        tokenStore = TokenStore(_newTokenStore);\r\n        return true;\r\n    }\r\n    \r\n    function changeTokenName(string memory _name, string memory _symbol) public onlyOwner {\r\n        tokenStore.changeTokenName(_name, _symbol);\r\n        emit ChangeTokenName(_name, _symbol);\r\n    }\r\n\r\n    function totalSupply() public view returns (uint256) {\r\n        return tokenStore.totalSupply();\r\n    }\r\n\r\n    function balanceOf(address _holder) public view returns (uint256) {\r\n        return tokenStore.balances(_holder);\r\n    }\r\n\r\n    function allowance(address _holder, address _spender) public view returns (uint256) {\r\n        return tokenStore.allowed(_holder, _spender);\r\n    }\r\n    \r\n    function name() public view returns (string memory) {\r\n        return tokenStore.name();\r\n    }\r\n    \r\n    function symbol() public view returns (string memory) {\r\n        return tokenStore.symbol();\r\n    }\r\n    \r\n    function decimals() public view returns (uint8) {\r\n        return tokenStore.decimals();\r\n    }\r\n    \r\n    /**\r\n     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n     * Beware that changing an allowance with this method brings the risk that someone may use both the old\r\n     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\r\n     * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     * @param _spender The address which will spend the funds.\r\n     * @param _value The amount of tokens to be spent.\r\n     */\r\n    function approve(\r\n        address _spender,\r\n        uint256 _value\r\n    ) public returns (bool success) {\r\n        require (_spender != address(0), \"Cannot approve to the zero address\");       \r\n        tokenStore.setAllowance(msg.sender, _spender, _value);\r\n        emit Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n    \r\n    /**\r\n     * @dev Increase the amount of tokens that an holder allowed to a spender.\r\n     *\r\n     * approve should be called when allowed[_spender] == 0. To increment\r\n     * allowed value is better to use this function to avoid 2 calls (and wait until\r\n     * the first transaction is mined)\r\n     * From MonolithDAO Token.sol\r\n     * @param _spender The address which will spend the funds.\r\n     * @param _addedValue The amount of tokens to increase the allowance by.\r\n     */\r\n    function increaseApproval(\r\n        address _spender,\r\n        uint256 _addedValue\r\n    ) public returns (bool success) {\r\n        require (_spender != address(0), \"Cannot increaseApproval to the zero address\");      \r\n        tokenStore.addAllowance(msg.sender, _spender, _addedValue);\r\n        emit Approval(msg.sender, _spender, tokenStore.allowed(msg.sender, _spender));\r\n        return true;\r\n    }\r\n    \r\n    /**\r\n     * @dev Decrease the amount of tokens that an holder allowed to a spender.\r\n     *\r\n     * approve should be called when allowed[_spender] == 0. To decrement\r\n     * allowed value is better to use this function to avoid 2 calls (and wait until\r\n     * the first transaction is mined)\r\n     * From MonolithDAO Token.sol\r\n     * @param _spender The address which will spend the funds.\r\n     * @param _subtractedValue The amount of tokens to decrease the allowance by.\r\n     */\r\n    function decreaseApproval(\r\n        address _spender,\r\n        uint256 _subtractedValue \r\n    ) public returns (bool success) {\r\n        require (_spender != address(0), \"Cannot decreaseApproval to the zero address\");       \r\n        tokenStore.subAllowance(msg.sender, _spender, _subtractedValue);\r\n        emit Approval(msg.sender, _spender, tokenStore.allowed(msg.sender, _spender));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Transfer tokens from one address to another\r\n     * @param _from address The address which you want to send tokens from\r\n     * @param _to address The address which you want to transfer to\r\n     * @param _value uint256 the amount of tokens to be transferred\r\n     */\r\n    function transferFrom(\r\n        address _from, \r\n        address _to, \r\n        uint256 _value\r\n    ) public returns (bool success) {\r\n        require(_to != address(0), \"Cannot transfer to zero address\"); \r\n        tokenStore.subAllowance(_from, msg.sender, _value);          \r\n        tokenStore.subBalance(_from, _value);\r\n        tokenStore.addBalance(_to, _value);\r\n        emit Transfer(_from, _to, _value);\r\n        return true;\r\n    } \r\n\r\n    /**\r\n     * @dev Transfer token for a specified address\r\n     * @param _to The address to transfer to.\r\n     * @param _value The amount to be transferred.\r\n     */\r\n    function transfer(\r\n        address _to, \r\n        uint256 _value\r\n    ) public returns (bool success) {\r\n        require (_to != address(0), \"Cannot transfer to zero address\");    \r\n        tokenStore.subBalance(msg.sender, _value);\r\n        tokenStore.addBalance(_to, _value);\r\n        emit Transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n\r\n}\r\n\r\n// File: contracts/PausableToken.sol\r\n\r\npragma solidity 0.5.0;\r\n\r\n\r\n\r\ncontract PausableToken is ERC20StandardToken {\r\n\r\n    address private _pauser;\r\n    bool public paused = false;\r\n\r\n    event Pause();\r\n    event Unpause();\r\n    event PauserChanged(address indexed previousPauser, address indexed newPauser);\r\n    \r\n    /**\r\n     * @dev Tells the address of the pauser\r\n     * @return The address of the pauser\r\n     */\r\n    function pauser() public view returns (address) {\r\n        return _pauser;\r\n    }\r\n    \r\n    /**\r\n     * @dev Modifier to make a function callable only when the contract is not paused.\r\n     */\r\n    modifier whenNotPaused() {\r\n        require(!paused, \"state shouldn't be paused\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev throws if called by any account other than the pauser\r\n     */\r\n    modifier onlyPauser() {\r\n        require(msg.sender == _pauser, \"msg.sender should be pauser\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev called by the owner to pause, triggers stopped state\r\n     */\r\n    function pause() public onlyPauser {\r\n        paused = true;\r\n        emit Pause();\r\n    }\r\n\r\n    /**\r\n     * @dev called by the owner to unpause, returns to normal state\r\n     */\r\n    function unpause() public onlyPauser {\r\n        paused = false;\r\n        emit Unpause();\r\n    }\r\n\r\n    /**\r\n     * @dev update the pauser role\r\n     * @param _newPauser The newPauser to update\r\n     */\r\n    function updatePauser(address _newPauser) public onlyOwner {\r\n        require(_newPauser != address(0), \"Cannot update the newPauser to the zero address\");\r\n        emit PauserChanged(_pauser, _newPauser);\r\n        _pauser = _newPauser;\r\n    }\r\n\r\n    function approve(\r\n        address _spender,\r\n        uint256 _value\r\n    ) public whenNotPaused returns (bool success) {\r\n        return super.approve(_spender, _value);\r\n    }\r\n\r\n    function increaseApproval(\r\n        address _spender,\r\n        uint256 _addedValue\r\n    ) public whenNotPaused returns (bool success) {\r\n        return super.increaseApproval(_spender, _addedValue);\r\n    } \r\n\r\n    function decreaseApproval(\r\n        address _spender,\r\n        uint256 _subtractedValue \r\n    ) public whenNotPaused returns (bool success) {\r\n        return super.decreaseApproval(_spender, _subtractedValue);\r\n    }\r\n\r\n    function transferFrom(\r\n        address _from, \r\n        address _to, \r\n        uint256 _value\r\n    ) public whenNotPaused returns (bool success) {\r\n        return super.transferFrom(_from, _to, _value);\r\n    } \r\n\r\n    function transfer(\r\n        address _to, \r\n        uint256 _value\r\n    ) public whenNotPaused returns (bool success) {\r\n        return super.transfer(_to, _value);\r\n    }\r\n\r\n}\r\n\r\n// File: contracts/BlacklistStore.sol\r\n\r\npragma solidity 0.5.0;\r\n\r\n\r\ncontract BlacklistStore is Operable {\r\n\r\n    mapping (address => uint256) public blacklisted;\r\n\r\n    /**\r\n     * @dev Checks if account is blacklisted\r\n     * @param _account The address to check\r\n     * @param _status The address status    \r\n     */\r\n    function setBlacklist(address _account, uint256 _status) public onlyOperator {\r\n        blacklisted[_account] = _status;\r\n    }\r\n\r\n}\r\n\r\n// File: contracts/BlacklistableToken.sol\r\n\r\npragma solidity 0.5.0;\r\n\r\n\r\n\r\n/**\r\n * @title BlacklistableToken\r\n * @dev Allows accounts to be blacklisted by a \"blacklister\" role\r\n */\r\ncontract BlacklistableToken is PausableToken {\r\n\r\n    BlacklistStore public blacklistStore;\r\n\r\n    address private _blacklister;\r\n\r\n    event BlacklisterChanged(address indexed previousBlacklister, address indexed newBlacklister);\r\n    event BlacklistStoreSet(address indexed previousBlacklistStore, address indexed newblacklistStore);\r\n    event Blacklist(address indexed account, uint256 _status);\r\n\r\n\r\n    /**\r\n     * @dev Throws if argument account is blacklisted\r\n     * @param _account The address to check\r\n     */\r\n    modifier notBlacklisted(address _account) {\r\n        require(blacklistStore.blacklisted(_account) == 0, \"Account in the blacklist\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the blacklister\r\n     */\r\n    modifier onlyBlacklister() {\r\n        require(msg.sender == _blacklister, \"msg.sener should be blacklister\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Tells the address of the blacklister\r\n     * @return The address of the blacklister\r\n     */\r\n    function blacklister() public view returns (address) {\r\n        return _blacklister;\r\n    }\r\n    \r\n    /**\r\n     * @dev Set the blacklistStore\r\n     * @param _newblacklistStore The blacklistStore address to set\r\n     */\r\n    function setBlacklistStore(address _newblacklistStore) public onlyOwner returns (bool) {\r\n        emit BlacklistStoreSet(address(blacklistStore), _newblacklistStore);\r\n        blacklistStore = BlacklistStore(_newblacklistStore);\r\n        return true;\r\n    }\r\n    \r\n    /**\r\n     * @dev Update the blacklister \r\n     * @param _newBlacklister The newBlacklister to update\r\n     */\r\n    function updateBlacklister(address _newBlacklister) public onlyOwner {\r\n        require(_newBlacklister != address(0), \"Cannot update the blacklister to the zero address\");\r\n        emit BlacklisterChanged(_blacklister, _newBlacklister);\r\n        _blacklister = _newBlacklister;\r\n    }\r\n\r\n    /**\r\n     * @dev Checks if account is blacklisted\r\n     * @param _account The address status to query\r\n     * @return the address status \r\n     */\r\n    function queryBlacklist(address _account) public view returns (uint256) {\r\n        return blacklistStore.blacklisted(_account);\r\n    }\r\n\r\n    /**\r\n     * @dev Adds account to blacklist\r\n     * @param _account The address to blacklist\r\n     * @param _status The address status to change\r\n     */\r\n    function changeBlacklist(address _account, uint256 _status) public onlyBlacklister {\r\n        blacklistStore.setBlacklist(_account, _status);\r\n        emit Blacklist(_account, _status);\r\n    }\r\n\r\n    function approve(\r\n        address _spender,\r\n        uint256 _value\r\n    ) public notBlacklisted(msg.sender) notBlacklisted(_spender) returns (bool success) {\r\n        return super.approve(_spender, _value);\r\n    }\r\n    \r\n    function increaseApproval(\r\n        address _spender,\r\n        uint256 _addedValue\r\n    ) public notBlacklisted(msg.sender) notBlacklisted(_spender) returns (bool success) {\r\n        return super.increaseApproval(_spender, _addedValue);\r\n    } \r\n\r\n    function decreaseApproval(\r\n        address _spender,\r\n        uint256 _subtractedValue \r\n    ) public notBlacklisted(msg.sender) notBlacklisted(_spender) returns (bool success) {\r\n        return super.decreaseApproval(_spender, _subtractedValue);\r\n    }\r\n\r\n    function transferFrom(\r\n        address _from, \r\n        address _to, \r\n        uint256 _value\r\n    ) public notBlacklisted(_from) notBlacklisted(_to) notBlacklisted(msg.sender) returns (bool success) {\r\n        return super.transferFrom(_from, _to, _value);\r\n    } \r\n\r\n    function transfer(\r\n        address _to, \r\n        uint256 _value\r\n    ) public notBlacklisted(msg.sender) notBlacklisted(_to) returns (bool success) {\r\n        return super.transfer(_to, _value);\r\n    }\r\n\r\n}\r\n\r\n// File: contracts/BurnableToken.sol\r\n\r\npragma solidity 0.5.0;\r\n\r\n\r\ncontract BurnableToken is BlacklistableToken {\r\n\r\n    event Burn(address indexed burner, uint256 value);\r\n    \r\n    /**\r\n     * @dev holder can burn some of its own tokens\r\n     * amount is less than or equal to the minter's account balance\r\n     * @param _value uint256 the amount of tokens to be burned\r\n    */\r\n    function burn(\r\n        uint256 _value\r\n    ) public whenNotPaused notBlacklisted(msg.sender) returns (bool success) {   \r\n        tokenStore.subBalance(msg.sender, _value);\r\n        tokenStore.subTotalSupply(_value);\r\n        emit Burn(msg.sender, _value);\r\n        emit Transfer(msg.sender, address(0), _value);\r\n        return true;\r\n    }\r\n\r\n}\r\n\r\n// File: contracts/MintableToken.sol\r\n\r\npragma solidity 0.5.0;\r\n\r\n\r\n\r\ncontract MintableToken is BlacklistableToken {\r\n\r\n    event MinterChanged(address indexed previousMinter, address indexed newMinter);\r\n    event Mint(address indexed minter, address indexed to, uint256 value);\r\n\r\n    address private _minter;\r\n\r\n    modifier onlyMinter() {\r\n        require(msg.sender == _minter, \"msg.sender should be minter\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Tells the address of the blacklister\r\n     * @return The address of the blacklister\r\n     */\r\n    function minter() public view returns (address) {\r\n        return _minter;\r\n    }\r\n \r\n    /**\r\n     * @dev update the minter\r\n     * @param _newMinter The newMinter to update\r\n     */\r\n    function updateMinter(address _newMinter) public onlyOwner {\r\n        require(_newMinter != address(0), \"Cannot update the newPauser to the zero address\");\r\n        emit MinterChanged(_minter, _newMinter);\r\n        _minter = _newMinter;\r\n    }\r\n\r\n    /**\r\n     * @dev Function to mint tokens\r\n     * @param _to The address that will receive the minted tokens.\r\n     * @param _value The amount of tokens to mint. Must be less than or equal to the minterAllowance of the caller.\r\n     * @return A boolean that indicates if the operation was successful.\r\n     */\r\n    function mint(\r\n        address _to, \r\n        uint256 _value\r\n    ) public onlyMinter whenNotPaused notBlacklisted(msg.sender) notBlacklisted(_to) returns (bool) {\r\n        require(_to != address(0), \"Cannot mint to zero address\");\r\n        tokenStore.addTotalSupply(_value);\r\n        tokenStore.addBalance(_to, _value);  \r\n        emit Mint(msg.sender, _to, _value);\r\n        emit Transfer(address(0), _to, _value);\r\n        return true;\r\n    }\r\n\r\n}\r\n\r\n// File: contracts/PingAnToken.sol\r\n\r\npragma solidity 0.5.0;\r\n\r\n\r\n\r\n\r\ncontract PingAnToken is BurnableToken, MintableToken {\r\n\r\n\r\n    /**\r\n     * contract only can initialized once \r\n     */\r\n    bool private initialized = true;\r\n\r\n    /**\r\n     * @dev sets 0 initials tokens, the owner.\r\n     * this serves as the constructor for the proxy but compiles to the\r\n     * memory model of the Implementation contract.\r\n     * @param _owner The owner to initials\r\n     */\r\n    function initialize(address _owner) public {\r\n        require(!initialized, \"already initialized\");\r\n        require(_owner != address(0), \"Cannot initialize the owner to zero address\");\r\n        setOwner(_owner);\r\n        initialized = true;\r\n    }\r\n\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_account\",\"type\":\"address\"},{\"name\":\"_status\",\"type\":\"uint256\"}],\"name\":\"changeBlacklist\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minter\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newblacklistStore\",\"type\":\"address\"}],\"name\":\"setBlacklistStore\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newTokenStore\",\"type\":\"address\"}],\"name\":\"setTokenStore\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"queryBlacklist\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_name\",\"type\":\"string\"},{\"name\":\"_symbol\",\"type\":\"string\"}],\"name\":\"changeTokenName\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claimOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newMinter\",\"type\":\"address\"}],\"name\":\"updateMinter\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newPauser\",\"type\":\"address\"}],\"name\":\"updatePauser\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenStore\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseApproval\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_holder\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"blacklistStore\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pauser\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newBlacklister\",\"type\":\"address\"}],\"name\":\"updateBlacklister\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"blacklister\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseApproval\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_holder\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pendingOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousMinter\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newMinter\",\"type\":\"address\"}],\"name\":\"MinterChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"minter\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Mint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"burner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Burn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousBlacklister\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newBlacklister\",\"type\":\"address\"}],\"name\":\"BlacklisterChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousBlacklistStore\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newblacklistStore\",\"type\":\"address\"}],\"name\":\"BlacklistStoreSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_status\",\"type\":\"uint256\"}],\"name\":\"Blacklist\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousPauser\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newPauser\",\"type\":\"address\"}],\"name\":\"PauserChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousTokenStore\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newTokenStore\",\"type\":\"address\"}],\"name\":\"TokenStoreSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newName\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"newSymbol\",\"type\":\"string\"}],\"name\":\"ChangeTokenName\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"holder\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"PingAnToken","CompilerVersion":"v0.5.0+commit.1d4f565a","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://2abfbe1408b788e5d54c5ff9b5f38c0f0a3a6e60fe32c21e953df043acef0d9e"}]}