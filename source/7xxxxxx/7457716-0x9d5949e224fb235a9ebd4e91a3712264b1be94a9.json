{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.5.0;\r\n\r\n// ----------------------------------------------------------------------------\r\n// ERC Token Standard #20 Interface\r\n// https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts/token/ERC20/ERC20.sol\r\n// https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts/token/ERC20/ERC20Basic.sol\r\n// \r\n// ----------------------------------------------------------------------------\r\ninterface ERC20Interface {\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address who) external view returns (uint256);\r\n    function allowance(address approver, address spender) external view returns (uint256);\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\r\n\r\n    // solhint-disable-next-line no-simple-event-func-name\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed approver, address indexed spender, uint256 value);\r\n}\r\n\r\n//\r\n// base contract for all our horizon contracts and tokens\r\n//\r\ncontract HorizonContractBase {\r\n    // The owner of the contract, set at contract creation to the creator.\r\n    address public owner;\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    // Contract authorization - only allow the owner to perform certain actions.\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner, \"Only the owner can call this function.\");\r\n        _;\r\n    }\r\n}\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n *\r\n * Source: https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts/math/SafeMath.sol\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Multiplies two numbers, throws on overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two numbers, truncating the quotient.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        // uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return a / b;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, throws on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}\r\n\r\n/**\r\n * ICOToken for the timelessluxurygroup.com by Horizon-Globex.com of Switzerland.\r\n *\r\n * An ERC20 standard\r\n *\r\n * Author: Horizon Globex GmbH Development Team\r\n *\r\n * Dev Notes\r\n *   NOTE: There is no fallback function as this contract will never contain Ether, only the ICO tokens.\r\n *   NOTE: There is no approveAndCall/receiveApproval or ERC223 functionality.\r\n *   NOTE: Coins will never be minted beyond those at contract creation.\r\n *   NOTE: Zero transfers are allowed - we don't want to break a valid transaction chain.\r\n *   NOTE: There is no selfDestruct, changeOwner or migration path - this is the only contract.\r\n */\r\n\r\n\r\ncontract ICOToken is ERC20Interface, HorizonContractBase {\r\n    using SafeMath for uint256;\r\n\r\n    // Contract authorization - only allow the official KYC provider to perform certain actions.\r\n    modifier onlyKycProvider {\r\n        require(msg.sender == regulatorApprovedKycProvider, \"Only the KYC Provider can call this function.\");\r\n        _;\r\n    }\r\n\t\r\n\t// Contract authorization - only allow the official issuer to perform certain actions.\r\n    modifier onlyIssuer {\r\n        require(msg.sender == issuer, \"Only the Issuer can call this function.\");\r\n        _;\r\n    }\r\n\r\n    // The approved KYC provider that verifies all ICO/TGE Contributors.\r\n    address public regulatorApprovedKycProvider;\r\n    \r\n    // The issuer\r\n    address public issuer;\r\n\r\n    // Public identity variables of the token used by ERC20 platforms.\r\n    string public name;\r\n    string public symbol;\r\n    \r\n    // There is no good reason to deviate from 18 decimals, see https://github.com/ethereum/EIPs/issues/724.\r\n    uint8 public decimals = 18;\r\n    \r\n    // The total supply of tokens, set at creation, decreased with burn.\r\n    uint256 public totalSupply_;\r\n\r\n    // The supply of tokens, set at creation, to be allocated for the referral bonuses.\r\n    uint256 public rewardPool_;\r\n\r\n    // The Initial Coin Offering is finished.\r\n    bool public isIcoComplete;\r\n\r\n    // The balances of all accounts.\r\n    mapping (address => uint256) public balances;\r\n\r\n    // KYC submission hashes accepted by KYC service provider for AML/KYC review.\r\n    bytes32[] public kycHashes;\r\n\r\n    // All users that have passed the external KYC verification checks.\r\n    address[] public kycValidated;\r\n\r\n    // Addresses authorized to transfer tokens on an account's behalf.\r\n    mapping (address => mapping (address => uint256)) internal allowanceCollection;\r\n\r\n    // Lookup an ICO/TGE Contributor address to see if it was referred by another address (referee => referrer).\r\n    mapping (address => address) public referredBy;\r\n\r\n    // Emitted when the Initial Coin Offering phase ends, see closeIco().\r\n    event IcoComplete();\r\n\r\n    // Notification when tokens are burned by the owner.\r\n    event Burn(address indexed from, uint256 value);\r\n    \r\n    // Emitted when mint event ocurred\r\n    // added by andrewju\r\n    event Mint(address indexed from, uint256 value);\r\n\r\n    // Someone who was referred has purchased tokens, when the bonus is awarded log the details.\r\n    event ReferralRedeemed(address indexed referrer, address indexed referee, uint256 value);\r\n\r\n    /**\r\n     * Initialise contract with the 50 million initial supply tokens, allocated to\r\n     * the creator of the contract (the owner).\r\n     */\r\n    constructor(uint256 totalSupply, string memory _name, string memory _symbol, uint256 _rewardPool) public {\r\n\t\tname = _name;\r\n\t\tsymbol = _symbol;\r\n        totalSupply_ = totalSupply * 10 ** uint256(decimals);   // Set the total supply of ICO Tokens.\r\n        balances[msg.sender] = totalSupply_;\r\n        rewardPool_ = _rewardPool * 10 ** uint256(decimals);   // Set the total supply of ICO Reward Tokens.\r\n        \r\n        setKycProvider(msg.sender);\r\n        setIssuer(msg.sender);\r\n        \r\n    }\r\n\r\n    /**\r\n     * The total number of tokens that exist.\r\n     */\r\n    function totalSupply() public view returns (uint256) {\r\n        return totalSupply_;\r\n    }\r\n\r\n    /**\r\n     * The total number of reward pool tokens that remains.\r\n     */\r\n    function rewardPool() public onlyOwner view returns (uint256) {\r\n        return rewardPool_;\r\n    }\r\n\r\n    /**\r\n     * Get the number of tokens for a specific account.\r\n     *\r\n     * @param who    The address to get the token balance of.\r\n     */\r\n    function balanceOf(address who) public view returns (uint256 balance) {\r\n        return balances[who];\r\n    }\r\n\r\n    /**\r\n     * Get the current allowanceCollection that the approver has allowed 'spender' to spend on their behalf.\r\n     *\r\n     * See also: approve() and transferFrom().\r\n     *\r\n     * @param _approver  The account that owns the tokens.\r\n     * @param _spender   The account that can spend the approver's tokens.\r\n     */\r\n    function allowance(address _approver, address _spender) public view returns (uint256) {\r\n        return allowanceCollection[_approver][_spender];\r\n    }\r\n\r\n    /**\r\n     * Add the link between the referrer and who they referred.\r\n     *\r\n     * ---- ICO-Platform Note ----\r\n     * The horizon-globex.com ICO platform offers functionality for referrers to sign-up\r\n     * to refer Contributors. Upon such referred Contributions, Company shall automatically\r\n     * award 1% of our \"owner\" ICO tokens to the referrer as coded by this Smart Contract.\r\n     *\r\n     * All referrers must successfully complete our ICO KYC review prior to being allowed on-board.\r\n     * -- End ICO-Platform Note --\r\n     *\r\n     * @param referrer  The person doing the referring.\r\n     * @param referee   The person that was referred.\r\n     */\r\n    function refer(address referrer, address referee) public onlyOwner {\r\n        require(referrer != address(0x0), \"Referrer cannot be null\");\r\n        require(referee != address(0x0), \"Referee cannot be null\");\r\n        require(!isIcoComplete, \"Cannot add new referrals after ICO is complete.\");\r\n\r\n        referredBy[referee] = referrer;\r\n    }\r\n\r\n    /**\r\n     * Transfer tokens from the caller's account to the recipient.\r\n     *\r\n     * @param to    The address of the recipient.\r\n     * @param value The number of tokens to send.\r\n     */\r\n    // solhint-disable-next-line no-simple-event-func-name\r\n    function transfer(address to, uint256 value) public returns (bool) {\r\n        return _transfer(msg.sender, to, value);\r\n    }\r\n\t\r\n    /**\r\n     * Transfer pre-approved tokens on behalf of an account.\r\n     *\r\n     * See also: approve() and allowance().\r\n     *\r\n     * @param from  The address of the sender\r\n     * @param to    The address of the recipient\r\n     * @param value The number of tokens to send\r\n     */\r\n    function transferFrom(address from, address to, uint256 value) public returns (bool) {\r\n        require(value <= allowanceCollection[from][msg.sender], \"Amount to transfer is greater than allowance.\");\r\n\t\t\r\n        allowanceCollection[from][msg.sender] = allowanceCollection[from][msg.sender].sub(value);\r\n        _transfer(from, to, value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Allow another address to spend tokens on your behalf.\r\n     *\r\n     * transferFrom can be called multiple times until the approved balance goes to zero.\r\n     * Subsequent calls to this function overwrite the previous balance.\r\n     * To change from a non-zero value to another non-zero value you must first set the\r\n     * allowance to zero - it is best to use safeApprove when doing this as you will\r\n     * manually have to check for transfers to ensure none happened before the zero allowance\r\n     * was set.\r\n     *\r\n     * @param _spender   The address authorized to spend your tokens.\r\n     * @param _value     The maximum amount of tokens they can spend.\r\n     */\r\n    function approve(address _spender, uint256 _value) public returns (bool) {\r\n        if(allowanceCollection[msg.sender][_spender] > 0 && _value != 0) {\r\n            revert(\"You cannot set a non-zero allowance to another non-zero, you must zero it first.\");\r\n        }\r\n\r\n        allowanceCollection[msg.sender][_spender] = _value;\r\n        emit Approval(msg.sender, _spender, _value);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Allow another address to spend tokens on your behalf while mitigating a double spend.\r\n     *\r\n     * Subsequent calls to this function overwrite the previous balance.\r\n     * The old value must match the current allowance otherwise this call reverts.\r\n     *\r\n     * @param spender   The address authorized to spend your tokens.\r\n     * @param value     The maximum amount of tokens they can spend.\r\n     * @param oldValue  The current allowance for this spender.\r\n     */\r\n    function safeApprove(address spender, uint256 value, uint256 oldValue) public returns (bool) {\r\n        require(spender != address(0x0), \"Cannot approve null address.\");\r\n        require(oldValue == allowanceCollection[msg.sender][spender], \"The expected old value did not match current allowance.\");\r\n\r\n        allowanceCollection[msg.sender][spender] = value;\r\n        emit Approval(msg.sender, spender, value);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * The hash for all Know Your Customer information is calculated outside but stored here.\r\n     * This storage will be cleared once the ICO completes, see closeIco().\r\n     *\r\n     * ---- ICO-Platform Note ----\r\n     * The horizon-globex.com ICO platform's KYC app will register a hash of the Contributors\r\n     * KYC submission on the blockchain. Our Swiss financial-intermediary KYC provider will be \r\n     * notified of the submission and retrieve the Contributor data for formal review.\r\n     *\r\n     * All Contributors must successfully complete our ICO KYC review prior to being allowed on-board.\r\n     * -- End ICO-Platform Note --\r\n     *\r\n     * @param sha   The hash of the customer data.\r\n    */\r\n    function setKycHash(bytes32 sha) public onlyOwner {\r\n        require(!isIcoComplete, \"The ICO phase has ended, you can no longer set KYC hashes.\");\r\n\r\n        kycHashes.push(sha);\r\n    }\r\n\r\n    /**\r\n     * A user has passed KYC verification, store them on the blockchain in the order it happened.\r\n     * This will be cleared once the ICO completes, see closeIco().\r\n     *\r\n     * ---- ICO-Platform Note ----\r\n     * The horizon-globex.com ICO platform's registered KYC provider submits their approval\r\n     * for this Contributor to particpate using the ICO-Platform portal. \r\n     *\r\n     * Each Contributor will then be sent the Ethereum, Bitcoin and IBAN account numbers to\r\n     * deposit their Approved Contribution in exchange for ICO Tokens.\r\n     * -- End ICO-Platform Note --\r\n     *\r\n     * @param who   The user's address.\r\n     */\r\n    function kycApproved(address who) public onlyKycProvider {\r\n        require(!isIcoComplete, \"The ICO phase has ended, you can no longer approve.\");\r\n        require(who != address(0x0), \"Cannot approve a null address.\");\r\n\r\n        kycValidated.push(who);\r\n    }\r\n\r\n    /**\r\n     * Set the address that has the authority to approve users by KYC.\r\n     *\r\n     * ---- ICO-Platform Note ----\r\n     * The horizon-globex.com ICO platform shall register a fully licensed Swiss KYC\r\n     * provider to assess each potential Contributor for KYC and AML under Swiss law. \r\n     *\r\n     * -- End ICO-Platform Note --\r\n     *\r\n     * @param who   The address of the KYC provider.\r\n     */\r\n    function setKycProvider(address who) public onlyOwner {\r\n        regulatorApprovedKycProvider = who;\r\n    }\r\n    \r\n        /**\r\n     * Set the issuer address\r\n     *\r\n     * @param who   The address of the issuer.\r\n     */\r\n    function setIssuer(address who) public onlyOwner {\r\n        issuer = who;\r\n    }\r\n    \r\n    \r\n    /**\r\n     * Retrieve the KYC hash from the specified index.\r\n     *\r\n     * @param   index   The index into the array.\r\n     */\r\n    function getKycHash(uint256 index) public view returns (bytes32) {\r\n        return kycHashes[index];\r\n    }\r\n\r\n    /**\r\n     * Retrieve the validated KYC address from the specified index.\r\n     *\r\n     * @param   index   The index into the array.\r\n     */\r\n    function getKycApproved(uint256 index) public view returns (address) {\r\n        return kycValidated[index];\r\n    }\r\n\r\n    /**\r\n     * When someone referred (the referee) purchases tokens the referrer gets a 1% bonus from the central pool.\r\n     *\r\n     * ---- ICO-Platform Note ----\r\n     * The horizon-globex.com ICO platform's portal shall award referrers as part of the ICO\r\n     * ICO Token issuance procedure as overseen by the Swiss KYC provider. \r\n     *\r\n     * -- End ICO-Platform Note --\r\n     *\r\n     * @param referee   The referred account who just purchased some tokens.\r\n     * @param referrer  The account that referred the one purchasing tokens.\r\n     * @param value     The number of tokens purchased by the referee.\r\n    */\r\n    function awardReferralBonus(address referee, address referrer, uint256 value) private {\r\n        uint256 bonus = value / 100;\r\n        balances[owner] = balances[owner].sub(bonus);\r\n        balances[referrer] = balances[referrer].add(bonus);\r\n        rewardPool_ -= bonus;\r\n        emit ReferralRedeemed(referee, referrer, bonus);\r\n    }\r\n\r\n    /**\r\n     * During the ICO phase the owner will allocate tokens once KYC completes and funds are deposited.\r\n     *\r\n     * ---- ICO-Platform Note ----\r\n     * The horizon-globex.com ICO platform's portal shall issue ICO Token to Contributors on receipt of \r\n     * the Approved Contribution funds at the KYC providers Escrow account/wallets.\r\n     * Only after ICO Tokens are issued to the Contributor can the Swiss KYC provider allow the transfer\r\n     * of funds from their Escrow to Company.\r\n     *\r\n     * -- End ICO-Platform Note --\r\n     *\r\n     * @param to       The recipient of the tokens.\r\n     * @param value    The number of tokens to send.\r\n     */\r\n    function icoTransfer(address to, uint256 value) public onlyOwner {\r\n        require(!isIcoComplete, \"ICO is complete, use transfer().\");\r\n\r\n        // If an attempt is made to transfer more tokens than owned, transfer the remainder.\r\n        uint256 toTransfer = (value > (balances[msg.sender] - rewardPool_ )) ? (balances[msg.sender] - rewardPool_) : value;\r\n        \r\n        _transfer(msg.sender, to, toTransfer);\r\n\r\n        // Handle a referred account receiving tokens.\r\n        address referrer = referredBy[to];\r\n        if(referrer != address(0x0)) {\r\n            referredBy[to] = address(0x0);\r\n            awardReferralBonus(to, referrer, toTransfer);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * End the ICO phase in accordance with KYC procedures and clean up.\r\n     *\r\n     * ---- ICO-Platform Note ----\r\n     * The horizon-globex.com ICO platform's portal shall halt the ICO at the end of the \r\n     * Contribution Period, as defined in the ICO Terms and Conditions at timelessluxurygroup.com.\r\n     *\r\n     * -- End ICO-Platform Note --\r\n     */\r\n    function closeIco() public onlyOwner {\r\n        require(!isIcoComplete, \"The ICO phase has already ended, you cannot close it again.\");\r\n        require((balances[owner] - rewardPool_) == 0, \"Cannot close ICO when a balance remains in the owner account.\");\r\n\r\n        isIcoComplete = true;\r\n        delete kycHashes;\r\n        delete kycValidated;\r\n\r\n        emit IcoComplete();\r\n    }\r\n\t\r\n    /**\r\n     * Internal transfer, can only be called by this contract\r\n     *\r\n     * @param from     The sender of the tokens.\r\n     * @param to       The recipient of the tokens.\r\n     * @param value    The number of tokens to send.\r\n     */\r\n    function _transfer(address from, address to, uint256 value) internal returns (bool) {\r\n        require(from != address(0x0), \"Cannot send tokens from null address\");\r\n        require(to != address(0x0), \"Cannot transfer tokens to null\");\r\n        require(balances[from] >= value, \"Insufficient funds\");\r\n\r\n        // Quick exit for zero, but allow it in case this transfer is part of a chain.\r\n        if(value == 0)\r\n            return true;\r\n\t\t\r\n        // Perform the transfer.\r\n        balances[from] = balances[from].sub(value);\r\n        balances[to] = balances[to].add(value);\r\n\t\t\r\n        // Any tokens sent to to owner are implicitly burned.\r\n        if (to == owner) {\r\n            _burn(to, value);\r\n        }\r\n\r\n        return true;\r\n    }\r\n    \r\n    /**\r\n     * Permanently mint tokens to increase the totalSupply_.\r\n     *\r\n     * @param value            The number of tokens to mint.\r\n     */\r\n    function mint(uint256 value) public onlyIssuer {\r\n        require(value > 0, \"Tokens to mint must be greater than zero\");\r\n        balances[owner] = balances[owner].add(value);\r\n        totalSupply_ = totalSupply_.add(value);\r\n        \r\n        emit Mint(msg.sender, value);\r\n        \r\n    }\r\n    \r\n    /**\r\n     * Permanently destroy tokens from totalSupply_.\r\n     *\r\n     * @param value            The number of tokens to burn.\r\n     */\r\n    function burn(uint256 value) public onlyIssuer {\r\n        _burn(owner, value);\r\n    }\r\n\r\n    /**\r\n     * Permanently destroy tokens belonging to a user.\r\n     *\r\n     * @param addressToBurn    The owner of the tokens to burn.\r\n     * @param value            The number of tokens to burn.\r\n     */\r\n    function _burn(address addressToBurn, uint256 value) private returns (bool success) {\r\n        require(value > 0, \"Tokens to burn must be greater than zero\");\r\n        require(balances[addressToBurn] >= value, \"Tokens to burn exceeds balance\");\r\n\r\n        balances[addressToBurn] = balances[addressToBurn].sub(value);\r\n        totalSupply_ = totalSupply_.sub(value);\r\n\r\n        emit Burn(msg.sender, value);\r\n\r\n        return true;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"regulatorApprovedKycProvider\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"issuer\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"balances\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"kycValidated\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"closeIco\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"who\",\"type\":\"address\"}],\"name\":\"setIssuer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"who\",\"type\":\"address\"}],\"name\":\"kycApproved\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rewardPool\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"kycHashes\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"who\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rewardPool_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"referredBy\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"sha\",\"type\":\"bytes32\"}],\"name\":\"setKycHash\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"icoTransfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getKycHash\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_approver\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"who\",\"type\":\"address\"}],\"name\":\"setKycProvider\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isIcoComplete\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"referrer\",\"type\":\"address\"},{\"name\":\"referee\",\"type\":\"address\"}],\"name\":\"refer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getKycApproved\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"oldValue\",\"type\":\"uint256\"}],\"name\":\"safeApprove\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"totalSupply\",\"type\":\"uint256\"},{\"name\":\"_name\",\"type\":\"string\"},{\"name\":\"_symbol\",\"type\":\"string\"},{\"name\":\"_rewardPool\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"IcoComplete\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Burn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Mint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"referrer\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"referee\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"ReferralRedeemed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"approver\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"ICOToken","CompilerVersion":"v0.5.0+commit.1d4f565a","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"0000000000000000000000000000000000000000000000000000000005f5e100000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000c00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001554696d656c657373204c75787572792047726f757000000000000000000000000000000000000000000000000000000000000000000000000000000000000003544c470000000000000000000000000000000000000000000000000000000000","Library":"","SwarmSource":"bzzr://90a3c038361ae1e54c6df63361fd4ffe8b3d397f2e09f97f8135b99931279d62"}]}