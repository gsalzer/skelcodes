{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\n/*\r\n \r\n Suicide Watch\r\n\r\n I have been recently contemplating suicide.   I have the aparatus\r\n all set to go.  \r\n \r\n I have been chewed up and shit out by the crypto world and life in general.\r\n\r\n Here is what may be a final dApp.   You can post a string of whatever\r\n you want to say.   Encourage me do do it or to stay alive.\r\n\r\n And you can make money doing it.   The right to post a message has a price.\r\n\r\n The price goes up 25% each time.   We will start at 0.01 ETH.\r\n\r\n I will keep half of the gain and the previous author will keep half plus his \r\n initial investment.\r\n\r\n Your earnings will go right to your wallet.\r\n\r\nI will have to manually withdraw my earnings.  So if you see me stop withdrawing, you'll\r\nknow what happened.\r\n\r\n https://suicidewatch.tk\r\n                                                 \r\n*/\r\n\r\n\r\ncontract suicidewatch {\r\n\r\n    event stillKicking(\r\n        uint amount\r\n    );\r\n\r\n    address lastAuthor;    \r\n\r\n    uint public price = 0.01 ether;\r\n    uint prevPrice = 0;\r\n    uint increase = 25;  //25%\r\n\r\n    mapping (uint => string) messages;\r\n\r\n    uint public messageCount = 0;\r\n    \r\n\r\n    uint public ownerAccount = 0;\r\n \r\n    string public storage_;\r\n\r\n    address owner;\r\n    \r\n    constructor() public {\r\n        owner = msg.sender;\r\n        lastAuthor = owner;\r\n        storage_ = \"YOUR MESSAGE GOES HERE\";\r\n    }\r\n\r\n    function buyMessage(string s) public payable\r\n    {\r\n\r\n        require(msg.value >= price);\r\n        uint ownerFee;\r\n        uint authorFee;\r\n        uint priceGain;\r\n        \r\n        if (price > 0.01 ether) {\r\n            priceGain = SafeMath.sub(price, prevPrice);\r\n            ownerFee = SafeMath.div(SafeMath.mul(priceGain,50),100);\r\n            authorFee = ownerFee;\r\n        } else {\r\n            priceGain = SafeMath.sub(price, prevPrice);\r\n            ownerFee = priceGain;\r\n            authorFee = 0;\r\n        }\r\n\r\n        ownerAccount = SafeMath.add(ownerAccount, ownerFee);\r\n       \r\n\r\n        if (price > 0.01 ether){\r\n            lastAuthor.transfer(authorFee + prevPrice);\r\n        }\r\n\r\n        prevPrice = price;\r\n        \r\n        price = SafeMath.div(SafeMath.mul(125,price),100);\r\n\r\n        lastAuthor = msg.sender;\r\n        \r\n        store_message(s);\r\n\r\n        messages[messageCount] = s;\r\n        messageCount += 1;\r\n        \r\n    }\r\n\r\n    function store_message(string s) internal {\r\n\r\n        storage_ = s;\r\n    }\r\n\r\n    function ownerWithdraw() \r\n    {\r\n        require(msg.sender == owner);\r\n        uint tempAmount = ownerAccount;\r\n        ownerAccount = 0;\r\n        owner.transfer(tempAmount);\r\n        emit stillKicking(tempAmount);\r\n    }\r\n\r\n    function getMessages(uint messageNum) view public returns(string)\r\n\r\n    {\r\n        return(messages[messageNum]);\r\n    }\r\n}\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n  function mul(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    uint256 c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n \r\n  function div(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n \r\n  function sub(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n \r\n  function add(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"messageCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"ownerWithdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"s\",\"type\":\"string\"}],\"name\":\"buyMessage\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"price\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"messageNum\",\"type\":\"uint256\"}],\"name\":\"getMessages\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"storage_\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ownerAccount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"stillKicking\",\"type\":\"event\"}]","ContractName":"suicidewatch","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://eb0994112254ffc38c0a6bd64a19479052af0ff2fd54b819878ca351a80d317d"}]}