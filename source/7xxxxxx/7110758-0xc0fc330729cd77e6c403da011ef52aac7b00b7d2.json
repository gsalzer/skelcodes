{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.25;\r\n\r\nlibrary SafeMath256 {\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a / b;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n\r\n    function pow(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) return 0;\r\n        if (b == 0) return 1;\r\n\r\n        uint256 c = a ** b;\r\n        assert(c / (a ** (b - 1)) == a);\r\n        return c;\r\n    }\r\n}\r\n\r\ncontract Ownable {\r\n    address public owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    function _validateAddress(address _addr) internal pure {\r\n        require(_addr != address(0), \"invalid address\");\r\n    }\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"not a contract owner\");\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _validateAddress(newOwner);\r\n        emit OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n\r\n}\r\n\r\ncontract Pausable is Ownable {\r\n    event Pause();\r\n    event Unpause();\r\n\r\n    bool public paused = false;\r\n\r\n    modifier whenNotPaused() {\r\n        require(!paused, \"contract is paused\");\r\n        _;\r\n    }\r\n\r\n    modifier whenPaused() {\r\n        require(paused, \"contract is not paused\");\r\n        _;\r\n    }\r\n\r\n    function pause() public onlyOwner whenNotPaused {\r\n        paused = true;\r\n        emit Pause();\r\n    }\r\n\r\n    function unpause() public onlyOwner whenPaused {\r\n        paused = false;\r\n        emit Unpause();\r\n    }\r\n}\r\n\r\ncontract Controllable is Ownable {\r\n    mapping(address => bool) controllers;\r\n\r\n    modifier onlyController {\r\n        require(_isController(msg.sender), \"no controller rights\");\r\n        _;\r\n    }\r\n\r\n    function _isController(address _controller) internal view returns (bool) {\r\n        return controllers[_controller];\r\n    }\r\n\r\n    function _setControllers(address[] _controllers) internal {\r\n        for (uint256 i = 0; i < _controllers.length; i++) {\r\n            _validateAddress(_controllers[i]);\r\n            controllers[_controllers[i]] = true;\r\n        }\r\n    }\r\n}\r\n\r\ncontract Upgradable is Controllable {\r\n    address[] internalDependencies;\r\n    address[] externalDependencies;\r\n\r\n    function getInternalDependencies() public view returns(address[]) {\r\n        return internalDependencies;\r\n    }\r\n\r\n    function getExternalDependencies() public view returns(address[]) {\r\n        return externalDependencies;\r\n    }\r\n\r\n    function setInternalDependencies(address[] _newDependencies) public onlyOwner {\r\n        for (uint256 i = 0; i < _newDependencies.length; i++) {\r\n            _validateAddress(_newDependencies[i]);\r\n        }\r\n        internalDependencies = _newDependencies;\r\n    }\r\n\r\n    function setExternalDependencies(address[] _newDependencies) public onlyOwner {\r\n        externalDependencies = _newDependencies;\r\n        _setControllers(_newDependencies);\r\n    }\r\n}\r\n\r\ncontract Battle {\r\n    function start(uint256, uint256, uint8[2], uint8[2], uint256, bool) external returns (uint256[2], uint32, uint32, uint32, uint32, uint256);\r\n}\r\n\r\ncontract Treasury {\r\n    function takeGold(uint256) external;\r\n}\r\n\r\ncontract Random {\r\n    function random(uint256) external view returns (uint256);\r\n    function randomOfBlock(uint256, uint256) external view returns (uint256);\r\n}\r\n\r\ncontract Getter {\r\n    function getDragonStrength(uint256) external view returns (uint32);\r\n    function isDragonOwner(address, uint256) external view returns (bool);\r\n    function isDragonInGladiatorBattle(uint256) public view returns (bool);\r\n    function isDragonOnSale(uint256) public view returns (bool);\r\n    function isBreedingOnSale(uint256) public view returns (bool);\r\n}\r\n\r\ncontract Gold {\r\n    function remoteTransfer(address _to, uint256 _value) external;\r\n}\r\n\r\ncontract GladiatorBattleStorage {\r\n    function challengesAmount() external view returns (uint256);\r\n    function battleOccurred(uint256) external view returns (bool);\r\n    function challengeCancelled(uint256) external view returns (bool);\r\n    function getChallengeApplicants(uint256) external view returns (uint256[]);\r\n    function challengeApplicantsAmount(uint256) external view returns (uint256);\r\n    function userApplicationIndex(address, uint256) external view returns (uint256, bool, uint256);\r\n    function challenges(uint256) external view returns (bool, uint256, uint256);\r\n    function challengeCompensation(uint256) external view returns (uint256);\r\n    function getDragonApplication(uint256) external view returns (uint256, uint8[2], address);\r\n    function battleBlockNumber(uint256) external view returns (uint256);\r\n    function creator(uint256) external view returns (address, uint256);\r\n    function opponent(uint256) external view returns (address, uint256);\r\n    function winner(uint256) external view returns (address, uint256);\r\n    function setCompensation(uint256, uint256) external;\r\n    function create(bool, uint256, uint16) external returns (uint256);\r\n    function addUserChallenge(address, uint256) external;\r\n    function addUserApplication(address, uint256, uint256) external;\r\n    function removeUserApplication(address, uint256) external;\r\n    function addChallengeApplicant(uint256, uint256) external;\r\n    function setCreator(uint256, address, uint256) external;\r\n    function setOpponent(uint256, address, uint256) external;\r\n    function setWinner(uint256, address, uint256) external;\r\n    function setDragonApplication(uint256, uint256, uint8[2], address) external;\r\n    function removeDragonApplication(uint256, uint256) external;\r\n    function setBattleBlockNumber(uint256, uint256) external;\r\n    function setAutoSelectBlock(uint256, uint256) external;\r\n    function autoSelectBlock(uint256) external view returns (uint256);\r\n    function challengeApplicants(uint256, uint256) external view returns (uint256);\r\n    function payOut(address, bool, uint256) external;\r\n    function setBattleOccurred(uint256) external;\r\n    function setChallengeCancelled(uint256) external;\r\n    function setChallengeBattleId(uint256, uint256) external;\r\n    function getExtensionTimePrice(uint256) external view returns (uint256);\r\n    function setExtensionTimePrice(uint256, uint256) external;\r\n}\r\n\r\ncontract GladiatorBattleSpectatorsStorage {\r\n    function challengeBetsValue(uint256, bool) external view returns (uint256);\r\n    function challengeBalance(uint256) external view returns (uint256);\r\n    function payOut(address, bool, uint256) external;\r\n    function setChallengeBalance(uint256, uint256) external;\r\n}\r\n\r\n\r\ncontract GladiatorBattle is Upgradable {\r\n    using SafeMath256 for uint256;\r\n\r\n    Battle battle;\r\n    Random random;\r\n    Gold goldTokens;\r\n    Getter getter;\r\n    Treasury treasury;\r\n    GladiatorBattleStorage _storage_;\r\n    GladiatorBattleSpectatorsStorage spectatorsStorage;\r\n\r\n    uint8 constant MAX_TACTICS_PERCENTAGE = 80;\r\n    uint8 constant MIN_TACTICS_PERCENTAGE = 20;\r\n    uint8 constant MAX_DRAGON_STRENGTH_PERCENTAGE = 120;\r\n    uint8 constant PERCENTAGE = 100;\r\n    uint256 AUTO_SELECT_TIME = 6000; // in blocks\r\n    uint256 INTERVAL_FOR_NEW_BLOCK = 1000; // in blocks\r\n\r\n    function() external payable {}\r\n\r\n    function _safeSub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return b > a ? 0 : a.sub(b);\r\n    }\r\n\r\n    function _payForBet(\r\n        uint256 _value,\r\n        bool _isGold,\r\n        uint256 _bet\r\n    ) internal {\r\n        if (_isGold) {\r\n            require(_value == 0, \"specify isGold as false to send eth\");\r\n            goldTokens.remoteTransfer(address(_storage_), _bet);\r\n        } else {\r\n            require(_value == _bet, \"wrong eth amount\");\r\n            address(_storage_).transfer(_value);\r\n        }\r\n    }\r\n\r\n    function _validateChallengeId(uint256 _challengeId) internal view {\r\n        require(\r\n            _challengeId > 0 &&\r\n            _challengeId < _storage_.challengesAmount(),\r\n            \"wrong challenge id\"\r\n        );\r\n    }\r\n\r\n    function _validateTactics(uint8[2] _tactics) internal pure {\r\n        require(\r\n            _tactics[0] >= MIN_TACTICS_PERCENTAGE &&\r\n            _tactics[0] <= MAX_TACTICS_PERCENTAGE &&\r\n            _tactics[1] >= MIN_TACTICS_PERCENTAGE &&\r\n            _tactics[1] <= MAX_TACTICS_PERCENTAGE,\r\n            \"tactics value must be between 20 and 80\"\r\n        );\r\n    }\r\n\r\n    function _checkDragonAvailability(address _user, uint256 _dragonId) internal view {\r\n        require(getter.isDragonOwner(_user, _dragonId), \"not a dragon owner\");\r\n        require(!getter.isDragonOnSale(_dragonId), \"dragon is on sale\");\r\n        require(!getter.isBreedingOnSale(_dragonId), \"dragon is on breeding sale\");\r\n        require(!isDragonChallenging(_dragonId), \"this dragon has already applied\");\r\n    }\r\n\r\n    function _checkTheBattleHasNotOccurred(uint256 _challengeId) internal view {\r\n        require(!_storage_.battleOccurred(_challengeId), \"the battle has already occurred\");\r\n    }\r\n\r\n    function _checkTheChallengeIsNotCancelled(uint256 _id) internal view {\r\n        require(!_storage_.challengeCancelled(_id), \"the challenge is cancelled\");\r\n    }\r\n\r\n    function _checkTheOpponentIsNotSelected(uint256 _id) internal view {\r\n        require(!_isOpponentSelected(_id), \"opponent already selected\");\r\n    }\r\n\r\n    function _checkThatTimeHasCome(uint256 _blockNumber) internal view {\r\n        require(_blockNumber <= block.number, \"time has not yet come\");\r\n    }\r\n\r\n    function _checkChallengeCreator(uint256 _id, address _user) internal view {\r\n        (address _creator, ) = _getCreator(_id);\r\n        require(_creator == _user, \"not a challenge creator\");\r\n    }\r\n\r\n    function _checkForApplicants(uint256 _id) internal view {\r\n        require(_getChallengeApplicantsAmount(_id) > 0, \"no applicants\");\r\n    }\r\n\r\n    function _compareApplicantsArrays(uint256 _challengeId, bytes32 _hash) internal view {\r\n        uint256[] memory _applicants = _storage_.getChallengeApplicants(_challengeId);\r\n        require(keccak256(abi.encode(_applicants)) == _hash, \"wrong applicants array\");\r\n    }\r\n\r\n    function _compareDragonStrength(uint256 _challengeId, uint256 _applicantId) internal view {\r\n        ( , uint256 _dragonId) = _getCreator(_challengeId);\r\n        uint256 _strength = getter.getDragonStrength(_dragonId);\r\n        uint256 _applicantStrength = getter.getDragonStrength(_applicantId);\r\n        uint256 _maxStrength = _strength.mul(MAX_DRAGON_STRENGTH_PERCENTAGE).div(PERCENTAGE); // +20%\r\n        require(_applicantStrength <= _maxStrength, \"too strong dragon\");\r\n    }\r\n\r\n    function _setChallengeCompensation(\r\n        uint256 _challengeId,\r\n        uint256 _bet,\r\n        uint256 _applicantsAmount\r\n    ) internal {\r\n        // 30% of a bet\r\n        _storage_.setCompensation(_challengeId, _bet.mul(3).div(10).div(_applicantsAmount));\r\n    }\r\n\r\n    function _isOpponentSelected(uint256 _challengeId) internal view returns (bool) {\r\n        ( , uint256 _dragonId) = _getOpponent(_challengeId);\r\n        return _dragonId != 0;\r\n    }\r\n\r\n    function _getChallengeApplicantsAmount(\r\n        uint256 _challengeId\r\n    ) internal view returns (uint256) {\r\n        return _storage_.challengeApplicantsAmount(_challengeId);\r\n    }\r\n\r\n    function _getUserApplicationIndex(\r\n        address _user,\r\n        uint256 _challengeId\r\n    ) internal view returns (uint256, bool, uint256) {\r\n        return _storage_.userApplicationIndex(_user, _challengeId);\r\n    }\r\n\r\n    function _getChallenge(\r\n        uint256 _id\r\n    ) internal view returns (bool, uint256, uint256) {\r\n        return _storage_.challenges(_id);\r\n    }\r\n\r\n    function _getCompensation(\r\n        uint256 _id\r\n    ) internal view returns (uint256) {\r\n        return _storage_.challengeCompensation(_id);\r\n    }\r\n\r\n    function _getDragonApplication(\r\n        uint256 _id\r\n    ) internal view returns (uint256, uint8[2], address) {\r\n        return _storage_.getDragonApplication(_id);\r\n    }\r\n\r\n    function _getBattleBlockNumber(\r\n        uint256 _id\r\n    ) internal view returns (uint256) {\r\n        return _storage_.battleBlockNumber(_id);\r\n    }\r\n\r\n    function _getCreator(\r\n        uint256 _id\r\n    ) internal view returns (address, uint256) {\r\n        return _storage_.creator(_id);\r\n    }\r\n\r\n    function _getOpponent(\r\n        uint256 _id\r\n    ) internal view returns (address, uint256) {\r\n        return _storage_.opponent(_id);\r\n    }\r\n\r\n    function _getSpectatorsBetsValue(\r\n        uint256 _challengeId,\r\n        bool _onCreator\r\n    ) internal view returns (uint256) {\r\n        return spectatorsStorage.challengeBetsValue(_challengeId, _onCreator);\r\n    }\r\n\r\n    function isDragonChallenging(uint256 _dragonId) public view returns (bool) {\r\n        (uint256 _challengeId, , ) = _getDragonApplication(_dragonId);\r\n        if (_challengeId != 0) {\r\n            if (_storage_.challengeCancelled(_challengeId)) {\r\n                return false;\r\n            }\r\n            ( , uint256 _owner) = _getCreator(_challengeId);\r\n            ( , uint256 _opponent) = _getOpponent(_challengeId);\r\n            bool _isParticipant = (_dragonId == _owner) || (_dragonId == _opponent);\r\n\r\n            if (_isParticipant) {\r\n                return !_storage_.battleOccurred(_challengeId);\r\n            }\r\n            return !_isOpponentSelected(_challengeId);\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function create(\r\n        address _user,\r\n        uint256 _dragonId,\r\n        uint8[2] _tactics,\r\n        bool _isGold,\r\n        uint256 _bet,\r\n        uint16 _counter,\r\n        uint256 _value // in eth\r\n    ) external onlyController returns (uint256 challengeId) {\r\n        _validateTactics(_tactics);\r\n        _checkDragonAvailability(_user, _dragonId);\r\n        require(_counter >= 5, \"too few blocks\");\r\n\r\n        _payForBet(_value, _isGold, _bet);\r\n\r\n        challengeId = _storage_.create(_isGold, _bet, _counter);\r\n        _storage_.addUserChallenge(_user, challengeId);\r\n        _storage_.setCreator(challengeId, _user, _dragonId);\r\n        _storage_.setDragonApplication(_dragonId, challengeId, _tactics, _user);\r\n    }\r\n\r\n    function apply(\r\n        uint256 _challengeId,\r\n        address _user,\r\n        uint256 _dragonId,\r\n        uint8[2] _tactics,\r\n        uint256 _value // in eth\r\n    ) external onlyController {\r\n        _validateChallengeId(_challengeId);\r\n        _validateTactics(_tactics);\r\n        _checkTheBattleHasNotOccurred(_challengeId);\r\n        _checkTheChallengeIsNotCancelled(_challengeId);\r\n        _checkTheOpponentIsNotSelected(_challengeId);\r\n        _checkDragonAvailability(_user, _dragonId);\r\n        _compareDragonStrength(_challengeId, _dragonId);\r\n        ( , bool _exist, ) = _getUserApplicationIndex(_user, _challengeId);\r\n        require(!_exist, \"you have already applied\");\r\n\r\n        (bool _isGold, uint256 _bet, ) = _getChallenge(_challengeId);\r\n\r\n        _payForBet(_value, _isGold, _bet);\r\n\r\n        _storage_.addUserApplication(_user, _challengeId, _dragonId);\r\n        _storage_.setDragonApplication(_dragonId, _challengeId, _tactics, _user);\r\n        _storage_.addChallengeApplicant(_challengeId, _dragonId);\r\n\r\n        // if it's the first applicant then set auto select block\r\n        if (_getChallengeApplicantsAmount(_challengeId) == 1) {\r\n            _storage_.setAutoSelectBlock(_challengeId, block.number.add(AUTO_SELECT_TIME));\r\n        }\r\n    }\r\n\r\n    function chooseOpponent(\r\n        address _user,\r\n        uint256 _challengeId,\r\n        uint256 _applicantId,\r\n        bytes32 _applicantsHash\r\n    ) external onlyController {\r\n        _validateChallengeId(_challengeId);\r\n        _checkChallengeCreator(_challengeId, _user);\r\n        _compareApplicantsArrays(_challengeId, _applicantsHash);\r\n        _selectOpponent(_challengeId, _applicantId);\r\n    }\r\n\r\n    function autoSelectOpponent(\r\n        uint256 _challengeId,\r\n        bytes32 _applicantsHash\r\n    ) external onlyController returns (uint256 applicantId) {\r\n        _validateChallengeId(_challengeId);\r\n        _compareApplicantsArrays(_challengeId, _applicantsHash);\r\n        uint256 _autoSelectBlock = _storage_.autoSelectBlock(_challengeId);\r\n        require(_autoSelectBlock != 0, \"no auto select\");\r\n        _checkThatTimeHasCome(_autoSelectBlock);\r\n\r\n        _checkForApplicants(_challengeId);\r\n\r\n        uint256 _applicantsAmount = _getChallengeApplicantsAmount(_challengeId);\r\n        uint256 _index = random.random(2**256 - 1) % _applicantsAmount;\r\n        applicantId = _storage_.challengeApplicants(_challengeId, _index);\r\n\r\n        _selectOpponent(_challengeId, applicantId);\r\n    }\r\n\r\n    function _selectOpponent(uint256 _challengeId, uint256 _dragonId) internal {\r\n        _checkTheChallengeIsNotCancelled(_challengeId);\r\n        _checkTheOpponentIsNotSelected(_challengeId);\r\n\r\n        (\r\n            uint256 _dragonChallengeId, ,\r\n            address _opponentUser\r\n        ) = _getDragonApplication(_dragonId);\r\n        ( , uint256 _creatorDragonId) = _getCreator(_challengeId);\r\n\r\n        require(_dragonChallengeId == _challengeId, \"wrong opponent\");\r\n        require(_creatorDragonId != _dragonId, \"the same dragon\");\r\n\r\n        _storage_.setOpponent(_challengeId, _opponentUser, _dragonId);\r\n\r\n        ( , uint256 _bet, uint256 _counter) = _getChallenge(_challengeId);\r\n        _storage_.setBattleBlockNumber(_challengeId, block.number.add(_counter));\r\n\r\n        _storage_.addUserChallenge(_opponentUser, _challengeId);\r\n        _storage_.removeUserApplication(_opponentUser, _challengeId);\r\n\r\n        // if there are more applicants than one just selected then set challenge compensation\r\n        uint256 _applicantsAmount = _getChallengeApplicantsAmount(_challengeId);\r\n        if (_applicantsAmount > 1) {\r\n            uint256 _otherApplicants = _applicantsAmount.sub(1);\r\n            _setChallengeCompensation(_challengeId, _bet, _otherApplicants);\r\n        }\r\n    }\r\n\r\n    function _checkBattleBlockNumber(uint256 _blockNumber) internal view {\r\n        require(_blockNumber != 0, \"opponent is not selected\");\r\n        _checkThatTimeHasCome(_blockNumber);\r\n    }\r\n\r\n    function _checkBattlePossibilityAndGenerateRandom(uint256 _challengeId) internal view returns (uint256) {\r\n        uint256 _blockNumber = _getBattleBlockNumber(_challengeId);\r\n        _checkBattleBlockNumber(_blockNumber);\r\n        require(_blockNumber >= _safeSub(block.number, 256), \"time has passed\");\r\n        _checkTheBattleHasNotOccurred(_challengeId);\r\n        _checkTheChallengeIsNotCancelled(_challengeId);\r\n\r\n        return random.randomOfBlock(2**256 - 1, _blockNumber);\r\n    }\r\n\r\n    function _payReward(uint256 _challengeId) internal returns (uint256 reward, bool isGold) {\r\n        uint8 _factor = _getCompensation(_challengeId) > 0 ? 17 : 20;\r\n        uint256 _bet;\r\n        (isGold, _bet, ) = _getChallenge(_challengeId);\r\n        ( , uint256 _creatorId) = _getCreator(_challengeId);\r\n        (address _winner, uint256 _winnerId) = _storage_.winner(_challengeId);\r\n\r\n        reward = _bet.mul(_factor).div(10);\r\n        _storage_.payOut(\r\n            _winner,\r\n            isGold,\r\n            reward\r\n        ); // 30% of bet to applicants\r\n\r\n        bool _didCreatorWin = _creatorId == _winnerId;\r\n        uint256 _winnerBetsValue = _getSpectatorsBetsValue(_challengeId, _didCreatorWin);\r\n        uint256 _opponentBetsValue = _getSpectatorsBetsValue(_challengeId, !_didCreatorWin);\r\n        if (_opponentBetsValue > 0 && _winnerBetsValue > 0) {\r\n            uint256 _rewardFromSpectatorsBets = _opponentBetsValue.mul(15).div(100); // 15%\r\n\r\n            uint256 _challengeBalance = spectatorsStorage.challengeBalance(_challengeId);\r\n            require(_challengeBalance >= _rewardFromSpectatorsBets, \"not enough coins, something went wrong\");\r\n\r\n            spectatorsStorage.payOut(_winner, isGold, _rewardFromSpectatorsBets);\r\n\r\n            _challengeBalance = _challengeBalance.sub(_rewardFromSpectatorsBets);\r\n            spectatorsStorage.setChallengeBalance(_challengeId, _challengeBalance);\r\n\r\n            reward = reward.add(_rewardFromSpectatorsBets);\r\n        }\r\n    }\r\n\r\n    function _setWinner(uint256 _challengeId, uint256 _dragonId) internal {\r\n        ( , , address _user) = _getDragonApplication(_dragonId);\r\n        _storage_.setWinner(_challengeId, _user, _dragonId);\r\n    }\r\n\r\n    function start(\r\n        uint256 _challengeId\r\n    ) external onlyController returns (\r\n        uint256 seed,\r\n        uint256 battleId,\r\n        uint256 reward,\r\n        bool isGold\r\n    ) {\r\n        _validateChallengeId(_challengeId);\r\n        seed = _checkBattlePossibilityAndGenerateRandom(_challengeId);\r\n\r\n        ( , uint256 _firstDragonId) = _getCreator(_challengeId);\r\n        ( , uint256 _secondDragonId) = _getOpponent(_challengeId);\r\n\r\n        ( , uint8[2] memory _firstTactics, ) = _getDragonApplication(_firstDragonId);\r\n        ( , uint8[2] memory _secondTactics, ) = _getDragonApplication(_secondDragonId);\r\n\r\n        uint256[2] memory winnerLooserIds;\r\n        (\r\n            winnerLooserIds, , , , , battleId\r\n        ) = battle.start(\r\n            _firstDragonId,\r\n            _secondDragonId,\r\n            _firstTactics,\r\n            _secondTactics,\r\n            seed,\r\n            true\r\n        );\r\n\r\n        _setWinner(_challengeId, winnerLooserIds[0]);\r\n\r\n        _storage_.setBattleOccurred(_challengeId);\r\n        _storage_.setChallengeBattleId(_challengeId, battleId);\r\n\r\n        (reward, isGold) = _payReward(_challengeId);\r\n    }\r\n\r\n    function cancel(\r\n        address _user,\r\n        uint256 _challengeId,\r\n        bytes32 _applicantsHash\r\n    ) external onlyController {\r\n        _validateChallengeId(_challengeId);\r\n        _checkChallengeCreator(_challengeId, _user);\r\n        _checkTheOpponentIsNotSelected(_challengeId);\r\n        _checkTheChallengeIsNotCancelled(_challengeId);\r\n        _compareApplicantsArrays(_challengeId, _applicantsHash);\r\n\r\n        (bool _isGold, uint256 _value /* bet */, ) = _getChallenge(_challengeId);\r\n        uint256 _applicantsAmount = _getChallengeApplicantsAmount(_challengeId);\r\n        // if there are opponents then set challenge compensation\r\n        if (_applicantsAmount > 0) {\r\n            _setChallengeCompensation(_challengeId, _value, _applicantsAmount); // 30% to applicants\r\n            _value = _value.mul(7).div(10); // 70% to creator\r\n        }\r\n        _storage_.payOut(_user, _isGold, _value);\r\n        _storage_.setChallengeCancelled(_challengeId);\r\n    }\r\n\r\n    function returnBet(address _user, uint256 _challengeId) external onlyController {\r\n        _validateChallengeId(_challengeId);\r\n        ( , bool _exist, uint256 _dragonId) = _getUserApplicationIndex(_user, _challengeId);\r\n        require(_exist, \"wrong challenge\");\r\n\r\n        (bool _isGold, uint256 _bet, ) = _getChallenge(_challengeId);\r\n        uint256 _compensation = _getCompensation(_challengeId);\r\n        uint256 _value = _bet.add(_compensation);\r\n        _storage_.payOut(_user, _isGold, _value);\r\n        _storage_.removeDragonApplication(_dragonId, _challengeId);\r\n        _storage_.removeUserApplication(_user, _challengeId);\r\n\r\n        // if there are no more applicants then reset auto select block\r\n        if (_getChallengeApplicantsAmount(_challengeId) == 0) {\r\n            _storage_.setAutoSelectBlock(_challengeId, 0);\r\n        }\r\n    }\r\n\r\n    function addTimeForOpponentSelect(\r\n        address _user,\r\n        uint256 _challengeId\r\n    ) external onlyController returns (uint256 newAutoSelectBlock) {\r\n        _validateChallengeId(_challengeId);\r\n        _checkChallengeCreator(_challengeId, _user);\r\n        _checkForApplicants(_challengeId);\r\n        _checkTheOpponentIsNotSelected(_challengeId);\r\n        _checkTheChallengeIsNotCancelled(_challengeId);\r\n        uint256 _price = _storage_.getExtensionTimePrice(_challengeId);\r\n         // take gold\r\n        treasury.takeGold(_price);\r\n         // update multiplier\r\n        _storage_.setExtensionTimePrice(_challengeId, _price.mul(2));\r\n        // update auto select block\r\n        uint256 _autoSelectBlock = _storage_.autoSelectBlock(_challengeId);\r\n        newAutoSelectBlock = _autoSelectBlock.add(AUTO_SELECT_TIME);\r\n        _storage_.setAutoSelectBlock(_challengeId, newAutoSelectBlock);\r\n    }\r\n\r\n    function updateBattleBlockNumber(\r\n        uint256 _challengeId\r\n    ) external onlyController returns (uint256 newBattleBlockNumber) {\r\n        _validateChallengeId(_challengeId);\r\n        _checkTheBattleHasNotOccurred(_challengeId);\r\n        _checkTheChallengeIsNotCancelled(_challengeId);\r\n        uint256 _blockNumber = _getBattleBlockNumber(_challengeId);\r\n        _checkBattleBlockNumber(_blockNumber);\r\n        require(_blockNumber < _safeSub(block.number, 256), \"you can start a battle\");\r\n\r\n        newBattleBlockNumber = block.number.add(INTERVAL_FOR_NEW_BLOCK);\r\n        _storage_.setBattleBlockNumber(_challengeId, newBattleBlockNumber);\r\n    }\r\n\r\n    // UPDATE CONTRACT\r\n\r\n    function setInternalDependencies(address[] _newDependencies) public onlyOwner {\r\n        super.setInternalDependencies(_newDependencies);\r\n\r\n        battle = Battle(_newDependencies[0]);\r\n        random = Random(_newDependencies[1]);\r\n        goldTokens = Gold(_newDependencies[2]);\r\n        getter = Getter(_newDependencies[3]);\r\n        treasury = Treasury(_newDependencies[4]);\r\n        _storage_ = GladiatorBattleStorage(_newDependencies[5]);\r\n        spectatorsStorage = GladiatorBattleSpectatorsStorage(_newDependencies[6]);\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_user\",\"type\":\"address\"},{\"name\":\"_challengeId\",\"type\":\"uint256\"}],\"name\":\"addTimeForOpponentSelect\",\"outputs\":[{\"name\":\"newAutoSelectBlock\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_user\",\"type\":\"address\"},{\"name\":\"_challengeId\",\"type\":\"uint256\"}],\"name\":\"returnBet\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_user\",\"type\":\"address\"},{\"name\":\"_challengeId\",\"type\":\"uint256\"},{\"name\":\"_applicantId\",\"type\":\"uint256\"},{\"name\":\"_applicantsHash\",\"type\":\"bytes32\"}],\"name\":\"chooseOpponent\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newDependencies\",\"type\":\"address[]\"}],\"name\":\"setExternalDependencies\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newDependencies\",\"type\":\"address[]\"}],\"name\":\"setInternalDependencies\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_user\",\"type\":\"address\"},{\"name\":\"_challengeId\",\"type\":\"uint256\"},{\"name\":\"_applicantsHash\",\"type\":\"bytes32\"}],\"name\":\"cancel\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_user\",\"type\":\"address\"},{\"name\":\"_dragonId\",\"type\":\"uint256\"},{\"name\":\"_tactics\",\"type\":\"uint8[2]\"},{\"name\":\"_isGold\",\"type\":\"bool\"},{\"name\":\"_bet\",\"type\":\"uint256\"},{\"name\":\"_counter\",\"type\":\"uint16\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"create\",\"outputs\":[{\"name\":\"challengeId\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_challengeId\",\"type\":\"uint256\"}],\"name\":\"start\",\"outputs\":[{\"name\":\"seed\",\"type\":\"uint256\"},{\"name\":\"battleId\",\"type\":\"uint256\"},{\"name\":\"reward\",\"type\":\"uint256\"},{\"name\":\"isGold\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_challengeId\",\"type\":\"uint256\"},{\"name\":\"_applicantsHash\",\"type\":\"bytes32\"}],\"name\":\"autoSelectOpponent\",\"outputs\":[{\"name\":\"applicantId\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getInternalDependencies\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_dragonId\",\"type\":\"uint256\"}],\"name\":\"isDragonChallenging\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_challengeId\",\"type\":\"uint256\"},{\"name\":\"_user\",\"type\":\"address\"},{\"name\":\"_dragonId\",\"type\":\"uint256\"},{\"name\":\"_tactics\",\"type\":\"uint8[2]\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"apply\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getExternalDependencies\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_challengeId\",\"type\":\"uint256\"}],\"name\":\"updateBattleBlockNumber\",\"outputs\":[{\"name\":\"newBattleBlockNumber\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"GladiatorBattle","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://6333610e95a133c2a1d2c102b3c999b1688db8274f235373e38055c5a38806d4"}]}