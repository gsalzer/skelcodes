{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\n/*\r\n*   gibmireinbier\r\n*   0xA4a799086aE18D7db6C4b57f496B081b44888888\r\n*   gibmireinbier@gmail.com\r\n*/\r\n\r\ninterface WhitelistInterface {\r\n    function joinNetwork(address[6] _contract) public;\r\n    function isLimited(address _address, uint256 _invested) public view returns(bool);\r\n}\r\n\r\ninterface NewTokenInterface {\r\n    function swapToken(uint256 _amount, address _invester) public payable;\r\n}\r\n\r\ninterface BankInterface {\r\n    function joinNetwork(address[6] _contract) public;\r\n    // Core functions\r\n    function pushToBank(address _player) public payable;\r\n}\r\n\r\n\r\ninterface DevTeamInterface {\r\n    function setF2mAddress(address _address) public;\r\n    function setLotteryAddress(address _address) public;\r\n    function setCitizenAddress(address _address) public;\r\n    function setBankAddress(address _address) public;\r\n    function setRewardAddress(address _address) public;\r\n    function setWhitelistAddress(address _address) public;\r\n\r\n    function setupNetwork() public;\r\n}\r\n\r\ninterface LotteryInterface {\r\n    function joinNetwork(address[6] _contract) public;\r\n    // call one time\r\n    function activeFirstRound() public;\r\n    // Core Functions\r\n    function pushToPot() public payable;\r\n    function finalizeable() public view returns(bool);\r\n    // bounty\r\n    function finalize() public;\r\n    function buy(string _sSalt) public payable;\r\n    function buyFor(string _sSalt, address _sender) public payable;\r\n    //function withdraw() public;\r\n    function withdrawFor(address _sender) public returns(uint256);\r\n\r\n    function getRewardBalance(address _buyer) public view returns(uint256);\r\n    function getTotalPot() public view returns(uint256);\r\n    // EarlyIncome\r\n    function getEarlyIncomeByAddress(address _buyer) public view returns(uint256);\r\n    // included claimed amount\r\n    // function getEarlyIncomeByAddressRound(address _buyer, uint256 _rId) public view returns(uint256);\r\n    function getCurEarlyIncomeByAddress(address _buyer) public view returns(uint256);\r\n    // function getCurEarlyIncomeByAddressRound(address _buyer, uint256 _rId) public view returns(uint256);\r\n    function getCurRoundId() public view returns(uint256);\r\n    // set endRound, prepare to upgrade new version\r\n    function setLastRound(uint256 _lastRoundId) public;\r\n    function getPInvestedSumByRound(uint256 _rId, address _buyer) public view returns(uint256);\r\n    function cashoutable(address _address) public view returns(bool);\r\n    function isLastRound() public view returns(bool);\r\n}\r\ninterface CitizenInterface {\r\n \r\n    function joinNetwork(address[6] _contract) public;\r\n    /*----------  ADMINISTRATOR ONLY FUNCTIONS  ----------*/\r\n    function devTeamWithdraw() public;\r\n\r\n    /*----------  WRITE FUNCTIONS  ----------*/\r\n    function updateUsername(string _sNewUsername) public;\r\n    //Sources: Token contract, DApps\r\n    function pushRefIncome(address _sender) public payable;\r\n    function withdrawFor(address _sender) public payable returns(uint256);\r\n    function devTeamReinvest() public returns(uint256);\r\n\r\n    /*----------  READ FUNCTIONS  ----------*/\r\n    function getRefWallet(address _address) public view returns(uint256);\r\n}\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n    int256 constant private INT256_MIN = -2**255;\r\n\r\n    /**\r\n    * @dev Multiplies two unsigned integers, reverts on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Multiplies two signed integers, reverts on overflow.\r\n    */\r\n    function mul(int256 a, int256 b) internal pure returns (int256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        require(!(a == -1 && b == INT256_MIN)); // This is the only case of overflow not detected by the check below\r\n\r\n        int256 c = a * b;\r\n        require(c / a == b);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two signed integers truncating the quotient, reverts on division by zero.\r\n    */\r\n    function div(int256 a, int256 b) internal pure returns (int256) {\r\n        require(b != 0); // Solidity only automatically asserts when dividing by 0\r\n        require(!(b == -1 && a == INT256_MIN)); // This is the only case of overflow\r\n\r\n        int256 c = a / b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two signed integers, reverts on overflow.\r\n    */\r\n    function sub(int256 a, int256 b) internal pure returns (int256) {\r\n        int256 c = a - b;\r\n        require((b >= 0 && c <= a) || (b < 0 && c > a));\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two unsigned integers, reverts on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two signed integers, reverts on overflow.\r\n    */\r\n    function add(int256 a, int256 b) internal pure returns (int256) {\r\n        int256 c = a + b;\r\n        require((b >= 0 && c >= a) || (b < 0 && c < a));\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\r\n    * reverts when dividing by zero.\r\n    */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}\r\ncontract F2m{\r\n    using SafeMath for *;\r\n\r\n    // only token holder\r\n\r\n    modifier onlyTokenHolders() {\r\n        require(balances[msg.sender] > 0, \"not own any token\");\r\n        _;\r\n    }\r\n    \r\n    modifier onlyAdmin(){\r\n        require(msg.sender == devTeam, \"admin required\");\r\n        _;\r\n    }\r\n\r\n    modifier withdrawRight(){\r\n        require((msg.sender == address(bankContract)), \"Bank Only\");\r\n        _;\r\n    }\r\n\r\n    modifier swapNotActived() {\r\n        require(swapActived == false, \"swap actived, stop minting new tokens\");\r\n        _;\r\n    }\r\n\r\n    modifier buyable() {\r\n        require(buyActived == true, \"token sale not ready\");\r\n        _;\r\n    }\r\n    \r\n    /*==============================\r\n    =            EVENTS            =\r\n    ==============================*/  \r\n    // ERC20\r\n    event Transfer(address indexed from, address indexed to, uint tokens);\r\n    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\r\n    \r\n    /*=====================================\r\n    =                 ERC20               =\r\n    =====================================*/\r\n    uint256 public totalSupply;  \r\n    string public name;  \r\n    string public symbol;  \r\n    uint32 public decimals;\r\n    uint256 public unitRate;\r\n    // Balances for each account\r\n    mapping(address => uint256) balances;\r\n \r\n    // Owner of account approves the transfer of an amount to another account\r\n    mapping(address => mapping (address => uint256)) allowed;\r\n    \r\n   /*================================\r\n    =            DATASETS            =\r\n    ================================*/\r\n    CitizenInterface public citizenContract;\r\n    LotteryInterface public lotteryContract;\r\n    BankInterface public bankContract;\r\n    NewTokenInterface public newTokenContract;\r\n    WhitelistInterface public whitelistContract;\r\n\r\n    uint256 constant public ONE_HOUR= 3600;\r\n    uint256 constant public ONE_DAY = 24 * ONE_HOUR; // seconds\r\n    uint256 constant public FIRST_POT_MAXIMUM = 360 ether; // 800 * 45%\r\n    uint256 constant public ROUND0_MIN_DURATION = ONE_DAY; // minimum\r\n    uint256 constant public SWAP_DURATION = 30 * ONE_DAY;\r\n    uint256 constant public BEFORE_SLEEP_DURAION = 7 * ONE_DAY;\r\n\r\n    uint256 public HARD_TOTAL_SUPPLY = 8000000;\r\n\r\n    uint256 constant public refPercent = 15;\r\n    uint256 constant public divPercent = 10;\r\n    uint256 constant public fundPercent = 2;\r\n\r\n    //Start Price\r\n    uint256 constant public startPrice = 0.002 ether;\r\n    //Most Tolerable Break-Even Period (MTBEP)\r\n    uint256 constant public BEP = 30;\r\n\r\n    uint256 public potPercent = 45; // set to 0 in func disableRound0()\r\n\r\n    // amount of shares for each address (scaled number)\r\n    mapping(address => int256) public credit;\r\n    mapping(address => uint256) public withdrawnAmount;\r\n    mapping(address => uint256) public fromSellingAmount;\r\n\r\n    mapping(address => uint256) public lastActiveDay;\r\n    mapping(address => int256) public todayCredit;\r\n\r\n    mapping(address => uint256) public pInvestedSum;\r\n\r\n    uint256 public investedAmount;\r\n    uint256 public totalBuyVolume;\r\n    uint256 public totalSellVolume;\r\n    uint256 public totalDividends;\r\n    mapping(uint256 => uint256) public totalDividendsByRound;\r\n\r\n    //Profit Per Share \r\n    uint256 public pps = 0;\r\n\r\n    //log by round\r\n    mapping(uint256 => uint256) rPps;\r\n    mapping(address => mapping (uint256 => int256)) rCredit; \r\n\r\n    uint256 public deployedTime;\r\n    uint256 public deployedDay;\r\n\r\n    // on/off auto buy Token\r\n    bool public autoBuy;\r\n\r\n    bool public round0 = true; //raise for first round\r\n\r\n    //pps added in day\r\n    mapping(uint256 => uint256) public ppsInDay; //Avarage pps in a day\r\n    mapping(uint256 => uint256) public divInDay;\r\n    mapping(uint256 => uint256) public totalBuyVolumeInDay;\r\n    mapping(uint256 => uint256) public totalSellVolumeInDay;\r\n\r\n    address public devTeam; //Smart contract address\r\n\r\n    uint256 public swapTime;\r\n    bool public swapActived = false;\r\n    bool public buyActived = false;\r\n\r\n    /*=======================================\r\n    =            PUBLIC FUNCTIONS            =\r\n    =======================================*/\r\n    constructor (address _devTeam)\r\n        public\r\n    {\r\n        symbol = \"F2M\";  \r\n        name = \"Fomo2Moon\";  \r\n        decimals = 10;\r\n        unitRate = 10**uint256(decimals);\r\n        HARD_TOTAL_SUPPLY = HARD_TOTAL_SUPPLY * unitRate;\r\n        totalSupply = 0; \r\n        //deployedTime = block.timestamp;\r\n        DevTeamInterface(_devTeam).setF2mAddress(address(this));\r\n        devTeam = _devTeam;\r\n        autoBuy = true;\r\n    }\r\n\r\n    // _contract = [f2mAddress, bankAddress, citizenAddress, lotteryAddress, rewardAddress, whitelistAddress];\r\n    function joinNetwork(address[6] _contract)\r\n        public\r\n    {\r\n        require(address(citizenContract) == 0x0, \"already setup\");\r\n        bankContract = BankInterface(_contract[1]);\r\n        citizenContract = CitizenInterface(_contract[2]);\r\n        lotteryContract = LotteryInterface(_contract[3]);\r\n        whitelistContract = WhitelistInterface(_contract[5]);\r\n    }\r\n \r\n    function()\r\n        public\r\n        payable\r\n    {\r\n        // Thanks for Donation\r\n    }\r\n\r\n    // one time called, manuell called in case not reached 360ETH for totalPot\r\n    function disableRound0() \r\n        public \r\n        onlyAdmin() \r\n    {\r\n        require(buyActived && block.timestamp > ROUND0_MIN_DURATION.add(deployedTime), \"too early to disable Round0\");\r\n        round0 = false;\r\n        potPercent = 0;\r\n    }\r\n\r\n    function activeBuy()\r\n        public\r\n        onlyAdmin()\r\n    {\r\n        require(buyActived == false, \"already actived\");\r\n        buyActived = true;\r\n        deployedTime = block.timestamp;\r\n        deployedDay = getToday();\r\n    }\r\n\r\n    // Dividends from all sources (DApps, Donate ...)\r\n    function pushDividends() \r\n        public \r\n        payable \r\n    {\r\n        // shared to fund and dividends only\r\n        uint256 ethAmount = msg.value;\r\n        uint256 dividends = ethAmount * divPercent / (divPercent + fundPercent);\r\n        uint256 fund = ethAmount.sub(dividends);\r\n        uint256 _buyPrice = getBuyPrice();\r\n        distributeTax(fund, dividends, 0, 0);\r\n        if (autoBuy) devTeamAutoBuy(0, _buyPrice);\r\n    }\r\n\r\n    function addFund(uint256 _fund)\r\n        private\r\n    {\r\n        credit[devTeam] = credit[devTeam].sub(int256(_fund));\r\n    }\r\n\r\n    function addDividends(uint256 _dividends)\r\n        private\r\n    {\r\n        if (_dividends == 0) return;\r\n        totalDividends += _dividends;\r\n        uint256 today = getToday();\r\n        divInDay[today] = _dividends.add(divInDay[today]);\r\n\r\n        if (totalSupply == 0) {\r\n            addFund(_dividends);\r\n        } else {\r\n            // increased profit with each token\r\n            // gib mir n bier\r\n            addFund(_dividends % totalSupply);\r\n            uint256 deltaShare = _dividends / totalSupply;\r\n            pps = pps.add(deltaShare);\r\n\r\n            // logs\r\n            uint256 curRoundId = getCurRoundId();\r\n            rPps[curRoundId] += deltaShare;\r\n            totalDividendsByRound[curRoundId] += _dividends;\r\n            ppsInDay[today] = deltaShare + ppsInDay[today];\r\n        }\r\n    }\r\n\r\n    function addToRef(uint256 _toRef)\r\n        private\r\n    {\r\n        if (_toRef == 0) return;\r\n        address sender = msg.sender;\r\n        citizenContract.pushRefIncome.value(_toRef)(sender);\r\n    }\r\n\r\n    function addToPot(uint256 _toPot)\r\n        private\r\n    {\r\n        if (_toPot == 0) return;\r\n        lotteryContract.pushToPot.value(_toPot)();\r\n        uint256 _totalPot = lotteryContract.getTotalPot();\r\n\r\n        // auto disable Round0 if reached 360ETH for first round\r\n        if (_totalPot >= FIRST_POT_MAXIMUM) {\r\n            round0 = false;\r\n            potPercent = 0;\r\n        }\r\n    }\r\n\r\n    function distributeTax(\r\n        uint256 _fund,\r\n        uint256 _dividends,\r\n        uint256 _toRef,\r\n        uint256 _toPot)\r\n        private\r\n    {\r\n        addFund(_fund);\r\n        addDividends(_dividends);\r\n        addToRef(_toRef);\r\n        addToPot(_toPot);\r\n    }\r\n\r\n    function updateCredit(address _owner, uint256 _currentEthAmount, uint256 _rDividends, uint256 _todayDividends) \r\n        private \r\n    {\r\n        // basicly to keep ethBalance not changed, after token balances changed (minted or burned)\r\n        // ethBalance = pps * tokens -credit\r\n        uint256 curRoundId = getCurRoundId();\r\n        credit[_owner] = int256(pps.mul(balances[_owner])).sub(int256(_currentEthAmount));\r\n        // logs\r\n        rCredit[_owner][curRoundId] = int256(rPps[curRoundId] * balances[_owner]) - int256(_rDividends);\r\n        todayCredit[_owner] = int256(ppsInDay[getToday()] * balances[_owner]) - int256(_todayDividends);\r\n    }\r\n\r\n    function mintToken(address _buyer, uint256 _taxedAmount, uint256 _buyPrice) \r\n        private \r\n        swapNotActived()\r\n        buyable()\r\n        returns(uint256) \r\n    {\r\n        uint256 revTokens = ethToToken(_taxedAmount, _buyPrice);\r\n        investedAmount = investedAmount.add(_taxedAmount);\r\n        // lottery ticket buy could be blocked without this\r\n        // the 1% from ticket buy will increases tokenSellPrice when totalSupply capped\r\n        if (revTokens + totalSupply > HARD_TOTAL_SUPPLY) \r\n            revTokens = HARD_TOTAL_SUPPLY.sub(totalSupply);\r\n        balances[_buyer] = balances[_buyer].add(revTokens);\r\n        totalSupply = totalSupply.add(revTokens);\r\n        return revTokens;\r\n    }\r\n\r\n    function burnToken(address _seller, uint256 _tokenAmount) \r\n        private \r\n        returns (uint256) \r\n    {\r\n        require(balances[_seller] >= _tokenAmount, \"not enough to burn\");\r\n        uint256 revEthAmount = tokenToEth(_tokenAmount);\r\n        investedAmount = investedAmount.sub(revEthAmount);\r\n        balances[_seller] = balances[_seller].sub(_tokenAmount);\r\n        totalSupply = totalSupply.sub(_tokenAmount);\r\n        return revEthAmount;\r\n    }\r\n\r\n    function devTeamAutoBuy(uint256 _reserved, uint256 _buyPrice)\r\n        private\r\n    {\r\n        uint256 _refClaim = citizenContract.devTeamReinvest();\r\n        credit[devTeam] -= int256(_refClaim);\r\n        uint256 _ethAmount = ethBalance(devTeam);\r\n        if ((_ethAmount + _reserved) / _buyPrice + totalSupply > HARD_TOTAL_SUPPLY) return;\r\n\r\n        uint256 _rDividends = getRDividends(devTeam);\r\n        uint256 _todayDividends = getTodayDividendsByAddress(devTeam);\r\n        mintToken(devTeam, _ethAmount, _buyPrice);\r\n        updateCredit(devTeam, 0, _rDividends, _todayDividends);\r\n    }\r\n\r\n    function buy()\r\n        public\r\n        payable\r\n    {\r\n        address _buyer = msg.sender;\r\n        buyFor(_buyer);\r\n    }\r\n\r\n    function checkLimit(address _buyer)\r\n        private\r\n        view\r\n    {\r\n        require(!round0 || !whitelistContract.isLimited(_buyer, pInvestedSum[_buyer]), \"Limited\");\r\n    }\r\n\r\n    function buyFor(address _buyer) \r\n        public \r\n        payable\r\n    {\r\n        //ADD Round0 WHITE LIST\r\n        // tax = fund + dividends + toRef + toPot;\r\n        updateLastActive(_buyer);\r\n        uint256 _buyPrice = getBuyPrice();\r\n        uint256 ethAmount = msg.value;\r\n        pInvestedSum[_buyer] += ethAmount;\r\n        checkLimit(_buyer);\r\n        uint256 onePercent = ethAmount / 100;\r\n        uint256 fund = onePercent.mul(fundPercent);\r\n        uint256 dividends = onePercent.mul(divPercent);\r\n        uint256 toRef = onePercent.mul(refPercent);\r\n        uint256 toPot = onePercent.mul(potPercent);\r\n        uint256 tax = fund + dividends + toRef + toPot;\r\n        uint256 taxedAmount = ethAmount.sub(tax);\r\n        \r\n        totalBuyVolume = totalBuyVolume + ethAmount;\r\n        totalBuyVolumeInDay[getToday()] += ethAmount;\r\n\r\n        distributeTax(fund, dividends, toRef, toPot);\r\n        if (autoBuy) devTeamAutoBuy(taxedAmount, _buyPrice);\r\n\r\n        uint256 curEthBalance = ethBalance(_buyer);\r\n        uint256 _rDividends = getRDividends(_buyer);\r\n        uint256 _todayDividends = getTodayDividendsByAddress(_buyer);\r\n\r\n        mintToken(_buyer, taxedAmount, _buyPrice);\r\n        updateCredit(_buyer, curEthBalance, _rDividends, _todayDividends);\r\n    }\r\n\r\n    function sell(uint256 _tokenAmount)\r\n        public\r\n        onlyTokenHolders()\r\n    {\r\n        // tax = fund only\r\n        updateLastActive(msg.sender);\r\n        address seller = msg.sender;\r\n        uint256 curEthBalance = ethBalance(seller);\r\n        uint256 _rDividends = getRDividends(seller);\r\n        uint256 _todayDividends = getTodayDividendsByAddress(seller);\r\n\r\n        uint256 ethAmount = burnToken(seller, _tokenAmount);\r\n        uint256 fund = ethAmount.mul(fundPercent) / 100;\r\n        //uint256 tax = fund;\r\n        uint256 taxedAmount = ethAmount.sub(fund);\r\n\r\n        totalSellVolume = totalSellVolume + ethAmount;\r\n        totalSellVolumeInDay[getToday()] += ethAmount;\r\n        curEthBalance = curEthBalance.add(taxedAmount);\r\n        fromSellingAmount[seller] += taxedAmount;\r\n        \r\n        updateCredit(seller, curEthBalance, _rDividends, _todayDividends);\r\n        distributeTax(fund, 0, 0, 0);\r\n    }\r\n\r\n    function devTeamWithdraw()\r\n        public\r\n        returns(uint256)\r\n    {\r\n        address sender = msg.sender;\r\n        require(sender == devTeam, \"dev. Team only\");\r\n        uint256 amount = ethBalance(sender);\r\n        if (amount == 0) return 0;\r\n        credit[sender] += int256(amount);\r\n        withdrawnAmount[sender] = amount.add(withdrawnAmount[sender]);\r\n        devTeam.transfer(amount);\r\n        return amount;\r\n    }\r\n\r\n    function withdrawFor(address sender)\r\n        public\r\n        withdrawRight()\r\n        returns(uint256)\r\n    {\r\n        uint256 amount = ethBalance(sender);\r\n        if (amount == 0) return 0;\r\n        credit[sender] = credit[sender].add(int256(amount));\r\n        withdrawnAmount[sender] = amount.add(withdrawnAmount[sender]);\r\n        bankContract.pushToBank.value(amount)(sender);\r\n        return amount;\r\n    }\r\n\r\n    function updateAllowed(address _from, address _to, uint256 _tokenAmount)\r\n        private\r\n    {\r\n        require(balances[_from] >= _tokenAmount, \"not enough to transfer\");\r\n        if (_from != msg.sender)\r\n        allowed[_from][_to] = allowed[_from][_to].sub(_tokenAmount);\r\n    }\r\n    \r\n    function transferFrom(address _from, address _to, uint256 _tokenAmount)\r\n        public\r\n        returns(bool)\r\n    {   \r\n        updateAllowed(_from, _to, _tokenAmount);\r\n        updateLastActive(_from);\r\n        updateLastActive(_to);\r\n        // tax = 0\r\n\r\n        uint256 curEthBalance_from = ethBalance(_from);\r\n        uint256 _rDividends_from = getRDividends(_from);\r\n        uint256 _todayDividends_from = getTodayDividendsByAddress(_from);\r\n\r\n        uint256 curEthBalance_to = ethBalance(_to);\r\n        uint256 _rDividends_to = getRDividends(_to);\r\n        uint256 _todayDividends_to = getTodayDividendsByAddress(_to);\r\n\r\n        uint256 taxedTokenAmount = _tokenAmount;\r\n        balances[_from] -= taxedTokenAmount;\r\n        balances[_to] += taxedTokenAmount;\r\n        updateCredit(_from, curEthBalance_from, _rDividends_from, _todayDividends_from);\r\n        updateCredit(_to, curEthBalance_to, _rDividends_to, _todayDividends_to);\r\n        // distributeTax(tax, 0, 0, 0);\r\n        // fire event\r\n        emit Transfer(_from, _to, taxedTokenAmount);\r\n        \r\n        return true;\r\n    }\r\n\r\n    function transfer(address _to, uint256 _tokenAmount)\r\n        public \r\n        returns (bool) \r\n    {\r\n        transferFrom(msg.sender, _to, _tokenAmount);\r\n        return true;\r\n    }\r\n\r\n    function approve(address spender, uint tokens) \r\n        public \r\n        returns (bool success) \r\n    {\r\n        allowed[msg.sender][spender] = tokens;\r\n        emit Approval(msg.sender, spender, tokens);\r\n        return true;\r\n    }\r\n\r\n    function updateLastActive(address _sender) \r\n        private\r\n    {\r\n        if (lastActiveDay[_sender] != getToday()) {\r\n            lastActiveDay[_sender] = getToday();\r\n            todayCredit[_sender] = 0;\r\n        }\r\n    }\r\n    \r\n    /*----------  ADMINISTRATOR ONLY FUNCTIONS  ----------*/\r\n\r\n    function setAutoBuy() \r\n        public\r\n        onlyAdmin()\r\n    {\r\n        //require(buyActived && block.timestamp > ROUND0_MIN_DURATION.add(deployedTime), \"too early to disable autoBuy\");\r\n        autoBuy = !autoBuy;\r\n    }\r\n\r\n    /*----------  HELPERS AND CALCULATORS  ----------*/\r\n    function totalEthBalance()\r\n        public\r\n        view\r\n        returns(uint256)\r\n    {\r\n        return address(this).balance;\r\n    }\r\n    \r\n    function ethBalance(address _address)\r\n        public\r\n        view\r\n        returns(uint256)\r\n    {\r\n        return (uint256) ((int256)(pps.mul(balances[_address])).sub(credit[_address]));\r\n    }\r\n\r\n    function getTotalDividendsByAddress(address _invester)\r\n        public\r\n        view\r\n        returns(uint256)\r\n    {\r\n\r\n        return (ethBalance(_invester)) + (withdrawnAmount[_invester]) - (fromSellingAmount[_invester]);\r\n    }\r\n\r\n    function getTodayDividendsByAddress(address _invester)\r\n        public\r\n        view\r\n        returns(uint256)\r\n    {\r\n        int256 _todayCredit = (getToday() == lastActiveDay[_invester]) ? todayCredit[_invester] : 0;\r\n        return (uint256) ((int256)(ppsInDay[getToday()] * balances[_invester]) - _todayCredit);\r\n    }\r\n    \r\n    /*==========================================\r\n    =            public FUNCTIONS            =\r\n    ==========================================*/\r\n\r\n    /**\r\n     * Return the sell price of 1 individual token.\r\n     */\r\n    function getSellPrice() \r\n        public \r\n        view \r\n        returns(uint256)\r\n    {\r\n        if (totalSupply == 0) {\r\n            return 0;\r\n        } else {\r\n            return investedAmount / totalSupply;\r\n        }\r\n    }\r\n\r\n    function getSellPriceAfterTax() \r\n        public \r\n        view \r\n        returns(uint256)\r\n    {\r\n        uint256 _sellPrice = getSellPrice();\r\n        uint256 taxPercent = fundPercent;\r\n        return _sellPrice * (100 - taxPercent) / 100;\r\n    }\r\n    \r\n    /**\r\n     * Return the buy price of 1 individual token.\r\n     * Start Price + (7-day Average Dividend Payout) x BEP x HARD_TOTAL_SUPPLY / (Total No. of Circulating Tokens) / (HARD_TOTAL_SUPPLY - Total No. of Circulating Tokens + 1)\r\n     */\r\n    function getBuyPrice() \r\n        public \r\n        view \r\n        returns(uint256)\r\n    {\r\n        // average profit per share of a day in week\r\n        uint256 taxPercent = fundPercent + potPercent + divPercent + refPercent;\r\n        if (round0) return startPrice * (100 - taxPercent) / 100 / unitRate;\r\n        uint256 avgPps = getAvgPps();\r\n        uint256 _sellPrice = getSellPrice();\r\n        uint256 _buyPrice = (startPrice / unitRate + avgPps * BEP * HARD_TOTAL_SUPPLY / (HARD_TOTAL_SUPPLY + unitRate - totalSupply)) * (100 - taxPercent) / 100;\r\n        if (_buyPrice < _sellPrice) return _sellPrice;\r\n        return _buyPrice;\r\n    }\r\n\r\n    function getBuyPriceAfterTax()\r\n        public \r\n        view \r\n        returns(uint256)\r\n    {\r\n        // average profit per share of a day in week\r\n        uint256 _buyPrice = getBuyPrice();\r\n        uint256 taxPercent = fundPercent + potPercent + divPercent + refPercent;\r\n        return _buyPrice * 100 / (100 - taxPercent);\r\n    }\r\n\r\n    function ethToToken(uint256 _ethAmount, uint256 _buyPrice)\r\n        public\r\n        pure\r\n        returns(uint256)\r\n    {\r\n        return _ethAmount / _buyPrice;\r\n    }\r\n\r\n/*     function ethToTokenRest(uint256 _ethAmount, uint256 _buyPrice)\r\n        public\r\n        pure\r\n        returns(uint256)\r\n    {\r\n        return _ethAmount % _buyPrice;\r\n    } */\r\n    \r\n    function tokenToEth(uint256 _tokenAmount)\r\n        public\r\n        view\r\n        returns(uint256)\r\n    {\r\n        uint256 sellPrice = getSellPrice();\r\n        return _tokenAmount.mul(sellPrice);\r\n    }\r\n    \r\n    function getToday() \r\n        public \r\n        view \r\n        returns (uint256) \r\n    {\r\n        return (block.timestamp / ONE_DAY);\r\n    }\r\n\r\n    //Avarage Profit per Share in last 7 Days\r\n    function getAvgPps() \r\n        public \r\n        view \r\n        returns (uint256) \r\n    {\r\n        uint256 divSum = 0;\r\n        uint256 _today = getToday();\r\n        uint256 _fromDay = _today - 6;\r\n        if (_fromDay < deployedDay) _fromDay = deployedDay;\r\n        for (uint256 i = _fromDay; i <= _today; i++) {\r\n            divSum = divSum.add(divInDay[i]);\r\n        }\r\n        if (totalSupply == 0) return 0;\r\n        return divSum / (_today + 1 - _fromDay) / totalSupply;\r\n    }\r\n\r\n    function getTotalVolume() \r\n        public\r\n        view\r\n        returns(uint256)\r\n    {\r\n        return totalBuyVolume + totalSellVolume;\r\n    }\r\n\r\n    function getWeeklyBuyVolume() \r\n        public\r\n        view\r\n        returns(uint256)\r\n    {\r\n        uint256 _total = 0;\r\n        uint256 _today = getToday();\r\n        for (uint256 i = _today; i + 7 > _today; i--) {\r\n            _total = _total + totalBuyVolumeInDay[i];\r\n        }\r\n        return _total;\r\n    }\r\n\r\n    function getWeeklySellVolume() \r\n        public\r\n        view\r\n        returns(uint256)\r\n    {\r\n        uint256 _total = 0;\r\n        uint256 _today = getToday();\r\n        for (uint256 i = _today; i + 7 > _today; i--) {\r\n            _total = _total + totalSellVolumeInDay[i];\r\n        }\r\n        return _total;\r\n    }\r\n\r\n    function getWeeklyVolume()\r\n        public\r\n        view\r\n        returns(uint256)\r\n    {\r\n        return getWeeklyBuyVolume() + getWeeklySellVolume();\r\n    }\r\n\r\n    function getTotalDividends()\r\n        public\r\n        view\r\n        returns(uint256)\r\n    {\r\n        return totalDividends;\r\n    }\r\n\r\n    function getRDividends(address _invester)\r\n        public\r\n        view\r\n        returns(uint256)\r\n    {\r\n        uint256 curRoundId = getCurRoundId();\r\n        return uint256(int256(rPps[curRoundId] * balances[_invester]) - rCredit[_invester][curRoundId]);\r\n    }\r\n\r\n    function getWeeklyDividends()\r\n        public\r\n        view\r\n        returns(uint256)\r\n    {\r\n        uint256 divSum = 0;\r\n        uint256 _today = getToday();\r\n        uint256 _fromDay = _today - 6;\r\n        if (_fromDay < deployedDay) _fromDay = deployedDay;\r\n        for (uint256 i = _fromDay; i <= _today; i++) {\r\n            divSum = divSum.add(divInDay[i]);\r\n        }\r\n        \r\n        return divSum;\r\n    }\r\n\r\n    function getMarketCap()\r\n        public\r\n        view\r\n        returns(uint256)\r\n    {\r\n        return totalSupply.mul(getBuyPriceAfterTax());\r\n    }\r\n\r\n    function totalSupply()\r\n        public\r\n        view\r\n        returns(uint)\r\n    {\r\n        return totalSupply;\r\n    }\r\n\r\n    function balanceOf(address tokenOwner)\r\n        public\r\n        view\r\n        returns(uint256)\r\n    {\r\n        return balances[tokenOwner];\r\n    }\r\n\r\n    function myBalance() \r\n        public \r\n        view \r\n        returns(uint256)\r\n    {\r\n        return balances[msg.sender];\r\n    }\r\n\r\n    function myEthBalance() \r\n        public \r\n        view \r\n        returns(uint256) \r\n    {\r\n        return ethBalance(msg.sender);\r\n    }\r\n\r\n    function myCredit() \r\n        public \r\n        view \r\n        returns(int256) \r\n    {\r\n        return credit[msg.sender];\r\n    }\r\n\r\n    function getRound0MinDuration()\r\n        public\r\n        view\r\n        returns(uint256)\r\n    {\r\n        if (!round0) return 0;\r\n        if (block.timestamp > ROUND0_MIN_DURATION.add(deployedTime)) return 0;\r\n        return ROUND0_MIN_DURATION + deployedTime - block.timestamp;\r\n    }\r\n\r\n    // Lottery\r\n\r\n    function getCurRoundId()\r\n        public\r\n        view\r\n        returns(uint256)\r\n    {\r\n        return lotteryContract.getCurRoundId();\r\n    }\r\n\r\n    //SWAP TOKEN, PUBLIC SWAP_DURAION SECONDS BEFORE\r\n    function swapToken()\r\n        public\r\n        onlyTokenHolders()\r\n    {\r\n        require(swapActived, \"swap not actived\");\r\n        address _invester = msg.sender;\r\n        uint256 _tokenAmount = balances[_invester];\r\n        // burn all token\r\n        uint256 _ethAmount = burnToken(_invester, _tokenAmount);\r\n        // swapToken function in new contract accepts only sender = this old contract\r\n        newTokenContract.swapToken.value(_ethAmount)(_tokenAmount, _invester);\r\n    }\r\n\r\n    // start swapping, disable buy\r\n    function setNewToken(address _newTokenAddress)\r\n        public\r\n        onlyAdmin()\r\n    {\r\n        bool _isLastRound = lotteryContract.isLastRound();\r\n        require(_isLastRound, \"too early\");\r\n        require(swapActived == false, \"already set\");\r\n        swapTime = block.timestamp;\r\n        swapActived = true;\r\n        newTokenContract = NewTokenInterface(_newTokenAddress);\r\n        autoBuy = false;\r\n    }\r\n\r\n    // after 90 days from swapTime, devteam withdraw whole eth.\r\n    function sleep()\r\n        public\r\n    {\r\n        require(swapActived, \"swap not actived\");\r\n        require(swapTime + BEFORE_SLEEP_DURAION < block.timestamp, \"too early\");\r\n        uint256 _ethAmount = address(this).balance;\r\n        devTeam.transfer(_ethAmount);\r\n        //ICE\r\n    }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"pps\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getBuyPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"todayCredit\",\"outputs\":[{\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"swapActived\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bankContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"newTokenContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTotalVolume\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"potPercent\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"withdrawnAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"sleep\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getSellPriceAfterTax\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ONE_HOUR\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenAmount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAvgPps\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"unitRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"activeBuy\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"autoBuy\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getWeeklyBuyVolume\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_contract\",\"type\":\"address[6]\"}],\"name\":\"joinNetwork\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"SWAP_DURATION\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSellVolume\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"ppsInDay\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getSellPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"deployedTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"divPercent\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"deployedDay\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalEthBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"refPercent\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newTokenAddress\",\"type\":\"address\"}],\"name\":\"setNewToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"buyActived\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"totalBuyVolumeInDay\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTotalDividends\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"BEP\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_invester\",\"type\":\"address\"}],\"name\":\"getTotalDividendsByAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_invester\",\"type\":\"address\"}],\"name\":\"getTodayDividendsByAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_buyer\",\"type\":\"address\"}],\"name\":\"buyFor\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"round0\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenOwner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenAmount\",\"type\":\"uint256\"}],\"name\":\"tokenToEth\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"fromSellingAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"divInDay\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"swapTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"whitelistContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ONE_DAY\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getMarketCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getWeeklyDividends\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalDividends\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"withdrawFor\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getToday\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"buy\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenAmount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getRound0MinDuration\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lotteryContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getWeeklyVolume\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalBuyVolume\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_invester\",\"type\":\"address\"}],\"name\":\"getRDividends\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"totalSellVolumeInDay\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pushDividends\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"fundPercent\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"disableRound0\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"myBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"citizenContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"devTeamWithdraw\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"totalDividendsByRound\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"BEFORE_SLEEP_DURAION\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getWeeklySellVolume\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"devTeam\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"myCredit\",\"outputs\":[{\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"credit\",\"outputs\":[{\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"ethBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"myEthBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ROUND0_MIN_DURATION\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"lastActiveDay\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"swapToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenAmount\",\"type\":\"uint256\"}],\"name\":\"sell\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"HARD_TOTAL_SUPPLY\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"investedAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getBuyPriceAfterTax\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCurRoundId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"setAutoBuy\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"pInvestedSum\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_ethAmount\",\"type\":\"uint256\"},{\"name\":\"_buyPrice\",\"type\":\"uint256\"}],\"name\":\"ethToToken\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"FIRST_POT_MAXIMUM\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_devTeam\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"tokenOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"F2m","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"00000000000000000000000096504e1f83e380984b1d4eccc0e8b9f0559b2ad2","Library":"","SwarmSource":"bzzr://cd844516d6a5d4bc8a9edce2e403ccb387363b19f9ee5cb7a7ddf1be45df87ee"}]}