{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\n// File: openzeppelin-solidity/contracts/introspection/IERC165.sol\r\n\r\n/**\r\n * @title IERC165\r\n * @dev https://github.com/ethereum/EIPs/blob/master/EIPS/eip-165.md\r\n */\r\ninterface IERC165 {\r\n\r\n  /**\r\n   * @notice Query if a contract implements an interface\r\n   * @param interfaceId The interface identifier, as specified in ERC-165\r\n   * @dev Interface identification is specified in ERC-165. This function\r\n   * uses less than 30,000 gas.\r\n   */\r\n  function supportsInterface(bytes4 interfaceId)\r\n    external\r\n    view\r\n    returns (bool);\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/introspection/ERC165.sol\r\n\r\n/**\r\n * @title ERC165\r\n * @author Matt Condon (@shrugs)\r\n * @dev Implements ERC165 using a lookup table.\r\n */\r\ncontract ERC165 is IERC165 {\r\n\r\n  bytes4 private constant _InterfaceId_ERC165 = 0x01ffc9a7;\r\n  /**\r\n   * 0x01ffc9a7 ===\r\n   *   bytes4(keccak256('supportsInterface(bytes4)'))\r\n   */\r\n\r\n  /**\r\n   * @dev a mapping of interface id to whether or not it's supported\r\n   */\r\n  mapping(bytes4 => bool) private _supportedInterfaces;\r\n\r\n  /**\r\n   * @dev A contract implementing SupportsInterfaceWithLookup\r\n   * implement ERC165 itself\r\n   */\r\n  constructor()\r\n    internal\r\n  {\r\n    _registerInterface(_InterfaceId_ERC165);\r\n  }\r\n\r\n  /**\r\n   * @dev implement supportsInterface(bytes4) using a lookup table\r\n   */\r\n  function supportsInterface(bytes4 interfaceId)\r\n    external\r\n    view\r\n    returns (bool)\r\n  {\r\n    return _supportedInterfaces[interfaceId];\r\n  }\r\n\r\n  /**\r\n   * @dev internal method for registering an interface\r\n   */\r\n  function _registerInterface(bytes4 interfaceId)\r\n    internal\r\n  {\r\n    require(interfaceId != 0xffffffff);\r\n    _supportedInterfaces[interfaceId] = true;\r\n  }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC721/IERC721.sol\r\n\r\n/**\r\n * @title ERC721 Non-Fungible Token Standard basic interface\r\n * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\r\n */\r\ncontract IERC721 is IERC165 {\r\n\r\n  event Transfer(\r\n    address indexed from,\r\n    address indexed to,\r\n    uint256 indexed tokenId\r\n  );\r\n  event Approval(\r\n    address indexed owner,\r\n    address indexed approved,\r\n    uint256 indexed tokenId\r\n  );\r\n  event ApprovalForAll(\r\n    address indexed owner,\r\n    address indexed operator,\r\n    bool approved\r\n  );\r\n\r\n  function balanceOf(address owner) public view returns (uint256 balance);\r\n  function ownerOf(uint256 tokenId) public view returns (address owner);\r\n\r\n  function approve(address to, uint256 tokenId) public;\r\n  function getApproved(uint256 tokenId)\r\n    public view returns (address operator);\r\n\r\n  function setApprovalForAll(address operator, bool _approved) public;\r\n  function isApprovedForAll(address owner, address operator)\r\n    public view returns (bool);\r\n\r\n  function transferFrom(address from, address to, uint256 tokenId) public;\r\n  function safeTransferFrom(address from, address to, uint256 tokenId)\r\n    public;\r\n\r\n  function safeTransferFrom(\r\n    address from,\r\n    address to,\r\n    uint256 tokenId,\r\n    bytes data\r\n  )\r\n    public;\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC721/IERC721Receiver.sol\r\n\r\n/**\r\n * @title ERC721 token receiver interface\r\n * @dev Interface for any contract that wants to support safeTransfers\r\n * from ERC721 asset contracts.\r\n */\r\ncontract IERC721Receiver {\r\n  /**\r\n   * @notice Handle the receipt of an NFT\r\n   * @dev The ERC721 smart contract calls this function on the recipient\r\n   * after a `safeTransfer`. This function MUST return the function selector,\r\n   * otherwise the caller will revert the transaction. The selector to be\r\n   * returned can be obtained as `this.onERC721Received.selector`. This\r\n   * function MAY throw to revert and reject the transfer.\r\n   * Note: the ERC721 contract address is always the message sender.\r\n   * @param operator The address which called `safeTransferFrom` function\r\n   * @param from The address which previously owned the token\r\n   * @param tokenId The NFT identifier which is being transferred\r\n   * @param data Additional data with no specified format\r\n   * @return `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\r\n   */\r\n  function onERC721Received(\r\n    address operator,\r\n    address from,\r\n    uint256 tokenId,\r\n    bytes data\r\n  )\r\n    public\r\n    returns(bytes4);\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/math/SafeMath.sol\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, reverts on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    uint256 c = a * b;\r\n    require(c / a == b);\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b > 0); // Solidity only automatically asserts when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b <= a);\r\n    uint256 c = a - b;\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, reverts on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    require(c >= a);\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\r\n  * reverts when dividing by zero.\r\n  */\r\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b != 0);\r\n    return a % b;\r\n  }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/utils/Address.sol\r\n\r\n/**\r\n * Utility library of inline functions on addresses\r\n */\r\nlibrary Address {\r\n\r\n  /**\r\n   * Returns whether the target address is a contract\r\n   * @dev This function will return false if invoked during the constructor of a contract,\r\n   * as the code is not actually created until after the constructor finishes.\r\n   * @param account address of the account to check\r\n   * @return whether the target address is a contract\r\n   */\r\n  function isContract(address account) internal view returns (bool) {\r\n    uint256 size;\r\n    // XXX Currently there is no better way to check if there is a contract in an address\r\n    // than to check the size of the code at that address.\r\n    // See https://ethereum.stackexchange.com/a/14016/36603\r\n    // for more details about how this works.\r\n    // TODO Check this again before the Serenity release, because all addresses will be\r\n    // contracts then.\r\n    // solium-disable-next-line security/no-inline-assembly\r\n    assembly { size := extcodesize(account) }\r\n    return size > 0;\r\n  }\r\n\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC721/ERC721.sol\r\n\r\n/**\r\n * @title ERC721 Non-Fungible Token Standard basic implementation\r\n * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\r\n */\r\ncontract ERC721 is ERC165, IERC721 {\r\n\r\n  using SafeMath for uint256;\r\n  using Address for address;\r\n\r\n  // Equals to `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\r\n  // which can be also obtained as `IERC721Receiver(0).onERC721Received.selector`\r\n  bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;\r\n\r\n  // Mapping from token ID to owner\r\n  mapping (uint256 => address) private _tokenOwner;\r\n\r\n  // Mapping from token ID to approved address\r\n  mapping (uint256 => address) private _tokenApprovals;\r\n\r\n  // Mapping from owner to number of owned token\r\n  mapping (address => uint256) private _ownedTokensCount;\r\n\r\n  // Mapping from owner to operator approvals\r\n  mapping (address => mapping (address => bool)) private _operatorApprovals;\r\n\r\n  bytes4 private constant _InterfaceId_ERC721 = 0x80ac58cd;\r\n  /*\r\n   * 0x80ac58cd ===\r\n   *   bytes4(keccak256('balanceOf(address)')) ^\r\n   *   bytes4(keccak256('ownerOf(uint256)')) ^\r\n   *   bytes4(keccak256('approve(address,uint256)')) ^\r\n   *   bytes4(keccak256('getApproved(uint256)')) ^\r\n   *   bytes4(keccak256('setApprovalForAll(address,bool)')) ^\r\n   *   bytes4(keccak256('isApprovedForAll(address,address)')) ^\r\n   *   bytes4(keccak256('transferFrom(address,address,uint256)')) ^\r\n   *   bytes4(keccak256('safeTransferFrom(address,address,uint256)')) ^\r\n   *   bytes4(keccak256('safeTransferFrom(address,address,uint256,bytes)'))\r\n   */\r\n\r\n  constructor()\r\n    public\r\n  {\r\n    // register the supported interfaces to conform to ERC721 via ERC165\r\n    _registerInterface(_InterfaceId_ERC721);\r\n  }\r\n\r\n  /**\r\n   * @dev Gets the balance of the specified address\r\n   * @param owner address to query the balance of\r\n   * @return uint256 representing the amount owned by the passed address\r\n   */\r\n  function balanceOf(address owner) public view returns (uint256) {\r\n    require(owner != address(0));\r\n    return _ownedTokensCount[owner];\r\n  }\r\n\r\n  /**\r\n   * @dev Gets the owner of the specified token ID\r\n   * @param tokenId uint256 ID of the token to query the owner of\r\n   * @return owner address currently marked as the owner of the given token ID\r\n   */\r\n  function ownerOf(uint256 tokenId) public view returns (address) {\r\n    address owner = _tokenOwner[tokenId];\r\n    require(owner != address(0));\r\n    return owner;\r\n  }\r\n\r\n  /**\r\n   * @dev Approves another address to transfer the given token ID\r\n   * The zero address indicates there is no approved address.\r\n   * There can only be one approved address per token at a given time.\r\n   * Can only be called by the token owner or an approved operator.\r\n   * @param to address to be approved for the given token ID\r\n   * @param tokenId uint256 ID of the token to be approved\r\n   */\r\n  function approve(address to, uint256 tokenId) public {\r\n    address owner = ownerOf(tokenId);\r\n    require(to != owner);\r\n    require(msg.sender == owner || isApprovedForAll(owner, msg.sender));\r\n\r\n    _tokenApprovals[tokenId] = to;\r\n    emit Approval(owner, to, tokenId);\r\n  }\r\n\r\n  /**\r\n   * @dev Gets the approved address for a token ID, or zero if no address set\r\n   * Reverts if the token ID does not exist.\r\n   * @param tokenId uint256 ID of the token to query the approval of\r\n   * @return address currently approved for the given token ID\r\n   */\r\n  function getApproved(uint256 tokenId) public view returns (address) {\r\n    require(_exists(tokenId));\r\n    return _tokenApprovals[tokenId];\r\n  }\r\n\r\n  /**\r\n   * @dev Sets or unsets the approval of a given operator\r\n   * An operator is allowed to transfer all tokens of the sender on their behalf\r\n   * @param to operator address to set the approval\r\n   * @param approved representing the status of the approval to be set\r\n   */\r\n  function setApprovalForAll(address to, bool approved) public {\r\n    require(to != msg.sender);\r\n    _operatorApprovals[msg.sender][to] = approved;\r\n    emit ApprovalForAll(msg.sender, to, approved);\r\n  }\r\n\r\n  /**\r\n   * @dev Tells whether an operator is approved by a given owner\r\n   * @param owner owner address which you want to query the approval of\r\n   * @param operator operator address which you want to query the approval of\r\n   * @return bool whether the given operator is approved by the given owner\r\n   */\r\n  function isApprovedForAll(\r\n    address owner,\r\n    address operator\r\n  )\r\n    public\r\n    view\r\n    returns (bool)\r\n  {\r\n    return _operatorApprovals[owner][operator];\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers the ownership of a given token ID to another address\r\n   * Usage of this method is discouraged, use `safeTransferFrom` whenever possible\r\n   * Requires the msg sender to be the owner, approved, or operator\r\n   * @param from current owner of the token\r\n   * @param to address to receive the ownership of the given token ID\r\n   * @param tokenId uint256 ID of the token to be transferred\r\n  */\r\n  function transferFrom(\r\n    address from,\r\n    address to,\r\n    uint256 tokenId\r\n  )\r\n    public\r\n  {\r\n    require(_isApprovedOrOwner(msg.sender, tokenId));\r\n    require(to != address(0));\r\n\r\n    _clearApproval(from, tokenId);\r\n    _removeTokenFrom(from, tokenId);\r\n    _addTokenTo(to, tokenId);\r\n\r\n    emit Transfer(from, to, tokenId);\r\n  }\r\n\r\n  /**\r\n   * @dev Safely transfers the ownership of a given token ID to another address\r\n   * If the target address is a contract, it must implement `onERC721Received`,\r\n   * which is called upon a safe transfer, and return the magic value\r\n   * `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`; otherwise,\r\n   * the transfer is reverted.\r\n   *\r\n   * Requires the msg sender to be the owner, approved, or operator\r\n   * @param from current owner of the token\r\n   * @param to address to receive the ownership of the given token ID\r\n   * @param tokenId uint256 ID of the token to be transferred\r\n  */\r\n  function safeTransferFrom(\r\n    address from,\r\n    address to,\r\n    uint256 tokenId\r\n  )\r\n    public\r\n  {\r\n    // solium-disable-next-line arg-overflow\r\n    safeTransferFrom(from, to, tokenId, \"\");\r\n  }\r\n\r\n  /**\r\n   * @dev Safely transfers the ownership of a given token ID to another address\r\n   * If the target address is a contract, it must implement `onERC721Received`,\r\n   * which is called upon a safe transfer, and return the magic value\r\n   * `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`; otherwise,\r\n   * the transfer is reverted.\r\n   * Requires the msg sender to be the owner, approved, or operator\r\n   * @param from current owner of the token\r\n   * @param to address to receive the ownership of the given token ID\r\n   * @param tokenId uint256 ID of the token to be transferred\r\n   * @param _data bytes data to send along with a safe transfer check\r\n   */\r\n  function safeTransferFrom(\r\n    address from,\r\n    address to,\r\n    uint256 tokenId,\r\n    bytes _data\r\n  )\r\n    public\r\n  {\r\n    transferFrom(from, to, tokenId);\r\n    // solium-disable-next-line arg-overflow\r\n    require(_checkOnERC721Received(from, to, tokenId, _data));\r\n  }\r\n\r\n  /**\r\n   * @dev Returns whether the specified token exists\r\n   * @param tokenId uint256 ID of the token to query the existence of\r\n   * @return whether the token exists\r\n   */\r\n  function _exists(uint256 tokenId) internal view returns (bool) {\r\n    address owner = _tokenOwner[tokenId];\r\n    return owner != address(0);\r\n  }\r\n\r\n  /**\r\n   * @dev Returns whether the given spender can transfer a given token ID\r\n   * @param spender address of the spender to query\r\n   * @param tokenId uint256 ID of the token to be transferred\r\n   * @return bool whether the msg.sender is approved for the given token ID,\r\n   *  is an operator of the owner, or is the owner of the token\r\n   */\r\n  function _isApprovedOrOwner(\r\n    address spender,\r\n    uint256 tokenId\r\n  )\r\n    internal\r\n    view\r\n    returns (bool)\r\n  {\r\n    address owner = ownerOf(tokenId);\r\n    // Disable solium check because of\r\n    // https://github.com/duaraghav8/Solium/issues/175\r\n    // solium-disable-next-line operator-whitespace\r\n    return (\r\n      spender == owner ||\r\n      getApproved(tokenId) == spender ||\r\n      isApprovedForAll(owner, spender)\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @dev Internal function to mint a new token\r\n   * Reverts if the given token ID already exists\r\n   * @param to The address that will own the minted token\r\n   * @param tokenId uint256 ID of the token to be minted by the msg.sender\r\n   */\r\n  function _mint(address to, uint256 tokenId) internal {\r\n    require(to != address(0));\r\n    _addTokenTo(to, tokenId);\r\n    emit Transfer(address(0), to, tokenId);\r\n  }\r\n\r\n  /**\r\n   * @dev Internal function to burn a specific token\r\n   * Reverts if the token does not exist\r\n   * @param tokenId uint256 ID of the token being burned by the msg.sender\r\n   */\r\n  function _burn(address owner, uint256 tokenId) internal {\r\n    _clearApproval(owner, tokenId);\r\n    _removeTokenFrom(owner, tokenId);\r\n    emit Transfer(owner, address(0), tokenId);\r\n  }\r\n\r\n  /**\r\n   * @dev Internal function to add a token ID to the list of a given address\r\n   * Note that this function is left internal to make ERC721Enumerable possible, but is not\r\n   * intended to be called by custom derived contracts: in particular, it emits no Transfer event.\r\n   * @param to address representing the new owner of the given token ID\r\n   * @param tokenId uint256 ID of the token to be added to the tokens list of the given address\r\n   */\r\n  function _addTokenTo(address to, uint256 tokenId) internal {\r\n    require(_tokenOwner[tokenId] == address(0));\r\n    _tokenOwner[tokenId] = to;\r\n    _ownedTokensCount[to] = _ownedTokensCount[to].add(1);\r\n  }\r\n\r\n  /**\r\n   * @dev Internal function to remove a token ID from the list of a given address\r\n   * Note that this function is left internal to make ERC721Enumerable possible, but is not\r\n   * intended to be called by custom derived contracts: in particular, it emits no Transfer event,\r\n   * and doesn't clear approvals.\r\n   * @param from address representing the previous owner of the given token ID\r\n   * @param tokenId uint256 ID of the token to be removed from the tokens list of the given address\r\n   */\r\n  function _removeTokenFrom(address from, uint256 tokenId) internal {\r\n    require(ownerOf(tokenId) == from);\r\n    _ownedTokensCount[from] = _ownedTokensCount[from].sub(1);\r\n    _tokenOwner[tokenId] = address(0);\r\n  }\r\n\r\n  /**\r\n   * @dev Internal function to invoke `onERC721Received` on a target address\r\n   * The call is not executed if the target address is not a contract\r\n   * @param from address representing the previous owner of the given token ID\r\n   * @param to target address that will receive the tokens\r\n   * @param tokenId uint256 ID of the token to be transferred\r\n   * @param _data bytes optional data to send along with the call\r\n   * @return whether the call correctly returned the expected magic value\r\n   */\r\n  function _checkOnERC721Received(\r\n    address from,\r\n    address to,\r\n    uint256 tokenId,\r\n    bytes _data\r\n  )\r\n    internal\r\n    returns (bool)\r\n  {\r\n    if (!to.isContract()) {\r\n      return true;\r\n    }\r\n    bytes4 retval = IERC721Receiver(to).onERC721Received(\r\n      msg.sender, from, tokenId, _data);\r\n    return (retval == _ERC721_RECEIVED);\r\n  }\r\n\r\n  /**\r\n   * @dev Private function to clear current approval of a given token ID\r\n   * Reverts if the given address is not indeed the owner of the token\r\n   * @param owner owner of the token\r\n   * @param tokenId uint256 ID of the token to be transferred\r\n   */\r\n  function _clearApproval(address owner, uint256 tokenId) private {\r\n    require(ownerOf(tokenId) == owner);\r\n    if (_tokenApprovals[tokenId] != address(0)) {\r\n      _tokenApprovals[tokenId] = address(0);\r\n    }\r\n  }\r\n}\r\n\r\n// File: contracts/library/token/ERC721Manager.sol\r\n\r\n/**\r\n * @title ERC721Manager\r\n *\r\n * @dev This library implements OpenZepellin's ERC721 implementation (as of 7/31/2018) as\r\n * an external library, in order to keep contract sizes smaller.\r\n *\r\n * Released under the MIT License.\r\n *\r\n *\r\n * The MIT License (MIT)\r\n *\r\n * Copyright (c) 2016 Smart Contract Solutions, Inc.\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining\r\n * a copy of this software and associated documentation files (the\r\n * \"Software\"), to deal in the Software without restriction, including\r\n * without limitation the rights to use, copy, modify, merge, publish,\r\n * distribute, sublicense, and/or sell copies of the Software, and to\r\n * permit persons to whom the Software is furnished to do so, subject to\r\n * the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included\r\n * in all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\r\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\r\n * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\r\n * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\r\n * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\r\n * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n *\r\n */\r\nlibrary ERC721Manager {\r\n\r\n    using SafeMath for uint256;\r\n\r\n    // We define the events on both the library and the client, so that the events emitted here are detected\r\n    // as if they had been emitted by the client\r\n    event Transfer(\r\n        address indexed _from,\r\n        address indexed _to,\r\n        uint256 indexed _tokenId\r\n    );\r\n    event Approval(\r\n        address indexed _owner,\r\n        address indexed _approved,\r\n        uint256 indexed _tokenId\r\n    );\r\n    event ApprovalForAll(\r\n        address indexed _owner,\r\n        address indexed _operator,\r\n        bool _approved\r\n    );\r\n\r\n    struct ERC721Data {\r\n        // List of supported interfaces\r\n        mapping (bytes4 => bool) supportedInterfaces;\r\n\r\n        // Mapping from token ID to owner\r\n        mapping (uint256 => address) tokenOwner;\r\n\r\n        // Mapping from token ID to approved address\r\n        mapping (uint256 => address) tokenApprovals;\r\n\r\n        // Mapping from owner to number of owned token\r\n        mapping (address => uint256) ownedTokensCount;\r\n\r\n        // Mapping from owner to operator approvals\r\n        mapping (address => mapping (address => bool)) operatorApprovals;\r\n\r\n\r\n        // Token name\r\n        string name_;\r\n\r\n        // Token symbol\r\n        string symbol_;\r\n\r\n        // Mapping from owner to list of owned token IDs\r\n        mapping(address => uint256[]) ownedTokens;\r\n\r\n        // Mapping from token ID to index of the owner tokens list\r\n        mapping(uint256 => uint256) ownedTokensIndex;\r\n\r\n        // Array with all token ids, used for enumeration\r\n        uint256[] allTokens;\r\n\r\n        // Mapping from token id to position in the allTokens array\r\n        mapping(uint256 => uint256) allTokensIndex;\r\n\r\n        // Optional mapping for token URIs\r\n        mapping(uint256 => string) tokenURIs;\r\n    }\r\n\r\n    // Equals to `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\r\n    // which can be also obtained as `ERC721Receiver(0).onERC721Received.selector`\r\n    bytes4 private constant ERC721_RECEIVED = 0x150b7a02;\r\n\r\n\r\n    bytes4 private constant InterfaceId_ERC165 = 0x01ffc9a7;\r\n    /**\r\n     * 0x01ffc9a7 ===\r\n     *   bytes4(keccak256('supportsInterface(bytes4)'))\r\n     */\r\n\r\n    bytes4 private constant InterfaceId_ERC721 = 0x80ac58cd;\r\n    /*\r\n     * 0x80ac58cd ===\r\n     *   bytes4(keccak256('balanceOf(address)')) ^\r\n     *   bytes4(keccak256('ownerOf(uint256)')) ^\r\n     *   bytes4(keccak256('approve(address,uint256)')) ^\r\n     *   bytes4(keccak256('getApproved(uint256)')) ^\r\n     *   bytes4(keccak256('setApprovalForAll(address,bool)')) ^\r\n     *   bytes4(keccak256('isApprovedForAll(address,address)')) ^\r\n     *   bytes4(keccak256('transferFrom(address,address,uint256)')) ^\r\n     *   bytes4(keccak256('safeTransferFrom(address,address,uint256)')) ^\r\n     *   bytes4(keccak256('safeTransferFrom(address,address,uint256,bytes)'))\r\n     */\r\n\r\n    bytes4 private constant InterfaceId_ERC721Exists = 0x4f558e79;\r\n    /*\r\n     * 0x4f558e79 ===\r\n     *   bytes4(keccak256('exists(uint256)'))\r\n     */\r\n\r\n    bytes4 private constant InterfaceId_ERC721Enumerable = 0x780e9d63;\r\n    /**\r\n     * 0x780e9d63 ===\r\n     *   bytes4(keccak256('totalSupply()')) ^\r\n     *   bytes4(keccak256('tokenOfOwnerByIndex(address,uint256)')) ^\r\n     *   bytes4(keccak256('tokenByIndex(uint256)'))\r\n     */\r\n\r\n    bytes4 private constant InterfaceId_ERC721Metadata = 0x5b5e139f;\r\n    /**\r\n     * 0x5b5e139f ===\r\n     *   bytes4(keccak256('name()')) ^\r\n     *   bytes4(keccak256('symbol()')) ^\r\n     *   bytes4(keccak256('tokenURI(uint256)'))\r\n     */\r\n\r\n\r\n    function initialize(ERC721Data storage self, string _name, string _symbol) external {\r\n        self.name_ = _name;\r\n        self.symbol_ = _symbol;\r\n\r\n        // register the supported interface to conform to ERC165\r\n        _registerInterface(self, InterfaceId_ERC165);\r\n\r\n        // register the supported interfaces to conform to ERC721 via ERC165\r\n        _registerInterface(self, InterfaceId_ERC721);\r\n        _registerInterface(self, InterfaceId_ERC721Exists);\r\n        _registerInterface(self, InterfaceId_ERC721Enumerable);\r\n        _registerInterface(self, InterfaceId_ERC721Metadata);\r\n    }\r\n\r\n    function _registerInterface(ERC721Data storage self, bytes4 _interfaceId) private {\r\n        self.supportedInterfaces[_interfaceId] = true;\r\n    }\r\n\r\n    function supportsInterface(ERC721Data storage self, bytes4 _interfaceId) external view returns (bool) {\r\n        return self.supportedInterfaces[_interfaceId];\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the balance of the specified address\r\n     * @param _owner address to query the balance of\r\n     * @return uint256 representing the amount owned by the passed address\r\n     */\r\n    function balanceOf(ERC721Data storage self, address _owner) public view returns (uint256) {\r\n        require(_owner != address(0));\r\n        return self.ownedTokensCount[_owner];\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the owner of the specified token ID\r\n     * @param _tokenId uint256 ID of the token to query the owner of\r\n     * @return owner address currently marked as the owner of the given token ID\r\n     */\r\n    function ownerOf(ERC721Data storage self, uint256 _tokenId) public view returns (address) {\r\n        address owner = self.tokenOwner[_tokenId];\r\n        require(owner != address(0));\r\n        return owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns whether the specified token exists\r\n     * @param _tokenId uint256 ID of the token to query the existence of\r\n     * @return whether the token exists\r\n     */\r\n    function exists(ERC721Data storage self, uint256 _tokenId) public view returns (bool) {\r\n        address owner = self.tokenOwner[_tokenId];\r\n        return owner != address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Approves another address to transfer the given token ID\r\n     * The zero address indicates there is no approved address.\r\n     * There can only be one approved address per token at a given time.\r\n     * Can only be called by the token owner or an approved operator.\r\n     * @param _to address to be approved for the given token ID\r\n     * @param _tokenId uint256 ID of the token to be approved\r\n     */\r\n    function approve(ERC721Data storage self, address _to, uint256 _tokenId) external {\r\n        address owner = ownerOf(self, _tokenId);\r\n        require(_to != owner);\r\n        require(msg.sender == owner || isApprovedForAll(self, owner, msg.sender));\r\n\r\n        self.tokenApprovals[_tokenId] = _to;\r\n\r\n        emit Approval(owner, _to, _tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the approved address for a token ID, or zero if no address set\r\n     * @param _tokenId uint256 ID of the token to query the approval of\r\n     * @return address currently approved for the given token ID\r\n     */\r\n    function getApproved(ERC721Data storage self, uint256 _tokenId) public view returns (address) {\r\n        return self.tokenApprovals[_tokenId];\r\n    }\r\n\r\n    /**\r\n     * @dev Sets or unsets the approval of a given operator\r\n     * An operator is allowed to transfer all tokens of the sender on their behalf\r\n     * @param _to operator address to set the approval\r\n     * @param _approved representing the status of the approval to be set\r\n     */\r\n    function setApprovalForAll(ERC721Data storage self, address _to, bool _approved) external {\r\n        require(_to != msg.sender);\r\n        self.operatorApprovals[msg.sender][_to] = _approved;\r\n        emit ApprovalForAll(msg.sender, _to, _approved);\r\n    }\r\n\r\n    /**\r\n     * @dev Tells whether an operator is approved by a given owner\r\n     * @param _owner owner address which you want to query the approval of\r\n     * @param _operator operator address which you want to query the approval of\r\n     * @return bool whether the given operator is approved by the given owner\r\n     */\r\n    function isApprovedForAll(\r\n        ERC721Data storage self,\r\n        address _owner,\r\n        address _operator\r\n    ) public view returns (bool) {\r\n        return self.operatorApprovals[_owner][_operator];\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers the ownership of a given token ID to another address\r\n     * Usage of this method is discouraged, use `safeTransferFrom` whenever possible\r\n     * Requires the msg sender to be the owner, approved, or operator\r\n     * @param _from current owner of the token\r\n     * @param _to address to receive the ownership of the given token ID\r\n     * @param _tokenId uint256 ID of the token to be transferred\r\n    */\r\n    function transferFrom(\r\n        ERC721Data storage self,\r\n        address _from,\r\n        address _to,\r\n        uint256 _tokenId\r\n    ) public {\r\n        require(isApprovedOrOwner(self, msg.sender, _tokenId));\r\n        require(_from != address(0));\r\n        require(_to != address(0));\r\n\r\n        _clearApproval(self, _from, _tokenId);\r\n        _removeTokenFrom(self, _from, _tokenId);\r\n        _addTokenTo(self, _to, _tokenId);\r\n\r\n        emit Transfer(_from, _to, _tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Safely transfers the ownership of a given token ID to another address\r\n     * If the target address is a contract, it must implement `onERC721Received`,\r\n     * which is called upon a safe transfer, and return the magic value\r\n     * `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`; otherwise,\r\n     * the transfer is reverted.\r\n     *\r\n     * Requires the msg sender to be the owner, approved, or operator\r\n     * @param _from current owner of the token\r\n     * @param _to address to receive the ownership of the given token ID\r\n     * @param _tokenId uint256 ID of the token to be transferred\r\n    */\r\n    function safeTransferFrom(\r\n        ERC721Data storage self,\r\n        address _from,\r\n        address _to,\r\n        uint256 _tokenId\r\n    ) external {\r\n        // solium-disable-next-line arg-overflow\r\n        safeTransferFrom(self, _from, _to, _tokenId, \"\");\r\n    }\r\n\r\n    /**\r\n     * @dev Safely transfers the ownership of a given token ID to another address\r\n     * If the target address is a contract, it must implement `onERC721Received`,\r\n     * which is called upon a safe transfer, and return the magic value\r\n     * `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`; otherwise,\r\n     * the transfer is reverted.\r\n     * Requires the msg sender to be the owner, approved, or operator\r\n     * @param _from current owner of the token\r\n     * @param _to address to receive the ownership of the given token ID\r\n     * @param _tokenId uint256 ID of the token to be transferred\r\n     * @param _data bytes data to send along with a safe transfer check\r\n     */\r\n    function safeTransferFrom(\r\n        ERC721Data storage self,\r\n        address _from,\r\n        address _to,\r\n        uint256 _tokenId,\r\n        bytes _data\r\n    ) public {\r\n        transferFrom(self, _from, _to, _tokenId);\r\n        // solium-disable-next-line arg-overflow\r\n        require(_checkAndCallSafeTransfer(_from, _to, _tokenId, _data));\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to clear current approval of a given token ID\r\n     * Reverts if the given address is not indeed the owner of the token\r\n     * @param _owner owner of the token\r\n     * @param _tokenId uint256 ID of the token to be transferred\r\n     */\r\n    function _clearApproval(ERC721Data storage self, address _owner, uint256 _tokenId) internal {\r\n        require(ownerOf(self, _tokenId) == _owner);\r\n        if (self.tokenApprovals[_tokenId] != address(0)) {\r\n            self.tokenApprovals[_tokenId] = address(0);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to invoke `onERC721Received` on a target address\r\n     * The call is not executed if the target address is not a contract\r\n     * @param _from address representing the previous owner of the given token ID\r\n     * @param _to target address that will receive the tokens\r\n     * @param _tokenId uint256 ID of the token to be transferred\r\n     * @param _data bytes optional data to send along with the call\r\n     * @return whether the call correctly returned the expected magic value\r\n     */\r\n    function _checkAndCallSafeTransfer(\r\n        address _from,\r\n        address _to,\r\n        uint256 _tokenId,\r\n        bytes _data\r\n    ) internal returns (bool) {\r\n        if (!_isContract(_to)) {\r\n            return true;\r\n        }\r\n        bytes4 retval = IERC721Receiver(_to).onERC721Received(msg.sender, _from, _tokenId, _data);\r\n        return (retval == ERC721_RECEIVED);\r\n    }\r\n\r\n    /**\r\n     * Returns whether the target address is a contract\r\n     * @dev This function will return false if invoked during the constructor of a contract,\r\n     * as the code is not actually created until after the constructor finishes.\r\n     * @param _addr address to check\r\n     * @return whether the target address is a contract\r\n     */\r\n    function _isContract(address _addr) internal view returns (bool) {\r\n        uint256 size;\r\n        // XXX Currently there is no better way to check if there is a contract in an address\r\n        // than to check the size of the code at that address.\r\n        // See https://ethereum.stackexchange.com/a/14016/36603\r\n        // for more details about how this works.\r\n        // TODO Check this again before the Serenity release, because all addresses will be\r\n        // contracts then.\r\n        // solium-disable-next-line security/no-inline-assembly\r\n        assembly { size := extcodesize(_addr) }\r\n        return size > 0;\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev Gets the token name\r\n     * @return string representing the token name\r\n     */\r\n    function name(ERC721Data storage self) external view returns (string) {\r\n        return self.name_;\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the token symbol\r\n     * @return string representing the token symbol\r\n     */\r\n    function symbol(ERC721Data storage self) external view returns (string) {\r\n        return self.symbol_;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns an URI for a given token ID\r\n     * Throws if the token ID does not exist. May return an empty string.\r\n     * @param _tokenId uint256 ID of the token to query\r\n     */\r\n    function tokenURI(ERC721Data storage self, uint256 _tokenId) external view returns (string) {\r\n        require(exists(self, _tokenId));\r\n        return self.tokenURIs[_tokenId];\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the token ID at a given index of the tokens list of the requested owner\r\n     * @param _owner address owning the tokens list to be accessed\r\n     * @param _index uint256 representing the index to be accessed of the requested tokens list\r\n     * @return uint256 token ID at the given index of the tokens list owned by the requested address\r\n     */\r\n    function tokenOfOwnerByIndex(\r\n        ERC721Data storage self,\r\n        address _owner,\r\n        uint256 _index\r\n    ) external view returns (uint256) {\r\n        require(_index < balanceOf(self, _owner));\r\n        return self.ownedTokens[_owner][_index];\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the total amount of tokens stored by the contract\r\n     * @return uint256 representing the total amount of tokens\r\n     */\r\n    function totalSupply(ERC721Data storage self) external view returns (uint256) {\r\n        return self.allTokens.length;\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the token ID at a given index of all the tokens in this contract\r\n     * Reverts if the index is greater or equal to the total number of tokens\r\n     * @param _index uint256 representing the index to be accessed of the tokens list\r\n     * @return uint256 token ID at the given index of the tokens list\r\n     */\r\n    function tokenByIndex(ERC721Data storage self, uint256 _index) external view returns (uint256) {\r\n        require(_index < self.allTokens.length);\r\n        return self.allTokens[_index];\r\n    }\r\n\r\n    /**\r\n     * @dev Function to set the token URI for a given token\r\n     * Reverts if the token ID does not exist\r\n     * @param _tokenId uint256 ID of the token to set its URI\r\n     * @param _uri string URI to assign\r\n     */\r\n    function setTokenURI(ERC721Data storage self, uint256 _tokenId, string _uri) external {\r\n        require(exists(self, _tokenId));\r\n        self.tokenURIs[_tokenId] = _uri;\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to add a token ID to the list of a given address\r\n     * @param _to address representing the new owner of the given token ID\r\n     * @param _tokenId uint256 ID of the token to be added to the tokens list of the given address\r\n     */\r\n    function _addTokenTo(ERC721Data storage self, address _to, uint256 _tokenId) internal {\r\n        require(self.tokenOwner[_tokenId] == address(0));\r\n        self.tokenOwner[_tokenId] = _to;\r\n        self.ownedTokensCount[_to] = self.ownedTokensCount[_to].add(1);\r\n\r\n        uint256 length = self.ownedTokens[_to].length;\r\n        self.ownedTokens[_to].push(_tokenId);\r\n        self.ownedTokensIndex[_tokenId] = length;\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to remove a token ID from the list of a given address\r\n     * @param _from address representing the previous owner of the given token ID\r\n     * @param _tokenId uint256 ID of the token to be removed from the tokens list of the given address\r\n     */\r\n    function _removeTokenFrom(ERC721Data storage self, address _from, uint256 _tokenId) internal {\r\n        require(ownerOf(self, _tokenId) == _from);\r\n        self.ownedTokensCount[_from] = self.ownedTokensCount[_from].sub(1);\r\n        self.tokenOwner[_tokenId] = address(0);\r\n\r\n        // To prevent a gap in the array, we store the last token in the index of the token to delete, and\r\n        // then delete the last slot.\r\n        uint256 tokenIndex = self.ownedTokensIndex[_tokenId];\r\n        uint256 lastTokenIndex = self.ownedTokens[_from].length.sub(1);\r\n        uint256 lastToken = self.ownedTokens[_from][lastTokenIndex];\r\n\r\n        self.ownedTokens[_from][tokenIndex] = lastToken;\r\n        self.ownedTokens[_from].length--;\r\n        // ^ This also deletes the contents at the last position of the array\r\n\r\n        // Note that this will handle single-element arrays. In that case, both tokenIndex and lastTokenIndex are going to\r\n        // be zero. Then we can make sure that we will remove _tokenId from the ownedTokens list since we are first swapping\r\n        // the lastToken to the first position, and then dropping the element placed in the last position of the list\r\n\r\n        self.ownedTokensIndex[_tokenId] = 0;\r\n        self.ownedTokensIndex[lastToken] = tokenIndex;\r\n    }\r\n\r\n    /**\r\n     * @dev Function to mint a new token\r\n     * Reverts if the given token ID already exists\r\n     * @param _to address the beneficiary that will own the minted token\r\n     * @param _tokenId uint256 ID of the token to be minted by the msg.sender\r\n     */\r\n    function mint(ERC721Data storage self, address _to, uint256 _tokenId) external {\r\n        require(_to != address(0));\r\n        _addTokenTo(self, _to, _tokenId);\r\n        emit Transfer(address(0), _to, _tokenId);\r\n\r\n        self.allTokensIndex[_tokenId] = self.allTokens.length;\r\n        self.allTokens.push(_tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Function to burn a specific token\r\n     * Reverts if the token does not exist\r\n     * @param _owner owner of the token to burn\r\n     * @param _tokenId uint256 ID of the token being burned by the msg.sender\r\n     */\r\n    function burn(ERC721Data storage self, address _owner, uint256 _tokenId) external {\r\n        _clearApproval(self, _owner, _tokenId);\r\n        _removeTokenFrom(self, _owner, _tokenId);\r\n        emit Transfer(_owner, address(0), _tokenId);\r\n\r\n        // Clear metadata (if any)\r\n        if (bytes(self.tokenURIs[_tokenId]).length != 0) {\r\n            delete self.tokenURIs[_tokenId];\r\n        }\r\n\r\n        // Reorg all tokens array\r\n        uint256 tokenIndex = self.allTokensIndex[_tokenId];\r\n        uint256 lastTokenIndex = self.allTokens.length.sub(1);\r\n        uint256 lastToken = self.allTokens[lastTokenIndex];\r\n\r\n        self.allTokens[tokenIndex] = lastToken;\r\n        self.allTokens[lastTokenIndex] = 0;\r\n\r\n        self.allTokens.length--;\r\n        self.allTokensIndex[_tokenId] = 0;\r\n        self.allTokensIndex[lastToken] = tokenIndex;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns whether the given spender can transfer a given token ID\r\n     * @param _spender address of the spender to query\r\n     * @param _tokenId uint256 ID of the token to be transferred\r\n     * @return bool whether the msg.sender is approved for the given token ID,\r\n     *  is an operator of the owner, or is the owner of the token\r\n     */\r\n    function isApprovedOrOwner(\r\n        ERC721Data storage self,\r\n        address _spender,\r\n        uint256 _tokenId\r\n    ) public view returns (bool) {\r\n        address owner = ownerOf(self, _tokenId);\r\n        // Disable solium check because of\r\n        // https://github.com/duaraghav8/Solium/issues/175\r\n        // solium-disable-next-line operator-whitespace\r\n        return (\r\n            _spender == owner\r\n            || getApproved(self, _tokenId) == _spender\r\n            || isApprovedForAll(self, owner, _spender)\r\n        );\r\n    }\r\n\r\n}\r\n\r\n// File: contracts/library/token/ERC721Token.sol\r\n\r\n/**\r\n * @title ERC721Token\r\n *\r\n * @dev This token interfaces with the OpenZepellin's ERC721 implementation (as of 7/31/2018) as\r\n * an external library, in order to keep contract sizes smaller.  Intended for use with the\r\n * ERC721Manager.sol, also provided.\r\n *\r\n * Both files are released under the MIT License.\r\n *\r\n *\r\n * The MIT License (MIT)\r\n *\r\n * Copyright (c) 2016 Smart Contract Solutions, Inc.\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining\r\n * a copy of this software and associated documentation files (the\r\n * \"Software\"), to deal in the Software without restriction, including\r\n * without limitation the rights to use, copy, modify, merge, publish,\r\n * distribute, sublicense, and/or sell copies of the Software, and to\r\n * permit persons to whom the Software is furnished to do so, subject to\r\n * the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included\r\n * in all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\r\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\r\n * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\r\n * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\r\n * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\r\n * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n *\r\n */\r\ncontract ERC721Token is ERC165, ERC721 {\r\n\r\n    ERC721Manager.ERC721Data internal erc721Data;\r\n\r\n    // We define the events on both the library and the client, so that the events emitted here are detected\r\n    // as if they had been emitted by the client\r\n    event Transfer(\r\n        address indexed _from,\r\n        address indexed _to,\r\n        uint256 indexed _tokenId\r\n    );\r\n    event Approval(\r\n        address indexed _owner,\r\n        address indexed _approved,\r\n        uint256 indexed _tokenId\r\n    );\r\n    event ApprovalForAll(\r\n        address indexed _owner,\r\n        address indexed _operator,\r\n        bool _approved\r\n    );\r\n\r\n\r\n    constructor(string _name, string _symbol) public {\r\n        ERC721Manager.initialize(erc721Data, _name, _symbol);\r\n    }\r\n\r\n    function supportsInterface(bytes4 _interfaceId) external view returns (bool) {\r\n        return ERC721Manager.supportsInterface(erc721Data, _interfaceId);\r\n    }\r\n\r\n    function balanceOf(address _owner) public view returns (uint256 _balance) {\r\n        return ERC721Manager.balanceOf(erc721Data, _owner);\r\n    }\r\n\r\n    function ownerOf(uint256 _tokenId) public view returns (address _owner) {\r\n        return ERC721Manager.ownerOf(erc721Data, _tokenId);\r\n    }\r\n\r\n    function exists(uint256 _tokenId) public view returns (bool _exists) {\r\n        return ERC721Manager.exists(erc721Data, _tokenId);\r\n    }\r\n\r\n    function approve(address _to, uint256 _tokenId) public {\r\n        ERC721Manager.approve(erc721Data, _to, _tokenId);\r\n    }\r\n\r\n    function getApproved(uint256 _tokenId) public view returns (address _operator) {\r\n        return ERC721Manager.getApproved(erc721Data, _tokenId);\r\n    }\r\n\r\n    function setApprovalForAll(address _to, bool _approved) public {\r\n        ERC721Manager.setApprovalForAll(erc721Data, _to, _approved);\r\n    }\r\n\r\n    function isApprovedForAll(address _owner, address _operator) public view returns (bool) {\r\n        return ERC721Manager.isApprovedForAll(erc721Data, _owner, _operator);\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _tokenId) public {\r\n        ERC721Manager.transferFrom(erc721Data, _from, _to, _tokenId);\r\n    }\r\n\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId) public {\r\n        ERC721Manager.safeTransferFrom(erc721Data, _from, _to, _tokenId);\r\n    }\r\n\r\n    function safeTransferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _tokenId,\r\n        bytes _data\r\n    ) public {\r\n        ERC721Manager.safeTransferFrom(erc721Data, _from, _to, _tokenId, _data);\r\n    }\r\n\r\n\r\n    function totalSupply() public view returns (uint256) {\r\n        return ERC721Manager.totalSupply(erc721Data);\r\n    }\r\n\r\n    function tokenOfOwnerByIndex(address _owner, uint256 _index) public view returns (uint256 _tokenId) {\r\n        return ERC721Manager.tokenOfOwnerByIndex(erc721Data, _owner, _index);\r\n    }\r\n\r\n    function tokenByIndex(uint256 _index) public view returns (uint256) {\r\n        return ERC721Manager.tokenByIndex(erc721Data, _index);\r\n    }\r\n\r\n    function name() external view returns (string _name) {\r\n        return erc721Data.name_;\r\n    }\r\n\r\n    function symbol() external view returns (string _symbol) {\r\n        return erc721Data.symbol_;\r\n    }\r\n\r\n    function tokenURI(uint256 _tokenId) public view returns (string) {\r\n        return ERC721Manager.tokenURI(erc721Data, _tokenId);\r\n    }\r\n\r\n\r\n    function _mint(address _to, uint256 _tokenId) internal {\r\n        ERC721Manager.mint(erc721Data, _to, _tokenId);\r\n    }\r\n\r\n    function _burn(address _owner, uint256 _tokenId) internal {\r\n        ERC721Manager.burn(erc721Data, _owner, _tokenId);\r\n    }\r\n\r\n    function _setTokenURI(uint256 _tokenId, string _uri) internal {\r\n        ERC721Manager.setTokenURI(erc721Data, _tokenId, _uri);\r\n    }\r\n\r\n    function isApprovedOrOwner(\r\n        address _spender,\r\n        uint256 _tokenId\r\n    ) public view returns (bool) {\r\n        return ERC721Manager.isApprovedOrOwner(erc721Data, _spender, _tokenId);\r\n    }\r\n}\r\n\r\n// File: contracts/library/data/PRNG.sol\r\n\r\n/**\r\n * Implementation of the xorshift128+ PRNG\r\n */\r\nlibrary PRNG {\r\n\r\n    struct Data {\r\n        uint64 s0;\r\n        uint64 s1;\r\n    }\r\n\r\n    function next(Data storage self) external returns (uint64) {\r\n        uint64 x = self.s0;\r\n        uint64 y = self.s1;\r\n\r\n        self.s0 = y;\r\n        x ^= x << 23; // a\r\n        self.s1 = x ^ y ^ (x >> 17) ^ (y >> 26); // b, c\r\n        return self.s1 + y;\r\n    }\r\n}\r\n\r\n// File: contracts/library/data/EnumerableSetAddress.sol\r\n\r\n/**\r\n * @title EnumerableSetAddress\r\n * @dev Library containing logic for an enumerable set of address values -- supports checking for presence, adding,\r\n * removing elements, and enumerating elements (without preserving order between mutable operations).\r\n */\r\nlibrary EnumerableSetAddress {\r\n\r\n    struct Data {\r\n        address[] elements;\r\n        mapping(address => uint160) elementToIndex;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns whether the set contains a given element\r\n     *\r\n     * @param self Data storage Reference to set data\r\n     * @param value address Value being checked for existence\r\n     * @return bool\r\n     */\r\n    function contains(Data storage self, address value) external view returns (bool) {\r\n        uint160 mappingIndex = self.elementToIndex[value];\r\n        return (mappingIndex < self.elements.length) && (self.elements[mappingIndex] == value);\r\n    }\r\n\r\n    /**\r\n     * @dev Adds a new element to the set.  Element must not belong to set yet.\r\n     *\r\n     * @param self Data storage Reference to set data\r\n     * @param value address Value being added\r\n     */\r\n    function add(Data storage self, address value) external {\r\n        uint160 mappingIndex = self.elementToIndex[value];\r\n        require(!((mappingIndex < self.elements.length) && (self.elements[mappingIndex] == value)));\r\n\r\n        self.elementToIndex[value] = uint160(self.elements.length);\r\n        self.elements.push(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Removes an element from the set.  Element must already belong to set.\r\n     *\r\n     * @param self Data storage Reference to set data\r\n     * @param value address Value being removed\r\n     */\r\n    function remove(Data storage self, address value) external {\r\n        uint160 currentElementIndex = self.elementToIndex[value];\r\n        require((currentElementIndex < self.elements.length) && (self.elements[currentElementIndex] == value));\r\n\r\n        uint160 lastElementIndex = uint160(self.elements.length - 1);\r\n        address lastElement = self.elements[lastElementIndex];\r\n\r\n        self.elements[currentElementIndex] = lastElement;\r\n        self.elements[lastElementIndex] = 0;\r\n        self.elements.length--;\r\n\r\n        self.elementToIndex[lastElement] = currentElementIndex;\r\n        self.elementToIndex[value] = 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the number of elements on the set.\r\n     *\r\n     * @param self Data storage Reference to set data\r\n     * @return uint160\r\n     */\r\n    function size(Data storage self) external view returns (uint160) {\r\n        return uint160(self.elements.length);\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the N-th element from the set, 0-indexed.  Note that the ordering is not necessarily consistent\r\n     * before and after add, remove operations.\r\n     *\r\n     * @param self Data storage Reference to set data\r\n     * @param index uint160 0-indexed position of the element being queried\r\n     * @return address\r\n     */\r\n    function get(Data storage self, uint160 index) external view returns (address) {\r\n        return self.elements[index];\r\n    }\r\n\r\n    /**\r\n     * @dev Mark the set as empty (not containing any further elements).\r\n     *\r\n     * @param self Data storage Reference to set data\r\n     */\r\n    function clear(Data storage self) external {\r\n        self.elements.length = 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Copy all data from a source set to a target set\r\n     *\r\n     * @param source Data storage Reference to source data\r\n     * @param target Data storage Reference to target data\r\n     */\r\n    function copy(Data storage source, Data storage target) external {\r\n        uint160 numElements = uint160(source.elements.length);\r\n\r\n        target.elements.length = numElements;\r\n        for (uint160 index = 0; index < numElements; index++) {\r\n            address element = source.elements[index];\r\n            target.elements[index] = element;\r\n            target.elementToIndex[element] = index;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Adds all elements from another set into this set, if they are not already present\r\n     *\r\n     * @param self Data storage Reference to set being edited\r\n     * @param other Data storage Reference to set items are being added from\r\n     */\r\n    function addAll(Data storage self, Data storage other) external {\r\n        uint160 numElements = uint160(other.elements.length);\r\n\r\n        for (uint160 index = 0; index < numElements; index++) {\r\n            address value = other.elements[index];\r\n\r\n            uint160 mappingIndex = self.elementToIndex[value];\r\n            if (!((mappingIndex < self.elements.length) && (self.elements[mappingIndex] == value))) {\r\n                self.elementToIndex[value] = uint160(self.elements.length);\r\n                self.elements.push(value);\r\n            }\r\n        }\r\n    }\r\n\r\n}\r\n\r\n// File: contracts/library/data/EnumerableSet256.sol\r\n\r\n/**\r\n * @title EnumerableSet256\r\n * @dev Library containing logic for an enumerable set of uint256 values -- supports checking for presence, adding,\r\n * removing elements, and enumerating elements (without preserving order between mutable operations).\r\n */\r\nlibrary EnumerableSet256 {\r\n\r\n    struct Data {\r\n        uint256[] elements;\r\n        mapping(uint256 => uint256) elementToIndex;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns whether the set contains a given element\r\n     *\r\n     * @param self Data storage Reference to set data\r\n     * @param value uint256 Value being checked for existence\r\n     * @return bool\r\n     */\r\n    function contains(Data storage self, uint256 value) external view returns (bool) {\r\n        uint256 mappingIndex = self.elementToIndex[value];\r\n        return (mappingIndex < self.elements.length) && (self.elements[mappingIndex] == value);\r\n    }\r\n\r\n    /**\r\n     * @dev Adds a new element to the set.  Element must not belong to set yet.\r\n     *\r\n     * @param self Data storage Reference to set data\r\n     * @param value uint256 Value being added\r\n     */\r\n    function add(Data storage self, uint256 value) external {\r\n        uint256 mappingIndex = self.elementToIndex[value];\r\n        require(!((mappingIndex < self.elements.length) && (self.elements[mappingIndex] == value)));\r\n\r\n        self.elementToIndex[value] = uint256(self.elements.length);\r\n        self.elements.push(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Removes an element from the set.  Element must already belong to set yet.\r\n     *\r\n     * @param self Data storage Reference to set data\r\n     * @param value uint256 Value being added\r\n     */\r\n    function remove(Data storage self, uint256 value) external {\r\n        uint256 currentElementIndex = self.elementToIndex[value];\r\n        require((currentElementIndex < self.elements.length) && (self.elements[currentElementIndex] == value));\r\n\r\n        uint256 lastElementIndex = uint256(self.elements.length - 1);\r\n        uint256 lastElement = self.elements[lastElementIndex];\r\n\r\n        self.elements[currentElementIndex] = lastElement;\r\n        self.elements[lastElementIndex] = 0;\r\n        self.elements.length--;\r\n\r\n        self.elementToIndex[lastElement] = currentElementIndex;\r\n        self.elementToIndex[value] = 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the number of elements on the set.\r\n     *\r\n     * @param self Data storage Reference to set data\r\n     * @return uint256\r\n     */\r\n    function size(Data storage self) external view returns (uint256) {\r\n        return uint256(self.elements.length);\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the N-th element from the set, 0-indexed.  Note that the ordering is not necessarily consistent\r\n     * before and after add, remove operations.\r\n     *\r\n     * @param self Data storage Reference to set data\r\n     * @param index uint256 0-indexed position of the element being queried\r\n     * @return uint256\r\n     */\r\n    function get(Data storage self, uint256 index) external view returns (uint256) {\r\n        return self.elements[index];\r\n    }\r\n\r\n    /**\r\n     * @dev Mark the set as empty (not containing any further elements).\r\n     *\r\n     * @param self Data storage Reference to set data\r\n     */\r\n    function clear(Data storage self) external {\r\n        self.elements.length = 0;\r\n    }\r\n}\r\n\r\n// File: contracts/library/data/URIDistribution.sol\r\n\r\n/**\r\n * @title URIDistribution\r\n * @dev Library responsible for maintaining a weighted distribution of URIs\r\n */\r\nlibrary URIDistribution {\r\n\r\n    struct Data {\r\n        uint16[] cumulativeWeights;\r\n        mapping(uint16 => string) uris;\r\n    }\r\n\r\n    /**\r\n     * @dev Adds a URI to the distribution, with a given weight\r\n     *\r\n     * @param self Data storage Distribution data reference\r\n     * @param weight uint16 Relative distribution weight\r\n     * @param uri string URI to be stored\r\n     */\r\n    function addURI(Data storage self, uint16 weight, string uri) external {\r\n        if (weight == 0) return;\r\n\r\n        if (self.cumulativeWeights.length == 0) {\r\n            self.cumulativeWeights.push(weight);\r\n        } else {\r\n            self.cumulativeWeights.push(self.cumulativeWeights[uint16(self.cumulativeWeights.length - 1)] + weight);\r\n        }\r\n        self.uris[uint16(self.cumulativeWeights.length - 1)] = uri;\r\n    }\r\n\r\n    /**\r\n     * @dev Gets an URI from the distribution, with the given random seed\r\n     *\r\n     * @param self Data storage Distribution data reference\r\n     * @param seed uint64\r\n     * @return string\r\n     */\r\n    function getURI(Data storage self, uint64 seed) external view returns (string) {\r\n        uint16 n = uint16(self.cumulativeWeights.length);\r\n        uint16 modSeed = uint16(seed % uint64(self.cumulativeWeights[n - 1]));\r\n\r\n        uint16 left = 0;\r\n        uint16 right = n;\r\n        uint16 mid;\r\n\r\n        while (left < right) {\r\n            mid = uint16((uint24(left) + uint24(right)) / 2);\r\n            if (self.cumulativeWeights[mid] <= modSeed) {\r\n                left = mid + 1;\r\n            } else {\r\n                right = mid;\r\n            }\r\n        }\r\n        return self.uris[left];\r\n    }\r\n}\r\n\r\n// File: contracts/library/game/GameDataLib.sol\r\n\r\n/**\r\n * @title GameDataLib\r\n *\r\n * Library containing data structures and logic for game entities.\r\n */\r\nlibrary GameDataLib {\r\n\r\n    /** Data structures */\r\n\r\n    struct Butterfly {\r\n        // data encoding butterfly appearance\r\n        uint64 gene;\r\n\r\n        // time this butterfly was created\r\n        uint64 createdTimestamp;\r\n\r\n        // last time this butterfly changed owner\r\n        uint64 lastTimestamp;\r\n\r\n        // set of owners, current and former\r\n        EnumerableSetAddress.Data previousAddresses;\r\n    }\r\n\r\n    struct Heart {\r\n        // ID of butterfly that generated this heart\r\n        uint256 butterflyId;\r\n\r\n        // time this heart was generated\r\n        uint64 snapshotTimestamp;\r\n\r\n        // set of owners, current and former, at time heart was generated\r\n        EnumerableSetAddress.Data previousAddresses;\r\n    }\r\n\r\n    struct Flower {\r\n        // Whether this address has ever claimed a butterfly\r\n        bool isClaimed;\r\n\r\n        // Data encoding flower appearance\r\n        uint64 gene;\r\n\r\n        // Data encoding the garden's timezone\r\n        uint64 gardenTimezone;\r\n\r\n        // Data encoding the creation timestamp\r\n        uint64 createdTimestamp;\r\n\r\n        // index of the flower registration\r\n        uint160 flowerIndex;\r\n    }\r\n\r\n    struct URIMappingData {\r\n        URIDistribution.Data flowerURIs;\r\n        string whiteFlowerURI;\r\n\r\n        URIDistribution.Data butterflyLiveURIs;\r\n        URIDistribution.Data butterflyDeadURIs;\r\n        URIDistribution.Data heartURIs;\r\n    }\r\n\r\n    // possible types of NFT\r\n    enum TokenType {\r\n        Butterfly,\r\n        Heart\r\n    }\r\n\r\n    struct Data {\r\n        // global pseudo-randomization seed\r\n        PRNG.Data seed;\r\n\r\n        // next ID available for token generation\r\n        uint256 nextId;\r\n\r\n        // token type data\r\n        mapping (uint256 => TokenType) tokenToType;\r\n        mapping (uint8 => mapping (address => EnumerableSet256.Data)) typedOwnedTokens;\r\n        mapping (uint8 => EnumerableSet256.Data) typedTokens;\r\n\r\n        // token data\r\n        mapping (uint256 => Butterfly) butterflyData;\r\n        mapping (uint256 => Heart) heartData;\r\n\r\n        // owner data\r\n        mapping (address => Flower) flowerData;\r\n        address[] claimedFlowers;\r\n\r\n        // URI mapping data\r\n        URIMappingData uriMappingData;\r\n    }\r\n\r\n    /** Viewer methods */\r\n\r\n    /**\r\n     * @dev Gets game information associated with a specific butterfly.\r\n     * Requires ID to be a valid butterfly.\r\n     *\r\n     * @param self Data storage Reference to game data\r\n     * @param butterflyId uint256 ID of butterfly being queried\r\n     *\r\n     * @return gene uint64\r\n     * @return createdTimestamp uint64\r\n     * @return lastTimestamp uint64\r\n     * @return numOwners uint160\r\n     */\r\n    function getButterflyInfo(\r\n        Data storage self,\r\n        uint256 butterflyId\r\n    ) external view returns (\r\n        uint64 gene,\r\n        uint64 createdTimestamp,\r\n        uint64 lastTimestamp,\r\n        uint160 numOwners\r\n    ) {\r\n        Butterfly storage butterfly = self.butterflyData[butterflyId];\r\n        require(butterfly.createdTimestamp != 0);\r\n\r\n        gene = butterfly.gene;\r\n        createdTimestamp = butterfly.createdTimestamp;\r\n        lastTimestamp = butterfly.lastTimestamp;\r\n        numOwners = uint160(butterfly.previousAddresses.elements.length);\r\n    }\r\n\r\n    /**\r\n     * @dev Gets game information associated with a specific heart.\r\n     * Requires ID to be a valid heart.\r\n     *\r\n     * @param self Data storage Reference to game data\r\n     * @param heartId uint256 ID of heart being queried\r\n     *\r\n     * @return butterflyId uint256\r\n     * @return gene uint64\r\n     * @return snapshotTimestamp uint64\r\n     * @return numOwners uint160\r\n     */\r\n    function getHeartInfo(\r\n        Data storage self,\r\n        uint256 heartId\r\n    ) external view returns (\r\n        uint256 butterflyId,\r\n        uint64 gene,\r\n        uint64 snapshotTimestamp,\r\n        uint160 numOwners\r\n    ) {\r\n        Heart storage heart = self.heartData[heartId];\r\n        require(heart.snapshotTimestamp != 0);\r\n\r\n        butterflyId = heart.butterflyId;\r\n        gene = self.butterflyData[butterflyId].gene;\r\n        snapshotTimestamp = heart.snapshotTimestamp;\r\n        numOwners = uint160(heart.previousAddresses.elements.length);\r\n    }\r\n\r\n    /**\r\n     * @dev Gets game information associated with a specific flower.\r\n     *\r\n     * @param self Data storage Reference to game data\r\n     * @param flowerAddress address Address of the flower being queried\r\n     *\r\n     * @return isClaimed bool\r\n     * @return gene uint64\r\n     * @return gardenTimezone uint64\r\n     * @return createdTimestamp uint64\r\n     * @return flowerIndex uint160\r\n     */\r\n    function getFlowerInfo(\r\n        Data storage self,\r\n        address flowerAddress\r\n    ) external view returns (\r\n        bool isClaimed,\r\n        uint64 gene,\r\n        uint64 gardenTimezone,\r\n        uint64 createdTimestamp,\r\n        uint160 flowerIndex\r\n    ) {\r\n        Flower storage flower = self.flowerData[flowerAddress];\r\n\r\n        isClaimed = flower.isClaimed;\r\n        if (isClaimed) {\r\n            gene = flower.gene;\r\n            gardenTimezone = flower.gardenTimezone;\r\n            createdTimestamp = flower.createdTimestamp;\r\n            flowerIndex = flower.flowerIndex;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the N-th owner associated with a butterfly.\r\n     * Requires ID to be a valid butterfly, and owner index to be smaller than the number of owners.\r\n     *\r\n     * @param self Data storage Reference to game data\r\n     * @param butterflyId uint256 ID of butterfly being queried\r\n     * @param index uint160 Index of owner being queried\r\n     *\r\n     * @return address\r\n     */\r\n    function getButterflyOwnerByIndex(\r\n        Data storage self,\r\n        uint256 butterflyId,\r\n        uint160 index\r\n    ) external view returns (address) {\r\n        Butterfly storage butterfly = self.butterflyData[butterflyId];\r\n        require(butterfly.createdTimestamp != 0);\r\n\r\n        return butterfly.previousAddresses.elements[index];\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the N-th owner associated with a heart's snapshot.\r\n     * Requires ID to be a valid butterfly, and owner index to be smaller than the number of owners.\r\n     *\r\n     * @param self Data storage Reference to game data\r\n     * @param heartId uint256 ID of heart being queried\r\n     * @param index uint160 Index of owner being queried\r\n     *\r\n     * @return address\r\n     */\r\n    function getHeartOwnerByIndex(\r\n        Data storage self,\r\n        uint256 heartId,\r\n        uint160 index\r\n    ) external view returns (address) {\r\n        Heart storage heart = self.heartData[heartId];\r\n        require(heart.snapshotTimestamp != 0);\r\n\r\n        return heart.previousAddresses.elements[index];\r\n    }\r\n\r\n    /**\r\n     * @dev Determines whether the game logic allows a transfer of a butterfly to another address.\r\n     * Conditions:\r\n     * - The receiver address must have already claimed a butterfly\r\n     * - The butterfly's last timestamp is within the last 24 hours\r\n     * - The receiver address must have never claimed *this* butterfly\r\n     * OR\r\n     * - The receiver is 0x0\r\n     *\r\n     * @param self Data storage Reference to game data\r\n     * @param butterflyId uint256 ID of butterfly being queried\r\n     * @param receiver address Address of potential receiver\r\n     * @param currentTimestamp uint64\r\n     */\r\n    function canReceiveButterfly(\r\n        Data storage self,\r\n        uint256 butterflyId,\r\n        address receiver,\r\n        uint64 currentTimestamp\r\n    ) public view returns (bool) {\r\n        Butterfly storage butterfly = self.butterflyData[butterflyId];\r\n\r\n        // butterfly must exist\r\n        if (butterfly.createdTimestamp == 0)\r\n            return false;\r\n\r\n        // can always transfer to 0 (destroying it)\r\n        if (receiver == address(0x0))\r\n            return true;\r\n\r\n        // butterfly must have been last updated on the last day\r\n        if (currentTimestamp < butterfly.lastTimestamp || currentTimestamp - butterfly.lastTimestamp > 1 days)\r\n            return false;\r\n\r\n        // receiver must have already claimed\r\n        Flower storage flower = self.flowerData[receiver];\r\n        if (!flower.isClaimed) return false;\r\n\r\n        // receiver must have never owned this butterfly\r\n        return !EnumerableSetAddress.contains(butterfly.previousAddresses, receiver);\r\n    }\r\n\r\n\r\n    /** Editor methods */\r\n\r\n    /**\r\n     * @dev Claims a flower and an initial butterfly for a given address.\r\n     * Requires address to have not claimed previously\r\n     *\r\n     * @param self Data storage Reference to game data\r\n     * @param claimer address Address making the claim\r\n     * @param gardenTimezone uint64\r\n     * @param currentTimestamp uint64\r\n     *\r\n     * @return butterflyId uint256 ID for the new butterfly\r\n     */\r\n    function claim(\r\n        Data storage self,\r\n        address claimer,\r\n        uint64 gardenTimezone,\r\n        uint64 currentTimestamp\r\n    ) external returns (uint256 butterflyId) {\r\n        Flower storage flower = self.flowerData[claimer];\r\n\r\n        // require address has not claimed before\r\n        require(!flower.isClaimed);\r\n        // assert no overflow on IDs\r\n        require(self.nextId + 1 != 0);\r\n\r\n        // get butterfly ID\r\n        butterflyId = self.nextId;\r\n        // assert ID is not being reused\r\n        Butterfly storage butterfly = self.butterflyData[butterflyId];\r\n        require(butterfly.createdTimestamp == 0);\r\n        // update counter\r\n        self.nextId++;\r\n\r\n        // update flower data\r\n        flower.isClaimed = true;\r\n        flower.gardenTimezone = gardenTimezone;\r\n        flower.createdTimestamp = currentTimestamp;\r\n        flower.gene = PRNG.next(self.seed);\r\n        flower.flowerIndex = uint160(self.claimedFlowers.length);\r\n\r\n        // update butterfly data\r\n        butterfly.gene = PRNG.next(self.seed);\r\n        butterfly.createdTimestamp = currentTimestamp;\r\n        butterfly.lastTimestamp = currentTimestamp;\r\n        EnumerableSetAddress.add(butterfly.previousAddresses, claimer);\r\n\r\n        // update butterfly token data\r\n        self.tokenToType[butterflyId] = TokenType.Butterfly;\r\n\r\n        // register butterfly token\r\n        EnumerableSet256.add(self.typedOwnedTokens[uint8(TokenType.Butterfly)][claimer], butterflyId);\r\n        EnumerableSet256.add(self.typedTokens[uint8(TokenType.Butterfly)], butterflyId);\r\n\r\n        // register address\r\n        self.claimedFlowers.push(claimer);\r\n    }\r\n\r\n    /**\r\n     * @dev Logs a transfer of a butterfly between two addresses, leaving a heart behind.\r\n     *\r\n     * Conditions:\r\n     * - The receiver address must have already claimed a butterfly\r\n     * - The butterfly's last timestamp is within the last 24 hours\r\n     *\r\n     * @param self Data storage Reference to game data\r\n     * @param butterflyId uint256 ID of butterfly being queried\r\n     * @param sender Address of sender\r\n     * @param receiver address Address of potential receiver\r\n     * @param currentTimestamp uint64\r\n     *\r\n     * @return heartId uint256 ID for the new heart\r\n     */\r\n    function transferButterfly(\r\n        Data storage self,\r\n        uint256 butterflyId,\r\n        address sender,\r\n        address receiver,\r\n        uint64 currentTimestamp\r\n    ) external returns (uint256 heartId) {\r\n        // require transfer conditions to be satisfied\r\n        require(canReceiveButterfly(self, butterflyId, receiver, currentTimestamp));\r\n\r\n        // require no overflow on IDs\r\n        require(self.nextId + 1 != 0);\r\n        // get heart ID\r\n        heartId = self.nextId;\r\n        // assert ID is not being reused\r\n        Heart storage heart = self.heartData[heartId];\r\n        require(heart.snapshotTimestamp == 0);\r\n        // update counter\r\n        self.nextId++;\r\n\r\n        // update heart data\r\n        heart.butterflyId = butterflyId;\r\n        heart.snapshotTimestamp = currentTimestamp;\r\n        Butterfly storage butterfly = self.butterflyData[butterflyId];\r\n\r\n        // update heart token heartId\r\n        self.tokenToType[heartId] = TokenType.Heart;\r\n\r\n        // update butterfly data\r\n        butterfly.lastTimestamp = currentTimestamp;\r\n        EnumerableSetAddress.add(butterfly.previousAddresses, receiver);\r\n\r\n        // update heart addresses\r\n        EnumerableSetAddress.copy(butterfly.previousAddresses, heart.previousAddresses);\r\n\r\n        // update butterfly register\r\n        EnumerableSet256.remove(self.typedOwnedTokens[uint8(TokenType.Butterfly)][sender], butterflyId);\r\n        EnumerableSet256.add(self.typedOwnedTokens[uint8(TokenType.Butterfly)][receiver], butterflyId);\r\n\r\n        // update heart register\r\n        EnumerableSet256.add(self.typedOwnedTokens[uint8(TokenType.Heart)][sender], heartId);\r\n        EnumerableSet256.add(self.typedTokens[uint8(TokenType.Heart)], heartId);\r\n    }\r\n\r\n    /**\r\n     * @dev Logs a transfer of a heart between two addresses\r\n     *\r\n     * @param self Data storage Reference to game data\r\n     * @param heartId uint256 ID of heart being queried\r\n     * @param sender Address of sender\r\n     * @param receiver address Address of potential receiver\r\n     */\r\n    function transferHeart(\r\n        Data storage self,\r\n        uint256 heartId,\r\n        address sender,\r\n        address receiver\r\n    ) external {\r\n        // update heart register\r\n        EnumerableSet256.remove(self.typedOwnedTokens[uint8(TokenType.Heart)][sender], heartId);\r\n        EnumerableSet256.add(self.typedOwnedTokens[uint8(TokenType.Heart)][receiver], heartId);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the total number of tokens for a given type, owned by a specific address\r\n     *\r\n     * @param self Data storage Reference to game data\r\n     * @param tokenType uint8\r\n     * @param _owner address\r\n     *\r\n     * @return uint256\r\n     */\r\n    function typedBalanceOf(Data storage self, uint8 tokenType, address _owner) public view returns (uint256) {\r\n        return self.typedOwnedTokens[tokenType][_owner].elements.length;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the total number of tokens for a given type\r\n     *\r\n     * @param self Data storage Reference to game data\r\n     * @param tokenType uint8\r\n     *\r\n     * @return uint256\r\n     */\r\n    function typedTotalSupply(Data storage self, uint8 tokenType) public view returns (uint256) {\r\n        return self.typedTokens[tokenType].elements.length;\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev Returns the I-th token of a specific type owned by an index\r\n     *\r\n     * @param self Data storage Reference to game data\r\n     * @param tokenType uint8\r\n     * @param _owner address\r\n     * @param _index uint256\r\n     *\r\n     * @return uint256\r\n     */\r\n    function typedTokenOfOwnerByIndex(\r\n        Data storage self,\r\n        uint8 tokenType,\r\n        address _owner,\r\n        uint256 _index\r\n    ) external view returns (uint256) {\r\n        return self.typedOwnedTokens[tokenType][_owner].elements[_index];\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the I-th token of a specific type\r\n     *\r\n     * @param self Data storage Reference to game data\r\n     * @param tokenType uint8\r\n     * @param _index uint256\r\n     *\r\n     * @return uint256\r\n     */\r\n    function typedTokenByIndex(\r\n        Data storage self,\r\n        uint8 tokenType,\r\n        uint256 _index\r\n    ) external view returns (uint256) {\r\n        return self.typedTokens[tokenType].elements[_index];\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the total number of claimed flowers\r\n     *\r\n     * @param self Data storage Reference to game data\r\n     * @return uint160\r\n     */\r\n    function totalFlowers(Data storage self) external view returns (uint160) {\r\n        return uint160(self.claimedFlowers.length);\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the address of the N-th flower\r\n     *\r\n     * @param self Data storage Reference to game data\r\n     * @return address\r\n     */\r\n    function getFlowerByIndex(Data storage self, uint160 index) external view returns (address) {\r\n        return self.claimedFlowers[index];\r\n    }\r\n\r\n    /** Admin methods **/\r\n\r\n    /**\r\n     * @dev Registers a new flower URI with the corresponding weight\r\n     *\r\n     * @param self Data storage Reference to game data\r\n     * @param weight uint16 Relative weight for the occurrence of this URI\r\n     * @param uri string\r\n     */\r\n    function addFlowerURI(Data storage self, uint16 weight, string uri) external {\r\n        URIDistribution.addURI(self.uriMappingData.flowerURIs, weight, uri);\r\n    }\r\n\r\n    /**\r\n     * @dev Registers the flower URI for address 0\r\n     *\r\n     * @param self Data storage Reference to game data\r\n     * @param uri string\r\n     */\r\n    function setWhiteFlowerURI(Data storage self, string uri) external {\r\n        self.uriMappingData.whiteFlowerURI = uri;\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the flower URI for address 0\r\n     *\r\n     * @param self Data storage Reference to game data\r\n     * @return string\r\n     */\r\n    function getWhiteFlowerURI(Data storage self) external view returns (string) {\r\n        return self.uriMappingData.whiteFlowerURI;\r\n    }\r\n\r\n    /**\r\n     * @dev Registers a new butterfly URI with the corresponding weight\r\n     *\r\n     * @param self Data storage Reference to game data\r\n     * @param weight uint16 Relative weight for the occurrence of this URI\r\n     * @param liveUri string\r\n     * @param deadUri string\r\n     * @param heartUri string\r\n     */\r\n    function addButterflyURI(Data storage self, uint16 weight, string liveUri, string deadUri, string heartUri) external {\r\n        URIDistribution.addURI(self.uriMappingData.butterflyLiveURIs, weight, liveUri);\r\n        URIDistribution.addURI(self.uriMappingData.butterflyDeadURIs, weight, deadUri);\r\n        URIDistribution.addURI(self.uriMappingData.heartURIs, weight, heartUri);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the URI mapped to a particular flower.\r\n     * Requires flower to be claimed / exist.\r\n     *\r\n     * @param self Data storage Reference to game data\r\n     * @param flowerAddress address Flower being queried\r\n     * @return string\r\n     */\r\n    function getFlowerURI(Data storage self, address flowerAddress) external view returns (string) {\r\n        Flower storage flower = self.flowerData[flowerAddress];\r\n        require(flower.isClaimed);\r\n        return URIDistribution.getURI(self.uriMappingData.flowerURIs, flower.gene);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the URI mapped to a particular butterfly -- selecting the URI for it being alive\r\n     * or dead based on the current timestamp.\r\n     * Requires butterfly to exist.\r\n     *\r\n     * @param self Data storage Reference to game data\r\n     * @param erc721Data ERC721Manager.ERC721Data storage Reference to ownership data\r\n     * @param butterflyId uint256 ID of the butterfly being queried\r\n     * @param currentTimestamp uint64\r\n     * @return string\r\n     */\r\n    function getButterflyURI(\r\n        Data storage self,\r\n        ERC721Manager.ERC721Data storage erc721Data,\r\n        uint256 butterflyId,\r\n        uint64 currentTimestamp\r\n    ) external view returns (string) {\r\n        Butterfly storage butterfly = self.butterflyData[butterflyId];\r\n        require(butterfly.createdTimestamp != 0);\r\n\r\n        if (erc721Data.tokenOwner[butterflyId] == 0\r\n            || currentTimestamp < butterfly.lastTimestamp\r\n            || currentTimestamp - butterfly.lastTimestamp > 1 days) {\r\n            return URIDistribution.getURI(self.uriMappingData.butterflyDeadURIs, butterfly.gene);\r\n        }\r\n        return URIDistribution.getURI(self.uriMappingData.butterflyLiveURIs, butterfly.gene);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the URI for a particular butterfly gene -- useful for seeing the butterfly \"as it was\"\r\n     * when it dropped a heart\r\n     *\r\n     * @param self Daata storage Reference to game data\r\n     * @param gene uint64\r\n     * @param isAlive bool\r\n     * @return string\r\n     */\r\n    function getButterflyURIFromGene(\r\n        Data storage self,\r\n        uint64 gene,\r\n        bool isAlive\r\n    ) external view returns (string) {\r\n        if (isAlive) {\r\n            return URIDistribution.getURI(self.uriMappingData.butterflyLiveURIs, gene);\r\n        }\r\n        return URIDistribution.getURI(self.uriMappingData.butterflyDeadURIs, gene);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the URI mapped to hearts\r\n     *\r\n     * @param self Data storage Reference to game data\r\n     * @param heartId uint256 ID of heart being queried\r\n     * @return string\r\n     */\r\n    function getHeartURI(Data storage self, uint256 heartId) external view returns (string) {\r\n        Heart storage heart = self.heartData[heartId];\r\n        require(heart.snapshotTimestamp != 0);\r\n\r\n        uint64 gene = self.butterflyData[heart.butterflyId].gene;\r\n        return URIDistribution.getURI(self.uriMappingData.heartURIs, gene);\r\n    }\r\n\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address private _owner;\r\n\r\n  event OwnershipTransferred(\r\n    address indexed previousOwner,\r\n    address indexed newOwner\r\n  );\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  constructor() internal {\r\n    _owner = msg.sender;\r\n    emit OwnershipTransferred(address(0), _owner);\r\n  }\r\n\r\n  /**\r\n   * @return the address of the owner.\r\n   */\r\n  function owner() public view returns(address) {\r\n    return _owner;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(isOwner());\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @return true if `msg.sender` is the owner of the contract.\r\n   */\r\n  function isOwner() public view returns(bool) {\r\n    return msg.sender == _owner;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to relinquish control of the contract.\r\n   * @notice Renouncing to ownership will leave the contract without an owner.\r\n   * It will not be possible to call the functions with the `onlyOwner`\r\n   * modifier anymore.\r\n   */\r\n  function renounceOwnership() public onlyOwner {\r\n    emit OwnershipTransferred(_owner, address(0));\r\n    _owner = address(0);\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    _transferOwnership(newOwner);\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function _transferOwnership(address newOwner) internal {\r\n    require(newOwner != address(0));\r\n    emit OwnershipTransferred(_owner, newOwner);\r\n    _owner = newOwner;\r\n  }\r\n}\r\n\r\n// File: contracts\\game\\Main.sol\r\n\r\n/**\r\n * @title Main\r\n *\r\n * Main contract for LittleButterflies.  Implements the ERC721 EIP for Non-Fungible Tokens.\r\n */\r\ncontract Main is ERC721Token, Ownable {\r\n\r\n    GameDataLib.Data internal data;\r\n\r\n    // Set our token name and symbol\r\n    constructor() ERC721Token(\"LittleButterfly\", \"BFLY\") public {\r\n        // initialize PRNG values\r\n        data.seed.s0 = uint64(now);\r\n        data.seed.s1 = uint64(msg.sender);\r\n    }\r\n\r\n\r\n    /** Token viewer methods **/\r\n\r\n\r\n    /**\r\n     * @dev Gets game information associated with a specific butterfly.\r\n     * Requires ID to be a valid butterfly.\r\n     *\r\n     * @param butterflyId uint256 ID of butterfly being queried\r\n     *\r\n     * @return gene uint64\r\n     * @return createdTimestamp uint64\r\n     * @return lastTimestamp uint64\r\n     * @return numOwners uint160\r\n     */\r\n    function getButterflyInfo(uint256 butterflyId) public view returns (\r\n        uint64 gene,\r\n        uint64 createdTimestamp,\r\n        uint64 lastTimestamp,\r\n        uint160 numOwners\r\n    ) {\r\n       (gene, createdTimestamp, lastTimestamp, numOwners) = GameDataLib.getButterflyInfo(data, butterflyId);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the N-th owner associated with a butterfly.\r\n     * Requires ID to be a valid butterfly, and owner index to be smaller than the number of owners.\r\n     *\r\n     * @param butterflyId uint256 ID of butterfly being queried\r\n     * @param index uint160 Index of owner being queried\r\n     *\r\n     * @return address\r\n     */\r\n    function getButterflyOwnerByIndex(\r\n        uint256 butterflyId,\r\n        uint160 index\r\n    ) external view returns (address) {\r\n        return GameDataLib.getButterflyOwnerByIndex(data, butterflyId, index);\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev Gets game information associated with a specific heart.\r\n     * Requires ID to be a valid heart.\r\n     *\r\n     * @param heartId uint256 ID of heart being queried\r\n     *\r\n     * @return butterflyId uint256\r\n     * @return gene uint64\r\n     * @return snapshotTimestamp uint64\r\n     * @return numOwners uint160\r\n     */\r\n    function getHeartInfo(uint256 heartId) public view returns (\r\n        uint256 butterflyId,\r\n        uint64 gene,\r\n        uint64 snapshotTimestamp,\r\n        uint160 numOwners\r\n    ) {\r\n        (butterflyId, gene, snapshotTimestamp, numOwners) = GameDataLib.getHeartInfo(data, heartId);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the N-th owner associated with a heart's snapshot.\r\n     * Requires ID to be a valid butterfly, and owner index to be smaller than the number of owners.\r\n     *\r\n     * @param heartId uint256 ID of heart being queried\r\n     * @param index uint160 Index of owner being queried\r\n     *\r\n     * @return address\r\n     */\r\n    function getHeartOwnerByIndex(\r\n        uint256 heartId,\r\n        uint160 index\r\n    ) external view returns (address) {\r\n        return GameDataLib.getHeartOwnerByIndex(data, heartId, index);\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev Gets game information associated with a specific flower.\r\n     *\r\n     * @param flowerAddress address Address of the flower being queried\r\n     *\r\n     * @return isClaimed bool\r\n     * @return gene uint64\r\n     * @return gardenTimezone uint64\r\n     * @return createdTimestamp uint64\r\n     * @return flowerIndex uint160\r\n     */\r\n    function getFlowerInfo(\r\n        address flowerAddress\r\n    ) external view returns (\r\n        bool isClaimed,\r\n        uint64 gene,\r\n        uint64 gardenTimezone,\r\n        uint64 createdTimestamp,\r\n        uint160 flowerIndex\r\n    ) {\r\n        (isClaimed, gene, gardenTimezone, createdTimestamp, flowerIndex) = GameDataLib.getFlowerInfo(data, flowerAddress);\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev Determines whether the game logic allows a transfer of a butterfly to another address.\r\n     * Conditions:\r\n     * - The receiver address must have already claimed a butterfly\r\n     * - The butterfly's last timestamp is within the last 24 hours\r\n     * - The receiver address must have never claimed *this* butterfly\r\n     *\r\n     * @param butterflyId uint256 ID of butterfly being queried\r\n     * @param receiver address Address of potential receiver\r\n     */\r\n    function canReceiveButterfly(\r\n        uint256 butterflyId,\r\n        address receiver\r\n    ) external view returns (bool) {\r\n        return GameDataLib.canReceiveButterfly(data, butterflyId, receiver, uint64(now));\r\n    }\r\n\r\n\r\n    /** Override token methods **/\r\n\r\n    /**\r\n     * @dev Override the default ERC721 transferFrom implementation in order to check game conditions and\r\n     * generate side effects\r\n     */\r\n    function transferFrom(address _from, address _to, uint256 _tokenId) public {\r\n        _setupTransferFrom(_from, _to, _tokenId, uint64(now));\r\n        ERC721Manager.transferFrom(erc721Data, _from, _to, _tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Override the default ERC721 safeTransferFrom implementation in order to check game conditions and\r\n     * generate side effects\r\n     */\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId) public {\r\n        _setupTransferFrom(_from, _to, _tokenId, uint64(now));\r\n        ERC721Manager.safeTransferFrom(erc721Data, _from, _to, _tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Override the default ERC721 safeTransferFrom implementation in order to check game conditions and\r\n     * generate side effects\r\n     */\r\n    function safeTransferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _tokenId,\r\n        bytes _data\r\n    ) public {\r\n        _setupTransferFrom(_from, _to, _tokenId, uint64(now));\r\n        ERC721Manager.safeTransferFrom(erc721Data, _from, _to, _tokenId, _data);\r\n    }\r\n\r\n\r\n    /**\r\n    * @dev Execute before transfer, preventing token transfer in some circumstances.\r\n    * Requirements:\r\n    *  - Caller is owner, approved, or operator for the token\r\n    *  - To has claimed a token before\r\n    *  - Token is a Heart, or Token's last activity was in the last 24 hours\r\n    *\r\n    * @param from current owner of the token\r\n    * @param to address to receive the ownership of the given token ID\r\n    * @param tokenId uint256 ID of the token to be transferred\r\n    * @param currentTimestamp uint64\r\n    */\r\n    function _setupTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId,\r\n        uint64 currentTimestamp\r\n    ) private {\r\n        if (data.tokenToType[tokenId] == GameDataLib.TokenType.Butterfly) {\r\n            // try to do transfer and mint a heart\r\n            uint256 heartId = GameDataLib.transferButterfly(data, tokenId, from, to, currentTimestamp);\r\n            ERC721Manager.mint(erc721Data, from, heartId);\r\n        } else {\r\n            GameDataLib.transferHeart(data, tokenId, from, to);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Overrides the default tokenURI method to lookup from the stored table of URIs -- rather than\r\n     * storing a copy of the URI for each instance\r\n     *\r\n     * @param _tokenId uint256\r\n     * @return string\r\n     */\r\n    function tokenURI(uint256 _tokenId) public view returns (string) {\r\n        if (data.tokenToType[_tokenId] == GameDataLib.TokenType.Heart) {\r\n            return GameDataLib.getHeartURI(data, _tokenId);\r\n        }\r\n        return GameDataLib.getButterflyURI(data, erc721Data, _tokenId, uint64(now));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the URI mapped to a particular account / flower\r\n     *\r\n     * @param accountAddress address\r\n     * @return string\r\n     */\r\n    function accountURI(address accountAddress) public view returns (string) {\r\n        return GameDataLib.getFlowerURI(data, accountAddress);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the URI mapped to account 0\r\n     *\r\n     * @return string\r\n     */\r\n    function accountZeroURI() public view returns (string) {\r\n        return GameDataLib.getWhiteFlowerURI(data);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the URI for a particular butterfly gene -- useful for seeing the butterfly \"as it was\"\r\n     * when it dropped a heart\r\n     *\r\n     * @param gene uint64\r\n     * @param isAlive bool\r\n     * @return string\r\n     */\r\n    function getButterflyURIFromGene(uint64 gene, bool isAlive) public view returns (string) {\r\n        return GameDataLib.getButterflyURIFromGene(data, gene, isAlive);\r\n    }\r\n\r\n\r\n    /** Extra token methods **/\r\n\r\n    /**\r\n     * @dev Claims a flower and an initial butterfly for a given address.\r\n     * Requires address to have not claimed previously\r\n     *\r\n     * @param gardenTimezone uint64\r\n     */\r\n    function claim(uint64 gardenTimezone) external {\r\n        address claimer = msg.sender;\r\n\r\n        // claim a butterfly\r\n        uint256 butterflyId = GameDataLib.claim(data, claimer, gardenTimezone, uint64(now));\r\n\r\n        // mint its token\r\n        ERC721Manager.mint(erc721Data, claimer, butterflyId);\r\n    }\r\n\r\n    /**\r\n     * @dev Burns a token.  Caller must be owner or approved.\r\n     *\r\n     * @param _tokenId uint256 ID of token to burn\r\n     */\r\n    function burn(uint256 _tokenId) public {\r\n        require(ERC721Manager.isApprovedOrOwner(erc721Data, msg.sender, _tokenId));\r\n\r\n        address _owner = ERC721Manager.ownerOf(erc721Data, _tokenId);\r\n\r\n        _setupTransferFrom(_owner, address(0x0), _tokenId, uint64(now));\r\n        ERC721Manager.burn(erc721Data, _owner, _tokenId);\r\n    }\r\n\r\n\r\n\r\n    /**\r\n     * @dev Returns the total number of tokens for a given type, owned by a specific address\r\n     *\r\n     * @param tokenType uint8\r\n     * @param _owner address\r\n     *\r\n     * @return uint256\r\n     */\r\n    function typedBalanceOf(uint8 tokenType, address _owner) public view returns (uint256) {\r\n        return GameDataLib.typedBalanceOf(data, tokenType, _owner);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the total number of tokens for a given type\r\n     *\r\n     * @param tokenType uint8\r\n     *\r\n     * @return uint256\r\n     */\r\n    function typedTotalSupply(uint8 tokenType) public view returns (uint256) {\r\n        return GameDataLib.typedTotalSupply(data, tokenType);\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev Returns the I-th token of a specific type owned by an index\r\n     *\r\n     * @param tokenType uint8\r\n     * @param _owner address\r\n     * @param _index uint256\r\n     *\r\n     * @return uint256\r\n     */\r\n    function typedTokenOfOwnerByIndex(\r\n        uint8 tokenType,\r\n        address _owner,\r\n        uint256 _index\r\n    ) external view returns (uint256) {\r\n        return GameDataLib.typedTokenOfOwnerByIndex(data, tokenType, _owner, _index);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the I-th token of a specific type\r\n     *\r\n     * @param tokenType uint8\r\n     * @param _index uint256\r\n     *\r\n     * @return uint256\r\n     */\r\n    function typedTokenByIndex(\r\n        uint8 tokenType,\r\n        uint256 _index\r\n    ) external view returns (uint256) {\r\n        return GameDataLib.typedTokenByIndex(data, tokenType, _index);\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the total number of claimed flowers\r\n     *\r\n     * @return uint160\r\n     */\r\n    function totalFlowers() external view returns (uint160) {\r\n        return GameDataLib.totalFlowers(data);\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the address of the N-th flower\r\n     *\r\n     * @return address\r\n     */\r\n    function getFlowerByIndex(uint160 index) external view returns (address) {\r\n        return GameDataLib.getFlowerByIndex(data, index);\r\n    }\r\n\r\n\r\n    /** Admin setup methods */\r\n\r\n    /*\r\n    * Methods intended for initial contract setup, to be called at deployment.\r\n    * Call renounceOwnership() to make the contract have no owner after setup is complete.\r\n    */\r\n\r\n    /**\r\n     * @dev Registers a new flower URI with the corresponding weight\r\n     *\r\n     * @param weight uint16 Relative weight for the occurrence of this URI\r\n     * @param uri string\r\n     */\r\n    function addFlowerURI(uint16 weight, string uri) external onlyOwner {\r\n        GameDataLib.addFlowerURI(data, weight, uri);\r\n    }\r\n\r\n    /**\r\n     * @dev Registers the flower URI for address 0\r\n     *\r\n     * @param uri string\r\n     */\r\n    function setWhiteFlowerURI(string uri) external onlyOwner {\r\n        GameDataLib.setWhiteFlowerURI(data, uri);\r\n    }\r\n\r\n    /**\r\n     * @dev Registers a new butterfly URI with the corresponding weight\r\n     *\r\n     * @param weight uint16 Relative weight for the occurrence of this URI\r\n     * @param liveUri string\r\n     * @param deadUri string\r\n     * @param heartUri string\r\n     */\r\n    function addButterflyURI(uint16 weight, string liveUri, string deadUri, string heartUri) external onlyOwner {\r\n        GameDataLib.addButterflyURI(data, weight, liveUri, deadUri, heartUri);\r\n    }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"_interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"_name\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"name\":\"_operator\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"weight\",\"type\":\"uint16\"},{\"name\":\"uri\",\"type\":\"string\"}],\"name\":\"addFlowerURI\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"flowerAddress\",\"type\":\"address\"}],\"name\":\"getFlowerInfo\",\"outputs\":[{\"name\":\"isClaimed\",\"type\":\"bool\"},{\"name\":\"gene\",\"type\":\"uint64\"},{\"name\":\"gardenTimezone\",\"type\":\"uint64\"},{\"name\":\"createdTimestamp\",\"type\":\"uint64\"},{\"name\":\"flowerIndex\",\"type\":\"uint160\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"uri\",\"type\":\"string\"}],\"name\":\"setWhiteFlowerURI\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"accountZeroURI\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"heartId\",\"type\":\"uint256\"},{\"name\":\"index\",\"type\":\"uint160\"}],\"name\":\"getHeartOwnerByIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"tokenOfOwnerByIndex\",\"outputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"accountAddress\",\"type\":\"address\"}],\"name\":\"accountURI\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"index\",\"type\":\"uint160\"}],\"name\":\"getFlowerByIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenType\",\"type\":\"uint8\"},{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"typedTokenOfOwnerByIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenType\",\"type\":\"uint8\"},{\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"typedTokenByIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"isApprovedOrOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"exists\",\"outputs\":[{\"name\":\"_exists\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"tokenByIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenType\",\"type\":\"uint8\"},{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"typedBalanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"butterflyId\",\"type\":\"uint256\"}],\"name\":\"getButterflyInfo\",\"outputs\":[{\"name\":\"gene\",\"type\":\"uint64\"},{\"name\":\"createdTimestamp\",\"type\":\"uint64\"},{\"name\":\"lastTimestamp\",\"type\":\"uint64\"},{\"name\":\"numOwners\",\"type\":\"uint160\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"_balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenType\",\"type\":\"uint8\"}],\"name\":\"typedTotalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"_symbol\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"gardenTimezone\",\"type\":\"uint64\"}],\"name\":\"claim\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"heartId\",\"type\":\"uint256\"}],\"name\":\"getHeartInfo\",\"outputs\":[{\"name\":\"butterflyId\",\"type\":\"uint256\"},{\"name\":\"gene\",\"type\":\"uint64\"},{\"name\":\"snapshotTimestamp\",\"type\":\"uint64\"},{\"name\":\"numOwners\",\"type\":\"uint160\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"weight\",\"type\":\"uint16\"},{\"name\":\"liveUri\",\"type\":\"string\"},{\"name\":\"deadUri\",\"type\":\"string\"},{\"name\":\"heartUri\",\"type\":\"string\"}],\"name\":\"addButterflyURI\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalFlowers\",\"outputs\":[{\"name\":\"\",\"type\":\"uint160\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"gene\",\"type\":\"uint64\"},{\"name\":\"isAlive\",\"type\":\"bool\"}],\"name\":\"getButterflyURIFromGene\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"butterflyId\",\"type\":\"uint256\"},{\"name\":\"index\",\"type\":\"uint160\"}],\"name\":\"getButterflyOwnerByIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"butterflyId\",\"type\":\"uint256\"},{\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"canReceiveButterfly\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_approved\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_operator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"}]","ContractName":"Main","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"10000","ConstructorArguments":"","Library":"ERC721Manager:E5891F3d883Edf4D4e162315D2A6BdeAb15Cd1b5;GameDataLib:AcBa4C0Faf23BE5dfCA6251b1a4a3b88D482FdB8","SwarmSource":"bzzr://28b6dce9486c6f5466c1a701cfbd8972ba07cef56f558567266ffac68018cc32"}]}