{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.24;\r\npragma experimental \"v0.5.0\";\r\n/******************************************************************************\\\r\n* Author: Nick Mudge, nick@mokens.io\r\n* Mokens\r\n* Copyright (c) 2019\r\n*\r\n* Minting functions and mint price functions.\r\n/******************************************************************************/\r\n\r\n///////////////////////////////////////////////////////////////////////////////////\r\n//Storage contracts\r\n////////////\r\n//Some delegate contracts are listed with storage contracts they inherit.\r\n///////////////////////////////////////////////////////////////////////////////////\r\n\r\n///////////////////////////////////////////////////////////////////////////////////\r\n//Mokens\r\n///////////////////////////////////////////////////////////////////////////////////\r\ncontract Storage0 {\r\n    // funcId => delegate contract\r\n    mapping(bytes4 => address) internal delegates;\r\n}\r\n///////////////////////////////////////////////////////////////////////////////////\r\n//MokenUpdates\r\n//MokenOwner\r\n//QueryMokenDelegates\r\n///////////////////////////////////////////////////////////////////////////////////\r\ncontract Storage1 is Storage0 {\r\n    address internal contractOwner;\r\n    bytes[] internal funcSignatures;\r\n    // signature => index+1\r\n    mapping(bytes => uint256) internal funcSignatureToIndex;\r\n}\r\n///////////////////////////////////////////////////////////////////////////////////\r\n//MokensSupportsInterfaces\r\n///////////////////////////////////////////////////////////////////////////////////\r\ncontract Storage2 is Storage1 {\r\n    mapping(bytes4 => bool) internal supportedInterfaces;\r\n}\r\n///////////////////////////////////////////////////////////////////////////////////\r\n//MokenRootOwnerOf\r\n//MokenERC721Metadata\r\n///////////////////////////////////////////////////////////////////////////////////\r\ncontract Storage3 is Storage2 {\r\n    struct Moken {\r\n        string name;\r\n        uint256 data;\r\n        uint256 parentTokenId;\r\n    }\r\n    //tokenId => moken\r\n    mapping(uint256 => Moken) internal mokens;\r\n    uint256 internal mokensLength;\r\n    // child address => child tokenId => tokenId+1\r\n    mapping(address => mapping(uint256 => uint256)) internal childTokenOwner;\r\n}\r\n///////////////////////////////////////////////////////////////////////////////////\r\n//MokenERC721Enumerable\r\n//MokenLinkHash\r\n///////////////////////////////////////////////////////////////////////////////////\r\ncontract Storage4 is Storage3 {\r\n    // root token owner address => (tokenId => approved address)\r\n    mapping(address => mapping(uint256 => address)) internal rootOwnerAndTokenIdToApprovedAddress;\r\n    // token owner => (operator address => bool)\r\n    mapping(address => mapping(address => bool)) internal tokenOwnerToOperators;\r\n    // Mapping from owner to list of owned token IDs\r\n    mapping(address => uint32[]) internal ownedTokens;\r\n}\r\n///////////////////////////////////////////////////////////////////////////////////\r\n//MokenERC998ERC721TopDown\r\n//MokenERC998ERC721TopDownBatch\r\n//MokenERC721\r\n//MokenERC721Batch\r\n///////////////////////////////////////////////////////////////////////////////////\r\ncontract Storage5 is Storage4 {\r\n    // tokenId => (child address => array of child tokens)\r\n    mapping(uint256 => mapping(address => uint256[])) internal childTokens;\r\n    // tokenId => (child address => (child token => child index)\r\n    mapping(uint256 => mapping(address => mapping(uint256 => uint256))) internal childTokenIndex;\r\n    // tokenId => (child address => contract index)\r\n    mapping(uint256 => mapping(address => uint256)) internal childContractIndex;\r\n    // tokenId => child contract\r\n    mapping(uint256 => address[]) internal childContracts;\r\n}\r\n///////////////////////////////////////////////////////////////////////////////////\r\n//MokenERC998ERC20TopDown\r\n//MokenStateChange\r\n///////////////////////////////////////////////////////////////////////////////////\r\ncontract Storage6 is Storage5 {\r\n    // tokenId => token contract\r\n    mapping(uint256 => address[]) internal erc20Contracts;\r\n    // tokenId => (token contract => token contract index)\r\n    mapping(uint256 => mapping(address => uint256)) erc20ContractIndex;\r\n    // tokenId => (token contract => balance)\r\n    mapping(uint256 => mapping(address => uint256)) internal erc20Balances;\r\n}\r\n///////////////////////////////////////////////////////////////////////////////////\r\n//MokenERC998ERC721BottomUp\r\n//MokenERC998ERC721BottomUpBatch\r\n///////////////////////////////////////////////////////////////////////////////////\r\ncontract Storage7 is Storage6 {\r\n    // parent address => (parent tokenId => array of child tokenIds)\r\n    mapping(address => mapping(uint256 => uint32[])) internal parentToChildTokenIds;\r\n    // tokenId => position in childTokens array\r\n    mapping(uint256 => uint256) internal tokenIdToChildTokenIdsIndex;\r\n}\r\n///////////////////////////////////////////////////////////////////////////////////\r\n//MokenMinting\r\n//MokenMintContractManagement\r\n//MokenEras\r\n//QueryMokenData\r\n///////////////////////////////////////////////////////////////////////////////////\r\ncontract Storage8 is Storage7 {\r\n    // index => era\r\n    mapping(uint256 => bytes32) internal eras;\r\n    uint256 internal eraLength;\r\n    // era => index+1\r\n    mapping(bytes32 => uint256) internal eraIndex;\r\n    uint256 internal mintPriceOffset; // = 0 szabo;\r\n    uint256 internal mintStepPrice; // = 500 szabo;\r\n    uint256 internal mintPriceBuffer; // = 5000 szabo;\r\n    address[] internal mintContracts;\r\n    mapping(address => uint256) internal mintContractIndex;\r\n    //moken name => tokenId+1\r\n    mapping(string => uint256) internal tokenByName_;\r\n}\r\n\r\ncontract MokenMintingFixedPrice is Storage8 {\r\n\r\n    uint256 constant MAX_MOKENS = 4294967296;\r\n    uint256 constant MAX_OWNER_MOKENS = 65536;\r\n    uint256 constant MOKEN_LINK_HASH_MASK = 0xffffffffffffffff000000000000000000000000000000000000000000000000;\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\r\n\r\n    event Mint(\r\n        address indexed mintContract,\r\n        address indexed owner,\r\n        bytes32 indexed era,\r\n        string mokenName,\r\n        bytes32 data,\r\n        uint256 tokenId,\r\n        bytes32 currencyName,\r\n        uint256 price\r\n    );\r\n\r\n    event MintPriceChange(\r\n        uint256 mintPrice\r\n    );\r\n\r\n    event MintPriceConfigurationChange(\r\n        uint256 mintPrice,\r\n        uint256 mintStepPrice,\r\n        uint256 mintPriceOffset,\r\n        uint256 mintPriceBuffer\r\n    );\r\n\r\n    event NewEra(\r\n        uint256 index,\r\n        bytes32 name,\r\n        uint256 startTokenId\r\n    );\r\n\r\n    function setMintPrice(uint256 _mintPrice) external returns (uint256 mintPrice) {\r\n        require(msg.sender == contractOwner, \"Must own Mokens contract.\");\r\n        mintPriceBuffer = _mintPrice;\r\n        mintStepPrice = 0;\r\n        mintPriceOffset = 0;\r\n        emit MintPriceConfigurationChange(_mintPrice, 0, 0, 0);\r\n        emit MintPriceChange(_mintPrice);\r\n        return _mintPrice;\r\n    }\r\n\r\n    function startNextEra_(bytes32 _eraName) internal returns (uint256 index, uint256 startTokenId) {\r\n        require(_eraName != 0, \"eraName is empty string.\");\r\n        require(eraIndex[_eraName] == 0, \"Era name already exists.\");\r\n        startTokenId = mokensLength;\r\n        index = eraLength++;\r\n        eras[index] = _eraName;\r\n        eraIndex[_eraName] = index + 1;\r\n        emit NewEra(index, _eraName, startTokenId);\r\n        return (index, startTokenId);\r\n    }\r\n\r\n    // It is predicted that often a new era comes with a mint price change\r\n    function startNextEra(bytes32 _eraName, uint256 _mintPrice) external\r\n    returns (uint256 index, uint256 startTokenId, uint256 mintPrice) {\r\n        require(msg.sender == contractOwner, \"Must own Mokens contract.\");\r\n        mintPriceBuffer = _mintPrice;\r\n        mintStepPrice = 0;\r\n        mintPriceOffset = 0;\r\n        emit MintPriceConfigurationChange(_mintPrice, 0, 0, 0);\r\n        emit MintPriceChange(_mintPrice);\r\n        (index, startTokenId) = startNextEra_(_eraName);\r\n        return (index, startTokenId, _mintPrice);\r\n    }\r\n\r\n    function mintData() external view returns (uint256 mokensLength_, uint256 mintStepPrice_, uint256 mintPriceOffset_) {\r\n        return (mokensLength, 0, 0);\r\n    }\r\n\r\n    function mintPrice() external view returns (uint256) {\r\n        return mintPriceBuffer;\r\n    }\r\n\r\n    function mint(address _tokenOwner, string _mokenName, bytes32 _linkHash) external payable returns (uint256 tokenId) {\r\n\r\n        require(_tokenOwner != address(0), \"Owner cannot be the 0 address.\");\r\n\r\n        tokenId = mokensLength++;\r\n        // prevents 32 bit overflow\r\n        require(tokenId < MAX_MOKENS, \"Only 4,294,967,296 mokens can be created.\");\r\n\r\n        //Was enough ether passed in?\r\n        uint256 currentMintPrice = mintPriceBuffer;\r\n        uint256 ownedTokensIndex = ownedTokens[_tokenOwner].length;\r\n        require(msg.value >= currentMintPrice, \"Paid ether is lower than mint price.\");\r\n\r\n\r\n        string memory lowerMokenName = validateAndLower(_mokenName);\r\n        require(tokenByName_[lowerMokenName] == 0, \"Moken name already exists.\");\r\n\r\n        uint256 eraIndex_ = eraLength - 1;\r\n\r\n        // prevents 16 bit overflow\r\n        require(ownedTokensIndex < MAX_OWNER_MOKENS, \"An single owner address cannot possess more than 65,536 mokens.\");\r\n\r\n        // adding the current era index, ownedTokenIndex and owner address to data\r\n        // this saves gas for each mint.\r\n        uint256 data = uint256(_linkHash) & MOKEN_LINK_HASH_MASK | eraIndex_ << 176 | ownedTokensIndex << 160 | uint160(_tokenOwner);\r\n\r\n        // create moken\r\n        mokens[tokenId].name = _mokenName;\r\n        mokens[tokenId].data = data;\r\n        tokenByName_[lowerMokenName] = tokenId + 1;\r\n\r\n        //add moken to the specific owner\r\n        ownedTokens[_tokenOwner].push(uint32(tokenId));\r\n\r\n        //emit events\r\n        emit Transfer(address(0), _tokenOwner, tokenId);\r\n        emit Mint(this, _tokenOwner, eras[eraIndex_], _mokenName, bytes32(data), tokenId, \"Ether\", currentMintPrice);\r\n\r\n        //send minter the change if any\r\n        if (msg.value > currentMintPrice) {\r\n            msg.sender.transfer(msg.value - currentMintPrice);\r\n        }\r\n\r\n        return tokenId;\r\n    }\r\n\r\n\r\n    function validateAndLower(string _s) internal pure returns (string mokenName) {\r\n        assembly {\r\n        // get length of _s\r\n            let len := mload(_s)\r\n        // get position of _s\r\n            let p := add(_s, 0x20)\r\n        // _s cannot be 0 characters\r\n            if eq(len, 0) {\r\n                revert(0, 0)\r\n            }\r\n        // _s cannot be more than 100 characters\r\n            if gt(len, 100) {\r\n                revert(0, 0)\r\n            }\r\n        // get first character\r\n            let b := byte(0, mload(add(_s, 0x20)))\r\n        // first character cannot be whitespace/unprintable\r\n            if lt(b, 0x21) {\r\n                revert(0, 0)\r\n            }\r\n        // get last character\r\n            b := byte(0, mload(add(p, sub(len, 1))))\r\n        // last character cannot be whitespace/unprintable\r\n            if lt(b, 0x21) {\r\n                revert(0, 0)\r\n            }\r\n        // loop through _s and lowercase uppercase characters\r\n            for {let end := add(p, len)}\r\n            lt(p, end)\r\n            {p := add(p, 1)}\r\n            {\r\n                b := byte(0, mload(p))\r\n                if lt(b, 0x5b) {\r\n                    if gt(b, 0x40) {\r\n                        mstore8(p, add(b, 32))\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return _s;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"mintData\",\"outputs\":[{\"name\":\"mokensLength_\",\"type\":\"uint256\"},{\"name\":\"mintStepPrice_\",\"type\":\"uint256\"},{\"name\":\"mintPriceOffset_\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"mintPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_eraName\",\"type\":\"bytes32\"},{\"name\":\"_mintPrice\",\"type\":\"uint256\"}],\"name\":\"startNextEra\",\"outputs\":[{\"name\":\"index\",\"type\":\"uint256\"},{\"name\":\"startTokenId\",\"type\":\"uint256\"},{\"name\":\"mintPrice\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenOwner\",\"type\":\"address\"},{\"name\":\"_mokenName\",\"type\":\"string\"},{\"name\":\"_linkHash\",\"type\":\"bytes32\"}],\"name\":\"mint\",\"outputs\":[{\"name\":\"tokenId\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_mintPrice\",\"type\":\"uint256\"}],\"name\":\"setMintPrice\",\"outputs\":[{\"name\":\"mintPrice\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"mintContract\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"era\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"mokenName\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"currencyName\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"Mint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"mintPrice\",\"type\":\"uint256\"}],\"name\":\"MintPriceChange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"mintPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"mintStepPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"mintPriceOffset\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"mintPriceBuffer\",\"type\":\"uint256\"}],\"name\":\"MintPriceConfigurationChange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"index\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"name\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"startTokenId\",\"type\":\"uint256\"}],\"name\":\"NewEra\",\"type\":\"event\"}]","ContractName":"MokenMintingFixedPrice","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"999","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://c6fc4c98ee727ed3e326e33e05c9663d3a2b1d4a5e5e78deaaaee8ae0413d95c"}]}