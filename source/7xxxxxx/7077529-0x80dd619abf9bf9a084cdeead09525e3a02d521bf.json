{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.25;\r\ncontract SignatureContract {\r\n\r\n    address private owner;\r\n\taddress public signer;\r\n\tmapping(bytes32 => bool) public isSignedMerkleRoot;\r\n\r\n\tevent SignerSet(address indexed newSigner);\r\n\tevent Signed(bytes32 indexed hash);\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyByOwner {\r\n        require(msg.sender == owner, \"Only owner can call this function!\");\r\n        _;\r\n    }\r\n    \r\n    modifier onlyBySigner {\r\n        require(msg.sender == signer, \"Only the current signer can call this function!\");\r\n        _;\r\n    }\r\n\r\n    function setSigner(address aSigner) external onlyByOwner {\r\n        require(aSigner != signer, \"This address is already set as the current signer!\");\r\n        signer = aSigner;\r\n        emit SignerSet(aSigner);\r\n    }\r\n\r\n    function disable() external onlyByOwner {\r\n       delete signer;\r\n       delete owner;\r\n    }\r\n\r\n    /*\r\n    *  Adds a SHA2-256 hash to the persisted map. This hash is supposed to be the root of the Merkle Tree of documents being signed.\r\n    *  Under the conventions of this contract, atleast one leaf of the Merkle Tree must be the SHA2-256 hash of this smart contract address. This allows proving non-membership by reproducing all the Merkle Trees.\r\n    */\r\n    function sign(bytes32 hash) external onlyBySigner {\r\n\t\trequire(!isSignedMerkleRoot[hash], \"This SHA2-256 hash is already signed!\");\r\n\t\tisSignedMerkleRoot[hash] = true;\r\n\t\temit Signed(hash);\r\n    }\r\n    \r\n    /*\r\n    *  Checks a given document hash for being a leaf of a signed Merkle Tree.\r\n    *  For the check to be performed the corresponding Merkle Proof is required along with an index encoding the position of siblings at each level (left or right).\r\n    */\r\n    function verifyDocument(bytes32 docHash, bytes merkleProof, uint16 index) external view returns (bool) {\r\n        require(merkleProof.length >= 32, \"The Merkle Proof given is too short! It must be atleast 32 bytes in size.\");\r\n        require(merkleProof.length <= 512, \"The Merkle Proof given is too long! It can be upto only 512 bytes as the Merkle Tree is allowed a maximum depth of 16 under conventions of this contract.\");\r\n        require(merkleProof.length%32 == 0, \"The Merkle Proof given is not a multiple of 32 bytes! It must be a sequence of 32-byte SHA2-256 hashes each representing the sibling at every non-root level starting from leaf level in the Merkle Tree.\");\r\n        \r\n        bytes32 root = docHash;\r\n        bytes32 sibling;\r\n        bytes memory proof = merkleProof;\r\n        \r\n        // This loop runs a maximum of 16 times with i = 32, 64, 96, ... proof.length. As i is uint16, no integer overflow possible.\r\n        // An upper limit of 16 iterations ensures that the function's gas requirements are within reasonable limits.\r\n        for(uint16 i=32; i<=proof.length; i+=32) {\r\n            assembly {\r\n                sibling := mload(add(proof, i))     // reading 32 bytes\r\n            }\r\n            \r\n            // Now we have to find out if this sibling is on the right or on the left?\r\n            // This information is encoded in the i/32th bit from the right of the 16 bit integer index.\r\n            // To find this but we create a 16-bit mask with i/32th position as the only non-zero bit: uint16(1)<<(i/32-1)\r\n            // For example: for i=32, mask=0x0000000000000001.\r\n            // Note that since (i/32-1) is in the range 0-15, the left shift operation should be safe to use.\r\n            if(index & (uint16(1)<<(i/32-1)) == 0) {\r\n                root = sha256(abi.encodePacked(root, sibling));\r\n            } else {\r\n                root = sha256(abi.encodePacked(sibling, root));\r\n            }\r\n        }\r\n        \r\n        return isSignedMerkleRoot[root];\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"isSignedMerkleRoot\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"signer\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"disable\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"aSigner\",\"type\":\"address\"}],\"name\":\"setSigner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"hash\",\"type\":\"bytes32\"}],\"name\":\"sign\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"docHash\",\"type\":\"bytes32\"},{\"name\":\"merkleProof\",\"type\":\"bytes\"},{\"name\":\"index\",\"type\":\"uint16\"}],\"name\":\"verifyDocument\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"newSigner\",\"type\":\"address\"}],\"name\":\"SignerSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"hash\",\"type\":\"bytes32\"}],\"name\":\"Signed\",\"type\":\"event\"}]","ContractName":"SignatureContract","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://018596cb739580f921e5b2e906d705413c911032e5eba4bdd7a2652c6c3a5532"}]}