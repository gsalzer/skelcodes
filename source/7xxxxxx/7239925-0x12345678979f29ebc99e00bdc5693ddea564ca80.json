{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.3;\r\n\r\n// counter.market smart contracts:\r\n//  1) Proxy - delegatecalls into current exchange code, maintains storage of exchange state\r\n//  2) Registry - stores information on the latest exchange contract version and user approvals\r\n//  3) Treasury (this one) - takes custody of funds, moves them between token accounts, authorizing exchange code via Registry\r\n\r\n// Counter contracts are deployed at predefined addresses which can be hardcoded.\r\ncontract FixedAddress {\r\n    address constant ProxyAddress = 0x1234567896326230a28ee368825D11fE6571Be4a;\r\n    address constant TreasuryAddress = 0x12345678979f29eBc99E00bdc5693ddEa564cA80;\r\n    address constant RegistryAddress = 0x12345678982cB986Dd291B50239295E3Cb10Cdf6;\r\n\r\n    function getRegistry() internal pure returns (RegistryInterface) {\r\n        return RegistryInterface(RegistryAddress);\r\n    }\r\n}\r\n\r\n// External contracts access Registry via one of these methods\r\ninterface RegistryInterface {\r\n    function getOwner() external view returns (address);\r\n    function getExchangeContract() external view returns (address);\r\n    function contractApproved(address traderAddr) external view returns (bool);\r\n    function contractApprovedBoth(address traderAddr1, address traderAddr2) external view returns (bool);\r\n    function acceptNextExchangeContract() external;\r\n}\r\n\r\n// Access modifiers on restricted Treasury methods\r\ncontract AccessModifiers is FixedAddress {\r\n\r\n    // Only the owner of the Registry contract may invoke this method.\r\n    modifier onlyRegistryOwner() {\r\n        require (msg.sender == getRegistry().getOwner(), \"onlyRegistryOwner() method called by non-owner.\");\r\n        _;\r\n    }\r\n\r\n    // Method should be called by the current exchange (by delegatecall from Proxy), and trader should have approved\r\n    // the latest Exchange code.\r\n    modifier onlyApprovedExchange(address trader) {\r\n        require (msg.sender == ProxyAddress, \"onlyApprovedExchange() called not by exchange proxy.\");\r\n        require (getRegistry().contractApproved(trader), \"onlyApprovedExchange() requires approval of the latest contract code by trader.\");\r\n        _;\r\n    }\r\n\r\n    // The same as above, but checks approvals of two traders simultaneously.\r\n    modifier onlyApprovedExchangeBoth(address trader1, address trader2) {\r\n        require (msg.sender == ProxyAddress, \"onlyApprovedExchange() called not by exchange proxy.\");\r\n        require (getRegistry().contractApprovedBoth(trader1, trader2), \"onlyApprovedExchangeBoth() requires approval of the latest contract code by both traders.\");\r\n        _;\r\n    }\r\n\r\n}\r\n\r\n// External contracts access Treasury via one of these methods\r\ninterface TreasuryInterface {\r\n    function withdrawEther(address traderAddr, address payable withdrawalAddr, uint amount) external;\r\n    function withdrawERC20Token(uint16 tokenCode, address traderAddr, address withdrawalAddr, uint amount) external;\r\n    function transferTokens(uint16 tokenCode, address fromAddr, address toAddr, uint amount) external;\r\n    function transferTokensTwice(uint16 tokenCode, address fromAddr, address toAddr1, uint amount1, address toAddr2, uint amount2) external;\r\n    function exchangeTokens(uint16 tokenCode1, uint16 tokenCode2, address addr1, address addr2, address addrFee, uint amount1, uint fee1, uint amount2, uint fee2) external;\r\n}\r\n\r\n// Treasury responsibilities:\r\n//  - storing the mapping of token codes to token contract addresses\r\n//  - processing deposits to/withdrawals from/transfers between token accounts within itself\r\n//  - processing emergency releases\r\n\r\n// Treasury is required because Counter is not a wallet-to-wallet exchange, and requires deposits and\r\n// withdrawals in order to be able to trade. Having full control over settlement order enables Counter\r\n// to be responsive on its UI by settling trades and withdrawals in background. The former\r\n// operations are authorized by ECDSA signatures collected from users and effected on-chain by the\r\n// Counter arbiter services.\r\n\r\n// Because user signatures are effected on the contract via an intermediary (the Counter arbiter),\r\n// there is inherent trust issue where a trader may assume that the Counter may refuse to apply some\r\n// operations on-chain (especially withdrawals), or may simply experience prolonged downtime. Hence\r\n// the need for the emergency release (ER) feature, which is an ability to withdraw funds from Counter\r\n// directly. It works as follows:\r\n//  1) any trader may initiate a cooldown of two days for all token accounts of the same address\r\n//  2) this cooldown is reset by invoking withdrawal or exchange on this address - these are the\r\n//     operations which require explicit consent in the form of digital signature and thus mean\r\n//     that a) exchange is operational b) the user trusts it\r\n//  3) in case the cooldown have not been reset by any means within two day period, the user may withdraw\r\n//     the entirety of their funds from Treasury.\r\n//\r\n// A note should be made regarding 2) - Counter does _not_ have an ability to reset the ER cooldown\r\n// arbitrarily long, as trade signatures contain an explicit expiration date, and withdrawals have a\r\n// nonce which makes them eligible to be applied once.\r\n\r\ncontract Treasury is AccessModifiers, TreasuryInterface {\r\n    // *** Constants.\r\n\r\n    uint constant EMERGENCY_RELEASE_CHALLENGE_PERIOD = 2 days;\r\n\r\n    // *** Variables.\r\n\r\n    // Treasury can be \"paused\" by the registry owner to effectively freeze fund movement\r\n    // (sans emergency releases).\r\n    bool active = false;\r\n\r\n    // Mapping from token codes (uint16) into corresponding ERC-20 contract addresses.\r\n    // Each token code can only be assigned once for security reasons. Token code 0 is\r\n    // always Ether.\r\n    mapping (uint16 => address) public tokenContracts;\r\n\r\n    // Balance of a specific token account, in lowest denomination (wei for Ether).\r\n    // uint176 key is composite of u16 token code (bits 160..175) and address (bits 0..159).\r\n    mapping (uint176 => uint) public tokenAmounts;\r\n\r\n    // *** Events\r\n\r\n    event SetActive(bool active);\r\n    event ChangeTokenInfo(uint16 tokenCode, address tokenContract);\r\n    event StartEmergencyRelease(address account);\r\n    event Deposit(uint16 tokenCode, address account, uint amount);\r\n    event Withdrawal(uint16 tokenCode, address traderAddr, address withdrawalAddr, uint amount);\r\n    event EmergencyRelease(uint16 tokenCode, address account, uint amount);\r\n\r\n    // Emergency release status for an address (_not_ for the token account):\r\n    //     == 0 - escape release challenge inactive\r\n    //     != 0 - timestamp after which ER can be executed\r\n    mapping (address => uint) public emergencyReleaseSince;\r\n\r\n    // *** Constructor\r\n\r\n    constructor () public {\r\n    }\r\n\r\n    // *** Modifiers\r\n\r\n    modifier onlyActive() {\r\n        require (active, \"Inactive treasury only allows withdrawals.\");\r\n        _;\r\n    }\r\n\r\n    modifier emergencyReleasePossible(address trader) {\r\n        uint deadline = emergencyReleaseSince[trader];\r\n        require (deadline > 0 && block.timestamp > deadline, \"Challenge should be active and deadline expired.\");\r\n        _;\r\n    }\r\n\r\n    // *** Admin methods (mostly self-explanatory)\r\n\r\n    function setActive(bool _active) external onlyRegistryOwner() {\r\n        active = _active;\r\n\r\n        emit SetActive(active);\r\n    }\r\n\r\n    function changeTokenInfo(uint16 tokenCode, address tokenContract) external onlyRegistryOwner() {\r\n        require (tokenCode != 0,\r\n                 \"Token code of zero is reserved for Ether.\");\r\n\r\n        require (tokenContracts[tokenCode] == address(0),\r\n                 \"Token contract address can be assigned only once.\");\r\n\r\n        tokenContracts[tokenCode] = tokenContract;\r\n\r\n        emit ChangeTokenInfo(tokenCode, tokenContract);\r\n    }\r\n\r\n    // *** Emergency release initiation and reset\r\n\r\n    // This method is invoked by the user to start the ER cooldown\r\n    function startEmergencyRelease() external {\r\n        emergencyReleaseSince[msg.sender] = block.timestamp + EMERGENCY_RELEASE_CHALLENGE_PERIOD;\r\n\r\n        emit StartEmergencyRelease(msg.sender);\r\n    }\r\n\r\n    // This private method resets the UR cooldown for when executing successful trades/withdrawals\r\n    function resetEmergencyRelease(address traderAddr) private {\r\n        if (emergencyReleaseSince[traderAddr] != 0) {\r\n            emergencyReleaseSince[traderAddr] = 0;\r\n        }\r\n    }\r\n\r\n    // *** Fund movement methods\r\n\r\n    // * Deposits (initiated by and paid for by the trader)\r\n\r\n    function depositEther(address account) external payable {\r\n        emit Deposit(0, account, msg.value);\r\n\r\n        addBalance(0, account, msg.value);\r\n    }\r\n\r\n    function depositERC20Token(uint176 tokenAccount, uint amount) external {\r\n        uint16 tokenCode = uint16(tokenAccount >> 160);\r\n        address tokenContract = tokenContracts[tokenCode];\r\n\r\n        require (tokenContract != address(0), \"Registered token contract.\");\r\n\r\n        // Need a preliminary .approve() call\r\n        require (safeTransferFrom(tokenContract, msg.sender, address(this), amount),\r\n                 \"Could not transfer ERC-20 tokens using transferFrom.\");\r\n\r\n        address account = address(tokenAccount);\r\n        emit Deposit(tokenCode, account, amount);\r\n\r\n        addBalance(tokenCode, account, amount);\r\n    }\r\n\r\n    // * Emergency release (initiated by and paid for by the trader)\r\n\r\n    function emergencyReleaseEther() external emergencyReleasePossible(msg.sender) {\r\n        uint amount = deductFullBalance(0, msg.sender);\r\n\r\n        emit EmergencyRelease(0, msg.sender, amount);\r\n\r\n        msg.sender.transfer(amount);\r\n    }\r\n\r\n    function emergencyReleaseERC20Token(uint16 tokenCode) external emergencyReleasePossible(msg.sender) {\r\n        uint amount = deductFullBalance(tokenCode, msg.sender);\r\n\r\n        emit EmergencyRelease(tokenCode, msg.sender, amount);\r\n\r\n        address tokenContract = tokenContracts[tokenCode];\r\n        require (tokenContract != address(0), \"Registered token contract.\");\r\n\r\n        require (safeTransfer(tokenContract, msg.sender, amount),\r\n                 \"Could not transfer ERC-20 tokens using transfer.\");\r\n    }\r\n\r\n    // * Regular withdrawal (authorized by the trader, initiated and paid for by Counter)\r\n    //   Requires trader approval of exchange contract.\r\n    //   Resets ER.\r\n\r\n    function withdrawEther(address traderAddr, address payable withdrawalAddr, uint amount) external\r\n        onlyActive()\r\n        onlyApprovedExchange(traderAddr) {\r\n\r\n        deductBalance(0, traderAddr, amount);\r\n        resetEmergencyRelease(traderAddr);\r\n\r\n        emit Withdrawal(0, traderAddr, withdrawalAddr, amount);\r\n\r\n        withdrawalAddr.transfer(amount);\r\n    }\r\n\r\n    function withdrawERC20Token(uint16 tokenCode, address traderAddr, address withdrawalAddr, uint amount) external\r\n        onlyActive()\r\n        onlyApprovedExchange(traderAddr) {\r\n\r\n        deductBalance(tokenCode, traderAddr, amount);\r\n        resetEmergencyRelease(traderAddr);\r\n\r\n        address tokenContract = tokenContracts[tokenCode];\r\n        require (tokenContract != address(0), \"Registered token contract.\");\r\n\r\n        require (safeTransfer(tokenContract, withdrawalAddr, amount),\r\n                 \"Could not transfer ERC-20 tokens using transfer.\");\r\n\r\n        emit Withdrawal(tokenCode, traderAddr, withdrawalAddr, amount);\r\n    }\r\n\r\n    // * Funds transfer between token accounts within Treasury\r\n    //   Initiated and paid for by Counter as part of trade or withdrawal fee collection.\r\n    //   Requires trader approval of exchange contract.\r\n    //   There are three specializations to save gas on inter-contract method calls.\r\n    //   Resets ER.\r\n\r\n    // Case 1 - transfer tokens from one account to another\r\n    // Example usecase: withdrawal fee collection\r\n    function transferTokens(uint16 tokenCode, address fromAddr, address toAddr, uint amount) external\r\n        onlyActive() onlyApprovedExchange(fromAddr) {\r\n\r\n        resetEmergencyRelease(fromAddr);\r\n\r\n        deductBalance(tokenCode, fromAddr, amount);\r\n        addBalance(tokenCode, toAddr, amount);\r\n    }\r\n\r\n    // Case 2 - transfer tokens from one account to two accounts, splitting arbitrarily.\r\n    function transferTokensTwice(uint16 tokenCode, address fromAddr, address toAddr1, uint amount1, address toAddr2, uint amount2) external\r\n        onlyActive() onlyApprovedExchange(fromAddr) {\r\n\r\n        resetEmergencyRelease(fromAddr);\r\n\r\n        deductBalance(tokenCode, fromAddr, amount1 + amount2);\r\n\r\n        addBalance(tokenCode, toAddr1, amount1);\r\n        addBalance(tokenCode, toAddr2, amount2);\r\n    }\r\n\r\n    // Case 3 - transfer tokens of one type from A to B, tokens of another type from B to A,\r\n    //          and deduct a fee from both transfers to a third account C.\r\n    // Example usecase: any trade on Counter\r\n    function exchangeTokens(\r\n        uint16 tokenCode1, uint16 tokenCode2,\r\n        address addr1, address addr2, address addrFee,\r\n        uint amount1, uint fee1,\r\n        uint amount2, uint fee2) external onlyActive() onlyApprovedExchangeBoth(addr1, addr2) {\r\n\r\n        resetEmergencyRelease(addr1);\r\n        resetEmergencyRelease(addr2);\r\n\r\n        deductBalance(tokenCode1, addr1, amount1 + fee1);\r\n        deductBalance(tokenCode2, addr2, amount2 + fee2);\r\n\r\n        addBalance(tokenCode1, addr2, amount1);\r\n        addBalance(tokenCode2, addr1, amount2);\r\n        addBalance(tokenCode1, addrFee, fee1);\r\n        addBalance(tokenCode2, addrFee, fee2);\r\n    }\r\n\r\n    // * Token account balance management routines.\r\n    //   Construct uint176 ids, check for over- and underflows.\r\n\r\n    function deductBalance(uint tokenCode, address addr, uint amount) private {\r\n        uint176 tokenAccount = uint176(tokenCode) << 160 | uint176(addr);\r\n        uint before = tokenAmounts[tokenAccount];\r\n        require (before >= amount, \"Enough funds.\");\r\n        tokenAmounts[tokenAccount] = before - amount;\r\n    }\r\n\r\n    function deductFullBalance(uint tokenCode, address addr) private returns (uint amount) {\r\n        uint176 tokenAccount = uint176(tokenCode) << 160 | uint176(addr);\r\n        amount = tokenAmounts[tokenAccount];\r\n        tokenAmounts[tokenAccount] = 0;\r\n    }\r\n\r\n    function addBalance(uint tokenCode, address addr, uint amount) private {\r\n        uint176 tokenAccount = uint176(tokenCode) << 160 | uint176(addr);\r\n        uint before = tokenAmounts[tokenAccount];\r\n        require (before + amount >= before, \"No overflow.\");\r\n        tokenAmounts[tokenAccount] = before + amount;\r\n    }\r\n\r\n    // * Safe ERC-20 transfer() and transferFrom() invocations\r\n    //   Work correctly with those tokens that do not return (bool success) and thus are not\r\n    //   strictly speaking ERC-20 compatible, but unfortunately are quite widespread.\r\n\r\n    function safeTransfer(address tokenContract, address to, uint value) internal returns (bool success)\r\n    {\r\n        // bytes4(keccak256(\"transfer(address,uint256)\")) = 0xa9059cbb\r\n        (bool call_success, bytes memory return_data) = tokenContract.call(abi.encodeWithSelector(0xa9059cbb, to, value));\r\n\r\n        success = false;\r\n\r\n        if (call_success) {\r\n            if (return_data.length == 0) {\r\n                // transfer() doesn't have a return value\r\n                success = true;\r\n\r\n            } else if (return_data.length == 32) {\r\n                // check returned bool\r\n                assembly { success := mload(add(return_data, 0x20)) }\r\n            }\r\n\r\n        }\r\n    }\r\n\r\n    function safeTransferFrom(address tokenContract, address from, address to, uint value) internal returns (bool success)\r\n    {\r\n        // bytes4(keccak256(\"transferFrom(address,address,uint256)\")) = 0x23b872dd\r\n        (bool call_success, bytes memory return_data) = tokenContract.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\r\n\r\n        success = false;\r\n\r\n        if (call_success) {\r\n            if (return_data.length == 0) {\r\n                success = true;\r\n\r\n            } else if (return_data.length == 32) {\r\n                assembly { success := mload(add(return_data, 0x20)) }\r\n            }\r\n\r\n        }\r\n    }\r\n\r\n}","ABI":"[{\"constant\":false,\"inputs\":[],\"name\":\"startEmergencyRelease\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint176\"}],\"name\":\"tokenAmounts\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenCode1\",\"type\":\"uint16\"},{\"name\":\"tokenCode2\",\"type\":\"uint16\"},{\"name\":\"addr1\",\"type\":\"address\"},{\"name\":\"addr2\",\"type\":\"address\"},{\"name\":\"addrFee\",\"type\":\"address\"},{\"name\":\"amount1\",\"type\":\"uint256\"},{\"name\":\"fee1\",\"type\":\"uint256\"},{\"name\":\"amount2\",\"type\":\"uint256\"},{\"name\":\"fee2\",\"type\":\"uint256\"}],\"name\":\"exchangeTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"depositEther\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenCode\",\"type\":\"uint16\"},{\"name\":\"fromAddr\",\"type\":\"address\"},{\"name\":\"toAddr\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_active\",\"type\":\"bool\"}],\"name\":\"setActive\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenCode\",\"type\":\"uint16\"},{\"name\":\"fromAddr\",\"type\":\"address\"},{\"name\":\"toAddr1\",\"type\":\"address\"},{\"name\":\"amount1\",\"type\":\"uint256\"},{\"name\":\"toAddr2\",\"type\":\"address\"},{\"name\":\"amount2\",\"type\":\"uint256\"}],\"name\":\"transferTokensTwice\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"emergencyReleaseEther\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenCode\",\"type\":\"uint16\"},{\"name\":\"traderAddr\",\"type\":\"address\"},{\"name\":\"withdrawalAddr\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawERC20Token\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenCode\",\"type\":\"uint16\"}],\"name\":\"emergencyReleaseERC20Token\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"traderAddr\",\"type\":\"address\"},{\"name\":\"withdrawalAddr\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawEther\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenAccount\",\"type\":\"uint176\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"depositERC20Token\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"emergencyReleaseSince\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint16\"}],\"name\":\"tokenContracts\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenCode\",\"type\":\"uint16\"},{\"name\":\"tokenContract\",\"type\":\"address\"}],\"name\":\"changeTokenInfo\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"active\",\"type\":\"bool\"}],\"name\":\"SetActive\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"tokenCode\",\"type\":\"uint16\"},{\"indexed\":false,\"name\":\"tokenContract\",\"type\":\"address\"}],\"name\":\"ChangeTokenInfo\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"StartEmergencyRelease\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"tokenCode\",\"type\":\"uint16\"},{\"indexed\":false,\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"tokenCode\",\"type\":\"uint16\"},{\"indexed\":false,\"name\":\"traderAddr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"withdrawalAddr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Withdrawal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"tokenCode\",\"type\":\"uint16\"},{\"indexed\":false,\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"EmergencyRelease\",\"type\":\"event\"}]","ContractName":"Treasury","CompilerVersion":"v0.5.3+commit.10d17f24","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://d17ac025c6b45371405ee3a1435c60b190cd48c898a0224870ad0958c79e5ec4"}]}