{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.5.9; // optimization enabled, runs: 10000, evm: constantinople\r\n\r\n\r\n/**\r\n * @title HomeWork Interface (version 1) - EIP165 ID 0xe5399799\r\n * @author 0age\r\n * @notice Homework is a utility to find, share, and reuse \"home\" addresses for\r\n * contracts. Anyone can work to find a new home address by searching for keys,\r\n * a 32-byte value with the first 20 bytes equal to the finder's calling address\r\n * (or derived by hashing an arbitrary 32-byte salt and the caller's address),\r\n * and can then deploy any contract they like (even one with a constructor) to\r\n * the address, or mint an ERC721 token that the owner can redeem that will then\r\n * allow them to do the same. Also, if the contract is `SELFDESTRUCT`ed, a new\r\n * contract can be redeployed by the current controller to the same address!\r\n * @dev This contract allows contract addresses to be located ahead of time, and\r\n * for arbitrary bytecode to be deployed (and redeployed if so desired, i.e.\r\n * metamorphic contracts) to the located address by a designated controller. To\r\n * enable this, the contract first deploys an \"initialization-code-in-runtime\"\r\n * contract, with the creation code of the contract you want to deploy stored in\r\n * RUNTIME code. Then, to deploy the actual contract, it retrieves the address\r\n * of the storage contract and `DELEGATECALL`s into it to execute the init code\r\n * and, if successful, retrieves and returns the contract runtime code. Rather\r\n * than using a located address directly, you can also lock it in the contract\r\n * and mint and ERC721 token for it, which can then be redeemed in order to gain\r\n * control over deployment to the address (note that tokens may not be minted if\r\n * the contract they control currently has a deployed contract at that address).\r\n * Once a contract undergoes metamorphosis, all existing storage will be deleted\r\n * and any existing contract code will be replaced with the deployed contract\r\n * code of the new implementation contract. The mechanisms behind this contract \r\n * are highly experimental - proceed with caution and please share any exploits\r\n * or optimizations you discover.\r\n */\r\ninterface IHomeWork {\r\n  // Fires when a contract is deployed or redeployed to a given home address.\r\n  event NewResident(\r\n    address indexed homeAddress,\r\n    bytes32 key,\r\n    bytes32 runtimeCodeHash\r\n  );\r\n\r\n  // Fires when a new runtime storage contract is deployed.\r\n  event NewRuntimeStorageContract(\r\n    address runtimeStorageContract,\r\n    bytes32 runtimeCodeHash\r\n  );\r\n\r\n  // Fires when a controller is changed from the default controller.\r\n  event NewController(bytes32 indexed key, address newController);\r\n\r\n  // Fires when a new high score is submitted.\r\n  event NewHighScore(bytes32 key, address submitter, uint256 score);\r\n\r\n  // Track total contract deploys and current controller for each home address.\r\n  struct HomeAddress {\r\n    bool exists;\r\n    address controller;\r\n    uint88 deploys;\r\n  }\r\n\r\n  // Track derivation of key for a given home address based on salt & submitter.\r\n  struct KeyInformation {\r\n    bytes32 key;\r\n    bytes32 salt;\r\n    address submitter;\r\n  }\r\n\r\n  /**\r\n   * @notice Deploy a new contract with the desired initialization code to the\r\n   * home address corresponding to a given key. Two conditions must be met: the\r\n   * submitter must be designated as the controller of the home address (with\r\n   * the initial controller set to the address corresponding to the first twenty\r\n   * bytes of the key), and there must not be a contract currently deployed at\r\n   * the home address. These conditions can be checked by calling\r\n   * `getHomeAddressInformation` and `isDeployable` with the same key.\r\n   * @param key bytes32 The unique value used to derive the home address.\r\n   * @param initializationCode bytes The contract creation code that will be\r\n   * used to deploy the contract to the home address.\r\n   * @return The home address of the deployed contract.\r\n   * @dev In order to deploy the contract to the home address, a new contract\r\n   * will be deployed with runtime code set to the initialization code of the\r\n   * contract that will be deployed to the home address. Then, metamorphic\r\n   * initialization code will retrieve that initialization code and use it to\r\n   * set up and deploy the desired contract to the home address. Bear in mind\r\n   * that the deployed contract will interpret msg.sender as the address of THIS\r\n   * contract, and not the address of the submitter - if the constructor of the\r\n   * deployed contract uses msg.sender to set up ownership or other variables,\r\n   * you must modify it to accept a constructor argument with the appropriate\r\n   * address, or alternately to hard-code the intended address. Also, if your\r\n   * contract DOES have constructor arguments, remember to include them as\r\n   * ABI-encoded arguments at the end of the initialization code, just as you\r\n   * would when performing a standard deploy. You may also want to provide the\r\n   * key to `setReverseLookup` in order to find it again using only the home\r\n   * address to prevent accidentally losing the key.\r\n   */\r\n  function deploy(bytes32 key, bytes calldata initializationCode)\r\n    external\r\n    payable\r\n    returns (address homeAddress, bytes32 runtimeCodeHash);\r\n\r\n  /**\r\n   * @notice Mint an ERC721 token to the supplied owner that can be redeemed in\r\n   * order to gain control of a home address corresponding to a given key. Two\r\n   * conditions must be met: the submitter must be designated as the controller\r\n   * of the home address (with the initial controller set to the address\r\n   * corresponding to the first 20 bytes of the key), and there must not be a\r\n   * contract currently deployed at the home address. These conditions can be\r\n   * checked by calling `getHomeAddressInformation` and `isDeployable` with the\r\n   * same key.\r\n   * @param key bytes32 The unique value used to derive the home address.\r\n   * @param owner address The account that will be granted ownership of the\r\n   * ERC721 token.\r\n   * @dev In order to mint an ERC721 token, the assocated home address cannot be\r\n   * in use, or else the token will not be able to deploy to the home address.\r\n   * The controller is set to this contract until the token is redeemed, at\r\n   * which point the redeemer designates a new controller for the home address.\r\n   * The key of the home address and the tokenID of the ERC721 token are the\r\n   * same value, but different types (bytes32 vs. uint256).\r\n   */\r\n  function lock(bytes32 key, address owner) external;\r\n\r\n  /**\r\n   * @notice Burn an ERC721 token to allow the supplied controller to gain the\r\n   * ability to deploy to the home address corresponding to the key matching the\r\n   * burned token. The submitter must be designated as either the owner of the\r\n   * token or as an approved spender.\r\n   * @param tokenId uint256 The ID of the ERC721 token to redeem.\r\n   * @param controller address The account that will be granted control of the\r\n   * home address corresponding to the given token.\r\n   * @dev The controller cannot be designated as the address of this contract,\r\n   * the null address, or the home address (the restriction on setting the home\r\n   * address as the controller is due to the fact that the home address will not\r\n   * be able to deploy to itself, as it needs to be empty before a contract can\r\n   * be deployed to it).\r\n   */\r\n  function redeem(uint256 tokenId, address controller) external;\r\n\r\n  /**\r\n   * @notice Transfer control over deployment to the home address corresponding\r\n   * to a given key. The caller must be designated as the current controller of\r\n   * the home address (with the initial controller set to the address\r\n   * corresponding to the first 20 bytes of the key) - This condition can be\r\n   * checked by calling `getHomeAddressInformation` with the same key.\r\n   * @param key bytes32 The unique value used to derive the home address.\r\n   * @param controller address The account that will be granted control of the\r\n   * home address corresponding to the given key.\r\n   * @dev The controller cannot be designated as the address of this contract,\r\n   * the null address, or the home address (the restriction on setting the home\r\n   * address as the controller is due to the fact that the home address will not\r\n   * be able to deploy to itself, as it needs to be empty before a contract can\r\n   * be deployed to it).\r\n   */\r\n  function assignController(bytes32 key, address controller) external;\r\n\r\n  /**\r\n   * @notice Transfer control over deployment to the home address corresponding\r\n   * to a given key to the null address, which will prevent it from being\r\n   * deployed to again in the future. The caller must be designated as the\r\n   * current controller of the corresponding home address (with the initial\r\n   * controller set to the address corresponding to the first 20 bytes of the\r\n   * key) - This condition can be checked by calling `getHomeAddressInformation`\r\n   * with the same key.\r\n   * @param key bytes32 The unique value used to derive the home address.\r\n   */\r\n  function relinquishControl(bytes32 key) external;\r\n\r\n  /**\r\n   * @notice Burn an ERC721 token, set a supplied controller, and deploy a new\r\n   * contract with the supplied initialization code to the corresponding home\r\n   * address for the given token. The submitter must be designated as either the\r\n   * owner of the token or as an approved spender.\r\n   * @param tokenId uint256 The ID of the ERC721 token to redeem.\r\n   * @param controller address The account that will be granted control of the\r\n   * home address corresponding to the given token.\r\n   * @param initializationCode bytes The contract creation code that will be\r\n   * used to deploy the contract to the home address.\r\n   * @return The home address and runtime code hash of the deployed contract.\r\n   * @dev In order to deploy the contract to the home address, a new contract\r\n   * will be deployed with runtime code set to the initialization code of the\r\n   * contract that will be deployed to the home address. Then, metamorphic\r\n   * initialization code will retrieve that initialization code and use it to\r\n   * set up and deploy the desired contract to the home address. Bear in mind\r\n   * that the deployed contract will interpret msg.sender as the address of THIS\r\n   * contract, and not the address of the submitter - if the constructor of the\r\n   * deployed contract uses msg.sender to set up ownership or other variables,\r\n   * you must modify it to accept a constructor argument with the appropriate\r\n   * address, or alternately to hard-code the intended address. Also, if your\r\n   * contract DOES have constructor arguments, remember to include them as\r\n   * ABI-encoded arguments at the end of the initialization code, just as you\r\n   * would when performing a standard deploy. You may also want to provide the\r\n   * key to `setReverseLookup` in order to find it again using only the home\r\n   * address to prevent accidentally losing the key. The controller cannot be\r\n   * designated as the address of this contract, the null address, or the home\r\n   * address (the restriction on setting the home address as the controller is\r\n   * due to the fact that the home address will not be able to deploy to itself,\r\n   * as it needs to be empty before a contract can be deployed to it). Also,\r\n   * checks on the contract at the home address being empty or not having the\r\n   * correct controller are unnecessary, as they are performed when minting the\r\n   * token and cannot be altered until the token is redeemed.\r\n   */\r\n  function redeemAndDeploy(\r\n    uint256 tokenId,\r\n    address controller,\r\n    bytes calldata initializationCode\r\n  )\r\n    external\r\n    payable\r\n    returns (address homeAddress, bytes32 runtimeCodeHash);\r\n\r\n  /**\r\n   * @notice Derive a new key by concatenating an arbitrary 32-byte salt value\r\n   * and the address of the caller and performing a keccak256 hash. This allows\r\n   * for the creation of keys with additional entropy where desired while also\r\n   * preventing collisions with standard keys. The caller will be set as the\r\n   * controller of the derived key.\r\n   * @param salt bytes32 The desired salt value to use (along with the address\r\n   * of the caller) when deriving the resultant key and corresponding home\r\n   * address.\r\n   * @return The derived key.\r\n   * @dev Home addresses from derived keys will take longer to \"mine\" or locate,\r\n   * as an additional hash must be performed when computing the corresponding\r\n   * home address for each given salt input. Each caller will derive a different\r\n   * key even if they are supplying the same salt value.\r\n   */\r\n  function deriveKey(bytes32 salt) external returns (bytes32 key);\r\n\r\n  /**\r\n   * @notice Mint an ERC721 token to the supplied owner that can be redeemed in\r\n   * order to gain control of a home address corresponding to a given derived\r\n   * key. Two conditions must be met: the submitter must be designated as the\r\n   * current controller of the home address, and there must not be a contract\r\n   * currently deployed at the home address. These conditions can be checked by\r\n   * calling `getHomeAddressInformation` and `isDeployable` with the key\r\n   * determined by calling `getDerivedKey`.\r\n   * @param salt bytes32 The salt value that is used to derive the key.\r\n   * @param owner address The account that will be granted ownership of the\r\n   * ERC721 token.\r\n   * @return The derived key.\r\n   * @dev In order to mint an ERC721 token, the assocated home address cannot be\r\n   * in use, or else the token will not be able to deploy to the home address.\r\n   * The controller is set to this contract until the token is redeemed, at\r\n   * which point the redeemer designates a new controller for the home address.\r\n   * The key of the home address and the tokenID of the ERC721 token are the\r\n   * same value, but different types (bytes32 vs. uint256).\r\n   */\r\n  function deriveKeyAndLock(bytes32 salt, address owner)\r\n    external\r\n    returns (bytes32 key);\r\n\r\n  /**\r\n   * @notice Transfer control over deployment to the home address corresponding\r\n   * to a given derived key. The caller must be designated as the current\r\n   * controller of the home address - This condition can be checked by calling\r\n   * `getHomeAddressInformation` with the key obtained via `getDerivedKey`.\r\n   * @param salt bytes32 The salt value that is used to derive the key.\r\n   * @param controller address The account that will be granted control of the\r\n   * home address corresponding to the given derived key.\r\n   * @return The derived key.\r\n   * @dev The controller cannot be designated as the address of this contract,\r\n   * the null address, or the home address (the restriction on setting the home\r\n   * address as the controller is due to the fact that the home address will not\r\n   * be able to deploy to itself, as it needs to be empty before a contract can\r\n   * be deployed to it).\r\n   */\r\n  function deriveKeyAndAssignController(bytes32 salt, address controller)\r\n    external\r\n    returns (bytes32 key);\r\n\r\n  /**\r\n   * @notice Transfer control over deployment to the home address corresponding\r\n   * to a given derived key to the null address, which will prevent it from\r\n   * being deployed to again in the future. The caller must be designated as the\r\n   * current controller of the home address - This condition can be checked by\r\n   * calling `getHomeAddressInformation` with the key determined by calling\r\n   * `getDerivedKey`.\r\n   * @param salt bytes32 The salt value that is used to derive the key.\r\n   * @return The derived key.\r\n   */\r\n  function deriveKeyAndRelinquishControl(bytes32 salt)\r\n    external\r\n    returns (bytes32 key);\r\n\r\n  /**\r\n   * @notice Record a key that corresponds to a given home address by supplying\r\n   * said key and using it to derive the address. This enables reverse lookup\r\n   * of a key using only the home address in question. This method may be called\r\n   * by anyone - control of the key is not required.\r\n   * @param key bytes32 The unique value used to derive the home address.\r\n   * @dev This does not set the salt or submitter fields, as those apply only to\r\n   * derived keys (although a derived key may also be set with this method, just\r\n   * without the derived fields).\r\n   */\r\n  function setReverseLookup(bytes32 key) external;\r\n\r\n  /**\r\n   * @notice Record the derived key that corresponds to a given home address by\r\n   * supplying the salt and submitter that were used to derive the key. This\r\n   * facititates reverse lookup of the derivation method of a key using only the\r\n   * home address in question. This method may be called by anyone - control of\r\n   * the derived key is not required.\r\n   * @param salt bytes32 The salt value that is used to derive the key.\r\n   * @param submitter address The account that submits the salt that is used to\r\n   * derive the key.\r\n   */\r\n  function setDerivedReverseLookup(bytes32 salt, address submitter) external;\r\n\r\n  /**\r\n   * @notice Deploy a new storage contract with the supplied code as runtime\r\n   * code without deploying a contract to a home address. This can be used to\r\n   * store the contract creation code for use in future deployments of contracts\r\n   * to home addresses.\r\n   * @param codePayload bytes The code to set as the runtime code of the\r\n   * deployed contract.\r\n   * @return The address of the deployed storage contract.\r\n   * @dev Consider placing adequate protections on the storage contract to\r\n   * prevent unwanted callers from modifying or destroying it. Also, if you are\r\n   * placing contract contract creation code into the runtime storage contract,\r\n   * remember to include any constructor parameters as ABI-encoded arguments at\r\n   * the end of the contract creation code, similar to how you would perform a\r\n   * standard deployment.\r\n   */\r\n  function deployRuntimeStorageContract(bytes calldata codePayload)\r\n    external\r\n    returns (address runtimeStorageContract);\r\n\r\n  /**\r\n   * @notice Deploy a new contract with the initialization code stored in the\r\n   * runtime code at the specified initialization runtime storage contract to\r\n   * the home address corresponding to a given key. Two conditions must be met:\r\n   * the submitter must be designated as the controller of the home address\r\n   * (with the initial controller set to the address corresponding to the first\r\n   * 20 bytes of the key), and there must not be a contract currently deployed\r\n   * at the home address. These conditions can be checked by calling\r\n   * `getHomeAddressInformation` and `isDeployable` with the same key.\r\n   * @param key bytes32 The unique value used to derive the home address.\r\n   * @param initializationRuntimeStorageContract address The storage contract\r\n   * with runtime code equal to the contract creation code that will be used to\r\n   * deploy the contract to the home address.\r\n   * @return The home address and runtime code hash of the deployed contract.\r\n   * @dev When deploying a contract to a home address via this method, the\r\n   * metamorphic initialization code will retrieve whatever initialization code\r\n   * currently resides at the specified address and use it to set up and deploy\r\n   * the desired contract to the home address. Bear in mind that the deployed\r\n   * contract will interpret msg.sender as the address of THIS contract, and not\r\n   * the address of the submitter - if the constructor of the deployed contract\r\n   * uses msg.sender to set up ownership or other variables, you must modify it\r\n   * to accept a constructor argument with the appropriate address, or\r\n   * alternately to hard-code the intended address. Also, if your contract DOES\r\n   * have constructor arguments, remember to include them as ABI-encoded\r\n   * arguments at the end of the initialization code, just as you would when\r\n   * performing a standard deploy. You may also want to provide the key to\r\n   * `setReverseLookup` in order to find it again using only the home address to\r\n   * prevent accidentally losing the key.\r\n   */\r\n  function deployViaExistingRuntimeStorageContract(\r\n    bytes32 key,\r\n    address initializationRuntimeStorageContract\r\n  )\r\n    external\r\n    payable\r\n    returns (address homeAddress, bytes32 runtimeCodeHash);\r\n\r\n  /**\r\n   * @notice Burn an ERC721 token, set a supplied controller, and deploy a new\r\n   * contract with the initialization code stored in the runtime code at the\r\n   * specified initialization runtime storage contract to the home address\r\n   * corresponding to a given key. The submitter must be designated as either\r\n   * the owner of the token or as an approved spender.\r\n   * @param tokenId uint256 The ID of the ERC721 token to redeem.\r\n   * @param controller address The account that will be granted control of the\r\n   * home address corresponding to the given token.\r\n   * @param initializationRuntimeStorageContract address The storage contract\r\n   * with runtime code equal to the contract creation code that will be used to\r\n   * deploy the contract to the home address.\r\n   * @return The home address and runtime code hash of the deployed contract.\r\n   * @dev When deploying a contract to a home address via this method, the\r\n   * metamorphic initialization code will retrieve whatever initialization code\r\n   * currently resides at the specified address and use it to set up and deploy\r\n   * the desired contract to the home address. Bear in mind that the deployed\r\n   * contract will interpret msg.sender as the address of THIS contract, and not\r\n   * the address of the submitter - if the constructor of the deployed contract\r\n   * uses msg.sender to set up ownership or other variables, you must modify it\r\n   * to accept a constructor argument with the appropriate address, or\r\n   * alternately to hard-code the intended address. Also, if your contract DOES\r\n   * have constructor arguments, remember to include them as ABI-encoded\r\n   * arguments at the end of the initialization code, just as you would when\r\n   * performing a standard deploy. You may also want to provide the key to\r\n   * `setReverseLookup` in order to find it again using only the home address to\r\n   * prevent accidentally losing the key. The controller cannot be designated as\r\n   * the address of this contract, the null address, or the home address (the\r\n   * restriction on setting the home address as the controller is due to the\r\n   * fact that the home address will not be able to deploy to itself, as it\r\n   * needs to be empty before a contract can be deployed to it). Also, checks on\r\n   * the contract at the home address being empty or not having the correct\r\n   * controller are unnecessary, as they are performed when minting the token\r\n   * and cannot be altered until the token is redeemed.\r\n   */\r\n  function redeemAndDeployViaExistingRuntimeStorageContract(\r\n    uint256 tokenId,\r\n    address controller,\r\n    address initializationRuntimeStorageContract\r\n  )\r\n    external\r\n    payable\r\n    returns (address homeAddress, bytes32 runtimeCodeHash);\r\n\r\n  /**\r\n   * @notice Deploy a new contract with the desired initialization code to the\r\n   * home address corresponding to a given derived key. Two conditions must be\r\n   * met: the submitter must be designated as the controller of the home\r\n   * address, and there must not be a contract currently deployed at the home\r\n   * address. These conditions can be checked by calling\r\n   * `getHomeAddressInformation` and `isDeployable` with the key obtained by\r\n   * calling `getDerivedKey`.\r\n   * @param salt bytes32 The salt value that is used to derive the key.\r\n   * @param initializationCode bytes The contract creation code that will be\r\n   * used to deploy the contract to the home address.\r\n   * @return The home address, derived key, and runtime code hash of the\r\n   * deployed contract.\r\n   * @dev In order to deploy the contract to the home address, a new contract\r\n   * will be deployed with runtime code set to the initialization code of the\r\n   * contract that will be deployed to the home address. Then, metamorphic\r\n   * initialization code will retrieve that initialization code and use it to\r\n   * set up and deploy the desired contract to the home address. Bear in mind\r\n   * that the deployed contract will interpret msg.sender as the address of THIS\r\n   * contract, and not the address of the submitter - if the constructor of the\r\n   * deployed contract uses msg.sender to set up ownership or other variables,\r\n   * you must modify it to accept a constructor argument with the appropriate\r\n   * address, or alternately to hard-code the intended address. Also, if your\r\n   * contract DOES have constructor arguments, remember to include them as\r\n   * ABI-encoded arguments at the end of the initialization code, just as you\r\n   * would when performing a standard deploy. You may want to provide the salt\r\n   * and submitter to `setDerivedReverseLookup` in order to find the salt,\r\n   * submitter, and derived key using only the home address to prevent\r\n   * accidentally losing them.\r\n   */\r\n  function deriveKeyAndDeploy(bytes32 salt, bytes calldata initializationCode)\r\n    external\r\n    payable\r\n    returns (address homeAddress, bytes32 key, bytes32 runtimeCodeHash);\r\n\r\n  /**\r\n   * @notice Deploy a new contract with the initialization code stored in the\r\n   * runtime code at the specified initialization runtime storage contract to\r\n   * the home address corresponding to a given derived key. Two conditions must\r\n   * be met: the submitter must be designated as the controller of the home\r\n   * address, and there must not be a contract currently deployed at the home\r\n   * address. These conditions can be checked by calling\r\n   * `getHomeAddressInformation` and `isDeployable` with the key obtained by\r\n   * calling `getDerivedKey`.\r\n   * @param salt bytes32 The salt value that is used to derive the key.\r\n   * @param initializationRuntimeStorageContract address The storage contract\r\n   * with runtime code equal to the contract creation code that will be used to\r\n   * deploy the contract to the home address.\r\n   * @return The home address, derived key, and runtime code hash of the\r\n   * deployed contract.\r\n   * @dev When deploying a contract to a home address via this method, the\r\n   * metamorphic initialization code will retrieve whatever initialization code\r\n   * currently resides at the specified address and use it to set up and deploy\r\n   * the desired contract to the home address. Bear in mind that the deployed\r\n   * contract will interpret msg.sender as the address of THIS contract, and not\r\n   * the address of the submitter - if the constructor of the deployed contract\r\n   * uses msg.sender to set up ownership or other variables, you must modify it\r\n   * to accept a constructor argument with the appropriate address, or\r\n   * alternately to hard-code the intended address. Also, if your contract DOES\r\n   * have constructor arguments, remember to include them as ABI-encoded\r\n   * arguments at the end of the initialization code, just as you would when\r\n   * performing a standard deploy. You may want to provide the salt and\r\n   * submitter to `setDerivedReverseLookup` in order to find the salt,\r\n   * submitter, and derived key using only the home address to prevent\r\n   * accidentally losing them.\r\n   */\r\n  function deriveKeyAndDeployViaExistingRuntimeStorageContract(\r\n    bytes32 salt,\r\n    address initializationRuntimeStorageContract\r\n  )\r\n    external\r\n    payable\r\n    returns (address homeAddress, bytes32 key, bytes32 runtimeCodeHash);\r\n\r\n  /**\r\n   * @notice Mint multiple ERC721 tokens, designated by their keys, to the\r\n   * specified owner. Keys that aren't controlled, or that point to home\r\n   * addresses that are currently deployed, will be skipped.\r\n   * @param owner address The account that will be granted ownership of the\r\n   * ERC721 tokens.\r\n   * @param keys bytes32[] An array of values used to derive each home address.\r\n   * @dev If you plan to use this method regularly or want to keep gas costs to\r\n   * an absolute minimum, and are willing to go without standard ABI encoding,\r\n   * see `batchLock_63efZf` for a more efficient (and unforgiving)\r\n   * implementation. For batch token minting with *derived* keys, see\r\n   * `deriveKeysAndBatchLock`.\r\n   */\r\n  function batchLock(address owner, bytes32[] calldata keys) external;\r\n\r\n  /**\r\n   * @notice Mint multiple ERC721 tokens, designated by salts that are hashed\r\n   * with the caller's address to derive each key, to the specified owner.\r\n   * Derived keys that aren't controlled, or that point to home addresses that\r\n   * are currently deployed, will be skipped.\r\n   * @param owner address The account that will be granted ownership of the\r\n   * ERC721 tokens.\r\n   * @param salts bytes32[] An array of values used to derive each key and\r\n   * corresponding home address.\r\n   * @dev See `batchLock` for batch token minting with standard, non-derived\r\n   * keys.\r\n   */\r\n  function deriveKeysAndBatchLock(address owner, bytes32[] calldata salts)\r\n    external;\r\n\r\n  /**\r\n   * @notice Efficient version of `batchLock` that uses less gas. The first 20\r\n   * bytes of each key are automatically populated using msg.sender, and the\r\n   * remaining key segments are passed in as a packed byte array, using twelve\r\n   * bytes per segment, with a function selector of 0x00000000 followed by a\r\n   * twenty-byte segment for the desired owner of the minted ERC721 tokens. Note\r\n   * that an attempt to lock a key that is not controlled or with its contract\r\n   * already deployed will cause the entire batch to revert. Checks on whether\r\n   * the owner is a valid ERC721 receiver are also skipped, similar to using\r\n   * `transferFrom` instead of `safeTransferFrom`.\r\n   */\r\n  function batchLock_63efZf(/* packed owner and key segments */) external;\r\n\r\n  /**\r\n   * @notice Submit a key to claim the \"high score\" - the lower the uint160\r\n   * value of the key's home address, the higher the score. The high score\r\n   * holder has the exclusive right to recover lost ether and tokens on this\r\n   * contract.\r\n   * @param key bytes32 The unique value used to derive the home address that\r\n   * will determine the resultant score.\r\n   * @dev The high score must be claimed by a direct key (one that is submitted\r\n   * by setting the first 20 bytes of the key to the address of the submitter)\r\n   * and not by a derived key, and is non-transferrable. If you want to help\r\n   * people recover their lost tokens, you might consider deploying a contract\r\n   * to the high score address (probably a metamorphic one so that you can use\r\n   * the home address later) with your contact information.\r\n   */\r\n  function claimHighScore(bytes32 key) external;\r\n\r\n  /**\r\n   * @notice Transfer any ether or ERC20 tokens that have somehow ended up at\r\n   * this contract by specifying a token address (set to the null address for\r\n   * ether) as well as a recipient address. Only the high score holder can\r\n   * recover lost ether and tokens on this contract.\r\n   * @param token address The contract address of the ERC20 token to recover, or\r\n   * the null address for recovering Ether.\r\n   * @param recipient address payable The account where recovered funds should\r\n   * be transferred.\r\n   * @dev If you are trying to recover funds that were accidentally sent into\r\n   * this contract, see if you can contact the holder of the current high score,\r\n   * found by calling `getHighScore`. Better yet, try to find a new high score\r\n   * yourself!\r\n   */\r\n  function recover(IERC20 token, address payable recipient) external;\r\n\r\n  /**\r\n   * @notice \"View\" function to determine if a contract can currently be\r\n   * deployed to a home address given the corresponding key. A contract is only\r\n   * deployable if no account currently exists at the address - any existing\r\n   * contract must be destroyed via `SELFDESTRUCT` before a new contract can be\r\n   * deployed to a home address. This method does not modify state but is\r\n   * inaccessible via staticcall.\r\n   * @param key bytes32 The unique value used to derive the home address.\r\n   * @return A boolean signifying if a contract can be deployed to the home\r\n   * address that corresponds to the provided key.\r\n   * @dev This will not detect if a contract is not deployable due control\r\n   * having been relinquished on the key.\r\n   */\r\n  function isDeployable(bytes32 key)\r\n    external\r\n    /* view */\r\n    returns (bool deployable);\r\n\r\n  /**\r\n   * @notice View function to get the current \"high score\", or the lowest\r\n   * uint160 value of a home address of all keys submitted. The high score\r\n   * holder has the exclusive right to recover lost ether and tokens on this\r\n   * contract.\r\n   * @return The current high score holder, their score, and the submitted key.\r\n   */\r\n  function getHighScore()\r\n    external\r\n    view\r\n    returns (address holder, uint256 score, bytes32 key);\r\n\r\n  /**\r\n   * @notice View function to get information on a home address given the\r\n   * corresponding key.\r\n   * @param key bytes32 The unique value used to derive the home address.\r\n   * @return The home address, the current controller of the address, the number\r\n   * of times the home address has been deployed to, and the code hash of the\r\n   * runtime currently found at the home address, if any.\r\n   * @dev There is also an `isDeployable` method for determining if a contract\r\n   * can be deployed to the address, but in extreme cases it must actually\r\n   * perform a dry-run to determine if the contract is deployable, which means\r\n   * that it does not support staticcalls. There is also a convenience method,\r\n   * `hasNeverBeenDeployed`, but the information it conveys can be determined\r\n   * from this method alone as well.\r\n   */\r\n  function getHomeAddressInformation(bytes32 key)\r\n    external\r\n    view\r\n    returns (\r\n      address homeAddress,\r\n      address controller,\r\n      uint256 deploys,\r\n      bytes32 currentRuntimeCodeHash\r\n    );\r\n\r\n  /**\r\n   * @notice View function to determine if no contract has ever been deployed to\r\n   * a home address given the corresponding key. This can be used to ensure that\r\n   * a given key or corresponding token is \"new\" or not.\r\n   * @param key bytes32 The unique value used to derive the home address.\r\n   * @return A boolean signifying if a contract has never been deployed using\r\n   * the supplied key before.\r\n   */\r\n  function hasNeverBeenDeployed(bytes32 key)\r\n    external\r\n    view\r\n    returns (bool neverBeenDeployed);\r\n\r\n  /**\r\n   * @notice View function to search for a known key, salt, and/or submitter\r\n   * given a supplied home address. Keys can be controlled directly by an\r\n   * address that matches the first 20 bytes of the key, or they can be derived\r\n   * from a salt and a submitter - if the key is not a derived key, the salt and\r\n   * submitter fields will both have a value of zero.\r\n   * @param homeAddress address The home address to check for key information.\r\n   * @return The key, salt, and/or submitter used to deploy to the home address,\r\n   * assuming they have been submitted to the reverse lookup.\r\n   * @dev To populate these values, call `setReverseLookup` for cases where keys\r\n   * are used directly or are the only value known, or `setDerivedReverseLookup`\r\n   * for cases where keys are derived from a known salt and submitter.\r\n   */\r\n  function reverseLookup(address homeAddress)\r\n    external\r\n    view\r\n    returns (bytes32 key, bytes32 salt, address submitter);\r\n\r\n  /**\r\n   * @notice Pure function to determine the key that is derived from a given\r\n   * salt and submitting address.\r\n   * @param salt bytes32 The salt value that is used to derive the key.\r\n   * @param submitter address The submitter of the salt value used to derive the\r\n   * key.\r\n   * @return The derived key.\r\n   */\r\n  function getDerivedKey(bytes32 salt, address submitter)\r\n    external\r\n    pure\r\n    returns (bytes32 key);\r\n\r\n  /**\r\n   * @notice Pure function to determine the home address that corresponds to\r\n   * a given key.\r\n   * @param key bytes32 The unique value used to derive the home address.\r\n   * @return The home address.\r\n   */\r\n  function getHomeAddress(bytes32 key)\r\n    external\r\n    pure\r\n    returns (address homeAddress);\r\n\r\n  /**\r\n   * @notice Pure function for retrieving the metamorphic initialization code\r\n   * used to deploy arbitrary contracts to home addresses. Provided for easy\r\n   * verification and for use in other applications.\r\n   * @return The 32-byte metamorphic initialization code.\r\n   * @dev This metamorphic init code works via the \"metamorphic delegator\"\r\n   * mechanism, which is explained in greater detail at `_deployToHomeAddress`.\r\n   */\r\n  function getMetamorphicDelegatorInitializationCode()\r\n    external\r\n    pure\r\n    returns (bytes32 metamorphicDelegatorInitializationCode);\r\n\r\n  /**\r\n   * @notice Pure function for retrieving the keccak256 of the metamorphic\r\n   * initialization code used to deploy arbitrary contracts to home addresses.\r\n   * This is the value that you should use, along with this contract's address\r\n   * and a caller address that you control, to mine for an partucular type of\r\n   * home address (such as one at a compact or gas-efficient address).\r\n   * @return The keccak256 hash of the metamorphic initialization code.\r\n   */\r\n  function getMetamorphicDelegatorInitializationCodeHash()\r\n    external\r\n    pure\r\n    returns (bytes32 metamorphicDelegatorInitializationCodeHash);\r\n\r\n  /**\r\n   * @notice Pure function for retrieving the prelude that will be inserted\r\n   * ahead of the code payload in order to deploy a runtime storage contract.\r\n   * @return The 11-byte \"arbitrary runtime\" prelude.\r\n   */\r\n  function getArbitraryRuntimeCodePrelude()\r\n    external\r\n    pure\r\n    returns (bytes11 prelude);\r\n}\r\n\r\n\r\n/**\r\n * @title ERC721 Non-Fungible Token Standard basic interface\r\n * @dev see https://eips.ethereum.org/EIPS/eip-721\r\n */\r\ninterface IERC721 {\r\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\r\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\r\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n\r\n    function balanceOf(address owner) external view returns (uint256 balance);\r\n    function ownerOf(uint256 tokenId) external view returns (address owner);\r\n\r\n    function approve(address to, uint256 tokenId) external;\r\n    function getApproved(uint256 tokenId) external view returns (address operator);\r\n\r\n    function setApprovalForAll(address operator, bool _approved) external;\r\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\r\n\r\n    function transferFrom(address from, address to, uint256 tokenId) external;\r\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\r\n\r\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\r\n}\r\n\r\n\r\n/**\r\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\r\n * @dev See https://eips.ethereum.org/EIPS/eip-721\r\n */\r\ninterface IERC721Enumerable {\r\n    function totalSupply() external view returns (uint256);\r\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256 tokenId);\r\n    function tokenByIndex(uint256 index) external view returns (uint256);\r\n}\r\n\r\n\r\n/**\r\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\r\n * @dev See https://eips.ethereum.org/EIPS/eip-721\r\n */\r\ninterface IERC721Metadata {\r\n    function name() external pure returns (string memory);\r\n    function symbol() external pure returns (string memory);\r\n    function tokenURI(uint256 tokenId) external view returns (string memory);\r\n}\r\n\r\n\r\n/**\r\n * @title ERC721 token receiver interface\r\n * @dev Interface for any contract that wants to support safeTransfers\r\n * from ERC721 asset contracts.\r\n */\r\ninterface IERC721Receiver {\r\n    /**\r\n     * @notice Handle the receipt of an NFT\r\n     * @dev The ERC721 smart contract calls this function on the recipient\r\n     * after a `safeTransfer`. This function MUST return the function selector,\r\n     * otherwise the caller will revert the transaction. The selector to be\r\n     * returned can be obtained as `this.onERC721Received.selector`. This\r\n     * function MAY throw to revert and reject the transfer.\r\n     * Note: the ERC721 contract address is always the message sender.\r\n     * @param operator The address which called `safeTransferFrom` function\r\n     * @param from The address which previously owned the token\r\n     * @param tokenId The NFT identifier which is being transferred\r\n     * @param data Additional data with no specified format\r\n     * @return bytes4 `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\r\n     */\r\n    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data)\r\n      external\r\n      returns (bytes4);\r\n}\r\n\r\n\r\n/**\r\n * @title ERC1412 Batch Transfers For Non-Fungible Tokens\r\n * @dev the ERC-165 identifier for this interface is 0x2b89bcaa\r\n */\r\ninterface IERC1412 {\r\n  /// @notice Transfers the ownership of multiple NFTs from one address to another address\r\n  /// @param _from The current owner of the NFT\r\n  /// @param _to The new owner\r\n  /// @param _tokenIds The NFTs to transfer\r\n  /// @param _data Additional data with no specified format, sent in call to `_to`  \r\n  function safeBatchTransferFrom(address _from, address _to, uint256[] calldata _tokenIds, bytes calldata _data) external;\r\n  \r\n  /// @notice Transfers the ownership of multiple NFTs from one address to another address\r\n  /// @param _from The current owner of the NFT\r\n  /// @param _to The new owner\r\n  /// @param _tokenIds The NFTs to transfer  \r\n  function safeBatchTransferFrom(address _from, address _to, uint256[] calldata _tokenIds) external; \r\n}\r\n\r\n\r\n/**\r\n * @title IERC165\r\n * @dev https://eips.ethereum.org/EIPS/eip-165\r\n */\r\ninterface IERC165 {\r\n    /**\r\n     * @notice Query if a contract implements an interface\r\n     * @param interfaceId The interface identifier, as specified in ERC-165\r\n     * @dev Interface identification is specified in ERC-165. This function\r\n     * uses less than 30,000 gas.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://eips.ethereum.org/EIPS/eip-20\r\n */\r\ninterface IERC20 {\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n\r\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address who) external view returns (uint256);\r\n\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"SafeMath: subtraction overflow\");\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, \"SafeMath: division by zero\");\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0, \"SafeMath: modulo by zero\");\r\n        return a % b;\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * Utility library of inline functions on addresses\r\n */\r\nlibrary Address {\r\n    /**\r\n     * Returns whether the target address is a contract\r\n     * @dev This function will return false if invoked during the constructor of a contract,\r\n     * as the code is not actually created until after the constructor finishes.\r\n     * @param account address of the account to check\r\n     * @return whether the target address is a contract\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        uint256 size;\r\n        // XXX Currently there is no better way to check if there is a contract in an address\r\n        // than to check the size of the code at that address.\r\n        // See https://ethereum.stackexchange.com/a/14016/36603\r\n        // for more details about how this works.\r\n        // TODO Check this again before the Serenity release, because all addresses will be\r\n        // contracts then.\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { size := extcodesize(account) }\r\n        return size > 0;\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @title Counters\r\n * @author Matt Condon (@shrugs)\r\n * @dev Provides counters that can only be incremented or decremented by one. This can be used e.g. to track the number\r\n * of elements in a mapping, issuing ERC721 ids, or counting request ids\r\n *\r\n * Include with `using Counters for Counters.Counter;`\r\n * Since it is not possible to overflow a 256 bit integer with increments of one, `increment` can skip the SafeMath\r\n * overflow check, thereby saving gas. This does assume however correct usage, in that the underlying `_value` is never\r\n * directly accessed.\r\n */\r\nlibrary Counters {\r\n    using SafeMath for uint256;\r\n\r\n    struct Counter {\r\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\r\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\r\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\r\n        uint256 _value; // default: 0\r\n    }\r\n\r\n    function current(Counter storage counter) internal view returns (uint256) {\r\n        return counter._value;\r\n    }\r\n\r\n    function increment(Counter storage counter) internal {\r\n        counter._value += 1;\r\n    }\r\n\r\n    function decrement(Counter storage counter) internal {\r\n        counter._value = counter._value.sub(1);\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @dev Implementation of the `IERC165` interface.\r\n *\r\n * Contracts may inherit from this and call `_registerInterface` to declare\r\n * their support of an interface.\r\n */\r\ncontract ERC165 is IERC165 {\r\n    /*\r\n     * bytes4(keccak256('supportsInterface(bytes4)')) == 0x01ffc9a7\r\n     */\r\n    bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;\r\n\r\n    /**\r\n     * @dev Mapping of interface ids to whether or not it's supported.\r\n     */\r\n    mapping(bytes4 => bool) private _supportedInterfaces;\r\n\r\n    constructor () internal {\r\n        // Derived contracts need only register support for their own interfaces,\r\n        // we register support for ERC165 itself here\r\n        _registerInterface(_INTERFACE_ID_ERC165);\r\n    }\r\n\r\n    /**\r\n     * @dev See `IERC165.supportsInterface`.\r\n     *\r\n     * Time complexity O(1), guaranteed to always use less than 30 000 gas.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool) {\r\n        return _supportedInterfaces[interfaceId];\r\n    }\r\n\r\n    /**\r\n     * @dev Registers the contract as an implementer of the interface defined by\r\n     * `interfaceId`. Support of the actual ERC165 interface is automatic and\r\n     * registering its interface id is not required.\r\n     *\r\n     * See `IERC165.supportsInterface`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `interfaceId` cannot be the ERC165 invalid interface (`0xffffffff`).\r\n     */\r\n    function _registerInterface(bytes4 interfaceId) internal {\r\n        require(interfaceId != 0xffffffff, \"ERC165: invalid interface id\");\r\n        _supportedInterfaces[interfaceId] = true;\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @title ERC721 Non-Fungible Token Standard basic implementation\r\n * @dev see https://eips.ethereum.org/EIPS/eip-721\r\n */\r\ncontract ERC721 is ERC165, IERC721 {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n    using Counters for Counters.Counter;\r\n\r\n    // Equals to `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\r\n    // which can be also obtained as `IERC721Receiver(0).onERC721Received.selector`\r\n    bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;\r\n\r\n    // Mapping from token ID to owner\r\n    mapping (uint256 => address) private _tokenOwner;\r\n\r\n    // Mapping from token ID to approved address\r\n    mapping (uint256 => address) private _tokenApprovals;\r\n\r\n    // Mapping from owner to number of owned token\r\n    mapping (address => Counters.Counter) private _ownedTokensCount;\r\n\r\n    // Mapping from owner to operator approvals\r\n    mapping (address => mapping (address => bool)) private _operatorApprovals;\r\n\r\n    bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;\r\n    /*\r\n     * 0x80ac58cd ===\r\n     *     bytes4(keccak256('balanceOf(address)')) ^\r\n     *     bytes4(keccak256('ownerOf(uint256)')) ^\r\n     *     bytes4(keccak256('approve(address,uint256)')) ^\r\n     *     bytes4(keccak256('getApproved(uint256)')) ^\r\n     *     bytes4(keccak256('setApprovalForAll(address,bool)')) ^\r\n     *     bytes4(keccak256('isApprovedForAll(address,address)')) ^\r\n     *     bytes4(keccak256('transferFrom(address,address,uint256)')) ^\r\n     *     bytes4(keccak256('safeTransferFrom(address,address,uint256)')) ^\r\n     *     bytes4(keccak256('safeTransferFrom(address,address,uint256,bytes)'))\r\n     */\r\n\r\n    constructor () public {\r\n        // register the supported interfaces to conform to ERC721 via ERC165\r\n        _registerInterface(_INTERFACE_ID_ERC721);\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the balance of the specified address\r\n     * @param owner address to query the balance of\r\n     * @return uint256 representing the amount owned by the passed address\r\n     */\r\n    function balanceOf(address owner) public view returns (uint256) {\r\n        require(owner != address(0));\r\n        return _ownedTokensCount[owner].current();\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the owner of the specified token ID\r\n     * @param tokenId uint256 ID of the token to query the owner of\r\n     * @return address currently marked as the owner of the given token ID\r\n     */\r\n    function ownerOf(uint256 tokenId) public view returns (address) {\r\n        address owner = _tokenOwner[tokenId];\r\n        require(owner != address(0));\r\n        return owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Approves another address to transfer the given token ID\r\n     * The zero address indicates there is no approved address.\r\n     * There can only be one approved address per token at a given time.\r\n     * Can only be called by the token owner or an approved operator.\r\n     * @param to address to be approved for the given token ID\r\n     * @param tokenId uint256 ID of the token to be approved\r\n     */\r\n    function approve(address to, uint256 tokenId) public {\r\n        address owner = ownerOf(tokenId);\r\n        require(to != owner);\r\n        require(msg.sender == owner || isApprovedForAll(owner, msg.sender));\r\n\r\n        _tokenApprovals[tokenId] = to;\r\n        emit Approval(owner, to, tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the approved address for a token ID, or zero if no address set\r\n     * Reverts if the token ID does not exist.\r\n     * @param tokenId uint256 ID of the token to query the approval of\r\n     * @return address currently approved for the given token ID\r\n     */\r\n    function getApproved(uint256 tokenId) public view returns (address) {\r\n        require(_exists(tokenId));\r\n        return _tokenApprovals[tokenId];\r\n    }\r\n\r\n    /**\r\n     * @dev Sets or unsets the approval of a given operator\r\n     * An operator is allowed to transfer all tokens of the sender on their behalf\r\n     * @param to operator address to set the approval\r\n     * @param approved representing the status of the approval to be set\r\n     */\r\n    function setApprovalForAll(address to, bool approved) public {\r\n        require(to != msg.sender);\r\n        _operatorApprovals[msg.sender][to] = approved;\r\n        emit ApprovalForAll(msg.sender, to, approved);\r\n    }\r\n\r\n    /**\r\n     * @dev Tells whether an operator is approved by a given owner\r\n     * @param owner owner address which you want to query the approval of\r\n     * @param operator operator address which you want to query the approval of\r\n     * @return bool whether the given operator is approved by the given owner\r\n     */\r\n    function isApprovedForAll(address owner, address operator) public view returns (bool) {\r\n        return _operatorApprovals[owner][operator];\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers the ownership of a given token ID to another address\r\n     * Usage of this method is discouraged, use `safeTransferFrom` whenever possible\r\n     * Requires the msg.sender to be the owner, approved, or operator\r\n     * @param from current owner of the token\r\n     * @param to address to receive the ownership of the given token ID\r\n     * @param tokenId uint256 ID of the token to be transferred\r\n     */\r\n    function transferFrom(address from, address to, uint256 tokenId) public {\r\n        require(_isApprovedOrOwner(msg.sender, tokenId));\r\n\r\n        _transferFrom(from, to, tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Safely transfers the ownership of a given token ID to another address\r\n     * If the target address is a contract, it must implement `onERC721Received`,\r\n     * which is called upon a safe transfer, and return the magic value\r\n     * `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`; otherwise,\r\n     * the transfer is reverted.\r\n     * Requires the msg.sender to be the owner, approved, or operator\r\n     * @param from current owner of the token\r\n     * @param to address to receive the ownership of the given token ID\r\n     * @param tokenId uint256 ID of the token to be transferred\r\n     */\r\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\r\n        safeTransferFrom(from, to, tokenId, \"\");\r\n    }\r\n\r\n    /**\r\n     * @dev Safely transfers the ownership of a given token ID to another address\r\n     * If the target address is a contract, it must implement `onERC721Received`,\r\n     * which is called upon a safe transfer, and return the magic value\r\n     * `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`; otherwise,\r\n     * the transfer is reverted.\r\n     * Requires the msg.sender to be the owner, approved, or operator\r\n     * @param from current owner of the token\r\n     * @param to address to receive the ownership of the given token ID\r\n     * @param tokenId uint256 ID of the token to be transferred\r\n     * @param _data bytes data to send along with a safe transfer check\r\n     */\r\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) public {\r\n        transferFrom(from, to, tokenId);\r\n        require(_checkOnERC721Received(from, to, tokenId, _data));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns whether the specified token exists\r\n     * @param tokenId uint256 ID of the token to query the existence of\r\n     * @return bool whether the token exists\r\n     */\r\n    function _exists(uint256 tokenId) internal view returns (bool) {\r\n        address owner = _tokenOwner[tokenId];\r\n        return owner != address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns whether the given spender can transfer a given token ID\r\n     * @param spender address of the spender to query\r\n     * @param tokenId uint256 ID of the token to be transferred\r\n     * @return bool whether the msg.sender is approved for the given token ID,\r\n     * is an operator of the owner, or is the owner of the token\r\n     */\r\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view returns (bool) {\r\n        address owner = ownerOf(tokenId);\r\n        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to mint a new token\r\n     * Reverts if the given token ID already exists\r\n     * @param to The address that will own the minted token\r\n     * @param tokenId uint256 ID of the token to be minted\r\n     */\r\n    function _mint(address to, uint256 tokenId) internal {\r\n        require(to != address(0));\r\n        require(!_exists(tokenId));\r\n\r\n        _tokenOwner[tokenId] = to;\r\n        _ownedTokensCount[to].increment();\r\n\r\n        emit Transfer(address(0), to, tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to burn a specific token\r\n     * Reverts if the token does not exist\r\n     * Deprecated, use _burn(uint256) instead.\r\n     * @param owner owner of the token to burn\r\n     * @param tokenId uint256 ID of the token being burned\r\n     */\r\n    function _burn(address owner, uint256 tokenId) internal {\r\n        require(ownerOf(tokenId) == owner);\r\n\r\n        _clearApproval(tokenId);\r\n\r\n        _ownedTokensCount[owner].decrement();\r\n        _tokenOwner[tokenId] = address(0);\r\n\r\n        emit Transfer(owner, address(0), tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to burn a specific token\r\n     * Reverts if the token does not exist\r\n     * @param tokenId uint256 ID of the token being burned\r\n     */\r\n    function _burn(uint256 tokenId) internal {\r\n        _burn(ownerOf(tokenId), tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to transfer ownership of a given token ID to another address.\r\n     * As opposed to transferFrom, this imposes no restrictions on msg.sender.\r\n     * @param from current owner of the token\r\n     * @param to address to receive the ownership of the given token ID\r\n     * @param tokenId uint256 ID of the token to be transferred\r\n     */\r\n    function _transferFrom(address from, address to, uint256 tokenId) internal {\r\n        require(ownerOf(tokenId) == from);\r\n        require(to != address(0));\r\n\r\n        _clearApproval(tokenId);\r\n\r\n        _ownedTokensCount[from].decrement();\r\n        _ownedTokensCount[to].increment();\r\n\r\n        _tokenOwner[tokenId] = to;\r\n\r\n        emit Transfer(from, to, tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to invoke `onERC721Received` on a target address\r\n     * The call is not executed if the target address is not a contract\r\n     * @param from address representing the previous owner of the given token ID\r\n     * @param to target address that will receive the tokens\r\n     * @param tokenId uint256 ID of the token to be transferred\r\n     * @param _data bytes optional data to send along with the call\r\n     * @return bool whether the call correctly returned the expected magic value\r\n     */\r\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory _data)\r\n        internal returns (bool)\r\n    {\r\n        if (!to.isContract()) {\r\n            return true;\r\n        }\r\n\r\n        bytes4 retval = IERC721Receiver(to).onERC721Received(msg.sender, from, tokenId, _data);\r\n        return (retval == _ERC721_RECEIVED);\r\n    }\r\n\r\n    /**\r\n     * @dev Private function to clear current approval of a given token ID\r\n     * @param tokenId uint256 ID of the token to be transferred\r\n     */\r\n    function _clearApproval(uint256 tokenId) private {\r\n        if (_tokenApprovals[tokenId] != address(0)) {\r\n            _tokenApprovals[tokenId] = address(0);\r\n        }\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @title ERC-721 Non-Fungible Token with optional enumeration extension logic\r\n * @dev See https://eips.ethereum.org/EIPS/eip-721\r\n */\r\ncontract ERC721Enumerable is ERC165, ERC721, IERC721Enumerable {\r\n    // Mapping from owner to list of owned token IDs\r\n    mapping(address => uint256[]) private _ownedTokens;\r\n\r\n    // Mapping from token ID to index of the owner tokens list\r\n    mapping(uint256 => uint256) private _ownedTokensIndex;\r\n\r\n    // Array with all token ids, used for enumeration\r\n    uint256[] private _allTokens;\r\n\r\n    // Mapping from token id to position in the allTokens array\r\n    mapping(uint256 => uint256) private _allTokensIndex;\r\n\r\n    /*\r\n     *     bytes4(keccak256('totalSupply()')) == 0x18160ddd\r\n     *     bytes4(keccak256('tokenOfOwnerByIndex(address,uint256)')) == 0x2f745c59\r\n     *     bytes4(keccak256('tokenByIndex(uint256)')) == 0x4f6ccce7\r\n     *\r\n     *     => 0x18160ddd ^ 0x2f745c59 ^ 0x4f6ccce7 == 0x780e9d63\r\n     */\r\n    bytes4 private constant _INTERFACE_ID_ERC721_ENUMERABLE = 0x780e9d63;\r\n\r\n    /**\r\n     * @dev Constructor function.\r\n     */\r\n    constructor () public {\r\n        // register the supported interface to conform to ERC721Enumerable via ERC165\r\n        _registerInterface(_INTERFACE_ID_ERC721_ENUMERABLE);\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the token ID at a given index of the tokens list of the requested owner.\r\n     * @param owner address owning the tokens list to be accessed\r\n     * @param index uint256 representing the index to be accessed of the requested tokens list\r\n     * @return uint256 token ID at the given index of the tokens list owned by the requested address\r\n     */\r\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view returns (uint256) {\r\n        require(index < balanceOf(owner), \"ERC721Enumerable: owner index out of bounds\");\r\n        return _ownedTokens[owner][index];\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the total amount of tokens stored by the contract.\r\n     * @return uint256 representing the total amount of tokens\r\n     */\r\n    function totalSupply() public view returns (uint256) {\r\n        return _allTokens.length;\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the token ID at a given index of all the tokens in this contract\r\n     * Reverts if the index is greater or equal to the total number of tokens.\r\n     * @param index uint256 representing the index to be accessed of the tokens list\r\n     * @return uint256 token ID at the given index of the tokens list\r\n     */\r\n    function tokenByIndex(uint256 index) public view returns (uint256) {\r\n        require(index < totalSupply(), \"ERC721Enumerable: global index out of bounds\");\r\n        return _allTokens[index];\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to transfer ownership of a given token ID to another address.\r\n     * As opposed to transferFrom, this imposes no restrictions on msg.sender.\r\n     * @param from current owner of the token\r\n     * @param to address to receive the ownership of the given token ID\r\n     * @param tokenId uint256 ID of the token to be transferred\r\n     */\r\n    function _transferFrom(address from, address to, uint256 tokenId) internal {\r\n        super._transferFrom(from, to, tokenId);\r\n\r\n        _removeTokenFromOwnerEnumeration(from, tokenId);\r\n\r\n        _addTokenToOwnerEnumeration(to, tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to mint a new token.\r\n     * Reverts if the given token ID already exists.\r\n     * @param to address the beneficiary that will own the minted token\r\n     * @param tokenId uint256 ID of the token to be minted\r\n     */\r\n    function _mint(address to, uint256 tokenId) internal {\r\n        super._mint(to, tokenId);\r\n\r\n        _addTokenToOwnerEnumeration(to, tokenId);\r\n\r\n        _addTokenToAllTokensEnumeration(tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to burn a specific token.\r\n     * Reverts if the token does not exist.\r\n     * Deprecated, use _burn(uint256) instead.\r\n     * @param owner owner of the token to burn\r\n     * @param tokenId uint256 ID of the token being burned\r\n     */\r\n    function _burn(address owner, uint256 tokenId) internal {\r\n        super._burn(owner, tokenId);\r\n\r\n        _removeTokenFromOwnerEnumeration(owner, tokenId);\r\n        // Since tokenId will be deleted, we can clear its slot in _ownedTokensIndex to trigger a gas refund\r\n        _ownedTokensIndex[tokenId] = 0;\r\n\r\n        _removeTokenFromAllTokensEnumeration(tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Private function to add a token to this extension's ownership-tracking data structures.\r\n     * @param to address representing the new owner of the given token ID\r\n     * @param tokenId uint256 ID of the token to be added to the tokens list of the given address\r\n     */\r\n    function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\r\n        _ownedTokensIndex[tokenId] = _ownedTokens[to].length;\r\n        _ownedTokens[to].push(tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Private function to add a token to this extension's token tracking data structures.\r\n     * @param tokenId uint256 ID of the token to be added to the tokens list\r\n     */\r\n    function _addTokenToAllTokensEnumeration(uint256 tokenId) private {\r\n        _allTokensIndex[tokenId] = _allTokens.length;\r\n        _allTokens.push(tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Private function to remove a token from this extension's ownership-tracking data structures. Note that\r\n     * while the token is not assigned a new owner, the _ownedTokensIndex mapping is _not_ updated: this allows for\r\n     * gas optimizations e.g. when performing a transfer operation (avoiding double writes).\r\n     * This has O(1) time complexity, but alters the order of the _ownedTokens array.\r\n     * @param from address representing the previous owner of the given token ID\r\n     * @param tokenId uint256 ID of the token to be removed from the tokens list of the given address\r\n     */\r\n    function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {\r\n        // To prevent a gap in from's tokens array, we store the last token in the index of the token to delete, and\r\n        // then delete the last slot (swap and pop).\r\n\r\n        uint256 lastTokenIndex = _ownedTokens[from].length.sub(1);\r\n        uint256 tokenIndex = _ownedTokensIndex[tokenId];\r\n\r\n        // When the token to delete is the last token, the swap operation is unnecessary\r\n        if (tokenIndex != lastTokenIndex) {\r\n            uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];\r\n\r\n            _ownedTokens[from][tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\r\n            _ownedTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\r\n        }\r\n\r\n        // This also deletes the contents at the last position of the array\r\n        _ownedTokens[from].length--;\r\n\r\n        // Note that _ownedTokensIndex[tokenId] hasn't been cleared: it still points to the old slot (now occupied by\r\n        // lastTokenId, or just over the end of the array if the token was the last one).\r\n    }\r\n\r\n    /**\r\n     * @dev Private function to remove a token from this extension's token tracking data structures.\r\n     * This has O(1) time complexity, but alters the order of the _allTokens array.\r\n     * @param tokenId uint256 ID of the token to be removed from the tokens list\r\n     */\r\n    function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {\r\n        // To prevent a gap in the tokens array, we store the last token in the index of the token to delete, and\r\n        // then delete the last slot (swap and pop).\r\n\r\n        uint256 lastTokenIndex = _allTokens.length.sub(1);\r\n        uint256 tokenIndex = _allTokensIndex[tokenId];\r\n\r\n        // When the token to delete is the last token, the swap operation is unnecessary. However, since this occurs so\r\n        // rarely (when the last minted token is burnt) that we still do the swap here to avoid the gas cost of adding\r\n        // an 'if' statement (like in _removeTokenFromOwnerEnumeration)\r\n        uint256 lastTokenId = _allTokens[lastTokenIndex];\r\n\r\n        _allTokens[tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\r\n        _allTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\r\n\r\n        // This also deletes the contents at the last position of the array\r\n        _allTokens.length--;\r\n        _allTokensIndex[tokenId] = 0;\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @title HomeWork (version 1)\r\n * @author 0age\r\n * @notice Homework is a utility to find, share, and reuse \"home\" addresses for\r\n * contracts. Anyone can work to find a new home address by searching for keys,\r\n * a 32-byte value with the first 20 bytes equal to the finder's calling address\r\n * (or derived by hashing an arbitrary 32-byte salt and the caller's address),\r\n * and can then deploy any contract they like (even one with a constructor) to\r\n * the address, or mint an ERC721 token that the owner can redeem that will then\r\n * allow them to do the same. Also, if the contract is `SELFDESTRUCT`ed, a new\r\n * contract can be redeployed by the current controller to the same address!\r\n * @dev This contract allows contract addresses to be located ahead of time, and\r\n * for arbitrary bytecode to be deployed (and redeployed if so desired, i.e.\r\n * metamorphic contracts) to the located address by a designated controller. To\r\n * enable this, the contract first deploys an \"initialization-code-in-runtime\"\r\n * contract, with the creation code of the contract you want to deploy stored in\r\n * RUNTIME code. Then, to deploy the actual contract, it retrieves the address\r\n * of the storage contract and `DELEGATECALL`s into it to execute the init code\r\n * and, if successful, retrieves and returns the contract runtime code. Rather\r\n * than using a located address directly, you can also lock it in the contract\r\n * and mint and ERC721 token for it, which can then be redeemed in order to gain\r\n * control over deployment to the address (note that tokens may not be minted if\r\n * the contract they control currently has a deployed contract at that address).\r\n * Once a contract undergoes metamorphosis, all existing storage will be deleted\r\n * and any existing contract code will be replaced with the deployed contract\r\n * code of the new implementation contract. The mechanisms behind this contract \r\n * are highly experimental - proceed with caution and please share any exploits\r\n * or optimizations you discover.\r\n */\r\ncontract HomeWork is IHomeWork, ERC721Enumerable, IERC721Metadata, IERC1412 {\r\n  // Allocate storage to track the current initialization-in-runtime contract.\r\n  address private _initializationRuntimeStorageContract;\r\n\r\n  // Finder of home address with lowest uint256 value can recover lost funds.\r\n  bytes32 private _highScoreKey;\r\n\r\n  // Track information on the Home address corresponding to each key.\r\n  mapping (bytes32 => HomeAddress) private _home;\r\n\r\n  // Provide optional reverse-lookup for key derivation of a given home address.\r\n  mapping (address => KeyInformation) private _key;\r\n\r\n  // Set 0xff + address(this) as a constant to use when deriving home addresses.\r\n  bytes21 private constant _FF_AND_THIS_CONTRACT = bytes21(\r\n    0xff0000000000001b84b1cb32787B0D64758d019317\r\n  );\r\n\r\n  // Set the address of the tokenURI runtime storage contract as a constant.\r\n  address private constant _URI_END_SEGMENT_STORAGE = address(\r\n    0x000000000071C1c84915c17BF21728BfE4Dac3f3\r\n  );\r\n\r\n  // Deploy arbitrary contracts to home addresses using metamorphic init code.\r\n  bytes32 private constant _HOME_INIT_CODE = bytes32(\r\n    0x5859385958601c335a585952fa1582838382515af43d3d93833e601e57fd5bf3\r\n  );\r\n\r\n  // Compute hash of above metamorphic init code in order to compute addresses.\r\n  bytes32 private constant _HOME_INIT_CODE_HASH = bytes32(\r\n    0x7816562e7f85866cae07183593075f3b5ec32aeff914a0693e20aaf39672babc\r\n  );\r\n\r\n  // Write arbitrary code to a contract's runtime using the following prelude.\r\n  bytes11 private constant _ARBITRARY_RUNTIME_PRELUDE = bytes11(\r\n    0x600b5981380380925939f3\r\n  );\r\n\r\n  // Set EIP165 interface IDs as constants (already set 165 and 721+enumerable).\r\n  bytes4 private constant _INTERFACE_ID_HOMEWORK = 0xe5399799;\r\n  /* this.deploy.selector ^ this.lock.selector ^ this.redeem.selector ^\r\n     this.assignController.selector ^ this.relinquishControl.selector ^\r\n     this.redeemAndDeploy.selector ^ this.deriveKey.selector ^\r\n     this.deriveKeyAndLock.selector ^\r\n     this.deriveKeyAndAssignController.selector ^\r\n     this.deriveKeyAndRelinquishControl.selector ^\r\n     this.setReverseLookup.selector ^ this.setDerivedReverseLookup.selector ^\r\n     this.deployRuntimeStorageContract.selector ^\r\n     this.deployViaExistingRuntimeStorageContract.selector ^\r\n     this.redeemAndDeployViaExistingRuntimeStorageContract.selector ^\r\n     this.deriveKeyAndDeploy.selector ^\r\n     this.deriveKeyAndDeployViaExistingRuntimeStorageContract.selector ^\r\n     this.batchLock.selector ^ this.deriveKeysAndBatchLock.selector ^\r\n     this.batchLock_63efZf.selector ^ this.claimHighScore.selector ^\r\n     this.recover.selector ^ this.isDeployable.selector ^\r\n     this.getHighScore.selector ^ this.getHomeAddressInformation.selector ^\r\n     this.hasNeverBeenDeployed.selector ^ this.reverseLookup.selector ^\r\n     this.getDerivedKey.selector ^ this.getHomeAddress.selector ^\r\n     this.getMetamorphicDelegatorInitializationCode.selector ^\r\n     this.getMetamorphicDelegatorInitializationCodeHash.selector ^\r\n     this.getArbitraryRuntimeCodePrelude.selector == 0xe5399799\r\n  */\r\n\r\n  bytes4 private constant _INTERFACE_ID_ERC721_METADATA = 0x5b5e139f;\r\n\r\n  bytes4 private constant _INTERFACE_ID_ERC1412_BATCH_TRANSFERS = 0x2b89bcaa;\r\n\r\n  // Set name of this contract as a constant (hex encoding is to support emoji).\r\n  string private constant _NAME = (\r\n    hex\"486f6d65576f726b20f09f8fa0f09f9ba0efb88f\"\r\n  );\r\n\r\n  // Set symbol of this contract as a constant.\r\n  string private constant _SYMBOL = \"HWK\";\r\n\r\n  // Set the start of each token URI for issued ERC721 tokens as a constant.\r\n  bytes private constant _URI_START_SEGMENT = abi.encodePacked(\r\n    hex\"646174613a6170706c69636174696f6e2f6a736f6e2c7b226e616d65223a22486f6d65\",\r\n    hex\"253230416464726573732532302d2532303078\"\r\n  ); /* data:application/json,{\"name\":\"Home%20Address%20-%200x */\r\n\r\n  // Store reused revert messages as constants.\r\n  string private constant _ACCOUNT_EXISTS = string(\r\n    \"Only non-existent accounts can be deployed or used to mint tokens.\"\r\n  );\r\n\r\n  string private constant _ONLY_CONTROLLER = string(\r\n    \"Only the designated controller can call this function.\"\r\n  );\r\n\r\n  string private constant _NO_INIT_CODE_SUPPLIED = string(\r\n    \"Cannot deploy a contract with no initialization code supplied.\"\r\n  );\r\n\r\n  /**\r\n   * @notice In the constructor, verify that deployment addresses are correct\r\n   * and that supplied constant hash value of the contract creation code used to\r\n   * deploy arbitrary contracts to home addresses is valid, and set an initial\r\n   * high score key with the null address as the high score \"holder\". ERC165\r\n   * supported interfaces are all registered during initizialization as well.\r\n   */\r\n  constructor() public {\r\n    // Verify that the deployment address is set correctly as a constant.\r\n    assert(address(this) == address(uint160(uint168(_FF_AND_THIS_CONTRACT))));\r\n\r\n    // Verify the derivation of the deployment address.\r\n    bytes32 initialDeployKey = bytes32(\r\n      0x486f6d65576f726b20f09f8fa0f09f9ba0efb88faa3c548a76f9bd3c000c0000\r\n    );    \r\n    assert(address(this) == address(\r\n      uint160(                      // Downcast to match the address type.\r\n        uint256(                    // Convert to uint to truncate upper digits.\r\n          keccak256(                // Compute the CREATE2 hash using 4 inputs.\r\n            abi.encodePacked(       // Pack all inputs to the hash together.\r\n              bytes1(0xff),         // Start with 0xff to distinguish from RLP.\r\n              msg.sender,           // The deployer will be the caller.\r\n              initialDeployKey,     // Pass in the supplied key as the salt.\r\n              _HOME_INIT_CODE_HASH  // The metamorphic initialization code hash.\r\n            )\r\n          )\r\n        )\r\n      )\r\n    ));\r\n\r\n    // Verify the derivation of the tokenURI runtime storage address.\r\n    bytes32 uriDeployKey = bytes32(\r\n      0x486f6d65576f726b202d20746f6b656e55524920c21352fee5a62228db000000\r\n    );\r\n    bytes32 uriInitCodeHash = bytes32(\r\n      0xdea98294867e3fdc48eb5975ecc53a79e2e1ea6e7e794137a9c34c4dd1565ba2\r\n    );\r\n    assert(_URI_END_SEGMENT_STORAGE == address(\r\n      uint160(                      // Downcast to match the address type.\r\n        uint256(                    // Convert to uint to truncate upper digits.\r\n          keccak256(                // Compute the CREATE2 hash using 4 inputs.\r\n            abi.encodePacked(       // Pack all inputs to the hash together.\r\n              bytes1(0xff),         // Start with 0xff to distinguish from RLP.\r\n              msg.sender,           // The deployer will be the caller.\r\n              uriDeployKey,         // Pass in the supplied key as the salt.\r\n              uriInitCodeHash       // The storage contract init code hash.\r\n            )\r\n          )\r\n        )\r\n      )\r\n    ));\r\n\r\n    // Verify that the correct runtime code is at the tokenURI storage contract.\r\n    bytes32 expectedRuntimeStorageHash = bytes32(\r\n      0x8834602968080bb1df9c44c9834c0a93533b72bbfa3865ee2c5be6a0c4125fc3\r\n    );\r\n    address runtimeStorage = _URI_END_SEGMENT_STORAGE;\r\n    bytes32 runtimeStorageHash;\r\n    assembly { runtimeStorageHash := extcodehash(runtimeStorage) }\r\n    assert(runtimeStorageHash == expectedRuntimeStorageHash);\r\n\r\n    // Verify that the supplied hash for the metamorphic init code is valid.\r\n    assert(keccak256(abi.encode(_HOME_INIT_CODE)) == _HOME_INIT_CODE_HASH);\r\n\r\n    // Set an initial high score key with the null address as the submitter.\r\n    _highScoreKey = bytes32(\r\n      0x0000000000000000000000000000000000000000ffffffffffffffffffffffff\r\n    );\r\n\r\n    // Register EIP165 interface for HomeWork.\r\n    _registerInterface(_INTERFACE_ID_HOMEWORK);\r\n\r\n    // Register EIP165 interface for ERC721 metadata.\r\n    _registerInterface(_INTERFACE_ID_ERC721_METADATA);\r\n\r\n    // Register EIP165 interface for ERC1412 (batch transfers).\r\n    _registerInterface(_INTERFACE_ID_ERC1412_BATCH_TRANSFERS);\r\n  }\r\n\r\n  /**\r\n   * @notice Deploy a new contract with the desired initialization code to the\r\n   * home address corresponding to a given key. Two conditions must be met: the\r\n   * submitter must be designated as the controller of the home address (with\r\n   * the initial controller set to the address corresponding to the first twenty\r\n   * bytes of the key), and there must not be a contract currently deployed at\r\n   * the home address. These conditions can be checked by calling\r\n   * `getHomeAddressInformation` and `isDeployable` with the same key.\r\n   * @param key bytes32 The unique value used to derive the home address.\r\n   * @param initializationCode bytes The contract creation code that will be\r\n   * used to deploy the contract to the home address.\r\n   * @return The home address of the deployed contract.\r\n   * @dev In order to deploy the contract to the home address, a new contract\r\n   * will be deployed with runtime code set to the initialization code of the\r\n   * contract that will be deployed to the home address. Then, metamorphic\r\n   * initialization code will retrieve that initialization code and use it to\r\n   * set up and deploy the desired contract to the home address. Bear in mind\r\n   * that the deployed contract will interpret msg.sender as the address of THIS\r\n   * contract, and not the address of the submitter - if the constructor of the\r\n   * deployed contract uses msg.sender to set up ownership or other variables,\r\n   * you must modify it to accept a constructor argument with the appropriate\r\n   * address, or alternately to hard-code the intended address. Also, if your\r\n   * contract DOES have constructor arguments, remember to include them as\r\n   * ABI-encoded arguments at the end of the initialization code, just as you\r\n   * would when performing a standard deploy. You may also want to provide the\r\n   * key to `setReverseLookup` in order to find it again using only the home\r\n   * address to prevent accidentally losing the key.\r\n   */\r\n  function deploy(bytes32 key, bytes calldata initializationCode)\r\n    external\r\n    payable\r\n    onlyEmpty(key)\r\n    onlyControllerDeployer(key)\r\n    returns (address homeAddress, bytes32 runtimeCodeHash)\r\n  {\r\n    // Ensure that initialization code was supplied.\r\n    require(initializationCode.length > 0, _NO_INIT_CODE_SUPPLIED);\r\n\r\n    // Deploy the initialization storage contract and set address in storage.\r\n    _initializationRuntimeStorageContract = _deployRuntimeStorageContract(\r\n      initializationCode\r\n    );\r\n\r\n    // Use metamorphic initialization code to deploy contract to home address.\r\n    (homeAddress, runtimeCodeHash) = _deployToHomeAddress(key);\r\n  }\r\n\r\n  /**\r\n   * @notice Mint an ERC721 token to the supplied owner that can be redeemed in\r\n   * order to gain control of a home address corresponding to a given key. Two\r\n   * conditions must be met: the submitter must be designated as the controller\r\n   * of the home address (with the initial controller set to the address\r\n   * corresponding to the first 20 bytes of the key), and there must not be a\r\n   * contract currently deployed at the home address. These conditions can be\r\n   * checked by calling `getHomeAddressInformation` and `isDeployable` with the\r\n   * same key.\r\n   * @param key bytes32 The unique value used to derive the home address.\r\n   * @param owner address The account that will be granted ownership of the\r\n   * ERC721 token.\r\n   * @dev In order to mint an ERC721 token, the assocated home address cannot be\r\n   * in use, or else the token will not be able to deploy to the home address.\r\n   * The controller is set to this contract until the token is redeemed, at\r\n   * which point the redeemer designates a new controller for the home address.\r\n   * The key of the home address and the tokenID of the ERC721 token are the\r\n   * same value, but different types (bytes32 vs. uint256).\r\n   */\r\n  function lock(bytes32 key, address owner)\r\n    external\r\n    onlyEmpty(key)\r\n    onlyController(key)\r\n  {\r\n    // Ensure that the specified owner is a valid ERC721 receiver.\r\n    _validateOwner(owner, key);\r\n\r\n    // Get the HomeAddress storage struct from the mapping using supplied key.\r\n    HomeAddress storage home = _home[key];\r\n\r\n    // Set the exists flag to true and the controller to this contract.\r\n    home.exists = true;\r\n    home.controller = address(this);\r\n\r\n    // Emit an event signifying that this contract is now the controller. \r\n    emit NewController(key, address(this));\r\n\r\n    // Mint the ERC721 token to the designated owner.\r\n    _mint(owner, uint256(key));\r\n  }\r\n\r\n  /**\r\n   * @notice Burn an ERC721 token to allow the supplied controller to gain the\r\n   * ability to deploy to the home address corresponding to the key matching the\r\n   * burned token. The submitter must be designated as either the owner of the\r\n   * token or as an approved spender.\r\n   * @param tokenId uint256 The ID of the ERC721 token to redeem.\r\n   * @param controller address The account that will be granted control of the\r\n   * home address corresponding to the given token.\r\n   * @dev The controller cannot be designated as the address of this contract,\r\n   * the null address, or the home address (the restriction on setting the home\r\n   * address as the controller is due to the fact that the home address will not\r\n   * be able to deploy to itself, as it needs to be empty before a contract can\r\n   * be deployed to it).\r\n   */\r\n  function redeem(uint256 tokenId, address controller)\r\n    external\r\n    onlyTokenOwnerOrApprovedSpender(tokenId)\r\n  {\r\n    // Convert the token ID to a bytes32 key.\r\n    bytes32 key = bytes32(tokenId);\r\n\r\n    // Prevent the controller from being set to prohibited account values.\r\n    _validateController(controller, key);\r\n\r\n    // Burn the ERC721 token in question.\r\n    _burn(tokenId);\r\n\r\n    // Assign the new controller to the corresponding home address.\r\n    _home[key].controller = controller;\r\n\r\n    // Emit an event with the new controller. \r\n    emit NewController(key, controller);\r\n  }\r\n\r\n  /**\r\n   * @notice Transfer control over deployment to the home address corresponding\r\n   * to a given key. The caller must be designated as the current controller of\r\n   * the home address (with the initial controller set to the address\r\n   * corresponding to the first 20 bytes of the key) - This condition can be\r\n   * checked by calling `getHomeAddressInformation` with the same key.\r\n   * @param key bytes32 The unique value used to derive the home address.\r\n   * @param controller address The account that will be granted control of the\r\n   * home address corresponding to the given key.\r\n   * @dev The controller cannot be designated as the address of this contract,\r\n   * the null address, or the home address (the restriction on setting the home\r\n   * address as the controller is due to the fact that the home address will not\r\n   * be able to deploy to itself, as it needs to be empty before a contract can\r\n   * be deployed to it).\r\n   */\r\n  function assignController(bytes32 key, address controller)\r\n    external\r\n    onlyController(key)\r\n  {\r\n    // Prevent the controller from being set to prohibited account values.\r\n    _validateController(controller, key);\r\n\r\n    // Assign the new controller to the corresponding home address.\r\n    HomeAddress storage home = _home[key];\r\n    home.exists = true;\r\n    home.controller = controller;\r\n\r\n    // Emit an event with the new controller. \r\n    emit NewController(key, controller);\r\n  }\r\n\r\n  /**\r\n   * @notice Transfer control over deployment to the home address corresponding\r\n   * to a given key to the null address, which will prevent it from being\r\n   * deployed to again in the future. The caller must be designated as the\r\n   * current controller of the corresponding home address (with the initial\r\n   * controller set to the address corresponding to the first 20 bytes of the\r\n   * key) - This condition can be checked by calling `getHomeAddressInformation`\r\n   * with the same key.\r\n   * @param key bytes32 The unique value used to derive the home address.\r\n   */\r\n  function relinquishControl(bytes32 key)\r\n    external\r\n    onlyController(key)\r\n  {\r\n    // Assign the null address as the controller of the given key.\r\n    HomeAddress storage home = _home[key];\r\n    home.exists = true;\r\n    home.controller = address(0);\r\n\r\n    // Emit an event with the null address as the controller. \r\n    emit NewController(key, address(0));\r\n  }\r\n\r\n  /**\r\n   * @notice Burn an ERC721 token, set a supplied controller, and deploy a new\r\n   * contract with the supplied initialization code to the corresponding home\r\n   * address for the given token. The submitter must be designated as either the\r\n   * owner of the token or as an approved spender.\r\n   * @param tokenId uint256 The ID of the ERC721 token to redeem.\r\n   * @param controller address The account that will be granted control of the\r\n   * home address corresponding to the given token.\r\n   * @param initializationCode bytes The contract creation code that will be\r\n   * used to deploy the contract to the home address.\r\n   * @return The home address and runtime code hash of the deployed contract.\r\n   * @dev In order to deploy the contract to the home address, a new contract\r\n   * will be deployed with runtime code set to the initialization code of the\r\n   * contract that will be deployed to the home address. Then, metamorphic\r\n   * initialization code will retrieve that initialization code and use it to\r\n   * set up and deploy the desired contract to the home address. Bear in mind\r\n   * that the deployed contract will interpret msg.sender as the address of THIS\r\n   * contract, and not the address of the submitter - if the constructor of the\r\n   * deployed contract uses msg.sender to set up ownership or other variables,\r\n   * you must modify it to accept a constructor argument with the appropriate\r\n   * address, or alternately to hard-code the intended address. Also, if your\r\n   * contract DOES have constructor arguments, remember to include them as\r\n   * ABI-encoded arguments at the end of the initialization code, just as you\r\n   * would when performing a standard deploy. You may also want to provide the\r\n   * key to `setReverseLookup` in order to find it again using only the home\r\n   * address to prevent accidentally losing the key. The controller cannot be\r\n   * designated as the address of this contract, the null address, or the home\r\n   * address (the restriction on setting the home address as the controller is\r\n   * due to the fact that the home address will not be able to deploy to itself,\r\n   * as it needs to be empty before a contract can be deployed to it). Also,\r\n   * checks on the contract at the home address being empty or not having the\r\n   * correct controller are unnecessary, as they are performed when minting the\r\n   * token and cannot be altered until the token is redeemed.\r\n   */\r\n  function redeemAndDeploy(\r\n    uint256 tokenId,\r\n    address controller,\r\n    bytes calldata initializationCode\r\n  )\r\n    external\r\n    payable\r\n    onlyTokenOwnerOrApprovedSpender(tokenId)\r\n    returns (address homeAddress, bytes32 runtimeCodeHash)\r\n  {\r\n    // Ensure that initialization code was supplied.\r\n    require(initializationCode.length > 0, _NO_INIT_CODE_SUPPLIED);\r\n\r\n    // Convert the token ID to a bytes32 key.\r\n    bytes32 key = bytes32(tokenId);\r\n\r\n    // Prevent the controller from being set to prohibited account values.\r\n    _validateController(controller, key);\r\n\r\n    // Burn the ERC721 token in question.\r\n    _burn(tokenId);\r\n\r\n    // Deploy the initialization storage contract and set address in storage.\r\n    _initializationRuntimeStorageContract = _deployRuntimeStorageContract(\r\n      initializationCode\r\n    );\r\n\r\n    // Set provided controller and increment contract deploy count at once.\r\n    HomeAddress storage home = _home[key];\r\n    home.exists = true;\r\n    home.controller = controller;\r\n    home.deploys += 1;\r\n\r\n    // Emit an event with the new controller. \r\n    emit NewController(key, controller);\r\n\r\n    // Use metamorphic initialization code to deploy contract to home address.\r\n    (homeAddress, runtimeCodeHash) = _deployToHomeAddress(key);\r\n  }\r\n\r\n  /**\r\n   * @notice Derive a new key by concatenating an arbitrary 32-byte salt value\r\n   * and the address of the caller and performing a keccak256 hash. This allows\r\n   * for the creation of keys with additional entropy where desired while also\r\n   * preventing collisions with standard keys. The caller will be set as the\r\n   * controller of the derived key.\r\n   * @param salt bytes32 The desired salt value to use (along with the address\r\n   * of the caller) when deriving the resultant key and corresponding home\r\n   * address.\r\n   * @return The derived key.\r\n   * @dev Home addresses from derived keys will take longer to \"mine\" or locate,\r\n   * as an additional hash must be performed when computing the corresponding\r\n   * home address for each given salt input. Each caller will derive a different\r\n   * key even if they are supplying the same salt value.\r\n   */\r\n  function deriveKey(bytes32 salt) external returns (bytes32 key) {\r\n    // Derive the key using the supplied salt and the calling address.\r\n    key = _deriveKey(salt, msg.sender);\r\n\r\n    // Register key and set caller as controller if it is not yet registered.\r\n    HomeAddress storage home = _home[key];\r\n    if (!home.exists) {\r\n      home.exists = true;\r\n      home.controller = msg.sender;\r\n\r\n      // Emit an event with the sender as the new controller. \r\n      emit NewController(key, msg.sender);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @notice Mint an ERC721 token to the supplied owner that can be redeemed in\r\n   * order to gain control of a home address corresponding to a given derived\r\n   * key. Two conditions must be met: the submitter must be designated as the\r\n   * current controller of the home address, and there must not be a contract\r\n   * currently deployed at the home address. These conditions can be checked by\r\n   * calling `getHomeAddressInformation` and `isDeployable` with the key\r\n   * determined by calling `getDerivedKey`.\r\n   * @param salt bytes32 The salt value that is used to derive the key.\r\n   * @param owner address The account that will be granted ownership of the\r\n   * ERC721 token.\r\n   * @return The derived key.\r\n   * @dev In order to mint an ERC721 token, the assocated home address cannot be\r\n   * in use, or else the token will not be able to deploy to the home address.\r\n   * The controller is set to this contract until the token is redeemed, at\r\n   * which point the redeemer designates a new controller for the home address.\r\n   * The key of the home address and the tokenID of the ERC721 token are the\r\n   * same value, but different types (bytes32 vs. uint256).\r\n   */\r\n  function deriveKeyAndLock(bytes32 salt, address owner)\r\n    external\r\n    returns (bytes32 key)\r\n  {\r\n    // Derive the key using the supplied salt and the calling address.\r\n    key = _deriveKey(salt, msg.sender);\r\n\r\n    // Ensure that the specified owner is a valid ERC721 receiver.\r\n    _validateOwner(owner, key);\r\n\r\n    // Ensure that a contract is not currently deployed to the home address.\r\n    require(_isNotDeployed(key), _ACCOUNT_EXISTS);\r\n\r\n    // Ensure that the caller is the controller of the derived key.\r\n    HomeAddress storage home = _home[key];\r\n    if (home.exists) {\r\n      require(home.controller == msg.sender, _ONLY_CONTROLLER);\r\n    }\r\n\r\n    // Set the exists flag to true and the controller to this contract.\r\n    home.exists = true;\r\n    home.controller = address(this);\r\n\r\n    // Mint the ERC721 token to the designated owner.\r\n    _mint(owner, uint256(key));\r\n\r\n    // Emit an event signifying that this contract is now the controller. \r\n    emit NewController(key, address(this));\r\n  }\r\n\r\n  /**\r\n   * @notice Transfer control over deployment to the home address corresponding\r\n   * to a given derived key. The caller must be designated as the current\r\n   * controller of the home address - This condition can be checked by calling\r\n   * `getHomeAddressInformation` with the key obtained via `getDerivedKey`.\r\n   * @param salt bytes32 The salt value that is used to derive the key.\r\n   * @param controller address The account that will be granted control of the\r\n   * home address corresponding to the given derived key.\r\n   * @return The derived key.\r\n   * @dev The controller cannot be designated as the address of this contract,\r\n   * the null address, or the home address (the restriction on setting the home\r\n   * address as the controller is due to the fact that the home address will not\r\n   * be able to deploy to itself, as it needs to be empty before a contract can\r\n   * be deployed to it).\r\n   */\r\n  function deriveKeyAndAssignController(bytes32 salt, address controller)\r\n    external\r\n    returns (bytes32 key)\r\n  {\r\n    // Derive the key using the supplied salt and the calling address.\r\n    key = _deriveKey(salt, msg.sender);\r\n\r\n    // Prevent the controller from being set to prohibited account values.\r\n    _validateController(controller, key);\r\n\r\n    // Ensure that the caller is the controller of the derived key.\r\n    HomeAddress storage home = _home[key];\r\n    if (home.exists) {\r\n      require(home.controller == msg.sender, _ONLY_CONTROLLER);\r\n    }\r\n\r\n    // Assign the new controller to the corresponding home address.\r\n    home.exists = true;\r\n    home.controller = controller;\r\n\r\n    // Emit an event with the new controller. \r\n    emit NewController(key, controller);\r\n  }\r\n\r\n  /**\r\n   * @notice Transfer control over deployment to the home address corresponding\r\n   * to a given derived key to the null address, which will prevent it from\r\n   * being deployed to again in the future. The caller must be designated as the\r\n   * current controller of the home address - This condition can be checked by\r\n   * calling `getHomeAddressInformation` with the key determined by calling\r\n   * `getDerivedKey`.\r\n   * @param salt bytes32 The salt value that is used to derive the key.\r\n   * @return The derived key.\r\n   */\r\n  function deriveKeyAndRelinquishControl(bytes32 salt)\r\n    external\r\n    returns (bytes32 key)\r\n  {\r\n    // Derive the key using the supplied salt and the calling address.\r\n    key = _deriveKey(salt, msg.sender);\r\n\r\n    // Ensure that the caller is the controller of the derived key.\r\n    HomeAddress storage home = _home[key];\r\n    if (home.exists) {\r\n      require(home.controller == msg.sender, _ONLY_CONTROLLER);\r\n    }\r\n\r\n    // Assign the null address as the controller of the given derived key.\r\n    home.exists = true;\r\n    home.controller = address(0);\r\n\r\n    // Emit an event with the null address as the controller. \r\n    emit NewController(key, address(0));\r\n  }\r\n\r\n  /**\r\n   * @notice Record a key that corresponds to a given home address by supplying\r\n   * said key and using it to derive the address. This enables reverse lookup\r\n   * of a key using only the home address in question. This method may be called\r\n   * by anyone - control of the key is not required.\r\n   * @param key bytes32 The unique value used to derive the home address.\r\n   * @dev This does not set the salt or submitter fields, as those apply only to\r\n   * derived keys (although a derived key may also be set with this method, just\r\n   * without the derived fields).\r\n   */\r\n  function setReverseLookup(bytes32 key) external {\r\n    // Derive home address of given key and set home address and key in mapping.\r\n    _key[_getHomeAddress(key)].key = key;\r\n  }\r\n\r\n  /**\r\n   * @notice Record the derived key that corresponds to a given home address by\r\n   * supplying the salt and submitter that were used to derive the key. This\r\n   * facititates reverse lookup of the derivation method of a key using only the\r\n   * home address in question. This method may be called by anyone - control of\r\n   * the derived key is not required.\r\n   * @param salt bytes32 The salt value that is used to derive the key.\r\n   * @param submitter address The account that submits the salt that is used to\r\n   * derive the key.\r\n   */\r\n  function setDerivedReverseLookup(bytes32 salt, address submitter) external {\r\n    // Derive the key using the supplied salt and submitter.\r\n    bytes32 key = _deriveKey(salt, submitter);\r\n\r\n    // Derive home address and set it along with all other relevant information.\r\n    _key[_getHomeAddress(key)] = KeyInformation({\r\n      key: key,\r\n      salt: salt,\r\n      submitter: submitter\r\n    });\r\n  }\r\n\r\n  /**\r\n   * @notice Deploy a new storage contract with the supplied code as runtime\r\n   * code without deploying a contract to a home address. This can be used to\r\n   * store the contract creation code for use in future deployments of contracts\r\n   * to home addresses.\r\n   * @param codePayload bytes The code to set as the runtime code of the\r\n   * deployed contract.\r\n   * @return The address of the deployed storage contract.\r\n   * @dev Consider placing adequate protections on the storage contract to\r\n   * prevent unwanted callers from modifying or destroying it. Also, if you are\r\n   * placing contract contract creation code into the runtime storage contract,\r\n   * remember to include any constructor parameters as ABI-encoded arguments at\r\n   * the end of the contract creation code, similar to how you would perform a\r\n   * standard deployment.\r\n   */\r\n  function deployRuntimeStorageContract(bytes calldata codePayload)\r\n    external\r\n    returns (address runtimeStorageContract)\r\n  {\r\n    // Ensure that a code payload was supplied.\r\n    require(codePayload.length > 0, \"No runtime code payload supplied.\");\r\n\r\n    // Deploy payload to the runtime storage contract and return the address.\r\n    runtimeStorageContract = _deployRuntimeStorageContract(codePayload);\r\n  }\r\n\r\n  /**\r\n   * @notice Deploy a new contract with the initialization code stored in the\r\n   * runtime code at the specified initialization runtime storage contract to\r\n   * the home address corresponding to a given key. Two conditions must be met:\r\n   * the submitter must be designated as the controller of the home address\r\n   * (with the initial controller set to the address corresponding to the first\r\n   * 20 bytes of the key), and there must not be a contract currently deployed\r\n   * at the home address. These conditions can be checked by calling\r\n   * `getHomeAddressInformation` and `isDeployable` with the same key.\r\n   * @param key bytes32 The unique value used to derive the home address.\r\n   * @param initializationRuntimeStorageContract address The storage contract\r\n   * with runtime code equal to the contract creation code that will be used to\r\n   * deploy the contract to the home address.\r\n   * @return The home address and runtime code hash of the deployed contract.\r\n   * @dev When deploying a contract to a home address via this method, the\r\n   * metamorphic initialization code will retrieve whatever initialization code\r\n   * currently resides at the specified address and use it to set up and deploy\r\n   * the desired contract to the home address. Bear in mind that the deployed\r\n   * contract will interpret msg.sender as the address of THIS contract, and not\r\n   * the address of the submitter - if the constructor of the deployed contract\r\n   * uses msg.sender to set up ownership or other variables, you must modify it\r\n   * to accept a constructor argument with the appropriate address, or\r\n   * alternately to hard-code the intended address. Also, if your contract DOES\r\n   * have constructor arguments, remember to include them as ABI-encoded\r\n   * arguments at the end of the initialization code, just as you would when\r\n   * performing a standard deploy. You may also want to provide the key to\r\n   * `setReverseLookup` in order to find it again using only the home address to\r\n   * prevent accidentally losing the key.\r\n   */\r\n  function deployViaExistingRuntimeStorageContract(\r\n    bytes32 key,\r\n    address initializationRuntimeStorageContract\r\n  )\r\n    external\r\n    payable\r\n    onlyEmpty(key)\r\n    onlyControllerDeployer(key)\r\n    returns (address homeAddress, bytes32 runtimeCodeHash)\r\n  {\r\n    // Ensure that the supplied runtime storage contract is not empty.\r\n    _validateRuntimeStorageIsNotEmpty(initializationRuntimeStorageContract);\r\n\r\n    // Set initialization runtime storage contract address in contract storage.\r\n    _initializationRuntimeStorageContract = initializationRuntimeStorageContract;\r\n\r\n    // Use metamorphic initialization code to deploy contract to home address.\r\n    (homeAddress, runtimeCodeHash) = _deployToHomeAddress(key);\r\n  }\r\n\r\n  /**\r\n   * @notice Burn an ERC721 token, set a supplied controller, and deploy a new\r\n   * contract with the initialization code stored in the runtime code at the\r\n   * specified initialization runtime storage contract to the home address\r\n   * corresponding to a given key. The submitter must be designated as either\r\n   * the owner of the token or as an approved spender.\r\n   * @param tokenId uint256 The ID of the ERC721 token to redeem.\r\n   * @param controller address The account that will be granted control of the\r\n   * home address corresponding to the given token.\r\n   * @param initializationRuntimeStorageContract address The storage contract\r\n   * with runtime code equal to the contract creation code that will be used to\r\n   * deploy the contract to the home address.\r\n   * @return The home address and runtime code hash of the deployed contract.\r\n   * @dev When deploying a contract to a home address via this method, the\r\n   * metamorphic initialization code will retrieve whatever initialization code\r\n   * currently resides at the specified address and use it to set up and deploy\r\n   * the desired contract to the home address. Bear in mind that the deployed\r\n   * contract will interpret msg.sender as the address of THIS contract, and not\r\n   * the address of the submitter - if the constructor of the deployed contract\r\n   * uses msg.sender to set up ownership or other variables, you must modify it\r\n   * to accept a constructor argument with the appropriate address, or\r\n   * alternately to hard-code the intended address. Also, if your contract DOES\r\n   * have constructor arguments, remember to include them as ABI-encoded\r\n   * arguments at the end of the initialization code, just as you would when\r\n   * performing a standard deploy. You may also want to provide the key to\r\n   * `setReverseLookup` in order to find it again using only the home address to\r\n   * prevent accidentally losing the key. The controller cannot be designated as\r\n   * the address of this contract, the null address, or the home address (the\r\n   * restriction on setting the home address as the controller is due to the\r\n   * fact that the home address will not be able to deploy to itself, as it\r\n   * needs to be empty before a contract can be deployed to it). Also, checks on\r\n   * the contract at the home address being empty or not having the correct\r\n   * controller are unnecessary, as they are performed when minting the token\r\n   * and cannot be altered until the token is redeemed.\r\n   */\r\n  function redeemAndDeployViaExistingRuntimeStorageContract(\r\n    uint256 tokenId,\r\n    address controller,\r\n    address initializationRuntimeStorageContract\r\n  )\r\n    external\r\n    payable\r\n    onlyTokenOwnerOrApprovedSpender(tokenId)\r\n    returns (address homeAddress, bytes32 runtimeCodeHash)\r\n  {\r\n    // Ensure that the supplied runtime storage contract is not empty.\r\n    _validateRuntimeStorageIsNotEmpty(initializationRuntimeStorageContract);\r\n\r\n    // Convert the token ID to a bytes32 key.\r\n    bytes32 key = bytes32(tokenId);\r\n\r\n    // Prevent the controller from being set to prohibited account values.\r\n    _validateController(controller, key);\r\n\r\n    // Burn the ERC721 token in question.\r\n    _burn(tokenId);\r\n\r\n    // Set initialization runtime storage contract address in contract storage.\r\n    _initializationRuntimeStorageContract = initializationRuntimeStorageContract;\r\n\r\n    // Set provided controller and increment contract deploy count at once.\r\n    HomeAddress storage home = _home[key];\r\n    home.exists = true;\r\n    home.controller = controller;\r\n    home.deploys += 1;\r\n\r\n    // Emit an event with the new controller. \r\n    emit NewController(key, controller);\r\n\r\n    // Use metamorphic initialization code to deploy contract to home address.\r\n    (homeAddress, runtimeCodeHash) = _deployToHomeAddress(key);\r\n  }\r\n\r\n  /**\r\n   * @notice Deploy a new contract with the desired initialization code to the\r\n   * home address corresponding to a given derived key. Two conditions must be\r\n   * met: the submitter must be designated as the controller of the home\r\n   * address, and there must not be a contract currently deployed at the home\r\n   * address. These conditions can be checked by calling\r\n   * `getHomeAddressInformation` and `isDeployable` with the key obtained by\r\n   * calling `getDerivedKey`.\r\n   * @param salt bytes32 The salt value that is used to derive the key.\r\n   * @param initializationCode bytes The contract creation code that will be\r\n   * used to deploy the contract to the home address.\r\n   * @return The home address, derived key, and runtime code hash of the\r\n   * deployed contract.\r\n   * @dev In order to deploy the contract to the home address, a new contract\r\n   * will be deployed with runtime code set to the initialization code of the\r\n   * contract that will be deployed to the home address. Then, metamorphic\r\n   * initialization code will retrieve that initialization code and use it to\r\n   * set up and deploy the desired contract to the home address. Bear in mind\r\n   * that the deployed contract will interpret msg.sender as the address of THIS\r\n   * contract, and not the address of the submitter - if the constructor of the\r\n   * deployed contract uses msg.sender to set up ownership or other variables,\r\n   * you must modify it to accept a constructor argument with the appropriate\r\n   * address, or alternately to hard-code the intended address. Also, if your\r\n   * contract DOES have constructor arguments, remember to include them as\r\n   * ABI-encoded arguments at the end of the initialization code, just as you\r\n   * would when performing a standard deploy. You may want to provide the salt\r\n   * and submitter to `setDerivedReverseLookup` in order to find the salt,\r\n   * submitter, and derived key using only the home address to prevent\r\n   * accidentally losing them.\r\n   */\r\n  function deriveKeyAndDeploy(bytes32 salt, bytes calldata initializationCode)\r\n    external\r\n    payable\r\n    returns (address homeAddress, bytes32 key, bytes32 runtimeCodeHash)\r\n  {\r\n    // Ensure that initialization code was supplied.\r\n    require(initializationCode.length > 0, _NO_INIT_CODE_SUPPLIED);\r\n\r\n    // Derive key and prepare to deploy using supplied salt and calling address.\r\n    key = _deriveKeyAndPrepareToDeploy(salt);\r\n\r\n    // Deploy the initialization storage contract and set address in storage.\r\n    _initializationRuntimeStorageContract = _deployRuntimeStorageContract(\r\n      initializationCode\r\n    );\r\n\r\n    // Use metamorphic initialization code to deploy contract to home address.\r\n    (homeAddress, runtimeCodeHash) = _deployToHomeAddress(key);\r\n  }\r\n\r\n  /**\r\n   * @notice Deploy a new contract with the initialization code stored in the\r\n   * runtime code at the specified initialization runtime storage contract to\r\n   * the home address corresponding to a given derived key. Two conditions must\r\n   * be met: the submitter must be designated as the controller of the home\r\n   * address, and there must not be a contract currently deployed at the home\r\n   * address. These conditions can be checked by calling\r\n   * `getHomeAddressInformation` and `isDeployable` with the key obtained by\r\n   * calling `getDerivedKey`.\r\n   * @param salt bytes32 The salt value that is used to derive the key.\r\n   * @param initializationRuntimeStorageContract address The storage contract\r\n   * with runtime code equal to the contract creation code that will be used to\r\n   * deploy the contract to the home address.\r\n   * @return The home address, derived key, and runtime code hash of the\r\n   * deployed contract.\r\n   * @dev When deploying a contract to a home address via this method, the\r\n   * metamorphic initialization code will retrieve whatever initialization code\r\n   * currently resides at the specified address and use it to set up and deploy\r\n   * the desired contract to the home address. Bear in mind that the deployed\r\n   * contract will interpret msg.sender as the address of THIS contract, and not\r\n   * the address of the submitter - if the constructor of the deployed contract\r\n   * uses msg.sender to set up ownership or other variables, you must modify it\r\n   * to accept a constructor argument with the appropriate address, or\r\n   * alternately to hard-code the intended address. Also, if your contract DOES\r\n   * have constructor arguments, remember to include them as ABI-encoded\r\n   * arguments at the end of the initialization code, just as you would when\r\n   * performing a standard deploy. You may want to provide the salt and\r\n   * submitter to `setDerivedReverseLookup` in order to find the salt,\r\n   * submitter, and derived key using only the home address to prevent\r\n   * accidentally losing them.\r\n   */\r\n  function deriveKeyAndDeployViaExistingRuntimeStorageContract(\r\n    bytes32 salt,\r\n    address initializationRuntimeStorageContract\r\n  )\r\n    external\r\n    payable\r\n    returns (address homeAddress, bytes32 key, bytes32 runtimeCodeHash)\r\n  {\r\n    // Ensure that the supplied runtime storage contract is not empty.\r\n    _validateRuntimeStorageIsNotEmpty(initializationRuntimeStorageContract);\r\n\r\n    // Derive key and prepare to deploy using supplied salt and calling address.\r\n    key = _deriveKeyAndPrepareToDeploy(salt);\r\n\r\n    // Set the initialization runtime storage contract in contract storage.\r\n    _initializationRuntimeStorageContract = initializationRuntimeStorageContract;\r\n\r\n    // Use metamorphic initialization code to deploy contract to home address.\r\n    (homeAddress, runtimeCodeHash) = _deployToHomeAddress(key);\r\n  }\r\n\r\n  /**\r\n   * @notice Mint multiple ERC721 tokens, designated by their keys, to the\r\n   * specified owner. Keys that aren't controlled, or that point to home\r\n   * addresses that are currently deployed, will be skipped.\r\n   * @param owner address The account that will be granted ownership of the\r\n   * ERC721 tokens.\r\n   * @param keys bytes32[] An array of values used to derive each home address.\r\n   * @dev If you plan to use this method regularly or want to keep gas costs to\r\n   * an absolute minimum, and are willing to go without standard ABI encoding,\r\n   * see `batchLock_63efZf` for a more efficient (and unforgiving)\r\n   * implementation. For batch token minting with *derived* keys, see\r\n   * `deriveKeysAndBatchLock`.\r\n   */\r\n  function batchLock(address owner, bytes32[] calldata keys) external {\r\n    // Track each key in the array of keys.\r\n    bytes32 key;\r\n\r\n    // Ensure that the specified owner is a valid ERC721 receiver.\r\n    if (keys.length > 0) {\r\n      _validateOwner(owner, keys[0]);\r\n    }\r\n\r\n    // Iterate through each provided key argument.\r\n    for (uint256 i; i < keys.length; i++) {\r\n      key = keys[i];\r\n\r\n      // Skip if the key currently has a contract deployed to its home address.\r\n      if (!_isNotDeployed(key)) {\r\n        continue;\r\n      }\r\n\r\n      // Skip if the caller is not the controller.\r\n      if (_getController(key) != msg.sender) {\r\n        continue;\r\n      }\r\n\r\n      // Set the exists flag to true and the controller to this contract.\r\n      HomeAddress storage home = _home[key];\r\n      home.exists = true;\r\n      home.controller = address(this);\r\n\r\n      // Emit an event signifying that this contract is now the controller. \r\n      emit NewController(key, address(this));\r\n\r\n      // Mint the ERC721 token to the designated owner.\r\n      _mint(owner, uint256(key));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @notice Mint multiple ERC721 tokens, designated by salts that are hashed\r\n   * with the caller's address to derive each key, to the specified owner.\r\n   * Derived keys that aren't controlled, or that point to home addresses that\r\n   * are currently deployed, will be skipped.\r\n   * @param owner address The account that will be granted ownership of the\r\n   * ERC721 tokens.\r\n   * @param salts bytes32[] An array of values used to derive each key and\r\n   * corresponding home address.\r\n   * @dev See `batchLock` for batch token minting with standard, non-derived\r\n   * keys.\r\n   */\r\n  function deriveKeysAndBatchLock(address owner, bytes32[] calldata salts)\r\n    external\r\n  {\r\n    // Track each key derived from the array of salts.\r\n    bytes32 key;\r\n\r\n    // Ensure that the specified owner is a valid ERC721 receiver.\r\n    if (salts.length > 0) {\r\n      _validateOwner(owner, _deriveKey(salts[0], msg.sender));\r\n    }\r\n\r\n    // Iterate through each provided salt argument.\r\n    for (uint256 i; i < salts.length; i++) {\r\n      // Derive the key using the supplied salt and the calling address.\r\n      key = _deriveKey(salts[i], msg.sender);\r\n\r\n      // Skip if the key currently has a contract deployed to its home address.\r\n      if (!_isNotDeployed(key)) {\r\n        continue;\r\n      }\r\n\r\n      // Skip if the caller is not the controller.\r\n      HomeAddress storage home = _home[key];\r\n      if (home.exists && home.controller != msg.sender) {\r\n        continue;\r\n      }\r\n\r\n      // Set the exists flag to true and the controller to this contract.\r\n      home.exists = true;\r\n      home.controller = address(this);\r\n\r\n      // Emit an event signifying that this contract is now the controller. \r\n      emit NewController(key, address(this));\r\n\r\n      // Mint the ERC721 token to the designated owner.\r\n      _mint(owner, uint256(key));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @notice Safely transfers the ownership of a group of token IDs to another\r\n   * address in a batch. If the target address is a contract, it must implement\r\n   * `onERC721Received`, called upon a safe transfer, and return the magic value\r\n   * `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`;\r\n   * otherwise, or if another error occurs, the entire batch is reverted.\r\n   * Requires msg.sender to be the owner, approved, or operator of the tokens.\r\n   * @param from address The current owner of the tokens.\r\n   * @param to address The account to receive ownership of the given tokens.\r\n   * @param tokenIds uint256[] ID of the tokens to be transferred.\r\n   */\r\n  function safeBatchTransferFrom(\r\n    address from,\r\n    address to,\r\n    uint256[] calldata tokenIds\r\n  )\r\n    external\r\n  {\r\n    // Track each token ID in the batch.\r\n    uint256 tokenId;\r\n\r\n    // Iterate over each supplied token ID.\r\n    for (uint256 i = 0; i < tokenIds.length; i++) {\r\n      // Set the current token ID.\r\n      tokenId = tokenIds[i];\r\n\r\n      // Perform the token transfer.\r\n      safeTransferFrom(from, to, tokenId);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @notice Safely transfers the ownership of a group of token IDs to another\r\n   * address in a batch. If the target address is a contract, it must implement\r\n   * `onERC721Received`, called upon a safe transfer, and return the magic value\r\n   * `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`;\r\n   * otherwise, or if another error occurs, the entire batch is reverted.\r\n   * Requires msg.sender to be the owner, approved, or operator of the tokens.\r\n   * @param from address The current owner of the tokens.\r\n   * @param to address The account to receive ownership of the given tokens.\r\n   * @param tokenIds uint256[] ID of the tokens to be transferred.\r\n   * @param data bytes A data payload to include with each transfer.   \r\n   */\r\n  function safeBatchTransferFrom(\r\n    address from,\r\n    address to,\r\n    uint256[] calldata tokenIds,\r\n    bytes calldata data\r\n  )\r\n    external\r\n  {\r\n    // Track each token ID in the batch.\r\n    uint256 tokenId;\r\n\r\n    // Iterate over each supplied token ID.\r\n    for (uint256 i = 0; i < tokenIds.length; i++) {\r\n      // Set the current token ID.\r\n      tokenId = tokenIds[i];\r\n\r\n      // Perform the token transfer.\r\n      safeTransferFrom(from, to, tokenId, data);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @notice Efficient version of `batchLock` that uses less gas. The first 20\r\n   * bytes of each key are automatically populated using msg.sender, and the\r\n   * remaining key segments are passed in as a packed byte array, using twelve\r\n   * bytes per segment, with a function selector of 0x00000000 followed by a\r\n   * twenty-byte segment for the desired owner of the minted ERC721 tokens. Note\r\n   * that an attempt to lock a key that is not controlled or with its contract\r\n   * already deployed will cause the entire batch to revert. Checks on whether\r\n   * the owner is a valid ERC721 receiver are also skipped, similar to using\r\n   * `transferFrom` instead of `safeTransferFrom`.\r\n   */\r\n  function batchLock_63efZf(/* packed owner and key segments */) external {\r\n    // Get the owner from calldata, located at bytes 4-23 (sig is bytes 0-3).\r\n    address owner;\r\n\r\n    // Determine number of 12-byte key segments in calldata from byte 24 on.\r\n    uint256 passedSaltSegments;\r\n\r\n    // Get the owner and calculate the total number of key segments.\r\n    assembly {\r\n      owner := shr(0x60, calldataload(4))                  // comes after sig\r\n      passedSaltSegments := div(sub(calldatasize, 24), 12) // after sig & owner\r\n    }\r\n\r\n    // Track each key, located at each 12-byte segment from byte 24 on.\r\n    bytes32 key;\r\n\r\n    // Iterate through each provided key segment argument.\r\n    for (uint256 i; i < passedSaltSegments; i++) {\r\n      // Construct keys by concatenating msg.sender with each key segment.\r\n      assembly {\r\n        key := add(                   // Combine msg.sender & provided key.\r\n          shl(0x60, caller),          // Place msg.sender at start of word.\r\n          shr(0xa0, calldataload(add(24, mul(i, 12))))   // Segment at end.\r\n        )\r\n      }\r\n\r\n      // Ensure that the key does not currently have a deployed contract.\r\n      require(_isNotDeployed(key), _ACCOUNT_EXISTS);\r\n\r\n      // Ensure that the caller is the controller of the key.\r\n      HomeAddress storage home = _home[key];\r\n      if (home.exists) {\r\n        require(home.controller == msg.sender, _ONLY_CONTROLLER);\r\n      }\r\n\r\n      // Set the exists flag to true and the controller to this contract.\r\n      home.exists = true;\r\n      home.controller = address(this);\r\n\r\n      // Emit an event signifying that this contract is now the controller. \r\n      emit NewController(key, address(this));\r\n\r\n      // Mint the ERC721 token to the designated owner.\r\n      _mint(owner, uint256(key));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @notice Perform a dry-run of the deployment of a contract using a given key\r\n   * and revert on successful deployment. It cannot be called from outside the\r\n   * contract (even though it is marked as external).\r\n   * @param key bytes32 The unique value used to derive the home address.\r\n   * @dev This contract is called by `_isNotDeployable` in extreme cases where\r\n   * the deployability of the contract cannot be determined conclusively.\r\n   */\r\n  function staticCreate2Check(bytes32 key) external {\r\n    require(\r\n      msg.sender == address(this),\r\n      \"This function can only be called by this contract.\"\r\n    );\r\n\r\n    assembly {\r\n      // Write the 32-byte metamorphic initialization code to scratch space.\r\n      mstore(\r\n        0,\r\n        0x5859385958601c335a585952fa1582838382515af43d3d93833e601e57fd5bf3\r\n      )\r\n\r\n      // Call `CREATE2` using metamorphic init code with supplied key as salt.\r\n      let deploymentAddress := create2(0, 0, 32, key)\r\n\r\n      // Revert and return the metamorphic init code on successful deployment.\r\n      if deploymentAddress {        \r\n        revert(0, 32)\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @notice Submit a key to claim the \"high score\" - the lower the uint160\r\n   * value of the key's home address, the higher the score. The high score\r\n   * holder has the exclusive right to recover lost ether and tokens on this\r\n   * contract.\r\n   * @param key bytes32 The unique value used to derive the home address that\r\n   * will determine the resultant score.\r\n   * @dev The high score must be claimed by a direct key (one that is submitted\r\n   * by setting the first 20 bytes of the key to the address of the submitter)\r\n   * and not by a derived key, and is non-transferrable. If you want to help\r\n   * people recover their lost tokens, you might consider deploying a contract\r\n   * to the high score address (probably a metamorphic one so that you can use\r\n   * the home address later) with your contact information.\r\n   */\r\n  function claimHighScore(bytes32 key) external {\r\n    require(\r\n      msg.sender == address(bytes20(key)),\r\n      \"Only submitters directly encoded in a given key may claim a high score.\"\r\n    );\r\n\r\n    // Derive the \"home address\" of the current high score key.\r\n    address currentHighScore = _getHomeAddress(_highScoreKey);\r\n\r\n    // Derive the \"home address\" of the new high score key.\r\n    address newHighScore = _getHomeAddress(key);\r\n\r\n    // Use addresses to ensure that supplied key is in fact a new high score.\r\n    require(\r\n      uint160(newHighScore) < uint160(currentHighScore),\r\n      \"Submitted high score is not better than the current high score.\"\r\n    );\r\n\r\n    // Set the new high score to the supplied key.\r\n    _highScoreKey = key;\r\n\r\n    // The score is equal to (2^160 - 1) - (\"home address\" of high score key).\r\n    uint256 score = uint256(uint160(-1) - uint160(newHighScore));\r\n\r\n    // Emit an event to signify that a new high score has been reached.\r\n    emit NewHighScore(key, msg.sender, score);\r\n  }\r\n\r\n  /**\r\n   * @notice Transfer any ether or ERC20 tokens that have somehow ended up at\r\n   * this contract by specifying a token address (set to the null address for\r\n   * ether) as well as a recipient address. Only the high score holder can\r\n   * recover lost ether and tokens on this contract.\r\n   * @param token address The contract address of the ERC20 token to recover, or\r\n   * the null address for recovering Ether.\r\n   * @param recipient address payable The account where recovered funds should\r\n   * be transferred.\r\n   * @dev If you are trying to recover funds that were accidentally sent into\r\n   * this contract, see if you can contact the holder of the current high score,\r\n   * found by calling `getHighScore`. Better yet, try to find a new high score\r\n   * yourself!\r\n   */\r\n  function recover(IERC20 token, address payable recipient) external {\r\n    require(\r\n      msg.sender == address(bytes20(_highScoreKey)),\r\n      \"Only the current high score holder may recover tokens.\"\r\n    );\r\n\r\n    if (address(token) == address(0)) {\r\n      // Recover ETH if the token's contract address is set to the null address.\r\n      recipient.transfer(address(this).balance);\r\n    } else {\r\n      // Determine the given ERC20 token balance and transfer to the recipient.\r\n      uint256 balance = token.balanceOf(address(this));\r\n      token.transfer(recipient, balance);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @notice \"View\" function to determine if a contract can currently be\r\n   * deployed to a home address given the corresponding key. A contract is only\r\n   * deployable if no account currently exists at the address - any existing\r\n   * contract must be destroyed via `SELFDESTRUCT` before a new contract can be\r\n   * deployed to a home address. This method does not modify state but is\r\n   * inaccessible via staticcall.\r\n   * @param key bytes32 The unique value used to derive the home address.\r\n   * @return A boolean signifying if a contract can be deployed to the home\r\n   * address that corresponds to the provided key.\r\n   * @dev This will not detect if a contract is not deployable due control\r\n   * having been relinquished on the key.\r\n   */\r\n  function isDeployable(bytes32 key)\r\n    external\r\n    /* view */\r\n    returns (bool deployable)\r\n  {\r\n    deployable = _isNotDeployed(key);\r\n  }\r\n\r\n  /**\r\n   * @notice View function to get the current \"high score\", or the lowest\r\n   * uint160 value of a home address of all keys submitted. The high score\r\n   * holder has the exclusive right to recover lost ether and tokens on this\r\n   * contract.\r\n   * @return The current high score holder, their score, and the submitted key.\r\n   */\r\n  function getHighScore()\r\n    external\r\n    view\r\n    returns (address holder, uint256 score, bytes32 key)\r\n  {\r\n    // Get the key and subbmitter holding the current high score.\r\n    key = _highScoreKey;\r\n    holder = address(bytes20(key));\r\n\r\n    // The score is equal to (2^160 - 1) - (\"home address\" of high score key).\r\n    score = uint256(uint160(-1) - uint160(_getHomeAddress(key)));\r\n  }\r\n\r\n  /**\r\n   * @notice View function to get information on a home address given the\r\n   * corresponding key.\r\n   * @param key bytes32 The unique value used to derive the home address.\r\n   * @return The home address, the current controller of the address, the number\r\n   * of times the home address has been deployed to, and the code hash of the\r\n   * runtime currently found at the home address, if any.\r\n   * @dev There is also an `isDeployable` method for determining if a contract\r\n   * can be deployed to the address, but in extreme cases it must actually\r\n   * perform a dry-run to determine if the contract is deployable, which means\r\n   * that it does not support staticcalls. There is also a convenience method,\r\n   * `hasNeverBeenDeployed`, but the information it conveys can be determined\r\n   * from this method alone as well.\r\n   */\r\n  function getHomeAddressInformation(bytes32 key)\r\n    external\r\n    view\r\n    returns (\r\n      address homeAddress,\r\n      address controller,\r\n      uint256 deploys,\r\n      bytes32 currentRuntimeCodeHash\r\n    )\r\n  {\r\n    // Derive home address and retrieve other information using supplied key.\r\n    homeAddress = _getHomeAddress(key);\r\n    HomeAddress memory home = _home[key];\r\n\r\n    // If the home address has not been seen before, use the default controller.\r\n    if (!home.exists) {\r\n      controller = address(bytes20(key));\r\n    } else {\r\n      controller = home.controller;\r\n    }\r\n\r\n    // Retrieve the count of total deploys to the home address.\r\n    deploys = home.deploys;\r\n\r\n    // Retrieve keccak256 hash of runtime code currently at the home address.\r\n    assembly { currentRuntimeCodeHash := extcodehash(homeAddress) }\r\n  }\r\n\r\n  /**\r\n   * @notice View function to determine if no contract has ever been deployed to\r\n   * a home address given the corresponding key. This can be used to ensure that\r\n   * a given key or corresponding token is \"new\" or not.\r\n   * @param key bytes32 The unique value used to derive the home address.\r\n   * @return A boolean signifying if a contract has never been deployed using\r\n   * the supplied key before.\r\n   */\r\n  function hasNeverBeenDeployed(bytes32 key)\r\n    external\r\n    view\r\n    returns (bool neverBeenDeployed)\r\n  {\r\n    neverBeenDeployed = (_home[key].deploys == 0);\r\n  }\r\n\r\n  /**\r\n   * @notice View function to search for a known key, salt, and/or submitter\r\n   * given a supplied home address. Keys can be controlled directly by an\r\n   * address that matches the first 20 bytes of the key, or they can be derived\r\n   * from a salt and a submitter - if the key is not a derived key, the salt and\r\n   * submitter fields will both have a value of zero.\r\n   * @param homeAddress address The home address to check for key information.\r\n   * @return The key, salt, and/or submitter used to deploy to the home address,\r\n   * assuming they have been submitted to the reverse lookup.\r\n   * @dev To populate these values, call `setReverseLookup` for cases where keys\r\n   * are used directly or are the only value known, or `setDerivedReverseLookup`\r\n   * for cases where keys are derived from a known salt and submitter.\r\n   */\r\n  function reverseLookup(address homeAddress)\r\n    external\r\n    view\r\n    returns (bytes32 key, bytes32 salt, address submitter)\r\n  {\r\n    KeyInformation memory keyInformation = _key[homeAddress];\r\n    key = keyInformation.key;\r\n    salt = keyInformation.salt;\r\n    submitter = keyInformation.submitter;\r\n  }\r\n\r\n  /**\r\n   * @notice View function used by the metamorphic initialization code when\r\n   * deploying a contract to a home address. It returns the address of the\r\n   * runtime storage contract that holds the contract creation code, which the\r\n   * metamorphic creation code then `DELEGATECALL`s into in order to set up the\r\n   * contract and deploy the target runtime code.\r\n   * @return The current runtime storage contract that contains the target\r\n   * contract creation code.\r\n   * @dev This method is not meant to be part of the user-facing contract API,\r\n   * but is rather a mechanism for enabling the deployment of arbitrary code via\r\n   * fixed initialization code. The odd naming is chosen so that function\r\n   * selector will be 0x00000009 - that way, the metamorphic contract can simply\r\n   * use the `PC` opcode in order to push the selector to the stack.\r\n   */\r\n  function getInitializationCodeFromContractRuntime_6CLUNS()\r\n    external\r\n    view\r\n    returns (address initializationRuntimeStorageContract)\r\n  {\r\n    // Return address of contract with initialization code set as runtime code.\r\n    initializationRuntimeStorageContract = _initializationRuntimeStorageContract;\r\n  }\r\n\r\n  /**\r\n   * @notice View function to return an URI for a given token ID. Throws if the\r\n   * token ID does not exist.\r\n   * @param tokenId uint256 ID of the token to query.\r\n   * @return String representing the URI data encoding of JSON metadata.\r\n   * @dev The URI returned by this method takes the following form (with all\r\n   * returns and initial whitespace removed - it's just here for clarity):\r\n   *\r\n   * data:application/json,{\r\n   *   \"name\":\"Home%20Address%20-%200x********************\",\r\n   *   \"description\":\"< ... HomeWork NFT desription ... >\",\r\n   *   \"image\":\"data:image/svg+xml;charset=utf-8;base64,< ... Image ... >\"}\r\n   *\r\n   * where ******************** represents the checksummed home address that the\r\n   * token confers control over.\r\n   */\r\n  function tokenURI(uint256 tokenId)\r\n    external\r\n    view\r\n    returns (string memory)\r\n  {\r\n    // Only return a URI for tokens that exist.\r\n    require(_exists(tokenId), \"A token with the given ID does not exist.\");\r\n\r\n    // Get the home address that the given tokenId corresponds to.\r\n    address homeAddress = _getHomeAddress(bytes32(tokenId));\r\n\r\n    // Get the checksummed, ascii-encoded representation of the home address.\r\n    string memory asciiHomeAddress = _toChecksummedAsciiString(homeAddress);\r\n    \r\n    bytes memory uriEndSegment = _getTokenURIStorageRuntime();\r\n\r\n    // Insert checksummed address into URI in name and image fields and return.\r\n    return string(\r\n      abi.encodePacked(      // Concatenate all the string segments together.\r\n        _URI_START_SEGMENT,  // Data URI ID and initial formatting is constant.\r\n        asciiHomeAddress,    // Checksummed home address is in the name field.\r\n        uriEndSegment        // Description, image, and formatting is constant.\r\n      )\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @notice Pure function to get the token name.\r\n   * @return String representing the token name.\r\n   */\r\n  function name() external pure returns (string memory) {\r\n    return _NAME;\r\n  }\r\n\r\n  /**\r\n   * @notice Pure function to get the token symbol.\r\n   * @return String representing the token symbol.\r\n   */\r\n  function symbol() external pure returns (string memory) {\r\n    return _SYMBOL;\r\n  }\r\n\r\n  /**\r\n   * @notice Pure function to determine the key that is derived from a given\r\n   * salt and submitting address.\r\n   * @param salt bytes32 The salt value that is used to derive the key.\r\n   * @param submitter address The submitter of the salt value used to derive the\r\n   * key.\r\n   * @return The derived key.\r\n   */\r\n  function getDerivedKey(bytes32 salt, address submitter)\r\n    external\r\n    pure\r\n    returns (bytes32 key)\r\n  {\r\n    // Derive the key using the supplied salt and submitter.\r\n    key = _deriveKey(salt, submitter);\r\n  }\r\n\r\n  /**\r\n   * @notice Pure function to determine the home address that corresponds to\r\n   * a given key.\r\n   * @param key bytes32 The unique value used to derive the home address.\r\n   * @return The home address.\r\n   */\r\n  function getHomeAddress(bytes32 key)\r\n    external\r\n    pure\r\n    returns (address homeAddress)\r\n  {\r\n    // Derive the home address using the supplied key.\r\n    homeAddress = _getHomeAddress(key);\r\n  }\r\n\r\n  /**\r\n   * @notice Pure function for retrieving the metamorphic initialization code\r\n   * used to deploy arbitrary contracts to home addresses. Provided for easy\r\n   * verification and for use in other applications.\r\n   * @return The 32-byte metamorphic initialization code.\r\n   * @dev This metamorphic init code works via the \"metamorphic delegator\"\r\n   * mechanism, which is explained in greater detail at `_deployToHomeAddress`.\r\n   */\r\n  function getMetamorphicDelegatorInitializationCode()\r\n    external\r\n    pure\r\n    returns (bytes32 metamorphicDelegatorInitializationCode)\r\n  {\r\n    metamorphicDelegatorInitializationCode = _HOME_INIT_CODE;\r\n  }\r\n\r\n  /**\r\n   * @notice Pure function for retrieving the keccak256 of the metamorphic\r\n   * initialization code used to deploy arbitrary contracts to home addresses.\r\n   * This is the value that you should use, along with this contract's address\r\n   * and a caller address that you control, to mine for an partucular type of\r\n   * home address (such as one at a compact or gas-efficient address).\r\n   * @return The keccak256 hash of the metamorphic initialization code.\r\n   */\r\n  function getMetamorphicDelegatorInitializationCodeHash()\r\n    external\r\n    pure\r\n    returns (bytes32 metamorphicDelegatorInitializationCodeHash)\r\n  {\r\n    metamorphicDelegatorInitializationCodeHash = _HOME_INIT_CODE_HASH;\r\n  }\r\n\r\n  /**\r\n   * @notice Pure function for retrieving the prelude that will be inserted\r\n   * ahead of the code payload in order to deploy a runtime storage contract.\r\n   * @return The 11-byte \"arbitrary runtime\" prelude.\r\n   */\r\n  function getArbitraryRuntimeCodePrelude()\r\n    external\r\n    pure\r\n    returns (bytes11 prelude)\r\n  {\r\n    prelude = _ARBITRARY_RUNTIME_PRELUDE;\r\n  }\r\n\r\n  /**\r\n   * @notice Internal function for deploying a runtime storage contract given a\r\n   * particular payload.\r\n   * @return The address of the runtime storage contract.\r\n   * @dev To take the provided code payload and deploy a contract with that\r\n   * payload as its runtime code, use the following prelude:\r\n   *\r\n   * 0x600b5981380380925939f3...\r\n   *\r\n   * 00  60  push1 0b      [11 -> offset]\r\n   * 02  59  msize         [offset, 0]\r\n   * 03  81  dup2          [offset, 0, offset]\r\n   * 04  38  codesize      [offset, 0, offset, codesize]\r\n   * 05  03  sub           [offset, 0, codesize - offset]\r\n   * 06  80  dup1          [offset, 0, codesize - offset, codesize - offset]\r\n   * 07  92  swap3         [codesize - offset, 0, codesize - offset, offset]\r\n   * 08  59  msize         [codesize - offset, 0, codesize - offset, offset, 0]\r\n   * 09  39  codecopy      [codesize - offset, 0] <init_code_in_runtime>\r\n   * 10  f3  return        [] *init_code_in_runtime*\r\n   * ... init_code\r\n   */\r\n  function _deployRuntimeStorageContract(bytes memory payload)\r\n    internal\r\n    returns (address runtimeStorageContract)\r\n  {\r\n    // Construct the contract creation code using the prelude and the payload.\r\n    bytes memory runtimeStorageContractCreationCode = abi.encodePacked(\r\n      _ARBITRARY_RUNTIME_PRELUDE,\r\n      payload\r\n    );\r\n\r\n    assembly {\r\n      // Get the location and length of the newly-constructed creation code.\r\n      let encoded_data := add(0x20, runtimeStorageContractCreationCode)\r\n      let encoded_size := mload(runtimeStorageContractCreationCode)\r\n\r\n      // Deploy the runtime storage contract via standard `CREATE`.\r\n      runtimeStorageContract := create(0, encoded_data, encoded_size)\r\n\r\n      // Pass along revert message if the contract did not deploy successfully.\r\n      if iszero(runtimeStorageContract) {\r\n        returndatacopy(0, 0, returndatasize)\r\n        revert(0, returndatasize)\r\n      }\r\n    }\r\n\r\n    // Emit an event with address of newly-deployed runtime storage contract.\r\n    emit NewRuntimeStorageContract(runtimeStorageContract, keccak256(payload));\r\n  }\r\n\r\n  /**\r\n   * @notice Internal function for deploying arbitrary contract code to the home\r\n   * address corresponding to a suppied key via metamorphic initialization code.\r\n   * @return The home address and the hash of the deployed runtime code.\r\n   * @dev This deployment method uses the \"metamorphic delegator\" pattern, where\r\n   * it will retrieve the address of the contract that contains the target\r\n   * initialization code, then delegatecall into it, which executes the\r\n   * initialization code stored there and returns the runtime code (or reverts).\r\n   * Then, the runtime code returned by the delegatecall is returned, and since\r\n   * we are still in the initialization context, it will be set as the runtime\r\n   * code of the metamorphic contract. The 32-byte metamorphic initialization\r\n   * code is as follows:\r\n   *\r\n   * 0x5859385958601c335a585952fa1582838382515af43d3d93833e601e57fd5bf3\r\n   *\r\n   * 00  58  PC               [0]\r\n   * 01  59  MSIZE            [0, 0]\r\n   * 02  38  CODESIZE         [0, 0, codesize -> 32]\r\n   * returndatac03  59  MSIZE            [0, 0, 32, 0]\r\n   * 04  58  PC               [0, 0, 32, 0, 4]\r\n   * 05  60  PUSH1 0x1c       [0, 0, 32, 0, 4, 28]\r\n   * 07  33  CALLER           [0, 0, 32, 0, 4, 28, caller]\r\n   * 08  5a  GAS              [0, 0, 32, 0, 4, 28, caller, gas]\r\n   * 09  58  PC               [0, 0, 32, 0, 4, 28, caller, gas, 9 -> selector]\r\n   * 10  59  MSIZE            [0, 0, 32, 0, 4, 28, caller, gas, selector, 0]\r\n   * 11  52  MSTORE           [0, 0, 32, 0, 4, 28, caller, gas] <selector>\r\n   * 12  fa  STATICCALL       [0, 0, 1 => success] <init_in_runtime_address>\r\n   * 13  15  ISZERO           [0, 0, 0]\r\n   * 14  82  DUP3             [0, 0, 0, 0]\r\n   * 15  83  DUP4             [0, 0, 0, 0, 0]\r\n   * 16  83  DUP4             [0, 0, 0, 0, 0, 0]\r\n   * 17  82  DUP3             [0, 0, 0, 0, 0, 0, 0]\r\n   * 18  51  MLOAD            [0, 0, 0, 0, 0, 0, init_in_runtime_address]\r\n   * 19  5a  GAS              [0, 0, 0, 0, 0, 0, init_in_runtime_address, gas]\r\n   * 20  f4  DELEGATECALL     [0, 0, 1 => success] {runtime_code}\r\n   * 21  3d  RETURNDATASIZE   [0, 0, 1 => success, size]\r\n   * 22  3d  RETURNDATASIZE   [0, 0, 1 => success, size, size]\r\n   * 23  93  SWAP4            [size, 0, 1 => success, size, 0]\r\n   * 24  83  DUP4             [size, 0, 1 => success, size, 0, 0]\r\n   * 25  3e  RETURNDATACOPY   [size, 0, 1 => success] <runtime_code>\r\n   * 26  60  PUSH1 0x1e       [size, 0, 1 => success, 30]\r\n   * 28  57  JUMPI            [size, 0]\r\n   * 29  fd  REVERT           [] *runtime_code*\r\n   * 30  5b  JUMPDEST         [size, 0]\r\n   * 31  f3  RETURN           []\r\n   */\r\n  function _deployToHomeAddress(bytes32 key)\r\n    internal\r\n    returns (address homeAddress, bytes32 runtimeCodeHash)\r\n  {    \r\n    assembly {\r\n      // Write the 32-byte metamorphic initialization code to scratch space.\r\n      mstore(\r\n        0,\r\n        0x5859385958601c335a585952fa1582838382515af43d3d93833e601e57fd5bf3\r\n      )\r\n\r\n      // Call `CREATE2` using above init code with the supplied key as the salt.\r\n      homeAddress := create2(callvalue, 0, 32, key)\r\n\r\n      // Pass along revert message if the contract did not deploy successfully.\r\n      if iszero(homeAddress) {\r\n        returndatacopy(0, 0, returndatasize)\r\n        revert(0, returndatasize)\r\n      }\r\n\r\n      // Get the runtime hash of the deployed contract.\r\n      runtimeCodeHash := extcodehash(homeAddress)\r\n    }\r\n\r\n    // Clear the address of the runtime storage contract from storage.\r\n    delete _initializationRuntimeStorageContract;\r\n\r\n    // Emit an event with home address, key, and runtime hash of new contract.\r\n    emit NewResident(homeAddress, key, runtimeCodeHash);\r\n  }\r\n\r\n  /**\r\n   * @notice Internal function for deriving a key given a particular salt and\r\n   * caller and for performing verifications of, and modifications to, the\r\n   * information set on that key.\r\n   * @param salt bytes32 The value used to derive the key.\r\n   * @return The derived key.\r\n   */\r\n  function _deriveKeyAndPrepareToDeploy(bytes32 salt)\r\n    internal\r\n    returns (bytes32 key)\r\n  {\r\n    // Derive the key using the supplied salt and the calling address.\r\n    key = _deriveKey(salt, msg.sender);\r\n\r\n    // Ensure that a contract is not currently deployed to the home address.\r\n    require(_isNotDeployed(key), _ACCOUNT_EXISTS);\r\n\r\n    // Set appropriate controller and increment contract deploy count at once.\r\n    HomeAddress storage home = _home[key];\r\n    if (!home.exists) {\r\n      home.exists = true;\r\n      home.controller = msg.sender;\r\n      home.deploys += 1;\r\n\r\n      // Emit an event signifying that this contract is now the controller. \r\n      emit NewController(key, msg.sender);\r\n    \r\n    } else {\r\n      home.deploys += 1;\r\n    }\r\n\r\n    // Ensure that the caller is the designated controller before proceeding.\r\n    require(home.controller == msg.sender, _ONLY_CONTROLLER);\r\n  }\r\n\r\n  /**\r\n   * @notice Internal function for verifying that an owner that cannot accept\r\n   * ERC721 tokens has not been supplied.\r\n   * @param owner address The specified owner.\r\n   * @param key bytes32 The unique value used to derive the home address.\r\n   */\r\n  function _validateOwner(address owner, bytes32 key) internal {\r\n    // Ensure that the specified owner is a valid ERC721 receiver.\r\n    require(\r\n      _checkOnERC721Received(address(0), owner, uint256(key), bytes(\"\")),\r\n      \"Owner must be an EOA or a contract that implements `onERC721Received`.\"\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @notice Internal \"view\" function for determining if a contract currently\r\n   * exists at a given home address corresponding to a particular key.\r\n   * @param key bytes32 The unique value used to derive the home address.\r\n   * @return A boolean signifying whether the home address has a contract\r\n   * deployed or not.\r\n   */\r\n  function _isNotDeployed(bytes32 key)\r\n    internal\r\n    /* view */\r\n    returns (bool notDeployed)\r\n  {\r\n    // Derive the home address using the supplied key.\r\n    address homeAddress = _getHomeAddress(key);\r\n\r\n    // Check whether account at home address is non-existent using EXTCODEHASH.\r\n    bytes32 hash;\r\n    assembly { hash := extcodehash(homeAddress) }\r\n\r\n    // Account does not exist, and contract is not deployed, if hash equals 0.\r\n    if (hash == bytes32(0)) {\r\n      return true;\r\n    }\r\n\r\n    // Contract is deployed (notDeployed = false) if codesize is greater than 0.\r\n    uint256 size;\r\n    assembly { size := extcodesize(homeAddress) }\r\n    if (size > 0) {\r\n      return false;\r\n    }\r\n\r\n    // Declare variable to move current runtime storage from storage to memory.\r\n    address currentStorage;\r\n\r\n    // Set runtime storage contract to null address temporarily if necessary.\r\n    if (_initializationRuntimeStorageContract != address(0)) {\r\n      // Place the current runtime storage contract address in memory.\r\n      currentStorage = _initializationRuntimeStorageContract;\r\n      \r\n      // Remove the existing runtime storage contract address from storage.\r\n      delete _initializationRuntimeStorageContract;\r\n    }\r\n\r\n    // Set gas to use when performing dry-run deployment (future-proof a bit).\r\n    uint256 checkGas = 27000 + (block.gaslimit / 1000);\r\n    \r\n    // As a last resort, deploy a contract to the address and revert on success.\r\n    (bool contractExists, bytes memory code) = address(this).call.gas(checkGas)(\r\n      abi.encodeWithSelector(this.staticCreate2Check.selector, key)\r\n    );\r\n\r\n    // Place runtime storage contract back in storage if necessary.\r\n    if (currentStorage != address(0)) {\r\n      _initializationRuntimeStorageContract = currentStorage;\r\n    }\r\n\r\n    // Check revert string to ensure failure is due to successful deployment.\r\n    bytes32 revertMessage;\r\n    assembly { revertMessage := mload(add(code, 32)) }\r\n\r\n    // Contract is not deployed if `staticCreate2Check` reverted with message.\r\n    notDeployed = !contractExists && revertMessage == _HOME_INIT_CODE;\r\n  }\r\n\r\n  /**\r\n   * @notice Internal view function for verifying that a restricted controller\r\n   * has not been supplied.\r\n   * @param controller address The specified controller.\r\n   * @param key bytes32 The unique value used to derive the home address.\r\n   */\r\n  function _validateController(address controller, bytes32 key) internal view {\r\n    // Prevent the controller from being set to prohibited account values.\r\n    require(\r\n      controller != address(0),\r\n      \"The null address may not be set as the controller using this function.\"\r\n    );\r\n    require(\r\n      controller != address(this),\r\n      \"This contract may not be set as the controller using this function.\"\r\n    );\r\n    require(\r\n      controller != _getHomeAddress(key),\r\n      \"Home addresses cannot be set as the controller of themselves.\"\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @notice Internal view function for verifying that a supplied runtime\r\n   * storage contract is not empty.\r\n   * @param target address The runtime storage contract.\r\n   */\r\n  function _validateRuntimeStorageIsNotEmpty(address target) internal view {\r\n    // Ensure that the runtime storage contract is not empty.\r\n    require(\r\n      target.isContract(),\r\n      \"No runtime code found at the supplied runtime storage address.\"\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @notice Internal view function for retrieving the controller of a home\r\n   * address corresponding to a particular key.\r\n   * @param key bytes32 The unique value used to derive the home address.\r\n   * @return The controller of the home address corresponding to the supplied\r\n   * key.\r\n   */\r\n  function _getController(bytes32 key)\r\n    internal\r\n    view\r\n    returns (address controller)\r\n  {\r\n    // Get controller from mapping, defaulting to first 20 bytes of the key.\r\n    HomeAddress memory home = _home[key];\r\n    if (!home.exists) {\r\n      controller = address(bytes20(key));\r\n    } else {\r\n      controller = home.controller;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @notice Internal view function for getting the runtime code at the tokenURI\r\n   * data storage address.\r\n   * @return The runtime code at the tokenURI storage address.\r\n   */\r\n  function _getTokenURIStorageRuntime()\r\n    internal\r\n    view\r\n    returns (bytes memory runtime)\r\n  {\r\n    // Bring the tokenURI storage address into memory for use in assembly block.\r\n    address target = _URI_END_SEGMENT_STORAGE;\r\n    \r\n    assembly {\r\n      // Retrieve the size of the external code.\r\n      let size := extcodesize(target)\r\n      \r\n      // Allocate output byte array.\r\n      runtime := mload(0x40)\r\n      \r\n      // Set new \"memory end\" including padding.\r\n      mstore(0x40, add(runtime, and(add(size, 0x3f), not(0x1f))))\r\n      \r\n      // Store length in memory.\r\n      mstore(runtime, size)\r\n      \r\n      // Get the code using extcodecopy.\r\n      extcodecopy(target, add(runtime, 0x20), 0, size)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @notice Internal pure function for calculating a home address given a\r\n   * particular key.\r\n   * @param key bytes32 The unique value used to derive the home address.\r\n   * @return The home address corresponding to the supplied key.\r\n   */\r\n  function _getHomeAddress(bytes32 key)\r\n    internal\r\n    pure\r\n    returns (address homeAddress)\r\n  {\r\n    // Determine the home address by replicating CREATE2 logic.\r\n    homeAddress = address(\r\n      uint160(                       // Downcast to match the address type.\r\n        uint256(                     // Cast to uint to truncate upper digits.\r\n          keccak256(                 // Compute CREATE2 hash using 4 inputs.\r\n            abi.encodePacked(        // Pack all inputs to the hash together.\r\n              _FF_AND_THIS_CONTRACT, // This contract will be the caller.\r\n              key,                   // Pass in the supplied key as the salt.\r\n              _HOME_INIT_CODE_HASH   // The metamorphic init code hash.\r\n            )\r\n          )\r\n        )\r\n      )\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @notice Internal pure function for deriving a key given a particular salt\r\n   * and caller.\r\n   * @param salt bytes32 The value used to derive the key.\r\n   * @param submitter address The submitter of the salt used to derive the key.\r\n   * @return The derived key.\r\n   */\r\n  function _deriveKey(bytes32 salt, address submitter)\r\n    internal\r\n    pure\r\n    returns (bytes32 key)\r\n  {\r\n    // Set the key as the keccak256 hash of the salt and submitter.\r\n    key = keccak256(abi.encodePacked(salt, submitter));\r\n  }\r\n\r\n  /**\r\n   * @notice Internal pure function for converting the bytes representation of\r\n   * an address to an ASCII string. This function is derived from the function\r\n   * at https://ethereum.stackexchange.com/a/56499/48410\r\n   * @param data bytes20 The account address to be converted.\r\n   * @return The account string in ASCII format. Note that leading \"0x\" is not\r\n   * included.\r\n   */\r\n  function _toAsciiString(bytes20 data)\r\n    internal\r\n    pure\r\n    returns (string memory asciiString)\r\n  {\r\n    // Create an in-memory fixed-size bytes array.\r\n    bytes memory asciiBytes = new bytes(40);\r\n\r\n    // Declare variable types.\r\n    uint8 oneByte;\r\n    uint8 leftNibble;\r\n    uint8 rightNibble;\r\n\r\n    // Iterate over bytes, processing left and right nibble in each iteration.\r\n    for (uint256 i = 0; i < data.length; i++) {\r\n      // locate the byte and extract each nibble.\r\n      oneByte = uint8(uint160(data) / (2 ** (8 * (19 - i))));\r\n      leftNibble = oneByte / 16;\r\n      rightNibble = oneByte - 16 * leftNibble;\r\n\r\n      // To convert to ascii characters, add 48 to 0-9 and 87 to a-f.\r\n      asciiBytes[2 * i] = byte(leftNibble + (leftNibble < 10 ? 48 : 87));\r\n      asciiBytes[2 * i + 1] = byte(rightNibble + (rightNibble < 10 ? 48 : 87));\r\n    }\r\n\r\n    asciiString = string(asciiBytes);\r\n  }\r\n\r\n  /**\r\n   * @notice Internal pure function for getting a fixed-size array of whether or\r\n   * not each character in an account will be capitalized in the checksum.\r\n   * @param account address The account to get the checksum capitalization\r\n   * information for.\r\n   * @return A fixed-size array of booleans that signify if each character or\r\n   * \"nibble\" of the hex encoding of the address will be capitalized by the\r\n   * checksum.\r\n   */\r\n  function _getChecksumCapitalizedCharacters(address account)\r\n    internal\r\n    pure\r\n    returns (bool[40] memory characterIsCapitalized)\r\n  {\r\n    // Convert the address to bytes.\r\n    bytes20 addressBytes = bytes20(account);\r\n\r\n    // Hash the address (used to calculate checksum).\r\n    bytes32 hash = keccak256(abi.encodePacked(_toAsciiString(addressBytes)));\r\n\r\n    // Declare variable types.\r\n    uint8 leftNibbleAddress;\r\n    uint8 rightNibbleAddress;\r\n    uint8 leftNibbleHash;\r\n    uint8 rightNibbleHash;\r\n\r\n    // Iterate over bytes, processing left and right nibble in each iteration.\r\n    for (uint256 i; i < addressBytes.length; i++) {\r\n      // locate the byte and extract each nibble for the address and the hash.\r\n      rightNibbleAddress = uint8(addressBytes[i]) % 16;\r\n      leftNibbleAddress = (uint8(addressBytes[i]) - rightNibbleAddress) / 16;\r\n      rightNibbleHash = uint8(hash[i]) % 16;\r\n      leftNibbleHash = (uint8(hash[i]) - rightNibbleHash) / 16;\r\n\r\n      // Set the capitalization flags based on the characters and the checksums.\r\n      characterIsCapitalized[2 * i] = (\r\n        leftNibbleAddress > 9 &&\r\n        leftNibbleHash > 7\r\n      );\r\n      characterIsCapitalized[2 * i + 1] = (\r\n        rightNibbleAddress > 9 &&\r\n        rightNibbleHash > 7\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @notice Internal pure function for converting the bytes representation of\r\n   * an address to a checksummed ASCII string.\r\n   * @param account address The account address to be converted.\r\n   * @return The checksummed account string in ASCII format. Note that leading\r\n   * \"0x\" is not included.\r\n   */\r\n  function _toChecksummedAsciiString(address account)\r\n    internal\r\n    pure\r\n    returns (string memory checksummedAsciiString)\r\n  {\r\n    // Get capitalized characters in the checksum.\r\n    bool[40] memory caps = _getChecksumCapitalizedCharacters(account);\r\n\r\n    // Create an in-memory fixed-size bytes array.\r\n    bytes memory asciiBytes = new bytes(40);\r\n\r\n    // Declare variable types.\r\n    uint8 oneByte;\r\n    uint8 leftNibble;\r\n    uint8 rightNibble;\r\n    uint8 leftNibbleOffset;\r\n    uint8 rightNibbleOffset;\r\n\r\n    // Convert account to bytes20.\r\n    bytes20 data = bytes20(account);\r\n\r\n    // Iterate over bytes, processing left and right nibble in each iteration.\r\n    for (uint256 i = 0; i < data.length; i++) {\r\n      // locate the byte and extract each nibble.\r\n      oneByte = uint8(uint160(data) / (2 ** (8 * (19 - i))));\r\n      leftNibble = oneByte / 16;\r\n      rightNibble = oneByte - 16 * leftNibble;\r\n\r\n      // To convert to ascii characters, add 48 to 0-9, 55 to A-F, & 87 to a-f.\r\n      if (leftNibble < 10) {\r\n        leftNibbleOffset = 48;\r\n      } else if (caps[i * 2]) {\r\n        leftNibbleOffset = 55;\r\n      } else {\r\n        leftNibbleOffset = 87;\r\n      }\r\n\r\n      if (rightNibble < 10) {\r\n        rightNibbleOffset = 48;\r\n      } else {\r\n        rightNibbleOffset = caps[(i * 2) + 1] ? 55 : 87; // instrumentation fix\r\n      }\r\n\r\n      asciiBytes[2 * i] = byte(leftNibble + leftNibbleOffset);\r\n      asciiBytes[2 * i + 1] = byte(rightNibble + rightNibbleOffset);\r\n    }\r\n\r\n    checksummedAsciiString = string(asciiBytes);\r\n  }\r\n\r\n  /**\r\n   * @notice Modifier to ensure that a contract is not currently deployed to the\r\n   * home address corresponding to a given key on the decorated function.\r\n   * @param key bytes32 The unique value used to derive the home address.\r\n   */\r\n  modifier onlyEmpty(bytes32 key) {\r\n    require(_isNotDeployed(key), _ACCOUNT_EXISTS);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @notice Modifier to ensure that the caller of the decorated function is the\r\n   * controller of the home address corresponding to a given key.\r\n   * @param key bytes32 The unique value used to derive the home address.\r\n   */\r\n  modifier onlyController(bytes32 key) {\r\n    require(_getController(key) == msg.sender, _ONLY_CONTROLLER);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @notice Modifier to track initial controllers and to count deploys, and to\r\n   * validate that only the designated controller has access to the decorated\r\n   * function.\r\n   * @param key bytes32 The unique value used to derive the home address.\r\n   */\r\n  modifier onlyControllerDeployer(bytes32 key) {\r\n    HomeAddress storage home = _home[key];\r\n\r\n    // Set appropriate controller and increment contract deploy count at once.\r\n    if (!home.exists) {\r\n      home.exists = true;\r\n      home.controller = address(bytes20(key));\r\n      home.deploys += 1;\r\n    } else {\r\n      home.deploys += 1;\r\n    }\r\n\r\n    require(home.controller == msg.sender, _ONLY_CONTROLLER);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @notice Modifier to ensure that only the owner of the supplied ERC721\r\n   * token, or an approved spender, can access the decorated function.\r\n   * @param tokenId uint256 The ID of the ERC721 token.\r\n   */\r\n  modifier onlyTokenOwnerOrApprovedSpender(uint256 tokenId) {\r\n    require(\r\n      _isApprovedOrOwner(msg.sender, tokenId),\r\n      \"Only the token owner or an approved spender may call this function.\"\r\n    );\r\n    _;\r\n  }\r\n}\r\n\r\n/**\r\n * @title HomeWork Deployer (alpha version)\r\n * @author 0age\r\n * @notice This contract is a stripped-down version of HomeWork that is used to\r\n * deploy HomeWork itself.\r\n *   HomeWork Deploy code at runtime: 0x7Cf7708ab4A064B14B02F34aecBd2511f3605395\r\n *   HomeWork Runtime code at:        0x0000000000001b84b1cb32787b0d64758d019317\r\n */\r\ncontract HomeWorkDeployer {\r\n  // Fires when HomeWork has been deployed.\r\n  event HomeWorkDeployment(address homeAddress, bytes32 key);\r\n\r\n  // Fires HomeWork's initialization-in-runtime storage contract is deployed.\r\n  event StorageContractDeployment(address runtimeStorageContract);\r\n\r\n  // Allocate storage to track the current initialization-in-runtime contract.\r\n  address private _initializationRuntimeStorageContract;\r\n\r\n  // Once HomeWork has been deployed, disable this contract.\r\n  bool private _disabled;\r\n\r\n  // Write arbitrary code to a contract's runtime using the following prelude.\r\n  bytes11 private constant _ARBITRARY_RUNTIME_PRELUDE = bytes11(\r\n    0x600b5981380380925939f3\r\n  );\r\n\r\n  /**\r\n   * @notice Perform phase one of the deployment.\r\n   * @param code bytes The contract creation code for HomeWork.\r\n   */\r\n  function phaseOne(bytes calldata code) external onlyUntilDisabled {\r\n    // Deploy payload to the runtime storage contract and set the address.\r\n    _initializationRuntimeStorageContract = _deployRuntimeStorageContract(\r\n      bytes32(0),\r\n      code\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @notice Perform phase two of the deployment (tokenURI data).\r\n   * @param key bytes32 The salt to provide to create2.\r\n   */\r\n  function phaseTwo(bytes32 key) external onlyUntilDisabled {\r\n    // Deploy runtime storage contract with the string used to construct end of\r\n    // token URI for issued ERC721s (data URI with a base64-encoded jpeg image).    \r\n    bytes memory code = abi.encodePacked(\r\n      hex\"222c226465736372697074696f6e223a22546869732532304e465425323063616e25\",\r\n      hex\"3230626525323072656465656d65642532306f6e253230486f6d65576f726b253230\",\r\n      hex\"746f2532306772616e7425323061253230636f6e74726f6c6c657225323074686525\",\r\n      hex\"32306578636c75736976652532307269676874253230746f2532306465706c6f7925\",\r\n      hex\"3230636f6e7472616374732532307769746825323061726269747261727925323062\",\r\n      hex\"797465636f6465253230746f25323074686525323064657369676e61746564253230\",\r\n      hex\"686f6d65253230616464726573732e222c22696d616765223a22646174613a696d61\",\r\n      hex\"67652f7376672b786d6c3b636861727365743d7574662d383b6261736536342c5048\",\r\n      hex\"4e325a79423462577875637a30696148523063446f764c336433647935334d793576\",\r\n      hex\"636d63764d6a41774d43397a646d636949485a705a58644362336739496a41674d43\",\r\n      hex\"41784e4451674e7a4969506a787a64486c735a543438495674445245465551567375\",\r\n      hex\"516e747a64484a766132557462476c755a57707661573436636d3931626d52394c6b\",\r\n      hex\"4e37633352796232746c4c5731706447567962476c74615851364d5442394c6b5237\",\r\n      hex\"633352796232746c4c5864705a48526f4f6a4a394c6b56375a6d6c7362446f6a4f57\",\r\n      hex\"4935596a6c686653354765334e30636d39725a5331736157356c593246774f6e4a76\",\r\n      hex\"6457356b66563164506a7776633352356247552b5047636764484a68626e4e6d6233\",\r\n      hex\"4a7450534a74595852796158676f4d5334774d694177494441674d5334774d694134\",\r\n      hex\"4c6a45674d436b69506a78775958526f49475a706247773949694e6d5a6d59694947\",\r\n      hex\"5139496b30784f53417a4d6d677a4e4859794e4567784f586f694c7a34385a79427a\",\r\n      hex\"64484a766132553949694d774d44416949474e7359584e7a50534a4349454d675243\",\r\n      hex\"492b50484268644767675a6d6c7362443069493245314e7a6b7a4f5349675a443069\",\r\n      hex\"545449314944517761446c324d545a6f4c546c364969382b50484268644767675a6d\",\r\n      hex\"6c7362443069497a6b795a444e6d4e5349675a443069545451774944517761446832\",\r\n      hex\"4e3267744f486f694c7a3438634746306143426d615778735053496a5a5745315954\",\r\n      hex\"51334969426b50534a4e4e544d674d7a4a494d546c324c5446734d5459744d545967\",\r\n      hex\"4d5467674d545a364969382b50484268644767675a6d6c7362443069626d39755a53\",\r\n      hex\"49675a4430695454453549444d7961444d30646a49305344453565694976506a7877\",\r\n      hex\"5958526f49475a706247773949694e6c595456684e44636949475139496b30794f53\",\r\n      hex\"41794d5777744e53413164693035614456364969382b5043396e506a77765a7a3438\",\r\n      hex\"5a794230636d467563325a76636d3039496d316864484a70654367754f4451674d43\",\r\n      hex\"4177494334344e4341324e5341314b53492b50484268644767675a44306954546b75\",\r\n      hex\"4e5341794d693435624451754f4341324c6a52684d7934784d69417a4c6a45794944\",\r\n      hex\"41674d4341784c544d674d693479624330304c6a67744e6934305979347a4c544575\",\r\n      hex\"4e4341784c6a59744d69343049444d744d693479656949675a6d6c73624430694932\",\r\n      hex\"517759325a6a5a534976506a78775958526f49475a706247773949694d774d544178\",\r\n      hex\"4d44456949475139496b30304d53343349444d344c6a56734e5334784c5459754e53\",\r\n      hex\"4976506a78775958526f49475139496b30304d693435494449334c6a684d4d546775\",\r\n      hex\"4e4341314f4334784944493049445979624449784c6a67744d6a63754d7941794c6a\",\r\n      hex\"4d744d693434656949675932786863334d39496b55694c7a3438634746306143426d\",\r\n      hex\"615778735053496a4d4445774d5441784969426b50534a4e4e444d754e4341794f53\",\r\n      hex\"347a624330304c6a63674e5334344969382b50484268644767675a44306954545132\",\r\n      hex\"4c6a67674d7a4a6a4d793479494449754e6941344c6a63674d533479494445794c6a\",\r\n      hex\"45744d793479637a4d754e6930354c6a6b754d7930784d693431624330314c6a4567\",\r\n      hex\"4e6934314c5449754f4330754d5330754e7930794c6a63674e5334784c5459754e57\",\r\n      hex\"4d744d7934794c5449754e6930344c6a63744d5334794c5445794c6a45674d793479\",\r\n      hex\"6379307a4c6a59674f5334354c53347a494445794c6a556949474e7359584e7a5053\",\r\n      hex\"4a464969382b50484268644767675a6d6c7362443069493245314e7a6b7a4f534967\",\r\n      hex\"5a443069545449334c6a4d674d6a5a734d5445754f4341784e53343349444d754e43\",\r\n      hex\"41794c6a51674f533478494445304c6a51744d793479494449754d79307849433433\",\r\n      hex\"4c5445774c6a49744d544d754e6930784c6a4d744d7934354c5445784c6a67744d54\",\r\n      hex\"55754e336f694c7a3438634746306143426b50534a4e4d5449674d546b754f577731\",\r\n      hex\"4c6a6b674e793435494445774c6a49744e7934324c544d754e4330304c6a567a4e69\",\r\n      hex\"34344c5455754d5341784d4334334c5451754e574d77494441744e6934324c544d74\",\r\n      hex\"4d544d754d7941784c6a46544d5449674d546b754f5341784d6941784f5334356569\",\r\n      hex\"49675932786863334d39496b55694c7a34385a79426d6157787350534a756232356c\",\r\n      hex\"4969427a64484a766132553949694d774d44416949474e7359584e7a50534a434945\",\r\n      hex\"4d675243492b50484268644767675a44306954545579494455344c6a6c4d4e444175\",\r\n      hex\"4f5341304d7934796243307a4c6a45744d69347a4c5445774c6a59744d5451754e79\",\r\n      hex\"30794c6a6b674d693479494445774c6a59674d5451754e7941784c6a45674d793432\",\r\n      hex\"494445784c6a55674d5455754e58704e4d5449754e5341784f533434624455754f43\",\r\n      hex\"4134494445774c6a4d744e7934304c544d754d7930304c6a5a7a4e6934354c545567\",\r\n      hex\"4d5441754f4330304c6a4e6a4d4341774c5459754e69307a4c6a45744d544d754d79\",\r\n      hex\"3435637930784d43347a494463754e4330784d43347a494463754e4870744c544975\",\r\n      hex\"4e6941794c6a6c734e433433494459754e574d744c6a55674d53347a4c5445754e79\",\r\n      hex\"41794c6a45744d7941794c6a4a734c5451754e7930324c6a566a4c6a4d744d533430\",\r\n      hex\"494445754e6930794c6a51674d7930794c6a4a364969382b50484268644767675a44\",\r\n      hex\"3069545451784c6a4d674d7a67754e5777314c6a45744e6934316253307a4c6a5574\",\r\n      hex\"4d693433624330304c6a59674e533434625467754d53307a4c6a466a4d7934794944\",\r\n      hex\"49754e6941344c6a63674d533479494445794c6a45744d793479637a4d754e693035\",\r\n      hex\"4c6a6b754d7930784d693431624330314c6a45674e6934314c5449754f4330754d53\",\r\n      hex\"30754f4330794c6a63674e5334784c5459754e574d744d7934794c5449754e693034\",\r\n      hex\"4c6a63744d5334794c5445794c6a45674d7934794c544d754e4341304c6a4d744d79\",\r\n      hex\"343249446b754f5330754d7941784d6934314969426a6247467a637a306952694976\",\r\n      hex\"506a78775958526f49475139496b307a4d433434494451304c6a524d4d546b674e54\",\r\n      hex\"67754f57773049444d674d5441744d5449754e7949675932786863334d39496b5969\",\r\n      hex\"4c7a34384c32632b5043396e506a777663335a6e50673d3d227d\"\r\n    ); /* \",\"description\":\"This%20NFT%20can%20be%20redeemed%20on%20HomeWork%20\r\n          to%20grant%20a%20controller%20the%20exclusive%20right%20to%20deploy%20\r\n          contracts%20with%20arbitrary%20bytecode%20to%20the%20designated%20home\r\n          %20address.\",\"image\":\"data:image/svg+xml;charset=utf-8;base64,...\"} */\r\n\r\n    // Deploy payload to the runtime storage contract.\r\n    _deployRuntimeStorageContract(key, code);\r\n  }\r\n\r\n  /**\r\n   * @notice Perform phase three of the deployment and disable this contract.\r\n   * @param key bytes32 The salt to provide to create2.\r\n   */\r\n  function phaseThree(bytes32 key) external onlyUntilDisabled {\r\n    // Use metamorphic initialization code to deploy contract to home address.\r\n    _deployToHomeAddress(key);\r\n\r\n    // Disable this contract from here on out - use HomeWork itself instead.\r\n    _disabled = true;\r\n  }\r\n\r\n  /**\r\n   * @notice View function used by the metamorphic initialization code when\r\n   * deploying a contract to a home address. It returns the address of the\r\n   * runtime storage contract that holds the contract creation code, which the\r\n   * metamorphic creation code then `DELEGATECALL`s into in order to set up the\r\n   * contract and deploy the target runtime code.\r\n   * @return The current runtime storage contract that contains the target\r\n   * contract creation code.\r\n   * @dev This method is not meant to be part of the user-facing contract API,\r\n   * but is rather a mechanism for enabling the deployment of arbitrary code via\r\n   * fixed initialization code. The odd naming is chosen so that function\r\n   * selector will be 0x00000009 - that way, the metamorphic contract can simply\r\n   * use the `PC` opcode in order to push the selector to the stack.\r\n   */\r\n  function getInitializationCodeFromContractRuntime_6CLUNS()\r\n    external\r\n    view\r\n    returns (address initializationRuntimeStorageContract)\r\n  {\r\n    // Return address of contract with initialization code set as runtime code.\r\n    initializationRuntimeStorageContract = _initializationRuntimeStorageContract;\r\n  }\r\n\r\n  /**\r\n   * @notice Internal function for deploying a runtime storage contract given a\r\n   * particular payload.\r\n   * @dev To take the provided code payload and deploy a contract with that\r\n   * payload as its runtime code, use the following prelude:\r\n   *\r\n   * 0x600b5981380380925939f3...\r\n   *\r\n   * 00  60  push1 0b      [11 -> offset]\r\n   * 02  59  msize         [offset, 0]\r\n   * 03  81  dup2          [offset, 0, offset]\r\n   * 04  38  codesize      [offset, 0, offset, codesize]\r\n   * 05  03  sub           [offset, 0, codesize - offset]\r\n   * 06  80  dup1          [offset, 0, codesize - offset, codesize - offset]\r\n   * 07  92  swap3         [codesize - offset, 0, codesize - offset, offset]\r\n   * 08  59  msize         [codesize - offset, 0, codesize - offset, offset, 0]\r\n   * 09  39  codecopy      [codesize - offset, 0] <init_code_in_runtime>\r\n   * 10  f3  return        [] *init_code_in_runtime*\r\n   * ... init_code\r\n   */\r\n  function _deployRuntimeStorageContract(bytes32 key, bytes memory payload)\r\n    internal\r\n    returns (address runtimeStorageContract)\r\n  {\r\n    // Construct the contract creation code using the prelude and the payload.\r\n    bytes memory runtimeStorageContractCreationCode = abi.encodePacked(\r\n      _ARBITRARY_RUNTIME_PRELUDE,\r\n      payload\r\n    );\r\n\r\n    assembly {\r\n      // Get the location and length of the newly-constructed creation code.\r\n      let encoded_data := add(0x20, runtimeStorageContractCreationCode)\r\n      let encoded_size := mload(runtimeStorageContractCreationCode)\r\n\r\n      // Deploy the runtime storage contract via `CREATE2`.\r\n      runtimeStorageContract := create2(0, encoded_data, encoded_size, key)\r\n\r\n      // Pass along revert message if the contract did not deploy successfully.\r\n      if iszero(runtimeStorageContract) {\r\n        returndatacopy(0, 0, returndatasize)\r\n        revert(0, returndatasize)\r\n      }\r\n    }\r\n\r\n    // Emit an event with address of newly-deployed runtime storage contract.\r\n    emit StorageContractDeployment(runtimeStorageContract);\r\n  }\r\n\r\n  /**\r\n   * @notice Internal function for deploying arbitrary contract code to the home\r\n   * address corresponding to a suppied key via metamorphic initialization code.\r\n   * @dev This deployment method uses the \"metamorphic delegator\" pattern, where\r\n   * it will retrieve the address of the contract that contains the target\r\n   * initialization code, then delegatecall into it, which executes the\r\n   * initialization code stored there and returns the runtime code (or reverts).\r\n   * Then, the runtime code returned by the delegatecall is returned, and since\r\n   * we are still in the initialization context, it will be set as the runtime\r\n   * code of the metamorphic contract. The 32-byte metamorphic initialization\r\n   * code is as follows:\r\n   *\r\n   * 0x5859385958601c335a585952fa1582838382515af43d3d93833e601e57fd5bf3\r\n   *\r\n   * 00  58  PC               [0]\r\n   * 01  59  MSIZE            [0, 0]\r\n   * 02  38  CODESIZE         [0, 0, codesize -> 32]\r\n   * returndatac03  59  MSIZE            [0, 0, 32, 0]\r\n   * 04  58  PC               [0, 0, 32, 0, 4]\r\n   * 05  60  PUSH1 0x1c       [0, 0, 32, 0, 4, 28]\r\n   * 07  33  CALLER           [0, 0, 32, 0, 4, 28, caller]\r\n   * 08  5a  GAS              [0, 0, 32, 0, 4, 28, caller, gas]\r\n   * 09  58  PC               [0, 0, 32, 0, 4, 28, caller, gas, 9 -> selector]\r\n   * 10  59  MSIZE            [0, 0, 32, 0, 4, 28, caller, gas, selector, 0]\r\n   * 11  52  MSTORE           [0, 0, 32, 0, 4, 28, caller, gas] <selector>\r\n   * 12  fa  STATICCALL       [0, 0, 1 => success] <init_in_runtime_address>\r\n   * 13  15  ISZERO           [0, 0, 0]\r\n   * 14  82  DUP3             [0, 0, 0, 0]\r\n   * 15  83  DUP4             [0, 0, 0, 0, 0]\r\n   * 16  83  DUP4             [0, 0, 0, 0, 0, 0]\r\n   * 17  82  DUP3             [0, 0, 0, 0, 0, 0, 0]\r\n   * 18  51  MLOAD            [0, 0, 0, 0, 0, 0, init_in_runtime_address]\r\n   * 19  5a  GAS              [0, 0, 0, 0, 0, 0, init_in_runtime_address, gas]\r\n   * 20  f4  DELEGATECALL     [0, 0, 1 => success] {runtime_code}\r\n   * 21  3d  RETURNDATASIZE   [0, 0, 1 => success, size]\r\n   * 22  3d  RETURNDATASIZE   [0, 0, 1 => success, size, size]\r\n   * 23  93  SWAP4            [size, 0, 1 => success, size, 0]\r\n   * 24  83  DUP4             [size, 0, 1 => success, size, 0, 0]\r\n   * 25  3e  RETURNDATACOPY   [size, 0, 1 => success] <runtime_code>\r\n   * 26  60  PUSH1 0x1e       [size, 0, 1 => success, 30]\r\n   * 28  57  JUMPI            [size, 0]\r\n   * 29  fd  REVERT           [] *runtime_code*\r\n   * 30  5b  JUMPDEST         [size, 0]\r\n   * 31  f3  RETURN           []\r\n   */\r\n  function _deployToHomeAddress(bytes32 key) internal {\r\n    // Declare a variable for the home address.\r\n    address homeAddress;\r\n\r\n    assembly {\r\n      // Write the 32-byte metamorphic initialization code to scratch space.\r\n      mstore(\r\n        0,\r\n        0x5859385958601c335a585952fa1582838382515af43d3d93833e601e57fd5bf3\r\n      )\r\n\r\n      // Call `CREATE2` using above init code with the supplied key as the salt.\r\n      homeAddress := create2(callvalue, 0, 32, key)\r\n\r\n      // Pass along revert message if the contract did not deploy successfully.\r\n      if iszero(homeAddress) {\r\n        returndatacopy(0, 0, returndatasize)\r\n        revert(0, returndatasize)\r\n      }\r\n    }\r\n\r\n    // Clear the address of the runtime storage contract from storage.\r\n    delete _initializationRuntimeStorageContract;\r\n\r\n    // Emit an event with home address and key for the newly-deployed contract.\r\n    emit HomeWorkDeployment(homeAddress, key);\r\n  }\r\n\r\n  /**\r\n   * @notice Modifier to disable the contract once deployment is complete.\r\n   */\r\n  modifier onlyUntilDisabled() {\r\n    require(!_disabled, \"Contract is disabled.\");\r\n    _;\r\n  }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"getInitializationCodeFromContractRuntime_6CLUNS\",\"outputs\":[{\"name\":\"initializationRuntimeStorageContract\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"key\",\"type\":\"bytes32\"}],\"name\":\"phaseTwo\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"key\",\"type\":\"bytes32\"}],\"name\":\"phaseThree\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"code\",\"type\":\"bytes\"}],\"name\":\"phaseOne\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"homeAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"key\",\"type\":\"bytes32\"}],\"name\":\"HomeWorkDeployment\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"runtimeStorageContract\",\"type\":\"address\"}],\"name\":\"StorageContractDeployment\",\"type\":\"event\"}]","ContractName":"HomeWorkDeployer","CompilerVersion":"v0.5.9+commit.e560f70d","OptimizationUsed":"1","Runs":"10000","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://48a66ab8569fdd04fe8dffff1a2e503ade4c58658ca224808fff3891420b7082"}]}