{"status":"1","message":"OK","result":[{"SourceCode":"// File: contracts/interfaces/IERC1620.sol\r\n\r\npragma solidity 0.5.8;\r\n\r\n/// @title ERC-1620 Money Streaming Standard\r\n/// @dev See https://github.com/ethereum/eips/issues/1620\r\n\r\ninterface IERC1620 {\r\n\r\n    /// @dev This emits when streams are successfully created and added\r\n    ///  in the mapping object.\r\n    event CreateStream(\r\n        uint256 indexed streamId,\r\n        address indexed sender,\r\n        address indexed recipient,\r\n        address tokenAddress,\r\n        uint256 startBlock,\r\n        uint256 stopBlock,\r\n        uint256 payment,\r\n        uint256 interval\r\n    );\r\n\r\n    /// @dev This emits when the receiver of a stream withdraws a portion\r\n    ///  or all of their available funds from an ongoing stream, without\r\n    ///  stopping it. Note that we don't emit both the sender and the\r\n    ///  recipient's balance because only the recipient can withdraw\r\n    ///  while the stream is active.\r\n    event WithdrawFromStream(\r\n        uint256 indexed streamId,\r\n        address indexed recipient,\r\n        uint256 amount\r\n    );\r\n\r\n    /// @dev This emits when a stream is successfully redeemed and\r\n    ///  all involved parties get their share of the available funds.\r\n    event RedeemStream(\r\n        uint256 indexed streamId,\r\n        address indexed sender,\r\n        address indexed recipient,\r\n        uint256 senderAmount,\r\n        uint256 recipientAmount\r\n    );\r\n\r\n    /// @dev This emits when an update is successfully committed by\r\n    ///  one of the involved parties.\r\n    event ConfirmUpdate(\r\n        uint256 indexed streamId,\r\n        address indexed confirmer,\r\n        address newTokenAddress,\r\n        uint256 newStopBlock,\r\n        uint256 newPayment,\r\n        uint256 newInterval\r\n    );\r\n\r\n    /// @dev This emits when one of the involved parties revokes\r\n    ///  a proposed update to the stream.\r\n    event RevokeUpdate(\r\n        uint256 indexed streamId,\r\n        address indexed revoker,\r\n        address newTokenAddress,\r\n        uint256 newStopBlock,\r\n        uint256 newPayment,\r\n        uint256 newInterval\r\n    );\r\n\r\n    /// @dev This emits when an update (that is, modifications to\r\n    ///  payment rate, starting or stopping block) is successfully\r\n    ///  approved by all involved parties.\r\n    event ExecuteUpdate(\r\n        uint256 indexed streamId,\r\n        address indexed sender,\r\n        address indexed recipient,\r\n        address newTokenAddress,\r\n        uint256 newStopBlock,\r\n        uint256 newPayment,\r\n        uint256 newInterval\r\n    );\r\n\r\n    /// @notice Creates a new stream between `msg.sender` and `_recipient`\r\n    /// @dev Throws unless `msg.value` is exactly\r\n    ///  `_payment * ((_stopBlock - _startBlock) / _interval)`.\r\n    ///  Throws if `_startBlock` is not higher than `block.number`.\r\n    ///  Throws if `_stopBlock` is not higher than `_startBlock`.\r\n    ///  Throws if the total streaming duration `_stopBlock - _startBlock`\r\n    ///  is not a multiple of `_interval`.\r\n    /// @param _recipient The stream sender or the payer\r\n    /// @param _recipient The stream recipient or the payee\r\n    /// @param _tokenAddress The token contract address\r\n    /// @param _startBlock The starting time of the stream\r\n    /// @param _stopBlock The stopping time of the stream\r\n    /// @param _payment How much money moves from sender to recipient\r\n    /// @param _interval How often the `payment` moves from sender to recipient\r\n    function createStream(\r\n        address _sender,\r\n        address _recipient,\r\n        address _tokenAddress,\r\n        uint256 _startBlock,\r\n        uint256 _stopBlock,\r\n        uint256 _payment,\r\n        uint256 _interval\r\n    )\r\n    external;\r\n\r\n    /// @notice Withdraws all or a fraction of the available funds\r\n    /// @dev If the stream ended and the recipient withdraws the deposit in full,\r\n    ///  the stream object gets deleted after this operation\r\n    ///  to save gas for the user and optimise contract storage.\r\n    ///  Throws if `_streamId` doesn't point to a valid stream.\r\n    ///  Throws if `msg.sender` is not the recipient of the given `streamId`\r\n    /// @param _streamId The stream to withdraw from\r\n    /// @param _funds The amount of money to withdraw\r\n    function withdrawFromStream(\r\n        uint256 _streamId,\r\n        uint256 _funds\r\n    )\r\n    external;\r\n\r\n    /// @notice Redeems the stream by distributing the funds to the sender and the recipient\r\n    /// @dev The stream object gets deleted after this operation\r\n    ///  to save gas for the user and optimise contract storage.\r\n    ///  Throws if `_streamId` doesn't point to a valid stream.\r\n    ///  Throws unless `msg.sender` is either the sender or the recipient\r\n    ///  of the given `streamId`.\r\n    /// @param _streamId The stream to stop\r\n    function redeemStream(\r\n        uint256 _streamId\r\n    )\r\n    external;\r\n\r\n    /// @notice Signals one party's willingness to update the stream\r\n    /// @dev Throws if `_streamId` doesn't point to a valid stream.\r\n    ///  Not executed prior to everyone agreeing to the new terms.\r\n    ///  In terms of validation, it works exactly the same as the `createStream` function.\r\n    /// @param _streamId The stream to update\r\n    /// @param _tokenAddress The token contract address\r\n    /// @param _stopBlock The new stopping time of the stream\r\n    /// @param _payment How much money moves from sender to recipient\r\n    /// @param _interval How often the `payment` moves from sender to recipient\r\n    function confirmUpdate(\r\n        uint256 _streamId,\r\n        address _tokenAddress,\r\n        uint256 _stopBlock,\r\n        uint256 _payment,\r\n        uint256 _interval\r\n    )\r\n    external;\r\n\r\n    /// @notice Revokes an update proposed by one of the involved parties\r\n    /// @dev Throws if `_streamId` doesn't point to a valid stream. The parameters\r\n    ///  are merely for logging purposes.\r\n    function revokeUpdate(\r\n        uint256 _streamId,\r\n        address _tokenAddress,\r\n        uint256 _stopBlock,\r\n        uint256 _payment,\r\n        uint256 _interval\r\n    )\r\n    external;\r\n\r\n    /// @notice Returns available funds for the given stream id and address\r\n    /// @dev Streams assigned to the zero address are considered invalid, and\r\n    ///  this function throws for queries about the zero address.\r\n    /// @param _streamId The stream for whom to query the balance\r\n    /// @param _addr The address for whom to query the balance\r\n    /// @return The total funds available to `addr` to withdraw\r\n    function balanceOf(\r\n        uint256 _streamId,\r\n        address _addr\r\n    )\r\n    external\r\n    view\r\n    returns (\r\n        uint256 balance\r\n    );\r\n\r\n    /// @notice Returns the full stream data\r\n    /// @dev Throws if `_streamId` doesn't point to a valid stream.\r\n    /// @param _streamId The stream to return data for\r\n    function getStream(\r\n        uint256 _streamId\r\n    )\r\n    external\r\n    view\r\n    returns (\r\n        address _sender,\r\n        address _recipient,\r\n        address _tokenAddress,\r\n        uint256 _balance,\r\n        uint256 _startBlock,\r\n        uint256 _stopBlock,\r\n        uint256 _payment,\r\n        uint256 _interval\r\n    );\r\n}\r\n\r\n// File: contracts/zeppelin/IERC20.sol\r\n\r\npragma solidity 0.5.8;\r\n\r\n/// @title ERC20 interface\r\n/// @author /// OpenZeppelin Community - <maintainers@openzeppelin.org>\r\n/// @dev see https://eips.ethereum.org/EIPS/eip-20\r\n\r\ninterface IERC20 {\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n\r\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address who) external view returns (uint256);\r\n\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: contracts/zeppelin/SafeMath.sol\r\n\r\npragma solidity 0.5.8;\r\n\r\n/// @title SafeMath\r\n/// @author OpenZeppelin Community - <maintainers@openzeppelin.org>\r\n/// @dev Unsigned math operations with safety checks that revert on error\r\n\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Multiplies two unsigned integers, reverts on overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Adds two unsigned integers, reverts on overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\r\n     * reverts when dividing by zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: contracts/Sablier.sol\r\n\r\npragma solidity 0.5.8;\r\n\r\n\r\n\r\n\r\n/// @title Sablier - ERC Money Streaming Implementation\r\n/// @author Paul Berg - <hello@paulrberg.com>\r\n\r\ncontract Sablier is IERC1620 {\r\n    using SafeMath for uint256;\r\n\r\n    /**\r\n     * Types\r\n     */\r\n    struct Timeframe {\r\n        uint256 start;\r\n        uint256 stop;\r\n    }\r\n\r\n    struct Rate {\r\n        uint256 payment;\r\n        uint256 interval;\r\n    }\r\n\r\n    struct Stream {\r\n        address sender;\r\n        address recipient;\r\n        address tokenAddress;\r\n        Timeframe timeframe;\r\n        Rate rate;\r\n        uint256 balance;\r\n    }\r\n\r\n    /**\r\n     * Storage\r\n     */\r\n    mapping(uint256 => Stream) private streams;\r\n    uint256 private streamNonce;\r\n    mapping(uint256 => mapping(address => bool)) private updates;\r\n\r\n    /**\r\n     * Events\r\n     */\r\n    event CreateStream(\r\n        uint256 indexed streamId,\r\n        address indexed sender,\r\n        address indexed recipient,\r\n        address tokenAddress,\r\n        uint256 startBlock,\r\n        uint256 stopBlock,\r\n        uint256 payment,\r\n        uint256 interval,\r\n        uint256 deposit\r\n    );\r\n\r\n    event WithdrawFromStream(\r\n        uint256 indexed streamId,\r\n        address indexed recipient,\r\n        uint256 amount\r\n    );\r\n\r\n    event RedeemStream(\r\n        uint256 indexed streamId,\r\n        address indexed sender,\r\n        address indexed recipient,\r\n        uint256 senderAmount,\r\n        uint256 recipientAmount\r\n    );\r\n\r\n    event ConfirmUpdate(\r\n        uint256 indexed streamId,\r\n        address indexed confirmer,\r\n        address newTokenAddress,\r\n        uint256 newStopBlock,\r\n        uint256 newPayment,\r\n        uint256 newInterval\r\n    );\r\n\r\n    event RevokeUpdate(\r\n        uint256 indexed streamId,\r\n        address indexed revoker,\r\n        address newTokenAddress,\r\n        uint256 newStopBlock,\r\n        uint256 newPayment,\r\n        uint256 newInterval\r\n    );\r\n\r\n    event ExecuteUpdate(\r\n        uint256 indexed streamId,\r\n        address indexed sender,\r\n        address indexed recipient,\r\n        address newTokenAddress,\r\n        uint256 newStopBlock,\r\n        uint256 newPayment,\r\n        uint256 newInterval\r\n    );\r\n\r\n    /*\r\n    * Modifiers\r\n    */\r\n    modifier onlyRecipient(uint256 _streamId) {\r\n        require(\r\n            streams[_streamId].recipient == msg.sender,\r\n            \"only the stream recipient is allowed to perform this action\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier onlySenderOrRecipient(uint256 _streamId) {\r\n        require(\r\n            msg.sender == streams[_streamId].sender ||\r\n            msg.sender == streams[_streamId].recipient,\r\n            \"only the sender or the recipient of the stream can perform this action\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier streamExists(uint256 _streamId) {\r\n        require(\r\n            streams[_streamId].sender != address(0x0), \"stream doesn't exist\");\r\n        _;\r\n    }\r\n\r\n    modifier updateConfirmed(uint256 _streamId, address _addr) {\r\n        require(\r\n            updates[_streamId][_addr] == true,\r\n            \"msg.sender has not confirmed the update\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * Functions\r\n     */\r\n    constructor() public {\r\n        streamNonce = 1;\r\n    }\r\n\r\n    function balanceOf(uint256 _streamId, address _addr)\r\n    public\r\n    view\r\n    streamExists(_streamId)\r\n    returns (uint256 balance)\r\n    {\r\n        Stream memory stream = streams[_streamId];\r\n        uint256 deposit = depositOf(_streamId);\r\n        uint256 delta = deltaOf(_streamId);\r\n        uint256 funds = delta.div(stream.rate.interval).mul(stream.rate.payment);\r\n\r\n        if (stream.balance != deposit)\r\n            funds = funds.sub(deposit.sub(stream.balance));\r\n\r\n        if (_addr == stream.recipient) {\r\n            return funds;\r\n        } else if (_addr == stream.sender) {\r\n            return stream.balance.sub(funds);\r\n        } else {\r\n            return 0;\r\n        }\r\n    }\r\n\r\n    function getStream(uint256 _streamId)\r\n    public\r\n    view\r\n    streamExists(_streamId)\r\n    returns (\r\n        address sender,\r\n        address recipient,\r\n        address tokenAddress,\r\n        uint256 balance,\r\n        uint256 startBlock,\r\n        uint256 stopBlock,\r\n        uint256 payment,\r\n        uint256 interval\r\n    )\r\n    {\r\n        Stream memory stream = streams[_streamId];\r\n        return (\r\n            stream.sender,\r\n            stream.recipient,\r\n            stream.tokenAddress,\r\n            stream.balance,\r\n            stream.timeframe.start,\r\n            stream.timeframe.stop,\r\n            stream.rate.payment,\r\n            stream.rate.interval\r\n        );\r\n    }\r\n\r\n    function getUpdate(uint256 _streamId, address _addr)\r\n    public\r\n    view\r\n    streamExists(_streamId)\r\n    returns (bool active)\r\n    {\r\n        return updates[_streamId][_addr];\r\n    }\r\n\r\n    function createStream(\r\n        address _sender,\r\n        address _recipient,\r\n        address _tokenAddress,\r\n        uint256 _startBlock,\r\n        uint256 _stopBlock,\r\n        uint256 _payment,\r\n        uint256 _interval\r\n    )\r\n        public\r\n    {\r\n        verifyTerms(\r\n            _tokenAddress,\r\n            _startBlock,\r\n            _stopBlock,\r\n            _interval\r\n        );\r\n\r\n        // only ERC20 tokens can be streamed\r\n        uint256 deposit = _stopBlock.sub(_startBlock).div(_interval).mul(_payment);\r\n        IERC20 tokenContract = IERC20(_tokenAddress);\r\n        uint256 allowance = tokenContract.allowance(_sender, address(this));\r\n        require(allowance >= deposit, \"contract not allowed to transfer enough tokens\");\r\n\r\n        // create and log the stream if the deposit is okay\r\n        streams[streamNonce] = Stream({\r\n            balance : deposit,\r\n            sender : _sender,\r\n            recipient : _recipient,\r\n            tokenAddress : _tokenAddress,\r\n            timeframe : Timeframe(_startBlock, _stopBlock),\r\n            rate : Rate(_payment, _interval)\r\n        });\r\n        emit CreateStream(\r\n            streamNonce,\r\n            _sender,\r\n            _recipient,\r\n            _tokenAddress,\r\n            _startBlock,\r\n            _stopBlock,\r\n            _payment,\r\n            _interval,\r\n            deposit\r\n        );\r\n        streamNonce = streamNonce.add(1);\r\n\r\n        // apply Checks-Effects-Interactions\r\n        tokenContract.transferFrom(_sender, address(this), deposit);\r\n    }\r\n\r\n    function withdrawFromStream(\r\n        uint256 _streamId,\r\n        uint256 _amount\r\n    )\r\n    public\r\n    streamExists(_streamId)\r\n    onlyRecipient(_streamId)\r\n    {\r\n        Stream memory stream = streams[_streamId];\r\n        uint256 availableFunds = balanceOf(_streamId, stream.recipient);\r\n        require(availableFunds >= _amount, \"not enough funds\");\r\n\r\n        streams[_streamId].balance = streams[_streamId].balance.sub(_amount);\r\n        emit WithdrawFromStream(_streamId, stream.recipient, _amount);\r\n\r\n        // saving gas\r\n        uint256 deposit = depositOf(_streamId);\r\n        if (_amount == deposit) {\r\n            delete streams[_streamId];\r\n            updates[_streamId][stream.sender] = false;\r\n            updates[_streamId][stream.recipient] = false;\r\n        }\r\n\r\n        // saving gas by checking beforehand\r\n        if (_amount > 0)\r\n            IERC20(stream.tokenAddress).transfer(stream.recipient, _amount);\r\n    }\r\n\r\n    function redeemStream(uint256 _streamId)\r\n    public\r\n    streamExists(_streamId)\r\n    onlySenderOrRecipient(_streamId)\r\n    {\r\n        Stream memory stream = streams[_streamId];\r\n        uint256 senderAmount = balanceOf(_streamId, stream.sender);\r\n        uint256 recipientAmount = balanceOf(_streamId, stream.recipient);\r\n        emit RedeemStream(\r\n            _streamId,\r\n            stream.sender,\r\n            stream.recipient,\r\n            senderAmount,\r\n            recipientAmount\r\n        );\r\n\r\n        // saving gas\r\n        delete streams[_streamId];\r\n        updates[_streamId][stream.sender] = false;\r\n        updates[_streamId][stream.recipient] = false;\r\n\r\n        // reverts when the token address is not an ERC20 contract\r\n        IERC20 tokenContract = IERC20(stream.tokenAddress);\r\n        // saving gas by checking beforehand\r\n        if (recipientAmount > 0)\r\n            tokenContract.transfer(stream.recipient, recipientAmount);\r\n        if (senderAmount > 0)\r\n            tokenContract.transfer(stream.sender, senderAmount);\r\n    }\r\n\r\n    function confirmUpdate(\r\n        uint256 _streamId,\r\n        address _tokenAddress,\r\n        uint256 _stopBlock,\r\n        uint256 _payment,\r\n        uint256 _interval\r\n    )\r\n    public\r\n    streamExists(_streamId)\r\n    onlySenderOrRecipient(_streamId)\r\n    {\r\n        onlyNewTerms(\r\n            _streamId,\r\n            _tokenAddress,\r\n            _stopBlock,\r\n            _payment,\r\n            _interval\r\n        );\r\n        verifyTerms(\r\n            _tokenAddress,\r\n            block.number,\r\n            _stopBlock,\r\n            _interval\r\n        );\r\n\r\n        emit ConfirmUpdate(\r\n            _streamId,\r\n            msg.sender,\r\n            _tokenAddress,\r\n            _stopBlock,\r\n            _payment,\r\n            _interval\r\n        );\r\n        updates[_streamId][msg.sender] = true;\r\n\r\n        executeUpdate(\r\n            _streamId,\r\n            _tokenAddress,\r\n            _stopBlock,\r\n            _payment,\r\n            _interval\r\n        );\r\n    }\r\n\r\n    function revokeUpdate(\r\n        uint256 _streamId,\r\n        address _tokenAddress,\r\n        uint256 _stopBlock,\r\n        uint256 _payment,\r\n        uint256 _interval\r\n    )\r\n        public\r\n        updateConfirmed(_streamId, msg.sender)\r\n    {\r\n        emit RevokeUpdate(\r\n            _streamId,\r\n            msg.sender,\r\n            _tokenAddress,\r\n            _stopBlock,\r\n            _payment,\r\n            _interval\r\n        );\r\n        updates[_streamId][msg.sender] = false;\r\n    }\r\n\r\n    /**\r\n     * Private\r\n     */\r\n    function deltaOf(uint256 _streamId)\r\n    private\r\n    view\r\n    returns (uint256 delta)\r\n    {\r\n        Stream memory stream = streams[_streamId];\r\n        uint256 startBlock = stream.timeframe.start;\r\n        uint256 stopBlock = stream.timeframe.stop;\r\n\r\n        // before the start of the stream\r\n        if (block.number <= startBlock)\r\n            return 0;\r\n\r\n        // during the stream\r\n        if (block.number <= stopBlock)\r\n            return block.number - startBlock;\r\n\r\n        // after the end of the stream\r\n        return stopBlock - startBlock;\r\n    }\r\n\r\n    function depositOf(uint256 _streamId)\r\n    private\r\n    view\r\n    returns (uint256 funds)\r\n    {\r\n        Stream memory stream = streams[_streamId];\r\n        return stream.timeframe.stop\r\n            .sub(stream.timeframe.start)\r\n            .div(stream.rate.interval)\r\n            .mul(stream.rate.payment);\r\n    }\r\n\r\n    function onlyNewTerms(\r\n        uint256 _streamId,\r\n        address _tokenAddress,\r\n        uint256 _stopBlock,\r\n        uint256 _payment,\r\n        uint256 _interval\r\n    )\r\n    private\r\n    view\r\n    returns (bool valid)\r\n    {\r\n        require(\r\n            streams[_streamId].tokenAddress != _tokenAddress ||\r\n            streams[_streamId].timeframe.stop != _stopBlock ||\r\n            streams[_streamId].rate.payment != _payment ||\r\n            streams[_streamId].rate.interval != _interval,\r\n            \"stream has these terms already\"\r\n        );\r\n        return true;\r\n    }\r\n\r\n    function verifyTerms(\r\n        address _tokenAddress,\r\n        uint256 _startBlock,\r\n        uint256 _stopBlock,\r\n        uint256 _interval\r\n    )\r\n    private\r\n    view\r\n    returns (bool valid)\r\n    {\r\n        require(\r\n            _tokenAddress != address(0x0),\r\n            \"token contract address needs to be provided\"\r\n        );\r\n        require(\r\n            _startBlock >= block.number,\r\n            \"the start block needs to be higher than the current block number\"\r\n        );\r\n        require(\r\n            _stopBlock > _startBlock,\r\n            \"the stop block needs to be higher than the start block\"\r\n        );\r\n        uint256 delta = _stopBlock - _startBlock;\r\n        require(\r\n            delta >= _interval,\r\n            \"the block difference needs to be higher than the payment interval\"\r\n        );\r\n        require(\r\n            delta.mod(_interval) == 0,\r\n            \"the block difference needs to be a multiple of the payment interval\"\r\n        );\r\n        return true;\r\n    }\r\n\r\n    function executeUpdate(\r\n        uint256 _streamId,\r\n        address _tokenAddress,\r\n        uint256 _stopBlock,\r\n        uint256 _payment,\r\n        uint256 _interval\r\n    )\r\n        private\r\n        streamExists(_streamId)\r\n    {\r\n        Stream memory stream = streams[_streamId];\r\n        if (updates[_streamId][stream.sender] == false)\r\n            return;\r\n        if (updates[_streamId][stream.recipient] == false)\r\n            return;\r\n\r\n        // adjust stop block\r\n        uint256 remainder = _stopBlock.sub(block.number).mod(_interval);\r\n        uint256 adjustedStopBlock = _stopBlock.sub(remainder);\r\n        emit ExecuteUpdate(\r\n            _streamId,\r\n            stream.sender,\r\n            stream.recipient,\r\n            _tokenAddress,\r\n            adjustedStopBlock,\r\n            _payment,\r\n            _interval\r\n        );\r\n        updates[_streamId][stream.sender] = false;\r\n        updates[_streamId][stream.recipient] = false;\r\n\r\n        redeemStream(_streamId);\r\n        createStream(\r\n            stream.sender,\r\n            stream.recipient,\r\n            _tokenAddress,\r\n            block.number,\r\n            adjustedStopBlock,\r\n            _payment,\r\n            _interval\r\n        );\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"_streamId\",\"type\":\"uint256\"},{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"getUpdate\",\"outputs\":[{\"name\":\"active\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_streamId\",\"type\":\"uint256\"},{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_streamId\",\"type\":\"uint256\"}],\"name\":\"redeemStream\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_streamId\",\"type\":\"uint256\"},{\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"name\":\"_stopBlock\",\"type\":\"uint256\"},{\"name\":\"_payment\",\"type\":\"uint256\"},{\"name\":\"_interval\",\"type\":\"uint256\"}],\"name\":\"confirmUpdate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_streamId\",\"type\":\"uint256\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdrawFromStream\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_streamId\",\"type\":\"uint256\"}],\"name\":\"getStream\",\"outputs\":[{\"name\":\"sender\",\"type\":\"address\"},{\"name\":\"recipient\",\"type\":\"address\"},{\"name\":\"tokenAddress\",\"type\":\"address\"},{\"name\":\"balance\",\"type\":\"uint256\"},{\"name\":\"startBlock\",\"type\":\"uint256\"},{\"name\":\"stopBlock\",\"type\":\"uint256\"},{\"name\":\"payment\",\"type\":\"uint256\"},{\"name\":\"interval\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_streamId\",\"type\":\"uint256\"},{\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"name\":\"_stopBlock\",\"type\":\"uint256\"},{\"name\":\"_payment\",\"type\":\"uint256\"},{\"name\":\"_interval\",\"type\":\"uint256\"}],\"name\":\"revokeUpdate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_sender\",\"type\":\"address\"},{\"name\":\"_recipient\",\"type\":\"address\"},{\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"name\":\"_startBlock\",\"type\":\"uint256\"},{\"name\":\"_stopBlock\",\"type\":\"uint256\"},{\"name\":\"_payment\",\"type\":\"uint256\"},{\"name\":\"_interval\",\"type\":\"uint256\"}],\"name\":\"createStream\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"streamId\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"startBlock\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"stopBlock\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"payment\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"interval\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"deposit\",\"type\":\"uint256\"}],\"name\":\"CreateStream\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"streamId\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"WithdrawFromStream\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"streamId\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"senderAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"recipientAmount\",\"type\":\"uint256\"}],\"name\":\"RedeemStream\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"streamId\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"confirmer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newTokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newStopBlock\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"newPayment\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"newInterval\",\"type\":\"uint256\"}],\"name\":\"ConfirmUpdate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"streamId\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"revoker\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newTokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newStopBlock\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"newPayment\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"newInterval\",\"type\":\"uint256\"}],\"name\":\"RevokeUpdate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"streamId\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newTokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newStopBlock\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"newPayment\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"newInterval\",\"type\":\"uint256\"}],\"name\":\"ExecuteUpdate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"streamId\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"startBlock\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"stopBlock\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"payment\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"interval\",\"type\":\"uint256\"}],\"name\":\"CreateStream\",\"type\":\"event\"}]","ContractName":"Sablier","CompilerVersion":"v0.5.8+commit.23d335f2","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://2d549b605af21feee4e9a2ec25023b21cb47fedd634f1c6da52ca937b5533e66"}]}