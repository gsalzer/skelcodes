{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity >=0.5;\r\npragma experimental ABIEncoderV2;\r\n\r\n/**\r\n * @title DexStatus\r\n * @dev Status for Dex  \r\n */ \r\ncontract DexStatus {\r\n    string constant ONLY_RELAYER    = \"ONLY_RELAYER\";\r\n    string constant ONLY_AIRDROP    = \"ONLY_AIRDROP\"; \r\n    string constant ONLY_INACTIVITY = \"ONLY_INACTIVITY\";\r\n    string constant ONLY_WITHDRAWALAPPROVED = \"ONLY_WITHDRAWALAPPROVED\";\r\n\r\n    string constant INVALID_NONCE  = \"INVALID_NONCE\";  \r\n    string constant INVALID_PERIOD = \"INVALID_PERIOD\";\r\n    string constant INVALID_AMOUNT = \"INVALID_AMOUNT\";\r\n    string constant INVALID_TIME   = \"INVALID_TIME\";\r\n    string constant INVALID_GASTOKEN = \"INVALID_GASTOKEN\";\r\n\r\n    string constant TRANSFER_FAILED = \"TRANSFER_FAILED\";\r\n    string constant ECRECOVER_FAILED  = \"ECRECOVER_FAILED\";\r\n\r\n    string constant INSUFFICIENT_FOUND = \"INSUFFICIENT\";  \r\n    string constant TRADE_EXISTS       = \"TRADED\";\r\n    string constant WITHDRAW_EXISTS    = \"WITHDRAWN\";\r\n\r\n    string constant MAX_VALUE_LIMIT = \"MAX_LIMIT\";\r\n\r\n    string constant AMOUNT_EXCEEDED = \"AMOUNT_EXCEEDED\"; \r\n}\r\n\r\n\r\n\r\n/**\r\n * @title IGasStorage\r\n * @dev  GasStorage interface to burn and mint gastoken\r\n */\r\ninterface IGasStorage\r\n{\r\n    function mint(uint256 value) external;\r\n    function burn(uint256 value) external;\r\n    function balanceOf() external view returns (uint256 balance);\r\n}\r\n\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  constructor() public {\r\n    owner = tx.origin;\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    require(newOwner != address(0));\r\n    emit OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n\r\n}\r\n\r\n/** \r\n * @dev ERC20 interface\r\n */\r\ninterface ERC20 {  \r\n    function balanceOf(address _owner) external view returns (uint256 balance); \r\n    function transfer(address _to, uint256 _value) external returns (bool success) ; \r\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success); \r\n    function approve(address _spender, uint256 _value) external returns (bool success); \r\n    function allowance(address _owner, address _spender) view external returns (uint256 remaining); \r\n}\r\n \r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, reverts on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    uint256 c = a * b;\r\n    require(c / a == b);\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b > 0); // Solidity only automatically asserts when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b <= a);\r\n    uint256 c = a - b;\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, reverts on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    require(c >= a);\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\r\n  * reverts when dividing by zero.\r\n  */\r\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b != 0);\r\n    return a % b;\r\n  }\r\n}\r\n  \r\n \r\n\r\n \r\n\r\n/**\r\n * @title Dex\r\n * @dev Smart contract for https://www.dex.io\r\n */ \r\ncontract Dex is Ownable,DexStatus {  \r\n    using SafeMath for uint256;     \r\n    \r\n    struct Order\r\n    {\r\n        address token;\r\n        address baseToken; \r\n        address user;  \r\n        uint256 tokenAmount;\r\n        uint256 baseTokenAmount;\r\n        uint    nonce;\r\n        uint    expireTime;  \r\n        uint    maxGasFee;  \r\n        uint    timestamp;\r\n        address gasToken;  \r\n        bool    sell;\r\n        uint8   V;\r\n        bytes32 R;\r\n        bytes32 S;  \r\n        uint    signType;\r\n    } \r\n\r\n    struct TradeInfo {\r\n        uint256 tradeTokenAmount;   \r\n        uint256 tradeTakerFee;\r\n        uint256 tradeMakerFee;    \r\n        uint256 tradeGasFee;\r\n        uint    tradeNonce; \r\n        address tradeGasToken;  \r\n    }    \r\n\r\n    mapping (address => mapping (address => uint256)) public _balances;  \r\n\r\n    mapping (address => uint)     public _invalidOrderNonce;     \r\n\r\n    mapping (bytes32 => uint256)  public _orderFills;\r\n\r\n    mapping (address => bool)     public _relayers;\r\n\r\n    mapping (bytes32 => bool)     public _traded;\r\n    mapping (bytes32 => bool)     public _withdrawn;   \r\n     \r\n    mapping (bytes32 => uint256)  public _orderGasFee; \r\n  \r\n    mapping (address => uint)     public _withdrawalApplication;\r\n\r\n    address public       _feeAccount; \r\n    address public       _airdropContract;  \r\n    address public       _gasStorage;\r\n\r\n    uint256 public _withdrawalApplicationPeriod = 10 days;\r\n \r\n    uint256 public _takerFeeRate   = 0.002 ether;\r\n    uint256 public _makerFeeRate   = 0.001 ether;    \r\n \r\n    string  private constant EIP712DOMAIN_TYPE  = \"EIP712Domain(string name)\";\r\n    bytes32 private constant EIP712DOMAIN_TYPEHASH = keccak256(abi.encodePacked(EIP712DOMAIN_TYPE)); \r\n    bytes32 private constant DOMAIN_SEPARATOR = keccak256(abi.encode(EIP712DOMAIN_TYPEHASH,keccak256(bytes(\"Dex.io\"))));\r\n \r\n    string  private constant  ORDER_TYPE = \"Order(address token,address baseToken,uint256 tokenAmount,uint256 baseTokenAmount,uint256 nonce,bool sell,uint256 expireTime,uint256 maxGasFee,address gasToken,uint timestamp)\";    \r\n    bytes32 private constant  ORDER_TYPEHASH = keccak256(abi.encodePacked(ORDER_TYPE)); \r\n    \r\n    string  private constant  WITHDRAW_TYPE = \"Withdraw(address token,uint256 tokenAmount,address to,uint256 nonce,address feeToken,uint256 feeWithdrawal,uint timestamp)\";    \r\n    bytes32 private constant  WITHDRAW_TYPEHASH = keccak256(abi.encodePacked(WITHDRAW_TYPE));\r\n\r\n    event Trade(bytes32 takerHash,bytes32 makerHash,uint256 tradeAmount,uint256 tradeBaseTokenAmount,uint256 tradeNonce,uint256 takerCostFee,\r\n          uint makerCostFee,bool sellerIsMaker,uint256 gasFee);\r\n\r\n    event Balance(uint256 takerBaseTokenBalance,uint256 takerTokenBalance,uint256 makerBaseTokenBalance,uint256 makerTokenBalance); \r\n\r\n    event Deposit(address indexed token, address indexed user, uint256 amount, uint256 balance);\r\n    event Withdraw(address indexed token,address indexed from,address indexed to, uint256 amount, uint256 balance); \r\n    event Transfer(address indexed token,address indexed from,address indexed to, uint256 amount, uint256 fromBalance,uint256 toBalance); \r\n    event Airdrop(address indexed to, address indexed token,uint256 amount); \r\n\r\n    event WithdrawalApplication(address user,uint timestamp);\r\n\r\n    modifier onlyRelayer {\r\n        if (msg.sender != owner && !_relayers[msg.sender]) revert(ONLY_RELAYER);\r\n        _;\r\n    } \r\n\r\n    modifier onlyAirdropContract {\r\n        if (msg.sender != _airdropContract) revert(ONLY_AIRDROP);\r\n        _;\r\n    }   \r\n \r\n    /** \r\n    *  @dev approved in 10 days \r\n    */  \r\n    modifier onlyWithdrawalApplicationApproved  {\r\n        require (\r\n             _withdrawalApplication[msg.sender] != uint(0) &&\r\n             block.timestamp - _withdrawalApplicationPeriod > _withdrawalApplication[msg.sender],\r\n             ONLY_WITHDRAWALAPPROVED);\r\n        _;\r\n    }   \r\n\r\n  \r\n    /** \r\n    *  @param feeAccount  account to receive the fee\r\n    */  \r\n    constructor(address feeAccount) public { \r\n        _feeAccount = feeAccount;  \r\n    }\r\n\r\n    /** \r\n    *  @dev do no send eth to dex contract directly.\r\n    */\r\n    function() external {\r\n        revert();\r\n    }  \r\n  \r\n    /** \r\n    *  @dev set a relayer\r\n    */ \r\n    function setRelayer(address relayer, bool isRelayer) public onlyOwner {\r\n        _relayers[relayer] = isRelayer;\r\n    } \r\n \r\n    /** \r\n    *  @dev check a relayer\r\n    */ \r\n    function isRelayer(address relayer) public view returns(bool)  {\r\n        return _relayers[relayer];\r\n    } \r\n \r\n    /** \r\n    *  @dev set account that receive the fee\r\n    */ \r\n    function setFeeAccount(address feeAccount) public onlyOwner {\r\n        _feeAccount = feeAccount;\r\n    }\r\n \r\n    /** \r\n    *  @dev set set maker and taker fee rate\r\n    *  @param makerFeeRate maker fee rate can't be more than 0.5%\r\n    *  @param takerFeeRate taker fee rate can't be more than 0.5%\r\n    */ \r\n    function setFee(uint256 makerFeeRate,uint256 takerFeeRate) public onlyOwner { \r\n\r\n        require(makerFeeRate <=  0.005 ether && takerFeeRate <=  0.005 ether,MAX_VALUE_LIMIT); \r\n\r\n        _makerFeeRate = makerFeeRate;\r\n        _takerFeeRate = takerFeeRate; \r\n    }   \r\n  \r\n    /** \r\n    *  @dev set gasStorage contract to save gas\r\n    */ \r\n    function setGasStorage(address gasStorage) public onlyOwner {\r\n        _gasStorage = gasStorage;\r\n    }\r\n \r\n    /** \r\n    *  @dev set airdrop contract to implement airdrop function\r\n    */ \r\n    function setAirdrop(address airdrop) public onlyOwner{\r\n        _airdropContract = airdrop;\r\n    }\r\n \r\n    /** \r\n    *  @dev set withdraw application period\r\n    *  @param period the period can't be more than 10 days\r\n    */ \r\n    function setWithdrawalApplicationPeriod(uint period) public onlyOwner {\r\n\r\n        if(period > 10 days ){\r\n            return;\r\n        }\r\n\r\n        _withdrawalApplicationPeriod = period; \r\n    }\r\n \r\n    /** \r\n    *  @dev invalid the orders before nonce\r\n    */ \r\n    function invalidateOrdersBefore(address user, uint256 nonce) public onlyRelayer {\r\n        if (nonce < _invalidOrderNonce[user]) {\r\n            revert(INVALID_NONCE);   \r\n        }\r\n\r\n        _invalidOrderNonce[user] = nonce;\r\n    } \r\n  \r\n    /** \r\n    *  @dev deposit token \r\n    */ \r\n    function depositToken(address token, uint256 amount)  public {  \r\n        require(ERC20(token).transferFrom(msg.sender, address(this), amount),TRANSFER_FAILED); \r\n        _deposit(msg.sender,token,amount); \r\n    }\r\n \r\n    /** \r\n    *  @dev deposit token from msg.sender to someone\r\n    */ \r\n    function depositTokenTo(address to,address token, uint256 amount)  public {  \r\n        require(ERC20(token).transferFrom(msg.sender, address(this), amount),TRANSFER_FAILED); \r\n        _deposit(to,token,amount); \r\n    }\r\n\r\n    /** \r\n    *  @dev deposit eth\r\n    */ \r\n    function deposit() public payable { \r\n        _deposit(msg.sender,address(0),msg.value); \r\n    }\r\n \r\n    /** \r\n    *  @dev deposit eth from msg.sender to someone\r\n    */ \r\n    function depositTo(address to) public payable {\r\n        _deposit(to,address(0),msg.value);\r\n    } \r\n \r\n    /** \r\n    *  @dev _deposit\r\n    */ \r\n    function _deposit(address user,address token,uint256 amount) internal {\r\n    \r\n        _balances[token][user] = _balances[token][user].add(amount);   \r\n        \r\n        emit Deposit(token, user, amount, _balances[token][user]);\r\n    } \r\n     \r\n    /** \r\n    *  @dev submit a withdrawal application, user can not place any orders after submit a withdrawal application\r\n    */ \r\n    function submitWithdrawApplication() public {\r\n        _withdrawalApplication[msg.sender] = block.timestamp;\r\n        emit WithdrawalApplication(msg.sender,block.timestamp);\r\n    }\r\n \r\n    /** \r\n    *  @dev cancel withdraw application\r\n    */ \r\n    function cancelWithdrawApplication() public {\r\n        _withdrawalApplication[msg.sender] = 0; \r\n        emit WithdrawalApplication(msg.sender,0);\r\n    }\r\n \r\n    /** \r\n    *  @dev check user withdraw application status\r\n    */ \r\n    function isWithdrawApplication(address user) view public returns(bool) {\r\n        if(_withdrawalApplication[user] == uint(0)) {\r\n            return false;\r\n        }\r\n        return true;\r\n    }   \r\n\r\n    /** \r\n    *  @dev withdraw token \r\n    */ \r\n    function _withdraw(address from,address payable to,address token,uint256 amount) internal {    \r\n\r\n        if ( _balances[token][from] < amount) { \r\n            revert(INSUFFICIENT_FOUND);\r\n        }  \r\n        \r\n        _balances[token][from] = _balances[token][from].sub(amount);\r\n\r\n        if(token == address(0)) {  \r\n            to.transfer(amount);\r\n        }else{    \r\n            require(ERC20(token).transfer(to, amount),TRANSFER_FAILED); \r\n        }  \r\n\r\n        emit Withdraw(token, from, to, amount, _balances[token][from]);\r\n    }  \r\n\r\n\r\n    /** \r\n    *  @dev user withdraw token \r\n    */ \r\n    function withdraw(address token) public onlyWithdrawalApplicationApproved { \r\n        uint256 amount = _balances[token][msg.sender];\r\n        if(amount != 0){ \r\n            _withdraw(msg.sender,msg.sender,token,amount);\r\n        }\r\n    } \r\n         \r\n    /** \r\n    *  @dev user withdraw many tokens \r\n    */ \r\n    function withdrawAll(address[] memory tokens) public onlyWithdrawalApplicationApproved { \r\n        \r\n        for(uint256 i = 0; i< tokens.length ;i++){ \r\n\r\n            uint256 amount = _balances[tokens[i]][msg.sender];\r\n            \r\n            if(amount == 0){\r\n                continue;\r\n            }\r\n\r\n            _withdraw(msg.sender,msg.sender,tokens[i],amount); \r\n        }\r\n    }\r\n  \r\n    /** \r\n    *  @dev user send withdraw request with relayer's authorized signature \r\n    */ \r\n    function authorizedWithdraw(address payable to,address token,uint256 amount,\r\n            uint256 nonce,uint expiredTime,address relayer,uint8 v, bytes32 r,bytes32 s) public\r\n    {  \r\n        require(_withdrawalApplication[msg.sender] == uint(0));\r\n        require(expiredTime >= block.timestamp,INVALID_TIME);\r\n        require(_relayers[relayer] == true,ONLY_RELAYER);\r\n\r\n        bytes32 hash = keccak256(abi.encodePacked(msg.sender,to, token, amount, nonce, expiredTime));\r\n        \r\n        if (_withdrawn[hash]) {\r\n            revert(WITHDRAW_EXISTS);    \r\n        }   \r\n\r\n        _withdrawn[hash] = true;  \r\n\r\n        if (ecrecover(keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash)), v, r, s) != relayer) {\r\n            revert(ECRECOVER_FAILED);\r\n        } \r\n\r\n        _withdraw(msg.sender,to,token,amount);  \r\n    }\r\n \r\n    /** \r\n    *  @dev withdraw the token from Dex Wallet to Etheruem Wallet,signType [0 = signTypeDataV3, 1 = eth_sign] \r\n    */ \r\n    function adminWithdraw(address from,address payable to,address token,uint256 amount,uint256 nonce,uint8 v,bytes32[2] memory rs, \r\n            address feeToken,uint256 feeWithdrawal,uint timestamp,uint signType) public onlyRelayer  { \r\n\r\n        bytes32 hash = ecrecoverWithdraw(from,to,token,amount,nonce,v,rs,feeToken,feeWithdrawal,timestamp,signType);     \r\n\r\n        if (_withdrawn[hash]) {\r\n            revert(WITHDRAW_EXISTS);    \r\n        }    \r\n\r\n        _withdrawn[hash] = true;   \r\n\r\n        _transfer(from,to,token,amount,feeToken,feeWithdrawal,false);\r\n    } \r\n \r\n    /** \r\n    *  @dev transfer the token between Dex Wallet,signType [0 = signTypeDataV3, 1 = eth_sign] \r\n    */ \r\n    function adminTransfer(address from,address payable to,address token,uint256 amount,uint256 nonce,uint8 v,bytes32[2] memory rs, \r\n            address feeToken,uint256 feeWithdrawal,uint timestamp,uint signType) public onlyRelayer  { \r\n\r\n        bytes32 hash = ecrecoverWithdraw(from,to,token,amount,nonce,v,rs,feeToken,feeWithdrawal,timestamp,signType);     \r\n\r\n        if (_withdrawn[hash]) {\r\n            revert(WITHDRAW_EXISTS);    \r\n        }    \r\n        _withdrawn[hash] = true;  \r\n\r\n\r\n        _transfer(from,to,token,amount,feeToken,feeWithdrawal,true);\r\n    }  \r\n \r\n    /** \r\n    *  @dev   transfer the token \r\n    *  @param from   token sender\r\n    *  @param to     token receiver  \r\n    *  @param token   The address of token to transfer\r\n    *  @param amount   The amount to transfer \r\n    *  @param feeToken   The address of token  to pay the fee\r\n    *  @param feeWithdrawal  The amount of feeToken to pay the fee\r\n    *  @param isInternal  True is transfer token from a Dex Wallet to a Dex Wallet, False is transfer a token from Dex wallet to a Etheruem Wallet\r\n    */ \r\n    function _transfer(address from,address payable to,address token,uint256 amount, address feeToken,uint256 feeWithdrawal, bool isInternal) internal  { \r\n  \r\n        if (feeWithdrawal > 0)\r\n        { \r\n            require(_balances[feeToken][from] >= feeWithdrawal,  INSUFFICIENT_FOUND ); \r\n            _balances[feeToken][from]        = _balances[feeToken][from].sub(feeWithdrawal);\r\n            _balances[feeToken][_feeAccount] = _balances[feeToken][_feeAccount].add(feeWithdrawal); \r\n        }   \r\n\r\n        if ( _balances[token][from] < amount) {  revert(INSUFFICIENT_FOUND); }  \r\n        \r\n        _balances[token][from] = _balances[token][from].sub(amount);  \r\n        \r\n        if(isInternal)\r\n        {\r\n            _balances[token][to] = _balances[token][to].add(amount);\r\n\r\n            emit Transfer(token, from, to, amount, _balances[token][from], _balances[token][to]);\r\n\r\n        }else{\r\n            if(token == address(0)) {  \r\n                to.transfer(amount);\r\n            }else{    \r\n                require(ERC20(token).transfer(to, amount),TRANSFER_FAILED); \r\n            }  \r\n\r\n            emit Withdraw(token, from, to, amount, _balances[token][from]);\r\n        }  \r\n    }       \r\n \r\n    /** \r\n    *  @dev  mirgate function will withdraw all user token balances to wallet\r\n    */ \r\n    function adminWithdrawAll(address payable user,address[] memory tokens) public onlyOwner { \r\n\r\n        for(uint256 i = 0; i< tokens.length ;i++){\r\n\r\n            address token = tokens[i];\r\n            uint256 amount = _balances[token][user];\r\n\r\n            if(amount == 0){\r\n                continue;\r\n            }\r\n\r\n            _withdraw(user,user,token,amount);\r\n        }\r\n    }\r\n \r\n    /** \r\n    *  @dev  get the balance of the account \r\n    */  \r\n    function balanceOf(address token, address user) public view returns (uint256) {\r\n        return _balances[token][user];\r\n    }   \r\n \r\n    /** \r\n    *  @dev  trade order only call by relayer, ti.signType: 0 = signTypeDataV3, 1 = eth_sign \r\n    */ \r\n    function tradeOrder(Order memory taker,Order memory maker, TradeInfo memory ti) public onlyRelayer \r\n    {\r\n        uint256 gasInitial = gasleft();\r\n\r\n        bytes32 takerHash = ecrecoverOrder(taker,taker.signType); \r\n        bytes32 makerHash = ecrecoverOrder(maker,maker.signType);\r\n    \r\n        bytes32 tradeHash = keccak256(abi.encodePacked(takerHash ,makerHash)); \r\n\r\n        require(_traded[tradeHash] == false,TRADE_EXISTS);  \r\n\r\n        _traded[tradeHash] = true;     \r\n\r\n        _tradeOrder(taker,maker,ti,takerHash,makerHash);     \r\n\r\n        uint256 gasUsed = gasInitial - gasleft();\r\n        \r\n        _burnGas(gasUsed);\r\n    }\r\n \r\n    /** \r\n    *  @dev  trade order internal\r\n    */ \r\n    function _tradeOrder(Order memory taker,Order memory maker, TradeInfo memory ti, bytes32 takerHash,bytes32 makerHash) internal\r\n    {   \r\n        require(taker.baseToken == maker.baseToken && taker.token == maker.token);\r\n        require(ti.tradeTokenAmount > 0 , INVALID_AMOUNT );\r\n        require((block.timestamp <= taker.expireTime) && (block.timestamp <= maker.expireTime)  ,  INVALID_TIME ); \r\n        require( (_invalidOrderNonce[taker.user] < taker.nonce) &&(_invalidOrderNonce[maker.user] < maker.nonce),INVALID_NONCE) ; \r\n\r\n        require( (taker.tokenAmount.sub(_orderFills[takerHash]) >= ti.tradeTokenAmount) &&\r\n                (maker.tokenAmount.sub(_orderFills[makerHash]) >= ti.tradeTokenAmount), AMOUNT_EXCEEDED); \r\n\r\n        require(taker.gasToken == ti.tradeGasToken, INVALID_GASTOKEN);\r\n\r\n        uint256 tradeBaseTokenAmount = ti.tradeTokenAmount.mul(maker.baseTokenAmount).div(maker.tokenAmount);     \r\n \r\n        (uint256 takerFee,uint256 makerFee) = calcMaxFee(ti,tradeBaseTokenAmount,maker.sell);    \r\n\r\n        uint  gasFee = ti.tradeGasFee;\r\n\r\n        if(gasFee != 0)\r\n        {  \r\n            if( taker.maxGasFee < _orderGasFee[takerHash].add(gasFee))\r\n            {\r\n                gasFee = taker.maxGasFee.sub(_orderGasFee[takerHash]);\r\n            } \r\n\r\n            if(gasFee != 0)\r\n            {\r\n                _orderGasFee[takerHash] = _orderGasFee[takerHash].add(gasFee); \r\n                _balances[taker.gasToken][taker.user]   = _balances[taker.gasToken][taker.user].sub(gasFee); \r\n            } \r\n        } \r\n         \r\n        if( maker.sell)\r\n        {  \r\n            //maker is seller \r\n            _updateOrderBalance(taker.user,maker.user,taker.baseToken,taker.token,\r\n                            tradeBaseTokenAmount,ti.tradeTokenAmount,takerFee,makerFee);\r\n        }else\r\n        {\r\n            //maker is buyer\r\n            _updateOrderBalance(maker.user,taker.user,taker.baseToken,taker.token,\r\n                            tradeBaseTokenAmount,ti.tradeTokenAmount,makerFee,takerFee); \r\n        }\r\n\r\n        //fill order\r\n        _orderFills[takerHash] = _orderFills[takerHash].add(ti.tradeTokenAmount);  \r\n        _orderFills[makerHash] = _orderFills[makerHash].add(ti.tradeTokenAmount);     \r\n\r\n        emit Trade(takerHash,makerHash,ti.tradeTokenAmount,tradeBaseTokenAmount,ti.tradeNonce,takerFee,makerFee, maker.sell ,gasFee);\r\n \r\n        emit Balance(_balances[taker.baseToken][taker.user],_balances[taker.token][taker.user],_balances[maker.baseToken][maker.user],_balances[maker.token][maker.user]); \r\n    }  \r\n   \r\n    /** \r\n    *  @dev  update the balance after each order traded\r\n    */ \r\n    function _updateOrderBalance(address buyer,address seller,address base,address token,uint256 baseAmount,uint256 amount,uint256 buyFee,uint256 sellFee) internal\r\n    {\r\n        _balances[base][seller]    = _balances[base][seller].add(baseAmount.sub(sellFee));    \r\n        _balances[base][buyer]     = _balances[base][buyer].sub(baseAmount);\r\n\r\n        _balances[token][buyer]    = _balances[token][buyer].add(amount.sub(buyFee));  \r\n        _balances[token][seller]   = _balances[token][seller].sub(amount);    \r\n    \r\n        _balances[base][_feeAccount]    = _balances[base][_feeAccount].add(sellFee);  \r\n        _balances[token][_feeAccount]    = _balances[token][_feeAccount].add(buyFee);   \r\n    }\r\n \r\n    /** \r\n    *  @dev  calc max fee for maker and taker\r\n    *  @return return a taker and maker fee limit by _takerFeeRate and _makerFeeRate\r\n    */ \r\n    function calcMaxFee(TradeInfo memory ti,uint256 tradeBaseTokenAmount,bool sellerIsMaker)  view public returns (uint256 takerFee,uint256 makerFee) { \r\n   \r\n        uint maxTakerFee;\r\n        uint maxMakerFee;\r\n\r\n        takerFee     = ti.tradeTakerFee;\r\n        makerFee      = ti.tradeMakerFee; \r\n        \r\n        if(sellerIsMaker)\r\n        { \r\n            // taker is buyer\r\n            maxTakerFee = (ti.tradeTokenAmount * _takerFeeRate) / 1 ether; \r\n            maxMakerFee = (tradeBaseTokenAmount * _makerFeeRate) / 1 ether; \r\n        }else{\r\n            // maker is buyer\r\n            maxTakerFee = (tradeBaseTokenAmount * _takerFeeRate) / 1 ether; \r\n            maxMakerFee = (ti.tradeTokenAmount  * _makerFeeRate) / 1 ether; \r\n        } \r\n\r\n        if(ti.tradeTakerFee > maxTakerFee)\r\n        {\r\n            takerFee = maxTakerFee;\r\n        }  \r\n\r\n        if(ti.tradeMakerFee > maxMakerFee)\r\n        {\r\n            makerFee = maxMakerFee;\r\n        }  \r\n    } \r\n \r\n    /** \r\n    *  @dev  get fee Rate \r\n    */ \r\n    function getFeeRate() view public  returns(uint256 makerFeeRate,uint256 takerFeeRate)\r\n    {\r\n        return (_makerFeeRate,_takerFeeRate);\r\n    } \r\n \r\n    /** \r\n    *  @dev get order filled amount\r\n    *  @param orderHash   the order hash  \r\n    *  @return return the filled amount for a order\r\n    */ \r\n    function getOrderFills(bytes32 orderHash) view public returns(uint256 filledAmount)\r\n    {\r\n        return _orderFills[orderHash];\r\n    }\r\n\r\n    ///@dev check orders traded\r\n    function isTraded(bytes32 buyOrderHash,bytes32 sellOrderHash) view public returns(bool traded)\r\n    {\r\n        return _traded[keccak256(abi.encodePacked(buyOrderHash, sellOrderHash))];\r\n    }   \r\n \r\n    /** \r\n    *  @dev Airdrop the token directly to Dex user's walle,only airdrop contract can call this function.\r\n    *  @param to   the recipient\r\n    *  @param token  the ERC20 token to send  \r\n    *  @param amount  the token amount to send \r\n    */ \r\n    function airdrop(address to,address token,uint256 amount) public onlyAirdropContract  \r\n    {  \r\n        //Not EOA\r\n        require(tx.origin != msg.sender);\r\n        require(_balances[token][msg.sender] >= amount ,INSUFFICIENT_FOUND);\r\n\r\n        _balances[token][msg.sender] = _balances[token][msg.sender].sub(amount); \r\n        _balances[token][to] = _balances[token][to].add(amount);  \r\n\r\n        emit Airdrop(to,token,amount);\r\n    }   \r\n\r\n    /** \r\n    *  @dev ecreover the order sign   \r\n    *  @return return a order hash\r\n    */ \r\n    function ecrecoverOrder(Order memory order,uint signType) public pure returns (bytes32 orderHash) {  \r\n \r\n        if(signType == 0 )\r\n        {\r\n            orderHash = keccak256(abi.encode(\r\n                ORDER_TYPEHASH,\r\n                order.token,order.baseToken,order.tokenAmount,order.baseTokenAmount,order.nonce,order.sell,order.expireTime,order.maxGasFee,order.gasToken,order.timestamp));\r\n            if (ecrecover(keccak256(abi.encodePacked(\"\\x19\\x01\",DOMAIN_SEPARATOR,orderHash)),order.V,order.R, order.S) != order.user) {\r\n                    revert(ECRECOVER_FAILED);\r\n            }  \r\n        }else {   \r\n\r\n            orderHash = keccak256(abi.encodePacked(order.token,order.baseToken,order.tokenAmount,order.baseTokenAmount,order.nonce,order.sell,order.expireTime,order.maxGasFee,order.gasToken,order.timestamp)); \r\n            if(ecrecover(keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\",orderHash)),order.V,order.R, order.S) != order.user) {\r\n                revert(ECRECOVER_FAILED);\r\n            }  \r\n        } \r\n    }   \r\n\r\n    /** \r\n    *  @dev ecrecover the withdraw sign\r\n    *  @return return a withdraw hash\r\n    */\r\n    function ecrecoverWithdraw(address from,address payable to,address token,uint256 amount,uint256 nonce,uint8 v,bytes32[2] memory rs, \r\n            address feeToken,uint256 feeWithdrawal,uint timestamp,uint signType) public pure returns (bytes32 orderHash) {  \r\n  \r\n        if(signType == 1 ) {\r\n\r\n            orderHash = keccak256(abi.encodePacked(token, amount, to, nonce,feeToken,feeWithdrawal,timestamp));\r\n\r\n            if (ecrecover(keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", orderHash)), v, rs[0], rs[1]) != from) {\r\n                revert(ECRECOVER_FAILED);\r\n            }\r\n \r\n        } else {\r\n            orderHash = keccak256(abi.encode(WITHDRAW_TYPEHASH,token, amount, to, nonce,feeToken,feeWithdrawal,timestamp));\r\n\r\n            if (ecrecover(keccak256(abi.encodePacked(\"\\x19\\x01\",DOMAIN_SEPARATOR,orderHash)), v, rs[0], rs[1]) != from) {\r\n                revert(ECRECOVER_FAILED);\r\n            }  \r\n        } \r\n    }  \r\n  \r\n    /**\r\n   * @dev burn the stored gastoken\r\n   * @param gasUsed The gas uesed to calc the gastoken to burn\r\n   */\r\n    function _burnGas(uint gasUsed) internal {\r\n\r\n        if(_gasStorage == address(0x0)){\r\n            return;\r\n        } \r\n\r\n        IGasStorage(_gasStorage).burn(gasUsed); \r\n    }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"_traded\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_gasStorage\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"airdrop\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_airdropContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"nonce\",\"type\":\"uint256\"},{\"name\":\"expiredTime\",\"type\":\"uint256\"},{\"name\":\"relayer\",\"type\":\"address\"},{\"name\":\"v\",\"type\":\"uint8\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"authorizedWithdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"cancelWithdrawApplication\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"depositToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"components\":[{\"name\":\"tradeTokenAmount\",\"type\":\"uint256\"},{\"name\":\"tradeTakerFee\",\"type\":\"uint256\"},{\"name\":\"tradeMakerFee\",\"type\":\"uint256\"},{\"name\":\"tradeGasFee\",\"type\":\"uint256\"},{\"name\":\"tradeNonce\",\"type\":\"uint256\"},{\"name\":\"tradeGasToken\",\"type\":\"address\"}],\"name\":\"ti\",\"type\":\"tuple\"},{\"name\":\"tradeBaseTokenAmount\",\"type\":\"uint256\"},{\"name\":\"sellerIsMaker\",\"type\":\"bool\"}],\"name\":\"calcMaxFee\",\"outputs\":[{\"name\":\"takerFee\",\"type\":\"uint256\"},{\"name\":\"makerFee\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"components\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"baseToken\",\"type\":\"address\"},{\"name\":\"user\",\"type\":\"address\"},{\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"name\":\"baseTokenAmount\",\"type\":\"uint256\"},{\"name\":\"nonce\",\"type\":\"uint256\"},{\"name\":\"expireTime\",\"type\":\"uint256\"},{\"name\":\"maxGasFee\",\"type\":\"uint256\"},{\"name\":\"timestamp\",\"type\":\"uint256\"},{\"name\":\"gasToken\",\"type\":\"address\"},{\"name\":\"sell\",\"type\":\"bool\"},{\"name\":\"V\",\"type\":\"uint8\"},{\"name\":\"R\",\"type\":\"bytes32\"},{\"name\":\"S\",\"type\":\"bytes32\"},{\"name\":\"signType\",\"type\":\"uint256\"}],\"name\":\"order\",\"type\":\"tuple\"},{\"name\":\"signType\",\"type\":\"uint256\"}],\"name\":\"ecrecoverOrder\",\"outputs\":[{\"name\":\"orderHash\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"user\",\"type\":\"address\"},{\"name\":\"tokens\",\"type\":\"address[]\"}],\"name\":\"adminWithdrawAll\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"nonce\",\"type\":\"uint256\"},{\"name\":\"v\",\"type\":\"uint8\"},{\"name\":\"rs\",\"type\":\"bytes32[2]\"},{\"name\":\"feeToken\",\"type\":\"address\"},{\"name\":\"feeWithdrawal\",\"type\":\"uint256\"},{\"name\":\"timestamp\",\"type\":\"uint256\"},{\"name\":\"signType\",\"type\":\"uint256\"}],\"name\":\"adminWithdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_takerFeeRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"feeAccount\",\"type\":\"address\"}],\"name\":\"setFeeAccount\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"nonce\",\"type\":\"uint256\"},{\"name\":\"v\",\"type\":\"uint8\"},{\"name\":\"rs\",\"type\":\"bytes32[2]\"},{\"name\":\"feeToken\",\"type\":\"address\"},{\"name\":\"feeWithdrawal\",\"type\":\"uint256\"},{\"name\":\"timestamp\",\"type\":\"uint256\"},{\"name\":\"signType\",\"type\":\"uint256\"}],\"name\":\"ecrecoverWithdraw\",\"outputs\":[{\"name\":\"orderHash\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"makerFeeRate\",\"type\":\"uint256\"},{\"name\":\"takerFeeRate\",\"type\":\"uint256\"}],\"name\":\"setFee\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_makerFeeRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"relayer\",\"type\":\"address\"}],\"name\":\"isRelayer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"_relayers\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"_withdrawn\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokens\",\"type\":\"address[]\"}],\"name\":\"withdrawAll\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"components\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"baseToken\",\"type\":\"address\"},{\"name\":\"user\",\"type\":\"address\"},{\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"name\":\"baseTokenAmount\",\"type\":\"uint256\"},{\"name\":\"nonce\",\"type\":\"uint256\"},{\"name\":\"expireTime\",\"type\":\"uint256\"},{\"name\":\"maxGasFee\",\"type\":\"uint256\"},{\"name\":\"timestamp\",\"type\":\"uint256\"},{\"name\":\"gasToken\",\"type\":\"address\"},{\"name\":\"sell\",\"type\":\"bool\"},{\"name\":\"V\",\"type\":\"uint8\"},{\"name\":\"R\",\"type\":\"bytes32\"},{\"name\":\"S\",\"type\":\"bytes32\"},{\"name\":\"signType\",\"type\":\"uint256\"}],\"name\":\"taker\",\"type\":\"tuple\"},{\"components\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"baseToken\",\"type\":\"address\"},{\"name\":\"user\",\"type\":\"address\"},{\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"name\":\"baseTokenAmount\",\"type\":\"uint256\"},{\"name\":\"nonce\",\"type\":\"uint256\"},{\"name\":\"expireTime\",\"type\":\"uint256\"},{\"name\":\"maxGasFee\",\"type\":\"uint256\"},{\"name\":\"timestamp\",\"type\":\"uint256\"},{\"name\":\"gasToken\",\"type\":\"address\"},{\"name\":\"sell\",\"type\":\"bool\"},{\"name\":\"V\",\"type\":\"uint8\"},{\"name\":\"R\",\"type\":\"bytes32\"},{\"name\":\"S\",\"type\":\"bytes32\"},{\"name\":\"signType\",\"type\":\"uint256\"}],\"name\":\"maker\",\"type\":\"tuple\"},{\"components\":[{\"name\":\"tradeTokenAmount\",\"type\":\"uint256\"},{\"name\":\"tradeTakerFee\",\"type\":\"uint256\"},{\"name\":\"tradeMakerFee\",\"type\":\"uint256\"},{\"name\":\"tradeGasFee\",\"type\":\"uint256\"},{\"name\":\"tradeNonce\",\"type\":\"uint256\"},{\"name\":\"tradeGasToken\",\"type\":\"address\"}],\"name\":\"ti\",\"type\":\"tuple\"}],\"name\":\"tradeOrder\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"airdrop\",\"type\":\"address\"}],\"name\":\"setAirdrop\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"_invalidOrderNonce\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"user\",\"type\":\"address\"}],\"name\":\"isWithdrawApplication\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getFeeRate\",\"outputs\":[{\"name\":\"makerFeeRate\",\"type\":\"uint256\"},{\"name\":\"takerFeeRate\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"period\",\"type\":\"uint256\"}],\"name\":\"setWithdrawalApplicationPeriod\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"submitWithdrawApplication\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"nonce\",\"type\":\"uint256\"},{\"name\":\"v\",\"type\":\"uint8\"},{\"name\":\"rs\",\"type\":\"bytes32[2]\"},{\"name\":\"feeToken\",\"type\":\"address\"},{\"name\":\"feeWithdrawal\",\"type\":\"uint256\"},{\"name\":\"timestamp\",\"type\":\"uint256\"},{\"name\":\"signType\",\"type\":\"uint256\"}],\"name\":\"adminTransfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"buyOrderHash\",\"type\":\"bytes32\"},{\"name\":\"sellOrderHash\",\"type\":\"bytes32\"}],\"name\":\"isTraded\",\"outputs\":[{\"name\":\"traded\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"user\",\"type\":\"address\"},{\"name\":\"nonce\",\"type\":\"uint256\"}],\"name\":\"invalidateOrdersBefore\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"_orderGasFee\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"}],\"name\":\"depositTo\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"orderHash\",\"type\":\"bytes32\"}],\"name\":\"getOrderFills\",\"outputs\":[{\"name\":\"filledAmount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_withdrawalApplicationPeriod\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"_withdrawalApplication\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_feeAccount\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"deposit\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"gasStorage\",\"type\":\"address\"}],\"name\":\"setGasStorage\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"_orderFills\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"_balances\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"relayer\",\"type\":\"address\"},{\"name\":\"isRelayer\",\"type\":\"bool\"}],\"name\":\"setRelayer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"depositTokenTo\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"user\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"feeAccount\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"takerHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"makerHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"tradeAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tradeBaseTokenAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tradeNonce\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"takerCostFee\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"makerCostFee\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"sellerIsMaker\",\"type\":\"bool\"},{\"indexed\":false,\"name\":\"gasFee\",\"type\":\"uint256\"}],\"name\":\"Trade\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"takerBaseTokenBalance\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"takerTokenBalance\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"makerBaseTokenBalance\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"makerTokenBalance\",\"type\":\"uint256\"}],\"name\":\"Balance\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"balance\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"balance\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"fromBalance\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"toBalance\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Airdrop\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"WithdrawalApplication\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"Dex","CompilerVersion":"v0.5.5+commit.47a71e8f","OptimizationUsed":"1","Runs":"100000","ConstructorArguments":"000000000000000000000000ce189233985f13b6c6f4c16eff8bb12cd4232f38","Library":"","SwarmSource":"bzzr://90cd3856e2f9a5b621054010d06bf8fe3364161a4ccb75bcde9d55df2b2e7c40"}]}