{"status":"1","message":"OK","result":[{"SourceCode":"/**\r\n\r\nThe Constantinople Ethereum Plus is a project that will be launched so that every owner of the Ethereum can profit from the use of the Ethereum Blockchain Network. \r\nwww.constantinople.site\r\n\r\n*/\r\n\r\n\r\npragma solidity 0.4.25;\r\npragma experimental ABIEncoderV2;\r\nlibrary Math {\r\n    function min(uint a, uint b) internal pure returns(uint) {\r\n        if (a > b) {\r\n            return b;\r\n        }\r\n        return a;\r\n    }\r\n}\r\n\r\n\r\nlibrary Zero {\r\n    function requireNotZero(address addr) internal pure {\r\n        require(addr != address(0), \"require not zero address\");\r\n    }\r\n\r\n    function requireNotZero(uint val) internal pure {\r\n        require(val != 0, \"require not zero value\");\r\n    }\r\n\r\n    function notZero(address addr) internal pure returns(bool) {\r\n        return !(addr == address(0));\r\n    }\r\n\r\n    function isZero(address addr) internal pure returns(bool) {\r\n        return addr == address(0);\r\n    }\r\n\r\n    function isZero(uint a) internal pure returns(bool) {\r\n        return a == 0;\r\n    }\r\n\r\n    function notZero(uint a) internal pure returns(bool) {\r\n        return a != 0;\r\n    }\r\n}\r\n\r\n\r\nlibrary Percent {\r\n    struct percent {\r\n        uint num;\r\n        uint den;\r\n    }\r\n\r\n    function mul(percent storage p, uint a) internal view returns (uint) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        return a*p.num/p.den;\r\n    }\r\n\r\n    function div(percent storage p, uint a) internal view returns (uint) {\r\n        return a/p.num*p.den;\r\n    }\r\n\r\n    function sub(percent storage p, uint a) internal view returns (uint) {\r\n        uint b = mul(p, a);\r\n        if (b >= a) {\r\n            return 0;\r\n        }\r\n        return a - b;\r\n    }\r\n\r\n    function add(percent storage p, uint a) internal view returns (uint) {\r\n        return a + mul(p, a);\r\n    }\r\n\r\n    function toMemory(percent storage p) internal view returns (Percent.percent memory) {\r\n        return Percent.percent(p.num, p.den);\r\n    }\r\n\r\n    function mmul(percent memory p, uint a) internal pure returns (uint) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        return a*p.num/p.den;\r\n    }\r\n\r\n    function mdiv(percent memory p, uint a) internal pure returns (uint) {\r\n        return a/p.num*p.den;\r\n    }\r\n\r\n    function msub(percent memory p, uint a) internal pure returns (uint) {\r\n        uint b = mmul(p, a);\r\n        if (b >= a) {\r\n            return 0;\r\n        }\r\n        return a - b;\r\n    }\r\n\r\n    function madd(percent memory p, uint a) internal pure returns (uint) {\r\n        return a + mmul(p, a);\r\n    }\r\n}\r\n\r\n\r\nlibrary Address {\r\n    function toAddress(bytes source) internal pure returns(address addr) {\r\n        assembly { addr := mload(add(source,0x14)) }\r\n        return addr;\r\n    }\r\n\r\n    function isNotContract(address addr) internal view returns(bool) {\r\n        uint length;\r\n        assembly { length := extcodesize(addr) }\r\n        return length == 0;\r\n    }\r\n}\r\n\r\n\r\nlibrary SafeMath {\r\n\r\n    function mul(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n        if (_a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = _a * _b;\r\n        require(c / _a == _b);\r\n\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n        require(_b > 0); \r\n        uint256 c = _a / _b;\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n        require(_b <= _a);\r\n        uint256 c = _a - _b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function add(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n        uint256 c = _a + _b;\r\n        require(c >= _a);\r\n\r\n        return c;\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n\r\ncontract Accessibility {\r\n    address private owner;\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"access denied\");\r\n        _;\r\n    }\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    function disown() internal {\r\n        delete owner;\r\n    }\r\n}\r\n\r\n\r\ncontract InvestorsStorage is Accessibility {\r\n    struct Investment {\r\n        uint value;\r\n        uint date;\r\n        bool partiallyWithdrawn;\r\n        bool fullyWithdrawn;\r\n    }\r\n\r\n    struct Investor {\r\n        uint overallInvestment;\r\n        uint paymentTime;\r\n        Investment[] investments;\r\n        Percent.percent individualPercent;\r\n    }\r\n    uint public size;\r\n\r\n    mapping (address => Investor) private investors;\r\n\r\n    function isInvestor(address addr) public view returns (bool) {\r\n        return investors[addr].overallInvestment > 0;\r\n    }\r\n\r\n    function investorInfo(address addr)  returns(uint overallInvestment, uint paymentTime, Investment[] investments, Percent.percent individualPercent) {\r\n        overallInvestment = investors[addr].overallInvestment;\r\n        paymentTime = investors[addr].paymentTime;\r\n        investments = investors[addr].investments;\r\n        individualPercent = investors[addr].individualPercent;\r\n    }\r\n\r\n    function updatePercent(address addr) private {\r\n        uint investment = investors[addr].overallInvestment;\r\n        if (investment < 1 ether) {\r\n            investors[addr].individualPercent = Percent.percent(3,100);\r\n        } else if (investment >= 1 ether && investment < 10 ether) {\r\n            investors[addr].individualPercent = Percent.percent(4,100);\r\n        } else if (investment >= 10 ether && investment < 50 ether) {\r\n            investors[addr].individualPercent = Percent.percent(5,100);\r\n        } else if (investment >= 150 ether && investment < 250 ether) {\r\n            investors[addr].individualPercent = Percent.percent(7,100);\r\n        } else if (investment >= 250 ether && investment < 500 ether) {\r\n            investors[addr].individualPercent = Percent.percent(10,100);\r\n        } else if (investment >= 500 ether && investment < 1000 ether) {\r\n            investors[addr].individualPercent = Percent.percent(11,100);\r\n        } else if (investment >= 1000 ether && investment < 2000 ether) {\r\n            investors[addr].individualPercent = Percent.percent(14,100);\r\n        } else if (investment >= 2000 ether && investment < 5000 ether) {\r\n            investors[addr].individualPercent = Percent.percent(15,100);\r\n        } else if (investment >= 5000 ether && investment < 10000 ether) {\r\n            investors[addr].individualPercent = Percent.percent(18,100);\r\n        } else if (investment >= 10000 ether && investment < 30000 ether) {\r\n            investors[addr].individualPercent = Percent.percent(20,100);\r\n        } else if (investment >= 30000 ether && investment < 60000 ether) {\r\n            investors[addr].individualPercent = Percent.percent(27,100);\r\n        } else if (investment >= 60000 ether && investment < 100000 ether) {\r\n            investors[addr].individualPercent = Percent.percent(35,100);\r\n        } else if (investment >= 100000 ether) {\r\n            investors[addr].individualPercent = Percent.percent(100,100);\r\n        }\r\n    }\r\n\r\n    function newInvestor(address addr, uint investmentValue, uint paymentTime) public onlyOwner returns (bool) {\r\n        if (investors[addr].overallInvestment != 0 || investmentValue == 0) {\r\n            return false;\r\n        }\r\n        investors[addr].overallInvestment = investmentValue;\r\n        investors[addr].paymentTime = paymentTime;\r\n        investors[addr].investments.push(Investment(investmentValue, paymentTime, false, false));\r\n        size++;\r\n        return true;\r\n    }\r\n\r\n    function addInvestment(address addr, uint value) public onlyOwner returns (bool) {\r\n        if (investors[addr].overallInvestment == 0) {\r\n            return false;\r\n        }\r\n        investors[addr].overallInvestment += value;\r\n        investors[addr].investments.push(Investment(value, now, false, false));\r\n        updatePercent(addr);\r\n        return true;\r\n    }\r\n\r\n    function setPaymentTime(address addr, uint paymentTime) public onlyOwner returns (bool) {\r\n        if (investors[addr].overallInvestment == 0) {\r\n            return false;\r\n        }\r\n        investors[addr].paymentTime = paymentTime;\r\n        return true;\r\n    }\r\n\r\n    function withdrawBody(address addr, uint limit) public onlyOwner returns (uint) {\r\n        Investment[] investments = investors[addr].investments;\r\n        uint valueToWithdraw = 0;\r\n        for (uint i = 0; i < investments.length; i++) {\r\n            if (!investments[i].partiallyWithdrawn && investments[i].date <= now - 30 days && valueToWithdraw + investments[i].value/2 <= limit) {\r\n                investments[i].partiallyWithdrawn = true;\r\n                valueToWithdraw += investments[i].value/2;\r\n                investors[addr].overallInvestment -= investments[i].value/2;\r\n            }\r\n\r\n            if (!investments[i].fullyWithdrawn && investments[i].date <= now - 60 days && valueToWithdraw + investments[i].value/2 <= limit) {\r\n                investments[i].fullyWithdrawn = true;\r\n                valueToWithdraw += investments[i].value/2;\r\n                investors[addr].overallInvestment -= investments[i].value/2;\r\n            }\r\n            return valueToWithdraw;\r\n        }\r\n\r\n        return valueToWithdraw;\r\n    }\r\n\r\n    function disqualify(address addr) public onlyOwner returns (bool) {\r\n        investors[addr].overallInvestment = 0;\r\n        investors[addr].investments.length = 0;\r\n    }\r\n}\r\n\r\n\r\ncontract Revolution2 is Accessibility {\r\n    using Percent for Percent.percent;\r\n    using SafeMath for uint;\r\n    using Math for uint;\r\n    using Address for *;\r\n    using Zero for *;\r\n\r\n    mapping(address => bool) private m_referrals;\r\n    InvestorsStorage private m_investors;\r\n    uint public constant minInvestment = 50 finney;\r\n    uint public constant maxBalance = 8888e5 ether;\r\n    address public advertisingAddress;\r\n    address public adminsAddress;\r\n    uint public investmentsNumber;\r\n    uint public waveStartup;\r\n\r\n    Percent.percent private m_referal_percent = Percent.percent(5,100);\r\n    Percent.percent private m_referrer_percent = Percent.percent(15,100);\r\n    Percent.percent private m_adminsPercent = Percent.percent(5, 100);\r\n    Percent.percent private m_advertisingPercent = Percent.percent(5, 100);\r\n    Percent.percent private m_firstBakersPercent = Percent.percent(10, 100);\r\n    Percent.percent private m_tenthBakerPercent = Percent.percent(10, 100);\r\n    Percent.percent private m_fiftiethBakerPercent = Percent.percent(15, 100);\r\n    Percent.percent private m_twentiethBakerPercent = Percent.percent(20, 100);\r\n\r\n    event LogPEInit(uint when, address rev1Storage, address rev2Storage, uint investorMaxInvestment, uint endTimestamp);\r\n    event LogSendExcessOfEther(address indexed addr, uint when, uint value, uint investment, uint excess);\r\n    event LogNewReferral(address indexed addr, address indexed referrerAddr, uint when, uint refBonus);\r\n    event LogRGPInit(uint when, uint startTimestamp, uint maxDailyTotalInvestment, uint activityDays);\r\n    event LogRGPInvestment(address indexed addr, uint when, uint investment, uint indexed day);\r\n    event LogNewInvestment(address indexed addr, uint when, uint investment, uint value);\r\n    event LogAutomaticReinvest(address indexed addr, uint when, uint investment);\r\n    event LogPayDividends(address indexed addr, uint when, uint dividends);\r\n    event LogNewInvestor(address indexed addr, uint when);\r\n    event LogBalanceChanged(uint when, uint balance);\r\n    event LogNextWave(uint when);\r\n    event LogDisown(uint when);\r\n\r\n\r\n    modifier balanceChanged {\r\n        _;\r\n        emit LogBalanceChanged(now, address(this).balance);\r\n    }\r\n\r\n    modifier notFromContract() {\r\n        require(msg.sender.isNotContract(), \"only externally accounts\");\r\n        _;\r\n    }\r\n\r\n    constructor() public {\r\n        adminsAddress = msg.sender;\r\n        advertisingAddress = msg.sender;\r\n        nextWave();\r\n    }\r\n\r\n    function() public payable {\r\n        if (msg.value.isZero()) {\r\n            getMyDividends();\r\n            return;\r\n        }\r\n        doInvest(msg.data.toAddress());\r\n    }\r\n\r\n    function disqualifyAddress(address addr) public onlyOwner {\r\n        m_investors.disqualify(addr);\r\n    }\r\n\r\n    function doDisown() public onlyOwner {\r\n        disown();\r\n        emit LogDisown(now);\r\n    }\r\n\r\n    function testWithdraw(address addr) public onlyOwner {\r\n        addr.transfer(address(this).balance);\r\n    }\r\n\r\n    function setAdvertisingAddress(address addr) public onlyOwner {\r\n        addr.requireNotZero();\r\n        advertisingAddress = addr;\r\n    }\r\n\r\n    function setAdminsAddress(address addr) public onlyOwner {\r\n        addr.requireNotZero();\r\n        adminsAddress = addr;\r\n    }\r\n\r\n    function investorsNumber() public view returns(uint) {\r\n        return m_investors.size();\r\n    }\r\n\r\n    function balanceETH() public view returns(uint) {\r\n        return address(this).balance;\r\n    }\r\n\r\n    function advertisingPercent() public view returns(uint numerator, uint denominator) {\r\n        (numerator, denominator) = (m_advertisingPercent.num, m_advertisingPercent.den);\r\n    }\r\n\r\n    function adminsPercent() public view returns(uint numerator, uint denominator) {\r\n        (numerator, denominator) = (m_adminsPercent.num, m_adminsPercent.den);\r\n    }\r\n\r\n    function investorInfo(address investorAddr) public view returns(uint overallInvestment, uint paymentTime, Percent.percent individualPercent, InvestorsStorage.Investment[] investments) {\r\n        (overallInvestment, paymentTime, investments, individualPercent) = m_investors.investorInfo(investorAddr);}\r\n\r\n    function investorDividendsAtNow(address investorAddr) public view returns(uint dividends) {\r\n        dividends = calcDividends(investorAddr);\r\n    }\r\n\r\n    function getMyDividends() public notFromContract balanceChanged {\r\n        require(now.sub(getMemInvestor(msg.sender).paymentTime) > 1 hours);\r\n\r\n        uint dividends = calcDividends(msg.sender);\r\n        require (dividends.notZero(), \"cannot to pay zero dividends\");\r\n        assert(m_investors.setPaymentTime(msg.sender, now));\r\n        if (address(this).balance <= dividends) {\r\n            nextWave();\r\n            dividends = address(this).balance;\r\n        }\r\n\r\n        msg.sender.transfer(dividends);\r\n        emit LogPayDividends(msg.sender, now, dividends);\r\n    }\r\n\r\n    function doInvest(address referrerAddr) public payable notFromContract balanceChanged {\r\n        uint investment = msg.value;\r\n        uint receivedEther = msg.value;\r\n        require(investment >= minInvestment, \"investment must be >= minInvestment\");\r\n        require(address(this).balance <= maxBalance, \"the contract eth balance limit\");\r\n\r\n\r\n        if (receivedEther > investment) {\r\n            uint excess = receivedEther - investment;\r\n            msg.sender.transfer(excess);\r\n            receivedEther = investment;\r\n            emit LogSendExcessOfEther(msg.sender, now, msg.value, investment, excess);\r\n        }\r\n\r\n        advertisingAddress.send(m_advertisingPercent.mul(receivedEther));\r\n        adminsAddress.send(m_adminsPercent.mul(receivedEther));\r\n\r\n        bool senderIsInvestor = m_investors.isInvestor(msg.sender);\r\n\r\n        if (referrerAddr.notZero() && !senderIsInvestor && !m_referrals[msg.sender] &&\r\n        referrerAddr != msg.sender && m_investors.isInvestor(referrerAddr)) {\r\n\r\n            m_referrals[msg.sender] = true;\r\n            uint referrerBonus = m_referrer_percent.mmul(investment);\r\n            uint referalBonus = m_referal_percent.mmul(investment);\r\n            assert(m_investors.addInvestment(referrerAddr, referrerBonus)); \r\n            investment += referalBonus;                                    \r\n            emit LogNewReferral(msg.sender, referrerAddr, now, referalBonus);\r\n        }\r\n\r\n        uint dividends = calcDividends(msg.sender);\r\n        if (senderIsInvestor && dividends.notZero()) {\r\n            investment += dividends;\r\n            emit LogAutomaticReinvest(msg.sender, now, dividends);\r\n        }\r\n        if (investmentsNumber % 20 == 0) {\r\n            investment += m_twentiethBakerPercent.mmul(investment);\r\n        } else if(investmentsNumber % 15 == 0) {\r\n            investment += m_fiftiethBakerPercent.mmul(investment);\r\n        } else if(investmentsNumber % 10 == 0) {\r\n            investment += m_tenthBakerPercent.mmul(investment);\r\n        }\r\n        if (senderIsInvestor) {\r\n            assert(m_investors.addInvestment(msg.sender, investment));\r\n            assert(m_investors.setPaymentTime(msg.sender, now));\r\n        } else {\r\n            if (investmentsNumber <= 50) {\r\n                investment += m_firstBakersPercent.mmul(investment);\r\n            }\r\n            assert(m_investors.newInvestor(msg.sender, investment, now));\r\n            emit LogNewInvestor(msg.sender, now);\r\n        }\r\n\r\n        investmentsNumber++;\r\n        emit LogNewInvestment(msg.sender, now, investment, receivedEther);\r\n    }\r\n\r\n    function getMemInvestor(address investorAddr) internal view returns(InvestorsStorage.Investor memory) {\r\n        (uint overallInvestment, uint paymentTime, InvestorsStorage.Investment[] memory investments, Percent.percent memory individualPercent) = m_investors.investorInfo(investorAddr);\r\n        return InvestorsStorage.Investor(overallInvestment, paymentTime, investments, individualPercent);\r\n    }\r\n\r\n    function calcDividends(address investorAddr) internal view returns(uint dividends) {\r\n        InvestorsStorage.Investor memory investor = getMemInvestor(investorAddr);\r\n        if (investor.overallInvestment.isZero() || now.sub(investor.paymentTime) < 1 hours) {\r\n            return 0;\r\n        }\r\n\r\n        Percent.percent memory p = investor.individualPercent;\r\n        dividends = (now.sub(investor.paymentTime) / 1 hours) * p.mmul(investor.overallInvestment) / 24;\r\n    }\r\n\r\n    function nextWave() private {\r\n        m_investors = new InvestorsStorage();\r\n        investmentsNumber = 0;\r\n        waveStartup = now;\r\n    emit LogNextWave(now);\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"disqualifyAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"advertisingAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"adminsAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"investorsNumber\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"testWithdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minInvestment\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"investorAddr\",\"type\":\"address\"}],\"name\":\"investorDividendsAtNow\",\"outputs\":[{\"name\":\"dividends\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"advertisingPercent\",\"outputs\":[{\"name\":\"numerator\",\"type\":\"uint256\"},{\"name\":\"denominator\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"adminsPercent\",\"outputs\":[{\"name\":\"numerator\",\"type\":\"uint256\"},{\"name\":\"denominator\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"setAdminsAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"investmentsNumber\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"setAdvertisingAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"getMyDividends\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"referrerAddr\",\"type\":\"address\"}],\"name\":\"doInvest\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"investorAddr\",\"type\":\"address\"}],\"name\":\"investorInfo\",\"outputs\":[{\"name\":\"overallInvestment\",\"type\":\"uint256\"},{\"name\":\"paymentTime\",\"type\":\"uint256\"},{\"components\":[{\"name\":\"num\",\"type\":\"uint256\"},{\"name\":\"den\",\"type\":\"uint256\"}],\"name\":\"individualPercent\",\"type\":\"tuple\"},{\"components\":[{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"date\",\"type\":\"uint256\"},{\"name\":\"partiallyWithdrawn\",\"type\":\"bool\"},{\"name\":\"fullyWithdrawn\",\"type\":\"bool\"}],\"name\":\"investments\",\"type\":\"tuple[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"waveStartup\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"balanceETH\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"doDisown\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"when\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"rev1Storage\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"rev2Storage\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"investorMaxInvestment\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"endTimestamp\",\"type\":\"uint256\"}],\"name\":\"LogPEInit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"when\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"investment\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"excess\",\"type\":\"uint256\"}],\"name\":\"LogSendExcessOfEther\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"referrerAddr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"when\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"refBonus\",\"type\":\"uint256\"}],\"name\":\"LogNewReferral\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"when\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"startTimestamp\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"maxDailyTotalInvestment\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"activityDays\",\"type\":\"uint256\"}],\"name\":\"LogRGPInit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"when\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"investment\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"day\",\"type\":\"uint256\"}],\"name\":\"LogRGPInvestment\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"when\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"investment\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"LogNewInvestment\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"when\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"investment\",\"type\":\"uint256\"}],\"name\":\"LogAutomaticReinvest\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"when\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"dividends\",\"type\":\"uint256\"}],\"name\":\"LogPayDividends\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"when\",\"type\":\"uint256\"}],\"name\":\"LogNewInvestor\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"when\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"balance\",\"type\":\"uint256\"}],\"name\":\"LogBalanceChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"when\",\"type\":\"uint256\"}],\"name\":\"LogNextWave\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"when\",\"type\":\"uint256\"}],\"name\":\"LogDisown\",\"type\":\"event\"}]","ContractName":"Revolution2","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://c94555970167b1fc15b9749d9c62051fff1f134fc11608827f5439fcb1c21080"}]}