{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.0;\r\n\r\n\r\n\r\n/**------------------------------------\r\n\r\nLAVA Token  (0xBTC Token Proxy with Lava Enabled)\r\n\r\n0xBTC proxy token contract.  ApproveAndCall() 0xBTC to this contract to receive LAVA tokens. Alternatively, Approve() 0xBTC to this contract and then call the mutateTokens() method. Do not directly transfer 0xBTC to this contract using Transfer() or TransferFrom().\r\n\r\nLAVA tokens can be spent not just by your account, but by any account as long as they have a lava packet signature, signed by your private key, which validates that specific transaction.\r\n\r\nA relayer reward can be specified in a signed packet.  This means that LAVA can be sent by paying an incentive fee of LAVA to relayers for the gas, not ETH.\r\n\r\nLAVA is 1:1 pegged to 0xBTC.\r\n\r\n\r\nThis contract implements EIP712 for Signing Typed Data:\r\nhttps://github.com/MetaMask/eth-sig-util\r\n\r\n------------------------------------*/\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n\r\ncontract ECRecovery {\r\n\r\n  /**\r\n   * @dev Recover signer address from a message by using their signature\r\n   * @param hash bytes32 message, the hash is the signed message. What is recovered is the signer address.\r\n   * @param sig bytes signature, the signature is generated using web3.eth.sign()\r\n   */\r\n  function recover(bytes32 hash, bytes memory sig) internal  pure returns (address) {\r\n    bytes32 r;\r\n    bytes32 s;\r\n    uint8 v;\r\n\r\n    //Check the signature length\r\n    if (sig.length != 65) {\r\n      return (address(0));\r\n    }\r\n\r\n    // Divide the signature in r, s and v variables\r\n    assembly {\r\n      r := mload(add(sig, 32))\r\n      s := mload(add(sig, 64))\r\n      v := byte(0, mload(add(sig, 96)))\r\n    }\r\n\r\n    // Version of signature should be 27 or 28, but 0 and 1 are also possible versions\r\n    if (v < 27) {\r\n      v += 27;\r\n    }\r\n\r\n    // If the version is correct return the signer address\r\n    if (v != 27 && v != 28) {\r\n      return (address(0));\r\n    } else {\r\n      return ecrecover(hash, v, r, s);\r\n    }\r\n  }\r\n\r\n}\r\n\r\n\r\n\r\ncontract RelayAuthorityInterface {\r\n    function getRelayAuthority() public returns (address);\r\n}\r\n\r\n\r\ncontract ERC20Interface {\r\n    function totalSupply() public view returns (uint);\r\n    function balanceOf(address tokenOwner) public view returns (uint balance);\r\n    function allowance(address tokenOwner, address spender) public view returns (uint remaining);\r\n    function transfer(address to, uint tokens) public returns (bool success);\r\n    function approve(address spender, uint tokens) public returns (bool success);\r\n    function transferFrom(address from, address to, uint tokens) public returns (bool success);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint tokens);\r\n    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\r\n}\r\n\r\n\r\ncontract ApproveAndCallFallBack {\r\n    function receiveApproval(address from, uint256 tokens, address token, bytes memory data) public;\r\n}\r\n\r\n\r\ncontract LavaToken is ECRecovery{\r\n\r\n    using SafeMath for uint;\r\n\r\n    address constant public masterToken = 0xB6eD7644C69416d67B522e20bC294A9a9B405B31;\r\n\r\n    string public name     = \"Lava\";\r\n    string public symbol   = \"LAVA\";\r\n    uint8  public decimals = 8;\r\n    uint private _totalSupply;\r\n\r\n    event  Approval(address indexed src, address indexed ext, uint amt);\r\n    event  Transfer(address indexed src, address indexed dst, uint amt);\r\n    event  Deposit(address indexed dst, uint amt);\r\n    event  Withdrawal(address indexed src, uint amt);\r\n\r\n    mapping (address => uint)                       public  balances;\r\n    mapping (address => mapping (address => uint))  public  allowance;\r\n\r\n    mapping (bytes32 => uint256)                    public burnedSignatures;\r\n\r\n\r\n  struct LavaPacket {\r\n    string methodName; //approve, transfer, or a custom data byte32 for ApproveAndCall()\r\n    address relayAuthority; //either a contract or an account\r\n    address from; //the packet origin and signer\r\n    address to; //the recipient of tokens\r\n    address wallet;  //this contract address\r\n    uint256 tokens; //the amount of tokens to give to the recipient\r\n    uint256 relayerRewardTokens; //the amount of tokens to give to msg.sender\r\n    uint256 expires; //the eth block number this packet expires at\r\n    uint256 nonce; //a random number to ensure that packet hashes are always unique (optional)\r\n  }\r\n\r\n\r\n\r\n\r\n\r\n\r\n  bytes32 constant EIP712DOMAIN_TYPEHASH = keccak256(\r\n        \"EIP712Domain(string contractName,string version,uint256 chainId,address verifyingContract)\"\r\n    );\r\n\r\n function getLavaDomainTypehash() public pure returns (bytes32) {\r\n    return EIP712DOMAIN_TYPEHASH;\r\n }\r\n\r\n  function getEIP712DomainHash(string memory contractName, string memory version, uint256 chainId, address verifyingContract) public pure returns (bytes32) {\r\n\r\n    return keccak256(abi.encode(\r\n          EIP712DOMAIN_TYPEHASH,\r\n          keccak256(bytes(contractName)),\r\n          keccak256(bytes(version)),\r\n          chainId,\r\n          verifyingContract\r\n      ));\r\n  }\r\n\r\n  bytes32 constant LAVAPACKET_TYPEHASH = keccak256(\r\n     \"LavaPacket(string methodName,address relayAuthority,address from,address to,address wallet,uint256 tokens,uint256 relayerRewardTokens,uint256 expires,uint256 nonce)\"\r\n );\r\n\r\n  function getLavaPacketTypehash() public pure returns (bytes32) {\r\n     return LAVAPACKET_TYPEHASH;\r\n }\r\n\r\n\r\n\r\n function getLavaPacketHash(string memory methodName, address relayAuthority,address from,address to, address wallet,uint256 tokens,uint256 relayerRewardTokens,uint256 expires,uint256 nonce) public pure returns (bytes32) {\r\n        return keccak256(abi.encode(\r\n            LAVAPACKET_TYPEHASH,\r\n            keccak256(bytes(methodName)),\r\n            relayAuthority,\r\n            from,\r\n            to,\r\n            wallet,\r\n            tokens,\r\n            relayerRewardTokens,\r\n            expires,\r\n            nonce\r\n        ));\r\n    }\r\n\r\n\r\n    constructor() public {\r\n\r\n    }\r\n\r\n    /**\r\n    * Do not allow ETH to enter\r\n    */\r\n     function() external payable\r\n     {\r\n         revert();\r\n     }\r\n\r\n\r\n    /**\r\n     * @dev Deposit original tokens, receive proxy tokens 1:1\r\n     * This method requires token approval.\r\n     *\r\n     * @param amount of tokens to deposit\r\n     */\r\n    function mutateTokens(address from, uint amount) public returns (bool)\r\n    {\r\n\r\n        require( amount >= 0 );\r\n\r\n        require( ERC20Interface( masterToken ).transferFrom( from, address(this), amount) );\r\n\r\n        balances[from] = balances[from].add(amount);\r\n        _totalSupply = _totalSupply.add(amount);\r\n\r\n        emit Transfer(address(this), from, amount);\r\n\r\n        return true;\r\n    }\r\n\r\n\r\n\r\n    /**\r\n     * @dev Withdraw original tokens, burn proxy tokens 1:1\r\n     *\r\n     *\r\n     *\r\n     * @param amount of tokens to withdraw\r\n     */\r\n    function unmutateTokens( uint amount) public returns (bool)\r\n    {\r\n        address from = msg.sender;\r\n        require( amount >= 0 );\r\n\r\n        balances[from] = balances[from].sub(amount);\r\n        _totalSupply = _totalSupply.sub(amount);\r\n\r\n        emit Transfer(from, address(this), amount);\r\n\r\n        require( ERC20Interface( masterToken ).transfer( from, amount) );\r\n\r\n        return true;\r\n    }\r\n\r\n\r\n\r\n   //standard ERC20 method\r\n    function totalSupply() public view returns (uint) {\r\n        return _totalSupply;\r\n    }\r\n\r\n   //standard ERC20 method\r\n     function balanceOf(address tokenOwner) public view returns (uint balance) {\r\n        return balances[tokenOwner];\r\n    }\r\n\r\n     //standard ERC20 method\r\n    function getAllowance(address owner, address spender) public view returns (uint)\r\n    {\r\n      return allowance[owner][spender];\r\n    }\r\n\r\n   //standard ERC20 method\r\n  function approve(address spender,   uint tokens) public returns (bool success) {\r\n      allowance[msg.sender][spender] = tokens;\r\n      emit Approval(msg.sender, spender, tokens);\r\n      return true;\r\n  }\r\n\r\n\r\n  //standard ERC20 method\r\n   function transfer(address to,  uint tokens) public returns (bool success) {\r\n        balances[msg.sender] = balances[msg.sender].sub(tokens);\r\n        balances[to] = balances[to].add(tokens);\r\n        emit Transfer(msg.sender, to, tokens);\r\n        return true;\r\n    }\r\n\r\n\r\n   //standard ERC20 method\r\n   function transferFrom( address from, address to,  uint tokens) public returns (bool success) {\r\n       balances[from] = balances[from].sub(tokens);\r\n       allowance[from][to] = allowance[from][to].sub(tokens);\r\n       balances[to] = balances[to].add(tokens);\r\n       emit Transfer( from, to, tokens);\r\n       return true;\r\n   }\r\n\r\n  //internal method for transferring tokens to the relayer reward as incentive for submitting the packet\r\n   function _giveRelayerReward( address from, address to, uint tokens) internal returns (bool success){\r\n     balances[from] = balances[from].sub(tokens);\r\n     balances[to] = balances[to].add(tokens);\r\n     emit Transfer( from, to, tokens);\r\n     return true;\r\n   }\r\n\r\n\r\n    /*\r\n        Read-only method that returns the EIP712 message structure to be signed for a lava packet.\r\n    */\r\n\r\n   function getLavaTypedDataHash(string memory methodName, address relayAuthority,address from,address to, address wallet,uint256 tokens,uint256 relayerRewardTokens,uint256 expires,uint256 nonce) public view returns (bytes32) {\r\n\r\n\r\n          // Note: we need to use `encodePacked` here instead of `encode`.\r\n          bytes32 digest = keccak256(abi.encodePacked(\r\n              \"\\x19\\x01\",\r\n              getEIP712DomainHash('Lava Wallet','1',1,address(this)),\r\n              getLavaPacketHash(methodName,relayAuthority,from,to,wallet,tokens,relayerRewardTokens,expires,nonce)\r\n          ));\r\n          return digest;\r\n      }\r\n\r\n\r\n\r\n    /*\r\n        The internal method for processing the internal data structure of an offchain lava packet with signature.\r\n    */\r\n\r\n   function _tokenApprovalWithSignature(  string memory methodName, address relayAuthority,address from,address to, address wallet,uint256 tokens,uint256 relayerRewardTokens,uint256 expires,uint256 nonce, bytes32 sigHash, bytes memory signature) internal returns (bool success)\r\n   {\r\n\r\n       /*\r\n        Always allow relaying a packet if the specified relayAuthority is 0.\r\n        If the authority address is not a contract, allow it to relay\r\n        If the authority address is a contract, allow its defined 'getAuthority()' delegate to relay\r\n\r\n       */\r\n\r\n\r\n       require( relayAuthority == address(0x0)\r\n         || (!addressContainsContract(relayAuthority) && msg.sender == relayAuthority)\r\n         || (addressContainsContract(relayAuthority) && msg.sender == RelayAuthorityInterface(relayAuthority).getRelayAuthority())  );\r\n\r\n\r\n\r\n       address recoveredSignatureSigner = recover(sigHash,signature);\r\n\r\n\r\n       //make sure the signer is the depositor of the tokens\r\n       require(from == recoveredSignatureSigner);\r\n\r\n       //make sure this is the correct 'wallet' for this packet\r\n       require(address(this) == wallet);\r\n\r\n       //make sure the signature has not expired\r\n       require(block.number < expires);\r\n\r\n       uint previousBurnedSignatureValue = burnedSignatures[sigHash];\r\n       burnedSignatures[sigHash] = 0x1; //spent\r\n       require(previousBurnedSignatureValue == 0x0);\r\n\r\n       //relayer reward tokens, has nothing to do with allowance\r\n       require(_giveRelayerReward(from, msg.sender,   relayerRewardTokens));\r\n\r\n       //approve transfer of tokens\r\n       allowance[from][to] = tokens;\r\n       emit Approval(from,  to, tokens);\r\n\r\n\r\n       return true;\r\n   }\r\n\r\n\r\n\r\n   function approveTokensWithSignature(string memory methodName, address relayAuthority,address from,address to, address wallet,uint256 tokens,uint256 relayerRewardTokens,uint256 expires,uint256 nonce, bytes memory signature) public returns (bool success)\r\n   {\r\n       require(bytesEqual('approve',bytes(methodName)));\r\n\r\n       bytes32 sigHash = getLavaTypedDataHash(methodName,relayAuthority,from,to,wallet,tokens,relayerRewardTokens,expires,nonce);\r\n\r\n       require(_tokenApprovalWithSignature(methodName,relayAuthority,from,to,wallet,tokens,relayerRewardTokens,expires,nonce,sigHash,signature));\r\n\r\n\r\n       return true;\r\n   }\r\n\r\n\r\n  function transferTokensWithSignature(string memory methodName, address relayAuthority,address from,address to, address wallet,uint256 tokens,uint256 relayerRewardTokens,uint256 expires,uint256 nonce, bytes memory signature) public returns (bool success)\r\n  {\r\n\r\n      require(bytesEqual('transfer',bytes(methodName)));\r\n\r\n      //check to make sure that signature == ecrecover signature\r\n      bytes32 sigHash = getLavaTypedDataHash(methodName,relayAuthority,from,to,wallet,tokens,relayerRewardTokens,expires,nonce);\r\n\r\n      require(_tokenApprovalWithSignature(methodName,relayAuthority,from,to,wallet,tokens,relayerRewardTokens,expires,nonce,sigHash,signature));\r\n\r\n      //it can be requested that fewer tokens be sent that were approved -- the whole approval will be invalidated though\r\n      require(transferFrom( from, to,  tokens));\r\n\r\n\r\n      return true;\r\n\r\n  }\r\n\r\n\r\n     /*\r\n      Approve LAVA tokens for a smart contract and call the contracts receiveApproval method in a single packet transaction.\r\n\r\n      Uses the methodName as the 'bytes' for the fallback function to the remote contract\r\n\r\n      */\r\n     function approveAndCallWithSignature( string memory methodName, address relayAuthority,address from,address to, address wallet,uint256 tokens,uint256 relayerRewardTokens,uint256 expires,uint256 nonce, bytes memory signature ) public returns (bool success)   {\r\n\r\n          require(!bytesEqual('approve',bytes(methodName))  && !bytesEqual('transfer',bytes(methodName)));\r\n\r\n           //check to make sure that signature == ecrecover signature\r\n          bytes32 sigHash = getLavaTypedDataHash(methodName,relayAuthority,from,to,wallet,tokens,relayerRewardTokens,expires,nonce);\r\n\r\n          require(_tokenApprovalWithSignature(methodName,relayAuthority,from,to,wallet,tokens,relayerRewardTokens,expires,nonce,sigHash,signature));\r\n\r\n          _sendApproveAndCall(from,to,tokens,bytes(methodName));\r\n\r\n           return true;\r\n     }\r\n\r\n     function _sendApproveAndCall(address from, address to, uint tokens, bytes memory methodName) internal\r\n     {\r\n         ApproveAndCallFallBack(to).receiveApproval(from, tokens, address(this), bytes(methodName));\r\n     }\r\n\r\n\r\n\r\n\r\n    /*\r\n      Burn the signature of an off-chain transaction packet so that it cannot be used on-chain.\r\n      Only the creator of the packet can call this method as msg.sender.\r\n    */\r\n\r\n     function burnSignature( string memory methodName, address relayAuthority,address from,address to, address wallet,uint256 tokens,uint256 relayerRewardTokens,uint256 expires,uint256 nonce,  bytes memory signature) public returns (bool success)\r\n     {\r\n\r\n\r\n        bytes32 sigHash = getLavaTypedDataHash(methodName,relayAuthority,from,to,wallet,tokens,relayerRewardTokens,expires,nonce);\r\n\r\n         address recoveredSignatureSigner = recover(sigHash,signature);\r\n\r\n         //make sure the invalidator is the signer\r\n         require(recoveredSignatureSigner == from);\r\n\r\n         //only the original packet owner can burn signature, not a relay\r\n         require(from == msg.sender);\r\n\r\n         //make sure this signature has never been used\r\n         uint burnedSignature = burnedSignatures[sigHash];\r\n         burnedSignatures[sigHash] = 0x2; //invalidated\r\n         require(burnedSignature == 0x0);\r\n\r\n         return true;\r\n     }\r\n\r\n\r\n    /*\r\n      Check the burn status of the SHA3 hash of a packet signature.\r\n      Signatures are burned whenever they are used for a transaction or whenever the burnSignature() method is called.\r\n    */\r\n     function signatureHashBurnStatus(bytes32 digest) public view returns (uint)\r\n     {\r\n       return (burnedSignatures[digest]);\r\n     }\r\n\r\n\r\n\r\n\r\n       /*\r\n         Receive approval from ApproveAndCall() to mutate tokens.\r\n\r\n         This method allows 0xBTC to be mutated into LAVA using a single method call.\r\n       */\r\n     function receiveApproval(address from, uint256 tokens, address token, bytes memory data) public returns (bool success) {\r\n\r\n        require(token == masterToken);\r\n\r\n        require(mutateTokens(from, tokens));\r\n\r\n        return true;\r\n\r\n     }\r\n\r\n\r\n\r\n\r\n     function addressContainsContract(address _to) view internal returns (bool)\r\n     {\r\n       uint codeLength;\r\n\r\n        assembly {\r\n            // Retrieve the size of the code on target address, this needs assembly .\r\n            codeLength := extcodesize(_to)\r\n        }\r\n\r\n         return (codeLength>0);\r\n     }\r\n\r\n\r\n     function bytesEqual(bytes memory b1,bytes memory b2) pure internal returns (bool)\r\n        {\r\n          if(b1.length != b2.length) return false;\r\n\r\n          for (uint i=0; i<b1.length; i++) {\r\n            if(b1[i] != b2[i]) return false;\r\n          }\r\n\r\n          return true;\r\n        }\r\n\r\n\r\n\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"getAllowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"digest\",\"type\":\"bytes32\"}],\"name\":\"signatureHashBurnStatus\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"balances\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"masterToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"methodName\",\"type\":\"string\"},{\"name\":\"relayAuthority\",\"type\":\"address\"},{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"wallet\",\"type\":\"address\"},{\"name\":\"tokens\",\"type\":\"uint256\"},{\"name\":\"relayerRewardTokens\",\"type\":\"uint256\"},{\"name\":\"expires\",\"type\":\"uint256\"},{\"name\":\"nonce\",\"type\":\"uint256\"},{\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"burnSignature\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"burnedSignatures\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"mutateTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenOwner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"methodName\",\"type\":\"string\"},{\"name\":\"relayAuthority\",\"type\":\"address\"},{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"wallet\",\"type\":\"address\"},{\"name\":\"tokens\",\"type\":\"uint256\"},{\"name\":\"relayerRewardTokens\",\"type\":\"uint256\"},{\"name\":\"expires\",\"type\":\"uint256\"},{\"name\":\"nonce\",\"type\":\"uint256\"},{\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"approveAndCallWithSignature\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"methodName\",\"type\":\"string\"},{\"name\":\"relayAuthority\",\"type\":\"address\"},{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"wallet\",\"type\":\"address\"},{\"name\":\"tokens\",\"type\":\"uint256\"},{\"name\":\"relayerRewardTokens\",\"type\":\"uint256\"},{\"name\":\"expires\",\"type\":\"uint256\"},{\"name\":\"nonce\",\"type\":\"uint256\"},{\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"approveTokensWithSignature\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getLavaDomainTypehash\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"tokens\",\"type\":\"uint256\"},{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"receiveApproval\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"methodName\",\"type\":\"string\"},{\"name\":\"relayAuthority\",\"type\":\"address\"},{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"wallet\",\"type\":\"address\"},{\"name\":\"tokens\",\"type\":\"uint256\"},{\"name\":\"relayerRewardTokens\",\"type\":\"uint256\"},{\"name\":\"expires\",\"type\":\"uint256\"},{\"name\":\"nonce\",\"type\":\"uint256\"}],\"name\":\"getLavaPacketHash\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"methodName\",\"type\":\"string\"},{\"name\":\"relayAuthority\",\"type\":\"address\"},{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"wallet\",\"type\":\"address\"},{\"name\":\"tokens\",\"type\":\"uint256\"},{\"name\":\"relayerRewardTokens\",\"type\":\"uint256\"},{\"name\":\"expires\",\"type\":\"uint256\"},{\"name\":\"nonce\",\"type\":\"uint256\"}],\"name\":\"getLavaTypedDataHash\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getLavaPacketTypehash\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"unmutateTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"contractName\",\"type\":\"string\"},{\"name\":\"version\",\"type\":\"string\"},{\"name\":\"chainId\",\"type\":\"uint256\"},{\"name\":\"verifyingContract\",\"type\":\"address\"}],\"name\":\"getEIP712DomainHash\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"methodName\",\"type\":\"string\"},{\"name\":\"relayAuthority\",\"type\":\"address\"},{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"wallet\",\"type\":\"address\"},{\"name\":\"tokens\",\"type\":\"uint256\"},{\"name\":\"relayerRewardTokens\",\"type\":\"uint256\"},{\"name\":\"expires\",\"type\":\"uint256\"},{\"name\":\"nonce\",\"type\":\"uint256\"},{\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"transferTokensWithSignature\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"src\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"ext\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amt\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"src\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"dst\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amt\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"dst\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amt\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"src\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amt\",\"type\":\"uint256\"}],\"name\":\"Withdrawal\",\"type\":\"event\"}]","ContractName":"LavaToken","CompilerVersion":"v0.5.0+commit.1d4f565a","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://c4281900d55b2788c033a6396f8a137e916d5593561d32219c66aeb1392127d1"}]}