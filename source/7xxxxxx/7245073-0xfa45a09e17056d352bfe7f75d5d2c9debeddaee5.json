{"status":"1","message":"OK","result":[{"SourceCode":"/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n     * account.\r\n     */\r\n    constructor () internal {\r\n        _owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), _owner);\r\n    }\r\n\r\n    /**\r\n     * @return the address of the owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner());\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @return true if `msg.sender` is the owner of the contract.\r\n     */\r\n    function isOwner() public view returns (bool) {\r\n        return msg.sender == _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to relinquish control of the contract.\r\n     * @notice Renouncing to ownership will leave the contract without an owner.\r\n     * It will not be possible to call the functions with the `onlyOwner`\r\n     * modifier anymore.\r\n     */\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0));\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n/**\r\n * @title SafeMath\r\n * @dev Unsigned math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Multiplies two unsigned integers, reverts on overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Adds two unsigned integers, reverts on overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\r\n     * reverts when dividing by zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}\r\ncontract SimpleToken is Ownable {\r\n    using SafeMath for uint256;\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    mapping (address => uint256) private _balances;\r\n\r\n    uint256 private _totalSupply;\r\n\r\n    /**\r\n     * @dev Total number of tokens in existence\r\n     */\r\n    function totalSupply() public view returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the balance of the specified address.\r\n     * @param owner The address to query the balance of.\r\n     * @return An uint256 representing the amount owned by the passed address.\r\n     */\r\n    function balanceOf(address owner) public view returns (uint256) {\r\n        return _balances[owner];\r\n    }\r\n\r\n    /**\r\n     * @dev Transfer token for a specified address\r\n     * @param to The address to transfer to.\r\n     * @param value The amount to be transferred.\r\n     */\r\n    function transfer(address to, uint256 value) public returns (bool) {\r\n        _transfer(msg.sender, to, value);\r\n        return true;\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev Transfer token for a specified addresses\r\n     * @param from The address to transfer from.\r\n     * @param to The address to transfer to.\r\n     * @param value The amount to be transferred.\r\n     */\r\n    function _transfer(address from, address to, uint256 value) internal {\r\n        require(to != address(0));\r\n        require(value <= _balances[from]); // Check there is enough balance.\r\n\r\n        _balances[from] = _balances[from].sub(value);\r\n        _balances[to] = _balances[to].add(value);\r\n        emit Transfer(from, to, value);\r\n    }\r\n\r\n    /**\r\n     * @dev public function that mints an amount of the token and assigns it to\r\n     * an account. This encapsulates the modification of balances such that the\r\n     * proper events are emitted.\r\n     * @param account The account that will receive the created tokens.\r\n     * @param value The amount that will be created.\r\n     */\r\n    function _mint(address account, uint256 value) internal {\r\n        require(account != address(0));\r\n\r\n        _totalSupply = _totalSupply.add(value);\r\n        _balances[account] = _balances[account].add(value);\r\n        emit Transfer(address(0), account, value);\r\n    }\r\n}\r\ncontract Manageable is Ownable {\r\n    mapping(address => bool) public listOfManagers;\r\n\r\n    modifier onlyManager() {\r\n        require(listOfManagers[msg.sender], \"\");\r\n        _;\r\n    }\r\n\r\n    function addManager(address _manager) public onlyOwner returns (bool success) {\r\n        if (!listOfManagers[_manager]) {\r\n            require(_manager != address(0), \"\");\r\n            listOfManagers[_manager] = true;\r\n            success = true;\r\n        }\r\n    }\r\n\r\n    function removeManager(address _manager) public onlyOwner returns (bool success) {\r\n        if (listOfManagers[_manager]) {\r\n            listOfManagers[_manager] = false;\r\n            success = true;\r\n        }\r\n    }\r\n\r\n    function getInfo(address _manager) public view returns (bool) {\r\n        return listOfManagers[_manager];\r\n    }\r\n}\r\n\r\n\r\ncontract iRNG {\r\n    function update(uint roundNumber, uint additionalNonce, uint period) public payable;\r\n    function __callback(bytes32 _queryId, uint _result) public;\r\n}\r\n\r\n\r\ncontract iKYCWhitelist {\r\n    function isWhitelisted(address _participant) public view returns (bool);\r\n}\r\n\r\ncontract BaseLottery is Manageable {\r\n    using SafeMath for uint;\r\n\r\n    enum RoundState {NOT_STARTED, ACCEPT_FUNDS, WAIT_RESULT, SUCCESS, REFUND}\r\n\r\n    struct Round {\r\n        RoundState state;\r\n        uint ticketsCount;\r\n        uint participantCount;\r\n        TicketsInterval[] tickets;\r\n        address[] participants;\r\n        uint random;\r\n        uint nonce; //xored participants addresses\r\n        uint startRoundTime;\r\n        uint[] winningTickets;\r\n        address[] winners;\r\n        uint roundFunds;\r\n        mapping(address => uint) winnersFunds;\r\n        mapping(address => uint) participantFunds;\r\n        mapping(address => bool) sendGain;\r\n    }\r\n\r\n    struct TicketsInterval {\r\n        address participant;\r\n        uint firstTicket;\r\n        uint lastTicket;\r\n    }\r\n\r\n    uint constant public NUMBER_OF_WINNERS = 10;\r\n    uint constant public SHARE_DENOMINATOR = 10000;\r\n    //uint constant public ORACLIZE_TIMEOUT = 86400;  // one day\r\n    uint public ORACLIZE_TIMEOUT = 86400;  // only for tests\r\n    uint[] public shareOfWinners = [5000, 2500, 1250, 620, 320, 160, 80, 40, 20, 10];\r\n    address payable public organiser;\r\n    uint constant public ORGANISER_PERCENT = 20;\r\n    uint constant public ROUND_FUND_PERCENT = 80;\r\n\r\n    iKYCWhitelist public KYCWhitelist;\r\n\r\n    uint public period;\r\n    address public mainLottery;\r\n    address public management;\r\n    address payable public rng;\r\n\r\n    mapping (uint => Round) public rounds;\r\n\r\n    uint public ticketPrice;\r\n    uint public currentRound;\r\n\r\n    event LotteryStarted(uint start);\r\n    event RoundStateChanged(uint currentRound, RoundState state);\r\n    event ParticipantAdded(uint round, address participant, uint ticketsCount, uint funds);\r\n    event RoundProcecced(uint round, address[] winners, uint[] winningTickets, uint roundFunds);\r\n    event RefundIsSuccess(uint round, address participant, uint funds);\r\n    event RefundIsFailed(uint round, address participant);\r\n    event Withdraw(address participant, uint funds, uint fromRound, uint toRound);\r\n    event AddressIsNotAddedInKYC(address participant);\r\n    event TicketPriceChanged(uint price);\r\n\r\n    modifier onlyRng {\r\n        require(msg.sender == address(rng), \"\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyLotteryContract {\r\n        require(msg.sender == address(mainLottery) || msg.sender == management, \"\");\r\n        _;\r\n    }\r\n\r\n    constructor (address payable _rng, uint _period) public {\r\n        require(_rng != address(0), \"\");\r\n        require(_period >= 60, \"\");\r\n\r\n        rng = _rng;\r\n        period = _period;\r\n    }\r\n\r\n    function setContracts(address payable _rng, address _mainLottery, address _management) public onlyOwner {\r\n        require(_rng != address(0), \"\");\r\n        require(_mainLottery != address(0), \"\");\r\n        require(_management != address(0), \"\");\r\n\r\n        rng = _rng;\r\n        mainLottery = _mainLottery;\r\n        management = _management;\r\n    }\r\n\r\n    function startLottery(uint _startPeriod) public payable onlyLotteryContract {\r\n        currentRound = 1;\r\n        uint time = getCurrentTime().add(_startPeriod).sub(period);\r\n        rounds[currentRound].startRoundTime = time;\r\n        rounds[currentRound].state = RoundState.ACCEPT_FUNDS;\r\n\r\n        iRNG(rng).update.value(msg.value)(currentRound, 0, _startPeriod);\r\n\r\n        emit LotteryStarted(time);\r\n    }\r\n\r\n    function buyTickets(address _participant) public payable onlyLotteryContract {\r\n        uint funds = msg.value;\r\n\r\n        updateRoundTimeAndState();\r\n        addParticipant(_participant, funds.div(ticketPrice));\r\n        updateRoundFundsAndParticipants(_participant, funds);\r\n\r\n        if (getCurrentTime() > rounds[currentRound].startRoundTime.add(period) &&\r\n            rounds[currentRound].participantCount >= 10\r\n        ) {\r\n            _restartLottery();\r\n        }\r\n    }\r\n\r\n    function buyBonusTickets(address _participant, uint _ticketsCount) public payable onlyLotteryContract {\r\n        updateRoundTimeAndState();\r\n        addParticipant(_participant, _ticketsCount);\r\n        updateRoundFundsAndParticipants(_participant, uint(0));\r\n\r\n        if (getCurrentTime() > rounds[currentRound].startRoundTime.add(period) &&\r\n            rounds[currentRound].participantCount >= 10\r\n        ) {\r\n            _restartLottery();\r\n        }\r\n    }\r\n\r\n    function processRound(uint _round, uint _randomNumber) public payable onlyRng returns (bool) {\r\n        if (rounds[_round].winners.length != 0) {\r\n            return true;\r\n        }\r\n\r\n        if (checkRoundState(_round) == RoundState.REFUND) {\r\n            return true;\r\n        }\r\n\r\n        if (rounds[_round].participantCount < 10) {\r\n            rounds[_round].state = RoundState.ACCEPT_FUNDS;\r\n            emit RoundStateChanged(_round, rounds[_round].state);\r\n            return true;\r\n        }\r\n\r\n        rounds[_round].random = _randomNumber;\r\n        findWinTickets(_round);\r\n        findWinners(_round);\r\n        rounds[_round].state = RoundState.SUCCESS;\r\n        emit RoundStateChanged(_round, rounds[_round].state);\r\n\r\n        if (rounds[_round.add(1)].state == RoundState.NOT_STARTED) {\r\n            currentRound = _round.add(1);\r\n            rounds[currentRound].state = RoundState.ACCEPT_FUNDS;\r\n            emit RoundStateChanged(currentRound, rounds[currentRound].state);\r\n        }\r\n\r\n        emit RoundProcecced(_round, rounds[_round].winners, rounds[_round].winningTickets, rounds[_round].roundFunds);\r\n        getRandomNumber(_round + 1, rounds[_round].nonce);\r\n        return true;\r\n    }\r\n\r\n    function restartLottery() public payable onlyOwner {\r\n        _restartLottery();\r\n    }\r\n\r\n    function getRandomNumber(uint _round, uint _nonce) public payable onlyRng {\r\n        iRNG(rng).update(_round, _nonce, period);\r\n    }\r\n\r\n    function setTicketPrice(uint _ticketPrice) public onlyLotteryContract {\r\n        require(_ticketPrice > 0, \"\");\r\n\r\n        emit TicketPriceChanged(_ticketPrice);\r\n        ticketPrice = _ticketPrice;\r\n    }\r\n\r\n    function findWinTickets(uint _round) public {\r\n        uint[10] memory winners = _findWinTickets(rounds[_round].random, rounds[_round].ticketsCount);\r\n\r\n        for (uint i = 0; i < 10; i++) {\r\n            rounds[_round].winningTickets.push(winners[i]);\r\n        }\r\n    }\r\n\r\n    function _findWinTickets(uint _random, uint _ticketsNum) public pure returns (uint[10] memory) {\r\n        uint random = _random;//uint(keccak256(abi.encodePacked(_random)));\r\n        uint winnersNum = 10;\r\n\r\n        uint[10] memory winTickets;\r\n        uint shift = uint(256).div(winnersNum);\r\n\r\n        for (uint i = 0; i < 10; i++) {\r\n            winTickets[i] =\r\n            uint(keccak256(abi.encodePacked(((random << (i.mul(shift))) >> (shift.mul(winnersNum.sub(1)).add(6)))))).mod(_ticketsNum);\r\n        }\r\n\r\n        return winTickets;\r\n    }\r\n\r\n    function refund(uint _round) public {\r\n        if (checkRoundState(_round) == RoundState.REFUND\r\n        && rounds[_round].participantFunds[msg.sender] > 0\r\n        ) {\r\n            uint amount = rounds[_round].participantFunds[msg.sender];\r\n            rounds[_round].participantFunds[msg.sender] = 0;\r\n            address(msg.sender).transfer(amount);\r\n            emit RefundIsSuccess(_round, msg.sender, amount);\r\n        } else {\r\n            emit RefundIsFailed(_round, msg.sender);\r\n        }\r\n    }\r\n\r\n    function checkRoundState(uint _round) public returns (RoundState) {\r\n        if (rounds[_round].state == RoundState.WAIT_RESULT\r\n        && getCurrentTime() > rounds[_round].startRoundTime.add(ORACLIZE_TIMEOUT)\r\n        ) {\r\n            rounds[_round].state = RoundState.REFUND;\r\n            emit RoundStateChanged(_round, rounds[_round].state);\r\n        }\r\n        return rounds[_round].state;\r\n    }\r\n\r\n    function setOrganiser(address payable _organiser) public onlyOwner {\r\n        require(_organiser != address(0), \"\");\r\n\r\n        organiser = _organiser;\r\n    }\r\n\r\n    function setKYCWhitelist(address _KYCWhitelist) public onlyOwner {\r\n        require(_KYCWhitelist != address(0), \"\");\r\n\r\n        KYCWhitelist = iKYCWhitelist(_KYCWhitelist);\r\n    }\r\n\r\n    function getGain(uint _fromRound, uint _toRound) public {\r\n        _transferGain(msg.sender, _fromRound, _toRound);\r\n    }\r\n\r\n    function sendGain(address payable _participant, uint _fromRound, uint _toRound) public onlyManager {\r\n        _transferGain(_participant, _fromRound, _toRound);\r\n    }\r\n\r\n    function getTicketsCount(uint _round) public view returns (uint) {\r\n        return rounds[_round].ticketsCount;\r\n    }\r\n\r\n    function getTicketPrice() public view returns (uint) {\r\n        return ticketPrice;\r\n    }\r\n\r\n    function getCurrentTime() public view returns (uint) {\r\n        return now;\r\n    }\r\n\r\n    function getPeriod() public view returns (uint) {\r\n        return period;\r\n    }\r\n\r\n    function getRoundWinners(uint _round) public view returns (address[] memory) {\r\n        return rounds[_round].winners;\r\n    }\r\n\r\n    function getRoundWinningTickets(uint _round) public view returns (uint[] memory) {\r\n        return rounds[_round].winningTickets;\r\n    }\r\n\r\n    function getRoundParticipants(uint _round) public view returns (address[] memory) {\r\n        return rounds[_round].participants;\r\n    }\r\n\r\n    function getWinningFunds(uint _round, address _winner) public view returns  (uint) {\r\n        return rounds[_round].winnersFunds[_winner];\r\n    }\r\n\r\n    function getRoundFunds(uint _round) public view returns (uint) {\r\n        return rounds[_round].roundFunds;\r\n    }\r\n\r\n    function getParticipantFunds(uint _round, address _participant) public view returns (uint) {\r\n        return rounds[_round].participantFunds[_participant];\r\n    }\r\n\r\n    function getCurrentRound() public view returns (uint) {\r\n        return currentRound;\r\n    }\r\n\r\n    function getRoundStartTime(uint _round) public view returns (uint) {\r\n        return rounds[_round].startRoundTime;\r\n    }\r\n\r\n    function _restartLottery() internal {\r\n        uint _now = getCurrentTime().sub(rounds[1].startRoundTime);\r\n        rounds[currentRound].startRoundTime = getCurrentTime().sub(_now.mod(period));\r\n        rounds[currentRound].state = RoundState.ACCEPT_FUNDS;\r\n        emit RoundStateChanged(currentRound, rounds[currentRound].state);\r\n        iRNG(rng).update(currentRound, 0, period.sub(_now.mod(period)));\r\n    }\r\n\r\n    function _transferGain(address payable _participant, uint _fromRound, uint _toRound) internal {\r\n        require(_fromRound <= _toRound, \"\");\r\n        require(_participant != address(0), \"\");\r\n\r\n        if (KYCWhitelist.isWhitelisted(_participant)) {\r\n            uint funds;\r\n\r\n            for (uint i = _fromRound; i <= _toRound; i++) {\r\n\r\n                if (rounds[i].state == RoundState.SUCCESS\r\n                && rounds[i].sendGain[_participant] == false) {\r\n\r\n                    rounds[i].sendGain[_participant] = true;\r\n                    funds = funds.add(getWinningFunds(i, _participant));\r\n                }\r\n            }\r\n\r\n            require(funds > 0, \"\");\r\n            _participant.transfer(funds);\r\n            emit Withdraw(_participant, funds, _fromRound, _toRound);\r\n        } else {\r\n            emit AddressIsNotAddedInKYC(_participant);\r\n        }\r\n    }\r\n\r\n    // find participant who has winning ticket\r\n    // to start: _begin is 0, _end is last index in ticketsInterval array\r\n    function getWinner(\r\n        uint _round,\r\n        uint _beginInterval,\r\n        uint _endInterval,\r\n        uint _winningTicket\r\n    )\r\n        internal\r\n        returns (address)\r\n    {\r\n        if (_beginInterval == _endInterval) {\r\n            return rounds[_round].tickets[_beginInterval].participant;\r\n        }\r\n\r\n        uint len = _endInterval.add(1).sub(_beginInterval);\r\n        uint mid = _beginInterval.add((len.div(2))).sub(1);\r\n        TicketsInterval memory interval = rounds[_round].tickets[mid];\r\n\r\n        if (_winningTicket < interval.firstTicket) {\r\n            return getWinner(_round, _beginInterval, mid, _winningTicket);\r\n        } else if (_winningTicket > interval.lastTicket) {\r\n            return getWinner(_round, mid.add(1), _endInterval, _winningTicket);\r\n        } else {\r\n            return interval.participant;\r\n        }\r\n    }\r\n\r\n    function addParticipant(address _participant, uint _ticketsCount) internal {\r\n        rounds[currentRound].participants.push(_participant);\r\n        uint currTicketsCount = rounds[currentRound].ticketsCount;\r\n        rounds[currentRound].ticketsCount = currTicketsCount.add(_ticketsCount);\r\n        rounds[currentRound].tickets.push(TicketsInterval(\r\n                _participant,\r\n                currTicketsCount,\r\n                rounds[currentRound].ticketsCount.sub(1))\r\n        );\r\n        rounds[currentRound].nonce = rounds[currentRound].nonce + uint(keccak256(abi.encodePacked(_participant)));\r\n        emit ParticipantAdded(currentRound, _participant, _ticketsCount, _ticketsCount.mul(ticketPrice));\r\n    }\r\n\r\n    function updateRoundTimeAndState() internal {\r\n        if (getCurrentTime() > rounds[currentRound].startRoundTime.add(period)\r\n            && rounds[currentRound].participantCount >= 10\r\n        ) {\r\n            rounds[currentRound].state = RoundState.WAIT_RESULT;\r\n            emit RoundStateChanged(currentRound, rounds[currentRound].state);\r\n            currentRound = currentRound.add(1);\r\n            rounds[currentRound].startRoundTime = rounds[currentRound-1].startRoundTime.add(period);\r\n            rounds[currentRound].state = RoundState.ACCEPT_FUNDS;\r\n            emit RoundStateChanged(currentRound, rounds[currentRound].state);\r\n        }\r\n    }\r\n\r\n    function updateRoundFundsAndParticipants(address _participant, uint _funds) internal {\r\n\r\n        if (rounds[currentRound].participantFunds[_participant] == 0) {\r\n            rounds[currentRound].participantCount = rounds[currentRound].participantCount.add(1);\r\n        }\r\n\r\n        rounds[currentRound].participantFunds[_participant] =\r\n        rounds[currentRound].participantFunds[_participant].add(_funds);\r\n\r\n        rounds[currentRound].roundFunds =\r\n        rounds[currentRound].roundFunds.add(_funds);\r\n    }\r\n\r\n    function findWinners(uint _round) internal {\r\n        address winner;\r\n        uint fundsToWinner;\r\n        for (uint i = 0; i < NUMBER_OF_WINNERS; i++) {\r\n            winner = getWinner(\r\n                _round,\r\n                0,\r\n                (rounds[_round].tickets.length).sub(1),\r\n                rounds[_round].winningTickets[i]\r\n            );\r\n\r\n            rounds[_round].winners.push(winner);\r\n            fundsToWinner = rounds[_round].roundFunds.mul(shareOfWinners[i]).div(SHARE_DENOMINATOR);\r\n            rounds[_round].winnersFunds[winner] = rounds[_round].winnersFunds[winner].add(fundsToWinner);\r\n        }\r\n    }\r\n\r\n}contract FiatContract {\r\n  function USD(uint _id) public pure returns (uint256);\r\n}\r\n\r\ncontract RealToken is Ownable, SimpleToken {\r\n  FiatContract public price;\r\n  BaseLottery public lottery;\r\n    \r\n  using SafeMath for uint256;\r\n\r\n  string public constant name = \"DreamPot Token\";\r\n  string public constant symbol = \"DPT\";\r\n  uint32 public constant decimals = 0;\r\n\r\n  address payable public ethBank;\r\n\r\n  uint256 public factor;\r\n\r\n  event GetEth(address indexed from, uint256 value);\r\n\r\n  constructor() public {\r\n    price = FiatContract(0x8055d0504666e2B6942BeB8D6014c964658Ca591);\r\n    ethBank = address(uint160(owner()));\r\n    factor = 100;\r\n  }\r\n\r\n  function setLotteryBank(address bank) public onlyOwner {\r\n    require(bank != address(0));\r\n    ethBank = address(uint160(bank));\r\n  }\r\n\r\n  function setRoundFactor(uint256 newFactor) public onlyOwner {\r\n    factor = newFactor;\r\n  }\r\n  \r\n  function AddTokens(address addrTo) public payable {\r\n    uint256 ethCent = price.USD(0);\r\n    uint256 usdv = ethCent.div(1000);\r\n    usdv = usdv.mul(factor);\r\n    \r\n    uint256 tokens = msg.value.div(usdv);\r\n    ethBank.transfer(msg.value);\r\n    emit GetEth(addrTo, msg.value);\r\n    _mint(addrTo, tokens);\r\n  }\r\n  \r\n  function() external payable {\r\n  }\r\n}\r\ncontract IChecker {\r\n    function update() public payable;\r\n}\r\n\r\n\r\ncontract SuperJackPot is BaseLottery {\r\n\r\n    IChecker public checker;\r\n\r\n    modifier onlyChecker {\r\n        require(msg.sender == address(checker), \"\");\r\n        _;\r\n    }\r\n\r\n    constructor(\r\n        address payable _rng,\r\n        uint _period,\r\n        address _checker\r\n    )\r\n        public\r\n        BaseLottery(_rng, _period) {\r\n            require(_checker != address(0), \"\");\r\n\r\n            checker = IChecker(_checker);\r\n    }\r\n\r\n    function () external payable {\r\n\r\n    }\r\n\r\n    function processLottery() public payable onlyChecker {\r\n        rounds[currentRound].state = RoundState.WAIT_RESULT;\r\n        emit RoundStateChanged(currentRound, rounds[currentRound].state);\r\n        currentRound = currentRound.add(1);\r\n        rounds[currentRound].startRoundTime = getCurrentTime();\r\n        rounds[currentRound].state = RoundState.ACCEPT_FUNDS;\r\n        emit RoundStateChanged(currentRound, rounds[currentRound].state);\r\n        iRNG(rng).update.value(msg.value)(currentRound, rounds[currentRound].nonce, 0);\r\n    }\r\n\r\n    function startLottery(uint _startPeriod) public payable onlyLotteryContract {\r\n        _startPeriod;\r\n        currentRound = 1;\r\n        uint time = getCurrentTime();\r\n        rounds[currentRound].startRoundTime = time;\r\n        rounds[currentRound].state = RoundState.ACCEPT_FUNDS;\r\n        emit RoundStateChanged(currentRound, rounds[currentRound].state);\r\n        emit LotteryStarted(time);\r\n        checker.update.value(msg.value)();\r\n    }\r\n\r\n    function setChecker(address _checker) public onlyOwner {\r\n        require(_checker != address(0), \"\");\r\n\r\n        checker = IChecker(_checker);\r\n    }\r\n\r\n    function processRound(uint _round, uint _randomNumber) public payable onlyRng returns (bool) {\r\n        rounds[_round].random = _randomNumber;\r\n        rounds[_round].winningTickets.push(_randomNumber.mod(rounds[_round].ticketsCount));\r\n\r\n        address winner = getWinner(\r\n            _round,\r\n            0,\r\n            (rounds[_round].tickets.length).sub(1),\r\n            rounds[_round].winningTickets[0]\r\n        );\r\n\r\n        rounds[_round].winners.push(winner);\r\n        rounds[_round].winnersFunds[winner] = rounds[_round].roundFunds;\r\n        rounds[_round].state = RoundState.SUCCESS;\r\n\r\n        emit RoundStateChanged(_round, rounds[_round].state);\r\n        emit RoundProcecced(_round, rounds[_round].winners, rounds[_round].winningTickets, rounds[_round].roundFunds);\r\n\r\n        currentRound = currentRound.add(1);\r\n        rounds[currentRound].state = RoundState.ACCEPT_FUNDS;\r\n\r\n        emit RoundStateChanged(_round, rounds[_round].state);\r\n        return true;\r\n    }\r\n\r\n    function buyTickets(address _participant) public payable onlyLotteryContract {\r\n        require(msg.value > 0, \"\");\r\n\r\n        uint ticketsCount = msg.value.div(ticketPrice);\r\n        addParticipant(_participant, ticketsCount);\r\n\r\n        updateRoundFundsAndParticipants(_participant, msg.value);\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"addrTo\",\"type\":\"address\"}],\"name\":\"AddTokens\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"factor\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newFactor\",\"type\":\"uint256\"}],\"name\":\"setRoundFactor\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"bank\",\"type\":\"address\"}],\"name\":\"setLotteryBank\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ethBank\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"price\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lottery\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"GetEth\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"RealToken","CompilerVersion":"v0.5.4+commit.9549d8ff","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"FiatContract:8055d0504666e2B6942BeB8D6014c964658Ca591","SwarmSource":"bzzr://5d103d810f9ad4457958aa6ad15f061ee1d6459fa5af1efb5464a513997f317d"}]}