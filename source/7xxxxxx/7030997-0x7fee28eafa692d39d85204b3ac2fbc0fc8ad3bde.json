{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.18;\r\n\r\n// File: contracts/PermissionGroups.sol\r\n\r\ncontract PermissionGroups {\r\n\r\n    address public admin;\r\n    address public pendingAdmin;\r\n    mapping(address=>bool) internal operators;\r\n    mapping(address=>bool) internal alerters;\r\n    address[] internal operatorsGroup;\r\n    address[] internal alertersGroup;\r\n    uint constant internal MAX_GROUP_SIZE = 50;\r\n\r\n    function PermissionGroups() public {\r\n        admin = msg.sender;\r\n    }\r\n\r\n    modifier onlyAdmin() {\r\n        require(msg.sender == admin);\r\n        _;\r\n    }\r\n\r\n    modifier onlyOperator() {\r\n        require(operators[msg.sender]);\r\n        _;\r\n    }\r\n\r\n    modifier onlyAlerter() {\r\n        require(alerters[msg.sender]);\r\n        _;\r\n    }\r\n\r\n    function getOperators () external view returns(address[]) {\r\n        return operatorsGroup;\r\n    }\r\n\r\n    function getAlerters () external view returns(address[]) {\r\n        return alertersGroup;\r\n    }\r\n\r\n    event TransferAdminPending(address pendingAdmin);\r\n\r\n    /**\r\n     * @dev Allows the current admin to set the pendingAdmin address.\r\n     * @param newAdmin The address to transfer ownership to.\r\n     */\r\n    function transferAdmin(address newAdmin) public onlyAdmin {\r\n        require(newAdmin != address(0));\r\n        TransferAdminPending(pendingAdmin);\r\n        pendingAdmin = newAdmin;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current admin to set the admin in one tx. Useful initial deployment.\r\n     * @param newAdmin The address to transfer ownership to.\r\n     */\r\n    function transferAdminQuickly(address newAdmin) public onlyAdmin {\r\n        require(newAdmin != address(0));\r\n        TransferAdminPending(newAdmin);\r\n        AdminClaimed(newAdmin, admin);\r\n        admin = newAdmin;\r\n    }\r\n\r\n    event AdminClaimed( address newAdmin, address previousAdmin);\r\n\r\n    /**\r\n     * @dev Allows the pendingAdmin address to finalize the change admin process.\r\n     */\r\n    function claimAdmin() public {\r\n        require(pendingAdmin == msg.sender);\r\n        AdminClaimed(pendingAdmin, admin);\r\n        admin = pendingAdmin;\r\n        pendingAdmin = address(0);\r\n    }\r\n\r\n    event AlerterAdded (address newAlerter, bool isAdd);\r\n\r\n    function addAlerter(address newAlerter) public onlyAdmin {\r\n        require(!alerters[newAlerter]); // prevent duplicates.\r\n        require(alertersGroup.length < MAX_GROUP_SIZE);\r\n\r\n        AlerterAdded(newAlerter, true);\r\n        alerters[newAlerter] = true;\r\n        alertersGroup.push(newAlerter);\r\n    }\r\n\r\n    function removeAlerter (address alerter) public onlyAdmin {\r\n        require(alerters[alerter]);\r\n        alerters[alerter] = false;\r\n\r\n        for (uint i = 0; i < alertersGroup.length; ++i) {\r\n            if (alertersGroup[i] == alerter) {\r\n                alertersGroup[i] = alertersGroup[alertersGroup.length - 1];\r\n                alertersGroup.length--;\r\n                AlerterAdded(alerter, false);\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    event OperatorAdded(address newOperator, bool isAdd);\r\n\r\n    function addOperator(address newOperator) public onlyAdmin {\r\n        require(!operators[newOperator]); // prevent duplicates.\r\n        require(operatorsGroup.length < MAX_GROUP_SIZE);\r\n\r\n        OperatorAdded(newOperator, true);\r\n        operators[newOperator] = true;\r\n        operatorsGroup.push(newOperator);\r\n    }\r\n\r\n    function removeOperator (address operator) public onlyAdmin {\r\n        require(operators[operator]);\r\n        operators[operator] = false;\r\n\r\n        for (uint i = 0; i < operatorsGroup.length; ++i) {\r\n            if (operatorsGroup[i] == operator) {\r\n                operatorsGroup[i] = operatorsGroup[operatorsGroup.length - 1];\r\n                operatorsGroup.length -= 1;\r\n                OperatorAdded(operator, false);\r\n                break;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/permissionless/OrderListInterface.sol\r\n\r\ninterface OrderListInterface {\r\n    function getOrderDetails(uint32 orderId) public view returns (address, uint128, uint128, uint32, uint32);\r\n    function add(address maker, uint32 orderId, uint128 srcAmount, uint128 dstAmount) public returns (bool);\r\n    function remove(uint32 orderId) public returns (bool);\r\n    function update(uint32 orderId, uint128 srcAmount, uint128 dstAmount) public returns (bool);\r\n    function getFirstOrder() public view returns(uint32 orderId, bool isEmpty);\r\n    function allocateIds(uint32 howMany) public returns(uint32);\r\n    function findPrevOrderId(uint128 srcAmount, uint128 dstAmount) public view returns(uint32);\r\n\r\n    function addAfterId(address maker, uint32 orderId, uint128 srcAmount, uint128 dstAmount, uint32 prevId) public\r\n        returns (bool);\r\n\r\n    function updateWithPositionHint(uint32 orderId, uint128 srcAmount, uint128 dstAmount, uint32 prevId) public\r\n        returns(bool, uint);\r\n}\r\n\r\n// File: contracts/permissionless/OrderList.sol\r\n\r\ncontract OrderList is PermissionGroups, OrderListInterface {\r\n\r\n    struct Order {\r\n        address maker;\r\n        uint32 prevId;\r\n        uint32 nextId;\r\n        uint128 srcAmount;\r\n        uint128 dstAmount;\r\n    }\r\n\r\n    mapping (uint32 => Order) public orders;\r\n\r\n    // Results of calling updateWithPositionHint.\r\n    uint constant public UPDATE_ONLY_AMOUNTS = 0;\r\n    uint constant public UPDATE_MOVE_ORDER = 1;\r\n    uint constant public UPDATE_FAILED = 2;\r\n\r\n    uint32 constant public TAIL_ID = 1;\r\n    uint32 constant public HEAD_ID = 2;\r\n\r\n    uint32 public nextFreeId = 3;\r\n\r\n    function OrderList(address _admin) public {\r\n        require(_admin != address(0));\r\n\r\n        admin = _admin;\r\n\r\n        // Initializing a \"dummy\" order as HEAD.\r\n        orders[HEAD_ID].maker = 0;\r\n        orders[HEAD_ID].prevId = 0;\r\n        orders[HEAD_ID].nextId = TAIL_ID;\r\n        orders[HEAD_ID].srcAmount = 0;\r\n        orders[HEAD_ID].dstAmount = 0;\r\n    }\r\n\r\n    function getOrderDetails(uint32 orderId)\r\n        public\r\n        view\r\n        returns (\r\n            address maker,\r\n            uint128 srcAmount,\r\n            uint128 dstAmount,\r\n            uint32 prevId,\r\n            uint32 nextId\r\n        )\r\n    {\r\n        Order storage order = orders[orderId];\r\n\r\n        maker = order.maker;\r\n        srcAmount = order.srcAmount;\r\n        dstAmount = order.dstAmount;\r\n        prevId = order.prevId;\r\n        nextId = order.nextId;\r\n    }\r\n\r\n    function add(\r\n        address maker,\r\n        uint32 orderId,\r\n        uint128 srcAmount,\r\n        uint128 dstAmount\r\n    )\r\n        public\r\n        onlyAdmin\r\n        returns(bool)\r\n    {\r\n        require(orderId != 0 && orderId != HEAD_ID && orderId != TAIL_ID);\r\n\r\n        uint32 prevId = findPrevOrderId(srcAmount, dstAmount);\r\n        return addAfterValidId(maker, orderId, srcAmount, dstAmount, prevId);\r\n    }\r\n\r\n    // Returns false if provided with bad hint.\r\n    function addAfterId(\r\n        address maker,\r\n        uint32 orderId,\r\n        uint128 srcAmount,\r\n        uint128 dstAmount,\r\n        uint32 prevId\r\n    )\r\n        public\r\n        onlyAdmin\r\n        returns (bool)\r\n    {\r\n        uint32 nextId = orders[prevId].nextId;\r\n        if (!isRightPosition(srcAmount, dstAmount, prevId, nextId)) {\r\n            return false;\r\n        }\r\n        return addAfterValidId(maker, orderId, srcAmount, dstAmount, prevId);\r\n    }\r\n\r\n    function remove(uint32 orderId) public onlyAdmin returns (bool) {\r\n        verifyCanRemoveOrderById(orderId);\r\n\r\n        // Disconnect order from list\r\n        Order storage order = orders[orderId];\r\n        orders[order.prevId].nextId = order.nextId;\r\n        orders[order.nextId].prevId = order.prevId;\r\n\r\n        // Mark deleted order\r\n        order.prevId = TAIL_ID;\r\n        order.nextId = HEAD_ID;\r\n\r\n        return true;\r\n    }\r\n\r\n    function update(uint32 orderId, uint128 srcAmount, uint128 dstAmount)\r\n        public\r\n        onlyAdmin\r\n        returns(bool)\r\n    {\r\n        address maker = orders[orderId].maker;\r\n        require(remove(orderId));\r\n        require(add(maker, orderId, srcAmount, dstAmount));\r\n\r\n        return true;\r\n    }\r\n\r\n    // Returns false if provided with a bad hint.\r\n    function updateWithPositionHint(\r\n        uint32 orderId,\r\n        uint128 updatedSrcAmount,\r\n        uint128 updatedDstAmount,\r\n        uint32 updatedPrevId\r\n    )\r\n        public\r\n        onlyAdmin\r\n        returns (bool, uint)\r\n    {\r\n        require(orderId != 0 && orderId != HEAD_ID && orderId != TAIL_ID);\r\n\r\n        // Normal orders usually cannot serve as their own previous order.\r\n        // For further discussion see Heinlein's '—All You Zombies—'.\r\n        require(orderId != updatedPrevId);\r\n\r\n        uint32 nextId;\r\n\r\n        // updatedPrevId is the intended prevId of the order, after updating its\r\n        // values.\r\n        // If it is the same as the current prevId of the order, the order does\r\n        // not need to change place in the list, only update its amounts.\r\n        if (orders[orderId].prevId == updatedPrevId) {\r\n            nextId = orders[orderId].nextId;\r\n            if (isRightPosition(\r\n                updatedSrcAmount,\r\n                updatedDstAmount,\r\n                updatedPrevId,\r\n                nextId)\r\n            ) {\r\n                orders[orderId].srcAmount = updatedSrcAmount;\r\n                orders[orderId].dstAmount = updatedDstAmount;\r\n                return (true, UPDATE_ONLY_AMOUNTS);\r\n            }\r\n        } else {\r\n            nextId = orders[updatedPrevId].nextId;\r\n            if (isRightPosition(\r\n                updatedSrcAmount,\r\n                updatedDstAmount,\r\n                updatedPrevId,\r\n                nextId)\r\n            ) {\r\n                // Let's move the order to the hinted position.\r\n                address maker = orders[orderId].maker;\r\n                require(remove(orderId));\r\n                require(\r\n                    addAfterValidId(\r\n                        maker,\r\n                        orderId,\r\n                        updatedSrcAmount,\r\n                        updatedDstAmount,\r\n                        updatedPrevId\r\n                    )\r\n                );\r\n                return (true, UPDATE_MOVE_ORDER);\r\n            }\r\n        }\r\n\r\n        // bad hint.\r\n        return (false, UPDATE_FAILED);\r\n    }\r\n\r\n    function allocateIds(uint32 howMany) public onlyAdmin returns(uint32) {\r\n        uint32 firstId = nextFreeId;\r\n        require(nextFreeId + howMany >= nextFreeId);\r\n        nextFreeId += howMany;\r\n        return firstId;\r\n    }\r\n\r\n    function compareOrders(\r\n        uint128 srcAmount1,\r\n        uint128 dstAmount1,\r\n        uint128 srcAmount2,\r\n        uint128 dstAmount2\r\n    )\r\n        public\r\n        pure\r\n        returns(int)\r\n    {\r\n        uint256 s1 = srcAmount1;\r\n        uint256 d1 = dstAmount1;\r\n        uint256 s2 = srcAmount2;\r\n        uint256 d2 = dstAmount2;\r\n\r\n        if (s2 * d1 < s1 * d2) return -1;\r\n        if (s2 * d1 > s1 * d2) return 1;\r\n        return 0;\r\n    }\r\n\r\n    function findPrevOrderId(uint128 srcAmount, uint128 dstAmount)\r\n        public\r\n        view\r\n        returns(uint32)\r\n    {\r\n        uint32 currId = HEAD_ID;\r\n        Order storage curr = orders[currId];\r\n\r\n        while (curr.nextId != TAIL_ID) {\r\n            currId = curr.nextId;\r\n            curr = orders[currId];\r\n            int cmp = compareOrders(\r\n                srcAmount,\r\n                dstAmount,\r\n                curr.srcAmount,\r\n                curr.dstAmount\r\n            );\r\n\r\n            if (cmp < 0) {\r\n                return curr.prevId;\r\n            }\r\n        }\r\n        return currId;\r\n    }\r\n\r\n    function getFirstOrder() public view returns(uint32 orderId, bool isEmpty) {\r\n        return (\r\n            orders[HEAD_ID].nextId,\r\n            orders[HEAD_ID].nextId == TAIL_ID\r\n        );\r\n    }\r\n\r\n    function addAfterValidId(\r\n        address maker,\r\n        uint32 orderId,\r\n        uint128 srcAmount,\r\n        uint128 dstAmount,\r\n        uint32 prevId\r\n    )\r\n        private\r\n        returns(bool)\r\n    {\r\n        Order storage prevOrder = orders[prevId];\r\n\r\n        // Add new order\r\n        orders[orderId].maker = maker;\r\n        orders[orderId].prevId = prevId;\r\n        orders[orderId].nextId = prevOrder.nextId;\r\n        orders[orderId].srcAmount = srcAmount;\r\n        orders[orderId].dstAmount = dstAmount;\r\n\r\n        // Update next order to point back to added order\r\n        uint32 nextOrderId = prevOrder.nextId;\r\n        if (nextOrderId != TAIL_ID) {\r\n            orders[nextOrderId].prevId = orderId;\r\n        }\r\n\r\n        // Update previous order to point to added order\r\n        prevOrder.nextId = orderId;\r\n\r\n        return true;\r\n    }\r\n\r\n    function verifyCanRemoveOrderById(uint32 orderId) private view {\r\n        require(orderId != 0 && orderId != HEAD_ID && orderId != TAIL_ID);\r\n\r\n        Order storage order = orders[orderId];\r\n\r\n        // Make sure such order exists in mapping.\r\n        require(order.prevId != 0 || order.nextId != 0);\r\n    }\r\n\r\n    function isRightPosition(\r\n        uint128 srcAmount,\r\n        uint128 dstAmount,\r\n        uint32 prevId,\r\n        uint32 nextId\r\n    )\r\n        private\r\n        view\r\n        returns (bool)\r\n    {\r\n        if (prevId == TAIL_ID || nextId == HEAD_ID) return false;\r\n\r\n        Order storage prev = orders[prevId];\r\n\r\n        // Make sure prev order is either HEAD or properly initialised.\r\n        if (prevId != HEAD_ID && (\r\n                prev.prevId == 0 ||\r\n                prev.nextId == 0 ||\r\n                prev.prevId == TAIL_ID ||\r\n                prev.nextId == HEAD_ID)) {\r\n            return false;\r\n        }\r\n\r\n        int cmp;\r\n        // Make sure that the new order should be after the provided prevId.\r\n        if (prevId != HEAD_ID) {\r\n            cmp = compareOrders(\r\n                srcAmount,\r\n                dstAmount,\r\n                prev.srcAmount,\r\n                prev.dstAmount\r\n            );\r\n            // new order is better than prev\r\n            if (cmp < 0) return false;\r\n        }\r\n\r\n        // Make sure that the new order should be before provided prevId's next order.\r\n        if (nextId != TAIL_ID) {\r\n            Order storage next = orders[nextId];\r\n            cmp = compareOrders(\r\n                srcAmount,\r\n                dstAmount,\r\n                next.srcAmount,\r\n                next.dstAmount\r\n            );\r\n            // new order is worse than next\r\n            if (cmp > 0) return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n}\r\n\r\n// File: contracts/permissionless/OrderListFactory.sol\r\n\r\ncontract OrderListFactory {\r\n    function newOrdersContract(address admin) public returns(OrderListInterface) {\r\n        OrderList orders = new OrderList(admin);\r\n        return orders;\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"admin\",\"type\":\"address\"}],\"name\":\"newOrdersContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"OrderListFactory","CompilerVersion":"v0.4.18+commit.9cf6e910","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://6dc33cf854b0dfb1c33ef943b0339c86c7094f40ae148825099a9e4c48bb8805"}]}