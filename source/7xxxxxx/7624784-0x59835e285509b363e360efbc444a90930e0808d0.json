{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.0;\r\n\r\n\r\ncontract IOwnable {\r\n\r\n    address public owner;\r\n    address public newOwner;\r\n\r\n    event OwnerChanged(address _oldOwner, address _newOwner);\r\n\r\n    function changeOwner(address _newOwner) public;\r\n    function acceptOwnership() public;\r\n}\r\n\r\ncontract Ownable is IOwnable {\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n        emit OwnerChanged(address(0), owner);\r\n    }\r\n\r\n    function changeOwner(address _newOwner) public onlyOwner {\r\n        newOwner = _newOwner;\r\n    }\r\n\r\n    function acceptOwnership() public {\r\n        require(msg.sender == newOwner);\r\n        emit OwnerChanged(owner, newOwner);\r\n        owner = newOwner;\r\n        newOwner = address(0);\r\n    }\r\n}\r\n\r\n\r\ncontract IERC20Token {\r\n    string public name;\r\n    string public symbol;\r\n    uint8 public decimals;\r\n    uint256 public totalSupply;\r\n\r\n    function balanceOf(address _owner) public view returns (uint256 balance);\r\n    function transfer(address _to, uint256 _value)  public returns (bool success);\r\n    function transferFrom(address _from, address _to, uint256 _value)  public returns (bool success);\r\n    function approve(address _spender, uint256 _value)  public returns (bool success);\r\n    function allowance(address _owner, address _spender)  public view returns (uint256 remaining);\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}\r\n\r\n\r\ncontract IWinbixToken is IERC20Token {\r\n\r\n    uint256 public votableTotal;\r\n    uint256 public accruableTotal;\r\n    address public issuer;\r\n    bool public transferAllowed;\r\n\r\n    mapping (address => bool) public isPayable;\r\n\r\n    event SetIssuer(address _address);\r\n    event TransferAllowed(bool _newState);\r\n    event FreezeWallet(address _address);\r\n    event UnfreezeWallet(address _address);\r\n    event IssueTokens(address indexed _to, uint256 _value);\r\n    event IssueVotable(address indexed _to, uint256 _value);\r\n    event IssueAccruable(address indexed _to, uint256 _value);\r\n    event BurnTokens(address indexed _from, uint256 _value);\r\n    event BurnVotable(address indexed _from, uint256 _value);\r\n    event BurnAccruable(address indexed _from, uint256 _value);\r\n    event SetPayable(address _address, bool _state);\r\n\r\n    function setIssuer(address _address) public;\r\n    function allowTransfer(bool _allowTransfer) public;\r\n    function freeze(address _address) public;\r\n    function unfreeze(address _address) public;\r\n    function isFrozen(address _address) public returns (bool);\r\n    function issue(address _to, uint256 _value) public;\r\n    function issueVotable(address _to, uint256 _value) public;\r\n    function issueAccruable(address _to, uint256 _value) public;\r\n    function votableBalanceOf(address _address) public view returns (uint256);\r\n    function accruableBalanceOf(address _address) public view returns (uint256);\r\n    function burn(uint256 _value) public;\r\n    function burnAll() public;\r\n    function increaseApproval(address _spender, uint256 _addedValue) public returns (bool);\r\n    function decreaseApproval(address _spender, uint256 _subtractedValue) public returns (bool);\r\n    function setMePayable(bool _state) public;\r\n}\r\n\r\ncontract ITap is IOwnable {\r\n\r\n    uint8[12] public tapPercents = [2, 2, 3, 11, 11, 17, 11, 11, 8, 8, 8, 8];\r\n    uint8 public nextTapNum;\r\n    uint8 public nextTapPercent = tapPercents[nextTapNum];\r\n    uint public nextTapDate;\r\n    uint public remainsForTap;\r\n    uint public baseEther;\r\n\r\n    function init(uint _baseEther, uint _startDate) public;\r\n    function changeNextTap(uint8 _newPercent) public;\r\n    function getNext() public returns (uint);\r\n    function subRemainsForTap(uint _delta) public;\r\n}\r\n\r\ncontract IRefund is IOwnable {\r\n    \r\n    ITap public tap;\r\n    uint public refundedTokens;\r\n    uint public tokensBase;\r\n\r\n    function init(uint _tokensBase, address _tap, uint _startDate) public;\r\n    function refundEther(uint _value) public returns (uint);\r\n    function calculateEtherForRefund(uint _tokensAmount) public view returns (uint);\r\n}\r\n\r\ncontract Refund is IRefund, Ownable {\r\n\r\n    uint startDate;\r\n\r\n    function init(uint _tokensBase, address _tap, uint _startDate) public onlyOwner {\r\n        tap = ITap(_tap);\r\n        tokensBase = _tokensBase;\r\n        startDate = _startDate;\r\n    }\r\n\r\n    function refundEther(uint _value) public onlyOwner returns (uint) {\r\n        uint etherForRefund = calculateEtherForRefund(_value);\r\n        refundedTokens += _value;\r\n        return etherForRefund;\r\n    }\r\n\r\n    function calculateEtherForRefund(uint _tokensAmount) public view returns (uint) {\r\n        require(startDate > 0 && now > startDate && tokensBase > 0);\r\n        uint etherRemains = tap.remainsForTap();\r\n        if (_tokensAmount == 0 || etherRemains == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint etherForRefund;\r\n\r\n        uint startPart = refundedTokens + 1;\r\n        uint endValue = refundedTokens + _tokensAmount;\r\n        require(endValue <= tokensBase);\r\n\r\n        uint refundCoeff;\r\n        uint nextStart;\r\n        uint endPart;\r\n        uint partTokensValue;\r\n        uint tokensRemains = tokensBase - refundedTokens;\r\n\r\n        while (true) {\r\n            refundCoeff = _refundCoeff(startPart);\r\n            nextStart = _nextStart(refundCoeff);\r\n            endPart = nextStart - 1;\r\n            if (endPart > endValue) endPart = endValue;\r\n            partTokensValue = endPart - startPart + 1;\r\n            etherForRefund += refundCoeff * (etherRemains - etherForRefund) * partTokensValue / tokensRemains / 100;\r\n            if (nextStart > endValue) break;\r\n            startPart = nextStart;\r\n            tokensRemains -= partTokensValue;\r\n        }\r\n        return etherForRefund;\r\n    }\r\n\r\n    function _refundCoeff(uint _tokensValue) private view returns (uint) {\r\n        uint refundedPercent = 100 * _tokensValue / tokensBase;\r\n        if (refundedPercent < 10) {\r\n            return 80;\r\n        } else if (refundedPercent < 20) {\r\n            return 85;\r\n        } else if (refundedPercent < 30) {\r\n            return 90;\r\n        } else if (refundedPercent < 40) {\r\n            return 95;\r\n        } else {\r\n            return 100;\r\n        }\r\n    }\r\n\r\n    function _nextStart(uint _refundCoefficient) private view returns (uint) {\r\n        uint res;\r\n        if (_refundCoefficient == 80) {\r\n            res = tokensBase * 10 / 100;\r\n        } else if (_refundCoefficient == 85) {\r\n            res = tokensBase * 20 / 100;\r\n        } else if (_refundCoefficient == 90) {\r\n            res = tokensBase * 30 / 100;\r\n        } else if (_refundCoefficient == 95) {\r\n            res = tokensBase * 40 / 100;\r\n        } else {\r\n            return tokensBase+1;\r\n        }\r\n        if (_refundCoeff(res) == _refundCoefficient) res += 1;\r\n        return res;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"tokensBase\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokensAmount\",\"type\":\"uint256\"}],\"name\":\"calculateEtherForRefund\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"refundedTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"newOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokensBase\",\"type\":\"uint256\"},{\"name\":\"_tap\",\"type\":\"address\"},{\"name\":\"_startDate\",\"type\":\"uint256\"}],\"name\":\"init\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tap\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"refundEther\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_oldOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"OwnerChanged\",\"type\":\"event\"}]","ContractName":"Refund","CompilerVersion":"v0.5.4+commit.9549d8ff","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://9f237d602ef4a1db581ad76c553d0d6d72554f38dfae793dd2a5101327f3a842"}]}