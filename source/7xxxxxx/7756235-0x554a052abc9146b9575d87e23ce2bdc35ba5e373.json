{"status":"1","message":"OK","result":[{"SourceCode":"// File: openzeppelin-solidity/contracts/access/Roles.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n/**\r\n * @title Roles\r\n * @dev Library for managing addresses assigned to a Role.\r\n */\r\nlibrary Roles {\r\n    struct Role {\r\n        mapping (address => bool) bearer;\r\n    }\r\n\r\n    /**\r\n     * @dev give an account access to this role\r\n     */\r\n    function add(Role storage role, address account) internal {\r\n        require(account != address(0));\r\n        require(!has(role, account));\r\n\r\n        role.bearer[account] = true;\r\n    }\r\n\r\n    /**\r\n     * @dev remove an account's access to this role\r\n     */\r\n    function remove(Role storage role, address account) internal {\r\n        require(account != address(0));\r\n        require(has(role, account));\r\n\r\n        role.bearer[account] = false;\r\n    }\r\n\r\n    /**\r\n     * @dev check if an account has this role\r\n     * @return bool\r\n     */\r\n    function has(Role storage role, address account) internal view returns (bool) {\r\n        require(account != address(0));\r\n        return role.bearer[account];\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/access/roles/PauserRole.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n\r\ncontract PauserRole {\r\n    using Roles for Roles.Role;\r\n\r\n    event PauserAdded(address indexed account);\r\n    event PauserRemoved(address indexed account);\r\n\r\n    Roles.Role private _pausers;\r\n\r\n    constructor () internal {\r\n        _addPauser(msg.sender);\r\n    }\r\n\r\n    modifier onlyPauser() {\r\n        require(isPauser(msg.sender));\r\n        _;\r\n    }\r\n\r\n    function isPauser(address account) public view returns (bool) {\r\n        return _pausers.has(account);\r\n    }\r\n\r\n    function addPauser(address account) public onlyPauser {\r\n        _addPauser(account);\r\n    }\r\n\r\n    function renouncePauser() public {\r\n        _removePauser(msg.sender);\r\n    }\r\n\r\n    function _addPauser(address account) internal {\r\n        _pausers.add(account);\r\n        emit PauserAdded(account);\r\n    }\r\n\r\n    function _removePauser(address account) internal {\r\n        _pausers.remove(account);\r\n        emit PauserRemoved(account);\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/lifecycle/Pausable.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n\r\n/**\r\n * @title Pausable\r\n * @dev Base contract which allows children to implement an emergency stop mechanism.\r\n */\r\ncontract Pausable is PauserRole {\r\n    event Paused(address account);\r\n    event Unpaused(address account);\r\n\r\n    bool private _paused;\r\n\r\n    constructor () internal {\r\n        _paused = false;\r\n    }\r\n\r\n    /**\r\n     * @return true if the contract is paused, false otherwise.\r\n     */\r\n    function paused() public view returns (bool) {\r\n        return _paused;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to make a function callable only when the contract is not paused.\r\n     */\r\n    modifier whenNotPaused() {\r\n        require(!_paused);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to make a function callable only when the contract is paused.\r\n     */\r\n    modifier whenPaused() {\r\n        require(_paused);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev called by the owner to pause, triggers stopped state\r\n     */\r\n    function pause() public onlyPauser whenNotPaused {\r\n        _paused = true;\r\n        emit Paused(msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @dev called by the owner to unpause, returns to normal state\r\n     */\r\n    function unpause() public onlyPauser whenPaused {\r\n        _paused = false;\r\n        emit Unpaused(msg.sender);\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n     * account.\r\n     */\r\n    constructor () internal {\r\n        _owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), _owner);\r\n    }\r\n\r\n    /**\r\n     * @return the address of the owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner());\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @return true if `msg.sender` is the owner of the contract.\r\n     */\r\n    function isOwner() public view returns (bool) {\r\n        return msg.sender == _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to relinquish control of the contract.\r\n     * It will not be possible to call the functions with the `onlyOwner`\r\n     * modifier anymore.\r\n     * @notice Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0));\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/utils/ReentrancyGuard.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n/**\r\n * @title Helps contracts guard against reentrancy attacks.\r\n * @author Remco Bloemen <remco@2Ï€.com>, Eenae <alexey@mixbytes.io>\r\n * @dev If you mark a function `nonReentrant`, you should also\r\n * mark it `external`.\r\n */\r\ncontract ReentrancyGuard {\r\n    /// @dev counter to allow mutex lock with only one SSTORE operation\r\n    uint256 private _guardCounter;\r\n\r\n    constructor () internal {\r\n        // The counter starts at one to prevent changing it from zero to a non-zero\r\n        // value, which is a more expensive operation.\r\n        _guardCounter = 1;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and make it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        _guardCounter += 1;\r\n        uint256 localCounter = _guardCounter;\r\n        _;\r\n        require(localCounter == _guardCounter);\r\n    }\r\n}\r\n\r\n// File: contracts/interfaces/IIssuer.sol\r\n\r\npragma solidity 0.5.4;\r\n\r\n\r\ninterface IIssuer {\r\n    event Issued(address indexed payee, uint amount);\r\n    event Claimed(address indexed payee, uint amount);\r\n    event FinishedIssuing(address indexed issuer);\r\n\r\n    function issue(address payee, uint amount) external;\r\n    function claim() external;\r\n    function airdrop(address payee, uint amount) external;\r\n    function isRunning() external view returns (bool);\r\n}\r\n\r\n// File: contracts/interfaces/IERC1594.sol\r\n\r\npragma solidity 0.5.4;\r\n\r\n\r\n/// @title IERC1594 Security Token Standard\r\n/// @dev See https://github.com/SecurityTokenStandard/EIP-Spec\r\ninterface IERC1594 {\r\n    // Issuance / Redemption Events\r\n    event Issued(address indexed _operator, address indexed _to, uint256 _value, bytes _data);\r\n    event Redeemed(address indexed _operator, address indexed _from, uint256 _value, bytes _data);\r\n\r\n    // Transfers\r\n    function transferWithData(address _to, uint256 _value, bytes calldata _data) external;\r\n    function transferFromWithData(address _from, address _to, uint256 _value, bytes calldata _data) external;\r\n\r\n    // Token Redemption\r\n    function redeem(uint256 _value, bytes calldata _data) external;\r\n    function redeemFrom(address _tokenHolder, uint256 _value, bytes calldata _data) external;\r\n\r\n    // Token Issuance\r\n    function issue(address _tokenHolder, uint256 _value, bytes calldata _data) external;\r\n    function isIssuable() external view returns (bool);\r\n\r\n    // Transfer Validity\r\n    function canTransfer(address _to, uint256 _value, bytes calldata _data) external view returns (bool, byte, bytes32);\r\n    function canTransferFrom(address _from, address _to, uint256 _value, bytes calldata _data) external view returns (bool, byte, bytes32);\r\n}\r\n\r\n// File: contracts/interfaces/IHasIssuership.sol\r\n\r\npragma solidity 0.5.4;\r\n\r\n\r\ninterface IHasIssuership {\r\n    event IssuershipTransferred(address indexed from, address indexed to);\r\n\r\n    function transferIssuership(address newIssuer) external;\r\n}\r\n\r\n// File: contracts/roles/IssuerStaffRole.sol\r\n\r\npragma solidity 0.5.4;\r\n\r\n\r\n\r\n// @notice IssuerStaffs are capable of managing over the Issuer contract.\r\ncontract IssuerStaffRole {\r\n    using Roles for Roles.Role;\r\n\r\n    event IssuerStaffAdded(address indexed account);\r\n    event IssuerStaffRemoved(address indexed account);\r\n\r\n    Roles.Role internal _issuerStaffs;\r\n\r\n    modifier onlyIssuerStaff() {\r\n        require(isIssuerStaff(msg.sender), \"Only IssuerStaffs can execute this function.\");\r\n        _;\r\n    }\r\n\r\n    constructor() internal {\r\n        _addIssuerStaff(msg.sender);\r\n    }\r\n\r\n    function isIssuerStaff(address account) public view returns (bool) {\r\n        return _issuerStaffs.has(account);\r\n    }\r\n\r\n    function addIssuerStaff(address account) public onlyIssuerStaff {\r\n        _addIssuerStaff(account);\r\n    }\r\n\r\n    function renounceIssuerStaff() public {\r\n        _removeIssuerStaff(msg.sender);\r\n    }\r\n\r\n    function _addIssuerStaff(address account) internal {\r\n        _issuerStaffs.add(account);\r\n        emit IssuerStaffAdded(account);\r\n    }\r\n\r\n    function _removeIssuerStaff(address account) internal {\r\n        _issuerStaffs.remove(account);\r\n        emit IssuerStaffRemoved(account);\r\n    }\r\n}\r\n\r\n// File: contracts/issuance/Issuer.sol\r\n\r\npragma solidity 0.5.4;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @notice The Issuer issues claims for TENX tokens which users can claim to receive tokens.\r\n */\r\ncontract Issuer is IIssuer, IHasIssuership, IssuerStaffRole, Ownable, Pausable, ReentrancyGuard {\r\n    struct Claim {\r\n        address issuer;\r\n        ClaimState status;\r\n        uint amount;\r\n    }\r\n\r\n    enum ClaimState { NONE, ISSUED, CLAIMED }\r\n    mapping(address => Claim) public claims;\r\n\r\n    bool public isRunning = true;\r\n    IERC1594 public token; // Mints tokens to payee's address\r\n\r\n    event Issued(address indexed payee, address indexed issuer, uint amount);\r\n    event Claimed(address indexed payee, uint amount);\r\n\r\n    /**\r\n    * @notice Modifier to check that the Issuer contract is currently running.\r\n    */\r\n    modifier whenRunning() {\r\n        require(isRunning, \"Issuer contract has stopped running.\");\r\n        _;\r\n    }    \r\n\r\n    /**\r\n    * @notice Modifier to check the status of a claim.\r\n    * @param _payee Payee address\r\n    * @param _state Claim status    \r\n    */\r\n    modifier atState(address _payee, ClaimState _state) {\r\n        Claim storage c = claims[_payee];\r\n        require(c.status == _state, \"Invalid claim source state.\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @notice Modifier to check the status of a claim.\r\n    * @param _payee Payee address\r\n    * @param _state Claim status\r\n    */\r\n    modifier notAtState(address _payee, ClaimState _state) {\r\n        Claim storage c = claims[_payee];\r\n        require(c.status != _state, \"Invalid claim source state.\");\r\n        _;\r\n    }\r\n\r\n    constructor(IERC1594 _token) public {\r\n        token = _token;\r\n    }\r\n\r\n    /**\r\n     * @notice Transfer the token's Issuer role from this contract to another address. Decommissions this Issuer contract.\r\n     */\r\n    function transferIssuership(address _newIssuer) \r\n        external onlyOwner whenRunning \r\n    {\r\n        require(_newIssuer != address(0), \"New Issuer cannot be zero address.\");\r\n        isRunning = false;\r\n        IHasIssuership t = IHasIssuership(address(token));\r\n        t.transferIssuership(_newIssuer);\r\n    }\r\n\r\n    /**\r\n    * @notice Issue a new claim.\r\n    * @param _payee The address of the _payee.\r\n    * @param _amount The amount of tokens the payee will receive.\r\n    */\r\n    function issue(address _payee, uint _amount) \r\n        external onlyIssuerStaff whenRunning whenNotPaused notAtState(_payee, ClaimState.CLAIMED) \r\n    {\r\n        require(_payee != address(0), \"Payee must not be a zero address.\");\r\n        require(_payee != msg.sender, \"Issuers cannot issue for themselves\");\r\n        require(_amount > 0, \"Claim amount must be positive.\");\r\n        claims[_payee] = Claim({\r\n            status: ClaimState.ISSUED,\r\n            amount: _amount,\r\n            issuer: msg.sender\r\n        });\r\n        emit Issued(_payee, msg.sender, _amount);\r\n    }\r\n\r\n    /**\r\n    * @notice Function for users to redeem a claim of tokens.\r\n    * @dev To claim, users must call this contract from their claim address. Tokens equal to the claim amount will be minted to the claim address.\r\n    */\r\n    function claim() \r\n        external whenRunning whenNotPaused atState(msg.sender, ClaimState.ISSUED) \r\n    {\r\n        address payee = msg.sender;\r\n        Claim storage c = claims[payee];\r\n        c.status = ClaimState.CLAIMED; // Marks claim as claimed\r\n        emit Claimed(payee, c.amount);\r\n\r\n        token.issue(payee, c.amount, \"\"); // Mints tokens to payee's address\r\n    }\r\n\r\n    /**\r\n    * @notice Function to mint tokens to users directly in a single step. Skips the issued state.\r\n    * @param _payee The address of the _payee.\r\n    * @param _amount The amount of tokens the payee will receive.    \r\n    */\r\n    function airdrop(address _payee, uint _amount) \r\n        external onlyIssuerStaff whenRunning whenNotPaused atState(_payee, ClaimState.NONE) nonReentrant \r\n    {\r\n        require(_payee != address(0), \"Payee must not be a zero address.\");\r\n        require(_payee != msg.sender, \"Issuers cannot airdrop for themselves\");\r\n        require(_amount > 0, \"Claim amount must be positive.\");\r\n        claims[_payee] = Claim({\r\n            status: ClaimState.CLAIMED,\r\n            amount: _amount,\r\n            issuer: msg.sender\r\n        });\r\n        emit Claimed(_payee, _amount);\r\n\r\n        token.issue(_payee, _amount, \"\"); // Mints tokens to payee's address\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"isRunning\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isPauser\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claim\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isIssuerStaff\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renouncePauser\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"addPauser\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_payee\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"issue\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_payee\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"airdrop\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newIssuer\",\"type\":\"address\"}],\"name\":\"transferIssuership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"addIssuerStaff\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"claims\",\"outputs\":[{\"name\":\"issuer\",\"type\":\"address\"},{\"name\":\"status\",\"type\":\"uint8\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceIssuerStaff\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"payee\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"issuer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Issued\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"payee\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Claimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"PauserAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"PauserRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"IssuerStaffAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"IssuerStaffRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"}],\"name\":\"IssuershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"payee\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Issued\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"issuer\",\"type\":\"address\"}],\"name\":\"FinishedIssuing\",\"type\":\"event\"}]","ContractName":"Issuer","CompilerVersion":"v0.5.4+commit.9549d8ff","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000515ba0a2e286af10115284f151cf398688a69170","Library":"","SwarmSource":"bzzr://b370474f6c338c1941893723b9831478876cfbcc45349b7716f2e37b573929a7"}]}