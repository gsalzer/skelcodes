{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.23;\r\n\r\n/// math.sol -- mixin for inline numerical wizardry\r\n\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\npragma solidity ^0.4.13;\r\n\r\ncontract DSMath {\r\n    function add(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x + y) >= x);\r\n    }\r\n    function sub(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x - y) <= x);\r\n    }\r\n    function mul(uint x, uint y) internal pure returns (uint z) {\r\n        require(y == 0 || (z = x * y) / y == x);\r\n    }\r\n\r\n    function min(uint x, uint y) internal pure returns (uint z) {\r\n        return x <= y ? x : y;\r\n    }\r\n    function max(uint x, uint y) internal pure returns (uint z) {\r\n        return x >= y ? x : y;\r\n    }\r\n    function imin(int x, int y) internal pure returns (int z) {\r\n        return x <= y ? x : y;\r\n    }\r\n    function imax(int x, int y) internal pure returns (int z) {\r\n        return x >= y ? x : y;\r\n    }\r\n\r\n    uint constant WAD = 10 ** 18;\r\n    uint constant RAY = 10 ** 27;\r\n\r\n    function wmul(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, y), WAD / 2) / WAD;\r\n    }\r\n    function rmul(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, y), RAY / 2) / RAY;\r\n    }\r\n    function wdiv(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, WAD), y / 2) / y;\r\n    }\r\n    function rdiv(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, RAY), y / 2) / y;\r\n    }\r\n\r\n    // This famous algorithm is called \"exponentiation by squaring\"\r\n    // and calculates x^n with x as fixed-point and n as regular unsigned.\r\n    //\r\n    // It's O(log n), instead of O(n) for naive repeated multiplication.\r\n    //\r\n    // These facts are why it works:\r\n    //\r\n    //  If n is even, then x^n = (x^2)^(n/2).\r\n    //  If n is odd,  then x^n = x * x^(n-1),\r\n    //   and applying the equation for even x gives\r\n    //    x^n = x * (x^2)^((n-1) / 2).\r\n    //\r\n    //  Also, EVM division is flooring and\r\n    //    floor[(n-1) / 2] = floor[n / 2].\r\n    //\r\n    function rpow(uint x, uint n) internal pure returns (uint z) {\r\n        z = n % 2 != 0 ? x : RAY;\r\n\r\n        for (n /= 2; n != 0; n /= 2) {\r\n            x = rmul(x, x);\r\n\r\n            if (n % 2 != 0) {\r\n                z = rmul(z, x);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\ncontract TubInterface {\r\n    function open() public returns (bytes32);\r\n    function join(uint) public;\r\n    function exit(uint) public;\r\n    function lock(bytes32, uint) public;\r\n    function free(bytes32, uint) public;\r\n    function draw(bytes32, uint) public;\r\n    function wipe(bytes32, uint) public;\r\n    function give(bytes32, address) public;\r\n    function shut(bytes32) public;\r\n    function cups(bytes32) public view returns (address, uint, uint, uint);\r\n    function gem() public view returns (TokenInterface);\r\n    function gov() public view returns (TokenInterface);\r\n    function skr() public view returns (TokenInterface);\r\n    function sai() public view returns (TokenInterface);\r\n    function mat() public view returns (uint);\r\n    function ink(bytes32) public view returns (uint);\r\n    function tab(bytes32) public view returns (uint);\r\n    function rap(bytes32) public view returns (uint);\r\n    function per() public view returns (uint);\r\n    function pep() public view returns (PepInterface);\r\n}\r\n\r\ncontract TokenInterface {\r\n    function allowance(address, address) public view returns (uint);\r\n    function balanceOf(address) public view returns (uint);\r\n    function approve(address, uint) public;\r\n    function transfer(address, uint) public returns (bool);\r\n    function transferFrom(address, address, uint) public returns (bool);\r\n    function deposit() public payable;\r\n    function withdraw(uint) public;\r\n}\r\n\r\ncontract PepInterface {\r\n    function peek() public returns (bytes32, bool);\r\n}\r\n\r\ncontract OtcInterface {\r\n    function getPayAmount(address, address, uint) public view returns (uint);\r\n    function buyAllAmount(address, uint, address pay_gem, uint) public returns (uint);\r\n}\r\n\r\ncontract SaiProxy is DSMath {\r\n    function open(address tub_) public returns (bytes32) {\r\n        return TubInterface(tub_).open();\r\n    }\r\n\r\n    function give(address tub_, bytes32 cup, address lad) public {\r\n        TubInterface(tub_).give(cup, lad);\r\n    }\r\n\r\n    function lock(address tub_, bytes32 cup) public payable {\r\n        if (msg.value > 0) {\r\n            TubInterface tub = TubInterface(tub_);\r\n\r\n            (address lad,,,) = tub.cups(cup);\r\n            require(lad == address(this), \"cup-not-owned\");\r\n\r\n            tub.gem().deposit.value(msg.value)();\r\n\r\n            uint ink = rdiv(msg.value, tub.per());\r\n            ink = rmul(ink, tub.per()) <= msg.value ? ink : ink - 1;\r\n\r\n            if (tub.gem().allowance(this, tub) != uint(-1)) {\r\n                tub.gem().approve(tub, uint(-1));\r\n            }\r\n            tub.join(ink);\r\n\r\n            if (tub.skr().allowance(this, tub) != uint(-1)) {\r\n                tub.skr().approve(tub, uint(-1));\r\n            }\r\n            tub.lock(cup, ink);\r\n        }\r\n    }\r\n\r\n    function draw(address tub_, bytes32 cup, uint wad) public {\r\n        if (wad > 0) {\r\n            TubInterface tub = TubInterface(tub_);\r\n            tub.draw(cup, wad);\r\n            tub.sai().transfer(msg.sender, wad);\r\n        }\r\n    }\r\n\r\n    function handleGovFee(TubInterface tub, uint saiDebtFee, address otc_) internal {\r\n        bytes32 val;\r\n        bool ok;\r\n        (val, ok) = tub.pep().peek();\r\n        if (ok && val != 0) {\r\n            uint govAmt = wdiv(saiDebtFee, uint(val));\r\n            if (otc_ != address(0)) {\r\n                uint saiGovAmt = OtcInterface(otc_).getPayAmount(tub.sai(), tub.gov(), govAmt);\r\n                if (tub.sai().allowance(this, otc_) != uint(-1)) {\r\n                    tub.sai().approve(otc_, uint(-1));\r\n                }\r\n                tub.sai().transferFrom(msg.sender, this, saiGovAmt);\r\n                OtcInterface(otc_).buyAllAmount(tub.gov(), govAmt, tub.sai(), saiGovAmt);\r\n            } else {\r\n                tub.gov().transferFrom(msg.sender, this, govAmt);\r\n            }\r\n        }\r\n    }\r\n\r\n    function wipe(address tub_, bytes32 cup, uint wad, address otc_) public {\r\n        if (wad > 0) {\r\n            TubInterface tub = TubInterface(tub_);\r\n\r\n            tub.sai().transferFrom(msg.sender, this, wad);\r\n            handleGovFee(tub, rmul(wad, rdiv(tub.rap(cup), tub.tab(cup))), otc_);\r\n\r\n            if (tub.sai().allowance(this, tub) != uint(-1)) {\r\n                tub.sai().approve(tub, uint(-1));\r\n            }\r\n            if (tub.gov().allowance(this, tub) != uint(-1)) {\r\n                tub.gov().approve(tub, uint(-1));\r\n            }\r\n            tub.wipe(cup, wad);\r\n        }\r\n    }\r\n\r\n    function wipe(address tub_, bytes32 cup, uint wad) public {\r\n        wipe(tub_, cup, wad, address(0));\r\n    }\r\n\r\n    function free(address tub_, bytes32 cup, uint jam) public {\r\n        if (jam > 0) {\r\n            TubInterface tub = TubInterface(tub_);\r\n            uint ink = rdiv(jam, tub.per());\r\n            ink = rmul(ink, tub.per()) <= jam ? ink : ink - 1;\r\n            tub.free(cup, ink);\r\n            if (tub.skr().allowance(this, tub) != uint(-1)) {\r\n                tub.skr().approve(tub, uint(-1));\r\n            }\r\n            tub.exit(ink);\r\n            uint freeJam = tub.gem().balanceOf(this); // Withdraw possible previous stuck WETH as well\r\n            tub.gem().withdraw(freeJam);\r\n            address(msg.sender).transfer(freeJam);\r\n        }\r\n    }\r\n\r\n    function lockAndDraw(address tub_, bytes32 cup, uint wad) public payable {\r\n        lock(tub_, cup);\r\n        draw(tub_, cup, wad);\r\n    }\r\n\r\n    function lockAndDraw(address tub_, uint wad) public payable returns (bytes32 cup) {\r\n        cup = open(tub_);\r\n        lockAndDraw(tub_, cup, wad);\r\n    }\r\n\r\n    function wipeAndFree(address tub_, bytes32 cup, uint jam, uint wad) public payable {\r\n        wipe(tub_, cup, wad);\r\n        free(tub_, cup, jam);\r\n    }\r\n\r\n    function wipeAndFree(address tub_, bytes32 cup, uint jam, uint wad, address otc_) public payable {\r\n        wipe(tub_, cup, wad, otc_);\r\n        free(tub_, cup, jam);\r\n    }\r\n\r\n    function shut(address tub_, bytes32 cup) public {\r\n        TubInterface tub = TubInterface(tub_);\r\n        wipeAndFree(tub_, cup, rmul(tub.ink(cup), tub.per()), tub.tab(cup));\r\n        tub.shut(cup);\r\n    }\r\n\r\n    function shut(address tub_, bytes32 cup, address otc_) public {\r\n        TubInterface tub = TubInterface(tub_);\r\n        wipeAndFree(tub_, cup, rmul(tub.ink(cup), tub.per()), tub.tab(cup), otc_);\r\n        tub.shut(cup);\r\n    }\r\n}\r\n\r\ncontract ProxyRegistryInterface {\r\n    function build(address) public returns (address);\r\n}\r\n\r\ncontract SaiProxyCreateAndExecute is SaiProxy {\r\n\r\n    // Create a DSProxy instance and open a cup\r\n    function createAndOpen(address registry_, address tub_) public returns (address proxy, bytes32 cup) {\r\n        proxy = ProxyRegistryInterface(registry_).build(msg.sender);\r\n        cup = open(tub_);\r\n        TubInterface(tub_).give(cup, proxy);\r\n    }\r\n\r\n    // Create a DSProxy instance, open a cup, and lock collateral\r\n    function createOpenAndLock(address registry_, address tub_) public payable returns (address proxy, bytes32 cup) {\r\n        proxy = ProxyRegistryInterface(registry_).build(msg.sender);\r\n        cup = open(tub_);\r\n        lock(tub_, cup);\r\n        TubInterface(tub_).give(cup, proxy);\r\n    }\r\n\r\n    // Create a DSProxy instance, open a cup, lock collateral, and draw DAI\r\n    function createOpenLockAndDraw(address registry_, address tub_, uint wad) public payable returns (address proxy, bytes32 cup) {\r\n        proxy = ProxyRegistryInterface(registry_).build(msg.sender);\r\n        cup = open(tub_);\r\n        lockAndDraw(tub_, cup, wad);\r\n        TubInterface(tub_).give(cup, proxy);\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"tub_\",\"type\":\"address\"},{\"name\":\"cup\",\"type\":\"bytes32\"},{\"name\":\"wad\",\"type\":\"uint256\"}],\"name\":\"draw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tub_\",\"type\":\"address\"},{\"name\":\"cup\",\"type\":\"bytes32\"},{\"name\":\"jam\",\"type\":\"uint256\"},{\"name\":\"wad\",\"type\":\"uint256\"},{\"name\":\"otc_\",\"type\":\"address\"}],\"name\":\"wipeAndFree\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tub_\",\"type\":\"address\"},{\"name\":\"cup\",\"type\":\"bytes32\"},{\"name\":\"wad\",\"type\":\"uint256\"}],\"name\":\"lockAndDraw\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tub_\",\"type\":\"address\"},{\"name\":\"wad\",\"type\":\"uint256\"}],\"name\":\"lockAndDraw\",\"outputs\":[{\"name\":\"cup\",\"type\":\"bytes32\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"registry_\",\"type\":\"address\"},{\"name\":\"tub_\",\"type\":\"address\"}],\"name\":\"createAndOpen\",\"outputs\":[{\"name\":\"proxy\",\"type\":\"address\"},{\"name\":\"cup\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tub_\",\"type\":\"address\"},{\"name\":\"cup\",\"type\":\"bytes32\"},{\"name\":\"otc_\",\"type\":\"address\"}],\"name\":\"shut\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tub_\",\"type\":\"address\"},{\"name\":\"cup\",\"type\":\"bytes32\"},{\"name\":\"wad\",\"type\":\"uint256\"},{\"name\":\"otc_\",\"type\":\"address\"}],\"name\":\"wipe\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tub_\",\"type\":\"address\"},{\"name\":\"cup\",\"type\":\"bytes32\"},{\"name\":\"wad\",\"type\":\"uint256\"}],\"name\":\"wipe\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tub_\",\"type\":\"address\"}],\"name\":\"open\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tub_\",\"type\":\"address\"},{\"name\":\"cup\",\"type\":\"bytes32\"}],\"name\":\"shut\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tub_\",\"type\":\"address\"},{\"name\":\"cup\",\"type\":\"bytes32\"}],\"name\":\"lock\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"registry_\",\"type\":\"address\"},{\"name\":\"tub_\",\"type\":\"address\"},{\"name\":\"wad\",\"type\":\"uint256\"}],\"name\":\"createOpenLockAndDraw\",\"outputs\":[{\"name\":\"proxy\",\"type\":\"address\"},{\"name\":\"cup\",\"type\":\"bytes32\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tub_\",\"type\":\"address\"},{\"name\":\"cup\",\"type\":\"bytes32\"},{\"name\":\"lad\",\"type\":\"address\"}],\"name\":\"give\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"registry_\",\"type\":\"address\"},{\"name\":\"tub_\",\"type\":\"address\"}],\"name\":\"createOpenAndLock\",\"outputs\":[{\"name\":\"proxy\",\"type\":\"address\"},{\"name\":\"cup\",\"type\":\"bytes32\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tub_\",\"type\":\"address\"},{\"name\":\"cup\",\"type\":\"bytes32\"},{\"name\":\"jam\",\"type\":\"uint256\"}],\"name\":\"free\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tub_\",\"type\":\"address\"},{\"name\":\"cup\",\"type\":\"bytes32\"},{\"name\":\"jam\",\"type\":\"uint256\"},{\"name\":\"wad\",\"type\":\"uint256\"}],\"name\":\"wipeAndFree\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"}]","ContractName":"SaiProxyCreateAndExecute","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://3882020989eed133489980542fe992a8b6761211e7f9e141daccbdaf91dfb632"}]}