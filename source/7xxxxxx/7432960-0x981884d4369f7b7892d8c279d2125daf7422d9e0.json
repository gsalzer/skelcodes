{"status":"1","message":"OK","result":[{"SourceCode":"\n// File: ../../mosaic-contracts/contracts/lib/CircularBufferUint.sol\n\npragma solidity ^0.5.0;\n\n// Copyright 2019 OpenST Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//    http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// ----------------------------------------------------------------------------\n//\n// http://www.simpletoken.org/\n//\n// ----------------------------------------------------------------------------\n\n/**\n * @title Circular buffer for `uint`s.\n *\n * @notice This contract represents a circular buffer that stores `uint`s. When\n *         a set number of `uint`s have been stored, the storage starts\n *         overwriting older entries. It overwrites always the oldest entry in\n *         the buffer.\n */\ncontract CircularBufferUint {\n\n    /* Storage */\n\n    /**\n     * The circular buffer that stores the latest `items.length` items. Once\n     * `items.length` items were stored, items will be overwritten starting at\n     * zero.\n     */\n    uint256[] private items;\n\n    /**\n     * The current index in the items array. The index increases up to\n     * `items.length - 1` and then resets to zero in an endless loop. This\n     * means that a new item will always overwrite the oldest item.\n     */\n    uint256 private index;\n\n\n    /* Constructor */\n\n    /**\n     * @notice Create a new buffer with the size `_maxItems`.\n     *\n     * @param _maxItems Defines how many items this buffer stores before\n     *                  overwriting older items.\n     */\n    constructor(uint256 _maxItems) public {\n        require(\n            _maxItems > 0,\n            \"The max number of items to store in a circular buffer must be greater than 0.\"\n        );\n\n        items.length = _maxItems;\n    }\n\n\n    /* Internal functions */\n\n    /**\n     * @notice Store a new item in the circular buffer.\n     *\n     * @param _item The item to store in the circular buffer.\n     *\n     * @return overwrittenItem_ The item that was in the circular buffer's\n     *                          position where the new item is now stored. The\n     *                          overwritten item is no longer available in the\n     *                          circular buffer.\n     */\n    function store(uint256 _item) internal returns(uint256 overwrittenItem_) {\n        nextIndex();\n\n        /*\n         * Retrieve the old item from the circular buffer before overwriting it\n         * with the new item.\n         */\n        overwrittenItem_ = items[index];\n        items[index] = _item;\n    }\n\n    /**\n     * @notice Get the most recent item that was stored in the circular buffer.\n     *\n     * @return head_ The most recently stored item.\n     */\n    function head() internal view returns(uint256 head_) {\n        head_ = items[index];\n    }\n\n\n    /* Private functions */\n\n    /**\n     * @notice Updates the index of the circular buffer to point to the next\n     *         slot of where to store an item. Resets to zero if it gets to the\n     *         end of the array that represents the circular.\n     */\n    function nextIndex() private {\n        index++;\n        if (index == items.length) {\n            index = 0;\n        }\n    }\n}\n\n// File: ../../mosaic-contracts/contracts/lib/RLP.sol\n\npragma solidity ^0.5.0;\n\n/**\n* @title RLPReader\n*\n* RLPReader is used to read and parse RLP encoded data in memory.\n*\n* @author Andreas Olofsson (androlo1980@gmail.com)\n*/\nlibrary RLP {\n\n    /** Constants */\n    uint constant DATA_SHORT_START = 0x80;\n    uint constant DATA_LONG_START = 0xB8;\n    uint constant LIST_SHORT_START = 0xC0;\n    uint constant LIST_LONG_START = 0xF8;\n\n    uint constant DATA_LONG_OFFSET = 0xB7;\n    uint constant LIST_LONG_OFFSET = 0xF7;\n\n    /** Storage */\n    struct RLPItem {\n        uint _unsafe_memPtr;    // Pointer to the RLP-encoded bytes.\n        uint _unsafe_length;    // Number of bytes. This is the full length of the string.\n    }\n\n    struct Iterator {\n        RLPItem _unsafe_item;   // Item that's being iterated over.\n        uint _unsafe_nextPtr;   // Position of the next item in the list.\n    }\n\n    /* Internal Functions */\n\n    /** Iterator */\n\n    function next(\n        Iterator memory self\n    )\n        internal\n        pure\n        returns (RLPItem memory subItem_)\n    {\n        require(hasNext(self));\n        uint ptr = self._unsafe_nextPtr;\n        uint itemLength = _itemLength(ptr);\n        subItem_._unsafe_memPtr = ptr;\n        subItem_._unsafe_length = itemLength;\n        self._unsafe_nextPtr = ptr + itemLength;\n    }\n\n    function next(\n        Iterator memory self,\n        bool strict\n    )\n        internal\n        pure\n        returns (RLPItem memory subItem_)\n    {\n        subItem_ = next(self);\n        require(!(strict && !_validate(subItem_)));\n    }\n\n    function hasNext(Iterator memory self) internal pure returns (bool) {\n        RLPItem memory item = self._unsafe_item;\n        return self._unsafe_nextPtr < item._unsafe_memPtr + item._unsafe_length;\n    }\n\n    /** RLPItem */\n\n    /**\n    *  @dev Creates an RLPItem from an array of RLP encoded bytes.\n    *\n    *  @param self The RLP encoded bytes.\n    *\n    *  @return An RLPItem.\n    */\n    function toRLPItem(\n        bytes memory self\n    )\n        internal\n        pure\n        returns (RLPItem memory)\n    {\n        uint len = self.length;\n        if (len == 0) {\n            return RLPItem(0, 0);\n        }\n        uint memPtr;\n\n        /* solium-disable-next-line */\n        assembly {\n            memPtr := add(self, 0x20)\n        }\n\n        return RLPItem(memPtr, len);\n    }\n\n    /**\n    *  @dev Creates an RLPItem from an array of RLP encoded bytes.\n    *\n    *  @param self The RLP encoded bytes.\n    *  @param strict Will throw if the data is not RLP encoded.\n    *\n    *  @return An RLPItem.\n    */\n    function toRLPItem(\n        bytes memory self,\n        bool strict\n    )\n        internal\n        pure\n        returns (RLPItem memory)\n    {\n        RLPItem memory item = toRLPItem(self);\n        if(strict) {\n            uint len = self.length;\n            require(_payloadOffset(item) <= len);\n            require(_itemLength(item._unsafe_memPtr) == len);\n            require(_validate(item));\n        }\n        return item;\n    }\n\n    /**\n    *  @dev Check if the RLP item is null.\n    *\n    *  @param self The RLP item.\n    *\n    *  @return 'true' if the item is null.\n    */\n    function isNull(RLPItem memory self) internal pure returns (bool ret) {\n        return self._unsafe_length == 0;\n    }\n\n    /**\n    *  @dev Check if the RLP item is a list.\n    *\n    *  @param self The RLP item.\n    *\n    *  @return 'true' if the item is a list.\n    */\n    function isList(RLPItem memory self) internal pure returns (bool ret) {\n        if (self._unsafe_length == 0) {\n            return false;\n        }\n        uint memPtr = self._unsafe_memPtr;\n\n        /* solium-disable-next-line */\n        assembly {\n            ret := iszero(lt(byte(0, mload(memPtr)), 0xC0))\n        }\n    }\n\n    /**\n    *  @dev Check if the RLP item is data.\n    *\n    *  @param self The RLP item.\n    *\n    *  @return 'true' if the item is data.\n    */\n    function isData(RLPItem memory self) internal pure returns (bool ret) {\n        if (self._unsafe_length == 0) {\n            return false;\n        }\n        uint memPtr = self._unsafe_memPtr;\n\n        /* solium-disable-next-line */\n        assembly {\n            ret := lt(byte(0, mload(memPtr)), 0xC0)\n        }\n    }\n\n    /**\n    *  @dev Check if the RLP item is empty (string or list).\n    *\n    *  @param self The RLP item.\n    *\n    *  @return 'true' if the item is null.\n    */\n    function isEmpty(RLPItem memory self) internal pure returns (bool ret) {\n        if(isNull(self)) {\n            return false;\n        }\n        uint b0;\n        uint memPtr = self._unsafe_memPtr;\n\n        /* solium-disable-next-line */\n        assembly {\n            b0 := byte(0, mload(memPtr))\n        }\n        return (b0 == DATA_SHORT_START || b0 == LIST_SHORT_START);\n    }\n\n    /**\n    *  @dev Get the number of items in an RLP encoded list.\n    *\n    *  @param self The RLP item.\n    *\n    *  @return The number of items.\n    */\n    function items(RLPItem memory self) internal pure returns (uint) {\n        if (!isList(self)) {\n            return 0;\n        }\n        uint b0;\n        uint memPtr = self._unsafe_memPtr;\n\n        /* solium-disable-next-line */\n        assembly {\n            b0 := byte(0, mload(memPtr))\n        }\n        uint pos = memPtr + _payloadOffset(self);\n        uint last = memPtr + self._unsafe_length - 1;\n        uint itms;\n        while(pos <= last) {\n            pos += _itemLength(pos);\n            itms++;\n        }\n        return itms;\n    }\n\n    /**\n    *  @dev Create an iterator.\n    *\n    *  @param self The RLP item.\n    *\n    *  @return An 'Iterator' over the item.\n    */\n    function iterator(\n        RLPItem memory self\n    )\n        internal\n        pure\n        returns (Iterator memory it_)\n    {\n        require (isList(self));\n        uint ptr = self._unsafe_memPtr + _payloadOffset(self);\n        it_._unsafe_item = self;\n        it_._unsafe_nextPtr = ptr;\n    }\n\n    /**\n    *  @dev Return the RLP encoded bytes.\n    *\n    *  @param self The RLPItem.\n    *\n    *  @return The bytes.\n    */\n    function toBytes(\n        RLPItem memory self\n    )\n        internal\n        pure\n        returns (bytes memory bts_)\n    {\n        uint len = self._unsafe_length;\n        if (len == 0) {\n            return bts_;\n        }\n        bts_ = new bytes(len);\n        _copyToBytes(self._unsafe_memPtr, bts_, len);\n    }\n\n    /**\n    *  @dev Decode an RLPItem into bytes. This will not work if the RLPItem is a list.\n    *\n    *  @param self The RLPItem.\n    *\n    *  @return The decoded string.\n    */\n    function toData(\n        RLPItem memory self\n    )\n        internal\n        pure\n        returns (bytes memory bts_)\n    {\n        require(isData(self));\n        uint rStartPos;\n        uint len;\n        (rStartPos, len) = _decode(self);\n        bts_ = new bytes(len);\n        _copyToBytes(rStartPos, bts_, len);\n    }\n\n    /**\n    *  @dev Get the list of sub-items from an RLP encoded list.\n    *       Warning: This is inefficient, as it requires that the list is read twice.\n    *\n    *  @param self The RLP item.\n    *\n    *  @return Array of RLPItems.\n    */\n    function toList(\n        RLPItem memory self\n    )\n        internal\n        pure\n        returns (RLPItem[] memory list_)\n    {\n        require(isList(self));\n        uint numItems = items(self);\n        list_ = new RLPItem[](numItems);\n        Iterator memory it = iterator(self);\n        uint idx = 0;\n        while(hasNext(it)) {\n            list_[idx] = next(it);\n            idx++;\n        }\n    }\n\n    /**\n    *  @dev Decode an RLPItem into an ascii string. This will not work if the\n    *       RLPItem is a list.\n    *\n    *  @param self The RLPItem.\n    *\n    *  @return The decoded string.\n    */\n    function toAscii(\n        RLPItem memory self\n    )\n        internal\n        pure\n        returns (string memory str_)\n    {\n        require(isData(self));\n        uint rStartPos;\n        uint len;\n        (rStartPos, len) = _decode(self);\n        bytes memory bts = new bytes(len);\n        _copyToBytes(rStartPos, bts, len);\n        str_ = string(bts);\n    }\n\n    /**\n    *  @dev Decode an RLPItem into a uint. This will not work if the\n    *  RLPItem is a list.\n    *\n    *  @param self The RLPItem.\n    *\n    *  @return The decoded string.\n    */\n    function toUint(RLPItem memory self) internal pure returns (uint data_) {\n        require(isData(self));\n        uint rStartPos;\n        uint len;\n        (rStartPos, len) = _decode(self);\n        if (len > 32 || len == 0) {\n            revert();\n        }\n\n        /* solium-disable-next-line */\n        assembly {\n            data_ := div(mload(rStartPos), exp(256, sub(32, len)))\n        }\n    }\n\n    /**\n    *  @dev Decode an RLPItem into a boolean. This will not work if the\n    *       RLPItem is a list.\n    *\n    *  @param self The RLPItem.\n    *\n    *  @return The decoded string.\n    */\n    function toBool(RLPItem memory self) internal pure returns (bool data) {\n        require(isData(self));\n        uint rStartPos;\n        uint len;\n        (rStartPos, len) = _decode(self);\n        require(len == 1);\n        uint temp;\n\n        /* solium-disable-next-line */\n        assembly {\n            temp := byte(0, mload(rStartPos))\n        }\n        require (temp <= 1);\n\n        return temp == 1 ? true : false;\n    }\n\n    /**\n    *  @dev Decode an RLPItem into a byte. This will not work if the\n    *       RLPItem is a list.\n    *\n    *  @param self The RLPItem.\n    *\n    *  @return The decoded string.\n    */\n    function toByte(RLPItem memory self) internal pure returns (byte data) {\n        require(isData(self));\n        uint rStartPos;\n        uint len;\n        (rStartPos, len) = _decode(self);\n        require(len == 1);\n        uint temp;\n\n        /* solium-disable-next-line */\n        assembly {\n            temp := byte(0, mload(rStartPos))\n        }\n\n        return byte(uint8(temp));\n    }\n\n    /**\n    *  @dev Decode an RLPItem into an int. This will not work if the\n    *       RLPItem is a list.\n    *\n    *  @param self The RLPItem.\n    *\n    *  @return The decoded string.\n    */\n    function toInt(RLPItem memory self) internal pure returns (int data) {\n        return int(toUint(self));\n    }\n\n    /**\n    *  @dev Decode an RLPItem into a bytes32. This will not work if the\n    *       RLPItem is a list.\n    *\n    *  @param self The RLPItem.\n    *\n    *  @return The decoded string.\n    */\n    function toBytes32(\n        RLPItem memory self\n    )\n        internal\n        pure\n        returns (bytes32 data)\n    {\n        return bytes32(toUint(self));\n    }\n\n    /**\n    *  @dev Decode an RLPItem into an address. This will not work if the\n    *       RLPItem is a list.\n    *\n    *  @param self The RLPItem.\n    *\n    *  @return The decoded string.\n    */\n    function toAddress(\n        RLPItem memory self\n    )\n        internal\n        pure\n        returns (address data)\n    {\n        require(isData(self));\n        uint rStartPos;\n        uint len;\n        (rStartPos, len) = _decode(self);\n        require (len == 20);\n\n        /* solium-disable-next-line */\n        assembly {\n            data := div(mload(rStartPos), exp(256, 12))\n        }\n    }\n\n    /**\n    *  @dev Decode an RLPItem into an address. This will not work if the\n    *       RLPItem is a list.\n    *\n    *  @param self The RLPItem.\n    *\n    *  @return Get the payload offset.\n    */\n    function _payloadOffset(RLPItem memory self) private pure returns (uint) {\n        if(self._unsafe_length == 0)\n            return 0;\n        uint b0;\n        uint memPtr = self._unsafe_memPtr;\n\n        /* solium-disable-next-line */\n        assembly {\n            b0 := byte(0, mload(memPtr))\n        }\n        if(b0 < DATA_SHORT_START)\n            return 0;\n        if(b0 < DATA_LONG_START || (b0 >= LIST_SHORT_START && b0 < LIST_LONG_START))\n            return 1;\n        if(b0 < LIST_SHORT_START)\n            return b0 - DATA_LONG_OFFSET + 1;\n        return b0 - LIST_LONG_OFFSET + 1;\n    }\n\n    /**\n    *  @dev Decode an RLPItem into an address. This will not work if the\n    *       RLPItem is a list.\n    *\n    *  @param memPtr Memory pointer.\n    *\n    *  @return Get the full length of an RLP item.\n    */\n    function _itemLength(uint memPtr) private pure returns (uint len) {\n        uint b0;\n\n        /* solium-disable-next-line */\n        assembly {\n            b0 := byte(0, mload(memPtr))\n        }\n        if (b0 < DATA_SHORT_START) {\n            len = 1;\n        } else if (b0 < DATA_LONG_START) {\n            len = b0 - DATA_SHORT_START + 1;\n        } else if (b0 < LIST_SHORT_START) {\n            /* solium-disable-next-line */\n            assembly {\n                let bLen := sub(b0, 0xB7) // bytes length (DATA_LONG_OFFSET)\n                let dLen := div(mload(add(memPtr, 1)), exp(256, sub(32, bLen))) // data length\n                len := add(1, add(bLen, dLen)) // total length\n            }\n        } else if (b0 < LIST_LONG_START) {\n            len = b0 - LIST_SHORT_START + 1;\n        } else {\n            /* solium-disable-next-line */\n            assembly {\n                let bLen := sub(b0, 0xF7) // bytes length (LIST_LONG_OFFSET)\n                let dLen := div(mload(add(memPtr, 1)), exp(256, sub(32, bLen))) // data length\n                len := add(1, add(bLen, dLen)) // total length\n            }\n        }\n    }\n\n    /**\n    *  @dev Decode an RLPItem into an address. This will not work if the\n    *       RLPItem is a list.\n    *\n    *  @param self The RLPItem.\n    *\n    *  @return Get the full length of an RLP item.\n    */\n    function _decode(\n        RLPItem memory self\n    )\n        private\n        pure\n        returns (uint memPtr_, uint len_)\n    {\n        require(isData(self));\n        uint b0;\n        uint start = self._unsafe_memPtr;\n\n        /* solium-disable-next-line */\n        assembly {\n            b0 := byte(0, mload(start))\n        }\n        if (b0 < DATA_SHORT_START) {\n            memPtr_ = start;\n            len_ = 1;\n\n            return (memPtr_, len_);\n        }\n        if (b0 < DATA_LONG_START) {\n            len_ = self._unsafe_length - 1;\n            memPtr_ = start + 1;\n        } else {\n            uint bLen;\n\n            /* solium-disable-next-line */\n            assembly {\n                bLen := sub(b0, 0xB7) // DATA_LONG_OFFSET\n            }\n            len_ = self._unsafe_length - 1 - bLen;\n            memPtr_ = start + bLen + 1;\n        }\n    }\n\n    /**\n    *  @dev Assumes that enough memory has been allocated to store in target.\n    *       Gets the full length of an RLP item.\n    *\n    *  @param btsPtr Bytes pointer.\n    *  @param tgt Last item to be allocated.\n    *  @param btsLen Bytes length.\n    */\n    function _copyToBytes(\n        uint btsPtr,\n        bytes memory tgt,\n        uint btsLen\n    )\n        private\n        pure\n    {\n        // Exploiting the fact that 'tgt' was the last thing to be allocated,\n        // we can write entire words, and just overwrite any excess.\n        /* solium-disable-next-line */\n        assembly {\n                let i := 0 // Start at arr + 0x20\n                let stopOffset := add(btsLen, 31)\n                let rOffset := btsPtr\n                let wOffset := add(tgt, 32)\n                for {} lt(i, stopOffset) { i := add(i, 32) }\n                {\n                    mstore(add(wOffset, i), mload(add(rOffset, i)))\n                }\n        }\n    }\n\n    /**\n    *  @dev Check that an RLP item is valid.\n    *\n    *  @param self The RLPItem.\n    */\n    function _validate(RLPItem memory self) private pure returns (bool ret) {\n        // Check that RLP is well-formed.\n        uint b0;\n        uint b1;\n        uint memPtr = self._unsafe_memPtr;\n\n        /* solium-disable-next-line */\n        assembly {\n            b0 := byte(0, mload(memPtr))\n            b1 := byte(1, mload(memPtr))\n        }\n        if(b0 == DATA_SHORT_START + 1 && b1 < DATA_SHORT_START)\n            return false;\n        return true;\n    }\n}\n\n// File: ../../mosaic-contracts/contracts/lib/MerklePatriciaProof.sol\n\npragma solidity ^0.5.0;\n/**\n * @title MerklePatriciaVerifier\n * @author Sam Mayo (sammayo888@gmail.com)\n *\n * @dev Library for verifing merkle patricia proofs.\n */\n\n\nlibrary MerklePatriciaProof {\n    /**\n     * @dev Verifies a merkle patricia proof.\n     * @param value The terminating value in the trie.\n     * @param encodedPath The path in the trie leading to value.\n     * @param rlpParentNodes The rlp encoded stack of nodes.\n     * @param root The root hash of the trie.\n     * @return The boolean validity of the proof.\n     */\n    function verify(\n        bytes32 value,\n        bytes calldata encodedPath,\n        bytes calldata rlpParentNodes,\n        bytes32 root\n    )\n        external\n        pure\n        returns (bool)\n    {\n        RLP.RLPItem memory item = RLP.toRLPItem(rlpParentNodes);\n        RLP.RLPItem[] memory parentNodes = RLP.toList(item);\n\n        bytes memory currentNode;\n        RLP.RLPItem[] memory currentNodeList;\n\n        bytes32 nodeKey = root;\n        uint pathPtr = 0;\n\n        bytes memory path = _getNibbleArray2(encodedPath);\n        if(path.length == 0) {return false;}\n\n        for (uint i=0; i<parentNodes.length; i++) {\n            if(pathPtr > path.length) {return false;}\n\n            currentNode = RLP.toBytes(parentNodes[i]);\n            if(nodeKey != keccak256(abi.encodePacked(currentNode))) {return false;}\n            currentNodeList = RLP.toList(parentNodes[i]);\n\n            if(currentNodeList.length == 17) {\n                if(pathPtr == path.length) {\n                    if(keccak256(abi.encodePacked(RLP.toBytes(currentNodeList[16]))) == value) {\n                        return true;\n                    } else {\n                        return false;\n                    }\n                }\n\n                uint8 nextPathNibble = uint8(path[pathPtr]);\n                if(nextPathNibble > 16) {return false;}\n                nodeKey = RLP.toBytes32(currentNodeList[nextPathNibble]);\n                pathPtr += 1;\n            } else if(currentNodeList.length == 2) {\n\n                // Count of matching node key nibbles in path starting from pathPtr.\n                uint traverseLength = _nibblesToTraverse(RLP.toData(currentNodeList[0]), path, pathPtr);\n\n                if(pathPtr + traverseLength == path.length) { //leaf node\n                    if(keccak256(abi.encodePacked(RLP.toData(currentNodeList[1]))) == value) {\n                        return true;\n                    } else {\n                        return false;\n                    }\n                } else if (traverseLength == 0) { // error: couldn't traverse path\n                    return false;\n                } else { // extension node\n                    pathPtr += traverseLength;\n                    nodeKey = RLP.toBytes32(currentNodeList[1]);\n                }\n\n            } else {\n                return false;\n            }\n        }\n    }\n\n    function verifyDebug(\n        bytes32 value,\n        bytes memory not_encodedPath,\n        bytes memory rlpParentNodes,\n        bytes32 root\n    )\n        public\n        pure\n        returns (bool res_, uint loc_, bytes memory path_debug_)\n    {\n        RLP.RLPItem memory item = RLP.toRLPItem(rlpParentNodes);\n        RLP.RLPItem[] memory parentNodes = RLP.toList(item);\n\n        bytes memory currentNode;\n        RLP.RLPItem[] memory currentNodeList;\n\n        bytes32 nodeKey = root;\n        uint pathPtr = 0;\n\n        bytes memory path = _getNibbleArray2(not_encodedPath);\n        path_debug_ = path;\n        if(path.length == 0) {\n            loc_ = 0;\n            res_ = false;\n            return (res_, loc_, path_debug_);\n        }\n\n        for (uint i=0; i<parentNodes.length; i++) {\n            if(pathPtr > path.length) {\n                loc_ = 1;\n                res_ = false;\n                return (res_, loc_, path_debug_);\n            }\n\n            currentNode = RLP.toBytes(parentNodes[i]);\n            if(nodeKey != keccak256(abi.encodePacked(currentNode))) {\n                res_ = false;\n                loc_ = 100 + i;\n                return (res_, loc_, path_debug_);\n            }\n            currentNodeList = RLP.toList(parentNodes[i]);\n\n            loc_ = currentNodeList.length;\n\n            if(currentNodeList.length == 17) {\n                if(pathPtr == path.length) {\n                    if(keccak256(abi.encodePacked(RLP.toBytes(currentNodeList[16]))) == value) {\n                        res_ = true;\n                        return (res_, loc_, path_debug_);\n                    } else {\n                        loc_ = 3;\n                        return (res_, loc_, path_debug_);\n                    }\n                }\n\n                uint8 nextPathNibble = uint8(path[pathPtr]);\n                if(nextPathNibble > 16) {\n                    loc_ = 4;\n                    return (res_, loc_, path_debug_);\n                }\n                nodeKey = RLP.toBytes32(currentNodeList[nextPathNibble]);\n                pathPtr += 1;\n            } else if(currentNodeList.length == 2) {\n                pathPtr += _nibblesToTraverse(RLP.toData(currentNodeList[0]), path, pathPtr);\n\n                if(pathPtr == path.length) {//leaf node\n                    if(keccak256(abi.encodePacked(RLP.toData(currentNodeList[1]))) == value) {\n                        res_ = true;\n                        return (res_, loc_, path_debug_);\n                    } else {\n                        loc_ = 5;\n                        return (res_, loc_, path_debug_);\n                    }\n                }\n                //extension node\n                if(_nibblesToTraverse(RLP.toData(currentNodeList[0]), path, pathPtr) == 0) {\n                    loc_ = 6;\n                    res_ = (keccak256(abi.encodePacked()) == value);\n                    return (res_, loc_, path_debug_);\n                }\n\n                nodeKey = RLP.toBytes32(currentNodeList[1]);\n            } else {\n                loc_ = 7;\n                return (res_, loc_, path_debug_);\n            }\n        }\n\n        loc_ = 8;\n    }\n\n    function _nibblesToTraverse(\n        bytes memory encodedPartialPath,\n        bytes memory path,\n        uint pathPtr\n    )\n        private\n        pure\n        returns (uint len_)\n    {\n        // encodedPartialPath has elements that are each two hex characters (1 byte), but partialPath\n        // and slicedPath have elements that are each one hex character (1 nibble)\n        bytes memory partialPath = _getNibbleArray(encodedPartialPath);\n        bytes memory slicedPath = new bytes(partialPath.length);\n\n        // pathPtr counts nibbles in path\n        // partialPath.length is a number of nibbles\n        for(uint i=pathPtr; i<pathPtr+partialPath.length; i++) {\n            byte pathNibble = path[i];\n            slicedPath[i-pathPtr] = pathNibble;\n        }\n\n        if(keccak256(abi.encodePacked(partialPath)) == keccak256(abi.encodePacked(slicedPath))) {\n            len_ = partialPath.length;\n        } else {\n            len_ = 0;\n        }\n    }\n\n    // bytes b must be hp encoded\n    function _getNibbleArray(\n        bytes memory b\n    )\n        private\n        pure\n        returns (bytes memory nibbles_)\n    {\n        if(b.length>0) {\n            uint8 offset;\n            uint8 hpNibble = uint8(_getNthNibbleOfBytes(0,b));\n            if(hpNibble == 1 || hpNibble == 3) {\n                nibbles_ = new bytes(b.length*2-1);\n                byte oddNibble = _getNthNibbleOfBytes(1,b);\n                nibbles_[0] = oddNibble;\n                offset = 1;\n            } else {\n                nibbles_ = new bytes(b.length*2-2);\n                offset = 0;\n            }\n\n            for(uint i=offset; i<nibbles_.length; i++) {\n                nibbles_[i] = _getNthNibbleOfBytes(i-offset+2,b);\n            }\n        }\n    }\n\n    // normal byte array, no encoding used\n    function _getNibbleArray2(\n        bytes memory b\n    )\n        private\n        pure\n        returns (bytes memory nibbles_)\n    {\n        nibbles_ = new bytes(b.length*2);\n        for (uint i = 0; i < nibbles_.length; i++) {\n            nibbles_[i] = _getNthNibbleOfBytes(i, b);\n        }\n    }\n\n    function _getNthNibbleOfBytes(\n        uint n,\n        bytes memory str\n    )\n        private\n        pure returns (byte)\n    {\n        return byte(n%2==0 ? uint8(str[n/2])/0x10 : uint8(str[n/2])%0x10);\n    }\n}\n\n// File: ../../mosaic-contracts/contracts/lib/OrganizationInterface.sol\n\npragma solidity ^0.5.0;\n\n// Copyright 2019 OpenST Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//    http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// ----------------------------------------------------------------------------\n//\n// http://www.simpletoken.org/\n//\n// ----------------------------------------------------------------------------\n\n/**\n *  @title OrganizationInterface provides methods to check if an address is\n *         currently registered as an active participant in the organization.\n */\ninterface OrganizationInterface {\n\n    /**\n     * @notice Checks if an address is currently registered as the organization.\n     *\n     * @param _organization Address to check.\n     *\n     * @return isOrganization_ True if the given address represents the\n     *                         organization. Returns false otherwise.\n     */\n    function isOrganization(\n        address _organization\n    )\n        external\n        view\n        returns (bool isOrganization_);\n\n    /**\n     * @notice Checks if an address is currently registered as an active worker.\n     *\n     * @param _worker Address to check.\n     *\n     * @return isWorker_ True if the given address is a registered, active\n     *                   worker. Returns false otherwise.\n     */\n    function isWorker(address _worker) external view returns (bool isWorker_);\n\n}\n\n// File: ../../mosaic-contracts/contracts/lib/Organized.sol\n\npragma solidity ^0.5.0;\n\n// Copyright 2019 OpenST Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//    http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// ----------------------------------------------------------------------------\n//\n// http://www.simpletoken.org/\n//\n// ----------------------------------------------------------------------------\n\n\n/**\n * @title Organized contract.\n *\n * @notice The Organized contract facilitates integration of\n *         organization administration keys with different contracts.\n */\ncontract Organized {\n\n\n    /* Storage */\n\n    /** Organization which holds all the keys needed to administer the economy. */\n    OrganizationInterface public organization;\n\n\n    /* Modifiers */\n\n    modifier onlyOrganization()\n    {\n        require(\n            organization.isOrganization(msg.sender),\n            \"Only the organization is allowed to call this method.\"\n        );\n\n        _;\n    }\n\n    modifier onlyWorker()\n    {\n        require(\n            organization.isWorker(msg.sender),\n            \"Only whitelisted workers are allowed to call this method.\"\n        );\n\n        _;\n    }\n\n\n    /* Constructor */\n\n    /**\n     * @notice Sets the address of the organization contract.\n     *\n     * @param _organization A contract that manages worker keys.\n     */\n    constructor(OrganizationInterface _organization) public {\n        require(\n            address(_organization) != address(0),\n            \"Organization contract address must not be zero.\"\n        );\n\n        organization = _organization;\n    }\n\n}\n\n// File: ../../mosaic-contracts/contracts/lib/SafeMath.sol\n\npragma solidity ^0.5.0;\n\n// Copyright 2019 OpenST Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//    http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n// \n// ----------------------------------------------------------------------------\n//\n// http://www.simpletoken.org/\n//\n// Based on the SafeMath library by the OpenZeppelin team.\n// Copyright (c) 2018 Smart Contract Solutions, Inc.\n// https://github.com/OpenZeppelin/zeppelin-solidity\n// The MIT License.\n// ----------------------------------------------------------------------------\n\n\n/**\n * @title SafeMath library.\n *\n * @notice Based on the SafeMath library by the OpenZeppelin team.\n *\n * @dev Math operations with safety checks that revert on error.\n */\nlibrary SafeMath {\n\n    /* Internal Functions */\n\n    /**\n     * @notice Multiplies two numbers, reverts on overflow.\n     *\n     * @param a Unsigned integer multiplicand.\n     * @param b Unsigned integer multiplier.\n     *\n     * @return uint256 Product.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        /*\n         * Gas optimization: this is cheaper than requiring 'a' not being zero,\n         * but the benefit is lost if 'b' is also tested.\n         * See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n         */\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(\n            c / a == b,\n            \"Overflow when multiplying.\"\n        );\n\n        return c;\n    }\n\n    /**\n     * @notice Integer division of two numbers truncating the quotient, reverts\n     *         on division by zero.\n     *\n     * @param a Unsigned integer dividend.\n     * @param b Unsigned integer divisor.\n     *\n     * @return uint256 Quotient.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0.\n        require(\n            b > 0,\n            \"Cannot do attempted division by less than or equal to zero.\"\n        );\n        uint256 c = a / b;\n\n        // There is no case in which the following doesn't hold:\n        // assert(a == b * c + a % b);\n\n        return c;\n    }\n\n    /**\n     * @notice Subtracts two numbers, reverts on underflow (i.e. if subtrahend\n     *         is greater than minuend).\n     *\n     * @param a Unsigned integer minuend.\n     * @param b Unsigned integer subtrahend.\n     *\n     * @return uint256 Difference.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(\n            b <= a,\n            \"Underflow when subtracting.\"\n        );\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @notice Adds two numbers, reverts on overflow.\n     *\n     * @param a Unsigned integer augend.\n     * @param b Unsigned integer addend.\n     *\n     * @return uint256 Sum.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(\n            c >= a,\n            \"Overflow when adding.\"\n        );\n\n        return c;\n    }\n\n    /**\n     * @notice Divides two numbers and returns the remainder (unsigned integer\n     *         modulo), reverts when dividing by zero.\n     *\n     * @param a Unsigned integer dividend.\n     * @param b Unsigned integer divisor.\n     *\n     * @return uint256 Remainder.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(\n            b != 0,\n            \"Cannot do attempted division by zero (in `mod()`).\"\n        );\n\n        return a % b;\n    }\n}\n\n// File: ../../mosaic-contracts/contracts/lib/StateRootInterface.sol\n\npragma solidity ^0.5.0;\n\n// Copyright 2019 OpenST Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//    http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// ----------------------------------------------------------------------------\n//\n// http://www.simpletoken.org/\n//\n// ----------------------------------------------------------------------------\n\n/** @title An interface to an get state root. */\ninterface StateRootInterface {\n\n    /**\n     * @notice Gets the block number of latest committed state root.\n     *\n     * @return height_ Block height of the latest committed state root.\n     */\n    function getLatestStateRootBlockHeight()\n        external\n        view\n        returns (uint256 height_);\n\n    /**\n     * @notice Get the state root for the given block height.\n     *\n     * @param _blockHeight The block height for which the state root is fetched.\n     *\n     * @return bytes32 State root at the given height.\n     */\n    function getStateRoot(uint256 _blockHeight)\n        external\n        view\n        returns (bytes32 stateRoot_);\n\n}\n\n// File: ../../mosaic-contracts/contracts/anchor/Anchor.sol\n\npragma solidity ^0.5.0;\n\n// Copyright 2019 OpenST Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//    http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// ----------------------------------------------------------------------------\n//\n// http://www.simpletoken.org/\n//\n// ----------------------------------------------------------------------------\n\n\n\n\n\n\n\n\n/**\n * @title Anchor contract which implements StateRootInterface.\n *\n * @notice Anchor stores another chain's state roots. It stores the address of\n *         the co-anchor, which will be the anchor on the other chain. State\n *         roots are exchanged bidirectionally between the anchor and the\n *         co-anchor by the organization.\n */\ncontract Anchor is StateRootInterface, Organized, CircularBufferUint {\n\n    /* Usings */\n\n    using SafeMath for uint256;\n\n\n    /* Events */\n\n    event StateRootAvailable(uint256 _blockHeight, bytes32 _stateRoot);\n\n\n    /* Storage */\n\n    /** Maps block heights to their respective state root. */\n    mapping (uint256 => bytes32) private stateRoots;\n\n    /**\n     * The remote chain ID is the remote chain id where anchor contract is\n     * deployed.\n     */\n    uint256 private remoteChainId;\n\n    /** Address of the anchor on the auxiliary chain. Can be zero. */\n    address public coAnchor;\n\n\n    /*  Constructor */\n\n    /**\n     * @notice Contract constructor.\n     *\n     * @param _remoteChainId The chain id of the chain that is tracked by this\n     *                       anchor.\n     * @param _blockHeight Block height at which _stateRoot needs to store.\n     * @param _stateRoot State root hash of given _blockHeight.\n     * @param _maxStateRoots The max number of state roots to store in the\n     *                       circular buffer.\n     * @param _organization Address of an organization contract.\n     */\n    constructor(\n        uint256 _remoteChainId,\n        uint256 _blockHeight,\n        bytes32 _stateRoot,\n        uint256 _maxStateRoots,\n        OrganizationInterface _organization\n    )\n        Organized(_organization)\n        CircularBufferUint(_maxStateRoots)\n        public\n    {\n        require(\n            _remoteChainId != 0,\n            \"Remote chain Id must not be 0.\"\n        );\n\n        remoteChainId = _remoteChainId;\n\n        stateRoots[_blockHeight] = _stateRoot;\n        CircularBufferUint.store(_blockHeight);\n    }\n\n\n    /* External functions */\n\n    /**\n     *  @notice The Co-Anchor address is the address of the anchor that is\n     *          deployed on the other (origin/auxiliary) chain.\n     *\n     *  @param _coAnchor Address of the Co-Anchor on auxiliary.\n     */\n    function setCoAnchorAddress(address _coAnchor)\n        external\n        onlyOrganization\n        returns (bool success_)\n    {\n\n        require(\n            _coAnchor != address(0),\n            \"Co-Anchor address must not be 0.\"\n        );\n\n        require(\n            coAnchor == address(0),\n            \"Co-Anchor has already been set and cannot be updated.\"\n        );\n\n        coAnchor = _coAnchor;\n\n        success_ = true;\n    }\n\n    /**\n     * @notice Get the state root for the given block height.\n     *\n     * @param _blockHeight The block height for which the state root is needed.\n     *\n     * @return bytes32 State root of the given height.\n     */\n    function getStateRoot(\n        uint256 _blockHeight\n    )\n        external\n        view\n        returns (bytes32 stateRoot_)\n    {\n        stateRoot_ = stateRoots[_blockHeight];\n    }\n\n    /**\n     * @notice Gets the block height of latest anchored state root.\n     *\n     * @return uint256 Block height of the latest anchored state root.\n     */\n    function getLatestStateRootBlockHeight()\n        external\n        view\n        returns (uint256 height_)\n    {\n        height_ = CircularBufferUint.head();\n    }\n\n    /**\n     *  @notice External function anchorStateRoot.\n     *\n     *  @dev anchorStateRoot Called from game process.\n     *       Anchor new state root for a block height.\n     *\n     *  @param _blockHeight Block height for which stateRoots mapping needs to\n     *                      update.\n     *  @param _stateRoot State root of input block height.\n     *\n     *  @return bytes32 stateRoot\n     */\n    function anchorStateRoot(\n        uint256 _blockHeight,\n        bytes32 _stateRoot\n    )\n        external\n        onlyOrganization\n        returns (bool success_)\n    {\n        // State root should be valid\n        require(\n            _stateRoot != bytes32(0),\n            \"State root must not be zero.\"\n        );\n\n        // Input block height should be valid.\n        require(\n            _blockHeight > CircularBufferUint.head(),\n            \"Given block height is lower or equal to highest anchored state root block height.\"\n        );\n\n        stateRoots[_blockHeight] = _stateRoot;\n        uint256 oldestStoredBlockHeight = CircularBufferUint.store(_blockHeight);\n        delete stateRoots[oldestStoredBlockHeight];\n\n        emit StateRootAvailable(_blockHeight, _stateRoot);\n\n        success_ = true;\n    }\n\n    /**\n     *  @notice Get the remote chain id of this anchor.\n     *\n     *  @return remoteChainId_ The remote chain id.\n     */\n    function getRemoteChainId()\n        external\n        view\n        returns (uint256 remoteChainId_)\n    {\n        remoteChainId_ = remoteChainId;\n    }\n}\n","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_coAnchor\",\"type\":\"address\"}],\"name\":\"setCoAnchorAddress\",\"outputs\":[{\"name\":\"success_\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"organization\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getLatestStateRootBlockHeight\",\"outputs\":[{\"name\":\"height_\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_blockHeight\",\"type\":\"uint256\"},{\"name\":\"_stateRoot\",\"type\":\"bytes32\"}],\"name\":\"anchorStateRoot\",\"outputs\":[{\"name\":\"success_\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getRemoteChainId\",\"outputs\":[{\"name\":\"remoteChainId_\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"coAnchor\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_blockHeight\",\"type\":\"uint256\"}],\"name\":\"getStateRoot\",\"outputs\":[{\"name\":\"stateRoot_\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_remoteChainId\",\"type\":\"uint256\"},{\"name\":\"_blockHeight\",\"type\":\"uint256\"},{\"name\":\"_stateRoot\",\"type\":\"bytes32\"},{\"name\":\"_maxStateRoots\",\"type\":\"uint256\"},{\"name\":\"_organization\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_blockHeight\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_stateRoot\",\"type\":\"bytes32\"}],\"name\":\"StateRootAvailable\",\"type\":\"event\"}]","ContractName":"Anchor","CompilerVersion":"v0.5.3+commit.10d17f24","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000000000000000000000000000000000000000000586000000000000000000000000000000000000000000000000000000000000083e4e611b793f91a508329892b577507f070c637bd062b0d6785d3cb370d86ec0a40000000000000000000000000000000000000000000000000000000000000064000000000000000000000000c450a2fa865972fb7a07acad6cf6c3654e37c617","Library":"","LicenseType":"","SwarmSource":"bzzr://243d8c2d60d874b350346e199fa86e5e8e5a5025435b19b4709ece874342641c"}]}