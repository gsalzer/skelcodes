{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.25;\r\n\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\ncontract DateTimeEnabled {\r\n        /*\r\n         *  Date and Time utilities for ethereum contracts\r\n         *\r\n         */\r\n        struct DateTime {\r\n                uint16 year;\r\n                uint8 month;\r\n                uint8 day;\r\n                uint8 hour;\r\n                uint8 minute;\r\n                uint8 second;\r\n                uint8 weekday;\r\n        }\r\n\r\n        uint constant DAY_IN_SECONDS = 86400;\r\n        uint constant YEAR_IN_SECONDS = 31536000;\r\n        uint constant LEAP_YEAR_IN_SECONDS = 31622400;\r\n\r\n        uint constant HOUR_IN_SECONDS = 3600;\r\n        uint constant MINUTE_IN_SECONDS = 60;\r\n\r\n        uint16 constant ORIGIN_YEAR = 1970;\r\n\r\n        function isLeapYear(uint16 year) internal constant returns (bool) {\r\n                if (year % 4 != 0) {\r\n                        return false;\r\n                }\r\n                if (year % 100 != 0) {\r\n                        return true;\r\n                }\r\n                if (year % 400 != 0) {\r\n                        return false;\r\n                }\r\n                return true;\r\n        }\r\n\r\n        function leapYearsBefore(uint year) internal constant returns (uint) {\r\n                year -= 1;\r\n                return year / 4 - year / 100 + year / 400;\r\n        }\r\n\r\n        function getDaysInMonth(uint8 month, uint16 year) internal constant returns (uint8) {\r\n                if (month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12) {\r\n                        return 31;\r\n                }\r\n                else if (month == 4 || month == 6 || month == 9 || month == 11) {\r\n                        return 30;\r\n                }\r\n                else if (isLeapYear(year)) {\r\n                        return 29;\r\n                }\r\n                else {\r\n                        return 28;\r\n                }\r\n        }\r\n\r\n        function parseTimestamp(uint timestamp) internal returns (DateTime dt) {\r\n                uint secondsAccountedFor = 0;\r\n                uint buf;\r\n                uint8 i;\r\n\r\n                // Year\r\n                dt.year = getYear(timestamp);\r\n                buf = leapYearsBefore(dt.year) - leapYearsBefore(ORIGIN_YEAR);\r\n\r\n                secondsAccountedFor += LEAP_YEAR_IN_SECONDS * buf;\r\n                secondsAccountedFor += YEAR_IN_SECONDS * (dt.year - ORIGIN_YEAR - buf);\r\n\r\n                // Month\r\n                uint secondsInMonth;\r\n                for (i = 1; i <= 12; i++) {\r\n                        secondsInMonth = DAY_IN_SECONDS * getDaysInMonth(i, dt.year);\r\n                        if (secondsInMonth + secondsAccountedFor > timestamp) {\r\n                                dt.month = i;\r\n                                break;\r\n                        }\r\n                        secondsAccountedFor += secondsInMonth;\r\n                }\r\n\r\n                // Day\r\n                for (i = 1; i <= getDaysInMonth(dt.month, dt.year); i++) {\r\n                        if (DAY_IN_SECONDS + secondsAccountedFor > timestamp) {\r\n                                dt.day = i;\r\n                                break;\r\n                        }\r\n                        secondsAccountedFor += DAY_IN_SECONDS;\r\n                }\r\n\r\n                // Hour\r\n                dt.hour = getHour(timestamp);\r\n\r\n                // Minute\r\n                dt.minute = getMinute(timestamp);\r\n\r\n                // Second\r\n                dt.second = getSecond(timestamp);\r\n\r\n                // Day of week.\r\n                dt.weekday = getWeekday(timestamp);\r\n        }\r\n\r\n        function getYear(uint timestamp) internal constant returns (uint16) {\r\n                uint secondsAccountedFor = 0;\r\n                uint16 year;\r\n                uint numLeapYears;\r\n\r\n                // Year\r\n                year = uint16(ORIGIN_YEAR + timestamp / YEAR_IN_SECONDS);\r\n                numLeapYears = leapYearsBefore(year) - leapYearsBefore(ORIGIN_YEAR);\r\n\r\n                secondsAccountedFor += LEAP_YEAR_IN_SECONDS * numLeapYears;\r\n                secondsAccountedFor += YEAR_IN_SECONDS * (year - ORIGIN_YEAR - numLeapYears);\r\n\r\n                while (secondsAccountedFor > timestamp) {\r\n                        if (isLeapYear(uint16(year - 1))) {\r\n                                secondsAccountedFor -= LEAP_YEAR_IN_SECONDS;\r\n                        }\r\n                        else {\r\n                                secondsAccountedFor -= YEAR_IN_SECONDS;\r\n                        }\r\n                        year -= 1;\r\n                }\r\n                return year;\r\n        }\r\n\r\n        function getMonth(uint timestamp) internal constant returns (uint8) {\r\n                return parseTimestamp(timestamp).month;\r\n        }\r\n\r\n        function getDay(uint timestamp) internal constant returns (uint8) {\r\n                return parseTimestamp(timestamp).day;\r\n        }\r\n\r\n        function getHour(uint timestamp) internal constant returns (uint8) {\r\n                return uint8((timestamp / 60 / 60) % 24);\r\n        }\r\n\r\n        function getMinute(uint timestamp) internal constant returns (uint8) {\r\n                return uint8((timestamp / 60) % 60);\r\n        }\r\n\r\n        function getSecond(uint timestamp) internal constant returns (uint8) {\r\n                return uint8(timestamp % 60);\r\n        }\r\n\r\n        function getWeekday(uint timestamp) internal constant returns (uint8) {\r\n                return uint8((timestamp / DAY_IN_SECONDS + 4) % 7);\r\n        }\r\n\r\n        function toTimestamp(uint16 year, uint8 month, uint8 day) internal constant returns (uint timestamp) {\r\n                return toTimestamp(year, month, day, 0, 0, 0);\r\n        }\r\n\r\n        function toTimestamp(uint16 year, uint8 month, uint8 day, uint8 hour) internal constant returns (uint timestamp) {\r\n                return toTimestamp(year, month, day, hour, 0, 0);\r\n        }\r\n\r\n        function toTimestamp(uint16 year, uint8 month, uint8 day, uint8 hour, uint8 minute) internal constant returns (uint timestamp) {\r\n                return toTimestamp(year, month, day, hour, minute, 0);\r\n        }\r\n\r\n        function toTimestamp(uint16 year, uint8 month, uint8 day, uint8 hour, uint8 minute, uint8 second) internal constant returns (uint timestamp) {\r\n                uint16 i;\r\n\r\n                // Year\r\n                for (i = ORIGIN_YEAR; i < year; i++) {\r\n                        if (isLeapYear(i)) {\r\n                                timestamp += LEAP_YEAR_IN_SECONDS;\r\n                        }\r\n                        else {\r\n                                timestamp += YEAR_IN_SECONDS;\r\n                        }\r\n                }\r\n\r\n                // Month\r\n                uint8[12] memory monthDayCounts;\r\n                monthDayCounts[0] = 31;\r\n                if (isLeapYear(year)) {\r\n                        monthDayCounts[1] = 29;\r\n                }\r\n                else {\r\n                        monthDayCounts[1] = 28;\r\n                }\r\n                monthDayCounts[2] = 31;\r\n                monthDayCounts[3] = 30;\r\n                monthDayCounts[4] = 31;\r\n                monthDayCounts[5] = 30;\r\n                monthDayCounts[6] = 31;\r\n                monthDayCounts[7] = 31;\r\n                monthDayCounts[8] = 30;\r\n                monthDayCounts[9] = 31;\r\n                monthDayCounts[10] = 30;\r\n                monthDayCounts[11] = 31;\r\n\r\n                for (i = 1; i < month; i++) {\r\n                        timestamp += DAY_IN_SECONDS * monthDayCounts[i - 1];\r\n                }\r\n\r\n                // Day\r\n                timestamp += DAY_IN_SECONDS * (day - 1);\r\n\r\n                // Hour\r\n                timestamp += HOUR_IN_SECONDS * (hour);\r\n\r\n                // Minute\r\n                timestamp += MINUTE_IN_SECONDS * (minute);\r\n\r\n                // Second\r\n                timestamp += second;\r\n\r\n                return timestamp;\r\n        }\r\n        \r\n        function addDaystoTimeStamp(uint16 _daysToBeAdded) internal  returns(uint){\r\n            return now + DAY_IN_SECONDS*_daysToBeAdded;\r\n        }\r\n\r\n        function addMinutestoTimeStamp(uint8 _minutesToBeAdded) internal  returns(uint){\r\n            return now + MINUTE_IN_SECONDS*_minutesToBeAdded;\r\n        }\r\n\r\n\r\n        function printDatestamp(uint timestamp) internal returns (uint16,uint8,uint8,uint8,uint8,uint8) {\r\n            DateTime memory dt;\r\n            dt = parseTimestamp(timestamp);\r\n            return (dt.year,dt.month,dt.day,dt.hour,dt.minute,dt.second);\r\n        }\r\n        \r\n        function currentTimeStamp() internal returns (uint) {\r\n            return now;\r\n        }\r\n}\r\n\r\n\r\ncontract ERC20 {\r\n    function totalSupply() view public returns (uint _totalSupply);\r\n    function balanceOf(address _owner) view public returns (uint balance);\r\n    function transfer(address _to, uint _value) public returns (bool success);\r\n    function transferFrom(address _from, address _to, uint _value) public returns (bool success);\r\n    function approve(address _spender, uint _value) public returns (bool success);\r\n    function allowance(address _owner, address _spender) view public returns (uint remaining);\r\n    event Transfer(address indexed _from, address indexed _to, uint _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint _value);\r\n}\r\n\r\n\r\ncontract BaseToken is ERC20 {\r\n    \r\n    address public owner;\r\n    using SafeMath for uint256;\r\n    \r\n    bool public tokenStatus = false;\r\n    \r\n    modifier ownerOnly(){\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    \r\n    modifier onlyWhenTokenIsOn(){\r\n        require(tokenStatus == true);\r\n        _;\r\n    }\r\n\r\n\r\n    function onOff () ownerOnly external{\r\n        tokenStatus = !tokenStatus;    \r\n    }\r\n\r\n\r\n    /**\r\n       * @dev Fix for the ERC20 short address attack.\r\n    */\r\n    modifier onlyPayloadSize(uint size) {\r\n        require(msg.data.length >= size + 4);\r\n        _;\r\n    }    \r\n    mapping (address => uint256) public balances;\r\n    mapping(address => mapping(address => uint256)) allowed;\r\n\r\n    //Token Details\r\n    string public symbol = \"BASE\";\r\n    string public name = \"Base Token\";\r\n    uint8 public decimals = 18;\r\n\r\n    uint256 public totalSupply; //will be instantiated in the derived Contracts\r\n    \r\n    function totalSupply() view public returns (uint256 ){\r\n        return totalSupply;\r\n    }\r\n\r\n\r\n    function balanceOf(address _owner) view public returns (uint balance){\r\n        return balances[_owner];\r\n    }\r\n    \r\n    function transfer(address _to, uint _value) onlyWhenTokenIsOn onlyPayloadSize(2 * 32) public returns (bool success){\r\n        //_value = _value.mul(1e18);\r\n        require(\r\n            balances[msg.sender]>=_value \r\n            && _value > 0);\r\n            balances[msg.sender] = balances[msg.sender].sub(_value);\r\n            balances[_to] = balances[_to].add(_value);\r\n            emit Transfer(msg.sender,_to,_value);\r\n            return true;\r\n    }\r\n    \r\n    function transferFrom(address _from, address _to, uint _value) onlyWhenTokenIsOn onlyPayloadSize(3 * 32) public returns (bool success){\r\n        //_value = _value.mul(10**decimals);\r\n        require(\r\n            allowed[_from][msg.sender]>= _value\r\n            && balances[_from] >= _value\r\n            && _value >0 \r\n            );\r\n        balances[_from] = balances[_from].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n        emit Transfer(_from, _to, _value);\r\n        return true;\r\n            \r\n    }\r\n    \r\n    function approve(address _spender, uint _value) onlyWhenTokenIsOn public returns (bool success){\r\n        //_value = _value.mul(10**decimals);\r\n        allowed[msg.sender][_spender] = _value;\r\n        emit Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n    \r\n    function allowance(address _owner, address _spender) view public returns (uint remaining){\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n    \r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n    \r\n\r\n}\r\n\r\n\r\n\r\n\r\ncontract ICO is BaseToken,DateTimeEnabled{\r\n\r\n    uint256 base = 10;\r\n    uint256 multiplier;\r\n\r\n    address ownerMultisig;\r\n\r\n    struct ICOPhase {\r\n        string phaseName;\r\n        uint256 tokensStaged;\r\n        uint256 tokensAllocated;\r\n        uint256 iRate;\r\n        uint256 fRate;\r\n        uint256 intialTime;\r\n        uint256 closingTime;\r\n       // uint256 RATE;\r\n        bool saleOn;\r\n        uint deadline;\r\n    }\r\n\r\n    uint8 public currentICOPhase;\r\n    \r\n    mapping(address=>uint256) public ethContributedBy;\r\n    uint256 public totalEthRaised;\r\n    uint256 public totalTokensSoldTillNow;\r\n\r\n    mapping(uint8=>ICOPhase) public icoPhases;\r\n    uint8 icoPhasesIndex=1;\r\n    \r\n    function getEthContributedBy(address _address) view public returns(uint256){\r\n        return ethContributedBy[_address];\r\n    }\r\n\r\n    function getTotalEthRaised() view public returns(uint256){\r\n        return totalEthRaised;\r\n    }\r\n\r\n    function getTotalTokensSoldTillNow() view public returns(uint256){\r\n        return totalTokensSoldTillNow;\r\n    }\r\n\r\n    \r\n    function addICOPhase(string _phaseName,uint256 _tokensStaged,uint256 _iRate, uint256 _fRate,uint256 _intialTime,uint256 _closingTime) ownerOnly public{\r\n        icoPhases[icoPhasesIndex].phaseName = _phaseName;\r\n        icoPhases[icoPhasesIndex].tokensStaged = _tokensStaged;\r\n        icoPhases[icoPhasesIndex].iRate = _iRate;\r\n        icoPhases[icoPhasesIndex].fRate = _fRate;\r\n        icoPhases[icoPhasesIndex].intialTime = _intialTime;\r\n        icoPhases[icoPhasesIndex].closingTime = _closingTime;\r\n        icoPhases[icoPhasesIndex].tokensAllocated = 0;\r\n        icoPhases[icoPhasesIndex].saleOn = false;\r\n        //icoPhases[icoPhasesIndex].deadline = _deadline;\r\n        icoPhasesIndex++;\r\n    }\r\n\r\n    function toggleSaleStatus() ownerOnly external{\r\n        icoPhases[currentICOPhase].saleOn = !icoPhases[currentICOPhase].saleOn;\r\n    }\r\n    function changefRate(uint256 _fRate) ownerOnly external{\r\n        icoPhases[currentICOPhase].fRate = _fRate;\r\n    }\r\n    function changeCurrentICOPhase(uint8 _newPhase) ownerOnly external{ //Only provided for exception handling in case some faulty phase has been added by the owner using addICOPhase\r\n        currentICOPhase = _newPhase;\r\n    }\r\n\r\n    function changeCurrentPhaseDeadline(uint8 _numdays) ownerOnly external{\r\n        icoPhases[currentICOPhase].closingTime= addDaystoTimeStamp(_numdays); //adds number of days to now and that becomes the new deadline\r\n    }\r\n    \r\n    function transferOwnership(address newOwner) ownerOnly external{\r\n        if (newOwner != address(0)) {\r\n          owner = newOwner;\r\n        }\r\n    }\r\n    \r\n}\r\ncontract MultiRound is ICO{\r\n    function newICORound(uint256 _newSupply) ownerOnly public{//This is different from Stages which means multiple parts of one round\r\n        _newSupply = _newSupply.mul(multiplier);\r\n        balances[owner] = balances[owner].add(_newSupply);\r\n        totalSupply = totalSupply.add(_newSupply);\r\n    }\r\n\r\n    function destroyUnsoldTokens(uint256 _tokens) ownerOnly public{\r\n        _tokens = _tokens.mul(multiplier);\r\n        totalSupply = totalSupply.sub(_tokens);\r\n        balances[owner] = balances[owner].sub(_tokens);\r\n    }\r\n\r\n    \r\n}\r\n\r\ncontract ReferralEnabledToken is BaseToken{\r\n\r\n    \r\n    struct referral {\r\n        address referrer;\r\n        uint8 referrerPerc;// this is the percentage referrer will get in ETH. \r\n        uint8 refereePerc; // this is the discount Refereee will get \r\n    }\r\n\r\n    struct redeemedReferral {\r\n        address referee;\r\n        uint timestamp;\r\n        uint ethContributed;\r\n        uint rewardGained;\r\n    }\r\n    mapping(address=>referral) public referrals;\r\n    \r\n    uint8 public currentReferralRewardPercentage=10;\r\n    uint8 public currentReferralDiscountPercentage=10;\r\n    \r\n    mapping(address=>uint256) public totalEthRewards;\r\n    mapping(address=>mapping(uint16=>redeemedReferral)) referrerRewards;\r\n    mapping(address=>uint16) referrerRewardIndex;\r\n    \r\n    function totalEthRewards(address _address) view public returns(uint256){\r\n        totalEthRewards[_address];\r\n    }\r\n    \r\n    function createReferral(address _referrer, address _referree) public returns (bool) {\r\n        require(_referrer != _referree);\r\n        require (referrals[_referree].referrer == address(0) || referrals[_referree].referrer==msg.sender);\r\n        referrals[_referree].referrer = _referrer;\r\n        referrals[_referree].referrerPerc = currentReferralRewardPercentage;\r\n        referrals[_referree].refereePerc = currentReferralDiscountPercentage;\r\n        return true;\r\n    }\r\n    \r\n    function getReferrerRewards(address _referrer, uint16 _index) view public returns(address,uint,uint,uint){\r\n        redeemedReferral r = referrerRewards[_referrer][_index];\r\n        return(r.referee,r.timestamp,r.ethContributed,r.rewardGained);\r\n    }\r\n    \r\n    function getReferrerIndex(address _referrer) view public returns(uint16) {\r\n        return(referrerRewardIndex[_referrer]);\r\n    }\r\n    \r\n    \r\n    function getReferrerTotalRewards(address _referrer) view public returns(uint){\r\n        return (totalEthRewards[_referrer]);\r\n    }\r\n    \r\n    function getReferral(address _refereeId) constant public returns(address,uint8,uint8) {\r\n        referral memory r = referrals[_refereeId];\r\n        return(r.referrer,r.referrerPerc,r.refereePerc);\r\n    } \r\n\r\n    function changeReferralPerc(uint8 _newPerc) ownerOnly external{\r\n        currentReferralRewardPercentage = _newPerc;\r\n    }\r\n\r\n    function changeRefereePerc(uint8 _newPerc) ownerOnly external{\r\n        currentReferralDiscountPercentage = _newPerc;\r\n    }\r\n}\r\ncontract killable is ICO {\r\n    \r\n    function killContract() ownerOnly external{\r\n        selfdestruct(ownerMultisig);\r\n    }\r\n}\r\n//TODO - ADD Total ETH raised and Record token wise contribution    \r\ncontract RefineMediumToken is ICO,killable,MultiRound,ReferralEnabledToken  {\r\n //   uint256 intialTime = 1542043381;\r\n //   uint256 closingTime = 1557681781;\r\n    uint256 constant alloc1perc=50; //TEAM ALLOCATION\r\n    address constant alloc1Acc = 0xF0B50870e5d01FbfE783F6e76994A0BA94d34fe9; //CORETEAM Address (test-TestRPC4)\r\n\r\n    uint256 constant alloc2perc=50;//in percent -- ADVISORS ALLOCATION\r\n    address constant alloc2Acc = 0x3c3daEd0733cDBB26c298443Cec93c48426CC4Bd; //TestRPC5\r\n\r\n    uint256 constant alloc3perc=50;//in percent -- Bounty Allocation\r\n    address constant alloc3Acc = 0xAc5c102B4063615053C29f9B4DC8001D529037Cd; //TestRPC6\r\n\r\n    uint256 constant alloc4perc=50;//in percent -- Reserved LEAVE IT TO ZERO IF NO MORE ALLOCATIONS ARE THERE\r\n    address constant alloc4Acc = 0xf080966E970AC351A9D576846915bBE049Fe98dB; //TestRPC7\r\n\r\n    address constant ownerMultisig = 0xc4010efafaf53be13498efcffa04df931dc1592a; //Test4\r\n    mapping(address=>uint) blockedTill;    \r\n\r\n    constructor() public{\r\n        symbol = \"XRM\";\r\n        name = \"Refine Medium Token\";\r\n        decimals = 18;\r\n        multiplier=base**decimals;\r\n\r\n        totalSupply = 300000000*multiplier;//300 mn-- extra 18 zeroes are for the wallets which use decimal variable to show the balance \r\n        owner = msg.sender;\r\n\r\n        balances[owner]=totalSupply;\r\n        currentICOPhase = 1;\r\n        addICOPhase(\"Private Sale\",15000000*multiplier,1550,1550,1558742400,1560556800);\r\n        runAllocations();\r\n    }\r\n\r\n    function runAllocations() ownerOnly public{\r\n        balances[owner]=((1000-(alloc1perc+alloc2perc+alloc3perc+alloc4perc))*totalSupply)/1000;\r\n        \r\n        balances[alloc1Acc]=(alloc1perc*totalSupply)/1000;\r\n        blockedTill[alloc1Acc] = addDaystoTimeStamp(2);\r\n        \r\n        balances[alloc2Acc]=(alloc2perc*totalSupply)/1000;\r\n        blockedTill[alloc2Acc] = addDaystoTimeStamp(2);\r\n        \r\n        balances[alloc3Acc]=(alloc3perc*totalSupply)/1000;\r\n        blockedTill[alloc3Acc] = addDaystoTimeStamp(2);\r\n        \r\n        balances[alloc4Acc]=(alloc4perc*totalSupply)/1000;\r\n        blockedTill[alloc4Acc] = addDaystoTimeStamp(2);\r\n        \r\n    }\r\n\r\n    function showRate(uint256 _epoch) public view returns (uint256){\r\n         ICOPhase storage i = icoPhases[currentICOPhase];\r\n         uint256 epoch = _epoch.sub(i.intialTime);\r\n         uint256 timeRange = i.closingTime.sub(i.intialTime);\r\n         uint256 rateRange = i.iRate.sub(i.fRate);\r\n         return (i.iRate*100000000000).sub((epoch.mul(rateRange)*100000000000).div(timeRange));\r\n    }\r\n    function currentRate() public view returns (uint256){\r\n         ICOPhase storage i = icoPhases[currentICOPhase];\r\n         uint256 epoch = now.sub(i.intialTime);\r\n         uint256 timeRange = i.closingTime.sub(i.intialTime);\r\n         uint256 rateRange = i.iRate.sub(i.fRate);\r\n         return ((i.iRate*100000000000).sub((epoch.mul(rateRange)*100000000000).div(timeRange)))/100000000000;\r\n    }\r\n    function () payable public{\r\n        createTokens();\r\n    }   \r\n\r\n    \r\n    function createTokens() payable public{\r\n        ICOPhase storage i = icoPhases[currentICOPhase]; \r\n        require(msg.value > 0\r\n            && i.saleOn == true);\r\n        \r\n        uint256 totalreferrerPerc = 0;\r\n        \r\n       // uint256 tokens = msg.value.mul((i.RATE*(100+r.refereePerc))/100);\r\n       uint256 tokens =   msg.value.mul((currentRate()*(100+r.refereePerc))/100);\r\n        balances[owner] = balances[owner].sub(tokens);\r\n        balances[msg.sender] = balances[msg.sender].add(tokens);\r\n        i.tokensAllocated = i.tokensAllocated.add(tokens);\r\n        totalTokensSoldTillNow = totalTokensSoldTillNow.add(tokens); \r\n        \r\n        ethContributedBy[msg.sender] = ethContributedBy[msg.sender].add(msg.value);\r\n        totalEthRaised = totalEthRaised.add(msg.value);\r\n        referral storage r = referrals[msg.sender];\r\n        uint8 counter = 1;\r\n        while(r.referrer != 0 && counter <= 2){\r\n                       \r\n            counter = counter + 1;            \r\n            \r\n            uint16 currIndex = referrerRewardIndex[r.referrer] + 1;\r\n            uint rewardGained = (r.referrerPerc*msg.value)/100;\r\n            referrerRewardIndex[r.referrer] = currIndex;\r\n            referrerRewards[r.referrer][currIndex].referee = msg.sender;\r\n            referrerRewards[r.referrer][currIndex].timestamp = now;\r\n            referrerRewards[r.referrer][currIndex].ethContributed = msg.value;\r\n            referrerRewards[r.referrer][currIndex].rewardGained = rewardGained ;\r\n            totalEthRewards[r.referrer] = totalEthRewards[r.referrer].add(rewardGained);\r\n            r.referrer.transfer(rewardGained);\r\n                \r\n            totalreferrerPerc = totalreferrerPerc + r.referrerPerc;\r\n            r = referrals[r.referrer];\r\n            \r\n        }\r\n        ownerMultisig.transfer(((100-totalreferrerPerc)*msg.value)/100);\r\n\r\n        //Token Disbursement\r\n\r\n        \r\n        if(i.tokensAllocated>=i.tokensStaged){\r\n            i.saleOn = !i.saleOn; \r\n            currentICOPhase++;\r\n        }\r\n        \r\n    }\r\n    \r\n    \r\n    \r\n    function transfer(address _to, uint _value) onlyWhenTokenIsOn onlyPayloadSize(2 * 32) public returns (bool success){\r\n        //_value = _value.mul(1e18);\r\n        require(\r\n            balances[msg.sender]>=_value \r\n            && _value > 0\r\n            && now > blockedTill[msg.sender]\r\n        );\r\n        balances[msg.sender] = balances[msg.sender].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n        emit Transfer(msg.sender,_to,_value);\r\n        return true;\r\n    }\r\n    \r\n    function transferFrom(address _from, address _to, uint _value) onlyWhenTokenIsOn onlyPayloadSize(3 * 32) public returns (bool success){\r\n        //_value = _value.mul(10**decimals);\r\n        require(\r\n            allowed[_from][msg.sender]>= _value\r\n            && balances[_from] >= _value\r\n            && _value >0 \r\n            && now > blockedTill[_from]            \r\n        );\r\n\r\n        balances[_from] = balances[_from].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n        emit Transfer(_from, _to, _value);\r\n        return true;\r\n            \r\n    }\r\n    event Burn(address indexed _burner, uint _value);\r\n    function burn(uint _value) ownerOnly returns (bool)\r\n    {\r\n        balances[msg.sender] = balances[msg.sender].sub(_value);\r\n        totalSupply = totalSupply.sub(_value);\r\n        emit Burn(msg.sender, _value);\r\n        emit Transfer(msg.sender, address(0x0), _value);\r\n        return true;\r\n    }\r\n     event Mint(address indexed to, uint256 amount);\r\n    event MintFinished();\r\n\r\n     bool public mintingFinished = false;\r\n\r\n\r\n     modifier canMint() {\r\n     require(!mintingFinished);\r\n     _;\r\n   }\r\n    function mint(address _to, uint256 _amount) ownerOnly canMint public returns (bool) {\r\n    totalSupply = totalSupply.add(_amount);\r\n    balances[_to] = balances[_to].add(_amount);\r\n    emit Mint(_to, _amount);\r\n    emit Transfer(address(0), _to, _amount);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Function to stop minting new tokens.\r\n   * @return True if the operation was successful.\r\n   */\r\n  function finishMinting() ownerOnly canMint public returns (bool) {\r\n    mintingFinished = true;\r\n    emit MintFinished();\r\n    return true;\r\n  }\r\n    \r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_phaseName\",\"type\":\"string\"},{\"name\":\"_tokensStaged\",\"type\":\"uint256\"},{\"name\":\"_iRate\",\"type\":\"uint256\"},{\"name\":\"_fRate\",\"type\":\"uint256\"},{\"name\":\"_intialTime\",\"type\":\"uint256\"},{\"name\":\"_closingTime\",\"type\":\"uint256\"}],\"name\":\"addICOPhase\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"toggleSaleStatus\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"mintingFinished\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"runAllocations\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"killContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"balances\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newPerc\",\"type\":\"uint8\"}],\"name\":\"changeReferralPerc\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTotalTokensSoldTillNow\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_numdays\",\"type\":\"uint8\"}],\"name\":\"changeCurrentPhaseDeadline\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_refereeId\",\"type\":\"address\"}],\"name\":\"getReferral\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint8\"},{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_epoch\",\"type\":\"uint256\"}],\"name\":\"showRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newPhase\",\"type\":\"uint8\"}],\"name\":\"changeCurrentICOPhase\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentReferralDiscountPercentage\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_referrer\",\"type\":\"address\"}],\"name\":\"getReferrerIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_referrer\",\"type\":\"address\"},{\"name\":\"_index\",\"type\":\"uint16\"}],\"name\":\"getReferrerRewards\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finishMinting\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"totalEthRewards\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentICOPhase\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"referrals\",\"outputs\":[{\"name\":\"referrer\",\"type\":\"address\"},{\"name\":\"referrerPerc\",\"type\":\"uint8\"},{\"name\":\"refereePerc\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"onOff\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenStatus\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokens\",\"type\":\"uint256\"}],\"name\":\"destroyUnsoldTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_fRate\",\"type\":\"uint256\"}],\"name\":\"changefRate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getEthContributedBy\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"createTokens\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newPerc\",\"type\":\"uint8\"}],\"name\":\"changeRefereePerc\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentReferralRewardPercentage\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalEthRaised\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"name\":\"icoPhases\",\"outputs\":[{\"name\":\"phaseName\",\"type\":\"string\"},{\"name\":\"tokensStaged\",\"type\":\"uint256\"},{\"name\":\"tokensAllocated\",\"type\":\"uint256\"},{\"name\":\"iRate\",\"type\":\"uint256\"},{\"name\":\"fRate\",\"type\":\"uint256\"},{\"name\":\"intialTime\",\"type\":\"uint256\"},{\"name\":\"closingTime\",\"type\":\"uint256\"},{\"name\":\"saleOn\",\"type\":\"bool\"},{\"name\":\"deadline\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalTokensSoldTillNow\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"ethContributedBy\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTotalEthRaised\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newSupply\",\"type\":\"uint256\"}],\"name\":\"newICORound\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_referrer\",\"type\":\"address\"}],\"name\":\"getReferrerTotalRewards\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_referrer\",\"type\":\"address\"},{\"name\":\"_referree\",\"type\":\"address\"}],\"name\":\"createReferral\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_burner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Burn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Mint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"MintFinished\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"RefineMediumToken","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://5a451b79a95d7c1ed9d1b6aacaf7bdd5673583ff39924cd98c626fb68148f541"}]}