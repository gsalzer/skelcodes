{"status":"1","message":"OK","result":[{"SourceCode":"// File: contracts/IUniswapExchange.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n// Solidity Interface\r\n\r\ncontract IUniswapExchange {\r\n    // Address of ERC20 token sold on this exchange\r\n    function tokenAddress() external view returns (address token);\r\n    // Address of Uniswap Factory\r\n    function factoryAddress() external view returns (address factory);\r\n    // Provide Liquidity\r\n    function addLiquidity(uint256 min_liquidity, uint256 max_tokens, uint256 deadline) external payable returns (uint256);\r\n    function removeLiquidity(uint256 amount, uint256 min_eth, uint256 min_tokens, uint256 deadline) external returns (uint256, uint256);\r\n    // Get Prices\r\n    function getEthToTokenInputPrice(uint256 eth_sold) external view returns (uint256 tokens_bought);\r\n    function getEthToTokenOutputPrice(uint256 tokens_bought) external view returns (uint256 eth_sold);\r\n    function getTokenToEthInputPrice(uint256 tokens_sold) external view returns (uint256 eth_bought);\r\n    function getTokenToEthOutputPrice(uint256 eth_bought) external view returns (uint256 tokens_sold);\r\n    // Trade ETH to ERC20\r\n    function ethToTokenSwapInput(uint256 min_tokens, uint256 deadline) external payable returns (uint256  tokens_bought);\r\n    function ethToTokenTransferInput(uint256 min_tokens, uint256 deadline, address recipient) external payable returns (uint256  tokens_bought);\r\n    function ethToTokenSwapOutput(uint256 tokens_bought, uint256 deadline) external payable returns (uint256  eth_sold);\r\n    function ethToTokenTransferOutput(uint256 tokens_bought, uint256 deadline, address recipient) external payable returns (uint256  eth_sold);\r\n    // Trade ERC20 to ETH\r\n    function tokenToEthSwapInput(uint256 tokens_sold, uint256 min_eth, uint256 deadline) external returns (uint256  eth_bought);\r\n    function tokenToEthTransferInput(uint256 tokens_sold, uint256 min_tokens, uint256 deadline, address recipient) external returns (uint256  eth_bought);\r\n    function tokenToEthSwapOutput(uint256 eth_bought, uint256 max_tokens, uint256 deadline) external returns (uint256  tokens_sold);\r\n    function tokenToEthTransferOutput(uint256 eth_bought, uint256 max_tokens, uint256 deadline, address recipient) external returns (uint256  tokens_sold);\r\n    // Trade ERC20 to ERC20\r\n    function tokenToTokenSwapInput(uint256 tokens_sold, uint256 min_tokens_bought, uint256 min_eth_bought, uint256 deadline, address token_addr) external returns (uint256  tokens_bought);\r\n    function tokenToTokenTransferInput(uint256 tokens_sold, uint256 min_tokens_bought, uint256 min_eth_bought, uint256 deadline, address recipient, address token_addr) external returns (uint256  tokens_bought);\r\n    function tokenToTokenSwapOutput(uint256 tokens_bought, uint256 max_tokens_sold, uint256 max_eth_sold, uint256 deadline, address token_addr) external returns (uint256  tokens_sold);\r\n    function tokenToTokenTransferOutput(uint256 tokens_bought, uint256 max_tokens_sold, uint256 max_eth_sold, uint256 deadline, address recipient, address token_addr) external returns (uint256  tokens_sold);\r\n    // Trade ERC20 to Custom Pool\r\n    function tokenToExchangeSwapInput(uint256 tokens_sold, uint256 min_tokens_bought, uint256 min_eth_bought, uint256 deadline, address exchange_addr) external returns (uint256  tokens_bought);\r\n    function tokenToExchangeTransferInput(uint256 tokens_sold, uint256 min_tokens_bought, uint256 min_eth_bought, uint256 deadline, address recipient, address exchange_addr) external returns (uint256  tokens_bought);\r\n    function tokenToExchangeSwapOutput(uint256 tokens_bought, uint256 max_tokens_sold, uint256 max_eth_sold, uint256 deadline, address exchange_addr) external returns (uint256  tokens_sold);\r\n    function tokenToExchangeTransferOutput(uint256 tokens_bought, uint256 max_tokens_sold, uint256 max_eth_sold, uint256 deadline, address recipient, address exchange_addr) external returns (uint256  tokens_sold);\r\n    // ERC20 comaptibility for liquidity tokens\r\n    bytes32 public name;\r\n    bytes32 public symbol;\r\n    uint256 public decimals;\r\n    function transfer(address _to, uint256 _value) external returns (bool);\r\n    function transferFrom(address _from, address _to, uint256 value) external returns (bool);\r\n    function approve(address _spender, uint256 _value) external returns (bool);\r\n    function allowance(address _owner, address _spender) external view returns (uint256);\r\n    function balanceOf(address _owner) external view returns (uint256);\r\n    function totalSupply() public view returns (uint256);\r\n    // Never use\r\n    function setup(address token_addr) external;\r\n}\r\n\r\n// File: contracts/IUniswapFactory.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n// Solidity Interface\r\n\r\ncontract IUniswapFactory {\r\n    // Public Variables\r\n    address public exchangeTemplate;\r\n    uint256 public tokenCount;\r\n    // Create Exchange\r\n    function createExchange(address token) external returns (address exchange);\r\n    // Get Exchange and Token Info\r\n    function getExchange(address token) external view returns (address exchange);\r\n    function getToken(address exchange) external view returns (address token);\r\n    function getTokenWithId(uint256 tokenId) external view returns (address token);\r\n    // Never use\r\n    function initializeFactory(address template) external;\r\n}\r\n\r\n// File: contracts/IDutchExchange.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\ncontract IDutchExchange {\r\n\r\n\r\n    mapping(address => mapping(address => uint)) public balances;\r\n\r\n    // Token => Token => auctionIndex => amount\r\n    mapping(address => mapping(address => mapping(uint => uint))) public extraTokens;\r\n\r\n    // Token => Token =>  auctionIndex => user => amount\r\n    mapping(address => mapping(address => mapping(uint => mapping(address => uint)))) public sellerBalances;\r\n    mapping(address => mapping(address => mapping(uint => mapping(address => uint)))) public buyerBalances;\r\n    mapping(address => mapping(address => mapping(uint => mapping(address => uint)))) public claimedAmounts;\r\n\r\n    \r\n    function ethToken() public view returns(address);\r\n    function claimBuyerFunds(address, address, address, uint) public returns(uint, uint);\r\n    function deposit(address tokenAddress, uint amount) public returns (uint);\r\n    function withdraw(address tokenAddress, uint amount) public returns (uint);\r\n    function getAuctionIndex(address token1, address token2) public returns(uint256);\r\n    function postBuyOrder(address token1, address token2, uint256 auctionIndex, uint256 amount) public returns(uint256);\r\n    function postSellOrder(address token1, address token2, uint256 auctionIndex, uint256 tokensBought) public returns(uint256, uint256);\r\n    function getCurrentAuctionPrice(address token1, address token2, uint256 auctionIndex) public view returns(uint256, uint256);\r\n    function claimAndWithdrawTokensFromSeveralAuctionsAsBuyer(address[] calldata, address[] calldata, uint[] calldata) external view returns(uint[] memory, uint);\r\n}\r\n\r\n// File: contracts/ITokenMinimal.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\ncontract ITokenMinimal {\r\n    function allowance(address tokenOwner, address spender) public view returns (uint remaining);\r\n    function balanceOf(address tokenOwner) public view returns (uint balance);\r\n    function deposit() public payable;\r\n    function withdraw(uint value) public;\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/utils/Address.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n/**\r\n * Utility library of inline functions on addresses\r\n */\r\nlibrary Address {\r\n    /**\r\n     * Returns whether the target address is a contract\r\n     * @dev This function will return false if invoked during the constructor of a contract,\r\n     * as the code is not actually created until after the constructor finishes.\r\n     * @param account address of the account to check\r\n     * @return whether the target address is a contract\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        uint256 size;\r\n        // XXX Currently there is no better way to check if there is a contract in an address\r\n        // than to check the size of the code at that address.\r\n        // See https://ethereum.stackexchange.com/a/14016/36603\r\n        // for more details about how this works.\r\n        // TODO Check this again before the Serenity release, because all addresses will be\r\n        // contracts then.\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { size := extcodesize(account) }\r\n        return size > 0;\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC20/IERC20.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://eips.ethereum.org/EIPS/eip-20\r\n */\r\ninterface IERC20 {\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n\r\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address who) external view returns (uint256);\r\n\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: contracts/SafeERC20.sol\r\n\r\n/*\r\n\r\nSafeERC20 by daostack.\r\nThe code is based on a fix by SECBIT Team.\r\n\r\nUSE WITH CAUTION & NO WARRANTY\r\n\r\nREFERENCE & RELATED READING\r\n- https://github.com/ethereum/solidity/issues/4116\r\n- https://medium.com/@chris_77367/explaining-unexpected-reverts-starting-with-solidity-0-4-22-3ada6e82308c\r\n- https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca\r\n- https://gist.github.com/BrendanChou/88a2eeb80947ff00bcf58ffdafeaeb61\r\n\r\n*/\r\npragma solidity ^0.5.0;\r\n\r\n\r\n\r\nlibrary SafeERC20 {\r\n    using Address for address;\r\n\r\n    bytes4 constant private TRANSFER_SELECTOR = bytes4(keccak256(bytes(\"transfer(address,uint256)\")));\r\n    bytes4 constant private TRANSFERFROM_SELECTOR = bytes4(keccak256(bytes(\"transferFrom(address,address,uint256)\")));\r\n    bytes4 constant private APPROVE_SELECTOR = bytes4(keccak256(bytes(\"approve(address,uint256)\")));\r\n\r\n    function safeTransfer(address _erc20Addr, address _to, uint256 _value) internal {\r\n\r\n        // Must be a contract addr first!\r\n        require(_erc20Addr.isContract(), \"ERC20 is not a contract\");\r\n\r\n        (bool success, bytes memory returnValue) =\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        _erc20Addr.call(abi.encodeWithSelector(TRANSFER_SELECTOR, _to, _value));\r\n        // call return false when something wrong\r\n        require(success, \"safeTransfer must succeed\");\r\n        //check return value\r\n        require(returnValue.length == 0 || (returnValue.length == 32 && (returnValue[31] != 0)), \"safeTransfer must return nothing or true\");\r\n    }\r\n\r\n    function safeTransferFrom(address _erc20Addr, address _from, address _to, uint256 _value) internal {\r\n\r\n        // Must be a contract addr first!\r\n        require(_erc20Addr.isContract(), \"ERC20 is not a contract\");\r\n\r\n        (bool success, bytes memory returnValue) =\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        _erc20Addr.call(abi.encodeWithSelector(TRANSFERFROM_SELECTOR, _from, _to, _value));\r\n        // call return false when something wrong\r\n        require(success, \"safeTransferFrom must succeed\");\r\n        //check return value\r\n        require(returnValue.length == 0 || (returnValue.length == 32 && (returnValue[31] != 0)), \"safeTransferFrom must return nothing or true\");\r\n    }\r\n\r\n    function safeApprove(address _erc20Addr, address _spender, uint256 _value) internal {\r\n\r\n        // Must be a contract addr first!\r\n        require(_erc20Addr.isContract(), \"ERC20 is not a contract\");\r\n        \r\n        // safeApprove should only be called when setting an initial allowance,\r\n        // or when resetting it to zero.\r\n        require((_value == 0) || (IERC20(_erc20Addr).allowance(address(this), _spender) == 0), \"safeApprove should only be called when setting an initial allowance, or when resetting it to zero.\");\r\n\r\n        (bool success, bytes memory returnValue) =\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        _erc20Addr.call(abi.encodeWithSelector(APPROVE_SELECTOR, _spender, _value));\r\n        // call return false when something wrong\r\n        require(success, \"safeApprove must succeed\");\r\n        //check return value\r\n        require(returnValue.length == 0 || (returnValue.length == 32 && (returnValue[31] != 0)),  \"safeApprove must return nothing or true\");\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n     * account.\r\n     */\r\n    constructor () internal {\r\n        _owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), _owner);\r\n    }\r\n\r\n    /**\r\n     * @return the address of the owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner());\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @return true if `msg.sender` is the owner of the contract.\r\n     */\r\n    function isOwner() public view returns (bool) {\r\n        return msg.sender == _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to relinquish control of the contract.\r\n     * It will not be possible to call the functions with the `onlyOwner`\r\n     * modifier anymore.\r\n     * @notice Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0));\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\n// File: contracts/Arbitrage.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/// @title Uniswap Arbitrage - Executes arbitrage transactions between Uniswap and DutchX.\r\n/// @author Billy Rennekamp - <billy@gnosis.pm>\r\ncontract Arbitrage is Ownable {\r\n\r\n    uint constant max = uint(-1);\r\n\r\n    IUniswapFactory public uniFactory;\r\n    IDutchExchange public dutchXProxy;\r\n\r\n    event Profit(uint profit, bool wasDutchOpportunity);\r\n\r\n    /// @dev Payable fallback function has nothing inside so it won't run out of gas with gas limited transfers\r\n    function() external payable {}\r\n\r\n    /// @dev Only owner can deposit contract Ether into the DutchX as WETH\r\n    function depositEther() public payable onlyOwner {\r\n\r\n        require(address(this).balance > 0, \"Balance must be greater than 0 to deposit\");\r\n        uint balance = address(this).balance;\r\n\r\n        // // Deposit balance to WETH\r\n        address weth = dutchXProxy.ethToken();\r\n        ITokenMinimal(weth).deposit.value(balance)();\r\n\r\n        uint wethBalance = ITokenMinimal(weth).balanceOf(address(this));\r\n        uint allowance = ITokenMinimal(weth).allowance(address(this), address(dutchXProxy));\r\n\r\n        if (allowance < wethBalance) {\r\n            if (allowance != 0) {\r\n                SafeERC20.safeApprove(weth, address(dutchXProxy), 0);\r\n            }\r\n            // Approve max amount of WETH to be transferred by dutchX\r\n            // Keeping it max will have same or similar costs to making it exact over and over again\r\n            SafeERC20.safeApprove(weth, address(dutchXProxy), max);\r\n        }\r\n\r\n        // Deposit new amount on dutchX, confirm there's at least the amount we just deposited\r\n        uint newBalance = dutchXProxy.deposit(weth, balance);\r\n        require(newBalance >= balance, \"Deposit WETH to DutchX didn't work.\");\r\n    }\r\n\r\n    /// @dev Only owner can withdraw WETH from DutchX, convert to Ether and transfer to owner\r\n    /// @param amount The amount of Ether to withdraw\r\n    function withdrawEtherThenTransfer(uint amount) external onlyOwner {\r\n        _withdrawEther(amount);\r\n        address(uint160(owner())).transfer(amount);\r\n    }\r\n\r\n    /// @dev Only owner can transfer any Ether currently in the contract to the owner address.\r\n    /// @param amount The amount of Ether to withdraw\r\n    function transferEther(uint amount) external onlyOwner {\r\n        // If amount is zero, deposit the entire contract balance.\r\n        address(uint160(owner())).transfer(amount == 0 ? address(this).balance : amount);\r\n    }\r\n\r\n    /// @dev Only owner function to withdraw WETH from the DutchX, convert it to Ether and keep it in contract\r\n    /// @param amount The amount of WETH to withdraw and convert.\r\n    function withdrawEther(uint amount) external onlyOwner {\r\n        _withdrawEther(amount);\r\n    }\r\n\r\n    /// @dev Internal function to withdraw WETH from the DutchX, convert it to Ether and keep it in contract\r\n    /// @param amount The amount of WETH to withdraw and convert.\r\n    function _withdrawEther(uint amount) internal {\r\n        address weth = dutchXProxy.ethToken();\r\n        dutchXProxy.withdraw(weth, amount);\r\n        ITokenMinimal(weth).withdraw(amount);\r\n    }\r\n\r\n    /// @dev Only owner can withdraw a token from the DutchX\r\n    /// @param token The token address that is being withdrawn.\r\n    /// @param amount The amount of token to withdraw. Can be larger than available balance and maximum will be withdrawn.\r\n    /// @return Returns the amount actually withdrawn from the DutchX\r\n    function withdrawToken(address token, uint amount) external onlyOwner returns (uint) {\r\n        return dutchXProxy.withdraw(token, amount);\r\n    }\r\n\r\n    /// @dev Only owner can transfer tokens to the owner that belong to this contract\r\n    /// @param token The token address that is being transferred.\r\n    /// @param amount The amount of token to transfer.\r\n    function transferToken(address token, uint amount) external onlyOwner {\r\n        SafeERC20.safeTransfer(token, owner(), amount);\r\n    }\r\n\r\n    /// @dev Only owner can approve tokens to be used by the DutchX\r\n    /// @param token The token address to be approved for use\r\n    /// @param spender The address that should be approved\r\n    /// @param allowance The amount of tokens that should be approved\r\n    function approveToken(address token, address spender, uint allowance) external onlyOwner {\r\n        SafeERC20.safeApprove(token, spender, allowance);\r\n    }\r\n\r\n    /// @dev Only owner can deposit token to the DutchX\r\n    /// @param token The token address that is being deposited.\r\n    /// @param amount The amount of token to deposit.\r\n    function depositToken(address token, uint amount) external onlyOwner {\r\n        _depositToken(token, amount);\r\n    }\r\n\r\n    /// @dev Internal function to deposit token to the DutchX\r\n    /// @param token The token address that is being deposited.\r\n    /// @param amount The amount of token to deposit.\r\n    function _depositToken(address token, uint amount) internal returns(uint deposited) {\r\n        uint balance = ITokenMinimal(token).balanceOf(address(this));\r\n        uint min = balance < amount ? balance : amount;\r\n        require(min > 0, \"Balance of token insufficient\");\r\n\r\n        uint allowance = ITokenMinimal(token).allowance(address(this), address(dutchXProxy));\r\n        if (allowance < min) {\r\n            if (allowance != 0) {\r\n                SafeERC20.safeApprove(token, address(dutchXProxy), 0);\r\n            }\r\n            SafeERC20.safeApprove(token, address(dutchXProxy), max);\r\n        }\r\n\r\n        // Confirm that the balance of the token on the DutchX is at least how much was deposited\r\n        uint newBalance = dutchXProxy.deposit(token, min);\r\n        require(newBalance >= min, \"deposit didn't work\");\r\n        return min;\r\n    }\r\n\r\n    /// @dev Executes a trade opportunity on dutchX. Assumes that there is a balance of WETH already on the dutchX\r\n    /// @param arbToken Address of the token that should be arbitraged.\r\n    /// @param amount Amount of Ether to use in arbitrage.\r\n    /// @return Returns if transaction can be executed.\r\n    function dutchOpportunity(address arbToken, uint256 amount) external onlyOwner {\r\n\r\n        address etherToken = dutchXProxy.ethToken();\r\n\r\n        // The order of parameters for getAuctionIndex don't matter\r\n        uint256 dutchAuctionIndex = dutchXProxy.getAuctionIndex(arbToken, etherToken);\r\n\r\n        // postBuyOrder(sellToken, buyToken, amount)\r\n        // results in a decrease of the amount the user owns of the second token\r\n        // which means the buyToken is what the buyer wants to get rid of.\r\n        // \"The buy token is what the buyer provides, the seller token is what the seller provides.\"\r\n        dutchXProxy.postBuyOrder(arbToken, etherToken, dutchAuctionIndex, amount);\r\n\r\n        (uint tokensBought, ) = dutchXProxy.claimBuyerFunds(arbToken, etherToken, address(this), dutchAuctionIndex);\r\n        dutchXProxy.withdraw(arbToken, tokensBought);\r\n\r\n        address uniswapExchange = uniFactory.getExchange(arbToken);\r\n\r\n        uint allowance = ITokenMinimal(arbToken).allowance(address(this), address(uniswapExchange));\r\n        if (allowance < tokensBought) {\r\n            if (allowance != 0) {\r\n                SafeERC20.safeApprove(arbToken, address(uniswapExchange), 0);\r\n            }\r\n            // Approve Uniswap to transfer arbToken on contract's behalf\r\n            // Keeping it max will have same or similar costs to making it exact over and over again\r\n            SafeERC20.safeApprove(arbToken, address(uniswapExchange), max);\r\n        }\r\n\r\n        // tokenToEthSwapInput(inputToken, minimumReturn, timeToLive)\r\n        // minimumReturn is enough to make a profit (excluding gas)\r\n        // timeToLive is now because transaction is atomic\r\n        uint256 etherReturned = IUniswapExchange(uniswapExchange).tokenToEthSwapInput(tokensBought, 1, block.timestamp);\r\n\r\n        // gas costs were excluded because worse case scenario the tx fails and gas costs were spent up to here anyway\r\n        // best worst case scenario the profit from the trade alleviates part of the gas costs even if still no total profit\r\n        require(etherReturned >= amount, \"no profit\");\r\n        emit Profit(etherReturned, true);\r\n\r\n        // Ether is deposited as WETH\r\n        depositEther();\r\n    }\r\n\r\n    /// @dev Executes a trade opportunity on uniswap.\r\n    /// @param arbToken Address of the token that should be arbitraged.\r\n    /// @param amount Amount of Ether to use in arbitrage.\r\n    /// @return Returns if transaction can be executed.\r\n    function uniswapOpportunity(address arbToken, uint256 amount) external onlyOwner {\r\n\r\n        // WETH must be converted to Eth for Uniswap trade\r\n        // (Uniswap allows ERC20:ERC20 but most liquidity is on ETH:ERC20 markets)\r\n        _withdrawEther(amount);\r\n        require(address(this).balance >= amount, \"buying from uniswap takes real Ether\");\r\n\r\n        // ethToTokenSwapInput(minTokens, deadline)\r\n        // minTokens is 1 because it will revert without a profit regardless\r\n        // deadline is now since trade is atomic\r\n        // solium-disable-next-line security/no-block-members\r\n        uint256 tokensBought = IUniswapExchange(uniFactory.getExchange(arbToken)).ethToTokenSwapInput.value(amount)(1, block.timestamp);\r\n\r\n        // tokens need to be approved for the dutchX before they are deposited\r\n        tokensBought = _depositToken(arbToken, tokensBought);\r\n\r\n        address etherToken = dutchXProxy.ethToken();\r\n\r\n        // The order of parameters for getAuctionIndex don't matter\r\n        uint256 dutchAuctionIndex = dutchXProxy.getAuctionIndex(arbToken, etherToken);\r\n\r\n        // spend max amount of tokens currently on the dutch x (might be combined from previous remainders)\r\n        // max is automatically reduced to maximum available tokens because there may be\r\n        // token remainders from previous auctions which closed after previous arbitrage opportunities\r\n        dutchXProxy.postBuyOrder(etherToken, arbToken, dutchAuctionIndex, max);\r\n        // solium-disable-next-line no-unused-vars\r\n        (uint etherReturned, ) = dutchXProxy.claimBuyerFunds(etherToken, arbToken, address(this), dutchAuctionIndex);\r\n\r\n        // gas costs were excluded because worse case scenario the tx fails and gas costs were spent up to here anyway\r\n        // best worst case scenario the profit from the trade alleviates part of the gas costs even if still no total profit\r\n        require(etherReturned >= amount, \"no profit\");\r\n        emit Profit(etherReturned, false);\r\n        // Ether returned is already in dutchX balance where Ether is assumed to be stored when not being used.\r\n    }\r\n\r\n}\r\n\r\n// File: contracts/ArbitrageMainnet.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/// @title Uniswap Arbitrage Module - Executes arbitrage transactions between Uniswap and DutchX.\r\n/// @author Billy Rennekamp - <billy@gnosis.pm>\r\ncontract ArbitrageMainnet is Arbitrage {\r\n    constructor() public {\r\n        uniFactory = IUniswapFactory(0xc0a47dFe034B400B47bDaD5FecDa2621de6c4d95);\r\n        dutchXProxy = IDutchExchange(0xb9812E2fA995EC53B5b6DF34d21f9304762C5497);\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"depositToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawEther\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"arbToken\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"uniswapOpportunity\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferEther\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"uniFactory\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawEtherThenTransfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"arbToken\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"dutchOpportunity\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"depositEther\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawToken\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"allowance\",\"type\":\"uint256\"}],\"name\":\"approveToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"dutchXProxy\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"profit\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"wasDutchOpportunity\",\"type\":\"bool\"}],\"name\":\"Profit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"ArbitrageMainnet","CompilerVersion":"v0.5.2+commit.1df8f40c","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://588de64b4aa73dea5d481a397739265044e232d4060d9eaefa3981a2108805ae"}]}