{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.0;\r\n\r\n/**\r\n* @title Ownable\r\n* @dev The Ownable contract has an owner address, and provides basic authorization control\r\n* functions, this simplifies the implementation of \"user permissions\".\r\n*/\r\ncontract Ownable {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n\r\n    /**\r\n    * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n    * account.\r\n    */\r\n    constructor() public {\r\n        _owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), _owner);\r\n    }\r\n\r\n    /**\r\n    * @return the address of the owner.\r\n    */\r\n    function owner() public view returns(address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n    * @dev Throws if called by any account other than the owner.\r\n    */\r\n    modifier onlyOwner() {\r\n        require(isOwner());\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @return true if `msg.sender` is the owner of the contract.\r\n    */\r\n    function isOwner() public view returns(bool) {\r\n        return msg.sender == _owner;\r\n    }\r\n\r\n    /**\r\n    * @dev Allows the current owner to relinquish control of the contract.\r\n    * @notice Renouncing to ownership will leave the contract without an owner.\r\n    * It will not be possible to call the functions with the `onlyOwner`\r\n    * modifier anymore.\r\n    */\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n    * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n    * @param newOwner The address to transfer ownership to.\r\n    */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n    * @dev Transfers control of the contract to a newOwner.\r\n    * @param newOwner The address to transfer ownership to.\r\n    */\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0));\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\n/**\r\n* @title SafeMath\r\n* @dev Math operations with safety checks that revert on error\r\n*/\r\nlibrary SafeMath {\r\n\r\n    /**\r\n    * @dev Multiplies two numbers, reverts on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0); // Solidity only automatically asserts when dividing by 0\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, reverts on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\r\n    * reverts when dividing by zero.\r\n    */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}\r\n\r\ninterface HydroInterface {\r\n    function balances(address) external view returns (uint);\r\n    function allowed(address, address) external view returns (uint);\r\n    function transfer(address _to, uint256 _amount) external returns (bool success);\r\n    function transferFrom(address _from, address _to, uint256 _amount) external returns (bool success);\r\n    function balanceOf(address _owner) external view returns (uint256 balance);\r\n    function approve(address _spender, uint256 _amount) external returns (bool success);\r\n    function approveAndCall(address _spender, uint256 _value, bytes calldata _extraData)\r\n        external returns (bool success);\r\n    function allowance(address _owner, address _spender) external view returns (uint256 remaining);\r\n    function totalSupply() external view returns (uint);\r\n\r\n    function authenticate(uint _value, uint _challenge, uint _partnerId) external;\r\n}\r\n\r\ninterface SnowflakeResolverInterface {\r\n    function callOnAddition() external view returns (bool);\r\n    function callOnRemoval() external view returns (bool);\r\n    function onAddition(uint ein, uint allowance, bytes calldata extraData) external returns (bool);\r\n    function onRemoval(uint ein, bytes calldata extraData) external returns (bool);\r\n}\r\n\r\ninterface SnowflakeViaInterface {\r\n    function snowflakeCall(address resolver, uint einFrom, uint einTo, uint amount, bytes calldata snowflakeCallBytes)\r\n        external;\r\n    function snowflakeCall(\r\n        address resolver, uint einFrom, address payable to, uint amount, bytes calldata snowflakeCallBytes\r\n    ) external;\r\n    function snowflakeCall(address resolver, uint einTo, uint amount, bytes calldata snowflakeCallBytes) external;\r\n    function snowflakeCall(address resolver, address payable to, uint amount, bytes calldata snowflakeCallBytes)\r\n        external;\r\n}\r\n\r\ninterface IdentityRegistryInterface {\r\n    function isSigned(address _address, bytes32 messageHash, uint8 v, bytes32 r, bytes32 s)\r\n        external pure returns (bool);\r\n\r\n    // Identity View Functions /////////////////////////////////////////////////////////////////////////////////////////\r\n    function identityExists(uint ein) external view returns (bool);\r\n    function hasIdentity(address _address) external view returns (bool);\r\n    function getEIN(address _address) external view returns (uint ein);\r\n    function isAssociatedAddressFor(uint ein, address _address) external view returns (bool);\r\n    function isProviderFor(uint ein, address provider) external view returns (bool);\r\n    function isResolverFor(uint ein, address resolver) external view returns (bool);\r\n    function getIdentity(uint ein) external view returns (\r\n        address recoveryAddress,\r\n        address[] memory associatedAddresses, address[] memory providers, address[] memory resolvers\r\n    );\r\n\r\n    // Identity Management Functions ///////////////////////////////////////////////////////////////////////////////////\r\n    function createIdentity(address recoveryAddress, address[] calldata providers, address[] calldata resolvers)\r\n        external returns (uint ein);\r\n    function createIdentityDelegated(\r\n        address recoveryAddress, address associatedAddress, address[] calldata providers, address[] calldata resolvers,\r\n        uint8 v, bytes32 r, bytes32 s, uint timestamp\r\n    ) external returns (uint ein);\r\n    function addAssociatedAddress(\r\n        address approvingAddress, address addressToAdd, uint8 v, bytes32 r, bytes32 s, uint timestamp\r\n    ) external;\r\n    function addAssociatedAddressDelegated(\r\n        address approvingAddress, address addressToAdd,\r\n        uint8[2] calldata v, bytes32[2] calldata r, bytes32[2] calldata s, uint[2] calldata timestamp\r\n    ) external;\r\n    function removeAssociatedAddress() external;\r\n    function removeAssociatedAddressDelegated(address addressToRemove, uint8 v, bytes32 r, bytes32 s, uint timestamp)\r\n        external;\r\n    function addProviders(address[] calldata providers) external;\r\n    function addProvidersFor(uint ein, address[] calldata providers) external;\r\n    function removeProviders(address[] calldata providers) external;\r\n    function removeProvidersFor(uint ein, address[] calldata providers) external;\r\n    function addResolvers(address[] calldata resolvers) external;\r\n    function addResolversFor(uint ein, address[] calldata resolvers) external;\r\n    function removeResolvers(address[] calldata resolvers) external;\r\n    function removeResolversFor(uint ein, address[] calldata resolvers) external;\r\n\r\n    // Recovery Management Functions ///////////////////////////////////////////////////////////////////////////////////\r\n    function triggerRecoveryAddressChange(address newRecoveryAddress) external;\r\n    function triggerRecoveryAddressChangeFor(uint ein, address newRecoveryAddress) external;\r\n    function triggerRecovery(uint ein, address newAssociatedAddress, uint8 v, bytes32 r, bytes32 s, uint timestamp)\r\n        external;\r\n    function triggerDestruction(\r\n        uint ein, address[] calldata firstChunk, address[] calldata lastChunk, bool resetResolvers\r\n    ) external;\r\n}\r\n\r\ninterface ClientRaindropInterface {\r\n    function hydroStakeUser() external returns (uint);\r\n    function hydroStakeDelegatedUser() external returns (uint);\r\n\r\n    function setSnowflakeAddress(address _snowflakeAddress) external;\r\n    function setStakes(uint _hydroStakeUser, uint _hydroStakeDelegatedUser) external;\r\n\r\n    function signUp(address _address, string calldata casedHydroId) external;\r\n\r\n    function hydroIDAvailable(string calldata uncasedHydroID) external view returns (bool available);\r\n    function hydroIDDestroyed(string calldata uncasedHydroID) external view returns (bool destroyed);\r\n    function hydroIDActive(string calldata uncasedHydroID) external view returns (bool active);\r\n\r\n    function getDetails(string calldata uncasedHydroID) external view\r\n        returns (uint ein, address _address, string memory casedHydroID);\r\n    function getDetails(uint ein) external view returns (address _address, string memory casedHydroID);\r\n    function getDetails(address _address) external view returns (uint ein, string memory casedHydroID);\r\n}\r\n\r\ncontract Snowflake is Ownable {\r\n    using SafeMath for uint;\r\n\r\n    // mapping of EIN to hydro token deposits\r\n    mapping (uint => uint) public deposits;\r\n    // mapping from EIN to resolver to allowance\r\n    mapping (uint => mapping (address => uint)) public resolverAllowances;\r\n\r\n    // SC variables\r\n    address public identityRegistryAddress;\r\n    IdentityRegistryInterface private identityRegistry;\r\n    address public hydroTokenAddress;\r\n    HydroInterface private hydroToken;\r\n    address public clientRaindropAddress;\r\n    ClientRaindropInterface private clientRaindrop;\r\n\r\n    // signature variables\r\n    uint public signatureTimeout = 1 days;\r\n    mapping (uint => uint) public signatureNonce;\r\n\r\n    constructor (address _identityRegistryAddress, address _hydroTokenAddress) public {\r\n        setAddresses(_identityRegistryAddress, _hydroTokenAddress);\r\n    }\r\n\r\n    // enforces that a particular EIN exists\r\n    modifier identityExists(uint ein, bool check) {\r\n        require(identityRegistry.identityExists(ein) == check, \"The EIN does not exist.\");\r\n        _;\r\n    }\r\n\r\n    // enforces signature timeouts\r\n    modifier ensureSignatureTimeValid(uint timestamp) {\r\n        require(\r\n            // solium-disable-next-line security/no-block-members\r\n            block.timestamp >= timestamp && block.timestamp < timestamp + signatureTimeout, \"Timestamp is not valid.\"\r\n        );\r\n        _;\r\n    }\r\n\r\n\r\n    // set the hydro token and identity registry addresses\r\n    function setAddresses(address _identityRegistryAddress, address _hydroTokenAddress) public onlyOwner {\r\n        identityRegistryAddress = _identityRegistryAddress;\r\n        identityRegistry = IdentityRegistryInterface(identityRegistryAddress);\r\n\r\n        hydroTokenAddress = _hydroTokenAddress;\r\n        hydroToken = HydroInterface(hydroTokenAddress);\r\n    }\r\n\r\n    function setClientRaindropAddress(address _clientRaindropAddress) public onlyOwner {\r\n        clientRaindropAddress = _clientRaindropAddress;\r\n        clientRaindrop = ClientRaindropInterface(clientRaindropAddress);\r\n    }\r\n\r\n    // wrap createIdentityDelegated and initialize the client raindrop resolver\r\n    function createIdentityDelegated(\r\n        address recoveryAddress, address associatedAddress, address[] memory providers, string memory casedHydroId,\r\n        uint8 v, bytes32 r, bytes32 s, uint timestamp\r\n    )\r\n        public returns (uint ein)\r\n    {\r\n        address[] memory _providers = new address[](providers.length + 1);\r\n        _providers[0] = address(this);\r\n        for (uint i; i < providers.length; i++) {\r\n            _providers[i + 1] = providers[i];\r\n        }\r\n\r\n        uint _ein = identityRegistry.createIdentityDelegated(\r\n            recoveryAddress, associatedAddress, _providers, new address[](0), v, r, s, timestamp\r\n        );\r\n\r\n        _addResolver(_ein, clientRaindropAddress, true, 0, abi.encode(associatedAddress, casedHydroId));\r\n\r\n        return _ein;\r\n    }\r\n\r\n    // permission addProvidersFor by signature\r\n    function addProvidersFor(\r\n        address approvingAddress, address[] memory providers, uint8 v, bytes32 r, bytes32 s, uint timestamp\r\n    )\r\n        public ensureSignatureTimeValid(timestamp)\r\n    {\r\n        uint ein = identityRegistry.getEIN(approvingAddress);\r\n        require(\r\n            identityRegistry.isSigned(\r\n                approvingAddress,\r\n                keccak256(\r\n                    abi.encodePacked(\r\n                        byte(0x19), byte(0), address(this),\r\n                        \"I authorize that these Providers be added to my Identity.\",\r\n                        ein, providers, timestamp\r\n                    )\r\n                ),\r\n                v, r, s\r\n            ),\r\n            \"Permission denied.\"\r\n        );\r\n\r\n        identityRegistry.addProvidersFor(ein, providers);\r\n    }\r\n\r\n    // permission removeProvidersFor by signature\r\n    function removeProvidersFor(\r\n        address approvingAddress, address[] memory providers, uint8 v, bytes32 r, bytes32 s, uint timestamp\r\n    )\r\n        public ensureSignatureTimeValid(timestamp)\r\n    {\r\n        uint ein = identityRegistry.getEIN(approvingAddress);\r\n        require(\r\n            identityRegistry.isSigned(\r\n                approvingAddress,\r\n                keccak256(\r\n                    abi.encodePacked(\r\n                        byte(0x19), byte(0), address(this),\r\n                        \"I authorize that these Providers be removed from my Identity.\",\r\n                        ein, providers, timestamp\r\n                    )\r\n                ),\r\n                v, r, s\r\n            ),\r\n            \"Permission denied.\"\r\n        );\r\n\r\n        identityRegistry.removeProvidersFor(ein, providers);\r\n    }\r\n\r\n    // permissioned addProvidersFor and removeProvidersFor by signature\r\n    function upgradeProvidersFor(\r\n        address approvingAddress, address[] memory newProviders, address[] memory oldProviders,\r\n        uint8[2] memory v, bytes32[2] memory r, bytes32[2] memory s, uint[2] memory timestamp\r\n    )\r\n        public\r\n    {\r\n        addProvidersFor(approvingAddress, newProviders, v[0], r[0], s[0], timestamp[0]);\r\n        removeProvidersFor(approvingAddress, oldProviders, v[1], r[1], s[1], timestamp[1]);\r\n        uint ein = identityRegistry.getEIN(approvingAddress);\r\n        emit SnowflakeProvidersUpgraded(ein, newProviders, oldProviders, approvingAddress);\r\n    }\r\n\r\n    // permission adding a resolver for identity of msg.sender\r\n    function addResolver(address resolver, bool isSnowflake, uint withdrawAllowance, bytes memory extraData) public {\r\n        _addResolver(identityRegistry.getEIN(msg.sender), resolver, isSnowflake, withdrawAllowance, extraData);\r\n    }\r\n\r\n    // permission adding a resolver for identity passed by a provider\r\n    function addResolverAsProvider(\r\n        uint ein, address resolver, bool isSnowflake, uint withdrawAllowance, bytes memory extraData\r\n    )\r\n        public\r\n    {\r\n        require(identityRegistry.isProviderFor(ein, msg.sender), \"The msg.sender is not a Provider for the passed EIN\");\r\n        _addResolver(ein, resolver, isSnowflake, withdrawAllowance, extraData);\r\n    }\r\n\r\n    // permission addResolversFor by signature\r\n    function addResolverFor(\r\n        address approvingAddress, address resolver, bool isSnowflake, uint withdrawAllowance, bytes memory extraData,\r\n        uint8 v, bytes32 r, bytes32 s, uint timestamp\r\n    )\r\n        public\r\n    {\r\n        uint ein = identityRegistry.getEIN(approvingAddress);\r\n\r\n        validateAddResolverForSignature(\r\n            approvingAddress, ein, resolver, isSnowflake, withdrawAllowance, extraData, v, r, s, timestamp\r\n        );\r\n\r\n        _addResolver(ein, resolver, isSnowflake, withdrawAllowance, extraData);\r\n    }\r\n\r\n    function validateAddResolverForSignature(\r\n        address approvingAddress, uint ein,\r\n        address resolver, bool isSnowflake, uint withdrawAllowance, bytes memory extraData,\r\n        uint8 v, bytes32 r, bytes32 s, uint timestamp\r\n    )\r\n        private view ensureSignatureTimeValid(timestamp)\r\n    {\r\n        require(\r\n            identityRegistry.isSigned(\r\n                approvingAddress,\r\n                keccak256(\r\n                    abi.encodePacked(\r\n                        byte(0x19), byte(0), address(this),\r\n                        \"I authorize that this resolver be added to my Identity.\",\r\n                        ein, resolver, isSnowflake, withdrawAllowance, extraData, timestamp\r\n                    )\r\n                ),\r\n                v, r, s\r\n            ),\r\n            \"Permission denied.\"\r\n        );\r\n    }\r\n\r\n    // common logic for adding resolvers\r\n    function _addResolver(uint ein, address resolver, bool isSnowflake, uint withdrawAllowance, bytes memory extraData)\r\n        private\r\n    {\r\n        require(!identityRegistry.isResolverFor(ein, resolver), \"Identity has already set this resolver.\");\r\n\r\n        address[] memory resolvers = new address[](1);\r\n        resolvers[0] = resolver;\r\n        identityRegistry.addResolversFor(ein, resolvers);\r\n\r\n        if (isSnowflake) {\r\n            resolverAllowances[ein][resolver] = withdrawAllowance;\r\n            SnowflakeResolverInterface snowflakeResolver = SnowflakeResolverInterface(resolver);\r\n            if (snowflakeResolver.callOnAddition())\r\n                require(snowflakeResolver.onAddition(ein, withdrawAllowance, extraData), \"Sign up failure.\");\r\n            emit SnowflakeResolverAdded(ein, resolver, withdrawAllowance);\r\n        }\r\n    }\r\n\r\n    // permission changing resolver allowances for identity of msg.sender\r\n    function changeResolverAllowances(address[] memory resolvers, uint[] memory withdrawAllowances) public {\r\n        changeResolverAllowances(identityRegistry.getEIN(msg.sender), resolvers, withdrawAllowances);\r\n    }\r\n\r\n    // change resolver allowances delegated\r\n    function changeResolverAllowancesDelegated(\r\n        address approvingAddress, address[] memory resolvers, uint[] memory withdrawAllowances,\r\n        uint8 v, bytes32 r, bytes32 s\r\n    )\r\n        public\r\n    {\r\n        uint ein = identityRegistry.getEIN(approvingAddress);\r\n\r\n        uint nonce = signatureNonce[ein]++;\r\n        require(\r\n            identityRegistry.isSigned(\r\n                approvingAddress,\r\n                keccak256(\r\n                    abi.encodePacked(\r\n                        byte(0x19), byte(0), address(this),\r\n                        \"I authorize this change in Resolver allowances.\",\r\n                        ein, resolvers, withdrawAllowances, nonce\r\n                    )\r\n                ),\r\n                v, r, s\r\n            ),\r\n            \"Permission denied.\"\r\n        );\r\n\r\n        changeResolverAllowances(ein, resolvers, withdrawAllowances);\r\n    }\r\n\r\n    // common logic to change resolver allowances\r\n    function changeResolverAllowances(uint ein, address[] memory resolvers, uint[] memory withdrawAllowances) private {\r\n        require(resolvers.length == withdrawAllowances.length, \"Malformed inputs.\");\r\n\r\n        for (uint i; i < resolvers.length; i++) {\r\n            require(identityRegistry.isResolverFor(ein, resolvers[i]), \"Identity has not set this resolver.\");\r\n            resolverAllowances[ein][resolvers[i]] = withdrawAllowances[i];\r\n            emit SnowflakeResolverAllowanceChanged(ein, resolvers[i], withdrawAllowances[i]);\r\n        }\r\n    }\r\n\r\n    // permission removing a resolver for identity of msg.sender\r\n    function removeResolver(address resolver, bool isSnowflake, bytes memory extraData) public {\r\n        removeResolver(identityRegistry.getEIN(msg.sender), resolver, isSnowflake, extraData);\r\n    }\r\n\r\n    // permission removeResolverFor by signature\r\n    function removeResolverFor(\r\n        address approvingAddress, address resolver, bool isSnowflake, bytes memory extraData,\r\n        uint8 v, bytes32 r, bytes32 s, uint timestamp\r\n    )\r\n        public ensureSignatureTimeValid(timestamp)\r\n    {\r\n        uint ein = identityRegistry.getEIN(approvingAddress);\r\n\r\n        validateRemoveResolverForSignature(approvingAddress, ein, resolver, isSnowflake, extraData, v, r, s, timestamp);\r\n\r\n        removeResolver(ein, resolver, isSnowflake, extraData);\r\n    }\r\n\r\n    function validateRemoveResolverForSignature(\r\n        address approvingAddress, uint ein, address resolver, bool isSnowflake, bytes memory extraData,\r\n        uint8 v, bytes32 r, bytes32 s, uint timestamp\r\n    )\r\n        private view\r\n    {\r\n        require(\r\n            identityRegistry.isSigned(\r\n                approvingAddress,\r\n                keccak256(\r\n                    abi.encodePacked(\r\n                        byte(0x19), byte(0), address(this),\r\n                        \"I authorize that these Resolvers be removed from my Identity.\",\r\n                        ein, resolver, isSnowflake, extraData, timestamp\r\n                    )\r\n                ),\r\n                v, r, s\r\n            ),\r\n            \"Permission denied.\"\r\n        );\r\n    }\r\n\r\n    // common logic to remove resolvers\r\n    function removeResolver(uint ein, address resolver, bool isSnowflake, bytes memory extraData) private {\r\n        require(identityRegistry.isResolverFor(ein, resolver), \"Identity has not yet set this resolver.\");\r\n    \r\n        delete resolverAllowances[ein][resolver];\r\n    \r\n        if (isSnowflake) {\r\n            SnowflakeResolverInterface snowflakeResolver = SnowflakeResolverInterface(resolver);\r\n            if (snowflakeResolver.callOnRemoval())\r\n                require(snowflakeResolver.onRemoval(ein, extraData), \"Removal failure.\");\r\n            emit SnowflakeResolverRemoved(ein, resolver);\r\n        }\r\n\r\n        address[] memory resolvers = new address[](1);\r\n        resolvers[0] = resolver;\r\n        identityRegistry.removeResolversFor(ein, resolvers);\r\n    }\r\n\r\n    function triggerRecoveryAddressChangeFor(\r\n        address approvingAddress, address newRecoveryAddress, uint8 v, bytes32 r, bytes32 s\r\n    )\r\n        public\r\n    {\r\n        uint ein = identityRegistry.getEIN(approvingAddress);\r\n        uint nonce = signatureNonce[ein]++;\r\n        require(\r\n            identityRegistry.isSigned(\r\n                approvingAddress,\r\n                keccak256(\r\n                    abi.encodePacked(\r\n                        byte(0x19), byte(0), address(this),\r\n                        \"I authorize this change of Recovery Address.\",\r\n                        ein, newRecoveryAddress, nonce\r\n                    )\r\n                ),\r\n                v, r, s\r\n            ),\r\n            \"Permission denied.\"\r\n        );\r\n\r\n        identityRegistry.triggerRecoveryAddressChangeFor(ein, newRecoveryAddress);\r\n    }\r\n\r\n    // allow contract to receive HYDRO tokens\r\n    function receiveApproval(address sender, uint amount, address _tokenAddress, bytes memory _bytes) public {\r\n        require(msg.sender == _tokenAddress, \"Malformed inputs.\");\r\n        require(_tokenAddress == hydroTokenAddress, \"Sender is not the HYDRO token smart contract.\");\r\n\r\n        // depositing to an EIN\r\n        if (_bytes.length <= 32) {\r\n            require(hydroToken.transferFrom(sender, address(this), amount), \"Unable to transfer token ownership.\");\r\n            uint recipient;\r\n            if (_bytes.length < 32) {\r\n                recipient = identityRegistry.getEIN(sender);\r\n            }\r\n            else {\r\n                recipient = abi.decode(_bytes, (uint));\r\n                require(identityRegistry.identityExists(recipient), \"The recipient EIN does not exist.\");\r\n            }\r\n            deposits[recipient] = deposits[recipient].add(amount);\r\n            emit SnowflakeDeposit(sender, recipient, amount);\r\n        }\r\n        // transferring to a via\r\n        else {\r\n            (\r\n                bool isTransfer, address resolver, address via, uint to, bytes memory snowflakeCallBytes\r\n            ) = abi.decode(_bytes, (bool, address, address, uint, bytes));\r\n            \r\n            require(hydroToken.transferFrom(sender, via, amount), \"Unable to transfer token ownership.\");\r\n\r\n            SnowflakeViaInterface viaContract = SnowflakeViaInterface(via);\r\n            if (isTransfer) {\r\n                viaContract.snowflakeCall(resolver, to, amount, snowflakeCallBytes);\r\n                emit SnowflakeTransferToVia(resolver, via, to, amount);\r\n            } else {\r\n                address payable payableTo = address(to);\r\n                viaContract.snowflakeCall(resolver, payableTo, amount, snowflakeCallBytes);\r\n                emit SnowflakeWithdrawToVia(resolver, via, address(to), amount);\r\n            }\r\n        }\r\n    }\r\n\r\n    // transfer snowflake balance from one snowflake holder to another\r\n    function transferSnowflakeBalance(uint einTo, uint amount) public {\r\n        _transfer(identityRegistry.getEIN(msg.sender), einTo, amount);\r\n    }\r\n\r\n    // withdraw Snowflake balance to an external address\r\n    function withdrawSnowflakeBalance(address to, uint amount) public {\r\n        _withdraw(identityRegistry.getEIN(msg.sender), to, amount);\r\n    }\r\n\r\n    // allows resolvers to transfer allowance amounts to other snowflakes (throws if unsuccessful)\r\n    function transferSnowflakeBalanceFrom(uint einFrom, uint einTo, uint amount) public {\r\n        handleAllowance(einFrom, amount);\r\n        _transfer(einFrom, einTo, amount);\r\n        emit SnowflakeTransferFrom(msg.sender);\r\n    }\r\n\r\n    // allows resolvers to withdraw allowance amounts to external addresses (throws if unsuccessful)\r\n    function withdrawSnowflakeBalanceFrom(uint einFrom, address to, uint amount) public {\r\n        handleAllowance(einFrom, amount);\r\n        _withdraw(einFrom, to, amount);\r\n        emit SnowflakeWithdrawFrom(msg.sender);\r\n    }\r\n\r\n    // allows resolvers to send withdrawal amounts to arbitrary smart contracts 'to' identities (throws if unsuccessful)\r\n    function transferSnowflakeBalanceFromVia(uint einFrom, address via, uint einTo, uint amount, bytes memory _bytes)\r\n        public\r\n    {\r\n        handleAllowance(einFrom, amount);\r\n        _withdraw(einFrom, via, amount);\r\n        SnowflakeViaInterface viaContract = SnowflakeViaInterface(via);\r\n        viaContract.snowflakeCall(msg.sender, einFrom, einTo, amount, _bytes);\r\n        emit SnowflakeTransferFromVia(msg.sender, einTo);\r\n    }\r\n\r\n    // allows resolvers to send withdrawal amounts 'to' addresses via arbitrary smart contracts\r\n    function withdrawSnowflakeBalanceFromVia(\r\n        uint einFrom, address via, address payable to, uint amount, bytes memory _bytes\r\n    )\r\n        public\r\n    {\r\n        handleAllowance(einFrom, amount);\r\n        _withdraw(einFrom, via, amount);\r\n        SnowflakeViaInterface viaContract = SnowflakeViaInterface(via);\r\n        viaContract.snowflakeCall(msg.sender, einFrom, to, amount, _bytes);\r\n        emit SnowflakeWithdrawFromVia(msg.sender, to);\r\n    }\r\n\r\n    function _transfer(uint einFrom, uint einTo, uint amount) private identityExists(einTo, true) returns (bool) {\r\n        require(deposits[einFrom] >= amount, \"Cannot withdraw more than the current deposit balance.\");\r\n        deposits[einFrom] = deposits[einFrom].sub(amount);\r\n        deposits[einTo] = deposits[einTo].add(amount);\r\n\r\n        emit SnowflakeTransfer(einFrom, einTo, amount);\r\n    }\r\n\r\n    function _withdraw(uint einFrom, address to, uint amount) internal {\r\n        require(to != address(this), \"Cannot transfer to the Snowflake smart contract itself.\");\r\n\r\n        require(deposits[einFrom] >= amount, \"Cannot withdraw more than the current deposit balance.\");\r\n        deposits[einFrom] = deposits[einFrom].sub(amount);\r\n        require(hydroToken.transfer(to, amount), \"Transfer was unsuccessful\");\r\n\r\n        emit SnowflakeWithdraw(einFrom, to, amount);\r\n    }\r\n\r\n    function handleAllowance(uint einFrom, uint amount) internal {\r\n        // check that resolver-related details are correct\r\n        require(identityRegistry.isResolverFor(einFrom, msg.sender), \"Resolver has not been set by from tokenholder.\");\r\n\r\n        if (resolverAllowances[einFrom][msg.sender] < amount) {\r\n            emit SnowflakeInsufficientAllowance(einFrom, msg.sender, resolverAllowances[einFrom][msg.sender], amount);\r\n            revert(\"Insufficient Allowance\");\r\n        }\r\n\r\n        resolverAllowances[einFrom][msg.sender] = resolverAllowances[einFrom][msg.sender].sub(amount);\r\n    }\r\n\r\n    // allowAndCall from msg.sender\r\n    function allowAndCall(address destination, uint amount, bytes memory data)\r\n        public returns (bytes memory returnData)\r\n    {\r\n        return allowAndCall(identityRegistry.getEIN(msg.sender), amount, destination, data);\r\n    }\r\n\r\n    // allowAndCall from approvingAddress with meta-transaction\r\n    function allowAndCallDelegated(\r\n        address destination, uint amount, bytes memory data, address approvingAddress, uint8 v, bytes32 r, bytes32 s\r\n    )\r\n        public returns (bytes memory returnData)\r\n    {\r\n        uint ein = identityRegistry.getEIN(approvingAddress);\r\n        uint nonce = signatureNonce[ein]++;\r\n        validateAllowAndCallDelegatedSignature(approvingAddress, ein, destination, amount, data, nonce, v, r, s);\r\n\r\n        return allowAndCall(ein, amount, destination, data);\r\n    }\r\n\r\n    function validateAllowAndCallDelegatedSignature(\r\n        address approvingAddress, uint ein, address destination, uint amount, bytes memory data, uint nonce,\r\n        uint8 v, bytes32 r, bytes32 s\r\n    )\r\n        private view\r\n    {\r\n        require(\r\n            identityRegistry.isSigned(\r\n                approvingAddress,\r\n                keccak256(\r\n                    abi.encodePacked(\r\n                        byte(0x19), byte(0), address(this),\r\n                        \"I authorize this allow and call.\", ein, destination, amount, data, nonce\r\n                    )\r\n                ),\r\n                v, r, s\r\n            ),\r\n            \"Permission denied.\"\r\n        );\r\n    }\r\n\r\n    // internal logic for allowAndCall\r\n    function allowAndCall(uint ein, uint amount, address destination, bytes memory data)\r\n        private returns (bytes memory returnData)\r\n    {\r\n        // check that resolver-related details are correct\r\n        require(identityRegistry.isResolverFor(ein, destination), \"Destination has not been set by from tokenholder.\");\r\n        if (amount != 0) {\r\n            resolverAllowances[ein][destination] = resolverAllowances[ein][destination].add(amount);\r\n        }\r\n\r\n        // solium-disable-next-line security/no-low-level-calls\r\n        (bool success, bytes memory _returnData) = destination.call(data);\r\n        require(success, \"Call was not successful.\");\r\n        return _returnData;\r\n    }\r\n\r\n    // events\r\n    event SnowflakeProvidersUpgraded(uint indexed ein, address[] newProviders, address[] oldProviders, address approvingAddress);\r\n\r\n    event SnowflakeResolverAdded(uint indexed ein, address indexed resolver, uint withdrawAllowance);\r\n    event SnowflakeResolverAllowanceChanged(uint indexed ein, address indexed resolver, uint withdrawAllowance);\r\n    event SnowflakeResolverRemoved(uint indexed ein, address indexed resolver);\r\n\r\n    event SnowflakeDeposit(address indexed from, uint indexed einTo, uint amount);\r\n    event SnowflakeTransfer(uint indexed einFrom, uint indexed einTo, uint amount);\r\n    event SnowflakeWithdraw(uint indexed einFrom, address indexed to, uint amount);\r\n\r\n    event SnowflakeTransferFrom(address indexed resolverFrom);\r\n    event SnowflakeWithdrawFrom(address indexed resolverFrom);\r\n    event SnowflakeTransferFromVia(address indexed resolverFrom, uint indexed einTo);\r\n    event SnowflakeWithdrawFromVia(address indexed resolverFrom, address indexed to);\r\n    event SnowflakeTransferToVia(address indexed resolverFrom, address indexed via, uint indexed einTo, uint amount);\r\n    event SnowflakeWithdrawToVia(address indexed resolverFrom, address indexed via, address indexed to, uint amount);\r\n\r\n    event SnowflakeInsufficientAllowance(\r\n        uint indexed ein, address indexed resolver, uint currentAllowance, uint requestedWithdraw\r\n    );\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"einFrom\",\"type\":\"uint256\"},{\"name\":\"einTo\",\"type\":\"uint256\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferSnowflakeBalanceFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"signatureNonce\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"destination\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"data\",\"type\":\"bytes\"},{\"name\":\"approvingAddress\",\"type\":\"address\"},{\"name\":\"v\",\"type\":\"uint8\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"allowAndCallDelegated\",\"outputs\":[{\"name\":\"returnData\",\"type\":\"bytes\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"clientRaindropAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"approvingAddress\",\"type\":\"address\"},{\"name\":\"newRecoveryAddress\",\"type\":\"address\"},{\"name\":\"v\",\"type\":\"uint8\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"triggerRecoveryAddressChangeFor\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"einTo\",\"type\":\"uint256\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferSnowflakeBalance\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"einFrom\",\"type\":\"uint256\"},{\"name\":\"via\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"_bytes\",\"type\":\"bytes\"}],\"name\":\"withdrawSnowflakeBalanceFromVia\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"approvingAddress\",\"type\":\"address\"},{\"name\":\"providers\",\"type\":\"address[]\"},{\"name\":\"v\",\"type\":\"uint8\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"},{\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"addProvidersFor\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"signatureTimeout\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"recoveryAddress\",\"type\":\"address\"},{\"name\":\"associatedAddress\",\"type\":\"address\"},{\"name\":\"providers\",\"type\":\"address[]\"},{\"name\":\"casedHydroId\",\"type\":\"string\"},{\"name\":\"v\",\"type\":\"uint8\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"},{\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"createIdentityDelegated\",\"outputs\":[{\"name\":\"ein\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"approvingAddress\",\"type\":\"address\"},{\"name\":\"newProviders\",\"type\":\"address[]\"},{\"name\":\"oldProviders\",\"type\":\"address[]\"},{\"name\":\"v\",\"type\":\"uint8[2]\"},{\"name\":\"r\",\"type\":\"bytes32[2]\"},{\"name\":\"s\",\"type\":\"bytes32[2]\"},{\"name\":\"timestamp\",\"type\":\"uint256[2]\"}],\"name\":\"upgradeProvidersFor\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"resolvers\",\"type\":\"address[]\"},{\"name\":\"withdrawAllowances\",\"type\":\"uint256[]\"}],\"name\":\"changeResolverAllowances\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"hydroTokenAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_clientRaindropAddress\",\"type\":\"address\"}],\"name\":\"setClientRaindropAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"approvingAddress\",\"type\":\"address\"},{\"name\":\"resolver\",\"type\":\"address\"},{\"name\":\"isSnowflake\",\"type\":\"bool\"},{\"name\":\"withdrawAllowance\",\"type\":\"uint256\"},{\"name\":\"extraData\",\"type\":\"bytes\"},{\"name\":\"v\",\"type\":\"uint8\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"},{\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"addResolverFor\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"ein\",\"type\":\"uint256\"},{\"name\":\"resolver\",\"type\":\"address\"},{\"name\":\"isSnowflake\",\"type\":\"bool\"},{\"name\":\"withdrawAllowance\",\"type\":\"uint256\"},{\"name\":\"extraData\",\"type\":\"bytes\"}],\"name\":\"addResolverAsProvider\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"sender\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"name\":\"_bytes\",\"type\":\"bytes\"}],\"name\":\"receiveApproval\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_identityRegistryAddress\",\"type\":\"address\"},{\"name\":\"_hydroTokenAddress\",\"type\":\"address\"}],\"name\":\"setAddresses\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"destination\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"allowAndCall\",\"outputs\":[{\"name\":\"returnData\",\"type\":\"bytes\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"einFrom\",\"type\":\"uint256\"},{\"name\":\"via\",\"type\":\"address\"},{\"name\":\"einTo\",\"type\":\"uint256\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"_bytes\",\"type\":\"bytes\"}],\"name\":\"transferSnowflakeBalanceFromVia\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"resolver\",\"type\":\"address\"},{\"name\":\"isSnowflake\",\"type\":\"bool\"},{\"name\":\"extraData\",\"type\":\"bytes\"}],\"name\":\"removeResolver\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"approvingAddress\",\"type\":\"address\"},{\"name\":\"resolvers\",\"type\":\"address[]\"},{\"name\":\"withdrawAllowances\",\"type\":\"uint256[]\"},{\"name\":\"v\",\"type\":\"uint8\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"changeResolverAllowancesDelegated\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"identityRegistryAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"deposits\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawSnowflakeBalance\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"resolver\",\"type\":\"address\"},{\"name\":\"isSnowflake\",\"type\":\"bool\"},{\"name\":\"withdrawAllowance\",\"type\":\"uint256\"},{\"name\":\"extraData\",\"type\":\"bytes\"}],\"name\":\"addResolver\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"einFrom\",\"type\":\"uint256\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawSnowflakeBalanceFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"resolverAllowances\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"approvingAddress\",\"type\":\"address\"},{\"name\":\"resolver\",\"type\":\"address\"},{\"name\":\"isSnowflake\",\"type\":\"bool\"},{\"name\":\"extraData\",\"type\":\"bytes\"},{\"name\":\"v\",\"type\":\"uint8\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"},{\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"removeResolverFor\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"approvingAddress\",\"type\":\"address\"},{\"name\":\"providers\",\"type\":\"address[]\"},{\"name\":\"v\",\"type\":\"uint8\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"},{\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"removeProvidersFor\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_identityRegistryAddress\",\"type\":\"address\"},{\"name\":\"_hydroTokenAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"ein\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"newProviders\",\"type\":\"address[]\"},{\"indexed\":false,\"name\":\"oldProviders\",\"type\":\"address[]\"},{\"indexed\":false,\"name\":\"approvingAddress\",\"type\":\"address\"}],\"name\":\"SnowflakeProvidersUpgraded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"ein\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"resolver\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"withdrawAllowance\",\"type\":\"uint256\"}],\"name\":\"SnowflakeResolverAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"ein\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"resolver\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"withdrawAllowance\",\"type\":\"uint256\"}],\"name\":\"SnowflakeResolverAllowanceChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"ein\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"resolver\",\"type\":\"address\"}],\"name\":\"SnowflakeResolverRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"einTo\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"SnowflakeDeposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"einFrom\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"einTo\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"SnowflakeTransfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"einFrom\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"SnowflakeWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"resolverFrom\",\"type\":\"address\"}],\"name\":\"SnowflakeTransferFrom\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"resolverFrom\",\"type\":\"address\"}],\"name\":\"SnowflakeWithdrawFrom\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"resolverFrom\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"einTo\",\"type\":\"uint256\"}],\"name\":\"SnowflakeTransferFromVia\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"resolverFrom\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"}],\"name\":\"SnowflakeWithdrawFromVia\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"resolverFrom\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"via\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"einTo\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"SnowflakeTransferToVia\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"resolverFrom\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"via\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"SnowflakeWithdrawToVia\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"ein\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"resolver\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"currentAllowance\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"requestedWithdraw\",\"type\":\"uint256\"}],\"name\":\"SnowflakeInsufficientAllowance\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"Snowflake","CompilerVersion":"v0.5.0+commit.1d4f565a","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000e65fb5c8aeb0305d3a1db0be2297f3e00b26e8c5000000000000000000000000ebbdf302c940c6bfd49c6b165f457fdb324649bc","Library":"","SwarmSource":"bzzr://ff45b01e6db118ce141f53184d2c858e2e2e6a095db9243b368fc821e70d6423"}]}