{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.5.6;\r\n\r\n/**\r\n * @dev Standard interface for a dex proxy contract.\r\n */\r\ninterface Proxy {\r\n\r\n  /**\r\n   * @dev Executes an action.\r\n   * @param _target Target of execution.\r\n   * @param _a Address usually representing from.\r\n   * @param _b Address usually representing to.\r\n   * @param _c Integer usually repersenting amount/value/id.\r\n   */\r\n  function execute(\r\n    address _target,\r\n    address _a,\r\n    address _b,\r\n    uint256 _c\r\n  )\r\n    external;\r\n    \r\n}\r\n\r\n/**\r\n * @dev Xcert interface.\r\n */\r\ninterface Xcert // is ERC721 metadata enumerable\r\n{\r\n\r\n  /**\r\n   * @dev Creates a new Xcert.\r\n   * @param _to The address that will own the created Xcert.\r\n   * @param _id The Xcert to be created by the msg.sender.\r\n   * @param _imprint Cryptographic asset imprint.\r\n   */\r\n  function create(\r\n    address _to,\r\n    uint256 _id,\r\n    bytes32 _imprint\r\n  )\r\n    external;\r\n\r\n  /**\r\n   * @dev Change URI base.\r\n   * @param _uriBase New uriBase.\r\n   */\r\n  function setUriBase(\r\n    string calldata _uriBase\r\n  )\r\n    external;\r\n\r\n  /**\r\n   * @dev Returns a bytes4 of keccak256 of json schema representing 0xcert Protocol convention.\r\n   * @return Schema id.\r\n   */\r\n  function schemaId()\r\n    external\r\n    view\r\n    returns (bytes32 _schemaId);\r\n\r\n  /**\r\n   * @dev Returns imprint for Xcert.\r\n   * @param _tokenId Id of the Xcert.\r\n   * @return Token imprint.\r\n   */\r\n  function tokenImprint(\r\n    uint256 _tokenId\r\n  )\r\n    external\r\n    view\r\n    returns(bytes32 imprint);\r\n\r\n}\r\n\r\n/**\r\n * @dev Math operations with safety checks that throw on error. This contract is based on the \r\n * source code at: \r\n * https://github.com/OpenZeppelin/openzeppelin-solidity/blob/master/contracts/math/SafeMath.sol.\r\n */\r\nlibrary SafeMath\r\n{\r\n\r\n  /**\r\n   * @dev Error constants.\r\n   */\r\n  string constant OVERFLOW = \"008001\";\r\n  string constant SUBTRAHEND_GREATER_THEN_MINUEND = \"008002\";\r\n  string constant DIVISION_BY_ZERO = \"008003\";\r\n\r\n  /**\r\n   * @dev Multiplies two numbers, reverts on overflow.\r\n   * @param _factor1 Factor number.\r\n   * @param _factor2 Factor number.\r\n   * @return The product of the two factors.\r\n   */\r\n  function mul(\r\n    uint256 _factor1,\r\n    uint256 _factor2\r\n  )\r\n    internal\r\n    pure\r\n    returns (uint256 product)\r\n  {\r\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (_factor1 == 0)\r\n    {\r\n      return 0;\r\n    }\r\n\r\n    product = _factor1 * _factor2;\r\n    require(product / _factor1 == _factor2, OVERFLOW);\r\n  }\r\n\r\n  /**\r\n   * @dev Integer division of two numbers, truncating the quotient, reverts on division by zero.\r\n   * @param _dividend Dividend number.\r\n   * @param _divisor Divisor number.\r\n   * @return The quotient.\r\n   */\r\n  function div(\r\n    uint256 _dividend,\r\n    uint256 _divisor\r\n  )\r\n    internal\r\n    pure\r\n    returns (uint256 quotient)\r\n  {\r\n    // Solidity automatically asserts when dividing by 0, using all gas.\r\n    require(_divisor > 0, DIVISION_BY_ZERO);\r\n    quotient = _dividend / _divisor;\r\n    // assert(_dividend == _divisor * quotient + _dividend % _divisor); // There is no case in which this doesn't hold.\r\n  }\r\n\r\n  /**\r\n   * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n   * @param _minuend Minuend number.\r\n   * @param _subtrahend Subtrahend number.\r\n   * @return Difference.\r\n   */\r\n  function sub(\r\n    uint256 _minuend,\r\n    uint256 _subtrahend\r\n  )\r\n    internal\r\n    pure\r\n    returns (uint256 difference)\r\n  {\r\n    require(_subtrahend <= _minuend, SUBTRAHEND_GREATER_THEN_MINUEND);\r\n    difference = _minuend - _subtrahend;\r\n  }\r\n\r\n  /**\r\n   * @dev Adds two numbers, reverts on overflow.\r\n   * @param _addend1 Number.\r\n   * @param _addend2 Number.\r\n   * @return Sum.\r\n   */\r\n  function add(\r\n    uint256 _addend1,\r\n    uint256 _addend2\r\n  )\r\n    internal\r\n    pure\r\n    returns (uint256 sum)\r\n  {\r\n    sum = _addend1 + _addend2;\r\n    require(sum >= _addend1, OVERFLOW);\r\n  }\r\n\r\n  /**\r\n    * @dev Divides two numbers and returns the remainder (unsigned integer modulo), reverts when\r\n    * dividing by zero.\r\n    * @param _dividend Number.\r\n    * @param _divisor Number.\r\n    * @return Remainder.\r\n    */\r\n  function mod(\r\n    uint256 _dividend,\r\n    uint256 _divisor\r\n  )\r\n    internal\r\n    pure\r\n    returns (uint256 remainder) \r\n  {\r\n    require(_divisor != 0, DIVISION_BY_ZERO);\r\n    remainder = _dividend % _divisor;\r\n  }\r\n\r\n}\r\n\r\n/**\r\n * @title Contract for setting abilities.\r\n * @dev For optimization purposes the abilities are represented as a bitfield. Maximum number of\r\n * abilities is therefore 256. This is an example(for simplicity is made for max 8 abilities) of how\r\n * this works. \r\n * 00000001 Ability A - number representation 1\r\n * 00000010 Ability B - number representation 2\r\n * 00000100 Ability C - number representation 4\r\n * 00001000 Ability D - number representation 8\r\n * 00010000 Ability E - number representation 16\r\n * etc ... \r\n * To grant abilities B and C, we would need a bitfield of 00000110 which is represented by number\r\n * 6, in other words, the sum of abilities B and C. The same concept works for revoking abilities\r\n * and checking if someone has multiple abilities.\r\n */\r\ncontract Abilitable\r\n{\r\n  using SafeMath for uint;\r\n\r\n  /**\r\n   * @dev Error constants.\r\n   */\r\n  string constant NOT_AUTHORIZED = \"017001\";\r\n  string constant CANNOT_REVOKE_OWN_SUPER_ABILITY = \"017002\";\r\n  string constant INVALID_INPUT = \"017003\";\r\n\r\n  /**\r\n   * @dev Ability 1 (00000001) is a reserved ability called super ability. It is an\r\n   * ability to grant or revoke abilities of other accounts. Other abilities are determined by the\r\n   * implementing contract.\r\n   */\r\n  uint8 constant SUPER_ABILITY = 1;\r\n\r\n  /**\r\n   * @dev Maps address to ability ids.\r\n   */\r\n  mapping(address => uint256) public addressToAbility;\r\n\r\n  /**\r\n   * @dev Emits when an address is granted an ability.\r\n   * @param _target Address to which we are granting abilities.\r\n   * @param _abilities Number representing bitfield of abilities we are granting.\r\n   */\r\n  event GrantAbilities(\r\n    address indexed _target,\r\n    uint256 indexed _abilities\r\n  );\r\n\r\n  /**\r\n   * @dev Emits when an address gets an ability revoked.\r\n   * @param _target Address of which we are revoking an ability.\r\n   * @param _abilities Number representing bitfield of abilities we are revoking.\r\n   */\r\n  event RevokeAbilities(\r\n    address indexed _target,\r\n    uint256 indexed _abilities\r\n  );\r\n\r\n  /**\r\n   * @dev Guarantees that msg.sender has certain abilities.\r\n   */\r\n  modifier hasAbilities(\r\n    uint256 _abilities\r\n  ) \r\n  {\r\n    require(_abilities > 0, INVALID_INPUT);\r\n    require(\r\n      addressToAbility[msg.sender] & _abilities == _abilities,\r\n      NOT_AUTHORIZED\r\n    );\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Contract constructor.\r\n   * Sets SUPER_ABILITY ability to the sender account.\r\n   */\r\n  constructor()\r\n    public\r\n  {\r\n    addressToAbility[msg.sender] = SUPER_ABILITY;\r\n    emit GrantAbilities(msg.sender, SUPER_ABILITY);\r\n  }\r\n\r\n  /**\r\n   * @dev Grants specific abilities to specified address.\r\n   * @param _target Address to grant abilities to.\r\n   * @param _abilities Number representing bitfield of abilities we are granting.\r\n   */\r\n  function grantAbilities(\r\n    address _target,\r\n    uint256 _abilities\r\n  )\r\n    external\r\n    hasAbilities(SUPER_ABILITY)\r\n  {\r\n    addressToAbility[_target] |= _abilities;\r\n    emit GrantAbilities(_target, _abilities);\r\n  }\r\n\r\n  /**\r\n   * @dev Unassigns specific abilities from specified address.\r\n   * @param _target Address of which we revoke abilites.\r\n   * @param _abilities Number representing bitfield of abilities we are revoking.\r\n   * @param _allowSuperRevoke Additional check that prevents you from removing your own super\r\n   * ability by mistake.\r\n   */\r\n  function revokeAbilities(\r\n    address _target,\r\n    uint256 _abilities,\r\n    bool _allowSuperRevoke\r\n  )\r\n    external\r\n    hasAbilities(SUPER_ABILITY)\r\n  {\r\n    if (!_allowSuperRevoke && msg.sender == _target)\r\n    {\r\n      require((_abilities & 1) == 0, CANNOT_REVOKE_OWN_SUPER_ABILITY);\r\n    }\r\n    addressToAbility[_target] &= ~_abilities;\r\n    emit RevokeAbilities(_target, _abilities);\r\n  }\r\n\r\n  /**\r\n   * @dev Check if an address has a specific ability. Throws if checking for 0.\r\n   * @param _target Address for which we want to check if it has a specific abilities.\r\n   * @param _abilities Number representing bitfield of abilities we are checking.\r\n   */\r\n  function isAble(\r\n    address _target,\r\n    uint256 _abilities\r\n  )\r\n    external\r\n    view\r\n    returns (bool)\r\n  {\r\n    require(_abilities > 0, INVALID_INPUT);\r\n    return (addressToAbility[_target] & _abilities) == _abilities;\r\n  }\r\n  \r\n}\r\n\r\n/**\r\n * @title XcertCreateProxy - creates a token on behalf of contracts that have been approved via\r\n * decentralized governance.\r\n */\r\ncontract XcertCreateProxy is \r\n  Abilitable \r\n{\r\n\r\n  /**\r\n   * @dev List of abilities:\r\n   * 2 - Ability to execute create. \r\n   */\r\n  uint8 constant ABILITY_TO_EXECUTE = 2;\r\n\r\n  /**\r\n   * @dev Creates a new Xcert.\r\n   * @param _xcert Address of the Xcert contract on which the creation will be perfomed.\r\n   * @param _to The address that will own the created Xcert.\r\n   * @param _id The Xcert to be created by the msg.sender.\r\n   * @param _imprint Cryptographic asset imprint.\r\n   */\r\n  function create(\r\n    address _xcert,\r\n    address _to,\r\n    uint256 _id,\r\n    bytes32 _imprint\r\n  )\r\n    external\r\n    hasAbilities(ABILITY_TO_EXECUTE)\r\n  {\r\n    Xcert(_xcert).create(_to, _id, _imprint);\r\n  }\r\n\r\n}\r\n\r\n/**\r\n * @dev Xcert nutable interface.\r\n */\r\ninterface XcertMutable // is Xcert\r\n{\r\n  \r\n  /**\r\n   * @dev Updates Xcert imprint.\r\n   * @param _tokenId Id of the Xcert.\r\n   * @param _imprint New imprint.\r\n   */\r\n  function updateTokenImprint(\r\n    uint256 _tokenId,\r\n    bytes32 _imprint\r\n  )\r\n    external;\r\n\r\n}\r\n\r\n/**\r\n * @title XcertUpdateProxy - updates a token on behalf of contracts that have been approved via\r\n * decentralized governance.\r\n * @notice There is a possibility of unintentional behavior when token imprint can be overwritten\r\n * if more than one claim is active. Be aware of this when implementing.\r\n */\r\ncontract XcertUpdateProxy is\r\n  Abilitable\r\n{\r\n\r\n  /**\r\n   * @dev List of abilities:\r\n   * 2 - Ability to execute create.\r\n   */\r\n  uint8 constant ABILITY_TO_EXECUTE = 2;\r\n\r\n  /**\r\n   * @dev Updates imprint of an existing Xcert.\r\n   * @param _xcert Address of the Xcert contract on which the update will be perfomed.\r\n   * @param _id The Xcert we will update.\r\n   * @param _imprint Cryptographic asset imprint.\r\n   */\r\n  function update(\r\n    address _xcert,\r\n    uint256 _id,\r\n    bytes32 _imprint\r\n  )\r\n    external\r\n    hasAbilities(ABILITY_TO_EXECUTE)\r\n  {\r\n    XcertMutable(_xcert).updateTokenImprint(_id, _imprint);\r\n  }\r\n\r\n}\r\n\r\npragma experimental ABIEncoderV2;\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @dev Decentralize exchange, creating, updating and other actions for fundgible and non-fundgible\r\n * tokens powered by atomic swaps.\r\n */\r\ncontract OrderGateway is\r\n  Abilitable\r\n{\r\n\r\n  /**\r\n   * @dev List of abilities:\r\n   * 2 - Ability to set proxies.\r\n   */\r\n  uint8 constant ABILITY_TO_SET_PROXIES = 2;\r\n\r\n  /**\r\n   * @dev Xcert abilities.\r\n   */\r\n  uint8 constant ABILITY_ALLOW_CREATE_ASSET = 32;\r\n  uint16 constant ABILITY_ALLOW_UPDATE_ASSET = 128;\r\n\r\n  /**\r\n   * @dev Error constants.\r\n   */\r\n  string constant INVALID_SIGNATURE_KIND = \"015001\";\r\n  string constant INVALID_PROXY = \"015002\";\r\n  string constant TAKER_NOT_EQUAL_TO_SENDER = \"015003\";\r\n  string constant SENDER_NOT_TAKER_OR_MAKER = \"015004\";\r\n  string constant CLAIM_EXPIRED = \"015005\";\r\n  string constant INVALID_SIGNATURE = \"015006\";\r\n  string constant ORDER_CANCELED = \"015007\";\r\n  string constant ORDER_ALREADY_PERFORMED = \"015008\";\r\n  string constant MAKER_NOT_EQUAL_TO_SENDER = \"015009\";\r\n  string constant SIGNER_NOT_AUTHORIZED = \"015010\";\r\n\r\n  /**\r\n   * @dev Enum of available signature kinds.\r\n   * @param eth_sign Signature using eth sign.\r\n   * @param trezor Signature from Trezor hardware wallet.\r\n   * It differs from web3.eth_sign in the encoding of message length\r\n   * (Bitcoin varint encoding vs ascii-decimal, the latter is not\r\n   * self-terminating which leads to ambiguities).\r\n   * See also:\r\n   * https://en.bitcoin.it/wiki/Protocol_documentation#Variable_length_integer\r\n   * https://github.com/trezor/trezor-mcu/blob/master/firmware/ethereum.c#L602\r\n   * https://github.com/trezor/trezor-mcu/blob/master/firmware/crypto.c#L36a\r\n   * @param eip721 Signature using eip721.\r\n   */\r\n  enum SignatureKind\r\n  {\r\n    eth_sign,\r\n    trezor,\r\n    eip712\r\n  }\r\n\r\n  /**\r\n   * Enum of available action kinds.\r\n   */\r\n  enum ActionKind\r\n  {\r\n    create,\r\n    transfer,\r\n    update\r\n  }\r\n\r\n  /**\r\n   * @dev Structure representing what to send and where.\r\n   * @notice For update action kind to parameter is unnecessary. For this reason we recommend you\r\n   * set it to zero address (0x000...0) since it costs less.\r\n   * @param kind Enum representing action kind.\r\n   * @param proxy Id representing approved proxy address.\r\n   * @param token Address of the token we are sending.\r\n   * @param param1 Address of the sender or imprint.\r\n   * @param to Address of the receiver.\r\n   * @param value Amount of ERC20 or ID of ERC721.\r\n   */\r\n  struct ActionData\r\n  {\r\n    ActionKind kind;\r\n    uint32 proxy;\r\n    address token;\r\n    bytes32 param1;\r\n    address to;\r\n    uint256 value;\r\n  }\r\n\r\n  /**\r\n   * @dev Structure representing the signature parts.\r\n   * @param r ECDSA signature parameter r.\r\n   * @param s ECDSA signature parameter s.\r\n   * @param v ECDSA signature parameter v.\r\n   * @param kind Type of signature.\r\n   */\r\n  struct SignatureData\r\n  {\r\n    bytes32 r;\r\n    bytes32 s;\r\n    uint8 v;\r\n    SignatureKind kind;\r\n  }\r\n\r\n  /**\r\n   * @dev Structure representing the data needed to do the order.\r\n   * @param maker Address of the one that made the claim.\r\n   * @param taker Address of the one that is executing the claim.\r\n   * @param actions Data of all the actions that should accure it this order.\r\n   * @param signature Data from the signed claim.\r\n   * @param seed Arbitrary number to facilitate uniqueness of the order's hash. Usually timestamp.\r\n   * @param expiration Timestamp of when the claim expires. 0 if indefinet.\r\n   */\r\n  struct OrderData\r\n  {\r\n    address maker;\r\n    address taker;\r\n    ActionData[] actions;\r\n    uint256 seed;\r\n    uint256 expiration;\r\n  }\r\n\r\n  /**\r\n   * @dev Valid proxy contract addresses.\r\n   */\r\n  address[] public proxies;\r\n\r\n  /**\r\n   * @dev Mapping of all cancelled orders.\r\n   */\r\n  mapping(bytes32 => bool) public orderCancelled;\r\n\r\n  /**\r\n   * @dev Mapping of all performed orders.\r\n   */\r\n  mapping(bytes32 => bool) public orderPerformed;\r\n\r\n  /**\r\n   * @dev This event emmits when tokens change ownership.\r\n   */\r\n  event Perform(\r\n    address indexed _maker,\r\n    address indexed _taker,\r\n    bytes32 _claim\r\n  );\r\n\r\n  /**\r\n   * @dev This event emmits when transfer order is cancelled.\r\n   */\r\n  event Cancel(\r\n    address indexed _maker,\r\n    address indexed _taker,\r\n    bytes32 _claim\r\n  );\r\n\r\n  /**\r\n   * @dev This event emmits when proxy address is changed..\r\n   */\r\n  event ProxyChange(\r\n    uint256 indexed _index,\r\n    address _proxy\r\n  );\r\n\r\n  /**\r\n   * @dev Adds a verified proxy address.\r\n   * @notice Can be done through a multisig wallet in the future.\r\n   * @param _proxy Proxy address.\r\n   */\r\n  function addProxy(\r\n    address _proxy\r\n  )\r\n    external\r\n    hasAbilities(ABILITY_TO_SET_PROXIES)\r\n  {\r\n    uint256 length = proxies.push(_proxy);\r\n    emit ProxyChange(length - 1, _proxy);\r\n  }\r\n\r\n  /**\r\n   * @dev Removes a proxy address.\r\n   * @notice Can be done through a multisig wallet in the future.\r\n   * @param _index Index of proxy we are removing.\r\n   */\r\n  function removeProxy(\r\n    uint256 _index\r\n  )\r\n    external\r\n    hasAbilities(ABILITY_TO_SET_PROXIES)\r\n  {\r\n    proxies[_index] = address(0);\r\n    emit ProxyChange(_index, address(0));\r\n  }\r\n\r\n  /**\r\n   * @dev Performs the atomic swap that can exchange, create, update and do other actions for\r\n   * fungible and non-fungible tokens.\r\n   * @param _data Data required to make the order.\r\n   * @param _signature Data from the signature.\r\n   */\r\n  function perform(\r\n    OrderData memory _data,\r\n    SignatureData memory _signature\r\n  )\r\n    public\r\n  {\r\n    require(_data.taker == msg.sender, TAKER_NOT_EQUAL_TO_SENDER);\r\n    require(_data.expiration >= now, CLAIM_EXPIRED);\r\n\r\n    bytes32 claim = getOrderDataClaim(_data);\r\n    require(\r\n      isValidSignature(\r\n        _data.maker,\r\n        claim,\r\n        _signature\r\n      ),\r\n      INVALID_SIGNATURE\r\n    );\r\n\r\n    require(!orderCancelled[claim], ORDER_CANCELED);\r\n    require(!orderPerformed[claim], ORDER_ALREADY_PERFORMED);\r\n\r\n    orderPerformed[claim] = true;\r\n\r\n    _doActions(_data);\r\n\r\n    emit Perform(\r\n      _data.maker,\r\n      _data.taker,\r\n      claim\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @dev Performs the atomic swap that can exchange, create, update and do other actions for\r\n   * fungible and non-fungible tokens where performing address does not need to be known before\r\n   * hand.\r\n   * @notice When using this function, be aware that the zero address is reserved for replacement\r\n   * with msg.sender, meaning you cannot send anything to the zero address.\r\n   * @param _data Data required to make the order.\r\n   * @param _signature Data from the signature.\r\n   */\r\n  function performAnyTaker(\r\n    OrderData memory _data,\r\n    SignatureData memory _signature\r\n  )\r\n    public\r\n  {\r\n    require(_data.expiration >= now, CLAIM_EXPIRED);\r\n\r\n    bytes32 claim = getOrderDataClaim(_data);\r\n    require(\r\n      isValidSignature(\r\n        _data.maker,\r\n        claim,\r\n        _signature\r\n      ),\r\n      INVALID_SIGNATURE\r\n    );\r\n\r\n    require(!orderCancelled[claim], ORDER_CANCELED);\r\n    require(!orderPerformed[claim], ORDER_ALREADY_PERFORMED);\r\n\r\n    orderPerformed[claim] = true;\r\n\r\n    _data.taker = msg.sender;\r\n    _doActionsReplaceZeroAddress(_data);\r\n\r\n    emit Perform(\r\n      _data.maker,\r\n      _data.taker,\r\n      claim\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @dev Cancels order.\r\n   * @notice You can cancel the same order multiple times. There is no check for whether the order\r\n   * was already canceled due to gas optimization. You should either check orderCancelled variable\r\n   * or listen to Cancel event if you want to check if an order is already canceled.\r\n   * @param _data Data of order to cancel.\r\n   */\r\n  function cancel(\r\n    OrderData memory _data\r\n  )\r\n    public\r\n  {\r\n    require(_data.maker == msg.sender, MAKER_NOT_EQUAL_TO_SENDER);\r\n\r\n    bytes32 claim = getOrderDataClaim(_data);\r\n    require(!orderPerformed[claim], ORDER_ALREADY_PERFORMED);\r\n\r\n    orderCancelled[claim] = true;\r\n    emit Cancel(\r\n      _data.maker,\r\n      _data.taker,\r\n      claim\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @dev Calculates keccak-256 hash of OrderData from parameters.\r\n   * @param _orderData Data needed for atomic swap.\r\n   * @return keccak-hash of order data.\r\n   */\r\n  function getOrderDataClaim(\r\n    OrderData memory _orderData\r\n  )\r\n    public\r\n    view\r\n    returns (bytes32)\r\n  {\r\n    bytes32 temp = 0x0;\r\n\r\n    for(uint256 i = 0; i < _orderData.actions.length; i++)\r\n    {\r\n      temp = keccak256(\r\n        abi.encodePacked(\r\n          temp,\r\n          _orderData.actions[i].kind,\r\n          _orderData.actions[i].proxy,\r\n          _orderData.actions[i].token,\r\n          _orderData.actions[i].param1,\r\n          _orderData.actions[i].to,\r\n          _orderData.actions[i].value\r\n        )\r\n      );\r\n    }\r\n\r\n    return keccak256(\r\n      abi.encodePacked(\r\n        address(this),\r\n        _orderData.maker,\r\n        _orderData.taker,\r\n        temp,\r\n        _orderData.seed,\r\n        _orderData.expiration\r\n      )\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @dev Verifies if claim signature is valid.\r\n   * @param _signer address of signer.\r\n   * @param _claim Signed Keccak-256 hash.\r\n   * @param _signature Signature data.\r\n   */\r\n  function isValidSignature(\r\n    address _signer,\r\n    bytes32 _claim,\r\n    SignatureData memory _signature\r\n  )\r\n    public\r\n    pure\r\n    returns (bool)\r\n  {\r\n    if (_signature.kind == SignatureKind.eth_sign)\r\n    {\r\n      return _signer == ecrecover(\r\n        keccak256(\r\n          abi.encodePacked(\r\n            \"\\x19Ethereum Signed Message:\\n32\",\r\n            _claim\r\n          )\r\n        ),\r\n        _signature.v,\r\n        _signature.r,\r\n        _signature.s\r\n      );\r\n    } else if (_signature.kind == SignatureKind.trezor)\r\n    {\r\n      return _signer == ecrecover(\r\n        keccak256(\r\n          abi.encodePacked(\r\n            \"\\x19Ethereum Signed Message:\\n\\x20\",\r\n            _claim\r\n          )\r\n        ),\r\n        _signature.v,\r\n        _signature.r,\r\n        _signature.s\r\n      );\r\n    } else if (_signature.kind == SignatureKind.eip712)\r\n    {\r\n      return _signer == ecrecover(\r\n        _claim,\r\n        _signature.v,\r\n        _signature.r,\r\n        _signature.s\r\n      );\r\n    }\r\n\r\n    revert(INVALID_SIGNATURE_KIND);\r\n  }\r\n\r\n  /**\r\n   * @dev Helper function that makes order actions and replaces zero addresses with msg.sender.\r\n   * @param _order Data needed for order.\r\n   */\r\n  function _doActionsReplaceZeroAddress(\r\n    OrderData memory _order\r\n  )\r\n    private\r\n  {\r\n    for(uint256 i = 0; i < _order.actions.length; i++)\r\n    {\r\n      require(\r\n        proxies[_order.actions[i].proxy] != address(0),\r\n        INVALID_PROXY\r\n      );\r\n\r\n      if (_order.actions[i].kind == ActionKind.create)\r\n      {\r\n        require(\r\n          Abilitable(_order.actions[i].token).isAble(_order.maker, ABILITY_ALLOW_CREATE_ASSET),\r\n          SIGNER_NOT_AUTHORIZED\r\n        );\r\n\r\n        if (_order.actions[i].to == address(0))\r\n        {\r\n          _order.actions[i].to = _order.taker;\r\n        }\r\n\r\n        XcertCreateProxy(proxies[_order.actions[i].proxy]).create(\r\n          _order.actions[i].token,\r\n          _order.actions[i].to,\r\n          _order.actions[i].value,\r\n          _order.actions[i].param1\r\n        );\r\n      }\r\n      else if (_order.actions[i].kind == ActionKind.transfer)\r\n      {\r\n        address from = address(uint160(bytes20(_order.actions[i].param1)));\r\n\r\n        if (_order.actions[i].to == address(0))\r\n        {\r\n          _order.actions[i].to = _order.taker;\r\n        }\r\n\r\n        if (from == address(0))\r\n        {\r\n          from = _order.taker;\r\n        }\r\n\r\n        require(\r\n          from == _order.maker\r\n          || from == _order.taker,\r\n          SENDER_NOT_TAKER_OR_MAKER\r\n        );\r\n\r\n        Proxy(proxies[_order.actions[i].proxy]).execute(\r\n          _order.actions[i].token,\r\n          from,\r\n          _order.actions[i].to,\r\n          _order.actions[i].value\r\n        );\r\n      }\r\n      else if (_order.actions[i].kind == ActionKind.update)\r\n      {\r\n        require(\r\n          Abilitable(_order.actions[i].token).isAble(_order.maker, ABILITY_ALLOW_UPDATE_ASSET),\r\n          SIGNER_NOT_AUTHORIZED\r\n        );\r\n\r\n        XcertUpdateProxy(proxies[_order.actions[i].proxy]).update(\r\n          _order.actions[i].token,\r\n          _order.actions[i].value,\r\n          _order.actions[i].param1\r\n        );\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Helper function that makes order actions.\r\n   * @param _order Data needed for order.\r\n   */\r\n  function _doActions(\r\n    OrderData memory _order\r\n  )\r\n    private\r\n  {\r\n    for(uint256 i = 0; i < _order.actions.length; i++)\r\n    {\r\n      require(\r\n        proxies[_order.actions[i].proxy] != address(0),\r\n        INVALID_PROXY\r\n      );\r\n\r\n      if (_order.actions[i].kind == ActionKind.create)\r\n      {\r\n        require(\r\n          Abilitable(_order.actions[i].token).isAble(_order.maker, ABILITY_ALLOW_CREATE_ASSET),\r\n          SIGNER_NOT_AUTHORIZED\r\n        );\r\n\r\n        XcertCreateProxy(proxies[_order.actions[i].proxy]).create(\r\n          _order.actions[i].token,\r\n          _order.actions[i].to,\r\n          _order.actions[i].value,\r\n          _order.actions[i].param1\r\n        );\r\n      }\r\n      else if (_order.actions[i].kind == ActionKind.transfer)\r\n      {\r\n        address from = address(uint160(bytes20(_order.actions[i].param1)));\r\n        require(\r\n          from == _order.maker\r\n          || from == _order.taker,\r\n          SENDER_NOT_TAKER_OR_MAKER\r\n        );\r\n\r\n        Proxy(proxies[_order.actions[i].proxy]).execute(\r\n          _order.actions[i].token,\r\n          from,\r\n          _order.actions[i].to,\r\n          _order.actions[i].value\r\n        );\r\n      }\r\n      else if (_order.actions[i].kind == ActionKind.update)\r\n      {\r\n        require(\r\n          Abilitable(_order.actions[i].token).isAble(_order.maker, ABILITY_ALLOW_UPDATE_ASSET),\r\n          SIGNER_NOT_AUTHORIZED\r\n        );\r\n\r\n        XcertUpdateProxy(proxies[_order.actions[i].proxy]).update(\r\n          _order.actions[i].token,\r\n          _order.actions[i].value,\r\n          _order.actions[i].param1\r\n        );\r\n      }\r\n    }\r\n  }\r\n\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"components\":[{\"name\":\"maker\",\"type\":\"address\"},{\"name\":\"taker\",\"type\":\"address\"},{\"components\":[{\"name\":\"kind\",\"type\":\"uint8\"},{\"name\":\"proxy\",\"type\":\"uint32\"},{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"param1\",\"type\":\"bytes32\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"actions\",\"type\":\"tuple[]\"},{\"name\":\"seed\",\"type\":\"uint256\"},{\"name\":\"expiration\",\"type\":\"uint256\"}],\"name\":\"_data\",\"type\":\"tuple\"},{\"components\":[{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"},{\"name\":\"v\",\"type\":\"uint8\"},{\"name\":\"kind\",\"type\":\"uint8\"}],\"name\":\"_signature\",\"type\":\"tuple\"}],\"name\":\"performAnyTaker\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_target\",\"type\":\"address\"},{\"name\":\"_abilities\",\"type\":\"uint256\"}],\"name\":\"grantAbilities\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_proxy\",\"type\":\"address\"}],\"name\":\"addProxy\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"components\":[{\"name\":\"maker\",\"type\":\"address\"},{\"name\":\"taker\",\"type\":\"address\"},{\"components\":[{\"name\":\"kind\",\"type\":\"uint8\"},{\"name\":\"proxy\",\"type\":\"uint32\"},{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"param1\",\"type\":\"bytes32\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"actions\",\"type\":\"tuple[]\"},{\"name\":\"seed\",\"type\":\"uint256\"},{\"name\":\"expiration\",\"type\":\"uint256\"}],\"name\":\"_data\",\"type\":\"tuple\"}],\"name\":\"cancel\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"removeProxy\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"addressToAbility\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"orderCancelled\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"components\":[{\"name\":\"maker\",\"type\":\"address\"},{\"name\":\"taker\",\"type\":\"address\"},{\"components\":[{\"name\":\"kind\",\"type\":\"uint8\"},{\"name\":\"proxy\",\"type\":\"uint32\"},{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"param1\",\"type\":\"bytes32\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"actions\",\"type\":\"tuple[]\"},{\"name\":\"seed\",\"type\":\"uint256\"},{\"name\":\"expiration\",\"type\":\"uint256\"}],\"name\":\"_data\",\"type\":\"tuple\"},{\"components\":[{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"},{\"name\":\"v\",\"type\":\"uint8\"},{\"name\":\"kind\",\"type\":\"uint8\"}],\"name\":\"_signature\",\"type\":\"tuple\"}],\"name\":\"perform\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_signer\",\"type\":\"address\"},{\"name\":\"_claim\",\"type\":\"bytes32\"},{\"components\":[{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"},{\"name\":\"v\",\"type\":\"uint8\"},{\"name\":\"kind\",\"type\":\"uint8\"}],\"name\":\"_signature\",\"type\":\"tuple\"}],\"name\":\"isValidSignature\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"proxies\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_target\",\"type\":\"address\"},{\"name\":\"_abilities\",\"type\":\"uint256\"},{\"name\":\"_allowSuperRevoke\",\"type\":\"bool\"}],\"name\":\"revokeAbilities\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_target\",\"type\":\"address\"},{\"name\":\"_abilities\",\"type\":\"uint256\"}],\"name\":\"isAble\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"components\":[{\"name\":\"maker\",\"type\":\"address\"},{\"name\":\"taker\",\"type\":\"address\"},{\"components\":[{\"name\":\"kind\",\"type\":\"uint8\"},{\"name\":\"proxy\",\"type\":\"uint32\"},{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"param1\",\"type\":\"bytes32\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"actions\",\"type\":\"tuple[]\"},{\"name\":\"seed\",\"type\":\"uint256\"},{\"name\":\"expiration\",\"type\":\"uint256\"}],\"name\":\"_orderData\",\"type\":\"tuple\"}],\"name\":\"getOrderDataClaim\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"orderPerformed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_maker\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_taker\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_claim\",\"type\":\"bytes32\"}],\"name\":\"Perform\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_maker\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_taker\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_claim\",\"type\":\"bytes32\"}],\"name\":\"Cancel\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_index\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_proxy\",\"type\":\"address\"}],\"name\":\"ProxyChange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_target\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_abilities\",\"type\":\"uint256\"}],\"name\":\"GrantAbilities\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_target\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_abilities\",\"type\":\"uint256\"}],\"name\":\"RevokeAbilities\",\"type\":\"event\"}]","ContractName":"OrderGateway","CompilerVersion":"v0.5.6+commit.b259423e","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://d4a7c50780436d23740125d763cba081e3c9eef54c1a6cdb8065de461616bd6c"}]}