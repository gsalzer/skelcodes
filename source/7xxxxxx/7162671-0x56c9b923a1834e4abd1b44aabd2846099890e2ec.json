{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.11;\r\n\r\nlibrary SafeMath\r\n{\r\n    uint256 constant public MAX_UINT256 =\r\n    0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\r\n\r\n    function GET_MAX_UINT256() pure internal returns(uint256){\r\n        return MAX_UINT256;\r\n    }\r\n\r\n    function mul(uint a, uint b) internal returns(uint){\r\n        uint c = a * b;\r\n        assertSafe(a == 0 || c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint a, uint b) pure internal returns(uint){\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        uint c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n\r\n    function sub(uint a, uint b) internal returns(uint){\r\n        assertSafe(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint a, uint b) internal returns(uint){\r\n        uint c = a + b;\r\n        assertSafe(c >= a);\r\n        return c;\r\n    }\r\n\r\n    function max64(uint64 a, uint64 b) internal view returns(uint64){\r\n        return a >= b ? a : b;\r\n    }\r\n\r\n    function min64(uint64 a, uint64 b) internal view returns(uint64){\r\n        return a < b ? a : b;\r\n    }\r\n\r\n    function max256(uint256 a, uint256 b) internal view returns(uint256){\r\n        return a >= b ? a : b;\r\n    }\r\n\r\n    function min256(uint256 a, uint256 b) internal view returns(uint256){\r\n        return a < b ? a : b;\r\n    }\r\n\r\n    function assertSafe(bool assertion) internal {\r\n        if (!assertion) {\r\n            revert();\r\n        }\r\n    }\r\n}\r\n\r\ncontract Auctioneer {\r\n    function createAuctionContract() payable public returns(address) {\r\n        AuctionContract auctionContract = (new AuctionContract).value(msg.value)(3000, this);//TODO CHANGE 30 -->> 3000\r\n\r\n        return auctionContract;\r\n    }\r\n}\r\n\r\ncontract AuctionContract {\r\n    using SafeMath for uint;\r\n\r\n    event BetPlacedEvent(address bidderAddress, uint amount);\r\n    event RefundEvent(address bidderAddress, uint amount);\r\n    event CreateAuctionContractEvent(address bidderAddress, uint amount);\r\n\r\n    uint public auctionSlideSize = 30;\r\n    uint public auctionCloseBlock;\r\n    uint public closeAuctionAfterNBlocks;\r\n    uint public bettingStep;\r\n    mapping (address => uint) public bettingMap;\r\n    address public firstBidder;\r\n    address public secondBidder;\r\n    address public winner;\r\n    uint public biggestBet;\r\n    uint public prize;\r\n    address public firstBetContract;\r\n    address public secondBetContract;\r\n    uint public minimalPrize = 10000000000000000;//0.01 ETH\r\n    uint public minimaBetStep = 10000000000000000;//0.01 ETH\r\n    address public auctioneerAddress;\r\n    bool public isActive;\r\n\r\n    constructor (uint _closeAuctionAfterNBlocks, address _auctioneerAddress) payable public{\r\n        assert(msg.value >= minimalPrize);\r\n        prize = msg.value;\r\n        auctioneerAddress = _auctioneerAddress;\r\n        closeAuctionAfterNBlocks = _closeAuctionAfterNBlocks;\r\n        auctionCloseBlock = block.number.add(_closeAuctionAfterNBlocks);\r\n        bettingStep = 0;\r\n        biggestBet = 0;\r\n        isActive = true;\r\n\r\n        emit CreateAuctionContractEvent(this, prize);\r\n    }\r\n\r\n    function() public payable {\r\n        assert(auctionCloseBlock >= block.number);\r\n        uint value = bettingMap[msg.sender];\r\n        value = value.add(msg.value);\r\n        assert(msg.value >= minimaBetStep);\r\n        assert(biggestBet < value);\r\n\r\n        bettingMap[msg.sender] = value;\r\n        biggestBet = value;\r\n\r\n        if (msg.sender != firstBidder) {\r\n            secondBidder = firstBidder;\r\n        }\r\n        \r\n        firstBidder = msg.sender;\r\n\r\n        bettingStep = bettingStep.add(1);\r\n        auctionCloseBlock = auctionCloseBlock.add(auctionSlideSize);\r\n        winner = msg.sender;\r\n\r\n        emit BetPlacedEvent(msg.sender, msg.value);\r\n    }\r\n\r\n    function askForRefund() public {\r\n        assert(firstBidder != msg.sender);\r\n        assert(secondBidder != msg.sender);\r\n        uint value = bettingMap[msg.sender];\r\n        assert(value != 0);\r\n\r\n        msg.sender.transfer(value);\r\n        bettingMap[msg.sender] = 0;\r\n\r\n        emit RefundEvent(msg.sender, value);\r\n    }\r\n\r\n    function closeAuction() public {\r\n        assert(isActive);\r\n        assert(auctionCloseBlock < block.number);\r\n        assert(msg.sender == winner);\r\n        msg.sender.transfer(prize);\r\n        Auctioneer auctioneer = Auctioneer(auctioneerAddress);\r\n\r\n        if(firstBidder != address(0)) {\r\n            uint firstValue = bettingMap[firstBidder];\r\n            if (firstValue >= minimalPrize) {\r\n                address firstContract = auctioneer.createAuctionContract.value(firstValue)();\r\n                firstBetContract = firstContract;\r\n            }\r\n        }\r\n\r\n        if(secondBidder != address(0)) {\r\n            uint secondValue = bettingMap[secondBidder];\r\n            if (secondValue >= minimalPrize) {\r\n                address secondContract = auctioneer.createAuctionContract.value(secondValue)();\r\n                secondBetContract = secondContract;\r\n            }\r\n        }\r\n        \r\n        isActive = false;\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[],\"name\":\"createAuctionContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"}]","ContractName":"Auctioneer","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://556760034baf0c794e7e09833e70e183798a683d01d4c8c98b417d4e9b41b2c9"}]}