{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.25;\r\n\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n\r\ncontract ERC20Basic {\r\n    function totalSupply() public view returns (uint256);\r\n    function balanceOf(address who) public view returns (uint256);\r\n    function transfer(address to, uint256 value) public returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n\r\ncontract ERC20 is ERC20Basic {\r\n    function allowance(address owner, address spender) public view returns (uint256);\r\n    function transferFrom(address from, address to, uint256 value) public returns (bool);\r\n    function approve(address spender, uint256 value) public returns (bool);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\n/// @title Intel contract\r\n\r\n/// @notice Intel, A contract for creating, rewarding and distributing Intels\r\ncontract Intel{\r\n    \r\n    using SafeMath for uint256;\r\n    \r\n    //Struct to main the state of an Intel\r\n    struct IntelState {\r\n        address intelProvider;\r\n        uint depositAmount;\r\n        uint desiredReward;\r\n  \r\n        // total balance of Pareto tokens given for this intel including the intel provider’s deposit\r\n        uint balance;\r\n\r\n       //unique identifier \r\n        uint intelID;\r\n\r\n        // timestamp for when rewards can be collected\r\n        uint rewardAfter;\r\n\r\n        // flag indicating whether the rewards have been collected\r\n        bool rewarded;\r\n        \r\n        // stores how many Pareto tokens were given for this intel in case you want to enforce a max amount per contributor\r\n        address[] contributionsList;\r\n        mapping(address => uint) contributions;\r\n    }\r\n\r\n    // mapping for all of the Intels\r\n    mapping(uint => IntelState) intelDB; \r\n\r\n    // mapping of Intels by a single provider\r\n    mapping(address => IntelState[]) public intelsByProvider;\r\n    \r\n    // mapping for the storage of deposit amounts by addresses\r\n    mapping(address => uint) public balances;\r\n\r\n    // mapping for storage of addresses who have at least deposited once\r\n    mapping(address => bool) public registered; \r\n\r\n    // list of addresses who have had made deposited to the smart contract\r\n    address[] public participants;\r\n\r\n    // total Pareto token balance inside the Intel contract\r\n    uint public totalParetoBalance; \r\n\r\n    uint[] intelIndexes;\r\n    \r\n    // total count of Intels\r\n    uint public intelCount; \r\n    \r\n    // Storage variable to hold the address of the owner of the intel contract\r\n    address public owner;    \r\n    \r\n    // Storage variable of type ERC20 to hold Pareto Token\r\n    ERC20 public token;  \r\n\r\n    // Address of the Pareto Token\r\n    address public paretoAddress;\r\n\r\n    \r\n    constructor(address _owner, address _token) public {\r\n        // owner is a Pareto wallet which should be able to perform admin functions\r\n        owner = _owner; \r\n        token = ERC20(_token);\r\n        paretoAddress = _token;\r\n    }\r\n    \r\n\r\n    // modifier to check to see if  the sender of transaction is the owner\r\n    modifier onlyOwner(){\r\n        require(msg.sender == owner, \"Sender of this transaction can be only the owner\");\r\n        _;\r\n    }\r\n\r\n\r\n    function changeOwner(address _newOwner) public onlyOwner{\r\n        require(_newOwner != address(0x0), \"New owner address is not valid\");\r\n        owner = _newOwner;\r\n    }\r\n    \r\n\r\n    event Reward( address sender, uint intelIndex, uint rewardAmount);\r\n    event NewIntel(address intelProvider, uint depositAmount, uint desiredReward, uint intelID, uint ttl);\r\n    event RewardDistributed(uint intelIndex, uint provider_amount, address provider, address distributor, uint distributor_amount);\r\n    event LogProxy(address destination, address account, uint amount, uint gasLimit);\r\n    event Deposited(address from, address to, uint amount);\r\n    \r\n    function makeDeposit(address _address, uint _amount) public {\r\n        require(_address != address(0x0), \"Address is invalid\");\r\n        require(_amount > 0, \"Deposit amount needs to be greater than 0\");\r\n\r\n        // Transfer token from the  depositing address to the Intel smart contract\r\n        token.transferFrom(_address, address(this), _amount);\r\n\r\n        // Increases the balance for the depositing address in the balances map \r\n        balances[_address] = balances[_address].add(_amount); \r\n\r\n        // We check to see  if the user who is making the deposit is already registered\r\n        // If they are not registered, then we add their address to the participants array, and update \r\n        // the registered map address => true\r\n        if(!registered[_address]) {     \r\n            participants.push(_address);\r\n            registered[_address] = true;\r\n        }\r\n\r\n        // Add the deposited amount to the total Pareto Balance to keep track of total deposited pareto inside the smart contract\r\n        totalParetoBalance = totalParetoBalance.add(_amount);  \r\n        \r\n\t\t// Fire the deposited event with the from address, to address, and amount\r\n        emit Deposited(_address, address(this), _amount);\r\n    }\r\n    \r\n    /// @notice this function creates an Intel\r\n    /// @dev Uses 'now' for timestamps. balance[address(this)] is for allocating tokens to the Intel contract for when we subtract tokens from user’s address in case of creation or rewarding of Intels. we actually should add tokens to somewhere when we subtract them from user’s balance and the smart contract’s address is being used for that.\r\n    /// @param intelProvider is the address of the creator\\provider of the Intel\r\n    /// @param depositAmount is the amount of Pareto tokens staked by the provider\r\n    /// @param desiredReward is the amount of Pareto tokens desired by the provider as the reward\r\n    /// @param intelID is the ID of Intel which is mapped against an Intel in IntelDB as well as the database external to Ethereum\r\n    /// @param ttl is the time in EPOCH format until the Intel remains active and accepts rewards\r\n    /// requires 210769 gas in Rinkeby Network\r\n    function create(address intelProvider, uint depositAmount, uint desiredReward, uint intelID, uint ttl) public {\r\n\r\n        require(intelID > 0, \"Intel's ID should be greater than 0.\");\r\n        require(address(intelProvider) != address(0x0), \"Intel Provider's address provided is invalid.\");\r\n        require(depositAmount > 0, \"Amount should be greater than 0.\");\r\n        require(desiredReward > 0, \"Desired reward should be greater than 0.\");\r\n        require(ttl > now, \"Expiration date for Intel should be greater than now.\");\r\n                \r\n        IntelState storage intel = intelDB[intelID];\r\n        require(intel.depositAmount == 0, \"Intel with the provided ID already exists\");\r\n\r\n        // First, check if the user already has deposited enough Paretos into this smart contract to satisfy the stake amount required to create the Intel\r\n        if(depositAmount <= balances[intelProvider]) {                      \r\n\r\n            // The user has deposited enough Pareto into this contract to create the Intel. Deduct the amount from the user's balance\r\n            balances[intelProvider] = balances[intelProvider].sub(depositAmount);   \r\n\r\n            // In the balances map for the address of this contract, we will maintain the amount of Pareto token used to create intel.\r\n            balances[address(this)] = balances[address(this)].add(depositAmount);   \r\n\r\n        } else {\r\n            //The user does NOT have an adequate balance to cover the creation of the intel. We will transfer the depositAmount from the user's address to the intel contract.\r\n            token.transferFrom(intelProvider, address(this), depositAmount);  \r\n\r\n            // In the balances map for the address of this contract, we will maintain the amount of Pareto token used to create intel. \r\n            balances[address(this)] = balances[address(this)].add(depositAmount); \r\n   \r\n            // Add depositAmount to the total Pareto Balance to keep track of total deposited pareto inside the smart contract\r\n            totalParetoBalance = totalParetoBalance.add(depositAmount);   \r\n        }\r\n\r\n        //For the new intel, create a contributionsList\r\n        address[] memory contributionsList;\r\n\r\n        //Create the new IntelState Struct\r\n        IntelState memory newIntel = IntelState(intelProvider, depositAmount, desiredReward, depositAmount, intelID, ttl, false, contributionsList);\r\n\r\n        //Add the IntelState to the intelDB indexed by IntelID\r\n        intelDB[intelID] = newIntel;\r\n\r\n        //Populate the intelsByProvider map\r\n        intelsByProvider[intelProvider].push(newIntel);\r\n\r\n        //maintain a separate array of IntelIDs.\r\n        intelIndexes.push(intelID);\r\n\r\n        //Increment the intel count\r\n        intelCount++;\r\n     \r\n        //Trigger a NewIntel event   \r\n        emit NewIntel(intelProvider, depositAmount, desiredReward, intelID, ttl);\r\n    }\r\n    \r\n\r\n    \r\n    /// @notice this function sends rewards to the Intel\r\n    /// @dev Uses 'now' for timestamps. balance[address(this)] is for allocating tokens to the Intel contract for when we subtract tokens from user’s address in case of creation or rewarding of Intels. we actually should add tokens to somewhere when we subtract them from user’s balance and the smart contract’s address is being used for that.\r\n    /// @param intelIndex is the ID of the Intel to send the rewards to\r\n    /// @param rewardAmount is the amount of Pareto tokens the rewarder wants to reward to the Intel\r\n    /// @return returns true in case of successful completion\r\n    /// requires 72283 gas on Rinkeby Network\r\n    function sendReward(uint intelIndex, uint rewardAmount) public returns(bool success){\r\n\r\n        //Ensure we have a valid intelIndex\r\n        require(intelIndex > 0, \"Intel's ID should be greater than 0.\");\r\n\r\n\t\t//Ensure that the rewardAmount is greater than 0.\r\n        require(rewardAmount > 0, \"Reward amount should be greater than 0.\");\r\n\r\n        IntelState storage intel = intelDB[intelIndex];\r\n\r\n        // make sure that Intel exists \r\n        require(intel.intelProvider != address(0x0), \"Intel for the provided ID does not exist.\");\r\n        \r\n        //Ensure that the person who is performing the reward is not the IntelProvider\r\n        require(msg.sender != intel.intelProvider, \"msg.sender should not be the current Intel's provider.\"); \r\n        \r\n        //You cannot reward intel if the timestamp of the reward transaction is greater than rewardAfter variable of the Intel.\r\n        require(intel.rewardAfter > now, \"Intel is expired\");  \r\n\r\n        // You cannot reward intel if the intel’s rewards have already been distributed\r\n        require(!intel.rewarded, \"Intel is already rewarded\"); \r\n     \r\n        // Check if the user who is sending the reward already has rewardAmount worth of tokens deposited in their balance\r\n        if(rewardAmount <= balances[msg.sender]) {      \r\n            //The user who is sending reward has enough deposited tokens to make the transaction. Hence, decrease the \r\n            //the user's token amount from balances map by rewardAmount\r\n            balances[msg.sender] = balances[msg.sender].sub(rewardAmount);  \r\n            \r\n            //In the balance map for this contract address, we keep track of the total amount transacted.  This looks funny. Are we going to be double counting?\r\n            balances[address(this)] = balances[address(this)].add(rewardAmount); \r\n        } else {\r\n\r\n            //The user who is sending reward does NOT have  enough deposited tokens to make the transaction. Hence, transfer token from caller to Intel Contract\r\n            token.transferFrom(msg.sender, address(this), rewardAmount); \r\n\r\n            // add token amount in balances worth rewardAmount for this smart contract. This looks fishy. What are we tracking here\r\n            balances[address(this)] = balances[address(this)].add(rewardAmount);\r\n\r\n            // add amount to total to keep track of total deposited pareto inside the smart contract\r\n            totalParetoBalance = totalParetoBalance.add(rewardAmount);   \r\n        }\r\n\r\n        //On the intel contract, increment the balance by the rewardAmount.\r\n        intel.balance = intel.balance.add(rewardAmount);\r\n\r\n        //On the intel contract, add the address of the person who is sending the reward, if they don't already exist\r\n        if(intel.contributions[msg.sender] == 0){\r\n            intel.contributionsList.push(msg.sender);\r\n        }\r\n        \r\n        //On the intel contract, increase the contributions map with this sender address by the amount rewarded \r\n        intel.contributions[msg.sender] = intel.contributions[msg.sender].add(rewardAmount);\r\n        \r\n\r\n        //Fire the reward event\r\n        emit Reward(msg.sender, intelIndex, rewardAmount);\r\n\r\n\r\n        return true;\r\n    }\r\n    \r\n\r\n    \r\n    /// @notice this function distributes rewards to the Intel provider\r\n    /// @dev Uses 'now' for timestamps. Uses balances[address(this)] to subtract the tokens from the smart contract in balances mapping.\r\n    /// @param intelIndex is the ID of the Intel to distribute tokens to\r\n    /// @return returns true in case of successful completion\r\n    /// requires 91837 gas on Rinkeby Network\r\n    function distributeReward(uint intelIndex) public returns(bool success){\r\n\r\n        require(intelIndex > 0, \"Intel's ID should be greater than 0.\");\r\n        \r\n\r\n        IntelState storage intel = intelDB[intelIndex];\r\n        \r\n        require(!intel.rewarded, \"Intel is already rewarded.\");\r\n        require(now >= intel.rewardAfter, \"Intel needs to be expired for distribution.\");\r\n        \r\n\r\n        intel.rewarded = true;\r\n        uint distributed_amount = 0;\r\n\r\n        distributed_amount = intel.balance;\r\n        \r\n        balances[address(this)] = balances[address(this)].sub(distributed_amount);  // subtract distributed_amount worth of tokens from balances for the Intel smart contract\r\n        intel.balance = 0;\r\n\r\n        uint fee = distributed_amount.div(10);    // calculate 10% as the fee for distribution\r\n        distributed_amount = distributed_amount.sub(fee);   // calculate final distribution amount\r\n\r\n        token.transfer(msg.sender, fee/2);  // transfer 5% fee to the distributor\r\n        balances[owner] = balances[owner].add(fee/2);  // update balances with 5% worth of distribution amount for the owner\r\n        token.transfer(intel.intelProvider, distributed_amount); // transfer the 90% token to the intel provider\r\n        totalParetoBalance = totalParetoBalance.sub(distributed_amount.add(fee/2)); // update balances with subtraction of 95% of distributing tokens from the Intel contract\r\n       \r\n\r\n        emit RewardDistributed(intelIndex, distributed_amount, intel.intelProvider, msg.sender, fee);\r\n\r\n\r\n        return true;\r\n\r\n    }\r\n    \r\n    function getParetoBalance(address _address) public view returns(uint) {\r\n        return balances[_address];\r\n    }\r\n\r\n    function distributeFeeRewards(address[] _participants, uint _amount) public onlyOwner {\r\n        uint totalCirculatingAmount = totalParetoBalance - balances[address(this)] - balances[owner];\r\n\r\n        for( uint i = 0; i < _participants.length; i++) {\r\n            if(balances[_participants[i]] > 0) {\r\n                uint amountToAdd = _amount.mul(balances[_participants[i]]).div(totalCirculatingAmount);\r\n                balances[_participants[i]] = balances[_participants[i]].add(amountToAdd);\r\n                balances[owner] = balances[owner].sub(amountToAdd);\r\n            }\r\n        }\r\n    }\r\n\r\n    function getParticipants() public view returns(address[] memory _participants) {\r\n        _participants = new address[](participants.length);\r\n        \r\n        for(uint i = 0; i < participants.length; i++) {\r\n            _participants[i] = participants[i];\r\n        }\r\n        return;\r\n    }\r\n\r\n    /// @notice this function sets the address of Pareto Token\r\n    /// @dev only owner can call it\r\n    /// @param _token is the Pareto token address\r\n    /// requires 63767 gas on Rinkeby Network\r\n    function setParetoToken(address _token) public onlyOwner{\r\n\r\n        token = ERC20(_token);\r\n        paretoAddress = _token;\r\n\r\n    }\r\n    \r\n\r\n    \r\n    /// @notice this function sends back the mistakenly sent non-Pareto ERC20 tokens\r\n    /// @dev only owner can call it\r\n    /// @param destination is the contract address where the tokens were received from mistakenly\r\n    /// @param account is the external account's address which sent the wrong tokens\r\n    /// @param amount is the amount of tokens sent\r\n    /// @param gasLimit is the amount of gas to be sent along with external contract's transfer call\r\n    /// requires 27431 gas on Rinkeby Network\r\n    function proxy(address destination, address account, uint amount, uint gasLimit) public onlyOwner{\r\n\r\n        require(destination != paretoAddress, \"Pareto Token cannot be assigned as destination.\");    // check that the destination is not the Pareto token contract\r\n\r\n        // make the call to transfer function of the 'destination' contract\r\n        // if(!address(destination).call.gas(gasLimit)(bytes4(keccak256(\"transfer(address,uint256)\")),account, amount)){\r\n        //     revert();\r\n        // }\r\n\r\n\r\n        // ERC20(destination).transfer(account,amount);\r\n\r\n\r\n        bytes4  sig = bytes4(keccak256(\"transfer(address,uint256)\"));\r\n\r\n        assembly {\r\n            let x := mload(0x40) //Find empty storage location using \"free memory pointer\"\r\n        mstore(x,sig) //Place signature at beginning of empty storage \r\n        mstore(add(x,0x04),account)\r\n        mstore(add(x,0x24),amount)\r\n\r\n        let success := call(      //This is the critical change (Pop the top stack value)\r\n                            gasLimit, //5k gas\r\n                            destination, //To addr\r\n                            0,    //No value\r\n                            x,    //Inputs are stored at location x\r\n                            0x44, //Inputs are 68 bytes long\r\n                            x,    //Store output over input (saves space)\r\n                            0x0) //Outputs are 32 bytes long\r\n\r\n        // Check return value and jump to bad destination if zero\r\n\t\tjumpi(0x02,iszero(success))\r\n\r\n        }\r\n        emit LogProxy(destination, account, amount, gasLimit);\r\n    }\r\n\r\n    \r\n    /// @notice It's a fallback function supposed to return sent Ethers by reverting the transaction\r\n    function() external{\r\n        revert();\r\n    }\r\n\r\n    \r\n    /// @notice this function provide the Intel based on its index\r\n    /// @dev it's a constant function which can be called\r\n    /// @param intelIndex is the ID of Intel that is to be returned from intelDB\r\n    function getIntel(uint intelIndex) public view returns(address intelProvider, uint depositAmount, uint desiredReward, uint balance, uint intelID, uint rewardAfter, bool rewarded) {\r\n        \r\n        IntelState storage intel = intelDB[intelIndex];\r\n        intelProvider = intel.intelProvider;\r\n        depositAmount = intel.depositAmount;\r\n        desiredReward = intel.desiredReward;\r\n        balance = intel.balance;\r\n        rewardAfter = intel.rewardAfter;\r\n        intelID = intel.intelID;\r\n        rewarded = intel.rewarded;\r\n\r\n    }\r\n\r\n    function getAllIntel() public view returns (uint[] intelID, address[] intelProvider, uint[] depositAmount, uint[] desiredReward, uint[] balance, uint[] rewardAfter, bool[] rewarded){\r\n        \r\n        uint length = intelIndexes.length;\r\n        intelID = new uint[](length);\r\n        intelProvider = new address[](length);\r\n        depositAmount = new uint[](length);\r\n        desiredReward = new uint[](length);\r\n        balance = new uint[](length);\r\n        rewardAfter = new uint[](length);\r\n        rewarded = new bool[](length);\r\n\r\n        for(uint i = 0; i < intelIndexes.length; i++){\r\n            intelID[i] = intelDB[intelIndexes[i]].intelID;\r\n            intelProvider[i] = intelDB[intelIndexes[i]].intelProvider;\r\n            depositAmount[i] = intelDB[intelIndexes[i]].depositAmount;\r\n            desiredReward[i] = intelDB[intelIndexes[i]].desiredReward;\r\n            balance[i] = intelDB[intelIndexes[i]].balance;\r\n            rewardAfter[i] = intelDB[intelIndexes[i]].rewardAfter;\r\n            rewarded[i] = intelDB[intelIndexes[i]].rewarded;\r\n        }\r\n    }\r\n\r\n\r\n    function getIntelsByProvider(address _provider) public view returns (uint[] intelID, address[] intelProvider, uint[] depositAmount, uint[] desiredReward, uint[] balance, uint[] rewardAfter, bool[] rewarded){\r\n        \r\n        uint length = intelsByProvider[_provider].length;\r\n\r\n        intelID = new uint[](length);\r\n        intelProvider = new address[](length);\r\n        depositAmount = new uint[](length);\r\n        desiredReward = new uint[](length);\r\n        balance = new uint[](length);\r\n        rewardAfter = new uint[](length);\r\n        rewarded = new bool[](length);\r\n\r\n        IntelState[] memory intels = intelsByProvider[_provider];\r\n\r\n        for(uint i = 0; i < length; i++){\r\n            intelID[i] = intels[i].intelID;\r\n            intelProvider[i] = intels[i].intelProvider;\r\n            depositAmount[i] = intels[i].depositAmount;\r\n            desiredReward[i] = intels[i].desiredReward;\r\n            balance[i] = intels[i].balance;\r\n            rewardAfter[i] = intels[i].rewardAfter;\r\n            rewarded[i] = intels[i].rewarded;\r\n        }\r\n    }\r\n\r\n    function contributionsByIntel(uint intelIndex) public view returns(address[] memory addresses, uint[] memory amounts){\r\n        IntelState storage intel = intelDB[intelIndex];\r\n                \r\n        uint length = intel.contributionsList.length;\r\n\r\n        addresses = new address[](length);\r\n        amounts = new uint[](length);\r\n\r\n        for(uint i = 0; i < length; i++){\r\n            addresses[i] = intel.contributionsList[i]; \r\n            amounts[i] = intel.contributions[intel.contributionsList[i]];       \r\n        }\r\n\r\n    }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"intelIndex\",\"type\":\"uint256\"}],\"name\":\"getIntel\",\"outputs\":[{\"name\":\"intelProvider\",\"type\":\"address\"},{\"name\":\"depositAmount\",\"type\":\"uint256\"},{\"name\":\"desiredReward\",\"type\":\"uint256\"},{\"name\":\"balance\",\"type\":\"uint256\"},{\"name\":\"intelID\",\"type\":\"uint256\"},{\"name\":\"rewardAfter\",\"type\":\"uint256\"},{\"name\":\"rewarded\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalParetoBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"destination\",\"type\":\"address\"},{\"name\":\"account\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"gasLimit\",\"type\":\"uint256\"}],\"name\":\"proxy\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"balances\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"participants\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getParetoBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"setParetoToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getParticipants\",\"outputs\":[{\"name\":\"_participants\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"intelIndex\",\"type\":\"uint256\"},{\"name\":\"rewardAmount\",\"type\":\"uint256\"}],\"name\":\"sendReward\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_participants\",\"type\":\"address[]\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"distributeFeeRewards\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"intelIndex\",\"type\":\"uint256\"}],\"name\":\"distributeReward\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"intelIndex\",\"type\":\"uint256\"}],\"name\":\"contributionsByIntel\",\"outputs\":[{\"name\":\"addresses\",\"type\":\"address[]\"},{\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"registered\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"makeDeposit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAllIntel\",\"outputs\":[{\"name\":\"intelID\",\"type\":\"uint256[]\"},{\"name\":\"intelProvider\",\"type\":\"address[]\"},{\"name\":\"depositAmount\",\"type\":\"uint256[]\"},{\"name\":\"desiredReward\",\"type\":\"uint256[]\"},{\"name\":\"balance\",\"type\":\"uint256[]\"},{\"name\":\"rewardAfter\",\"type\":\"uint256[]\"},{\"name\":\"rewarded\",\"type\":\"bool[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paretoAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"intelCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"intelsByProvider\",\"outputs\":[{\"name\":\"intelProvider\",\"type\":\"address\"},{\"name\":\"depositAmount\",\"type\":\"uint256\"},{\"name\":\"desiredReward\",\"type\":\"uint256\"},{\"name\":\"balance\",\"type\":\"uint256\"},{\"name\":\"intelID\",\"type\":\"uint256\"},{\"name\":\"rewardAfter\",\"type\":\"uint256\"},{\"name\":\"rewarded\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_provider\",\"type\":\"address\"}],\"name\":\"getIntelsByProvider\",\"outputs\":[{\"name\":\"intelID\",\"type\":\"uint256[]\"},{\"name\":\"intelProvider\",\"type\":\"address[]\"},{\"name\":\"depositAmount\",\"type\":\"uint256[]\"},{\"name\":\"desiredReward\",\"type\":\"uint256[]\"},{\"name\":\"balance\",\"type\":\"uint256[]\"},{\"name\":\"rewardAfter\",\"type\":\"uint256[]\"},{\"name\":\"rewarded\",\"type\":\"bool[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"intelProvider\",\"type\":\"address\"},{\"name\":\"depositAmount\",\"type\":\"uint256\"},{\"name\":\"desiredReward\",\"type\":\"uint256\"},{\"name\":\"intelID\",\"type\":\"uint256\"},{\"name\":\"ttl\",\"type\":\"uint256\"}],\"name\":\"create\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_token\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"intelIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"rewardAmount\",\"type\":\"uint256\"}],\"name\":\"Reward\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"intelProvider\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"depositAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"desiredReward\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"intelID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"ttl\",\"type\":\"uint256\"}],\"name\":\"NewIntel\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"intelIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"provider_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"provider\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"distributor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"distributor_amount\",\"type\":\"uint256\"}],\"name\":\"RewardDistributed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"destination\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"gasLimit\",\"type\":\"uint256\"}],\"name\":\"LogProxy\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Deposited\",\"type\":\"event\"}]","ContractName":"Intel","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000f646d0a6ceb626c665acb09a139e15a265bdf4a3000000000000000000000000b22169c1d3667c163e23a75f4c48ddc0c3b5756d","Library":"","SwarmSource":"bzzr://170a8d65c817f979b23f105b47b20fbd9857c0b9c62e98ef16a5c58d3929fcf9"}]}