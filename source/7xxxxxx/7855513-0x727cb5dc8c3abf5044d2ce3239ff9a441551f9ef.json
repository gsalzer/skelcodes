{"status":"1","message":"OK","result":[{"SourceCode":"{\"AdminManaged.sol\":{\"content\":\"pragma solidity \\u003e=0.5.3 \\u003c 0.6.0;\\r\\nimport { Roles } from \\\"./Roles.sol\\\";\\r\\n\\r\\ncontract AdminManaged{\\r\\n    using Roles for Roles.Role;\\r\\n\\r\\n    Roles.Role internal admins_;\\r\\n\\r\\n    constructor(address _firstAdmin) public {\\r\\n        admins_.add(_firstAdmin);\\r\\n    }\\r\\n\\r\\n    modifier onlyAdmin() {\\r\\n        require(admins_.has(msg.sender), \\\"User not authorised\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /// @dev    Used to add an admin \\r\\n    /// @param _newAdmin        :address The address of the new admin\\r\\n    function addAdmin(address _newAdmin) external onlyAdmin {\\r\\n        admins_.add(_newAdmin);\\r\\n        require(admins_.has(_newAdmin), \\\"User not added as admin\\\");\\r\\n    }\\r\\n\\r\\n    /// @dev    Used to remove admins\\r\\n    /// @param _oldAdmin        :address The address of the previous admin\\r\\n    function removeAdmin(address _oldAdmin) external onlyAdmin {\\r\\n        admins_.remove(_oldAdmin);\\r\\n        require(!admins_.has(_oldAdmin), \\\"User not removed as admin\\\");\\r\\n    }\\r\\n\\r\\n    /// @dev    Checking admin rights\\r\\n    /// @param _account         :address in question \\r\\n    /// @return bool            \\r\\n    function isAdmin(address _account) external view returns(bool) {\\r\\n        return admins_.has(_account);\\r\\n    }\\r\\n\\r\\n}\"},\"BaseFactory.sol\":{\"content\":\"pragma solidity \\u003e=0.5.3 \\u003c 0.6.0;\\r\\n\\r\\ncontract BaseFactory {\\r\\n    address internal admin_;\\r\\n    mapping(address =\\u003e bool) internal rootFactories_;\\r\\n\\r\\n    constructor(address _rootFactory) public {\\r\\n        rootFactories_[_rootFactory] = true;\\r\\n        admin_ = msg.sender;\\r\\n    }\\r\\n\\r\\n    modifier onlyAdmin() {\\r\\n        require(msg.sender == admin_, \\\"Not authorised\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier onlyRootFactory() {\\r\\n        require(rootFactories_[msg.sender], \\\"Not authorised\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    function addRootFactory(address _newRoot) external onlyAdmin() {\\r\\n        rootFactories_[_newRoot] = true;\\r\\n    }\\r\\n\\r\\n    function removeRootFactory(address _newRoot) external onlyAdmin() {\\r\\n        rootFactories_[_newRoot] = false;\\r\\n    }\\r\\n}\"},\"BaseTokenManager.sol\":{\"content\":\"pragma solidity \\u003e=0.5.3 \\u003c 0.6.0;\\r\\n\\r\\nimport { SafeMath } from \\\"./SafeMath.sol\\\";\\r\\nimport { AdminManaged } from \\\"./AdminManaged.sol\\\";\\r\\n\\r\\n\\r\\n/// @author Ben, Veronica \\u0026 Ryan of Linum Labs\\r\\n/// @author Ryan N.                 RyRy79261\\r\\n/// @title Basic Linear Token Manager\\r\\ncontract BaseTokenManager is AdminManaged {\\r\\n    using SafeMath for uint256;\\r\\n\\r\\n    address internal membershipManager_;\\r\\n    address internal reserveToken_;\\r\\n    address internal revenueTarget_;\\r\\n    address internal proteaAccount_;\\r\\n    uint256 internal contributionRate_;\\r\\n\\r\\n    string internal name_;\\r\\n    string internal symbol_;\\r\\n\\r\\n    uint256 internal totalSupply_;\\r\\n    uint256 internal poolBalance_;\\r\\n    \\r\\n    \\r\\n    uint256 internal gradientDenominator_ = 2000; // numerator/denominator DAI/Token\\r\\n    uint256 internal decimals_ = 18; // For now, assume 10^18 decimal precision\\r\\n\\r\\n    mapping(address =\\u003e mapping (address =\\u003e uint256)) internal allowed;\\r\\n    mapping(address =\\u003e uint256) internal balances;\\r\\n\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n    event Transfer(address indexed from, address indexed to, uint value);\\r\\n    \\r\\n    event Mint(address indexed to, uint256 amount, uint256 totalCost);\\r\\n    event Burn(address indexed from, uint256 amount, uint256 reward);\\r\\n\\r\\n    constructor(\\r\\n        string memory _name,\\r\\n        string memory _symbol,\\r\\n        address _reserveToken,\\r\\n        address _proteaAccount,\\r\\n        address _publisher,\\r\\n        uint256 _contributionRate,\\r\\n        address _membershipManager\\r\\n    ) \\r\\n        public\\r\\n        AdminManaged(_publisher)\\r\\n    {\\r\\n        name_ = _name;\\r\\n        symbol_ = _symbol;\\r\\n        reserveToken_ = _reserveToken;\\r\\n        revenueTarget_ = _publisher;\\r\\n        proteaAccount_ = _proteaAccount;\\r\\n        contributionRate_ = _contributionRate;\\r\\n        membershipManager_ = _membershipManager;\\r\\n    }\\r\\n\\r\\n     /// @dev                Gets the balance of the specified address.\\r\\n    /// @param _spender     :address The account that will receive the funds.\\r\\n    /// @param _value       :uint256 The value of funds accessed.\\r\\n    /// @return             :boolean Indicating the action was successful.\\r\\n    // Rough gas usage 47,234\\r\\n    function approve(\\r\\n        address _spender, \\r\\n        uint256 _value\\r\\n    ) \\r\\n        external \\r\\n        returns (bool) \\r\\n    {\\r\\n        allowed[msg.sender][_spender] = _value;\\r\\n        emit Approval(msg.sender, _spender, _value);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /// @dev                Gets the value of the current allowance specifed for that account\\r\\n    /// @param _owner       :address The account sending the funds.\\r\\n    /// @param _spender     :address The account that will receive the funds.\\r\\n    /// @return             An uint256 representing the amount owned by the passed address.\\r\\n    function allowance(address _owner, address _spender) \\r\\n        external \\r\\n        view \\r\\n        returns (uint256) \\r\\n    {\\r\\n        return allowed[_owner][_spender];\\r\\n    }\\r\\n    \\r\\n    /// @dev                Gets the balance of the specified address.\\r\\n    /// @param _owner       :address The address to query the the balance of.\\r\\n    /// @return             An uint256 representing the amount owned by the passed address.\\r\\n    function balanceOf(address _owner) external view returns (uint256) {\\r\\n        return balances[_owner];\\r\\n    }\\r\\n\\r\\n    /// @dev                Total number of tokens in existence\\r\\n    /// @return             A uint256 representing the total supply of tokens in this market\\r\\n    function totalSupply() external view returns (uint256) {\\r\\n        return totalSupply_;\\r\\n    }\\r\\n\\r\\n    /// @dev                Returns the address where community revenue is sent\\r\\n    /// @return             :address Address of the revenue storing account\\r\\n    function revenueTarget() external view returns(address) {\\r\\n        return revenueTarget_;\\r\\n    }\\r\\n\\r\\n    /// @dev                Returns the contribution rate for the community on Token purchase\\r\\n    /// @return             :uint256 The percentage of incoming collateral collected as revenue\\r\\n    function contributionRate() external view returns(uint256) {\\r\\n        return contributionRate_;\\r\\n    }\\r\\n\\r\\n    /// @dev                Returns the decimals set for the community\\r\\n    /// @return             :uint256 The decimals set for the community\\r\\n    function decimals() external view returns(uint256) {\\r\\n        return decimals_;\\r\\n    }\\r\\n}\"},\"BasicLinearTokenManager.sol\":{\"content\":\"pragma solidity \\u003e=0.5.3 \\u003c 0.6.0;\\r\\n\\r\\nimport { BaseTokenManager } from \\\"./BaseTokenManager.sol\\\";\\r\\nimport { IERC20 } from \\\"./IERC20.sol\\\";\\r\\n\\r\\n/// @author Ben, Veronica \\u0026 Ryan of Linum Labs\\r\\n/// @author Ryan N.                 RyRy79261\\r\\n/// @title Basic Linear Token Manager\\r\\ncontract BasicLinearTokenManager is BaseTokenManager {\\r\\n    constructor(\\r\\n        string memory _name,\\r\\n        string memory _symbol,\\r\\n        address _reserveToken,\\r\\n        address _proteaAccount,\\r\\n        address _publisher,\\r\\n        uint256 _contributionRate,\\r\\n        address _membershipManager\\r\\n    ) \\r\\n        public\\r\\n        BaseTokenManager(_name, _symbol, _reserveToken, _proteaAccount, _publisher, _contributionRate, _membershipManager)\\r\\n    {\\r\\n    }\\r\\n\\r\\n    // [Bonding curve functions]\\r\\n\\r\\n    /// @dev                Selling tokens back to the bonding curve for collateral\\r\\n    /// @param _numTokens   The number of tokens that you want to burn\\r\\n    function burn(uint256 _numTokens) external returns(bool) {\\r\\n        require(balances[msg.sender] \\u003e= _numTokens, \\\"Not enough tokens available\\\");\\r\\n\\r\\n        uint256 rewardForTokens = rewardForBurn(_numTokens);\\r\\n        totalSupply_ = totalSupply_.sub(_numTokens);\\r\\n        balances[msg.sender] = balances[msg.sender].sub(_numTokens);\\r\\n        poolBalance_ = poolBalance_.sub(rewardForTokens);\\r\\n        require(\\r\\n            IERC20(reserveToken_).transfer(msg.sender, rewardForTokens), \\r\\n            \\\"Require transferFrom to succeed\\\"\\r\\n        );\\r\\n\\r\\n        emit Transfer(msg.sender, address(0), _numTokens);\\r\\n\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /// @dev                Mint new tokens with ether\\r\\n    /// @param _to          :address Address to mint tokens to\\r\\n    /// @param _numTokens   :uint256 The number of tokens you want to mint\\r\\n    /// @dev                We have modified the minting function to divert a portion of the purchase tokens\\r\\n    // Rough gas usage 153,440 \\r\\n    function mint(address _to, uint256 _numTokens) external returns(bool) {\\r\\n        uint256 priceForTokens = priceToMint(_numTokens);\\r\\n        require(\\r\\n            IERC20(reserveToken_).transferFrom(msg.sender, address(this), priceForTokens), \\r\\n            \\\"Require transferFrom to succeed\\\"\\r\\n        );\\r\\n        require(\\r\\n            IERC20(reserveToken_).transfer(proteaAccount_, priceForTokens.div(101)), // This takes the 1 percent out of the total price\\r\\n            \\\"Protea contribution must succeed\\\"\\r\\n        );\\r\\n\\r\\n        uint256 comContribution = _numTokens.div(100).mul(contributionRate_);\\r\\n        totalSupply_ = totalSupply_.add(_numTokens);\\r\\n        poolBalance_ = poolBalance_.add(priceForTokens.sub(priceForTokens.div(101))); // Minus amount sent to Protea\\r\\n        balances[msg.sender] = balances[msg.sender].add(_numTokens.sub(comContribution)); // Minus amount sent to Revenue target\\r\\n\\r\\n        balances[revenueTarget_] = balances[revenueTarget_].add(comContribution); // Minus amount sent to Revenue target\\r\\n\\r\\n        emit Transfer(address(0), _to, _numTokens);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    // [ERC20 functions]\\r\\n\\r\\n   \\r\\n\\r\\n    /// @dev                        Transfer ownership token from msg.sender to a specified address\\r\\n    /// @param _to                  : address The address to transfer to.\\r\\n    /// @param _value               : uint256 The amount to be transferred.\\r\\n    function transfer(address _to, uint256 _value) public returns (bool) {\\r\\n        require(_value \\u003c= balances[msg.sender], \\\"Insufficient funds\\\");\\r\\n        require(_to != address(0), \\\"Target account invalid\\\");\\r\\n\\r\\n        balances[msg.sender] = balances[msg.sender].sub(_value);\\r\\n        balances[_to] = balances[_to].add(_value);\\r\\n        emit Transfer(msg.sender, _to, _value);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /// @dev                Transfer tokens from one address to another\\r\\n    /// @param _from        :address The address which you want to send tokens from\\r\\n    /// @param _to          :address The address which you want to transfer to\\r\\n    /// @param _value       :uint256 the amount of tokens to be transferred\\r\\n    function transferFrom(\\r\\n        address _from,\\r\\n        address _to,\\r\\n        uint256 _value\\r\\n    )\\r\\n        public\\r\\n        returns (bool)\\r\\n    {\\r\\n        require(_value \\u003c= balances[_from], \\\"Requested amount exceeds balance\\\");\\r\\n        \\r\\n        // This is to allow the membership manager elevated access for managing tokens\\r\\n        if(msg.sender != membershipManager_){\\r\\n            require(_value \\u003c= allowed[_from][msg.sender], \\\"Allowance exceeded\\\");\\r\\n            require(_to != address(0), \\\"Target account invalid\\\");\\r\\n        }\\r\\n\\r\\n        balances[_from] = balances[_from].sub(_value);\\r\\n        balances[_to] = balances[_to].add(_value);\\r\\n\\r\\n        if(msg.sender != membershipManager_){\\r\\n            allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\\r\\n        }\\r\\n        \\r\\n        emit Transfer(_from, _to, _value);\\r\\n        return true;\\r\\n    } \\r\\n\\r\\n\\r\\n    /// @dev                Returns the gradient for the communities curve\\r\\n    /// @return             :uint256 The gradient for the communities curve\\r\\n    function gradientDenominator() external view returns(uint256) {\\r\\n        return gradientDenominator_;\\r\\n    }\\r\\n\\r\\n    // [Pricing functions]\\r\\n    \\r\\n    /// @dev                Returns the required collateral amount for a volume of bonding curve tokens\\r\\n    /// @return             :uint256 Required collateral corrected for decimals\\r\\n    function priceToMint(uint256 _numTokens) public view returns(uint256) {\\r\\n        // return curveIntegral(totalSupply_.add(_numTokens)).sub(poolBalance_);\\r\\n        uint256 rawDai = curveIntegral(totalSupply_.add(_numTokens)).sub(poolBalance_);\\r\\n        return rawDai.add(rawDai.div(100)); // Adding 1 percent \\r\\n    }\\r\\n\\r\\n    /// @dev                Returns the required collateral amount for a volume of bonding curve tokens\\r\\n    /// @return             Potential return collateral corrected for decimals\\r\\n    function rewardForBurn(uint256 _numTokens) public view returns(uint256) {\\r\\n        return poolBalance_.sub(curveIntegral(totalSupply_.sub(_numTokens)));\\r\\n    }\\r\\n\\r\\n    // [Inverse pricing functions]\\r\\n    /// @dev                This function returns the amount of tokens one can receive for a specified amount of collateral token\\r\\n    ///                     Including Protea \\u0026 Community contributions\\r\\n    /// @param  _colateralTokenOffered  :uint256 Amount of reserve token offered for purchase\\r\\n    function colateralToTokenBuying(uint256 _colateralTokenOffered) external view returns(uint256) {\\r\\n        uint256 correctedForContribution = _colateralTokenOffered.sub(_colateralTokenOffered.div(101)); // Removing 1 percent\\r\\n        return inverseCurveIntegral(curveIntegral(totalSupply_).add(correctedForContribution)).sub(totalSupply_);\\r\\n    }\\r\\n\\r\\n    /// @dev                 This function returns the amount of tokens needed to be burnt to withdraw a specified amount of reserve token\\r\\n    ///                                 Including Protea \\u0026 Community contributions\\r\\n    /// @param  _collateralTokenNeeded  :uint256 Amount of dai to be withdraw\\r\\n    function colateralToTokenSelling(uint256 _collateralTokenNeeded) external view returns(uint256) {\\r\\n        return uint256(\\r\\n            totalSupply_.sub(\\r\\n                inverseCurveIntegral(curveIntegral(totalSupply_).sub(_collateralTokenNeeded))\\r\\n            )\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /// @dev                Calculate the integral from 0 to x tokens supply\\r\\n    /// @param _x            The number of tokens supply to integrate to\\r\\n    /// @return             The total supply in tokens, not wei\\r\\n    function curveIntegral(uint256 _x) internal view returns (uint256) {\\r\\n        /** This is the formula for the curve\\r\\n            f(x) = gradient*(x + b) + c\\r\\n            f(x) indicates it is a function of x, where x is the token supply\\r\\n            the gradient is the gradient of the curve i.e. the change in price over the change in token supply\\r\\n            c is the y-offset, which is set to 0 for now.\\r\\n            For more information visit:\\r\\n            https://en.wikipedia.org/wiki/Linear_function\\r\\n        */\\r\\n\\r\\n        uint256 c = 0;\\r\\n\\r\\n        /* The gradient of a curve is the rate at which it increases its slope.\\r\\n\\t    \\tFor example, to increase at a value of 5 DAI for every 1 token,\\r\\n\\t    \\tour gradient would be (change in y)/(change in x) = 5/1 = 5 DAI/Token\\r\\n\\t    \\tRemember that contracts deal with uint256 integers with 18 decimal points, not floating points, so:\\r\\n\\t    \\tto represent our gradient of 0.0005 DAI/Token, we simply divide by the denominator, to avoid floating points,\\r\\n\\t    \\tso we end up with 1/0.0005 = 2000 as our denominator.\\r\\n\\t    */\\r\\n\\r\\n        /* We need to calculate the definite integral from zero to the defined token supply, x.\\r\\n\\t    \\tA definite integral is essentially the area under the curve, from zero to the defined token supply.\\r\\n\\t    \\tThe area under the curve is equivalent to the value of the tokens up until that point.\\r\\n\\t    \\tThe integral of the linear curve, f(x), is calculated as:\\r\\n\\t    \\tgradient*0.5*x^2 + cx; where c = 0\\r\\n\\t    \\tBecause we are essentially squaring the decimal scaling in the calculation,\\r\\n\\t    \\twe need to divide the result by the scaling factor before returning - this hurt my mind a bit, but mathematically holds true.\\r\\n\\t    */\\r\\n        return ((_x**2).div(2*gradientDenominator_).add(c.mul(_x)).div(10**decimals_));\\r\\n    }\\r\\n    \\r\\n    /// @dev                Inverse integral to convert the incoming colateral value to token volume\\r\\n    /// @param _x           :uint256 The volume to identify the root off\\r\\n    function inverseCurveIntegral(uint256 _x) internal view returns(uint256){\\r\\n        return sqrt(2*_x*gradientDenominator_*(10**decimals_));\\r\\n    }\\r\\n\\r\\n    /// @dev                Babylonian square rooting using while loops\\r\\n    /// @param _x           :uint256 The number to identify the root off\\r\\n    function sqrt(uint256 _x) internal pure returns (uint256) {\\r\\n        if (_x == 0) return 0;\\r\\n        else if (_x \\u003c= 3) return 1;\\r\\n        uint256 z = (_x + 1) / 2;\\r\\n        uint256 y = _x;\\r\\n        while (z \\u003c y)\\r\\n        /// @why3 invariant { to_int !_z = div ((div (to_int arg_x) (to_int !_y)) + (to_int !_y)) 2 }\\r\\n        /// @why3 invariant { to_int arg_x \\u003c (to_int !_y + 1) * (to_int !_y + 1) }\\r\\n        /// @why3 invariant { to_int arg_x \\u003c (to_int !_z + 1) * (to_int !_z + 1) }\\r\\n        /// @why3 variant { to_int !_y }\\r\\n        {\\r\\n            y = z;\\r\\n            z = (_x / z + z) / 2;\\r\\n        }\\r\\n        return y;\\r\\n    }\\r\\n\\r\\n    /// Not needed in this iteration \\r\\n    /// @dev                Bakhashali square rooting using while loops, this increases accuracy for each itteration\\r\\n    // function sqrtBakhshali(uint256 x) public pure returns(uint256) {\\r\\n    //     uint256 n = sqrt(x);\\r\\n    //     for(uint i = 0; i \\u003c= 5; i++) {\\r\\n    //         n = ((n**2)*(n**2 + 6*x) + x**2)/(4*n*(n**2 + x));\\r\\n    //     }\\r\\n    //     return n;\\r\\n    // }\\r\\n}\"},\"BasicLinearTokenManagerFactory.sol\":{\"content\":\"pragma solidity \\u003e=0.5.3 \\u003c 0.6.0;\\r\\n\\r\\nimport { BasicLinearTokenManager } from \\\"./BasicLinearTokenManager.sol\\\";\\r\\nimport { BaseFactory } from \\\"./BaseFactory.sol\\\";\\r\\nimport { ITokenManagerFactory } from \\\"./ITokenManagerFactory.sol\\\";\\r\\n\\r\\ncontract BasicLinearTokenManagerFactory is BaseFactory, ITokenManagerFactory {\\r\\n    constructor(address _rootFactory) public BaseFactory(_rootFactory) {\\r\\n\\r\\n    }\\r\\n    \\r\\n    function deployMarket(\\r\\n        string calldata _name,\\r\\n        string calldata _symbol,\\r\\n        address _reserveToken,\\r\\n        address _proteaAccount,\\r\\n        address _publisher,\\r\\n        uint256 _contributionRate,\\r\\n        address _membershipManager\\r\\n    ) external onlyRootFactory() returns (address) {\\r\\n        return address(\\r\\n            new BasicLinearTokenManager(\\r\\n                _name,\\r\\n                _symbol,\\r\\n                _reserveToken,\\r\\n                _proteaAccount,\\r\\n                _publisher,\\r\\n                _contributionRate,\\r\\n                _membershipManager\\r\\n            )\\r\\n        );\\r\\n    }\\r\\n}\"},\"IERC20.sol\":{\"content\":\"pragma solidity \\u003e=0.5.3 \\u003c 0.6.0;\\r\\n\\r\\n/**\\r\\n * @title ERC20 interface\\r\\n * @dev see https://github.com/ethereum/EIPs/issues/20\\r\\n */\\r\\ninterface IERC20 {\\r\\n  function totalSupply() external view returns (uint256);\\r\\n\\r\\n  function balanceOf(address who) external view returns (uint256);\\r\\n\\r\\n  function allowance(address owner, address spender)\\r\\n    external view returns (uint256);\\r\\n\\r\\n  function transfer(address to, uint256 value) external returns (bool);\\r\\n\\r\\n  function approve(address spender, uint256 value)\\r\\n    external returns (bool);\\r\\n\\r\\n  function transferFrom(address from, address to, uint256 value)\\r\\n    external returns (bool);\\r\\n\\r\\n  event Transfer(\\r\\n    address indexed from,\\r\\n    address indexed to,\\r\\n    uint256 value\\r\\n  );\\r\\n\\r\\n  event Approval(\\r\\n    address indexed owner,\\r\\n    address indexed spender,\\r\\n    uint256 value\\r\\n  );\\r\\n}\\r\\n\"},\"ITokenManagerFactory.sol\":{\"content\":\"pragma solidity \\u003e=0.5.3 \\u003c 0.6.0;\\r\\n\\r\\ninterface ITokenManagerFactory{\\r\\n    function deployMarket(\\r\\n        string calldata _name,\\r\\n        string calldata _symbol,\\r\\n        address _reserveToken,\\r\\n        address _proteaAccount,\\r\\n        address _publisher,\\r\\n        uint256 _contributionRate,\\r\\n        address _membershipManager\\r\\n    ) external returns (address);\\r\\n}\"},\"Roles.sol\":{\"content\":\"pragma solidity \\u003e=0.5.3 \\u003c 0.6.0;\\r\\n\\r\\n/**\\r\\n * @title Roles\\r\\n * @dev Library for managing addresses assigned to a Role.\\r\\n */\\r\\nlibrary Roles {\\r\\n    struct Role {\\r\\n        mapping (address =\\u003e bool) bearer;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev give an account access to this role\\r\\n     */\\r\\n    function add(Role storage role, address account) internal {\\r\\n        require(account != address(0));\\r\\n        require(!has(role, account));\\r\\n\\r\\n        role.bearer[account] = true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev remove an account\\u0027s access to this role\\r\\n     */\\r\\n    function remove(Role storage role, address account) internal {\\r\\n        require(account != address(0));\\r\\n        require(has(role, account));\\r\\n\\r\\n        role.bearer[account] = false;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev check if an account has this role\\r\\n     * @return bool\\r\\n     */\\r\\n    function has(Role storage role, address account)\\r\\n      internal\\r\\n      view\\r\\n      returns (bool)\\r\\n    {\\r\\n        require(account != address(0));\\r\\n        return role.bearer[account];\\r\\n    }\\r\\n}\\r\\n\"},\"SafeMath.sol\":{\"content\":\"pragma solidity \\u003e=0.5.3 \\u003c 0.6.0;\\r\\n\\r\\n/**\\r\\n * @title SafeMath\\r\\n * @dev Math operations with safety checks that revert on error\\r\\n */\\r\\nlibrary SafeMath {\\r\\n\\r\\n  /**\\r\\n  * @dev Multiplies two numbers, reverts on overflow.\\r\\n  */\\r\\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n    // Gas optimization: this is cheaper than requiring \\u0027a\\u0027 not being zero, but the\\r\\n    // benefit is lost if \\u0027b\\u0027 is also tested.\\r\\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\\r\\n    if (a == 0) {\\r\\n      return 0;\\r\\n    }\\r\\n\\r\\n    uint256 c = a * b;\\r\\n    require(c / a == b);\\r\\n\\r\\n    return c;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n  * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\\r\\n  */\\r\\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n    require(b \\u003e 0); // Solidity only automatically asserts when dividing by 0\\r\\n    uint256 c = a / b;\\r\\n    // assert(a == b * c + a % b); // There is no case in which this doesn\\u0027t hold\\r\\n\\r\\n    return c;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n  * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\\r\\n  */\\r\\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n    require(b \\u003c= a);\\r\\n    uint256 c = a - b;\\r\\n\\r\\n    return c;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n  * @dev Adds two numbers, reverts on overflow.\\r\\n  */\\r\\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n    uint256 c = a + b;\\r\\n    require(c \\u003e= a);\\r\\n\\r\\n    return c;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n  * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\\r\\n  * reverts when dividing by zero.\\r\\n  */\\r\\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n    require(b != 0);\\r\\n    return a % b;\\r\\n  }\\r\\n}\\r\\n\"}}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_newRoot\",\"type\":\"address\"}],\"name\":\"removeRootFactory\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newRoot\",\"type\":\"address\"}],\"name\":\"addRootFactory\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_name\",\"type\":\"string\"},{\"name\":\"_symbol\",\"type\":\"string\"},{\"name\":\"_reserveToken\",\"type\":\"address\"},{\"name\":\"_proteaAccount\",\"type\":\"address\"},{\"name\":\"_publisher\",\"type\":\"address\"},{\"name\":\"_contributionRate\",\"type\":\"uint256\"},{\"name\":\"_membershipManager\",\"type\":\"address\"}],\"name\":\"deployMarket\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_rootFactory\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"}]","ContractName":"BasicLinearTokenManagerFactory","CompilerVersion":"v0.5.4+commit.9549d8ff","OptimizationUsed":"1","Runs":"999","ConstructorArguments":"000000000000000000000000c5af5f868eff2f7cc49d7be5362c505bd5bec06a","Library":"","SwarmSource":"bzzr://3b94abf22f3d57068b8fc8726f682da336c724bfefb8bdca4e8018e14a0b350e"}]}