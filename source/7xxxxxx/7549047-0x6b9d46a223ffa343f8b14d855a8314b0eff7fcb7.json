{"status":"1","message":"OK","result":[{"SourceCode":"//\r\n// FormSI060719, which is part of the show \"Garage Politburo\" at Susan Inglett Gallery, NY.\r\n// June 7, 2019 - July 26, 2019\r\n\r\n// For more information see https://github.com/GaragePolitburo/FormSI060719\r\n\r\n// Based on code by OpenZeppelin: \r\n// https://github.com/OpenZeppelin/openzeppelin-solidity/tree/master/contracts/token/ERC721\r\n// Used Jan 4 2019 Open Zepplin package 76abd1a41ec7d96ef76370f3eadfe097226896a2\r\n\r\n// Based also on CryptoPunks by Larva Labs:\r\n// https://github.com/larvalabs/cryptopunks\r\n\r\n// Text snippets taken from Fredric Jameson, Masha Gessen, Nisi Shawl, Margaret Thatcher, \r\n//  Leni Zumas, Philip Roth, Omar El Akkad, Wayne La Pierre, David Graeber,\r\n// Walt Whitman, George Orwell, Rudyard Kipling, and Donna Haraway.\r\n\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @title IERC165\r\n * @dev https://github.com/ethereum/EIPs/blob/master/EIPS/eip-165.md\r\n */\r\ninterface IERC165 {\r\n    /**\r\n     * @notice Query if a contract implements an interface\r\n     * @param interfaceId The interface identifier, as specified in ERC-165\r\n     * @dev Interface identification is specified in ERC-165. This function\r\n     * uses less than 30,000 gas.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\n/**\r\n * @title ERC165\r\n * @author Matt Condon (@shrugs)\r\n * @dev Implements ERC165 using a lookup table.\r\n */\r\ncontract ERC165 is IERC165 {\r\n    bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;\r\n    /**\r\n     * 0x01ffc9a7 ===\r\n     *     bytes4(keccak256('supportsInterface(bytes4)'))\r\n     */\r\n\r\n    /**\r\n     * @dev a mapping of interface id to whether or not it's supported\r\n     */\r\n    mapping(bytes4 => bool) private _supportedInterfaces;\r\n\r\n    /**\r\n     * @dev A contract implementing SupportsInterfaceWithLookup\r\n     * implement ERC165 itself\r\n     */\r\n    constructor () internal {\r\n        _registerInterface(_INTERFACE_ID_ERC165);\r\n    }\r\n\r\n    /**\r\n     * @dev implement supportsInterface(bytes4) using a lookup table\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool) {\r\n        return _supportedInterfaces[interfaceId];\r\n    }\r\n\r\n    /**\r\n     * @dev internal method for registering an interface\r\n     */\r\n    function _registerInterface(bytes4 interfaceId) internal {\r\n        require(interfaceId != 0xffffffff);\r\n        _supportedInterfaces[interfaceId] = true;\r\n    }\r\n}\r\n\r\n\r\n\r\n/**\r\n * @title ERC721 Non-Fungible Token Standard basic interface\r\n * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\r\n */\r\n\r\ncontract IERC721 is IERC165 {\r\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\r\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\r\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n\r\n    function balanceOf(address owner) public view returns (uint256 balance);\r\n    function ownerOf(uint256 tokenId) public view returns (address owner);\r\n\r\n    function approve(address to, uint256 tokenId) public;\r\n    function getApproved(uint256 tokenId) public view returns (address operator);\r\n\r\n    function setApprovalForAll(address operator, bool _approved) public;\r\n    function isApprovedForAll(address owner, address operator) public view returns (bool);\r\n\r\n    function transferFrom(address from, address to, uint256 tokenId) public;\r\n    function safeTransferFrom(address from, address to, uint256 tokenId) public;\r\n\r\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public;\r\n}\r\n\r\n/**\r\n * @title ERC721 token receiver interface\r\n * @dev Interface for any contract that wants to support safeTransfers\r\n * from ERC721 asset contracts.\r\n */\r\ncontract IERC721Receiver {\r\n    /**\r\n     * @notice Handle the receipt of an NFT\r\n     * @dev The ERC721 smart contract calls this function on the recipient\r\n     * after a `safeTransfer`. This function MUST return the function selector,\r\n     * otherwise the caller will revert the transaction. The selector to be\r\n     * returned can be obtained as `this.onERC721Received.selector`. This\r\n     * function MAY throw to revert and reject the transfer.\r\n     * Note: the ERC721 contract address is always the message sender.\r\n     * @param operator The address which called `safeTransferFrom` function\r\n     * @param from The address which previously owned the token\r\n     * @param tokenId The NFT identifier which is being transferred\r\n     * @param data Additional data with no specified format\r\n     * @return `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\r\n     */\r\n    function onERC721Received(address operator, address from, uint256 tokenId, bytes memory data)\r\n    public returns (bytes4);\r\n}\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Unsigned math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n    * @dev Multiplies two unsigned integers, reverts on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two unsigned integers, reverts on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\r\n    * reverts when dividing by zero.\r\n    */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n/**\r\n * Utility library of inline functions on addresses\r\n */\r\nlibrary Address {\r\n    /**\r\n     * Returns whether the target address is a contract\r\n     * @dev This function will return false if invoked during the constructor of a contract,\r\n     * as the code is not actually created until after the constructor finishes.\r\n     * @param account address of the account to check\r\n     * @return whether the target address is a contract\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        uint256 size;\r\n        // XXX Currently there is no better way to check if there is a contract in an address\r\n        // than to check the size of the code at that address.\r\n        // See https://ethereum.stackexchange.com/a/14016/36603\r\n        // for more details about how this works.\r\n        // TODO Check this again before the Serenity release, because all addresses will be\r\n        // contracts then.\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { size := extcodesize(account) }\r\n        return size > 0;\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @title ERC721 Non-Fungible Token Standard basic implementation\r\n * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\r\n */\r\ncontract FormSI060719 is ERC165, IERC721 {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n\r\n    // Equals to `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\r\n    // which can be also obtained as `IERC721Receiver(0).onERC721Received.selector`\r\n    bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;\r\n\r\n    // Mapping from token ID to owner\r\n    mapping (uint256 => address) private _tokenOwner;\r\n\r\n    // Mapping from token ID to approved address\r\n    mapping (uint256 => address) private _tokenApprovals;\r\n\r\n    // Mapping from owner to number of owned token\r\n    mapping (address => uint256) private _ownedTokensCount;\r\n\r\n    // Mapping from owner to operator approvals\r\n    mapping (address => mapping (address => bool)) private _operatorApprovals;\r\n\r\n    bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;\r\n    /*\r\n     * 0x80ac58cd ===\r\n     *     bytes4(keccak256('balanceOf(address)')) ^\r\n     *     bytes4(keccak256('ownerOf(uint256)')) ^\r\n     *     bytes4(keccak256('approve(address,uint256)')) ^\r\n     *     bytes4(keccak256('getApproved(uint256)')) ^\r\n     *     bytes4(keccak256('setApprovalForAll(address,bool)')) ^\r\n     *     bytes4(keccak256('isApprovedForAll(address,address)')) ^\r\n     *     bytes4(keccak256('transferFrom(address,address,uint256)')) ^\r\n     *     bytes4(keccak256('safeTransferFrom(address,address,uint256)')) ^\r\n     *     bytes4(keccak256('safeTransferFrom(address,address,uint256,bytes)'))\r\n     */\r\n\r\n    // FORM\r\n    string private _name = \"FormSI060719 :: Garage Politburo Tokens\";\r\n    string private _symbol = \"SIGP\";\r\n    string[] private _theFormSI060719;\r\n    uint256[2][] private _theIndexToQA; //tokeId gives (questionId, textId)\r\n    uint256[][13] private _theQAtoIndex; // [questionId, textid] gives tokenId\r\n    uint256 private _totalSupply; \r\n    uint256[13] private _supplyPerQ; \r\n    uint256 public numberOfQuestions = 13;\r\n    string[] private _qSection;\r\n    string private _qForm;\r\n\r\n    \r\n    // END FORM\r\n    \r\n    //AUCTION\r\n     \r\n    // Put list element up for sale by owner. Can be linked to specific \r\n    // potential buyer\r\n    struct forSaleInfo {\r\n        bool isForSale;\r\n        uint256 tokenId;\r\n        address seller;\r\n        uint256 minValue;          //in wei.... everything in wei\r\n        address onlySellTo;     // specify to sell only to a specific person\r\n    }\r\n\r\n    // Place bid for specific list element\r\n    struct bidInfo {\r\n        bool hasBid;\r\n        uint256 tokenId;\r\n        address bidder;\r\n        uint256 value;\r\n    }\r\n\r\n    // Public info about tokens for sale.\r\n    mapping (uint256 => forSaleInfo) public marketForSaleInfoByIndex;\r\n    // Public info about highest bid for each token.\r\n    mapping (uint256 => bidInfo) public marketBidInfoByIndex;\r\n    // Information about withdrawals (in units of wei) available  \r\n    //  ... for addresses due to failed bids, successful sales, etc...\r\n    mapping (address => uint256) public marketPendingWithdrawals;\r\n    \r\n    //END AUCTION\r\n    \r\n    //EVENTS\r\n    \r\n    // In addition to Transfer, Approval, and ApprovalForAll IERC721 events\r\n    event QuestionAnswered(uint256 indexed questionId, uint256 indexed answerId, \r\n        address indexed by);\r\n    event ForSaleDeclared(uint256 indexed tokenId, address indexed from, \r\n        uint256 minValue,address indexed to);\r\n    event ForSaleWithdrawn(uint256 indexed tokenId, address indexed from);\r\n    event ForSaleBought(uint256 indexed tokenId, uint256 value, \r\n        address indexed from, address indexed to);\r\n    event BidDeclared(uint256 indexed tokenId, uint256 value, \r\n        address indexed from);\r\n    event BidWithdrawn(uint256 indexed tokenId, uint256 value, \r\n        address indexed from);\r\n    event BidAccepted(uint256 indexed tokenId, uint256 value, \r\n        address indexed from, address indexed to);\r\n    \r\n    //END EVENTS\r\n\r\n    constructor () public {\r\n        // register the supported interfaces to conform to ERC721 via ERC165\r\n        _registerInterface(_INTERFACE_ID_ERC721);\r\n        _qForm = \"FormSI060719 :: freeAssociationAndResponse :: \";\r\n        _qSection.push(\"Section 0-2b :: \");\r\n        _qSection.push(\"Section2-TINA :: \");\r\n        _qSection.push(\"Section2b-WS :: \");\r\n \r\n\r\n        _theFormSI060719.push(\"When we ask ourselves \\\"How are we?\\\" :: we really want to know ::\");\r\n        _theQAtoIndex[0].push(0);\r\n        _theIndexToQA.push([0,0]);\r\n        _tokenOwner[0] = msg.sender;\r\n        _ownedTokensCount[msg.sender] = _ownedTokensCount[msg.sender].add(1);\r\n        _supplyPerQ[0] = 1;\r\n\r\n        _theFormSI060719.push(\"How are we to ensure equitable merit-based access? :: Tried to cut down :: used more than intended :: \");\r\n        _theQAtoIndex[1].push(1);\r\n        _theIndexToQA.push([1,0]);\r\n        _tokenOwner[1] = msg.sender;\r\n        _ownedTokensCount[msg.sender] = _ownedTokensCount[msg.sender].add(1);\r\n        _supplyPerQ[1] = 1;\r\n\r\n        _theFormSI060719.push(\"Psychoanalytic Placement Bureau ::\");\r\n        _theQAtoIndex[2].push(2);\r\n        _theIndexToQA.push([2,0]);\r\n        _tokenOwner[2] = msg.sender;\r\n        _ownedTokensCount[msg.sender] = _ownedTokensCount[msg.sender].add(1);\r\n        _supplyPerQ[2] = 1;\r\n\r\n        _theFormSI060719.push(\"Department of Aspirational Hypocrisy :: Anti-Dishumanitarian League ::\");\r\n        _theQAtoIndex[3].push(3);\r\n        _theIndexToQA.push([3,0]);\r\n        _tokenOwner[3] = msg.sender;\r\n        _ownedTokensCount[msg.sender] = _ownedTokensCount[msg.sender].add(1);\r\n        _supplyPerQ[3] = 1;\r\n\r\n        _theFormSI060719.push(\"Personhood Amendment :: Homestead 42 ::\");\r\n        _theQAtoIndex[4].push(4);\r\n        _theIndexToQA.push([4,0]);\r\n        _tokenOwner[4] = msg.sender;\r\n        _ownedTokensCount[msg.sender] = _ownedTokensCount[msg.sender].add(1);\r\n        _supplyPerQ[4] = 1;\r\n\r\n        _theFormSI060719.push(\"Joint Compensation Office :: Oh how socialists love to make lists ::\");\r\n        _theQAtoIndex[5].push(5);\r\n        _theIndexToQA.push([5,0]);\r\n        _tokenOwner[5] = msg.sender;\r\n        _ownedTokensCount[msg.sender] = _ownedTokensCount[msg.sender].add(1);\r\n        _supplyPerQ[5] = 1;\r\n\r\n        _theFormSI060719.push(\"Division of Confetti Drones and Online Community Standards ::\");\r\n        _theQAtoIndex[6].push(6);\r\n        _theIndexToQA.push([6,0]);\r\n        _tokenOwner[6] = msg.sender;\r\n        _ownedTokensCount[msg.sender] = _ownedTokensCount[msg.sender].add(1);\r\n        _supplyPerQ[6] = 1;\r\n\r\n        _theFormSI060719.push(\"The Secret Joys of Bureaucracy :: Ministry of Splendid Suns :: Ministry of Plenty :: Crime Bureau :: Aerial Board of Control :: Office of Tabletop Assumption :: Central Committee :: Division of Complicity :: Ministry of Information ::\");\r\n        _theQAtoIndex[7].push(7);\r\n        _theIndexToQA.push([7,0]);\r\n        _tokenOwner[7] = msg.sender;\r\n        _ownedTokensCount[msg.sender] = _ownedTokensCount[msg.sender].add(1);\r\n        _supplyPerQ[7] = 1;\r\n\r\n        _theFormSI060719.push(\"We seek droning bureaucracy :: glory :: digital socialist commodities ::\");\r\n        _theQAtoIndex[8].push(8);\r\n        _theIndexToQA.push([8,0]);\r\n        _tokenOwner[8] = msg.sender;\r\n        _ownedTokensCount[msg.sender] = _ownedTokensCount[msg.sender].add(1);\r\n        _supplyPerQ[8] = 1;\r\n\r\n        _theFormSI060719.push(\"Bureau of Rage Embetterment :: machines made of sunshine ::\");\r\n        _theQAtoIndex[9].push(9);\r\n        _theIndexToQA.push([9,0]);\r\n        _tokenOwner[9] = msg.sender;\r\n        _ownedTokensCount[msg.sender] = _ownedTokensCount[msg.sender].add(1);\r\n        _supplyPerQ[9] = 1;\r\n\r\n        _theFormSI060719.push(\"Office of Agency :: seize the means of bureaucratic production ::\");\r\n        _theQAtoIndex[10].push(10);\r\n        _theIndexToQA.push([10,0]);\r\n        _tokenOwner[10] = msg.sender;\r\n        _ownedTokensCount[msg.sender] = _ownedTokensCount[msg.sender].add(1);\r\n        _supplyPerQ[10] = 1;\r\n\r\n        _theFormSI060719.push(\"Garage Politburo :: Boutique Ministry ::\");\r\n        _theQAtoIndex[11].push(11);\r\n        _theIndexToQA.push([11,0]);\r\n        _tokenOwner[11] = msg.sender;\r\n        _ownedTokensCount[msg.sender] = _ownedTokensCount[msg.sender].add(1);\r\n        _supplyPerQ[11] = 1;\r\n\r\n        _theFormSI060719.push(\"Grassroots :: Tabletop :: Bureaucracy Saves! ::\"); \r\n        _theQAtoIndex[12].push(12);\r\n        _theIndexToQA.push([12,0]);\r\n        _tokenOwner[12] = msg.sender;\r\n        _ownedTokensCount[msg.sender] = _ownedTokensCount[msg.sender].add(1);\r\n        _supplyPerQ[12] = 1;\r\n\r\n        _totalSupply = 13;\r\n        assert (_totalSupply == numberOfQuestions);\r\n        assert (_totalSupply == _ownedTokensCount[msg.sender]);\r\n        \r\n    }\r\n\r\n    //Begin Form\r\n\r\n\r\n    function name() external view returns (string memory){\r\n       return _name;\r\n    }\r\n\r\n    function totalSupply() external view returns (uint256){\r\n       return _totalSupply;\r\n    }\r\n\r\n\r\n    function symbol() external view returns (string memory){\r\n       return _symbol;\r\n    }\r\n\r\n\r\n    // questionId goes from 0 to numberOfQuestions - 1    \r\n    function getFormQuestion(uint256 questionId)\r\n        public view\r\n        returns (string memory){\r\n            \r\n        return (_getQAtext(questionId, 0));\r\n            \r\n    }\r\n    \r\n    // questionId goes from 0 to numberOfQuestions - 1  \r\n    // answerId goes from 1 to _supplyPerQ - 1\r\n    // If there are no answers to questionId, this function reverts\r\n    function getFormAnswers(uint256 questionId, uint256 answerId)\r\n        public view\r\n        returns (string memory){\r\n            \r\n        require (answerId > 0);\r\n        return (_getQAtext(questionId, answerId));\r\n            \r\n    }    \r\n\r\n \r\n    function _getQAtext(uint256 questionId, uint256 textId)\r\n        private view \r\n        returns (string memory){\r\n    \r\n        require (questionId < numberOfQuestions);\r\n        require (textId < _supplyPerQ[questionId]);\r\n       \r\n        if (textId > 0){\r\n          return (_theFormSI060719[_theQAtoIndex[questionId][textId]]);\r\n        }\r\n\r\n        else {\r\n            bytes memory qPrefix;\r\n            if (questionId <= 1) {\r\n                qPrefix = bytes(_qSection[0]);\r\n            }\r\n            if ((questionId >= 2) && (questionId <= 6)){\r\n                qPrefix = bytes(_qSection[1]);\r\n            }\r\n            if (questionId >= 7){\r\n                qPrefix = bytes(_qSection[2]);\r\n            }\r\n            return (string(abi.encodePacked(bytes(_qForm), qPrefix, \r\n                bytes(_theFormSI060719[_theQAtoIndex[questionId][textId]]))));\r\n        }\r\n            \r\n    }\r\n      \r\n     function answerQuestion(uint256 questionId, string calldata answer)\r\n        external\r\n        returns (bool){\r\n\r\n        require (questionId < numberOfQuestions);\r\n        require (bytes(answer).length != 0);\r\n        _theFormSI060719.push(answer);\r\n        _totalSupply = _totalSupply.add(1);\r\n        _supplyPerQ[questionId] = _supplyPerQ[questionId].add(1);\r\n        _theQAtoIndex[questionId].push(_totalSupply - 1);\r\n        _theIndexToQA.push([questionId, _supplyPerQ[questionId] - 1]);\r\n        _tokenOwner[_totalSupply - 1] = msg.sender;\r\n        _ownedTokensCount[msg.sender] = _ownedTokensCount[msg.sender].add(1);\r\n        emit QuestionAnswered(questionId, _supplyPerQ[questionId] - 1,\r\n            msg.sender);\r\n       return true;\r\n    }\r\n    \r\n    // Returns index of ERC721 token\r\n    // questionId start with index 0\r\n    // textId 0 returns the question text associated with questionId\r\n    // textId 1 returns the first answer to questionId, etc...\r\n    function getIndexfromQA(uint256 questionId, uint256 textId)\r\n        public view\r\n        returns (uint256) {\r\n            \r\n        require (questionId < numberOfQuestions);\r\n        require (textId < _supplyPerQ[questionId]);\r\n        return _theQAtoIndex[questionId][textId];\r\n    }\r\n\r\n    // Returns (questionId, textId) \r\n    // questionId starts with index 0\r\n    // textId starts with index 0\r\n    // textId = 0 corresponds to question text\r\n    // textId > 0 corresponts to answers\r\n    \r\n    function getQAfromIndex(uint256 tokenId)\r\n        public view\r\n        returns (uint256[2] memory) {\r\n            \r\n        require (tokenId < _totalSupply);\r\n        return ([_theIndexToQA[tokenId][0] ,_theIndexToQA[tokenId][1]]) ;\r\n    }\r\n        \r\n    function getNumberOfAnswers(uint256 questionId)\r\n        public view\r\n        returns (uint256){\r\n        \r\n        require (questionId < numberOfQuestions);\r\n        return (_supplyPerQ[questionId] - 1);\r\n        \r\n    }\r\n    //End Form\r\n\r\n \r\n    /**\r\n     * @dev Gets the balance of the specified address\r\n     * @param owner address to query the balance of\r\n     * @return uint256 representing the amount owned by the passed address\r\n     */\r\n    function balanceOf(address owner) public view returns (uint256) {\r\n        require(owner != address(0));\r\n        return _ownedTokensCount[owner];\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the owner of the specified token ID\r\n     * @param tokenId uint256 ID of the token to query the owner of\r\n     * @return owner address currently marked as the owner of the given token ID\r\n     */\r\n    function ownerOf(uint256 tokenId) public view returns (address) {\r\n        address owner = _tokenOwner[tokenId];\r\n        require(owner != address(0));\r\n        return owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Approves another address to transfer the given token ID\r\n     * The zero address indicates there is no approved address.\r\n     * There can only be one approved address per token at a given time.\r\n     * Can only be called by the token owner or an approved operator.\r\n     * @param to address to be approved for the given token ID\r\n     * @param tokenId uint256 ID of the token to be approved\r\n     */\r\n    function approve(address to, uint256 tokenId) public {\r\n        address owner = ownerOf(tokenId);\r\n        require(to != owner);\r\n        require(msg.sender == owner || isApprovedForAll(owner, msg.sender));\r\n\r\n        _tokenApprovals[tokenId] = to;\r\n        emit Approval(owner, to, tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the approved address for a token ID, or zero if no address set\r\n     * Reverts if the token ID does not exist.\r\n     * @param tokenId uint256 ID of the token to query the approval of\r\n     * @return address currently approved for the given token ID\r\n     */\r\n    function getApproved(uint256 tokenId) public view returns (address) {\r\n        require(_exists(tokenId));\r\n        return _tokenApprovals[tokenId];\r\n    }\r\n\r\n    /**\r\n     * @dev Sets or unsets the approval of a given operator\r\n     * An operator is allowed to transfer all tokens of the sender on their behalf\r\n     * @param to operator address to set the approval\r\n     * @param approved representing the status of the approval to be set\r\n     */\r\n    function setApprovalForAll(address to, bool approved) public {\r\n        require(to != msg.sender);\r\n        _operatorApprovals[msg.sender][to] = approved;\r\n        emit ApprovalForAll(msg.sender, to, approved);\r\n    }\r\n\r\n    /**\r\n     * @dev Tells whether an operator is approved by a given owner\r\n     * @param owner owner address which you want to query the approval of\r\n     * @param operator operator address which you want to query the approval of\r\n     * @return bool whether the given operator is approved by the given owner\r\n     */\r\n    function isApprovedForAll(address owner, address operator) public view returns (bool) {\r\n        return _operatorApprovals[owner][operator];\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers the ownership of a given token ID to another address\r\n     * Usage of this method is discouraged, use `safeTransferFrom` whenever possible\r\n     * Requires the msg sender to be the owner, approved, or operator\r\n     * @param from current owner of the token\r\n     * @param to address to receive the ownership of the given token ID\r\n     * @param tokenId uint256 ID of the token to be transferred\r\n    */\r\n    function transferFrom(address from, address to, uint256 tokenId) public {\r\n        // this checks if token exists\r\n        require(_isApprovedOrOwner(msg.sender, tokenId));\r\n\r\n        // remove for sale, if it exists.\r\n        if (marketForSaleInfoByIndex[tokenId].isForSale){\r\n            marketForSaleInfoByIndex[tokenId] = forSaleInfo(false, tokenId, \r\n             address(0), 0, address(0));\r\n            emit ForSaleWithdrawn(tokenId, _tokenOwner[tokenId]);\r\n        }\r\n        _transferFrom(from, to, tokenId);\r\n        \r\n        // remove bid of recipient (and now new owner), if it exists.\r\n        // Need to do this since marketWithdrawBid requires that msg.sender not owner.\r\n        if (marketBidInfoByIndex[tokenId].bidder == to){\r\n            _clearNewOwnerBid(to, tokenId);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Safely transfers the ownership of a given token ID to another address\r\n     * If the target address is a contract, it must implement `onERC721Received`,\r\n     * which is called upon a safe transfer, and return the magic value\r\n     * `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`; otherwise,\r\n     * the transfer is reverted.\r\n     *\r\n     * Requires the msg sender to be the owner, approved, or operator\r\n     * @param from current owner of the token\r\n     * @param to address to receive the ownership of the given token ID\r\n     * @param tokenId uint256 ID of the token to be transferred\r\n    */\r\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\r\n        safeTransferFrom(from, to, tokenId, \"\");\r\n    }\r\n\r\n    /**\r\n     * @dev Safely transfers the ownership of a given token ID to another address\r\n     * If the target address is a contract, it must implement `onERC721Received`,\r\n     * which is called upon a safe transfer, and return the magic value\r\n     * `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`; otherwise,\r\n     * the transfer is reverted.\r\n     * Requires the msg sender to be the owner, approved, or operator\r\n     * @param from current owner of the token\r\n     * @param to address to receive the ownership of the given token ID\r\n     * @param tokenId uint256 ID of the token to be transferred\r\n     * @param _data bytes data to send along with a safe transfer check\r\n     */\r\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) public {\r\n        transferFrom(from, to, tokenId);\r\n        require(_checkOnERC721Received(from, to, tokenId, _data));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns whether the specified token exists\r\n     * @param tokenId uint256 ID of the token to query the existence of\r\n     * @return whether the token exists\r\n     */\r\n    function _exists(uint256 tokenId) internal view returns (bool) {\r\n        address owner = _tokenOwner[tokenId];\r\n        return owner != address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns whether the given spender can transfer a given token ID\r\n     * @param spender address of the spender to query\r\n     * @param tokenId uint256 ID of the token to be transferred\r\n     * @return bool whether the msg.sender is approved for the given token ID,\r\n     *    is an operator of the owner, or is the owner of the token\r\n     */\r\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view returns (bool) {\r\n        address owner = ownerOf(tokenId);\r\n        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\r\n    }\r\n\r\n\r\n\r\n    /**\r\n     * @dev Internal function to transfer ownership of a given token ID to another address.\r\n     * As opposed to transferFrom, this imposes no restrictions on msg.sender.\r\n     * @param from current owner of the token\r\n     * @param to address to receive the ownership of the given token ID\r\n     * @param tokenId uint256 ID of the token to be transferred\r\n    */\r\n    function _transferFrom(address from, address to, uint256 tokenId) internal {\r\n        require(ownerOf(tokenId) == from);\r\n        require(to != address(0));\r\n\r\n        _clearApproval(tokenId);\r\n\r\n        _ownedTokensCount[from] = _ownedTokensCount[from].sub(1);\r\n        _ownedTokensCount[to] = _ownedTokensCount[to].add(1);\r\n\r\n        _tokenOwner[tokenId] = to;\r\n\r\n        emit Transfer(from, to, tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to invoke `onERC721Received` on a target address\r\n     * The call is not executed if the target address is not a contract\r\n     * @param from address representing the previous owner of the given token ID\r\n     * @param to target address that will receive the tokens\r\n     * @param tokenId uint256 ID of the token to be transferred\r\n     * @param _data bytes optional data to send along with the call\r\n     * @return whether the call correctly returned the expected magic value\r\n     */\r\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory _data)\r\n        internal returns (bool)\r\n    {\r\n        if (!to.isContract()) {\r\n            return true;\r\n        }\r\n\r\n        bytes4 retval = IERC721Receiver(to).onERC721Received(msg.sender, from, tokenId, _data);\r\n        return (retval == _ERC721_RECEIVED);\r\n    }\r\n\r\n    /**\r\n     * @dev Private function to clear current approval of a given token ID\r\n     * @param tokenId uint256 ID of the token to be transferred\r\n     */\r\n    function _clearApproval(uint256 tokenId) private {\r\n        if (_tokenApprovals[tokenId] != address(0)) {\r\n            _tokenApprovals[tokenId] = address(0);\r\n        }\r\n    }\r\n    \r\n        //MARKET\r\n\r\n    // Let anyone interested know that the owner put a token up for sale. \r\n    // Anyone can obtain it by sending an amount of wei equal to or\r\n    // larger than  _minPriceInWei. \r\n    // Only token owner can use this function.\r\n\r\n    function marketDeclareForSale(uint256 tokenId, uint256 minPriceInWei) \r\n            external returns (bool){\r\n        require (_exists(tokenId));\r\n        require (msg.sender == _tokenOwner[tokenId]);\r\n        marketForSaleInfoByIndex[tokenId] = forSaleInfo(true, tokenId, \r\n            msg.sender, minPriceInWei, address(0));\r\n        emit ForSaleDeclared(tokenId, msg.sender, minPriceInWei, address(0));\r\n        return true;\r\n    }\r\n    \r\n    // Let anyone interested know that the owner put a token up for sale. \r\n    // Only the address _to can obtain it by sending an amount of wei equal \r\n    // to or larger than _minPriceInWei.\r\n    // Only token owner can use this function.\r\n\r\n    function marketDeclareForSaleToAddress(uint256 tokenId, uint256 \r\n            minPriceInWei, address to) external returns(bool){\r\n        require (_exists(tokenId));\r\n        require (msg.sender == _tokenOwner[tokenId]);\r\n        marketForSaleInfoByIndex[tokenId] = forSaleInfo(true, tokenId, \r\n            msg.sender, minPriceInWei, to);\r\n        emit ForSaleDeclared(tokenId, msg.sender, minPriceInWei, to);\r\n        return true;\r\n    }\r\n\r\n    // Owner no longer wants token for sale, or token has changed owner, \r\n    // so previously posted for sale is no longer valid.\r\n    // Only token owner can use this function.\r\n\r\n    function marketWithdrawForSale(uint256 tokenId) public returns(bool){\r\n        require (_exists(tokenId));\r\n        require(msg.sender == _tokenOwner[tokenId]);\r\n        marketForSaleInfoByIndex[tokenId] = forSaleInfo(false, tokenId, \r\n            address(0), 0, address(0));\r\n        emit ForSaleWithdrawn(tokenId, msg.sender);\r\n        return true;\r\n    }\r\n    \r\n    // I'll take it. Must send at least as many wei as minValue in \r\n    // forSale structure.\r\n\r\n    function marketBuyForSale(uint256 tokenId) payable external returns(bool){\r\n        require (_exists(tokenId));\r\n        forSaleInfo storage existingForSale = marketForSaleInfoByIndex[tokenId];\r\n        require(existingForSale.isForSale);\r\n        require(existingForSale.onlySellTo == address(0) || \r\n            existingForSale.onlySellTo == msg.sender);\r\n        require(msg.value >= existingForSale.minValue);\r\n        address seller = _tokenOwner[tokenId];\r\n        require(existingForSale.seller == seller);\r\n        _transferFrom(seller, msg.sender, tokenId);\r\n        // must withdrawal for sale after transfer to make sure msg.sender\r\n        //  is the current owner.\r\n        marketWithdrawForSale(tokenId);\r\n        // clear bid of new owner, if it exists. \r\n        if (marketBidInfoByIndex[tokenId].bidder == msg.sender){\r\n            _clearNewOwnerBid(msg.sender, tokenId);\r\n        }\r\n        marketPendingWithdrawals[seller] = marketPendingWithdrawals[seller].add(msg.value);\r\n        emit ForSaleBought(tokenId, msg.value, seller, msg.sender);\r\n        return true;\r\n    }\r\n    \r\n    // Potential buyer puts up money for a token.\r\n\r\n    function marketDeclareBid(uint256 tokenId) payable external returns(bool){\r\n        require (_exists(tokenId));\r\n        require (_tokenOwner[tokenId] != msg.sender);\r\n        require (msg.value > 0);\r\n        bidInfo storage existingBid = marketBidInfoByIndex[tokenId];\r\n        // Keep only the highest bid.\r\n        require (msg.value > existingBid.value);\r\n        if (existingBid.value > 0){             \r\n            marketPendingWithdrawals[existingBid.bidder] = \r\n            marketPendingWithdrawals[existingBid.bidder].add(existingBid.value);\r\n        }\r\n        marketBidInfoByIndex[tokenId] = bidInfo(true, tokenId, \r\n            msg.sender, msg.value);\r\n        emit BidDeclared(tokenId, msg.value, msg.sender);\r\n        return true;\r\n    }\r\n    \r\n    // Potential buyer changes mind and withdrawals bid.\r\n\r\n    function marketWithdrawBid(uint256 tokenId) external returns(bool){\r\n        require (_exists(tokenId));\r\n        require (_tokenOwner[tokenId] != msg.sender); \r\n        bidInfo storage existingBid = marketBidInfoByIndex[tokenId];\r\n        require (existingBid.hasBid);\r\n        require (existingBid.bidder == msg.sender);\r\n        uint256 amount = existingBid.value;\r\n        // Refund\r\n        marketPendingWithdrawals[existingBid.bidder] =\r\n            marketPendingWithdrawals[existingBid.bidder].add(amount);\r\n        marketBidInfoByIndex[tokenId] = bidInfo(false, tokenId, address(0), 0);\r\n        emit BidWithdrawn(tokenId, amount, msg.sender);\r\n        return true;\r\n    }\r\n    \r\n    // Owner accepts bid, and money and token change hands. All money in wei.\r\n    // Only token owner can use this function.\r\n\r\n    function marketAcceptBid(uint256 tokenId, uint256 minPrice) \r\n            external returns(bool){\r\n        require (_exists(tokenId));\r\n        address seller = _tokenOwner[tokenId];\r\n        require (seller == msg.sender);\r\n        bidInfo storage existingBid = marketBidInfoByIndex[tokenId];\r\n        require (existingBid.hasBid);\r\n        require (existingBid.value >= minPrice);\r\n        address buyer = existingBid.bidder;\r\n        // Remove for sale while msg.sender still owner or approved.\r\n        marketWithdrawForSale(tokenId);\r\n        _transferFrom (seller, buyer, tokenId);\r\n        uint256 amount = existingBid.value;\r\n        // Remove bid.\r\n        marketBidInfoByIndex[tokenId] = bidInfo(false, tokenId, address(0),0);\r\n        marketPendingWithdrawals[seller] = marketPendingWithdrawals[seller].add(amount);\r\n        emit BidAccepted(tokenId, amount, seller, buyer);\r\n        return true;\r\n    }\r\n    \r\n    // Retrieve money to successful sale, failed bid, withdrawn bid, etc.\r\n    //  All in wei. Note that refunds, income, etc. are NOT automatically\r\n    // deposited in the user's address. The user must withdraw the funds.\r\n\r\n    function marketWithdrawWei() external returns(bool) {\r\n       uint256 amount = marketPendingWithdrawals[msg.sender];\r\n       require (amount > 0);\r\n       marketPendingWithdrawals[msg.sender] = 0;\r\n       msg.sender.transfer(amount);\r\n       return true;\r\n    } \r\n\r\n    // Clears bid when become owner changes via forSaleBuy or transferFrom.\r\n    \r\n    function _clearNewOwnerBid(address to, uint256 tokenId) internal {\r\n\r\n        uint256 amount = marketBidInfoByIndex[tokenId].value;\r\n        marketBidInfoByIndex[tokenId] = bidInfo(false, tokenId, \r\n            address(0), 0);\r\n        marketPendingWithdrawals[to] = marketPendingWithdrawals[to].add(amount);\r\n        emit BidWithdrawn(tokenId, amount, to);\r\n\r\n      \r\n    }\r\n    \r\n    \r\n    //END MARKET\r\n    \r\n    \r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"marketBuyForSale\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"marketDeclareBid\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"questionId\",\"type\":\"uint256\"},{\"name\":\"textId\",\"type\":\"uint256\"}],\"name\":\"getIndexfromQA\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"marketWithdrawBid\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"questionId\",\"type\":\"uint256\"},{\"name\":\"answer\",\"type\":\"string\"}],\"name\":\"answerQuestion\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"marketWithdrawWei\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenId\",\"type\":\"uint256\"},{\"name\":\"minPriceInWei\",\"type\":\"uint256\"},{\"name\":\"to\",\"type\":\"address\"}],\"name\":\"marketDeclareForSaleToAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"marketForSaleInfoByIndex\",\"outputs\":[{\"name\":\"isForSale\",\"type\":\"bool\"},{\"name\":\"tokenId\",\"type\":\"uint256\"},{\"name\":\"seller\",\"type\":\"address\"},{\"name\":\"minValue\",\"type\":\"uint256\"},{\"name\":\"onlySellTo\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenId\",\"type\":\"uint256\"},{\"name\":\"minPriceInWei\",\"type\":\"uint256\"}],\"name\":\"marketDeclareForSale\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"questionId\",\"type\":\"uint256\"},{\"name\":\"answerId\",\"type\":\"uint256\"}],\"name\":\"getFormAnswers\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"marketPendingWithdrawals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"numberOfQuestions\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"tokenId\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getQAfromIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[2]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"questionId\",\"type\":\"uint256\"}],\"name\":\"getFormQuestion\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"marketBidInfoByIndex\",\"outputs\":[{\"name\":\"hasBid\",\"type\":\"bool\"},{\"name\":\"tokenId\",\"type\":\"uint256\"},{\"name\":\"bidder\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenId\",\"type\":\"uint256\"},{\"name\":\"minPrice\",\"type\":\"uint256\"}],\"name\":\"marketAcceptBid\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"marketWithdrawForSale\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"questionId\",\"type\":\"uint256\"}],\"name\":\"getNumberOfAnswers\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"questionId\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"answerId\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"by\",\"type\":\"address\"}],\"name\":\"QuestionAnswered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"minValue\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"}],\"name\":\"ForSaleDeclared\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"}],\"name\":\"ForSaleWithdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"}],\"name\":\"ForSaleBought\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"}],\"name\":\"BidDeclared\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"}],\"name\":\"BidWithdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"}],\"name\":\"BidAccepted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"}]","ContractName":"FormSI060719","CompilerVersion":"v0.5.7+commit.6da8b019","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://ae82db8a099c17dcfa656e82de147ff7a47fd8e517464919401d1b305de6b11e"}]}