{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.17;\r\n\r\n// File: contracts/iERC20Token.sol\r\n\r\n// Abstract contract for the full ERC 20 Token standard\r\n// https://github.com/ConsenSys/Tokens\r\n// https://github.com/ethereum/EIPs/issues/20\r\npragma solidity ^0.4.17;\r\n\r\n\r\n/// @title iERC20Token contract\r\ncontract iERC20Token {\r\n\r\n    // FIELDS\r\n\r\n    \r\n    uint256 public totalSupply = 0;\r\n    bytes32 public name;// token name, e.g, pounds for fiat UK pounds.\r\n    uint8 public decimals;// How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.\r\n    bytes32 public symbol;// An identifier: eg SBX.\r\n\r\n\r\n    // NON-CONSTANT METHODS\r\n\r\n    /// @dev send `_value` tokens to `_to` address/wallet from `msg.sender`.\r\n    /// @param _to The address of the recipient.\r\n    /// @param _value The amount of token to be transferred.\r\n    /// @return Whether the transfer was successful or not.\r\n    function transfer(address _to, uint256 _value) public returns (bool success);\r\n\r\n    /// @dev send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n    /// @param _from The address of the sender\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\r\n\r\n    /// @dev `msg.sender` approves `_spender` to spend `_value` tokens.\r\n    /// @param _spender The address of the account able to transfer the tokens.\r\n    /// @param _value The amount of tokens to be approved for transfer.\r\n    /// @return Whether the approval was successful or not.\r\n    function approve(address _spender, uint256 _value) public returns (bool success);\r\n\r\n    // CONSTANT METHODS\r\n\r\n    /** @dev Checks the balance of an address without changing the state of the blockchain.\r\n      * @param _owner The address to check.\r\n      * @return balance An unsigned integer representing the token balance of the address.\r\n      */\r\n    function balanceOf(address _owner) public view returns (uint256 balance);\r\n\r\n    /** @dev Checks for the balance of the tokens of that which the owner had approved another address owner to spend.\r\n      * @param _owner The address of the token owner.\r\n      * @param _spender The address of the allowed spender.\r\n      * @return remaining An unsigned integer representing the remaining approved tokens.\r\n      */\r\n    function allowance(address _owner, address _spender) public view returns (uint256 remaining);\r\n\r\n\r\n    // EVENTS\r\n\r\n    // An event triggered when a transfer of tokens is made from a _from address to a _to address.\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    // An event triggered when an owner of tokens successfully approves another address to spend a specified amount of tokens.\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}\r\n\r\n// File: contracts/CurrencyToken.sol\r\n\r\n/// @title CurrencyToken contract\r\ncontract CurrencyToken {\r\n\r\n    address public server; // Address, which the platform website uses.\r\n    address public populous; // Address of the Populous bank contract.\r\n\r\n    uint256 public totalSupply;\r\n    bytes32 public name;// token name, e.g, pounds for fiat UK pounds.\r\n    uint8 public decimals;// How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.\r\n    bytes32 public symbol;// An identifier: eg SBX.\r\n\r\n    uint256 constant private MAX_UINT256 = 2**256 - 1;\r\n    mapping (address => uint256) public balances;\r\n    mapping (address => mapping (address => uint256)) public allowed;\r\n    //EVENTS\r\n    // An event triggered when a transfer of tokens is made from a _from address to a _to address.\r\n    event Transfer(\r\n        address indexed _from, \r\n        address indexed _to, \r\n        uint256 _value\r\n    );\r\n    // An event triggered when an owner of tokens successfully approves another address to spend a specified amount of tokens.\r\n    event Approval(\r\n        address indexed _owner, \r\n        address indexed _spender, \r\n        uint256 _value\r\n    );\r\n    event EventMintTokens(bytes32 currency, address owner, uint amount);\r\n    event EventDestroyTokens(bytes32 currency, address owner, uint amount);\r\n\r\n\r\n    // MODIFIERS\r\n\r\n    modifier onlyServer {\r\n        require(isServer(msg.sender) == true);\r\n        _;\r\n    }\r\n\r\n    modifier onlyServerOrOnlyPopulous {\r\n        require(isServer(msg.sender) == true || isPopulous(msg.sender) == true);\r\n        _;\r\n    }\r\n\r\n    modifier onlyPopulous {\r\n        require(isPopulous(msg.sender) == true);\r\n        _;\r\n    }\r\n    // NON-CONSTANT METHODS\r\n    \r\n    /** @dev Creates a new currency/token.\r\n      * param _decimalUnits The decimal units/places the token can have.\r\n      * param _tokenSymbol The token's symbol, e.g., GBP.\r\n      * param _decimalUnits The tokens decimal unites/precision\r\n      * param _amount The amount of tokens to create upon deployment\r\n      * param _owner The owner of the tokens created upon deployment\r\n      * param _server The server/admin address\r\n      */\r\n    function CurrencyToken ()\r\n        public\r\n    {\r\n        populous = server = 0xf8B3d742B245Ec366288160488A12e7A2f1D720D;\r\n        symbol = name = 0x55534443; // Set the name for display purposes\r\n        decimals = 6; // Amount of decimals for display purposes\r\n        balances[server] = safeAdd(balances[server], 10000000000000000);\r\n        totalSupply = safeAdd(totalSupply, 10000000000000000);\r\n    }\r\n\r\n    // ERC20\r\n\r\n    /** @dev Mints a specified amount of tokens \r\n      * @param owner The token owner.\r\n      * @param amount The amount of tokens to create.\r\n      */\r\n    function mint(uint amount, address owner) public onlyServerOrOnlyPopulous returns (bool success) {\r\n        balances[owner] = safeAdd(balances[owner], amount);\r\n        totalSupply = safeAdd(totalSupply, amount);\r\n        emit EventMintTokens(symbol, owner, amount);\r\n        return true;\r\n    }\r\n\r\n    /** @dev Destroys a specified amount of tokens \r\n      * @dev The method uses a modifier from withAccessManager contract to only permit populous to use it.\r\n      * @dev The method uses SafeMath to carry out safe token deductions/subtraction.\r\n      * @param amount The amount of tokens to create.\r\n      */\r\n    function destroyTokens(uint amount) public onlyServerOrOnlyPopulous returns (bool success) {\r\n        require(balances[msg.sender] >= amount);\r\n        balances[msg.sender] = safeSub(balances[msg.sender], amount);\r\n        totalSupply = safeSub(totalSupply, amount);\r\n        emit EventDestroyTokens(symbol, populous, amount);\r\n        return true;\r\n    }\r\n    \r\n    /** @dev Destroys a specified amount of tokens, from a user.\r\n      * @dev The method uses a modifier from withAccessManager contract to only permit populous to use it.\r\n      * @dev The method uses SafeMath to carry out safe token deductions/subtraction.\r\n      * @param amount The amount of tokens to create.\r\n      */\r\n    function destroyTokensFrom(uint amount, address from) public onlyServerOrOnlyPopulous returns (bool success) {\r\n        require(balances[from] >= amount);\r\n        balances[from] = safeSub(balances[from], amount);\r\n        totalSupply = safeSub(totalSupply, amount);\r\n        emit EventDestroyTokens(symbol, from, amount);\r\n        return true;\r\n    }\r\n\r\n    function transfer(address _to, uint256 _value) public returns (bool success) {\r\n        require(balances[msg.sender] >= _value);\r\n        balances[msg.sender] -= _value;\r\n        balances[_to] += _value;\r\n        Transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\r\n        uint256 allowance = allowed[_from][msg.sender];\r\n        require(balances[_from] >= _value && allowance >= _value);\r\n        balances[_to] += _value;\r\n        balances[_from] -= _value;\r\n        if (allowance < MAX_UINT256) {\r\n            allowed[_from][msg.sender] -= _value;\r\n        }\r\n        Transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    function balanceOf(address _owner) public view returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) public returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n\r\n    // ACCESS MANAGER\r\n\r\n    /** @dev Checks a given address to determine whether it is populous address.\r\n      * @param sender The address to be checked.\r\n      * @return bool returns true or false is the address corresponds to populous or not.\r\n      */\r\n    function isPopulous(address sender) public view returns (bool) {\r\n        return sender == populous;\r\n    }\r\n\r\n        /** @dev Changes the populous contract address.\r\n      * @dev The method requires the message sender to be the set server.\r\n      * @param _populous The address to be set as populous.\r\n      */\r\n    function changePopulous(address _populous) public {\r\n        require(isServer(msg.sender) == true);\r\n        populous = _populous;\r\n    }\r\n\r\n    // CONSTANT METHODS\r\n    \r\n    /** @dev Checks a given address to determine whether it is the server.\r\n      * @param sender The address to be checked.\r\n      * @return bool returns true or false is the address corresponds to the server or not.\r\n      */\r\n    function isServer(address sender) public view returns (bool) {\r\n        return sender == server;\r\n    }\r\n\r\n    /** @dev Changes the server address that is set by the constructor.\r\n      * @dev The method requires the message sender to be the set server.\r\n      * @param _server The new address to be set as the server.\r\n      */\r\n    function changeServer(address _server) public {\r\n        require(isServer(msg.sender) == true);\r\n        server = _server;\r\n    }\r\n\r\n\r\n    // SAFE MATH\r\n\r\n\r\n      /** @dev Safely multiplies two unsigned/non-negative integers.\r\n    * @dev Ensures that one of both numbers can be derived from dividing the product by the other.\r\n    * @param a The first number.\r\n    * @param b The second number.\r\n    * @return uint The expected result.\r\n    */\r\n    function safeMul(uint a, uint b) internal pure returns (uint) {\r\n        uint c = a * b;\r\n        assert(a == 0 || c / a == b);\r\n        return c;\r\n    }\r\n\r\n  /** @dev Safely subtracts one number from another\r\n    * @dev Ensures that the number to subtract is lower.\r\n    * @param a The first number.\r\n    * @param b The second number.\r\n    * @return uint The expected result.\r\n    */\r\n    function safeSub(uint a, uint b) internal pure returns (uint) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n  /** @dev Safely adds two unsigned/non-negative integers.\r\n    * @dev Ensures that the sum of both numbers is greater or equal to one of both.\r\n    * @param a The first number.\r\n    * @param b The second number.\r\n    * @return uint The expected result.\r\n    */\r\n    function safeAdd(uint a, uint b) internal pure returns (uint) {\r\n        uint c = a + b;\r\n        assert(c>=a && c>=b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        uint256 c = a / b;\r\n        assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n}\r\n\r\n// File: contracts/AccessManager.sol\r\n\r\n/// @title AccessManager contract\r\ncontract AccessManager {\r\n    // FIELDS\r\n\r\n    // fields that can be changed by constructor and functions\r\n\r\n    address public server; // Address, which the platform website uses.\r\n    address public populous; // Address of the Populous bank contract.\r\n\r\n    // NON-CONSTANT METHODS\r\n\r\n    /** @dev Constructor that sets the server when contract is deployed.\r\n      * @param _server The address to set as the server.\r\n      */\r\n    function AccessManager(address _server) public {\r\n        server = _server;\r\n        //guardian = _guardian;\r\n    }\r\n\r\n    /** @dev Changes the server address that is set by the constructor.\r\n      * @dev The method requires the message sender to be the set server.\r\n      * @param _server The new address to be set as the server.\r\n      */\r\n    function changeServer(address _server) public {\r\n        require(isServer(msg.sender) == true);\r\n        server = _server;\r\n    }\r\n\r\n    /** @dev Changes the guardian address that is set by the constructor.\r\n      * @dev The method requires the message sender to be the set guardian.\r\n      */\r\n    /* function changeGuardian(address _guardian) public {\r\n        require(isGuardian(msg.sender) == true);\r\n        guardian = _guardian;\r\n    } */\r\n\r\n    /** @dev Changes the populous contract address.\r\n      * @dev The method requires the message sender to be the set server.\r\n      * @param _populous The address to be set as populous.\r\n      */\r\n    function changePopulous(address _populous) public {\r\n        require(isServer(msg.sender) == true);\r\n        populous = _populous;\r\n    }\r\n\r\n    // CONSTANT METHODS\r\n    \r\n    /** @dev Checks a given address to determine whether it is the server.\r\n      * @param sender The address to be checked.\r\n      * @return bool returns true or false is the address corresponds to the server or not.\r\n      */\r\n    function isServer(address sender) public view returns (bool) {\r\n        return sender == server;\r\n    }\r\n\r\n    /** @dev Checks a given address to determine whether it is the guardian.\r\n      * @param sender The address to be checked.\r\n      * @return bool returns true or false is the address corresponds to the guardian or not.\r\n      */\r\n    /* function isGuardian(address sender) public view returns (bool) {\r\n        return sender == guardian;\r\n    } */\r\n\r\n    /** @dev Checks a given address to determine whether it is populous address.\r\n      * @param sender The address to be checked.\r\n      * @return bool returns true or false is the address corresponds to populous or not.\r\n      */\r\n    function isPopulous(address sender) public view returns (bool) {\r\n        return sender == populous;\r\n    }\r\n\r\n}\r\n\r\n// File: contracts/withAccessManager.sol\r\n\r\n/// @title withAccessManager contract\r\ncontract withAccessManager {\r\n\r\n    // FIELDS\r\n    \r\n    AccessManager public AM;\r\n\r\n    // MODIFIERS\r\n\r\n    // This modifier uses the isServer method in the AccessManager contract AM to determine\r\n    // whether the msg.sender address is server.\r\n    modifier onlyServer {\r\n        require(AM.isServer(msg.sender) == true);\r\n        _;\r\n    }\r\n\r\n    modifier onlyServerOrOnlyPopulous {\r\n        require(AM.isServer(msg.sender) == true || AM.isPopulous(msg.sender) == true);\r\n        _;\r\n    }\r\n\r\n    // This modifier uses the isGuardian method in the AccessManager contract AM to determine\r\n    // whether the msg.sender address is guardian.\r\n    /* modifier onlyGuardian {\r\n        require(AM.isGuardian(msg.sender) == true);\r\n        _;\r\n    } */\r\n\r\n    // This modifier uses the isPopulous method in the AccessManager contract AM to determine\r\n    // whether the msg.sender address is populous.\r\n    modifier onlyPopulous {\r\n        require(AM.isPopulous(msg.sender) == true);\r\n        _;\r\n    }\r\n\r\n    // NON-CONSTANT METHODS\r\n    \r\n    /** @dev Sets the AccessManager contract address while deploying this contract`.\r\n      * @param _accessManager The address to set.\r\n      */\r\n    function withAccessManager(address _accessManager) public {\r\n        AM = AccessManager(_accessManager);\r\n    }\r\n    \r\n    /** @dev Updates the AccessManager contract address if msg.sender is guardian.\r\n      * @param _accessManager The address to set.\r\n      */\r\n    function updateAccessManager(address _accessManager) public onlyServer {\r\n        AM = AccessManager(_accessManager);\r\n    }\r\n\r\n}\r\n\r\n// File: contracts/ERC1155SafeMath.sol\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary ERC1155SafeMath {\r\n\r\n    /**\r\n    * @dev Multiplies two numbers, throws on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two numbers, truncating the quotient.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        // uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return a / b;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, throws on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}\r\n\r\n// File: contracts/Address.sol\r\n\r\n/**\r\n * Utility library of inline functions on addresses\r\n */\r\nlibrary Address {\r\n\r\n    /**\r\n     * Returns whether the target address is a contract\r\n     * @dev This function will return false if invoked during the constructor of a contract,\r\n     * as the code is not actually created until after the constructor finishes.\r\n     * @param account address of the account to check\r\n     * @return whether the target address is a contract\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        uint256 size;\r\n        // XXX Currently there is no better way to check if there is a contract in an address\r\n        // than to check the size of the code at that address.\r\n        // See https://ethereum.stackexchange.com/a/14016/36603\r\n        // for more details about how this works.\r\n        // TODO Check this again before the Serenity release, because all addresses will be\r\n        // contracts then.\r\n        // solium-disable-next-line security/no-inline-assembly\r\n        assembly { size := extcodesize(account) }\r\n        return size > 0;\r\n    }\r\n\r\n}\r\n\r\n// File: contracts/IERC1155.sol\r\n\r\n/// @dev Note: the ERC-165 identifier for this interface is 0xf23a6e61.\r\ninterface IERC1155TokenReceiver {\r\n    /// @notice Handle the receipt of an ERC1155 type\r\n    /// @dev The smart contract calls this function on the recipient\r\n    ///  after a `safeTransfer`. This function MAY throw to revert and reject the\r\n    ///  transfer. Return of other than the magic value MUST result in the\r\n    ///  transaction being reverted.\r\n    ///  Note: the contract address is always the message sender.\r\n    /// @param _operator The address which called `safeTransferFrom` function\r\n    /// @param _from The address which previously owned the token\r\n    /// @param _id The identifier of the item being transferred\r\n    /// @param _value The amount of the item being transferred\r\n    /// @param _data Additional data with no specified format\r\n    /// @return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\r\n    ///  unless throwing\r\n    function onERC1155Received(address _operator, address _from, uint256 _id, uint256 _value, bytes _data) external returns(bytes4);\r\n}\r\n\r\ninterface IERC1155 {\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 indexed _id, uint256 _oldValue, uint256 _value);\r\n    event Transfer(address _spender, address indexed _from, address indexed _to, uint256 indexed _id, uint256 _value);\r\n\r\n    function transferFrom(address _from, address _to, uint256 _id, uint256 _value) external;\r\n    function safeTransferFrom(address _from, address _to, uint256 _id, uint256 _value, bytes _data) external;\r\n    function approve(address _spender, uint256 _id, uint256 _currentValue, uint256 _value) external;\r\n    function balanceOf(uint256 _id, address _owner) external view returns (uint256);\r\n    function allowance(uint256 _id, address _owner, address _spender) external view returns (uint256);\r\n}\r\n\r\ninterface IERC1155Extended {\r\n    function transfer(address _to, uint256 _id, uint256 _value) external;\r\n    function safeTransfer(address _to, uint256 _id, uint256 _value, bytes _data) external;\r\n}\r\n\r\ninterface IERC1155BatchTransfer {\r\n    function batchTransferFrom(address _from, address _to, uint256[] _ids, uint256[] _values) external;\r\n    function safeBatchTransferFrom(address _from, address _to, uint256[] _ids, uint256[] _values, bytes _data) external;\r\n    function batchApprove(address _spender, uint256[] _ids,  uint256[] _currentValues, uint256[] _values) external;\r\n}\r\n\r\ninterface IERC1155BatchTransferExtended {\r\n    function batchTransfer(address _to, uint256[] _ids, uint256[] _values) external;\r\n    function safeBatchTransfer(address _to, uint256[] _ids, uint256[] _values, bytes _data) external;\r\n}\r\n\r\ninterface IERC1155Operators {\r\n    event OperatorApproval(address indexed _owner, address indexed _operator, uint256 indexed _id, bool _approved);\r\n    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\r\n\r\n    function setApproval(address _operator, uint256[] _ids, bool _approved) external;\r\n    function isApproved(address _owner, address _operator, uint256 _id)  external view returns (bool);\r\n    function setApprovalForAll(address _operator, bool _approved) external;\r\n    function isApprovedForAll(address _owner, address _operator) external view returns (bool isOperator);\r\n}\r\n\r\ninterface IERC1155Views {\r\n    function totalSupply(uint256 _id) external view returns (uint256);\r\n    function name(uint256 _id) external view returns (string);\r\n    function symbol(uint256 _id) external view returns (string);\r\n    function decimals(uint256 _id) external view returns (uint8);\r\n    function uri(uint256 _id) external view returns (string);\r\n}\r\n\r\n// File: contracts/ERC1155.sol\r\n\r\ncontract ERC1155 is IERC1155, IERC1155Extended, IERC1155BatchTransfer, IERC1155BatchTransferExtended {\r\n    using ERC1155SafeMath for uint256;\r\n    using Address for address;\r\n\r\n    // Variables\r\n    struct Items {\r\n        string name;\r\n        uint256 totalSupply;\r\n        mapping (address => uint256) balances;\r\n    }\r\n    mapping (uint256 => uint8) public decimals;\r\n    mapping (uint256 => string) public symbols;\r\n    mapping (uint256 => mapping(address => mapping(address => uint256))) public allowances;\r\n    mapping (uint256 => Items) public items;\r\n    mapping (uint256 => string) public metadataURIs;\r\n\r\n    bytes4 constant private ERC1155_RECEIVED = 0xf23a6e61;\r\n\r\n/////////////////////////////////////////// IERC1155 //////////////////////////////////////////////\r\n\r\n    // Events\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 indexed _id, uint256 _oldValue, uint256 _value);\r\n    event Transfer(address _spender, address indexed _from, address indexed _to, uint256 indexed _id, uint256 _value);\r\n\r\n    function transferFrom(address _from, address _to, uint256 _id, uint256 _value) external {\r\n        if(_from != msg.sender) {\r\n            //require(allowances[_id][_from][msg.sender] >= _value);\r\n            allowances[_id][_from][msg.sender] = allowances[_id][_from][msg.sender].sub(_value);\r\n        }\r\n\r\n        items[_id].balances[_from] = items[_id].balances[_from].sub(_value);\r\n        items[_id].balances[_to] = _value.add(items[_id].balances[_to]);\r\n\r\n        Transfer(msg.sender, _from, _to, _id, _value);\r\n    }\r\n\r\n    function safeTransferFrom(address _from, address _to, uint256 _id, uint256 _value, bytes _data) external {\r\n        //this.transferFrom(_from, _to, _id, _value);\r\n\r\n        // solium-disable-next-line arg-overflow\r\n        require(_checkAndCallSafeTransfer(_from, _to, _id, _value, _data));\r\n        if(_from != msg.sender) {\r\n            //require(allowances[_id][_from][msg.sender] >= _value);\r\n            allowances[_id][_from][msg.sender] = allowances[_id][_from][msg.sender].sub(_value);\r\n        }\r\n\r\n        items[_id].balances[_from] = items[_id].balances[_from].sub(_value);\r\n        items[_id].balances[_to] = _value.add(items[_id].balances[_to]);\r\n\r\n        Transfer(msg.sender, _from, _to, _id, _value);\r\n    }\r\n\r\n    function approve(address _spender, uint256 _id, uint256 _currentValue, uint256 _value) external {\r\n        // if the allowance isn't 0, it can only be updated to 0 to prevent an allowance change immediately after withdrawal\r\n        require(_value == 0 || allowances[_id][msg.sender][_spender] == _currentValue);\r\n        allowances[_id][msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _id, _currentValue, _value);\r\n    }\r\n\r\n    function balanceOf(uint256 _id, address _owner) external view returns (uint256) {\r\n        return items[_id].balances[_owner];\r\n    }\r\n\r\n    function allowance(uint256 _id, address _owner, address _spender) external view returns (uint256) {\r\n        return allowances[_id][_owner][_spender];\r\n    }\r\n\r\n/////////////////////////////////////// IERC1155Extended //////////////////////////////////////////\r\n\r\n    function transfer(address _to, uint256 _id, uint256 _value) external {\r\n        // Not needed. SafeMath will do the same check on .sub(_value)\r\n        //require(_value <= items[_id].balances[msg.sender]);\r\n        items[_id].balances[msg.sender] = items[_id].balances[msg.sender].sub(_value);\r\n        items[_id].balances[_to] = _value.add(items[_id].balances[_to]);\r\n        Transfer(msg.sender, msg.sender, _to, _id, _value);\r\n    }\r\n\r\n    function safeTransfer(address _to, uint256 _id, uint256 _value, bytes _data) external {\r\n        //this.transfer(_to, _id, _value);\r\n                \r\n        // solium-disable-next-line arg-overflow\r\n        require(_checkAndCallSafeTransfer(msg.sender, _to, _id, _value, _data));\r\n        items[_id].balances[msg.sender] = items[_id].balances[msg.sender].sub(_value);\r\n        items[_id].balances[_to] = _value.add(items[_id].balances[_to]);\r\n        Transfer(msg.sender, msg.sender, _to, _id, _value);\r\n    }\r\n\r\n//////////////////////////////////// IERC1155BatchTransfer ////////////////////////////////////////\r\n\r\n    function batchTransferFrom(address _from, address _to, uint256[] _ids, uint256[] _values) external {\r\n        uint256 _id;\r\n        uint256 _value;\r\n\r\n        if(_from == msg.sender) {\r\n            for (uint256 i = 0; i < _ids.length; ++i) {\r\n                _id = _ids[i];\r\n                _value = _values[i];\r\n\r\n                items[_id].balances[_from] = items[_id].balances[_from].sub(_value);\r\n                items[_id].balances[_to] = _value.add(items[_id].balances[_to]);\r\n\r\n                Transfer(msg.sender, _from, _to, _id, _value);\r\n            }\r\n        }\r\n        else {\r\n            for (i = 0; i < _ids.length; ++i) {\r\n                _id = _ids[i];\r\n                _value = _values[i];\r\n\r\n                allowances[_id][_from][msg.sender] = allowances[_id][_from][msg.sender].sub(_value);\r\n\r\n                items[_id].balances[_from] = items[_id].balances[_from].sub(_value);\r\n                items[_id].balances[_to] = _value.add(items[_id].balances[_to]);\r\n\r\n                Transfer(msg.sender, _from, _to, _id, _value);\r\n            }\r\n        }\r\n    }\r\n\r\n    function safeBatchTransferFrom(address _from, address _to, uint256[] _ids, uint256[] _values, bytes _data) external {\r\n        //this.batchTransferFrom(_from, _to, _ids, _values);\r\n\r\n        for (uint256 i = 0; i < _ids.length; ++i) {\r\n            // solium-disable-next-line arg-overflow\r\n            require(_checkAndCallSafeTransfer(_from, _to, _ids[i], _values[i], _data));\r\n        }\r\n\r\n        uint256 _id;\r\n        uint256 _value;\r\n\r\n        if(_from == msg.sender) {\r\n            for (i = 0; i < _ids.length; ++i) {\r\n                _id = _ids[i];\r\n                _value = _values[i];\r\n\r\n                items[_id].balances[_from] = items[_id].balances[_from].sub(_value);\r\n                items[_id].balances[_to] = _value.add(items[_id].balances[_to]);\r\n\r\n                Transfer(msg.sender, _from, _to, _id, _value);\r\n            }\r\n        }\r\n        else {\r\n            for (i = 0; i < _ids.length; ++i) {\r\n                _id = _ids[i];\r\n                _value = _values[i];\r\n\r\n                allowances[_id][_from][msg.sender] = allowances[_id][_from][msg.sender].sub(_value);\r\n\r\n                items[_id].balances[_from] = items[_id].balances[_from].sub(_value);\r\n                items[_id].balances[_to] = _value.add(items[_id].balances[_to]);\r\n\r\n                Transfer(msg.sender, _from, _to, _id, _value);\r\n            }\r\n        }\r\n    }\r\n\r\n    function batchApprove(address _spender, uint256[] _ids,  uint256[] _currentValues, uint256[] _values) external {\r\n        uint256 _id;\r\n        uint256 _value;\r\n\r\n        for (uint256 i = 0; i < _ids.length; ++i) {\r\n            _id = _ids[i];\r\n            _value = _values[i];\r\n\r\n            require(_value == 0 || allowances[_id][msg.sender][_spender] == _currentValues[i]);\r\n            allowances[_id][msg.sender][_spender] = _value;\r\n            Approval(msg.sender, _spender, _id, _currentValues[i], _value);\r\n        }\r\n    }\r\n\r\n//////////////////////////////// IERC1155BatchTransferExtended ////////////////////////////////////\r\n\r\n    function batchTransfer(address _to, uint256[] _ids, uint256[] _values) external {\r\n        uint256 _id;\r\n        uint256 _value;\r\n\r\n        for (uint256 i = 0; i < _ids.length; ++i) {\r\n            _id = _ids[i];\r\n            _value = _values[i];\r\n\r\n            items[_id].balances[msg.sender] = items[_id].balances[msg.sender].sub(_value);\r\n            items[_id].balances[_to] = _value.add(items[_id].balances[_to]);\r\n\r\n            Transfer(msg.sender, msg.sender, _to, _id, _value);\r\n        }\r\n    }\r\n\r\n    function safeBatchTransfer(address _to, uint256[] _ids, uint256[] _values, bytes _data) external {\r\n        //this.batchTransfer(_to, _ids, _values);\r\n\r\n        for (uint256 i = 0; i < _ids.length; ++i) {\r\n            // solium-disable-next-line arg-overflow\r\n            require(_checkAndCallSafeTransfer(msg.sender, _to, _ids[i], _values[i], _data));\r\n        }\r\n\r\n        uint256 _id;\r\n        uint256 _value;\r\n\r\n        for (i = 0; i < _ids.length; ++i) {\r\n            _id = _ids[i];\r\n            _value = _values[i];\r\n\r\n            items[_id].balances[msg.sender] = items[_id].balances[msg.sender].sub(_value);\r\n            items[_id].balances[_to] = _value.add(items[_id].balances[_to]);\r\n\r\n            Transfer(msg.sender, msg.sender, _to, _id, _value);\r\n        }\r\n    }\r\n\r\n//////////////////////////////// IERC1155BatchTransferExtended ////////////////////////////////////\r\n\r\n    // Optional meta data view Functions\r\n    // consider multi-lingual support for name?\r\n    function name(uint256 _id) external view returns (string) {\r\n        return items[_id].name;\r\n    }\r\n\r\n    function symbol(uint256 _id) external view returns (string) {\r\n        return symbols[_id];\r\n    }\r\n\r\n    function decimals(uint256 _id) external view returns (uint8) {\r\n        return decimals[_id];\r\n    }\r\n\r\n    function totalSupply(uint256 _id) external view returns (uint256) {\r\n        return items[_id].totalSupply;\r\n    }\r\n\r\n    function uri(uint256 _id) external view returns (string) {\r\n        return metadataURIs[_id];\r\n    }\r\n\r\n////////////////////////////////////////// OPTIONALS //////////////////////////////////////////////\r\n\r\n\r\n    function multicastTransfer(address[] _to, uint256[] _ids, uint256[] _values) external {\r\n        for (uint256 i = 0; i < _to.length; ++i) {\r\n            uint256 _id = _ids[i];\r\n            uint256 _value = _values[i];\r\n            address _dst = _to[i];\r\n\r\n            items[_id].balances[msg.sender] = items[_id].balances[msg.sender].sub(_value);\r\n            items[_id].balances[_dst] = _value.add(items[_id].balances[_dst]);\r\n\r\n            Transfer(msg.sender, msg.sender, _dst, _id, _value);\r\n        }\r\n    }\r\n\r\n    function safeMulticastTransfer(address[] _to, uint256[] _ids, uint256[] _values, bytes _data) external {\r\n        //this.multicastTransfer(_to, _ids, _values);\r\n\r\n        for (uint256 i = 0; i < _ids.length; ++i) {\r\n            // solium-disable-next-line arg-overflow\r\n            require(_checkAndCallSafeTransfer(msg.sender, _to[i], _ids[i], _values[i], _data));\r\n        }\r\n\r\n        for (i = 0; i < _to.length; ++i) {\r\n            uint256 _id = _ids[i];\r\n            uint256 _value = _values[i];\r\n            address _dst = _to[i];\r\n\r\n            items[_id].balances[msg.sender] = items[_id].balances[msg.sender].sub(_value);\r\n            items[_id].balances[_dst] = _value.add(items[_id].balances[_dst]);\r\n\r\n            Transfer(msg.sender, msg.sender, _dst, _id, _value);\r\n        }\r\n    }\r\n\r\n////////////////////////////////////////// INTERNAL //////////////////////////////////////////////\r\n\r\n    function _checkAndCallSafeTransfer(\r\n        address _from,\r\n        address _to,\r\n        uint256 _id,\r\n        uint256 _value,\r\n        bytes _data\r\n    )\r\n    internal\r\n    returns (bool)\r\n    {\r\n        if (!_to.isContract()) {\r\n            return true;\r\n        }\r\n        bytes4 retval = IERC1155TokenReceiver(_to).onERC1155Received(\r\n            msg.sender, _from, _id, _value, _data);\r\n        return (retval == ERC1155_RECEIVED);\r\n    }\r\n}\r\n\r\n// File: contracts/ERC165.sol\r\n\r\n/**\r\n * @title ERC165\r\n * @dev https://github.com/ethereum/EIPs/blob/master/EIPS/eip-165.md\r\n */\r\ninterface ERC165 {\r\n\r\n  /**\r\n   * @notice Query if a contract implements an interface\r\n   * @param _interfaceId The interface identifier, as specified in ERC-165\r\n   * @dev Interface identification is specified in ERC-165. This function\r\n   * uses less than 30,000 gas.\r\n   */\r\n  function supportsInterface(bytes4 _interfaceId)\r\n    external\r\n    view\r\n    returns (bool);\r\n}\r\n\r\n// File: contracts/ERC721Basic.sol\r\n\r\n/**\r\n * @title ERC721 Non-Fungible Token Standard basic interface\r\n * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\r\n */\r\ncontract ERC721Basic is ERC165 {\r\n\r\n    bytes4 internal constant InterfaceId_ERC721 = 0x80ac58cd;\r\n    /*\r\n    * 0x80ac58cd ===\r\n    *   bytes4(keccak256('balanceOf(address)')) ^\r\n    *   bytes4(keccak256('ownerOf(uint256)')) ^\r\n    *   bytes4(keccak256('approve(address,uint256)')) ^\r\n    *   bytes4(keccak256('getApproved(uint256)')) ^\r\n    *   bytes4(keccak256('setApprovalForAll(address,bool)')) ^\r\n    *   bytes4(keccak256('isApprovedForAll(address,address)')) ^\r\n    *   bytes4(keccak256('transferFrom(address,address,uint256)')) ^\r\n    *   bytes4(keccak256('safeTransferFrom(address,address,uint256)')) ^\r\n    *   bytes4(keccak256('safeTransferFrom(address,address,uint256,bytes)'))\r\n    */\r\n\r\n    bytes4 internal constant InterfaceId_ERC721Exists = 0x4f558e79;\r\n    /*\r\n    * 0x4f558e79 ===\r\n    *   bytes4(keccak256('exists(uint256)'))\r\n    */\r\n\r\n    bytes4 internal constant InterfaceId_ERC721Enumerable = 0x780e9d63;\r\n    /**\r\n    * 0x780e9d63 ===\r\n    *   bytes4(keccak256('totalSupply()')) ^\r\n    *   bytes4(keccak256('tokenOfOwnerByIndex(address,uint256)')) ^\r\n    *   bytes4(keccak256('tokenByIndex(uint256)'))\r\n    */\r\n\r\n    bytes4 internal constant InterfaceId_ERC721Metadata = 0x5b5e139f;\r\n    /**\r\n    * 0x5b5e139f ===\r\n    *   bytes4(keccak256('name()')) ^\r\n    *   bytes4(keccak256('symbol()')) ^\r\n    *   bytes4(keccak256('tokenURI(uint256)'))\r\n    */\r\n\r\n    event Transfer(\r\n      address indexed _from,\r\n      address indexed _to,\r\n      uint256 indexed _tokenId\r\n    );\r\n    event Approval(\r\n      address indexed _owner,\r\n      address indexed _approved,\r\n      uint256 indexed _tokenId\r\n    );\r\n    event ApprovalForAll(\r\n      address indexed _owner,\r\n      address indexed _operator,\r\n      bool _approved\r\n    );\r\n\r\n    function balanceOf(address _owner) public view returns (uint256 _balance);\r\n    function ownerOf(uint256 _tokenId) public view returns (address _owner);\r\n    function exists(uint256 _tokenId) public view returns (bool _exists);\r\n\r\n    function approve(address _to, uint256 _tokenId) public;\r\n    function getApproved(uint256 _tokenId) public view returns (address _operator);\r\n\r\n    function setApprovalForAll(address _operator, bool _approved) public;\r\n    function isApprovedForAll(address _owner, address _operator) public view returns (bool);\r\n\r\n    function transferFrom(address _from, address _to, uint256 _tokenId) public;\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId) public;\r\n\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes _data) public;\r\n}\r\n\r\n// File: contracts/DepositContract.sol\r\n\r\n/// @title DepositContract contract\r\ncontract DepositContract is withAccessManager {\r\n\r\n    bytes32 public clientId; // client ID.\r\n    uint256 public version = 2;\r\n\r\n    // EVENTS\r\n    event EtherTransfer(address to, uint256 value);\r\n\r\n    // NON-CONSTANT METHODS \r\n\r\n    /** @dev Constructor that sets the _clientID when the contract is deployed.\r\n      * @dev The method also sets the manager to the msg.sender.\r\n      * @param _clientId A string of fixed length representing the client ID.\r\n      */\r\n    function DepositContract(bytes32 _clientId, address accessManager) public withAccessManager(accessManager) {\r\n        clientId = _clientId;\r\n    }\r\n     \r\n    /** @dev Transfers an amount '_value' of tokens from msg.sender to '_to' address/wallet.\r\n      * @param populousTokenContract The address of the ERC20 token contract which implements the transfer method.\r\n      * @param _value the amount of tokens to transfer.\r\n      * @param _to The address/wallet to send to.\r\n      * @return success boolean true or false indicating whether the transfer was successful or not.\r\n      */\r\n    function transfer(address populousTokenContract, address _to, uint256 _value) public\r\n        onlyServerOrOnlyPopulous returns (bool success) \r\n    {\r\n        return iERC20Token(populousTokenContract).transfer(_to, _value);\r\n    }\r\n\r\n    /** @dev This function will transfer iERC1155 tokens\r\n     */\r\n    function transferERC1155(address _erc1155Token, address _to, uint256 _id, uint256 _value) \r\n        public onlyServerOrOnlyPopulous returns (bool success) {\r\n        ERC1155(_erc1155Token).safeTransfer(_to, _id, _value, \"\");\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @notice Handle the receipt of an NFT\r\n    * @dev The ERC721 smart contract calls this function on the recipient\r\n    * after a `safetransfer` if the recipient is a smart contract. This function MAY throw to revert and reject the\r\n    * transfer. Return of other than the magic value (0x150b7a02) MUST result in the\r\n    * transaction being reverted.\r\n    * Note: the contract address is always the message sender.\r\n    * @param _operator The address which called `safeTransferFrom` function\r\n    * @param _from The address which previously owned the token\r\n    * @param _tokenId The NFT identifier which is being transferred\r\n    * @param _data Additional data with no specified format\r\n    * @return `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\r\n    */\r\n    function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes _data) public returns(bytes4) {\r\n        return 0x150b7a02; \r\n    }\r\n\r\n    /// @notice Handle the receipt of an ERC1155 type\r\n    /// @dev The smart contract calls this function on the recipient\r\n    ///  after a `safeTransfer`. This function MAY throw to revert and reject the\r\n    ///  transfer. Return of other than the magic value MUST result in the\r\n    ///  transaction being reverted.\r\n    ///  Note: the contract address is always the message sender.\r\n    /// @param _operator The address which called `safeTransferFrom` function\r\n    /// @param _from The address which previously owned the token\r\n    /// @param _id The identifier of the item being transferred\r\n    /// @param _value The amount of the item being transferred\r\n    /// @param _data Additional data with no specified format\r\n    /// @return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\r\n    ///  unless throwing\r\n    function onERC1155Received(address _operator, address _from, uint256 _id, uint256 _value, bytes _data) public returns(bytes4) {\r\n        return 0xf23a6e61;\r\n    }\r\n\r\n    /**\r\n    * @dev Safely transfers the ownership of a given token ID to another address\r\n    * If the target address is a contract, it must implement `onERC721Received`,\r\n    * which is called upon a safe transfer, and return the magic value\r\n    * `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`; otherwise,\r\n    * the transfer is reverted.\r\n    *\r\n    * Requires the msg sender to be the owner, approved, or operator\r\n    * @param erc721Token address of the erc721 token to target\r\n    * @param _to address to receive the ownership of the given token ID\r\n    * @param _tokenId uint256 ID of the token to be transferred\r\n    */\r\n    function transferERC721(\r\n        address erc721Token,\r\n        address _to,\r\n        uint256 _tokenId\r\n    )\r\n        public onlyServerOrOnlyPopulous returns (bool success)\r\n    {\r\n        // solium-disable-next-line arg-overflow\r\n        ERC721Basic(erc721Token).safeTransferFrom(this, _to, _tokenId, \"\");\r\n        return true;\r\n    }\r\n\r\n    /** @dev Transfers ether from this contract to a specified wallet/address\r\n      * @param _to An address implementing to send ether to.\r\n      * @param _value The amount of ether to send in wei. \r\n      * @return bool Successful or unsuccessful transfer\r\n      */\r\n    function transferEther(address _to, uint256 _value) public \r\n        onlyServerOrOnlyPopulous returns (bool success) \r\n    {\r\n        require(this.balance >= _value);\r\n        require(_to.send(_value) == true);\r\n        EtherTransfer(_to, _value);\r\n        return true;\r\n    }\r\n\r\n    // payable function to allow this contract receive ether - for version 3\r\n    //function () public payable {}\r\n\r\n    // CONSTANT METHODS\r\n    \r\n    /** @dev Returns the ether or token balance of the current contract instance using the ERC20 balanceOf method.\r\n      * @param populousTokenContract An address implementing the ERC20 token standard. \r\n      * @return uint An unsigned integer representing the returned token balance.\r\n      */\r\n    function balanceOf(address populousTokenContract) public view returns (uint256) {\r\n        // ether\r\n        if (populousTokenContract == address(0)) {\r\n            return address(this).balance;\r\n        } else {\r\n            // erc20\r\n            return iERC20Token(populousTokenContract).balanceOf(this);\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Gets the balance of the specified address\r\n    * @param erc721Token address to erc721 token to target\r\n    * @return uint256 representing the amount owned by the passed address\r\n    */\r\n    function balanceOfERC721(address erc721Token) public view returns (uint256) {\r\n        return ERC721Basic(erc721Token).balanceOf(this);\r\n        // returns ownedTokensCount[_owner];\r\n    }\r\n\r\n    /**\r\n    * @dev Gets the balance of the specified address\r\n    * @param _id the token id\r\n    * @param erc1155Token address to erc1155 token to target\r\n    * @return uint256 representing the amount owned by the passed address\r\n    */\r\n    function balanceOfERC1155(address erc1155Token, uint256 _id) external view returns (uint256) {\r\n        return ERC1155(erc1155Token).balanceOf(_id, this);\r\n    }\r\n\r\n    /** @dev Gets the version of this deposit contract\r\n      * @return uint256 version\r\n      */\r\n    function getVersion() public view returns (uint256) {\r\n        return version;\r\n    }\r\n\r\n    // CONSTANT FUNCTIONS\r\n\r\n    /** @dev This function gets the client ID or deposit contract owner\r\n     * returns _clientId\r\n     */\r\n    function getClientId() public view returns (bytes32 _clientId) {\r\n        return clientId;\r\n    }\r\n}\r\n\r\n// File: contracts/SafeMath.sol\r\n\r\n/// @title Overflow aware uint math functions.\r\n/// @notice Inspired by https://github.com/MakerDAO/maker-otc/blob/master/contracts/simple_market.sol\r\nlibrary SafeMath {\r\n\r\n  /** @dev Safely multiplies two unsigned/non-negative integers.\r\n    * @dev Ensures that one of both numbers can be derived from dividing the product by the other.\r\n    * @param a The first number.\r\n    * @param b The second number.\r\n    * @return uint The expected result.\r\n    */\r\n    function safeMul(uint a, uint b) internal pure returns (uint) {\r\n        uint c = a * b;\r\n        assert(a == 0 || c / a == b);\r\n        return c;\r\n    }\r\n\r\n  /** @dev Safely subtracts one number from another\r\n    * @dev Ensures that the number to subtract is lower.\r\n    * @param a The first number.\r\n    * @param b The second number.\r\n    * @return uint The expected result.\r\n    */\r\n    function safeSub(uint a, uint b) internal pure returns (uint) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n  /** @dev Safely adds two unsigned/non-negative integers.\r\n    * @dev Ensures that the sum of both numbers is greater or equal to one of both.\r\n    * @param a The first number.\r\n    * @param b The second number.\r\n    * @return uint The expected result.\r\n    */\r\n    function safeAdd(uint a, uint b) internal pure returns (uint) {\r\n        uint c = a + b;\r\n        assert(c>=a && c>=b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        uint256 c = a / b;\r\n        assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n}\r\n\r\n// File: contracts/iDataManager.sol\r\n\r\n/// @title DataManager contract\r\ncontract iDataManager {\r\n    // FIELDS\r\n    uint256 public version;\r\n    // currency symbol => currency erc20 contract address\r\n    mapping(bytes32 => address) public currencyAddresses;\r\n    // currency address => currency symbol\r\n    mapping(address => bytes32) public currencySymbols;\r\n    // clientId => depositAddress\r\n    mapping(bytes32 => address) public depositAddresses;\r\n    // depositAddress => clientId\r\n    mapping(address => bytes32) public depositClientIds;\r\n    // blockchainActionId => boolean \r\n    mapping(bytes32 => bool) public actionStatus;\r\n    // blockchainActionData\r\n    struct actionData {\r\n        bytes32 currency;\r\n        uint amount;\r\n        bytes32 accountId;\r\n        address to;\r\n        uint pptFee;\r\n    }\r\n    // blockchainActionId => actionData\r\n    mapping(bytes32 => actionData) public blockchainActionIdData;\r\n    \r\n    //actionId => invoiceId\r\n    mapping(bytes32 => bytes32) public actionIdToInvoiceId;\r\n    // invoice provider company data\r\n    struct providerCompany {\r\n        //bool isEnabled;\r\n        bytes32 companyNumber;\r\n        bytes32 companyName;\r\n        bytes2 countryCode;\r\n    }\r\n    // companyCode => companyNumber => providerId\r\n    mapping(bytes2 => mapping(bytes32 => bytes32)) public providerData;\r\n    // providedId => providerCompany\r\n    mapping(bytes32 => providerCompany) public providerCompanyData;\r\n    // crowdsale invoiceDetails\r\n    struct _invoiceDetails {\r\n        bytes2 invoiceCountryCode;\r\n        bytes32 invoiceCompanyNumber;\r\n        bytes32 invoiceCompanyName;\r\n        bytes32 invoiceNumber;\r\n    }\r\n    // crowdsale invoiceData\r\n    struct invoiceData {\r\n        bytes32 providerUserId;\r\n        bytes32 invoiceCompanyName;\r\n    }\r\n\r\n    // country code => company number => invoice number => invoice data\r\n    mapping(bytes2 => mapping(bytes32 => mapping(bytes32 => invoiceData))) public invoices;\r\n    \r\n    \r\n    \r\n    \r\n    // NON-CONSTANT METHODS\r\n\r\n    /** @dev Adds a new deposit smart contract address linked to a client id\r\n      * @param _depositAddress the deposit smart contract address\r\n      * @param _clientId the client id\r\n      * @return success true/false denoting successful function call\r\n      */\r\n    function setDepositAddress(bytes32 _blockchainActionId, address _depositAddress, bytes32 _clientId) public returns (bool success);\r\n\r\n    /** @dev Adds a new currency sumbol and smart contract address  \r\n      * @param _currencyAddress the currency smart contract address\r\n      * @param _currencySymbol the currency symbol\r\n      * @return success true/false denoting successful function call\r\n      */\r\n    function setCurrency(bytes32 _blockchainActionId, address _currencyAddress, bytes32 _currencySymbol) public returns (bool success);\r\n\r\n    /** @dev Updates a currency sumbol and smart contract address  \r\n      * @param _currencyAddress the currency smart contract address\r\n      * @param _currencySymbol the currency symbol\r\n      * @return success true/false denoting successful function call\r\n      */\r\n    function _setCurrency(bytes32 _blockchainActionId, address _currencyAddress, bytes32 _currencySymbol) public returns (bool success);\r\n\r\n\r\n    /** @dev set blockchain action data in struct \r\n      * @param _blockchainActionId the blockchain action id\r\n      * @param currency the token currency symbol\r\n      * @param accountId the clientId\r\n      * @param to the blockchain address or smart contract address used in the transaction\r\n      * @param amount the amount of tokens in the transaction\r\n      * @return success true/false denoting successful function call\r\n      */\r\n    function setBlockchainActionData(\r\n        bytes32 _blockchainActionId, bytes32 currency, \r\n        uint amount, bytes32 accountId, address to, uint pptFee) \r\n        public \r\n        returns (bool success);\r\n\r\n    /** @dev upgrade deposit address \r\n      * @param _blockchainActionId the blockchain action id\r\n      * @param _clientId the client id\r\n      * @param _depositContract the deposit contract address for the client\r\n      * @return success true/false denoting successful function call\r\n      */\r\n    function upgradeDepositAddress(bytes32 _blockchainActionId, bytes32 _clientId, address _depositContract) public returns (bool success);\r\n  \r\n\r\n    /** @dev Updates a deposit address for client id\r\n      * @param _blockchainActionId the blockchain action id\r\n      * @param _clientId the client id\r\n      * @param _depositContract the deposit contract address for the client\r\n      * @return success true/false denoting successful function call\r\n      */\r\n    function _setDepositAddress(bytes32 _blockchainActionId, bytes32 _clientId, address _depositContract) public returns (bool success);\r\n\r\n    /** @dev Add a new invoice to the platform  \r\n      * @param _providerUserId the providers user id\r\n      * @param _invoiceCountryCode the country code of the provider\r\n      * @param _invoiceCompanyNumber the providers company number\r\n      * @param _invoiceCompanyName the providers company name\r\n      * @param _invoiceNumber the invoice number\r\n      * @return success true or false if function call is successful\r\n      */\r\n    function setInvoice(\r\n        bytes32 _blockchainActionId, bytes32 _providerUserId, bytes2 _invoiceCountryCode, \r\n        bytes32 _invoiceCompanyNumber, bytes32 _invoiceCompanyName, bytes32 _invoiceNumber) \r\n        public returns (bool success);\r\n\r\n    \r\n    /** @dev Add a new invoice provider to the platform  \r\n      * @param _blockchainActionId the blockchain action id\r\n      * @param _userId the user id of the provider\r\n      * @param _companyNumber the providers company number\r\n      * @param _companyName the providers company name\r\n      * @param _countryCode the providers country code\r\n      * @return success true or false if function call is successful\r\n      */\r\n    function setProvider(\r\n        bytes32 _blockchainActionId, bytes32 _userId, bytes32 _companyNumber, \r\n        bytes32 _companyName, bytes2 _countryCode) \r\n        public returns (bool success);\r\n\r\n    /** @dev Update an added invoice provider to the platform  \r\n      * @param _blockchainActionId the blockchain action id\r\n      * @param _userId the user id of the provider\r\n      * @param _companyNumber the providers company number\r\n      * @param _companyName the providers company name\r\n      * @param _countryCode the providers country code\r\n      * @return success true or false if function call is successful\r\n      */\r\n    function _setProvider(\r\n        bytes32 _blockchainActionId, bytes32 _userId, bytes32 _companyNumber, \r\n        bytes32 _companyName, bytes2 _countryCode) \r\n        public returns (bool success);\r\n    \r\n    // CONSTANT METHODS\r\n\r\n    /** @dev Gets a deposit address with the client id \r\n      * @return clientDepositAddress The client's deposit address\r\n      */\r\n    function getDepositAddress(bytes32 _clientId) public view returns (address clientDepositAddress);\r\n\r\n\r\n    /** @dev Gets a client id linked to a deposit address \r\n      * @return depositClientId The client id\r\n      */\r\n    function getClientIdWithDepositAddress(address _depositContract) public view returns (bytes32 depositClientId);\r\n\r\n\r\n    /** @dev Gets a currency smart contract address \r\n      * @return currencyAddress The currency address\r\n      */\r\n    function getCurrency(bytes32 _currencySymbol) public view returns (address currencyAddress);\r\n\r\n   \r\n    /** @dev Gets a currency symbol given it's smart contract address \r\n      * @return currencySymbol The currency symbol\r\n      */\r\n    function getCurrencySymbol(address _currencyAddress) public view returns (bytes32 currencySymbol);\r\n\r\n    /** @dev Gets details of a currency given it's smart contract address \r\n      * @return _symbol The currency symbol\r\n      * @return _name The currency name\r\n      * @return _decimals The currency decimal places/precision\r\n      */\r\n    function getCurrencyDetails(address _currencyAddress) public view returns (bytes32 _symbol, bytes32 _name, uint8 _decimals);\r\n\r\n    /** @dev Get the blockchain action Id Data for a blockchain Action id\r\n      * @param _blockchainActionId the blockchain action id\r\n      * @return bytes32 currency\r\n      * @return uint amount\r\n      * @return bytes32 accountId\r\n      * @return address to\r\n      */\r\n    function getBlockchainActionIdData(bytes32 _blockchainActionId) public view returns (bytes32 _currency, uint _amount, bytes32 _accountId, address _to);\r\n\r\n\r\n    /** @dev Get the bool status of a blockchain Action id\r\n      * @param _blockchainActionId the blockchain action id\r\n      * @return bool actionStatus\r\n      */\r\n    function getActionStatus(bytes32 _blockchainActionId) public view returns (bool _blockchainActionStatus);\r\n\r\n\r\n    /** @dev Gets the details of an invoice with the country code, company number and invocie number.\r\n      * @param _invoiceCountryCode The country code.\r\n      * @param _invoiceCompanyNumber The company number.\r\n      * @param _invoiceNumber The invoice number\r\n      * @return providerUserId The invoice provider user Id\r\n      * @return invoiceCompanyName the invoice company name\r\n      */\r\n    function getInvoice(bytes2 _invoiceCountryCode, bytes32 _invoiceCompanyNumber, bytes32 _invoiceNumber) \r\n        public \r\n        view \r\n        returns (bytes32 providerUserId, bytes32 invoiceCompanyName);\r\n\r\n\r\n    /** @dev Gets the details of an invoice provider with the country code and company number.\r\n      * @param _providerCountryCode The country code.\r\n      * @param _providerCompanyNumber The company number.\r\n      * @return isEnabled The boolean value true/false indicating whether invoice provider is enabled or not\r\n      * @return providerId The invoice provider user Id\r\n      * @return companyName the invoice company name\r\n      */\r\n    function getProviderByCountryCodeCompanyNumber(bytes2 _providerCountryCode, bytes32 _providerCompanyNumber) \r\n        public \r\n        view \r\n        returns (bytes32 providerId, bytes32 companyName);\r\n\r\n\r\n    /** @dev Gets the details of an invoice provider with the providers user Id.\r\n      * @param _providerUserId The provider user Id.\r\n      * @return countryCode The invoice provider country code\r\n      * @return companyName the invoice company name\r\n      */\r\n    function getProviderByUserId(bytes32 _providerUserId) public view \r\n        returns (bytes2 countryCode, bytes32 companyName, bytes32 companyNumber);\r\n\r\n\r\n    /** @dev Gets the version number for the current contract instance\r\n      * @return _version The version number\r\n      */\r\n    function getVersion() public view returns (uint256 _version);\r\n\r\n}\r\n\r\n// File: contracts/DataManager.sol\r\n\r\n/// @title DataManager contract\r\ncontract DataManager is iDataManager, withAccessManager {\r\n    \r\n\r\n    // NON-CONSTANT METHODS\r\n\r\n    /** @dev Constructor that sets the server when contract is deployed.\r\n      * @param _accessManager The address to set as the access manager.\r\n      */\r\n    function DataManager(address _accessManager, uint256 _version) public withAccessManager(_accessManager) {\r\n        version = _version;\r\n    }\r\n\r\n    /** @dev Adds a new deposit smart contract address linked to a client id\r\n      * @param _depositAddress the deposit smart contract address\r\n      * @param _clientId the client id\r\n      * @return success true/false denoting successful function call\r\n      */\r\n    function setDepositAddress(bytes32 _blockchainActionId, address _depositAddress, bytes32 _clientId) public onlyServerOrOnlyPopulous returns (bool success) {\r\n        require(actionStatus[_blockchainActionId] == false);\r\n        require(depositAddresses[_clientId] == 0x0 && depositClientIds[_depositAddress] == 0x0);\r\n        depositAddresses[_clientId] = _depositAddress;\r\n        depositClientIds[_depositAddress] = _clientId;\r\n        assert(depositAddresses[_clientId] != 0x0 && depositClientIds[_depositAddress] != 0x0);\r\n        return true;\r\n    }\r\n\r\n    /** @dev Adds a new currency sumbol and smart contract address  \r\n      * @param _currencyAddress the currency smart contract address\r\n      * @param _currencySymbol the currency symbol\r\n      * @return success true/false denoting successful function call\r\n      */\r\n    function setCurrency(bytes32 _blockchainActionId, address _currencyAddress, bytes32 _currencySymbol) public onlyServerOrOnlyPopulous returns (bool success) {\r\n        require(actionStatus[_blockchainActionId] == false);\r\n        require(currencySymbols[_currencyAddress] == 0x0 && currencyAddresses[_currencySymbol] == 0x0);\r\n        currencySymbols[_currencyAddress] = _currencySymbol;\r\n        currencyAddresses[_currencySymbol] = _currencyAddress;\r\n        assert(currencyAddresses[_currencySymbol] != 0x0 && currencySymbols[_currencyAddress] != 0x0);\r\n        return true;\r\n    }\r\n\r\n    /** @dev Updates a currency sumbol and smart contract address  \r\n      * @param _currencyAddress the currency smart contract address\r\n      * @param _currencySymbol the currency symbol\r\n      * @return success true/false denoting successful function call\r\n      */\r\n    function _setCurrency(bytes32 _blockchainActionId, address _currencyAddress, bytes32 _currencySymbol) public onlyServerOrOnlyPopulous returns (bool success) {\r\n        require(actionStatus[_blockchainActionId] == false);\r\n        currencySymbols[_currencyAddress] = _currencySymbol;\r\n        currencyAddresses[_currencySymbol] = _currencyAddress;\r\n        assert(currencyAddresses[_currencySymbol] != 0x0 && currencySymbols[_currencyAddress] != 0x0);\r\n        setBlockchainActionData(_blockchainActionId, _currencySymbol, 0, 0x0, _currencyAddress, 0);\r\n        return true;\r\n    }\r\n\r\n    /** @dev set blockchain action data in struct \r\n      * @param _blockchainActionId the blockchain action id\r\n      * @param currency the token currency symbol\r\n      * @param accountId the clientId\r\n      * @param to the blockchain address or smart contract address used in the transaction\r\n      * @param amount the amount of tokens in the transaction\r\n      * @return success true/false denoting successful function call\r\n      */\r\n    function setBlockchainActionData(\r\n        bytes32 _blockchainActionId, bytes32 currency, \r\n        uint amount, bytes32 accountId, address to, uint pptFee) \r\n        public\r\n        onlyServerOrOnlyPopulous \r\n        returns (bool success)\r\n    {\r\n        require(actionStatus[_blockchainActionId] == false);\r\n        blockchainActionIdData[_blockchainActionId].currency = currency;\r\n        blockchainActionIdData[_blockchainActionId].amount = amount;\r\n        blockchainActionIdData[_blockchainActionId].accountId = accountId;\r\n        blockchainActionIdData[_blockchainActionId].to = to;\r\n        blockchainActionIdData[_blockchainActionId].pptFee = pptFee;\r\n        actionStatus[_blockchainActionId] = true;\r\n        return true;\r\n    }\r\n    \r\n    /** @dev Updates a deposit address for client id\r\n      * @param _blockchainActionId the blockchain action id\r\n      * @param _clientId the client id\r\n      * @param _depositContract the deposit contract address for the client\r\n      * @return success true/false denoting successful function call\r\n      */\r\n    function _setDepositAddress(bytes32 _blockchainActionId, bytes32 _clientId, address _depositContract) public\r\n      onlyServerOrOnlyPopulous\r\n      returns (bool success)\r\n    {\r\n        require(actionStatus[_blockchainActionId] == false);\r\n        depositAddresses[_clientId] = _depositContract;\r\n        depositClientIds[_depositContract] = _clientId;\r\n        // check that deposit address has been stored for client Id\r\n        assert(depositAddresses[_clientId] == _depositContract && depositClientIds[_depositContract] == _clientId);\r\n        // set blockchain action data\r\n        setBlockchainActionData(_blockchainActionId, 0x0, 0, _clientId, depositAddresses[_clientId], 0);\r\n        return true;\r\n    }\r\n\r\n    /** @dev Add a new invoice to the platform  \r\n      * @param _providerUserId the providers user id\r\n      * @param _invoiceCountryCode the country code of the provider\r\n      * @param _invoiceCompanyNumber the providers company number\r\n      * @param _invoiceCompanyName the providers company name\r\n      * @param _invoiceNumber the invoice number\r\n      * @return success true or false if function call is successful\r\n      */\r\n    function setInvoice(\r\n        bytes32 _blockchainActionId, bytes32 _providerUserId, bytes2 _invoiceCountryCode, \r\n        bytes32 _invoiceCompanyNumber, bytes32 _invoiceCompanyName, bytes32 _invoiceNumber) \r\n        public \r\n        onlyServerOrOnlyPopulous \r\n        returns (bool success) \r\n    {   \r\n        require(actionStatus[_blockchainActionId] == false);\r\n        bytes32 providerUserId; \r\n        bytes32 companyName;\r\n        (providerUserId, companyName) = getInvoice(_invoiceCountryCode, _invoiceCompanyNumber, _invoiceNumber);\r\n        require(providerUserId == 0x0 && companyName == 0x0);\r\n        // country code => company number => invoice number => invoice data\r\n        invoices[_invoiceCountryCode][_invoiceCompanyNumber][_invoiceNumber].providerUserId = _providerUserId;\r\n        invoices[_invoiceCountryCode][_invoiceCompanyNumber][_invoiceNumber].invoiceCompanyName = _invoiceCompanyName;\r\n        \r\n        assert(\r\n            invoices[_invoiceCountryCode][_invoiceCompanyNumber][_invoiceNumber].providerUserId != 0x0 && \r\n            invoices[_invoiceCountryCode][_invoiceCompanyNumber][_invoiceNumber].invoiceCompanyName != 0x0\r\n        );\r\n        return true;\r\n    }\r\n    \r\n    /** @dev Add a new invoice provider to the platform  \r\n      * @param _blockchainActionId the blockchain action id\r\n      * @param _userId the user id of the provider\r\n      * @param _companyNumber the providers company number\r\n      * @param _companyName the providers company name\r\n      * @param _countryCode the providers country code\r\n      * @return success true or false if function call is successful\r\n      */\r\n    function setProvider(\r\n        bytes32 _blockchainActionId, bytes32 _userId, bytes32 _companyNumber, \r\n        bytes32 _companyName, bytes2 _countryCode) \r\n        public \r\n        onlyServerOrOnlyPopulous\r\n        returns (bool success)\r\n    {   \r\n        require(actionStatus[_blockchainActionId] == false);\r\n        require(\r\n            providerCompanyData[_userId].companyNumber == 0x0 && \r\n            providerCompanyData[_userId].countryCode == 0x0 &&\r\n            providerCompanyData[_userId].companyName == 0x0);\r\n        \r\n        providerCompanyData[_userId].countryCode = _countryCode;\r\n        providerCompanyData[_userId].companyName = _companyName;\r\n        providerCompanyData[_userId].companyNumber = _companyNumber;\r\n\r\n        providerData[_countryCode][_companyNumber] = _userId;\r\n        return true;\r\n    }\r\n\r\n\r\n    /** @dev Update an added invoice provider to the platform  \r\n      * @param _blockchainActionId the blockchain action id\r\n      * @param _userId the user id of the provider\r\n      * @param _companyNumber the providers company number\r\n      * @param _companyName the providers company name\r\n      * @param _countryCode the providers country code\r\n      * @return success true or false if function call is successful\r\n      */\r\n    function _setProvider(\r\n        bytes32 _blockchainActionId, bytes32 _userId, bytes32 _companyNumber, \r\n        bytes32 _companyName, bytes2 _countryCode) \r\n        public \r\n        onlyServerOrOnlyPopulous\r\n        returns (bool success)\r\n    {   \r\n        require(actionStatus[_blockchainActionId] == false);\r\n        providerCompanyData[_userId].countryCode = _countryCode;\r\n        providerCompanyData[_userId].companyName = _companyName;\r\n        providerCompanyData[_userId].companyNumber = _companyNumber;\r\n        providerData[_countryCode][_companyNumber] = _userId;\r\n        \r\n        setBlockchainActionData(_blockchainActionId, 0x0, 0, _userId, 0x0, 0);\r\n        return true;\r\n    }\r\n\r\n    // CONSTANT METHODS\r\n\r\n    /** @dev Gets a deposit address with the client id \r\n      * @return clientDepositAddress The client's deposit address\r\n      */\r\n    function getDepositAddress(bytes32 _clientId) public view returns (address clientDepositAddress){\r\n        return depositAddresses[_clientId];\r\n    }\r\n\r\n    /** @dev Gets a client id linked to a deposit address \r\n      * @return depositClientId The client id\r\n      */\r\n    function getClientIdWithDepositAddress(address _depositContract) public view returns (bytes32 depositClientId){\r\n        return depositClientIds[_depositContract];\r\n    }\r\n\r\n    /** @dev Gets a currency smart contract address \r\n      * @return currencyAddress The currency address\r\n      */\r\n    function getCurrency(bytes32 _currencySymbol) public view returns (address currencyAddress) {\r\n        return currencyAddresses[_currencySymbol];\r\n    }\r\n   \r\n    /** @dev Gets a currency symbol given it's smart contract address \r\n      * @return currencySymbol The currency symbol\r\n      */\r\n    function getCurrencySymbol(address _currencyAddress) public view returns (bytes32 currencySymbol) {\r\n        return currencySymbols[_currencyAddress];\r\n    }\r\n\r\n    /** @dev Gets details of a currency given it's smart contract address \r\n      * @return _symbol The currency symbol\r\n      * @return _name The currency name\r\n      * @return _decimals The currency decimal places/precision\r\n      */\r\n    function getCurrencyDetails(address _currencyAddress) public view returns (bytes32 _symbol, bytes32 _name, uint8 _decimals) {\r\n        return (CurrencyToken(_currencyAddress).symbol(), CurrencyToken(_currencyAddress).name(), CurrencyToken(_currencyAddress).decimals());\r\n    } \r\n\r\n    /** @dev Get the blockchain action Id Data for a blockchain Action id\r\n      * @param _blockchainActionId the blockchain action id\r\n      * @return bytes32 currency\r\n      * @return uint amount\r\n      * @return bytes32 accountId\r\n      * @return address to\r\n      */\r\n    function getBlockchainActionIdData(bytes32 _blockchainActionId) public view \r\n    returns (bytes32 _currency, uint _amount, bytes32 _accountId, address _to) \r\n    {\r\n        require(actionStatus[_blockchainActionId] == true);\r\n        return (blockchainActionIdData[_blockchainActionId].currency, \r\n        blockchainActionIdData[_blockchainActionId].amount,\r\n        blockchainActionIdData[_blockchainActionId].accountId,\r\n        blockchainActionIdData[_blockchainActionId].to);\r\n    }\r\n\r\n    /** @dev Get the bool status of a blockchain Action id\r\n      * @param _blockchainActionId the blockchain action id\r\n      * @return bool actionStatus\r\n      */\r\n    function getActionStatus(bytes32 _blockchainActionId) public view returns (bool _blockchainActionStatus) {\r\n        return actionStatus[_blockchainActionId];\r\n    }\r\n\r\n    /** @dev Gets the details of an invoice with the country code, company number and invocie number.\r\n      * @param _invoiceCountryCode The country code.\r\n      * @param _invoiceCompanyNumber The company number.\r\n      * @param _invoiceNumber The invoice number\r\n      * @return providerUserId The invoice provider user Id\r\n      * @return invoiceCompanyName the invoice company name\r\n      */\r\n    function getInvoice(bytes2 _invoiceCountryCode, bytes32 _invoiceCompanyNumber, bytes32 _invoiceNumber) \r\n        public \r\n        view \r\n        returns (bytes32 providerUserId, bytes32 invoiceCompanyName) \r\n    {   \r\n        bytes32 _providerUserId = invoices[_invoiceCountryCode][_invoiceCompanyNumber][_invoiceNumber].providerUserId;\r\n        bytes32 _invoiceCompanyName = invoices[_invoiceCountryCode][_invoiceCompanyNumber][_invoiceNumber].invoiceCompanyName;\r\n        return (_providerUserId, _invoiceCompanyName);\r\n    }\r\n\r\n    /** @dev Gets the details of an invoice provider with the country code and company number.\r\n      * @param _providerCountryCode The country code.\r\n      * @param _providerCompanyNumber The company number.\r\n      * @return isEnabled The boolean value true/false indicating whether invoice provider is enabled or not\r\n      * @return providerId The invoice provider user Id\r\n      * @return companyName the invoice company name\r\n      */\r\n    function getProviderByCountryCodeCompanyNumber(bytes2 _providerCountryCode, bytes32 _providerCompanyNumber) \r\n        public \r\n        view \r\n        returns (bytes32 providerId, bytes32 companyName) \r\n    {\r\n        bytes32 providerUserId = providerData[_providerCountryCode][_providerCompanyNumber];\r\n        return (providerUserId, \r\n        providerCompanyData[providerUserId].companyName);\r\n    }\r\n\r\n    /** @dev Gets the details of an invoice provider with the providers user Id.\r\n      * @param _providerUserId The provider user Id.\r\n      * @return countryCode The invoice provider country code\r\n      * @return companyName the invoice company name\r\n      */\r\n    function getProviderByUserId(bytes32 _providerUserId) public view \r\n        returns (bytes2 countryCode, bytes32 companyName, bytes32 companyNumber) \r\n    {\r\n        return (providerCompanyData[_providerUserId].countryCode,\r\n        providerCompanyData[_providerUserId].companyName,\r\n        providerCompanyData[_providerUserId].companyNumber);\r\n    }\r\n\r\n    /** @dev Gets the version number for the current contract instance\r\n      * @return _version The version number\r\n      */\r\n    function getVersion() public view returns (uint256 _version) {\r\n        return version;\r\n    }\r\n\r\n}\r\n\r\n// File: contracts/Populous.sol\r\n\r\n/**\r\nThis is the core module of the system. Currently it holds the code of\r\nthe Bank and crowdsale modules to avoid external calls and higher gas costs.\r\nIt might be a good idea in the future to split the code, separate Bank\r\nand crowdsale modules into external files and have the core interact with them\r\nwith addresses and interfaces. \r\n*/\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/// @title Populous contract\r\ncontract Populous is withAccessManager {\r\n    // EVENTS\r\n    // Bank events\r\n    event EventUSDCToUSDp(bytes32 _blockchainActionId, bytes32 _clientId, uint amount);\r\n    event EventUSDpToUSDC(bytes32 _blockchainActionId, bytes32 _clientId, uint amount);\r\n    event EventDepositAddressUpgrade(bytes32 blockchainActionId, address oldDepositContract, address newDepositContract, bytes32 clientId, uint256 version);\r\n    event EventWithdrawPPT(bytes32 blockchainActionId, bytes32 accountId, address depositContract, address to, uint amount);\r\n    event EventWithdrawPoken(bytes32 _blockchainActionId, bytes32 accountId, bytes32 currency, uint amount);\r\n    event EventNewDepositContract(bytes32 blockchainActionId, bytes32 clientId, address depositContractAddress, uint256 version);\r\n    event EventWithdrawXAUp(bytes32 _blockchainActionId, address erc1155Token, uint amount, uint token_id, bytes32 accountId, uint pptFee);\r\n\r\n    // FIELDS\r\n    struct tokens {   \r\n        address _token;\r\n        uint256 _precision;\r\n    }\r\n    mapping(bytes8 => tokens) public tokenDetails;\r\n\r\n    // NON-CONSTANT METHODS\r\n    // Constructor method called when contract instance is \r\n    // deployed with 'withAccessManager' modifier.\r\n    function Populous(address _accessManager) public withAccessManager(_accessManager) {\r\n        /*ropsten\r\n        \r\n        //pxt\r\n        tokenDetails[0x505854]._token = 0xD8A7C588f8DC19f49dAFd8ecf08eec58e64d4cC9;\r\n        tokenDetails[0x505854]._precision = 8;\r\n        //usdc\r\n        tokenDetails[0x55534443]._token = 0xF930f2C7Bc02F89D05468112520553FFc6D24801;\r\n        tokenDetails[0x55534443]._precision = 6;\r\n        //tusd\r\n        tokenDetails[0x54555344]._token = 0x78e7BEE398D66660bDF820DbDB415A33d011cD48;\r\n        tokenDetails[0x54555344]._precision = 18;\r\n        //ppt\r\n        tokenDetails[0x505054]._token = 0x0ff72e24AF7c09A647865820D4477F98fcB72a2c;        \r\n        tokenDetails[0x505054]._precision = 8;\r\n        //xau\r\n        tokenDetails[0x584155]._token = 0x9b935E3779098bC5E1ffc073CaF916F1E92A6145;\r\n        tokenDetails[0x584155]._precision = 0;\r\n        //usdp\r\n        tokenDetails[0x55534470]._token = 0xf4b1533b6F45fAC936fA508F7e5db6d4BbC4c8bd;\r\n        tokenDetails[0x55534470]._precision = 6;\r\n        */\r\n        \r\n        /*livenet*/\r\n\r\n        //pxt\r\n        tokenDetails[0x505854]._token = 0xc14830E53aA344E8c14603A91229A0b925b0B262;\r\n        tokenDetails[0x505854]._precision = 8;\r\n        //usdc\r\n        tokenDetails[0x55534443]._token = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;\r\n        tokenDetails[0x55534443]._precision = 6;\r\n        //tusd\r\n        tokenDetails[0x54555344]._token = 0x8dd5fbCe2F6a956C3022bA3663759011Dd51e73E;\r\n        tokenDetails[0x54555344]._precision = 18;\r\n        //ppt\r\n        tokenDetails[0x505054]._token = 0xd4fa1460F537bb9085d22C7bcCB5DD450Ef28e3a;        \r\n        tokenDetails[0x505054]._precision = 8;\r\n        //xau\r\n        tokenDetails[0x584155]._token = 0x73a3b7DFFE9af119621f8467D8609771AB4BC33f;\r\n        tokenDetails[0x584155]._precision = 0;\r\n        //usdp\r\n        tokenDetails[0x55534470]._token = 0xBaB5D0f110Be6f4a5b70a2FA22eD17324bFF6576;\r\n        tokenDetails[0x55534470]._precision = 6;\r\n        \r\n    }\r\n\r\n    /**\r\n    BANK MODULE\r\n    */\r\n    // NON-CONSTANT METHODS\r\n\r\n    function usdcToUsdp(\r\n        address _dataManager, bytes32 _blockchainActionId, \r\n        bytes32 _clientId, uint amount)\r\n        public\r\n        onlyServer\r\n    {   \r\n        // client deposit smart contract address\r\n        address _depositAddress = DataManager(_dataManager).getDepositAddress(_clientId);\r\n        require(_dataManager != 0x0 && _depositAddress != 0x0 && amount > 0);\r\n        //transfer usdc from deposit contract to server/admin\r\n        require(DepositContract(_depositAddress).transfer(tokenDetails[0x55534443]._token, msg.sender, amount) == true);\r\n        // mint USDp into depositAddress with amount\r\n        require(CurrencyToken(tokenDetails[0x55534470]._token).mint(amount, _depositAddress) == true);     \r\n        //set action data\r\n        require(DataManager(_dataManager).setBlockchainActionData(_blockchainActionId, 0x55534470, amount, _clientId, _depositAddress, 0) == true); \r\n        //event\r\n        emit EventUSDCToUSDp(_blockchainActionId, _clientId, amount);\r\n    }\r\n\r\n    function usdpToUsdc(\r\n        address _dataManager, bytes32 _blockchainActionId, \r\n        bytes32 _clientId, uint amount) \r\n        public\r\n        onlyServer\r\n    {\r\n        // client deposit smart contract address\r\n        address _depositAddress = DataManager(_dataManager).getDepositAddress(_clientId);\r\n        require(_dataManager != 0x0 && _depositAddress != 0x0 && amount > 0);\r\n        //destroyFrom depositAddress USDp amount\r\n        require(CurrencyToken(tokenDetails[0x55534470]._token).destroyTokensFrom(amount, _depositAddress) == true);\r\n        //transferFrom USDC from server to depositAddress\r\n        require(CurrencyToken(tokenDetails[0x55534443]._token).transferFrom(msg.sender, _depositAddress, amount) == true);\r\n        //set action data\r\n        require(DataManager(_dataManager).setBlockchainActionData(_blockchainActionId, 0x55534470, amount, _clientId, _depositAddress, 0) == true); \r\n        //event\r\n        emit EventUSDpToUSDC(_blockchainActionId, _clientId, amount);\r\n    }\r\n\r\n    // Creates a new 'depositAddress' gotten from deploying a deposit contract linked to a client ID\r\n    function createAddress(address _dataManager, bytes32 _blockchainActionId, bytes32 clientId) \r\n        public\r\n        onlyServer\r\n    {   \r\n        require(_dataManager != 0x0);\r\n        DepositContract newDepositContract;\r\n        DepositContract dc;\r\n        if (DataManager(_dataManager).getDepositAddress(clientId) != 0x0) {\r\n            dc = DepositContract(DataManager(_dataManager).getDepositAddress(clientId));\r\n            newDepositContract = new DepositContract(clientId, AM);\r\n            require(!dc.call(bytes4(keccak256(\"getVersion()\")))); \r\n            // only checking version 1 now to upgrade to version 2\r\n            address PXT = tokenDetails[0x505854]._token;\r\n            address PPT = tokenDetails[0x505054]._token;            \r\n            if(dc.balanceOf(PXT) > 0){\r\n                require(dc.transfer(PXT, newDepositContract, dc.balanceOf(PXT)) == true);\r\n            }\r\n            if(dc.balanceOf(PPT) > 0) {\r\n                require(dc.transfer(PPT, newDepositContract, dc.balanceOf(PPT)) == true);\r\n            }\r\n            require(DataManager(_dataManager)._setDepositAddress(_blockchainActionId, clientId, newDepositContract) == true);\r\n            EventDepositAddressUpgrade(_blockchainActionId, address(dc), DataManager(_dataManager).getDepositAddress(clientId), clientId, newDepositContract.getVersion());\r\n        } else { \r\n            newDepositContract = new DepositContract(clientId, AM);\r\n            require(DataManager(_dataManager).setDepositAddress(_blockchainActionId, newDepositContract, clientId) == true);\r\n            require(DataManager(_dataManager).setBlockchainActionData(_blockchainActionId, 0x0, 0, clientId, DataManager(_dataManager).getDepositAddress(clientId), 0) == true);\r\n            EventNewDepositContract(_blockchainActionId, clientId, DataManager(_dataManager).getDepositAddress(clientId), newDepositContract.getVersion());\r\n        }\r\n    }\r\n\r\n    /* /// Ether to XAUp exchange between deposit contract and Populous.sol\r\n    function exchangeXAUP(\r\n        address _dataManager, bytes32 _blockchainActionId, \r\n        address erc20_tokenAddress, uint erc20_amount, uint xaup_amount, \r\n        uint _tokenId, bytes32 _clientId, address adminExternalWallet) \r\n        public \r\n        onlyServer\r\n    {    \r\n        ERC1155 xa = ERC1155(tokenDetails[0x584155]._token);\r\n        // client deposit smart contract address\r\n        address _depositAddress = DataManager(_dataManager).getDepositAddress(_clientId);\r\n        require(\r\n            // check dataManager contract is valid\r\n            _dataManager != 0x0 &&\r\n            // check deposit address of client\r\n            _depositAddress != 0x0 && \r\n            // check xaup token address\r\n            // tokenDetails[0x584155]._token != 0x0 && \r\n            erc20_tokenAddress != 0x0 &&\r\n            // check action id is unused\r\n            DataManager(_dataManager).getActionStatus(_blockchainActionId) == false &&\r\n            // deposit contract version >= 2\r\n            DepositContract(_depositAddress).getVersion() >= 2 &&\r\n            // populous server xaup balance\r\n            xa.balanceOf(_tokenId, msg.sender) >= xaup_amount\r\n        );\r\n        // transfer erc20 token balance from clients deposit contract to server/admin\r\n        require(DepositContract(_depositAddress).transfer(erc20_tokenAddress, adminExternalWallet, erc20_amount) == true);\r\n        // transfer xaup tokens to clients deposit address from populous server allowance\r\n        xa.safeTransferFrom(msg.sender, _depositAddress, _tokenId, xaup_amount, \"\");\r\n        // set action status in dataManager\r\n        require(DataManager(_dataManager).setBlockchainActionData(_blockchainActionId, 0x0, erc20_amount, _clientId, _depositAddress, 0) == true);\r\n        // emit event \r\n        EventExchangeXAUp(_blockchainActionId, erc20_tokenAddress, erc20_amount, xaup_amount, _tokenId, _clientId, _depositAddress);\r\n    } */\r\n\r\n\r\n    /** dev Import an amount of pokens of a particular currency from an ethereum wallet/address to bank\r\n      * @param _blockchainActionId the blockchain action id\r\n      * @param accountId the account id of the client\r\n      * @param from the blockchain address to import pokens from\r\n      * @param currency the poken currency\r\n      */\r\n    function withdrawPoken(\r\n        address _dataManager, bytes32 _blockchainActionId, \r\n        bytes32 currency, uint256 amount, uint256 amountUSD,\r\n        address from, address to, bytes32 accountId, \r\n        uint256 inCollateral,\r\n        uint256 pptFee, address adminExternalWallet) \r\n        public \r\n        onlyServer \r\n    {\r\n        require(_dataManager != 0x0);\r\n        //DataManager dm = DataManager(_dataManager);\r\n        require(DataManager(_dataManager).getActionStatus(_blockchainActionId) == false && DataManager(_dataManager).getDepositAddress(accountId) != 0x0);\r\n        require(adminExternalWallet != 0x0 && pptFee > 0 && amount > 0);\r\n        require(DataManager(_dataManager).getCurrency(currency) != 0x0);\r\n        DepositContract o = DepositContract(DataManager(_dataManager).getDepositAddress(accountId));\r\n        // check if pptbalance minus collateral held is more than pptFee then transfer pptFee from users ppt deposit to adminWallet\r\n        require(SafeMath.safeSub(o.balanceOf(tokenDetails[0x505054]._token), inCollateral) >= pptFee);\r\n        require(o.transfer(tokenDetails[0x505054]._token, adminExternalWallet, pptFee) == true);\r\n        // WITHDRAW PART / DEBIT\r\n        if(amount > CurrencyToken(DataManager(_dataManager).getCurrency(currency)).balanceOf(from)) {\r\n            // destroying total balance as user has less than pokens they want to withdraw\r\n            require(CurrencyToken(DataManager(_dataManager).getCurrency(currency)).destroyTokensFrom(CurrencyToken(DataManager(_dataManager).getCurrency(currency)).balanceOf(from), from) == true);\r\n            //remaining ledger balance of deposit address is 0\r\n        } else {\r\n            // destroy amount from balance as user has more than pokens they want to withdraw\r\n            require(CurrencyToken(DataManager(_dataManager).getCurrency(currency)).destroyTokensFrom(amount, from) == true);\r\n            //left over balance is deposit address balance.\r\n        }\r\n        // TRANSFER PART / CREDIT\r\n        // approve currency amount for populous for the next require to pass\r\n        if(amountUSD > 0) //give the user USDC\r\n        {\r\n            CurrencyToken(tokenDetails[0x55534443]._token).transferFrom(msg.sender, to, amountUSD);\r\n        }else { //give the user GBP / poken currency\r\n            CurrencyToken(DataManager(_dataManager).getCurrency(currency)).transferFrom(msg.sender, to, amount);\r\n        }\r\n        require(DataManager(_dataManager).setBlockchainActionData(_blockchainActionId, currency, amount, accountId, to, pptFee) == true); \r\n        EventWithdrawPoken(_blockchainActionId, accountId, currency, amount);\r\n    }\r\n\r\n    /** @dev Withdraw an amount of PPT Populous tokens to a blockchain address \r\n      * @param _blockchainActionId the blockchain action id\r\n      * @param pptAddress the address of the PPT smart contract\r\n      * @param accountId the account id of the client\r\n      * @param pptFee the amount of fees to pay in PPT tokens\r\n      * @param adminExternalWallet the platform admin wallet address to pay the fees to \r\n      * @param to the blockchain address to withdraw and transfer the pokens to\r\n      * @param inCollateral the amount of pokens withheld by the platform\r\n      */    \r\n    function withdrawERC20(\r\n        address _dataManager, bytes32 _blockchainActionId, \r\n        address pptAddress, bytes32 accountId, \r\n        address to, uint256 amount, uint256 inCollateral, \r\n        uint256 pptFee, address adminExternalWallet) \r\n        public \r\n        onlyServer \r\n    {   \r\n        require(_dataManager != 0x0);\r\n        require(DataManager(_dataManager).getActionStatus(_blockchainActionId) == false && DataManager(_dataManager).getDepositAddress(accountId) != 0x0);\r\n        require(adminExternalWallet != 0x0 && pptFee >= 0 && amount > 0);\r\n        address depositContract = DataManager(_dataManager).getDepositAddress(accountId);\r\n        if(pptAddress == tokenDetails[0x505054]._token) {\r\n            uint pptBalance = SafeMath.safeSub(DepositContract(depositContract).balanceOf(tokenDetails[0x505054]._token), inCollateral);\r\n            require(pptBalance >= SafeMath.safeAdd(amount, pptFee));\r\n        } else {\r\n            uint erc20Balance = DepositContract(depositContract).balanceOf(pptAddress);\r\n            require(erc20Balance >= amount);\r\n        }\r\n        require(DepositContract(depositContract).transfer(tokenDetails[0x505054]._token, adminExternalWallet, pptFee) == true);\r\n        require(DepositContract(depositContract).transfer(pptAddress, to, amount) == true);\r\n        bytes32 tokenSymbol = iERC20Token(pptAddress).symbol();    \r\n        require(DataManager(_dataManager).setBlockchainActionData(_blockchainActionId, tokenSymbol, amount, accountId, to, pptFee) == true);\r\n        EventWithdrawPPT(_blockchainActionId, accountId, DataManager(_dataManager).getDepositAddress(accountId), to, amount);\r\n    }\r\n\r\n    // erc1155 withdraw function from deposit contract\r\n/*     function withdrawERC1155(\r\n        address _dataManager, bytes32 _blockchainActionId,\r\n        address _to, uint256 _id, uint256 _value,\r\n        bytes32 accountId, uint256 pptFee, \r\n        address adminExternalWallet) \r\n        public\r\n        onlyServer \r\n    {\r\n        require(DataManager(_dataManager).getActionStatus(_blockchainActionId) == false && DataManager(_dataManager).getDepositAddress(accountId) != 0x0);\r\n        require(adminExternalWallet != 0x0 && pptFee > 0 && _value > 0);\r\n        DepositContract o = DepositContract(DataManager(_dataManager).getDepositAddress(accountId));\r\n        require(o.transfer(tokenDetails[0x505054]._token, adminExternalWallet, pptFee) == true);\r\n        // transfer xaup tokens to address from deposit contract\r\n        require(o.transferERC1155(tokenDetails[0x584155]._token, _to, _id, _value) == true);\r\n        // set action status in dataManager\r\n        require(DataManager(_dataManager).setBlockchainActionData(_blockchainActionId, 0x584155, _value, accountId, _to, pptFee) == true);\r\n        // emit event \r\n        EventWithdrawXAUp(_blockchainActionId, tokenDetails[0x584155]._token, _value, _id, accountId, pptFee);\r\n    } */\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_accessManager\",\"type\":\"address\"}],\"name\":\"updateAccessManager\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_dataManager\",\"type\":\"address\"},{\"name\":\"_blockchainActionId\",\"type\":\"bytes32\"},{\"name\":\"pptAddress\",\"type\":\"address\"},{\"name\":\"accountId\",\"type\":\"bytes32\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"inCollateral\",\"type\":\"uint256\"},{\"name\":\"pptFee\",\"type\":\"uint256\"},{\"name\":\"adminExternalWallet\",\"type\":\"address\"}],\"name\":\"withdrawERC20\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_dataManager\",\"type\":\"address\"},{\"name\":\"_blockchainActionId\",\"type\":\"bytes32\"},{\"name\":\"currency\",\"type\":\"bytes32\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"amountUSD\",\"type\":\"uint256\"},{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"accountId\",\"type\":\"bytes32\"},{\"name\":\"inCollateral\",\"type\":\"uint256\"},{\"name\":\"pptFee\",\"type\":\"uint256\"},{\"name\":\"adminExternalWallet\",\"type\":\"address\"}],\"name\":\"withdrawPoken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_dataManager\",\"type\":\"address\"},{\"name\":\"_blockchainActionId\",\"type\":\"bytes32\"},{\"name\":\"_clientId\",\"type\":\"bytes32\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"usdpToUsdc\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_dataManager\",\"type\":\"address\"},{\"name\":\"_blockchainActionId\",\"type\":\"bytes32\"},{\"name\":\"_clientId\",\"type\":\"bytes32\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"usdcToUsdp\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes8\"}],\"name\":\"tokenDetails\",\"outputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_precision\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_dataManager\",\"type\":\"address\"},{\"name\":\"_blockchainActionId\",\"type\":\"bytes32\"},{\"name\":\"clientId\",\"type\":\"bytes32\"}],\"name\":\"createAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"AM\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_accessManager\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_blockchainActionId\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"_clientId\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"EventUSDCToUSDp\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_blockchainActionId\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"_clientId\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"EventUSDpToUSDC\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"blockchainActionId\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"oldDepositContract\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newDepositContract\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"clientId\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"version\",\"type\":\"uint256\"}],\"name\":\"EventDepositAddressUpgrade\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"blockchainActionId\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"accountId\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"depositContract\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"EventWithdrawPPT\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_blockchainActionId\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"accountId\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"currency\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"EventWithdrawPoken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"blockchainActionId\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"clientId\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"depositContractAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"version\",\"type\":\"uint256\"}],\"name\":\"EventNewDepositContract\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_blockchainActionId\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"erc1155Token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"token_id\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"accountId\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"pptFee\",\"type\":\"uint256\"}],\"name\":\"EventWithdrawXAUp\",\"type\":\"event\"}]","ContractName":"Populous","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"00000000000000000000000098ca4bf7e522cd6d2f69cf843dfab327a1e26497","Library":"","SwarmSource":"bzzr://a86dc7fbc2c1c0b454419afd083251cfc3ed2e84c0790b25bd36c155f488fdff"}]}