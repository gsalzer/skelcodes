{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.0;\r\n\r\ncontract owned {\r\n    address owner;\r\n\r\n    modifier onlyowner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n\r\n    }\r\n\r\n     constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n}\r\n\r\nlibrary SafeMath {\r\n  function safeMul(uint a, uint b) internal pure returns (uint) {\r\n    uint c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function safeSub(uint a, uint b) internal pure returns (uint) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function safeAdd(uint a, uint b) internal pure returns (uint) {\r\n    uint c = a + b;\r\n    assert(c>=a && c>=b);\r\n    return c;\r\n  }\r\n\r\n\r\n}\r\n\r\ncontract ERC20Interface {\r\n    // Get the total token supply\r\n    function totalSupply() view public returns (uint256);\r\n\r\n    // Get the account balance of another account with address _owner\r\n    function balanceOf(address _owner) view public returns (uint256);\r\n\r\n    // Send _value amount of tokens to address _to\r\n    function transfer(address _to, uint256 _value) public returns (bool success);\r\n\r\n    // Send _value amount of tokens from address _from to address _to\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\r\n\r\n    // Allow _spender to withdraw from your account, multiple times, up to the _value amount.\r\n    // If this function is called again it overwrites the current allowance with _value.\r\n    // this function is required for some DEX functionality\r\n    function approve(address _spender, uint256 _value) public returns (bool success);\r\n\r\n    // Returns the amount which _spender is still allowed to withdraw from _owner\r\n    function allowance(address _owner, address _spender) view public returns (uint256 remaining);\r\n\r\n    // Triggered when tokens are transferred.\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n\r\n    // Triggered whenever approve(address _spender, uint256 _value) is called.\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}\r\n\r\ncontract swapToken is  owned{\r\n    ////////////////\r\n    ///// EVENTS /////\r\n    //////////////////\r\n    event DepositForEthReceived(address indexed _from, uint _amount, uint _timestamp);\r\n    event withdrawalSwappedAsset(address indexed _to, uint indexed _symbolIndex, uint _amount, uint _timestamp);\r\n    event DepositForTokenReceived(address indexed _from, uint indexed _symbolIndex, uint _amount, uint _timestamp);\r\n\r\n    using SafeMath for uint256;\r\n    \r\n      //////////////\r\n    // BALANCES //\r\n    //////////////\r\n    mapping (address => mapping (uint256 => uint)) tokenBalanceForAddress;\r\n      struct Contracts {\r\n         address contractAddr;\r\n    }\r\n    mapping (uint => Contracts) public ContractAddresses;\r\n   \r\n\r\n    mapping (address => uint) balanceEthForAddress;\r\n       function depositEther() public payable {\r\n        require(balanceEthForAddress[msg.sender] + msg.value >= balanceEthForAddress[msg.sender]);\r\n        balanceEthForAddress[msg.sender] += msg.value;\r\n        emit DepositForEthReceived(msg.sender, msg.value, now);\r\n    }\r\n    \r\n    \r\n     function addTokenContractAddress(string memory _symbol, address _contract) public{\r\n         uint index = getSymbolContract(_symbol);\r\n          require(index > 0);\r\n         ContractAddresses[index] = Contracts(_contract);\r\n        \r\n    }\r\n    \r\n    \r\n    \r\n      function getSymbolContract(string memory _symbol) internal pure returns (uint) {\r\n          uint index = 0;\r\n         if(compareStringsbyBytes(_symbol,\"BINS\") || compareStringsbyBytes(_symbol,\"BIB\") || compareStringsbyBytes(_symbol,\"DAIX\")){\r\n             if(compareStringsbyBytes(_symbol,\"BINS\")){\r\n               index = 1;\r\n             }else if(compareStringsbyBytes(_symbol,\"BIB\")){\r\n                index = 2; \r\n             }else if(compareStringsbyBytes(_symbol,\"DAIX\")){\r\n                index = 3; \r\n             }\r\n             return index;\r\n         }else{\r\n            revert(); \r\n         }\r\n         \r\n        return 0;\r\n    }\r\n\r\n\r\n function compareStringsbyBytes(string memory s1, string memory s2) public pure returns(bool){\r\n    return keccak256(bytes(s1)) == keccak256(bytes(s2));\r\n}\r\n\r\n    \r\n      function getTokenContractAddress(string memory _a) view public returns(address){\r\n           uint index = getSymbolContract(_a);\r\n           require(index > 0);\r\n          return ContractAddresses[index].contractAddr;\r\n     }\r\n     \r\n        function getTokenSymbolByContractAddress(string memory _a) view public returns(uint256){\r\n          \r\n           uint index = getSymbolContract(_a);\r\n           require(index > 0);\r\n            ERC20Interface token = ERC20Interface(ContractAddresses[index].contractAddr);\r\n\r\n            return token.totalSupply();\r\n     }\r\n     \r\n    \r\n      \r\n      \r\n      function swapAsset(string memory _symbol) public {\r\n           if(compareStringsbyBytes(_symbol,\"DAIX\")) revert(); \r\n       uint256 amountDue = 0;\r\n       uint swapFromindex = getSymbolContract(_symbol);\r\n     \r\n      \r\n       require(swapFromindex > 0);\r\n       ERC20Interface swapFrom = ERC20Interface(ContractAddresses[swapFromindex].contractAddr);\r\n  \r\n      // require(swapFrom.approve(address(this), swapFrom.balanceOf(msg.sender)) == true);\r\n        require(ContractAddresses[swapFromindex].contractAddr != address(0));\r\n        \r\n        require(swapFrom.transferFrom(msg.sender, address(this), swapFrom.balanceOf(msg.sender)) == true);\r\n        require(tokenBalanceForAddress[msg.sender][swapFromindex] + swapFrom.balanceOf(msg.sender) >= tokenBalanceForAddress[msg.sender][swapFromindex]);\r\n       if(compareStringsbyBytes(_symbol,\"BINS\")){\r\n            amountDue = swapFrom.balanceOf(msg.sender);\r\n        }else if(compareStringsbyBytes(_symbol,\"BIB\")){\r\n             amountDue = swapFrom.balanceOf(msg.sender) / 200 * 3;\r\n        }\r\n        \r\n        tokenBalanceForAddress[msg.sender][swapFromindex] += amountDue;\r\n        emit DepositForTokenReceived(msg.sender, swapFromindex, amountDue, now);\r\n        \r\n      }\r\n      \r\n    function withdrawSwappedAsset(string memory _symbol) public {\r\n        string memory toAssetSymbol = \"DAIX\";\r\n        uint symbolIndex = getSymbolContract(toAssetSymbol);\r\n        uint withdrawSymbolIndex = getSymbolContract(_symbol);\r\n        uint256 amount = tokenBalanceForAddress[msg.sender][withdrawSymbolIndex];\r\n        require(ContractAddresses[symbolIndex].contractAddr != address(0));\r\n\r\n        ERC20Interface token = ERC20Interface(ContractAddresses[symbolIndex].contractAddr);\r\n\r\n        require(tokenBalanceForAddress[msg.sender][withdrawSymbolIndex] - amount >= 0);\r\n        require(tokenBalanceForAddress[msg.sender][withdrawSymbolIndex] - amount <= tokenBalanceForAddress[msg.sender][withdrawSymbolIndex]);\r\n\r\n        tokenBalanceForAddress[msg.sender][withdrawSymbolIndex] -= amount;\r\n        require(token.transfer(msg.sender, amount) == true);\r\n        emit withdrawalSwappedAsset(msg.sender, withdrawSymbolIndex, amount, now);\r\n    }\r\n    \r\n    \r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"_a\",\"type\":\"string\"}],\"name\":\"getTokenSymbolByContractAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_symbol\",\"type\":\"string\"}],\"name\":\"withdrawSwappedAsset\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_a\",\"type\":\"string\"}],\"name\":\"getTokenContractAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"depositEther\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_symbol\",\"type\":\"string\"}],\"name\":\"swapAsset\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"ContractAddresses\",\"outputs\":[{\"name\":\"contractAddr\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"s1\",\"type\":\"string\"},{\"name\":\"s2\",\"type\":\"string\"}],\"name\":\"compareStringsbyBytes\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_symbol\",\"type\":\"string\"},{\"name\":\"_contract\",\"type\":\"address\"}],\"name\":\"addTokenContractAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_timestamp\",\"type\":\"uint256\"}],\"name\":\"DepositForEthReceived\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_symbolIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_timestamp\",\"type\":\"uint256\"}],\"name\":\"withdrawalSwappedAsset\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_symbolIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_timestamp\",\"type\":\"uint256\"}],\"name\":\"DepositForTokenReceived\",\"type\":\"event\"}]","ContractName":"swapToken","CompilerVersion":"v0.5.0+commit.1d4f565a","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://bbfffe35409eaacedae56e9a992ce5b0c110ef5eddc3061a70359c567f03c525"}]}