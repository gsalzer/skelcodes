{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity >=0.5.0 <0.6.0;\r\n\r\n/**\r\n * Author: Sik Jean Soon\r\n */\r\n\r\n/**\r\n * @title SafeMath for uint256\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMathUint256 {\r\n    /**\r\n    * @dev Multiplies two numbers, throws on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        c = a * b;\r\n        require(c / a == b, \"Multiplier exception\");\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two numbers, truncating the quotient.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a / b; // Solidity automatically throws when dividing by 0\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"Subtraction exception\");\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, throws on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        c = a + b;\r\n        require(c >= a, \"Addition exception\");\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\r\n    * reverts when dividing by zero.\r\n    */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0, \"Modulo exception\");\r\n        return a % b;\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * @title SafeMath for uint8\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMathUint8 {\r\n    /**\r\n    * @dev Multiplies two numbers, throws on overflow.\r\n    */\r\n    function mul(uint8 a, uint8 b) internal pure returns (uint8 c) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        c = a * b;\r\n        require(c / a == b, \"Multiplier exception\");\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two numbers, truncating the quotient.\r\n    */\r\n    function div(uint8 a, uint8 b) internal pure returns (uint8) {\r\n        return a / b; // Solidity automatically throws when dividing by 0\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint8 a, uint8 b) internal pure returns (uint8) {\r\n        require(b <= a, \"Subtraction exception\");\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, throws on overflow.\r\n    */\r\n    function add(uint8 a, uint8 b) internal pure returns (uint8 c) {\r\n        c = a + b;\r\n        require(c >= a, \"Addition exception\");\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\r\n    * reverts when dividing by zero.\r\n    */\r\n    function mod(uint8 a, uint8 b) internal pure returns (uint8) {\r\n        require(b != 0, \"Modulo exception\");\r\n        return a % b;\r\n    }\r\n\r\n}\r\n\r\ncontract Common {\r\n    bytes32 internal LABEL_CODE_STAKER;\r\n    bytes32 internal LABEL_CODE_STAKER_CONTROLLER;\r\n    bytes32 internal LABEL_CODE_SIGNER_CONTROLLER;\r\n    bytes32 internal LABEL_CODE_SIGNER;\r\n    bytes32 internal LABEL_CODE_BACKSYS;\r\n    bytes32 internal LABEL_CODE_OPS;\r\n\r\n    uint8 constant internal MAX_WALLET = 64;\r\n    uint256 constant internal WALLET_FLAG_ALL = (2 ** (uint256(MAX_WALLET))) - 1;\r\n\r\n    constructor() public\r\n    {\r\n        LABEL_CODE_STAKER = encodePacked(\"STAKER\");\r\n        LABEL_CODE_STAKER_CONTROLLER = encodePacked(\"STAKER_CONTROLLER\");\r\n        LABEL_CODE_SIGNER_CONTROLLER = encodePacked(\"SIGNER_CONTROLLER\");\r\n        LABEL_CODE_SIGNER = encodePacked(\"SIGNER\");\r\n        LABEL_CODE_BACKSYS = encodePacked(\"BACKSYS\");\r\n        LABEL_CODE_OPS = encodePacked(\"OPS\");\r\n    }\r\n\r\n    function encodePacked(string memory s) internal pure\r\n        returns (bytes32)\r\n    {\r\n        return keccak256(abi.encodePacked(s));\r\n    }\r\n\r\n    function convertBytesToBytes4(bytes memory _in) internal pure\r\n        returns (bytes4 out)\r\n    {\r\n        if (0 == _in.length)\r\n            return 0x0;\r\n\r\n        assembly {\r\n            out := mload(add(_in, 32))\r\n        }\r\n    }\r\n\r\n    function isContract(address _address) internal view\r\n        returns (bool)\r\n    {\r\n        uint32 size;\r\n        assembly {\r\n            size := extcodesize(_address)\r\n        }\r\n        return (0 < size);\r\n    }\r\n\r\n}\r\n\r\ncontract Label is Common {\r\n    string public class;\r\n    string public label;\r\n    string public description;\r\n\r\n    bytes32 public classCode;\r\n    bytes32 public labelCode;\r\n\r\n    constructor(string memory _class, string memory _label, string memory _description) public\r\n    {\r\n        class = _class;        \r\n        label = _label;\r\n        description = _description;\r\n\r\n        classCode = encodePacked(_class);\r\n        labelCode = encodePacked(_label);\r\n    }\r\n\r\n}\r\n\r\n\r\ncontract MultiSigNode is Label {\r\n    using SafeMathUint8 for uint8;\r\n\r\n    address payable public root;\r\n    address public parent;\r\n\r\n    // wallet index => wallet address\r\n    mapping(uint8 => address) public wallets;\r\n    // wallet address => wallet bit position\r\n    mapping(address => uint8) public walletsIndex;\r\n\r\n    // Normal wallet\r\n    uint8 public walletCount;\r\n    // Total wallet = normal wallet + contract wallet\r\n    uint8 public totalWallet;\r\n\r\n    modifier onlyRoot() {\r\n        require(msg.sender == root, \"Node.onlyRoot: Access denied\");\r\n        _;\r\n    }\r\n\r\n    constructor(address payable _root, address[] memory _wallets, string memory _label, string memory _description) public\r\n        Label(\"NODE\", _label, _description)\r\n    {\r\n        require(address(0) != _root, \"Node: Root address is empty\");\r\n        require(MAX_WALLET >= _wallets.length, \"Node: Wallet list exceeded limit\");\r\n\r\n        root = _root;\r\n\r\n        for (uint8 i = 1; _wallets.length >= i; i = i.add(1)) {\r\n            address wallet = _wallets[i.sub(1)];\r\n\r\n            require(address(0) != wallet, \"Node: Wallet address is empty\");\r\n            require(0 == walletsIndex[wallet], \"Node: Duplicated wallet address\");\r\n\r\n            wallets[i] = wallet;\r\n            walletsIndex[wallet] = i;\r\n\r\n            if (!isContract(wallet))\r\n                walletCount = walletCount.add(1);\r\n        }\r\n\r\n        totalWallet = uint8(_wallets.length);\r\n    }\r\n\r\n    function init(address _parent) external\r\n        onlyRoot\r\n    {\r\n        parent = _parent;\r\n\r\n        if (0 < totalWallet) {\r\n            uint8 count = 0;\r\n\r\n            for (uint8 i = 1; i <= MAX_WALLET && count <= totalWallet; i = i.add(1)) {\r\n                address wallet = wallets[i];\r\n\r\n                if (address(0) != wallet) {\r\n                    count = count.add(1);\r\n\r\n                    // Notify root this attached wallet, root will set parent address (if this is node)\r\n                    MultiSigRoot(root).attachWalletOrNode(wallet);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    function term() external\r\n        onlyRoot\r\n    {\r\n        if (0 < totalWallet) {\r\n            uint8 count = 0;\r\n\r\n            for (uint8 i = 1; i <= MAX_WALLET && count <= totalWallet; i = i.add(1)) {\r\n                address wallet = wallets[i];\r\n\r\n                if (address(0) != wallet) {\r\n                    count = count.add(1);\r\n\r\n                    // Notify root to remove this wallet from list\r\n                    MultiSigRoot(root).detachWalletOrNode(wallet);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    function attach(uint8 _index, address _wallet) external\r\n        onlyRoot\r\n        returns (bool)\r\n    {\r\n        require(0 < _index && MAX_WALLET >= _index, \"Node.attach: Index out of range\");\r\n        require(address(0) != _wallet, \"Node.attach: Wallet address is empty\");\r\n        require(0 == walletsIndex[_wallet], \"Node.attach: Duplicated wallet address\");\r\n\r\n        if (address(0) != wallets[_index])\r\n            detach(wallets[_index]);\r\n\r\n        walletsIndex[_wallet] = _index;\r\n        wallets[_index] = _wallet;\r\n\r\n        if (!isContract(_wallet))\r\n            walletCount = walletCount.add(1);\r\n\r\n        totalWallet = totalWallet.add(1);\r\n\r\n        // Notify root this attached wallet, root will trigger attach operation (if this wallet is a contract)\r\n        MultiSigRoot(root).attachWalletOrNode(_wallet);\r\n\r\n        return true;\r\n    }\r\n\r\n    function detach(address _wallet) public\r\n        onlyRoot\r\n        returns (bool)\r\n    {\r\n        require(address(0) != _wallet, \"Node.detach: Wallet address is empty\");\r\n\r\n        uint8 index = walletsIndex[_wallet];\r\n        require(0 < index && MAX_WALLET >= index, \"Node.detach: Wallet address is not registered\");\r\n\r\n        if (!isContract(_wallet))\r\n            walletCount = walletCount.sub(1);\r\n\r\n        totalWallet = totalWallet.sub(1);\r\n\r\n        delete wallets[index];\r\n        delete walletsIndex[_wallet];\r\n\r\n        // Notify root to remove this wallet from list\r\n        MultiSigRoot(root).detachWalletOrNode(_wallet);\r\n\r\n        return true;\r\n    }\r\n\r\n    function getRootNode() external view\r\n        returns (address)\r\n    {\r\n        if (address(0) == parent)\r\n            return address(this);\r\n\r\n        return MultiSigNode(parent).getRootNode();\r\n    }\r\n\r\n}\r\n\r\n\r\n/**\r\n * NOTE: Regulator is meant for changable rules for multi-sig\r\n */\r\ncontract MultiSigRegulator is Label {\r\n    using SafeMathUint8 for uint8;\r\n    using SafeMathUint256 for uint256;\r\n\r\n    event TransactionLimitChanged(string requirementType, uint256 limit);\r\n\r\n    address payable public root;\r\n\r\n    address private creator;\r\n\r\n    // Cached parameters\r\n    address private argTo;\r\n    uint256 private argValue;\r\n\r\n    bool public isSealed;\r\n\r\n    // Daily transaction limit (mapped: requirement type => TransactionLimit)\r\n    mapping(bytes32 => TransactionLimit) public transactionLimits;\r\n\r\n    struct TransactionLimit {\r\n        uint256 datetime;\r\n        uint256 volume;\r\n        uint256 upperLimit;\r\n    }\r\n\r\n    modifier onlySealed() {\r\n        require(isSealed, \"Regulator.onlySealed: Not sealed\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyMe() {\r\n        require(msg.sender == address(this), \"Regulator.onlyMe: Access denied\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyRoot() {\r\n        require(msg.sender == root, \"Regulator.onlyRoot: Access denied\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyCreator() {\r\n        require(msg.sender == creator, \"Regulator.onlyCreator: Access denied\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * Supported non-payable default function\r\n     */\r\n    function () external\r\n        onlyMe\r\n        onlySealed\r\n    {\r\n        revert(\"Regulator: Not supported\");\r\n    }\r\n\r\n    constructor(address payable _root, string memory _label, string memory _description) public\r\n        Label(\"REGULATOR\", _label, _description)\r\n    {\r\n        require(address(0) != _root, \"Regulator: Root address is empty\");\r\n        root = _root;\r\n        creator = msg.sender;\r\n    }\r\n\r\n    /**\r\n     * Supported non-payable function: ERC_ER_SHI.increaseSupply\r\n     * Only can be called by this contract itself to resolve calldata\r\n     */\r\n    function increaseSupply(uint256 _value, address /* _to */) external\r\n        onlyMe\r\n        onlySealed\r\n    {\r\n        defaultRequirement(\"increaseSupply\", _value);\r\n    }\r\n\r\n    /**\r\n     * Supported non-payable function: ERC_ER_SHI.decreaseSupply\r\n     * Only can be called by this contract itself to resolve calldata\r\n     */\r\n    function decreaseSupply(uint256 _value, address /* _from */) external\r\n        onlyMe\r\n        onlySealed\r\n    {\r\n        defaultRequirement(\"decreaseSupply\", _value);\r\n    }\r\n\r\n    /**\r\n     * Supported non-payable function: ERC_ER_SHI.freeze\r\n     * Only can be called by this contract itself to resolve calldata\r\n     */\r\n    function freeze(address /* _from */, uint256 /* _value */) external\r\n        onlyMe\r\n        onlySealed\r\n    {\r\n        requirement1Backsys();\r\n    }\r\n\r\n    /**\r\n     * Supported non-payable function: ERC_ER_SHI.unfreeze\r\n     * Only can be called by this contract itself to resolve calldata\r\n     */\r\n    function unfreeze(address /* _from */, uint256 /* _value */) external\r\n        onlyMe\r\n        onlySealed\r\n    {\r\n        requirement1Backsys();\r\n    }\r\n\r\n    /**\r\n     * Supported non-payable function: ERC_ER_SHI.freezeAddress\r\n     * Only can be called by this contract itself to resolve calldata\r\n     */\r\n    function freezeAddress(address /* _addressOf */) external\r\n        onlyMe\r\n        onlySealed\r\n    {\r\n        requirement1Backsys();\r\n    }\r\n\r\n    /**\r\n     * Supported non-payable function: ERC_ER_SHI.unfreezeAddress\r\n     * Only can be called by this contract itself to resolve calldata\r\n     */\r\n    function unfreezeAddress(address /* _addressOf */) external\r\n        onlyMe\r\n        onlySealed\r\n    {\r\n        requirement1Backsys();\r\n    }\r\n\r\n    /**\r\n     * Supported non-payable function: Ownership.acceptOwnership\r\n     * Only can be called by this contract itself to resolve calldata\r\n     */\r\n    function acceptOwnership () external\r\n        onlyMe\r\n        onlySealed\r\n    {\r\n        requirement(LABEL_CODE_OPS, 2, 1); // INDEX 2: ONE SIGNABLE\r\n        requirement(LABEL_CODE_SIGNER_CONTROLLER, 1, 1); // INDEX 1: ONE SIGNABLE\r\n    }\r\n\r\n    /**\r\n     * Supported non-payable function: Ownership.transferOwnership\r\n     * Only can be called by this contract itself to resolve calldata\r\n     */\r\n    function transferOwnership (address payable /* _newOwner */) external\r\n        onlyMe\r\n        onlySealed\r\n    {\r\n        requirement(LABEL_CODE_STAKER, WALLET_FLAG_ALL, 1); // ANY ONE SIGNABLE\r\n        requirement(LABEL_CODE_STAKER_CONTROLLER, WALLET_FLAG_ALL, uint8(-1)); // ALL SIGNABLE\r\n        requirement(LABEL_CODE_SIGNER_CONTROLLER, WALLET_FLAG_ALL, 1); // ANY ONE SIGNABLE\r\n    }\r\n\r\n    /**\r\n     * Supported non-payable function: Controllable.pause\r\n     * Only can be called by this contract itself to resolve calldata\r\n     */\r\n    function pause () external\r\n        onlyMe\r\n        onlySealed\r\n    {\r\n        requirement(LABEL_CODE_STAKER_CONTROLLER, WALLET_FLAG_ALL, 1); // ANY ONE SIGNABLE\r\n    }\r\n\r\n    /**\r\n     * Supported non-payable function: Controllable.resume\r\n     * Only can be called by this contract itself to resolve calldata\r\n     */\r\n    function resume () external\r\n        onlyMe\r\n        onlySealed\r\n    {\r\n        requirement(LABEL_CODE_STAKER_CONTROLLER, WALLET_FLAG_ALL, 2); // ANY TWO SIGNABLE\r\n    }\r\n\r\n    /**\r\n     * Supported non-payable function: MultiSigRegulator.setTransactionLimit\r\n     */\r\n    function setTransactionLimit(string calldata _requirementType, uint256 _limit) external\r\n    {\r\n        if (msg.sender == root || !isSealed) {\r\n            // Set transaction limit\r\n            transactionLimits[encodePacked(_requirementType)].upperLimit = _limit;\r\n            emit TransactionLimitChanged(_requirementType, _limit);\r\n        }\r\n        else {\r\n            require(msg.sender == address(this), \"Regulator.setTransactionLimit: Access denied\");\r\n\r\n            // Create requirements for this transaction\r\n            requirement(LABEL_CODE_STAKER_CONTROLLER, WALLET_FLAG_ALL, 2); // ANY TWO SIGNABLE\r\n        }\r\n    }\r\n\r\n    function seal() external\r\n        onlyCreator\r\n    {\r\n        require(!isSealed, \"Regulator.seal: Access denied\");\r\n        isSealed = true;\r\n    }\r\n\r\n    function createRequirement(uint256 /* _transactionCode */, address /* _from */, address _to, uint256 _value, bytes calldata _data) external\r\n        onlyRoot\r\n    {\r\n        // Cache parameters\r\n        argTo = _to;\r\n        argValue = _value;\r\n\r\n        // Perform self call to determine function details for requirement setup\r\n        (bool success, bytes memory returnData) = address(this).call.value(_value)(_data);\r\n\r\n        if (!success) {\r\n            // Check the error string is available or not\r\n            if (0 == returnData.length || bytes4(0x08c379a0) != convertBytesToBytes4(returnData))\r\n                revert(\"Regulator.createRequirement: Function call failed\");\r\n            else {\r\n                bytes memory bytesArray = new bytes(returnData.length);\r\n                for (uint256 i = 0; i < returnData.length.sub(4); i = i.add(1)) {\r\n                    bytesArray[i] = returnData[i.add(4)];\r\n                }\r\n\r\n                (string memory reason) = abi.decode(bytesArray, (string));\r\n                revert(reason);\r\n            }\r\n        }\r\n    }\r\n\r\n    function requirement(bytes32 _labelCode, uint256 _flag, uint8 _required) private\r\n    {\r\n        MultiSigRoot(root).createRequirement(_labelCode, _flag, _required);\r\n    }\r\n\r\n    function defaultRequirement(string memory _requirementType, uint256 _value) private\r\n    {\r\n        bytes32 t = encodePacked(_requirementType);\r\n\r\n        // Check transaction volume limit\r\n        TransactionLimit storage limit = transactionLimits[t];\r\n\r\n        // Check transaction volume limit\r\n        if (0 < limit.upperLimit) {\r\n            // Truncate timestamp (YYYYMMDD) to daily (UTC time)\r\n            uint256 dt = now - (now % 86400);\r\n\r\n            if (dt == limit.datetime)\r\n                limit.volume = limit.volume.add(_value);\r\n            else {\r\n                // Reset volume on new day\r\n                limit.datetime = dt;\r\n                limit.volume = _value;\r\n            }\r\n\r\n            require(limit.upperLimit >= limit.volume, \"Regulator.defaultRequirement: Exceeded limit\");\r\n        }\r\n\r\n        // Create requirement for this transaction\r\n        requirement(LABEL_CODE_OPS, WALLET_FLAG_ALL, 4); // ANY FOUR SIGNABLE\r\n    }\r\n\r\n    function requirement1Backsys() private\r\n    {\r\n        requirement(LABEL_CODE_BACKSYS, WALLET_FLAG_ALL, 1); // ANY ONE SIGNABLE\r\n    }\r\n\r\n}\r\n\r\n\r\ncontract MultiSigRoot is Label {\r\n    using SafeMathUint8 for uint8;\r\n    using SafeMathUint256 for uint256;\r\n\r\n    uint8 constant private WALLET_TYPE_WALLET = 1;\r\n    uint8 constant private WALLET_TYPE_NODE = 2;\r\n\r\n    uint8 constant private TRANSACTION_STATUS_EMPTY = 0;\r\n    uint8 constant private TRANSACTION_STATUS_PENDING = 1;\r\n    uint8 constant private TRANSACTION_STATUS_EXECUTED = 2;\r\n    uint8 constant private TRANSACTION_STATUS_FAILURE = 3;\r\n    uint8 constant private TRANSACTION_STATUS_REVOKED = 4;\r\n\r\n    event Confirmation(address indexed sender, uint256 indexed transactionCode);\r\n    event Revocation(address indexed sender, uint256 indexed transactionCode);\r\n    event Submission(uint256 indexed transactionCode);\r\n    event Requirement(uint256 indexed transactionCode, bytes32 labelCode, uint256 flag, uint8 required);\r\n    event Execution(uint256 indexed transactionCode);\r\n    event ExecutionFailure(uint256 indexed transactionCode);\r\n    event Deposit(address indexed sender, uint256 value);\r\n\r\n    event StakersChanged(address indexed stakers);\r\n    event SignersChanged(address indexed signers);\r\n    event RegulatorChanged(address indexed regulator);\r\n    event StakersControllerChanged(address indexed stakersController);\r\n    event SignersControllerChanged(address indexed signersController);\r\n    \r\n    event WalletOrNodeAttached(address indexed wallet);\r\n    event WalletOrNodeDetached(address indexed wallet);\r\n    \r\n    address public stakers;\r\n    address public signers;\r\n\r\n    address public stakersController;\r\n    address public signersController;\r\n\r\n    address public regulator;\r\n\r\n    // Transaction (mapped: transactionCode => Transaction)\r\n    mapping(uint256 => Transaction) public transactions;\r\n    uint256 public transactionCode;\r\n\r\n    // Requirement (mapped: transactionCode + label code => requirement)\r\n    mapping(uint256 => mapping(bytes32 => TransactionRequirement)) public requirements;\r\n    // Prevent duplicated confirmation (mapped: transactionCode + wallet address => bool)\r\n    mapping(uint256 => mapping(address => bool)) public confirmations;\r\n\r\n    // Registered wallets or nodes (mapped: address => type)\r\n    mapping(address => uint8) public registered;\r\n\r\n    // Search node address by wallet address (mapped: wallet address => node address)\r\n    mapping(address => address) public walletToNodes;\r\n\r\n    // Search wallet index by wallet address (mapped: wallet address => wallet index)\r\n    mapping(address => uint8) private walletToIndexes;\r\n\r\n    // Search label code by wallet address (mapped: wallet address => label code)\r\n    mapping(address => bytes32) private walletToLabelCodes;\r\n\r\n    // Search node address by label code (mapped: label code => node address)\r\n    mapping(bytes32 => address) private labelCodeToNodes;\r\n\r\n    struct Transaction {\r\n        uint8 status;\r\n        uint8 totalRequired;\r\n\r\n        address to;\r\n        uint256 value;\r\n        bytes data;\r\n        string reason;\r\n    }\r\n\r\n    struct TransactionRequirement {\r\n        uint8 required;\r\n        uint256 flag;\r\n    }\r\n\r\n    modifier onlyEligible(uint256 _transactionCode) {\r\n        require(isEligible(_transactionCode, msg.sender), \"Root.onlyEligible: Not eligible\");\r\n        _;\r\n    }\r\n\r\n    modifier onlySignable(uint256 _transactionCode) {\r\n        require(isSignable(_transactionCode, msg.sender), \"Root.onlySignable: Not signable\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyNode() {\r\n        require(WALLET_TYPE_NODE == registered[msg.sender], \"Root.onlyNode: Access denied\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyWallet() {\r\n        require(WALLET_TYPE_WALLET == registered[msg.sender], \"Root.onlyWallet: Access denied\");\r\n        require(!isContract(msg.sender), \"Root.onlyWallet: Is not node\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyRegulator() {\r\n        require(msg.sender == regulator, \"Root.onlyRegulator: Access denied\");\r\n        _;\r\n    }\r\n\r\n    constructor(string memory _label, string memory _description) public\r\n        Label(\"ROOT\", _label, _description)\r\n    {\r\n    }\r\n\r\n    function () external payable\r\n    {\r\n        if (0 < msg.value)\r\n            emit Deposit(msg.sender, msg.value);\r\n    }\r\n\r\n    function isEligible(uint256 _transactionCode, address _sender) public view\r\n        returns (bool)\r\n    {\r\n        uint256 flag = requirements[_transactionCode][walletToLabelCodes[_sender]].flag;\r\n\r\n        if (0 != flag) {\r\n            uint8 index = walletToIndexes[_sender];\r\n\r\n            if (0 != index) {\r\n                index = index.sub(1);\r\n\r\n                // Check the bit is on for wallet index\r\n                return (0 != ((flag >> index) & 1));\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function isSignable(uint256 _transactionCode, address _sender) public view\r\n        returns (bool)\r\n    {\r\n        if (TRANSACTION_STATUS_PENDING == transactions[_transactionCode].status) {\r\n            if (!confirmations[_transactionCode][_sender]) {\r\n                if (0 != requirements[_transactionCode][walletToLabelCodes[_sender]].required)\r\n                    return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function createRequirement(bytes32 _labelCode, uint256 _flag, uint8 _required) external\r\n        onlyRegulator\r\n    {\r\n        setRequirement(_labelCode, _flag, _required);\r\n    }\r\n\r\n    function setRequirement(bytes32 _labelCode, uint256 _flag, uint8 _required) private\r\n    {\r\n        require(0 < _flag, \"Root.setRequirement: Confirmation flag is empty\");\r\n\r\n        uint8 totalRequired;\r\n\r\n        // Required all wallet in the node\r\n        if (uint8(-1) == _required) {\r\n            address node = labelCodeToNodes[_labelCode];\r\n            require(address(0) != node, \"Root.setRequirement: Node is not found\");\r\n\r\n            totalRequired = MultiSigNode(node).walletCount();\r\n\r\n            if (node != signers) {\r\n                // Stakers and controllers must have at least 1 wallet attached\r\n                require(0 < totalRequired, \"Root.setRequirement: No wallet\");\r\n            }\r\n            else {\r\n                // Signer node allowed to be empty\r\n                if (0 == totalRequired)\r\n                    return;\r\n            }\r\n\r\n            require(0 < totalRequired, \"Root.setRequirement: Confirmation required is empty\");\r\n        }\r\n        else {\r\n            // allowed 0 requirement, in order to support eligible user but not signable (view transaction only)\r\n            totalRequired = _required;\r\n        }\r\n\r\n        require(0 == requirements[transactionCode][_labelCode].flag, \"Root.setRequirement: Duplicated requirement\");\r\n\r\n        requirements[transactionCode][_labelCode] = TransactionRequirement({\r\n            required: totalRequired,\r\n            flag: _flag\r\n        });\r\n\r\n        // Increase total required in transaction\r\n        transactions[transactionCode].totalRequired = transactions[transactionCode].totalRequired.add(totalRequired);\r\n\r\n        emit Requirement(transactionCode, _labelCode, _flag, totalRequired);\r\n    }\r\n\r\n    function submit(address _to, uint256 _value, bytes calldata _data) external\r\n        onlyWallet\r\n        returns (uint256 /* transactionCode */) \r\n    {\r\n        require(address(0) != _to, \"Root.submit: Target address is empty\");\r\n\r\n        // Generate transaction id\r\n        transactionCode = transactionCode.add(1);\r\n\r\n        bytes4 functionId = convertBytesToBytes4(_data);\r\n\r\n        // Create requirement that based on destination address\r\n        if (address(this) != _to) {\r\n            // Check this is node address or not\r\n            if (WALLET_TYPE_NODE == registered[_to]) {\r\n                // Calling node function\r\n                // - 0x80882800: node.attach\r\n                // - 0xceb6c343: node.detach\r\n                if (bytes4(0x80882800) == functionId || bytes4(0xceb6c343) == functionId) { // node.attach or node.detach\r\n                    address rootNode = MultiSigNode(_to).getRootNode();\r\n\r\n                    if (rootNode == signers) {\r\n                        // Change SIGNER need ALL SIGNER_CONTROLLER\r\n                        setRequirement(LABEL_CODE_SIGNER_CONTROLLER, WALLET_FLAG_ALL, uint8(-1)); // ALL signable\r\n                    }\r\n                    else if (rootNode == signersController || rootNode == stakersController) {\r\n                        // Change SIGNERS_CONTROLLER or STAKER_CONTROLLER need ALL STAKER\r\n                        setRequirement(LABEL_CODE_STAKER, WALLET_FLAG_ALL, uint8(-1)); // ALL signable\r\n                    }\r\n                    else if (rootNode == stakers) {\r\n                        // Change STAKER need ALL STAKER_CONTROLLER\r\n                        setRequirement(LABEL_CODE_STAKER_CONTROLLER, WALLET_FLAG_ALL, uint8(-1)); // ALL signable\r\n                    }\r\n                    else {\r\n                        revert(\"Root.submit: Unknown node\");\r\n                    }\r\n                }\r\n                else\r\n                    revert(\"Root.submit: Not supported\");\r\n            }\r\n            else {\r\n                // Regulator create requirement\r\n                MultiSigRegulator(regulator).createRequirement(transactionCode, msg.sender, _to, _value, _data);\r\n            }\r\n        }\r\n        else {\r\n            // Calling self functions\r\n            // - 0xcde0a4f8: root.setRegulator\r\n            // - 0xb47876ea: root.setSigners\r\n            // - 0xc27dbe63: root.setStakers\r\n            // - 0x26bc178c: root.setStakersController\r\n            // - 0x51d996bf: root.setSignersController\r\n            if (bytes4(0xcde0a4f8) == functionId || bytes4(0xc27dbe63) == functionId) // setRegulator or setStakers\r\n                setRequirement(LABEL_CODE_STAKER_CONTROLLER, WALLET_FLAG_ALL, uint8(-1)); // ALL signable\r\n            else if (bytes4(0x26bc178c) == functionId || bytes4(0x51d996bf) == functionId) // setStakersController or setSignersController\r\n                setRequirement(LABEL_CODE_STAKER, WALLET_FLAG_ALL, uint8(-1)); // ALL signable\r\n            else if (bytes4(0xb47876ea) == functionId) // setSigners\r\n                setRequirement(LABEL_CODE_SIGNER_CONTROLLER, WALLET_FLAG_ALL, uint8(-1)); // ALL signable\r\n            else\r\n                revert(\"Root.submit: Not supported\");\r\n        }\r\n\r\n        require(0 < transactions[transactionCode].totalRequired, \"Root.submit: Requirement is empty\");\r\n\r\n        // Create transaction structure\r\n        transactions[transactionCode] = Transaction({\r\n            status: TRANSACTION_STATUS_PENDING,\r\n            totalRequired: transactions[transactionCode].totalRequired,\r\n            to: _to,\r\n            value: _value,\r\n            data: _data,\r\n            reason: \"\"\r\n        });\r\n\r\n        emit Submission(transactionCode);\r\n\r\n        // Confirm transaction if eligible and signable\r\n        if (isEligible(transactionCode, msg.sender) && isSignable(transactionCode, msg.sender))\r\n            confirmTransaction(transactionCode, transactions[transactionCode]);\r\n\r\n        return transactionCode;\r\n    }\r\n\r\n    function confirm(uint256 _transactionCode) external\r\n        onlyWallet\r\n        onlyEligible(_transactionCode)\r\n        onlySignable(_transactionCode)\r\n        returns (bool)\r\n    {\r\n        Transaction storage transaction = transactions[_transactionCode];\r\n\r\n        return confirmTransaction(_transactionCode, transaction);\r\n    }\r\n\r\n    function revoke(uint256 _transactionCode) external\r\n        onlyWallet\r\n        onlyEligible(_transactionCode)\r\n        returns (bool)\r\n    {\r\n        require(TRANSACTION_STATUS_PENDING == transactions[_transactionCode].status, \"Root.revoke: Transaction has been completed\");\r\n        transactions[_transactionCode].status = TRANSACTION_STATUS_REVOKED;\r\n\r\n        emit Revocation(msg.sender, _transactionCode);\r\n        return true;\r\n    }\r\n\r\n    function confirmTransaction(uint256 _transactionCode, Transaction storage _transaction) private\r\n        returns (bool)\r\n    {\r\n        TransactionRequirement storage requirement = requirements[_transactionCode][walletToLabelCodes[msg.sender]];\r\n        require(0 != requirement.flag && 0 != requirement.required, \"Root.confirmTransaction: Requirement is empty\");\r\n\r\n        // Prevent duplicated confirmation\r\n        require(!confirmations[_transactionCode][msg.sender], \"root.confirmTransaction: Duplicated confirmation\");\r\n        confirmations[_transactionCode][msg.sender] = true;\r\n\r\n        requirement.required = requirement.required.sub(1);\r\n        _transaction.totalRequired = _transaction.totalRequired.sub(1);\r\n\r\n        emit Confirmation(msg.sender, _transactionCode);\r\n\r\n        return executeTransaction(_transactionCode, _transaction);\r\n    }\r\n\r\n    function executeTransaction(uint256 _transactionCode, Transaction storage _transaction) private\r\n        returns (bool)\r\n    {\r\n        require(TRANSACTION_STATUS_PENDING == _transaction.status, \"Root.executeTransaction: Status not active\");\r\n\r\n        if (0 == _transaction.totalRequired) {\r\n            _transaction.status = TRANSACTION_STATUS_EXECUTED;\r\n\r\n            // Perform remote call\r\n            (bool success, bytes memory returnData) = _transaction.to.call.value(_transaction.value)(_transaction.data);\r\n\r\n            if (success)\r\n                emit Execution(_transactionCode);\r\n            else {\r\n                // Check the error string is available or not\r\n                if (0 == returnData.length || bytes4(0x08c379a0) != convertBytesToBytes4(returnData))\r\n                    _transaction.reason = \"Root.executeTransaction: Function call failed\";\r\n                else {\r\n                    bytes memory bytesArray = new bytes(returnData.length);\r\n                    for (uint256 i = 0; i < returnData.length.sub(4); i = i.add(1)) {\r\n                        bytesArray[i] = returnData[i.add(4)];\r\n                    }\r\n\r\n                    (string memory reason) = abi.decode(bytesArray, (string));\r\n                    _transaction.reason = reason;\r\n                }\r\n\r\n                _transaction.status = TRANSACTION_STATUS_FAILURE;\r\n                emit ExecutionFailure(_transactionCode);\r\n            }\r\n\r\n            return success;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    function setRegulator(address _addressOf) external\r\n    {\r\n        if (address(0) != regulator)\r\n            require(msg.sender == address(this), \"Root.setRegulator: Access denied\");\r\n        \r\n        require(MultiSigRegulator(_addressOf).isSealed(), \"Root.setRegulator: Regulator is not sealed\");\r\n\r\n        regulator = setNode(regulator, _addressOf, false);\r\n        emit RegulatorChanged(regulator);\r\n    }\r\n\r\n    function setStakers(address _addressOf) external\r\n    {\r\n        if (address(0) != stakers)\r\n            require(msg.sender == address(this), \"Root.setStakers: Access denied\");\r\n\r\n        if (isContract(_addressOf))\r\n            require(0 < MultiSigNode(_addressOf).walletCount(), \"Root.setStakers: No wallet\");\r\n\r\n        stakers = setNode(stakers, _addressOf, true);\r\n        emit StakersChanged(stakers);\r\n    }\r\n\r\n    function setSigners(address _addressOf) external\r\n        returns (bool)\r\n    {\r\n        if (address(0) != signers)\r\n            require(msg.sender == address(this), \"Root.setSigners: Access denied\");\r\n\r\n        // Signer node allowed to be empty\r\n\r\n        signers = setNode(signers, _addressOf, true);\r\n        emit SignersChanged(signers);\r\n        return true;\r\n    }\r\n\r\n    function setStakersController(address _addressOf) external\r\n    {\r\n        if (address(0) != stakersController)\r\n            require(msg.sender == address(this), \"Root.setStakersController: Access denied\");\r\n\r\n        if (isContract(_addressOf))\r\n            require(0 < MultiSigNode(_addressOf).walletCount(), \"Root.setStakersController: No wallet\");\r\n\r\n        stakersController = setNode(stakersController, _addressOf, true);\r\n        emit StakersControllerChanged(stakersController);\r\n    }\r\n\r\n    function setSignersController(address _addressOf) external\r\n    {\r\n        if (address(0) != signersController)\r\n            require(msg.sender == address(this), \"Root.setSignersController: Access denied\");\r\n\r\n        if (isContract(_addressOf))\r\n            require(0 < MultiSigNode(_addressOf).walletCount(), \"Root.setSignersController: No wallet\");\r\n\r\n        signersController = setNode(signersController, _addressOf, true);\r\n        emit SignersControllerChanged(signersController);\r\n    }\r\n\r\n    function setNode(address _from, address _to, bool needAttachment) private\r\n        returns (address)\r\n    {\r\n        require(address(0) != _to, \"Root.setNode: Address is empty\");\r\n\r\n        if (needAttachment) {\r\n            require(0 == registered[_to], \"Root.setNode: Duplicated node\");\r\n\r\n            // Remove node from list\r\n            if (address(0) != _from) {\r\n                if (isContract(_from)) {\r\n                    // detach node\r\n                    MultiSigNode(_from).term();\r\n                }\r\n\r\n                delete registered[_from];\r\n            }\r\n\r\n            if (isContract(_to)) {\r\n                // Mark address as registered node\r\n                registered[_to] = WALLET_TYPE_NODE;\r\n\r\n                if (needAttachment) {\r\n                    // Attach node (parrent address = 0x0)\r\n                    MultiSigNode(_to).init(address(0));\r\n                }\r\n            }\r\n            else {\r\n                // Mark address as registered wallet\r\n                registered[_to] = WALLET_TYPE_WALLET;\r\n            }\r\n        }\r\n\r\n        return _to;\r\n    }\r\n\r\n    function attachWalletOrNode(address _wallet) external\r\n        onlyNode\r\n        returns (bool)\r\n    {\r\n        require(address(0) != _wallet, \"Root.attachWalletOrNode: Wallet address is empty\");\r\n        require(0 == registered[_wallet], \"Root.attachWalletOrNode: Duplicated wallet address\");\r\n\r\n        bytes32 labelCode = MultiSigNode(msg.sender).labelCode();\r\n\r\n        walletToNodes[_wallet] = msg.sender;\r\n        walletToIndexes[_wallet] = MultiSigNode(msg.sender).walletsIndex(_wallet);\r\n        walletToLabelCodes[_wallet] = labelCode;\r\n\r\n        labelCodeToNodes[labelCode] = msg.sender;\r\n\r\n        if (isContract(_wallet)) {\r\n            // Mark address as registered node\r\n            registered[_wallet] = WALLET_TYPE_NODE;\r\n\r\n            // Attach node with their parent address\r\n            MultiSigNode(_wallet).init(msg.sender);\r\n        }\r\n        else {\r\n            // Mark address as registered wallet\r\n            registered[_wallet] = WALLET_TYPE_WALLET;\r\n        }\r\n\r\n        emit WalletOrNodeAttached(_wallet);\r\n\r\n        return true;\r\n    }\r\n\r\n    function detachWalletOrNode(address _wallet) external\r\n        onlyNode\r\n        returns (bool)\r\n    {\r\n        require(address(0) != _wallet, \"Root.detachWalletOrNode: Wallet address is empty\");\r\n        require(0 != registered[_wallet], \"Root.detachWalletOrNode: Wallet address is not registered\");\r\n\r\n        if (isContract(_wallet)) {\r\n            // Detach node with their parent\r\n            MultiSigNode(_wallet).term();\r\n\r\n            bytes32 labelCode = MultiSigNode(msg.sender).labelCode();\r\n\r\n            delete labelCodeToNodes[labelCode];\r\n        }\r\n\r\n        delete registered[_wallet];\r\n        delete walletToNodes[_wallet];\r\n        delete walletToIndexes[_wallet];\r\n        delete walletToLabelCodes[_wallet];\r\n\r\n        emit WalletOrNodeDetached(_wallet);\r\n\r\n        return true;\r\n    }\r\n\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_parent\",\"type\":\"address\"}],\"name\":\"init\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"walletCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getRootNode\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"parent\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"description\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"name\":\"wallets\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_index\",\"type\":\"uint8\"},{\"name\":\"_wallet\",\"type\":\"address\"}],\"name\":\"attach\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalWallet\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"term\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"class\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"labelCode\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"walletsIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"label\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_wallet\",\"type\":\"address\"}],\"name\":\"detach\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"classCode\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"root\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_root\",\"type\":\"address\"},{\"name\":\"_wallets\",\"type\":\"address[]\"},{\"name\":\"_label\",\"type\":\"string\"},{\"name\":\"_description\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"}]","ContractName":"MultiSigNode","CompilerVersion":"v0.5.0+commit.1d4f565a","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"00000000000000000000000078a81946f5b221b9487ac56a96871977c1a1a357000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000e0000000000000000000000000000000000000000000000000000000000000012000000000000000000000000000000000000000000000000000000000000000020000000000000000000000003a7d2528fe3fa0d1e666b3f31fb2912880b2303d0000000000000000000000004cd9eb40b44c29881af37f98a23a8b25c62e4ec100000000000000000000000000000000000000000000000000000000000000065354414b4552000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000075374616b65727300000000000000000000000000000000000000000000000000","Library":"","SwarmSource":"bzzr://4aea8e7ad23668107a3b2b5be25f4a6fe69e1bd29b74cc8affbbbe701b6a4868"}]}