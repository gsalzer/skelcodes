{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity >=0.4.22 <0.6.0;\r\n\r\n\r\ncontract Orders {\r\n\r\n  event LogNewSellOrder(bytes3 indexed currency, address sellorder);\r\n  event LogNewBuyOrder(bytes3 indexed currency, address buyorder);\r\n  event LogRemoveSellOrder(address indexed sellorder);\r\n  event LogRemoveBuyOrder(address indexed buyorder);   \r\n  function newSellOrder(bytes3 curr, uint price) public payable {\r\n    require(msg.value/price >= 10000);\r\n    Sell_eth newselleth = (new Sell_eth).value(msg.value)(price, msg.sender, address(this));\r\n    emit LogNewSellOrder(curr, address(newselleth));    \r\n  }\r\n\r\n  function newBuyOrder(bytes3 curr, uint price) public payable {\r\n    require(msg.value/price >= 5000);\r\n    Buy_eth newbuyeth =(new Buy_eth).value(msg.value)(price, msg.sender, address(this));\r\n    emit LogNewBuyOrder(curr, address(newbuyeth));\r\n  }\r\n\r\n  function removeSellOrder() public {  \r\n    emit LogRemoveSellOrder(msg.sender);\r\n  }\r\n\r\n  function removeBuyOrder() public {\r\n    emit LogRemoveBuyOrder(msg.sender);\r\n  }\r\n\r\n  function() external {revert();}\r\n}\r\n\r\ncontract Sell_eth {\r\n    Orders orders;\r\n    uint weiForSale;\r\n    uint price; //wei per smallest currency unit (eg. cent)\r\n    address payable seller;\r\n    mapping(address => uint) sales;\r\n    uint8 pending;\r\n    modifier onlySeller() {require(msg.sender == seller);  _;}\r\n\r\n    event LogNewWeiForSale(uint wei_for_sale);\r\n    event LogNewPrice(uint nprice);\r\n    event LogSalePending(address indexed _seller, address indexed _buyer, uint value, uint _price);\r\n    event LogCashReceived(address indexed _buyer, address indexed _seller);\r\n\r\n    constructor(uint _price, address payable _seller, address _orders) public payable {\r\n        orders = Orders(_orders);\r\n        seller = _seller;\r\n        price = _price;\r\n        pending = 0;\r\n        weiForSale = msg.value / 2;\r\n    }\r\n    \r\n    function buy() payable public {\r\n        require(sales[msg.sender] == 0);\r\n        require(msg.value > 0 && msg.value <= weiForSale && (msg.value/price)%5000 == 0);\r\n        sales[msg.sender] = msg.value;\r\n        weiForSale -= msg.value;\r\n        pending += 1;\r\n        emit LogNewWeiForSale(weiForSale);\r\n        emit LogSalePending(seller, msg.sender, msg.value, price);\r\n    }\r\n\r\n    function confirmReceived(address payable _buyer) public  onlySeller {\r\n        require(sales[_buyer] > 0 && pending > 0);\r\n        uint amt = sales[_buyer];\r\n        sales[_buyer] = 0;\r\n        _buyer.transfer(2*amt);\r\n        pending -= 1;\r\n        emit LogCashReceived(_buyer, seller);\r\n\tweiForSale += amt/2;\r\n\temit LogNewWeiForSale(weiForSale); \r\n    }\r\n\r\n    function addEther() public onlySeller payable {\r\n        weiForSale += msg.value/2;\r\n        emit LogNewWeiForSale(weiForSale);\r\n    }\r\n\r\n    function changePrice(uint new_price) public onlySeller {\r\n        price = new_price;\r\n        emit LogNewPrice(price);\r\n    }\r\n    \r\n    function retr_funds() public onlySeller payable {\r\n        require(pending == 0);\r\n        orders.removeSellOrder();\r\n        selfdestruct(address(seller));\r\n    }\r\n    \r\n    function get_vars() view public returns(uint, uint) {\r\n        return (weiForSale, price);\r\n    }\r\n\r\n    function is_party() view public returns(string memory) {\r\n        if (sales[msg.sender] > 0) return \"buyer\";\r\n        else if (seller == msg.sender) return \"seller\";\r\n    }\r\n\r\n    function has_pending() view public returns(bool) {\r\n\tif (pending > 0) return true;\r\n    }\r\n}\r\n\r\ncontract Buy_eth {\r\n    Orders orders;\r\n    uint weiToBuy;\r\n    uint price; //wei per smallest currency unit (eg. cent)   \r\n    address payable buyer;\r\n    mapping(address => uint) sales;\r\n    uint8 pending;\r\n    modifier onlyBuyer() {require(msg.sender == buyer);  _;}\r\n    \r\n    event LogNewWeiToBuy(uint wei_to_buy);\r\n    event LogNewPrice(uint nprice);\r\n    event LogSalePending(address indexed _buyer, address indexed _seller, uint value, uint _price);\r\n    event LogCashReceived(address indexed _seller, address indexed _buyer);\r\n\r\n    constructor(uint _price, address payable _buyer, address _orders) public payable {\r\n        orders = Orders(_orders);\r\n        buyer = _buyer;\r\n        price = _price;\r\n        pending = 0;\r\n        weiToBuy = msg.value;\r\n    }\r\n    function sell() public payable {\r\n        require(sales[msg.sender] == 0);\r\n        require(msg.value > 0 && msg.value/2 <= weiToBuy && (msg.value/price)%10000 == 0); \r\n        uint amt = msg.value/2;\r\n        sales[msg.sender] = amt;\r\n        weiToBuy -= amt;\r\n        pending += 1;\r\n        emit LogSalePending(buyer, msg.sender, amt, price);\r\n        emit LogNewWeiToBuy(weiToBuy);\r\n    }\r\n\r\n    function confirmReceived() public payable {\r\n        require(sales[msg.sender] > 0 && pending > 0);\r\n        uint amt = sales[msg.sender];\r\n        sales[msg.sender] = 0;\r\n        msg.sender.transfer(amt);\r\n        emit LogCashReceived(msg.sender, buyer);\r\n        weiToBuy += 2*amt;\r\n        pending -= 1;\r\n        emit LogNewWeiToBuy(weiToBuy);\r\n    }\r\n    \r\n    function retreive_eth(uint vol) public onlyBuyer payable {  \r\n        require(vol <= weiToBuy-price*5000);\r\n        weiToBuy -= vol;\r\n        buyer.transfer(vol);\r\n        emit LogNewWeiToBuy(weiToBuy);\r\n    }\r\n\r\n    function changePrice(uint new_price) public onlyBuyer {\r\n        price = new_price;\r\n        emit LogNewPrice(price);\r\n    }\r\n\r\n    function terminate_contract() public onlyBuyer payable {\r\n        require(pending == 0);\r\n        orders.removeBuyOrder();\r\n        selfdestruct(buyer);\r\n    }\r\n\r\n    function get_vars() view public returns(uint,uint) {\r\n        return (weiToBuy, price);\r\n    }\r\n\r\n    function is_party() view public returns(string memory) {\r\n        if (buyer == msg.sender) return \"buyer\";\r\n        else if (sales[msg.sender] > 0) return \"seller\";\r\n    }\r\n\r\n    function has_pending() view public returns(bool) {\r\n\tif (pending > 0) return true;\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"curr\",\"type\":\"bytes3\"},{\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"newBuyOrder\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"removeBuyOrder\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"removeSellOrder\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"curr\",\"type\":\"bytes3\"},{\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"newSellOrder\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"currency\",\"type\":\"bytes3\"},{\"indexed\":false,\"name\":\"sellorder\",\"type\":\"address\"}],\"name\":\"LogNewSellOrder\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"currency\",\"type\":\"bytes3\"},{\"indexed\":false,\"name\":\"buyorder\",\"type\":\"address\"}],\"name\":\"LogNewBuyOrder\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"sellorder\",\"type\":\"address\"}],\"name\":\"LogRemoveSellOrder\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"buyorder\",\"type\":\"address\"}],\"name\":\"LogRemoveBuyOrder\",\"type\":\"event\"}]","ContractName":"Orders","CompilerVersion":"v0.5.0+commit.1d4f565a","OptimizationUsed":"0","Runs":"0","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://251c76f727b3c2a8c359183d0e88ffc8bf9ef904236a1065c433040060505103"}]}