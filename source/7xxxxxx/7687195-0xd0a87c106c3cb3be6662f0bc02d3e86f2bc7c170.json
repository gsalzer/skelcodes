{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.5.6;\r\n\r\n/**\r\n * @dev Xcert nutable interface.\r\n */\r\ninterface XcertMutable // is Xcert\r\n{\r\n  \r\n  /**\r\n   * @dev Updates Xcert imprint.\r\n   * @param _tokenId Id of the Xcert.\r\n   * @param _imprint New imprint.\r\n   */\r\n  function updateTokenImprint(\r\n    uint256 _tokenId,\r\n    bytes32 _imprint\r\n  )\r\n    external;\r\n\r\n}\r\n\r\n/**\r\n * @dev Math operations with safety checks that throw on error. This contract is based on the \r\n * source code at: \r\n * https://github.com/OpenZeppelin/openzeppelin-solidity/blob/master/contracts/math/SafeMath.sol.\r\n */\r\nlibrary SafeMath\r\n{\r\n\r\n  /**\r\n   * @dev Error constants.\r\n   */\r\n  string constant OVERFLOW = \"008001\";\r\n  string constant SUBTRAHEND_GREATER_THEN_MINUEND = \"008002\";\r\n  string constant DIVISION_BY_ZERO = \"008003\";\r\n\r\n  /**\r\n   * @dev Multiplies two numbers, reverts on overflow.\r\n   * @param _factor1 Factor number.\r\n   * @param _factor2 Factor number.\r\n   * @return The product of the two factors.\r\n   */\r\n  function mul(\r\n    uint256 _factor1,\r\n    uint256 _factor2\r\n  )\r\n    internal\r\n    pure\r\n    returns (uint256 product)\r\n  {\r\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (_factor1 == 0)\r\n    {\r\n      return 0;\r\n    }\r\n\r\n    product = _factor1 * _factor2;\r\n    require(product / _factor1 == _factor2, OVERFLOW);\r\n  }\r\n\r\n  /**\r\n   * @dev Integer division of two numbers, truncating the quotient, reverts on division by zero.\r\n   * @param _dividend Dividend number.\r\n   * @param _divisor Divisor number.\r\n   * @return The quotient.\r\n   */\r\n  function div(\r\n    uint256 _dividend,\r\n    uint256 _divisor\r\n  )\r\n    internal\r\n    pure\r\n    returns (uint256 quotient)\r\n  {\r\n    // Solidity automatically asserts when dividing by 0, using all gas.\r\n    require(_divisor > 0, DIVISION_BY_ZERO);\r\n    quotient = _dividend / _divisor;\r\n    // assert(_dividend == _divisor * quotient + _dividend % _divisor); // There is no case in which this doesn't hold.\r\n  }\r\n\r\n  /**\r\n   * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n   * @param _minuend Minuend number.\r\n   * @param _subtrahend Subtrahend number.\r\n   * @return Difference.\r\n   */\r\n  function sub(\r\n    uint256 _minuend,\r\n    uint256 _subtrahend\r\n  )\r\n    internal\r\n    pure\r\n    returns (uint256 difference)\r\n  {\r\n    require(_subtrahend <= _minuend, SUBTRAHEND_GREATER_THEN_MINUEND);\r\n    difference = _minuend - _subtrahend;\r\n  }\r\n\r\n  /**\r\n   * @dev Adds two numbers, reverts on overflow.\r\n   * @param _addend1 Number.\r\n   * @param _addend2 Number.\r\n   * @return Sum.\r\n   */\r\n  function add(\r\n    uint256 _addend1,\r\n    uint256 _addend2\r\n  )\r\n    internal\r\n    pure\r\n    returns (uint256 sum)\r\n  {\r\n    sum = _addend1 + _addend2;\r\n    require(sum >= _addend1, OVERFLOW);\r\n  }\r\n\r\n  /**\r\n    * @dev Divides two numbers and returns the remainder (unsigned integer modulo), reverts when\r\n    * dividing by zero.\r\n    * @param _dividend Number.\r\n    * @param _divisor Number.\r\n    * @return Remainder.\r\n    */\r\n  function mod(\r\n    uint256 _dividend,\r\n    uint256 _divisor\r\n  )\r\n    internal\r\n    pure\r\n    returns (uint256 remainder) \r\n  {\r\n    require(_divisor != 0, DIVISION_BY_ZERO);\r\n    remainder = _dividend % _divisor;\r\n  }\r\n\r\n}\r\n\r\n/**\r\n * @title Contract for setting abilities.\r\n * @dev For optimization purposes the abilities are represented as a bitfield. Maximum number of\r\n * abilities is therefore 256. This is an example(for simplicity is made for max 8 abilities) of how\r\n * this works. \r\n * 00000001 Ability A - number representation 1\r\n * 00000010 Ability B - number representation 2\r\n * 00000100 Ability C - number representation 4\r\n * 00001000 Ability D - number representation 8\r\n * 00010000 Ability E - number representation 16\r\n * etc ... \r\n * To grant abilities B and C, we would need a bitfield of 00000110 which is represented by number\r\n * 6, in other words, the sum of abilities B and C. The same concept works for revoking abilities\r\n * and checking if someone has multiple abilities.\r\n */\r\ncontract Abilitable\r\n{\r\n  using SafeMath for uint;\r\n\r\n  /**\r\n   * @dev Error constants.\r\n   */\r\n  string constant NOT_AUTHORIZED = \"017001\";\r\n  string constant CANNOT_REVOKE_OWN_SUPER_ABILITY = \"017002\";\r\n  string constant INVALID_INPUT = \"017003\";\r\n\r\n  /**\r\n   * @dev Ability 1 (00000001) is a reserved ability called super ability. It is an\r\n   * ability to grant or revoke abilities of other accounts. Other abilities are determined by the\r\n   * implementing contract.\r\n   */\r\n  uint8 constant SUPER_ABILITY = 1;\r\n\r\n  /**\r\n   * @dev Maps address to ability ids.\r\n   */\r\n  mapping(address => uint256) public addressToAbility;\r\n\r\n  /**\r\n   * @dev Emits when an address is granted an ability.\r\n   * @param _target Address to which we are granting abilities.\r\n   * @param _abilities Number representing bitfield of abilities we are granting.\r\n   */\r\n  event GrantAbilities(\r\n    address indexed _target,\r\n    uint256 indexed _abilities\r\n  );\r\n\r\n  /**\r\n   * @dev Emits when an address gets an ability revoked.\r\n   * @param _target Address of which we are revoking an ability.\r\n   * @param _abilities Number representing bitfield of abilities we are revoking.\r\n   */\r\n  event RevokeAbilities(\r\n    address indexed _target,\r\n    uint256 indexed _abilities\r\n  );\r\n\r\n  /**\r\n   * @dev Guarantees that msg.sender has certain abilities.\r\n   */\r\n  modifier hasAbilities(\r\n    uint256 _abilities\r\n  ) \r\n  {\r\n    require(_abilities > 0, INVALID_INPUT);\r\n    require(\r\n      addressToAbility[msg.sender] & _abilities == _abilities,\r\n      NOT_AUTHORIZED\r\n    );\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Contract constructor.\r\n   * Sets SUPER_ABILITY ability to the sender account.\r\n   */\r\n  constructor()\r\n    public\r\n  {\r\n    addressToAbility[msg.sender] = SUPER_ABILITY;\r\n    emit GrantAbilities(msg.sender, SUPER_ABILITY);\r\n  }\r\n\r\n  /**\r\n   * @dev Grants specific abilities to specified address.\r\n   * @param _target Address to grant abilities to.\r\n   * @param _abilities Number representing bitfield of abilities we are granting.\r\n   */\r\n  function grantAbilities(\r\n    address _target,\r\n    uint256 _abilities\r\n  )\r\n    external\r\n    hasAbilities(SUPER_ABILITY)\r\n  {\r\n    addressToAbility[_target] |= _abilities;\r\n    emit GrantAbilities(_target, _abilities);\r\n  }\r\n\r\n  /**\r\n   * @dev Unassigns specific abilities from specified address.\r\n   * @param _target Address of which we revoke abilites.\r\n   * @param _abilities Number representing bitfield of abilities we are revoking.\r\n   * @param _allowSuperRevoke Additional check that prevents you from removing your own super\r\n   * ability by mistake.\r\n   */\r\n  function revokeAbilities(\r\n    address _target,\r\n    uint256 _abilities,\r\n    bool _allowSuperRevoke\r\n  )\r\n    external\r\n    hasAbilities(SUPER_ABILITY)\r\n  {\r\n    if (!_allowSuperRevoke && msg.sender == _target)\r\n    {\r\n      require((_abilities & 1) == 0, CANNOT_REVOKE_OWN_SUPER_ABILITY);\r\n    }\r\n    addressToAbility[_target] &= ~_abilities;\r\n    emit RevokeAbilities(_target, _abilities);\r\n  }\r\n\r\n  /**\r\n   * @dev Check if an address has a specific ability. Throws if checking for 0.\r\n   * @param _target Address for which we want to check if it has a specific abilities.\r\n   * @param _abilities Number representing bitfield of abilities we are checking.\r\n   */\r\n  function isAble(\r\n    address _target,\r\n    uint256 _abilities\r\n  )\r\n    external\r\n    view\r\n    returns (bool)\r\n  {\r\n    require(_abilities > 0, INVALID_INPUT);\r\n    return (addressToAbility[_target] & _abilities) == _abilities;\r\n  }\r\n  \r\n}\r\n\r\n/**\r\n * @title XcertUpdateProxy - updates a token on behalf of contracts that have been approved via\r\n * decentralized governance.\r\n * @notice There is a possibility of unintentional behavior when token imprint can be overwritten\r\n * if more than one claim is active. Be aware of this when implementing.\r\n */\r\ncontract XcertUpdateProxy is\r\n  Abilitable\r\n{\r\n\r\n  /**\r\n   * @dev List of abilities:\r\n   * 2 - Ability to execute create.\r\n   */\r\n  uint8 constant ABILITY_TO_EXECUTE = 2;\r\n\r\n  /**\r\n   * @dev Updates imprint of an existing Xcert.\r\n   * @param _xcert Address of the Xcert contract on which the update will be perfomed.\r\n   * @param _id The Xcert we will update.\r\n   * @param _imprint Cryptographic asset imprint.\r\n   */\r\n  function update(\r\n    address _xcert,\r\n    uint256 _id,\r\n    bytes32 _imprint\r\n  )\r\n    external\r\n    hasAbilities(ABILITY_TO_EXECUTE)\r\n  {\r\n    XcertMutable(_xcert).updateTokenImprint(_id, _imprint);\r\n  }\r\n\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_target\",\"type\":\"address\"},{\"name\":\"_abilities\",\"type\":\"uint256\"}],\"name\":\"grantAbilities\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"addressToAbility\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_xcert\",\"type\":\"address\"},{\"name\":\"_id\",\"type\":\"uint256\"},{\"name\":\"_imprint\",\"type\":\"bytes32\"}],\"name\":\"update\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_target\",\"type\":\"address\"},{\"name\":\"_abilities\",\"type\":\"uint256\"},{\"name\":\"_allowSuperRevoke\",\"type\":\"bool\"}],\"name\":\"revokeAbilities\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_target\",\"type\":\"address\"},{\"name\":\"_abilities\",\"type\":\"uint256\"}],\"name\":\"isAble\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_target\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_abilities\",\"type\":\"uint256\"}],\"name\":\"GrantAbilities\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_target\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_abilities\",\"type\":\"uint256\"}],\"name\":\"RevokeAbilities\",\"type\":\"event\"}]","ContractName":"XcertUpdateProxy","CompilerVersion":"v0.5.6+commit.b259423e","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://bfc47d081301ded74257b8e9e0e52bf2b2d858fdd07fba0e7384047c58a7bba3"}]}