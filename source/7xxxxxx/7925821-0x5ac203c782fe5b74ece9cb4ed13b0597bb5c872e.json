{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.5.8;\r\n\r\n//TODO: third party auditory\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Unsigned math operations with safety checks that revert on error.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns(uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns(uint256) {\r\n        require(b <= a, \"SafeMath: subtraction overflow\");\r\n        uint256 c = a - b;\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns(uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns(uint256) {\r\n        require(b > 0, \"SafeMath: division by zero\");\r\n        uint256 c = a / b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns(uint256) {\r\n        require(b != 0, \"SafeMath: modulo by zero\");\r\n        return a % b;\r\n    }\r\n}\r\n\r\n\r\n// ----------------------------------------------------------------------------\r\n// ERC20 Token Standard Interface\r\n// ----------------------------------------------------------------------------\r\ninterface ERC20Interface {\r\n    function totalSupply() external returns(uint);\r\n    function balanceOf(address tokenOwner) external returns(uint balance);\r\n    function allowance(address tokenOwner, address spender) external returns(uint remaining);\r\n    function transfer(address to, uint tokens) external returns(bool success);\r\n    function approve(address spender, uint tokens) external returns(bool success);\r\n    function transferFrom(address from, address to, uint tokens) external returns(bool success);\r\n    event Transfer(address indexed from, address indexed to, uint tokens);\r\n    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\r\n}\r\n\r\n/**\r\n * @title admined\r\n * @notice This contract is administered\r\n */\r\ncontract admined {\r\n    //mapping to user levels\r\n    mapping(address => uint8) public level;\r\n    //0 normal user\r\n    //1 basic admin\r\n    //2 master admin\r\n\r\n    constructor() internal {\r\n        level[0x7a3a57c620fA468b304b5d1826CDcDe28E2b2b98] = 2; //Set initial admin to contract creator\r\n        emit AdminshipUpdated(0x7a3a57c620fA468b304b5d1826CDcDe28E2b2b98, 2); //Log the admin set\r\n    }\r\n\r\n    /**\r\n     * @dev This modifier limits function execution to the admin\r\n     */\r\n    modifier onlyAdmin(uint8 _level) { //A modifier to define admin-only functions\r\n        //It require the user level to be more or equal than _level\r\n        require(level[msg.sender] >= _level, \"You dont have rights for this transaction\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @notice This function transfer the adminship of the contract to _newAdmin\r\n     * @param _newAdmin The new admin of the contract\r\n     * @param _level Level to assign to the new admin of the contract\r\n     */\r\n    function adminshipLevel(address _newAdmin, uint8 _level) public onlyAdmin(2) {//Admin can be set\r\n        require(_newAdmin != address(0), \"Address cannot be zero\"); //The new admin must not be zero address\r\n        level[_newAdmin] = _level; //New level is set\r\n        emit AdminshipUpdated(_newAdmin, _level); //Log the admin set\r\n    }\r\n\r\n    /**\r\n     * @dev Log Events\r\n     */\r\n    event AdminshipUpdated(address _newAdmin, uint8 _level);\r\n\r\n}\r\n\r\n// ----------------------------------------------------------------------------\r\n// Main Contract definition\r\n// ----------------------------------------------------------------------------\r\ncontract ICO is admined {\r\n\r\n    using SafeMath for uint256;\r\n\r\n    enum State {\r\n        //This ico have these states\r\n        OnSale,\r\n        Successful\r\n    }\r\n\r\n    //public variables\r\n\r\n    //state related\r\n    State public state = State.OnSale; //Set initial stage\r\n\r\n    //time related\r\n    uint256 public SaleStartTime = now;\r\n    uint256 public completedAt;\r\n\r\n    //token related\r\n    ERC20Interface public tokenReward;\r\n\r\n    //funding related\r\n    uint256 public totalRaised; //eth in wei\r\n    uint256 public totalDistributed; //tokens distributed\r\n    uint256 public totalBonusDistributed; //bonus tokens distributed\r\n    uint256 public constant rate = 2941; //Rate\r\n    uint256 public constant trancheSize = 52500000 * 1e18;\r\n    uint256 public constant hardCap = 420000000 * 1e18;\r\n    uint256 public constant softCap = 3000000 * 1e18;\r\n    mapping(address => uint256) public invested;\r\n    mapping(address => uint256) public received;\r\n    mapping(address => uint256) public bonusReceived;\r\n\r\n    //info\r\n    address public owner;\r\n    address payable public beneficiary;\r\n    string public version = '1';\r\n\r\n    //events for log\r\n    event LogFundingInitialized(address _owner);\r\n    event LogFundingReceived(address _addr, uint _amount, uint _currentTotal);\r\n    event LogContributorsPayout(address _addr, uint _amount);\r\n    event LogBeneficiaryPaid(address _beneficiaryAddress);\r\n    event LogFundingSuccessful(uint _totalRaised);\r\n\r\n    modifier notFinished() {\r\n        require(state != State.Successful, \"Sale have finished\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @notice ICO constructor\r\n     * @param _addressOfTokenUsedAsReward is the token to distributed\r\n     */\r\n    constructor(ERC20Interface _addressOfTokenUsedAsReward) public {\r\n\r\n        tokenReward = _addressOfTokenUsedAsReward;\r\n        owner = 0x7a3a57c620fA468b304b5d1826CDcDe28E2b2b98;\r\n        beneficiary = 0x8605409D35f707714A83410BE9C8025dcefa9faC;\r\n\r\n        emit LogFundingInitialized(owner);\r\n\r\n    }\r\n\r\n    /**\r\n     * @notice contribution handler\r\n     */\r\n    function contribute(address _target, uint256 _value) public notFinished payable {\r\n\r\n        address user;\r\n        uint valueHandler;\r\n\r\n        uint tokenBought;\r\n        uint tokenBonus;\r\n\r\n        uint bonusStack;\r\n        uint trancheLeft;\r\n        uint remaining;\r\n\r\n        if (_target != address(0) && level[msg.sender] >= 1) {\r\n            user = _target;\r\n            valueHandler = _value;\r\n        } else {\r\n            user = msg.sender;\r\n            valueHandler = msg.value;\r\n            //Refund through contract for eth contributors only\r\n            invested[msg.sender] = invested[msg.sender].add(msg.value);\r\n        }\r\n\r\n        require(valueHandler >= 0.1 ether, \"Not enough value for this transaction\");\r\n\r\n        totalRaised = totalRaised.add(valueHandler); //ether received updated\r\n\r\n        //This keep the tokens bought\r\n        tokenBought = valueHandler.mul(rate);\r\n        //This keep the tokens to be bonus-analized\r\n        remaining = valueHandler.mul(rate);\r\n\r\n        //First Tranche Handler\r\n        if (remaining > 0 &&\r\n            totalDistributed < trancheSize\r\n        ) {\r\n            trancheLeft = trancheSize.sub(totalDistributed);\r\n\r\n            if (remaining < trancheLeft) {\r\n                bonusStack = remaining.mul(4);\r\n                tokenBonus = bonusStack.div(10);\r\n\r\n                totalDistributed = totalDistributed.add(remaining);\r\n\r\n                remaining = 0;\r\n                bonusStack = 0;\r\n                trancheLeft = 0;\r\n            } else {\r\n                bonusStack = trancheLeft.mul(4);\r\n                tokenBonus = bonusStack.div(10);\r\n\r\n                totalDistributed = totalDistributed.add(trancheLeft);\r\n\r\n                remaining = remaining.sub(trancheLeft);\r\n                bonusStack = 0;\r\n                trancheLeft = 0;\r\n            }\r\n        }\r\n\r\n        //Second Tranche Handler\r\n        if (remaining > 0 &&\r\n            totalDistributed >= trancheSize &&\r\n            totalDistributed < trancheSize.mul(2)\r\n        ) {\r\n            trancheLeft = trancheSize.mul(2).sub(totalDistributed);\r\n\r\n            if (remaining < trancheLeft) {\r\n                bonusStack = remaining.mul(35);\r\n                tokenBonus = tokenBonus.add(bonusStack.div(100));\r\n\r\n                totalDistributed = totalDistributed.add(remaining);\r\n\r\n                remaining = 0;\r\n                bonusStack = 0;\r\n                trancheLeft = 0;\r\n            } else {\r\n                bonusStack = trancheLeft.mul(35);\r\n                tokenBonus = tokenBonus.add(bonusStack.div(100));\r\n\r\n                totalDistributed = totalDistributed.add(trancheLeft);\r\n\r\n                remaining = remaining.sub(trancheLeft);\r\n                bonusStack = 0;\r\n                trancheLeft = 0;\r\n            }\r\n        }\r\n\r\n        //Third Tranche Handler\r\n        if (remaining > 0 &&\r\n            totalDistributed >= trancheSize.mul(2) &&\r\n            totalDistributed < trancheSize.mul(3)\r\n        ) {\r\n            trancheLeft = trancheSize.mul(3).sub(totalDistributed);\r\n\r\n            if (remaining < trancheLeft) {\r\n                bonusStack = remaining.mul(3);\r\n                tokenBonus = tokenBonus.add(bonusStack.div(10));\r\n\r\n                totalDistributed = totalDistributed.add(remaining);\r\n\r\n                remaining = 0;\r\n                bonusStack = 0;\r\n                trancheLeft = 0;\r\n            } else {\r\n                bonusStack = trancheLeft.mul(3);\r\n                tokenBonus = tokenBonus.add(bonusStack.div(10));\r\n\r\n                totalDistributed = totalDistributed.add(trancheLeft);\r\n\r\n                remaining = remaining.sub(trancheLeft);\r\n                bonusStack = 0;\r\n                trancheLeft = 0;\r\n            }\r\n        }\r\n\r\n        //Fourth Tranche Handler\r\n        if (remaining > 0 &&\r\n            totalDistributed >= trancheSize.mul(3) &&\r\n            totalDistributed < trancheSize.mul(4)\r\n        ) {\r\n            trancheLeft = trancheSize.mul(4).sub(totalDistributed);\r\n\r\n            if (remaining < trancheLeft) {\r\n                bonusStack = remaining.mul(2);\r\n                tokenBonus = tokenBonus.add(bonusStack.div(10));\r\n\r\n                totalDistributed = totalDistributed.add(remaining);\r\n\r\n                remaining = 0;\r\n                bonusStack = 0;\r\n                trancheLeft = 0;\r\n            } else {\r\n                bonusStack = trancheLeft.mul(2);\r\n                tokenBonus = tokenBonus.add(bonusStack.div(10));\r\n\r\n                totalDistributed = totalDistributed.add(trancheLeft);\r\n\r\n                remaining = remaining.sub(trancheLeft);\r\n                bonusStack = 0;\r\n                trancheLeft = 0;\r\n            }\r\n        }\r\n\r\n        //Fifth Tranche Handler\r\n        if (remaining > 0 &&\r\n            totalDistributed >= trancheSize.mul(4) &&\r\n            totalDistributed < trancheSize.mul(5)\r\n        ) {\r\n            trancheLeft = trancheSize.mul(5).sub(totalDistributed);\r\n\r\n            if (remaining < trancheLeft) {\r\n                tokenBonus = tokenBonus.add(remaining.div(10));\r\n\r\n                totalDistributed = totalDistributed.add(remaining);\r\n\r\n                remaining = 0;\r\n                bonusStack = 0;\r\n                trancheLeft = 0;\r\n            } else {\r\n                tokenBonus = tokenBonus.add(trancheLeft.div(10));\r\n\r\n                totalDistributed = totalDistributed.add(trancheLeft);\r\n\r\n                remaining = remaining.sub(trancheLeft);\r\n                bonusStack = 0;\r\n                trancheLeft = 0;\r\n            }\r\n        }\r\n\r\n        //Sixth Tranche Handler\r\n        if (remaining > 0 &&\r\n            totalDistributed >= trancheSize.mul(5) &&\r\n            totalDistributed < trancheSize.mul(6)\r\n        ) {\r\n            trancheLeft = trancheSize.mul(6).sub(totalDistributed);\r\n\r\n            if (remaining < trancheLeft) {\r\n                bonusStack = remaining.mul(5);\r\n                tokenBonus = tokenBonus.add(bonusStack.div(100));\r\n\r\n                totalDistributed = totalDistributed.add(remaining);\r\n\r\n                remaining = 0;\r\n                bonusStack = 0;\r\n                trancheLeft = 0;\r\n            } else {\r\n                bonusStack = trancheLeft.mul(5);\r\n                tokenBonus = tokenBonus.add(bonusStack.div(100));\r\n\r\n                totalDistributed = totalDistributed.add(trancheLeft);\r\n\r\n                remaining = remaining.sub(trancheLeft);\r\n                bonusStack = 0;\r\n                trancheLeft = 0;\r\n            }\r\n        }\r\n\r\n        totalDistributed = totalDistributed.add(remaining);\r\n        totalBonusDistributed = totalBonusDistributed.add(tokenBonus);\r\n\r\n        tokenReward.transfer(user, tokenBought.add(tokenBonus));\r\n        received[user] = received[user].add(tokenBought);\r\n        bonusReceived[user] = bonusReceived[user].add(tokenBonus);\r\n\r\n        emit LogFundingReceived(user, valueHandler, totalRaised); //Log the purchase\r\n\r\n        checkIfFundingCompleteOrExpired(); //Execute state checks\r\n    }\r\n\r\n    /**\r\n     * @notice check status\r\n     */\r\n    function checkIfFundingCompleteOrExpired() public {\r\n\r\n        if (totalDistributed.add(totalBonusDistributed) > hardCap.sub(rate)) { //If we reach the PubSale deadline\r\n\r\n            state = State.Successful; //ico becomes Successful\r\n\r\n            completedAt = now; //ICO is complete\r\n\r\n            emit LogFundingSuccessful(totalRaised); //we log the finish\r\n            finished(); //and execute closure\r\n\r\n        }\r\n    }\r\n\r\n    function withdrawEth() public onlyAdmin(2) {\r\n        require(totalDistributed >= softCap, \"Too early to retrieve funds\");\r\n        beneficiary.transfer(address(this).balance);\r\n    }\r\n\r\n    function getRefund() public notFinished {\r\n        require(totalDistributed >= softCap, \"Too early to retrieve funds\");\r\n        require(invested[msg.sender] > 0, \"No eth to refund\");\r\n        require(\r\n            tokenReward.transferFrom(\r\n                msg.sender,\r\n                address(this),\r\n                received[msg.sender].add(bonusReceived[msg.sender])\r\n            ),\r\n            \"Cannot retrieve tokens\"\r\n        );\r\n\r\n        totalDistributed = totalDistributed.sub(received[msg.sender]);\r\n        totalBonusDistributed = totalBonusDistributed.sub(bonusReceived[msg.sender]);\r\n        received[msg.sender] = 0;\r\n        bonusReceived[msg.sender] = 0;\r\n        uint toTransfer = invested[msg.sender];\r\n        invested[msg.sender] = 0;\r\n        msg.sender.transfer(toTransfer);\r\n    }\r\n\r\n    /**\r\n     * @notice closure handler\r\n     */\r\n    function finished() public { //When finished, eth are transfered to beneficiary\r\n        //Only on sucess\r\n        require(state == State.Successful, \"Wrong Stage\");\r\n\r\n        uint256 remanent = tokenReward.balanceOf(address(this));\r\n\r\n        require(tokenReward.transfer(beneficiary, remanent), \"Transfer could not be made\");\r\n\r\n        beneficiary.transfer(address(this).balance);\r\n        emit LogBeneficiaryPaid(beneficiary);\r\n    }\r\n\r\n    /*\r\n     * @notice direct payments handler\r\n     */\r\n    function () external payable {\r\n        contribute(address(0), 0);\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"rate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"completedAt\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"beneficiary\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"bonusReceived\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"invested\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"trancheSize\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenReward\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_target\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"contribute\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"checkIfFundingCompleteOrExpired\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"softCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawEth\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalBonusDistributed\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"getRefund\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"SaleStartTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finished\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"state\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalRaised\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newAdmin\",\"type\":\"address\"},{\"name\":\"_level\",\"type\":\"uint8\"}],\"name\":\"adminshipLevel\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"level\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"received\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalDistributed\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"hardCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_addressOfTokenUsedAsReward\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"LogFundingInitialized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_currentTotal\",\"type\":\"uint256\"}],\"name\":\"LogFundingReceived\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"LogContributorsPayout\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_beneficiaryAddress\",\"type\":\"address\"}],\"name\":\"LogBeneficiaryPaid\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_totalRaised\",\"type\":\"uint256\"}],\"name\":\"LogFundingSuccessful\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_newAdmin\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_level\",\"type\":\"uint8\"}],\"name\":\"AdminshipUpdated\",\"type\":\"event\"}]","ContractName":"ICO","CompilerVersion":"v0.5.8+commit.23d335f2","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000004e84a65b5664d33b67750771f8beaec458bd6729","Library":"","SwarmSource":"bzzr://cb074fb41919da8712cac4c7fb1d74aa83f74c9d055cda095326807c3cdf7ae8"}]}