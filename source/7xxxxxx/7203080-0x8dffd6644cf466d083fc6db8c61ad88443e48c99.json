{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.11;\r\n\r\ncontract CertiMe {\r\n    // Defines a new type with two fields.\r\n    struct Certificate {\r\n        string certHash;\r\n        address issuer_addr;\r\n        address recepient_addr;\r\n        string version;\r\n        string content;\r\n        bool isRevoked;\r\n        uint256 issuance_time;\r\n    }\r\n\r\n    uint numCerts;\r\n    mapping (uint => Certificate) public certificates;\r\n    mapping (string => Certificate) certHashKey;\r\n\r\n    function newCertificate(address beneficiary, string certHash, string version, string content ) public returns (uint certID) {\r\n        certID = ++numCerts; // campaignID is return variable\r\n        // Creates new struct and saves in storage. We leave out the mapping type.\r\n        certificates[certID] = Certificate(certHash,msg.sender,beneficiary, version,content,false,block.timestamp);\r\n        certHashKey[certHash]=certificates[certID];\r\n    }\r\n    \r\n    function arraySum(uint[] arr) internal pure returns (uint){\r\n        uint len= 0;\r\n        for(uint i=0;i<arr.length;i++){\r\n            len+=arr[i];\r\n        }\r\n        return len;\r\n    }\r\n    function getCharacterCount(string str) pure internal returns (uint length)    {\r\n        uint i=0;\r\n        bytes memory string_rep = bytes(str);\r\n    \r\n        while (i<string_rep.length)\r\n        {\r\n            if (string_rep[i]>>7==0)\r\n                i+=1;\r\n            else if (string_rep[i]>>5==0x6)\r\n                i+=2;\r\n            else if (string_rep[i]>>4==0xE)\r\n                i+=3;\r\n            else if (string_rep[i]>>3==0x1E)\r\n                i+=4;\r\n            else\r\n                //For safety\r\n                i+=1;\r\n    \r\n            length++;\r\n        }\r\n    }    \r\n    function batchNewCertificate(address[] beneficiaries, string certHash, string version, string content,uint[] certHashChar, uint[] versionChar,uint[] contentChar) public returns (uint[]) {\r\n        //require(beneficiaries.length==certHashChar.length);\r\n        //require(versionChar.length==certHashChar.length);    \r\n        //require(versionChar.length==contentChar.length);        \r\n        //uint log=getCharacterCount(version);\r\n        //require(arraySum(versionChar)==getCharacterCount(version));             \r\n        //require(arraySum(certHashChar)==getCharacterCount(certHash));        \r\n        //require(arraySum(contentChar)==getCharacterCount(content));        \r\n\r\n        \r\n        uint certHashCharSteps=0;\r\n        uint versionCharSteps=0;\r\n        uint contentCharSteps=0;\r\n        \r\n        uint[] memory certID = new uint[](beneficiaries.length);\r\n        for (uint i=0;i<beneficiaries.length;i++){\r\n            certID[i]=newCertificate(\r\n                beneficiaries[i],\r\n                substring(certHash,certHashCharSteps,(certHashCharSteps+certHashChar[i])),\r\n                substring(version,versionCharSteps,(versionCharSteps+versionChar[i])),\r\n                substring(content,contentCharSteps,(contentCharSteps+contentChar[i]))\r\n            );\r\n            \r\n            certHashCharSteps+=certHashChar[i];\r\n            versionCharSteps+=versionChar[i];\r\n            contentCharSteps+=contentChar[i];\r\n            \r\n        }\r\n        return certID;\r\n    }\r\n        \r\n    function revokeCertificate(uint targetCertID) public returns (bool){\r\n        if(msg.sender==certificates[targetCertID].issuer_addr){\r\n            certificates[targetCertID].isRevoked=true;\r\n            return true;\r\n        }else{\r\n            return false;\r\n        }\r\n    }\r\n/*\r\n    function contribute(uint campaignID) public payable {\r\n        Campaign storage c = campaigns[campaignID];\r\n        // Creates a new temporary memory struct, initialised with the given values\r\n        // and copies it over to storage.\r\n        // Note that you can also use Funder(msg.sender, msg.value) to initialise.\r\n        c.funders[c.numFunders++] = CertIssuer({addr: msg.sender, amount: msg.value});\r\n        c.amount += msg.value;\r\n    }\r\n*/\r\n  /*  \r\n    function certHashExist(string value) constant returns (uint) {\r\n        for (uint i=1; i<numCerts+1; i++) {\r\n              if(stringsEqual(certificates[i].certHash,value)){\r\n                return i;\r\n              }\r\n        }\r\n        \r\n        return 0;\r\n    }*/\r\n    function getMatchCountAddress(uint addr_type,address value) public constant returns (uint){\r\n        uint counter = 0;\r\n        for (uint i=1; i<numCerts+1; i++) {\r\n              if((addr_type==0&&certificates[i].issuer_addr==value)||(addr_type==1&&certificates[i].recepient_addr==value)){\r\n                counter++;\r\n              }\r\n        }        \r\n        return counter;\r\n    }\r\n    function getCertsByIssuer(address value) public constant returns (uint[]) {\r\n        uint256[] memory matches=new uint[](getMatchCountAddress(0,value));\r\n        uint matchCount=0;\r\n        for (uint i=1; i<numCerts+1; i++) {\r\n              if(certificates[i].issuer_addr==value){\r\n                matches[matchCount++]=i;\r\n              }\r\n        }\r\n        \r\n        return matches;\r\n    }\r\n    function getCertsByRecepient(address value) public constant returns (uint[]) {\r\n        uint256[] memory matches=new uint[](getMatchCountAddress(1,value));\r\n        uint matchCount=0;\r\n        for (uint i=1; i<numCerts+1; i++) {\r\n              if(certificates[i].recepient_addr==value){\r\n                matches[matchCount++]=i;\r\n              }\r\n        }\r\n        \r\n        return matches;\r\n    }   \r\n\r\n    function getMatchCountString(uint string_type,string value) public constant returns (uint){\r\n        uint counter = 0;\r\n        for (uint i=1; i<numCerts+1; i++) {\r\n              if(string_type==0){\r\n                if(stringsEqual(certificates[i].certHash,value)){\r\n                    counter++;\r\n                }\r\n              }\r\n              if(string_type==1){\r\n                if(stringsEqual(certificates[i].version,value)){\r\n                    counter++;\r\n                }\r\n              }\r\n              if(string_type==2){\r\n                if(stringsEqual(certificates[i].content,value)){\r\n                    counter++;\r\n                }\r\n              }\r\n        }        \r\n        return counter;\r\n    }\r\n    \r\n    function getCertsByProof(string value) public constant returns (uint[]) {\r\n        uint256[] memory matches=new uint[](getMatchCountString(0,value));\r\n        uint matchCount=0;\r\n        for (uint i=1; i<numCerts+1; i++) {\r\n              if(stringsEqual(certificates[i].certHash,value)){\r\n                matches[matchCount++]=i;\r\n              }\r\n        }\r\n        \r\n        return matches;\r\n    }    \r\n    function getCertsByVersion(string value) public constant returns (uint[]) {\r\n        uint256[] memory matches=new uint[](getMatchCountString(1,value));\r\n        uint matchCount=0;\r\n        for (uint i=1; i<numCerts+1; i++) {\r\n              if(stringsEqual(certificates[i].version,value)){\r\n                matches[matchCount++]=i;\r\n              }\r\n        }\r\n        \r\n        return matches;\r\n    }\r\n    function getCertsByContent(string value) public constant returns (uint[]) {\r\n        uint256[] memory matches=new uint[](getMatchCountString(2,value));\r\n        uint matchCount=0;\r\n        for (uint i=1; i<numCerts+1; i++) {\r\n              if(stringsEqual(certificates[i].content,value)){\r\n                matches[matchCount++]=i;\r\n              }\r\n        }\r\n        \r\n        return matches;\r\n    }\r\n    \r\n/*    function getCertIssuer(string key) constant returns (address,address,string,string) {\r\n         return (certHashKey[key].issuer_addr,certHashKey[key].recepient_addr,certHashKey[key].version,certHashKey[key].content);\r\n    }\r\n*/\r\n    \r\n\tfunction stringsEqual(string storage _a, string memory _b) internal constant returns (bool) {\r\n\t\tbytes storage a = bytes(_a);\r\n\t\tbytes memory b = bytes(_b);\r\n\t\tif (a.length != b.length)\r\n\t\t\treturn false;\r\n\t\t// @todo unroll this loop\r\n\t\tfor (uint i = 0; i < a.length; i ++)\r\n\t\t\tif (a[i] != b[i])\r\n\t\t\t\treturn false;\r\n\t\treturn true;\r\n\t} \r\n\t\r\n\tfunction substring(string str, uint startIndex, uint endIndex) internal pure returns (string) {\r\n        bytes memory strBytes = bytes(str);\r\n        bytes memory result = new bytes(endIndex-startIndex);\r\n        for(uint i = startIndex; i < endIndex; i++) {\r\n            result[i-startIndex] = strBytes[i];\r\n        }\r\n        return string(result);\r\n    }\r\n    \r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"targetCertID\",\"type\":\"uint256\"}],\"name\":\"revokeCertificate\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"value\",\"type\":\"string\"}],\"name\":\"getCertsByContent\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"value\",\"type\":\"string\"}],\"name\":\"getCertsByProof\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"beneficiary\",\"type\":\"address\"},{\"name\":\"certHash\",\"type\":\"string\"},{\"name\":\"version\",\"type\":\"string\"},{\"name\":\"content\",\"type\":\"string\"}],\"name\":\"newCertificate\",\"outputs\":[{\"name\":\"certID\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"certificates\",\"outputs\":[{\"name\":\"certHash\",\"type\":\"string\"},{\"name\":\"issuer_addr\",\"type\":\"address\"},{\"name\":\"recepient_addr\",\"type\":\"address\"},{\"name\":\"version\",\"type\":\"string\"},{\"name\":\"content\",\"type\":\"string\"},{\"name\":\"isRevoked\",\"type\":\"bool\"},{\"name\":\"issuance_time\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"string_type\",\"type\":\"uint256\"},{\"name\":\"value\",\"type\":\"string\"}],\"name\":\"getMatchCountString\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"value\",\"type\":\"address\"}],\"name\":\"getCertsByIssuer\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"value\",\"type\":\"string\"}],\"name\":\"getCertsByVersion\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"beneficiaries\",\"type\":\"address[]\"},{\"name\":\"certHash\",\"type\":\"string\"},{\"name\":\"version\",\"type\":\"string\"},{\"name\":\"content\",\"type\":\"string\"},{\"name\":\"certHashChar\",\"type\":\"uint256[]\"},{\"name\":\"versionChar\",\"type\":\"uint256[]\"},{\"name\":\"contentChar\",\"type\":\"uint256[]\"}],\"name\":\"batchNewCertificate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"value\",\"type\":\"address\"}],\"name\":\"getCertsByRecepient\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"addr_type\",\"type\":\"uint256\"},{\"name\":\"value\",\"type\":\"address\"}],\"name\":\"getMatchCountAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"CertiMe","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://80223f249d2bb87036b5d32205091425ccb325b65e7a2e7d3591a34d92e4efa4"}]}