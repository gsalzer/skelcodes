{"status":"1","message":"OK","result":[{"SourceCode":"//    Copyright (C) 2018 LikeCoin Foundation Limited\r\n//\r\n//    This file is part of LikeCoin Smart Contract.\r\n//\r\n//    LikeCoin Smart Contract is free software: you can redistribute it and/or modify\r\n//    it under the terms of the GNU General Public License as published by\r\n//    the Free Software Foundation, either version 3 of the License, or\r\n//    (at your option) any later version.\r\n//\r\n//    LikeCoin Smart Contract is distributed in the hope that it will be useful,\r\n//    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n//    GNU General Public License for more details.\r\n//\r\n//    You should have received a copy of the GNU General Public License\r\n//    along with LikeCoin Smart Contract.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\n// Introduction\r\n// \r\n// This smart contract (the Relay contract) acts as the gateway between LikeChain and Ethereum.\r\n// When LikeCoin is transferred into this smart contract, the Transfer event will be received by the\r\n// background services of LikeChain, which will then fire corresponding Deposit transaction onto\r\n// LikeChain through Tendermint, minting LikeCoin on LikeChain.\r\n// When someone withdraw on LikeChain, it will create a record in the Merkle tree in LikeChain.\r\n// The Merkle root of the tree will be committed onto this smart contract periodically. Then, the user\r\n// (or operators of LikeChain, or other third-parties) can commit the Merkle proof to prove that there\r\n// exists such a withdraw record, releasing the LikeCoin previously transferred and locked in this contract.\r\n//\r\n// The main flow is as follows:\r\n// 1. Someone calls commitWithdrawHash with a payload containing votes, app hash, Merkle proof, etc.\r\n// 2. The contract checks if the votes from the validators are valid.\r\n// 3. The contract extracts block hash from the votes.\r\n// 4. The contract checks if the app hash is in the block hash by validating the Merkle proof.\r\n// 5. If everything are fine, the contract extracts the withdraw hash from app hash.\r\n// 6. When someone calls withdraw, the contract checks the Merkle proof from the call data to see if\r\n//    the withdraw data is actually in the Merkle tree of the withdraw hash committed previously.\r\n// 7. After checking, the contract transfers LikeCoin according to the withdraw info.\r\n// \r\n//\r\n// Tendermint sign bytes format:\r\n// Tendermint runs using BFT algorithms. Every block produced is signed by >2/3 of validators before\r\n// being a valid block.\r\n// The signatures are signed on the SHA-256 hash of the \"sign bytes\" of the vote. Therefore the contract\r\n// needs to reconstruct the sign bytes before validating the signatures.\r\n// The sign bytes in the votes starting from Tendermint v0.26 is changed to amino encoding.\r\n// The structure and field-order is as follows:\r\n//\r\n// type CanonicalVote struct {\r\n//     Type      SignedMsgType // type alias for byte\r\n//     Height    int64         `binary:\"fixed64\"`\r\n//     Round     int64         `binary:\"fixed64\"`\r\n//     Timestamp time.Time\r\n//     BlockID   CanonicalBlockID\r\n//     ChainID   string\r\n// }\r\n// \r\n// type CanonicalBlockID struct {\r\n//     Hash        cmn.HexBytes\r\n//     PartsHeader CanonicalPartSetHeader\r\n// }\r\n// \r\n// type CanonicalPartSetHeader struct {\r\n//     Hash  cmn.HexBytes\r\n//     Total int\r\n// }\r\n//\r\n// (cmn.HexBytes is defined as []byte)\r\n//\r\n// Type is encoded into one single byte.\r\n// Height and Round are encoded as 64-bit fixed-length integers, in little endian.\r\n// Timestamp is specially handled as a struct roughly as follows:\r\n//\r\n// type Time struct {\r\n//     Second int64 // Varint\r\n//     Nanosecond int32 // Varint, ranged from 0 to 999,999,999\r\n// }\r\n//\r\n// Varint encoding: (see https://developers.google.com/protocol-buffers/docs/encoding#varints)\r\n// \r\n// Varint is used a lot in amino, so we will first explain the encoding of varint.\r\n// In a varint, only the last 7 bits of a byte is used as the encoding of the integer.\r\n// The first bit indicates whether the varint still has succeeding bytes.\r\n// For example: 10111011 11011000 10111101 00101011\r\n// The first byte is 10111011. The value part is 0111011. Since the first bit is 1, we still need other bytes.\r\n// The second byte is 11011000. The value part is 1011000. Since the first bit is 1, we still need other bytes.\r\n// The third byte is 10111101. The value part is 0111101. Since the first bit is 1, we still need other bytes.\r\n// The fourth byte is 00101011. The value part is 0101011. Since the first bit is 0, this is the end of this varint.\r\n// So the value of the varint will be 0111011 1011000 0111101 0101011 reversed and concatenated, which is 91188283 in decimals.\r\n// \r\n// \r\n// In amino, structs are serialized into binary in a way similar to Protobuf.\r\n// Basically, it is a key-value structure, where the key is the index of the field in the struct (starting from 1),\r\n// encoeded as varint.\r\n// For example, in CanonicalVote, Type has field index 1, Height has 2, etc. So the encoding could be decoded as a mapping:\r\n// {\r\n//     Field 1 => Type 2,\r\n//     Field 2 => Height 1337,\r\n//     Field 3 => Round 2345,\r\n//     Field 4 => {\r\n//         Field 1 => 1234 Seconds,\r\n//         Field 2 => 5678 Nanoseconds\r\n//     },\r\n//     ...\r\n// }\r\n//\r\n// If a field has default value (e.g. 0 in numbers), amino will not encode that field by default.\r\n// Amino encodes the fields in sequential order.\r\n//\r\n// Typ3: (see https://developers.google.com/protocol-buffers/docs/encoding#structure)\r\n// In addition to field index, 3 bits (called Typ3) are used in the key to indicate the length of the value:\r\n//\r\n// 0 - the field itself is a varint\r\n// 1 - fixed 8-byte length\r\n// 2 - Length prefixed (using varint)\r\n// 5 - fixed 4-byte length (not used in CanonicalVote)\r\n//\r\n// For example, the Type field has field index 1, and it is encoded as varint.\r\n// Therefore the key will be 00001|000 (Field 1, Typ3 0) = 0x08.\r\n// The Height field has field index 2, and it is encoded as 8 byte fixed length integer.\r\n// Therefore the key will be 00010|001 (Field 2, Typ3 1) = 0x11.\r\n// The Timestamp field has field index 4, and it is variable length.\r\n// Therefore the key will be 00100|010 (Field 4, Typ3 2) = 0x22.\r\n// Timestamp will be encoded in a length-prefixed format. Therefore if the length of the encoded value of\r\n// the timestamp is 14, then 14 will appear right after 0x22.\r\n//\r\n// Below is an example of sign bytes:\r\n// \r\n// 0x760802110200000000000000220C08E881CADF0510E8A9E088032A480A2042288B2C20A42426A9E80F2B6D7BAA7DCEC8F7DC5B63FF5360CE8B9B7C78B5DE12240A2052F24411779931CCF793D9C222B48EFB63C034CCACBB336B655FCB3F331EBCF310013211746573742D636861696E2D77467A62616B\r\n// \r\n// which is disassembled below:\r\n//\r\n// 76 # length of the sign bytes (in varint, not including the length field itself), which is 0x76 = 118 bytes\r\n//     08 # 00001000 = 00001|000 = Field 1 (Type), Typ3 0 (varint)\r\n//         02 # value of Type field = 2\r\n//     11 # 00010001 = 00010|001 = Field 2 (Height), Typ3 1 (8 bytes)\r\n//         0200000000000000 # value of Height field (in int64, little endian) = 2\r\n//     22 # 00100010 = 00100|010 = Field 4 (Timestamp), Typ3 2 (length prefixed) (note that Field 3 (Round) is missing, hence the value is default value, which is 0)\r\n//         0C # length of the Timestamp field = 0x0C = 12\r\n//             08 # 00001000 = 00001|000 = Field 1 (Timestamp.Second), Typ3 0 (varint)\r\n//                 E881CADF05 # value of the Timestamp.Second field = 11101000 10000001 11001010 11011111 00000101, actual value = 0000101 1011111 1001010 0000001 1101000 = 1542619368\r\n//             10 # 00010000 = 00010|000 = Field 2 (Timestamp.Nanosecond), Typ3 0 (varint)\r\n//                 E8A9E08803 # value of the Timestamp.Nanosecond field = 11101000 10101001 11100000 10001000 00000011, actual value = 0000011 0001000 1100000 0101001 1101000 = 823661800\r\n//     2A # 00101010 = 00101|010 = Field 5 (BlockID), Typ3 2 (length prefixed)\r\n//         48 # length of the BlockID field = 0x48 = 72\r\n//             0A # 00001010 = 00001|010 = Field 1 (BlockID.Hash), Typ3 2 (length prefixed)\r\n//                 20 # length of the BlockID.Hash field = 0x20 = 32\r\n//                     42288B2C20A42426A9E80F2B6D7BAA7DCEC8F7DC5B63FF5360CE8B9B7C78B5DE # Value of the BlockID.Hash field\r\n//             12 # 00010010 = 00010|010 = Field 2 (BlockID.PartsHeader), Typ3 2 (length prefixed)\r\n//                 24 # length of the BlockID.Hash field = 0x24 = 36\r\n//                     0A # 00001010 = 00001|010 = Field 1 (BlockID.PartsHeader.Hash), Typ3 2 (length prefixed)\r\n//                         20 # length of the BlockID.PartsHeader.Hash field = 0x20 = 32\r\n//                             52F24411779931CCF793D9C222B48EFB63C034CCACBB336B655FCB3F331EBCF3 # Value of the BlockID.PartsHeader.Hash field\r\n//                     10 # 00010000 = 00010|000 = Field 2 (BlockID.PartsHeader.Total), Typ3 0 (varint)\r\n//                         01 # value of BlockID.PartsHeader.Total field = 1\r\n//     32 # 00110010 = 00110|010 = Field 6 (ChainID), Typ3 2 (length prefixed)\r\n//         11 # length of the ChainID field = 0x11 = 17\r\n//             746573742D636861696E2D77467A62616B # value of the ChainID field = \"test-chain-wFzbak\"\r\n//\r\n// A few points to note:\r\n// 1. Every field except the Timestamp field in the sign bytes should be the same among all the votes of the validators on the same block number\r\n// 2. Timestamp has varint, therefore could affect the length of the sign bytes, and also the offsets of the fields afterwards\r\n// 3. After confirming the offset of the BlockID part, the offset of t he block hash could also be confirmed, since every hash has fixed length 32\r\n//\r\n// Application hash:\r\n// In Tendermint, the application logic is defined by developer. The state of the application is reported\r\n// to Tendermint by application hash (app hash).\r\n// LikeChain defines the app hash as the concatenation of 2 hashes: withdraw hash and state hash.\r\n// Withdraw hash is the Merkle root of a tree containing info which the Relay contract should know.\r\n// State hash is the Merkle root of the tree containing the remaining states.\r\n// The reason of splitting them into 2 trees is to reduce the length of Merkle proof when doing withdraw.\r\n// \r\n// The app hash will be in the block header of a block. The fields in the block header will be aggregated\r\n// into a simple Merkle tree, which the tree root will be the block hash. Therefore we can use a Merkle proof\r\n// to prove that the app hash is really inside the header with specific block hash.\r\n//\r\n// Details could be found at https://github.com/tendermint/tendermint/blob/master/types/block.go#L388\r\n//\r\n//\r\n// Payload encoding to the contract:\r\n// The encoding of the votes onto the contract is as follows:\r\n// 1. the Height and Round are passed onto the contract by function parameters directly\r\n// 2. the remaining parts are encoded into a big bytes\r\n// 3. by the Height and Round, we can construct the parts before Timestamp (Type is fixed as 2)\r\n// 4. for every validators in this block, Timestamp and the signature is encoded\r\n// 5. the remaining parts after Timestamp (called \"suffix\") is encoded\r\n// 6. the Merkle proof for proving the app hash in the block hash is encoded\r\n//\r\n// The structure is like this:\r\n//\r\n// type AppHashContractProof struct {\r\n// \tHeight     uint64\r\n// \tRound      uint64\r\n// \tPayload struct {\r\n// \t\tSuffixLen  uint8\r\n// \t\tSuffix     []byte\r\n// \t\tVotesCount uint8\r\n// \t\tVotes      []struct {\r\n// \t\t\tTimeLen uint8\r\n// \t\t\tTime    []byte\r\n// \t\t\tSig     [65]byte\r\n// \t\t}\r\n// \t\tAppHashLen   uint8\r\n// \t\tAppHash      []byte\r\n// \t\tAppHashProof [4][32]byte\r\n// \t}\r\n// }\r\n//\r\n// We assume that the total length of the sign bytes are <= 127, so uint8 could be used as varint prefix.\r\n// The length restriction could be calculated as follows:\r\n//\r\n// Type: 1 byte field number + 1 byte value = 2 bytes\r\n// Height: 1 byte field numnber + 8 bytes value = 9 bytes\r\n// Round: 1 byte field numnber + 8 bytes value = 9 bytes\r\n// Timestamp: 1 byte field numnber + 1 byte length +\r\n//           1 byte field number + 6 bytes varint second (at most 43 bits, enough for ~278,731 years since 1970) +\r\n//           1 byte field number + 5 bytes varint nanosecond (at most 36 bits, enough since maximum value is 999,999,999, which is < 2^36)\r\n// = 15 bytes\r\n// BlockID: 1 byte field numnber + 1 byte length +\r\n//              1 byte field number + 1 byte length + 32 bytes value +\r\n//              1 byte field number + 1 bytes length +\r\n//                  1 byte field number + 1 byte length + 32 byte value +\r\n//                  1 byte field number + 1 byte value\r\n// = 74 bytes\r\n// ChainID: 1 byte field numnber + 1 byte length + n bytes value = (n + 2) bytes\r\n// Total = 111 + n bytes\r\n// \r\n// So we have 111 + n <= 127, which means ChainID should have length <= 16.\r\n// In practice, Timestamp is shorter than the maximum (until ~year 4140), and Round usually have default value 0,\r\n// therefore the restriction is not that strict, but should still be considered.\r\n//\r\n//\r\n//  \r\n// IAVL RangeProof:\r\n// In IAVL tree, RangeProof is used to prove that a range of values (\"sibling\" leaves) are inside the tree.\r\n// It is also possible to prove that a value is absent in the tree, by proving a range is in the tree and the\r\n// value should appear in that range if it is present.\r\n// In this contract, we are only using RangeProof with only one leaf.\r\n//\r\n// The definition of RangeProof struct is as follows:\r\n// (See https://github.com/tendermint/iavl/blob/master/proof_range.go#L216 for source code)\r\n//\r\n// type RangeProof struct {\r\n// \t// You don't need the right path because\r\n// \t// it can be derived from what we have.\r\n// \tLeftPath   PathToLeaf      `json:\"left_path\"`\r\n// \tInnerNodes []PathToLeaf    `json:\"inner_nodes\"`\r\n// \tLeaves     []proofLeafNode `json:\"leaves\"`\r\n//\r\n// \t// memoize\r\n// \trootVerified bool\r\n// \trootHash     []byte // valid iff rootVerified is true\r\n// \ttreeEnd      bool   // valid iff rootVerified is true\r\n//\r\n// }\r\n//\r\n// type PathToLeaf []proofInnerNode\r\n//\r\n// type proofInnerNode struct {\r\n// \tHeight  int8   `json:\"height\"`\r\n// \tSize    int64  `json:\"size\"`\r\n// \tVersion int64  `json:\"version\"`\r\n// \tLeft    []byte `json:\"left\"`\r\n// \tRight   []byte `json:\"right\"`\r\n// }\r\n//\r\n// type proofLeafNode struct {\r\n// \tKey       cmn.HexBytes `json:\"key\"`\r\n// \tValueHash cmn.HexBytes `json:\"value\"`\r\n// \tVersion   int64        `json:\"version\"`\r\n// }\r\n//\r\n// In case of there is only one leaf in the RangeProof, InnerNodes will be empty and Leaves will only contain one node.\r\n// In this case, the procedure of computing root hash is as follows:\r\n// \r\n// 1. Encode leaf node in binary.\r\n//   1.1. Encode Height (0) as int8 (one single byte).\r\n//   1.2. Encode Size (1) as varint.\r\n//        (note that it is an integer, which could be negative, and is encoded in zigzag encoding in varint, so positive\r\n//        number n will be encoded as 2n, i.e. 0x02 is used for encoding 1)\r\n//   1.3. Encode Version as varint.\r\n//   1.4. Encode Key by prefixing length in varint, then encode the bytes.\r\n//   1.5. Encode ValueHash by prefixing length in varint, then encode the bytes.\r\n// 2. Hash the encoded binary by SHA-256 to get current hash.\r\n// 3. Repeatedly mix inner nodes (from bottom to up) into current hash to update current hash, until reaching the top.\r\n//   3.1. Encode Height as int8 (one single byte).\r\n//   3.2. Encode Size as varint.\r\n//   3.3. Encode Version as varint.\r\n//   3.4. Encode current hash and one of Left or Right. (One of Left or Right must be empty)\r\n//     3.4.1. If Left is empty, then first encode current hash (prefix length), then encode Right (prefix length).\r\n//     3.4.2. If Right is empty, then first encode Left (prefix length), then encode current hash (prefix length).\r\n//\r\n// Payload encoding to the contract:\r\n// The proof has 2 parts: leaf and inner nodes.\r\n// For leaf, only the version is needed. However, since it is varint, we also need to know the length of the version field.\r\n// For inner nodes, we need to know all the info, plus whether current hash should be Left or Right, to decide the hashing order.\r\n// There we need to encode the followings:\r\n//\r\n// 1. Length of leaf Version\r\n// 2. Leaf version\r\n// 3. Number of inner nodes\r\n// 4. Inner nodes\r\n//   4.1. Length of all the parts except Left or Right. This part is called \"prefix\".\r\n//   4.2. One bit for indicating whether current hash should be Left or Right.\r\n//   4.3. The prefix\r\n//   4.4. The Left or Right in the inner node. This is called \"sibling\".\r\n//\r\n// Further investigation shows that the prefix part of inner nodes will never exceed 127 bytes.\r\n// Therefore the \"one bit\" is encoded together with the prefix length.\r\n// The final format is as follows:\r\n//\r\n// type ContractIAVLTreeProof struct {\r\n// \tVersionLength    uint8\r\n// \tLeafVersionBytes []byte\r\n// \tPathLength       uint8\r\n// \tPath             []struct {\r\n// \t\tPrefixLengthAndOrder uint8 // first bit indicates the node is left or right\r\n// \t\tPrefix               []byte\r\n// \t\tSibling              []byte\r\n// \t}\r\n// }\r\n\r\n\r\n\r\n\r\n\r\n\r\npragma solidity ^0.4.25;\r\n\r\n// Source: https://github.com/OpenZeppelin/openzeppelin-solidity/blob/5471fc808a17342d738853d7bf3e9e5ef3108074/contracts/token/ERC20/IERC20.sol\r\n// Copied here to avoid incompatibility with Solidity v0.5.x in latest master branch\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address who) external view returns (uint256);\r\n\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n\r\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\ncontract LikeChainRelayLogicInterface {\r\n    function commitWithdrawHash(uint64 height, uint64 round, bytes _payload) public;\r\n    function updateValidator(address[] _newValidators, bytes _proof) public;\r\n    function withdraw(bytes _withdrawInfo, bytes _proof) public;\r\n    function upgradeLogicContract(address _newLogicContract, bytes _proof) public;\r\n    event Upgraded(uint256 _newLogicContractIndex, address _newLogicContract);\r\n}\r\n\r\ncontract LikeChainRelayState {\r\n    uint256 public logicContractIndex;\r\n    address public logicContract;\r\n\r\n    IERC20 public tokenContract;\r\n\r\n    address[] public validators;\r\n    \r\n    struct ValidatorInfo {\r\n        uint8 index;\r\n        uint32 power;\r\n    }\r\n    \r\n    mapping(address => ValidatorInfo) public validatorInfo;\r\n    uint256 public totalVotingPower;\r\n    uint public lastValidatorUpdateTime;\r\n\r\n    uint public latestBlockHeight;\r\n    bytes32 public latestWithdrawHash;\r\n\r\n    mapping(bytes32 => bool) public consumedIds;\r\n    mapping(bytes32 => bytes32) public reserved;\r\n}\r\n\r\ncontract LikeChainRelayLogic is LikeChainRelayState, LikeChainRelayLogicInterface {\r\n    constructor(address[] _validators, uint32[] _votingPowers, address _tokenContract) public {\r\n        uint len = _validators.length;\r\n        require(len > 0);\r\n        require(len < 256);\r\n        require(_votingPowers.length == len);\r\n\r\n        for (uint8 i = 0; i < len; i += 1) {\r\n            address v = _validators[i];\r\n            require(validatorInfo[v].power == 0);\r\n            uint32 power = _votingPowers[i];\r\n            require(power > 0);\r\n            validators.push(v);\r\n            validatorInfo[v] = ValidatorInfo({\r\n                index: i,\r\n                power: power\r\n            });\r\n            totalVotingPower += power;\r\n        }\r\n        \r\n        tokenContract = IERC20(_tokenContract);\r\n    }\r\n    \r\n    function _proofRootHash(bytes32 _key, bytes32 _value, bytes _proof) internal view returns (bytes32 rootHash) {\r\n        assembly {\r\n            let start := mload(0x40)\r\n            let p := start\r\n            let curHashStart := add(start, 128)\r\n            let data := add(_proof, 33) // 32 byte length + 1 byte reserved\r\n            \r\n            let len := and(mload(sub(data, 31)), 0xff) // version length\r\n            if gt(len, 9) { revert(0, 0) } // version is uint64, so the varint encoded should never longer than 9 bytes\r\n            data := add(data, 1)\r\n            mstore(p, hex\"0002\")\r\n            p := add(p, 2)\r\n            mstore(p, mload(data))\r\n            data := add(data, len)\r\n            p := add(p, len)\r\n            mstore8(p, 32) // amino length-prefixed encoding for []byte (length 32)\r\n            p := add(p, 1)\r\n            mstore(p, _key)\r\n            p := add(p, 32)\r\n            mstore8(p, 32) // amino length-prefixed encoding for []byte (length 32)\r\n            p := add(p, 1)\r\n            mstore(p, _value)\r\n            p := add(p, 32)\r\n            let _ := staticcall(gas, 2, start, sub(p, start), curHashStart, 32)\r\n            \r\n            len := and(mload(sub(data, 31)), 0xff) // number of path nodes\r\n            data := add(data, 1)\r\n            for { let i := len } gt(i, 0) { i := sub(i, 1) } {\r\n                p := start\r\n                len := and(mload(sub(data, 31)), 0xff) // 1 bit left-right indicator, 7 bits length\r\n                let order := and(len, 0x80)\r\n                len := and(len, 0x7f)\r\n                if gt(len, 19) { revert(0, 0) } // 1-byte height (< 128) + 9-byte 64-bit varint-encoded numbers * 2\r\n                data := add(data, 1)\r\n                mstore(p, mload(data))\r\n                p := add(p, len)\r\n                data := add(data, len)\r\n                switch order\r\n                case 0 {\r\n                    mstore8(p, 32) // amino length-prefixed encoding for []byte\r\n                    p := add(p, 1)\r\n                    mstore(p, mload(curHashStart))\r\n                    p := add(p, 32)\r\n                    mstore8(p, 32) // amino length-prefixed encoding for []byte\r\n                    p := add(p, 1)\r\n                    mstore(p, mload(data))\r\n                    p := add(p, 32)\r\n                } default {\r\n                    mstore8(p, 32) // amino length-prefixed encoding for []byte\r\n                    p := add(p, 1)\r\n                    mstore(p, mload(data))\r\n                    p := add(p, 32)\r\n                    mstore8(p, 32) // amino length-prefixed encoding for []byte\r\n                    p := add(p, 1)\r\n                    mstore(p, mload(curHashStart))\r\n                    p := add(p, 32)\r\n                }\r\n                data := add(data, 32)\r\n                _ := staticcall(gas, 2, start, sub(p, start), curHashStart, 32)\r\n            }\r\n            len := mload(_proof)\r\n            if gt(sub(data, add(_proof, 32)), len) {\r\n                revert(0, 0)\r\n            }\r\n            rootHash := mload(curHashStart)\r\n        }\r\n        return rootHash;\r\n    }\r\n    \r\n    // See https://tendermint.com/docs/spec/blockchain/blockchain.html#lastcommit\r\n    function commitWithdrawHash(uint64 height, uint64 round, bytes _payload) public {\r\n        // Memory layout:\r\n        // 0..127: sign bytes\r\n        // 128..: temporary storage e.g. computing mapping storage position by hash, recovering address\r\n        assembly {\r\n            // The n bytes are at the beginning of a 32-byte word, with zeros following\r\n            function getNByte(p, n) -> bs {\r\n                if gt(n, 32) {\r\n                    revert(0, 0)\r\n                }\r\n                let numberOfOnes := mul(n, 8)\r\n                let numberOfZeros := sub(256, numberOfOnes)\r\n                // mask == 111111...11100000...000, with (8*n) 1s and (256 - 8*n) 0s\r\n                let mask := 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\r\n                mask := xor(mask, sub(exp(2, numberOfZeros), 1))\r\n                bs := and(mload(p), mask)\r\n            }\r\n            \r\n            // The byte is at the end of a 32-byte word\r\n            function getOneByte(p) -> b {\r\n                // b := and(mload(sub(p, 31)), 0xFF)\r\n                b := byte(0, mload(p))\r\n            }\r\n            \r\n            // Takes the height and round, reconstruct the prefix part of the amino-encoded sign bytes,\r\n            // which contains type (0x02), height, round\r\n            function reconstructPrefix(p, height, round) -> next {\r\n                mstore8(p, 0x00) // place-holder for length prefix\r\n                p := add(p, 1)\r\n                mstore8(p, 0x08) // field number for `type`\r\n                p := add(p, 1)\r\n                mstore8(p, 0x02) // value for `precommit` type\r\n                p := add(p, 1)\r\n                if gt(height, 0) {\r\n                    mstore8(p, 0x11) // field number for `height`\r\n                    p := add(p, 1)\r\n                    for { let i := 0 } lt(i, 8) { i := add(i, 1) } {\r\n                        mstore8(p, mod(height, 0x100))\r\n                        height := div(height, 0x100)\r\n                        p := add(p, 1)\r\n                    }\r\n                }\r\n                if gt(round, 0) {\r\n                    mstore8(p, 0x19) // field number for `round`\r\n                    p := add(p, 1)\r\n                    for { let i := 0 } lt(i, 8) { i := add(i, 1) } {\r\n                        mstore8(p, mod(round, 0x100))\r\n                        height := div(round, 0x100)\r\n                        p := add(p, 1)\r\n                    }\r\n                }\r\n                next := p\r\n            }\r\n            \r\n            function extractBlockHash(suffix) -> blockHash {\r\n                blockHash := mload(add(suffix, 4))\r\n            }\r\n            \r\n            // Note that copy is done in words, so the last word may overwrite some bytes\r\n            function memcpy(dst, src, len) {\r\n                let dstEnd := add(dst, len)\r\n                for { } lt(dst, dstEnd) { dst := add(dst, 32) src := add(src, 32) } {\r\n                    mstore(dst, mload(src))\r\n                }\r\n            }\r\n            \r\n            // 1. copy `timeLength` bytes from `timeSource` to `timeStart`\r\n            // 2. copy `suffixLength` bytes from `suffixSource` to the location next to time\r\n            // 3. calculate the total length of the content and write to starting position\r\n            function reconstructSignBytes(p, timeStart, time, timeLen, suffixSrc, suffixLen) -> end {\r\n                let start := p\r\n                mstore(timeStart, time)\r\n                p := add(timeStart, timeLen)\r\n                memcpy(p, suffixSrc, suffixLen)\r\n                end := add(p, suffixLen)\r\n                let len := sub(end, add(start, 1))\r\n                mstore8(start, len)\r\n            }\r\n            \r\n            function getVoter(p, timeStart, suffixSrc, suffixLen) -> voter, next {\r\n                let msgStart := mload(0x40)\r\n                let timeLen := getOneByte(p)\r\n                if gt(timeLen, 15) { revert(0, 0) }\r\n                p := add(p, 1)\r\n                let time := getNByte(p, timeLen)\r\n                p := add(p, timeLen)\r\n                let msgEnd := reconstructSignBytes(msgStart, timeStart, time, timeLen, suffixSrc, suffixLen)\r\n                \r\n                // ecrecover precompiled contract\r\n                // Contract address: 1\r\n                // Input: bytes32 hash, uint v, bytes32 r, bytes32 s\r\n                // Output: address signer\r\n\r\n                let buf := add(msgStart, 128)\r\n                let _ := staticcall(gas, 2, msgStart, sub(msgEnd, msgStart), buf, 32) // SHA-256 hash, at buf[0:32]\r\n                mstore(add(buf, 32), getOneByte(p)) // v at buf[32:64]\r\n                p := add(p, 1)\r\n                mstore(add(buf, 64), mload(p)) // r at buf[64:96]\r\n                p := add(p, 32)\r\n                mstore(add(buf, 96), mload(p)) // s at buf[96:128]\r\n                p := add(p, 32)\r\n                let succ := staticcall(gas, 1, buf, 128, buf, 32)\r\n                if iszero(succ) {\r\n                    revert(0, 0)\r\n                }\r\n                voter := mload(buf)\r\n                next := p\r\n            }\r\n            \r\n            // For layout of mapping, see\r\n            // https://solidity.readthedocs.io/en/v0.4.24/miscellaneous.html#layout-of-state-variables-in-storage\r\n            function getVoterInfo(addr) -> index, power {\r\n                let buf := add(mload(0x40), 128)\r\n                mstore(buf, addr)\r\n                mstore(add(buf, 32), validatorInfo_slot)\r\n                let slot := keccak256(buf, 64)\r\n                let votingInfo := sload(slot)\r\n                if eq(votingInfo, 0) {\r\n                    revert(0, 0)\r\n                }\r\n                index := and(votingInfo, 0xFF)\r\n                power := and(div(votingInfo, 0x100), 0xFFFFFFFF)\r\n            }\r\n            \r\n            function accumulateVoterPower(voter, votedSet, power) -> newVotedSet, newPower {\r\n                let voterIndex, voterPower := getVoterInfo(voter)\r\n                let mask := exp(2, voterIndex)\r\n                if iszero(eq(0, and(votedSet, mask))) {\r\n                    revert(0, 0)\r\n                }\r\n                newVotedSet := or(votedSet, mask)\r\n                newPower := add(power, voterPower)\r\n            }\r\n            \r\n            function checkVotes(p, height, round) -> blockHash, next {\r\n                let votedSet := 0\r\n                let voterPower := 0\r\n                \r\n                let suffixLen := getOneByte(p)\r\n                if gt(suffixLen, 92) { revert(0, 0) }\r\n                p := add(p, 1)\r\n                let suffixSrc := p\r\n                p := add(p, suffixLen)\r\n                blockHash := extractBlockHash(suffixSrc)\r\n                \r\n                let msgStart := mload(0x40)\r\n                let timeStart := reconstructPrefix(msgStart, height, round)\r\n                \r\n                let votesCount := getOneByte(p)\r\n                p := add(p, 1)\r\n                for {} gt(votesCount, 0) { votesCount := sub(votesCount, 1) } {\r\n                    let voter\r\n                    voter, p := getVoter(p, timeStart, suffixSrc, suffixLen)\r\n                    votedSet, voterPower := accumulateVoterPower(voter, votedSet, voterPower)\r\n                }\r\n                // Need strictly more than 2/3 of total voting power\r\n                if iszero(gt(mul(voterPower, 3), mul(sload(totalVotingPower_slot), 2))) {\r\n                    revert(0, 0)\r\n                }\r\n                next := p\r\n            }\r\n            \r\n            // The blockHash is the Merkle root of 16 fields (including AppHash) in the block header.\r\n            // Therefore we can use a Merkle proof to prove the appHash is in the block header.\r\n            // The Merkle root is computed as follows:\r\n            // 1. Each field is amino-encoded into a []byte. For []byte, it is done by prefixing len(bs).\r\n            // 2. The resulting []byte will be hashed again to get a leaf node in the Merkle tree.\r\n            // 3. Each pair of leaf nodes are amino-encoded and concated, then hashed into the parent of these 2 nodes.\r\n            // 4. Repeat the process until reaching the root, which will be blockHash.\r\n            //\r\n            // So to verify the Merkle proof of the \"App\" field, the contract needs to:\r\n            // 1. hash \"\\x{appHashLen}{appHashLen-byte-appHash}\" to get the leaf node for AppHash\r\n            // 2. Hash \"\\x20{leaf-node}\\x20{proof-1}\" to get new leaf node.\r\n            // 3. Hash \"\\x20{leaf-node}\\x20{proof-2}\" to get new leaf node.\r\n            // 4. Hash \"\\x20{proof-3}\\x20{leaf-node}\" to get new leaf node.\r\n            // 5. Hash \"\\x20{proof-4}\\x20{leaf-node}\" to get root hash.\r\n            // 6. Check if the root hash equals to blockHash\r\n            //\r\n            // Then the first 32 bytes of the AppHash will be extracted as the withdrawHash.\r\n            function extractAndProofWithdrawHash(p, blockHash) -> withdrawHash {\r\n                let buf := mload(0x40)\r\n                let aminoEncodedAppHashLen := add(getOneByte(p), 1)\r\n                // No need to `p := add(p, 1)`, as the amino-encoded appHash needs length prefix\r\n                memcpy(buf, p, aminoEncodedAppHashLen)\r\n                withdrawHash := mload(add(p, 1))\r\n                p := add(p, aminoEncodedAppHashLen)\r\n                \r\n                let left := add(buf, 1)\r\n                let right := add(buf, 34)\r\n                // 1. hash \"\\x{appHashLen}{appHashLen-byte-appHash}\" to get the leaf node for AppHash\r\n                let _ := staticcall(gas, 2, buf, aminoEncodedAppHashLen, left, 32)\r\n                // 2. Hash \"\\x20{leaf-node}\\x20{proof-1}\" to get new leaf node.\r\n                mstore8(sub(left, 1), 32)\r\n                mstore8(sub(right, 1), 32)\r\n                mstore(right, mload(p))\r\n                p := add(p, 32)\r\n                _ := staticcall(gas, 2, buf, 66, left, 32)\r\n                // 3. Hash \"\\x20{leaf-node}\\x20{proof-2}\" to get new leaf node.\r\n                mstore(right, mload(p))\r\n                p := add(p, 32)\r\n                _ := staticcall(gas, 2, buf, 66, right, 32)\r\n                // 4. Hash \"\\x20{proof-3}\\x20{leaf-node}\" to get new leaf node.\r\n                mstore(left, mload(p))\r\n                p := add(p, 32)\r\n                _ := staticcall(gas, 2, buf, 66, right, 32)\r\n                // 5. Hash \"\\x20{proof-4}\\x20{leaf-node}\" to get root hash.\r\n                mstore(left, mload(p))\r\n                p := add(p, 32)\r\n                _ := staticcall(gas, 2, buf, 66, buf, 32)\r\n                // 6. Check if the root hash equals to blockHash\r\n                if iszero(eq(blockHash, mload(buf))) {\r\n                    revert(0, 0)\r\n                }\r\n            }\r\n            \r\n            if iszero(gt(height, sload(latestBlockHeight_slot))) {\r\n                revert(0, 0)\r\n            }\r\n            let blockHash\r\n            let p := add(_payload, 32)\r\n            blockHash, p := checkVotes(p, height, round)\r\n            let withdrawHash := extractAndProofWithdrawHash(p, blockHash)\r\n            sstore(latestBlockHeight_slot, height)\r\n            sstore(latestWithdrawHash_slot, withdrawHash)\r\n        }\r\n    }\r\n\r\n    // In the IAVL tree, the key is the hash of the withdraw information ({ from, to, value, fee, nonce }) and the value is\r\n    // 0x01 (only as an indicator of key existence). Therefore the proving process is as follows:\r\n    // 1. reconstruct key from { from, to, value, fee, nonce }\r\n    // 2. pack lead node: [0, 1, leafVersionBytes, key, sha256(0x01)]\r\n    //    (Note that the `1` is encoded as signed varint, so is 0x02 in binary. See line 275 for details)\r\n    // 3. hash packed output to get current hash\r\n    // 4. repeat the followings:\r\n    //    1. extract prefixBytes and suffixBytes\r\n    //    2. pack [prefixBytes, currentHash, suffixBytes]\r\n    //    3. hash packed output and update current hash\r\n    // 5. output current hash as root hash\r\n    // 6. check if root hash from the proof is equal to the withdraw hash recorded previously from commitWithdrawHash\r\n    \r\n    function _proofAndExtractWithdraw(bytes _withdrawInfo, bytes _proof) internal returns (address to, uint256 value, uint256 fee) {\r\n        bytes32 id = sha256(_withdrawInfo);\r\n        require(!consumedIds[id]);\r\n        consumedIds[id] = true;\r\n        bytes32 proofValueHash = hex\"4bf5122f344554c53bde2ebb8cd2b7e3d1600ad631c385a5d7cce23c7785459a\"; // sha256 of hex\"01\"\r\n        bytes32 rootHash = _proofRootHash(id, proofValueHash, _proof);\r\n        require(rootHash == latestWithdrawHash);\r\n        assembly {\r\n            to := mload(add(_withdrawInfo, 40))\r\n            value := mload(add(_withdrawInfo, 72))\r\n            fee := mload(add(_withdrawInfo, 104))\r\n        }\r\n        return (to, value, fee);\r\n    }\r\n\r\n    function withdraw(bytes _withdrawInfo, bytes _proof) public {\r\n        address to;\r\n        uint256 value;\r\n        uint256 fee;\r\n        (to, value, fee) = _proofAndExtractWithdraw(_withdrawInfo, _proof);\r\n        tokenContract.transfer(msg.sender, fee);\r\n        tokenContract.transfer(to, value);\r\n    }\r\n\r\n    function updateValidator(address[] _newValidators, bytes _proof) public {\r\n        // TODO\r\n    }\r\n    \r\n    // 1. reconstruct key by the format sha256(\"exec{big-endian encoded 64-bit contract index})\"\r\n    // 2. get value hash by sha256(contract address)\r\n    // 3. prove that the key-value pair is in withdraw tree\r\n    // 4. update the contract and contract index\r\n    function upgradeLogicContract(address _newLogicContract, bytes _proof) public {\r\n        logicContractIndex += 1;\r\n        bytes12 keyBeforeHash = bytes12(uint96(bytes12(\"exec\")) | uint96(logicContractIndex));\r\n        bytes32 key = sha256(abi.encodePacked(keyBeforeHash));\r\n        bytes32 proofValueHash = sha256(abi.encodePacked(_newLogicContract));\r\n        bytes32 rootHash = _proofRootHash(key, proofValueHash, _proof);\r\n        require(rootHash == latestWithdrawHash);\r\n        logicContract = _newLogicContract;\r\n        emit Upgraded(logicContractIndex, _newLogicContract);\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_newValidators\",\"type\":\"address[]\"},{\"name\":\"_proof\",\"type\":\"bytes\"}],\"name\":\"updateValidator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"validators\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"latestWithdrawHash\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"validatorInfo\",\"outputs\":[{\"name\":\"index\",\"type\":\"uint8\"},{\"name\":\"power\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_withdrawInfo\",\"type\":\"bytes\"},{\"name\":\"_proof\",\"type\":\"bytes\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastValidatorUpdateTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalVotingPower\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newLogicContract\",\"type\":\"address\"},{\"name\":\"_proof\",\"type\":\"bytes\"}],\"name\":\"upgradeLogicContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"reserved\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"height\",\"type\":\"uint64\"},{\"name\":\"round\",\"type\":\"uint64\"},{\"name\":\"_payload\",\"type\":\"bytes\"}],\"name\":\"commitWithdrawHash\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"logicContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"logicContractIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"consumedIds\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"latestBlockHeight\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_validators\",\"type\":\"address[]\"},{\"name\":\"_votingPowers\",\"type\":\"uint32[]\"},{\"name\":\"_tokenContract\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_newLogicContractIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_newLogicContract\",\"type\":\"address\"}],\"name\":\"Upgraded\",\"type\":\"event\"}]","ContractName":"LikeChainRelayLogic","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000014000000000000000000000000002f61fd266da6e8b102d4121f5ce7b992640cf98000000000000000000000000000000000000000000000000000000000000000600000000000000000000000062be52bd46aaeb2bdcd2d123478b1acbfb1d2346000000000000000000000000d2df2a279f931d57042440f694b27048f618b319000000000000000000000000db53bc6aa6cf634669e704c49568d18d539e830d0000000000000000000000001aef7c26e48e5ed83024bcb122931fb30a99d54b000000000000000000000000c6720a4b73ad41ab7147b8ac42eca62250d8fb9a00000000000000000000000049a116b7eda1a5eae5e56a4e285d4dbdfd18aa5e0000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000411a000000000000000000000000000000000000000000000000000000000000411a000000000000000000000000000000000000000000000000000000000000411a000000000000000000000000000000000000000000000000000000000000411a000000000000000000000000000000000000000000000000000000000000411a000000000000000000000000000000000000000000000000000000000000411e","Library":"","SwarmSource":"bzzr://28cc1d4d922e49da40fdbb2a7a9bdc996e552363d6837d45cf07c4bf166b97c3"}]}