{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.5.4;\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Unsigned math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Multiplies two unsigned integers, reverts on overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Adds two unsigned integers, reverts on overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\r\n     * reverts when dividing by zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n     * account.\r\n     */\r\n    constructor () internal {\r\n        _owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), _owner);\r\n    }\r\n\r\n    /**\r\n     * @return the address of the owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner());\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @return true if `msg.sender` is the owner of the contract.\r\n     */\r\n    function isOwner() public view returns (bool) {\r\n        return msg.sender == _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to relinquish control of the contract.\r\n     * It will not be possible to call the functions with the `onlyOwner`\r\n     * modifier anymore.\r\n     * @notice Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0));\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\n/**\r\n * @title Roles\r\n * @dev Library for managing addresses assigned to a Role.\r\n */\r\nlibrary Roles {\r\n    struct Role {\r\n        mapping (address => bool) bearer;\r\n    }\r\n\r\n    /**\r\n     * @dev give an account access to this role\r\n     */\r\n    function add(Role storage role, address account) internal {\r\n        require(account != address(0));\r\n        require(!has(role, account));\r\n\r\n        role.bearer[account] = true;\r\n    }\r\n\r\n    /**\r\n     * @dev remove an account's access to this role\r\n     */\r\n    function remove(Role storage role, address account) internal {\r\n        require(account != address(0));\r\n        require(has(role, account));\r\n\r\n        role.bearer[account] = false;\r\n    }\r\n\r\n    /**\r\n     * @dev check if an account has this role\r\n     * @return bool\r\n     */\r\n    function has(Role storage role, address account) internal view returns (bool) {\r\n        require(account != address(0));\r\n        return role.bearer[account];\r\n    }\r\n}\r\n\r\ncontract MinterRole {\r\n    using Roles for Roles.Role;\r\n\r\n    event MinterAdded(address indexed account);\r\n    event MinterRemoved(address indexed account);\r\n\r\n    Roles.Role private _minters;\r\n\r\n    constructor () internal {\r\n        _addMinter(msg.sender);\r\n    }\r\n\r\n    modifier onlyMinter() {\r\n        require(isMinter(msg.sender));\r\n        _;\r\n    }\r\n\r\n    function isMinter(address account) public view returns (bool) {\r\n        return _minters.has(account);\r\n    }\r\n\r\n    function addMinter(address account) public onlyMinter {\r\n        _addMinter(account);\r\n    }\r\n\r\n    function renounceMinter() public {\r\n        _removeMinter(msg.sender);\r\n    }\r\n\r\n    function _addMinter(address account) internal {\r\n        _minters.add(account);\r\n        emit MinterAdded(account);\r\n    }\r\n\r\n    function _removeMinter(address account) internal {\r\n        _minters.remove(account);\r\n        emit MinterRemoved(account);\r\n    }\r\n}\r\n\r\n/**\r\n * @title Helps contracts guard against reentrancy attacks.\r\n * @author Remco Bloemen <remco@2π.com>, Eenae <alexey@mixbytes.io>\r\n * @dev If you mark a function `nonReentrant`, you should also\r\n * mark it `external`.\r\n */\r\ncontract ReentrancyGuard {\r\n    /// @dev counter to allow mutex lock with only one SSTORE operation\r\n    uint256 private _guardCounter;\r\n\r\n    constructor () internal {\r\n        // The counter starts at one to prevent changing it from zero to a non-zero\r\n        // value, which is a more expensive operation.\r\n        _guardCounter = 1;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and make it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        _guardCounter += 1;\r\n        uint256 localCounter = _guardCounter;\r\n        _;\r\n        require(localCounter == _guardCounter);\r\n    }\r\n}\r\n\r\ncontract CertificateControllerMock {\r\n\r\n  // Address used by off-chain controller service to sign certificate\r\n  mapping(address => bool) internal _certificateSigners;\r\n\r\n  // A nonce used to ensure a certificate can be used only once\r\n  mapping(address => uint256) internal _checkCount;\r\n\r\n  event Checked(address sender);\r\n\r\n  constructor(address _certificateSigner) public {\r\n    _setCertificateSigner(_certificateSigner, true);\r\n  }\r\n\r\n  /**\r\n   * @dev Modifier to protect methods with certificate control\r\n   */\r\n  modifier isValidCertificate(bytes memory data) {\r\n\r\n    require(_certificateSigners[msg.sender] || _checkCertificate(data, 0, 0x00000000), \"A3: Transfer Blocked - Sender lockup period not ended\");\r\n\r\n    _checkCount[msg.sender] += 1; // Increment sender check count\r\n\r\n    emit Checked(msg.sender);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Get number of transations already sent to this contract by the sender\r\n   * @param sender Address whom to check the counter of.\r\n   * @return uint256 Number of transaction already sent to this contract.\r\n   */\r\n  function checkCount(address sender) external view returns (uint256) {\r\n    return _checkCount[sender];\r\n  }\r\n\r\n  /**\r\n   * @dev Get certificate signer authorization for an operator.\r\n   * @param operator Address whom to check the certificate signer authorization for.\r\n   * @return bool 'true' if operator is authorized as certificate signer, 'false' if not.\r\n   */\r\n  function certificateSigners(address operator) external view returns (bool) {\r\n    return _certificateSigners[operator];\r\n  }\r\n\r\n  /**\r\n   * @dev Set signer authorization for operator.\r\n   * @param operator Address to add/remove as a certificate signer.\r\n   * @param authorized 'true' if operator shall be accepted as certificate signer, 'false' if not.\r\n   */\r\n  function _setCertificateSigner(address operator, bool authorized) internal {\r\n    require(operator != address(0), \"Action Blocked - Not a valid address\");\r\n    _certificateSigners[operator] = authorized;\r\n  }\r\n\r\n  /**\r\n   * @dev Checks if a certificate is correct\r\n   * @param data Certificate to control\r\n   */\r\n   function _checkCertificate(bytes memory data, uint256 /*value*/, bytes4 /*functionID*/) internal pure returns(bool) { \r\n     // Comments to avoid compilation warnings for unused variables.\r\n     if(data.length > 0 && (data[0] == hex\"10\" || data[0] == hex\"11\" || data[0] == hex\"22\")) {\r\n       return true;\r\n     } else {\r\n       return false;\r\n     }\r\n   }\r\n}\r\n\r\ncontract CertificateController is CertificateControllerMock {\r\n\r\n  constructor(address _certificateSigner) public CertificateControllerMock(_certificateSigner) {}\r\n\r\n}\r\n\r\n\r\n/**\r\n * @title IERC777TokensRecipient\r\n * @dev ERC777TokensRecipient interface\r\n */\r\ninterface IERC777TokensRecipient {\r\n\r\n  function canReceive(\r\n    bytes32 partition,\r\n    address from,\r\n    address to,\r\n    uint value,\r\n    bytes calldata data,\r\n    bytes calldata operatorData\r\n  ) external view returns(bool);\r\n\r\n  function tokensReceived(\r\n    bytes32 partition,\r\n    address operator,\r\n    address from,\r\n    address to,\r\n    uint value,\r\n    bytes calldata data,\r\n    bytes calldata operatorData\r\n  ) external;\r\n\r\n}\r\n\r\n/**\r\n * @title IERC777TokensSender\r\n * @dev ERC777TokensSender interface\r\n */\r\ninterface IERC777TokensSender {\r\n\r\n  function canTransfer(\r\n    bytes32 partition,\r\n    address from,\r\n    address to,\r\n    uint value,\r\n    bytes calldata data,\r\n    bytes calldata operatorData\r\n  ) external view returns(bool);\r\n\r\n  function tokensToTransfer(\r\n    bytes32 partition,\r\n    address operator,\r\n    address from,\r\n    address to,\r\n    uint value,\r\n    bytes calldata data,\r\n    bytes calldata operatorData\r\n  ) external;\r\n\r\n}\r\n\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://eips.ethereum.org/EIPS/eip-20\r\n */\r\ncontract IERC20 {\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n\r\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address who) external view returns (uint256);\r\n\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n/**\r\n * @title IERC1410 partially fungible token standard\r\n * @dev ERC1410 interface\r\n */\r\ninterface IERC1410 {\r\n\r\n    // Token Information\r\n    function balanceOfByPartition(bytes32 partition, address tokenHolder) external view returns (uint256); // 1/10\r\n    function partitionsOf(address tokenHolder) external view returns (bytes32[] memory); // 2/10\r\n\r\n    // Token Transfers\r\n    function transferByPartition(bytes32 partition, address to, uint256 value, bytes calldata data) external returns (bytes32); // 3/10\r\n    function operatorTransferByPartition(bytes32 partition, address from, address to, uint256 value, bytes calldata data, bytes calldata operatorData) external returns (bytes32); // 4/10\r\n\r\n    // Default Partition Management\r\n    function getDefaultPartitions(address tokenHolder) external view returns (bytes32[] memory); // 5/10\r\n    function setDefaultPartitions(bytes32[] calldata partitions) external; // 6/10\r\n\r\n    // Operators\r\n    function controllersByPartition(bytes32 partition) external view returns (address[] memory); // 7/10\r\n    function authorizeOperatorByPartition(bytes32 partition, address operator) external; // 8/10\r\n    function revokeOperatorByPartition(bytes32 partition, address operator) external; // 9/10\r\n    function isOperatorForPartition(bytes32 partition, address operator, address tokenHolder) external view returns (bool); // 10/10\r\n\r\n    // Transfer Events\r\n    event TransferByPartition(\r\n        bytes32 indexed fromPartition,\r\n        address operator,\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256 value,\r\n        bytes data,\r\n        bytes operatorData\r\n    );\r\n\r\n    event ChangedPartition(\r\n        bytes32 indexed fromPartition,\r\n        bytes32 indexed toPartition,\r\n        uint256 value\r\n    );\r\n\r\n    // Operator Events\r\n    event AuthorizedOperatorByPartition(bytes32 indexed partition, address indexed operator, address indexed tokenHolder);\r\n    event RevokedOperatorByPartition(bytes32 indexed partition, address indexed operator, address indexed tokenHolder);\r\n\r\n}\r\n\r\n\r\n/**\r\n * @title IERC777 token standard\r\n * @dev ERC777 interface\r\n */\r\ninterface IERC777 {\r\n\r\n  function name() external view returns (string memory); // 1/13\r\n  function symbol() external view returns (string memory); // 2/13\r\n  function totalSupply() external view returns (uint256); // 3/13\r\n  function balanceOf(address owner) external view returns (uint256); // 4/13\r\n  function granularity() external view returns (uint256); // 5/13\r\n\r\n  function controllers() external view returns (address[] memory); // 6/13\r\n  function authorizeOperator(address operator) external; // 7/13\r\n  function revokeOperator(address operator) external; // 8/13\r\n  function isOperatorFor(address operator, address tokenHolder) external view returns (bool); // 9/13\r\n\r\n  function transferWithData(address to, uint256 value, bytes calldata data) external; // 10/13\r\n  function transferFromWithData(address from, address to, uint256 value, bytes calldata data, bytes calldata operatorData) external; // 11/13\r\n\r\n  function redeem(uint256 value, bytes calldata data) external; // 12/13\r\n  function redeemFrom(address from, uint256 value, bytes calldata data, bytes calldata operatorData) external; // 13/13\r\n\r\n  event TransferWithData(\r\n    address indexed operator,\r\n    address indexed from,\r\n    address indexed to,\r\n    uint256 value,\r\n    bytes data,\r\n    bytes operatorData\r\n  );\r\n  event Issued(address indexed operator, address indexed to, uint256 value, bytes data, bytes operatorData);\r\n  event Redeemed(address indexed operator, address indexed from, uint256 value, bytes data, bytes operatorData);\r\n  event AuthorizedOperator(address indexed operator, address indexed tokenHolder);\r\n  event RevokedOperator(address indexed operator, address indexed tokenHolder);\r\n\r\n}\r\n\r\n\r\n/**\r\n * @title ERC1400 security token standard\r\n * @dev ERC1400 logic\r\n */\r\ninterface IERC1400  {\r\n\r\n    // Document Management\r\n    function getDocument(bytes32 name) external view returns (string memory, bytes32); // 1/9\r\n    function setDocument(bytes32 name, string calldata uri, bytes32 documentHash) external; // 2/9\r\n    event Document(bytes32 indexed name, string uri, bytes32 documentHash);\r\n\r\n    // Controller Operation\r\n    function isControllable() external view returns (bool); // 3/9\r\n\r\n    // Token Issuance\r\n    function isIssuable() external view returns (bool); // 4/9\r\n    function issueByPartition(bytes32 partition, address tokenHolder, uint256 value, bytes calldata data) external; // 5/9\r\n    event IssuedByPartition(bytes32 indexed partition, address indexed operator, address indexed to, uint256 value, bytes data, bytes operatorData);\r\n\r\n    // Token Redemption\r\n    function redeemByPartition(bytes32 partition, uint256 value, bytes calldata data) external; // 6/9\r\n    function operatorRedeemByPartition(bytes32 partition, address tokenHolder, uint256 value, bytes calldata data, bytes calldata operatorData) external; // 7/9\r\n    event RedeemedByPartition(bytes32 indexed partition, address indexed operator, address indexed from, uint256 value, bytes data, bytes operatorData);\r\n\r\n    // Transfer Validity\r\n    function canTransferByPartition(bytes32 partition, address to, uint256 value, bytes calldata data) external view returns (byte, bytes32, bytes32); // 8/9\r\n    function canOperatorTransferByPartition(bytes32 partition, address from, address to, uint256 value, bytes calldata data, bytes calldata operatorData) external view returns (byte, bytes32, bytes32); // 9/9\r\n\r\n}\r\n\r\n/**\r\n * Reason codes - ERC1066\r\n *\r\n * To improve the token holder experience, canTransfer MUST return a reason byte code\r\n * on success or failure based on the EIP-1066 application-specific status codes specified below.\r\n * An implementation can also return arbitrary data as a bytes32 to provide additional\r\n * information not captured by the reason code.\r\n *\r\n * Code Reason\r\n * 0xA0 Transfer Verified - Unrestricted\r\n * 0xA1 Transfer Verified - On-Chain approval for restricted token\r\n * 0xA2 Transfer Verified - Off-Chain approval for restricted token\r\n * 0xA3 Transfer Blocked - Sender lockup period not ended\r\n * 0xA4 Transfer Blocked - Sender balance insufficient\r\n * 0xA5 Transfer Blocked - Sender not eligible\r\n * 0xA6 Transfer Blocked - Receiver not eligible\r\n * 0xA7 Transfer Blocked - Identity restriction\r\n * 0xA8 Transfer Blocked - Token restriction\r\n * 0xA9 Transfer Blocked - Token granularity\r\n */\r\n\r\n\r\ncontract ERC820Registry {\r\n    function setInterfaceImplementer(address _addr, bytes32 _interfaceHash, address _implementer) external;\r\n    function getInterfaceImplementer(address _addr, bytes32 _interfaceHash) external view returns (address);\r\n    function setManager(address _addr, address _newManager) external;\r\n    function getManager(address _addr) public view returns(address);\r\n}\r\n\r\n\r\n/// Base client to interact with the registry.\r\ncontract ERC820Client {\r\n    ERC820Registry constant ERC820REGISTRY = ERC820Registry(0x820b586C8C28125366C998641B09DCbE7d4cBF06);\r\n\r\n    function setInterfaceImplementation(string memory _interfaceLabel, address _implementation) internal {\r\n        bytes32 interfaceHash = keccak256(abi.encodePacked(_interfaceLabel));\r\n        ERC820REGISTRY.setInterfaceImplementer(address(this), interfaceHash, _implementation);\r\n    }\r\n\r\n    function interfaceAddr(address addr, string memory _interfaceLabel) internal view returns(address) {\r\n        bytes32 interfaceHash = keccak256(abi.encodePacked(_interfaceLabel));\r\n        return ERC820REGISTRY.getInterfaceImplementer(addr, interfaceHash);\r\n    }\r\n\r\n    function delegateManagement(address _newManager) internal {\r\n        ERC820REGISTRY.setManager(address(this), _newManager);\r\n    }\r\n}\r\n\r\n/**\r\n * @title ERC777\r\n * @dev ERC777 logic\r\n */\r\ncontract ERC777 is IERC777, Ownable, ERC820Client, CertificateController, ReentrancyGuard {\r\n  using SafeMath for uint256;\r\n\r\n  string internal _name;\r\n  string internal _symbol;\r\n  uint256 internal _granularity;\r\n  uint256 internal _totalSupply;\r\n\r\n  // Indicate whether the token can still be controlled by operators or not anymore.\r\n  bool internal _isControllable;\r\n\r\n  // Mapping from tokenHolder to balance.\r\n  mapping(address => uint256) internal _balances;\r\n\r\n  /******************** Mappings related to operator **************************/\r\n  // Mapping from (operator, tokenHolder) to authorized status. [TOKEN-HOLDER-SPECIFIC]\r\n  mapping(address => mapping(address => bool)) internal _authorizedOperator;\r\n\r\n  // Array of controllers. [GLOBAL - NOT TOKEN-HOLDER-SPECIFIC]\r\n  address[] internal _controllers;\r\n\r\n  // Mapping from operator to controller status. [GLOBAL - NOT TOKEN-HOLDER-SPECIFIC]\r\n  mapping(address => bool) internal _isController;\r\n  /****************************************************************************/\r\n\r\n  /**\r\n   * [ERC777 CONSTRUCTOR]\r\n   * @dev Initialize ERC777 and CertificateController parameters + register\r\n   * the contract implementation in ERC820Registry.\r\n   * @param name Name of the token.\r\n   * @param symbol Symbol of the token.\r\n   * @param granularity Granularity of the token.\r\n   * @param controllers Array of initial controllers.\r\n   * @param certificateSigner Address of the off-chain service which signs the\r\n   * conditional ownership certificates required for token transfers, issuance,\r\n   * redemption (Cf. CertificateController.sol).\r\n   */\r\n  constructor(\r\n    string memory name,\r\n    string memory symbol,\r\n    uint256 granularity,\r\n    address[] memory controllers,\r\n    address certificateSigner\r\n  )\r\n    public\r\n    CertificateController(certificateSigner)\r\n  {\r\n    _name = name;\r\n    _symbol = symbol;\r\n    _totalSupply = 0;\r\n    require(granularity >= 1, \"Constructor Blocked - Token granularity can not be lower than 1\");\r\n    _granularity = granularity;\r\n\r\n    _setControllers(controllers);\r\n\r\n    setInterfaceImplementation(\"ERC777Token\", address(this));\r\n  }\r\n\r\n  /********************** ERC777 EXTERNAL FUNCTIONS ***************************/\r\n\r\n  /**\r\n   * [ERC777 INTERFACE (1/13)]\r\n   * @dev Get the name of the token, e.g., \"MyToken\".\r\n   * @return Name of the token.\r\n   */\r\n  function name() external view returns(string memory) {\r\n    return _name;\r\n  }\r\n\r\n  /**\r\n   * [ERC777 INTERFACE (2/13)]\r\n   * @dev Get the symbol of the token, e.g., \"MYT\".\r\n   * @return Symbol of the token.\r\n   */\r\n  function symbol() external view returns(string memory) {\r\n    return _symbol;\r\n  }\r\n\r\n  /**\r\n   * [ERC777 INTERFACE (3/13)]\r\n   * @dev Get the total number of issued tokens.\r\n   * @return Total supply of tokens currently in circulation.\r\n   */\r\n  function totalSupply() external view returns (uint256) {\r\n    return _totalSupply;\r\n  }\r\n\r\n  /**\r\n   * [ERC777 INTERFACE (4/13)]\r\n   * @dev Get the balance of the account with address 'tokenHolder'.\r\n   * @param tokenHolder Address for which the balance is returned.\r\n   * @return Amount of token held by 'tokenHolder' in the token contract.\r\n   */\r\n  function balanceOf(address tokenHolder) external view returns (uint256) {\r\n    return _balances[tokenHolder];\r\n  }\r\n\r\n  /**\r\n   * [ERC777 INTERFACE (5/13)]\r\n   * @dev Get the smallest part of the token that’s not divisible.\r\n   * @return The smallest non-divisible part of the token.\r\n   */\r\n  function granularity() external view returns(uint256) {\r\n    return _granularity;\r\n  }\r\n\r\n  /**\r\n   * [ERC777 INTERFACE (6/13)]\r\n   * @dev Get the list of controllers as defined by the token contract.\r\n   * @return List of addresses of all the controllers.\r\n   */\r\n  function controllers() external view returns (address[] memory) {\r\n    return _controllers;\r\n  }\r\n\r\n  /**\r\n   * [ERC777 INTERFACE (7/13)]\r\n   * @dev Set a third party operator address as an operator of 'msg.sender' to transfer\r\n   * and redeem tokens on its behalf.\r\n   * @param operator Address to set as an operator for 'msg.sender'.\r\n   */\r\n  function authorizeOperator(address operator) external {\r\n    _authorizedOperator[operator][msg.sender] = true;\r\n    emit AuthorizedOperator(operator, msg.sender);\r\n  }\r\n\r\n  /**\r\n   * [ERC777 INTERFACE (8/13)]\r\n   * @dev Remove the right of the operator address to be an operator for 'msg.sender'\r\n   * and to transfer and redeem tokens on its behalf.\r\n   * @param operator Address to rescind as an operator for 'msg.sender'.\r\n   */\r\n  function revokeOperator(address operator) external {\r\n    _authorizedOperator[operator][msg.sender] = false;\r\n    emit RevokedOperator(operator, msg.sender);\r\n  }\r\n\r\n  /**\r\n   * [ERC777 INTERFACE (9/13)]\r\n   * @dev Indicate whether the operator address is an operator of the tokenHolder address.\r\n   * @param operator Address which may be an operator of tokenHolder.\r\n   * @param tokenHolder Address of a token holder which may have the operator address as an operator.\r\n   * @return 'true' if operator is an operator of 'tokenHolder' and 'false' otherwise.\r\n   */\r\n  function isOperatorFor(address operator, address tokenHolder) external view returns (bool) {\r\n    return _isOperatorFor(operator, tokenHolder);\r\n  }\r\n\r\n  /**\r\n   * [ERC777 INTERFACE (10/13)]\r\n   * @dev Transfer the amount of tokens from the address 'msg.sender' to the address 'to'.\r\n   * @param to Token recipient.\r\n   * @param value Number of tokens to transfer.\r\n   * @param data Information attached to the transfer, by the token holder. [CONTAINS THE CONDITIONAL OWNERSHIP CERTIFICATE]\r\n   */\r\n  function transferWithData(address to, uint256 value, bytes calldata data)\r\n    external\r\n    isValidCertificate(data)\r\n  {\r\n    _transferWithData(\"\", msg.sender, msg.sender, to, value, data, \"\", true);\r\n  }\r\n\r\n  /**\r\n   * [ERC777 INTERFACE (11/13)]\r\n   * @dev Transfer the amount of tokens on behalf of the address 'from' to the address 'to'.\r\n   * @param from Token holder (or 'address(0)' to set from to 'msg.sender').\r\n   * @param to Token recipient.\r\n   * @param value Number of tokens to transfer.\r\n   * @param data Information attached to the transfer, and intended for the token holder ('from').\r\n   * @param operatorData Information attached to the transfer by the operator. [CONTAINS THE CONDITIONAL OWNERSHIP CERTIFICATE]\r\n   */\r\n  function transferFromWithData(address from, address to, uint256 value, bytes calldata data, bytes calldata operatorData)\r\n    external\r\n    isValidCertificate(operatorData)\r\n  {\r\n    address _from = (from == address(0)) ? msg.sender : from;\r\n\r\n    require(_isOperatorFor(msg.sender, _from), \"A7: Transfer Blocked - Identity restriction\");\r\n\r\n    _transferWithData(\"\", msg.sender, _from, to, value, data, operatorData, true);\r\n  }\r\n\r\n  /**\r\n   * [ERC777 INTERFACE (12/13)]\r\n   * @dev Redeem the amount of tokens from the address 'msg.sender'.\r\n   * @param value Number of tokens to redeem.\r\n   * @param data Information attached to the redemption, by the token holder. [CONTAINS THE CONDITIONAL OWNERSHIP CERTIFICATE]\r\n   */\r\n  function redeem(uint256 value, bytes calldata data)\r\n    external\r\n    isValidCertificate(data)\r\n  {\r\n    _redeem(\"\", msg.sender, msg.sender, value, data, \"\");\r\n  }\r\n\r\n  /**\r\n   * [ERC777 INTERFACE (13/13)]\r\n   * @dev Redeem the amount of tokens on behalf of the address from.\r\n   * @param from Token holder whose tokens will be redeemed (or address(0) to set from to msg.sender).\r\n   * @param value Number of tokens to redeem.\r\n   * @param data Information attached to the redemption.\r\n   * @param operatorData Information attached to the redemption, by the operator. [CONTAINS THE CONDITIONAL OWNERSHIP CERTIFICATE]\r\n   */\r\n  function redeemFrom(address from, uint256 value, bytes calldata data, bytes calldata operatorData)\r\n    external\r\n    isValidCertificate(operatorData)\r\n  {\r\n    address _from = (from == address(0)) ? msg.sender : from;\r\n\r\n    require(_isOperatorFor(msg.sender, _from), \"A7: Transfer Blocked - Identity restriction\");\r\n\r\n    _redeem(\"\", msg.sender, _from, value, data, operatorData);\r\n  }\r\n\r\n  /********************** ERC777 INTERNAL FUNCTIONS ***************************/\r\n\r\n  /**\r\n   * [INTERNAL]\r\n   * @dev Check if 'value' is multiple of the granularity.\r\n   * @param value The quantity that want's to be checked.\r\n   * @return 'true' if 'value' is a multiple of the granularity.\r\n   */\r\n  function _isMultiple(uint256 value) internal view returns(bool) {\r\n    return(value.div(_granularity).mul(_granularity) == value);\r\n  }\r\n\r\n  /**\r\n   * [INTERNAL]\r\n   * @dev Check whether an address is a regular address or not.\r\n   * @param addr Address of the contract that has to be checked.\r\n   * @return 'true' if 'addr' is a regular address (not a contract).\r\n   */\r\n  function _isRegularAddress(address addr) internal view returns(bool) {\r\n    if (addr == address(0)) { return false; }\r\n    uint size;\r\n    assembly { size := extcodesize(addr) } // solhint-disable-line no-inline-assembly\r\n    return size == 0;\r\n  }\r\n\r\n  /**\r\n   * [INTERNAL]\r\n   * @dev Indicate whether the operator address is an operator of the tokenHolder address.\r\n   * @param operator Address which may be an operator of 'tokenHolder'.\r\n   * @param tokenHolder Address of a token holder which may have the 'operator' address as an operator.\r\n   * @return 'true' if 'operator' is an operator of 'tokenHolder' and 'false' otherwise.\r\n   */\r\n  function _isOperatorFor(address operator, address tokenHolder) internal view returns (bool) {\r\n    return (operator == tokenHolder\r\n      || _authorizedOperator[operator][tokenHolder]\r\n      || (_isControllable && _isController[operator])\r\n    );\r\n  }\r\n\r\n   /**\r\n    * [INTERNAL]\r\n    * @dev Perform the transfer of tokens.\r\n    * @param partition Name of the partition (bytes32 to be left empty for ERC777 transfer).\r\n    * @param operator The address performing the transfer.\r\n    * @param from Token holder.\r\n    * @param to Token recipient.\r\n    * @param value Number of tokens to transfer.\r\n    * @param data Information attached to the transfer.\r\n    * @param operatorData Information attached to the transfer by the operator (if any)..\r\n    * @param preventLocking 'true' if you want this function to throw when tokens are sent to a contract not\r\n    * implementing 'erc777tokenHolder'.\r\n    * ERC777 native transfer functions MUST set this parameter to 'true', and backwards compatible ERC20 transfer\r\n    * functions SHOULD set this parameter to 'false'.\r\n    */\r\n  function _transferWithData(\r\n    bytes32 partition,\r\n    address operator,\r\n    address from,\r\n    address to,\r\n    uint256 value,\r\n    bytes memory data,\r\n    bytes memory operatorData,\r\n    bool preventLocking\r\n  )\r\n    internal\r\n    nonReentrant\r\n  {\r\n    require(_isMultiple(value), \"A9: Transfer Blocked - Token granularity\");\r\n    require(to != address(0), \"A6: Transfer Blocked - Receiver not eligible\");\r\n    require(_balances[from] >= value, \"A4: Transfer Blocked - Sender balance insufficient\");\r\n\r\n    _callSender(partition, operator, from, to, value, data, operatorData);\r\n\r\n    _balances[from] = _balances[from].sub(value);\r\n    _balances[to] = _balances[to].add(value);\r\n\r\n    _callRecipient(partition, operator, from, to, value, data, operatorData, preventLocking);\r\n\r\n    emit TransferWithData(operator, from, to, value, data, operatorData);\r\n  }\r\n\r\n  /**\r\n   * [INTERNAL]\r\n   * @dev Perform the token redemption.\r\n   * @param partition Name of the partition (bytes32 to be left empty for ERC777 transfer).\r\n   * @param operator The address performing the redemption.\r\n   * @param from Token holder whose tokens will be redeemed.\r\n   * @param value Number of tokens to redeem.\r\n   * @param data Information attached to the redemption.\r\n   * @param operatorData Information attached to the redemption, by the operator (if any).\r\n   */\r\n  function _redeem(bytes32 partition, address operator, address from, uint256 value, bytes memory data, bytes memory operatorData)\r\n    internal\r\n    nonReentrant\r\n  {\r\n    require(_isMultiple(value), \"A9: Transfer Blocked - Token granularity\");\r\n    require(from != address(0), \"A5: Transfer Blocked - Sender not eligible\");\r\n    require(_balances[from] >= value, \"A4: Transfer Blocked - Sender balance insufficient\");\r\n\r\n    _callSender(partition, operator, from, address(0), value, data, operatorData);\r\n\r\n    _balances[from] = _balances[from].sub(value);\r\n    _totalSupply = _totalSupply.sub(value);\r\n\r\n    emit Redeemed(operator, from, value, data, operatorData);\r\n  }\r\n\r\n  /**\r\n   * [INTERNAL]\r\n   * @dev Check for 'ERC777TokensSender' hook on the sender and call it.\r\n   * May throw according to 'preventLocking'.\r\n   * @param partition Name of the partition (bytes32 to be left empty for ERC777 transfer).\r\n   * @param operator Address which triggered the balance decrease (through transfer or redemption).\r\n   * @param from Token holder.\r\n   * @param to Token recipient for a transfer and 0x for a redemption.\r\n   * @param value Number of tokens the token holder balance is decreased by.\r\n   * @param data Extra information.\r\n   * @param operatorData Extra information, attached by the operator (if any).\r\n   */\r\n  function _callSender(\r\n    bytes32 partition,\r\n    address operator,\r\n    address from,\r\n    address to,\r\n    uint256 value,\r\n    bytes memory data,\r\n    bytes memory operatorData\r\n  )\r\n    internal\r\n  {\r\n    address senderImplementation;\r\n    senderImplementation = interfaceAddr(from, \"ERC777TokensSender\");\r\n\r\n    if (senderImplementation != address(0)) {\r\n      IERC777TokensSender(senderImplementation).tokensToTransfer(partition, operator, from, to, value, data, operatorData);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * [INTERNAL]\r\n   * @dev Check for 'ERC777TokensRecipient' hook on the recipient and call it.\r\n   * May throw according to 'preventLocking'.\r\n   * @param partition Name of the partition (bytes32 to be left empty for ERC777 transfer).\r\n   * @param operator Address which triggered the balance increase (through transfer or issuance).\r\n   * @param from Token holder for a transfer and 0x for an issuance.\r\n   * @param to Token recipient.\r\n   * @param value Number of tokens the recipient balance is increased by.\r\n   * @param data Extra information, intended for the token holder ('from').\r\n   * @param operatorData Extra information attached by the operator (if any).\r\n   * @param preventLocking 'true' if you want this function to throw when tokens are sent to a contract not\r\n   * implementing 'ERC777TokensRecipient'.\r\n   * ERC777 native transfer functions MUST set this parameter to 'true', and backwards compatible ERC20 transfer\r\n   * functions SHOULD set this parameter to 'false'.\r\n   */\r\n  function _callRecipient(\r\n    bytes32 partition,\r\n    address operator,\r\n    address from,\r\n    address to,\r\n    uint256 value,\r\n    bytes memory data,\r\n    bytes memory operatorData,\r\n    bool preventLocking\r\n  )\r\n    internal\r\n  {\r\n    address recipientImplementation;\r\n    recipientImplementation = interfaceAddr(to, \"ERC777TokensRecipient\");\r\n\r\n    if (recipientImplementation != address(0)) {\r\n      IERC777TokensRecipient(recipientImplementation).tokensReceived(partition, operator, from, to, value, data, operatorData);\r\n    } else if (preventLocking) {\r\n      require(_isRegularAddress(to), \"A6: Transfer Blocked - Receiver not eligible\");\r\n    }\r\n  }\r\n\r\n  /**\r\n   * [INTERNAL]\r\n   * @dev Perform the issuance of tokens.\r\n   * @param partition Name of the partition (bytes32 to be left empty for ERC777 transfer).\r\n   * @param operator Address which triggered the issuance.\r\n   * @param to Token recipient.\r\n   * @param value Number of tokens issued.\r\n   * @param data Information attached to the issuance, and intended for the recipient (to).\r\n   * @param operatorData Information attached to the issuance by the operator (if any).\r\n   */\r\n  function _issue(bytes32 partition, address operator, address to, uint256 value, bytes memory data, bytes memory operatorData) internal nonReentrant {\r\n    require(_isMultiple(value), \"A9: Transfer Blocked - Token granularity\");\r\n    require(to != address(0), \"A6: Transfer Blocked - Receiver not eligible\");\r\n\r\n    _totalSupply = _totalSupply.add(value);\r\n    _balances[to] = _balances[to].add(value);\r\n\r\n    _callRecipient(partition, operator, address(0), to, value, data, operatorData, true);\r\n\r\n    emit Issued(operator, to, value, data, operatorData);\r\n  }\r\n\r\n  /********************** ERC777 OPTIONAL FUNCTIONS ***************************/\r\n\r\n  /**\r\n   * [NOT MANDATORY FOR ERC777 STANDARD]\r\n   * @dev Set list of token controllers.\r\n   * @param operators Controller addresses.\r\n   */\r\n  function _setControllers(address[] memory operators) internal {\r\n    for (uint i = 0; i<_controllers.length; i++){\r\n      _isController[_controllers[i]] = false;\r\n    }\r\n    for (uint j = 0; j<operators.length; j++){\r\n      _isController[operators[j]] = true;\r\n    }\r\n    _controllers = operators;\r\n  }\r\n\r\n}\r\n\r\n/**\r\n * @title ERC1410\r\n * @dev ERC1410 logic\r\n */\r\ncontract ERC1410 is IERC1410, ERC777{\r\n\r\n  /******************** Mappings to find partition ******************************/\r\n  // List of partitions.\r\n  bytes32[] internal _totalPartitions;\r\n\r\n  // Mapping from partition to global balance of corresponding partition.\r\n  mapping (bytes32 => uint256) internal _totalSupplyByPartition;\r\n\r\n  // Mapping from tokenHolder to their partitions.\r\n  mapping (address => bytes32[]) internal _partitionsOf;\r\n\r\n  // Mapping from (tokenHolder, partition) to balance of corresponding partition.\r\n  mapping (address => mapping (bytes32 => uint256)) internal _balanceOfByPartition;\r\n\r\n  // Mapping from tokenHolder to their default partitions (for ERC777 and ERC20 compatibility).\r\n  mapping (address => bytes32[]) internal _defaultPartitionsOf;\r\n\r\n  // List of token default partitions (for ERC20 compatibility).\r\n  bytes32[] internal _tokenDefaultPartitions;\r\n  /****************************************************************************/\r\n\r\n  /**************** Mappings to find partition operators ************************/\r\n  // Mapping from (tokenHolder, partition, operator) to 'approved for partition' status. [TOKEN-HOLDER-SPECIFIC]\r\n  mapping (address => mapping (bytes32 => mapping (address => bool))) internal _authorizedOperatorByPartition;\r\n\r\n  // Mapping from partition to controllers for the partition. [NOT TOKEN-HOLDER-SPECIFIC]\r\n  mapping (bytes32 => address[]) internal _controllersByPartition;\r\n\r\n  // Mapping from (partition, operator) to PartitionController status. [NOT TOKEN-HOLDER-SPECIFIC]\r\n  mapping (bytes32 => mapping (address => bool)) internal _isControllerByPartition;\r\n  /****************************************************************************/\r\n\r\n  /**\r\n   * [ERC1410 CONSTRUCTOR]\r\n   * @dev Initialize ERC1410 parameters + register\r\n   * the contract implementation in ERC820Registry.\r\n   * @param name Name of the token.\r\n   * @param symbol Symbol of the token.\r\n   * @param granularity Granularity of the token.\r\n   * @param controllers Array of initial controllers.\r\n   * @param certificateSigner Address of the off-chain service which signs the\r\n   * conditional ownership certificates required for token transfers, issuance,\r\n   * redemption (Cf. CertificateController.sol).\r\n   */\r\n  constructor(\r\n    string memory name,\r\n    string memory symbol,\r\n    uint256 granularity,\r\n    address[] memory controllers,\r\n    address certificateSigner,\r\n    bytes32[] memory tokenDefaultPartitions\r\n  )\r\n    public\r\n    ERC777(name, symbol, granularity, controllers, certificateSigner)\r\n  {\r\n    _tokenDefaultPartitions = tokenDefaultPartitions;\r\n  }\r\n\r\n  /********************** ERC1410 EXTERNAL FUNCTIONS **************************/\r\n\r\n  /**\r\n   * [ERC1410 INTERFACE (1/10)]\r\n   * @dev Get balance of a tokenholder for a specific partition.\r\n   * @param partition Name of the partition.\r\n   * @param tokenHolder Address for which the balance is returned.\r\n   * @return Amount of token of partition 'partition' held by 'tokenHolder' in the token contract.\r\n   */\r\n  function balanceOfByPartition(bytes32 partition, address tokenHolder) external view returns (uint256) {\r\n    return _balanceOfByPartition[tokenHolder][partition];\r\n  }\r\n\r\n  /**\r\n   * [ERC1410 INTERFACE (2/10)]\r\n   * @dev Get partitions index of a tokenholder.\r\n   * @param tokenHolder Address for which the partitions index are returned.\r\n   * @return Array of partitions index of 'tokenHolder'.\r\n   */\r\n  function partitionsOf(address tokenHolder) external view returns (bytes32[] memory) {\r\n    return _partitionsOf[tokenHolder];\r\n  }\r\n\r\n  /**\r\n   * [ERC1410 INTERFACE (3/10)]\r\n   * @dev Transfer tokens from a specific partition.\r\n   * @param partition Name of the partition.\r\n   * @param to Token recipient.\r\n   * @param value Number of tokens to transfer.\r\n   * @param data Information attached to the transfer, by the token holder. [CONTAINS THE CONDITIONAL OWNERSHIP CERTIFICATE]\r\n   * @return Destination partition.\r\n   */\r\n  function transferByPartition(\r\n    bytes32 partition,\r\n    address to,\r\n    uint256 value,\r\n    bytes calldata data\r\n  )\r\n    external\r\n    isValidCertificate(data)\r\n    returns (bytes32)\r\n  {\r\n    return _transferByPartition(partition, msg.sender, msg.sender, to, value, data, \"\");\r\n  }\r\n\r\n  /**\r\n   * [ERC1410 INTERFACE (4/10)]\r\n   * @dev Transfer tokens from a specific partition through an operator.\r\n   * @param partition Name of the partition.\r\n   * @param from Token holder.\r\n   * @param to Token recipient.\r\n   * @param value Number of tokens to transfer.\r\n   * @param data Information attached to the transfer. [CAN CONTAIN THE DESTINATION PARTITION]\r\n   * @param operatorData Information attached to the transfer, by the operator. [CONTAINS THE CONDITIONAL OWNERSHIP CERTIFICATE]\r\n   * @return Destination partition.\r\n   */\r\n  function operatorTransferByPartition(\r\n    bytes32 partition,\r\n    address from,\r\n    address to,\r\n    uint256 value,\r\n    bytes calldata data,\r\n    bytes calldata operatorData\r\n  )\r\n    external\r\n    isValidCertificate(operatorData)\r\n    returns (bytes32)\r\n  {\r\n    address _from = (from == address(0)) ? msg.sender : from;\r\n    require(_isOperatorForPartition(partition, msg.sender, _from), \"A7: Transfer Blocked - Identity restriction\");\r\n\r\n    return _transferByPartition(partition, msg.sender, _from, to, value, data, operatorData);\r\n  }\r\n\r\n  /**\r\n   * [ERC1410 INTERFACE (5/10)]\r\n   * @dev Get default partitions to transfer from.\r\n   * Function used for ERC777 and ERC20 backwards compatibility.\r\n   * For example, a security token may return the bytes32(\"unrestricted\").\r\n   * @param tokenHolder Address for which we want to know the default partitions.\r\n   * @return Array of default partitions.\r\n   */\r\n  function getDefaultPartitions(address tokenHolder) external view returns (bytes32[] memory) {\r\n    return _defaultPartitionsOf[tokenHolder];\r\n  }\r\n\r\n  /**\r\n   * [ERC1410 INTERFACE (6/10)]\r\n   * @dev Set default partitions to transfer from.\r\n   * Function used for ERC777 and ERC20 backwards compatibility.\r\n   * @param partitions partitions to use by default when not specified.\r\n   */\r\n  function setDefaultPartitions(bytes32[] calldata partitions) external {\r\n    _defaultPartitionsOf[msg.sender] = partitions;\r\n  }\r\n\r\n  /**\r\n   * [ERC1410 INTERFACE (7/10)]\r\n   * @dev Get controllers for a given partition.\r\n   * Function used for ERC777 and ERC20 backwards compatibility.\r\n   * @param partition Name of the partition.\r\n   * @return Array of controllers for partition.\r\n   */\r\n  function controllersByPartition(bytes32 partition) external view returns (address[] memory) {\r\n    return _controllersByPartition[partition];\r\n  }\r\n\r\n  /**\r\n   * [ERC1410 INTERFACE (8/10)]\r\n   * @dev Set 'operator' as an operator for 'msg.sender' for a given partition.\r\n   * @param partition Name of the partition.\r\n   * @param operator Address to set as an operator for 'msg.sender'.\r\n   */\r\n  function authorizeOperatorByPartition(bytes32 partition, address operator) external {\r\n    _authorizedOperatorByPartition[msg.sender][partition][operator] = true;\r\n    emit AuthorizedOperatorByPartition(partition, operator, msg.sender);\r\n  }\r\n\r\n  /**\r\n   * [ERC1410 INTERFACE (9/10)]\r\n   * @dev Remove the right of the operator address to be an operator on a given\r\n   * partition for 'msg.sender' and to transfer and redeem tokens on its behalf.\r\n   * @param partition Name of the partition.\r\n   * @param operator Address to rescind as an operator on given partition for 'msg.sender'.\r\n   */\r\n  function revokeOperatorByPartition(bytes32 partition, address operator) external {\r\n    _authorizedOperatorByPartition[msg.sender][partition][operator] = false;\r\n    emit RevokedOperatorByPartition(partition, operator, msg.sender);\r\n  }\r\n\r\n  /**\r\n   * [ERC1410 INTERFACE (10/10)]\r\n   * @dev Indicate whether the operator address is an operator of the tokenHolder\r\n   * address for the given partition.\r\n   * @param partition Name of the partition.\r\n   * @param operator Address which may be an operator of tokenHolder for the given partition.\r\n   * @param tokenHolder Address of a token holder which may have the operator address as an operator for the given partition.\r\n   * @return 'true' if 'operator' is an operator of 'tokenHolder' for partition 'partition' and 'false' otherwise.\r\n   */\r\n  function isOperatorForPartition(bytes32 partition, address operator, address tokenHolder) external view returns (bool) {\r\n    return _isOperatorForPartition(partition, operator, tokenHolder);\r\n  }\r\n\r\n  /********************** ERC1410 INTERNAL FUNCTIONS **************************/\r\n\r\n  /**\r\n   * [INTERNAL]\r\n   * @dev Indicate whether the operator address is an operator of the tokenHolder\r\n   * address for the given partition.\r\n   * @param partition Name of the partition.\r\n   * @param operator Address which may be an operator of tokenHolder for the given partition.\r\n   * @param tokenHolder Address of a token holder which may have the operator address as an operator for the given partition.\r\n   * @return 'true' if 'operator' is an operator of 'tokenHolder' for partition 'partition' and 'false' otherwise.\r\n   */\r\n   function _isOperatorForPartition(bytes32 partition, address operator, address tokenHolder) internal view returns (bool) {\r\n     return (_isOperatorFor(operator, tokenHolder)\r\n       || _authorizedOperatorByPartition[tokenHolder][partition][operator]\r\n       || (_isControllable && _isControllerByPartition[partition][operator])\r\n     );\r\n   }\r\n\r\n  /**\r\n   * [INTERNAL]\r\n   * @dev Transfer tokens from a specific partition.\r\n   * @param fromPartition Partition of the tokens to transfer.\r\n   * @param operator The address performing the transfer.\r\n   * @param from Token holder.\r\n   * @param to Token recipient.\r\n   * @param value Number of tokens to transfer.\r\n   * @param data Information attached to the transfer. [CAN CONTAIN THE DESTINATION PARTITION]\r\n   * @param operatorData Information attached to the transfer, by the operator (if any).\r\n   * @return Destination partition.\r\n   */\r\n  function _transferByPartition(\r\n    bytes32 fromPartition,\r\n    address operator,\r\n    address from,\r\n    address to,\r\n    uint256 value,\r\n    bytes memory data,\r\n    bytes memory operatorData\r\n  )\r\n    internal\r\n    returns (bytes32)\r\n  {\r\n    require(_balanceOfByPartition[from][fromPartition] >= value, \"A4: Transfer Blocked - Sender balance insufficient\"); // ensure enough funds\r\n\r\n    bytes32 toPartition = fromPartition;\r\n\r\n    if(operatorData.length != 0 && data.length != 0) {\r\n      toPartition = _getDestinationPartition(fromPartition, data);\r\n    }\r\n\r\n    _removeTokenFromPartition(from, fromPartition, value);\r\n    _transferWithData(fromPartition, operator, from, to, value, data, operatorData, true);\r\n    _addTokenToPartition(to, toPartition, value);\r\n\r\n    emit TransferByPartition(fromPartition, operator, from, to, value, data, operatorData);\r\n\r\n    if(toPartition != fromPartition) {\r\n      emit ChangedPartition(fromPartition, toPartition, value);\r\n    }\r\n\r\n    return toPartition;\r\n  }\r\n\r\n  /**\r\n   * [INTERNAL]\r\n   * @dev Remove a token from a specific partition.\r\n   * @param from Token holder.\r\n   * @param partition Name of the partition.\r\n   * @param value Number of tokens to transfer.\r\n   */\r\n  function _removeTokenFromPartition(address from, bytes32 partition, uint256 value) internal {\r\n    _balanceOfByPartition[from][partition] = _balanceOfByPartition[from][partition].sub(value);\r\n    _totalSupplyByPartition[partition] = _totalSupplyByPartition[partition].sub(value);\r\n\r\n    // If the balance of the TokenHolder's partition is zero, finds and deletes the partition.\r\n    if(_balanceOfByPartition[from][partition] == 0) {\r\n      for (uint i = 0; i < _partitionsOf[from].length; i++) {\r\n        if(_partitionsOf[from][i] == partition) {\r\n          _partitionsOf[from][i] = _partitionsOf[from][_partitionsOf[from].length - 1];\r\n          delete _partitionsOf[from][_partitionsOf[from].length - 1];\r\n          _partitionsOf[from].length--;\r\n          break;\r\n        }\r\n      }\r\n    }\r\n\r\n    // If the total supply is zero, finds and deletes the partition.\r\n    if(_totalSupplyByPartition[partition] == 0) {\r\n      for (uint i = 0; i < _totalPartitions.length; i++) {\r\n        if(_totalPartitions[i] == partition) {\r\n          _totalPartitions[i] = _totalPartitions[_totalPartitions.length - 1];\r\n          delete _totalPartitions[_totalPartitions.length - 1];\r\n          _totalPartitions.length--;\r\n          break;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * [INTERNAL]\r\n   * @dev Add a token to a specific partition.\r\n   * @param to Token recipient.\r\n   * @param partition Name of the partition.\r\n   * @param value Number of tokens to transfer.\r\n   */\r\n  function _addTokenToPartition(address to, bytes32 partition, uint256 value) internal {\r\n    if(value != 0) {\r\n      if(_balanceOfByPartition[to][partition] == 0) {\r\n        _partitionsOf[to].push(partition);\r\n      }\r\n      _balanceOfByPartition[to][partition] = _balanceOfByPartition[to][partition].add(value);\r\n\r\n      if(_totalSupplyByPartition[partition] == 0) {\r\n        _totalPartitions.push(partition);\r\n      }\r\n      _totalSupplyByPartition[partition] = _totalSupplyByPartition[partition].add(value);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * [INTERNAL]\r\n   * @dev Retrieve the destination partition from the 'data' field.\r\n   * By convention, a partition change is requested ONLY when 'data' starts\r\n   * with the flag: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\r\n   * When the flag is detected, the destination tranche is extracted from the\r\n   * 32 bytes following the flag.\r\n   * @param fromPartition Partition of the tokens to transfer.\r\n   * @param data Information attached to the transfer. [CAN CONTAIN THE DESTINATION PARTITION]\r\n   * @return Destination partition.\r\n   */\r\n  function _getDestinationPartition(bytes32 fromPartition, bytes memory data) internal pure returns(bytes32 toPartition) {\r\n    bytes32 changePartitionFlag = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\r\n    bytes32 flag;\r\n    assembly {\r\n      flag := mload(add(data, 32))\r\n    }\r\n    if(flag == changePartitionFlag) {\r\n      assembly {\r\n        toPartition := mload(add(data, 64))\r\n      }\r\n    } else {\r\n      toPartition = fromPartition;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * [INTERNAL]\r\n   * @dev Get the sender's default partition if setup, or the global default partition if not.\r\n   * @param tokenHolder Address for which the default partition is returned.\r\n   * @return Default partition.\r\n   */\r\n  function _getDefaultPartitions(address tokenHolder) internal view returns(bytes32[] memory) {\r\n    if(_defaultPartitionsOf[tokenHolder].length != 0) {\r\n      return _defaultPartitionsOf[tokenHolder];\r\n    } else {\r\n      return _tokenDefaultPartitions;\r\n    }\r\n  }\r\n\r\n\r\n  /********************* ERC1410 OPTIONAL FUNCTIONS ***************************/\r\n\r\n  /**\r\n   * [NOT MANDATORY FOR ERC1410 STANDARD]\r\n   * @dev Get list of existing partitions.\r\n   * @return Array of all exisiting partitions.\r\n   */\r\n  function totalPartitions() external view returns (bytes32[] memory) {\r\n    return _totalPartitions;\r\n  }\r\n\r\n  /**\r\n   * [NOT MANDATORY FOR ERC1410 STANDARD][SHALL BE CALLED ONLY FROM ERC1400]\r\n   * @dev Set list of token partition controllers.\r\n   * @param partition Name of the partition.\r\n   * @param operators Controller addresses.\r\n   */\r\n   function _setPartitionControllers(bytes32 partition, address[] memory operators) internal {\r\n     for (uint i = 0; i<_controllersByPartition[partition].length; i++){\r\n       _isControllerByPartition[partition][_controllersByPartition[partition][i]] = false;\r\n     }\r\n     for (uint j = 0; j<operators.length; j++){\r\n       _isControllerByPartition[partition][operators[j]] = true;\r\n     }\r\n     _controllersByPartition[partition] = operators;\r\n   }\r\n\r\n  /************** ERC777 BACKWARDS RETROCOMPATIBILITY *************************/\r\n\r\n  /**\r\n   * [NOT MANDATORY FOR ERC1410 STANDARD][OVERRIDES ERC777 METHOD]\r\n   * @dev Transfer the value of tokens from the address 'msg.sender' to the address 'to'.\r\n   * @param to Token recipient.\r\n   * @param value Number of tokens to transfer.\r\n   * @param data Information attached to the transfer, by the token holder. [CONTAINS THE CONDITIONAL OWNERSHIP CERTIFICATE]\r\n   */\r\n  function transferWithData(address to, uint256 value, bytes calldata data)\r\n    external\r\n    isValidCertificate(data)\r\n  {\r\n    _transferByDefaultPartitions(msg.sender, msg.sender, to, value, data, \"\");\r\n  }\r\n\r\n  /**\r\n   * [NOT MANDATORY FOR ERC1410 STANDARD][OVERRIDES ERC777 METHOD]\r\n   * @dev Transfer the value of tokens on behalf of the address from to the address to.\r\n   * @param from Token holder (or 'address(0)'' to set from to 'msg.sender').\r\n   * @param to Token recipient.\r\n   * @param value Number of tokens to transfer.\r\n   * @param data Information attached to the transfer, and intended for the token holder ('from'). [CAN CONTAIN THE DESTINATION PARTITION]\r\n   * @param operatorData Information attached to the transfer by the operator. [CONTAINS THE CONDITIONAL OWNERSHIP CERTIFICATE]\r\n   */\r\n  function transferFromWithData(address from, address to, uint256 value, bytes calldata data, bytes calldata operatorData)\r\n    external\r\n    isValidCertificate(operatorData)\r\n  {\r\n    address _from = (from == address(0)) ? msg.sender : from;\r\n\r\n    require(_isOperatorFor(msg.sender, _from), \"A7: Transfer Blocked - Identity restriction\");\r\n\r\n    _transferByDefaultPartitions(msg.sender, _from, to, value, data, operatorData);\r\n  }\r\n\r\n  /**\r\n   * [NOT MANDATORY FOR ERC1410 STANDARD][OVERRIDES ERC777 METHOD]\r\n   * @dev Empty function to erase ERC777 redeem() function since it doesn't handle partitions.\r\n   */\r\n  function redeem(uint256 /*value*/, bytes calldata /*data*/) external { // Comments to avoid compilation warnings for unused variables.\r\n  }\r\n\r\n  /**\r\n   * [NOT MANDATORY FOR ERC1410 STANDARD][OVERRIDES ERC777 METHOD]\r\n   * @dev Empty function to erase ERC777 redeemFrom() function since it doesn't handle partitions.\r\n   */\r\n  function redeemFrom(address /*from*/, uint256 /*value*/, bytes calldata /*data*/, bytes calldata /*operatorData*/) external { // Comments to avoid compilation warnings for unused variables.\r\n  }\r\n\r\n  /**\r\n   * [NOT MANDATORY FOR ERC1410 STANDARD]\r\n   * @dev Transfer tokens from default partitions.\r\n   * @param operator The address performing the transfer.\r\n   * @param from Token holder.\r\n   * @param to Token recipient.\r\n   * @param value Number of tokens to transfer.\r\n   * @param data Information attached to the transfer, and intended for the token holder ('from') [CAN CONTAIN THE DESTINATION PARTITION].\r\n   * @param operatorData Information attached to the transfer by the operator (if any).\r\n   */\r\n  function _transferByDefaultPartitions(\r\n    address operator,\r\n    address from,\r\n    address to,\r\n    uint256 value,\r\n    bytes memory data,\r\n    bytes memory operatorData\r\n  )\r\n    internal\r\n  {\r\n    bytes32[] memory _partitions = _getDefaultPartitions(from);\r\n    require(_partitions.length != 0, \"A8: Transfer Blocked - Token restriction\");\r\n\r\n    uint256 _remainingValue = value;\r\n    uint256 _localBalance;\r\n\r\n    for (uint i = 0; i < _partitions.length; i++) {\r\n      _localBalance = _balanceOfByPartition[from][_partitions[i]];\r\n      if(_remainingValue <= _localBalance) {\r\n        _transferByPartition(_partitions[i], operator, from, to, _remainingValue, data, operatorData);\r\n        _remainingValue = 0;\r\n        break;\r\n      } else {\r\n        _transferByPartition(_partitions[i], operator, from, to, _localBalance, data, operatorData);\r\n        _remainingValue = _remainingValue - _localBalance;\r\n      }\r\n    }\r\n\r\n    require(_remainingValue == 0, \"A8: Transfer Blocked - Token restriction\");\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * @title ERC1400\r\n * @dev ERC1400 logic\r\n */\r\ncontract ERC1400 is IERC1400, ERC1410, MinterRole {\r\n\r\n  struct Doc {\r\n    string docURI;\r\n    bytes32 docHash;\r\n  }\r\n\r\n  // Mapping for token URIs.\r\n  mapping(bytes32 => Doc) internal _documents;\r\n\r\n  // Indicate whether the token can still be issued by the issuer or not anymore.\r\n  bool internal _isIssuable;\r\n\r\n  /**\r\n   * @dev Modifier to verify if token is issuable.\r\n   */\r\n  modifier issuableToken() {\r\n    require(_isIssuable, \"A8, Transfer Blocked - Token restriction\");\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * [ERC1400 CONSTRUCTOR]\r\n   * @dev Initialize ERC1400 + register\r\n   * the contract implementation in ERC820Registry.\r\n   * @param name Name of the token.\r\n   * @param symbol Symbol of the token.\r\n   * @param granularity Granularity of the token.\r\n   * @param controllers Array of initial controllers.\r\n   * @param certificateSigner Address of the off-chain service which signs the\r\n   * conditional ownership certificates required for token transfers, issuance,\r\n   * redemption (Cf. CertificateController.sol).\r\n   */\r\n  constructor(\r\n    string memory name,\r\n    string memory symbol,\r\n    uint256 granularity,\r\n    address[] memory controllers,\r\n    address certificateSigner,\r\n    bytes32[] memory tokenDefaultPartitions\r\n  )\r\n    public\r\n    ERC1410(name, symbol, granularity, controllers, certificateSigner, tokenDefaultPartitions)\r\n  {\r\n    setInterfaceImplementation(\"ERC1400Token\", address(this));\r\n    _isControllable = true;\r\n    _isIssuable = true;\r\n  }\r\n\r\n  /********************** ERC1400 EXTERNAL FUNCTIONS **************************/\r\n\r\n  /**\r\n   * [ERC1400 INTERFACE (1/9)]\r\n   * @dev Access a document associated with the token.\r\n   * @param name Short name (represented as a bytes32) associated to the document.\r\n   * @return Requested document + document hash.\r\n   */\r\n  function getDocument(bytes32 name) external view returns (string memory, bytes32) {\r\n    require(bytes(_documents[name].docURI).length != 0, \"Action Blocked - Empty document\");\r\n    return (\r\n      _documents[name].docURI,\r\n      _documents[name].docHash\r\n    );\r\n  }\r\n\r\n  /**\r\n   * [ERC1400 INTERFACE (2/9)]\r\n   * @dev Associate a document with the token.\r\n   * @param name Short name (represented as a bytes32) associated to the document.\r\n   * @param uri Document content.\r\n   * @param documentHash Hash of the document [optional parameter].\r\n   */\r\n  function setDocument(bytes32 name, string calldata uri, bytes32 documentHash) external onlyOwner {\r\n    _documents[name] = Doc({\r\n      docURI: uri,\r\n      docHash: documentHash\r\n    });\r\n    emit Document(name, uri, documentHash);\r\n  }\r\n\r\n  /**\r\n   * [ERC1400 INTERFACE (3/9)]\r\n   * @dev Know if the token can be controlled by operators.\r\n   * If a token returns 'false' for 'isControllable()'' then it MUST always return 'false' in the future.\r\n   * @return bool 'true' if the token can still be controlled by operators, 'false' if it can't anymore.\r\n   */\r\n  function isControllable() external view returns (bool) {\r\n    return _isControllable;\r\n  }\r\n\r\n  /**\r\n   * [ERC1400 INTERFACE (4/9)]\r\n   * @dev Know if new tokens can be issued in the future.\r\n   * @return bool 'true' if tokens can still be issued by the issuer, 'false' if they can't anymore.\r\n   */\r\n  function isIssuable() external view returns (bool) {\r\n    return _isIssuable;\r\n  }\r\n\r\n  /**\r\n   * [ERC1400 INTERFACE (5/9)]\r\n   * @dev Issue tokens from a specific partition.\r\n   * @param partition Name of the partition.\r\n   * @param tokenHolder Address for which we want to issue tokens.\r\n   * @param value Number of tokens issued.\r\n   * @param data Information attached to the issuance, by the issuer. [CONTAINS THE CONDITIONAL OWNERSHIP CERTIFICATE]\r\n   */\r\n  function issueByPartition(bytes32 partition, address tokenHolder, uint256 value, bytes calldata data)\r\n    external\r\n    onlyMinter\r\n    issuableToken\r\n    isValidCertificate(data)\r\n  {\r\n    _issueByPartition(partition, msg.sender, tokenHolder, value, data, \"\");\r\n  }\r\n\r\n  /**\r\n   * [ERC1400 INTERFACE (6/9)]\r\n   * @dev Redeem tokens of a specific partition.\r\n   * @param partition Name of the partition.\r\n   * @param value Number of tokens redeemed.\r\n   * @param data Information attached to the redemption, by the redeemer. [CONTAINS THE CONDITIONAL OWNERSHIP CERTIFICATE]\r\n   */\r\n  function redeemByPartition(bytes32 partition, uint256 value, bytes calldata data)\r\n    external\r\n    isValidCertificate(data)\r\n  {\r\n    _redeemByPartition(partition, msg.sender, msg.sender, value, data, \"\");\r\n  }\r\n\r\n  /**\r\n   * [ERC1400 INTERFACE (7/9)]\r\n   * @dev Redeem tokens of a specific partition.\r\n   * @param partition Name of the partition.\r\n   * @param tokenHolder Address for which we want to redeem tokens.\r\n   * @param value Number of tokens redeemed.\r\n   * @param data Information attached to the redemption.\r\n   * @param operatorData Information attached to the redemption, by the operator. [CONTAINS THE CONDITIONAL OWNERSHIP CERTIFICATE]\r\n   */\r\n  function operatorRedeemByPartition(bytes32 partition, address tokenHolder, uint256 value, bytes calldata data, bytes calldata operatorData)\r\n    external\r\n    isValidCertificate(operatorData)\r\n  {\r\n    address _from = (tokenHolder == address(0)) ? msg.sender : tokenHolder;\r\n    require(_isOperatorForPartition(partition, msg.sender, _from), \"A7: Transfer Blocked - Identity restriction\");\r\n\r\n    _redeemByPartition(partition, msg.sender, _from, value, data, operatorData);\r\n  }\r\n\r\n  /**\r\n   * [ERC1400 INTERFACE (8/9)]\r\n   * @dev Know the reason on success or failure based on the EIP-1066 application-specific status codes.\r\n   * @param partition Name of the partition.\r\n   * @param to Token recipient.\r\n   * @param value Number of tokens to transfer.\r\n   * @param data Information attached to the transfer, by the token holder. [CONTAINS THE CONDITIONAL OWNERSHIP CERTIFICATE]\r\n   * @return ESC (Ethereum Status Code) following the EIP-1066 standard.\r\n   * @return Additional bytes32 parameter that can be used to define\r\n   * application specific reason codes with additional details (for example the\r\n   * transfer restriction rule responsible for making the transfer operation invalid).\r\n   * @return Destination partition.\r\n   */\r\n  function canTransferByPartition(bytes32 partition, address to, uint256 value, bytes calldata data)\r\n    external\r\n    view\r\n    returns (byte, bytes32, bytes32)\r\n  {\r\n    if(!_checkCertificate(data, 0, 0xf3d490db)) { // 4 first bytes of keccak256(transferByPartition(bytes32,address,uint256,bytes))\r\n      return(hex\"A3\", \"\", partition); // Transfer Blocked - Sender lockup period not ended\r\n    } else {\r\n      return _canTransfer(partition, msg.sender, msg.sender, to, value, data, \"\");\r\n    }\r\n  }\r\n\r\n  /**\r\n   * [ERC1400 INTERFACE (9/9)]\r\n   * @dev Know the reason on success or failure based on the EIP-1066 application-specific status codes.\r\n   * @param partition Name of the partition.\r\n   * @param from Token holder.\r\n   * @param to Token recipient.\r\n   * @param value Number of tokens to transfer.\r\n   * @param data Information attached to the transfer. [CAN CONTAIN THE DESTINATION PARTITION]\r\n   * @param operatorData Information attached to the transfer, by the operator. [CONTAINS THE CONDITIONAL OWNERSHIP CERTIFICATE]\r\n   * @return ESC (Ethereum Status Code) following the EIP-1066 standard.\r\n   * @return Additional bytes32 parameter that can be used to define\r\n   * application specific reason codes with additional details (for example the\r\n   * transfer restriction rule responsible for making the transfer operation invalid).\r\n   * @return Destination partition.\r\n   */\r\n  function canOperatorTransferByPartition(bytes32 partition, address from, address to, uint256 value, bytes calldata data, bytes calldata operatorData)\r\n    external\r\n    view\r\n    returns (byte, bytes32, bytes32)\r\n  {\r\n    if(!_checkCertificate(operatorData, 0, 0x8c0dee9c)) { // 4 first bytes of keccak256(operatorTransferByPartition(bytes32,address,address,uint256,bytes,bytes))\r\n      return(hex\"A3\", \"\", partition); // Transfer Blocked - Sender lockup period not ended\r\n    } else {\r\n      address _from = (from == address(0)) ? msg.sender : from;\r\n      return _canTransfer(partition, msg.sender, _from, to, value, data, operatorData);\r\n    }\r\n  }\r\n\r\n  /********************** ERC1400 INTERNAL FUNCTIONS **************************/\r\n\r\n  /**\r\n   * [INTERNAL]\r\n   * @dev Know the reason on success or failure based on the EIP-1066 application-specific status codes.\r\n   * @param partition Name of the partition.\r\n   * @param operator The address performing the transfer.\r\n   * @param from Token holder.\r\n   * @param to Token recipient.\r\n   * @param value Number of tokens to transfer.\r\n   * @param data Information attached to the transfer. [CAN CONTAIN THE DESTINATION PARTITION]\r\n   * @param operatorData Information attached to the transfer, by the operator (if any).\r\n   * @return ESC (Ethereum Status Code) following the EIP-1066 standard.\r\n   * @return Additional bytes32 parameter that can be used to define\r\n   * application specific reason codes with additional details (for example the\r\n   * transfer restriction rule responsible for making the transfer operation invalid).\r\n   * @return Destination partition.\r\n   */\r\n   function _canTransfer(bytes32 partition, address operator, address from, address to, uint256 value, bytes memory data, bytes memory operatorData)\r\n     internal\r\n     view\r\n     returns (byte, bytes32, bytes32)\r\n   {\r\n     if(!_isOperatorForPartition(partition, operator, from))\r\n       return(hex\"A7\", \"\", partition); // \"Transfer Blocked - Identity restriction\"\r\n\r\n     if((_balances[from] < value) || (_balanceOfByPartition[from][partition] < value))\r\n       return(hex\"A4\", \"\", partition); // Transfer Blocked - Sender balance insufficient\r\n\r\n     if(to == address(0))\r\n       return(hex\"A6\", \"\", partition); // Transfer Blocked - Receiver not eligible\r\n\r\n     address senderImplementation;\r\n     address recipientImplementation;\r\n     senderImplementation = interfaceAddr(from, \"ERC777TokensSender\");\r\n     recipientImplementation = interfaceAddr(to, \"ERC777TokensRecipient\");\r\n\r\n     if((senderImplementation != address(0))\r\n       && !IERC777TokensSender(senderImplementation).canTransfer(partition, from, to, value, data, operatorData))\r\n       return(hex\"A5\", \"\", partition); // Transfer Blocked - Sender not eligible\r\n\r\n     if((recipientImplementation != address(0))\r\n       && !IERC777TokensRecipient(recipientImplementation).canReceive(partition, from, to, value, data, operatorData))\r\n       return(hex\"A6\", \"\", partition); // Transfer Blocked - Receiver not eligible\r\n\r\n     if(!_isMultiple(value))\r\n       return(hex\"A9\", \"\", partition); // Transfer Blocked - Token granularity\r\n\r\n     return(hex\"A2\", \"\", partition);  // Transfer Verified - Off-Chain approval for restricted token\r\n   }\r\n\r\n  /**\r\n   * [INTERNAL]\r\n   * @dev Issue tokens from a specific partition.\r\n   * @param toPartition Name of the partition.\r\n   * @param operator The address performing the issuance.\r\n   * @param to Token recipient.\r\n   * @param value Number of tokens to issue.\r\n   * @param data Information attached to the issuance.\r\n   * @param operatorData Information attached to the issuance, by the operator (if any).\r\n   */\r\n  function _issueByPartition(\r\n    bytes32 toPartition,\r\n    address operator,\r\n    address to,\r\n    uint256 value,\r\n    bytes memory data,\r\n    bytes memory operatorData\r\n  )\r\n    internal\r\n  {\r\n    _issue(toPartition, operator, to, value, data, operatorData);\r\n    _addTokenToPartition(to, toPartition, value);\r\n\r\n    emit IssuedByPartition(toPartition, operator, to, value, data, operatorData);\r\n  }\r\n\r\n  /**\r\n   * [INTERNAL]\r\n   * @dev Redeem tokens of a specific partition.\r\n   * @param fromPartition Name of the partition.\r\n   * @param operator The address performing the redemption.\r\n   * @param from Token holder whose tokens will be redeemed.\r\n   * @param value Number of tokens to redeem.\r\n   * @param data Information attached to the redemption.\r\n   * @param operatorData Information attached to the redemption, by the operator (if any).\r\n   */\r\n  function _redeemByPartition(\r\n    bytes32 fromPartition,\r\n    address operator,\r\n    address from,\r\n    uint256 value,\r\n    bytes memory data,\r\n    bytes memory operatorData\r\n  )\r\n    internal\r\n  {\r\n    require(_balanceOfByPartition[from][fromPartition] >= value, \"A4: Transfer Blocked - Sender balance insufficient\");\r\n\r\n    _removeTokenFromPartition(from, fromPartition, value);\r\n    _redeem(fromPartition, operator, from, value, data, operatorData);\r\n\r\n    emit RedeemedByPartition(fromPartition, operator, from, value, data, operatorData);\r\n  }\r\n\r\n  /********************** ERC1400 OPTIONAL FUNCTIONS **************************/\r\n\r\n  /**\r\n   * [NOT MANDATORY FOR ERC1400 STANDARD]\r\n   * @dev Definitely renounce the possibility to control tokens on behalf of tokenHolders.\r\n   * Once set to false, '_isControllable' can never be set to 'true' again.\r\n   */\r\n  function renounceControl() external onlyOwner {\r\n    _isControllable = false;\r\n  }\r\n\r\n  /**\r\n   * [NOT MANDATORY FOR ERC1400 STANDARD]\r\n   * @dev Definitely renounce the possibility to issue new tokens.\r\n   * Once set to false, '_isIssuable' can never be set to 'true' again.\r\n   */\r\n  function renounceIssuance() external onlyOwner {\r\n    _isIssuable = false;\r\n  }\r\n\r\n  /**\r\n   * [NOT MANDATORY FOR ERC1400 STANDARD]\r\n   * @dev Set list of token controllers.\r\n   * @param operators Controller addresses.\r\n   */\r\n  function setControllers(address[] calldata operators) external onlyOwner {\r\n    _setControllers(operators);\r\n  }\r\n\r\n  /**\r\n   * [NOT MANDATORY FOR ERC1400 STANDARD]\r\n   * @dev Set list of token partition controllers.\r\n   * @param partition Name of the partition.\r\n   * @param operators Controller addresses.\r\n   */\r\n   function setPartitionControllers(bytes32 partition, address[] calldata operators) external onlyOwner {\r\n     _setPartitionControllers(partition, operators);\r\n   }\r\n\r\n   /**\r\n   * @dev Add a certificate signer for the token.\r\n   * @param operator Address to set as a certificate signer.\r\n   * @param authorized 'true' if operator shall be accepted as certificate signer, 'false' if not.\r\n   */\r\n  function setCertificateSigner(address operator, bool authorized) external onlyOwner {\r\n    _setCertificateSigner(operator, authorized);\r\n  }\r\n\r\n  /************* ERC1410/ERC777 BACKWARDS RETROCOMPATIBILITY ******************/\r\n\r\n  /**\r\n   * [NOT MANDATORY FOR ERC1400 STANDARD]\r\n   * @dev Get token default partitions to send from.\r\n   * Function used for ERC777 and ERC20 backwards compatibility.\r\n   * For example, a security token may return the bytes32(\"unrestricted\").\r\n   * @return Default partitions.\r\n   */\r\n  function getTokenDefaultPartitions() external view returns (bytes32[] memory) {\r\n    return _tokenDefaultPartitions;\r\n  }\r\n\r\n  /**\r\n   * [NOT MANDATORY FOR ERC1400 STANDARD]\r\n   * @dev Set token default partitions to send from.\r\n   * Function used for ERC777 and ERC20 backwards compatibility.\r\n   * @param defaultPartitions Partitions to use by default when not specified.\r\n   */\r\n  function setTokenDefaultPartitions(bytes32[] calldata defaultPartitions) external onlyOwner {\r\n    _tokenDefaultPartitions = defaultPartitions;\r\n  }\r\n\r\n\r\n  /**\r\n   * [NOT MANDATORY FOR ERC1400 STANDARD][OVERRIDES ERC1410 METHOD]\r\n   * @dev Redeem the value of tokens from the address 'msg.sender'.\r\n   * @param value Number of tokens to redeem.\r\n   * @param data Information attached to the redemption, by the token holder. [CONTAINS THE CONDITIONAL OWNERSHIP CERTIFICATE]\r\n   */\r\n  function redeem(uint256 value, bytes calldata data)\r\n    external\r\n    isValidCertificate(data)\r\n  {\r\n    _redeemByDefaultPartitions(msg.sender, msg.sender, value, data, \"\");\r\n  }\r\n\r\n  /**\r\n   * [NOT MANDATORY FOR ERC1400 STANDARD][OVERRIDES ERC1410 METHOD]\r\n   * @dev Redeem the value of tokens on behalf of the address 'from'.\r\n   * @param from Token holder whose tokens will be redeemed (or 'address(0)' to set from to 'msg.sender').\r\n   * @param value Number of tokens to redeem.\r\n   * @param data Information attached to the redemption.\r\n   * @param operatorData Information attached to the redemption, by the operator. [CONTAINS THE CONDITIONAL OWNERSHIP CERTIFICATE]\r\n   */\r\n  function redeemFrom(address from, uint256 value, bytes calldata data, bytes calldata operatorData)\r\n    external\r\n    isValidCertificate(operatorData)\r\n  {\r\n    address _from = (from == address(0)) ? msg.sender : from;\r\n\r\n    require(_isOperatorFor(msg.sender, _from), \"A7: Transfer Blocked - Identity restriction\");\r\n\r\n    _redeemByDefaultPartitions(msg.sender, _from, value, data, operatorData);\r\n  }\r\n\r\n  /**\r\n  * [NOT MANDATORY FOR ERC1410 STANDARD]\r\n   * @dev Redeem tokens from a default partitions.\r\n   * @param operator The address performing the redeem.\r\n   * @param from Token holder.\r\n   * @param value Number of tokens to redeem.\r\n   * @param data Information attached to the redemption.\r\n   * @param operatorData Information attached to the redemption, by the operator (if any).\r\n   */\r\n  function _redeemByDefaultPartitions(\r\n    address operator,\r\n    address from,\r\n    uint256 value,\r\n    bytes memory data,\r\n    bytes memory operatorData\r\n  )\r\n    internal\r\n  {\r\n    bytes32[] memory _partitions = _getDefaultPartitions(from);\r\n    require(_partitions.length != 0, \"A8: Transfer Blocked - Token restriction\");\r\n\r\n    uint256 _remainingValue = value;\r\n    uint256 _localBalance;\r\n\r\n    for (uint i = 0; i < _partitions.length; i++) {\r\n      _localBalance = _balanceOfByPartition[from][_partitions[i]];\r\n      if(_remainingValue <= _localBalance) {\r\n        _redeemByPartition(_partitions[i], operator, from, _remainingValue, data, operatorData);\r\n        _remainingValue = 0;\r\n        break;\r\n      } else {\r\n        _redeemByPartition(_partitions[i], operator, from, _localBalance, data, operatorData);\r\n        _remainingValue = _remainingValue - _localBalance;\r\n      }\r\n    }\r\n\r\n    require(_remainingValue == 0, \"A8: Transfer Blocked - Token restriction\");\r\n  }\r\n\r\n}\r\n\r\n/**\r\n * @title ERC1400ERC20\r\n * @dev ERC1400 with ERC20 retrocompatibility\r\n */\r\ncontract ERC1400ERC20 is IERC20, ERC1400 {\r\n\r\n  // Mapping from (tokenHolder, spender) to allowed value.\r\n  mapping (address => mapping (address => uint256)) internal _allowed;\r\n\r\n  // Mapping from (tokenHolder) to whitelisted status.\r\n  mapping (address => bool) internal _whitelisted;\r\n\r\n  /**\r\n   * @dev Modifier to verify if sender and recipient are whitelisted.\r\n   */\r\n  modifier isWhitelisted(address recipient) {\r\n    require(_whitelisted[recipient], \"A3: Transfer Blocked - Sender lockup period not ended\");\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * [ERC1400ERC20 CONSTRUCTOR]\r\n   * @dev Initialize ERC71400ERC20 and CertificateController parameters + register\r\n   * the contract implementation in ERC820Registry.\r\n   * @param name Name of the token.\r\n   * @param symbol Symbol of the token.\r\n   * @param granularity Granularity of the token.\r\n   * @param controllers Array of initial controllers.\r\n   * @param certificateSigner Address of the off-chain service which signs the\r\n   * conditional ownership certificates required for token transfers, issuance,\r\n   * redemption (Cf. CertificateController.sol).\r\n   */\r\n  constructor(\r\n    string memory name,\r\n    string memory symbol,\r\n    uint256 granularity,\r\n    address[] memory controllers,\r\n    address certificateSigner,\r\n    bytes32[] memory tokenDefaultPartitions\r\n  )\r\n    public\r\n    ERC1400(name, symbol, granularity, controllers, certificateSigner, tokenDefaultPartitions)\r\n  {\r\n    setInterfaceImplementation(\"ERC20Token\", address(this));\r\n  }\r\n\r\n  /**\r\n   * [OVERRIDES ERC1400 METHOD]\r\n   * @dev Perform the transfer of tokens.\r\n   * @param partition Name of the partition (bytes32 to be left empty for ERC777 transfer).\r\n   * @param operator The address performing the transfer.\r\n   * @param from Token holder.\r\n   * @param to Token recipient.\r\n   * @param value Number of tokens to transfer.\r\n   * @param data Information attached to the transfer.\r\n   * @param operatorData Information attached to the transfer by the operator (if any).\r\n   * @param preventLocking 'true' if you want this function to throw when tokens are sent to a contract not\r\n   * implementing 'erc777tokenHolder'.\r\n   * ERC777 native transfer functions MUST set this parameter to 'true', and backwards compatible ERC20 transfer\r\n   * functions SHOULD set this parameter to 'false'.\r\n   */\r\n  function _transferWithData(\r\n    bytes32 partition,\r\n    address operator,\r\n    address from,\r\n    address to,\r\n    uint256 value,\r\n    bytes memory data,\r\n    bytes memory operatorData,\r\n    bool preventLocking\r\n  )\r\n    internal\r\n  {\r\n    ERC777._transferWithData(partition, operator, from, to, value, data, operatorData, preventLocking);\r\n\r\n    emit Transfer(from, to, value);\r\n  }\r\n\r\n  /**\r\n   * [OVERRIDES ERC1400 METHOD]\r\n   * @dev Perform the token redemption.\r\n   * @param partition Name of the partition (bytes32 to be left empty for ERC777 transfer).\r\n   * @param operator The address performing the redemption.\r\n   * @param from Token holder whose tokens will be redeemed.\r\n   * @param value Number of tokens to redeem.\r\n   * @param data Information attached to the redemption.\r\n   * @param operatorData Information attached to the redemption by the operator (if any).\r\n   */\r\n  function _redeem(bytes32 partition, address operator, address from, uint256 value, bytes memory data, bytes memory operatorData) internal {\r\n    ERC777._redeem(partition, operator, from, value, data, operatorData);\r\n\r\n    emit Transfer(from, address(0), value);  //  ERC20 backwards compatibility\r\n  }\r\n\r\n  /**\r\n   * [OVERRIDES ERC1400 METHOD]\r\n   * @dev Perform the issuance of tokens.\r\n   * @param partition Name of the partition (bytes32 to be left empty for ERC777 transfer).\r\n   * @param operator Address which triggered the issuance.\r\n   * @param to Token recipient.\r\n   * @param value Number of tokens issued.\r\n   * @param data Information attached to the issuance.\r\n   * @param operatorData Information attached to the issuance by the operator (if any).\r\n   */\r\n  function _issue(bytes32 partition, address operator, address to, uint256 value, bytes memory data, bytes memory operatorData) internal {\r\n    ERC777._issue(partition, operator, to, value, data, operatorData);\r\n\r\n    emit Transfer(address(0), to, value); // ERC20 backwards compatibility\r\n  }\r\n\r\n  /**\r\n   * [OVERRIDES ERC1400 METHOD]\r\n   * @dev Get the number of decimals of the token.\r\n   * @return The number of decimals of the token. For Backwards compatibility, decimals are forced to 18 in ERC777.\r\n   */\r\n  function decimals() external pure returns(uint8) {\r\n    return uint8(18);\r\n  }\r\n\r\n  /**\r\n   * [NOT MANDATORY FOR ERC1400 STANDARD]\r\n   * @dev Check the value of tokens that an owner allowed to a spender.\r\n   * @param owner address The address which owns the funds.\r\n   * @param spender address The address which will spend the funds.\r\n   * @return A uint256 specifying the value of tokens still available for the spender.\r\n   */\r\n  function allowance(address owner, address spender) external view returns (uint256) {\r\n    return _allowed[owner][spender];\r\n  }\r\n\r\n  /**\r\n   * [NOT MANDATORY FOR ERC1400 STANDARD]\r\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of 'msg.sender'.\r\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\r\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\r\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\r\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n   * @param spender The address which will spend the funds.\r\n   * @param value The amount of tokens to be spent.\r\n   * @return A boolean that indicates if the operation was successful.\r\n   */\r\n  function approve(address spender, uint256 value) external returns (bool) {\r\n    require(spender != address(0), \"A5: Transfer Blocked - Sender not eligible\");\r\n    _allowed[msg.sender][spender] = value;\r\n    emit Approval(msg.sender, spender, value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * [NOT MANDATORY FOR ERC1400 STANDARD]\r\n   * @dev Transfer token for a specified address.\r\n   * @param to The address to transfer to.\r\n   * @param value The value to be transferred.\r\n   * @return A boolean that indicates if the operation was successful.\r\n   */\r\n  function transfer(address to, uint256 value) external isWhitelisted(to) returns (bool) {\r\n    _transferByDefaultPartitions(msg.sender, msg.sender, to, value, \"\", \"\");\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * [NOT MANDATORY FOR ERC1400 STANDARD]\r\n   * @dev Transfer tokens from one address to another.\r\n   * @param from The address which you want to transfer tokens from.\r\n   * @param to The address which you want to transfer to.\r\n   * @param value The amount of tokens to be transferred.\r\n   * @return A boolean that indicates if the operation was successful.\r\n   */\r\n  function transferFrom(address from, address to, uint256 value) external isWhitelisted(to) returns (bool) {\r\n    address _from = (from == address(0)) ? msg.sender : from;\r\n    require( _isOperatorFor(msg.sender, _from)\r\n      || (value <= _allowed[_from][msg.sender]), \"A7: Transfer Blocked - Identity restriction\");\r\n\r\n    if(_allowed[_from][msg.sender] >= value) {\r\n      _allowed[_from][msg.sender] = _allowed[_from][msg.sender].sub(value);\r\n    } else {\r\n      _allowed[_from][msg.sender] = 0;\r\n    }\r\n\r\n    _transferByDefaultPartitions(msg.sender, _from, to, value, \"\", \"\");\r\n    return true;\r\n  }\r\n\r\n  /***************** ERC1400ERC20 OPTIONAL FUNCTIONS ***************************/\r\n\r\n  /**\r\n   * [NOT MANDATORY FOR ERC1400ERC20 STANDARD]\r\n   * @dev Get whitelisted status for a tokenHolder.\r\n   * @param tokenHolder Address whom to check the whitelisted status for.\r\n   * @return bool 'true' if tokenHolder is whitelisted, 'false' if not.\r\n   */\r\n  function whitelisted(address tokenHolder) external view returns (bool) {\r\n    return _whitelisted[tokenHolder];\r\n  }\r\n\r\n  /**\r\n   * [NOT MANDATORY FOR ERC1400ERC20 STANDARD]\r\n   * @dev Set whitelisted status for a tokenHolder.\r\n   * @param tokenHolder Address to add/remove from whitelist.\r\n   * @param authorized 'true' if tokenHolder shall be added to whitelist, 'false' if not.\r\n   */\r\n  function setWhitelisted(address tokenHolder, bool authorized) external onlyOwner {\r\n    _setWhitelisted(tokenHolder, authorized);\r\n  }\r\n\r\n  /**\r\n   * [NOT MANDATORY FOR ERC1400ERC20 STANDARD]\r\n   * @dev Set whitelisted status for a tokenHolder.\r\n   * @param tokenHolder Address to add/remove from whitelist.\r\n   * @param authorized 'true' if tokenHolder shall be added to whitelist, 'false' if not.\r\n   */\r\n  function _setWhitelisted(address tokenHolder, bool authorized) internal {\r\n    require(tokenHolder != address(0), \"Action Blocked - Not a valid address\");\r\n    _whitelisted[tokenHolder] = authorized;\r\n  }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"name\",\"type\":\"bytes32\"},{\"name\":\"uri\",\"type\":\"string\"},{\"name\":\"documentHash\",\"type\":\"bytes32\"}],\"name\":\"setDocument\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"partition\",\"type\":\"bytes32\"},{\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"authorizeOperatorByPartition\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"partition\",\"type\":\"bytes32\"},{\"name\":\"tokenHolder\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"data\",\"type\":\"bytes\"},{\"name\":\"operatorData\",\"type\":\"bytes\"}],\"name\":\"operatorRedeemByPartition\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"partition\",\"type\":\"bytes32\"},{\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"revokeOperatorByPartition\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"partition\",\"type\":\"bytes32\"},{\"name\":\"operators\",\"type\":\"address[]\"}],\"name\":\"setPartitionControllers\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"transferWithData\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isIssuable\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"partition\",\"type\":\"bytes32\"},{\"name\":\"tokenHolder\",\"type\":\"address\"}],\"name\":\"balanceOfByPartition\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTokenDefaultPartitions\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isControllable\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"granularity\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"defaultPartitions\",\"type\":\"bytes32[]\"}],\"name\":\"setTokenDefaultPartitions\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"partition\",\"type\":\"bytes32\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"redeemByPartition\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"partition\",\"type\":\"bytes32\"},{\"name\":\"tokenHolder\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"issueByPartition\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"checkCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalPartitions\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"partition\",\"type\":\"bytes32\"},{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"data\",\"type\":\"bytes\"},{\"name\":\"operatorData\",\"type\":\"bytes\"}],\"name\":\"canOperatorTransferByPartition\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes1\"},{\"name\":\"\",\"type\":\"bytes32\"},{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceIssuance\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"partition\",\"type\":\"bytes32\"},{\"name\":\"operator\",\"type\":\"address\"},{\"name\":\"tokenHolder\",\"type\":\"address\"}],\"name\":\"isOperatorForPartition\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenHolder\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"certificateSigners\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenHolder\",\"type\":\"address\"}],\"name\":\"partitionsOf\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"operator\",\"type\":\"address\"},{\"name\":\"authorized\",\"type\":\"bool\"}],\"name\":\"setCertificateSigner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"controllers\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"partition\",\"type\":\"bytes32\"}],\"name\":\"controllersByPartition\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"data\",\"type\":\"bytes\"},{\"name\":\"operatorData\",\"type\":\"bytes\"}],\"name\":\"transferFromWithData\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"partition\",\"type\":\"bytes32\"},{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"data\",\"type\":\"bytes\"},{\"name\":\"operatorData\",\"type\":\"bytes\"}],\"name\":\"operatorTransferByPartition\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"partition\",\"type\":\"bytes32\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"canTransferByPartition\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes1\"},{\"name\":\"\",\"type\":\"bytes32\"},{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenHolder\",\"type\":\"address\"},{\"name\":\"authorized\",\"type\":\"bool\"}],\"name\":\"setWhitelisted\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"authorizeOperator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"addMinter\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceMinter\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isMinter\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenHolder\",\"type\":\"address\"}],\"name\":\"getDefaultPartitions\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"name\",\"type\":\"bytes32\"}],\"name\":\"getDocument\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"},{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceControl\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenHolder\",\"type\":\"address\"}],\"name\":\"whitelisted\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"operator\",\"type\":\"address\"},{\"name\":\"tokenHolder\",\"type\":\"address\"}],\"name\":\"isOperatorFor\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"redeem\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"operators\",\"type\":\"address[]\"}],\"name\":\"setControllers\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"partitions\",\"type\":\"bytes32[]\"}],\"name\":\"setDefaultPartitions\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"partition\",\"type\":\"bytes32\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"transferByPartition\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"revokeOperator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"data\",\"type\":\"bytes\"},{\"name\":\"operatorData\",\"type\":\"bytes\"}],\"name\":\"redeemFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"name\",\"type\":\"string\"},{\"name\":\"symbol\",\"type\":\"string\"},{\"name\":\"granularity\",\"type\":\"uint256\"},{\"name\":\"controllers\",\"type\":\"address[]\"},{\"name\":\"certificateSigner\",\"type\":\"address\"},{\"name\":\"tokenDefaultPartitions\",\"type\":\"bytes32[]\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"MinterAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"MinterRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"Checked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"},{\"indexed\":false,\"name\":\"operatorData\",\"type\":\"bytes\"}],\"name\":\"TransferWithData\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"},{\"indexed\":false,\"name\":\"operatorData\",\"type\":\"bytes\"}],\"name\":\"Issued\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"},{\"indexed\":false,\"name\":\"operatorData\",\"type\":\"bytes\"}],\"name\":\"Redeemed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"tokenHolder\",\"type\":\"address\"}],\"name\":\"AuthorizedOperator\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"tokenHolder\",\"type\":\"address\"}],\"name\":\"RevokedOperator\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"fromPartition\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"},{\"indexed\":false,\"name\":\"operatorData\",\"type\":\"bytes\"}],\"name\":\"TransferByPartition\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"fromPartition\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"toPartition\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"ChangedPartition\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"partition\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"tokenHolder\",\"type\":\"address\"}],\"name\":\"AuthorizedOperatorByPartition\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"partition\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"tokenHolder\",\"type\":\"address\"}],\"name\":\"RevokedOperatorByPartition\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"name\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"uri\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"documentHash\",\"type\":\"bytes32\"}],\"name\":\"Document\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"partition\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"},{\"indexed\":false,\"name\":\"operatorData\",\"type\":\"bytes\"}],\"name\":\"IssuedByPartition\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"partition\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"},{\"indexed\":false,\"name\":\"operatorData\",\"type\":\"bytes\"}],\"name\":\"RedeemedByPartition\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"ERC1400ERC20","CompilerVersion":"v0.5.4+commit.9549d8ff","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000000000000000000000000000000000000000000c000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000014000000000000000000000000039a227331dbbfbaf8db076f79dd40872e464b5340000000000000000000000000000000000000000000000000000000000000180000000000000000000000000000000000000000000000000000000000000000854657374436f696e00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000025443000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000039a227331dbbfbaf8db076f79dd40872e464b5340000000000000000000000000000000000000000000000000000000000000003526573657276656400000000000000000000000000000000000000000000000049737375656400000000000000000000000000000000000000000000000000004c6f636b65640000000000000000000000000000000000000000000000000000","Library":"","SwarmSource":"bzzr://a241e7e9928f566888f71fc343e2a5f544e4e3694ecd48247c1b7e47b8226795"}]}