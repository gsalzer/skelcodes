{"status":"1","message":"OK","result":[{"SourceCode":"/*\r\n * This file was generated by MyWish Platform (https://mywish.io/)\r\n * The complete code could be found at https://github.com/MyWishPlatform/\r\n * Copyright (C) 2018 MyWish\r\n *\r\n * This program is free software: you can redistribute it and/or modify\r\n * it under the terms of the GNU Lesser General Public License as published by\r\n * the Free Software Foundation, either version 3 of the License, or\r\n * (at your option) any later version.\r\n *\r\n * This program is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\r\n * GNU Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public License\r\n * along with this program. If not, see <http://www.gnu.org/licenses/>.\r\n */\r\npragma solidity ^0.5.7;\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n     * account.\r\n     */\r\n    constructor () internal {\r\n        _owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), _owner);\r\n    }\r\n\r\n    /**\r\n     * @return the address of the owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner());\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @return true if `msg.sender` is the owner of the contract.\r\n     */\r\n    function isOwner() public view returns (bool) {\r\n        return msg.sender == _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to relinquish control of the contract.\r\n     * It will not be possible to call the functions with the `onlyOwner`\r\n     * modifier anymore.\r\n     * @notice Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0));\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @title ERC20 interface without bool returns\r\n * @dev see https://eips.ethereum.org/EIPS/eip-20\r\n */\r\ninterface IERC20 {\r\n    function transfer(address to, uint256 value) external;\r\n\r\n    function approve(address spender, uint256 value) external;\r\n\r\n    function transferFrom(address from, address to, uint256 value) external;\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address who) external view returns (uint256);\r\n\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\n/**\r\n * @title Helps contracts guard against reentrancy attacks.\r\n * @author Remco Bloemen <remco@2Ï€.com>, Eenae <alexey@mixbytes.io>\r\n * @dev If you mark a function `nonReentrant`, you should also\r\n * mark it `external`.\r\n */\r\ncontract ReentrancyGuard {\r\n    /// @dev counter to allow mutex lock with only one SSTORE operation\r\n    uint256 private _guardCounter;\r\n\r\n    constructor () internal {\r\n        // The counter starts at one to prevent changing it from zero to a non-zero\r\n        // value, which is a more expensive operation.\r\n        _guardCounter = 1;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and make it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        _guardCounter += 1;\r\n        uint256 localCounter = _guardCounter;\r\n        _;\r\n        require(localCounter == _guardCounter);\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Unsigned math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Multiplies two unsigned integers, reverts on overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Adds two unsigned integers, reverts on overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\r\n     * reverts when dividing by zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n\r\ninterface ISwaps {\r\n    function createOrder(\r\n        bytes32 _id,\r\n        address _baseAddress,\r\n        address _quoteAddress,\r\n        uint _baseLimit,\r\n        uint _quoteLimit,\r\n        uint _expirationTimestamp,\r\n        address _baseOnlyInvestor,\r\n        uint _minBaseInvestment,\r\n        uint _minQuoteInvestment\r\n    ) external;\r\n\r\n    function deposit(\r\n        bytes32 _id,\r\n        address _token,\r\n        uint _amount\r\n    ) payable external;\r\n\r\n    function cancel(bytes32 _id) external;\r\n\r\n    function refund(bytes32 _id, address _token) external;\r\n}\r\n\r\n\r\ncontract Vault is Ownable {\r\n    address public swaps;\r\n\r\n    modifier onlySwaps() {\r\n        require(msg.sender == swaps);\r\n        _;\r\n    }\r\n\r\n    function () external payable {\r\n    }\r\n\r\n    function tokenFallback(address, uint, bytes calldata) external {\r\n    }\r\n\r\n    function setSwaps(address _swaps) public onlyOwner {\r\n        swaps = _swaps;\r\n    }\r\n\r\n    function withdraw(address _token, address _receiver, uint _amount) public onlySwaps {\r\n        if (_token == address(0)) {\r\n            address(uint160(_receiver)).transfer(_amount);\r\n        } else {\r\n            IERC20(_token).transfer(_receiver, _amount);\r\n        }\r\n    }\r\n}\r\n\r\n\r\ncontract Swaps is Ownable, ISwaps, ReentrancyGuard {\r\n    using SafeMath for uint;\r\n\r\n    uint public MAX_INVESTORS = 10;\r\n\r\n    Vault public vault;\r\n    mapping (bytes32 => address) public baseOnlyInvestor;\r\n    mapping (bytes32 => address) public owners;\r\n    mapping (bytes32 => address) public baseAddresses;\r\n    mapping (bytes32 => address) public quoteAddresses;\r\n    mapping (bytes32 => uint) public expirationTimestamps;\r\n    mapping (bytes32 => bool) public isSwapped;\r\n    mapping (bytes32 => bool) public isCancelled;\r\n    mapping (bytes32 => mapping (address => uint)) public limits;\r\n    mapping (bytes32 => mapping (address => uint)) public raised;\r\n    mapping (bytes32 => mapping (address => address[])) public investors;\r\n    mapping (bytes32 => mapping (address => mapping (address => uint))) public investments;\r\n    mapping (bytes32 => mapping (address => uint)) public minInvestments;\r\n\r\n    modifier onlyInvestor(bytes32 _id, address _token) {\r\n        require(_isInvestor(_id, _token, msg.sender), \"Allowed only for investors\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyWhenVaultDefined() {\r\n        require(address(vault) != address(0), \"Vault is not defined\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyOrderOwner(bytes32 _id) {\r\n        require(msg.sender == owners[_id], \"Allowed only for owner\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyWhenOrderExists(bytes32 _id) {\r\n        require(owners[_id] != address(0), \"Order doesn't exist\");\r\n        _;\r\n    }\r\n\r\n    event OrderCreated(\r\n        bytes32 id,\r\n        address owner,\r\n        address baseAddress,\r\n        address quoteAddress,\r\n        uint baseLimit,\r\n        uint quoteLimit,\r\n        uint expirationTimestamp,\r\n        address baseOnlyInvestor,\r\n        uint minBaseInvestment,\r\n        uint minQuoteInvestment\r\n    );\r\n\r\n    event OrderCancelled(bytes32 id);\r\n\r\n    event Deposit(\r\n        bytes32 id,\r\n        address token,\r\n        address user,\r\n        uint amount,\r\n        uint balance\r\n    );\r\n\r\n    event Refund(\r\n        bytes32 id,\r\n        address token,\r\n        address user,\r\n        uint amount\r\n    );\r\n\r\n    event OrderSwapped(\r\n        bytes32 id,\r\n        address byUser\r\n    );\r\n\r\n    event SwapSend(\r\n        bytes32 id,\r\n        address token,\r\n        address user,\r\n        uint amount\r\n    );\r\n\r\n    function tokenFallback(address, uint, bytes calldata) external {\r\n    }\r\n\r\n    function createOrder(\r\n        bytes32 _id,\r\n        address _baseAddress,\r\n        address _quoteAddress,\r\n        uint _baseLimit,\r\n        uint _quoteLimit,\r\n        uint _expirationTimestamp,\r\n        address _baseOnlyInvestor,\r\n        uint _minBaseInvestment,\r\n        uint _minQuoteInvestment\r\n    )\r\n        external\r\n        nonReentrant\r\n        onlyWhenVaultDefined\r\n    {\r\n        require(owners[_id] == address(0), \"Order already exists\");\r\n        require(_baseAddress != _quoteAddress, \"Exchanged tokens must be different\");\r\n        require(_baseLimit > 0, \"Base limit must be positive\");\r\n        require(_quoteLimit > 0, \"Quote limit must be positive\");\r\n        require(_expirationTimestamp > now, \"Expiration time must be in future\");\r\n\r\n        owners[_id] = msg.sender;\r\n        baseAddresses[_id] = _baseAddress;\r\n        quoteAddresses[_id] = _quoteAddress;\r\n        expirationTimestamps[_id] = _expirationTimestamp;\r\n        limits[_id][_baseAddress] = _baseLimit;\r\n        limits[_id][_quoteAddress] = _quoteLimit;\r\n        baseOnlyInvestor[_id] = _baseOnlyInvestor;\r\n        minInvestments[_id][_baseAddress] = _minBaseInvestment;\r\n        minInvestments[_id][_quoteAddress] = _minQuoteInvestment;\r\n\r\n        emit OrderCreated(\r\n            _id,\r\n            msg.sender,\r\n            _baseAddress,\r\n            _quoteAddress,\r\n            _baseLimit,\r\n            _quoteLimit,\r\n            _expirationTimestamp,\r\n            _baseOnlyInvestor,\r\n            _minBaseInvestment,\r\n            _minQuoteInvestment\r\n        );\r\n    }\r\n\r\n    function deposit(\r\n        bytes32 _id,\r\n        address _token,\r\n        uint _amount\r\n    )\r\n        payable\r\n        external\r\n        nonReentrant\r\n        onlyWhenVaultDefined\r\n        onlyWhenOrderExists(_id)\r\n    {\r\n        if (_token == address(0)) {\r\n            require(msg.value == _amount, \"Payable value should be equals value\");\r\n            address(vault).transfer(msg.value);\r\n        } else {\r\n            require(msg.value == 0, \"Payable not allowed here\");\r\n            uint allowance = IERC20(_token).allowance(msg.sender, address(this));\r\n            require(_amount <= allowance, \"Allowance should be not less than amount\");\r\n            IERC20(_token).transferFrom(msg.sender, address(vault), _amount);\r\n        }\r\n        _deposit(_id, _token, msg.sender, _amount);\r\n    }\r\n\r\n    function cancel(bytes32 _id)\r\n        external\r\n        nonReentrant\r\n        onlyOrderOwner(_id)\r\n        onlyWhenVaultDefined\r\n        onlyWhenOrderExists(_id)\r\n    {\r\n        require(!isCancelled[_id], \"Already cancelled\");\r\n        require(!isSwapped[_id], \"Already swapped\");\r\n\r\n        address[2] memory tokens = [baseAddresses[_id], quoteAddresses[_id]];\r\n        for (uint t = 0; t < tokens.length; t++) {\r\n            address token = tokens[t];\r\n            for (uint u = 0; u < investors[_id][token].length; u++) {\r\n                address user = investors[_id][token][u];\r\n                uint userInvestment = investments[_id][token][user];\r\n                vault.withdraw(token, user, userInvestment);\r\n            }\r\n        }\r\n\r\n        isCancelled[_id] = true;\r\n        emit OrderCancelled(_id);\r\n    }\r\n\r\n    function refund(bytes32 _id, address _token)\r\n        external\r\n        nonReentrant\r\n        onlyInvestor(_id, _token)\r\n        onlyWhenVaultDefined\r\n        onlyWhenOrderExists(_id)\r\n    {\r\n        require(!isSwapped[_id], \"Already swapped\");\r\n        address user = msg.sender;\r\n        uint investment = investments[_id][_token][user];\r\n        if (investment > 0) {\r\n            delete investments[_id][_token][user];\r\n        }\r\n\r\n        _removeInvestor(investors[_id][_token], user);\r\n\r\n        if (investment > 0) {\r\n            raised[_id][_token] = raised[_id][_token].sub(investment);\r\n            vault.withdraw(_token, user, investment);\r\n        }\r\n\r\n        emit Refund(_id, _token, user, investment);\r\n    }\r\n\r\n    function setVault(Vault _vault) external onlyOwner {\r\n        vault = _vault;\r\n    }\r\n\r\n    function createKey(address _owner)\r\n        public\r\n        view\r\n        returns (bytes32 result)\r\n    {\r\n        uint creationTime = now;\r\n        result = 0x0000000000000000000000000000000000000000000000000000000000000000;\r\n        assembly {\r\n            result := or(result, mul(_owner, 0x1000000000000000000000000))\r\n            result := or(result, and(creationTime, 0xffffffffffffffffffffffff))\r\n        }\r\n    }\r\n\r\n    function baseLimit(bytes32 _id)\r\n        public\r\n        view\r\n        returns (uint)\r\n    {\r\n        return limits[_id][baseAddresses[_id]];\r\n    }\r\n\r\n    function quoteLimit(bytes32 _id)\r\n        public\r\n        view\r\n        returns (uint)\r\n    {\r\n        return limits[_id][quoteAddresses[_id]];\r\n    }\r\n\r\n    function baseRaised(bytes32 _id)\r\n        public\r\n        view\r\n        returns (uint)\r\n    {\r\n        return raised[_id][baseAddresses[_id]];\r\n    }\r\n\r\n    function quoteRaised(bytes32 _id)\r\n        public\r\n        view\r\n        returns (uint)\r\n    {\r\n        return raised[_id][quoteAddresses[_id]];\r\n    }\r\n\r\n    function isBaseFilled(bytes32 _id)\r\n        public\r\n        view\r\n        returns (bool)\r\n    {\r\n        return raised[_id][baseAddresses[_id]] == limits[_id][baseAddresses[_id]];\r\n    }\r\n\r\n    function isQuoteFilled(bytes32 _id)\r\n        public\r\n        view\r\n        returns (bool)\r\n    {\r\n        return raised[_id][quoteAddresses[_id]] == limits[_id][quoteAddresses[_id]];\r\n    }\r\n\r\n    function baseInvestors(bytes32 _id)\r\n        public\r\n        view\r\n        returns (address[] memory)\r\n    {\r\n        return investors[_id][baseAddresses[_id]];\r\n    }\r\n\r\n    function quoteInvestors(bytes32 _id)\r\n        public\r\n        view\r\n        returns (address[] memory)\r\n    {\r\n        return investors[_id][quoteAddresses[_id]];\r\n    }\r\n\r\n    function baseUserInvestment(bytes32 _id, address _user)\r\n        public\r\n        view\r\n        returns (uint)\r\n    {\r\n        return investments[_id][baseAddresses[_id]][_user];\r\n    }\r\n\r\n    function quoteUserInvestment(bytes32 _id, address _user)\r\n        public\r\n        view\r\n        returns (uint)\r\n    {\r\n        return investments[_id][quoteAddresses[_id]][_user];\r\n    }\r\n\r\n    function _swap(bytes32 _id) internal {\r\n        require(!isSwapped[_id], \"Already swapped\");\r\n        require(!isCancelled[_id], \"Already cancelled\");\r\n        require(isBaseFilled(_id), \"Base tokens not filled\");\r\n        require(isQuoteFilled(_id), \"Quote tokens not filled\");\r\n        require(now <= expirationTimestamps[_id], \"Contract expired\");\r\n\r\n        _distribute(_id, baseAddresses[_id], quoteAddresses[_id]);\r\n        _distribute(_id, quoteAddresses[_id], baseAddresses[_id]);\r\n\r\n        isSwapped[_id] = true;\r\n        emit OrderSwapped(_id, msg.sender);\r\n    }\r\n\r\n    function _distribute(bytes32 _id, address _aSide, address _bSide) internal {\r\n        uint remainder = raised[_id][_bSide];\r\n        for (uint i = 0; i < investors[_id][_aSide].length; i++) {\r\n            address user = investors[_id][_aSide][i];\r\n            uint toPay;\r\n            // last\r\n            if (i + 1 == investors[_id][_aSide].length) {\r\n                toPay = remainder;\r\n            } else {\r\n                uint aSideRaised = raised[_id][_aSide];\r\n                uint userInvestment = investments[_id][_aSide][user];\r\n                uint bSideRaised = raised[_id][_bSide];\r\n                toPay = userInvestment.mul(bSideRaised).div(aSideRaised);\r\n                remainder = remainder.sub(toPay);\r\n            }\r\n\r\n            vault.withdraw(_bSide, user, toPay);\r\n            emit SwapSend(_id, _bSide, user, toPay);\r\n        }\r\n    }\r\n\r\n    function _removeInvestor(address[] storage _array, address _investor) internal {\r\n        uint idx = _array.length - 1;\r\n        for (uint i = 0; i < _array.length - 1; i++) {\r\n            if (_array[i] == _investor) {\r\n                idx = i;\r\n                break;\r\n            }\r\n        }\r\n\r\n        _array[idx] = _array[_array.length - 1];\r\n        delete _array[_array.length - 1];\r\n        _array.length--;\r\n    }\r\n\r\n    function _deposit(\r\n        bytes32 _id,\r\n        address _token,\r\n        address _from,\r\n        uint _amount\r\n    ) internal {\r\n        uint amount = _amount;\r\n        require(baseAddresses[_id] == _token || quoteAddresses[_id] == _token, \"You can deposit only base or quote currency\");\r\n        require(raised[_id][_token] < limits[_id][_token], \"Limit already reached\");\r\n        require(now <= expirationTimestamps[_id], \"Contract expired\");\r\n        if (baseAddresses[_id] == _token && baseOnlyInvestor[_id] != address(0)) {\r\n            require(msg.sender == baseOnlyInvestor[_id], \"Allowed only for specified address\");\r\n        }\r\n        if (limits[_id][_token].sub(raised[_id][_token]) > minInvestments[_id][_token]) {\r\n            require(_amount >= minInvestments[_id][_token], \"Should not be less than minimum value\");\r\n        }\r\n\r\n        if (!_isInvestor(_id, _token, _from)) {\r\n            require(investors[_id][_token].length < MAX_INVESTORS, \"Too many investors\");\r\n            investors[_id][_token].push(_from);\r\n        }\r\n\r\n        uint raisedWithOverflow = raised[_id][_token].add(amount);\r\n        if (raisedWithOverflow > limits[_id][_token]) {\r\n            uint overflow = raisedWithOverflow.sub(limits[_id][_token]);\r\n            vault.withdraw(_token, _from, overflow);\r\n            amount = amount.sub(overflow);\r\n        }\r\n\r\n        investments[_id][_token][_from] = investments[_id][_token][_from].add(amount);\r\n\r\n        raised[_id][_token] = raised[_id][_token].add(amount);\r\n        emit Deposit(\r\n            _id,\r\n            _token,\r\n            _from,\r\n            amount,\r\n            investments[_id][_token][_from]\r\n        );\r\n\r\n        if (isBaseFilled(_id) && isQuoteFilled(_id)) {\r\n            _swap(_id);\r\n        }\r\n    }\r\n\r\n    function _isInvestor(\r\n        bytes32 _id,\r\n        address _token,\r\n        address _who\r\n    )\r\n        internal\r\n        view\r\n        returns (bool)\r\n    {\r\n        return investments[_id][_token][_who] > 0;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"raised\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"isSwapped\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"quoteAddresses\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"expirationTimestamps\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"baseOnlyInvestor\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_id\",\"type\":\"bytes32\"}],\"name\":\"quoteInvestors\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_id\",\"type\":\"bytes32\"},{\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"refund\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_id\",\"type\":\"bytes32\"}],\"name\":\"quoteRaised\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"limits\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_vault\",\"type\":\"address\"}],\"name\":\"setVault\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_id\",\"type\":\"bytes32\"}],\"name\":\"isQuoteFilled\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_INVESTORS\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"},{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"investors\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"minInvestments\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_id\",\"type\":\"bytes32\"},{\"name\":\"_baseAddress\",\"type\":\"address\"},{\"name\":\"_quoteAddress\",\"type\":\"address\"},{\"name\":\"_baseLimit\",\"type\":\"uint256\"},{\"name\":\"_quoteLimit\",\"type\":\"uint256\"},{\"name\":\"_expirationTimestamp\",\"type\":\"uint256\"},{\"name\":\"_baseOnlyInvestor\",\"type\":\"address\"},{\"name\":\"_minBaseInvestment\",\"type\":\"uint256\"},{\"name\":\"_minQuoteInvestment\",\"type\":\"uint256\"}],\"name\":\"createOrder\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"isCancelled\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_id\",\"type\":\"bytes32\"}],\"name\":\"baseLimit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_id\",\"type\":\"bytes32\"}],\"name\":\"baseInvestors\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_id\",\"type\":\"bytes32\"}],\"name\":\"baseRaised\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"tokenFallback\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_id\",\"type\":\"bytes32\"}],\"name\":\"quoteLimit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_id\",\"type\":\"bytes32\"}],\"name\":\"cancel\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"createKey\",\"outputs\":[{\"name\":\"result\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_id\",\"type\":\"bytes32\"},{\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"baseUserInvestment\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"},{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"investments\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_id\",\"type\":\"bytes32\"}],\"name\":\"isBaseFilled\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_id\",\"type\":\"bytes32\"},{\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"quoteUserInvestment\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_id\",\"type\":\"bytes32\"},{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"baseAddresses\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"owners\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"vault\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"id\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"baseAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"quoteAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"baseLimit\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"quoteLimit\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"expirationTimestamp\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"baseOnlyInvestor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"minBaseInvestment\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"minQuoteInvestment\",\"type\":\"uint256\"}],\"name\":\"OrderCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"id\",\"type\":\"bytes32\"}],\"name\":\"OrderCancelled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"id\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"balance\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"id\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Refund\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"id\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"byUser\",\"type\":\"address\"}],\"name\":\"OrderSwapped\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"id\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"SwapSend\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"Swaps","CompilerVersion":"v0.5.7+commit.6da8b019","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://19b74a4b314ae295b408cadad75b2df2856ad2ea309117a40fedbb99092c9c7c"}]}