{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.24;\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC20/ERC20Basic.sol\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * See https://github.com/ethereum/EIPs/issues/179\r\n */\r\ncontract ERC20Basic {\r\n  function totalSupply() public view returns (uint256);\r\n  function balanceOf(address _who) public view returns (uint256);\r\n  function transfer(address _to, uint256 _value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC20/ERC20.sol\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address _owner, address _spender)\r\n    public view returns (uint256);\r\n\r\n  function transferFrom(address _from, address _to, uint256 _value)\r\n    public returns (bool);\r\n\r\n  function approve(address _spender, uint256 _value) public returns (bool);\r\n  event Approval(\r\n    address indexed owner,\r\n    address indexed spender,\r\n    uint256 value\r\n  );\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC20/SafeERC20.sol\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure.\r\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n  function safeTransfer(\r\n    ERC20Basic _token,\r\n    address _to,\r\n    uint256 _value\r\n  )\r\n    internal\r\n  {\r\n    require(_token.transfer(_to, _value));\r\n  }\r\n\r\n  function safeTransferFrom(\r\n    ERC20 _token,\r\n    address _from,\r\n    address _to,\r\n    uint256 _value\r\n  )\r\n    internal\r\n  {\r\n    require(_token.transferFrom(_from, _to, _value));\r\n  }\r\n\r\n  function safeApprove(\r\n    ERC20 _token,\r\n    address _spender,\r\n    uint256 _value\r\n  )\r\n    internal\r\n  {\r\n    require(_token.approve(_spender, _value));\r\n  }\r\n}\r\n\r\n// File: zos-lib/contracts/Initializable.sol\r\n\r\n/**\r\n * @title Initializable\r\n *\r\n * @dev Helper contract to support initializer functions. To use it, replace\r\n * the constructor with a function that has the `initializer` modifier.\r\n * WARNING: Unlike constructors, initializer functions must be manually\r\n * invoked. This applies both to deploying an Initializable contract, as well\r\n * as extending an Initializable contract via inheritance.\r\n * WARNING: When used with inheritance, manual care must be taken to not invoke\r\n * a parent initializer twice, or ensure that all initializers are idempotent,\r\n * because this is not dealt with automatically as with constructors.\r\n */\r\ncontract Initializable {\r\n\r\n  /**\r\n   * @dev Indicates that the contract has been initialized.\r\n   */\r\n  bool private initialized;\r\n\r\n  /**\r\n   * @dev Indicates that the contract is in the process of being initialized.\r\n   */\r\n  bool private initializing;\r\n\r\n  /**\r\n   * @dev Modifier to use in the initializer function of a contract.\r\n   */\r\n  modifier initializer() {\r\n    require(initializing || isConstructor() || !initialized, \"Contract instance has already been initialized\");\r\n\r\n    bool wasInitializing = initializing;\r\n    initializing = true;\r\n    initialized = true;\r\n\r\n    _;\r\n\r\n    initializing = wasInitializing;\r\n  }\r\n\r\n  /// @dev Returns true if and only if the function is running in the constructor\r\n  function isConstructor() private view returns (bool) {\r\n    // extcodesize checks the size of the code stored in an address, and\r\n    // address returns the current address. Since the code is still not\r\n    // deployed when running a constructor, any checks on its code size will\r\n    // yield zero, making it an effective way to detect if a contract is\r\n    // under construction or not.\r\n    uint256 cs;\r\n    assembly { cs := extcodesize(address) }\r\n    return cs == 0;\r\n  }\r\n\r\n  // Reserved storage space to allow for layout changes in the future.\r\n  uint256[50] private ______gap;\r\n}\r\n\r\n// File: openzeppelin-eth/contracts/ownership/Ownable.sol\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable is Initializable {\r\n  address private _owner;\r\n\r\n\r\n  event OwnershipRenounced(address indexed previousOwner);\r\n  event OwnershipTransferred(\r\n    address indexed previousOwner,\r\n    address indexed newOwner\r\n  );\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  function initialize(address sender) public initializer {\r\n    _owner = sender;\r\n  }\r\n\r\n  /**\r\n   * @return the address of the owner.\r\n   */\r\n  function owner() public view returns(address) {\r\n    return _owner;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(isOwner());\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @return true if `msg.sender` is the owner of the contract.\r\n   */\r\n  function isOwner() public view returns(bool) {\r\n    return msg.sender == _owner;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to relinquish control of the contract.\r\n   * @notice Renouncing to ownership will leave the contract without an owner.\r\n   * It will not be possible to call the functions with the `onlyOwner`\r\n   * modifier anymore.\r\n   */\r\n  function renounceOwnership() public onlyOwner {\r\n    emit OwnershipRenounced(_owner);\r\n    _owner = address(0);\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    _transferOwnership(newOwner);\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function _transferOwnership(address newOwner) internal {\r\n    require(newOwner != address(0));\r\n    emit OwnershipTransferred(_owner, newOwner);\r\n    _owner = newOwner;\r\n  }\r\n\r\n  uint256[50] private ______gap;\r\n}\r\n\r\n// File: openzeppelin-eth/contracts/math/SafeMath.sol\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, reverts on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    uint256 c = a * b;\r\n    require(c / a == b);\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b > 0); // Solidity only automatically asserts when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b <= a);\r\n    uint256 c = a - b;\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, reverts on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    require(c >= a);\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\r\n  * reverts when dividing by zero.\r\n  */\r\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b != 0);\r\n    return a % b;\r\n  }\r\n}\r\n\r\n// File: contracts/library/OperationStore.sol\r\n\r\nlibrary OperationStore {\r\n\r\n    /**\r\n     * @notice Stores historical integer data\r\n     * @param _history History of stored int data in format time1, value1, time2, value2, time3...\r\n     * @param _value Value to be stored\r\n     */\r\n    function storeInt(uint256[] storage _history, uint256 _value) internal {\r\n        _history.push(block.timestamp);\r\n        _history.push(_value);\r\n    }\r\n\r\n    /**\r\n     * @notice Returns integer value for specified time\r\n     * @param _history History of stored int data in format time1, value1, time2, value2, time3...\r\n     * @param _timestamp Time for which we get value\r\n     */\r\n    function getInt(uint256[] memory _history, uint256 _timestamp) internal pure returns (uint256) {\r\n        uint256 index = findIndex(_history, _timestamp, 2);\r\n        if (index > 0) {\r\n            return _history[index - 1];\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     * @notice Stores historical boolean data\r\n     * @param _history History of stored boolean data in format: new record each times value changed (time1, time2...)\r\n     * @param _value Value to be stored\r\n     */\r\n    function storeBool(uint256[] storage _history, bool _value) internal {\r\n        bool current = (_history.length % 2 == 1);\r\n        if (current != _value) {\r\n            _history.push(block.timestamp);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Returns boolean value for specified time\r\n     * @param _history History of stored boolean data in format: new record each times value changed (time1, time2...)\r\n     * @param _timestamp Time for which we get value\r\n     */\r\n    function getBool(uint256[] memory _history, uint256 _timestamp) internal pure returns (bool) {\r\n        return findIndex(_history, _timestamp, 1) % 2 == 1;\r\n    }\r\n\r\n    /**\r\n     * @notice Stores historical timestamp data\r\n     * @param _history History of stored timestamp data in format: time1, time2, time3...\r\n     * @param _value Value to be stored\r\n     */\r\n    function storeTimestamp(uint256[] storage _history, uint256 _value) internal {\r\n        _history.push(_value);\r\n    }\r\n\r\n    /**\r\n     * @notice Returns last timestamp value for specified time\r\n     * @param _history History of stored timestamp data in format: time1, time2, time3...\r\n     * @param _timestamp Time for which we get value\r\n     */\r\n    function getTimestamp(uint256[] memory _history, uint256 _timestamp) internal pure returns (uint256) {\r\n        uint256 index = findIndex(_history, _timestamp, 1);\r\n        if (index > 0) {\r\n            return _history[index - 1];\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     * @notice Searches for index of timestamp with specified step\r\n     * @dev History elements is sorted so binary search is used.\r\n     * @param _history History of stored timestamp data in format: time1, time2, time3...\r\n     * @param _timestamp Time for which we get value\r\n     * @param _step Step used for binary search. For bool & timestamp steps is 1, for uint step is 2\r\n     */\r\n    function findIndex(uint256[] memory _history, uint256 _timestamp, uint256 _step) internal pure returns (uint256) {\r\n        if (_history.length == 0) {\r\n            return 0;\r\n        }\r\n        uint256 low = 0;\r\n        uint256 high = _history.length - _step;\r\n\r\n        while (low <= high) {\r\n            uint256 mid = ((low + high) >> _step) << (_step - 1);\r\n            uint256 midVal = _history[mid];\r\n            if (midVal < _timestamp) {\r\n                low = mid + _step;\r\n            } else if (midVal > _timestamp) {\r\n                if (mid == 0) {\r\n                    return 0;\r\n                    // min key\r\n                }\r\n                high = mid - _step;\r\n            } else {\r\n                // take the last one if there are many same items\r\n                uint256 result = mid + _step;\r\n                while (result < _history.length && _history[result] == _timestamp) {\r\n                    result = result + _step;\r\n                }\r\n                // key found\r\n                return result;\r\n            }\r\n        }\r\n        // key not found\r\n        return low;\r\n    }\r\n\r\n}\r\n\r\n// File: zos-lib/contracts/upgradeability/Proxy.sol\r\n\r\n/**\r\n * @title Proxy\r\n * @dev Implements delegation of calls to other contracts, with proper\r\n * forwarding of return values and bubbling of failures.\r\n * It defines a fallback function that delegates all calls to the address\r\n * returned by the abstract _implementation() internal function.\r\n */\r\ncontract Proxy {\r\n  /**\r\n   * @dev Fallback function.\r\n   * Implemented entirely in `_fallback`.\r\n   */\r\n  function () payable external {\r\n    _fallback();\r\n  }\r\n\r\n  /**\r\n   * @return The Address of the implementation.\r\n   */\r\n  function _implementation() internal view returns (address);\r\n\r\n  /**\r\n   * @dev Delegates execution to an implementation contract.\r\n   * This is a low level function that doesn't return to its internal call site.\r\n   * It will return to the external caller whatever the implementation returns.\r\n   * @param implementation Address to delegate.\r\n   */\r\n  function _delegate(address implementation) internal {\r\n    assembly {\r\n      // Copy msg.data. We take full control of memory in this inline assembly\r\n      // block because it will not return to Solidity code. We overwrite the\r\n      // Solidity scratch pad at memory position 0.\r\n      calldatacopy(0, 0, calldatasize)\r\n\r\n      // Call the implementation.\r\n      // out and outsize are 0 because we don't know the size yet.\r\n      let result := delegatecall(gas, implementation, 0, calldatasize, 0, 0)\r\n\r\n      // Copy the returned data.\r\n      returndatacopy(0, 0, returndatasize)\r\n\r\n      switch result\r\n      // delegatecall returns 0 on error.\r\n      case 0 { revert(0, returndatasize) }\r\n      default { return(0, returndatasize) }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Function that is run as the first thing in the fallback function.\r\n   * Can be redefined in derived contracts to add functionality.\r\n   * Redefinitions must call super._willFallback().\r\n   */\r\n  function _willFallback() internal {\r\n  }\r\n\r\n  /**\r\n   * @dev fallback implementation.\r\n   * Extracted to enable manual triggering.\r\n   */\r\n  function _fallback() internal {\r\n    _willFallback();\r\n    _delegate(_implementation());\r\n  }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/AddressUtils.sol\r\n\r\n/**\r\n * Utility library of inline functions on addresses\r\n */\r\nlibrary AddressUtils {\r\n\r\n  /**\r\n   * Returns whether the target address is a contract\r\n   * @dev This function will return false if invoked during the constructor of a contract,\r\n   * as the code is not actually created until after the constructor finishes.\r\n   * @param _addr address to check\r\n   * @return whether the target address is a contract\r\n   */\r\n  function isContract(address _addr) internal view returns (bool) {\r\n    uint256 size;\r\n    // XXX Currently there is no better way to check if there is a contract in an address\r\n    // than to check the size of the code at that address.\r\n    // See https://ethereum.stackexchange.com/a/14016/36603\r\n    // for more details about how this works.\r\n    // TODO Check this again before the Serenity release, because all addresses will be\r\n    // contracts then.\r\n    // solium-disable-next-line security/no-inline-assembly\r\n    assembly { size := extcodesize(_addr) }\r\n    return size > 0;\r\n  }\r\n\r\n}\r\n\r\n// File: zos-lib/contracts/upgradeability/UpgradeabilityProxy.sol\r\n\r\n/**\r\n * @title UpgradeabilityProxy\r\n * @dev This contract implements a proxy that allows to change the\r\n * implementation address to which it will delegate.\r\n * Such a change is called an implementation upgrade.\r\n */\r\ncontract UpgradeabilityProxy is Proxy {\r\n  /**\r\n   * @dev Emitted when the implementation is upgraded.\r\n   * @param implementation Address of the new implementation.\r\n   */\r\n  event Upgraded(address indexed implementation);\r\n\r\n  /**\r\n   * @dev Storage slot with the address of the current implementation.\r\n   * This is the keccak-256 hash of \"org.zeppelinos.proxy.implementation\", and is\r\n   * validated in the constructor.\r\n   */\r\n  bytes32 private constant IMPLEMENTATION_SLOT = 0x7050c9e0f4ca769c69bd3a8ef740bc37934f8e2c036e5a723fd8ee048ed3f8c3;\r\n\r\n  /**\r\n   * @dev Contract constructor.\r\n   * @param _implementation Address of the initial implementation.\r\n   * @param _data Data to send as msg.data to the implementation to initialize the proxied contract.\r\n   * It should include the signature and the parameters of the function to be called, as described in\r\n   * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\r\n   * This parameter is optional, if no data is given the initialization call to proxied contract will be skipped.\r\n   */\r\n  constructor(address _implementation, bytes _data) public payable {\r\n    assert(IMPLEMENTATION_SLOT == keccak256(\"org.zeppelinos.proxy.implementation\"));\r\n    _setImplementation(_implementation);\r\n    if(_data.length > 0) {\r\n      require(_implementation.delegatecall(_data));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the current implementation.\r\n   * @return Address of the current implementation\r\n   */\r\n  function _implementation() internal view returns (address impl) {\r\n    bytes32 slot = IMPLEMENTATION_SLOT;\r\n    assembly {\r\n      impl := sload(slot)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Upgrades the proxy to a new implementation.\r\n   * @param newImplementation Address of the new implementation.\r\n   */\r\n  function _upgradeTo(address newImplementation) internal {\r\n    _setImplementation(newImplementation);\r\n    emit Upgraded(newImplementation);\r\n  }\r\n\r\n  /**\r\n   * @dev Sets the implementation address of the proxy.\r\n   * @param newImplementation Address of the new implementation.\r\n   */\r\n  function _setImplementation(address newImplementation) private {\r\n    require(AddressUtils.isContract(newImplementation), \"Cannot set a proxy implementation to a non-contract address\");\r\n\r\n    bytes32 slot = IMPLEMENTATION_SLOT;\r\n\r\n    assembly {\r\n      sstore(slot, newImplementation)\r\n    }\r\n  }\r\n}\r\n\r\n// File: zos-lib/contracts/upgradeability/AdminUpgradeabilityProxy.sol\r\n\r\n/**\r\n * @title AdminUpgradeabilityProxy\r\n * @dev This contract combines an upgradeability proxy with an authorization\r\n * mechanism for administrative tasks.\r\n * All external functions in this contract must be guarded by the\r\n * `ifAdmin` modifier. See ethereum/solidity#3864 for a Solidity\r\n * feature proposal that would enable this to be done automatically.\r\n */\r\ncontract AdminUpgradeabilityProxy is UpgradeabilityProxy {\r\n  /**\r\n   * @dev Emitted when the administration has been transferred.\r\n   * @param previousAdmin Address of the previous admin.\r\n   * @param newAdmin Address of the new admin.\r\n   */\r\n  event AdminChanged(address previousAdmin, address newAdmin);\r\n\r\n  /**\r\n   * @dev Storage slot with the admin of the contract.\r\n   * This is the keccak-256 hash of \"org.zeppelinos.proxy.admin\", and is\r\n   * validated in the constructor.\r\n   */\r\n  bytes32 private constant ADMIN_SLOT = 0x10d6a54a4754c8869d6886b5f5d7fbfa5b4522237ea5c60d11bc4e7a1ff9390b;\r\n\r\n  /**\r\n   * @dev Modifier to check whether the `msg.sender` is the admin.\r\n   * If it is, it will run the function. Otherwise, it will delegate the call\r\n   * to the implementation.\r\n   */\r\n  modifier ifAdmin() {\r\n    if (msg.sender == _admin()) {\r\n      _;\r\n    } else {\r\n      _fallback();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Contract constructor.\r\n   * It sets the `msg.sender` as the proxy administrator.\r\n   * @param _implementation address of the initial implementation.\r\n   * @param _data Data to send as msg.data to the implementation to initialize the proxied contract.\r\n   * It should include the signature and the parameters of the function to be called, as described in\r\n   * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\r\n   * This parameter is optional, if no data is given the initialization call to proxied contract will be skipped.\r\n   */\r\n  constructor(address _implementation, bytes _data) UpgradeabilityProxy(_implementation, _data) public payable {\r\n    assert(ADMIN_SLOT == keccak256(\"org.zeppelinos.proxy.admin\"));\r\n\r\n    _setAdmin(msg.sender);\r\n  }\r\n\r\n  /**\r\n   * @return The address of the proxy admin.\r\n   */\r\n  function admin() external view ifAdmin returns (address) {\r\n    return _admin();\r\n  }\r\n\r\n  /**\r\n   * @return The address of the implementation.\r\n   */\r\n  function implementation() external view ifAdmin returns (address) {\r\n    return _implementation();\r\n  }\r\n\r\n  /**\r\n   * @dev Changes the admin of the proxy.\r\n   * Only the current admin can call this function.\r\n   * @param newAdmin Address to transfer proxy administration to.\r\n   */\r\n  function changeAdmin(address newAdmin) external ifAdmin {\r\n    require(newAdmin != address(0), \"Cannot change the admin of a proxy to the zero address\");\r\n    emit AdminChanged(_admin(), newAdmin);\r\n    _setAdmin(newAdmin);\r\n  }\r\n\r\n  /**\r\n   * @dev Upgrade the backing implementation of the proxy.\r\n   * Only the admin can call this function.\r\n   * @param newImplementation Address of the new implementation.\r\n   */\r\n  function upgradeTo(address newImplementation) external ifAdmin {\r\n    _upgradeTo(newImplementation);\r\n  }\r\n\r\n  /**\r\n   * @dev Upgrade the backing implementation of the proxy and call a function\r\n   * on the new implementation.\r\n   * This is useful to initialize the proxied contract.\r\n   * @param newImplementation Address of the new implementation.\r\n   * @param data Data to send as msg.data in the low level call.\r\n   * It should include the signature and the parameters of the function to be called, as described in\r\n   * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\r\n   */\r\n  function upgradeToAndCall(address newImplementation, bytes data) payable external ifAdmin {\r\n    _upgradeTo(newImplementation);\r\n    require(newImplementation.delegatecall(data));\r\n  }\r\n\r\n  /**\r\n   * @return The admin slot.\r\n   */\r\n  function _admin() internal view returns (address adm) {\r\n    bytes32 slot = ADMIN_SLOT;\r\n    assembly {\r\n      adm := sload(slot)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Sets the address of the proxy admin.\r\n   * @param newAdmin Address of the new proxy admin.\r\n   */\r\n  function _setAdmin(address newAdmin) internal {\r\n    bytes32 slot = ADMIN_SLOT;\r\n\r\n    assembly {\r\n      sstore(slot, newAdmin)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Only fall back when the sender is not the admin.\r\n   */\r\n  function _willFallback() internal {\r\n    require(msg.sender != _admin(), \"Cannot call fallback function from the proxy admin\");\r\n    super._willFallback();\r\n  }\r\n}\r\n\r\n// File: contracts/upgradeability/OwnedUpgradeabilityProxy.sol\r\n\r\n/**\r\n * @title OwnedUpgradeabilityProxy\r\n * @notice This contract combines an upgradeability proxy with an authorization\r\n * mechanism for administrative tasks.\r\n * All external functions in this contract must be guarded by the\r\n * `ifAdmin` modifier. See ethereum/solidity#3864 for a Solidity\r\n * feature proposal that would enable this to be done automatically.\r\n */\r\ncontract OwnedUpgradeabilityProxy is AdminUpgradeabilityProxy {\r\n\r\n    /**\r\n     * Contract constructor.\r\n     * It sets the `msg.sender` as the proxy administrator.\r\n     * @param _implementation address of the initial implementation.\r\n     */\r\n    constructor(address _implementation) AdminUpgradeabilityProxy(_implementation, \"\") public {\r\n    }\r\n\r\n    /**\r\n     * @notice Only fall back when the sender is not the admin.\r\n     */\r\n    function _willFallback() internal {\r\n    }\r\n}\r\n\r\n// File: contracts/library/Conversions.sol\r\n\r\nlibrary Conversions {\r\n\r\n    /**\r\n     * @notice Converts bytes20 to string\r\n     */\r\n    function bytes20ToString(bytes20 _input) internal pure returns (string) {\r\n        bytes memory bytesString = new bytes(20);\r\n        uint256 charCount = 0;\r\n        for (uint256 index = 0; index < 20; index++) {\r\n            byte char = byte(bytes20(uint256(_input) * 2 ** (8 * index)));\r\n            if (char != 0) {\r\n                bytesString[charCount] = char;\r\n                charCount++;\r\n            }\r\n        }\r\n        bytes memory bytesStringTrimmed = new bytes(charCount);\r\n        for (index = 0; index < charCount; index++) {\r\n            bytesStringTrimmed[index] = bytesString[index];\r\n        }\r\n        return string(bytesStringTrimmed);\r\n    }\r\n\r\n}\r\n\r\n// File: contracts/governance/GovernanceReference.sol\r\n\r\n/**\r\n* @title Governance reference to be used in other contracts\r\n*/\r\ninterface GovernanceReference {\r\n\r\n    /**\r\n    * @notice Make a proposal to add/remove specified delegate to the blacklist\r\n    */\r\n    function submitBlacklistProposal(bytes32 _id, address _delegate, bool _blacklisted) external;\r\n\r\n    /**\r\n    * @notice Make a proposal to add/remove specified delegate to the blacklist\r\n    */\r\n    function submitActivateProposal(bytes32 _id) external;\r\n\r\n    /**\r\n    * @notice Vote in favor or against blacklist proposal with the specified identifier\r\n    */\r\n    function vote(bytes32 _id, bool _inFavor) external;\r\n\r\n    /**\r\n    * @notice Finalize voting and apply proposed changes if success.\r\n    * This method will fail if voting period is not over.\r\n    */\r\n    function finalizeVoting(bytes32 _id) external;\r\n\r\n    /**\r\n    * @notice Checks if delegate is known by governance (was created by governance)\r\n    */\r\n    function isDelegateKnown(address _delegate) external view returns (bool);\r\n\r\n    /**\r\n    * @notice Unregisters delegate\r\n    */\r\n    function unregisterDelegate() external;\r\n\r\n}\r\n\r\n// File: contracts/governance/DelegateReference.sol\r\n\r\n/**\r\n* @title Delegate reference to be used in other contracts\r\n*/\r\ninterface DelegateReference {\r\n    /**\r\n    * @notice Stake specified amount of tokens to the delegate to participate in coin distribution\r\n    */\r\n    function stake(uint256 _amount) external;\r\n\r\n    /**\r\n    * @notice Unstake specified amount of tokens from the delegate\r\n    */\r\n    function unstake(uint256 _amount) external;\r\n\r\n    /**\r\n    * @notice Return number of tokens staked by the specified staker\r\n    */\r\n    function stakeOf(address _staker) external view returns (uint256);\r\n\r\n    /**\r\n    * @notice Sets Aerum address for delegate & calling staker\r\n    */\r\n    function setAerumAddress(address _aerum) external;\r\n}\r\n\r\n// File: contracts/governance/Delegate.sol\r\n\r\n/**\r\n * @title Ethereum-based contract for delegate\r\n */\r\ncontract Delegate is DelegateReference, Initializable, Ownable {\r\n    using SafeMath for uint256;\r\n    using SafeERC20 for ERC20;\r\n    using OperationStore for uint256[];\r\n    using Conversions for bytes20;\r\n\r\n    /** AER token **/\r\n    ERC20 public token;\r\n\r\n    /** Governance address **/\r\n    GovernanceReference public governance;\r\n\r\n    /** Aerum address used for coin distribution **/\r\n    address public aerum;\r\n\r\n    /** Description name of the delegate **/\r\n    bytes20 public name;\r\n\r\n    /** Stake per user address in the delegate **/\r\n    mapping(address => uint256) public stakes;\r\n\r\n    /** Aerum address per ethereum address in the delegate **/\r\n    mapping(address => address) public stakerAerumAddress;\r\n\r\n    /** Number of staked tokens locked to participate in coin distribution **/\r\n    uint256 public lockedStake;\r\n\r\n    uint256[] stakeHistory;\r\n    uint256[] keepAliveHistory;\r\n    uint256[] blacklistHistory;\r\n    uint256[] activationHistory;\r\n\r\n    event AerumAddressUpdated(address aerum);\r\n    event KeepAlive(uint256 timestamp);\r\n    event BlacklistUpdated(bool blocked);\r\n    event IsActiveUpdated(bool active);\r\n\r\n    event Staked(address indexed staker, uint256 amount);\r\n    event Unstaked(address indexed staker, uint256 amount);\r\n    event StakeLocked(uint256 amount);\r\n\r\n    /** Check if the sender is a valid delegate **/\r\n    modifier onlyGovernance {\r\n        require(msg.sender == address(governance));\r\n        _;\r\n    }\r\n\r\n    /** Check if the sender is a valid delegate or owner **/\r\n    modifier onlyOwnerOrGovernance {\r\n        require((msg.sender == address(governance)) || (msg.sender == owner()));\r\n        _;\r\n    }\r\n\r\n    /** Check if delegate is approved **/\r\n    modifier onlyForApprovedDelegate() {\r\n        require(activationHistory.getBool(block.timestamp));\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @notice Delegate initializer\r\n    * @dev This init is called by governance when created\r\n    * @param _owner Delegate owner address\r\n    * @param _token XRM token address\r\n    * @param _name Delegate name\r\n    * @param _aerum Delegate Aerum address\r\n    */\r\n    function init(address _owner, ERC20 _token, bytes20 _name, address _aerum) initializer public {\r\n        Ownable.initialize(_owner);\r\n        token = _token;\r\n        name = _name;\r\n        aerum = _aerum;\r\n        governance = GovernanceReference(msg.sender);\r\n    }\r\n\r\n    /**\r\n    * @notice Returns delegate name as string\r\n    */\r\n    function getName() public view returns (string) {\r\n        return name.bytes20ToString();\r\n    }\r\n\r\n    /**\r\n    * @notice Notify governance contract this delegate is still alive\r\n    */\r\n    function keepAlive() external onlyOwner {\r\n        keepAliveHistory.storeTimestamp(block.timestamp);\r\n        emit KeepAlive(block.timestamp);\r\n    }\r\n\r\n    /**\r\n    * @notice Timestamp of the last keep alive message before the given timestamp\r\n    * @param _timestamp Time for which we would like to check last keep alive call\r\n    */\r\n    function getKeepAliveTimestamp(uint256 _timestamp) public view returns (uint256) {\r\n        return keepAliveHistory.getTimestamp(_timestamp);\r\n    }\r\n\r\n    /**\r\n    * @notice Sets Aerum address for specific staker\r\n    * @param _aerum Aerum address\r\n    */\r\n    function setAerumAddress(address _aerum) external {\r\n        require(stakes[msg.sender] > 0);\r\n        stakerAerumAddress[msg.sender] = _aerum;\r\n        emit AerumAddressUpdated(_aerum);\r\n    }\r\n\r\n    /**\r\n    * @notice Returns Aerum address for specific staker\r\n    * @param _staker Staker address\r\n    */\r\n    function getAerumAddress(address _staker) external view returns (address) {\r\n        return stakerAerumAddress[_staker];\r\n    }\r\n\r\n    /**\r\n    * @notice Change delegate status in the blacklist\r\n    * @param _blocked Is delegate blacklisted or not\r\n    */\r\n    function updateBlacklist(bool _blocked) external onlyGovernance {\r\n        blacklistHistory.storeBool(_blocked);\r\n        emit BlacklistUpdated(_blocked);\r\n    }\r\n\r\n    /**\r\n    * @notice Whether this delegate was blacklisted at the given timestamp\r\n    * @param _timestamp Time for which we would like to check blacklisted\r\n    */\r\n    function isBlacklisted(uint256 _timestamp) public view returns (bool) {\r\n        return blacklistHistory.getBool(_timestamp);\r\n    }\r\n\r\n    /**\r\n    * @notice Change delegate activations status\r\n    * @param _active Is delegate active or not\r\n    */\r\n    function setActive(bool _active) external onlyGovernance {\r\n        activationHistory.storeBool(_active);\r\n        emit IsActiveUpdated(_active);\r\n    }\r\n\r\n    /**\r\n    * @notice Whether this delegate was activated at the given timestamp\r\n    * @param _timestamp Time for which we would like to check activation status\r\n    */\r\n    function isActive(uint256 _timestamp) external view returns (bool) {\r\n        return activationHistory.getBool(_timestamp);\r\n    }\r\n\r\n    /**\r\n    * @notice Deactivate delegate and return bond back\r\n    */\r\n    function deactivate() external onlyOwner {\r\n        governance.unregisterDelegate();\r\n    }\r\n\r\n    /**\r\n    * @notice Stake specified amount of tokens to the delegate to participate in coin distribution\r\n    * @param _amount Amount to stake\r\n    */\r\n    function stake(uint256 _amount) external onlyForApprovedDelegate() {\r\n        address staker = msg.sender;\r\n        token.safeTransferFrom(staker, this, _amount);\r\n        stakes[staker] = stakes[staker].add(_amount);\r\n        emit Staked(staker, _amount);\r\n    }\r\n\r\n    /**\r\n    * @notice Unstake specified amount of tokens from the delegate\r\n    * @param _amount Amount to unstake\r\n    */\r\n    function unstake(uint256 _amount) external {\r\n        address staker = msg.sender;\r\n        require(stakes[staker] >= _amount);\r\n        require(token.balanceOf(this).sub(_amount) >= lockedStake);\r\n        token.safeTransfer(staker, _amount);\r\n        stakes[staker] = stakes[staker].sub(_amount);\r\n        emit Unstaked(staker, _amount);\r\n    }\r\n\r\n    /**\r\n    * @notice Return number of tokens staked by the specified staker\r\n    * @param _staker Staker address\r\n    */\r\n    function stakeOf(address _staker) external view returns (uint256) {\r\n        return stakes[_staker];\r\n    }\r\n\r\n    /**\r\n    * @notice Lock specified number of tokens in the Governance contract\r\n    * @param _amount Amount to lock\r\n    */\r\n    function lockStake(uint256 _amount) external onlyOwnerOrGovernance {\r\n        require(token.balanceOf(this) >= _amount);\r\n        stakeHistory.storeInt(_amount);\r\n        lockedStake = _amount;\r\n        emit StakeLocked(_amount);\r\n    }\r\n\r\n    /**\r\n    * @notice Delegate stake at the given timestamp\r\n    * @param _timestamp Time for which we would like to check stake\r\n    */\r\n    function getStake(uint256 _timestamp) public view returns (uint256) {\r\n        return stakeHistory.getInt(_timestamp);\r\n    }\r\n\r\n    /**\r\n    * @notice Make a proposal to add/remove specified delegate to the blacklist\r\n    * @param _id Proposal / voting id. Should be unique\r\n    * @param _delegate Delegate which is affected by proposal\r\n    * @param _blacklisted Blacklist or undo blacklist delegate\r\n    */\r\n    function submitBlacklistProposal(bytes32 _id, address _delegate, bool _blacklisted) external onlyOwner {\r\n        governance.submitBlacklistProposal(_id, _delegate, _blacklisted);\r\n    }\r\n\r\n    /**\r\n    * @notice Make a proposal to activate delegate. Can only be done delegate owner\r\n    * @param _id Proposal / voting id\r\n    */\r\n    function submitActivateProposal(bytes32 _id) external onlyOwner {\r\n        governance.submitActivateProposal(_id);\r\n    }\r\n\r\n    /**\r\n    * @notice Vote in favor or against blacklist proposal with the specified identifier\r\n    * @param _id Proposal / voting id\r\n    * @param _inFavor Support or do not support proposal\r\n    */\r\n    function vote(bytes32 _id, bool _inFavor) external onlyOwner {\r\n        governance.vote(_id, _inFavor);\r\n    }\r\n\r\n    /**\r\n    * @notice Finalize voting and apply proposed changes if success.\r\n    * This method will fail if voting period is not over.\r\n    * @param _id Proposal / voting id\r\n    */\r\n    function finalizeVoting(bytes32 _id) external {\r\n        governance.finalizeVoting(_id);\r\n    }\r\n\r\n}\r\n\r\n// File: contracts\\governance\\Governance.sol\r\n\r\n/**\r\n * @title Ethereum-based governance contract\r\n */\r\ncontract Governance is GovernanceReference, Initializable, Ownable {\r\n    using SafeMath for uint256;\r\n    using SafeERC20 for ERC20;\r\n    using OperationStore for uint256[];\r\n\r\n    /** Period when delegates can vote from proposal submission. Hardcoded to week */\r\n    uint256 constant votingPeriod = 60 * 60 * 24 * 7;\r\n    /** Number of Aerum blocks when composers are updated */\r\n    uint256 constant delegatesUpdateAerumBlocksPeriod = 1000;\r\n    /** Bond required for delegate to be registered. Should be set to 100k */\r\n    uint256 public delegateBond;\r\n\r\n    /** User used to upgrade governance or delegate contracts. Owner by default */\r\n    address public upgradeAdmin;\r\n    /** User which can approve delegates on initial phase. Owner by default */\r\n    address public delegateApprover;\r\n    /** Is delegate approver renounced. If yes we won't be able to set it again */\r\n    bool public delegateApproverRenounced;\r\n\r\n    /** XRM token */\r\n    ERC20 public token;\r\n\r\n    /** List of all delegates */\r\n    address[] public delegates;\r\n    /** Mapping of all known delegates. It's used to quickly check if it's known delegate */\r\n    mapping(address => bool) public knownDelegates;\r\n    /** List of bonds known by delegate */\r\n    mapping(address => uint256) public bonds;\r\n\r\n    /** Min stake required to be valid delegate. We should keep full history for consensus */\r\n    uint256[] public minBalance;\r\n    /** Keep alive duration in which delegate should call keep alive method to be valid. We should keep full history for consensus */\r\n    uint256[] public keepAliveDuration;\r\n    /** Composers count. We should keep full history for consensus */\r\n    uint256[] public composersCount;\r\n\r\n    enum VotingCategory { BLACKLIST, ACTIVATE }\r\n\r\n    struct Voting {\r\n        bytes32 id;\r\n        VotingCategory category;\r\n        uint256 timestamp;\r\n        address delegate;\r\n        bool proposal;\r\n        mapping(address => bool) votes;\r\n        address[] voters;\r\n    }\r\n\r\n    /** List of active votings */\r\n    mapping(bytes32 => Voting) public votings;\r\n\r\n    event UpgradeAdminUpdated(address admin);\r\n    event DelegateApproverUpdated(address admin);\r\n    event DelegateApproverRenounced();\r\n\r\n    event MinBalanceUpdated(uint256 balance);\r\n    event KeepAliveDurationUpdated(uint256 duration);\r\n    event ComposersCountUpdated(uint256 count);\r\n    event BlacklistUpdated(address indexed delegate, bool blocked);\r\n\r\n    event DelegateCreated(address indexed delegate, address indexed owner);\r\n    event DelegateApproved(address indexed delegate);\r\n    event DelegateUnregistered(address indexed delegate);\r\n    event BondSent(address indexed delegate, uint256 amount);\r\n    event StakeLocked(address indexed delegate, uint256 amount);\r\n\r\n    event ProposalSubmitted(bytes32 indexed id, address indexed author, address indexed delegate, VotingCategory category, bool proposal);\r\n    event Vote(bytes32 indexed id, address indexed voter, bool inFavor);\r\n    event VotingFinalized(bytes32 indexed id, bool voted, bool supported);\r\n\r\n    /** Check if delegate is known **/\r\n    modifier onlyOwnerOrDelegateApprover() {\r\n        require((owner() == msg.sender) || (delegateApprover == msg.sender));\r\n        _;\r\n    }\r\n\r\n    /** Check if delegate is known **/\r\n    modifier onlyKnownDelegate(address delegate) {\r\n        require(knownDelegates[delegate]);\r\n        _;\r\n    }\r\n\r\n    /** Check if the sender is a valid delegate **/\r\n    modifier onlyValidDelegate {\r\n        require(isDelegateValid(msg.sender, block.timestamp));\r\n        _;\r\n    }\r\n\r\n    /** Check if delegate approver active **/\r\n    modifier onlyWhenDelegateApproverActive {\r\n        require(!delegateApproverRenounced);\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @notice Governance initializer\r\n    * @param _owner Governance owner address\r\n    * @param _token XRM token address\r\n    * @param _minBalance Min stake balance required for delegate to be valid\r\n    * @param _keepAliveDuration Max keep alive duration when delegate should sent keep alive to be valid\r\n    * @param _delegatesLimit Max delegates / composers limit at one point of time\r\n    * @param _delegateBond Delegate bond to be sent to create new delegate\r\n    */\r\n    function init(\r\n        address _owner, address _token,\r\n        uint256 _minBalance, uint256 _keepAliveDuration, uint256 _delegatesLimit,\r\n        uint256 _delegateBond\r\n    ) initializer public {\r\n        require(_owner != address(0));\r\n        require(_token != address(0));\r\n\r\n        Ownable.initialize(_owner);\r\n        token = ERC20(_token);\r\n\r\n        delegateBond = _delegateBond;\r\n        delegateApprover = _owner;\r\n        upgradeAdmin = _owner;\r\n\r\n        minBalance.storeInt(_minBalance);\r\n        keepAliveDuration.storeInt(_keepAliveDuration);\r\n        composersCount.storeInt(_delegatesLimit);\r\n    }\r\n\r\n    /**\r\n    * @notice Set admin who can upgrade delegate contracts\r\n    * @param _admin New upgradeability admin\r\n    */\r\n    function setUpgradeAdmin(address _admin) external onlyOwner {\r\n        upgradeAdmin = _admin;\r\n        emit UpgradeAdminUpdated(_admin);\r\n    }\r\n\r\n    /**\r\n    * @notice Set user who can approve delegates\r\n    * @param _admin New delegate approver\r\n    */\r\n    function setDelegateApprover(address _admin) external onlyOwner onlyWhenDelegateApproverActive {\r\n        delegateApprover = _admin;\r\n        emit DelegateApproverUpdated(_admin);\r\n    }\r\n\r\n    /**\r\n    * @notice Set user who can approve delegates\r\n    */\r\n    function renouncedDelegateApprover() external onlyOwner {\r\n        delegateApproverRenounced = true;\r\n        delegateApprover = address(0);\r\n        emit DelegateApproverRenounced();\r\n    }\r\n\r\n    /**\r\n    * @notice Set up minimum delegate balance necessary to participate in staking\r\n    * @param _balance Minimum delegate balance\r\n    */\r\n    function setMinBalance(uint256 _balance) external onlyOwner {\r\n        minBalance.storeInt(_balance);\r\n        emit MinBalanceUpdated(_balance);\r\n    }\r\n\r\n    /**\r\n    * @notice Set up duration between keep alive message and current time to consider delegate active\r\n    * @param _duration Keep alive duration\r\n    */\r\n    function setKeepAliveDuration(uint256 _duration) external onlyOwner {\r\n        keepAliveDuration.storeInt(_duration);\r\n        emit KeepAliveDurationUpdated(_duration);\r\n    }\r\n\r\n    /**\r\n    * @notice Set up limit of delegates / composers\r\n    * @param _count Delegates / composers count\r\n    */\r\n    function setComposersCount(uint256 _count) external onlyOwner {\r\n        composersCount.storeInt(_count);\r\n        emit ComposersCountUpdated(_count);\r\n    }\r\n\r\n    /**\r\n    * @notice Change delegate status in the blacklist\r\n    * @param _delegate Delegate to be updated\r\n    * @param _blocked Is delegate blocked or not\r\n    */\r\n    function updateBlacklist(address _delegate, bool _blocked) external onlyOwner onlyKnownDelegate(_delegate) {\r\n        Delegate(_delegate).updateBlacklist(_blocked);\r\n        emit BlacklistUpdated(_delegate, _blocked);\r\n    }\r\n\r\n    /**\r\n    * @notice Get min balance for timestamp\r\n    * @param _timestamp Time for which delegate is blocked or not\r\n    */\r\n    function getMinBalance(uint256 _timestamp) external view returns (uint256) {\r\n        return minBalance.getInt(_timestamp);\r\n    }\r\n\r\n    /**\r\n    * @notice Get keep alive duration for timestamp\r\n    * @param _timestamp Time for which keep alive duration is returned\r\n    */\r\n    function getKeepAliveDuration(uint256 _timestamp) external view returns (uint256) {\r\n        return keepAliveDuration.getInt(_timestamp);\r\n    }\r\n\r\n    /**\r\n    * @notice Get delegates limit for timestamp\r\n    * @param _timestamp Time for which composers count is returned\r\n    */\r\n    function getComposersCount(uint256 _timestamp) external view returns (uint256) {\r\n        return composersCount.getInt(_timestamp);\r\n    }\r\n\r\n    /**\r\n    * @notice locks delegate stake by owner\r\n    * @param _delegate Delegate to lock stake\r\n    * @param _amount Stake amount to lock\r\n    */\r\n    function lockStake(address _delegate, uint256 _amount) external onlyOwner onlyKnownDelegate(_delegate) {\r\n        Delegate(_delegate).lockStake(_amount);\r\n        emit StakeLocked(_delegate, _amount);\r\n    }\r\n\r\n    /**\r\n    * @notice Create new delegate contract, get bond and transfer ownership to a caller\r\n    * @param _name Delegate name\r\n    * @param _aerum Delegate Aerum address\r\n    */\r\n    function createDelegate(bytes20 _name, address _aerum) external returns (address) {\r\n        token.safeTransferFrom(msg.sender, address(this), delegateBond);\r\n\r\n        Delegate impl = new Delegate();\r\n        OwnedUpgradeabilityProxy proxy = new OwnedUpgradeabilityProxy(impl);\r\n        proxy.changeAdmin(upgradeAdmin);\r\n        Delegate wrapper = Delegate(proxy);\r\n        wrapper.init(msg.sender, token, _name, _aerum);\r\n\r\n        address proxyAddr = address(wrapper);\r\n        knownDelegates[proxyAddr] = true;\r\n        bonds[proxyAddr] = delegateBond;\r\n\r\n        emit DelegateCreated(proxyAddr, msg.sender);\r\n\r\n        return proxyAddr;\r\n    }\r\n\r\n    /**\r\n    * @notice Register specified delegate by delegate approver\r\n    * @param _delegate Delegate to be approved\r\n    */\r\n    function approveDelegate(address _delegate) external onlyOwnerOrDelegateApprover onlyKnownDelegate(_delegate) {\r\n        approveDelegateInternal(_delegate);\r\n    }\r\n\r\n    /**\r\n    * @notice Register specified delegate (by delegate approver or voting)\r\n    * @param _delegate Delegate to be approved\r\n    */\r\n    function approveDelegateInternal(address _delegate) internal {\r\n        require(bonds[_delegate] >= delegateBond);\r\n\r\n        Delegate(_delegate).setActive(true);\r\n\r\n        emit DelegateApproved(_delegate);\r\n\r\n        for (uint256 index = 0; index < delegates.length; index++) {\r\n            if (delegates[index] == _delegate) {\r\n                // delegate already registered\r\n                return;\r\n            }\r\n        }\r\n        delegates.push(_delegate);\r\n    }\r\n\r\n    /**\r\n    * @notice Unregister specified delegate. Can only be called by delegate itself\r\n    */\r\n    function unregisterDelegate() external onlyKnownDelegate(msg.sender) {\r\n        address delegateAddr = msg.sender;\r\n        Delegate delegate = Delegate(delegateAddr);\r\n        require(delegate.isActive(block.timestamp));\r\n\r\n        uint256 bond = bonds[delegateAddr];\r\n        bonds[delegateAddr] = 0;\r\n        token.safeTransfer(delegate.owner(), bond);\r\n        delegate.setActive(false);\r\n\r\n        emit DelegateUnregistered(delegateAddr);\r\n    }\r\n\r\n    /**\r\n    * @notice Send bond for specified delegate, should be used when unregistered delegate wants to be registered again\r\n    * @param _delegate Delegate which will receive bond\r\n    * @param _amount Bond amount\r\n    */\r\n    function sendBond(address _delegate, uint256 _amount) external onlyKnownDelegate(_delegate) {\r\n        token.safeTransferFrom(msg.sender, address(this), _amount);\r\n        bonds[_delegate] = bonds[_delegate].add(_amount);\r\n        emit BondSent(_delegate, _amount);\r\n    }\r\n\r\n    /**\r\n    * @notice Whether specified delegate is known by governance, created by governance\r\n    * @param _delegate Delegate address to check\r\n    */\r\n    function isDelegateKnown(address _delegate) public view returns (bool) {\r\n        return knownDelegates[_delegate];\r\n    }\r\n\r\n    /**\r\n    * @notice List of composers for the specified block number and timestamp. This method is used by AerumGo\r\n    * @param _blockNum Aerum block number. Used for delegates list shifting\r\n    * @param _timestamp Time at which composers list is requested\r\n    */\r\n    function getComposers(uint256 _blockNum, uint256 _timestamp) external view returns (address[]) {\r\n        (address[] memory candidates,) = getValidDelegates(_timestamp);\r\n        uint256 candidatesLength = candidates.length;\r\n\r\n        uint256 limit = composersCount.getInt(_timestamp);\r\n        if (candidatesLength < limit) {\r\n            limit = candidatesLength;\r\n        }\r\n\r\n        address[] memory composers = new address[](limit);\r\n\r\n        if (candidatesLength == 0) {\r\n            return composers;\r\n        }\r\n\r\n        uint256 first = _blockNum.div(delegatesUpdateAerumBlocksPeriod) % candidatesLength;\r\n        for (uint256 index = 0; index < limit; index++) {\r\n            composers[index] = candidates[(first + index) % candidatesLength];\r\n        }\r\n\r\n        return composers;\r\n    }\r\n\r\n    /**\r\n    * @notice List of all active delegates addresses\r\n    */\r\n    function getDelegates() public view returns (address[]) {\r\n        return delegates;\r\n    }\r\n\r\n    /**\r\n    * @notice Returns number of active delegates\r\n    */\r\n    function getDelegateCount() public view returns (uint256) {\r\n        return delegates.length;\r\n    }\r\n\r\n    /**\r\n    * @notice List of valid delegates which might be composers and their names\r\n    * @param _timestamp Time at which delegates list is requested\r\n    */\r\n    function getValidDelegates(uint256 _timestamp) public view returns (address[], bytes20[]) {\r\n        address[] memory array = new address[](delegates.length);\r\n        uint16 length = 0;\r\n        for (uint256 i = 0; i < delegates.length; i++) {\r\n            if (isDelegateValid(delegates[i], _timestamp)) {\r\n                array[length] = delegates[i];\r\n                length++;\r\n            }\r\n        }\r\n        address[] memory addresses = new address[](length);\r\n        bytes20[] memory names = new bytes20[](length);\r\n        for (uint256 j = 0; j < length; j++) {\r\n            Delegate delegate = Delegate(array[j]);\r\n            addresses[j] = delegate.aerum();\r\n            names[j] = delegate.name();\r\n        }\r\n        return (addresses, names);\r\n    }\r\n\r\n    /**\r\n    * @notice Returns valid delegates count\r\n    */\r\n    function getValidDelegateCount() public view returns (uint256) {\r\n        (address[] memory validDelegates,) = getValidDelegates(block.timestamp);\r\n        return validDelegates.length;\r\n    }\r\n\r\n    /**\r\n    * @notice Whether specified delegate can be a composer\r\n    * @param _delegate Delegate address to validate\r\n    * @param _timestamp Time at which check is requested\r\n    */\r\n    function isDelegateValid(address _delegate, uint256 _timestamp) public view returns (bool) {\r\n        if (!knownDelegates[_delegate]) {\r\n            // Delegate not owned by this contract\r\n            return false;\r\n        }\r\n        Delegate proxy = Delegate(_delegate);\r\n        // Delegate has not been activated\r\n        if (!proxy.isActive(_timestamp)) {\r\n            return false;\r\n        }\r\n        // Delegate has not been blacklisted\r\n        if (proxy.isBlacklisted(_timestamp)) {\r\n            return false;\r\n        }\r\n        // Delegate has enough minimal stake to participate in consensus\r\n        uint256 stake = proxy.getStake(_timestamp);\r\n        if (stake < minBalance.getInt(_timestamp)) {\r\n            return false;\r\n        }\r\n        // Delegate has produced a keep-alive message in last 24h\r\n        uint256 lastKeepAlive = proxy.getKeepAliveTimestamp(_timestamp);\r\n        return lastKeepAlive.add(keepAliveDuration.getInt(_timestamp)) >= block.timestamp;\r\n    }\r\n\r\n    /**\r\n    * @notice Make a proposal to approved calling delegate\r\n    * @param _id Voting id\r\n    */\r\n    function submitActivateProposal(bytes32 _id) external onlyKnownDelegate(msg.sender) {\r\n        address delegate = msg.sender;\r\n        require(!Delegate(delegate).isActive(block.timestamp));\r\n\r\n        submitProposal(_id, delegate, VotingCategory.ACTIVATE, true);\r\n    }\r\n\r\n    /**\r\n    * @notice Make a proposal to add/remove specified delegate to the blacklist\r\n    * @param _id Voting id\r\n    * @param _delegate Delegate affected by voting\r\n    * @param _proposal Should be blacklisted on un blacklisted\r\n    */\r\n    function submitBlacklistProposal(bytes32 _id, address _delegate, bool _proposal) external onlyValidDelegate {\r\n        submitProposal(_id, _delegate, VotingCategory.BLACKLIST, _proposal);\r\n    }\r\n\r\n    /**\r\n    * @notice Make generic proposal\r\n    * @param _id Voting id\r\n    * @param _delegate Delegate affected by voting\r\n    * @param _category Voting category: activate or blacklist\r\n    * @param _proposal Should be blacklisted on un blacklisted\r\n    */\r\n    function submitProposal(bytes32 _id, address _delegate, VotingCategory _category, bool _proposal) internal {\r\n        // make sure voting is unique\r\n        require(votings[_id].id != _id);\r\n\r\n        Voting memory voting = Voting({\r\n            id : _id,\r\n            category : _category,\r\n            timestamp : block.timestamp,\r\n            delegate : _delegate,\r\n            proposal : _proposal,\r\n            voters : new address[](0)\r\n        });\r\n\r\n        votings[_id] = voting;\r\n\r\n        emit ProposalSubmitted(_id, msg.sender, _delegate, _category, _proposal);\r\n    }\r\n\r\n    /**\r\n    * @notice Vote in favor or against proposal with the specified identifier\r\n    * @param _id Voting id\r\n    * @param _inFavor Support proposal or not\r\n    */\r\n    function vote(bytes32 _id, bool _inFavor) external onlyValidDelegate {\r\n        Voting storage voting = votings[_id];\r\n        // have specified blacklist voting\r\n        require(voting.id == _id);\r\n        // voting is still active\r\n        require(voting.timestamp.add(votingPeriod) > block.timestamp);\r\n\r\n        address voter = msg.sender;\r\n        for (uint256 index = 0; index < voting.voters.length; index++) {\r\n            if (voting.voters[index] == voter) {\r\n                // delegate already voted\r\n                return;\r\n            }\r\n        }\r\n\r\n        voting.voters.push(voter);\r\n        voting.votes[voter] = _inFavor;\r\n\r\n        emit Vote(_id, voter, _inFavor);\r\n    }\r\n\r\n    /**\r\n    * @notice Finalize voting and apply proposed changes if success.\r\n    * This method will fail if voting period is not over.\r\n    * @param _id Voting id\r\n    */\r\n    function finalizeVoting(bytes32 _id) external {\r\n        bool voted;\r\n        bool supported;\r\n        Voting storage voting = votings[_id];\r\n        // have specified blacklist voting\r\n        require(voting.id == _id);\r\n        // voting period if finished\r\n        require(voting.timestamp.add(votingPeriod) <= block.timestamp);\r\n\r\n        uint256 requiredVotesNumber = getValidDelegateCount() * 3 / 10;\r\n        if (voting.voters.length >= requiredVotesNumber) {\r\n            voted = true;\r\n            uint256 proponents = 0;\r\n            for (uint256 index = 0; index < voting.voters.length; index++) {\r\n                if (voting.votes[voting.voters[index]]) {\r\n                    proponents++;\r\n                }\r\n            }\r\n            if (proponents * 2 > voting.voters.length) {\r\n                supported = true;\r\n                if (voting.category == VotingCategory.BLACKLIST) {\r\n                    Delegate(voting.delegate).updateBlacklist(voting.proposal);\r\n                }\r\n                // NOTE: It's always true for activate\r\n                if (voting.category == VotingCategory.ACTIVATE) {\r\n                    approveDelegateInternal(voting.delegate);\r\n                }\r\n            }\r\n        }\r\n\r\n        delete votings[_id];\r\n\r\n        emit VotingFinalized(_id, voted, supported);\r\n    }\r\n\r\n    /**\r\n    * @notice Returns voting details by id\r\n    * @param _id Voting id\r\n    */\r\n    function getVotingDetails(bytes32 _id) external view returns (bytes32, uint256, address, VotingCategory, bool, address[], bool[]) {\r\n        Voting storage voting = votings[_id];\r\n        address[] storage voters = voting.voters;\r\n\r\n        bool[] memory votes = new bool[] (voters.length);\r\n        for (uint256 index = 0; index < voters.length; index++) {\r\n            votes[index] = voting.votes[voters[index]];\r\n        }\r\n\r\n        return (voting.id, voting.timestamp, voting.delegate, voting.category, voting.proposal, voters, votes);\r\n    }\r\n\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_id\",\"type\":\"bytes32\"},{\"name\":\"_delegate\",\"type\":\"address\"},{\"name\":\"_proposal\",\"type\":\"bool\"}],\"name\":\"submitBlacklistProposal\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_delegate\",\"type\":\"address\"}],\"name\":\"approveDelegate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getDelegateCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_id\",\"type\":\"bytes32\"}],\"name\":\"submitActivateProposal\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_id\",\"type\":\"bytes32\"}],\"name\":\"getVotingDetails\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint8\"},{\"name\":\"\",\"type\":\"bool\"},{\"name\":\"\",\"type\":\"address[]\"},{\"name\":\"\",\"type\":\"bool[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renouncedDelegateApprover\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_delegate\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"lockStake\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_blockNum\",\"type\":\"uint256\"},{\"name\":\"_timestamp\",\"type\":\"uint256\"}],\"name\":\"getComposers\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"votings\",\"outputs\":[{\"name\":\"id\",\"type\":\"bytes32\"},{\"name\":\"category\",\"type\":\"uint8\"},{\"name\":\"timestamp\",\"type\":\"uint256\"},{\"name\":\"delegate\",\"type\":\"address\"},{\"name\":\"proposal\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_delegate\",\"type\":\"address\"}],\"name\":\"isDelegateKnown\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_id\",\"type\":\"bytes32\"}],\"name\":\"finalizeVoting\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_timestamp\",\"type\":\"uint256\"}],\"name\":\"getKeepAliveDuration\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"keepAliveDuration\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_timestamp\",\"type\":\"uint256\"}],\"name\":\"getValidDelegates\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"},{\"name\":\"\",\"type\":\"bytes20[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"delegateApprover\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getValidDelegateCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"minBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_delegate\",\"type\":\"address\"},{\"name\":\"_blocked\",\"type\":\"bool\"}],\"name\":\"updateBlacklist\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_name\",\"type\":\"bytes20\"},{\"name\":\"_aerum\",\"type\":\"address\"}],\"name\":\"createDelegate\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_admin\",\"type\":\"address\"}],\"name\":\"setUpgradeAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_id\",\"type\":\"bytes32\"},{\"name\":\"_inFavor\",\"type\":\"bool\"}],\"name\":\"vote\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_delegate\",\"type\":\"address\"},{\"name\":\"_timestamp\",\"type\":\"uint256\"}],\"name\":\"isDelegateValid\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_duration\",\"type\":\"uint256\"}],\"name\":\"setKeepAliveDuration\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"knownDelegates\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unregisterDelegate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_delegate\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"sendBond\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"delegates\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"composersCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_timestamp\",\"type\":\"uint256\"}],\"name\":\"getComposersCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_minBalance\",\"type\":\"uint256\"},{\"name\":\"_keepAliveDuration\",\"type\":\"uint256\"},{\"name\":\"_delegatesLimit\",\"type\":\"uint256\"},{\"name\":\"_delegateBond\",\"type\":\"uint256\"}],\"name\":\"init\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"delegateApproverRenounced\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"upgradeAdmin\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getDelegates\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_balance\",\"type\":\"uint256\"}],\"name\":\"setMinBalance\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_count\",\"type\":\"uint256\"}],\"name\":\"setComposersCount\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_timestamp\",\"type\":\"uint256\"}],\"name\":\"getMinBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_admin\",\"type\":\"address\"}],\"name\":\"setDelegateApprover\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"delegateBond\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"bonds\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"admin\",\"type\":\"address\"}],\"name\":\"UpgradeAdminUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"admin\",\"type\":\"address\"}],\"name\":\"DelegateApproverUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"DelegateApproverRenounced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"balance\",\"type\":\"uint256\"}],\"name\":\"MinBalanceUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"duration\",\"type\":\"uint256\"}],\"name\":\"KeepAliveDurationUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"count\",\"type\":\"uint256\"}],\"name\":\"ComposersCountUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"delegate\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"blocked\",\"type\":\"bool\"}],\"name\":\"BlacklistUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"delegate\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"DelegateCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"delegate\",\"type\":\"address\"}],\"name\":\"DelegateApproved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"delegate\",\"type\":\"address\"}],\"name\":\"DelegateUnregistered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"delegate\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"BondSent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"delegate\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"StakeLocked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"id\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"author\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"delegate\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"category\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"proposal\",\"type\":\"bool\"}],\"name\":\"ProposalSubmitted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"id\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"voter\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"inFavor\",\"type\":\"bool\"}],\"name\":\"Vote\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"id\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"voted\",\"type\":\"bool\"},{\"indexed\":false,\"name\":\"supported\",\"type\":\"bool\"}],\"name\":\"VotingFinalized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"}],\"name\":\"OwnershipRenounced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"Governance","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://31931a80b9783a79fea4fb60792a5d13fed5901fe3901a6cc99dae869f895a55"}]}