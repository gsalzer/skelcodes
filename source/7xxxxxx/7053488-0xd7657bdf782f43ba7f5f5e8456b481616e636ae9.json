{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\n/*\r\n*   gibmireinbier\r\n*   0xA4a799086aE18D7db6C4b57f496B081b44888888\r\n*   gibmireinbier@gmail.com\r\n*/\r\n\r\nlibrary Helper {\r\n    using SafeMath for uint256;\r\n\r\n    uint256 constant public ZOOM = 1000;\r\n    uint256 constant public SDIVIDER = 3450000;\r\n    uint256 constant public PDIVIDER = 3450000;\r\n    uint256 constant public RDIVIDER = 1580000;\r\n    // Starting LS price (SLP)\r\n    uint256 constant public SLP = 0.002 ether;\r\n    // Starting Added Time (SAT)\r\n    uint256 constant public SAT = 30; // seconds\r\n    // Price normalization (PN)\r\n    uint256 constant public PN = 777;\r\n    // EarlyIncome base\r\n    uint256 constant public PBASE = 13;\r\n    uint256 constant public PMULTI = 26;\r\n    uint256 constant public LBase = 15;\r\n\r\n    uint256 constant public ONE_HOUR = 3600;\r\n    uint256 constant public ONE_DAY = 24 * ONE_HOUR;\r\n    //uint256 constant public TIMEOUT0 = 3 * ONE_HOUR;\r\n    uint256 constant public TIMEOUT1 = 12 * ONE_HOUR;\r\n    \r\n    function bytes32ToString (bytes32 data)\r\n        public\r\n        pure\r\n        returns (string) \r\n    {\r\n        bytes memory bytesString = new bytes(32);\r\n        for (uint j=0; j<32; j++) {\r\n            byte char = byte(bytes32(uint(data) * 2 ** (8 * j)));\r\n            if (char != 0) {\r\n                bytesString[j] = char;\r\n            }\r\n        }\r\n        return string(bytesString);\r\n    }\r\n    \r\n    function uintToBytes32(uint256 n)\r\n        public\r\n        pure\r\n        returns (bytes32) \r\n    {\r\n        return bytes32(n);\r\n    }\r\n    \r\n    function bytes32ToUint(bytes32 n) \r\n        public\r\n        pure\r\n        returns (uint256) \r\n    {\r\n        return uint256(n);\r\n    }\r\n    \r\n    function stringToBytes32(string memory source) \r\n        public\r\n        pure\r\n        returns (bytes32 result) \r\n    {\r\n        bytes memory tempEmptyStringTest = bytes(source);\r\n        if (tempEmptyStringTest.length == 0) {\r\n            return 0x0;\r\n        }\r\n\r\n        assembly {\r\n            result := mload(add(source, 32))\r\n        }\r\n    }\r\n    \r\n    function stringToUint(string memory source) \r\n        public\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return bytes32ToUint(stringToBytes32(source));\r\n    }\r\n    \r\n    function uintToString(uint256 _uint) \r\n        public\r\n        pure\r\n        returns (string)\r\n    {\r\n        return bytes32ToString(uintToBytes32(_uint));\r\n    }\r\n\r\n/*     \r\n    function getSlice(uint256 begin, uint256 end, string text) public pure returns (string) {\r\n        bytes memory a = new bytes(end-begin+1);\r\n        for(uint i = 0; i <= end - begin; i++){\r\n            a[i] = bytes(text)[i + begin - 1];\r\n        }\r\n        return string(a);    \r\n    }\r\n */\r\n    function validUsername(string _username)\r\n        public\r\n        pure\r\n        returns(bool)\r\n    {\r\n        uint256 len = bytes(_username).length;\r\n        // Im Raum [4, 18]\r\n        if ((len < 4) || (len > 18)) return false;\r\n        // Letzte Char != ' '\r\n        if (bytes(_username)[len-1] == 32) return false;\r\n        // Erste Char != '0'\r\n        return uint256(bytes(_username)[0]) != 48;\r\n    }\r\n\r\n    // Lottery Helper\r\n\r\n    // Seconds added per LT = SAT - ((Current no. of LT + 1) / SDIVIDER)^6\r\n    function getAddedTime(uint256 _rTicketSum, uint256 _tAmount)\r\n        public\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        //Luppe = 10000 = 10^4\r\n        uint256 base = (_rTicketSum + 1).mul(10000) / SDIVIDER;\r\n        uint256 expo = base;\r\n        expo = expo.mul(expo).mul(expo); // ^3\r\n        expo = expo.mul(expo); // ^6\r\n        // div 10000^6\r\n        expo = expo / (10**24);\r\n\r\n        if (expo > SAT) return 0;\r\n        return (SAT - expo).mul(_tAmount);\r\n    }\r\n\r\n    function getNewEndTime(uint256 toAddTime, uint256 slideEndTime, uint256 fixedEndTime)\r\n        public\r\n        view\r\n        returns(uint256)\r\n    {\r\n        uint256 _slideEndTime = (slideEndTime).add(toAddTime);\r\n        uint256 timeout = _slideEndTime.sub(block.timestamp);\r\n        // timeout capped at TIMEOUT1\r\n        if (timeout > TIMEOUT1) timeout = TIMEOUT1;\r\n        _slideEndTime = (block.timestamp).add(timeout);\r\n        // Capped at fixedEndTime\r\n        if (_slideEndTime > fixedEndTime)  return fixedEndTime;\r\n        return _slideEndTime;\r\n    }\r\n\r\n    // get random in range [1, _range] with _seed\r\n    function getRandom(uint256 _seed, uint256 _range)\r\n        public\r\n        pure\r\n        returns(uint256)\r\n    {\r\n        if (_range == 0) return _seed;\r\n        return (_seed % _range) + 1;\r\n    }\r\n\r\n\r\n    function getEarlyIncomeMul(uint256 _ticketSum)\r\n        public\r\n        pure\r\n        returns(uint256)\r\n    {\r\n        // Early-Multiplier = 1 + PBASE / (1 + PMULTI * ((Current No. of LT)/RDIVIDER)^6)\r\n        uint256 base = _ticketSum * ZOOM / RDIVIDER;\r\n        uint256 expo = base.mul(base).mul(base); //^3\r\n        expo = expo.mul(expo) / (ZOOM**6); //^6\r\n        return (1 + PBASE / (1 + expo.mul(PMULTI)));\r\n    }\r\n\r\n    // get reveiced Tickets, based on current round ticketSum\r\n    function getTAmount(uint256 _ethAmount, uint256 _ticketSum) \r\n        public\r\n        pure\r\n        returns(uint256)\r\n    {\r\n        uint256 _tPrice = getTPrice(_ticketSum);\r\n        return _ethAmount.div(_tPrice);\r\n    }\r\n\r\n    // Lotto-Multiplier = 1 + LBase * (Current No. of Tickets / PDivider)^6\r\n    function getTMul(uint256 _ticketSum) // Unit Wei\r\n        public\r\n        pure\r\n        returns(uint256)\r\n    {\r\n        uint256 base = _ticketSum * ZOOM / PDIVIDER;\r\n        uint256 expo = base.mul(base).mul(base);\r\n        expo = expo.mul(expo); // ^6\r\n        return 1 + expo.mul(LBase) / (10**18);\r\n    }\r\n\r\n    // get ticket price, based on current round ticketSum\r\n    //unit in ETH, no need / zoom^6\r\n    function getTPrice(uint256 _ticketSum)\r\n        public\r\n        pure\r\n        returns(uint256)\r\n    {\r\n        uint256 base = (_ticketSum + 1).mul(ZOOM) / PDIVIDER;\r\n        uint256 expo = base;\r\n        expo = expo.mul(expo).mul(expo); // ^3\r\n        expo = expo.mul(expo); // ^6\r\n        uint256 tPrice = SLP + expo / PN;\r\n        return tPrice;\r\n    }\r\n\r\n    // get weight of slot, chance to win grandPot\r\n    function getSlotWeight(uint256 _ethAmount, uint256 _ticketSum)\r\n        public\r\n        pure\r\n        returns(uint256)\r\n    {\r\n        uint256 _tAmount = getTAmount(_ethAmount, _ticketSum);\r\n        uint256 _tMul = getTMul(_ticketSum);\r\n        return (_tAmount).mul(_tMul);\r\n    }\r\n\r\n    // used to draw grandpot results\r\n    // weightRange = roundWeight * grandpot / (grandpot - initGrandPot)\r\n    // grandPot = initGrandPot + round investedSum(for grandPot)\r\n    function getWeightRange(uint256 grandPot, uint256 initGrandPot, uint256 curRWeight)\r\n        public\r\n        pure\r\n        returns(uint256)\r\n    {\r\n        //calculate round grandPot-investedSum\r\n        uint256 grandPotInvest = grandPot - initGrandPot;\r\n        if (grandPotInvest == 0) return 8;\r\n        uint256 zoomMul = grandPot * ZOOM / grandPotInvest;\r\n        uint256 weightRange = zoomMul * curRWeight / ZOOM;\r\n        if (weightRange < curRWeight) weightRange = curRWeight;\r\n        return weightRange;\r\n    }\r\n}\r\n\r\ninterface F2mInterface {\r\n    function joinNetwork(address[6] _contract) public;\r\n    // one time called\r\n    function disableRound0() public;\r\n    function activeBuy() public;\r\n    // Dividends from all sources (DApps, Donate ...)\r\n    function pushDividends() public payable;\r\n    /**\r\n     * Converts all of caller's dividends to tokens.\r\n     */\r\n    //function reinvest() public;\r\n    //function buy() public payable;\r\n    function buyFor(address _buyer) public payable;\r\n    function sell(uint256 _tokenAmount) public;\r\n    function exit() public;\r\n    function devTeamWithdraw() public returns(uint256);\r\n    function withdrawFor(address sender) public returns(uint256);\r\n    function transfer(address _to, uint256 _tokenAmount) public returns(bool);\r\n    /*----------  ADMINISTRATOR ONLY FUNCTIONS  ----------*/\r\n    function setAutoBuy() public;\r\n    /*==========================================\r\n    =            public FUNCTIONS            =\r\n    ==========================================*/\r\n    // function totalEthBalance() public view returns(uint256);\r\n    function ethBalance(address _address) public view returns(uint256);\r\n    function myBalance() public view returns(uint256);\r\n    function myEthBalance() public view returns(uint256);\r\n\r\n    function swapToken() public;\r\n    function setNewToken(address _newTokenAddress) public;\r\n}\r\n\r\ninterface BankInterface {\r\n    function joinNetwork(address[6] _contract) public;\r\n    // Core functions\r\n    function pushToBank(address _player) public payable;\r\n}\r\n\r\n\r\ninterface DevTeamInterface {\r\n    function setF2mAddress(address _address) public;\r\n    function setLotteryAddress(address _address) public;\r\n    function setCitizenAddress(address _address) public;\r\n    function setBankAddress(address _address) public;\r\n    function setRewardAddress(address _address) public;\r\n    function setWhitelistAddress(address _address) public;\r\n\r\n    function setupNetwork() public;\r\n}\r\n\r\ninterface LotteryInterface {\r\n    function joinNetwork(address[6] _contract) public;\r\n    // call one time\r\n    function activeFirstRound() public;\r\n    // Core Functions\r\n    function pushToPot() public payable;\r\n    function finalizeable() public view returns(bool);\r\n    // bounty\r\n    function finalize() public;\r\n    function buy(string _sSalt) public payable;\r\n    function buyFor(string _sSalt, address _sender) public payable;\r\n    //function withdraw() public;\r\n    function withdrawFor(address _sender) public returns(uint256);\r\n\r\n    function getRewardBalance(address _buyer) public view returns(uint256);\r\n    function getTotalPot() public view returns(uint256);\r\n    // EarlyIncome\r\n    function getEarlyIncomeByAddress(address _buyer) public view returns(uint256);\r\n    // included claimed amount\r\n    // function getEarlyIncomeByAddressRound(address _buyer, uint256 _rId) public view returns(uint256);\r\n    function getCurEarlyIncomeByAddress(address _buyer) public view returns(uint256);\r\n    // function getCurEarlyIncomeByAddressRound(address _buyer, uint256 _rId) public view returns(uint256);\r\n    function getCurRoundId() public view returns(uint256);\r\n    // set endRound, prepare to upgrade new version\r\n    function setLastRound(uint256 _lastRoundId) public;\r\n    function getPInvestedSumByRound(uint256 _rId, address _buyer) public view returns(uint256);\r\n    function cashoutable(address _address) public view returns(bool);\r\n    function isLastRound() public view returns(bool);\r\n}\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n    int256 constant private INT256_MIN = -2**255;\r\n\r\n    /**\r\n    * @dev Multiplies two unsigned integers, reverts on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Multiplies two signed integers, reverts on overflow.\r\n    */\r\n    function mul(int256 a, int256 b) internal pure returns (int256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        require(!(a == -1 && b == INT256_MIN)); // This is the only case of overflow not detected by the check below\r\n\r\n        int256 c = a * b;\r\n        require(c / a == b);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two signed integers truncating the quotient, reverts on division by zero.\r\n    */\r\n    function div(int256 a, int256 b) internal pure returns (int256) {\r\n        require(b != 0); // Solidity only automatically asserts when dividing by 0\r\n        require(!(b == -1 && a == INT256_MIN)); // This is the only case of overflow\r\n\r\n        int256 c = a / b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two signed integers, reverts on overflow.\r\n    */\r\n    function sub(int256 a, int256 b) internal pure returns (int256) {\r\n        int256 c = a - b;\r\n        require((b >= 0 && c <= a) || (b < 0 && c > a));\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two unsigned integers, reverts on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two signed integers, reverts on overflow.\r\n    */\r\n    function add(int256 a, int256 b) internal pure returns (int256) {\r\n        int256 c = a + b;\r\n        require((b >= 0 && c >= a) || (b < 0 && c < a));\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\r\n    * reverts when dividing by zero.\r\n    */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}\r\n\r\ncontract Citizen {\r\n    using SafeMath for uint256;\r\n\r\n    event Register(address indexed _member, address indexed _ref);\r\n\r\n    modifier withdrawRight(){\r\n        require((msg.sender == address(bankContract)), \"Bank only\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyAdmin() {\r\n        require(msg.sender == devTeam, \"admin required\");\r\n        _;\r\n    }\r\n\r\n    modifier notRegistered(){\r\n        require(!isCitizen[msg.sender], \"already exist\");\r\n        _;\r\n    }\r\n\r\n    modifier registered(){\r\n        require(isCitizen[msg.sender], \"must be a citizen\");\r\n        _;\r\n    }\r\n\r\n    struct Profile{\r\n        uint256 id;\r\n        uint256 username;\r\n        uint256 refWallet;\r\n        address ref;\r\n        address[] refTo;\r\n        uint256 totalChild;\r\n        uint256 donated;\r\n        uint256 treeLevel;\r\n        // logs\r\n        uint256 totalSale;\r\n        uint256 allRoundRefIncome;\r\n        mapping(uint256 => uint256) roundRefIncome;\r\n        mapping(uint256 => uint256) roundRefWallet;\r\n    }\r\n\r\n    //bool public oneWayTicket = true;\r\n    mapping (address => Profile) public citizen;\r\n    mapping (address => bool) public isCitizen;\r\n    mapping (uint256 => address) public idAddress;\r\n    mapping (uint256 => address) public usernameAddress;\r\n\r\n    mapping (uint256 => address[]) levelCitizen;\r\n\r\n    BankInterface bankContract;\r\n    LotteryInterface lotteryContract;\r\n    F2mInterface f2mContract;\r\n    address devTeam;\r\n\r\n    uint256 citizenNr;\r\n    uint256 lastLevel;\r\n\r\n    // logs\r\n    mapping(uint256 => uint256) public totalRefByRound;\r\n    uint256 public totalRefAllround;\r\n\r\n    constructor (address _devTeam)\r\n        public\r\n    {\r\n        DevTeamInterface(_devTeam).setCitizenAddress(address(this));\r\n        devTeam = _devTeam;\r\n\r\n        // first citizen is the development team\r\n        citizenNr = 1;\r\n        idAddress[1] = devTeam;\r\n        isCitizen[devTeam] = true;\r\n        //root => self ref\r\n        citizen[devTeam].ref = devTeam;\r\n        // username rules bypass\r\n        uint256 _username = Helper.stringToUint(\"f2m\");\r\n        citizen[devTeam].username = _username;\r\n        usernameAddress[_username] = devTeam; \r\n        citizen[devTeam].id = 1;\r\n        citizen[devTeam].treeLevel = 1;\r\n        levelCitizen[1].push(devTeam);\r\n        lastLevel = 1;\r\n    }\r\n\r\n    // _contract = [f2mAddress, bankAddress, citizenAddress, lotteryAddress, rewardAddress, whitelistAddress];\r\n    function joinNetwork(address[6] _contract)\r\n        public\r\n    {\r\n        require(address(lotteryContract) == 0,\"already setup\");\r\n        f2mContract = F2mInterface(_contract[0]);\r\n        bankContract = BankInterface(_contract[1]);\r\n        lotteryContract = LotteryInterface(_contract[3]);\r\n    }\r\n\r\n    /*----------  WRITE FUNCTIONS  ----------*/\r\n    function updateTotalChild(address _address)\r\n        private\r\n    {\r\n        address _member = _address;\r\n        while(_member != devTeam) {\r\n            _member = getRef(_member);\r\n            citizen[_member].totalChild ++;\r\n        }\r\n    }\r\n\r\n    function register(string _sUsername, address _ref)\r\n        public\r\n        notRegistered()\r\n    {\r\n        require(Helper.validUsername(_sUsername), \"invalid username\");\r\n        address sender = msg.sender;\r\n        uint256 _username = Helper.stringToUint(_sUsername);\r\n        require(usernameAddress[_username] == 0x0, \"username already exist\");\r\n        usernameAddress[_username] = sender;\r\n        //ref must be a citizen, else ref = devTeam\r\n        address validRef = isCitizen[_ref] ? _ref : devTeam;\r\n\r\n        //Welcome new Citizen\r\n        isCitizen[sender] = true;\r\n        citizen[sender].username = _username;\r\n        citizen[sender].ref = validRef;\r\n        citizenNr++;\r\n\r\n        idAddress[citizenNr] = sender;\r\n        citizen[sender].id = citizenNr;\r\n        \r\n        uint256 refLevel = citizen[validRef].treeLevel;\r\n        if (refLevel == lastLevel) lastLevel++;\r\n        citizen[sender].treeLevel = refLevel + 1;\r\n        levelCitizen[refLevel + 1].push(sender);\r\n        //add child\r\n        citizen[validRef].refTo.push(sender);\r\n        updateTotalChild(sender);\r\n        emit Register(sender, validRef);\r\n    }\r\n\r\n    function updateUsername(string _sNewUsername)\r\n        public\r\n        registered()\r\n    {\r\n        require(Helper.validUsername(_sNewUsername), \"invalid username\");\r\n        address sender = msg.sender;\r\n        uint256 _newUsername = Helper.stringToUint(_sNewUsername);\r\n        require(usernameAddress[_newUsername] == 0x0, \"username already exist\");\r\n        uint256 _oldUsername = citizen[sender].username;\r\n        citizen[sender].username = _newUsername;\r\n        usernameAddress[_oldUsername] = 0x0;\r\n        usernameAddress[_newUsername] = sender;\r\n    }\r\n\r\n    //Sources: Token contract, DApps\r\n    function pushRefIncome(address _sender)\r\n        public\r\n        payable\r\n    {\r\n        uint256 curRoundId = lotteryContract.getCurRoundId();\r\n        uint256 _amount = msg.value;\r\n        address sender = _sender;\r\n        address ref = getRef(sender);\r\n        // logs\r\n        citizen[sender].totalSale += _amount;\r\n        totalRefAllround += _amount;\r\n        totalRefByRound[curRoundId] += _amount;\r\n        // push to root\r\n        // lower level cost less gas\r\n        while (sender != devTeam) {\r\n            _amount = _amount / 2;\r\n            citizen[ref].refWallet = _amount.add(citizen[ref].refWallet);\r\n            citizen[ref].roundRefIncome[curRoundId] += _amount;\r\n            citizen[ref].allRoundRefIncome += _amount;\r\n            sender = ref;\r\n            ref = getRef(sender);\r\n        }\r\n        citizen[sender].refWallet = _amount.add(citizen[ref].refWallet);\r\n        // devTeam Logs\r\n        citizen[sender].roundRefIncome[curRoundId] += _amount;\r\n        citizen[sender].allRoundRefIncome += _amount;\r\n    }\r\n\r\n    function withdrawFor(address sender) \r\n        public\r\n        withdrawRight()\r\n        returns(uint256)\r\n    {\r\n        uint256 amount = citizen[sender].refWallet;\r\n        if (amount == 0) return 0;\r\n        citizen[sender].refWallet = 0;\r\n        bankContract.pushToBank.value(amount)(sender);\r\n        return amount;\r\n    }\r\n\r\n    function devTeamWithdraw()\r\n        public\r\n        onlyAdmin()\r\n    {\r\n        uint256 _amount = citizen[devTeam].refWallet;\r\n        if (_amount == 0) return;\r\n        devTeam.transfer(_amount);\r\n        citizen[devTeam].refWallet = 0;\r\n    }\r\n\r\n    function devTeamReinvest()\r\n        public\r\n        returns(uint256)\r\n    {\r\n        address sender = msg.sender;\r\n        require(sender == address(f2mContract), \"only f2m contract\");\r\n        uint256 _amount = citizen[devTeam].refWallet;\r\n        citizen[devTeam].refWallet = 0;\r\n        address(f2mContract).transfer(_amount);\r\n        return _amount;\r\n    }\r\n\r\n    /*----------  READ FUNCTIONS  ----------*/\r\n\r\n    function getTotalChild(address _address)\r\n        public\r\n        view\r\n        returns(uint256)\r\n    {\r\n        return citizen[_address].totalChild;\r\n    }\r\n\r\n    function getAllRoundRefIncome(address _address)\r\n        public\r\n        view\r\n        returns(uint256)\r\n    {\r\n        return citizen[_address].allRoundRefIncome;\r\n    }\r\n\r\n    function getRoundRefIncome(address _address, uint256 _rId)\r\n        public\r\n        view\r\n        returns(uint256)\r\n    {\r\n        return citizen[_address].roundRefIncome[_rId];\r\n    }\r\n\r\n    function getRefWallet(address _address)\r\n        public\r\n        view\r\n        returns(uint256)\r\n    {\r\n        return citizen[_address].refWallet;\r\n    }\r\n\r\n    function getAddressById(uint256 _id)\r\n        public\r\n        view\r\n        returns (address)\r\n    {\r\n        return idAddress[_id];\r\n    }\r\n\r\n    function getAddressByUserName(string _username)\r\n        public\r\n        view\r\n        returns (address)\r\n    {\r\n        return usernameAddress[Helper.stringToUint(_username)];\r\n    }\r\n\r\n    function exist(string _username)\r\n        public\r\n        view\r\n        returns (bool)\r\n    {\r\n        return usernameAddress[Helper.stringToUint(_username)] != 0x0;\r\n    }\r\n\r\n    function getId(address _address)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return citizen[_address].id;\r\n    }\r\n\r\n    function getUsername(address _address)\r\n        public\r\n        view\r\n        returns (string)\r\n    {\r\n        if (!isCitizen[_address]) return \"\";\r\n        return Helper.uintToString(citizen[_address].username);\r\n    }\r\n\r\n    function getUintUsername(address _address)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return citizen[_address].username;\r\n    }\r\n\r\n    function getRef(address _address)\r\n        public\r\n        view\r\n        returns (address)\r\n    {\r\n        return citizen[_address].ref == 0x0 ? devTeam : citizen[_address].ref;\r\n    }\r\n\r\n    function getRefTo(address _address)\r\n        public\r\n        view\r\n        returns (address[])\r\n    {\r\n        return citizen[_address].refTo;\r\n    }\r\n\r\n    function getRefToById(address _address, uint256 _id)\r\n        public\r\n        view\r\n        returns (address, string, uint256, uint256, uint256, uint256)\r\n    {\r\n        address _refTo = citizen[_address].refTo[_id];\r\n        return (\r\n            _refTo,\r\n            Helper.uintToString(citizen[_refTo].username),\r\n            citizen[_refTo].treeLevel,\r\n            citizen[_refTo].refTo.length,\r\n            citizen[_refTo].refWallet,\r\n            citizen[_refTo].totalSale\r\n            );\r\n    }\r\n\r\n    function getRefToLength(address _address)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return citizen[_address].refTo.length;\r\n    }\r\n\r\n    function getLevelCitizenLength(uint256 _level)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return levelCitizen[_level].length;\r\n    }\r\n\r\n    function getLevelCitizenById(uint256 _level, uint256 _id)\r\n        public\r\n        view\r\n        returns (address)\r\n    {\r\n        return levelCitizen[_level][_id];\r\n    }\r\n\r\n    function getCitizenLevel(address _address)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return citizen[_address].treeLevel;\r\n    }\r\n\r\n    function getLastLevel()\r\n        public\r\n        view\r\n        returns(uint256)\r\n    {\r\n        return lastLevel;\r\n    }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"_username\",\"type\":\"string\"}],\"name\":\"exist\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_sUsername\",\"type\":\"string\"},{\"name\":\"_ref\",\"type\":\"address\"}],\"name\":\"register\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_level\",\"type\":\"uint256\"},{\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"getLevelCitizenById\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getAllRoundRefIncome\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_level\",\"type\":\"uint256\"}],\"name\":\"getLevelCitizenLength\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_contract\",\"type\":\"address[6]\"}],\"name\":\"joinNetwork\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getUintUsername\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_username\",\"type\":\"string\"}],\"name\":\"getAddressByUserName\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getRef\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getRefWallet\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"},{\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"getRefToById\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"string\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getRefTo\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"getAddressById\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"},{\"name\":\"_rId\",\"type\":\"uint256\"}],\"name\":\"getRoundRefIncome\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalRefAllround\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"citizen\",\"outputs\":[{\"name\":\"id\",\"type\":\"uint256\"},{\"name\":\"username\",\"type\":\"uint256\"},{\"name\":\"refWallet\",\"type\":\"uint256\"},{\"name\":\"ref\",\"type\":\"address\"},{\"name\":\"totalChild\",\"type\":\"uint256\"},{\"name\":\"donated\",\"type\":\"uint256\"},{\"name\":\"treeLevel\",\"type\":\"uint256\"},{\"name\":\"totalSale\",\"type\":\"uint256\"},{\"name\":\"allRoundRefIncome\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"withdrawFor\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getCitizenLevel\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"usernameAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getTotalChild\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getRefToLength\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getLastLevel\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"devTeamReinvest\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_sNewUsername\",\"type\":\"string\"}],\"name\":\"updateUsername\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"devTeamWithdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getUsername\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_sender\",\"type\":\"address\"}],\"name\":\"pushRefIncome\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"idAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"isCitizen\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"totalRefByRound\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_devTeam\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_member\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_ref\",\"type\":\"address\"}],\"name\":\"Register\",\"type\":\"event\"}]","ContractName":"Citizen","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"00000000000000000000000096504e1f83e380984b1d4eccc0e8b9f0559b2ad2","Library":"Helper:7d04e6ef521ac2de68ed92318cde4f7332b2c2a7","SwarmSource":"bzzr://de8990fa571cb25cab1e7d0d3019d035587cd3b14da636c5a709d5da3227ead7"}]}