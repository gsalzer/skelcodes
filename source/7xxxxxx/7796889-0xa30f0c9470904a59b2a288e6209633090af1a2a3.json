{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.0;\r\npragma experimental ABIEncoderV2;\r\n// File: contracts/ECDSA.sol\r\n\r\n// pragma solidity >=0.4.21 <0.6.0;\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @title Elliptic curve signature operations\r\n * @dev Based on https://gist.github.com/axic/5b33912c6f61ae6fd96d6c4a47afde6d\r\n * TODO Remove this library once solidity supports passing a signature to ecrecover.\r\n * See https://github.com/ethereum/solidity/issues/864\r\n */\r\n\r\nlibrary ECDSA {\r\n\r\n/**\r\n  * @dev Recover signer address from a message by using their signature\r\n  * @param hash bytes32 message, the hash is the signed message. What is recovered is the signer address.\r\n  * @param signature bytes signature, the signature is generated using web3.eth.sign()\r\n  */\r\nfunction recover(bytes32 hash, bytes memory signature)\r\n    internal\r\n    pure\r\n    returns (address)\r\n{\r\n    bytes32 r;\r\n    bytes32 s;\r\n    uint8 v;\r\n\r\n    // Check the signature length\r\n    if (signature.length != 65) {\r\n        return (address(0));\r\n    }\r\n\r\n    // Divide the signature in r, s and v variables\r\n    // ecrecover takes the signature parameters, and the only way to get them\r\n    // currently is to use assembly.\r\n    // solium-disable-next-line security/no-inline-assembly\r\n    assembly {\r\n        r := mload(add(signature, 0x20))\r\n        s := mload(add(signature, 0x40))\r\n        v := byte(0, mload(add(signature, 0x60)))\r\n    }\r\n\r\n    // Version of signature should be 27 or 28, but 0 and 1 are also possible versions\r\n    if (v < 27) {\r\n        v += 27;\r\n    }\r\n\r\n    // If the version is correct return the signer address\r\n    if (v != 27 && v != 28) {\r\n        return (address(0));\r\n    } else {\r\n        // solium-disable-next-line arg-overflow\r\n        return ecrecover(hash, v, r, s);\r\n    }\r\n}\r\n\r\n    /**\r\n    * toEthSignedMessageHash\r\n    * @dev prefix a bytes32 value with \"\\x19Ethereum Signed Message:\"\r\n    * and hash the result\r\n    */\r\n    function toEthSignedMessageHash(bytes32 hash)\r\n      internal\r\n      pure\r\n      returns (bytes32)\r\n    {\r\n        // 32 is the length in bytes of hash,\r\n        // enforced by the type signature above\r\n        return keccak256(\r\n            abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash)\r\n        );\r\n    }\r\n}\r\n\r\n// File: contracts/lib/RLPReader.sol\r\n\r\n/*\r\n* @author Hamdi Allam hamdi.allam97@gmail.com\r\n* Please reach out with any questions or concerns\r\n*/\r\npragma solidity ^0.5.0;\r\n\r\nlibrary RLPReader {\r\n    uint8 constant STRING_SHORT_START = 0x80;\r\n    uint8 constant STRING_LONG_START  = 0xb8;\r\n    uint8 constant LIST_SHORT_START   = 0xc0;\r\n    uint8 constant LIST_LONG_START    = 0xf8;\r\n\r\n    uint8 constant WORD_SIZE = 32;\r\n\r\n    struct RLPItem {\r\n        uint len;\r\n        uint memPtr;\r\n    }\r\n\r\n    /*\r\n    * @param item RLP encoded bytes\r\n    */\r\n    function toRlpItem(bytes memory item) internal pure returns (RLPItem memory) {\r\n        uint memPtr;\r\n        assembly {\r\n            memPtr := add(item, 0x20)\r\n        }\r\n\r\n        return RLPItem(item.length, memPtr);\r\n    }\r\n\r\n    /*\r\n    * @param item RLP encoded bytes\r\n    */\r\n    function rlpLen(RLPItem memory item) internal pure returns (uint) {\r\n        return item.len;\r\n    }\r\n\r\n    /*\r\n    * @param item RLP encoded bytes\r\n    */\r\n    function payloadLen(RLPItem memory item) internal pure returns (uint) {\r\n        return item.len - _payloadOffset(item.memPtr);\r\n    }\r\n\r\n    /*\r\n    * @param item RLP encoded list in bytes\r\n    */\r\n    function toList(RLPItem memory item) internal pure returns (RLPItem[] memory result) {\r\n        require(isList(item));\r\n\r\n        uint items = numItems(item);\r\n        result = new RLPItem[](items);\r\n\r\n        uint memPtr = item.memPtr + _payloadOffset(item.memPtr);\r\n        uint dataLen;\r\n        for (uint i = 0; i < items; i++) {\r\n            dataLen = _itemLength(memPtr);\r\n            result[i] = RLPItem(dataLen, memPtr); \r\n            memPtr = memPtr + dataLen;\r\n        }\r\n    }\r\n\r\n    // @return indicator whether encoded payload is a list. negate this function call for isData.\r\n    function isList(RLPItem memory item) internal pure returns (bool) {\r\n        if (item.len == 0) return false;\r\n\r\n        uint8 byte0;\r\n        uint memPtr = item.memPtr;\r\n        assembly {\r\n            byte0 := byte(0, mload(memPtr))\r\n        }\r\n\r\n        if (byte0 < LIST_SHORT_START)\r\n            return false;\r\n        return true;\r\n    }\r\n\r\n    /** RLPItem conversions into data types **/\r\n\r\n    // @returns raw rlp encoding in bytes\r\n    function toRlpBytes(RLPItem memory item) internal pure returns (bytes memory) {\r\n        bytes memory result = new bytes(item.len);\r\n        if (result.length == 0) return result;\r\n        \r\n        uint ptr;\r\n        assembly {\r\n            ptr := add(0x20, result)\r\n        }\r\n\r\n        copy(item.memPtr, ptr, item.len);\r\n        return result;\r\n    }\r\n\r\n    // any non-zero byte is considered true\r\n    function toBoolean(RLPItem memory item) internal pure returns (bool) {\r\n        require(item.len == 1);\r\n        uint result;\r\n        uint memPtr = item.memPtr;\r\n        assembly {\r\n            result := byte(0, mload(memPtr))\r\n        }\r\n\r\n        return result == 0 ? false : true;\r\n    }\r\n\r\n    function toAddress(RLPItem memory item) internal pure returns (address) {\r\n        // 1 byte for the length prefix\r\n        require(item.len == 21);\r\n\r\n        return address(toUint(item));\r\n    }\r\n\r\n    function toUint(RLPItem memory item) internal pure returns (uint) {\r\n        require(item.len > 0 && item.len <= 33);\r\n\r\n        uint offset = _payloadOffset(item.memPtr);\r\n        uint len = item.len - offset;\r\n\r\n        uint result;\r\n        uint memPtr = item.memPtr + offset;\r\n        assembly {\r\n            result := mload(memPtr)\r\n\r\n            // shfit to the correct location if neccesary\r\n            if lt(len, 32) {\r\n                result := div(result, exp(256, sub(32, len)))\r\n            }\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    // enforces 32 byte length\r\n    function toUintStrict(RLPItem memory item) internal pure returns (uint) {\r\n        // one byte prefix\r\n        require(item.len == 33);\r\n\r\n        uint result;\r\n        uint memPtr = item.memPtr + 1;\r\n        assembly {\r\n            result := mload(memPtr)\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    function toBytes(RLPItem memory item) internal pure returns (bytes memory) {\r\n        require(item.len > 0);\r\n\r\n        uint offset = _payloadOffset(item.memPtr);\r\n        uint len = item.len - offset; // data length\r\n        bytes memory result = new bytes(len);\r\n\r\n        uint destPtr;\r\n        assembly {\r\n            destPtr := add(0x20, result)\r\n        }\r\n\r\n        copy(item.memPtr + offset, destPtr, len);\r\n        return result;\r\n    }\r\n\r\n    /*\r\n    * Private Helpers\r\n    */\r\n\r\n    // @return number of payload items inside an encoded list.\r\n    function numItems(RLPItem memory item) private pure returns (uint) {\r\n        if (item.len == 0) return 0;\r\n\r\n        uint count = 0;\r\n        uint currPtr = item.memPtr + _payloadOffset(item.memPtr);\r\n        uint endPtr = item.memPtr + item.len;\r\n        while (currPtr < endPtr) {\r\n           currPtr = currPtr + _itemLength(currPtr); // skip over an item\r\n           count++;\r\n        }\r\n\r\n        return count;\r\n    }\r\n\r\n    // @return entire rlp item byte length\r\n    function _itemLength(uint memPtr) private pure returns (uint len) {\r\n        uint byte0;\r\n        assembly {\r\n            byte0 := byte(0, mload(memPtr))\r\n        }\r\n\r\n        if (byte0 < STRING_SHORT_START)\r\n            return 1;\r\n        \r\n        else if (byte0 < STRING_LONG_START)\r\n            return byte0 - STRING_SHORT_START + 1;\r\n\r\n        else if (byte0 < LIST_SHORT_START) {\r\n            assembly {\r\n                let byteLen := sub(byte0, 0xb7) // # of bytes the actual length is\r\n                memPtr := add(memPtr, 1) // skip over the first byte\r\n                \r\n                /* 32 byte word size */\r\n                let dataLen := div(mload(memPtr), exp(256, sub(32, byteLen))) // right shifting to get the len\r\n                len := add(dataLen, add(byteLen, 1))\r\n            }\r\n        }\r\n\r\n        else if (byte0 < LIST_LONG_START) {\r\n            return byte0 - LIST_SHORT_START + 1;\r\n        } \r\n\r\n        else {\r\n            assembly {\r\n                let byteLen := sub(byte0, 0xf7)\r\n                memPtr := add(memPtr, 1)\r\n\r\n                let dataLen := div(mload(memPtr), exp(256, sub(32, byteLen))) // right shifting to the correct length\r\n                len := add(dataLen, add(byteLen, 1))\r\n            }\r\n        }\r\n    }\r\n\r\n    // @return number of bytes until the data\r\n    function _payloadOffset(uint memPtr) private pure returns (uint) {\r\n        uint byte0;\r\n        assembly {\r\n            byte0 := byte(0, mload(memPtr))\r\n        }\r\n\r\n        if (byte0 < STRING_SHORT_START) \r\n            return 0;\r\n        else if (byte0 < STRING_LONG_START || (byte0 >= LIST_SHORT_START && byte0 < LIST_LONG_START))\r\n            return 1;\r\n        else if (byte0 < LIST_SHORT_START)  // being explicit\r\n            return byte0 - (STRING_LONG_START - 1) + 1;\r\n        else\r\n            return byte0 - (LIST_LONG_START - 1) + 1;\r\n    }\r\n\r\n    /*\r\n    * @param src Pointer to source\r\n    * @param dest Pointer to destination\r\n    * @param len Amount of memory to copy from the source\r\n    */\r\n    function copy(uint src, uint dest, uint len) private pure {\r\n        if (len == 0) return;\r\n\r\n        // copy as many word sizes as possible\r\n        for (; len >= WORD_SIZE; len -= WORD_SIZE) {\r\n            assembly {\r\n                mstore(dest, mload(src))\r\n            }\r\n\r\n            src += WORD_SIZE;\r\n            dest += WORD_SIZE;\r\n        }\r\n\r\n        // left over bytes. Mask is used to remove unwanted bytes from the word\r\n        uint mask = 256 ** (WORD_SIZE - len) - 1;\r\n        assembly {\r\n            let srcpart := and(mload(src), not(mask)) // zero out src\r\n            let destpart := and(mload(dest), mask) // retrieve the bytes\r\n            mstore(dest, or(destpart, srcpart))\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/lib/MsDecoder.sol\r\n\r\n// pragma experimental ABIEncoderV2;\r\n\r\n/*\r\n* Used to proxy function calls to the RLPReader for testing\r\n*/\r\n\r\n\r\nlibrary MsDecoder {\r\n    using RLPReader for bytes;\r\n    using RLPReader for uint;\r\n    using RLPReader for RLPReader.RLPItem;\r\n\r\n    struct Message {\r\n        address from;\r\n        address to;\r\n        bytes32 sessionID;\r\n        uint mType;\r\n        bytes content;\r\n        bytes signature;\r\n        // balance proof\r\n        bytes32 channelID;\r\n        uint256 balance;\r\n        uint256 nonce;\r\n        // hash of data related to transfer\r\n        uint256 amount;\r\n        bytes32 additionalHash;\r\n        bytes paymentSignature;\r\n    }\r\n\r\n    function decode(bytes memory data) internal view returns (Message[] memory) {\r\n        RLPReader.RLPItem[] memory messages = data.toRlpItem().toList();\r\n        Message[] memory ms = new Message[](messages.length);\r\n        RLPReader.RLPItem[] memory items;\r\n        for(uint i=0; i<messages.length; i++) {\r\n            items = messages[i].toList();\r\n            ms[i] = Message(items[0].toAddress(), items[1].toAddress(), toBytes32(items[2].toBytes()), items[3].toUint(), items[4].toBytes(), items[5].toBytes(), toBytes32(items[6].toBytes()), items[7].toUint(), items[8].toUint(), items[9].toUint(), toBytes32(items[10].toBytes()), items[11].toBytes());\r\n        }\r\n        return ms;\r\n    }\r\n\r\n    function toBytes32(bytes memory source) internal pure returns (bytes32 result) {\r\n        if (source.length == 0) {\r\n            return 0x0;\r\n        }\r\n        assembly {\r\n            result := mload(add(source, 32))\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/PacketVerify.sol\r\n\r\n// pragma experimental ABIEncoderV2;\r\n\r\n\r\n\r\n\r\n\r\ncontract PacketVerify {\r\n    using RLPReader for bytes;\r\n    using RLPReader for uint;\r\n    using RLPReader for RLPReader.RLPItem;\r\n\r\n    uint256 constant rate = 98;\r\n\r\n    struct State {\r\n        bytes32 prh;\r\n        address token;\r\n        uint256 amount;\r\n        address provider;\r\n        bytes32 pr;\r\n        address loser;\r\n    }\r\n    struct URHash {\r\n        bytes32 urh;\r\n        address user;\r\n        bytes32 urr;\r\n        uint256 m;\r\n    }\r\n    struct PSettle{\r\n        address user;\r\n        uint amount;\r\n    }\r\n\r\n    function verify (\r\n        bytes memory data\r\n    )\r\n        public\r\n        view\r\n        returns(string memory verifyResult, string memory gameInformation, address loser, address[5] memory users, bytes32[5] memory userSecretHashs, bytes32[5] memory userSecrets, uint[5] memory userModules, uint[5] memory userSettleAmounts) //0=success, 1xxx=invalid data, 2xxx=wrong result\r\n    {\r\n        MsDecoder.Message[] memory ms = MsDecoder.decode(data);\r\n        State memory s;\r\n        URHash[] memory urHash = new URHash[](5);\r\n        PSettle[] memory pSettle = new PSettle[](5);\r\n        uint idx = 0;\r\n        // provider start game message\r\n        if (ms[0].mType == 1) {\r\n            RLPReader.RLPItem[] memory items = ms[0].content.toRlpItem().toList();\r\n            s.prh = toBytes32(items[0].toBytes());\r\n            s.token = items[1].toAddress();\r\n            s.amount = items[2].toUint();\r\n            s.provider = ms[0].from;\r\n            gameInformation = string(abi.encodePacked(\"provider: \", addressToString(s.provider), \", token: \", addressToString(s.token), \", wager: \", uintToString(s.amount), \", provider secret hash: \", bytes32ToString(s.prh)));\r\n            // token = s.token;\r\n        } else {\r\n            verifyResult = \"error(-1001): provider should send game information message first\\n\";\r\n            return (verifyResult, gameInformation, loser, users, userSecretHashs, userSecrets, userModules, userSettleAmounts);\r\n        }\r\n        // provider cancel game\r\n        for(uint i=1; i<ms.length; i++){\r\n            if(ms[i].mType == 6 && ms[i].from == s.provider){\r\n                if(verifyCancel(s, ms, i)){\r\n                    verifyResult = \"game canceled, refund success\\n\";\r\n                    return (verifyResult, gameInformation, loser, users, userSecretHashs, userSecrets, userModules, userSettleAmounts);\r\n                } else {\r\n                    verifyResult = \"game canceled, refund failed\\n\";\r\n                    return (verifyResult, gameInformation, loser, users, userSecretHashs, userSecrets, userModules, userSettleAmounts);    \r\n                }\r\n            }\r\n        }\r\n        // provider send hash ready message\r\n        for(uint i=1; i<ms.length; i++){ \r\n            if(ms[i].mType == 3 && ms[i].from == s.provider){\r\n                RLPReader.RLPItem[] memory items = ms[i].content.toRlpItem().toList();\r\n                for(uint k=0; k<5; k++) {\r\n                    urHash[k].user = items[k].toAddress();\r\n                    users[k] = items[k].toAddress();\r\n                }\r\n                idx = 0;\r\n                for(uint j=1; j<i&&idx<5; j++){\r\n                    if(ms[j].mType == 2 && ms[j].to == s.provider && ms[j].from == urHash[idx].user && ms[j].amount == s.amount){\r\n                        urHash[idx].urh = toBytes32(ms[j].content.toRlpItem().toList()[0].toBytes());\r\n                        userSecretHashs[idx] = urHash[idx].urh;\r\n                        idx++;\r\n                    }\r\n                }\r\n                if(idx < 5){\r\n                    verifyResult = \"error(-1002): users provider picked was wrong\\n\";\r\n                    return (verifyResult, gameInformation, loser, users, userSecretHashs, userSecrets, userModules, userSettleAmounts);\r\n                }\r\n                break;\r\n            }\r\n        }\r\n        if(urHash[0].user == address(0)) {\r\n            verifyResult = \"error(-1003): provider did not pick users\\n\";\r\n            return (verifyResult, gameInformation, loser, users, userSecretHashs, userSecrets, userModules, userSettleAmounts);\r\n        }\r\n        // provider settle game\r\n        idx = 0;\r\n        for(uint i=1; i<ms.length&&idx<5; i++){\r\n            if(ms[i].mType == 5 && ms[i].from == s.provider){\r\n                if(idx == 0) {\r\n                    s.pr = toBytes32(ms[i].content.toRlpItem().toList()[0].toBytes());\r\n                    gameInformation = string(abi.encodePacked(gameInformation, \", provider secret: \", bytes32ToString(s.pr)));\r\n                    if (keccak256(abi.encodePacked(s.pr)) != s.prh) {\r\n                        verifyResult = \"error(-1004): provider random was not matched with hash of random\\n\";\r\n                        return (verifyResult, gameInformation, loser, users, userSecretHashs, userSecrets, userModules, userSettleAmounts);\r\n                    }\r\n                } else if(toBytes32(ms[i].content.toRlpItem().toList()[0].toBytes()) != s.pr) {\r\n                    verifyResult = \"error(-1004): provider random was not matched with hash of random\\n\";\r\n                    return (verifyResult, gameInformation, loser, users, userSecretHashs, userSecrets, userModules, userSettleAmounts);\r\n                }\r\n                pSettle[idx].user = ms[i].to;\r\n                pSettle[idx].amount = ms[i].amount;\r\n                userSettleAmounts[idx] = ms[i].amount;\r\n                idx++;\r\n            }\r\n        }\r\n        if(!verifyProviderSettle(urHash, pSettle)) {\r\n            verifyResult = \"error(-1005): provider settle order was not matched with order of users\\n\";\r\n            return (verifyResult, gameInformation, loser, users, userSecretHashs, userSecrets, userModules, userSettleAmounts);\r\n        }\r\n        // provider send random message\r\n        for(uint i=1; i<ms.length; i++){\r\n            if(ms[i].mType == 4 && ms[i].from == s.provider){\r\n                RLPReader.RLPItem[] memory items = ms[i].content.toRlpItem().toList();\r\n                for(uint j=0; j<5; j++){\r\n                    if(keccak256(abi.encodePacked(toBytes32(items[j].toBytes()))) != urHash[j].urh) {\r\n                        verifyResult = \"error(-1006): user random was not matched with hash of random\\n\";\r\n                        return (verifyResult, gameInformation, loser, users, userSecretHashs, userSecrets, userModules, userSettleAmounts);\r\n                    }\r\n                    urHash[j].urr = toBytes32(items[j].toBytes());\r\n                    userSecrets[j] = urHash[j].urr;\r\n                }\r\n            }\r\n        }\r\n        uint256 m = uint256(urHash[0].urr^urHash[1].urr^urHash[2].urr^urHash[3].urr^urHash[4].urr^s.pr)%100 + 100;\r\n        gameInformation = string(abi.encodePacked(gameInformation, \", module: \", uintToString(m)));\r\n        uint256 minRand = 0;\r\n        for (uint i=0; i<5; i++) {\r\n            // uint i = 4 - j;\r\n            // urHash[i].m = uint256(urHash[i].urr)%m;\r\n            urHash[i].m = selectNumber(uint256(urHash[i].urr)%(m-i) + 1, userModules, m);\r\n            userModules[i] = urHash[i].m;\r\n            if(i == 0) {\r\n                s.loser = urHash[i].user;\r\n                minRand = urHash[i].m;\r\n            } else if(urHash[i].m < minRand) {\r\n                minRand = urHash[i].m;\r\n                s.loser = urHash[i].user;\r\n            }\r\n        }\r\n        loser = s.loser;\r\n        // verify if settlement was correct\r\n        for (uint i=0; i<5; i++) {\r\n            if(pSettle[i].user == s.loser) {\r\n                if(pSettle[i].amount != (s.amount*rate/100)*urHash[i].m/(urHash[0].m+urHash[1].m+urHash[2].m+urHash[3].m+urHash[4].m)) {\r\n                    verifyResult = \"error(-1007): wrong settle amount\\n\";\r\n                    return (verifyResult, gameInformation, loser, users, userSecretHashs, userSecrets, userModules, userSettleAmounts);\r\n                }\r\n            } else {\r\n                if(pSettle[i].amount != ((s.amount*rate/100)*urHash[i].m/(urHash[0].m+urHash[1].m+urHash[2].m+urHash[3].m+urHash[4].m)) + s.amount) {\r\n                    verifyResult = \"error(-1007): wrong settle amount\\n\";\r\n                    return (verifyResult, gameInformation, loser, users, userSecretHashs, userSecrets, userModules, userSettleAmounts);\r\n                }\r\n            }\r\n        }\r\n        verifyResult = \"Success!\\n\";\r\n        return (verifyResult, gameInformation, loser, users, userSecretHashs, userSecrets, userModules, userSettleAmounts);\r\n    }\r\n\r\n    function selectNumber(\r\n        uint rand,\r\n        uint[5] memory userModules,\r\n        uint module\r\n    )\r\n        internal\r\n        view\r\n        returns(uint)\r\n    {\r\n        uint temp = rand;\r\n        for(uint i = 1; i < module + 1; i++){\r\n\r\n            bool included = false;\r\n            for(uint j = 0; j < 5; j ++){\r\n                if(userModules[j] == i){\r\n                    included = true;\r\n                    break;\r\n                }\r\n            }\r\n            if(!included) {\r\n                temp --;\r\n            }\r\n            if(temp <= 0){\r\n                return i;\r\n            }\r\n        }\r\n        return module;\r\n    }\r\n\r\n    function verifyCancel (\r\n        State memory s,\r\n        MsDecoder.Message[] memory ms,\r\n        uint cIdx\r\n    )\r\n        internal\r\n        view\r\n        returns(bool)\r\n    {\r\n        address[] memory users = new address[](cIdx);\r\n        uint userLength = 0;\r\n        for(uint i=0; i<cIdx; i++) {\r\n            if(ms[i].mType == 2 && ms[i].to == s.provider  && ms[i].amount == s.amount){\r\n                users[userLength] = ms[i].from;\r\n                userLength++;\r\n            }\r\n        }\r\n        uint idx = 0;\r\n        for(uint j=cIdx; j<ms.length&&idx<userLength; j++) {\r\n            if(ms[j].mType == 7 && ms[j].to == users[idx] && ms[j].amount == s.amount){\r\n                idx++;\r\n            }\r\n        }\r\n        if(idx < userLength) {\r\n            return false;\r\n        } else {\r\n            return true;\r\n        }\r\n    }\r\n\r\n    function verifyProviderSettle (\r\n        URHash[] memory urHash,\r\n        PSettle[] memory pSettle \r\n    )\r\n        internal\r\n        pure\r\n        returns(bool)\r\n    {\r\n        for(uint i=0; i<5; i++) {\r\n            uint j = 0;\r\n            while(urHash[i].user != pSettle[j].user && j<5) j++;\r\n            if(j==5) return false;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    function toBytes32(\r\n        bytes memory source\r\n    ) \r\n        internal \r\n        pure \r\n        returns (bytes32 result) \r\n    {\r\n        if (source.length == 0) {\r\n            return 0x0;\r\n        }\r\n        assembly {\r\n            result := mload(add(source, 32))\r\n        }\r\n    }\r\n\r\n\r\n    function addressToString(address _addr) internal pure returns(string memory) {\r\n        bytes32 value = bytes32(uint256(_addr));\r\n        bytes memory alphabet = \"0123456789abcdef\";\r\n    \r\n        bytes memory str = new bytes(42);\r\n        str[0] = '0';\r\n        str[1] = 'x';\r\n        for (uint i = 0; i < 20; i++) {\r\n            str[2+i*2] = alphabet[uint(uint8(value[i + 12]) >> 4)];\r\n            str[3+i*2] = alphabet[uint(uint8(value[i + 12]) & 0x0f)];\r\n        }\r\n        return string(str);\r\n    }\r\n    \r\n    function bytes32ToString(bytes32 value) internal view returns (string memory) {\r\n        bytes memory alphabet = \"0123456789abcdef\";\r\n        bytes memory str = new bytes(66);\r\n        str[0] = '0';\r\n        str[1] = 'x';\r\n        for (uint i = 0; i < 32; i++) {\r\n            str[2+i*2] = alphabet[uint(uint8(value[i]) >> 4)];\r\n            str[3+i*2] = alphabet[uint(uint8(value[i]) & 0x0f)];\r\n        }\r\n        return string(str);\r\n    }\r\n    \r\n    function uintToString(uint _i) internal pure returns (string memory _uintAsString) {\r\n        if (_i == 0) {\r\n            return \"0\";\r\n        }\r\n        uint j = _i;\r\n        uint len;\r\n        while (j != 0) {\r\n            len++;\r\n            j /= 10;\r\n        }\r\n        bytes memory bstr = new bytes(len);\r\n        uint k = len - 1;\r\n        while (_i != 0) {\r\n            bstr[k--] = byte(uint8(48 + _i % 10));\r\n            _i /= 10;\r\n        }\r\n        return string(bstr);\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"verify\",\"outputs\":[{\"name\":\"verifyResult\",\"type\":\"string\"},{\"name\":\"gameInformation\",\"type\":\"string\"},{\"name\":\"loser\",\"type\":\"address\"},{\"name\":\"users\",\"type\":\"address[5]\"},{\"name\":\"userSecretHashs\",\"type\":\"bytes32[5]\"},{\"name\":\"userSecrets\",\"type\":\"bytes32[5]\"},{\"name\":\"userModules\",\"type\":\"uint256[5]\"},{\"name\":\"userSettleAmounts\",\"type\":\"uint256[5]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"PacketVerify","CompilerVersion":"v0.5.0+commit.1d4f565a","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://e7783d983890609b007d7a33e4bec02e14515de4fc3a8bad8a146c6f968cae6b"}]}