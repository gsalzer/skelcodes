{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.2;\r\n\r\ncontract RLPEncode {\r\n    uint8 constant STRING_SHORT_PREFIX = 0x80;\r\n    uint8 constant STRING_LONG_PREFIX = 0xb7;\r\n    uint8 constant LIST_SHORT_PREFIX = 0xc0;\r\n    uint8 constant LIST_LONG_PREFIX = 0xf7;\r\n\r\n\r\n    function encodeBytes(bytes memory self) internal  returns (bytes memory) {\r\n        bytes memory encoded;\r\n        if(self.length == 1 && uint8(self[0]) < 0x80) {\r\n            encoded = new bytes(1);\r\n            encoded = self;\r\n        } else {\r\n            encoded = encode(self, STRING_SHORT_PREFIX, STRING_LONG_PREFIX);\r\n        }\r\n        return encoded;\r\n    }\r\n\r\n    /// @dev Rlp encodes a bytes[]. Note that the items in the bytes[] will not automatically be rlp encoded.\r\n    /// @param self The bytes[] to be encoded\r\n    /// @return The rlp encoded bytes[]\r\n    function encodeList(bytes[] memory self) internal  returns (bytes memory) {\r\n        bytes memory list = flatten(self);\r\n        bytes memory encoded = encode(list, LIST_SHORT_PREFIX, LIST_LONG_PREFIX);\r\n        return encoded;\r\n    }\r\n\r\n    function encode(bytes memory self, uint8 prefix1, uint8 prefix2) private  returns (bytes memory) {\r\n        uint selfPtr;\r\n        assembly { selfPtr := add(self, 0x20) }\r\n\r\n        bytes memory encoded;\r\n        uint encodedPtr;\r\n\r\n        uint len = self.length;\r\n        uint lenLen;\r\n        uint i = 0x1;\r\n        while(len/i != 0) {\r\n            lenLen++;\r\n            i *= 0x100;\r\n        }\r\n\r\n        if(len <= 55) {\r\n            encoded = new bytes(len+1);\r\n\r\n            // length encoding byte\r\n            encoded[0] = byte(uint8(prefix1+len));\r\n\r\n            // string/list contents\r\n            assembly { encodedPtr := add(encoded, 0x21) }\r\n            memcpy(encodedPtr, selfPtr, len);\r\n        } else {\r\n            // 1 is the length of the length of the length\r\n            encoded = new bytes(1+lenLen+len);\r\n\r\n            // length of the length encoding byte\r\n            encoded[0] = byte(uint8(prefix2+lenLen));\r\n\r\n            // length bytes\r\n            for(i=1; i<=lenLen; i++) {\r\n                encoded[i] = byte(uint8((len/(0x100**(lenLen-i)))%0x100));\r\n            }\r\n\r\n            // string/list contents\r\n            assembly { encodedPtr := add(add(encoded, 0x21), lenLen) }\r\n            memcpy(encodedPtr, selfPtr, len);\r\n        }\r\n        return encoded;\r\n    }\r\n\r\n    function flatten(bytes[] memory self) private  returns (bytes memory) {\r\n        if(self.length == 0) {\r\n            return new bytes(0);\r\n        }\r\n\r\n        uint len;\r\n        for(uint i=0; i<self.length; i++) {\r\n            len += self[i].length;\r\n        }\r\n\r\n        bytes memory flattened = new bytes(len);\r\n        uint flattenedPtr;\r\n        assembly { flattenedPtr := add(flattened, 0x20) }\r\n\r\n        for(uint i=0; i<self.length; i++) {\r\n            bytes memory item = self[i];\r\n\r\n            uint selfPtr;\r\n            assembly { selfPtr := add(item, 0x20)}\r\n\r\n            memcpy(flattenedPtr, selfPtr, item.length);\r\n            flattenedPtr += self[i].length;\r\n        }\r\n\r\n        return flattened;\r\n    }\r\n\r\n    /// This function is from Nick Johnson's string utils library\r\n    function memcpy(uint dest, uint src, uint len) private {\r\n        // Copy word-length chunks while possible\r\n        for(; len >= 32; len -= 32) {\r\n            assembly {\r\n                mstore(dest, mload(src))\r\n            }\r\n            dest += 32;\r\n            src += 32;\r\n        }\r\n\r\n        // Copy remaining bytes\r\n        uint mask = 256 ** (32 - len) - 1;\r\n        assembly {\r\n            let srcpart := and(mload(src), not(mask))\r\n            let destpart := and(mload(dest), mask)\r\n            mstore(dest, or(destpart, srcpart))\r\n        }\r\n    }\r\n\r\n    function strToBytes(string memory data)internal pure returns (bytes memory){\r\n        uint _ascii_0 = 48;\r\n        uint _ascii_A = 65;\r\n        uint _ascii_a = 97;\r\n\r\n        bytes memory a = bytes(data);\r\n        uint[] memory b = new uint[](a.length);\r\n\r\n        for (uint i = 0; i < a.length; i++) {\r\n            uint _a = uint8(a[i]);\r\n\r\n            if (_a > 96) {\r\n                b[i] = _a - 97 + 10;\r\n            }\r\n            else if (_a > 66) {\r\n                b[i] = _a - 65 + 10;\r\n            }\r\n            else {\r\n                b[i] = _a - 48;\r\n            }\r\n        }\r\n\r\n        bytes memory c = new bytes(b.length / 2);\r\n        for (uint _i = 0; _i < b.length; _i += 2) {\r\n            c[_i / 2] = byte(uint8(b[_i] * 16 + b[_i + 1]));\r\n        }\r\n\r\n        return c;\r\n    }\r\n\r\n    function bytesToUint(bytes memory b) internal pure returns (uint256){\r\n        uint256 number;\r\n        for(uint i=0;i<b.length;i++){\r\n            number = number + uint8(b[i])*(2**(8*(b.length-(i+1))));\r\n        }\r\n        return number;\r\n    }\r\n\r\n    function addressToBytes(address a) internal pure returns (bytes memory b){\r\n        assembly {\r\n            let m := mload(0x40)\r\n            mstore(add(m, 20), xor(0x140000000000000000000000000000000000000000, a))\r\n            mstore(0x40, add(m, 52))\r\n            b := m\r\n        }\r\n    }\r\n\r\n    function stringToUint(string memory s) internal pure returns (uint) {\r\n        bytes memory b = bytes(s);\r\n        uint result = 0;\r\n        for (uint i = 0; i < b.length; i++) {\r\n           if (uint8(b[i]) >= 48 && uint8(b[i]) <= 57){\r\n                result = result * 16 + (uint8(b[i]) - 48); // bytes and int are not compatible with the operator -.\r\n            }\r\n            else if(uint8(b[i]) >= 97 && uint8(b[i]) <= 122)\r\n            {\r\n                result = result * 16 + (uint8(b[i]) - 87);\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    function subString(string memory str, uint startIndex, uint endIndex) internal pure returns (string memory) {\r\n        bytes memory strBytes = bytes(str);\r\n        bytes memory result = new bytes(endIndex-startIndex);\r\n        for(uint i = startIndex; i < endIndex; i++) {\r\n            result[i-startIndex] = strBytes[i];\r\n        }\r\n        return string(result);\r\n    }\r\n\r\n    function strConcat(string memory _a, string memory _b) internal pure returns (string memory){\r\n        bytes memory _ba = bytes(_a);\r\n        bytes memory _bb = bytes(_b);\r\n        string memory ab = new string(_ba.length + _bb.length);\r\n        bytes memory bab = bytes(ab);\r\n        uint k = 0;\r\n        for (uint i = 0; i < _ba.length; i++) bab[k++] = _ba[i];\r\n            for (uint i = 0; i < _bb.length; i++) bab[k++] = _bb[i];\r\n                return string(bab);\r\n        }\r\n\r\n    function stringToAddr(string memory _input) internal pure returns (address){\r\n        string memory _a = strConcat(\"0x\",_input);\r\n        bytes memory tmp = bytes(_a);\r\n        uint160 iaddr = 0;\r\n        uint160 b1;\r\n        uint160 b2;\r\n        for (uint i=2; i<2+2*20; i+=2){\r\n            iaddr *= 256;\r\n            b1 = uint8(tmp[i]);\r\n            b2 = uint8(tmp[i+1]);\r\n            if ((b1 >= 97)&&(b1 <= 102)) b1 -= 87;\r\n            else if ((b1 >= 48)&&(b1 <= 57)) b1 -= 48;\r\n            if ((b2 >= 97)&&(b2 <= 102)) b2 -= 87;\r\n            else if ((b2 >= 48)&&(b2 <= 57)) b2 -= 48;\r\n            iaddr += (b1*16+b2);\r\n        }\r\n            return address(iaddr);\r\n    }\r\n\r\n    function addressToString(address _addr) internal pure returns(string memory) {\r\n        bytes32 value = bytes32(uint256(_addr));\r\n        bytes memory alphabet = \"0123456789abcdef\";\r\n\r\n        bytes memory str = new bytes(40);\r\n\r\n        for (uint i = 0; i < 20; i++) {\r\n            str[i*2] = alphabet[uint8(value[i + 12] >> 4)];\r\n            str[1+i*2] = alphabet[uint8(value[i + 12] & 0x0f)];\r\n        }\r\n        return string(str);\r\n    }\r\n    \r\n    function toHexDigit(uint8 d) pure internal returns (byte) {                                                                                      \r\n        if (0 <= d && d <= 9) {                                                                                                                      \r\n            return byte(uint8(byte('0')) + d);                                                                                                       \r\n        } else if (10 <= uint8(d) && uint8(d) <= 15) {                                                                                               \r\n            return byte(uint8(byte('a')) + d - 10);                                                                                                  \r\n        }                                                                                                                                            \r\n    }   \r\n    \r\n    function fromCode(bytes4 code) public pure returns (string memory) {                                                                                    \r\n        bytes memory result = new bytes(8);                                                                                                         \r\n        //result[0] = byte('0');\r\n        //result[1] = byte('x');\r\n        for (uint i=0; i<4; ++i) {\r\n            result[2*i+0] = toHexDigit(uint8(code[i])/16);\r\n            result[2*i+1] = toHexDigit(uint8(code[i])%16);\r\n        }\r\n        return string(result);\r\n    }\r\n    \r\n    \r\n    function getMsgHash(address _destination, string memory _value, string memory _strTransactionData)  internal returns (bytes32){\r\n\r\n        bytes[] memory rawTx = new bytes[](9);\r\n        bytes[] memory bytesArray = new bytes[](9);\r\n\r\n        rawTx[0] = hex\"09\";\r\n        rawTx[1] = hex\"09502f9000\";\r\n        rawTx[2] = hex\"5208\";\r\n        rawTx[3] = addressToBytes(_destination);\r\n        rawTx[4] = strToBytes(_value);\r\n        rawTx[5] = strToBytes(_strTransactionData);\r\n        rawTx[6] = hex\"01\"; //03=testnet,01=mainnet\r\n\r\n        for(uint8 i = 0; i < 9; i++){\r\n            bytesArray[i] = encodeBytes(rawTx[i]);\r\n        }\r\n\r\n        bytes memory bytesList = encodeList(bytesArray);\r\n\r\n        return keccak256(bytesList);\r\n    }\r\n}\r\n\r\n/**\r\n * @title IVTImplementation\r\n * @dev Contract for Implementation applications.\r\n */\r\ncontract IVTImplementation is RLPEncode {\r\n    event Transacted(address _to, address _tokenContractAddress, uint256 _value);\r\n    event Errorlog(uint256 _type, string  _msg);\r\n    \r\n/**\r\n * @dev    ETH转账逻辑处理， 外部函数\r\n * @param  _destination 最终转账目标地址\r\n * @param  _value 最终转账金额，如\"03e8\"\r\n * @param  _strTransactionData 签名数据，v4版本数据结构 [User地址]+[时间戳]\r\n * @param  _v v数组，如[27,28,28]\r\n * @param  _r r数组，如[\"\",\"\",\"\"]\r\n * @param  _s s数组，如[\"\",\"\",\"\"]\r\n * @return {[type]}\r\n */\r\n    function submitTransaction(address payable _destination, string memory _value, string memory _strTransactionData, uint8[] memory _v, bytes32[] memory _r, bytes32[] memory _s)  public {\r\n        IVTUserInterface userTemp = IVTUserInterface(address(this)); \r\n\r\n        processAndCheckParam(_destination, _strTransactionData, _v, _r, _s, userTemp);\r\n\r\n        uint256 transactionValue = RLPEncode.stringToUint(_value);\r\n        bytes32 _msgHash = getMsgHash(_destination, _value, _strTransactionData);\r\n        verifySignatures(userTemp, _msgHash, _v, _r, _s);\r\n\r\n        _destination.transfer(transactionValue); //此时的上下文仍为user合约\r\n\r\n        emit Transacted(_destination, address(0), transactionValue);\r\n    }\r\n\r\n/**\r\n * @dev Token转账逻辑处理\r\n * @param _destination 最终转账目标地址\r\n * @param  _tokenAddress  Token合约地址\r\n * @param  _value 最终转账金额，如\"03e8\"\r\n * @param  _strTransactionData 签名数据，v4版本数据结构 [User地址]+[时间戳]\r\n * @param  _v v数组，如[27,28,28]\r\n * @param  _r r数组，如[\"\",\"\",\"\"]\r\n * @param  _s s数组，如[\"\",\"\",\"\"]\r\n * @param  _tokenType Token版本，v4使用两种规范\r\n * @return {[type]}\r\n */\r\n    function submitTransactionToken(address _destination, address _tokenAddress, string memory _value, string memory _strTransactionData, uint8[] memory _v, bytes32[] memory _r,bytes32[] memory _s, uint256  _tokenType)  public {\r\n        IVTUserInterface userTemp = IVTUserInterface(address(this)); \r\n\r\n        processAndCheckParam(_destination, _strTransactionData, _v, _r, _s, userTemp);\r\n\r\n        uint256 transactionValue = RLPEncode.stringToUint(_value);\r\n        _strTransactionData = RLPEncode.strConcat(_strTransactionData, RLPEncode.addressToString(_tokenAddress));\r\n        bytes32 _msgHash = getMsgHash(_destination, _value, _strTransactionData);\r\n        verifySignatures(userTemp, _msgHash, _v, _r, _s);\r\n\r\n        //此时的上下文仍为user合约--enum update to uint8 param by shitao. 10001 is ERC20_STANDARD ,10002 is ERC20_NONSTANDARD;\r\n        if(10001 == _tokenType){\r\n            ERC20StandardInterface instanceStandard = ERC20StandardInterface(_tokenAddress);\r\n            require(instanceStandard.transfer(_destination, transactionValue));\r\n        }else if(10002 == _tokenType){\r\n            ERC20NonStandardInterface instanceNonStandard = ERC20NonStandardInterface(_tokenAddress);\r\n            instanceNonStandard.transfer(_destination, transactionValue);\r\n        }else{\r\n            emit Errorlog(_tokenType, \"unknownType\");\r\n        }\r\n\r\n        emit Transacted(_tokenAddress , _destination, transactionValue);\r\n    }\r\n\r\n/**\r\n * @dev    校验参数，内部函数\r\n * @param  _destination 最终转账目标地址\r\n * @param  _strTransactionData 签名数据，v4版本数据结构为 [user合约地址]+[时间戳]\r\n * @param  _v 如上\r\n * @param  _r 如上\r\n * @param  _s 如上\r\n * @return \r\n */\r\n    function processAndCheckParam(address _destination, string memory _strTransactionData, uint8[] memory _v, bytes32[] memory _r, bytes32[] memory _s, IVTUserInterface _userTemp) internal {\r\n        require(_destination != address(0)  && _v.length == _r.length && _v.length == _s.length && _v.length > 0);\r\n\r\n        string memory strTransactionId = RLPEncode.subString(_strTransactionData, 40, 48);\r\n        uint256 transactionId = RLPEncode.stringToUint(strTransactionId);\r\n        require(!_userTemp.hasTransactionId(transactionId));\r\n\r\n\r\n        string memory strTransactionAddress = RLPEncode.subString(_strTransactionData, 0, 40);\r\n        address contractAddress = RLPEncode.stringToAddr(strTransactionAddress);\r\n\r\n        //多签地址 == user地址\r\n        require(contractAddress == address(_userTemp));\r\n\r\n        _userTemp.setTransactionId(transactionId);\r\n    }\r\n\r\n/**\r\n * @dev   内部函数，校验签名\r\n * @param _msgHash 签名消息Hash\r\n * @param  _v  如上\r\n * @param  _r  如上\r\n * @param  _s  如上\r\n * @return \r\n */\r\n    function verifySignatures(IVTUserInterface _userTemp, bytes32 _msgHash, uint8[] memory _v, bytes32[] memory _r,bytes32[] memory _s) view internal {\r\n        uint8 hasConfirmed = 0;\r\n        address[] memory tempAddresses = new address[](_v.length);\r\n      \r\n        for (uint8 i = 0; i < _v.length; i++){\r\n            tempAddresses[i] = ecrecover(_msgHash, _v[i], _r[i], _s[i]);\r\n         \r\n            require(_userTemp.hasSigner(tempAddresses[i]));      \r\n            hasConfirmed++;\r\n        }\r\n\r\n\r\n        for (uint8 m = 0; m < _v.length; m++){\r\n            for (uint8 n = m + 1; n< _v.length; n++){\r\n                require(tempAddresses[m] != tempAddresses[n]);\r\n            }\r\n        }\r\n        require(hasConfirmed >= _userTemp.getRequired());\r\n    }\r\n}\r\n\r\n\r\n\r\ncontract ERC20StandardInterface {\r\n    function transfer(address _to, uint256 _value) public returns (bool success);\r\n}\r\n\r\ncontract ERC20NonStandardInterface {\r\n    function transfer(address _to, uint256 _value) public;\r\n}\r\n\r\ncontract IVTUserInterface {\r\n    function setTransactionId(uint256 _time) public;\r\n    function getRequired() public view returns (uint256);\r\n    function hasSigner(address _signer)public view returns(bool);\r\n    function hasTransactionId(uint256 _transactionId)public view returns(bool);\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_destination\",\"type\":\"address\"},{\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"string\"},{\"name\":\"_strTransactionData\",\"type\":\"string\"},{\"name\":\"_v\",\"type\":\"uint8[]\"},{\"name\":\"_r\",\"type\":\"bytes32[]\"},{\"name\":\"_s\",\"type\":\"bytes32[]\"},{\"name\":\"_tokenType\",\"type\":\"uint256\"}],\"name\":\"submitTransactionToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"code\",\"type\":\"bytes4\"}],\"name\":\"fromCode\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_destination\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"string\"},{\"name\":\"_strTransactionData\",\"type\":\"string\"},{\"name\":\"_v\",\"type\":\"uint8[]\"},{\"name\":\"_r\",\"type\":\"bytes32[]\"},{\"name\":\"_s\",\"type\":\"bytes32[]\"}],\"name\":\"submitTransaction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_tokenContractAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Transacted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_type\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_msg\",\"type\":\"string\"}],\"name\":\"Errorlog\",\"type\":\"event\"}]","ContractName":"IVTImplementation","CompilerVersion":"v0.5.2+commit.1df8f40c","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://dd8cf2bad448a310c3414ac7a65eaa63d1e423d442015408f85f574d8ca91c4c"}]}