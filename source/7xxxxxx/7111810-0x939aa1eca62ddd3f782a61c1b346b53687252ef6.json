{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.0;\r\n\r\n/**\r\n * Syndicate\r\n *\r\n * A way to distribute ownership of ether in time\r\n **/\r\n\r\ncontract Syndicate {\r\n\r\n  mapping (address => uint256) public balances;\r\n\r\n  struct Payment {\r\n    address sender;\r\n    address payable receiver;\r\n    uint256 timestamp;\r\n    uint256 time;\r\n    uint256 weiValue;\r\n    uint256 weiPaid;\r\n    bool isFork;\r\n    uint256 parentIndex;\r\n    bool isForked;\r\n    uint256 fork1Index;\r\n    uint256 fork2Index;\r\n  }\r\n\r\n  Payment[] public payments;\r\n\r\n  event PaymentUpdated(uint256 index);\r\n  event PaymentCreated(uint256 index);\r\n  event BalanceUpdated(address payable target);\r\n\r\n  /**\r\n   * Deposit to a given address over a certain amount of time.\r\n   **/\r\n  function deposit(address payable _receiver, uint256 _time) external payable {\r\n    balances[msg.sender] += msg.value;\r\n    emit BalanceUpdated(msg.sender);\r\n    pay(_receiver, msg.value, _time);\r\n  }\r\n\r\n  /**\r\n   * Pay from sender to receiver a certain amount over a certain amount of time.\r\n   **/\r\n  function pay(address payable _receiver, uint256 _weiValue, uint256 _time) public {\r\n    // Verify that the balance is there and value is non-zero\r\n    require(_weiValue <= balances[msg.sender] && _weiValue > 0);\r\n    // Verify the time is non-zero\r\n    require(_time > 0);\r\n    payments.push(Payment({\r\n      sender: msg.sender,\r\n      receiver: _receiver,\r\n      timestamp: block.timestamp,\r\n      time: _time,\r\n      weiValue: _weiValue,\r\n      weiPaid: 0,\r\n      isFork: false,\r\n      parentIndex: 0,\r\n      isForked: false,\r\n      fork1Index: 0,\r\n      fork2Index: 0\r\n    }));\r\n    // Update the balance value of the sender to effectively lock the funds in place\r\n    balances[msg.sender] -= _weiValue;\r\n    emit BalanceUpdated(msg.sender);\r\n    emit PaymentCreated(payments.length - 1);\r\n  }\r\n\r\n  /**\r\n   * Settle an individual payment at the current point in time.\r\n   *\r\n   * Can be called idempotently.\r\n   **/\r\n  function paymentSettle(uint256 index) public {\r\n    uint256 owedWei = paymentWeiOwed(index);\r\n    balances[payments[index].receiver] += owedWei;\r\n    emit BalanceUpdated(payments[index].receiver);\r\n    payments[index].weiPaid += owedWei;\r\n    emit PaymentUpdated(index);\r\n  }\r\n\r\n  /**\r\n   * Return the wei owed on a payment at the current block timestamp.\r\n   **/\r\n  function paymentWeiOwed(uint256 index) public view returns (uint256) {\r\n    requirePaymentIndexInRange(index);\r\n    Payment memory payment = payments[index];\r\n    // Calculate owed wei based on current time and total wei owed/paid\r\n    return max(payment.weiPaid, payment.weiValue * min(block.timestamp - payment.timestamp, payment.time) / payment.time) - payment.weiPaid;\r\n  }\r\n\r\n  /**\r\n   * Forks a payment to another address for the duration of a payment. Allows\r\n   * responsibility of funds to be delegated to other addresses by payment\r\n   * recipient.\r\n   *\r\n   * Payment completion time is unaffected by forking, the only thing that\r\n   * changes is recipient(s).\r\n   *\r\n   * Payments can be forked until weiValue is 0, at which point the Payment is\r\n   * settled. Child payments can also be forked.\r\n   *\r\n   * The genealogy of a payment can be represented as a binary tree.\r\n   **/\r\n  function paymentFork(uint256 index, address payable _receiver, uint256 _weiValue) public {\r\n    Payment memory payment = payments[index];\r\n    // Make sure the payment owner is operating\r\n    require(msg.sender == payment.receiver);\r\n\r\n    uint256 remainingWei = payment.weiValue - payment.weiPaid;\r\n    uint256 remainingTime = max(0, payment.time - (block.timestamp - payment.timestamp));\r\n\r\n    // Ensure there is more remainingWei than requested fork wei\r\n    require(remainingWei > _weiValue);\r\n    require(_weiValue > 0);\r\n\r\n    // Create a new Payment of _weiValue to _receiver over the remaining time of\r\n    // Payment at index\r\n    payments[index].weiValue = payments[index].weiPaid;\r\n    emit PaymentUpdated(index);\r\n\r\n    payments.push(Payment({\r\n      sender: msg.sender,\r\n      receiver: _receiver,\r\n      timestamp: block.timestamp,\r\n      time: remainingTime,\r\n      weiValue: _weiValue,\r\n      weiPaid: 0,\r\n      isFork: true,\r\n      parentIndex: index,\r\n      isForked: false,\r\n      fork1Index: 0,\r\n      fork2Index: 0\r\n    }));\r\n    payments[index].fork1Index = payments.length - 1;\r\n    emit PaymentCreated(payments.length - 1);\r\n\r\n    payments.push(Payment({\r\n      sender: payment.receiver,\r\n      receiver: payment.receiver,\r\n      timestamp: block.timestamp,\r\n      time: remainingTime,\r\n      weiValue: remainingWei - _weiValue,\r\n      weiPaid: 0,\r\n      isFork: true,\r\n      parentIndex: index,\r\n      isForked: false,\r\n      fork1Index: 0,\r\n      fork2Index: 0\r\n    }));\r\n    payments[index].fork2Index = payments.length - 1;\r\n    emit PaymentCreated(payments.length - 1);\r\n\r\n    payments[index].isForked = true;\r\n  }\r\n\r\n  /**\r\n   * Accessor for determining if a given payment is fully settled.\r\n   **/\r\n  function isPaymentSettled(uint256 index) public view returns (bool) {\r\n    requirePaymentIndexInRange(index);\r\n    return payments[index].weiValue == payments[index].weiPaid;\r\n  }\r\n\r\n  /**\r\n   * Reverts if the supplied payment index is out of range.\r\n   **/\r\n  function requirePaymentIndexInRange(uint256 index) public view {\r\n    require(index < payments.length);\r\n  }\r\n\r\n  /**\r\n   * Withdraw target address balance from Syndicate to ether.\r\n   **/\r\n  function withdraw(address payable target, uint256 weiValue) public {\r\n    require(balances[target] >= weiValue);\r\n    balances[target] -= weiValue;\r\n    emit BalanceUpdated(target);\r\n    target.transfer(weiValue);\r\n  }\r\n\r\n  /**\r\n   * One argument, target address.\r\n   **/\r\n  function withdraw(address payable target) public {\r\n    withdraw(target, balances[target]);\r\n  }\r\n\r\n  /**\r\n   * No arguments, withdraws full balance to sender from sender balance.\r\n   **/\r\n  function withdraw() public {\r\n    withdraw(msg.sender, balances[msg.sender]);\r\n  }\r\n\r\n  /**\r\n   * Accessor for array length.\r\n   **/\r\n  function paymentCount() public view returns (uint) {\r\n    return payments.length;\r\n  }\r\n\r\n  /**\r\n   * Return the smaller of two values.\r\n   **/\r\n  function min(uint a, uint b) private pure returns (uint) {\r\n    return a < b ? a : b;\r\n  }\r\n\r\n  /**\r\n   * Return the larger of two values.\r\n   **/\r\n  function max(uint a, uint b) private pure returns (uint) {\r\n    return a > b ? a : b;\r\n  }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"paymentCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"balances\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_receiver\",\"type\":\"address\"},{\"name\":\"_time\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"requirePaymentIndexInRange\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"target\",\"type\":\"address\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"paymentWeiOwed\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_receiver\",\"type\":\"address\"},{\"name\":\"_weiValue\",\"type\":\"uint256\"},{\"name\":\"_time\",\"type\":\"uint256\"}],\"name\":\"pay\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"isPaymentSettled\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"paymentSettle\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"payments\",\"outputs\":[{\"name\":\"sender\",\"type\":\"address\"},{\"name\":\"receiver\",\"type\":\"address\"},{\"name\":\"timestamp\",\"type\":\"uint256\"},{\"name\":\"time\",\"type\":\"uint256\"},{\"name\":\"weiValue\",\"type\":\"uint256\"},{\"name\":\"weiPaid\",\"type\":\"uint256\"},{\"name\":\"isFork\",\"type\":\"bool\"},{\"name\":\"parentIndex\",\"type\":\"uint256\"},{\"name\":\"isForked\",\"type\":\"bool\"},{\"name\":\"fork1Index\",\"type\":\"uint256\"},{\"name\":\"fork2Index\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"index\",\"type\":\"uint256\"},{\"name\":\"_receiver\",\"type\":\"address\"},{\"name\":\"_weiValue\",\"type\":\"uint256\"}],\"name\":\"paymentFork\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"target\",\"type\":\"address\"},{\"name\":\"weiValue\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"PaymentUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"PaymentCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"target\",\"type\":\"address\"}],\"name\":\"BalanceUpdated\",\"type\":\"event\"}]","ContractName":"Syndicate","CompilerVersion":"v0.5.0+commit.1d4f565a","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://eb57ef3789ba5af44334d397804634bb0c9f345aac466b2f8ec003277c27abe3"}]}