{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.25;\r\n\r\n\r\ninterface IOrbsValidatorsRegistry {\r\n\r\n    event ValidatorLeft(address indexed validator);\r\n    event ValidatorRegistered(address indexed validator);\r\n    event ValidatorUpdated(address indexed validator);\r\n\r\n    /// @dev register a validator and provide registration data.\r\n    /// the new validator entry will be owned and identified by msg.sender.\r\n    /// if msg.sender is already registered as a validator in this registry the\r\n    /// transaction will fail.\r\n    /// @param name string The name of the validator\r\n    /// @param ipAddress bytes4 The validator node ip address. If another validator previously registered this ipAddress the transaction will fail\r\n    /// @param website string The website of the validator\r\n    /// @param orbsAddress bytes20 The validator node orbs public address. If another validator previously registered this orbsAddress the transaction will fail\r\n    function register(\r\n        string name,\r\n        bytes4 ipAddress,\r\n        string website,\r\n        bytes20 orbsAddress\r\n    )\r\n        external;\r\n\r\n    /// @dev update the validator registration data entry associated with msg.sender.\r\n    /// msg.sender must be registered in this registry contract.\r\n    /// @param name string The name of the validator\r\n    /// @param ipAddress bytes4 The validator node ip address. If another validator previously registered this ipAddress the transaction will fail\r\n    /// @param website string The website of the validator\r\n    /// @param orbsAddress bytes20 The validator node orbs public address. If another validator previously registered this orbsAddress the transaction will fail\r\n    function update(\r\n        string name,\r\n        bytes4 ipAddress,\r\n        string website,\r\n        bytes20 orbsAddress\r\n    )\r\n        external;\r\n\r\n    /// @dev deletes a validator registration entry associated with msg.sender.\r\n    function leave() external;\r\n\r\n    /// @dev returns validator registration data.\r\n    /// @param validator address address of the validator.\r\n    function getValidatorData(address validator)\r\n        external\r\n        view\r\n        returns (\r\n            string name,\r\n            bytes4 ipAddress,\r\n            string website,\r\n            bytes20 orbsAddress\r\n        );\r\n\r\n    /// @dev returns the blocks in which a validator was registered and last updated.\r\n    /// if validator does not designate a registered validator this method returns zero values.\r\n    /// @param validator address of a validator\r\n    function getRegistrationBlockNumber(address validator)\r\n        external\r\n        view\r\n        returns (uint registeredOn, uint lastUpdatedOn);\r\n\r\n    /// @dev Checks if validator is currently registered as a validator.\r\n    /// @param validator address address of the validator\r\n    /// @return true iff validator belongs to a registered validator\r\n    function isValidator(address validator) external view returns (bool);\r\n\r\n    /// @dev returns the orbs node public address of a specific validator.\r\n    /// @param validator address address of the validator\r\n    /// @return an Orbs node address\r\n    function getOrbsAddress(address validator)\r\n        external\r\n        view\r\n        returns (bytes20 orbsAddress);\r\n}\r\n\r\n\r\n/// @title Orbs Validators Registry smart contract.\r\ncontract OrbsValidatorsRegistry is IOrbsValidatorsRegistry {\r\n\r\n    // The validator registration data object.\r\n    struct ValidatorData {\r\n        string name;\r\n        bytes4 ipAddress;\r\n        string website;\r\n        bytes20 orbsAddress;\r\n        uint registeredOnBlock;\r\n        uint lastUpdatedOnBlock;\r\n    }\r\n\r\n    // The version of the current validators data registration smart contract.\r\n    uint public constant VERSION = 1;\r\n\r\n    // A mapping from validator's Ethereum address to registration data.\r\n    mapping(address => ValidatorData) internal validatorsData;\r\n\r\n    // Lookups for IP Address & Orbs Address for uniqueness checks. Useful also be used for as a public lookup index.\r\n    mapping(bytes4 => address) public lookupByIp;\r\n    mapping(bytes20 => address) public lookupByOrbsAddr;\r\n\r\n    /// @dev check that the caller is a validator.\r\n    modifier onlyValidator() {\r\n        require(isValidator(msg.sender), \"You must be a registered validator\");\r\n        _;\r\n    }\r\n\r\n    /// @dev register a validator and provide registration data.\r\n    /// the new validator entry will be owned and identified by msg.sender.\r\n    /// if msg.sender is already registered as a validator in this registry the\r\n    /// transaction will fail.\r\n    /// @param name string The name of the validator\r\n    /// @param ipAddress bytes4 The validator node ip address. If another validator previously registered this ipAddress the transaction will fail\r\n    /// @param website string The website of the validator\r\n    /// @param orbsAddress bytes20 The validator node orbs public address. If another validator previously registered this orbsAddress the transaction will fail\r\n    function register(\r\n        string name,\r\n        bytes4 ipAddress,\r\n        string website,\r\n        bytes20 orbsAddress\r\n    )\r\n        external\r\n    {\r\n        address sender = msg.sender;\r\n        require(bytes(name).length > 0, \"Please provide a valid name\");\r\n        require(bytes(website).length > 0, \"Please provide a valid website\");\r\n        require(!isValidator(sender), \"Validator already exists\");\r\n        require(ipAddress != bytes4(0), \"Please pass a valid ip address represented as an array of exactly 4 bytes\");\r\n        require(orbsAddress != bytes20(0), \"Please provide a valid Orbs Address\");\r\n        require(lookupByIp[ipAddress] == address(0), \"IP address already in use\");\r\n        require(lookupByOrbsAddr[orbsAddress] == address(0), \"Orbs Address is already in use by another validator\");\r\n\r\n        lookupByIp[ipAddress] = sender;\r\n        lookupByOrbsAddr[orbsAddress] = sender;\r\n\r\n        validatorsData[sender] = ValidatorData({\r\n            name: name,\r\n            ipAddress: ipAddress,\r\n            website: website,\r\n            orbsAddress: orbsAddress,\r\n            registeredOnBlock: block.number,\r\n            lastUpdatedOnBlock: block.number\r\n        });\r\n\r\n        emit ValidatorRegistered(sender);\r\n    }\r\n\r\n    /// @dev update the validator registration data entry associated with msg.sender.\r\n    /// msg.sender must be registered in this registry contract.\r\n    /// @param name string The name of the validator\r\n    /// @param ipAddress bytes4 The validator node ip address. If another validator previously registered this ipAddress the transaction will fail\r\n    /// @param website string The website of the validator\r\n    /// @param orbsAddress bytes20 The validator node orbs public address. If another validator previously registered this orbsAddress the transaction will fail\r\n    function update(\r\n        string name,\r\n        bytes4 ipAddress,\r\n        string website,\r\n        bytes20 orbsAddress\r\n    )\r\n        external\r\n        onlyValidator\r\n    {\r\n        address sender = msg.sender;\r\n        require(bytes(name).length > 0, \"Please provide a valid name\");\r\n        require(bytes(website).length > 0, \"Please provide a valid website\");\r\n        require(ipAddress != bytes4(0), \"Please pass a valid ip address represented as an array of exactly 4 bytes\");\r\n        require(orbsAddress != bytes20(0), \"Please provide a valid Orbs Address\");\r\n        require(isIpFreeToUse(ipAddress), \"IP Address is already in use by another validator\");\r\n        require(isOrbsAddressFreeToUse(orbsAddress), \"Orbs Address is already in use by another validator\");\r\n\r\n        ValidatorData storage data = validatorsData[sender];\r\n\r\n        // Remove previous key from lookup.\r\n        delete lookupByIp[data.ipAddress];\r\n        delete lookupByOrbsAddr[data.orbsAddress];\r\n\r\n        // Set new keys in lookup.\r\n        lookupByIp[ipAddress] = sender;\r\n        lookupByOrbsAddr[orbsAddress] = sender;\r\n\r\n        data.name = name;\r\n        data.ipAddress = ipAddress;\r\n        data.website = website;\r\n        data.orbsAddress = orbsAddress;\r\n        data.lastUpdatedOnBlock = block.number;\r\n\r\n        emit ValidatorUpdated(sender);\r\n    }\r\n\r\n    /// @dev deletes a validator registration entry associated with msg.sender.\r\n    function leave() external onlyValidator {\r\n        address sender = msg.sender;\r\n\r\n        ValidatorData storage data = validatorsData[sender];\r\n\r\n        delete lookupByIp[data.ipAddress];\r\n        delete lookupByOrbsAddr[data.orbsAddress];\r\n\r\n        delete validatorsData[sender];\r\n\r\n        emit ValidatorLeft(sender);\r\n    }\r\n\r\n    /// @dev returns the blocks in which a validator was registered and last updated.\r\n    /// if validator does not designate a registered validator this method returns zero values.\r\n    /// @param validator address of a validator\r\n    function getRegistrationBlockNumber(address validator)\r\n        external\r\n        view\r\n        returns (uint registeredOn, uint lastUpdatedOn)\r\n    {\r\n        require(isValidator(validator), \"Unlisted Validator\");\r\n\r\n        ValidatorData storage entry = validatorsData[validator];\r\n        registeredOn = entry.registeredOnBlock;\r\n        lastUpdatedOn = entry.lastUpdatedOnBlock;\r\n    }\r\n\r\n    /// @dev returns the orbs node public address of a specific validator.\r\n    /// @param validator address address of the validator\r\n    /// @return an Orbs node address\r\n    function getOrbsAddress(address validator)\r\n        external\r\n        view\r\n        returns (bytes20)\r\n    {\r\n        return validatorsData[validator].orbsAddress;\r\n    }\r\n\r\n    /// @dev returns validator registration data.\r\n    /// @param validator address address of the validator.\r\n    function getValidatorData(address validator)\r\n        public\r\n        view\r\n        returns (\r\n            string memory name,\r\n            bytes4 ipAddress,\r\n            string memory website,\r\n            bytes20 orbsAddress\r\n        )\r\n    {\r\n        ValidatorData storage entry = validatorsData[validator];\r\n        name = entry.name;\r\n        ipAddress = entry.ipAddress;\r\n        website = entry.website;\r\n        orbsAddress = entry.orbsAddress;\r\n    }\r\n\r\n    /// @dev Checks if validator is currently registered as a validator.\r\n    /// @param validator address address of the validator\r\n    /// @return true iff validator belongs to a registered validator\r\n    function isValidator(address validator) public view returns (bool) {\r\n        return validatorsData[validator].registeredOnBlock > 0;\r\n    }\r\n\r\n    /// @dev INTERNAL. Checks if ipAddress is currently available to msg.sender.\r\n    /// @param ipAddress bytes4 ip address to check for uniqueness\r\n    /// @return true iff ipAddress is currently not registered for any validator other than msg.sender.\r\n    function isIpFreeToUse(bytes4 ipAddress) internal view returns (bool) {\r\n        return\r\n            lookupByIp[ipAddress] == address(0) ||\r\n            lookupByIp[ipAddress] == msg.sender;\r\n    }\r\n\r\n    /// @dev INTERNAL. Checks if orbsAddress is currently available to msg.sender.\r\n    /// @param orbsAddress bytes20 ip address to check for uniqueness\r\n    /// @return true iff orbsAddress is currently not registered for a validator other than msg.sender.\r\n    function isOrbsAddressFreeToUse(bytes20 orbsAddress)\r\n        internal\r\n        view\r\n        returns (bool)\r\n    {\r\n        return\r\n            lookupByOrbsAddr[orbsAddress] == address(0) ||\r\n            lookupByOrbsAddr[orbsAddress] == msg.sender;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes4\"}],\"name\":\"lookupByIp\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"validator\",\"type\":\"address\"}],\"name\":\"getValidatorData\",\"outputs\":[{\"name\":\"name\",\"type\":\"string\"},{\"name\":\"ipAddress\",\"type\":\"bytes4\"},{\"name\":\"website\",\"type\":\"string\"},{\"name\":\"orbsAddress\",\"type\":\"bytes20\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes20\"}],\"name\":\"lookupByOrbsAddr\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"validator\",\"type\":\"address\"}],\"name\":\"getRegistrationBlockNumber\",\"outputs\":[{\"name\":\"registeredOn\",\"type\":\"uint256\"},{\"name\":\"lastUpdatedOn\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"name\",\"type\":\"string\"},{\"name\":\"ipAddress\",\"type\":\"bytes4\"},{\"name\":\"website\",\"type\":\"string\"},{\"name\":\"orbsAddress\",\"type\":\"bytes20\"}],\"name\":\"update\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"validator\",\"type\":\"address\"}],\"name\":\"getOrbsAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes20\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"name\",\"type\":\"string\"},{\"name\":\"ipAddress\",\"type\":\"bytes4\"},{\"name\":\"website\",\"type\":\"string\"},{\"name\":\"orbsAddress\",\"type\":\"bytes20\"}],\"name\":\"register\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"leave\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"validator\",\"type\":\"address\"}],\"name\":\"isValidator\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"VERSION\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"validator\",\"type\":\"address\"}],\"name\":\"ValidatorLeft\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"validator\",\"type\":\"address\"}],\"name\":\"ValidatorRegistered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"validator\",\"type\":\"address\"}],\"name\":\"ValidatorUpdated\",\"type\":\"event\"}]","ContractName":"OrbsValidatorsRegistry","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://b11a7b5f90e22f286d427439a150b562fd8d06ade6da146b7558605c44548eed"}]}