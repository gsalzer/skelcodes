{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\ninterface CitizenInterface {\r\n    /*----------  READ FUNCTIONS  ----------*/\r\n    function getUsername(address _address) public view returns (string);\r\n    function getRef(address _address) public view returns (address);\r\n}\r\n\r\ninterface F2mInterface {\r\n    function pushDividends() public payable;\r\n}\r\n\r\nlibrary SafeMath {\r\n    int256 constant private INT256_MIN = -2**255;\r\n\r\n    /**\r\n    * @dev Multiplies two unsigned integers, reverts on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Multiplies two signed integers, reverts on overflow.\r\n    */\r\n    function mul(int256 a, int256 b) internal pure returns (int256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        require(!(a == -1 && b == INT256_MIN)); // This is the only case of overflow not detected by the check below\r\n\r\n        int256 c = a * b;\r\n        require(c / a == b);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two signed integers truncating the quotient, reverts on division by zero.\r\n    */\r\n    function div(int256 a, int256 b) internal pure returns (int256) {\r\n        require(b != 0); // Solidity only automatically asserts when dividing by 0\r\n        require(!(b == -1 && a == INT256_MIN)); // This is the only case of overflow\r\n\r\n        int256 c = a / b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two signed integers, reverts on overflow.\r\n    */\r\n    function sub(int256 a, int256 b) internal pure returns (int256) {\r\n        int256 c = a - b;\r\n        require((b >= 0 && c <= a) || (b < 0 && c > a));\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two unsigned integers, reverts on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two signed integers, reverts on overflow.\r\n    */\r\n    function add(int256 a, int256 b) internal pure returns (int256) {\r\n        int256 c = a + b;\r\n        require((b >= 0 && c >= a) || (b < 0 && c < a));\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\r\n    * reverts when dividing by zero.\r\n    */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}\r\n\r\ncontract Helper {\r\n    uint256 constant public GAS_COST = 0.002 ether;\r\n    uint256 constant public MAX_BLOCK_DISTANCE = 254;\r\n    uint256 constant public ZOOM = 1000000000;\r\n\r\n    function getKeyBlockNr(uint256 _estKeyBlockNr)\r\n        public\r\n        view\r\n        returns(uint256)\r\n    {\r\n        require(block.number > _estKeyBlockNr, \"blockHash not avaiable\");\r\n        uint256 jump = (block.number - _estKeyBlockNr) / MAX_BLOCK_DISTANCE * MAX_BLOCK_DISTANCE;\r\n        return _estKeyBlockNr + jump;\r\n    }\r\n\r\n    function getSeed(uint256 _keyBlockNr)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        // Key Block not mined atm\r\n        if (block.number <= _keyBlockNr) return block.number;\r\n        return uint256(blockhash(_keyBlockNr));\r\n    }\r\n\r\n    function getWinTeam(\r\n        uint256 _seed,\r\n        uint256 _trueAmount,\r\n        uint256 _falseAmount\r\n    )\r\n        public\r\n        pure\r\n        returns (bool)\r\n    {\r\n        uint256 _sum = _trueAmount + _falseAmount;\r\n        if (_sum == 0) return true;\r\n        return (_seed % _sum) < _trueAmount;\r\n    }\r\n\r\n    function getWinningPerWei(\r\n        uint256 _winTeam,\r\n        uint256 _lostTeam\r\n    )\r\n        public\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return _lostTeam * ZOOM / _winTeam;\r\n    }\r\n\r\n    function getMin(\r\n        uint256 a,\r\n        uint256 b\r\n    )\r\n        public\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return a < b ? a : b;\r\n    }\r\n}\r\n\r\ncontract SimpleDice is Helper{\r\n    using SafeMath for uint256;\r\n\r\n    event Payment(address indexed _winner, uint _amount, bool _success);\r\n\r\n    modifier onlyDevTeam() {\r\n        require(msg.sender == devTeam, \"only development team\");\r\n        _;\r\n    }\r\n\r\n    modifier betable() {\r\n        uint256 _keyBlock = rounds[curRoundId].keyBlock;\r\n        require(msg.value >= MIN_BET, \"betAmount too low\");\r\n        require(block.number <= _keyBlock, \"round locked\");\r\n        _;\r\n    }\r\n\r\n    modifier roundLocked() {\r\n        uint256 _keyBlock = rounds[curRoundId].keyBlock;\r\n        require(block.number > _keyBlock, \"still betable\");\r\n        _;\r\n    }\r\n\r\n    struct Bet{\r\n        address buyer;\r\n        uint256 amount;\r\n    }\r\n\r\n    struct Round {\r\n        mapping(bool => Bet[]) bets;\r\n        mapping(bool => uint256) betSum;\r\n\r\n        uint256 keyBlock;\r\n        bool finalized;\r\n        bool winTeam;\r\n        uint256 cashoutFrom;\r\n        uint256 winningPerWei; // Zoomed\r\n    }\r\n    \r\n    uint256 constant public TAXED_PERCENT = 95;\r\n    uint256 constant public BLOCK_TIME = 15;\r\n    uint256 constant public DURATION = 300; // 5 min.\r\n    uint256 constant public MIN_BET = 0.05 ether;\r\n    uint256 constant public F2M_PERCENT = 10;\r\n    uint256 constant public MAX_ROUND = 888888888;\r\n\r\n    uint256 public MAX_CASHOUT_PER_BLOCK = 100;\r\n\r\n    address public devTeam;\r\n    F2mInterface public f2mContract;\r\n    uint256 public fund;\r\n\r\n    uint256 public curRoundId;\r\n    mapping(uint256 => Round) public rounds;\r\n    mapping(address => mapping(uint256 => mapping(bool => uint256))) pRoundBetSum;\r\n\r\n    CitizenInterface public citizenContract;\r\n\r\n    constructor(address _devTeam, address _citizen) public {\r\n        devTeam = _devTeam;\r\n        citizenContract = CitizenInterface(_citizen);\r\n        initRound();\r\n    }\r\n\r\n    function devTeamWithdraw()\r\n        public\r\n        onlyDevTeam()\r\n    {\r\n        require(fund > 0, \"nothing to withdraw\");\r\n        uint256 _toF2m = fund / 100 * F2M_PERCENT;\r\n        uint256 _toDevTeam = fund - _toF2m;\r\n        fund = 0;\r\n        f2mContract.pushDividends.value(_toF2m)();\r\n        devTeam.transfer(_toDevTeam);\r\n    }\r\n\r\n    function initRound()\r\n        private\r\n    {\r\n        curRoundId++;\r\n        Round memory _round;\r\n        _round.keyBlock = MAX_ROUND; // block.number + 1 + DURATION / BLOCK_TIME;\r\n        rounds[curRoundId] = _round;\r\n    }\r\n\r\n    function finalize()\r\n        private\r\n    {\r\n        uint256 _keyBlock = getKeyBlockNr(rounds[curRoundId].keyBlock);\r\n        uint256 _seed = getSeed(_keyBlock);\r\n        bool _winTeam = _seed % 2 == 0;\r\n        //getWinTeam(_seed, rounds[curRoundId].betSum[true], rounds[curRoundId].betSum[false]);\r\n        rounds[curRoundId].winTeam = _winTeam;\r\n        // winAmount Per Wei zoomed \r\n        rounds[curRoundId].winningPerWei = getWinningPerWei(rounds[curRoundId].betSum[_winTeam], rounds[curRoundId].betSum[!_winTeam]);\r\n        rounds[curRoundId].finalized = true;\r\n        fund = address(this).balance - rounds[curRoundId].betSum[_winTeam] - rounds[curRoundId].betSum[!_winTeam];\r\n    }\r\n\r\n    function payment(\r\n        address _buyer,\r\n        uint256 _winAmount\r\n    ) \r\n        private\r\n    {\r\n        bool success = _buyer.send(_winAmount);\r\n        emit Payment(_buyer, _winAmount, success);\r\n    }\r\n\r\n    function distribute()\r\n        private\r\n    {\r\n        address _buyer;\r\n        uint256 _betAmount;\r\n        uint256 _winAmount;\r\n        uint256 _from = rounds[curRoundId].cashoutFrom;\r\n        bool _winTeam = rounds[curRoundId].winTeam;\r\n        uint256 _teamBets = rounds[curRoundId].bets[_winTeam].length;\r\n        uint256 _to = getMin(_teamBets, _from + MAX_CASHOUT_PER_BLOCK);\r\n        uint256 _perWei = rounds[curRoundId].winningPerWei;\r\n        \r\n        //GAS BURNING \r\n        while (_from < _to) {\r\n            _buyer = rounds[curRoundId].bets[_winTeam][_from].buyer;\r\n            _betAmount = rounds[curRoundId].bets[_winTeam][_from].amount;\r\n            _winAmount = _betAmount / ZOOM * _perWei + _betAmount;\r\n            payment(_buyer, _winAmount);\r\n            _from++;\r\n        }\r\n        rounds[curRoundId].cashoutFrom = _from;\r\n    }\r\n\r\n    function isDistributed()\r\n        public\r\n        view\r\n        returns (bool)\r\n    {\r\n        bool _winTeam = rounds[curRoundId].winTeam;\r\n        return (rounds[curRoundId].cashoutFrom == rounds[curRoundId].bets[_winTeam].length);\r\n    }\r\n\r\n    function endRound()\r\n        public\r\n        roundLocked()\r\n    {\r\n        if (!rounds[curRoundId].finalized) finalize();\r\n        distribute();\r\n        if (isDistributed()) initRound();\r\n    }\r\n\r\n    // _team = {true, false}\r\n    function bet(\r\n        bool _team\r\n    )\r\n        public\r\n        payable\r\n        betable()\r\n    {\r\n        // active timer if both Teams got player(s)\r\n        if (rounds[curRoundId].betSum[_team] == 0 && rounds[curRoundId].betSum[!_team] > 0) \r\n            rounds[curRoundId].keyBlock = block.number + 1 + DURATION / BLOCK_TIME;\r\n        address _sender = msg.sender;\r\n        uint256 _betAmount = (msg.value).sub(GAS_COST);\r\n        address _ref = getRef(msg.sender);\r\n        _ref.transfer(_betAmount / 100);\r\n        _betAmount = _betAmount / 100 * TAXED_PERCENT;\r\n        \r\n        Bet memory _bet = Bet(_sender, _betAmount);\r\n        rounds[curRoundId].bets[_team].push(_bet);\r\n        rounds[curRoundId].betSum[_team] += _betAmount;\r\n\r\n        pRoundBetSum[_sender][curRoundId][_team] += _betAmount;\r\n    }\r\n\r\n    // BACKEND FUNCTION\r\n\r\n    function distributeSetting(uint256 _limit)\r\n        public\r\n        onlyDevTeam()\r\n    {\r\n        require(_limit >= 1, \"cashout at least for one each tx\");\r\n        MAX_CASHOUT_PER_BLOCK = _limit;\r\n    }\r\n\r\n    function setF2mContract(address _address)\r\n        public\r\n    {\r\n        require(address(f2mContract) == 0x0, \"already set\");\r\n        f2mContract = F2mInterface(_address);\r\n    }\r\n\r\n    // READING FUNCTIONS\r\n\r\n    // if return true\r\n    // Backend : call endRound()\r\n    function isLocked() \r\n        public\r\n        view\r\n        returns(bool)\r\n    {\r\n        return rounds[curRoundId].keyBlock <= block.number;\r\n    }\r\n\r\n    function getRef(address _address)\r\n        public\r\n        view\r\n        returns(address)\r\n    {\r\n        address _ref = citizenContract.getRef(_address);\r\n        return _ref;\r\n    }\r\n\r\n    function getUsername(address _address)\r\n        public\r\n        view\r\n        returns (string)\r\n    {\r\n        return citizenContract.getUsername(_address);\r\n    }\r\n\r\n    function getBlockDist()\r\n        public\r\n        view\r\n        returns(uint256)\r\n    {\r\n        if (rounds[curRoundId].keyBlock == MAX_ROUND) return MAX_ROUND;\r\n        if (rounds[curRoundId].keyBlock <= block.number) return 0;\r\n        return rounds[curRoundId].keyBlock - block.number;\r\n\r\n    }\r\n\r\n    function getRoundResult(uint256 _rId)\r\n        public\r\n        view\r\n        returns(\r\n            uint256, // _trueAmount,\r\n            uint256, // _falseAmount,\r\n            uint256, // _trueBets\r\n            uint256, // _falseBets\r\n            uint256, // curBlock\r\n            uint256, // keyBlock\r\n            bool,\r\n            bool // winTeam\r\n        )\r\n    {\r\n        Round storage _round = rounds[_rId];\r\n        return(\r\n            _round.betSum[true],\r\n            _round.betSum[false],\r\n            _round.bets[true].length,\r\n            _round.bets[false].length,\r\n            block.number,\r\n            _round.keyBlock,\r\n            _round.finalized,\r\n            _round.winTeam\r\n        );\r\n    }\r\n\r\n    function getCurRoundResult()\r\n        public\r\n        view\r\n        returns(\r\n            uint256, // _trueAmount\r\n            uint256, // _falseAmount\r\n            uint256, // _trueBets\r\n            uint256, // _falseBets\r\n            uint256, // curBlock\r\n            uint256, // keyBlock\r\n            bool, // finalized\r\n            bool // winTeam\r\n        )\r\n    {\r\n        Round storage _round = rounds[curRoundId];\r\n        return(\r\n            _round.betSum[true],\r\n            _round.betSum[false],\r\n            _round.bets[true].length,\r\n            _round.bets[false].length,\r\n            block.number,\r\n            _round.keyBlock,\r\n            _round.finalized,\r\n            _round.winTeam\r\n        );\r\n    }\r\n\r\n    function getPRoundBetSum(address _player, uint256 _rId)\r\n        public\r\n        view\r\n        returns(string, uint256[2])\r\n    {\r\n        string memory _username = getUsername(_player);\r\n        return (_username, [pRoundBetSum[_player][_rId][true], pRoundBetSum[_player][_rId][false]]);\r\n    }\r\n\r\n    function getRoundBetById(uint256 _rId, bool _team, uint256 _id)\r\n        public\r\n        view\r\n        returns(address, string, uint256)\r\n    {\r\n        address _address = rounds[_rId].bets[_team][_id].buyer;\r\n        string memory _username = getUsername(_address);\r\n        return (_address, _username, rounds[_rId].bets[_team][_id].amount);\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"_rId\",\"type\":\"uint256\"}],\"name\":\"getRoundResult\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"bool\"},{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCurRoundResult\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"bool\"},{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"curRoundId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"a\",\"type\":\"uint256\"},{\"name\":\"b\",\"type\":\"uint256\"}],\"name\":\"getMin\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_estKeyBlockNr\",\"type\":\"uint256\"}],\"name\":\"getKeyBlockNr\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"setF2mContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"DURATION\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_CASHOUT_PER_BLOCK\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"F2M_PERCENT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"f2mContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_seed\",\"type\":\"uint256\"},{\"name\":\"_trueAmount\",\"type\":\"uint256\"},{\"name\":\"_falseAmount\",\"type\":\"uint256\"}],\"name\":\"getWinTeam\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getBlockDist\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_winTeam\",\"type\":\"uint256\"},{\"name\":\"_lostTeam\",\"type\":\"uint256\"}],\"name\":\"getWinningPerWei\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_BLOCK_DISTANCE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_team\",\"type\":\"bool\"}],\"name\":\"bet\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ZOOM\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getRef\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TAXED_PERCENT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MIN_BET\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"endRound\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"rounds\",\"outputs\":[{\"name\":\"keyBlock\",\"type\":\"uint256\"},{\"name\":\"finalized\",\"type\":\"bool\"},{\"name\":\"winTeam\",\"type\":\"bool\"},{\"name\":\"cashoutFrom\",\"type\":\"uint256\"},{\"name\":\"winningPerWei\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isLocked\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_rId\",\"type\":\"uint256\"},{\"name\":\"_team\",\"type\":\"bool\"},{\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"getRoundBetById\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"string\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_limit\",\"type\":\"uint256\"}],\"name\":\"distributeSetting\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_ROUND\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"fund\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"GAS_COST\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"citizenContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"devTeamWithdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getUsername\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"devTeam\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_keyBlockNr\",\"type\":\"uint256\"}],\"name\":\"getSeed\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_player\",\"type\":\"address\"},{\"name\":\"_rId\",\"type\":\"uint256\"}],\"name\":\"getPRoundBetSum\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"},{\"name\":\"\",\"type\":\"uint256[2]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isDistributed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"BLOCK_TIME\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_devTeam\",\"type\":\"address\"},{\"name\":\"_citizen\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_winner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_success\",\"type\":\"bool\"}],\"name\":\"Payment\",\"type\":\"event\"}]","ContractName":"SimpleDice","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000ac72cb0564eb7b915c8f85252ec5c1c05d546981000000000000000000000000d7657bdf782f43ba7f5f5e8456b481616e636ae9","Library":"","SwarmSource":"bzzr://02c31e914e4f3f60e93ea15c33f82329d542de718652726d617ef97441c593f8"}]}