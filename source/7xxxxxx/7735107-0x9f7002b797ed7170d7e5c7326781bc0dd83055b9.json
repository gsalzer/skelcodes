{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.8;\r\n\r\n\r\nlibrary SafeMath {\r\n    function add(uint a, uint b) internal pure returns (uint c) {\r\n        c = a + b;\r\n        require(c >= a);\r\n    }\r\n\r\n    function sub(uint a, uint b) internal pure returns (uint c) {\r\n        require(b <= a);\r\n        c = a - b;\r\n    }\r\n}\r\n\r\n\r\ninterface IERC20 {\r\n  function balanceOf(address owner) external view returns (uint256 balance);\r\n  function transfer(address to, uint256 value) external returns (bool success);\r\n  function transferFrom(address from, address to, uint256 value) external returns (bool success);\r\n  function approve(address spender, uint256 value) external returns (bool success);\r\n  function allowance(address owner, address spender) external view returns (uint256 remaining);\r\n\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\n/// @dev This is taken from https://github.com/OpenZeppelin/openzeppelin-solidity project.\r\n/// https://github.com/OpenZeppelin/openzeppelin-solidity/blob/67bca857eedf99bf44a4b6a0fc5b5ed553135316/contracts/token/ERC20/ERC20.sol\r\ncontract ERC20 is IERC20 {\r\n  using SafeMath for uint256;\r\n\r\n  string public constant name = \"CAPZ\";\r\n  string public constant symbol = \"CAPZ\";\r\n  uint8 public constant decimals = 18;\r\n\r\n  /// @dev Total number of tokens in existence.\r\n  uint256 public totalSupply;\r\n\r\n  mapping(address => uint256) internal balances;\r\n  mapping(address => mapping(address => uint256)) internal allowed;\r\n\r\n  /// @dev Gets the balance of the specified address.\r\n  /// @param owner The address to query the balance of.\r\n  /// @return A uint256 representing the amount owned by the passed address.\r\n  function balanceOf(address owner) external view returns (uint256) {\r\n    return balances[owner];\r\n  }\r\n\r\n  /// @dev Transfer token to a specified address.\r\n  /// @param to The address to transfer to.\r\n  /// @param value The amount to be transferred.\r\n  function transfer(address to, uint256 value) external returns (bool) {\r\n    _transfer(msg.sender, to, value);\r\n    return true;\r\n  }\r\n\r\n  /// @dev Transfer tokens from one address to another.\r\n  /// Note that while this function emits an Approval event, this is not required as per the specification,\r\n  /// and other compliant implementations may not emit the event.\r\n  /// @param from The address which you want to send tokens from\r\n  /// @param to The address which you want to transfer to\r\n  /// @param value The amount of tokens to be transferred\r\n  function transferFrom(address from, address to, uint256 value) external returns (bool) {\r\n    _transfer(from, to, value);\r\n    _approve(from, msg.sender, allowed[from][msg.sender].sub(value));\r\n    return true;\r\n  }\r\n\r\n  /// @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n  /// Beware that changing an allowance with this method brings the risk that someone may use both the old\r\n  /// and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\r\n  /// race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\r\n  /// https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n  /// @param spender The address which will spend the funds.\r\n  /// @param value The amount of tokens to be spent.\r\n  function approve(address spender, uint256 value) external returns (bool) {\r\n    _approve(msg.sender, spender, value);\r\n    return true;\r\n  }\r\n\r\n  /// @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n  /// @param owner The address which owns the funds.\r\n  /// @param spender The address which will spend the funds.\r\n  /// @return A uint256 specifying the amount of tokens still available for the spender.\r\n  function allowance(address owner, address spender) external view returns (uint256) {\r\n    return allowed[owner][spender];\r\n  }\r\n\r\n  /// @dev Internal function that transfer token for a specified addresses.\r\n  /// @param from The address to transfer from.\r\n  /// @param to The address to transfer to.\r\n  /// @param value The amount to be transferred.\r\n  function _transfer(address from, address to, uint256 value) internal {\r\n    require(address(this) != to);\r\n    require(address(0) != to);\r\n\r\n    balances[from] = balances[from].sub(value);\r\n    balances[to] = balances[to].add(value);\r\n\r\n    emit Transfer(from, to, value);\r\n  }\r\n\r\n  /// @dev Approve an address to spend another addresses' tokens.\r\n  /// @param owner The address that owns the tokens.\r\n  /// @param spender The address that will spend the tokens.\r\n  /// @param value The number of tokens that can be spent.\r\n  function _approve(address owner, address spender, uint256 value) internal {\r\n    require(address(0) != owner);\r\n    require(address(0) != spender);\r\n\r\n    allowed[owner][spender] = value;\r\n\r\n    emit Approval(owner, spender, value);\r\n  }\r\n\r\n  /// @dev Internal function that mints an amount of the token and assigns it to\r\n  /// an account. This encapsulates the modification of balances such that the\r\n  /// proper events are emitted.\r\n  /// @param account The account that will receive the created tokens.\r\n  /// @param value The amount that will be created.\r\n  function _mint(address account, uint256 value) internal {\r\n    require(address(0) != account);\r\n\r\n    totalSupply = totalSupply.add(value);\r\n    balances[account] = balances[account].add(value);\r\n\r\n    emit Transfer(address(0), account, value);\r\n  }\r\n}\r\n\r\n\r\n/// @notice The CAPZ contract has a finite date span and a financial\r\n/// goal set in wei. While this contract is in force, users may buy\r\n/// tokens. After certain conditions are met, token holders may either\r\n/// refund the paid amount or claim the tokens in the form of points\r\n/// with us. The availability of each operation depends on the result\r\n/// of this contract. During the period that the contract is in force\r\n/// (w.r.t. the dates and goals) the funds are locked and can only be\r\n/// unlocked when status is GoalReached or GoalNotReached.\r\ncontract CAPZ is ERC20 {\r\n  using SafeMath for uint256;\r\n\r\n  /// @dev This is us. We use it internally to allow/deny usage of\r\n  /// admininstrative functions.\r\n  address internal owner;\r\n\r\n  /// @notice The current wei amount that this contract has\r\n  /// received. It also represents the number of tokens that have been\r\n  /// granted.\r\n  uint256 public balanceInWei;\r\n\r\n  /// @notice The soft limit that we check against for success at the\r\n  /// end of this contract. These limits may change over the course of\r\n  /// this crowdsale contract as we want to adjust these values to\r\n  /// match a certain amount in fiat currency.\r\n  uint256 public goalLimitMinInWei;\r\n\r\n  /// @title Same as goalLimitMinInWei but defines the hard limit. In\r\n  /// the event this amount is received we do not wait for the end\r\n  /// date to collect received funds and close the contract.\r\n  uint256 public goalLimitMaxInWei;\r\n\r\n  /// @notice The date (unix timestamp) which this contract terminates.\r\n  uint256 public endOn;\r\n\r\n  /// @notice The date (unix timestamp) which this contract starts.\r\n  uint256 public startOn;\r\n\r\n  /// @dev Internal struct that tracks the refunds made so far.\r\n  mapping(address => uint256) internal refunds;\r\n\r\n  /// @title The current status of this contract.\r\n  enum ICOStatus {\r\n    /// @notice The contract is not yet in force.\r\n    NotOpen,\r\n    /// @notice The contract is in force, accepting payments and\r\n    /// granting tokens.\r\n    Open,\r\n    /// @notice The contract has terminated with success and the owner\r\n    /// of this contract may withdraw the amount in wei. The contract\r\n    /// may terminate prior the endOn date on the event that the\r\n    /// goalLimitMaxInWei has been reached.\r\n    GoalReached,\r\n    /// @notice The contract has terminated and the goal not been\r\n    /// reached. Token holders may refund the invested value.\r\n    GoalNotReached\r\n  }\r\n\r\n  constructor (uint256 _startOn, uint256 _endOn, uint256 _goalLimitMinInWei, uint256 _goalLimitMaxInWei) public {\r\n    require(_startOn < _endOn);\r\n    require(_goalLimitMinInWei < _goalLimitMaxInWei);\r\n\r\n    owner = msg.sender;\r\n    endOn = _endOn;\r\n    startOn = _startOn;\r\n    goalLimitMaxInWei = _goalLimitMaxInWei;\r\n    goalLimitMinInWei = _goalLimitMinInWei;\r\n  }\r\n\r\n  function () external payable {\r\n    require(0 == msg.data.length);\r\n\r\n    buyTokens();\r\n  }\r\n\r\n  /// @notice The function that allow users to buy tokens. This\r\n  /// function shall grant the amount received in wei to tokens. As\r\n  /// this is an standard ERC20 contract you may trade these tokens at\r\n  /// any time if desirable. At the end of the contract, you may\r\n  /// either claim these tokens or refund the amount paid. Refer to\r\n  /// these two functions for more information about the rules.\r\n  /// @dev Receives wei and _mint the received amount to the\r\n  /// msg.sender. Emits a Transfer event, using address(0) as the\r\n  /// source address. It also increases the totalSupply and balanceInWei.\r\n  function buyTokens() public whenOpen payable {\r\n    uint256 receivedAmount = msg.value;\r\n    address beneficiary = msg.sender;\r\n    uint256 newBalance = balanceInWei.add(receivedAmount);\r\n    uint256 newRefundBalance = refunds[beneficiary].add(receivedAmount);\r\n\r\n    _mint(beneficiary, receivedAmount);\r\n    refunds[beneficiary] = newRefundBalance;\r\n    balanceInWei = newBalance;\r\n  }\r\n\r\n  /// @notice In the event the contract has terminated [status is\r\n  /// GoalNotReached] and the goal has not been reached users may\r\n  /// refund the amount paid [disregarding gas expenses].\r\n  function escrowRefund() external whenGoalNotReached {\r\n    uint256 amount = refunds[msg.sender];\r\n\r\n    require(address(0) != msg.sender);\r\n    require(0 < amount);\r\n\r\n    refunds[msg.sender] = 0;\r\n    msg.sender.transfer(amount);\r\n  }\r\n\r\n  /// @notice This is an administrative function and can only be\r\n  /// called by the contract's owner when the status is\r\n  /// GoalReached. If these conditions are met the balance is\r\n  /// transferred to the contract's owner.\r\n  function escrowWithdraw() external onlyOwner whenGoalReached {\r\n    uint256 amount = address(this).balance;\r\n\r\n    require(address(0) != msg.sender);\r\n    require(0 < amount);\r\n\r\n    msg.sender.transfer(amount);\r\n  }\r\n\r\n  /// @notice This function is used in the event the contract's status\r\n  /// is GoalReached. It allows the user to exchange tokens in\r\n  /// points. The conversion rate is variable and is not defined in\r\n  /// this contract.\r\n  /// @param amount The tokens you want to convert in points.\r\n  /// @dev Emits the Claim event.\r\n  function escrowClaim(uint256 amount) external whenGoalReached {\r\n    _transfer(msg.sender, owner, amount);\r\n    emit Claim(msg.sender, amount);\r\n  }\r\n\r\n  /// @notice Administrative function that allows the contract's owner\r\n  /// to change the goals. As the goals are set in fiat currency, this\r\n  /// mechanism might be used to adjust the goal so that the goal\r\n  /// won't suffer from severe ETH fluctuations. Notice this function\r\n  /// can't be used when the status is GoalNotReached or GoalReached.\r\n  /// @dev Emits the GoalChange event.\r\n  function alterGoal(uint256 _goalLimitMinInWei, uint256 _goalLimitMaxInWei) external onlyOwner {\r\n    ICOStatus status = status(block.timestamp);\r\n\r\n    require(ICOStatus.GoalReached != status);\r\n    require(ICOStatus.GoalNotReached != status);\r\n    require(_goalLimitMinInWei < _goalLimitMaxInWei);\r\n\r\n    goalLimitMinInWei = _goalLimitMinInWei;\r\n    goalLimitMaxInWei = _goalLimitMaxInWei;\r\n\r\n    emit GoalChange(_goalLimitMinInWei, _goalLimitMaxInWei);\r\n  }\r\n\r\n  /// @notice Administrative function.\r\n  function transferOwnership(address newOwner) external onlyOwner {\r\n    require(address(0) != newOwner);\r\n    require(address(this) != newOwner);\r\n\r\n    owner = newOwner;\r\n  }\r\n\r\n  /// @notice Returns the current status of the contract. All functions\r\n  /// depend on this to enforce invariants, like allowing/denying\r\n  /// refund or withdraw. Please refer to ICOStatus enum documentation\r\n  /// for more information about each status in detail.\r\n  function status() external view returns (ICOStatus) {\r\n    return status(block.timestamp);\r\n  }\r\n\r\n  /// @dev internal function that receives a timestamp instead of\r\n  /// reading from block.timestamp.\r\n  function status(uint256 timestamp) internal view returns (ICOStatus) {\r\n    if (timestamp < startOn) {\r\n      return ICOStatus.NotOpen;\r\n    } else if (timestamp < endOn && balanceInWei < goalLimitMaxInWei) {\r\n      return ICOStatus.Open;\r\n    } else if (balanceInWei >= goalLimitMinInWei) {\r\n      return ICOStatus.GoalReached;\r\n    } else {\r\n      return ICOStatus.GoalNotReached;\r\n    }\r\n  }\r\n\r\n  /// @notice Event emitted when the contract's owner has adjusted the\r\n  /// goal. Refer to alterGoal function for more information.\r\n  event GoalChange(uint256 goalLimitMinInWei, uint256 goalLimitMaxInWei);\r\n\r\n  /// @notice Event emitted when the user has exchanged tokens per\r\n  /// points.\r\n  event Claim(address beneficiary, uint256 value);\r\n\r\n  modifier onlyOwner() {\r\n    require(owner == msg.sender);\r\n    _;\r\n  }\r\n\r\n  modifier whenOpen() {\r\n    require(ICOStatus.Open == status(block.timestamp));\r\n    _;\r\n  }\r\n\r\n  modifier whenGoalReached() {\r\n    require(ICOStatus.GoalReached == status(block.timestamp));\r\n    _;\r\n  }\r\n\r\n  modifier whenGoalNotReached() {\r\n    require(ICOStatus.GoalNotReached == status(block.timestamp));\r\n    _;\r\n  }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"endOn\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_goalLimitMinInWei\",\"type\":\"uint256\"},{\"name\":\"_goalLimitMaxInWei\",\"type\":\"uint256\"}],\"name\":\"alterGoal\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"status\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"escrowClaim\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"goalLimitMinInWei\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"escrowWithdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startOn\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"escrowRefund\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"goalLimitMaxInWei\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"buyTokens\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"balanceInWei\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_startOn\",\"type\":\"uint256\"},{\"name\":\"_endOn\",\"type\":\"uint256\"},{\"name\":\"_goalLimitMinInWei\",\"type\":\"uint256\"},{\"name\":\"_goalLimitMaxInWei\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"goalLimitMinInWei\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"goalLimitMaxInWei\",\"type\":\"uint256\"}],\"name\":\"GoalChange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Claim\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"CAPZ","CompilerVersion":"v0.5.8+commit.23d335f2","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000000000000000000000000000000000005cdabbd0000000000000000000000000000000000000000000000000000000005d5162d00000000000000000000000000000000000000000000000ccab92f10c8a8780000000000000000000000000000000000000000000000028ffe87c47beb1535800","Library":"","SwarmSource":"bzzr://c813660ededb7f35dd37929091d590e9580f39cde95ad67977b3d0c16b7b057f"}]}