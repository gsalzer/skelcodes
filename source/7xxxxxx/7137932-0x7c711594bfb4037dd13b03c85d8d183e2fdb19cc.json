{"status":"1","message":"OK","result":[{"SourceCode":"/**\r\n * Copyright 2017â€“2018, bZeroX, LLC. All Rights Reserved.\r\n * Licensed under the Apache License, Version 2.0.\r\n */\r\n \r\npragma solidity 0.5.3;\r\n\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * See https://github.com/ethereum/EIPs/issues/179\r\n */\r\ncontract ERC20Basic {\r\n  function totalSupply() public view returns (uint256);\r\n  function balanceOf(address _who) public view returns (uint256);\r\n  function transfer(address _to, uint256 _value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address _owner, address _spender)\r\n    public view returns (uint256);\r\n\r\n  function transferFrom(address _from, address _to, uint256 _value)\r\n    public returns (bool);\r\n\r\n  function approve(address _spender, uint256 _value) public returns (bool);\r\n  event Approval(\r\n    address indexed owner,\r\n    address indexed spender,\r\n    uint256 value\r\n  );\r\n}\r\n\r\ncontract EIP20 is ERC20 {\r\n    string public name;\r\n    uint8 public decimals;\r\n    string public symbol;\r\n}\r\n\r\ninterface NonCompliantEIP20 {\r\n    function transfer(address _to, uint256 _value) external;\r\n    function transferFrom(address _from, address _to, uint256 _value) external;\r\n    function approve(address _spender, uint256 _value) external;\r\n}\r\n\r\ncontract EIP20Wrapper {\r\n\r\n    function eip20Transfer(\r\n        address token,\r\n        address to,\r\n        uint256 value)\r\n        internal\r\n        returns (bool result) {\r\n\r\n        NonCompliantEIP20(token).transfer(to, value);\r\n\r\n        assembly {\r\n            switch returndatasize()   \r\n            case 0 {                        // non compliant ERC20\r\n                result := not(0)            // result is true\r\n            }\r\n            case 32 {                       // compliant ERC20\r\n                returndatacopy(0, 0, 32) \r\n                result := mload(0)          // result == returndata of external call\r\n            }\r\n            default {                       // not an not an ERC20 token\r\n                revert(0, 0) \r\n            }\r\n        }\r\n\r\n        require(result, \"eip20Transfer failed\");\r\n    }\r\n\r\n    function eip20TransferFrom(\r\n        address token,\r\n        address from,\r\n        address to,\r\n        uint256 value)\r\n        internal\r\n        returns (bool result) {\r\n\r\n        NonCompliantEIP20(token).transferFrom(from, to, value);\r\n\r\n        assembly {\r\n            switch returndatasize()   \r\n            case 0 {                        // non compliant ERC20\r\n                result := not(0)            // result is true\r\n            }\r\n            case 32 {                       // compliant ERC20\r\n                returndatacopy(0, 0, 32) \r\n                result := mload(0)          // result == returndata of external call\r\n            }\r\n            default {                       // not an not an ERC20 token\r\n                revert(0, 0) \r\n            }\r\n        }\r\n\r\n        require(result, \"eip20TransferFrom failed\");\r\n    }\r\n\r\n    function eip20Approve(\r\n        address token,\r\n        address spender,\r\n        uint256 value)\r\n        internal\r\n        returns (bool result) {\r\n\r\n        NonCompliantEIP20(token).approve(spender, value);\r\n\r\n        assembly {\r\n            switch returndatasize()   \r\n            case 0 {                        // non compliant ERC20\r\n                result := not(0)            // result is true\r\n            }\r\n            case 32 {                       // compliant ERC20\r\n                returndatacopy(0, 0, 32) \r\n                result := mload(0)          // result == returndata of external call\r\n            }\r\n            default {                       // not an not an ERC20 token\r\n                revert(0, 0) \r\n            }\r\n        }\r\n\r\n        require(result, \"eip20Approve failed\");\r\n    }\r\n}\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\r\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (_a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    c = _a * _b;\r\n    assert(c / _a == _b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    // assert(_b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = _a / _b;\r\n    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\r\n    return _a / _b;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, rounding up and truncating the quotient\r\n  */\r\n  function divCeil(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    if (_a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    return ((_a - 1) / _b) + 1;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    assert(_b <= _a);\r\n    return _a - _b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\r\n    c = _a + _b;\r\n    assert(c >= _a);\r\n    return c;\r\n  }\r\n}\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n  event OwnershipTransferred(\r\n    address indexed previousOwner,\r\n    address indexed newOwner\r\n  );\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  constructor() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address _newOwner) public onlyOwner {\r\n    _transferOwnership(_newOwner);\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function _transferOwnership(address _newOwner) internal {\r\n    require(_newOwner != address(0));\r\n    emit OwnershipTransferred(owner, _newOwner);\r\n    owner = _newOwner;\r\n  }\r\n}\r\n\r\ncontract BZxOwnable is Ownable {\r\n\r\n    address public bZxContractAddress;\r\n\r\n    event BZxOwnershipTransferred(address indexed previousBZxContract, address indexed newBZxContract);\r\n\r\n    // modifier reverts if bZxContractAddress isn't set\r\n    modifier onlyBZx() {\r\n        require(msg.sender == bZxContractAddress, \"only bZx contracts can call this function\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev Allows the current owner to transfer the bZx contract owner to a new contract address\r\n    * @param newBZxContractAddress The bZx contract address to transfer ownership to.\r\n    */\r\n    function transferBZxOwnership(address newBZxContractAddress) public onlyOwner {\r\n        require(newBZxContractAddress != address(0) && newBZxContractAddress != owner, \"transferBZxOwnership::unauthorized\");\r\n        emit BZxOwnershipTransferred(bZxContractAddress, newBZxContractAddress);\r\n        bZxContractAddress = newBZxContractAddress;\r\n    }\r\n\r\n    /**\r\n    * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n    * @param newOwner The address to transfer ownership to.\r\n    * This overrides transferOwnership in Ownable to prevent setting the new owner the same as the bZxContract\r\n    */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        require(newOwner != address(0) && newOwner != bZxContractAddress, \"transferOwnership::unauthorized\");\r\n        emit OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n}\r\n\r\ninterface ExchangeInterface {\r\n    event LogError(uint8 indexed errorId, bytes32 indexed orderHash);\r\n\r\n    function fillOrder(\r\n          address[5] calldata orderAddresses,\r\n          uint256[6] calldata orderValues,\r\n          uint256 fillTakerTokenAmount,\r\n          bool shouldThrowOnInsufficientBalanceOrAllowance,\r\n          uint8 v,\r\n          bytes32 r,\r\n          bytes32 s)\r\n          external\r\n          returns (uint256 filledTakerTokenAmount);\r\n\r\n    function fillOrdersUpTo(\r\n        address[5][] calldata orderAddresses,\r\n        uint256[6][] calldata orderValues,\r\n        uint256 fillTakerTokenAmount,\r\n        bool shouldThrowOnInsufficientBalanceOrAllowance,\r\n        uint8[] calldata v,\r\n        bytes32[] calldata r,\r\n        bytes32[] calldata s)\r\n        external\r\n        returns (uint256);\r\n\r\n    function isValidSignature(\r\n        address signer,\r\n        bytes32 hash,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s)\r\n        external\r\n        view\r\n        returns (bool);\r\n}\r\n\r\ncontract BZxTo0xShared {\r\n    using SafeMath for uint256;\r\n\r\n    /// @dev Calculates partial value given a numerator and denominator rounded down.\r\n    ///      Reverts if rounding error is >= 0.1%\r\n    /// @param numerator Numerator.\r\n    /// @param denominator Denominator.\r\n    /// @param target Value to calculate partial of.\r\n    /// @return Partial value of target rounded down.\r\n    function _safeGetPartialAmountFloor(\r\n        uint256 numerator,\r\n        uint256 denominator,\r\n        uint256 target\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256 partialAmount)\r\n    {\r\n        require(\r\n            denominator > 0,\r\n            \"DIVISION_BY_ZERO\"\r\n        );\r\n\r\n        require(\r\n            !_isRoundingErrorFloor(\r\n                numerator,\r\n                denominator,\r\n                target\r\n            ),\r\n            \"ROUNDING_ERROR\"\r\n        );\r\n        \r\n        partialAmount = SafeMath.div(\r\n            SafeMath.mul(numerator, target),\r\n            denominator\r\n        );\r\n        return partialAmount;\r\n    }\r\n\r\n    /// @dev Checks if rounding error >= 0.1% when rounding down.\r\n    /// @param numerator Numerator.\r\n    /// @param denominator Denominator.\r\n    /// @param target Value to multiply with numerator/denominator.\r\n    /// @return Rounding error is present.\r\n    function _isRoundingErrorFloor(\r\n        uint256 numerator,\r\n        uint256 denominator,\r\n        uint256 target\r\n    )\r\n        internal\r\n        pure\r\n        returns (bool isError)\r\n    {\r\n        require(\r\n            denominator > 0,\r\n            \"DIVISION_BY_ZERO\"\r\n        );\r\n        \r\n        // The absolute rounding error is the difference between the rounded\r\n        // value and the ideal value. The relative rounding error is the\r\n        // absolute rounding error divided by the absolute value of the\r\n        // ideal value. This is undefined when the ideal value is zero.\r\n        //\r\n        // The ideal value is `numerator * target / denominator`.\r\n        // Let's call `numerator * target % denominator` the remainder.\r\n        // The absolute error is `remainder / denominator`.\r\n        //\r\n        // When the ideal value is zero, we require the absolute error to\r\n        // be zero. Fortunately, this is always the case. The ideal value is\r\n        // zero iff `numerator == 0` and/or `target == 0`. In this case the\r\n        // remainder and absolute error are also zero. \r\n        if (target == 0 || numerator == 0) {\r\n            return false;\r\n        }\r\n        \r\n        // Otherwise, we want the relative rounding error to be strictly\r\n        // less than 0.1%.\r\n        // The relative error is `remainder / (numerator * target)`.\r\n        // We want the relative error less than 1 / 1000:\r\n        //        remainder / (numerator * denominator)  <  1 / 1000\r\n        // or equivalently:\r\n        //        1000 * remainder  <  numerator * target\r\n        // so we have a rounding error iff:\r\n        //        1000 * remainder  >=  numerator * target\r\n        uint256 remainder = mulmod(\r\n            target,\r\n            numerator,\r\n            denominator\r\n        );\r\n        isError = SafeMath.mul(1000, remainder) >= SafeMath.mul(numerator, target);\r\n        return isError;\r\n    }\r\n}\r\n\r\ncontract BZxTo0x is BZxTo0xShared, EIP20Wrapper, BZxOwnable {\r\n    using SafeMath for uint256;\r\n\r\n    address public exchangeContract;\r\n    address public zrxTokenContract;\r\n    address public tokenTransferProxyContract;\r\n\r\n    constructor(\r\n        address _exchange,\r\n        address _zrxToken,\r\n        address _proxy)\r\n        public\r\n    {\r\n        exchangeContract = _exchange;\r\n        zrxTokenContract = _zrxToken;\r\n        tokenTransferProxyContract = _proxy;\r\n    }\r\n\r\n    function()\r\n        external {\r\n        revert();\r\n    }\r\n\r\n   function take0xTrade(\r\n        address trader,\r\n        address vaultAddress,\r\n        uint256 sourceTokenAmountToUse,\r\n        bytes memory orderData0x, // 0x order arguments, converted to hex, padded to 32 bytes and concatenated\r\n        bytes memory signature0x) // ECDSA of the 0x order\r\n        public\r\n        onlyBZx\r\n        returns (\r\n            address destTokenAddress,\r\n            uint256 destTokenAmount,\r\n            uint256 sourceTokenUsedAmount)\r\n    {\r\n        (address[5][] memory orderAddresses0x, uint256[6][] memory orderValues0x) = getOrderValuesFromData(orderData0x);\r\n\r\n        (sourceTokenUsedAmount, destTokenAmount) = _take0xTrade(\r\n            trader,\r\n            sourceTokenAmountToUse,\r\n            orderAddresses0x,\r\n            orderValues0x,\r\n            signature0x);\r\n\r\n        if (sourceTokenUsedAmount < sourceTokenAmountToUse) {\r\n            // all sourceToken has to be traded\r\n            revert(\"BZxTo0x::take0xTrade: sourceTokenUsedAmount < sourceTokenAmountToUse\");\r\n        }\r\n\r\n        // transfer the destToken to the vault\r\n        eip20Transfer(\r\n            orderAddresses0x[0][2],\r\n            vaultAddress,\r\n            destTokenAmount);\r\n\r\n        destTokenAddress = orderAddresses0x[0][2]; // makerToken (aka destTokenAddress)\r\n    }\r\n\r\n    function getOrderValuesFromData(\r\n        bytes memory orderData0x)\r\n        public\r\n        pure\r\n        returns (\r\n            address[5][] memory orderAddresses,\r\n            uint256[6][] memory orderValues)\r\n    {\r\n        address maker;\r\n        address taker;\r\n        address makerToken;\r\n        address takerToken;\r\n        address feeRecipient;\r\n        uint256 makerTokenAmount;\r\n        uint256 takerTokenAmount;\r\n        uint256 makerFee;\r\n        uint256 takerFee;\r\n        uint256 expirationTimestampInSec;\r\n        uint256 salt;\r\n        orderAddresses = new address[5][](orderData0x.length/352);\r\n        orderValues = new uint256[6][](orderData0x.length/352);\r\n        for (uint256 i = 0; i < orderData0x.length/352; i++) {\r\n            assembly {\r\n                maker := mload(add(orderData0x, add(mul(i, 352), 32)))\r\n                taker := mload(add(orderData0x, add(mul(i, 352), 64)))\r\n                makerToken := mload(add(orderData0x, add(mul(i, 352), 96)))\r\n                takerToken := mload(add(orderData0x, add(mul(i, 352), 128)))\r\n                feeRecipient := mload(add(orderData0x, add(mul(i, 352), 160)))\r\n                makerTokenAmount := mload(add(orderData0x, add(mul(i, 352), 192)))\r\n                takerTokenAmount := mload(add(orderData0x, add(mul(i, 352), 224)))\r\n                makerFee := mload(add(orderData0x, add(mul(i, 352), 256)))\r\n                takerFee := mload(add(orderData0x, add(mul(i, 352), 288)))\r\n                expirationTimestampInSec := mload(add(orderData0x, add(mul(i, 352), 320)))\r\n                salt := mload(add(orderData0x, add(mul(i, 352), 352)))\r\n            }\r\n            orderAddresses[i] = [\r\n                maker,\r\n                taker,\r\n                makerToken,\r\n                takerToken,\r\n                feeRecipient\r\n            ];\r\n            orderValues[i] = [\r\n                makerTokenAmount,\r\n                takerTokenAmount,\r\n                makerFee,\r\n                takerFee,\r\n                expirationTimestampInSec,\r\n                salt\r\n            ];\r\n        }\r\n    }\r\n\r\n    /// @param signatures ECDSA signatures in raw bytes (rsv).\r\n    function getSignatureParts(\r\n        bytes memory signatures)\r\n        public\r\n        pure\r\n        returns (\r\n            uint8[] memory vs,\r\n            bytes32[] memory rs,\r\n            bytes32[] memory ss)\r\n    {\r\n        vs = new uint8[](signatures.length/65);\r\n        rs = new bytes32[](signatures.length/65);\r\n        ss = new bytes32[](signatures.length/65);\r\n        for (uint256 i = 0; i < signatures.length/65; i++) {\r\n            uint8 v;\r\n            bytes32 r;\r\n            bytes32 s;\r\n            assembly {\r\n                r := mload(add(signatures, add(mul(i, 65), 32)))\r\n                s := mload(add(signatures, add(mul(i, 65), 64)))\r\n                v := mload(add(signatures, add(mul(i, 65), 65)))\r\n            }\r\n            if (v < 27) {\r\n                v = v + 27;\r\n            }\r\n            vs[i] = v;\r\n            rs[i] = r;\r\n            ss[i] = s;\r\n        }\r\n    }\r\n\r\n    function set0xExchange (\r\n        address _exchange)\r\n        public\r\n        onlyOwner\r\n    {\r\n        exchangeContract = _exchange;\r\n    }\r\n\r\n    function setZRXToken (\r\n        address _zrxToken)\r\n        public\r\n        onlyOwner\r\n    {\r\n        zrxTokenContract = _zrxToken;\r\n    }\r\n\r\n    function set0xTokenProxy (\r\n        address _proxy)\r\n        public\r\n        onlyOwner\r\n    {\r\n        tokenTransferProxyContract = _proxy;\r\n    }\r\n\r\n    function approveFor (\r\n        address token,\r\n        address spender,\r\n        uint256 value)\r\n        public\r\n        onlyOwner\r\n        returns (bool)\r\n    {\r\n        eip20Approve(\r\n            token,\r\n            spender,\r\n            value);\r\n\r\n        return true;\r\n    }\r\n\r\n    function _take0xTrade(\r\n        address trader,\r\n        uint256 sourceTokenAmountToUse,\r\n        address[5][] memory orderAddresses0x,\r\n        uint256[6][] memory orderValues0x,\r\n        bytes memory signature)\r\n        internal\r\n        returns (uint256 sourceTokenUsedAmount, uint256 destTokenAmount)\r\n    {\r\n        uint256[4] memory summations; // takerTokenAmountTotal, makerTokenAmountTotal, zrxTokenAmount, takerTokenRemaining\r\n        summations[3] = sourceTokenAmountToUse; // takerTokenRemaining\r\n\r\n        for (uint256 i = 0; i < orderAddresses0x.length; i++) {\r\n            // Note: takerToken is confirmed to be the same in 0x for batch orders\r\n            require(orderAddresses0x[i][2] == orderAddresses0x[0][2], \"makerToken must be the same for each order\"); // // makerToken (aka destTokenAddress) must be the same for each order\r\n\r\n            summations[0] = summations[0].add(orderValues0x[i][1]); // takerTokenAmountTotal\r\n            summations[1] = summations[1].add(orderValues0x[i][0]); // makerTokenAmountTotal\r\n\r\n            // calculate required takerFee\r\n            if (summations[3] > 0 && orderAddresses0x[i][4] != address(0) && // feeRecipient\r\n                    orderValues0x[i][3] > 0 // takerFee\r\n            ) {\r\n                if (summations[3] >= orderValues0x[i][1]) {\r\n                    summations[2] = summations[2].add(orderValues0x[i][3]); // takerFee\r\n                    summations[3] = summations[3].sub(orderValues0x[i][1]); // takerTokenAmount\r\n                } else {\r\n                    summations[2] = summations[2].add(_safeGetPartialAmountFloor(\r\n                        summations[3],\r\n                        orderValues0x[i][1], // takerTokenAmount\r\n                        orderValues0x[i][3] // takerFee\r\n                    ));\r\n                    summations[3] = 0;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (summations[2] > 0) {\r\n            // The 0x TokenTransferProxy already has unlimited transfer allowance for ZRX from this contract (set during deployment of this contract)\r\n            eip20TransferFrom(\r\n                zrxTokenContract,\r\n                trader,\r\n                address(this),\r\n                summations[2]);\r\n        }\r\n\r\n        (uint8[] memory v, bytes32[] memory r, bytes32[] memory s) = getSignatureParts(signature);\r\n\r\n        // Make sure there is enough allowance for 0x Exchange Proxy to transfer the sourceToken needed for the 0x trade\r\n        // orderAddresses0x[0][3] -> takerToken/sourceToken\r\n        uint256 tempAllowance = EIP20(orderAddresses0x[0][3]).allowance(address(this), tokenTransferProxyContract);\r\n        if (tempAllowance < sourceTokenAmountToUse) {\r\n            if (tempAllowance > 0) {\r\n                // reset approval to 0\r\n                eip20Approve(\r\n                    orderAddresses0x[0][3],\r\n                    tokenTransferProxyContract,\r\n                    0);\r\n            }\r\n\r\n            eip20Approve(\r\n                orderAddresses0x[0][3],\r\n                tokenTransferProxyContract,\r\n                sourceTokenAmountToUse);\r\n        }\r\n\r\n        if (orderAddresses0x.length > 1) {\r\n            sourceTokenUsedAmount = ExchangeInterface(exchangeContract).fillOrdersUpTo(\r\n                orderAddresses0x,\r\n                orderValues0x,\r\n                sourceTokenAmountToUse,\r\n                false, // shouldThrowOnInsufficientBalanceOrAllowance\r\n                v,\r\n                r,\r\n                s);\r\n        } else {\r\n            sourceTokenUsedAmount = ExchangeInterface(exchangeContract).fillOrder(\r\n                orderAddresses0x[0],\r\n                orderValues0x[0],\r\n                sourceTokenAmountToUse,\r\n                false, // shouldThrowOnInsufficientBalanceOrAllowance\r\n                v[0],\r\n                r[0],\r\n                s[0]);\r\n        }\r\n\r\n        destTokenAmount = _safeGetPartialAmountFloor(\r\n            sourceTokenUsedAmount,\r\n            summations[0], // takerTokenAmountTotal (aka sourceTokenAmount)\r\n            summations[1]  // makerTokenAmountTotal (aka destTokenAmount)\r\n        );\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_exchange\",\"type\":\"address\"}],\"name\":\"set0xExchange\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"approveFor\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"exchangeContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_zrxToken\",\"type\":\"address\"}],\"name\":\"setZRXToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"trader\",\"type\":\"address\"},{\"name\":\"vaultAddress\",\"type\":\"address\"},{\"name\":\"sourceTokenAmountToUse\",\"type\":\"uint256\"},{\"name\":\"orderData0x\",\"type\":\"bytes\"},{\"name\":\"signature0x\",\"type\":\"bytes\"}],\"name\":\"take0xTrade\",\"outputs\":[{\"name\":\"destTokenAddress\",\"type\":\"address\"},{\"name\":\"destTokenAmount\",\"type\":\"uint256\"},{\"name\":\"sourceTokenUsedAmount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newBZxContractAddress\",\"type\":\"address\"}],\"name\":\"transferBZxOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"orderData0x\",\"type\":\"bytes\"}],\"name\":\"getOrderValuesFromData\",\"outputs\":[{\"name\":\"orderAddresses\",\"type\":\"address[5][]\"},{\"name\":\"orderValues\",\"type\":\"uint256[6][]\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenTransferProxyContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"zrxTokenContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bZxContractAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"signatures\",\"type\":\"bytes\"}],\"name\":\"getSignatureParts\",\"outputs\":[{\"name\":\"vs\",\"type\":\"uint8[]\"},{\"name\":\"rs\",\"type\":\"bytes32[]\"},{\"name\":\"ss\",\"type\":\"bytes32[]\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_proxy\",\"type\":\"address\"}],\"name\":\"set0xTokenProxy\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_exchange\",\"type\":\"address\"},{\"name\":\"_zrxToken\",\"type\":\"address\"},{\"name\":\"_proxy\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousBZxContract\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newBZxContract\",\"type\":\"address\"}],\"name\":\"BZxOwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"BZxTo0x","CompilerVersion":"v0.5.3+commit.10d17f24","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000012459c951127e0c374ff9105dda097662a027093000000000000000000000000e41d2489571d322189246dafa5ebde1f4699f4980000000000000000000000008da0d80f5007ef1e431dd2127178d224e32c2ef4","Library":"","SwarmSource":"bzzr://de98d738fc7c8554e9305c8e2917cc654806000e34be4ad6a906d5272194401c"}]}