{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\n/*\r\n*   gibmireinbier - Full Stack Blockchain Developer\r\n*   0xA4a799086aE18D7db6C4b57f496B081b44888888\r\n*   gibmireinbier@gmail.com\r\n*/\r\n\r\n/*\r\n    CHANGELOGS:\r\n    . Read data from old citizen contract (Data part, used for old next versions in future)\r\n    . Hold refferal income (Logic part)\r\n*/\r\n\r\ninterface OldCitizenInterface {\r\n    /*----------  READ FUNCTIONS  ----------*/\r\n    function getTotalChild(address _address) public view returns(uint256);\r\n    function getAddressById(uint256 _id) public view returns (address);\r\n    function getAddressByUserName(string _username) public view returns (address);\r\n    function exist(string _username) public view returns (bool);\r\n    function getId(address _address) public view returns (uint256);\r\n    function getUsername(address _address) public view returns (string);\r\n    function getUintUsername(address _address) public view returns (uint256);\r\n    function getRef(address _address) public view returns (address);\r\n    function getRefTo(address _address) public view returns (address[]);\r\n    function getRefToById(address _address, uint256 _id) public view returns (address, string memory, uint256, uint256, uint256, uint256);\r\n    function getRefToLength(address _address) public view returns (uint256);\r\n    function getLevelCitizenLength(uint256 _level) public view returns (uint256);\r\n    function getLevelCitizenById(uint256 _level, uint256 _id) public view returns (address);\r\n    function getCitizenLevel(address _address) public view returns (uint256);\r\n    function getLastLevel() public view returns(uint256);\r\n}\r\n\r\ncontract Citizen {\r\n    using SafeMath for uint256;\r\n\r\n    event Register(address indexed _member, address indexed _ref);\r\n\r\n    modifier withdrawRight(){\r\n        require((msg.sender == address(bankContract)), \"Bank only\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyAdmin() {\r\n        require(msg.sender == devTeam, \"admin required\");\r\n        _;\r\n    }\r\n\r\n    modifier notRegistered(){\r\n        require(!isCitizen[msg.sender], \"already exist\");\r\n        _;\r\n    }\r\n\r\n    modifier registered(){\r\n        require(isCitizen[msg.sender], \"must be a citizen\");\r\n        _;\r\n    }\r\n\r\n    struct Profile{\r\n        uint256 id;\r\n        uint256 username;\r\n        uint256 refWallet;\r\n        address ref;\r\n        address[] refTo;\r\n        uint256 totalChild;\r\n        uint256 donated;\r\n        uint256 treeLevel;\r\n        // logs\r\n        uint256 totalSale;\r\n        uint256 allRoundRefIncome;\r\n        mapping(uint256 => uint256) roundRefIncome;\r\n        mapping(uint256 => uint256) roundRefWallet;\r\n    }\r\n\r\n    //bool public oneWayTicket = true;\r\n    mapping (address => Profile) public citizen;\r\n    mapping (address => bool) public isCitizen;\r\n    mapping (uint256 => address) public idAddress;\r\n    mapping (uint256 => address) public usernameAddress;\r\n\r\n    mapping (uint256 => address[]) levelCitizen;\r\n\r\n    BankInterface public bankContract;\r\n    LotteryInterface public lotteryContract;\r\n    F2mInterface public f2mContract;\r\n    OldCitizenInterface public oldCitizenContract;\r\n    address public devTeam;\r\n    address public oldDevTeam;\r\n\r\n    uint256 citizenNr;\r\n    uint256 lastLevel;\r\n\r\n    // logs\r\n    mapping(uint256 => uint256) public totalRefByRound;\r\n    uint256 public totalRefAllround;\r\n\r\n    constructor (address _devTeam)\r\n        public\r\n    {\r\n        DevTeamInterface(_devTeam).setCitizenAddress(address(this));\r\n        devTeam = _devTeam;\r\n        // TestNet\r\n        // oldDevTeam = 0x610ac102d56e4385b524eb5e63edb9b10147edff;\r\n        // oldCitizenContract = OldCitizenInterface(0x6263c712f5982f05f3d5a6456bce9a03c13c41f7);\r\n\r\n        // Mainnet\r\n        oldDevTeam = 0x96504e1f83e380984b1d4eccc0e8b9f0559b2ad2;\r\n        oldCitizenContract = OldCitizenInterface(0xd7657bdf782f43ba7f5f5e8456b481616e636ae9);\r\n    }\r\n\r\n    // _contract = [f2mAddress, bankAddress, citizenAddress, lotteryAddress, rewardAddress, whitelistAddress];\r\n    function joinNetwork(address[6] _contract)\r\n        public\r\n    {\r\n        require(address(lotteryContract) == 0,\"already setup\");\r\n        f2mContract = F2mInterface(_contract[0]);\r\n        bankContract = BankInterface(_contract[1]);\r\n        lotteryContract = LotteryInterface(_contract[3]);\r\n    }\r\n\r\n    /*----------  WRITE FUNCTIONS  ----------*/\r\n\r\n    //Sources: Token contract, DApps\r\n    function pushRefIncome(address _sender)\r\n        public\r\n        payable\r\n    {\r\n        uint256 curRoundId = lotteryContract.getCurRoundId();\r\n        uint256 _amount = msg.value;\r\n        address sender = _sender;\r\n        address ref = getRef(sender);\r\n        // logs\r\n        citizen[sender].totalSale += _amount;\r\n        totalRefAllround += _amount;\r\n        totalRefByRound[curRoundId] += _amount;\r\n        // push to root\r\n        // lower level cost less gas\r\n        while (sender != devTeam) {\r\n            _amount = _amount / 2;\r\n            citizen[ref].refWallet = _amount.add(citizen[ref].refWallet);\r\n            citizen[ref].roundRefIncome[curRoundId] += _amount;\r\n            citizen[ref].allRoundRefIncome += _amount;\r\n            sender = ref;\r\n            ref = getRef(sender);\r\n        }\r\n        citizen[sender].refWallet = _amount.add(citizen[ref].refWallet);\r\n        // devTeam Logs\r\n        citizen[sender].roundRefIncome[curRoundId] += _amount;\r\n        citizen[sender].allRoundRefIncome += _amount;\r\n    }\r\n\r\n    function withdrawFor(address sender) \r\n        public\r\n        withdrawRight()\r\n        returns(uint256)\r\n    {\r\n        uint256 amount = citizen[sender].refWallet;\r\n        if (amount == 0) return 0;\r\n        citizen[sender].refWallet = 0;\r\n        bankContract.pushToBank.value(amount)(sender);\r\n        return amount;\r\n    }\r\n\r\n    function devTeamWithdraw()\r\n        public\r\n        onlyAdmin()\r\n    {\r\n        uint256 _amount = citizen[devTeam].refWallet;\r\n        if (_amount == 0) return;\r\n        devTeam.transfer(_amount);\r\n        citizen[devTeam].refWallet = 0;\r\n    }\r\n\r\n    function devTeamReinvest()\r\n        public\r\n        returns(uint256)\r\n    {\r\n        address sender = msg.sender;\r\n        require(sender == address(f2mContract), \"only f2m contract\");\r\n        uint256 _amount = citizen[devTeam].refWallet;\r\n        citizen[devTeam].refWallet = 0;\r\n        address(f2mContract).transfer(_amount);\r\n        return _amount;\r\n    }\r\n\r\n    function sleep()\r\n        public\r\n        onlyAdmin()\r\n    {\r\n        bool _isLastRound = lotteryContract.isLastRound();\r\n        require(_isLastRound, \"too early\");\r\n        uint256 _ethAmount = address(this).balance;\r\n        devTeam.transfer(_ethAmount);\r\n        //ICE\r\n    }\r\n\r\n    /*----------  READ FUNCTIONS  ----------*/\r\n\r\n    function getTotalChild(address _address)\r\n        public\r\n        view\r\n        returns(uint256)\r\n    {\r\n        return _address == devTeam ? oldCitizenContract.getTotalChild(oldDevTeam) : oldCitizenContract.getTotalChild(_address);\r\n    }\r\n\r\n    function getAllRoundRefIncome(address _address)\r\n        public\r\n        view\r\n        returns(uint256)\r\n    {\r\n        return citizen[_address].allRoundRefIncome;\r\n    }\r\n\r\n    function getRoundRefIncome(address _address, uint256 _rId)\r\n        public\r\n        view\r\n        returns(uint256)\r\n    {\r\n        return citizen[_address].roundRefIncome[_rId];\r\n    }\r\n\r\n    function getRefWallet(address _address)\r\n        public\r\n        view\r\n        returns(uint256)\r\n    {\r\n        return citizen[_address].refWallet;\r\n    }\r\n\r\n    function getAddressById(uint256 _id)\r\n        public\r\n        view\r\n        returns (address)\r\n    {\r\n        return oldCitizenContract.getAddressById(_id);\r\n    }\r\n\r\n    function getAddressByUserName(string _username)\r\n        public\r\n        view\r\n        returns (address)\r\n    {\r\n        return oldCitizenContract.getAddressByUserName(_username);\r\n    }\r\n\r\n    function exist(string _username)\r\n        public\r\n        view\r\n        returns (bool)\r\n    {\r\n        return oldCitizenContract.exist(_username);\r\n    }\r\n\r\n    function getId(address _address)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return oldCitizenContract.getId(_address);\r\n    }\r\n\r\n    function getUsername(address _address)\r\n        public\r\n        view\r\n        returns (string)\r\n    {\r\n        return oldCitizenContract.getUsername(_address);\r\n    }\r\n\r\n    function getRef(address _address)\r\n        public\r\n        view\r\n        returns (address)\r\n    {\r\n        address _ref = oldCitizenContract.getRef(_address);\r\n        return _ref == oldDevTeam ? devTeam : _ref;\r\n    }\r\n\r\n    function getRefTo(address _address)\r\n        public\r\n        view\r\n        returns (address[])\r\n    {\r\n        return oldCitizenContract.getRefTo(_address);\r\n    }\r\n\r\n    function getRefToById(address _address, uint256 _id)\r\n        public\r\n        view\r\n        returns (address, string, uint256, uint256, uint256, uint256)\r\n    {\r\n        address _refTo;\r\n        string memory _username;\r\n        uint256 _treeLevel;\r\n        uint256 _refToLength;\r\n        uint256 _refWallet;\r\n        uint256 _totalSale;\r\n        (_refTo, _username, _treeLevel, _refToLength, _refWallet, _totalSale) = oldCitizenContract.getRefToById(_address, _id);\r\n        return (\r\n            _refTo,\r\n            _username,\r\n            _treeLevel,\r\n            _refToLength,\r\n            citizen[_refTo].refWallet,\r\n            citizen[_refTo].totalSale\r\n            );\r\n    }\r\n\r\n    function getRefToLength(address _address)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return oldCitizenContract.getRefToLength(_address);\r\n    }\r\n\r\n    function getLevelCitizenLength(uint256 _level)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return oldCitizenContract.getLevelCitizenLength(_level);\r\n    }\r\n\r\n    function getLevelCitizenById(uint256 _level, uint256 _id)\r\n        public\r\n        view\r\n        returns (address)\r\n    {\r\n        return oldCitizenContract.getLevelCitizenById(_level, _id);\r\n    }\r\n\r\n    function getCitizenLevel(address _address)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return oldCitizenContract.getCitizenLevel(_address);\r\n    }\r\n\r\n    function getLastLevel()\r\n        public\r\n        view\r\n        returns(uint256)\r\n    {\r\n        return oldCitizenContract.getLastLevel();\r\n    }\r\n}\r\n\r\nlibrary Helper {\r\n    using SafeMath for uint256;\r\n\r\n    uint256 constant public ZOOM = 1000;\r\n    uint256 constant public SDIVIDER = 3450000;\r\n    uint256 constant public PDIVIDER = 3450000;\r\n    uint256 constant public RDIVIDER = 1580000;\r\n    // Starting LS price (SLP)\r\n    uint256 constant public SLP = 0.002 ether;\r\n    // Starting Added Time (SAT)\r\n    uint256 constant public SAT = 30; // seconds\r\n    // Price normalization (PN)\r\n    uint256 constant public PN = 777;\r\n    // EarlyIncome base\r\n    uint256 constant public PBASE = 13;\r\n    uint256 constant public PMULTI = 26;\r\n    uint256 constant public LBase = 1;\r\n\r\n    uint256 constant public ONE_HOUR = 3600;\r\n    uint256 constant public ONE_DAY = 24 * ONE_HOUR;\r\n    //uint256 constant public TIMEOUT0 = 3 * ONE_HOUR;\r\n    uint256 constant public TIMEOUT1 = 12 * ONE_HOUR;\r\n    uint256 constant public TIMEOUT2 = 7 * ONE_DAY;\r\n    \r\n    function bytes32ToString (bytes32 data)\r\n        public\r\n        pure\r\n        returns (string) \r\n    {\r\n        bytes memory bytesString = new bytes(32);\r\n        for (uint j=0; j<32; j++) {\r\n            byte char = byte(bytes32(uint(data) * 2 ** (8 * j)));\r\n            if (char != 0) {\r\n                bytesString[j] = char;\r\n            }\r\n        }\r\n        return string(bytesString);\r\n    }\r\n    \r\n    function uintToBytes32(uint256 n)\r\n        public\r\n        pure\r\n        returns (bytes32) \r\n    {\r\n        return bytes32(n);\r\n    }\r\n    \r\n    function bytes32ToUint(bytes32 n) \r\n        public\r\n        pure\r\n        returns (uint256) \r\n    {\r\n        return uint256(n);\r\n    }\r\n    \r\n    function stringToBytes32(string memory source) \r\n        public\r\n        pure\r\n        returns (bytes32 result) \r\n    {\r\n        bytes memory tempEmptyStringTest = bytes(source);\r\n        if (tempEmptyStringTest.length == 0) {\r\n            return 0x0;\r\n        }\r\n\r\n        assembly {\r\n            result := mload(add(source, 32))\r\n        }\r\n    }\r\n    \r\n    function stringToUint(string memory source) \r\n        public\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return bytes32ToUint(stringToBytes32(source));\r\n    }\r\n    \r\n    function uintToString(uint256 _uint) \r\n        public\r\n        pure\r\n        returns (string)\r\n    {\r\n        return bytes32ToString(uintToBytes32(_uint));\r\n    }\r\n\r\n/*     \r\n    function getSlice(uint256 begin, uint256 end, string text) public pure returns (string) {\r\n        bytes memory a = new bytes(end-begin+1);\r\n        for(uint i = 0; i <= end - begin; i++){\r\n            a[i] = bytes(text)[i + begin - 1];\r\n        }\r\n        return string(a);    \r\n    }\r\n */\r\n    function validUsername(string _username)\r\n        public\r\n        pure\r\n        returns(bool)\r\n    {\r\n        uint256 len = bytes(_username).length;\r\n        // Im Raum [4, 18]\r\n        if ((len < 4) || (len > 18)) return false;\r\n        // Letzte Char != ' '\r\n        if (bytes(_username)[len-1] == 32) return false;\r\n        // Erste Char != '0'\r\n        return uint256(bytes(_username)[0]) != 48;\r\n    }\r\n\r\n    // Lottery Helper\r\n\r\n    // Seconds added per LT = SAT - ((Current no. of LT + 1) / SDIVIDER)^6\r\n    function getAddedTime(uint256 _rTicketSum, uint256 _tAmount)\r\n        public\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        //Luppe = 10000 = 10^4\r\n        uint256 base = (_rTicketSum + 1).mul(10000) / SDIVIDER;\r\n        uint256 expo = base;\r\n        expo = expo.mul(expo).mul(expo); // ^3\r\n        expo = expo.mul(expo); // ^6\r\n        // div 10000^6\r\n        expo = expo / (10**24);\r\n\r\n        if (expo > SAT) return 0;\r\n        return (SAT - expo).mul(_tAmount);\r\n    }\r\n\r\n    function getNewEndTime(uint256 toAddTime, uint256 slideEndTime, uint256 fixedEndTime)\r\n        public\r\n        view\r\n        returns(uint256)\r\n    {\r\n        uint256 _slideEndTime = (slideEndTime).add(toAddTime);\r\n        uint256 timeout = _slideEndTime.sub(block.timestamp);\r\n        // timeout capped at TIMEOUT1\r\n        if (timeout > TIMEOUT1) timeout = TIMEOUT1;\r\n        _slideEndTime = (block.timestamp).add(timeout);\r\n        // Capped at fixedEndTime\r\n        if (_slideEndTime > fixedEndTime)  return fixedEndTime;\r\n        return _slideEndTime;\r\n    }\r\n\r\n    // get random in range [1, _range] with _seed\r\n    function getRandom(uint256 _seed, uint256 _range)\r\n        public\r\n        pure\r\n        returns(uint256)\r\n    {\r\n        if (_range == 0) return _seed;\r\n        return (_seed % _range) + 1;\r\n    }\r\n\r\n\r\n    function getEarlyIncomeMul(uint256 _ticketSum)\r\n        public\r\n        pure\r\n        returns(uint256)\r\n    {\r\n        // Early-Multiplier = 1 + PBASE / (1 + PMULTI * ((Current No. of LT)/RDIVIDER)^6)\r\n        uint256 base = _ticketSum * ZOOM / RDIVIDER;\r\n        uint256 expo = base.mul(base).mul(base); //^3\r\n        expo = expo.mul(expo) / (ZOOM**6); //^6\r\n        return (1 + PBASE / (1 + expo.mul(PMULTI)));\r\n    }\r\n\r\n    // get reveiced Tickets, based on current round ticketSum\r\n    function getTAmount(uint256 _ethAmount, uint256 _ticketSum) \r\n        public\r\n        pure\r\n        returns(uint256)\r\n    {\r\n        uint256 _tPrice = getTPrice(_ticketSum);\r\n        return _ethAmount.div(_tPrice);\r\n    }\r\n\r\n    function isGoldenMin(\r\n        uint256 _slideEndTime\r\n        )\r\n        public\r\n        view\r\n        returns(bool)\r\n    {\r\n        uint256 _restTime1 = _slideEndTime.sub(block.timestamp);\r\n        // golden min. exist if timer1 < 6 hours\r\n        if (_restTime1 > 6 hours) return false;\r\n        uint256 _min = (block.timestamp / 60) % 60;\r\n        return _min == 8;\r\n    }\r\n\r\n    // percent ZOOM = 100, ie. mul = 2.05 return 205\r\n    // Lotto-Multiplier = ((grandPot / initGrandPot)^2) * x * y * z\r\n    // x = (TIMEOUT1 - timer1 - 1) / 4 + 1 => (unit = hour, max = 11/4 + 1 = 3.75) \r\n    // y = (TIMEOUT2 - timer2 - 1) / 3 + 1) => (unit = day max = 3)\r\n    // z = isGoldenMin ? 4 : 1\r\n    function getTMul(\r\n        uint256 _initGrandPot,\r\n        uint256 _grandPot, \r\n        uint256 _slideEndTime, \r\n        uint256 _fixedEndTime\r\n        )\r\n        public\r\n        view\r\n        returns(uint256)\r\n    {\r\n        uint256 _pZoom = 100;\r\n        uint256 base = _initGrandPot != 0 ?_pZoom.mul(_grandPot) / _initGrandPot : _pZoom;\r\n        uint256 expo = base.mul(base);\r\n        uint256 _timer1 = _slideEndTime.sub(block.timestamp) / 1 hours; // 0.. 11\r\n        uint256 _timer2 = _fixedEndTime.sub(block.timestamp) / 1 days; // 0 .. 6\r\n        uint256 x = (_pZoom * (11 - _timer1) / 4) + _pZoom; // [1, 3.75]\r\n        uint256 y = (_pZoom * (6 - _timer2) / 3) + _pZoom; // [1, 3]\r\n        uint256 z = isGoldenMin(_slideEndTime) ? 4 : 1;\r\n        uint256 res = expo.mul(x).mul(y).mul(z) / (_pZoom ** 3); // ~ [1, 90]\r\n        return res;\r\n    }\r\n\r\n    // get ticket price, based on current round ticketSum\r\n    //unit in ETH, no need / zoom^6\r\n    function getTPrice(uint256 _ticketSum)\r\n        public\r\n        pure\r\n        returns(uint256)\r\n    {\r\n        uint256 base = (_ticketSum + 1).mul(ZOOM) / PDIVIDER;\r\n        uint256 expo = base;\r\n        expo = expo.mul(expo).mul(expo); // ^3\r\n        expo = expo.mul(expo); // ^6\r\n        uint256 tPrice = SLP + expo / PN;\r\n        return tPrice;\r\n    }\r\n\r\n    // used to draw grandpot results\r\n    // weightRange = roundWeight * grandpot / (grandpot - initGrandPot)\r\n    // grandPot = initGrandPot + round investedSum(for grandPot)\r\n    function getWeightRange(uint256 initGrandPot)\r\n        public\r\n        pure\r\n        returns(uint256)\r\n    {\r\n        uint256 avgMul = 30;\r\n        return ((initGrandPot * 2 * 100 / 68) * avgMul / SLP) + 1000;\r\n    }\r\n\r\n    // dynamic rate _RATE = n\r\n    // major rate = 1/n with _RATE = 1000 999 ... 1\r\n    // minor rate = 1/n with _RATE = 500 499 ... 1\r\n    // loop = _ethAmount / _MIN\r\n    // lose rate = ((n- 1) / n) * ((n- 2) / (n - 1)) * ... * ((n- k) / (n - k + 1)) = (n - k) / n\r\n    function isJackpot(\r\n        uint256 _seed,\r\n        uint256 _RATE,\r\n        uint256 _MIN,\r\n        uint256 _ethAmount\r\n        )\r\n        public\r\n        pure\r\n        returns(bool)\r\n    {\r\n        // _RATE >= 2\r\n        uint256 k = _ethAmount / _MIN;\r\n        if (k == 0) return false;\r\n        // LOSE RATE MIN 50%, WIN RATE MAX 50%\r\n        uint256 _loseCap = _RATE / 2;\r\n        // IF _RATE - k > _loseCap\r\n        if (_RATE > k + _loseCap) _loseCap = _RATE - k;\r\n\r\n        bool _lose = (_seed % _RATE) < _loseCap;\r\n        return !_lose;\r\n    }\r\n}\r\n\r\ninterface DevTeamInterface {\r\n    function setF2mAddress(address _address) public;\r\n    function setLotteryAddress(address _address) public;\r\n    function setCitizenAddress(address _address) public;\r\n    function setBankAddress(address _address) public;\r\n    function setRewardAddress(address _address) public;\r\n    function setWhitelistAddress(address _address) public;\r\n\r\n    function setupNetwork() public;\r\n}\r\n\r\ninterface BankInterface {\r\n    function joinNetwork(address[6] _contract) public;\r\n    function pushToBank(address _player) public payable;\r\n}\r\n\r\ninterface LotteryInterface {\r\n    function joinNetwork(address[6] _contract) public;\r\n    // call one time\r\n    function activeFirstRound() public;\r\n    // Core Functions\r\n    function pushToPot() public payable;\r\n    function finalizeable() public view returns(bool);\r\n    // bounty\r\n    function finalize() public;\r\n    function buy(string _sSalt) public payable;\r\n    function buyFor(string _sSalt, address _sender) public payable;\r\n    //function withdraw() public;\r\n    function withdrawFor(address _sender) public returns(uint256);\r\n\r\n    function getRewardBalance(address _buyer) public view returns(uint256);\r\n    function getTotalPot() public view returns(uint256);\r\n    // EarlyIncome\r\n    function getEarlyIncomeByAddress(address _buyer) public view returns(uint256);\r\n    // included claimed amount\r\n    function getCurEarlyIncomeByAddress(address _buyer) public view returns(uint256);\r\n    function getCurRoundId() public view returns(uint256);\r\n    // set endRound, prepare to upgrade new version\r\n    function setLastRound(uint256 _lastRoundId) public;\r\n    function getPInvestedSumByRound(uint256 _rId, address _buyer) public view returns(uint256);\r\n    function cashoutable(address _address) public view returns(bool);\r\n    function isLastRound() public view returns(bool);\r\n    function sBountyClaim(address _sBountyHunter) public returns(uint256);\r\n}\r\n\r\ninterface F2mInterface {\r\n    function joinNetwork(address[6] _contract) public;\r\n    // one time called\r\n    // function disableRound0() public;\r\n    function activeBuy() public;\r\n    // function premine() public;\r\n    // Dividends from all sources (DApps, Donate ...)\r\n    function pushDividends() public payable;\r\n    /**\r\n     * Converts all of caller's dividends to tokens.\r\n     */\r\n    function buyFor(address _buyer) public payable;\r\n    function sell(uint256 _tokenAmount) public;\r\n    function exit() public;\r\n    function devTeamWithdraw() public returns(uint256);\r\n    function withdrawFor(address sender) public returns(uint256);\r\n    function transfer(address _to, uint256 _tokenAmount) public returns(bool);\r\n    /*----------  ADMINISTRATOR ONLY FUNCTIONS  ----------*/\r\n    function setAutoBuy() public;\r\n    /*==========================================\r\n    =            PUBLIC FUNCTIONS            =\r\n    ==========================================*/\r\n    function ethBalance(address _address) public view returns(uint256);\r\n    function myBalance() public view returns(uint256);\r\n    function myEthBalance() public view returns(uint256);\r\n\r\n    function swapToken() public;\r\n    function setNewToken(address _newTokenAddress) public;\r\n}\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n    int256 constant private INT256_MIN = -2**255;\r\n\r\n    /**\r\n    * @dev Multiplies two unsigned integers, reverts on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Multiplies two signed integers, reverts on overflow.\r\n    */\r\n    function mul(int256 a, int256 b) internal pure returns (int256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        require(!(a == -1 && b == INT256_MIN)); // This is the only case of overflow not detected by the check below\r\n\r\n        int256 c = a * b;\r\n        require(c / a == b);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two signed integers truncating the quotient, reverts on division by zero.\r\n    */\r\n    function div(int256 a, int256 b) internal pure returns (int256) {\r\n        require(b != 0); // Solidity only automatically asserts when dividing by 0\r\n        require(!(b == -1 && a == INT256_MIN)); // This is the only case of overflow\r\n\r\n        int256 c = a / b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two signed integers, reverts on overflow.\r\n    */\r\n    function sub(int256 a, int256 b) internal pure returns (int256) {\r\n        int256 c = a - b;\r\n        require((b >= 0 && c <= a) || (b < 0 && c > a));\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two unsigned integers, reverts on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two signed integers, reverts on overflow.\r\n    */\r\n    function add(int256 a, int256 b) internal pure returns (int256) {\r\n        int256 c = a + b;\r\n        require((b >= 0 && c >= a) || (b < 0 && c < a));\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\r\n    * reverts when dividing by zero.\r\n    */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"_username\",\"type\":\"string\"}],\"name\":\"exist\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bankContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"sleep\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_level\",\"type\":\"uint256\"},{\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"getLevelCitizenById\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getAllRoundRefIncome\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"f2mContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_level\",\"type\":\"uint256\"}],\"name\":\"getLevelCitizenLength\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_contract\",\"type\":\"address[6]\"}],\"name\":\"joinNetwork\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_username\",\"type\":\"string\"}],\"name\":\"getAddressByUserName\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"oldDevTeam\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getRef\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getRefWallet\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"},{\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"getRefToById\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"string\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getRefTo\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"oldCitizenContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"getAddressById\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"},{\"name\":\"_rId\",\"type\":\"uint256\"}],\"name\":\"getRoundRefIncome\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalRefAllround\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"citizen\",\"outputs\":[{\"name\":\"id\",\"type\":\"uint256\"},{\"name\":\"username\",\"type\":\"uint256\"},{\"name\":\"refWallet\",\"type\":\"uint256\"},{\"name\":\"ref\",\"type\":\"address\"},{\"name\":\"totalChild\",\"type\":\"uint256\"},{\"name\":\"donated\",\"type\":\"uint256\"},{\"name\":\"treeLevel\",\"type\":\"uint256\"},{\"name\":\"totalSale\",\"type\":\"uint256\"},{\"name\":\"allRoundRefIncome\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"withdrawFor\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getCitizenLevel\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"usernameAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getTotalChild\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getRefToLength\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lotteryContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getLastLevel\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"devTeamReinvest\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"devTeamWithdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getUsername\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"devTeam\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_sender\",\"type\":\"address\"}],\"name\":\"pushRefIncome\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"idAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"isCitizen\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"totalRefByRound\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_devTeam\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_member\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_ref\",\"type\":\"address\"}],\"name\":\"Register\",\"type\":\"event\"}]","ContractName":"Citizen","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000888888203c05f29a5e2174d9716af4348c4cee50","Library":"","SwarmSource":"bzzr://e4ae6081ae957d8b522fc17332c263fd1de8ef988b93a451654a67c6503a0fdb"}]}