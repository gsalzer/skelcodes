{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.8;\r\npragma experimental ABIEncoderV2;\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n     * account.\r\n     */\r\n    constructor () internal {\r\n        _owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), _owner);\r\n    }\r\n\r\n    /**\r\n     * @return the address of the owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner());\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @return true if `msg.sender` is the owner of the contract.\r\n     */\r\n    function isOwner() public view returns (bool) {\r\n        return msg.sender == _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to relinquish control of the contract.\r\n     * It will not be possible to call the functions with the `onlyOwner`\r\n     * modifier anymore.\r\n     * @notice Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0));\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Unsigned math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath\r\n{\r\n\t/**\r\n\t* @dev Adds two unsigned integers, reverts on overflow.\r\n\t*/\r\n\tfunction add(uint256 a, uint256 b) internal pure returns (uint256)\r\n\t{\r\n\t\tuint256 c = a + b;\r\n\t\trequire(c >= a);\r\n\t\treturn c;\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n\t*/\r\n\tfunction sub(uint256 a, uint256 b) internal pure returns (uint256)\r\n\t{\r\n\t\trequire(b <= a);\r\n\t\tuint256 c = a - b;\r\n\t\treturn c;\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Multiplies two unsigned integers, reverts on overflow.\r\n\t*/\r\n\tfunction mul(uint256 a, uint256 b) internal pure returns (uint256)\r\n\t{\r\n\t\t// Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n\t\t// benefit is lost if 'b' is also tested.\r\n\t\t// See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n\t\tif (a == 0)\r\n\t\t{\r\n\t\t\treturn 0;\r\n\t\t}\r\n\t\tuint256 c = a * b;\r\n\t\trequire(c / a == b);\r\n\t\treturn c;\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\r\n\t*/\r\n\tfunction div(uint256 a, uint256 b) internal pure returns (uint256)\r\n\t{\r\n\t\t\t// Solidity only automatically asserts when dividing by 0\r\n\t\t\trequire(b > 0);\r\n\t\t\tuint256 c = a / b;\r\n\t\t\t// assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\t\t\treturn c;\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\r\n\t* reverts when dividing by zero.\r\n\t*/\r\n\tfunction mod(uint256 a, uint256 b) internal pure returns (uint256)\r\n\t{\r\n\t\trequire(b != 0);\r\n\t\treturn a % b;\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Returns the largest of two numbers.\r\n\t*/\r\n\tfunction max(uint256 a, uint256 b) internal pure returns (uint256)\r\n\t{\r\n\t\treturn a >= b ? a : b;\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Returns the smallest of two numbers.\r\n\t*/\r\n\tfunction min(uint256 a, uint256 b) internal pure returns (uint256)\r\n\t{\r\n\t\treturn a < b ? a : b;\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Multiplies the a by the fraction b/c\r\n\t*/\r\n\tfunction mulByFraction(uint256 a, uint256 b, uint256 c) internal pure returns (uint256)\r\n\t{\r\n\t\treturn div(mul(a, b), c);\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Return b percents of a (equivalent to a percents of b)\r\n\t*/\r\n\tfunction percentage(uint256 a, uint256 b) internal pure returns (uint256)\r\n\t{\r\n\t\treturn mulByFraction(a, b, 100);\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Returns the base 2 log of x\r\n\t* @notice Source : https://ethereum.stackexchange.com/questions/8086/logarithm-math-operation-in-solidity\r\n\t*/\r\n\tfunction log(uint x) internal pure returns (uint y)\r\n\t{\r\n\t\tassembly\r\n\t\t{\r\n\t\t\tlet arg := x\r\n\t\t\tx := sub(x,1)\r\n\t\t\tx := or(x, div(x, 0x02))\r\n\t\t\tx := or(x, div(x, 0x04))\r\n\t\t\tx := or(x, div(x, 0x10))\r\n\t\t\tx := or(x, div(x, 0x100))\r\n\t\t\tx := or(x, div(x, 0x10000))\r\n\t\t\tx := or(x, div(x, 0x100000000))\r\n\t\t\tx := or(x, div(x, 0x10000000000000000))\r\n\t\t\tx := or(x, div(x, 0x100000000000000000000000000000000))\r\n\t\t\tx := add(x, 1)\r\n\t\t\tlet m := mload(0x40)\r\n\t\t\tmstore(m,           0xf8f9cbfae6cc78fbefe7cdc3a1793dfcf4f0e8bbd8cec470b6a28a7a5a3e1efd)\r\n\t\t\tmstore(add(m,0x20), 0xf5ecf1b3e9debc68e1d9cfabc5997135bfb7a7a3938b7b606b5b4b3f2f1f0ffe)\r\n\t\t\tmstore(add(m,0x40), 0xf6e4ed9ff2d6b458eadcdf97bd91692de2d4da8fd2d0ac50c6ae9a8272523616)\r\n\t\t\tmstore(add(m,0x60), 0xc8c0b887b0a8a4489c948c7f847c6125746c645c544c444038302820181008ff)\r\n\t\t\tmstore(add(m,0x80), 0xf7cae577eec2a03cf3bad76fb589591debb2dd67e0aa9834bea6925f6a4a2e0e)\r\n\t\t\tmstore(add(m,0xa0), 0xe39ed557db96902cd38ed14fad815115c786af479b7e83247363534337271707)\r\n\t\t\tmstore(add(m,0xc0), 0xc976c13bb96e881cb166a933a55e490d9d56952b8d4e801485467d2362422606)\r\n\t\t\tmstore(add(m,0xe0), 0x753a6d1b65325d0c552a4d1345224105391a310b29122104190a110309020100)\r\n\t\t\tmstore(0x40, add(m, 0x100))\r\n\t\t\tlet magic := 0x818283848586878898a8b8c8d8e8f929395969799a9b9d9e9faaeb6bedeeff\r\n\t\t\tlet shift := 0x100000000000000000000000000000000000000000000000000000000000000\r\n\t\t\tlet a := div(mul(x, magic), shift)\r\n\t\t\ty := div(mload(add(m,sub(255,a))), shift)\r\n\t\t\ty := add(y, mul(256, gt(arg, 0x8000000000000000000000000000000000000000000000000000000000000000)))\r\n\t\t}\r\n\t}\r\n}\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md\r\n */\r\ninterface IERC20\r\n{\r\n\tfunction totalSupply()\r\n\t\texternal view returns (uint256);\r\n\r\n\tfunction balanceOf(address who)\r\n\t\texternal view returns (uint256);\r\n\r\n\tfunction allowance(address owner, address spender)\r\n\t\texternal view returns (uint256);\r\n\r\n\tfunction transfer(address to, uint256 value)\r\n\t\texternal returns (bool);\r\n\r\n\tfunction approve(address spender, uint256 value)\r\n\t\texternal returns (bool);\r\n\r\n\tfunction transferFrom(address from, address to, uint256 value)\r\n\t\texternal returns (bool);\r\n\r\n\tevent Transfer(\r\n\t\taddress indexed from,\r\n\t\taddress indexed to,\r\n\t\tuint256 value\r\n\t);\r\n\r\n\tevent Approval(\r\n\t\taddress indexed owner,\r\n\t\taddress indexed spender,\r\n\t\tuint256 value\r\n\t);\r\n}\r\n\r\ncontract IERC734\r\n{\r\n\t// 1: MANAGEMENT keys, which can manage the identity\r\n\tuint256 public constant MANAGEMENT_KEY = 1;\r\n\t// 2: ACTION keys, which perform actions in this identities name (signing, logins, transactions, etc.)\r\n\tuint256 public constant ACTION_KEY = 2;\r\n\t// 3: CLAIM signer keys, used to sign claims on other identities which need to be revokable.\r\n\tuint256 public constant CLAIM_SIGNER_KEY = 3;\r\n\t// 4: ENCRYPTION keys, used to encrypt data e.g. hold in claims.\r\n\tuint256 public constant ENCRYPTION_KEY = 4;\r\n\r\n\t// KeyType\r\n\tuint256 public constant ECDSA_TYPE = 1;\r\n\t// https://medium.com/@alexberegszaszi/lets-bring-the-70s-to-ethereum-48daa16a4b51\r\n\tuint256 public constant RSA_TYPE = 2;\r\n\r\n\t// Events\r\n\tevent KeyAdded          (bytes32 indexed key, uint256 indexed purpose, uint256 indexed keyType);\r\n\tevent KeyRemoved        (bytes32 indexed key, uint256 indexed purpose, uint256 indexed keyType);\r\n\tevent ExecutionRequested(uint256 indexed executionId, address indexed to, uint256 indexed value, bytes data);\r\n\tevent Executed          (uint256 indexed executionId, address indexed to, uint256 indexed value, bytes data);\r\n\tevent ExecutionFailed   (uint256 indexed executionId, address indexed to, uint256 indexed value, bytes data);\r\n\tevent Approved          (uint256 indexed executionId, bool approved);\r\n\r\n\t// Functions\r\n\tfunction getKey          (bytes32 _key                                     ) external view returns (uint256[] memory purposes, uint256 keyType, bytes32 key);\r\n\tfunction keyHasPurpose   (bytes32 _key, uint256 purpose                    ) external view returns (bool exists);\r\n\tfunction getKeysByPurpose(uint256 _purpose                                 ) external view returns (bytes32[] memory keys);\r\n\tfunction addKey          (bytes32 _key, uint256 _purpose, uint256 _keyType ) external      returns (bool success);\r\n\tfunction removeKey       (bytes32 _key, uint256 _purpose                   ) external      returns (bool success);\r\n\tfunction execute         (address _to, uint256 _value, bytes calldata _data) external      returns (uint256 executionId);\r\n\tfunction approve         (uint256 _id, bool _approve                       ) external      returns (bool success);\r\n}\r\n\r\ncontract IERC1271\r\n{\r\n\t// bytes4(keccak256(\"isValidSignature(bytes,bytes)\")\r\n\tbytes4 constant internal MAGICVALUE = 0x20c13b0b;\r\n\r\n\t/**\r\n\t * @dev Should return whether the signature provided is valid for the provided data\r\n\t * @param _data Arbitrary length data signed on the behalf of address(this)\r\n\t * @param _signature Signature byte array associated with _data\r\n\t *\r\n\t * MUST return the bytes4 magic value 0x20c13b0b when function passes.\r\n\t * MUST NOT modify state (using STATICCALL for solc < 0.5, view modifier for solc > 0.5)\r\n\t * MUST allow external calls\r\n\t */\r\n\t// function isValidSignature(\r\n\t// \tbytes memory _data,\r\n\t// \tbytes memory _signature)\r\n\t// \tpublic\r\n\t// \tview\r\n\t// \treturns (bytes4 magicValue);\r\n\r\n\t// Newer version ? From 0x V2\r\n\tfunction isValidSignature(\r\n\t\tbytes32 _data,\r\n\t\tbytes memory _signature\r\n\t)\r\n\tpublic\r\n\tview\r\n\treturns (bool isValid);\r\n}\r\n\r\n/**\r\n * @title EIP1154 interface\r\n * @dev see https://eips.ethereum.org/EIPS/eip-1154\r\n */\r\ninterface IOracleConsumer\r\n{\r\n\tfunction receiveResult(bytes32, bytes calldata)\r\n\t\texternal;\r\n}\r\n\r\ninterface IOracle\r\n{\r\n\tfunction resultFor(bytes32)\r\n\t\texternal view returns (bytes memory);\r\n}\r\n\r\nlibrary IexecODBLibCore\r\n{\r\n\t/**\r\n\t* Tools\r\n\t*/\r\n\tstruct Account\r\n\t{\r\n\t\tuint256 stake;\r\n\t\tuint256 locked;\r\n\t}\r\n\tstruct Category\r\n\t{\r\n\t\tstring  name;\r\n\t\tstring  description;\r\n\t\tuint256 workClockTimeRef;\r\n\t}\r\n\r\n\t/**\r\n\t * Clerk - Deals\r\n\t */\r\n\tstruct Resource\r\n\t{\r\n\t\taddress pointer;\r\n\t\taddress owner;\r\n\t\tuint256 price;\r\n\t}\r\n\tstruct Deal\r\n\t{\r\n\t\t// Ressources\r\n\t\tResource app;\r\n\t\tResource dataset;\r\n\t\tResource workerpool;\r\n\t\tuint256 trust;\r\n\t\tuint256 category;\r\n\t\tbytes32 tag;\r\n\t\t// execution details\r\n\t\taddress requester;\r\n\t\taddress beneficiary;\r\n\t\taddress callback;\r\n\t\tstring  params;\r\n\t\t// execution settings\r\n\t\tuint256 startTime;\r\n\t\tuint256 botFirst;\r\n\t\tuint256 botSize;\r\n\t\t// consistency\r\n\t\tuint256 workerStake;\r\n\t\tuint256 schedulerRewardRatio;\r\n\t}\r\n\r\n\t/**\r\n\t * Tasks\r\n\t // TODO: rename Workorder → Task\r\n\t */\r\n\tenum TaskStatusEnum\r\n\t{\r\n\t\tUNSET,     // Work order not yet initialized (invalid address)\r\n\t\tACTIVE,    // Marketed → constributions are open\r\n\t\tREVEALING, // Starting consensus reveal\r\n\t\tCOMPLETED, // Concensus achieved\r\n\t\tFAILLED    // Failled consensus\r\n\t}\r\n\tstruct Task\r\n\t{\r\n\t\tTaskStatusEnum status;\r\n\t\tbytes32   dealid;\r\n\t\tuint256   idx;\r\n\t\tuint256   timeref;\r\n\t\tuint256   contributionDeadline;\r\n\t\tuint256   revealDeadline;\r\n\t\tuint256   finalDeadline;\r\n\t\tbytes32   consensusValue;\r\n\t\tuint256   revealCounter;\r\n\t\tuint256   winnerCounter;\r\n\t\taddress[] contributors;\r\n\t\tbytes32   resultDigest;\r\n\t\tbytes     results;\r\n\t}\r\n\r\n\t/**\r\n\t * Consensus\r\n\t */\r\n\tenum ContributionStatusEnum\r\n\t{\r\n\t\tUNSET,\r\n\t\tCONTRIBUTED,\r\n\t\tPROVED,\r\n\t\tREJECTED\r\n\t}\r\n\tstruct Contribution\r\n\t{\r\n\t\tContributionStatusEnum status;\r\n\t\tbytes32 resultHash;\r\n\t\tbytes32 resultSeal;\r\n\t\taddress enclaveChallenge;\r\n\t}\r\n\r\n}\r\n\r\nlibrary IexecODBLibOrders\r\n{\r\n\t// bytes32 public constant    EIP712DOMAIN_TYPEHASH = keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\");\r\n\t// bytes32 public constant        APPORDER_TYPEHASH = keccak256(\"AppOrder(address app,uint256 appprice,uint256 volume,bytes32 tag,address datasetrestrict,address workerpoolrestrict,address requesterrestrict,bytes32 salt)\");\r\n\t// bytes32 public constant    DATASETORDER_TYPEHASH = keccak256(\"DatasetOrder(address dataset,uint256 datasetprice,uint256 volume,bytes32 tag,address apprestrict,address workerpoolrestrict,address requesterrestrict,bytes32 salt)\");\r\n\t// bytes32 public constant WORKERPOOLORDER_TYPEHASH = keccak256(\"WorkerpoolOrder(address workerpool,uint256 workerpoolprice,uint256 volume,bytes32 tag,uint256 category,uint256 trust,address apprestrict,address datasetrestrict,address requesterrestrict,bytes32 salt)\");\r\n\t// bytes32 public constant    REQUESTORDER_TYPEHASH = keccak256(\"RequestOrder(address app,uint256 appmaxprice,address dataset,uint256 datasetmaxprice,address workerpool,uint256 workerpoolmaxprice,address requester,uint256 volume,bytes32 tag,uint256 category,uint256 trust,address beneficiary,address callback,string params,bytes32 salt)\");\r\n\tbytes32 public constant    EIP712DOMAIN_TYPEHASH = 0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f;\r\n\tbytes32 public constant        APPORDER_TYPEHASH = 0x60815a0eeec47dddf1615fe53b31d016c31444e01b9d796db365443a6445d008;\r\n\tbytes32 public constant    DATASETORDER_TYPEHASH = 0x6cfc932a5a3d22c4359295b9f433edff52b60703fa47690a04a83e40933dd47c;\r\n\tbytes32 public constant WORKERPOOLORDER_TYPEHASH = 0xaa3429fb281b34691803133d3d978a75bb77c617ed6bc9aa162b9b30920022bb;\r\n\tbytes32 public constant    REQUESTORDER_TYPEHASH = 0xf24e853034a3a450aba845a82914fbb564ad85accca6cf62be112a154520fae0;\r\n\r\n\tstruct EIP712Domain\r\n\t{\r\n\t\tstring  name;\r\n\t\tstring  version;\r\n\t\tuint256 chainId;\r\n\t\taddress verifyingContract;\r\n\t}\r\n\tstruct AppOrder\r\n\t{\r\n\t\taddress app;\r\n\t\tuint256 appprice;\r\n\t\tuint256 volume;\r\n\t\tbytes32 tag;\r\n\t\taddress datasetrestrict;\r\n\t\taddress workerpoolrestrict;\r\n\t\taddress requesterrestrict;\r\n\t\tbytes32 salt;\r\n\t\tbytes   sign;\r\n\t}\r\n\tstruct DatasetOrder\r\n\t{\r\n\t\taddress dataset;\r\n\t\tuint256 datasetprice;\r\n\t\tuint256 volume;\r\n\t\tbytes32 tag;\r\n\t\taddress apprestrict;\r\n\t\taddress workerpoolrestrict;\r\n\t\taddress requesterrestrict;\r\n\t\tbytes32 salt;\r\n\t\tbytes   sign;\r\n\t}\r\n\tstruct WorkerpoolOrder\r\n\t{\r\n\t\taddress workerpool;\r\n\t\tuint256 workerpoolprice;\r\n\t\tuint256 volume;\r\n\t\tbytes32 tag;\r\n\t\tuint256 category;\r\n\t\tuint256 trust;\r\n\t\taddress apprestrict;\r\n\t\taddress datasetrestrict;\r\n\t\taddress requesterrestrict;\r\n\t\tbytes32 salt;\r\n\t\tbytes   sign;\r\n\t}\r\n\tstruct RequestOrder\r\n\t{\r\n\t\taddress app;\r\n\t\tuint256 appmaxprice;\r\n\t\taddress dataset;\r\n\t\tuint256 datasetmaxprice;\r\n\t\taddress workerpool;\r\n\t\tuint256 workerpoolmaxprice;\r\n\t\taddress requester;\r\n\t\tuint256 volume;\r\n\t\tbytes32 tag;\r\n\t\tuint256 category;\r\n\t\tuint256 trust;\r\n\t\taddress beneficiary;\r\n\t\taddress callback;\r\n\t\tstring  params;\r\n\t\tbytes32 salt;\r\n\t\tbytes   sign;\r\n\t}\r\n\r\n\tfunction hash(EIP712Domain memory _domain)\r\n\tpublic pure returns (bytes32 domainhash)\r\n\t{\r\n\t\t/**\r\n\t\t * Readeable but expensive\r\n\t\t */\r\n\t\t// return keccak256(abi.encode(\r\n\t\t// \tEIP712DOMAIN_TYPEHASH\r\n\t\t// , keccak256(bytes(_domain.name))\r\n\t\t// , keccak256(bytes(_domain.version))\r\n\t\t// , _domain.chainId\r\n\t\t// , _domain.verifyingContract\r\n\t\t// ));\r\n\r\n\t\t// Compute sub-hashes\r\n\t\tbytes32 typeHash    = EIP712DOMAIN_TYPEHASH;\r\n\t\tbytes32 nameHash    = keccak256(bytes(_domain.name));\r\n\t\tbytes32 versionHash = keccak256(bytes(_domain.version));\r\n\t\tassembly {\r\n\t\t\t// Back up select memory\r\n\t\t\tlet temp1 := mload(sub(_domain, 0x20))\r\n\t\t\tlet temp2 := mload(add(_domain, 0x00))\r\n\t\t\tlet temp3 := mload(add(_domain, 0x20))\r\n\t\t\t// Write typeHash and sub-hashes\r\n\t\t\tmstore(sub(_domain, 0x20),    typeHash)\r\n\t\t\tmstore(add(_domain, 0x00),    nameHash)\r\n\t\t\tmstore(add(_domain, 0x20), versionHash)\r\n\t\t\t// Compute hash\r\n\t\t\tdomainhash := keccak256(sub(_domain, 0x20), 0xA0) // 160 = 32 + 128\r\n\t\t\t// Restore memory\r\n\t\t\tmstore(sub(_domain, 0x20), temp1)\r\n\t\t\tmstore(add(_domain, 0x00), temp2)\r\n\t\t\tmstore(add(_domain, 0x20), temp3)\r\n\t\t}\r\n\t}\r\n\tfunction hash(AppOrder memory _apporder)\r\n\tpublic pure returns (bytes32 apphash)\r\n\t{\r\n\t\t/**\r\n\t\t * Readeable but expensive\r\n\t\t */\r\n\t\t// return keccak256(abi.encode(\r\n\t\t// \tAPPORDER_TYPEHASH\r\n\t\t// , _apporder.app\r\n\t\t// , _apporder.appprice\r\n\t\t// , _apporder.volume\r\n\t\t// , _apporder.tag\r\n\t\t// , _apporder.datasetrestrict\r\n\t\t// , _apporder.workerpoolrestrict\r\n\t\t// , _apporder.requesterrestrict\r\n\t\t// , _apporder.salt\r\n\t\t// ));\r\n\r\n\t\t// Compute sub-hashes\r\n\t\tbytes32 typeHash = APPORDER_TYPEHASH;\r\n\t\tassembly {\r\n\t\t\t// Back up select memory\r\n\t\t\tlet temp1 := mload(sub(_apporder, 0x20))\r\n\t\t\t// Write typeHash and sub-hashes\r\n\t\t\tmstore(sub(_apporder, 0x20), typeHash)\r\n\t\t\t// Compute hash\r\n\t\t\tapphash := keccak256(sub(_apporder, 0x20), 0x120) // 288 = 32 + 256\r\n\t\t\t// Restore memory\r\n\t\t\tmstore(sub(_apporder, 0x20), temp1)\r\n\t\t}\r\n\t}\r\n\tfunction hash(DatasetOrder memory _datasetorder)\r\n\tpublic pure returns (bytes32 datasethash)\r\n\t{\r\n\t\t/**\r\n\t\t * Readeable but expensive\r\n\t\t */\r\n\t\t// return keccak256(abi.encode(\r\n\t\t// \tDATASETORDER_TYPEHASH\r\n\t\t// , _datasetorder.dataset\r\n\t\t// , _datasetorder.datasetprice\r\n\t\t// , _datasetorder.volume\r\n\t\t// , _datasetorder.tag\r\n\t\t// , _datasetorder.apprestrict\r\n\t\t// , _datasetorder.workerpoolrestrict\r\n\t\t// , _datasetorder.requesterrestrict\r\n\t\t// , _datasetorder.salt\r\n\t\t// ));\r\n\r\n\t\t// Compute sub-hashes\r\n\t\tbytes32 typeHash = DATASETORDER_TYPEHASH;\r\n\t\tassembly {\r\n\t\t\t// Back up select memory\r\n\t\t\tlet temp1 := mload(sub(_datasetorder, 0x20))\r\n\t\t\t// Write typeHash and sub-hashes\r\n\t\t\tmstore(sub(_datasetorder, 0x20), typeHash)\r\n\t\t\t// Compute hash\r\n\t\t\tdatasethash := keccak256(sub(_datasetorder, 0x20), 0x120) // 288 = 32 + 256\r\n\t\t\t// Restore memory\r\n\t\t\tmstore(sub(_datasetorder, 0x20), temp1)\r\n\t\t}\r\n\t}\r\n\tfunction hash(WorkerpoolOrder memory _workerpoolorder)\r\n\tpublic pure returns (bytes32 workerpoolhash)\r\n\t{\r\n\t\t/**\r\n\t\t * Readeable but expensive\r\n\t\t */\r\n\t\t// return keccak256(abi.encode(\r\n\t\t// \tWORKERPOOLORDER_TYPEHASH\r\n\t\t// , _workerpoolorder.workerpool\r\n\t\t// , _workerpoolorder.workerpoolprice\r\n\t\t// , _workerpoolorder.volume\r\n\t\t// , _workerpoolorder.tag\r\n\t\t// , _workerpoolorder.category\r\n\t\t// , _workerpoolorder.trust\r\n\t\t// , _workerpoolorder.apprestrict\r\n\t\t// , _workerpoolorder.datasetrestrict\r\n\t\t// , _workerpoolorder.requesterrestrict\r\n\t\t// , _workerpoolorder.salt\r\n\t\t// ));\r\n\r\n\t\t// Compute sub-hashes\r\n\t\tbytes32 typeHash = WORKERPOOLORDER_TYPEHASH;\r\n\t\tassembly {\r\n\t\t\t// Back up select memory\r\n\t\t\tlet temp1 := mload(sub(_workerpoolorder, 0x20))\r\n\t\t\t// Write typeHash and sub-hashes\r\n\t\t\tmstore(sub(_workerpoolorder, 0x20), typeHash)\r\n\t\t\t// Compute hash\r\n\t\t\tworkerpoolhash := keccak256(sub(_workerpoolorder, 0x20), 0x160) // 352 = 32 + 320\r\n\t\t\t// Restore memory\r\n\t\t\tmstore(sub(_workerpoolorder, 0x20), temp1)\r\n\t\t}\r\n\t}\r\n\tfunction hash(RequestOrder memory _requestorder)\r\n\tpublic pure returns (bytes32 requesthash)\r\n\t{\r\n\t\t/**\r\n\t\t * Readeable but expensive\r\n\t\t */\r\n\t\t//return keccak256(abi.encodePacked(\r\n\t\t//\tabi.encode(\r\n\t\t//\t\tREQUESTORDER_TYPEHASH\r\n\t\t//\t, _requestorder.app\r\n\t\t//\t, _requestorder.appmaxprice\r\n\t\t//\t, _requestorder.dataset\r\n\t\t//\t, _requestorder.datasetmaxprice\r\n\t\t//\t, _requestorder.workerpool\r\n\t\t//\t, _requestorder.workerpoolmaxprice\r\n\t\t//\t, _requestorder.requester\r\n\t\t//\t, _requestorder.volume\r\n\t\t//\t, _requestorder.tag\r\n\t\t//\t, _requestorder.category\r\n\t\t//\t, _requestorder.trust\r\n\t\t//\t, _requestorder.beneficiary\r\n\t\t//\t, _requestorder.callback\r\n\t\t//\t, keccak256(bytes(_requestorder.params))\r\n\t\t//\t, _requestorder.salt\r\n\t\t//\t)\r\n\t\t//));\r\n\r\n\t\t// Compute sub-hashes\r\n\t\tbytes32 typeHash = REQUESTORDER_TYPEHASH;\r\n\t\tbytes32 paramsHash = keccak256(bytes(_requestorder.params));\r\n\t\tassembly {\r\n\t\t\t// Back up select memory\r\n\t\t\tlet temp1 := mload(sub(_requestorder, 0x020))\r\n\t\t\tlet temp2 := mload(add(_requestorder, 0x1A0))\r\n\t\t\t// Write typeHash and sub-hashes\r\n\t\t\tmstore(sub(_requestorder, 0x020), typeHash)\r\n\t\t\tmstore(add(_requestorder, 0x1A0), paramsHash)\r\n\t\t\t// Compute hash\r\n\t\t\trequesthash := keccak256(sub(_requestorder, 0x20), 0x200) // 512 = 32 + 480\r\n\t\t\t// Restore memory\r\n\t\t\tmstore(sub(_requestorder, 0x020), temp1)\r\n\t\t\tmstore(add(_requestorder, 0x1A0), temp2)\r\n\t\t}\r\n\t}\r\n\r\n\tfunction toEthTypedStructHash(bytes32 _structHash, bytes32 _domainHash)\r\n\tpublic pure returns (bytes32 typedStructHash)\r\n\t{\r\n\t\treturn keccak256(abi.encodePacked(\"\\x19\\x01\", _domainHash, _structHash));\r\n\t}\r\n}\r\n\r\n\r\ncontract RegistryBase\r\n{\r\n\r\n\tusing SafeMath for uint256;\r\n\r\n\t/**\r\n\t * Members\r\n\t */\r\n\tmapping(address => bool                       ) m_registered;\r\n\tmapping(address => mapping(uint256 => address)) m_byOwnerByIndex;\r\n\tmapping(address => uint256                    ) m_countByOwner;\r\n\r\n\t/**\r\n\t * Constructor\r\n\t */\r\n\tconstructor()\r\n\tpublic\r\n\t{\r\n\t}\r\n\r\n\t/**\r\n\t * Accessors\r\n\t */\r\n\tfunction isRegistered(address _entry)\r\n\tpublic view returns (bool)\r\n\t{\r\n\t\treturn m_registered[_entry];\r\n\t}\r\n\r\n\tfunction viewEntry(address _owner, uint256 _index)\r\n\tpublic view returns (address)\r\n\t{\r\n\t\treturn m_byOwnerByIndex[_owner][_index];\r\n\t}\r\n\r\n\tfunction viewCount(address _owner)\r\n\tpublic view returns (uint256)\r\n\t{\r\n\t\treturn m_countByOwner[_owner];\r\n\t}\r\n\r\n\t/**\r\n\t * Internal\r\n\t */\r\n\tfunction insert(\r\n\t\taddress _entry,\r\n\t\taddress _owner)\r\n\tinternal returns (bool)\r\n\t{\r\n\t\tuint id = m_countByOwner[_owner].add(1);\r\n\t\tm_countByOwner  [_owner]     = id;\r\n\t\tm_byOwnerByIndex[_owner][id] = _entry;\r\n\t\tm_registered    [_entry]     = true;\r\n\t\treturn true;\r\n\t}\r\n}\r\n\r\n\r\ncontract App is Ownable\r\n{\r\n\t/**\r\n\t * Members\r\n\t */\r\n\tstring  public m_appName;\r\n\tstring  public m_appType;\r\n\tbytes   public m_appMultiaddr;\r\n\tbytes32 public m_appChecksum;\r\n\tbytes   public m_appMREnclave;\r\n\r\n\t/**\r\n\t * Constructor\r\n\t */\r\n\tconstructor(\r\n\t\taddress        _appOwner,\r\n\t\tstring  memory _appName,\r\n\t\tstring  memory _appType,\r\n\t\tbytes   memory _appMultiaddr,\r\n\t\tbytes32        _appChecksum,\r\n\t\tbytes   memory _appMREnclave)\r\n\tpublic\r\n\t{\r\n\t\t_transferOwnership(_appOwner);\r\n\t\tm_appName      = _appName;\r\n\t\tm_appType      = _appType;\r\n\t\tm_appMultiaddr = _appMultiaddr;\r\n\t\tm_appChecksum  = _appChecksum;\r\n\t\tm_appMREnclave = _appMREnclave;\r\n\t}\r\n\r\n\tfunction transferOwnership(address) public { revert(\"disabled\"); }\r\n\r\n}\r\n\r\n\r\ncontract AppRegistry is RegistryBase //, OwnableMutable // is Owned by IexecHub\r\n{\r\n\tevent CreateApp(address indexed appOwner, address app);\r\n\r\n\t/**\r\n\t * Constructor\r\n\t */\r\n\tconstructor()\r\n\tpublic\r\n\t{\r\n\t}\r\n\r\n\t/**\r\n\t * App creation\r\n\t */\r\n\tfunction createApp(\r\n\t\taddress          _appOwner,\r\n\t\tstring  calldata _appName,\r\n\t\tstring  calldata _appType,\r\n\t\tbytes   calldata _appMultiaddr,\r\n\t\tbytes32          _appChecksum,\r\n\t\tbytes   calldata _appMREnclave)\r\n\texternal /* onlyOwner /*owner == IexecHub*/ returns (App)\r\n\t{\r\n\t\tApp newApp = new App(\r\n\t\t\t_appOwner,\r\n\t\t\t_appName,\r\n\t\t\t_appType,\r\n\t\t\t_appMultiaddr,\r\n\t\t\t_appChecksum,\r\n\t\t\t_appMREnclave\r\n\t\t);\r\n\t\trequire(insert(address(newApp), _appOwner));\r\n\t\temit CreateApp(_appOwner, address(newApp));\r\n\t\treturn newApp;\r\n\t}\r\n\r\n}\r\n\r\n\r\ncontract Dataset is Ownable\r\n{\r\n\t/**\r\n\t * Members\r\n\t */\r\n\tstring  public m_datasetName;\r\n\tbytes   public m_datasetMultiaddr;\r\n\tbytes32 public m_datasetChecksum;\r\n\r\n\t/**\r\n\t * Constructor\r\n\t */\r\n\tconstructor(\r\n\t\taddress        _datasetOwner,\r\n\t\tstring  memory _datasetName,\r\n\t\tbytes   memory _datasetMultiaddr,\r\n\t\tbytes32        _datasetChecksum)\r\n\tpublic\r\n\t{\r\n\t\t_transferOwnership(_datasetOwner);\r\n\t\tm_datasetName      = _datasetName;\r\n\t\tm_datasetMultiaddr = _datasetMultiaddr;\r\n\t\tm_datasetChecksum  = _datasetChecksum;\r\n\t}\r\n\r\n\tfunction transferOwnership(address) public { revert(\"disabled\"); }\r\n\r\n}\r\n\r\n\r\ncontract DatasetRegistry is RegistryBase //, OwnableMutable // is Owned by IexecHub\r\n{\r\n\tevent CreateDataset(address indexed datasetOwner, address dataset);\r\n\r\n\t/**\r\n\t * Constructor\r\n\t */\r\n\tconstructor()\r\n\tpublic\r\n\t{\r\n\t}\r\n\r\n\t/**\r\n\t * Dataset creation\r\n\t */\r\n\tfunction createDataset(\r\n\t\taddress          _datasetOwner,\r\n\t\tstring  calldata _datasetName,\r\n\t\tbytes   calldata _datasetMultiaddr,\r\n\t\tbytes32          _datasetChecksum)\r\n\texternal /* onlyOwner /*owner == IexecHub*/ returns (Dataset)\r\n\t{\r\n\t\tDataset newDataset = new Dataset(\r\n\t\t\t_datasetOwner,\r\n\t\t\t_datasetName,\r\n\t\t\t_datasetMultiaddr,\r\n\t\t\t_datasetChecksum\r\n\t\t);\r\n\t\trequire(insert(address(newDataset), _datasetOwner));\r\n\t\temit CreateDataset(_datasetOwner, address(newDataset));\r\n\t\treturn newDataset;\r\n\t}\r\n}\r\n\r\n\r\ncontract Workerpool is Ownable\r\n{\r\n\t/**\r\n\t * Parameters\r\n\t */\r\n\tstring  public m_workerpoolDescription;\r\n\tuint256 public m_workerStakeRatioPolicy;     // % of reward to stake\r\n\tuint256 public m_schedulerRewardRatioPolicy; // % of reward given to scheduler\r\n\r\n\t/**\r\n\t * Events\r\n\t */\r\n\tevent PolicyUpdate(\r\n\t\tuint256 oldWorkerStakeRatioPolicy,     uint256 newWorkerStakeRatioPolicy,\r\n\t\tuint256 oldSchedulerRewardRatioPolicy, uint256 newSchedulerRewardRatioPolicy);\r\n\r\n\t/**\r\n\t * Constructor\r\n\t */\r\n\tconstructor(\r\n\t\taddress        _workerpoolOwner,\r\n\t\tstring  memory _workerpoolDescription)\r\n\tpublic\r\n\t{\r\n\t\t_transferOwnership(_workerpoolOwner);\r\n\t\tm_workerpoolDescription      = _workerpoolDescription;\r\n\t\tm_workerStakeRatioPolicy     = 30; // mutable\r\n\t\tm_schedulerRewardRatioPolicy = 1;  // mutable\r\n\t}\r\n\r\n\tfunction changePolicy(\r\n\t\tuint256 _newWorkerStakeRatioPolicy,\r\n\t\tuint256 _newSchedulerRewardRatioPolicy)\r\n\tpublic onlyOwner\r\n\t{\r\n\t\trequire(_newSchedulerRewardRatioPolicy <= 100);\r\n\r\n\t\temit PolicyUpdate(\r\n\t\t\tm_workerStakeRatioPolicy,     _newWorkerStakeRatioPolicy,\r\n\t\t\tm_schedulerRewardRatioPolicy, _newSchedulerRewardRatioPolicy\r\n\t\t);\r\n\r\n\t\tm_workerStakeRatioPolicy     = _newWorkerStakeRatioPolicy;\r\n\t\tm_schedulerRewardRatioPolicy = _newSchedulerRewardRatioPolicy;\r\n\t}\r\n\r\n\tfunction transferOwnership(address) public { revert(\"disabled\"); }\r\n\r\n}\r\n\r\n\r\ncontract WorkerpoolRegistry is RegistryBase //, OwnableMutable // is Owned by IexecHub\r\n{\r\n\tevent CreateWorkerpool(address indexed workerpoolOwner, address indexed workerpool, string workerpoolDescription);\r\n\r\n\t/**\r\n\t * Constructor\r\n\t */\r\n\tconstructor()\r\n\tpublic\r\n\t{\r\n\t}\r\n\r\n\t/**\r\n\t * Pool creation\r\n\t */\r\n\tfunction createWorkerpool(\r\n\t\taddress          _workerpoolOwner,\r\n\t\tstring  calldata _workerpoolDescription)\r\n\texternal /* onlyOwner /*owner == IexecHub*/ returns (Workerpool)\r\n\t{\r\n\t\tWorkerpool newWorkerpool = new Workerpool(\r\n\t\t\t_workerpoolOwner,\r\n\t\t\t_workerpoolDescription\r\n\t\t);\r\n\t\trequire(insert(address(newWorkerpool), _workerpoolOwner));\r\n\t\temit CreateWorkerpool(_workerpoolOwner, address(newWorkerpool), _workerpoolDescription);\r\n\t\treturn newWorkerpool;\r\n\t}\r\n}\r\n\r\n\r\n\r\ncontract CategoryManager is Ownable\r\n{\r\n\t/**\r\n\t * Content\r\n\t */\r\n\tIexecODBLibCore.Category[] m_categories;\r\n\r\n\t/**\r\n\t * Event\r\n\t */\r\n\tevent CreateCategory(\r\n\t\tuint256 catid,\r\n\t\tstring  name,\r\n\t\tstring  description,\r\n\t\tuint256 workClockTimeRef);\r\n\r\n\t/**\r\n\t * Constructor\r\n\t */\r\n\tconstructor()\r\n\tpublic\r\n\t{\r\n\t}\r\n\r\n\t/**\r\n\t * Accessors\r\n\t */\r\n\tfunction viewCategory(uint256 _catid)\r\n\texternal view returns (IexecODBLibCore.Category memory category)\r\n\t{\r\n\t\treturn m_categories[_catid];\r\n\t}\r\n\r\n\tfunction countCategory()\r\n\texternal view returns (uint256 count)\r\n\t{\r\n\t\treturn m_categories.length;\r\n\t}\r\n\r\n\t/**\r\n\t * Methods\r\n\t */\r\n\tfunction createCategory(\r\n\t\tstring  calldata name,\r\n\t\tstring  calldata description,\r\n\t\tuint256          workClockTimeRef)\r\n\texternal onlyOwner returns (uint256)\r\n\t{\r\n\t\tuint256 catid = m_categories.push(IexecODBLibCore.Category(\r\n\t\t\tname,\r\n\t\t\tdescription,\r\n\t\t\tworkClockTimeRef\r\n\t\t)) - 1;\r\n\r\n\t\temit CreateCategory(\r\n\t\t\tcatid,\r\n\t\t\tname,\r\n\t\t\tdescription,\r\n\t\t\tworkClockTimeRef\r\n\t\t);\r\n\t\treturn catid;\r\n\t}\r\n\t/**\r\n\t * TODO: move to struct based initialization ?\r\n\t *\r\n\tfunction createCategory(IexecODBLib.Category _category)\r\n\tpublic onlyOwner returns (uint256)\r\n\t{\r\n\t\tuint256 catid = m_categories.push(_category);\r\n\t\temit CreateCategory(\r\n\t\t\tcatid,\r\n\t\t\t_category.name,\r\n\t\t\t_category.description,\r\n\t\t\t_category.workClockTimeRef\r\n\t\t);\r\n\t\treturn catid;\r\n\t}\r\n\t*/\r\n\r\n}\r\n\r\n\r\n\r\ncontract Escrow\r\n{\r\n\tusing SafeMath for uint256;\r\n\r\n\t/**\r\n\t* token contract for transfers.\r\n\t*/\r\n\tIERC20 public token;\r\n\r\n\t/**\r\n\t * Escrow content\r\n\t */\r\n\tmapping(address => IexecODBLibCore.Account) m_accounts;\r\n\r\n\t/**\r\n\t * Events\r\n\t */\r\n\tevent Deposit   (address owner, uint256 amount);\r\n\tevent DepositFor(address owner, uint256 amount, address target);\r\n\tevent Withdraw  (address owner, uint256 amount);\r\n\tevent Reward    (address user,  uint256 amount, bytes32 ref);\r\n\tevent Seize     (address user,  uint256 amount, bytes32 ref);\r\n\tevent Lock      (address user,  uint256 amount);\r\n\tevent Unlock    (address user,  uint256 amount);\r\n\r\n\t/**\r\n\t * Constructor\r\n\t */\r\n\tconstructor(address _token)\r\n\tpublic\r\n\t{\r\n\t\ttoken = IERC20(_token);\r\n\t}\r\n\r\n\t/**\r\n\t * Accessor\r\n\t */\r\n\tfunction viewAccount(address _user)\r\n\texternal view returns (IexecODBLibCore.Account memory account)\r\n\t{\r\n\t\treturn m_accounts[_user];\r\n\t}\r\n\r\n\t/**\r\n\t * Wallet methods: public\r\n\t */\r\n\tfunction deposit(uint256 _amount)\r\n\texternal returns (bool)\r\n\t{\r\n\t\trequire(token.transferFrom(msg.sender, address(this), _amount));\r\n\t\tm_accounts[msg.sender].stake = m_accounts[msg.sender].stake.add(_amount);\r\n\t\temit Deposit(msg.sender, _amount);\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction depositFor(uint256 _amount, address _target)\r\n\tpublic returns (bool)\r\n\t{\r\n\t\trequire(_target != address(0));\r\n\r\n\t\trequire(token.transferFrom(msg.sender, address(this), _amount));\r\n\t\tm_accounts[_target].stake = m_accounts[_target].stake.add(_amount);\r\n\t\temit DepositFor(msg.sender, _amount, _target);\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction depositForArray(uint256[] calldata _amounts, address[] calldata _targets)\r\n\texternal returns (bool)\r\n\t{\r\n\t\trequire(_amounts.length == _targets.length);\r\n\t\tfor (uint i = 0; i < _amounts.length; ++i)\r\n\t\t{\r\n\t\t\tdepositFor(_amounts[i], _targets[i]);\r\n\t\t}\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction withdraw(uint256 _amount)\r\n\texternal returns (bool)\r\n\t{\r\n\t\tm_accounts[msg.sender].stake = m_accounts[msg.sender].stake.sub(_amount);\r\n\t\trequire(token.transfer(msg.sender, _amount));\r\n\t\temit Withdraw(msg.sender, _amount);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * Wallet methods: Internal\r\n\t */\r\n\tfunction reward(address _user, uint256 _amount, bytes32 _reference) internal /* returns (bool) */\r\n\t{\r\n\t\tm_accounts[_user].stake = m_accounts[_user].stake.add(_amount);\r\n\t\temit Reward(_user, _amount, _reference);\r\n\t\t/* return true; */\r\n\t}\r\n\tfunction seize(address _user, uint256 _amount, bytes32 _reference) internal /* returns (bool) */\r\n\t{\r\n\t\tm_accounts[_user].locked = m_accounts[_user].locked.sub(_amount);\r\n\t\temit Seize(_user, _amount, _reference);\r\n\t\t/* return true; */\r\n\t}\r\n\tfunction lock(address _user, uint256 _amount) internal /* returns (bool) */\r\n\t{\r\n\t\tm_accounts[_user].stake  = m_accounts[_user].stake.sub(_amount);\r\n\t\tm_accounts[_user].locked = m_accounts[_user].locked.add(_amount);\r\n\t\temit Lock(_user, _amount);\r\n\t\t/* return true; */\r\n\t}\r\n\tfunction unlock(address _user, uint256 _amount) internal /* returns (bool) */\r\n\t{\r\n\t\tm_accounts[_user].locked = m_accounts[_user].locked.sub(_amount);\r\n\t\tm_accounts[_user].stake  = m_accounts[_user].stake.add(_amount);\r\n\t\temit Unlock(_user, _amount);\r\n\t\t/* return true; */\r\n\t}\r\n}\r\n\r\n\r\ncontract Relay\r\n{\r\n\tevent BroadcastAppOrder       (IexecODBLibOrders.AppOrder        apporder       );\r\n\tevent BroadcastDatasetOrder   (IexecODBLibOrders.DatasetOrder    datasetorder   );\r\n\tevent BroadcastWorkerpoolOrder(IexecODBLibOrders.WorkerpoolOrder workerpoolorder);\r\n\tevent BroadcastRequestOrder   (IexecODBLibOrders.RequestOrder    requestorder   );\r\n\r\n\tconstructor() public {}\r\n\r\n\tfunction broadcastAppOrder       (IexecODBLibOrders.AppOrder        memory _apporder       ) public { emit BroadcastAppOrder       (_apporder       ); }\r\n\tfunction broadcastDatasetOrder   (IexecODBLibOrders.DatasetOrder    memory _datasetorder   ) public { emit BroadcastDatasetOrder   (_datasetorder   ); }\r\n\tfunction broadcastWorkerpoolOrder(IexecODBLibOrders.WorkerpoolOrder memory _workerpoolorder) public { emit BroadcastWorkerpoolOrder(_workerpoolorder); }\r\n\tfunction broadcastRequestOrder   (IexecODBLibOrders.RequestOrder    memory _requestorder   ) public { emit BroadcastRequestOrder   (_requestorder   ); }\r\n}\r\n\r\n\r\ncontract SignatureVerifier\r\n{\r\n\tfunction addrToKey(address _addr)\r\n\tinternal pure returns (bytes32)\r\n\t{\r\n\t\treturn bytes32(uint256(_addr));\r\n\t}\r\n\r\n\tfunction checkIdentity(address _identity, address _candidate, uint256 _purpose)\r\n\tinternal view returns (bool valid)\r\n\t{\r\n\t\treturn _identity == _candidate || IERC734(_identity).keyHasPurpose(addrToKey(_candidate), _purpose); // Simple address || ERC 734 identity contract\r\n\t}\r\n\r\n\t// internal ?\r\n\tfunction verifySignature(\r\n\t\taddress      _identity,\r\n\t\tbytes32      _hash,\r\n\t\tbytes memory _signature)\r\n\tpublic view returns (bool)\r\n\t{\r\n\t\treturn recoverCheck(_identity, _hash, _signature) || IERC1271(_identity).isValidSignature(_hash, _signature);\r\n\t}\r\n\r\n\t// recoverCheck does not revert if signature has invalid format\r\n\tfunction recoverCheck(address candidate, bytes32 hash, bytes memory sign)\r\n\tinternal pure returns (bool)\r\n\t{\r\n\t\tbytes32 r;\r\n\t\tbytes32 s;\r\n\t\tuint8   v;\r\n\t\tif (sign.length != 65) return false;\r\n\t\tassembly\r\n\t\t{\r\n\t\t\tr :=         mload(add(sign, 0x20))\r\n\t\t\ts :=         mload(add(sign, 0x40))\r\n\t\t\tv := byte(0, mload(add(sign, 0x60)))\r\n\t\t}\r\n\t\tif (v < 27) v += 27;\r\n\t\tif (v != 27 && v != 28) return false;\r\n\t\treturn candidate == ecrecover(hash, v, r, s);\r\n\t}\r\n\r\n\tfunction toEthSignedMessageHash(bytes32 hash)\r\n\tinternal pure returns (bytes32)\r\n\t{\r\n\t\treturn keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\r\n\t}\r\n}\r\n\r\ninterface IexecHubInterface\r\n{\r\n\tfunction checkResources(address, address, address)\r\n\texternal view returns (bool);\r\n}\r\n\r\n\r\ncontract IexecHubAccessor\r\n{\r\n\tIexecHubInterface public iexechub;\r\n\r\n\tmodifier onlyIexecHub()\r\n\t{\r\n\t\trequire(msg.sender == address(iexechub));\r\n\t\t_;\r\n\t}\r\n\r\n\tconstructor(address _iexechub)\r\n\tpublic\r\n\t{\r\n\t\trequire(_iexechub != address(0));\r\n\t\tiexechub = IexecHubInterface(_iexechub);\r\n\t}\r\n\r\n}\r\n\r\ncontract IexecClerkABILegacy\r\n{\r\n\tuint256 public constant POOL_STAKE_RATIO = 30;\r\n\tuint256 public constant KITTY_RATIO      = 10;\r\n\tuint256 public constant KITTY_MIN        = 1000000000; // TODO: 1RLC ?\r\n\r\n\tbytes32 public /* immutable */ EIP712DOMAIN_SEPARATOR;\r\n\r\n\tmapping(bytes32 => bytes32[]) public m_requestdeals;\r\n\tmapping(bytes32 => uint256  ) public m_consumed;\r\n\tmapping(bytes32 => bool     ) public m_presigned;\r\n\r\n\tevent OrdersMatched        (bytes32 dealid, bytes32 appHash, bytes32 datasetHash, bytes32 workerpoolHash, bytes32 requestHash, uint256 volume);\r\n\tevent ClosedAppOrder       (bytes32 appHash);\r\n\tevent ClosedDatasetOrder   (bytes32 datasetHash);\r\n\tevent ClosedWorkerpoolOrder(bytes32 workerpoolHash);\r\n\tevent ClosedRequestOrder   (bytes32 requestHash);\r\n\tevent SchedulerNotice      (address indexed workerpool, bytes32 dealid);\r\n\r\n\tfunction viewRequestDeals(bytes32 _id)\r\n\texternal view returns (bytes32[] memory);\r\n\r\n\tfunction viewConsumed(bytes32 _id)\r\n\texternal view returns (uint256);\r\n\r\n\tfunction lockContribution(bytes32 _dealid, address _worker)\r\n\texternal;\r\n\r\n\tfunction unlockContribution(bytes32 _dealid, address _worker)\r\n\texternal;\r\n\r\n\tfunction unlockAndRewardForContribution(bytes32 _dealid, address _worker, uint256 _amount, bytes32 _taskid)\r\n\texternal;\r\n\r\n\tfunction seizeContribution(bytes32 _dealid, address _worker, bytes32 _taskid)\r\n\texternal;\r\n\r\n\tfunction rewardForScheduling(bytes32 _dealid, uint256 _amount, bytes32 _taskid)\r\n\texternal;\r\n\r\n\tfunction successWork(bytes32 _dealid, bytes32 _taskid)\r\n\texternal;\r\n\r\n\tfunction failedWork(bytes32 _dealid, bytes32 _taskid)\r\n\texternal;\r\n\r\n\r\n\r\n\r\n\tfunction viewDealABILegacy_pt1(bytes32 _id)\r\n\texternal view returns\r\n\t( address\r\n\t, address\r\n\t, uint256\r\n\t, address\r\n\t, address\r\n\t, uint256\r\n\t, address\r\n\t, address\r\n\t, uint256\r\n\t);\r\n\r\n\tfunction viewDealABILegacy_pt2(bytes32 _id)\r\n\texternal view returns\r\n\t( uint256\r\n\t, bytes32\r\n\t, address\r\n\t, address\r\n\t, address\r\n\t, string memory\r\n\t);\r\n\r\n\tfunction viewConfigABILegacy(bytes32 _id)\r\n\texternal view returns\r\n\t( uint256\r\n\t, uint256\r\n\t, uint256\r\n\t, uint256\r\n\t, uint256\r\n\t, uint256\r\n\t);\r\n\r\n\tfunction viewAccountABILegacy(address _user)\r\n\texternal view returns (uint256, uint256);\r\n}\r\n\r\n\r\n\r\n/**\r\n * /!\\ TEMPORARY LEGACY /!\\\r\n */\r\n\r\ncontract IexecClerk is Escrow, Relay, IexecHubAccessor, SignatureVerifier, IexecClerkABILegacy\r\n{\r\n\tusing SafeMath          for uint256;\r\n\tusing IexecODBLibOrders for bytes32;\r\n\tusing IexecODBLibOrders for IexecODBLibOrders.EIP712Domain;\r\n\tusing IexecODBLibOrders for IexecODBLibOrders.AppOrder;\r\n\tusing IexecODBLibOrders for IexecODBLibOrders.DatasetOrder;\r\n\tusing IexecODBLibOrders for IexecODBLibOrders.WorkerpoolOrder;\r\n\tusing IexecODBLibOrders for IexecODBLibOrders.RequestOrder;\r\n\r\n\t/***************************************************************************\r\n\t *                                Constants                                *\r\n\t ***************************************************************************/\r\n\tuint256 public constant WORKERPOOL_STAKE_RATIO = 30;\r\n\tuint256 public constant KITTY_RATIO            = 10;\r\n\tuint256 public constant KITTY_MIN              = 1000000000; // TODO: 1RLC ?\r\n\r\n\t// For authorizations\r\n\tuint256 public constant GROUPMEMBER_PURPOSE    = 4;\r\n\r\n\t/***************************************************************************\r\n\t *                            EIP712 signature                             *\r\n\t ***************************************************************************/\r\n\tbytes32 public /* immutable */ EIP712DOMAIN_SEPARATOR;\r\n\r\n\t/***************************************************************************\r\n\t *                               Clerk data                                *\r\n\t ***************************************************************************/\r\n\tmapping(bytes32 => bytes32[]           ) m_requestdeals;\r\n\tmapping(bytes32 => IexecODBLibCore.Deal) m_deals;\r\n\tmapping(bytes32 => uint256             ) m_consumed;\r\n\tmapping(bytes32 => bool                ) m_presigned;\r\n\r\n\t/***************************************************************************\r\n\t *                                 Events                                  *\r\n\t ***************************************************************************/\r\n\tevent OrdersMatched        (bytes32 dealid, bytes32 appHash, bytes32 datasetHash, bytes32 workerpoolHash, bytes32 requestHash, uint256 volume);\r\n\tevent ClosedAppOrder       (bytes32 appHash);\r\n\tevent ClosedDatasetOrder   (bytes32 datasetHash);\r\n\tevent ClosedWorkerpoolOrder(bytes32 workerpoolHash);\r\n\tevent ClosedRequestOrder   (bytes32 requestHash);\r\n\tevent SchedulerNotice      (address indexed workerpool, bytes32 dealid);\r\n\r\n\t/***************************************************************************\r\n\t *                               Constructor                               *\r\n\t ***************************************************************************/\r\n\tconstructor(\r\n\t\taddress _token,\r\n\t\taddress _iexechub,\r\n\t\tuint256 _chainid)\r\n\tpublic\r\n\tEscrow(_token)\r\n\tIexecHubAccessor(_iexechub)\r\n\t{\r\n\t\tEIP712DOMAIN_SEPARATOR = IexecODBLibOrders.EIP712Domain({\r\n\t\t\tname:              \"iExecODB\"\r\n\t\t, version:           \"3.0-alpha\"\r\n\t\t, chainId:           _chainid\r\n\t\t, verifyingContract: address(this)\r\n\t\t}).hash();\r\n\t}\r\n\r\n\t/***************************************************************************\r\n\t *                                Accessor                                 *\r\n\t ***************************************************************************/\r\n\tfunction viewRequestDeals(bytes32 _id)\r\n\texternal view returns (bytes32[] memory requestdeals)\r\n\t{\r\n\t\treturn m_requestdeals[_id];\r\n\t}\r\n\r\n\tfunction viewDeal(bytes32 _id)\r\n\texternal view returns (IexecODBLibCore.Deal memory deal)\r\n\t{\r\n\t\treturn m_deals[_id];\r\n\t}\r\n\r\n\tfunction viewConsumed(bytes32 _id)\r\n\texternal view returns (uint256 consumed)\r\n\t{\r\n\t\treturn m_consumed[_id];\r\n\t}\r\n\r\n\tfunction viewPresigned(bytes32 _id)\r\n\texternal view returns (bool presigned)\r\n\t{\r\n\t\treturn m_presigned[_id];\r\n\t}\r\n\r\n\t/***************************************************************************\r\n\t *                            pre-signing tools                            *\r\n\t ***************************************************************************/\r\n\t// should be external\r\n\tfunction signAppOrder(IexecODBLibOrders.AppOrder memory _apporder)\r\n\tpublic returns (bool)\r\n\t{\r\n\t\trequire(msg.sender == App(_apporder.app).owner());\r\n\t\tm_presigned[_apporder.hash().toEthTypedStructHash(EIP712DOMAIN_SEPARATOR)] = true;\r\n\t\treturn true;\r\n\t}\r\n\r\n\t// should be external\r\n\tfunction signDatasetOrder(IexecODBLibOrders.DatasetOrder memory _datasetorder)\r\n\tpublic returns (bool)\r\n\t{\r\n\t\trequire(msg.sender == Dataset(_datasetorder.dataset).owner());\r\n\t\tm_presigned[_datasetorder.hash().toEthTypedStructHash(EIP712DOMAIN_SEPARATOR)] = true;\r\n\t\treturn true;\r\n\t}\r\n\r\n\t// should be external\r\n\tfunction signWorkerpoolOrder(IexecODBLibOrders.WorkerpoolOrder memory _workerpoolorder)\r\n\tpublic returns (bool)\r\n\t{\r\n\t\trequire(msg.sender == Workerpool(_workerpoolorder.workerpool).owner());\r\n\t\tm_presigned[_workerpoolorder.hash().toEthTypedStructHash(EIP712DOMAIN_SEPARATOR)] = true;\r\n\t\treturn true;\r\n\t}\r\n\r\n\t// should be external\r\n\tfunction signRequestOrder(IexecODBLibOrders.RequestOrder memory _requestorder)\r\n\tpublic returns (bool)\r\n\t{\r\n\t\trequire(msg.sender == _requestorder.requester);\r\n\t\tm_presigned[_requestorder.hash().toEthTypedStructHash(EIP712DOMAIN_SEPARATOR)] = true;\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/***************************************************************************\r\n\t *                              Clerk methods                              *\r\n\t ***************************************************************************/\r\n\tstruct Identities\r\n\t{\r\n\t\tbytes32 appHash;\r\n\t\taddress appOwner;\r\n\t\tbytes32 datasetHash;\r\n\t\taddress datasetOwner;\r\n\t\tbytes32 workerpoolHash;\r\n\t\taddress workerpoolOwner;\r\n\t\tbytes32 requestHash;\r\n\t\tbool    hasDataset;\r\n\t}\r\n\r\n\t// should be external\r\n\tfunction matchOrders(\r\n\t\tIexecODBLibOrders.AppOrder        memory _apporder,\r\n\t\tIexecODBLibOrders.DatasetOrder    memory _datasetorder,\r\n\t\tIexecODBLibOrders.WorkerpoolOrder memory _workerpoolorder,\r\n\t\tIexecODBLibOrders.RequestOrder    memory _requestorder)\r\n\tpublic returns (bytes32)\r\n\t{\r\n\t\t/**\r\n\t\t * Check orders compatibility\r\n\t\t */\r\n\r\n\t\t// computation environment & allowed enough funds\r\n\t\trequire(_requestorder.category           == _workerpoolorder.category       );\r\n\t\trequire(_requestorder.trust              <= _workerpoolorder.trust          );\r\n\t\trequire(_requestorder.appmaxprice        >= _apporder.appprice              );\r\n\t\trequire(_requestorder.datasetmaxprice    >= _datasetorder.datasetprice      );\r\n\t\trequire(_requestorder.workerpoolmaxprice >= _workerpoolorder.workerpoolprice);\r\n\t\trequire((_apporder.tag | _datasetorder.tag | _requestorder.tag) & ~_workerpoolorder.tag == 0x0);\r\n\r\n\t\t// Check matching and restrictions\r\n\t\trequire(_requestorder.app     == _apporder.app        );\r\n\t\trequire(_requestorder.dataset == _datasetorder.dataset);\r\n\t\trequire(_requestorder.workerpool           == address(0) || checkIdentity(_requestorder.workerpool,           _workerpoolorder.workerpool, GROUPMEMBER_PURPOSE)); // requestorder.workerpool is a restriction\r\n\t\trequire(_apporder.datasetrestrict          == address(0) || checkIdentity(_apporder.datasetrestrict,          _datasetorder.dataset,       GROUPMEMBER_PURPOSE));\r\n\t\trequire(_apporder.workerpoolrestrict       == address(0) || checkIdentity(_apporder.workerpoolrestrict,       _workerpoolorder.workerpool, GROUPMEMBER_PURPOSE));\r\n\t\trequire(_apporder.requesterrestrict        == address(0) || checkIdentity(_apporder.requesterrestrict,        _requestorder.requester,     GROUPMEMBER_PURPOSE));\r\n\t\trequire(_datasetorder.apprestrict          == address(0) || checkIdentity(_datasetorder.apprestrict,          _apporder.app,               GROUPMEMBER_PURPOSE));\r\n\t\trequire(_datasetorder.workerpoolrestrict   == address(0) || checkIdentity(_datasetorder.workerpoolrestrict,   _workerpoolorder.workerpool, GROUPMEMBER_PURPOSE));\r\n\t\trequire(_datasetorder.requesterrestrict    == address(0) || checkIdentity(_datasetorder.requesterrestrict,    _requestorder.requester,     GROUPMEMBER_PURPOSE));\r\n\t\trequire(_workerpoolorder.apprestrict       == address(0) || checkIdentity(_workerpoolorder.apprestrict,       _apporder.app,               GROUPMEMBER_PURPOSE));\r\n\t\trequire(_workerpoolorder.datasetrestrict   == address(0) || checkIdentity(_workerpoolorder.datasetrestrict,   _datasetorder.dataset,       GROUPMEMBER_PURPOSE));\r\n\t\trequire(_workerpoolorder.requesterrestrict == address(0) || checkIdentity(_workerpoolorder.requesterrestrict, _requestorder.requester,     GROUPMEMBER_PURPOSE));\r\n\r\n\t\trequire(iexechub.checkResources(_apporder.app, _datasetorder.dataset, _workerpoolorder.workerpool));\r\n\r\n\t\t/**\r\n\t\t * Check orders authenticity\r\n\t\t */\r\n\t\tIdentities memory ids;\r\n\t\tids.hasDataset = _datasetorder.dataset != address(0);\r\n\r\n\t\t// app\r\n\t\tids.appHash  = _apporder.hash().toEthTypedStructHash(EIP712DOMAIN_SEPARATOR);\r\n\t\tids.appOwner = App(_apporder.app).owner();\r\n\t\trequire(m_presigned[ids.appHash] || verifySignature(ids.appOwner, ids.appHash, _apporder.sign));\r\n\r\n\t\t// dataset\r\n\t\tif (ids.hasDataset) // only check if dataset is enabled\r\n\t\t{\r\n\t\t\tids.datasetHash  = _datasetorder.hash().toEthTypedStructHash(EIP712DOMAIN_SEPARATOR);\r\n\t\t\tids.datasetOwner = Dataset(_datasetorder.dataset).owner();\r\n\t\t\trequire(m_presigned[ids.datasetHash] || verifySignature(ids.datasetOwner, ids.datasetHash, _datasetorder.sign));\r\n\t\t}\r\n\r\n\t\t// workerpool\r\n\t\tids.workerpoolHash  = _workerpoolorder.hash().toEthTypedStructHash(EIP712DOMAIN_SEPARATOR);\r\n\t\tids.workerpoolOwner = Workerpool(_workerpoolorder.workerpool).owner();\r\n\t\trequire(m_presigned[ids.workerpoolHash] || verifySignature(ids.workerpoolOwner, ids.workerpoolHash, _workerpoolorder.sign));\r\n\r\n\t\t// request\r\n\t\tids.requestHash = _requestorder.hash().toEthTypedStructHash(EIP712DOMAIN_SEPARATOR);\r\n\t\trequire(m_presigned[ids.requestHash] || verifySignature(_requestorder.requester, ids.requestHash, _requestorder.sign));\r\n\r\n\t\t/**\r\n\t\t * Check availability\r\n\t\t */\r\n\t\tuint256 volume;\r\n\t\tvolume =                             _apporder.volume.sub       (m_consumed[ids.appHash       ]);\r\n\t\tvolume = ids.hasDataset ? volume.min(_datasetorder.volume.sub   (m_consumed[ids.datasetHash   ])) : volume;\r\n\t\tvolume =                  volume.min(_workerpoolorder.volume.sub(m_consumed[ids.workerpoolHash]));\r\n\t\tvolume =                  volume.min(_requestorder.volume.sub   (m_consumed[ids.requestHash   ]));\r\n\t\trequire(volume > 0);\r\n\r\n\t\t/**\r\n\t\t * Record\r\n\t\t */\r\n\t\tbytes32 dealid = keccak256(abi.encodePacked(\r\n\t\t\tids.requestHash,            // requestHash\r\n\t\t\tm_consumed[ids.requestHash] // idx of first subtask\r\n\t\t));\r\n\r\n\t\tIexecODBLibCore.Deal storage deal = m_deals[dealid];\r\n\t\tdeal.app.pointer          = _apporder.app;\r\n\t\tdeal.app.owner            = ids.appOwner;\r\n\t\tdeal.app.price            = _apporder.appprice;\r\n\t\tdeal.dataset.owner        = ids.datasetOwner;\r\n\t\tdeal.dataset.pointer      = _datasetorder.dataset;\r\n\t\tdeal.dataset.price        = ids.hasDataset ? _datasetorder.datasetprice : 0;\r\n\t\tdeal.workerpool.pointer   = _workerpoolorder.workerpool;\r\n\t\tdeal.workerpool.owner     = ids.workerpoolOwner;\r\n\t\tdeal.workerpool.price     = _workerpoolorder.workerpoolprice;\r\n\t\tdeal.trust                = _requestorder.trust.max(1);\r\n\t\tdeal.category             = _requestorder.category;\r\n\t\tdeal.tag                  = _apporder.tag | _datasetorder.tag | _requestorder.tag;\r\n\t\tdeal.requester            = _requestorder.requester;\r\n\t\tdeal.beneficiary          = _requestorder.beneficiary;\r\n\t\tdeal.callback             = _requestorder.callback;\r\n\t\tdeal.params               = _requestorder.params;\r\n\t\tdeal.startTime            = now;\r\n\t\tdeal.botFirst             = m_consumed[ids.requestHash];\r\n\t\tdeal.botSize              = volume;\r\n\t\tdeal.workerStake          = _workerpoolorder.workerpoolprice.percentage(Workerpool(_workerpoolorder.workerpool).m_workerStakeRatioPolicy());\r\n\t\tdeal.schedulerRewardRatio = Workerpool(_workerpoolorder.workerpool).m_schedulerRewardRatioPolicy();\r\n\r\n\t\tm_requestdeals[ids.requestHash].push(dealid);\r\n\r\n\t\t/**\r\n\t\t * Update consumed\r\n\t\t */\r\n\t\tm_consumed[ids.appHash       ] = m_consumed[ids.appHash       ].add(                 volume    );\r\n\t\tm_consumed[ids.datasetHash   ] = m_consumed[ids.datasetHash   ].add(ids.hasDataset ? volume : 0);\r\n\t\tm_consumed[ids.workerpoolHash] = m_consumed[ids.workerpoolHash].add(                 volume    );\r\n\t\tm_consumed[ids.requestHash   ] = m_consumed[ids.requestHash   ].add(                 volume    );\r\n\r\n\t\t/**\r\n\t\t * Lock\r\n\t\t */\r\n\t\tlock(\r\n\t\t\tdeal.requester,\r\n\t\t\tdeal.app.price\r\n\t\t\t.add(deal.dataset.price)\r\n\t\t\t.add(deal.workerpool.price)\r\n\t\t\t.mul(volume)\r\n\t\t);\r\n\t\tlock(\r\n\t\t\tdeal.workerpool.owner,\r\n\t\t\tdeal.workerpool.price\r\n\t\t\t.percentage(WORKERPOOL_STAKE_RATIO) // ORDER IS IMPORTANT HERE!\r\n\t\t\t.mul(volume)                        // ORDER IS IMPORTANT HERE!\r\n\t\t);\r\n\r\n\t\t/**\r\n\t\t * Advertize deal\r\n\t\t */\r\n\t\temit SchedulerNotice(deal.workerpool.pointer, dealid);\r\n\r\n\t\t/**\r\n\t\t * Advertize consumption\r\n\t\t */\r\n\t\temit OrdersMatched(\r\n\t\t\tdealid,\r\n\t\t\tids.appHash,\r\n\t\t\tids.datasetHash,\r\n\t\t\tids.workerpoolHash,\r\n\t\t\tids.requestHash,\r\n\t\t\tvolume\r\n\t\t);\r\n\r\n\t\treturn dealid;\r\n\t}\r\n\r\n\t// should be external\r\n\tfunction cancelAppOrder(IexecODBLibOrders.AppOrder memory _apporder)\r\n\tpublic returns (bool)\r\n\t{\r\n\t\tbytes32 dapporderHash = _apporder.hash().toEthTypedStructHash(EIP712DOMAIN_SEPARATOR);\r\n\t\trequire(msg.sender == App(_apporder.app).owner());\r\n\t\tm_consumed[dapporderHash] = _apporder.volume;\r\n\t\temit ClosedAppOrder(dapporderHash);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t// should be external\r\n\tfunction cancelDatasetOrder(IexecODBLibOrders.DatasetOrder memory _datasetorder)\r\n\tpublic returns (bool)\r\n\t{\r\n\t\tbytes32 dataorderHash = _datasetorder.hash().toEthTypedStructHash(EIP712DOMAIN_SEPARATOR);\r\n\t\trequire(msg.sender == Dataset(_datasetorder.dataset).owner());\r\n\t\tm_consumed[dataorderHash] = _datasetorder.volume;\r\n\t\temit ClosedDatasetOrder(dataorderHash);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t// should be external\r\n\tfunction cancelWorkerpoolOrder(IexecODBLibOrders.WorkerpoolOrder memory _workerpoolorder)\r\n\tpublic returns (bool)\r\n\t{\r\n\t\tbytes32 poolorderHash = _workerpoolorder.hash().toEthTypedStructHash(EIP712DOMAIN_SEPARATOR);\r\n\t\trequire(msg.sender == Workerpool(_workerpoolorder.workerpool).owner());\r\n\t\tm_consumed[poolorderHash] = _workerpoolorder.volume;\r\n\t\temit ClosedWorkerpoolOrder(poolorderHash);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t// should be external\r\n\tfunction cancelRequestOrder(IexecODBLibOrders.RequestOrder memory _requestorder)\r\n\tpublic returns (bool)\r\n\t{\r\n\t\tbytes32 requestorderHash = _requestorder.hash().toEthTypedStructHash(EIP712DOMAIN_SEPARATOR);\r\n\t\trequire(msg.sender == _requestorder.requester);\r\n\t\tm_consumed[requestorderHash] = _requestorder.volume;\r\n\t\temit ClosedRequestOrder(requestorderHash);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/***************************************************************************\r\n\t *                    Escrow overhead for contribution                     *\r\n\t ***************************************************************************/\r\n\tfunction lockContribution(bytes32 _dealid, address _worker)\r\n\texternal onlyIexecHub\r\n\t{\r\n\t\tlock(_worker, m_deals[_dealid].workerStake);\r\n\t}\r\n\r\n\tfunction unlockContribution(bytes32 _dealid, address _worker)\r\n\texternal onlyIexecHub\r\n\t{\r\n\t\tunlock(_worker, m_deals[_dealid].workerStake);\r\n\t}\r\n\r\n\tfunction unlockAndRewardForContribution(bytes32 _dealid, address _worker, uint256 _amount, bytes32 _taskid)\r\n\texternal onlyIexecHub\r\n\t{\r\n\t\tunlock(_worker, m_deals[_dealid].workerStake);\r\n\t\treward(_worker, _amount, _taskid);\r\n\t}\r\n\r\n\tfunction seizeContribution(bytes32 _dealid, address _worker, bytes32 _taskid)\r\n\texternal onlyIexecHub\r\n\t{\r\n\t\tseize(_worker, m_deals[_dealid].workerStake, _taskid);\r\n\t}\r\n\r\n\tfunction rewardForScheduling(bytes32 _dealid, uint256 _amount, bytes32 _taskid)\r\n\texternal onlyIexecHub\r\n\t{\r\n\t\treward(m_deals[_dealid].workerpool.owner, _amount, _taskid);\r\n\t}\r\n\r\n\tfunction successWork(bytes32 _dealid, bytes32 _taskid)\r\n\texternal onlyIexecHub\r\n\t{\r\n\t\tIexecODBLibCore.Deal storage deal = m_deals[_dealid];\r\n\r\n\t\tuint256 requesterstake = deal.app.price\r\n\t\t                         .add(deal.dataset.price)\r\n\t\t                         .add(deal.workerpool.price);\r\n\t\tuint256 poolstake = deal.workerpool.price\r\n\t\t                    .percentage(WORKERPOOL_STAKE_RATIO);\r\n\r\n\t\t// seize requester funds\r\n\t\tseize(deal.requester, requesterstake, _taskid);\r\n\t\t// dapp reward\r\n\t\tif (deal.app.price > 0)\r\n\t\t{\r\n\t\t\treward(deal.app.owner, deal.app.price, _taskid);\r\n\t\t}\r\n\t\t// data reward\r\n\t\tif (deal.dataset.price > 0 && deal.dataset.pointer != address(0))\r\n\t\t{\r\n\t\t\treward(deal.dataset.owner, deal.dataset.price, _taskid);\r\n\t\t}\r\n\t\t// unlock pool stake\r\n\t\tunlock(deal.workerpool.owner, poolstake);\r\n\t\t// pool reward performed by consensus manager\r\n\r\n\t\t/**\r\n\t\t * Retrieve part of the kitty\r\n\t\t * TODO: remove / keep ?\r\n\t\t */\r\n\t\tuint256 kitty = m_accounts[address(0)].locked;\r\n\t\tif (kitty > 0)\r\n\t\t{\r\n\t\t\tkitty = kitty\r\n\t\t\t        .percentage(KITTY_RATIO) // fraction\r\n\t\t\t        .max(KITTY_MIN)          // at least this\r\n\t\t\t        .min(kitty);             // but not more than available\r\n\t\t\tseize (address(0),            kitty, _taskid);\r\n\t\t\treward(deal.workerpool.owner, kitty, _taskid);\r\n\t\t}\r\n\t}\r\n\r\n\tfunction failedWork(bytes32 _dealid, bytes32 _taskid)\r\n\texternal onlyIexecHub\r\n\t{\r\n\t\tIexecODBLibCore.Deal storage deal = m_deals[_dealid];\r\n\r\n\t\tuint256 requesterstake = deal.app.price\r\n\t\t                         .add(deal.dataset.price)\r\n\t\t                         .add(deal.workerpool.price);\r\n\t\tuint256 poolstake = deal.workerpool.price\r\n\t\t                    .percentage(WORKERPOOL_STAKE_RATIO);\r\n\r\n\t\tunlock(deal.requester,        requesterstake    );\r\n\t\tseize (deal.workerpool.owner, poolstake, _taskid);\r\n\t\treward(address(0),            poolstake, _taskid); // → Kitty / Burn\r\n\t\tlock  (address(0),            poolstake         ); // → Kitty / Burn\r\n\t}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\t/**\r\n\t * /!\\ TEMPORARY LEGACY /!\\\r\n\t */\r\n\r\n\tfunction viewDealABILegacy_pt1(bytes32 _id)\r\n\texternal view returns\r\n\t( address\r\n\t, address\r\n\t, uint256\r\n\t, address\r\n\t, address\r\n\t, uint256\r\n\t, address\r\n\t, address\r\n\t, uint256\r\n\t)\r\n\t{\r\n\t\tIexecODBLibCore.Deal memory deal = m_deals[_id];\r\n\t\treturn (\r\n\t\t\tdeal.app.pointer,\r\n\t\t\tdeal.app.owner,\r\n\t\t\tdeal.app.price,\r\n\t\t\tdeal.dataset.pointer,\r\n\t\t\tdeal.dataset.owner,\r\n\t\t\tdeal.dataset.price,\r\n\t\t\tdeal.workerpool.pointer,\r\n\t\t\tdeal.workerpool.owner,\r\n\t\t\tdeal.workerpool.price\r\n\t\t);\r\n\t}\r\n\r\n\tfunction viewDealABILegacy_pt2(bytes32 _id)\r\n\texternal view returns\r\n\t( uint256\r\n\t, bytes32\r\n\t, address\r\n\t, address\r\n\t, address\r\n\t, string memory\r\n\t)\r\n\t{\r\n\t\tIexecODBLibCore.Deal memory deal = m_deals[_id];\r\n\t\treturn (\r\n\t\t\tdeal.trust,\r\n\t\t\tdeal.tag,\r\n\t\t\tdeal.requester,\r\n\t\t\tdeal.beneficiary,\r\n\t\t\tdeal.callback,\r\n\t\t\tdeal.params\r\n\t\t);\r\n\t}\r\n\r\n\tfunction viewConfigABILegacy(bytes32 _id)\r\n\texternal view returns\r\n\t( uint256\r\n\t, uint256\r\n\t, uint256\r\n\t, uint256\r\n\t, uint256\r\n\t, uint256\r\n\t)\r\n\t{\r\n\t\tIexecODBLibCore.Deal memory deal = m_deals[_id];\r\n\t\treturn (\r\n\t\t\tdeal.category,\r\n\t\t\tdeal.startTime,\r\n\t\t\tdeal.botFirst,\r\n\t\t\tdeal.botSize,\r\n\t\t\tdeal.workerStake,\r\n\t\t\tdeal.schedulerRewardRatio\r\n\t\t);\r\n\t}\r\n\r\n\tfunction viewAccountABILegacy(address _user)\r\n\texternal view returns (uint256, uint256)\r\n\t{\r\n\t\tIexecODBLibCore.Account memory account = m_accounts[_user];\r\n\t\treturn ( account.stake, account.locked );\r\n\t}\r\n}\r\n\r\n\r\n\r\ncontract IexecHubABILegacy\r\n{\r\n\tuint256 public constant CONSENSUS_DURATION_RATIO = 10;\r\n\tuint256 public constant REVEAL_DURATION_RATIO    = 2;\r\n\r\n\tIexecClerk   public iexecclerk;\r\n\tRegistryBase public appregistry;\r\n\tRegistryBase public datasetregistry;\r\n\tRegistryBase public workerpoolregistry;\r\n\r\n\tevent TaskInitialize(bytes32 indexed taskid, address indexed workerpool               );\r\n\tevent TaskContribute(bytes32 indexed taskid, address indexed worker, bytes32 hash     );\r\n\tevent TaskConsensus (bytes32 indexed taskid,                         bytes32 consensus);\r\n\tevent TaskReveal    (bytes32 indexed taskid, address indexed worker, bytes32 digest   );\r\n\tevent TaskReopen    (bytes32 indexed taskid                                           );\r\n\tevent TaskFinalize  (bytes32 indexed taskid,                         bytes   results  );\r\n\tevent TaskClaimed   (bytes32 indexed taskid                                           );\r\n\r\n\tevent AccurateContribution(address indexed worker, bytes32 indexed taskid);\r\n\tevent FaultyContribution  (address indexed worker, bytes32 indexed taskid);\r\n\r\n\tfunction attachContracts(\r\n\t\taddress _iexecclerkAddress,\r\n\t\taddress _appregistryAddress,\r\n\t\taddress _datasetregistryAddress,\r\n\t\taddress _workerpoolregistryAddress)\r\n\texternal;\r\n\r\n\tfunction viewScore(address _worker)\r\n\texternal view returns (uint256);\r\n\r\n\tfunction checkResources(address aap, address dataset, address workerpool)\r\n\texternal view returns (bool);\r\n\r\n\tfunction resultFor(bytes32 id)\r\n\texternal view returns (bytes memory);\r\n\r\n\tfunction initialize(\r\n\t\tbytes32 _dealid,\r\n\t\tuint256 idx)\r\n\tpublic returns (bytes32);\r\n\r\n\tfunction contribute(\r\n\t\tbytes32      _taskid,\r\n\t\tbytes32      _resultHash,\r\n\t\tbytes32      _resultSeal,\r\n\t\taddress      _enclaveChallenge,\r\n\t\tbytes memory _enclaveSign,\r\n\t\tbytes memory _workerpoolSign)\r\n\tpublic;\r\n\r\n\tfunction reveal(\r\n\t\tbytes32 _taskid,\r\n\t\tbytes32 _resultDigest)\r\n\texternal;\r\n\r\n\tfunction reopen(\r\n\t\tbytes32 _taskid)\r\n\texternal;\r\n\r\n\tfunction finalize(\r\n\t\tbytes32 _taskid,\r\n\t\tbytes calldata  _results)\r\n\texternal;\r\n\r\n\tfunction claim(\r\n\t\tbytes32 _taskid)\r\n\tpublic;\r\n\r\n\tfunction initializeArray(\r\n\t\tbytes32[] calldata _dealid,\r\n\t\tuint256[] calldata _idx)\r\n\texternal returns (bool);\r\n\r\n\tfunction claimArray(\r\n\t\tbytes32[] calldata _taskid)\r\n\texternal returns (bool);\r\n\r\n\tfunction initializeAndClaimArray(\r\n\t\tbytes32[] calldata _dealid,\r\n\t\tuint256[] calldata _idx)\r\n\texternal returns (bool);\r\n\r\n\tfunction viewTaskABILegacy(bytes32 _taskid)\r\n\texternal view returns\r\n\t( IexecODBLibCore.TaskStatusEnum\r\n\t, bytes32\r\n\t, uint256\r\n\t, uint256\r\n\t, uint256\r\n\t, uint256\r\n\t, uint256\r\n\t, bytes32\r\n\t, uint256\r\n\t, uint256\r\n\t, address[] memory\r\n\t, bytes     memory\r\n\t);\r\n\r\n\tfunction viewContributionABILegacy(bytes32 _taskid, address _worker)\r\n\texternal view returns\r\n\t( IexecODBLibCore.ContributionStatusEnum\r\n\t, bytes32\r\n\t, bytes32\r\n\t, address\r\n\t);\r\n\r\n\tfunction viewCategoryABILegacy(uint256 _catid)\r\n\texternal view returns (string memory, string memory, uint256);\r\n}\r\n\r\n\r\n\r\n/**\r\n * /!\\ TEMPORARY LEGACY /!\\\r\n */\r\n\r\ncontract IexecHub is CategoryManager, IOracle, SignatureVerifier, IexecHubABILegacy\r\n{\r\n\tusing SafeMath for uint256;\r\n\r\n\t/***************************************************************************\r\n\t *                                Constants                                *\r\n\t ***************************************************************************/\r\n\tuint256 public constant CONTRIBUTION_DEADLINE_RATIO = 7;\r\n\tuint256 public constant       REVEAL_DEADLINE_RATIO = 2;\r\n\tuint256 public constant        FINAL_DEADLINE_RATIO = 10;\r\n\r\n\t/***************************************************************************\r\n\t *                             Other contracts                             *\r\n\t ***************************************************************************/\r\n\tIexecClerk   public iexecclerk;\r\n\tRegistryBase public appregistry;\r\n\tRegistryBase public datasetregistry;\r\n\tRegistryBase public workerpoolregistry;\r\n\r\n\t/***************************************************************************\r\n\t *                          Consensuses & Workers                          *\r\n\t ***************************************************************************/\r\n\tmapping(bytes32 =>                    IexecODBLibCore.Task         ) m_tasks;\r\n\tmapping(bytes32 => mapping(address => IexecODBLibCore.Contribution)) m_contributions;\r\n\tmapping(address =>                    uint256                      ) m_workerScores;\r\n\r\n\tmapping(bytes32 => mapping(address => uint256                     )) m_logweight;\r\n\tmapping(bytes32 => mapping(bytes32 => uint256                     )) m_groupweight;\r\n\tmapping(bytes32 =>                    uint256                      ) m_totalweight;\r\n\r\n\t/***************************************************************************\r\n\t *                                 Events                                  *\r\n\t ***************************************************************************/\r\n\tevent TaskInitialize(bytes32 indexed taskid, address indexed workerpool               );\r\n\tevent TaskContribute(bytes32 indexed taskid, address indexed worker, bytes32 hash     );\r\n\tevent TaskConsensus (bytes32 indexed taskid,                         bytes32 consensus);\r\n\tevent TaskReveal    (bytes32 indexed taskid, address indexed worker, bytes32 digest   );\r\n\tevent TaskReopen    (bytes32 indexed taskid                                           );\r\n\tevent TaskFinalize  (bytes32 indexed taskid,                         bytes results    );\r\n\tevent TaskClaimed   (bytes32 indexed taskid                                           );\r\n\r\n\tevent AccurateContribution(address indexed worker, bytes32 indexed taskid);\r\n\tevent FaultyContribution  (address indexed worker, bytes32 indexed taskid);\r\n\r\n\t/***************************************************************************\r\n\t *                                Modifiers                                *\r\n\t ***************************************************************************/\r\n\tmodifier onlyScheduler(bytes32 _taskid)\r\n\t{\r\n\t\trequire(msg.sender == iexecclerk.viewDeal(m_tasks[_taskid].dealid).workerpool.owner);\r\n\t\t_;\r\n\t}\r\n\r\n\t/***************************************************************************\r\n\t *                               Constructor                               *\r\n\t ***************************************************************************/\r\n\tconstructor()\r\n\tpublic\r\n\t{\r\n\t}\r\n\r\n\tfunction attachContracts(\r\n\t\taddress _iexecclerkAddress,\r\n\t\taddress _appregistryAddress,\r\n\t\taddress _datasetregistryAddress,\r\n\t\taddress _workerpoolregistryAddress)\r\n\texternal onlyOwner\r\n\t{\r\n\t\trequire(address(iexecclerk) == address(0));\r\n\t\tiexecclerk         = IexecClerk  (_iexecclerkAddress  );\r\n\t\tappregistry        = RegistryBase(_appregistryAddress);\r\n\t\tdatasetregistry    = RegistryBase(_datasetregistryAddress);\r\n\t\tworkerpoolregistry = RegistryBase(_workerpoolregistryAddress);\r\n\t}\r\n\r\n\t/***************************************************************************\r\n\t *                                Accessors                                *\r\n\t ***************************************************************************/\r\n\tfunction viewTask(bytes32 _taskid)\r\n\texternal view returns (IexecODBLibCore.Task memory)\r\n\t{\r\n\t\treturn m_tasks[_taskid];\r\n\t}\r\n\r\n\tfunction viewContribution(bytes32 _taskid, address _worker)\r\n\texternal view returns (IexecODBLibCore.Contribution memory)\r\n\t{\r\n\t\treturn m_contributions[_taskid][_worker];\r\n\t}\r\n\r\n\tfunction viewScore(address _worker)\r\n\texternal view returns (uint256)\r\n\t{\r\n\t\treturn m_workerScores[_worker];\r\n\t}\r\n\r\n\tfunction checkResources(address app, address dataset, address workerpool)\r\n\texternal view returns (bool)\r\n\t{\r\n\t\trequire(                         appregistry.isRegistered(app));\r\n\t\trequire(dataset == address(0) || datasetregistry.isRegistered(dataset));\r\n\t\trequire(                         workerpoolregistry.isRegistered(workerpool));\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/***************************************************************************\r\n\t *                         EIP 1154 PULL INTERFACE                         *\r\n\t ***************************************************************************/\r\n\tfunction resultFor(bytes32 id)\r\n\texternal view returns (bytes memory)\r\n\t{\r\n\t\tIexecODBLibCore.Task storage task = m_tasks[id];\r\n\t\trequire(task.status == IexecODBLibCore.TaskStatusEnum.COMPLETED);\r\n\t\treturn task.results;\r\n\t}\r\n\r\n\t/***************************************************************************\r\n\t *                            Consensus methods                            *\r\n\t ***************************************************************************/\r\n\tfunction initialize(bytes32 _dealid, uint256 idx)\r\n\tpublic returns (bytes32)\r\n\t{\r\n\t\tIexecODBLibCore.Deal memory deal = iexecclerk.viewDeal(_dealid);\r\n\r\n\t\trequire(idx >= deal.botFirst                  );\r\n\t\trequire(idx <  deal.botFirst.add(deal.botSize));\r\n\r\n\t\tbytes32 taskid  = keccak256(abi.encodePacked(_dealid, idx));\r\n\t\tIexecODBLibCore.Task storage task = m_tasks[taskid];\r\n\t\trequire(task.status == IexecODBLibCore.TaskStatusEnum.UNSET);\r\n\r\n\t\ttask.status               = IexecODBLibCore.TaskStatusEnum.ACTIVE;\r\n\t\ttask.dealid               = _dealid;\r\n\t\ttask.idx                  = idx;\r\n\t\ttask.timeref              = m_categories[deal.category].workClockTimeRef;\r\n\t\ttask.contributionDeadline = task.timeref.mul(CONTRIBUTION_DEADLINE_RATIO).add(deal.startTime);\r\n\t\ttask.finalDeadline        = task.timeref.mul(       FINAL_DEADLINE_RATIO).add(deal.startTime);\r\n\r\n\t\t// setup denominator\r\n\t\tm_totalweight[taskid] = 1;\r\n\r\n\t\temit TaskInitialize(taskid, iexecclerk.viewDeal(_dealid).workerpool.pointer);\r\n\r\n\t\treturn taskid;\r\n\t}\r\n\r\n\t// TODO: make external w/ calldata\r\n\tfunction contribute(\r\n\t\tbytes32      _taskid,\r\n\t\tbytes32      _resultHash,\r\n\t\tbytes32      _resultSeal,\r\n\t\taddress      _enclaveChallenge,\r\n\t\tbytes memory _enclaveSign,\r\n\t\tbytes memory _workerpoolSign)\r\n\tpublic\r\n\t{\r\n\t\tIexecODBLibCore.Task         storage task         = m_tasks[_taskid];\r\n\t\tIexecODBLibCore.Contribution storage contribution = m_contributions[_taskid][msg.sender];\r\n\t\tIexecODBLibCore.Deal         memory  deal         = iexecclerk.viewDeal(task.dealid);\r\n\r\n\t\trequire(task.status               == IexecODBLibCore.TaskStatusEnum.ACTIVE       );\r\n\t\trequire(task.contributionDeadline >  now                                         );\r\n\t\trequire(contribution.status       == IexecODBLibCore.ContributionStatusEnum.UNSET);\r\n\r\n\t\t// Check that the worker + taskid + enclave combo is authorized to contribute (scheduler signature)\r\n\t\trequire(verifySignature(\r\n\t\t\tdeal.workerpool.owner,\r\n\t\t\ttoEthSignedMessageHash(\r\n\t\t\t\tkeccak256(abi.encodePacked(\r\n\t\t\t\t\tmsg.sender,\r\n\t\t\t\t\t_taskid,\r\n\t\t\t\t\t_enclaveChallenge\r\n\t\t\t\t))\r\n\t\t\t),\r\n\t\t\t_workerpoolSign\r\n\t\t));\r\n\r\n\t\t// need enclave challenge if tag is set\r\n\t\trequire(_enclaveChallenge != address(0) || (deal.tag[31] & 0x01 == 0));\r\n\r\n\t\t// Check enclave signature\r\n\t\trequire(_enclaveChallenge == address(0) || verifySignature(\r\n\t\t\t_enclaveChallenge,\r\n\t\t\ttoEthSignedMessageHash(\r\n\t\t\t\tkeccak256(abi.encodePacked(\r\n\t\t\t\t\t_resultHash,\r\n\t\t\t\t\t_resultSeal\r\n\t\t\t\t))\r\n\t\t\t),\r\n\t\t\t_enclaveSign\r\n\t\t));\r\n\r\n\t\t// Update contribution entry\r\n\t\tcontribution.status           = IexecODBLibCore.ContributionStatusEnum.CONTRIBUTED;\r\n\t\tcontribution.resultHash       = _resultHash;\r\n\t\tcontribution.resultSeal       = _resultSeal;\r\n\t\tcontribution.enclaveChallenge = _enclaveChallenge;\r\n\t\ttask.contributors.push(msg.sender);\r\n\r\n\t\tiexecclerk.lockContribution(task.dealid, msg.sender);\r\n\r\n\t\temit TaskContribute(_taskid, msg.sender, _resultHash);\r\n\r\n\t\t// Contribution done → updating and checking concensus\r\n\r\n\t\t/*************************************************************************\r\n\t\t *                           SCORE POLICY 1/3                            *\r\n\t\t *                                                                       *\r\n\t\t *                          see documentation!                           *\r\n\t\t *************************************************************************/\r\n\t\t// k = 3\r\n\t\tuint256 weight = m_workerScores[msg.sender].div(3).max(3).sub(1);\r\n\t\tuint256 group  = m_groupweight[_taskid][_resultHash];\r\n\t\tuint256 delta  = group.max(1).mul(weight).sub(group);\r\n\r\n\t\tm_logweight  [_taskid][msg.sender ] = weight.log();\r\n\t\tm_groupweight[_taskid][_resultHash] = m_groupweight[_taskid][_resultHash].add(delta);\r\n\t\tm_totalweight[_taskid]              = m_totalweight[_taskid].add(delta);\r\n\r\n\t\t// Check consensus\r\n\t\tcheckConsensus(_taskid, _resultHash);\r\n\t}\r\n\tfunction checkConsensus(\r\n\t\tbytes32 _taskid,\r\n\t\tbytes32 _consensus)\r\n\tprivate\r\n\t{\r\n\t\tuint256 trust = iexecclerk.viewDeal(m_tasks[_taskid].dealid).trust;\r\n\t\tif (m_groupweight[_taskid][_consensus].mul(trust) > m_totalweight[_taskid].mul(trust.sub(1)))\r\n\t\t{\r\n\t\t\t// Preliminary checks done in \"contribute()\"\r\n\r\n\t\t\tIexecODBLibCore.Task storage task = m_tasks[_taskid];\r\n\t\t\tuint256 winnerCounter = 0;\r\n\t\t\tfor (uint256 i = 0; i < task.contributors.length; ++i)\r\n\t\t\t{\r\n\t\t\t\taddress w = task.contributors[i];\r\n\t\t\t\tif\r\n\t\t\t\t(\r\n\t\t\t\t\tm_contributions[_taskid][w].resultHash == _consensus\r\n\t\t\t\t\t&&\r\n\t\t\t\t\tm_contributions[_taskid][w].status == IexecODBLibCore.ContributionStatusEnum.CONTRIBUTED // REJECTED contribution must not be count\r\n\t\t\t\t)\r\n\t\t\t\t{\r\n\t\t\t\t\twinnerCounter = winnerCounter.add(1);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t// msg.sender is a contributor: no need to check\r\n\t\t\t// require(winnerCounter > 0);\r\n\t\t\ttask.status         = IexecODBLibCore.TaskStatusEnum.REVEALING;\r\n\t\t\ttask.consensusValue = _consensus;\r\n\t\t\ttask.revealDeadline = task.timeref.mul(REVEAL_DEADLINE_RATIO).add(now);\r\n\t\t\ttask.revealCounter  = 0;\r\n\t\t\ttask.winnerCounter  = winnerCounter;\r\n\r\n\t\t\temit TaskConsensus(_taskid, _consensus);\r\n\t\t}\r\n\t}\r\n\r\n\tfunction reveal(\r\n\t\tbytes32 _taskid,\r\n\t\tbytes32 _resultDigest)\r\n\texternal // worker\r\n\t{\r\n\t\tIexecODBLibCore.Task         storage task         = m_tasks[_taskid];\r\n\t\tIexecODBLibCore.Contribution storage contribution = m_contributions[_taskid][msg.sender];\r\n\t\trequire(task.status             == IexecODBLibCore.TaskStatusEnum.REVEALING                       );\r\n\t\trequire(task.revealDeadline     >  now                                                            );\r\n\t\trequire(contribution.status     == IexecODBLibCore.ContributionStatusEnum.CONTRIBUTED             );\r\n\t\trequire(contribution.resultHash == task.consensusValue                                            );\r\n\t\trequire(contribution.resultHash == keccak256(abi.encodePacked(            _taskid, _resultDigest)));\r\n\t\trequire(contribution.resultSeal == keccak256(abi.encodePacked(msg.sender, _taskid, _resultDigest)));\r\n\r\n\t\tcontribution.status = IexecODBLibCore.ContributionStatusEnum.PROVED;\r\n\t\ttask.revealCounter  = task.revealCounter.add(1);\r\n\t\ttask.resultDigest   = _resultDigest;\r\n\r\n\t\temit TaskReveal(_taskid, msg.sender, _resultDigest);\r\n\t}\r\n\r\n\tfunction reopen(\r\n\t\tbytes32 _taskid)\r\n\texternal onlyScheduler(_taskid)\r\n\t{\r\n\t\tIexecODBLibCore.Task storage task = m_tasks[_taskid];\r\n\t\trequire(task.status         == IexecODBLibCore.TaskStatusEnum.REVEALING);\r\n\t\trequire(task.finalDeadline  >  now                                     );\r\n\t\trequire(task.revealDeadline <= now\r\n\t\t     && task.revealCounter  == 0                                       );\r\n\r\n\t\tfor (uint256 i = 0; i < task.contributors.length; ++i)\r\n\t\t{\r\n\t\t\taddress worker = task.contributors[i];\r\n\t\t\tif (m_contributions[_taskid][worker].resultHash == task.consensusValue)\r\n\t\t\t{\r\n\t\t\t\tm_contributions[_taskid][worker].status = IexecODBLibCore.ContributionStatusEnum.REJECTED;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tm_totalweight[_taskid]                      = m_totalweight[_taskid].sub(m_groupweight[_taskid][task.consensusValue]);\r\n\t\tm_groupweight[_taskid][task.consensusValue] = 0;\r\n\r\n\t\ttask.status         = IexecODBLibCore.TaskStatusEnum.ACTIVE;\r\n\t\ttask.consensusValue = 0x0;\r\n\t\ttask.revealDeadline = 0;\r\n\t\ttask.winnerCounter  = 0;\r\n\r\n\t\temit TaskReopen(_taskid);\r\n\t}\r\n\r\n\tfunction finalize(\r\n\t\tbytes32          _taskid,\r\n\t\tbytes   calldata _results)\r\n\texternal onlyScheduler(_taskid)\r\n\t{\r\n\t\tIexecODBLibCore.Task storage task = m_tasks[_taskid];\r\n\t\trequire(task.status        == IexecODBLibCore.TaskStatusEnum.REVEALING);\r\n\t\trequire(task.finalDeadline >  now                                     );\r\n\t\trequire(task.revealCounter == task.winnerCounter\r\n\t\t    || (task.revealCounter >  0  && task.revealDeadline <= now)       );\r\n\r\n\t\ttask.status  = IexecODBLibCore.TaskStatusEnum.COMPLETED;\r\n\t\ttask.results = _results;\r\n\r\n\t\t/**\r\n\t\t * Stake and reward management\r\n\t\t */\r\n\t\tiexecclerk.successWork(task.dealid, _taskid);\r\n\t\tdistributeRewards(_taskid);\r\n\r\n\t\t/**\r\n\t\t * Event\r\n\t\t */\r\n\t\temit TaskFinalize(_taskid, _results);\r\n\r\n\t\t/**\r\n\t\t * Callback for smartcontracts using EIP1154\r\n\t\t */\r\n\t\taddress callbackTarget = iexecclerk.viewDeal(task.dealid).callback;\r\n\t\tif (callbackTarget != address(0))\r\n\t\t{\r\n\t\t\t/**\r\n\t\t\t * Call does not revert if the target smart contract is incompatible or reverts\r\n\t\t\t *\r\n\t\t\t * ATTENTION!\r\n\t\t\t * This call is dangerous and target smart contract can charge the stack.\r\n\t\t\t * Assume invalid state after the call.\r\n\t\t\t * See: https://solidity.readthedocs.io/en/develop/types.html#members-of-addresses\r\n\t\t\t *\r\n\t\t\t * TODO: gas provided?\r\n\t\t\t */\r\n\t\t\trequire(gasleft() > 100000);\r\n\t\t\tbool success;\r\n\t\t\t(success,) = callbackTarget.call.gas(100000)(abi.encodeWithSignature(\r\n\t\t\t\t\"receiveResult(bytes32,bytes)\",\r\n\t\t\t\t_taskid,\r\n\t\t\t\t_results\r\n\t\t\t));\r\n\t\t}\r\n\t}\r\n\r\n\tfunction distributeRewards(bytes32 _taskid)\r\n\tprivate\r\n\t{\r\n\t\tIexecODBLibCore.Task storage task = m_tasks[_taskid];\r\n\t\tIexecODBLibCore.Deal memory  deal = iexecclerk.viewDeal(task.dealid);\r\n\r\n\t\tuint256 i;\r\n\t\taddress worker;\r\n\r\n\t\tuint256 totalLogWeight = 0;\r\n\t\tuint256 totalReward = iexecclerk.viewDeal(task.dealid).workerpool.price;\r\n\r\n\t\tfor (i = 0; i < task.contributors.length; ++i)\r\n\t\t{\r\n\t\t\tworker = task.contributors[i];\r\n\t\t\tif (m_contributions[_taskid][worker].status == IexecODBLibCore.ContributionStatusEnum.PROVED)\r\n\t\t\t{\r\n\t\t\t\ttotalLogWeight = totalLogWeight.add(m_logweight[_taskid][worker]);\r\n\t\t\t}\r\n\t\t\telse // ContributionStatusEnum.REJECT or ContributionStatusEnum.CONTRIBUTED (not revealed)\r\n\t\t\t{\r\n\t\t\t\ttotalReward = totalReward.add(deal.workerStake);\r\n\t\t\t}\r\n\t\t}\r\n\t\trequire(totalLogWeight > 0);\r\n\r\n\t\t// compute how much is going to the workers\r\n\t\tuint256 workersReward = totalReward.percentage(uint256(100).sub(deal.schedulerRewardRatio));\r\n\r\n\t\tfor (i = 0; i < task.contributors.length; ++i)\r\n\t\t{\r\n\t\t\tworker = task.contributors[i];\r\n\t\t\tif (m_contributions[_taskid][worker].status == IexecODBLibCore.ContributionStatusEnum.PROVED)\r\n\t\t\t{\r\n\t\t\t\tuint256 workerReward = workersReward.mulByFraction(m_logweight[_taskid][worker], totalLogWeight);\r\n\t\t\t\ttotalReward          = totalReward.sub(workerReward);\r\n\r\n\t\t\t\tiexecclerk.unlockAndRewardForContribution(task.dealid, worker, workerReward, _taskid);\r\n\r\n\t\t\t\t// Only reward if replication happened\r\n\t\t\t\tif (task.contributors.length > 1)\r\n\t\t\t\t{\r\n\t\t\t\t\t/*******************************************************************\r\n\t\t\t\t\t *                        SCORE POLICY 2/3                         *\r\n\t\t\t\t\t *                                                                 *\r\n\t\t\t\t\t *                       see documentation!                        *\r\n\t\t\t\t\t *******************************************************************/\r\n\t\t\t\t\tm_workerScores[worker] = m_workerScores[worker].add(1);\r\n\t\t\t\t\temit AccurateContribution(worker, _taskid);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse // WorkStatusEnum.POCO_REJECT or ContributionStatusEnum.CONTRIBUTED (not revealed)\r\n\t\t\t{\r\n\t\t\t\t// No Reward\r\n\t\t\t\tiexecclerk.seizeContribution(task.dealid, worker, _taskid);\r\n\r\n\t\t\t\t// Always punish bad contributors\r\n\t\t\t\t{\r\n\t\t\t\t\t/*******************************************************************\r\n\t\t\t\t\t *                        SCORE POLICY 3/3                         *\r\n\t\t\t\t\t *                                                                 *\r\n\t\t\t\t\t *                       see documentation!                        *\r\n\t\t\t\t\t *******************************************************************/\r\n\t\t\t\t\t// k = 3\r\n\t\t\t\t\tm_workerScores[worker] = m_workerScores[worker].mulByFraction(2,3);\r\n\t\t\t\t\temit FaultyContribution(worker, _taskid);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t// totalReward now contains the scheduler share\r\n\t\tiexecclerk.rewardForScheduling(task.dealid, totalReward, _taskid);\r\n\t}\r\n\r\n\tfunction claim(\r\n\t\tbytes32 _taskid)\r\n\tpublic\r\n\t{\r\n\t\tIexecODBLibCore.Task storage task = m_tasks[_taskid];\r\n\t\trequire(task.status == IexecODBLibCore.TaskStatusEnum.ACTIVE\r\n\t\t     || task.status == IexecODBLibCore.TaskStatusEnum.REVEALING);\r\n\t\trequire(task.finalDeadline <= now);\r\n\r\n\t\ttask.status = IexecODBLibCore.TaskStatusEnum.FAILLED;\r\n\r\n\t\t/**\r\n\t\t * Stake management\r\n\t\t */\r\n\t\tiexecclerk.failedWork(task.dealid, _taskid);\r\n\t\tfor (uint256 i = 0; i < task.contributors.length; ++i)\r\n\t\t{\r\n\t\t\taddress worker = task.contributors[i];\r\n\t\t\tiexecclerk.unlockContribution(task.dealid, worker);\r\n\t\t}\r\n\r\n\t\temit TaskClaimed(_taskid);\r\n\t}\r\n\r\n\t/***************************************************************************\r\n\t *                            Array operations                             *\r\n\t ***************************************************************************/\r\n\tfunction initializeArray(\r\n\t\tbytes32[] calldata _dealid,\r\n\t\tuint256[] calldata _idx)\r\n\texternal returns (bool)\r\n\t{\r\n\t\trequire(_dealid.length == _idx.length);\r\n\t\tfor (uint i = 0; i < _dealid.length; ++i)\r\n\t\t{\r\n\t\t\tinitialize(_dealid[i], _idx[i]);\r\n\t\t}\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction claimArray(\r\n\t\tbytes32[] calldata _taskid)\r\n\texternal returns (bool)\r\n\t{\r\n\t\tfor (uint i = 0; i < _taskid.length; ++i)\r\n\t\t{\r\n\t\t\tclaim(_taskid[i]);\r\n\t\t}\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction initializeAndClaimArray(\r\n\t\tbytes32[] calldata _dealid,\r\n\t\tuint256[] calldata _idx)\r\n\texternal returns (bool)\r\n\t{\r\n\t\trequire(_dealid.length == _idx.length);\r\n\t\tfor (uint i = 0; i < _dealid.length; ++i)\r\n\t\t{\r\n\t\t\tclaim(initialize(_dealid[i], _idx[i]));\r\n\t\t}\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * /!\\ TEMPORARY LEGACY /!\\\r\n\t */\r\n\r\n\tfunction viewTaskABILegacy(bytes32 _taskid)\r\n\texternal view returns\r\n\t( IexecODBLibCore.TaskStatusEnum\r\n\t, bytes32\r\n\t, uint256\r\n\t, uint256\r\n\t, uint256\r\n\t, uint256\r\n\t, uint256\r\n\t, bytes32\r\n\t, uint256\r\n\t, uint256\r\n\t, address[] memory\r\n\t, bytes     memory\r\n\t)\r\n\t{\r\n\t\tIexecODBLibCore.Task memory task = m_tasks[_taskid];\r\n\t\treturn (\r\n\t\t\ttask.status,\r\n\t\t\ttask.dealid,\r\n\t\t\ttask.idx,\r\n\t\t\ttask.timeref,\r\n\t\t\ttask.contributionDeadline,\r\n\t\t\ttask.revealDeadline,\r\n\t\t\ttask.finalDeadline,\r\n\t\t\ttask.consensusValue,\r\n\t\t\ttask.revealCounter,\r\n\t\t\ttask.winnerCounter,\r\n\t\t\ttask.contributors,\r\n\t\t\ttask.results\r\n\t\t);\r\n\t}\r\n\r\n\tfunction viewContributionABILegacy(bytes32 _taskid, address _worker)\r\n\texternal view returns\r\n\t( IexecODBLibCore.ContributionStatusEnum\r\n\t, bytes32\r\n\t, bytes32\r\n\t, address\r\n\t)\r\n\t{\r\n\t\tIexecODBLibCore.Contribution memory contribution = m_contributions[_taskid][_worker];\r\n\t\treturn (\r\n\t\t\tcontribution.status,\r\n\t\t\tcontribution.resultHash,\r\n\t\t\tcontribution.resultSeal,\r\n\t\t\tcontribution.enclaveChallenge\r\n\t\t);\r\n\t}\r\n\r\n\tfunction viewCategoryABILegacy(uint256 _catid)\r\n\texternal view returns (string memory, string memory, uint256)\r\n\t{\r\n\t\tIexecODBLibCore.Category memory category = m_categories[_catid];\r\n\t\treturn ( category.name, category.description, category.workClockTimeRef );\r\n\t}\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"_identity\",\"type\":\"address\"},{\"name\":\"_hash\",\"type\":\"bytes32\"},{\"name\":\"_signature\",\"type\":\"bytes\"}],\"name\":\"verifySignature\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"app\",\"type\":\"address\"},{\"name\":\"dataset\",\"type\":\"address\"},{\"name\":\"workerpool\",\"type\":\"address\"}],\"name\":\"checkResources\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_taskid\",\"type\":\"bytes32\"},{\"name\":\"_worker\",\"type\":\"address\"}],\"name\":\"viewContributionABILegacy\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"},{\"name\":\"\",\"type\":\"bytes32\"},{\"name\":\"\",\"type\":\"bytes32\"},{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_taskid\",\"type\":\"bytes32\"}],\"name\":\"viewTaskABILegacy\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"},{\"name\":\"\",\"type\":\"bytes32\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"bytes32\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"address[]\"},{\"name\":\"\",\"type\":\"bytes\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"name\",\"type\":\"string\"},{\"name\":\"description\",\"type\":\"string\"},{\"name\":\"workClockTimeRef\",\"type\":\"uint256\"}],\"name\":\"createCategory\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_taskid\",\"type\":\"bytes32\"},{\"name\":\"_resultHash\",\"type\":\"bytes32\"},{\"name\":\"_resultSeal\",\"type\":\"bytes32\"},{\"name\":\"_enclaveChallenge\",\"type\":\"address\"},{\"name\":\"_enclaveSign\",\"type\":\"bytes\"},{\"name\":\"_workerpoolSign\",\"type\":\"bytes\"}],\"name\":\"contribute\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"appregistry\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CONSENSUS_DURATION_RATIO\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_iexecclerkAddress\",\"type\":\"address\"},{\"name\":\"_appregistryAddress\",\"type\":\"address\"},{\"name\":\"_datasetregistryAddress\",\"type\":\"address\"},{\"name\":\"_workerpoolregistryAddress\",\"type\":\"address\"}],\"name\":\"attachContracts\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_catid\",\"type\":\"uint256\"}],\"name\":\"viewCategory\",\"outputs\":[{\"components\":[{\"name\":\"name\",\"type\":\"string\"},{\"name\":\"description\",\"type\":\"string\"},{\"name\":\"workClockTimeRef\",\"type\":\"uint256\"}],\"name\":\"category\",\"type\":\"tuple\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_dealid\",\"type\":\"bytes32\"},{\"name\":\"idx\",\"type\":\"uint256\"}],\"name\":\"initialize\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"REVEAL_DEADLINE_RATIO\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CONTRIBUTION_DEADLINE_RATIO\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"workerpoolregistry\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"FINAL_DEADLINE_RATIO\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_taskid\",\"type\":\"bytes32\"}],\"name\":\"viewTask\",\"outputs\":[{\"components\":[{\"name\":\"status\",\"type\":\"uint8\"},{\"name\":\"dealid\",\"type\":\"bytes32\"},{\"name\":\"idx\",\"type\":\"uint256\"},{\"name\":\"timeref\",\"type\":\"uint256\"},{\"name\":\"contributionDeadline\",\"type\":\"uint256\"},{\"name\":\"revealDeadline\",\"type\":\"uint256\"},{\"name\":\"finalDeadline\",\"type\":\"uint256\"},{\"name\":\"consensusValue\",\"type\":\"bytes32\"},{\"name\":\"revealCounter\",\"type\":\"uint256\"},{\"name\":\"winnerCounter\",\"type\":\"uint256\"},{\"name\":\"contributors\",\"type\":\"address[]\"},{\"name\":\"resultDigest\",\"type\":\"bytes32\"},{\"name\":\"results\",\"type\":\"bytes\"}],\"name\":\"\",\"type\":\"tuple\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"iexecclerk\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"datasetregistry\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_dealid\",\"type\":\"bytes32[]\"},{\"name\":\"_idx\",\"type\":\"uint256[]\"}],\"name\":\"initializeArray\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_taskid\",\"type\":\"bytes32\"}],\"name\":\"claim\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_taskid\",\"type\":\"bytes32\"},{\"name\":\"_results\",\"type\":\"bytes\"}],\"name\":\"finalize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"countCategory\",\"outputs\":[{\"name\":\"count\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"id\",\"type\":\"bytes32\"}],\"name\":\"resultFor\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_worker\",\"type\":\"address\"}],\"name\":\"viewScore\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_taskid\",\"type\":\"bytes32\"},{\"name\":\"_worker\",\"type\":\"address\"}],\"name\":\"viewContribution\",\"outputs\":[{\"components\":[{\"name\":\"status\",\"type\":\"uint8\"},{\"name\":\"resultHash\",\"type\":\"bytes32\"},{\"name\":\"resultSeal\",\"type\":\"bytes32\"},{\"name\":\"enclaveChallenge\",\"type\":\"address\"}],\"name\":\"\",\"type\":\"tuple\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"REVEAL_DURATION_RATIO\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_taskid\",\"type\":\"bytes32\"}],\"name\":\"reopen\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_dealid\",\"type\":\"bytes32[]\"},{\"name\":\"_idx\",\"type\":\"uint256[]\"}],\"name\":\"initializeAndClaimArray\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_catid\",\"type\":\"uint256\"}],\"name\":\"viewCategoryABILegacy\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"},{\"name\":\"\",\"type\":\"string\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_taskid\",\"type\":\"bytes32[]\"}],\"name\":\"claimArray\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_taskid\",\"type\":\"bytes32\"},{\"name\":\"_resultDigest\",\"type\":\"bytes32\"}],\"name\":\"reveal\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"taskid\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"workerpool\",\"type\":\"address\"}],\"name\":\"TaskInitialize\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"taskid\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"worker\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"hash\",\"type\":\"bytes32\"}],\"name\":\"TaskContribute\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"taskid\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"consensus\",\"type\":\"bytes32\"}],\"name\":\"TaskConsensus\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"taskid\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"worker\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"digest\",\"type\":\"bytes32\"}],\"name\":\"TaskReveal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"taskid\",\"type\":\"bytes32\"}],\"name\":\"TaskReopen\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"taskid\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"results\",\"type\":\"bytes\"}],\"name\":\"TaskFinalize\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"taskid\",\"type\":\"bytes32\"}],\"name\":\"TaskClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"worker\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"taskid\",\"type\":\"bytes32\"}],\"name\":\"AccurateContribution\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"worker\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"taskid\",\"type\":\"bytes32\"}],\"name\":\"FaultyContribution\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"catid\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"name\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"description\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"workClockTimeRef\",\"type\":\"uint256\"}],\"name\":\"CreateCategory\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"IexecHub","CompilerVersion":"v0.5.8+commit.23d335f2","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://b24b453fcf049f5dadae933248d9a8ef20fc136f9e2776dfdc750ab69c3768fb"}]}