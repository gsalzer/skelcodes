{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.5.6;\r\n\r\n\r\n/**\r\n * @title Metapod (Version 1)\r\n * @author 0age\r\n * @notice This contract creates \"hardened\" metamorphic contracts, or contracts\r\n * that can be redeployed with new code to the same address, with additional\r\n * protections against creating non-metamorphic contracts or losing any balance\r\n * held by the contract when it is destroyed. It does so by first setting the\r\n * desired contract initialization code in temporary storage. Next, a vault\r\n * contract corresponding to the target address is checked for a balance, and if\r\n * one exists it will be sent to the address of an intermediate deployer, or a\r\n * transient contract with fixed, non-deterministic initialization code. Once\r\n * deployed via CREATE2, the transient contract retrieves the initialization\r\n * code from storage and uses it to deploy the contract via CREATE, forwarding\r\n * the entire balance to the new contract, and then SELFDESTRUCTs. Finally, the\r\n * contract prelude is checked to ensure that it is properly destructible and\r\n * that it designates the vault as the forwarding address. Once the contract\r\n * undergoes metamorphosis, all existing storage will be deleted and any balance\r\n * will be forwarded to the vault that can then resupply the metamorphic\r\n * contract upon redeployment.\r\n * @dev This contract has not yet been fully tested or audited - proceed with\r\n * abundant caution and please share any exploits or optimizations you discover.\r\n * Also, bear in mind that any initialization code provided to the contract must\r\n * contain the proper prelude, or initial sequence, with a length of 44 bytes:\r\n *\r\n *  `0x6e2b13cccec913420a21e4d11b2dcd3c3318602b5773 + vault_address + 0xff5b`\r\n *\r\n * For the required vault address, use `findVaultContractAddress(bytes32 salt)`.\r\n * Any initialization code generated by Solidity or another compiler will need\r\n * to have the stack items provided to JUMP, JUMPI, and CODECOPY altered\r\n * appropriately upon inserting this code, and may also need to alter some PC\r\n * operations (especially if it is not Solidity code). Be aware that contracts\r\n * are still accessible after they have been scheduled for deletion until the\r\n * transaction is completed, and that ether may still be sent to them - as the\r\n * funds forwarding step is performed immediately, not as part of the\r\n * transaction substate with the account removal. If those funds do not move to\r\n * a non-destructing account by the end of the transaction, they will be\r\n * irreversibly burned. Lastly, due to the mechanics of SELFDESTRUCT, a contract\r\n * cannot be destroyed and redeployed in a single transaction - to avoid\r\n * \"downtime\" of the contract, consider utilizing multiple contracts and having\r\n * the callers determine the current contract by using EXTCODEHASH.\r\n */\r\ncontract Metapod {\r\n  // fires when a metamorphic contract is deployed.\r\n  event Metamorphosed(address metamorphicContract, bytes32 salt);\r\n\r\n  // fires when a metamorphic contract is destroyed.\r\n  event Cocooned(address metamorphicContract, bytes32 salt);\r\n\r\n  // initialization code for transient contract to deploy metamorphic contracts.\r\n  /* ##  op  operation        [stack] <memory> {return_buffer} *contract_deploy*\r\n     00  58  PC               [0]\r\n     01  60  PUSH1 0x1c       [0, 28]\r\n     03  59  MSIZE            [0, 28, 0]\r\n     04  58  PC               [0, 28, 0, 4]\r\n     05  59  MSIZE            [0, 28, 0, 4, 0]\r\n     06  92  SWAP3            [0, 0, 0, 4, 28]\r\n     07  33  CALLER           [0, 0, 0, 4, 28, caller]\r\n     08  5a  GAS              [0, 0, 0, 4, 28, caller, gas]\r\n     09  63  PUSH4 0x57b9f523 [0, 0, 0, 4, 28, caller, gas, selector]\r\n     14  59  MSIZE            [0, 0, 0, 4, 28, caller, gas, selector, 0]\r\n     15  52  MSTORE           [0, 0, 0, 4, 28, caller, gas] <selector>\r\n     16  fa  STATICCALL       [0, 1 => success] {init_code}\r\n     17  50  POP              [0]\r\n     18  60  PUSH1 0x40       [0, 64]\r\n     20  30  ADDRESS          [0, 64, address]\r\n     21  31  BALANCE          [0, 64, balance]\r\n     22  81  DUP2             [0, 64, balance, 64]\r\n     23  3d  RETURNDATASIZE   [0, 64, balance, 64, size]\r\n     24  03  SUB              [0, 64, balance, size - 64]\r\n     25  83  DUP4             [0, 64, balance, size - 64, 0]\r\n     26  92  SWAP3            [0, 0, balance, size - 64, 64]\r\n     27  81  DUP2             [0, 0, balance, size - 64, 64, size - 64]\r\n     28  94  SWAP5            [size - 64, 0, balance, size - 64, 64, 0]\r\n     29  3e  RETURNDATACOPY   [size - 64, 0, balance] <init_code>\r\n     30  f0  CREATE           [contract_address or 0] *init_code*\r\n     31  80  DUP1             [contract_address or 0, contract_address or 0]\r\n     32  15  ISZERO           [contract_address or 0, 0 or 1]\r\n     33  60  PUSH1 0x25       [contract_address or 0, 0 or 1, 37]\r\n     35  57  JUMPI            [contract_address]\r\n     36  ff  SELFDESTRUCT     []\r\n     37  5b  JUMPDEST         [0]\r\n     38  80  DUP1             [0, 0]\r\n     39  fd  REVERT           []\r\n  */\r\n  bytes private constant TRANSIENT_CONTRACT_INITIALIZATION_CODE = (\r\n    hex\"58601c59585992335a6357b9f5235952fa5060403031813d03839281943ef08015602557ff5b80fd\"\r\n  );\r\n\r\n  // store the hash of the initialization code for transient contracts as well.\r\n  bytes32 private constant TRANSIENT_CONTRACT_INITIALIZATION_CODE_HASH = bytes32(\r\n    0xb7d11e258d6663925ce8e43f07ba3b7792a573ecc2fd7682d01f8a70b2223294\r\n  );\r\n\r\n  // the \"empty data hash\" is used to determine if the vault has been deployed.\r\n  bytes32 private constant EMPTY_DATA_HASH = bytes32(\r\n    0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470\r\n  );\r\n\r\n  // maintain a temporary storage slot for metamorphic initialization code.\r\n  bytes private _initCode;\r\n\r\n  constructor() public {\r\n    // ensure that the deployment address is correct.\r\n    // factory: 0x00000000e82eb0431756271F0d00CFB143685e7B\r\n    // caller: 0x0734d56DA60852A03e2Aafae8a36FFd8c12B32f1\r\n    // init code hash: 0x8954ff8965dbf871b7b4f49acc85a2a7c96c93ebc16ba59a4d07c52d8d0b6ec2\r\n    // salt: 0x0734d56da60852a03e2aafae8a36ffd8c12b32f1ee8671f229d5dd0853050000\r\n    require(\r\n      address(this) == address(0x00000000002B13cCcEC913420A21e4D11b2DCd3C),\r\n      \"Incorrect deployment address.\"\r\n    );\r\n\r\n    // ensure the transient initialization code hash constant value is correct.\r\n    require(\r\n      keccak256(\r\n        abi.encodePacked(TRANSIENT_CONTRACT_INITIALIZATION_CODE)\r\n      ) == TRANSIENT_CONTRACT_INITIALIZATION_CODE_HASH,\r\n      \"Incorrect hash for transient initialization code.\"\r\n    );\r\n\r\n    // ensure the empty data hash constant value is correct.\r\n    require(\r\n      keccak256(abi.encodePacked(hex\"\")) == EMPTY_DATA_HASH,\r\n      \"Incorrect hash for empty data.\"\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @dev Deploy a metamorphic contract by submitting a given salt or nonce\r\n   * along with the initialization code to a transient contract which will then\r\n   * deploy the metamorphic contract before immediately SELFDESTRUCTing. To\r\n   * replace the metamorphic contract, call destroy() with the same salt value,\r\n   * then call with the same salt value and new initialization code (be aware\r\n   * that all existing state will be wiped from the contract).\r\n   * @param identifier uint96 The last twelve bytes of the salt that will be\r\n   * passed into the CREATE2 call (with the first twenty bytes of the salt set\r\n   * to `msg.sender`) and thus will determine the resulant address of the\r\n   * metamorphic contract.\r\n   * @param initializationCode bytes The initialization code for the metamorphic\r\n   * contract that will be deployed by the transient contract.\r\n   * @return The address of the deployed metamorphic contract.\r\n   */\r\n  function deploy(\r\n    uint96 identifier,\r\n    bytes calldata initializationCode\r\n  ) external payable returns (address metamorphicContract) {\r\n    // compute the salt using the supplied identifier.\r\n    bytes32 salt = _getSalt(identifier);\r\n\r\n    // store the initialization code to be retrieved by the transient contract.\r\n    _initCode = initializationCode;\r\n\r\n    // get vault contract and provide any funds therein to transient contract.\r\n    address vaultContract = _triggerVaultFundsRelease(salt);\r\n\r\n    // declare variable to verify successful transient contract deployment.\r\n    address transientContract;\r\n\r\n    // move transient contract initialization code into memory.\r\n    bytes memory initCode = TRANSIENT_CONTRACT_INITIALIZATION_CODE;\r\n\r\n    // load transient contract init data and size, then deploy via CREATE2.\r\n    assembly { /* solhint-disable no-inline-assembly */\r\n      let encoded_data := add(0x20, initCode) // load initialization code.\r\n      let encoded_size := mload(initCode)     // load the init code's length.\r\n      transientContract := create2(           // call CREATE2 with 4 arguments.\r\n        callvalue,                            // forward any supplied endowment.\r\n        encoded_data,                         // pass in initialization code.\r\n        encoded_size,                         // pass in init code's length.\r\n        salt                                  // pass in the salt value.\r\n      )\r\n    } /* solhint-enable no-inline-assembly */\r\n\r\n    // ensure that the contracts were successfully deployed.\r\n    require(transientContract != address(0), \"Failed to deploy contract.\");\r\n\r\n    // get the address of the deployed metamorphic contract.\r\n    metamorphicContract = _getMetamorphicContractAddress(transientContract);\r\n\r\n    // ensure that the deployed runtime code has the required prelude.\r\n    _verifyPrelude(metamorphicContract, _getPrelude(vaultContract));\r\n\r\n    // clear the supplied initialization code from temporary storage.\r\n    delete _initCode;\r\n\r\n    // emit an event to signify that the contract was successfully deployed.\r\n    emit Metamorphosed(metamorphicContract, salt);\r\n  }\r\n\r\n  /**\r\n   * @dev Destroy a metamorphic contract by calling into it, which will trigger\r\n   * a SELFDESTRUCT and forward all funds to the designated vault contract. Be\r\n   * aware that all existing state will be wiped from the contract.\r\n   * @param identifier uint96 The last twelve bytes of the salt that was passed\r\n   * into the CREATE2 call (with the first twenty bytes of the salt set to\r\n   * `msg.sender`) that determined resulant address of the metamorphic contract.\r\n   */\r\n  function destroy(uint96 identifier) external {\r\n    // compute the salt using the supplied identifier.\r\n    bytes32 salt = _getSalt(identifier);\r\n\r\n    // determine the address of the metamorphic contract.\r\n    address metamorphicContract = _getMetamorphicContractAddress(\r\n      _getTransientContractAddress(salt)\r\n    );\r\n\r\n    // call it to trigger a SELFDESTRUCT that forwards any funds to the vault.\r\n    metamorphicContract.call(\"\"); /* solhint-disable-line avoid-low-level-calls */\r\n\r\n    // emit an event to signify that the contract was scheduled for deletion.\r\n    emit Cocooned(metamorphicContract, salt);\r\n  }\r\n\r\n  /**\r\n   * @dev Recover the funds from a metamorphic contract, the associated vault,\r\n   * and the associated transient contract by deploying a dedicated metamorphic\r\n   * contract that will forward funds to `msg.sender` and immediately\r\n   * SELFDESTRUCT. The contract must be \"cocooned\" or else it will fail.\r\n   * @param identifier uint96 The last twelve bytes of the salt that was passed\r\n   * into the CREATE2 call (with the first twenty bytes of the salt set to\r\n   * `msg.sender`) that determined resulant address of the metamorphic contract.\r\n   */\r\n  function recover(uint96 identifier) external {\r\n    // compute the salt using the supplied identifier.\r\n    bytes32 salt = _getSalt(identifier);\r\n\r\n    // trigger the vault contract to forward funds to the transient contract.\r\n    _triggerVaultFundsRelease(salt);\r\n\r\n    // construct recovery contract initialization code and set in temp storage.\r\n    _initCode = abi.encodePacked(\r\n      bytes2(0x5873),  // PC PUSH20\r\n      msg.sender,      // <the caller is the recipient of funds>\r\n      bytes13(0x905959593031856108fcf150ff)\r\n        // SWAP1 MSIZEx3 ADDRESS BALANCE DUP6 PUSH2 2300 CALL POP SELFDESTRUCT\r\n    );\r\n\r\n    // declare variable to verify successful transient contract deployment.\r\n    address transientContract;\r\n\r\n    // move transient contract initialization code into memory.\r\n    bytes memory initCode = TRANSIENT_CONTRACT_INITIALIZATION_CODE;\r\n\r\n    // load transient contract init data and size, then deploy via CREATE2.\r\n    assembly { /* solhint-disable no-inline-assembly */\r\n      let encoded_data := add(0x20, initCode) // load initialization code.\r\n      let encoded_size := mload(initCode)     // load the init code's length.\r\n      transientContract := create2(           // call CREATE2 with 4 arguments.\r\n        callvalue,                            // forward any supplied endowment.\r\n        encoded_data,                         // pass in initialization code.\r\n        encoded_size,                         // pass in init code's length.\r\n        salt                                  // pass in the salt value.\r\n      )\r\n    } /* solhint-enable no-inline-assembly */\r\n\r\n    // ensure that the recovery contract was successfully deployed.\r\n    require(\r\n      transientContract != address(0),\r\n      \"Recovery failed - ensure that the contract has been destroyed.\"\r\n    );\r\n\r\n    // clear recovery contract initialization code from temporary storage.\r\n    delete _initCode;\r\n  }\r\n\r\n  /**\r\n   * @dev View function for retrieving the initialization code for a given\r\n   * metamorphic contract to deploy via a transient contract. Called by the\r\n   * constructor of each transient contract - not meant to be called by users.\r\n   * @return The initialization code to use to deploy the metamorphic contract.\r\n   */\r\n  function getInitializationCode() external view returns (\r\n    bytes memory initializationCode\r\n  ) {\r\n    // return the current initialization code from temporary storage.\r\n    initializationCode = _initCode;\r\n  }\r\n\r\n  /**\r\n   * @dev Compute the address of the transient contract that will be created\r\n   * upon submitting a given salt to the contract.\r\n   * @param salt bytes32 The nonce passed into CREATE2 when deploying the\r\n   * transient contract, composed of caller ++ identifier.\r\n   * @return The address of the corresponding transient contract.\r\n   */\r\n  function findTransientContractAddress(\r\n    bytes32 salt\r\n  ) external pure returns (address transientContract) {\r\n    // determine the address where the transient contract will be deployed.\r\n    transientContract = _getTransientContractAddress(salt);\r\n  }\r\n\r\n  /**\r\n   * @dev Compute the address of the metamorphic contract that will be created\r\n   * upon submitting a given salt to the contract.\r\n   * @param salt bytes32 The nonce used to create the transient contract that\r\n   * deploys the metamorphic contract, composed of caller ++ identifier.\r\n   * @return The address of the corresponding metamorphic contract.\r\n   */\r\n  function findMetamorphicContractAddress(\r\n    bytes32 salt\r\n  ) external pure returns (address metamorphicContract) {\r\n    // determine the address of the metamorphic contract.\r\n    metamorphicContract = _getMetamorphicContractAddress(\r\n      _getTransientContractAddress(salt)\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @dev Compute the address of the vault contract that will be set as the\r\n   * recipient of funds from the metamorphic contract when it is destroyed.\r\n   * @param salt bytes32 The nonce used to create the transient contract that\r\n   * deploys the metamorphic contract, composed of caller ++ identifier.\r\n   * @return The address of the corresponding vault contract.\r\n   */\r\n  function findVaultContractAddress(\r\n    bytes32 salt\r\n  ) external pure returns (address vaultContract) {\r\n    vaultContract = _getVaultContractAddress(\r\n      _getVaultContractInitializationCode(\r\n        _getTransientContractAddress(salt)\r\n      )\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @dev View function for retrieving the prelude that will be required for any\r\n   * metamorphic contract deployed via a specific salt.\r\n   * @param salt bytes32 The nonce used to create the transient contract that\r\n   * deploys the metamorphic contract, composed of caller ++ identifier.\r\n   * @return The prelude that will be need to be present at the start of the\r\n   * deployed runtime code for any metamorphic contracts deployed using the\r\n   * provided salt.\r\n   */\r\n  function getPrelude(bytes32 salt) external pure returns (\r\n    bytes memory prelude\r\n  ) {\r\n    // compute and return the prelude.\r\n    prelude = _getPrelude(\r\n      _getVaultContractAddress(\r\n        _getVaultContractInitializationCode(\r\n          _getTransientContractAddress(salt)\r\n        )\r\n      )\r\n    );\r\n  }  \r\n\r\n  /**\r\n   * @dev View function for retrieving the initialization code of metamorphic\r\n   * contracts for purposes of verification.\r\n   * @return The initialization code used to deploy transient contracts.\r\n   */\r\n  function getTransientContractInitializationCode() external pure returns (\r\n    bytes memory transientContractInitializationCode\r\n  ) {\r\n    // return the initialization code used to deploy transient contracts.\r\n    transientContractInitializationCode = (\r\n      TRANSIENT_CONTRACT_INITIALIZATION_CODE\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @dev View function for retrieving the keccak256 hash of the initialization\r\n   * code of metamorphic contracts for purposes of verification.\r\n   * @return The keccak256 hash of the initialization code used to deploy\r\n   * transient contracts.\r\n   */\r\n  function getTransientContractInitializationCodeHash() external pure returns (\r\n    bytes32 transientContractInitializationCodeHash\r\n  ) {\r\n    // return hash of initialization code used to deploy transient contracts.\r\n    transientContractInitializationCodeHash = (\r\n      TRANSIENT_CONTRACT_INITIALIZATION_CODE_HASH\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @dev View function for calculating a salt given a particular caller and\r\n   * identifier.\r\n   * @param identifier bytes12 The last twelve bytes of the salt (the first\r\n   * twenty bytes are set to `msg.sender`).\r\n   * @return The salt that will be supplied to CREATE2 upon providing the given\r\n   * identifier from the calling account.\r\n   */\r\n  function getSalt(uint96 identifier) external view returns (bytes32 salt) {\r\n    salt = _getSalt(identifier);\r\n  }\r\n\r\n  /**\r\n   * @dev Internal view function for calculating a salt given a particular\r\n   * caller and identifier.\r\n   * @param identifier bytes12 The last twelve bytes of the salt (the first\r\n   * twenty bytes are set to `msg.sender`).\r\n   * @return The salt that will be supplied to CREATE2.\r\n   */\r\n  function _getSalt(uint96 identifier) internal view returns (bytes32 salt) {\r\n    assembly { /* solhint-disable no-inline-assembly */\r\n      salt := or(shl(96, caller), identifier) // caller: first 20, ID: last 12\r\n    } /* solhint-enable no-inline-assembly */\r\n  }\r\n\r\n  /**\r\n   * @dev Internal function for determining the required prelude for metamorphic\r\n   * contracts deployed through the factory based on the corresponding vault\r\n   * contract.\r\n   * @param vaultContract address The address of the vault contract.\r\n   * @return The prelude that will be required for given a vault contract.\r\n   */\r\n  function _getPrelude(\r\n    address vaultContract\r\n  ) internal pure returns (bytes memory prelude) {\r\n    prelude = abi.encodePacked(\r\n      // PUSH15 <this> CALLER XOR PUSH1 43 JUMPI PUSH20\r\n      bytes22(0x6e2b13cccec913420a21e4d11b2dcd3c3318602b5773),\r\n      vaultContract, // <vault is the approved SELFDESTRUCT recipient>\r\n      bytes2(0xff5b) // SELFDESTRUCT JUMPDEST\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @dev Internal function for determining if deployed metamorphic contract has\r\n   * the necessary prelude at the start of its runtime code. The prelude ensures\r\n   * that the contract can be destroyed by a call originating from this contract\r\n   * and that any funds will be forwarded to the corresponding vault contract.\r\n   * @param metamorphicContract address The address of the metamorphic contract.\r\n   * @param prelude bytes The prelude that must be present on the contract.\r\n   */\r\n  function _verifyPrelude(\r\n    address metamorphicContract,\r\n    bytes memory prelude\r\n  ) internal view {\r\n    // get the first 44 bytes of metamorphic contract runtime code.\r\n    bytes memory runtimeHeader;\r\n\r\n    assembly { /* solhint-disable no-inline-assembly */\r\n      // set and update the pointer based on the size of the runtime header.\r\n      runtimeHeader := mload(0x40)\r\n      mstore(0x40, add(runtimeHeader, 0x60))\r\n\r\n      // store the runtime header code and length in memory.\r\n      mstore(runtimeHeader, 44)\r\n      extcodecopy(metamorphicContract, add(runtimeHeader, 0x20), 0, 44)\r\n    } /* solhint-enable no-inline-assembly */\r\n\r\n    // ensure that the contract's runtime code has the correct prelude.\r\n    require(\r\n      keccak256(\r\n        abi.encodePacked(prelude)\r\n      ) == keccak256(\r\n        abi.encodePacked(runtimeHeader)\r\n      ),\r\n      \"Deployed runtime code does not have the required prelude.\"\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @dev Internal function for determining if a vault contract has a balance\r\n   * and tranferring the balance to the corresponding transient contract if so.\r\n   * This is achieved via deploying the vault contract if no contract exists yet\r\n   * or by calling the contract if it has already been deployed.\r\n   * @param salt bytes32 The nonce used to create the transient contract that\r\n   * deploys the metamorphic contract associated with a corresponding vault.\r\n   * @return The address of the vault contract.\r\n   */\r\n  function _triggerVaultFundsRelease(\r\n    bytes32 salt\r\n  ) internal returns (address vaultContract) {\r\n    // determine the address of the transient contract.\r\n    address transientContract = _getTransientContractAddress(salt);\r\n\r\n    // determine the initialization code of the vault contract.\r\n    bytes memory vaultContractInitCode = _getVaultContractInitializationCode(\r\n      transientContract\r\n    );\r\n\r\n    // determine the address of the vault contract.\r\n    vaultContract = _getVaultContractAddress(vaultContractInitCode);\r\n\r\n    // determine if the vault has a balance.\r\n    if (vaultContract.balance > 0) {\r\n      // determine if the vault has already been deployed.\r\n      bytes32 vaultContractCodeHash;\r\n\r\n      assembly { /* solhint-disable no-inline-assembly */\r\n        vaultContractCodeHash := extcodehash(vaultContract)\r\n      } /* solhint-enable no-inline-assembly */\r\n\r\n      // if it hasn't been deployed, deploy it to send funds to transient.\r\n      if (vaultContractCodeHash == EMPTY_DATA_HASH) {\r\n        assembly { /* solhint-disable no-inline-assembly */\r\n          let encoded_data := add(0x20, vaultContractInitCode) // init code.\r\n          let encoded_size := mload(vaultContractInitCode)     // init length.\r\n          let _ := create2(                   // call CREATE2.\r\n            0,                                // do not supply any endowment.\r\n            encoded_data,                     // pass in initialization code.\r\n            encoded_size,                     // pass in init code's length.\r\n            0                                 // pass in zero as the salt value.\r\n          )\r\n        } /* solhint-enable no-inline-assembly */\r\n      // otherwise, just call it which will also send funds to transient.\r\n      } else {\r\n        vaultContract.call(\"\"); /* solhint-disable-line avoid-low-level-calls */\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Internal view function for calculating a transient contract address\r\n   * given a particular salt.\r\n   * @param salt bytes32 The nonce used to create the transient contract.\r\n   * @return The address of the transient contract.\r\n   */\r\n  function _getTransientContractAddress(\r\n    bytes32 salt\r\n  ) internal pure returns (address transientContract) {\r\n    // determine the address of the transient contract.\r\n    transientContract = address(\r\n      uint160(                      // downcast to match the address type.\r\n        uint256(                    // convert to uint to truncate upper digits.\r\n          keccak256(                // compute the CREATE2 hash using 4 inputs.\r\n            abi.encodePacked(       // pack all inputs to the hash together.\r\n              hex\"ff\",              // start with 0xff to distinguish from RLP.\r\n              address(0x00000000002B13cCcEC913420A21e4D11b2DCd3C), // this.\r\n              salt,                 // pass in the supplied salt value.\r\n              TRANSIENT_CONTRACT_INITIALIZATION_CODE_HASH // the init code hash.\r\n            )\r\n          )\r\n        )\r\n      )\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @dev Internal view function for calculating a metamorphic contract address\r\n   * that has been deployed via a transient contract given the address of the\r\n   * transient contract.\r\n   * @param transientContract address The address of the transient contract.\r\n   * @return The address of the metamorphic contract.\r\n   */\r\n  function _getMetamorphicContractAddress(\r\n    address transientContract\r\n  ) internal pure returns (address metamorphicContract) {\r\n    // determine the address of the metamorphic contract.\r\n    metamorphicContract = address(\r\n      uint160(                          // downcast to match the address type.\r\n        uint256(                        // set to uint to truncate upper digits.\r\n          keccak256(                    // compute CREATE hash via RLP encoding.\r\n            abi.encodePacked(           // pack all inputs to the hash together.\r\n              bytes2(0xd694),           // first two RLP bytes.\r\n              transientContract,        // called by the transient contract.\r\n              byte(0x01)                // nonce begins at 1 for contracts.\r\n            )\r\n          )\r\n        )\r\n      )\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @dev Internal view function for calculating a initialization code for a\r\n   * given vault contract based on the corresponding transient contract.\r\n   * @param transientContract address The address of the transient contract.\r\n   * @return The initialization code for the vault contract.\r\n   */\r\n  function _getVaultContractInitializationCode(\r\n    address transientContract\r\n  ) internal pure returns (bytes memory vaultContractInitializationCode) {\r\n    vaultContractInitializationCode = abi.encodePacked(\r\n      // PC PUSH15 <this> CALLER XOR PC JUMPI MSIZEx3 ADDRESS BALANCE PUSH20\r\n      bytes27(0x586e2b13cccec913420a21e4d11b2dcd3c33185857595959303173),\r\n      // the transient contract is the recipient of funds\r\n      transientContract,\r\n      // GAS CALL PUSH1 49 MSIZE DUP2 MSIZEx2 CODECOPY RETURN\r\n      bytes10(0x5af160315981595939f3)\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @dev Internal view function for calculating a vault contract address given\r\n   * the initialization code for the vault contract.\r\n   * @param vaultContractInitializationCode bytes The initialization code of the\r\n   * vault contract.\r\n   * @return The address of the vault contract.\r\n   */\r\n  function _getVaultContractAddress(\r\n    bytes memory vaultContractInitializationCode\r\n  ) internal pure returns (address vaultContract) {\r\n    // determine the address of the vault contract.\r\n    vaultContract = address(\r\n      uint160(                      // downcast to match the address type.\r\n        uint256(                    // convert to uint to truncate upper digits.\r\n          keccak256(                // compute the CREATE2 hash using 4 inputs.\r\n            abi.encodePacked(       // pack all inputs to the hash together.\r\n              byte(0xff),           // start with 0xff to distinguish from RLP.\r\n              address(0x00000000002B13cCcEC913420A21e4D11b2DCd3C), // this.\r\n              bytes32(0),           // leave the salt value set to zero.\r\n              keccak256(            // hash the supplied initialization code.\r\n                vaultContractInitializationCode\r\n              )\r\n            )\r\n          )\r\n        )\r\n      )\r\n    );\r\n  }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"getTransientContractInitializationCodeHash\",\"outputs\":[{\"name\":\"transientContractInitializationCodeHash\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTransientContractInitializationCode\",\"outputs\":[{\"name\":\"transientContractInitializationCode\",\"type\":\"bytes\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"identifier\",\"type\":\"uint96\"}],\"name\":\"getSalt\",\"outputs\":[{\"name\":\"salt\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"identifier\",\"type\":\"uint96\"}],\"name\":\"recover\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"identifier\",\"type\":\"uint96\"},{\"name\":\"initializationCode\",\"type\":\"bytes\"}],\"name\":\"deploy\",\"outputs\":[{\"name\":\"metamorphicContract\",\"type\":\"address\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"salt\",\"type\":\"bytes32\"}],\"name\":\"findVaultContractAddress\",\"outputs\":[{\"name\":\"vaultContract\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getInitializationCode\",\"outputs\":[{\"name\":\"initializationCode\",\"type\":\"bytes\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"salt\",\"type\":\"bytes32\"}],\"name\":\"findTransientContractAddress\",\"outputs\":[{\"name\":\"transientContract\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"salt\",\"type\":\"bytes32\"}],\"name\":\"findMetamorphicContractAddress\",\"outputs\":[{\"name\":\"metamorphicContract\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"identifier\",\"type\":\"uint96\"}],\"name\":\"destroy\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"salt\",\"type\":\"bytes32\"}],\"name\":\"getPrelude\",\"outputs\":[{\"name\":\"prelude\",\"type\":\"bytes\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"metamorphicContract\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"salt\",\"type\":\"bytes32\"}],\"name\":\"Metamorphosed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"metamorphicContract\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"salt\",\"type\":\"bytes32\"}],\"name\":\"Cocooned\",\"type\":\"event\"}]","ContractName":"Metapod","CompilerVersion":"v0.5.6+commit.b259423e","OptimizationUsed":"1","Runs":"999","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://6411f371afb1521ed97b533674cf320a713eaf657fa9416375ed4d1317700f69"}]}