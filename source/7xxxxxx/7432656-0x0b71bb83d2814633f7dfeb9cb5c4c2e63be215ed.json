{"status":"1","message":"OK","result":[{"SourceCode":"// File: ../../mosaic-contracts/contracts/lib/RLP.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n* @title RLPReader\r\n*\r\n* RLPReader is used to read and parse RLP encoded data in memory.\r\n*\r\n* @author Andreas Olofsson (androlo1980@gmail.com)\r\n*/\r\nlibrary RLP {\r\n\r\n    /** Constants */\r\n    uint constant DATA_SHORT_START = 0x80;\r\n    uint constant DATA_LONG_START = 0xB8;\r\n    uint constant LIST_SHORT_START = 0xC0;\r\n    uint constant LIST_LONG_START = 0xF8;\r\n\r\n    uint constant DATA_LONG_OFFSET = 0xB7;\r\n    uint constant LIST_LONG_OFFSET = 0xF7;\r\n\r\n    /** Storage */\r\n    struct RLPItem {\r\n        uint _unsafe_memPtr;    // Pointer to the RLP-encoded bytes.\r\n        uint _unsafe_length;    // Number of bytes. This is the full length of the string.\r\n    }\r\n\r\n    struct Iterator {\r\n        RLPItem _unsafe_item;   // Item that's being iterated over.\r\n        uint _unsafe_nextPtr;   // Position of the next item in the list.\r\n    }\r\n\r\n    /* Internal Functions */\r\n\r\n    /** Iterator */\r\n\r\n    function next(\r\n        Iterator memory self\r\n    )\r\n        internal\r\n        pure\r\n        returns (RLPItem memory subItem_)\r\n    {\r\n        require(hasNext(self));\r\n        uint ptr = self._unsafe_nextPtr;\r\n        uint itemLength = _itemLength(ptr);\r\n        subItem_._unsafe_memPtr = ptr;\r\n        subItem_._unsafe_length = itemLength;\r\n        self._unsafe_nextPtr = ptr + itemLength;\r\n    }\r\n\r\n    function next(\r\n        Iterator memory self,\r\n        bool strict\r\n    )\r\n        internal\r\n        pure\r\n        returns (RLPItem memory subItem_)\r\n    {\r\n        subItem_ = next(self);\r\n        require(!(strict && !_validate(subItem_)));\r\n    }\r\n\r\n    function hasNext(Iterator memory self) internal pure returns (bool) {\r\n        RLPItem memory item = self._unsafe_item;\r\n        return self._unsafe_nextPtr < item._unsafe_memPtr + item._unsafe_length;\r\n    }\r\n\r\n    /** RLPItem */\r\n\r\n    /**\r\n    *  @dev Creates an RLPItem from an array of RLP encoded bytes.\r\n    *\r\n    *  @param self The RLP encoded bytes.\r\n    *\r\n    *  @return An RLPItem.\r\n    */\r\n    function toRLPItem(\r\n        bytes memory self\r\n    )\r\n        internal\r\n        pure\r\n        returns (RLPItem memory)\r\n    {\r\n        uint len = self.length;\r\n        if (len == 0) {\r\n            return RLPItem(0, 0);\r\n        }\r\n        uint memPtr;\r\n\r\n        /* solium-disable-next-line */\r\n        assembly {\r\n            memPtr := add(self, 0x20)\r\n        }\r\n\r\n        return RLPItem(memPtr, len);\r\n    }\r\n\r\n    /**\r\n    *  @dev Creates an RLPItem from an array of RLP encoded bytes.\r\n    *\r\n    *  @param self The RLP encoded bytes.\r\n    *  @param strict Will throw if the data is not RLP encoded.\r\n    *\r\n    *  @return An RLPItem.\r\n    */\r\n    function toRLPItem(\r\n        bytes memory self,\r\n        bool strict\r\n    )\r\n        internal\r\n        pure\r\n        returns (RLPItem memory)\r\n    {\r\n        RLPItem memory item = toRLPItem(self);\r\n        if(strict) {\r\n            uint len = self.length;\r\n            require(_payloadOffset(item) <= len);\r\n            require(_itemLength(item._unsafe_memPtr) == len);\r\n            require(_validate(item));\r\n        }\r\n        return item;\r\n    }\r\n\r\n    /**\r\n    *  @dev Check if the RLP item is null.\r\n    *\r\n    *  @param self The RLP item.\r\n    *\r\n    *  @return 'true' if the item is null.\r\n    */\r\n    function isNull(RLPItem memory self) internal pure returns (bool ret) {\r\n        return self._unsafe_length == 0;\r\n    }\r\n\r\n    /**\r\n    *  @dev Check if the RLP item is a list.\r\n    *\r\n    *  @param self The RLP item.\r\n    *\r\n    *  @return 'true' if the item is a list.\r\n    */\r\n    function isList(RLPItem memory self) internal pure returns (bool ret) {\r\n        if (self._unsafe_length == 0) {\r\n            return false;\r\n        }\r\n        uint memPtr = self._unsafe_memPtr;\r\n\r\n        /* solium-disable-next-line */\r\n        assembly {\r\n            ret := iszero(lt(byte(0, mload(memPtr)), 0xC0))\r\n        }\r\n    }\r\n\r\n    /**\r\n    *  @dev Check if the RLP item is data.\r\n    *\r\n    *  @param self The RLP item.\r\n    *\r\n    *  @return 'true' if the item is data.\r\n    */\r\n    function isData(RLPItem memory self) internal pure returns (bool ret) {\r\n        if (self._unsafe_length == 0) {\r\n            return false;\r\n        }\r\n        uint memPtr = self._unsafe_memPtr;\r\n\r\n        /* solium-disable-next-line */\r\n        assembly {\r\n            ret := lt(byte(0, mload(memPtr)), 0xC0)\r\n        }\r\n    }\r\n\r\n    /**\r\n    *  @dev Check if the RLP item is empty (string or list).\r\n    *\r\n    *  @param self The RLP item.\r\n    *\r\n    *  @return 'true' if the item is null.\r\n    */\r\n    function isEmpty(RLPItem memory self) internal pure returns (bool ret) {\r\n        if(isNull(self)) {\r\n            return false;\r\n        }\r\n        uint b0;\r\n        uint memPtr = self._unsafe_memPtr;\r\n\r\n        /* solium-disable-next-line */\r\n        assembly {\r\n            b0 := byte(0, mload(memPtr))\r\n        }\r\n        return (b0 == DATA_SHORT_START || b0 == LIST_SHORT_START);\r\n    }\r\n\r\n    /**\r\n    *  @dev Get the number of items in an RLP encoded list.\r\n    *\r\n    *  @param self The RLP item.\r\n    *\r\n    *  @return The number of items.\r\n    */\r\n    function items(RLPItem memory self) internal pure returns (uint) {\r\n        if (!isList(self)) {\r\n            return 0;\r\n        }\r\n        uint b0;\r\n        uint memPtr = self._unsafe_memPtr;\r\n\r\n        /* solium-disable-next-line */\r\n        assembly {\r\n            b0 := byte(0, mload(memPtr))\r\n        }\r\n        uint pos = memPtr + _payloadOffset(self);\r\n        uint last = memPtr + self._unsafe_length - 1;\r\n        uint itms;\r\n        while(pos <= last) {\r\n            pos += _itemLength(pos);\r\n            itms++;\r\n        }\r\n        return itms;\r\n    }\r\n\r\n    /**\r\n    *  @dev Create an iterator.\r\n    *\r\n    *  @param self The RLP item.\r\n    *\r\n    *  @return An 'Iterator' over the item.\r\n    */\r\n    function iterator(\r\n        RLPItem memory self\r\n    )\r\n        internal\r\n        pure\r\n        returns (Iterator memory it_)\r\n    {\r\n        require (isList(self));\r\n        uint ptr = self._unsafe_memPtr + _payloadOffset(self);\r\n        it_._unsafe_item = self;\r\n        it_._unsafe_nextPtr = ptr;\r\n    }\r\n\r\n    /**\r\n    *  @dev Return the RLP encoded bytes.\r\n    *\r\n    *  @param self The RLPItem.\r\n    *\r\n    *  @return The bytes.\r\n    */\r\n    function toBytes(\r\n        RLPItem memory self\r\n    )\r\n        internal\r\n        pure\r\n        returns (bytes memory bts_)\r\n    {\r\n        uint len = self._unsafe_length;\r\n        if (len == 0) {\r\n            return bts_;\r\n        }\r\n        bts_ = new bytes(len);\r\n        _copyToBytes(self._unsafe_memPtr, bts_, len);\r\n    }\r\n\r\n    /**\r\n    *  @dev Decode an RLPItem into bytes. This will not work if the RLPItem is a list.\r\n    *\r\n    *  @param self The RLPItem.\r\n    *\r\n    *  @return The decoded string.\r\n    */\r\n    function toData(\r\n        RLPItem memory self\r\n    )\r\n        internal\r\n        pure\r\n        returns (bytes memory bts_)\r\n    {\r\n        require(isData(self));\r\n        uint rStartPos;\r\n        uint len;\r\n        (rStartPos, len) = _decode(self);\r\n        bts_ = new bytes(len);\r\n        _copyToBytes(rStartPos, bts_, len);\r\n    }\r\n\r\n    /**\r\n    *  @dev Get the list of sub-items from an RLP encoded list.\r\n    *       Warning: This is inefficient, as it requires that the list is read twice.\r\n    *\r\n    *  @param self The RLP item.\r\n    *\r\n    *  @return Array of RLPItems.\r\n    */\r\n    function toList(\r\n        RLPItem memory self\r\n    )\r\n        internal\r\n        pure\r\n        returns (RLPItem[] memory list_)\r\n    {\r\n        require(isList(self));\r\n        uint numItems = items(self);\r\n        list_ = new RLPItem[](numItems);\r\n        Iterator memory it = iterator(self);\r\n        uint idx = 0;\r\n        while(hasNext(it)) {\r\n            list_[idx] = next(it);\r\n            idx++;\r\n        }\r\n    }\r\n\r\n    /**\r\n    *  @dev Decode an RLPItem into an ascii string. This will not work if the\r\n    *       RLPItem is a list.\r\n    *\r\n    *  @param self The RLPItem.\r\n    *\r\n    *  @return The decoded string.\r\n    */\r\n    function toAscii(\r\n        RLPItem memory self\r\n    )\r\n        internal\r\n        pure\r\n        returns (string memory str_)\r\n    {\r\n        require(isData(self));\r\n        uint rStartPos;\r\n        uint len;\r\n        (rStartPos, len) = _decode(self);\r\n        bytes memory bts = new bytes(len);\r\n        _copyToBytes(rStartPos, bts, len);\r\n        str_ = string(bts);\r\n    }\r\n\r\n    /**\r\n    *  @dev Decode an RLPItem into a uint. This will not work if the\r\n    *  RLPItem is a list.\r\n    *\r\n    *  @param self The RLPItem.\r\n    *\r\n    *  @return The decoded string.\r\n    */\r\n    function toUint(RLPItem memory self) internal pure returns (uint data_) {\r\n        require(isData(self));\r\n        uint rStartPos;\r\n        uint len;\r\n        (rStartPos, len) = _decode(self);\r\n        if (len > 32 || len == 0) {\r\n            revert();\r\n        }\r\n\r\n        /* solium-disable-next-line */\r\n        assembly {\r\n            data_ := div(mload(rStartPos), exp(256, sub(32, len)))\r\n        }\r\n    }\r\n\r\n    /**\r\n    *  @dev Decode an RLPItem into a boolean. This will not work if the\r\n    *       RLPItem is a list.\r\n    *\r\n    *  @param self The RLPItem.\r\n    *\r\n    *  @return The decoded string.\r\n    */\r\n    function toBool(RLPItem memory self) internal pure returns (bool data) {\r\n        require(isData(self));\r\n        uint rStartPos;\r\n        uint len;\r\n        (rStartPos, len) = _decode(self);\r\n        require(len == 1);\r\n        uint temp;\r\n\r\n        /* solium-disable-next-line */\r\n        assembly {\r\n            temp := byte(0, mload(rStartPos))\r\n        }\r\n        require (temp <= 1);\r\n\r\n        return temp == 1 ? true : false;\r\n    }\r\n\r\n    /**\r\n    *  @dev Decode an RLPItem into a byte. This will not work if the\r\n    *       RLPItem is a list.\r\n    *\r\n    *  @param self The RLPItem.\r\n    *\r\n    *  @return The decoded string.\r\n    */\r\n    function toByte(RLPItem memory self) internal pure returns (byte data) {\r\n        require(isData(self));\r\n        uint rStartPos;\r\n        uint len;\r\n        (rStartPos, len) = _decode(self);\r\n        require(len == 1);\r\n        uint temp;\r\n\r\n        /* solium-disable-next-line */\r\n        assembly {\r\n            temp := byte(0, mload(rStartPos))\r\n        }\r\n\r\n        return byte(uint8(temp));\r\n    }\r\n\r\n    /**\r\n    *  @dev Decode an RLPItem into an int. This will not work if the\r\n    *       RLPItem is a list.\r\n    *\r\n    *  @param self The RLPItem.\r\n    *\r\n    *  @return The decoded string.\r\n    */\r\n    function toInt(RLPItem memory self) internal pure returns (int data) {\r\n        return int(toUint(self));\r\n    }\r\n\r\n    /**\r\n    *  @dev Decode an RLPItem into a bytes32. This will not work if the\r\n    *       RLPItem is a list.\r\n    *\r\n    *  @param self The RLPItem.\r\n    *\r\n    *  @return The decoded string.\r\n    */\r\n    function toBytes32(\r\n        RLPItem memory self\r\n    )\r\n        internal\r\n        pure\r\n        returns (bytes32 data)\r\n    {\r\n        return bytes32(toUint(self));\r\n    }\r\n\r\n    /**\r\n    *  @dev Decode an RLPItem into an address. This will not work if the\r\n    *       RLPItem is a list.\r\n    *\r\n    *  @param self The RLPItem.\r\n    *\r\n    *  @return The decoded string.\r\n    */\r\n    function toAddress(\r\n        RLPItem memory self\r\n    )\r\n        internal\r\n        pure\r\n        returns (address data)\r\n    {\r\n        require(isData(self));\r\n        uint rStartPos;\r\n        uint len;\r\n        (rStartPos, len) = _decode(self);\r\n        require (len == 20);\r\n\r\n        /* solium-disable-next-line */\r\n        assembly {\r\n            data := div(mload(rStartPos), exp(256, 12))\r\n        }\r\n    }\r\n\r\n    /**\r\n    *  @dev Decode an RLPItem into an address. This will not work if the\r\n    *       RLPItem is a list.\r\n    *\r\n    *  @param self The RLPItem.\r\n    *\r\n    *  @return Get the payload offset.\r\n    */\r\n    function _payloadOffset(RLPItem memory self) private pure returns (uint) {\r\n        if(self._unsafe_length == 0)\r\n            return 0;\r\n        uint b0;\r\n        uint memPtr = self._unsafe_memPtr;\r\n\r\n        /* solium-disable-next-line */\r\n        assembly {\r\n            b0 := byte(0, mload(memPtr))\r\n        }\r\n        if(b0 < DATA_SHORT_START)\r\n            return 0;\r\n        if(b0 < DATA_LONG_START || (b0 >= LIST_SHORT_START && b0 < LIST_LONG_START))\r\n            return 1;\r\n        if(b0 < LIST_SHORT_START)\r\n            return b0 - DATA_LONG_OFFSET + 1;\r\n        return b0 - LIST_LONG_OFFSET + 1;\r\n    }\r\n\r\n    /**\r\n    *  @dev Decode an RLPItem into an address. This will not work if the\r\n    *       RLPItem is a list.\r\n    *\r\n    *  @param memPtr Memory pointer.\r\n    *\r\n    *  @return Get the full length of an RLP item.\r\n    */\r\n    function _itemLength(uint memPtr) private pure returns (uint len) {\r\n        uint b0;\r\n\r\n        /* solium-disable-next-line */\r\n        assembly {\r\n            b0 := byte(0, mload(memPtr))\r\n        }\r\n        if (b0 < DATA_SHORT_START) {\r\n            len = 1;\r\n        } else if (b0 < DATA_LONG_START) {\r\n            len = b0 - DATA_SHORT_START + 1;\r\n        } else if (b0 < LIST_SHORT_START) {\r\n            /* solium-disable-next-line */\r\n            assembly {\r\n                let bLen := sub(b0, 0xB7) // bytes length (DATA_LONG_OFFSET)\r\n                let dLen := div(mload(add(memPtr, 1)), exp(256, sub(32, bLen))) // data length\r\n                len := add(1, add(bLen, dLen)) // total length\r\n            }\r\n        } else if (b0 < LIST_LONG_START) {\r\n            len = b0 - LIST_SHORT_START + 1;\r\n        } else {\r\n            /* solium-disable-next-line */\r\n            assembly {\r\n                let bLen := sub(b0, 0xF7) // bytes length (LIST_LONG_OFFSET)\r\n                let dLen := div(mload(add(memPtr, 1)), exp(256, sub(32, bLen))) // data length\r\n                len := add(1, add(bLen, dLen)) // total length\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n    *  @dev Decode an RLPItem into an address. This will not work if the\r\n    *       RLPItem is a list.\r\n    *\r\n    *  @param self The RLPItem.\r\n    *\r\n    *  @return Get the full length of an RLP item.\r\n    */\r\n    function _decode(\r\n        RLPItem memory self\r\n    )\r\n        private\r\n        pure\r\n        returns (uint memPtr_, uint len_)\r\n    {\r\n        require(isData(self));\r\n        uint b0;\r\n        uint start = self._unsafe_memPtr;\r\n\r\n        /* solium-disable-next-line */\r\n        assembly {\r\n            b0 := byte(0, mload(start))\r\n        }\r\n        if (b0 < DATA_SHORT_START) {\r\n            memPtr_ = start;\r\n            len_ = 1;\r\n\r\n            return (memPtr_, len_);\r\n        }\r\n        if (b0 < DATA_LONG_START) {\r\n            len_ = self._unsafe_length - 1;\r\n            memPtr_ = start + 1;\r\n        } else {\r\n            uint bLen;\r\n\r\n            /* solium-disable-next-line */\r\n            assembly {\r\n                bLen := sub(b0, 0xB7) // DATA_LONG_OFFSET\r\n            }\r\n            len_ = self._unsafe_length - 1 - bLen;\r\n            memPtr_ = start + bLen + 1;\r\n        }\r\n    }\r\n\r\n    /**\r\n    *  @dev Assumes that enough memory has been allocated to store in target.\r\n    *       Gets the full length of an RLP item.\r\n    *\r\n    *  @param btsPtr Bytes pointer.\r\n    *  @param tgt Last item to be allocated.\r\n    *  @param btsLen Bytes length.\r\n    */\r\n    function _copyToBytes(\r\n        uint btsPtr,\r\n        bytes memory tgt,\r\n        uint btsLen\r\n    )\r\n        private\r\n        pure\r\n    {\r\n        // Exploiting the fact that 'tgt' was the last thing to be allocated,\r\n        // we can write entire words, and just overwrite any excess.\r\n        /* solium-disable-next-line */\r\n        assembly {\r\n                let i := 0 // Start at arr + 0x20\r\n                let stopOffset := add(btsLen, 31)\r\n                let rOffset := btsPtr\r\n                let wOffset := add(tgt, 32)\r\n                for {} lt(i, stopOffset) { i := add(i, 32) }\r\n                {\r\n                    mstore(add(wOffset, i), mload(add(rOffset, i)))\r\n                }\r\n        }\r\n    }\r\n\r\n    /**\r\n    *  @dev Check that an RLP item is valid.\r\n    *\r\n    *  @param self The RLPItem.\r\n    */\r\n    function _validate(RLPItem memory self) private pure returns (bool ret) {\r\n        // Check that RLP is well-formed.\r\n        uint b0;\r\n        uint b1;\r\n        uint memPtr = self._unsafe_memPtr;\r\n\r\n        /* solium-disable-next-line */\r\n        assembly {\r\n            b0 := byte(0, mload(memPtr))\r\n            b1 := byte(1, mload(memPtr))\r\n        }\r\n        if(b0 == DATA_SHORT_START + 1 && b1 < DATA_SHORT_START)\r\n            return false;\r\n        return true;\r\n    }\r\n}\r\n\r\n// File: ../../mosaic-contracts/contracts/lib/MerklePatriciaProof.sol\r\n\r\npragma solidity ^0.5.0;\r\n/**\r\n * @title MerklePatriciaVerifier\r\n * @author Sam Mayo (sammayo888@gmail.com)\r\n *\r\n * @dev Library for verifing merkle patricia proofs.\r\n */\r\n\r\n\r\nlibrary MerklePatriciaProof {\r\n    /**\r\n     * @dev Verifies a merkle patricia proof.\r\n     * @param value The terminating value in the trie.\r\n     * @param encodedPath The path in the trie leading to value.\r\n     * @param rlpParentNodes The rlp encoded stack of nodes.\r\n     * @param root The root hash of the trie.\r\n     * @return The boolean validity of the proof.\r\n     */\r\n    function verify(\r\n        bytes32 value,\r\n        bytes calldata encodedPath,\r\n        bytes calldata rlpParentNodes,\r\n        bytes32 root\r\n    )\r\n        external\r\n        pure\r\n        returns (bool)\r\n    {\r\n        RLP.RLPItem memory item = RLP.toRLPItem(rlpParentNodes);\r\n        RLP.RLPItem[] memory parentNodes = RLP.toList(item);\r\n\r\n        bytes memory currentNode;\r\n        RLP.RLPItem[] memory currentNodeList;\r\n\r\n        bytes32 nodeKey = root;\r\n        uint pathPtr = 0;\r\n\r\n        bytes memory path = _getNibbleArray2(encodedPath);\r\n        if(path.length == 0) {return false;}\r\n\r\n        for (uint i=0; i<parentNodes.length; i++) {\r\n            if(pathPtr > path.length) {return false;}\r\n\r\n            currentNode = RLP.toBytes(parentNodes[i]);\r\n            if(nodeKey != keccak256(abi.encodePacked(currentNode))) {return false;}\r\n            currentNodeList = RLP.toList(parentNodes[i]);\r\n\r\n            if(currentNodeList.length == 17) {\r\n                if(pathPtr == path.length) {\r\n                    if(keccak256(abi.encodePacked(RLP.toBytes(currentNodeList[16]))) == value) {\r\n                        return true;\r\n                    } else {\r\n                        return false;\r\n                    }\r\n                }\r\n\r\n                uint8 nextPathNibble = uint8(path[pathPtr]);\r\n                if(nextPathNibble > 16) {return false;}\r\n                nodeKey = RLP.toBytes32(currentNodeList[nextPathNibble]);\r\n                pathPtr += 1;\r\n            } else if(currentNodeList.length == 2) {\r\n\r\n                // Count of matching node key nibbles in path starting from pathPtr.\r\n                uint traverseLength = _nibblesToTraverse(RLP.toData(currentNodeList[0]), path, pathPtr);\r\n\r\n                if(pathPtr + traverseLength == path.length) { //leaf node\r\n                    if(keccak256(abi.encodePacked(RLP.toData(currentNodeList[1]))) == value) {\r\n                        return true;\r\n                    } else {\r\n                        return false;\r\n                    }\r\n                } else if (traverseLength == 0) { // error: couldn't traverse path\r\n                    return false;\r\n                } else { // extension node\r\n                    pathPtr += traverseLength;\r\n                    nodeKey = RLP.toBytes32(currentNodeList[1]);\r\n                }\r\n\r\n            } else {\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n\r\n    function verifyDebug(\r\n        bytes32 value,\r\n        bytes memory not_encodedPath,\r\n        bytes memory rlpParentNodes,\r\n        bytes32 root\r\n    )\r\n        public\r\n        pure\r\n        returns (bool res_, uint loc_, bytes memory path_debug_)\r\n    {\r\n        RLP.RLPItem memory item = RLP.toRLPItem(rlpParentNodes);\r\n        RLP.RLPItem[] memory parentNodes = RLP.toList(item);\r\n\r\n        bytes memory currentNode;\r\n        RLP.RLPItem[] memory currentNodeList;\r\n\r\n        bytes32 nodeKey = root;\r\n        uint pathPtr = 0;\r\n\r\n        bytes memory path = _getNibbleArray2(not_encodedPath);\r\n        path_debug_ = path;\r\n        if(path.length == 0) {\r\n            loc_ = 0;\r\n            res_ = false;\r\n            return (res_, loc_, path_debug_);\r\n        }\r\n\r\n        for (uint i=0; i<parentNodes.length; i++) {\r\n            if(pathPtr > path.length) {\r\n                loc_ = 1;\r\n                res_ = false;\r\n                return (res_, loc_, path_debug_);\r\n            }\r\n\r\n            currentNode = RLP.toBytes(parentNodes[i]);\r\n            if(nodeKey != keccak256(abi.encodePacked(currentNode))) {\r\n                res_ = false;\r\n                loc_ = 100 + i;\r\n                return (res_, loc_, path_debug_);\r\n            }\r\n            currentNodeList = RLP.toList(parentNodes[i]);\r\n\r\n            loc_ = currentNodeList.length;\r\n\r\n            if(currentNodeList.length == 17) {\r\n                if(pathPtr == path.length) {\r\n                    if(keccak256(abi.encodePacked(RLP.toBytes(currentNodeList[16]))) == value) {\r\n                        res_ = true;\r\n                        return (res_, loc_, path_debug_);\r\n                    } else {\r\n                        loc_ = 3;\r\n                        return (res_, loc_, path_debug_);\r\n                    }\r\n                }\r\n\r\n                uint8 nextPathNibble = uint8(path[pathPtr]);\r\n                if(nextPathNibble > 16) {\r\n                    loc_ = 4;\r\n                    return (res_, loc_, path_debug_);\r\n                }\r\n                nodeKey = RLP.toBytes32(currentNodeList[nextPathNibble]);\r\n                pathPtr += 1;\r\n            } else if(currentNodeList.length == 2) {\r\n                pathPtr += _nibblesToTraverse(RLP.toData(currentNodeList[0]), path, pathPtr);\r\n\r\n                if(pathPtr == path.length) {//leaf node\r\n                    if(keccak256(abi.encodePacked(RLP.toData(currentNodeList[1]))) == value) {\r\n                        res_ = true;\r\n                        return (res_, loc_, path_debug_);\r\n                    } else {\r\n                        loc_ = 5;\r\n                        return (res_, loc_, path_debug_);\r\n                    }\r\n                }\r\n                //extension node\r\n                if(_nibblesToTraverse(RLP.toData(currentNodeList[0]), path, pathPtr) == 0) {\r\n                    loc_ = 6;\r\n                    res_ = (keccak256(abi.encodePacked()) == value);\r\n                    return (res_, loc_, path_debug_);\r\n                }\r\n\r\n                nodeKey = RLP.toBytes32(currentNodeList[1]);\r\n            } else {\r\n                loc_ = 7;\r\n                return (res_, loc_, path_debug_);\r\n            }\r\n        }\r\n\r\n        loc_ = 8;\r\n    }\r\n\r\n    function _nibblesToTraverse(\r\n        bytes memory encodedPartialPath,\r\n        bytes memory path,\r\n        uint pathPtr\r\n    )\r\n        private\r\n        pure\r\n        returns (uint len_)\r\n    {\r\n        // encodedPartialPath has elements that are each two hex characters (1 byte), but partialPath\r\n        // and slicedPath have elements that are each one hex character (1 nibble)\r\n        bytes memory partialPath = _getNibbleArray(encodedPartialPath);\r\n        bytes memory slicedPath = new bytes(partialPath.length);\r\n\r\n        // pathPtr counts nibbles in path\r\n        // partialPath.length is a number of nibbles\r\n        for(uint i=pathPtr; i<pathPtr+partialPath.length; i++) {\r\n            byte pathNibble = path[i];\r\n            slicedPath[i-pathPtr] = pathNibble;\r\n        }\r\n\r\n        if(keccak256(abi.encodePacked(partialPath)) == keccak256(abi.encodePacked(slicedPath))) {\r\n            len_ = partialPath.length;\r\n        } else {\r\n            len_ = 0;\r\n        }\r\n    }\r\n\r\n    // bytes b must be hp encoded\r\n    function _getNibbleArray(\r\n        bytes memory b\r\n    )\r\n        private\r\n        pure\r\n        returns (bytes memory nibbles_)\r\n    {\r\n        if(b.length>0) {\r\n            uint8 offset;\r\n            uint8 hpNibble = uint8(_getNthNibbleOfBytes(0,b));\r\n            if(hpNibble == 1 || hpNibble == 3) {\r\n                nibbles_ = new bytes(b.length*2-1);\r\n                byte oddNibble = _getNthNibbleOfBytes(1,b);\r\n                nibbles_[0] = oddNibble;\r\n                offset = 1;\r\n            } else {\r\n                nibbles_ = new bytes(b.length*2-2);\r\n                offset = 0;\r\n            }\r\n\r\n            for(uint i=offset; i<nibbles_.length; i++) {\r\n                nibbles_[i] = _getNthNibbleOfBytes(i-offset+2,b);\r\n            }\r\n        }\r\n    }\r\n\r\n    // normal byte array, no encoding used\r\n    function _getNibbleArray2(\r\n        bytes memory b\r\n    )\r\n        private\r\n        pure\r\n        returns (bytes memory nibbles_)\r\n    {\r\n        nibbles_ = new bytes(b.length*2);\r\n        for (uint i = 0; i < nibbles_.length; i++) {\r\n            nibbles_[i] = _getNthNibbleOfBytes(i, b);\r\n        }\r\n    }\r\n\r\n    function _getNthNibbleOfBytes(\r\n        uint n,\r\n        bytes memory str\r\n    )\r\n        private\r\n        pure returns (byte)\r\n    {\r\n        return byte(n%2==0 ? uint8(str[n/2])/0x10 : uint8(str[n/2])%0x10);\r\n    }\r\n}\r\n\r\n// File: ../../mosaic-contracts/contracts/lib/SafeMath.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n// Copyright 2019 OpenST Ltd.\r\n//\r\n// Licensed under the Apache License, Version 2.0 (the \"License\");\r\n// you may not use this file except in compliance with the License.\r\n// You may obtain a copy of the License at\r\n//\r\n//    http://www.apache.org/licenses/LICENSE-2.0\r\n//\r\n// Unless required by applicable law or agreed to in writing, software\r\n// distributed under the License is distributed on an \"AS IS\" BASIS,\r\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n// See the License for the specific language governing permissions and\r\n// limitations under the License.\r\n// \r\n// ----------------------------------------------------------------------------\r\n//\r\n// http://www.simpletoken.org/\r\n//\r\n// Based on the SafeMath library by the OpenZeppelin team.\r\n// Copyright (c) 2018 Smart Contract Solutions, Inc.\r\n// https://github.com/OpenZeppelin/zeppelin-solidity\r\n// The MIT License.\r\n// ----------------------------------------------------------------------------\r\n\r\n\r\n/**\r\n * @title SafeMath library.\r\n *\r\n * @notice Based on the SafeMath library by the OpenZeppelin team.\r\n *\r\n * @dev Math operations with safety checks that revert on error.\r\n */\r\nlibrary SafeMath {\r\n\r\n    /* Internal Functions */\r\n\r\n    /**\r\n     * @notice Multiplies two numbers, reverts on overflow.\r\n     *\r\n     * @param a Unsigned integer multiplicand.\r\n     * @param b Unsigned integer multiplier.\r\n     *\r\n     * @return uint256 Product.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        /*\r\n         * Gas optimization: this is cheaper than requiring 'a' not being zero,\r\n         * but the benefit is lost if 'b' is also tested.\r\n         * See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n         */\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(\r\n            c / a == b,\r\n            \"Overflow when multiplying.\"\r\n        );\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @notice Integer division of two numbers truncating the quotient, reverts\r\n     *         on division by zero.\r\n     *\r\n     * @param a Unsigned integer dividend.\r\n     * @param b Unsigned integer divisor.\r\n     *\r\n     * @return uint256 Quotient.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0.\r\n        require(\r\n            b > 0,\r\n            \"Cannot do attempted division by less than or equal to zero.\"\r\n        );\r\n        uint256 c = a / b;\r\n\r\n        // There is no case in which the following doesn't hold:\r\n        // assert(a == b * c + a % b);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @notice Subtracts two numbers, reverts on underflow (i.e. if subtrahend\r\n     *         is greater than minuend).\r\n     *\r\n     * @param a Unsigned integer minuend.\r\n     * @param b Unsigned integer subtrahend.\r\n     *\r\n     * @return uint256 Difference.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(\r\n            b <= a,\r\n            \"Underflow when subtracting.\"\r\n        );\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @notice Adds two numbers, reverts on overflow.\r\n     *\r\n     * @param a Unsigned integer augend.\r\n     * @param b Unsigned integer addend.\r\n     *\r\n     * @return uint256 Sum.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(\r\n            c >= a,\r\n            \"Overflow when adding.\"\r\n        );\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @notice Divides two numbers and returns the remainder (unsigned integer\r\n     *         modulo), reverts when dividing by zero.\r\n     *\r\n     * @param a Unsigned integer dividend.\r\n     * @param b Unsigned integer divisor.\r\n     *\r\n     * @return uint256 Remainder.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(\r\n            b != 0,\r\n            \"Cannot do attempted division by zero (in `mod()`).\"\r\n        );\r\n\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: ../../mosaic-contracts/contracts/lib/BytesLib.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\nlibrary BytesLib {\r\n    function concat(\r\n        bytes memory _preBytes,\r\n        bytes memory _postBytes\r\n    )\r\n        internal\r\n        pure returns (bytes memory bytes_)\r\n    {\r\n        /* solium-disable-next-line */\r\n        assembly {\r\n            // Get a location of some free memory and store it in bytes_ as\r\n            // Solidity does for memory variables.\r\n            bytes_ := mload(0x40)\r\n\r\n            // Store the length of the first bytes array at the beginning of\r\n            // the memory for bytes_.\r\n            let length := mload(_preBytes)\r\n            mstore(bytes_, length)\r\n\r\n            // Maintain a memory counter for the current write location in the\r\n            // temp bytes array by adding the 32 bytes for the array length to\r\n            // the starting location.\r\n            let mc := add(bytes_, 0x20)\r\n            // Stop copying when the memory counter reaches the length of the\r\n            // first bytes array.\r\n            let end := add(mc, length)\r\n\r\n            for {\r\n                // Initialize a copy counter to the start of the _preBytes data,\r\n                // 32 bytes into its memory.\r\n                let cc := add(_preBytes, 0x20)\r\n            } lt(mc, end) {\r\n                // Increase both counters by 32 bytes each iteration.\r\n                mc := add(mc, 0x20)\r\n                cc := add(cc, 0x20)\r\n            } {\r\n                // Write the _preBytes data into the bytes_ memory 32 bytes\r\n                // at a time.\r\n                mstore(mc, mload(cc))\r\n            }\r\n\r\n            // Add the length of _postBytes to the current length of bytes_\r\n            // and store it as the new length in the first 32 bytes of the\r\n            // bytes_ memory.\r\n            length := mload(_postBytes)\r\n            mstore(bytes_, add(length, mload(bytes_)))\r\n\r\n            // Move the memory counter back from a multiple of 0x20 to the\r\n            // actual end of the _preBytes data.\r\n            mc := end\r\n            // Stop copying when the memory counter reaches the new combined\r\n            // length of the arrays.\r\n            end := add(mc, length)\r\n\r\n            for {\r\n                let cc := add(_postBytes, 0x20)\r\n            } lt(mc, end) {\r\n                mc := add(mc, 0x20)\r\n                cc := add(cc, 0x20)\r\n            } {\r\n                mstore(mc, mload(cc))\r\n            }\r\n\r\n            // Update the free-memory pointer by padding our last write location\r\n            // to 32 bytes: add 31 bytes to the end of bytes_ to move to the\r\n            // next 32 byte block, then round down to the nearest multiple of\r\n            // 32. If the sum of the length of the two arrays is zero then add\r\n            // one before rounding down to leave a blank 32 bytes (the length block with 0).\r\n            mstore(0x40, and(\r\n              add(add(end, iszero(add(length, mload(_preBytes)))), 31),\r\n              not(31) // Round down to the nearest 32 bytes.\r\n            ))\r\n        }\r\n    }\r\n\r\n    // Pad a bytes array to 32 bytes\r\n    function leftPad(\r\n        bytes memory _bytes\r\n    )\r\n        internal\r\n        pure\r\n        returns (bytes memory padded_)\r\n    {\r\n        bytes memory padding = new bytes(32 - _bytes.length);\r\n        padded_ = concat(padding, _bytes);\r\n    }\r\n\r\n    /**\r\n     * @notice Convert bytes32 to bytes\r\n     *\r\n     * @param _inBytes32 bytes32 value\r\n     *\r\n     * @return bytes value\r\n     */\r\n    function bytes32ToBytes(bytes32 _inBytes32)\r\n        internal\r\n        pure\r\n        returns (bytes memory bytes_)\r\n    {\r\n        bytes_ = new bytes(32);\r\n\r\n        /* solium-disable-next-line */\r\n        assembly {\r\n            mstore(add(32, bytes_), _inBytes32)\r\n        }\r\n    }\r\n\r\n}\r\n\r\n// File: ../../mosaic-contracts/contracts/lib/MessageBus.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n// Copyright 2019 OpenST Ltd.\r\n//\r\n// Licensed under the Apache License, Version 2.0 (the \"License\");\r\n// you may not use this file except in compliance with the License.\r\n// You may obtain a copy of the License at\r\n//\r\n//    http://www.apache.org/licenses/LICENSE-2.0\r\n//\r\n// Unless required by applicable law or agreed to in writing, software\r\n// distributed under the License is distributed on an \"AS IS\" BASIS,\r\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n// See the License for the specific language governing permissions and\r\n// limitations under the License.\r\n//\r\n// ----------------------------------------------------------------------------\r\n//\r\n// http://www.simpletoken.org/\r\n//\r\n// ----------------------------------------------------------------------------\r\n\r\n\r\n\r\n\r\nlibrary MessageBus {\r\n\r\n    /* Usings */\r\n\r\n    using SafeMath for uint256;\r\n\r\n\r\n    /* Enums */\r\n\r\n    /** Status of the message state machine. */\r\n    enum MessageStatus {\r\n        Undeclared,\r\n        Declared,\r\n        Progressed,\r\n        DeclaredRevocation,\r\n        Revoked\r\n    }\r\n\r\n    /** Status of the message state machine. */\r\n    enum MessageBoxType {\r\n        Outbox,\r\n        Inbox\r\n    }\r\n\r\n\r\n    /* Structs */\r\n\r\n    /** MessageBox stores the inbox and outbox mapping. */\r\n    struct MessageBox {\r\n\r\n        /** Maps message hash to the MessageStatus. */\r\n        mapping(bytes32 => MessageStatus) outbox;\r\n\r\n        /** Maps message hash to the MessageStatus. */\r\n        mapping(bytes32 => MessageStatus) inbox;\r\n    }\r\n\r\n    /** A Message is sent between gateways. */\r\n    struct Message {\r\n\r\n        /** Intent hash of specific request type. */\r\n        bytes32 intentHash;\r\n\r\n        /** Nonce of the sender. */\r\n        uint256 nonce;\r\n\r\n        /** Gas price that sender will pay for reward. */\r\n        uint256 gasPrice;\r\n\r\n        /** Gas limit that sender will pay. */\r\n        uint256 gasLimit;\r\n\r\n        /** Address of the message sender. */\r\n        address sender;\r\n\r\n        /** Hash lock provided by the facilitator. */\r\n        bytes32 hashLock;\r\n\r\n        /**\r\n         * The amount of the gas consumed, this is used for reward\r\n         * calculation.\r\n         */\r\n        uint256 gasConsumed;\r\n    }\r\n\r\n\r\n    /* Constants */\r\n\r\n    bytes32 public constant MESSAGE_TYPEHASH = keccak256(\r\n        abi.encode(\r\n            \"Message(bytes32 intentHash,uint256 nonce,uint256 gasPrice,uint256 gasLimit,address sender,bytes32 hashLock)\"\r\n        )\r\n    );\r\n\r\n    /**\r\n     * Position of outbox in struct MessageBox.\r\n     * This is used to generate storage merkel proof.\r\n     */\r\n    uint8 public constant OUTBOX_OFFSET = 0;\r\n\r\n    /**\r\n     * Position of inbox in struct MessageBox.\r\n     * This is used to generate storage merkel proof.\r\n     */\r\n    uint8 public constant INBOX_OFFSET = 1;\r\n\r\n\r\n    /* External Functions */\r\n\r\n    /**\r\n     * @notice Declare a new message. This will update the outbox status to\r\n     *         `Declared` for the given message hash.\r\n     *\r\n     * @param _messageBox Message Box.\r\n     * @param _message Message object.\r\n     *\r\n     * @return messageHash_ Message hash\r\n     */\r\n    function declareMessage(\r\n        MessageBox storage _messageBox,\r\n        Message storage _message\r\n    )\r\n        external\r\n        returns (bytes32 messageHash_)\r\n    {\r\n        messageHash_ = messageDigest(_message);\r\n        require(\r\n            _messageBox.outbox[messageHash_] == MessageStatus.Undeclared,\r\n            \"Message on source must be Undeclared.\"\r\n        );\r\n\r\n        // Update the outbox message status to `Declared`.\r\n        _messageBox.outbox[messageHash_] = MessageStatus.Declared;\r\n    }\r\n\r\n    /**\r\n     * @notice Confirm a new message that is declared in outbox on the source\r\n     *         chain. Merkle proof will be performed to verify the declared\r\n     *         status in source chains outbox. This will update the inbox\r\n     *         status to `Declared` for the given message hash.\r\n     *\r\n     * @param _messageBox Message Box.\r\n     * @param _message Message object.\r\n     * @param _rlpParentNodes RLP encoded parent node data to prove in\r\n     *                        messageBox outbox.\r\n     * @param _messageBoxOffset position of the messageBox.\r\n     * @param _storageRoot Storage root for proof.\r\n     *\r\n     * @return messageHash_ Message hash.\r\n     */\r\n    function confirmMessage(\r\n        MessageBox storage _messageBox,\r\n        Message storage _message,\r\n        bytes calldata _rlpParentNodes,\r\n        uint8 _messageBoxOffset,\r\n        bytes32 _storageRoot\r\n    )\r\n        external\r\n        returns (bytes32 messageHash_)\r\n    {\r\n        messageHash_ = messageDigest(_message);\r\n        require(\r\n            _messageBox.inbox[messageHash_] == MessageStatus.Undeclared,\r\n            \"Message on target must be Undeclared.\"\r\n        );\r\n\r\n        // Get the storage path to verify proof.\r\n        bytes memory path = BytesLib.bytes32ToBytes(\r\n            storageVariablePathForStruct(\r\n                _messageBoxOffset,\r\n                OUTBOX_OFFSET,\r\n                messageHash_\r\n            )\r\n        );\r\n\r\n        // Verify the merkle proof.\r\n        require(\r\n            MerklePatriciaProof.verify(\r\n                keccak256(abi.encodePacked(MessageStatus.Declared)),\r\n                path,\r\n                _rlpParentNodes,\r\n                _storageRoot\r\n            ),\r\n            \"Merkle proof verification failed.\"\r\n        );\r\n\r\n        // Update the message box inbox status to `Declared`.\r\n        _messageBox.inbox[messageHash_] = MessageStatus.Declared;\r\n    }\r\n\r\n    /**\r\n     * @notice Update the outbox message hash status to `Progressed`.\r\n     *\r\n     * @param _messageBox Message Box.\r\n     * @param _message Message object.\r\n     * @param _unlockSecret Unlock secret for the hash lock provided while\r\n     *                      declaration.\r\n     *\r\n     * @return messageHash_ Message hash.\r\n     */\r\n    function progressOutbox(\r\n        MessageBox storage _messageBox,\r\n        Message storage _message,\r\n        bytes32 _unlockSecret\r\n    )\r\n        external\r\n        returns (bytes32 messageHash_)\r\n    {\r\n        require(\r\n            _message.hashLock == keccak256(abi.encode(_unlockSecret)),\r\n            \"Invalid unlock secret.\"\r\n        );\r\n\r\n        messageHash_ = messageDigest(_message);\r\n        require(\r\n            _messageBox.outbox[messageHash_] == MessageStatus.Declared,\r\n            \"Message on source must be Declared.\"\r\n        );\r\n\r\n        // Update the outbox message status to `Progressed`.\r\n        _messageBox.outbox[messageHash_] = MessageStatus.Progressed;\r\n    }\r\n\r\n    /**\r\n     * @notice Update the status for the outbox for a given message hash to\r\n     *         `Progressed`. Merkle proof is used to verify status of inbox in\r\n     *         source chain. This is an alternative approach to hashlocks.\r\n     *\r\n     * @dev The messsage status for the message hash in the inbox should be\r\n     *      either `Declared` or `Progresses`. Either of this status will be\r\n     *      verified with the merkle proof.\r\n     *\r\n     * @param _messageBox Message Box.\r\n     * @param _message Message object.\r\n     * @param _rlpParentNodes RLP encoded parent node data to prove in\r\n     *                        messageBox inbox.\r\n     * @param _messageBoxOffset Position of the messageBox.\r\n     * @param _storageRoot Storage root for proof.\r\n     * @param _messageStatus Message status of message hash in the inbox of\r\n     *                       source chain.\r\n     *\r\n     * @return messageHash_ Message hash.\r\n     */\r\n    function progressOutboxWithProof(\r\n        MessageBox storage _messageBox,\r\n        Message storage _message,\r\n        bytes calldata _rlpParentNodes,\r\n        uint8 _messageBoxOffset,\r\n        bytes32 _storageRoot,\r\n        MessageStatus _messageStatus\r\n    )\r\n        external\r\n        returns (bytes32 messageHash_)\r\n    {\r\n        messageHash_ = messageDigest(_message);\r\n\r\n        if(_messageBox.outbox[messageHash_] == MessageStatus.Declared) {\r\n\r\n            /*\r\n             * The inbox message status of target must be either `Declared` or\r\n             * `Progressed` when outbox message status at source is `Declared`.\r\n             */\r\n            require(\r\n                _messageStatus == MessageStatus.Declared ||\r\n                _messageStatus == MessageStatus.Progressed,\r\n                \"Message on target must be Declared or Progressed.\"\r\n            );\r\n\r\n        } else if (_messageBox.outbox[messageHash_] == MessageStatus.DeclaredRevocation) {\r\n\r\n            /*\r\n             * The inbox message status of target must be either `Progressed`\r\n             * when outbox message status at source is `DeclaredRevocation`.\r\n             */\r\n            require(\r\n                _messageStatus == MessageStatus.Progressed,\r\n                \"Message on target must be Progressed.\"\r\n            );\r\n\r\n        } else {\r\n            revert(\"Status of message on source must be Declared or DeclareRevocation.\");\r\n        }\r\n\r\n        bytes memory storagePath = BytesLib.bytes32ToBytes(\r\n            storageVariablePathForStruct(\r\n                _messageBoxOffset,\r\n                INBOX_OFFSET,\r\n                messageHash_\r\n            )\r\n        );\r\n\r\n        // Verify the merkle proof.\r\n        require(\r\n            MerklePatriciaProof.verify(\r\n                keccak256(abi.encodePacked(_messageStatus)),\r\n                storagePath,\r\n                _rlpParentNodes,\r\n                _storageRoot),\r\n            \"Merkle proof verification failed.\"\r\n        );\r\n\r\n        _messageBox.outbox[messageHash_] = MessageStatus.Progressed;\r\n    }\r\n\r\n    /**\r\n     * @notice Update the status for the inbox for a given message hash to\r\n     *         `Progressed`\r\n     *\r\n     * @param _messageBox Message Box.\r\n     * @param _message Message object.\r\n     * @param _unlockSecret Unlock secret for the hash lock provided while\r\n     *                      declaration.\r\n     *\r\n     * @return messageHash_ Message hash.\r\n     */\r\n    function progressInbox(\r\n        MessageBox storage _messageBox,\r\n        Message storage _message,\r\n        bytes32 _unlockSecret\r\n    )\r\n        external\r\n        returns (bytes32 messageHash_)\r\n    {\r\n        require(\r\n            _message.hashLock == keccak256(abi.encode(_unlockSecret)),\r\n            \"Invalid unlock secret.\"\r\n        );\r\n\r\n        messageHash_ = messageDigest(_message);\r\n        require(\r\n            _messageBox.inbox[messageHash_] == MessageStatus.Declared,\r\n            \"Message on target status must be Declared.\"\r\n        );\r\n\r\n        _messageBox.inbox[messageHash_] = MessageStatus.Progressed;\r\n    }\r\n\r\n    /**\r\n     * @notice Update the status for the inbox for a given message hash to\r\n     *         `Progressed`. Merkle proof is used to verify status of outbox in\r\n     *         source chain. This is an alternative approach to hashlocks.\r\n     *\r\n     * @dev The messsage status for the message hash in the outbox should be\r\n     *      either `Declared` or `Progresses`. Either of this status will be\r\n     *      verified in the merkle proof.\r\n     *\r\n     * @param _messageBox Message Box.\r\n     * @param _message Message object.\r\n     * @param _rlpParentNodes RLP encoded parent node data to prove in\r\n     *                        messageBox outbox.\r\n     * @param _messageBoxOffset Position of the messageBox.\r\n     * @param _storageRoot Storage root for proof.\r\n     * @param _messageStatus Message status of message hash in the outbox of\r\n     *                       source chain.\r\n     *\r\n     * @return messageHash_ Message hash.\r\n     */\r\n    function progressInboxWithProof(\r\n        MessageBox storage _messageBox,\r\n        Message storage _message,\r\n        bytes calldata _rlpParentNodes,\r\n        uint8 _messageBoxOffset,\r\n        bytes32 _storageRoot,\r\n        MessageStatus _messageStatus\r\n    )\r\n        external\r\n        returns (bytes32 messageHash_)\r\n    {\r\n        // Outbox message status must be either `Declared` or `Progressed`.\r\n        require(\r\n            _messageStatus == MessageStatus.Declared ||\r\n            _messageStatus == MessageStatus.Progressed,\r\n            \"Message on source must be Declared or Progressed.\"\r\n        );\r\n\r\n        messageHash_ = messageDigest(_message);\r\n        require(\r\n            _messageBox.inbox[messageHash_] == MessageStatus.Declared,\r\n            \"Message on target must be Declared.\"\r\n        );\r\n\r\n        // The outbox is at location OUTBOX_OFFSET of the MessageBox struct.\r\n        bytes memory path = BytesLib.bytes32ToBytes(\r\n            storageVariablePathForStruct(\r\n                _messageBoxOffset,\r\n                OUTBOX_OFFSET,\r\n                messageHash_\r\n            )\r\n        );\r\n\r\n        // Perform the merkle proof.\r\n        require(\r\n            MerklePatriciaProof.verify(\r\n                keccak256(abi.encodePacked(_messageStatus)),\r\n                path,\r\n                _rlpParentNodes,\r\n                _storageRoot\r\n            ),\r\n            \"Merkle proof verification failed.\"\r\n        );\r\n\r\n        _messageBox.inbox[messageHash_] = MessageStatus.Progressed;\r\n    }\r\n\r\n    /**\r\n     * @notice Declare a new revocation message. This will update the outbox\r\n     *         status to `DeclaredRevocation` for the given message hash.\r\n     *\r\n     * @dev In order to declare revocation the existing message status for the\r\n     *      given message hash should be `Declared`.\r\n     *\r\n     * @param _messageBox Message Box.\r\n     * @param _message Message object.\r\n     *\r\n     * @return messageHash_ Message hash.\r\n     */\r\n    function declareRevocationMessage(\r\n        MessageBox storage _messageBox,\r\n        Message storage _message\r\n    )\r\n        external\r\n        returns (bytes32 messageHash_)\r\n    {\r\n        messageHash_ = messageDigest(_message);\r\n        require(\r\n            _messageBox.outbox[messageHash_] == MessageStatus.Declared,\r\n            \"Message on source must be Declared.\"\r\n        );\r\n\r\n        _messageBox.outbox[messageHash_] = MessageStatus.DeclaredRevocation;\r\n    }\r\n\r\n    /**\r\n     * @notice Confirm a revocation message that is declared in the outbox of\r\n     *         source chain. This will update the outbox status to\r\n     *         `Revoked` for the given message hash.\r\n     *\r\n     * @dev In order to declare revocation the existing message status for the\r\n     *      given message hash should be `Declared`.\r\n     *\r\n     * @param _messageBox Message Box.\r\n     * @param _message Message object.\r\n     * @param _rlpParentNodes RLP encoded parent node data to prove in\r\n     *                        messageBox outbox.\r\n     * @param _messageBoxOffset Position of the messageBox.\r\n     * @param _storageRoot Storage root for proof.\r\n     *\r\n     * @return messageHash_ Message hash.\r\n     */\r\n    function confirmRevocation(\r\n        MessageBox storage _messageBox,\r\n        Message storage _message,\r\n        bytes calldata _rlpParentNodes,\r\n        uint8 _messageBoxOffset,\r\n        bytes32 _storageRoot\r\n    )\r\n        external\r\n        returns (bytes32 messageHash_)\r\n    {\r\n        messageHash_ = messageDigest(_message);\r\n        require(\r\n            _messageBox.inbox[messageHash_] == MessageStatus.Declared,\r\n            \"Message on target must be Declared.\"\r\n        );\r\n\r\n        // Get the path.\r\n        bytes memory path = BytesLib.bytes32ToBytes(\r\n            storageVariablePathForStruct(\r\n                _messageBoxOffset,\r\n                OUTBOX_OFFSET,\r\n                messageHash_\r\n            )\r\n        );\r\n\r\n        // Perform the merkle proof.\r\n        require(\r\n            MerklePatriciaProof.verify(\r\n                keccak256(abi.encodePacked(MessageStatus.DeclaredRevocation)),\r\n                path,\r\n                _rlpParentNodes,\r\n                _storageRoot\r\n            ),\r\n            \"Merkle proof verification failed.\"\r\n        );\r\n\r\n        _messageBox.inbox[messageHash_] = MessageStatus.Revoked;\r\n    }\r\n\r\n    /**\r\n     * @notice Update the status for the outbox for a given message hash to\r\n     *         `Revoked`. Merkle proof is used to verify status of inbox in\r\n     *         source chain.\r\n     *\r\n     * @dev The messsage status in the inbox should be\r\n     *      either `DeclaredRevocation` or `Revoked`. Either of this status\r\n     *      will be verified in the merkle proof.\r\n     *\r\n     * @param _messageBox Message Box.\r\n     * @param _message Message object.\r\n     * @param _messageBoxOffset Position of the messageBox.\r\n     * @param _rlpParentNodes RLP encoded parent node data to prove in\r\n     *                        messageBox inbox.\r\n     * @param _storageRoot Storage root for proof.\r\n     * @param _messageStatus Message status of message hash in the inbox of\r\n     *                       source chain.\r\n     *\r\n     * @return messageHash_ Message hash.\r\n     */\r\n    function progressOutboxRevocation(\r\n        MessageBox storage _messageBox,\r\n        Message storage _message,\r\n        uint8 _messageBoxOffset,\r\n        bytes calldata _rlpParentNodes,\r\n        bytes32 _storageRoot,\r\n        MessageStatus _messageStatus\r\n    )\r\n        external\r\n        returns (bytes32 messageHash_)\r\n    {\r\n        require(\r\n            _messageStatus == MessageStatus.Revoked,\r\n            \"Message on target status must be Revoked.\"\r\n        );\r\n\r\n        messageHash_ = messageDigest(_message);\r\n        require(\r\n            _messageBox.outbox[messageHash_] ==\r\n            MessageStatus.DeclaredRevocation,\r\n            \"Message status on source must be DeclaredRevocation.\"\r\n        );\r\n\r\n        // The inbox is at location INBOX_OFFSET of the MessageBox struct.\r\n        bytes memory path = BytesLib.bytes32ToBytes(\r\n            storageVariablePathForStruct(\r\n                _messageBoxOffset,\r\n                INBOX_OFFSET,\r\n                messageHash_\r\n            )\r\n        );\r\n\r\n        // Perform the merkle proof.\r\n        require(\r\n            MerklePatriciaProof.verify(\r\n                keccak256(abi.encodePacked(_messageStatus)),\r\n                path,\r\n                _rlpParentNodes,\r\n                _storageRoot\r\n            ),\r\n            \"Merkle proof verification failed.\"\r\n        );\r\n\r\n        _messageBox.outbox[messageHash_] = MessageStatus.Revoked;\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the type hash of the type \"Message\".\r\n     *\r\n     * @return messageTypehash_ The type hash of the \"Message\" type.\r\n     */\r\n    function messageTypehash() public pure returns(bytes32 messageTypehash_) {\r\n        messageTypehash_ = MESSAGE_TYPEHASH;\r\n    }\r\n\r\n\r\n    /* Public Functions */\r\n\r\n    /**\r\n     * @notice Generate message hash from the input params\r\n     *\r\n     * @param _intentHash Intent hash.\r\n     * @param _nonce Nonce of the message sender.\r\n     * @param _gasPrice Gas price.\r\n     *\r\n     * @return messageHash_ Message hash.\r\n     */\r\n    function messageDigest(\r\n        bytes32 _intentHash,\r\n        uint256 _nonce,\r\n        uint256 _gasPrice,\r\n        uint256 _gasLimit,\r\n        address _sender,\r\n        bytes32 _hashLock\r\n    )\r\n        public\r\n        pure\r\n        returns (bytes32 messageHash_)\r\n    {\r\n        messageHash_ = keccak256(\r\n            abi.encode(\r\n                MESSAGE_TYPEHASH,\r\n                _intentHash,\r\n                _nonce,\r\n                _gasPrice,\r\n                _gasLimit,\r\n                _sender,\r\n                _hashLock\r\n            )\r\n        );\r\n    }\r\n\r\n\r\n    /* Private Functions */\r\n\r\n    /**\r\n     * @notice Creates a hash from a message struct.\r\n     *\r\n     * @param _message The message to hash.\r\n     *\r\n     * @return messageHash_ The hash that represents this message.\r\n     */\r\n    function messageDigest(\r\n        Message storage _message\r\n    )\r\n        private\r\n        view\r\n        returns (bytes32 messageHash_)\r\n    {\r\n        messageHash_ = messageDigest(\r\n            _message.intentHash,\r\n            _message.nonce,\r\n            _message.gasPrice,\r\n            _message.gasLimit,\r\n            _message.sender,\r\n            _message.hashLock\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Get the storage path of the variable inside the struct.\r\n     *\r\n     * @param _structPosition Position of struct variable.\r\n     * @param _offset Offset of variable inside the struct.\r\n     * @param _key Key of variable in case of mapping\r\n     *\r\n     * @return storagePath_ Storage path of the variable.\r\n     */\r\n    function storageVariablePathForStruct(\r\n        uint8 _structPosition,\r\n        uint8 _offset,\r\n        bytes32 _key\r\n    )\r\n        private\r\n        pure\r\n        returns(bytes32 storagePath_)\r\n    {\r\n        if(_offset > 0){\r\n            _structPosition = _structPosition + _offset;\r\n        }\r\n\r\n        bytes memory indexBytes = BytesLib.leftPad(\r\n            BytesLib.bytes32ToBytes(bytes32(uint256(_structPosition)))\r\n        );\r\n\r\n        bytes memory keyBytes = BytesLib.leftPad(BytesLib.bytes32ToBytes(_key));\r\n        bytes memory path = BytesLib.concat(keyBytes, indexBytes);\r\n\r\n        storagePath_ = keccak256(\r\n            abi.encodePacked(keccak256(abi.encodePacked(path)))\r\n        );\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_messageBox\",\"type\":\"MessageBus.MessageBox storage\"},{\"name\":\"_message\",\"type\":\"MessageBus.Message storage\"},{\"name\":\"_rlpParentNodes\",\"type\":\"bytes\"},{\"name\":\"_messageBoxOffset\",\"type\":\"uint8\"},{\"name\":\"_storageRoot\",\"type\":\"bytes32\"},{\"name\":\"_messageStatus\",\"type\":\"MessageBus.MessageStatus\"}],\"name\":\"progressOutboxWithProof\",\"outputs\":[{\"name\":\"messageHash_\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_messageBox\",\"type\":\"MessageBus.MessageBox storage\"},{\"name\":\"_message\",\"type\":\"MessageBus.Message storage\"},{\"name\":\"_unlockSecret\",\"type\":\"bytes32\"}],\"name\":\"progressInbox\",\"outputs\":[{\"name\":\"messageHash_\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_messageBox\",\"type\":\"MessageBus.MessageBox storage\"},{\"name\":\"_message\",\"type\":\"MessageBus.Message storage\"},{\"name\":\"_rlpParentNodes\",\"type\":\"bytes\"},{\"name\":\"_messageBoxOffset\",\"type\":\"uint8\"},{\"name\":\"_storageRoot\",\"type\":\"bytes32\"}],\"name\":\"confirmRevocation\",\"outputs\":[{\"name\":\"messageHash_\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_messageBox\",\"type\":\"MessageBus.MessageBox storage\"},{\"name\":\"_message\",\"type\":\"MessageBus.Message storage\"},{\"name\":\"_messageBoxOffset\",\"type\":\"uint8\"},{\"name\":\"_rlpParentNodes\",\"type\":\"bytes\"},{\"name\":\"_storageRoot\",\"type\":\"bytes32\"},{\"name\":\"_messageStatus\",\"type\":\"MessageBus.MessageStatus\"}],\"name\":\"progressOutboxRevocation\",\"outputs\":[{\"name\":\"messageHash_\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_intentHash\",\"type\":\"bytes32\"},{\"name\":\"_nonce\",\"type\":\"uint256\"},{\"name\":\"_gasPrice\",\"type\":\"uint256\"},{\"name\":\"_gasLimit\",\"type\":\"uint256\"},{\"name\":\"_sender\",\"type\":\"address\"},{\"name\":\"_hashLock\",\"type\":\"bytes32\"}],\"name\":\"messageDigest\",\"outputs\":[{\"name\":\"messageHash_\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_messageBox\",\"type\":\"MessageBus.MessageBox storage\"},{\"name\":\"_message\",\"type\":\"MessageBus.Message storage\"},{\"name\":\"_unlockSecret\",\"type\":\"bytes32\"}],\"name\":\"progressOutbox\",\"outputs\":[{\"name\":\"messageHash_\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MESSAGE_TYPEHASH\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_messageBox\",\"type\":\"MessageBus.MessageBox storage\"},{\"name\":\"_message\",\"type\":\"MessageBus.Message storage\"}],\"name\":\"declareRevocationMessage\",\"outputs\":[{\"name\":\"messageHash_\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"INBOX_OFFSET\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"messageTypehash\",\"outputs\":[{\"name\":\"messageTypehash_\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_messageBox\",\"type\":\"MessageBus.MessageBox storage\"},{\"name\":\"_message\",\"type\":\"MessageBus.Message storage\"},{\"name\":\"_rlpParentNodes\",\"type\":\"bytes\"},{\"name\":\"_messageBoxOffset\",\"type\":\"uint8\"},{\"name\":\"_storageRoot\",\"type\":\"bytes32\"},{\"name\":\"_messageStatus\",\"type\":\"MessageBus.MessageStatus\"}],\"name\":\"progressInboxWithProof\",\"outputs\":[{\"name\":\"messageHash_\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_messageBox\",\"type\":\"MessageBus.MessageBox storage\"},{\"name\":\"_message\",\"type\":\"MessageBus.Message storage\"}],\"name\":\"declareMessage\",\"outputs\":[{\"name\":\"messageHash_\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_messageBox\",\"type\":\"MessageBus.MessageBox storage\"},{\"name\":\"_message\",\"type\":\"MessageBus.Message storage\"},{\"name\":\"_rlpParentNodes\",\"type\":\"bytes\"},{\"name\":\"_messageBoxOffset\",\"type\":\"uint8\"},{\"name\":\"_storageRoot\",\"type\":\"bytes32\"}],\"name\":\"confirmMessage\",\"outputs\":[{\"name\":\"messageHash_\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"OUTBOX_OFFSET\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"MessageBus","CompilerVersion":"v0.5.3+commit.10d17f24","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"MerklePatriciaProof:30db9dd1875dbea601ba061e81dd88325d68fd18","LicenseType":"Apache-2.0","SwarmSource":"bzzr://8067e5d3a224544827694a53bab8c63d41db0a8694e64c9c72ffa94669d66924"}]}