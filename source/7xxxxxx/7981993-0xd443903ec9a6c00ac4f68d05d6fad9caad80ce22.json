{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.7;\r\n\r\ninterface TubInterface {\r\n    function open() external returns (bytes32);\r\n    function join(uint) external;\r\n    function exit(uint) external;\r\n    function lock(bytes32, uint) external;\r\n    function free(bytes32, uint) external;\r\n    function draw(bytes32, uint) external;\r\n    function wipe(bytes32, uint) external;\r\n    function give(bytes32, address) external;\r\n    function shut(bytes32) external;\r\n    function cups(bytes32) external view returns (address, uint, uint, uint);\r\n    function gem() external view returns (TokenInterface);\r\n    function gov() external view returns (TokenInterface);\r\n    function skr() external view returns (TokenInterface);\r\n    function sai() external view returns (TokenInterface);\r\n    function ink(bytes32) external view returns (uint);\r\n    function tab(bytes32) external returns (uint);\r\n    function rap(bytes32) external returns (uint);\r\n    function per() external view returns (uint);\r\n    function pep() external view returns (PepInterface);\r\n}\r\n\r\ninterface TokenInterface {\r\n    function allowance(address, address) external view returns (uint);\r\n    function balanceOf(address) external view returns (uint);\r\n    function approve(address, uint) external;\r\n    function transfer(address, uint) external returns (bool);\r\n    function transferFrom(address, address, uint) external returns (bool);\r\n    function deposit() external payable;\r\n    function withdraw(uint) external;\r\n}\r\n\r\ninterface PepInterface {\r\n    function peek() external returns (bytes32, bool);\r\n}\r\n\r\ninterface MakerOracleInterface {\r\n    function read() external view returns (bytes32);\r\n}\r\n\r\ninterface UniswapExchange {\r\n    function getEthToTokenOutputPrice(uint256 tokensBought) external view returns (uint256 ethSold);\r\n    function getTokenToEthOutputPrice(uint256 ethBought) external view returns (uint256 tokensSold);\r\n    function tokenToTokenSwapOutput(\r\n        uint256 tokensBought,\r\n        uint256 maxTokensSold,\r\n        uint256 maxEthSold,\r\n        uint256 deadline,\r\n        address tokenAddr\r\n        ) external returns (uint256  tokensSold);\r\n}\r\n\r\ninterface BridgeInterface {\r\n    function transferDAI(uint) external;\r\n    function transferBackDAI(uint) external;\r\n    function cArrLength() external view returns (uint);\r\n    function cTokenAddr(uint) external view returns (address, uint);\r\n}\r\n\r\ninterface CTokenInterface {\r\n    function redeem(uint redeemTokens) external returns (uint);\r\n    function redeemUnderlying(uint redeemAmount) external returns (uint);\r\n    function borrow(uint borrowAmount) external returns (uint);\r\n    function liquidateBorrow(address borrower, uint repayAmount, address cTokenCollateral) external returns (uint);\r\n    function liquidateBorrow(address borrower, address cTokenCollateral) external payable;\r\n    function exchangeRateCurrent() external returns (uint);\r\n    function getCash() external view returns (uint);\r\n    function totalBorrowsCurrent() external returns (uint);\r\n    function borrowRatePerBlock() external view returns (uint);\r\n    function supplyRatePerBlock() external view returns (uint);\r\n    function totalReserves() external view returns (uint);\r\n    function reserveFactorMantissa() external view returns (uint);\r\n    function borrowBalanceCurrent(address account) external returns (uint);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address owner) external view returns (uint256 balance);\r\n    function allowance(address, address) external view returns (uint);\r\n    function approve(address, uint) external;\r\n    function transfer(address, uint) external returns (bool);\r\n    function transferFrom(address, address, uint) external returns (bool);\r\n}\r\n\r\ninterface CERC20Interface {\r\n    function mint(uint mintAmount) external returns (uint); // For ERC20\r\n    function repayBorrow(uint repayAmount) external returns (uint); // For ERC20\r\n    function repayBorrowBehalf(address borrower, uint repayAmount) external returns (uint); // For ERC20\r\n    function borrowBalanceCurrent(address account) external returns (uint);\r\n}\r\n\r\ninterface CETHInterface {\r\n    function mint() external payable; // For ETH\r\n    function repayBorrow() external payable; // For ETH\r\n    function repayBorrowBehalf(address borrower) external payable; // For ETH\r\n    function borrowBalanceCurrent(address account) external returns (uint);\r\n}\r\n\r\ninterface ERC20Interface {\r\n    function allowance(address, address) external view returns (uint);\r\n    function balanceOf(address) external view returns (uint);\r\n    function approve(address, uint) external;\r\n    function transfer(address, uint) external returns (bool);\r\n    function transferFrom(address, address, uint) external returns (bool);\r\n}\r\n\r\ninterface ComptrollerInterface {\r\n    function enterMarkets(address[] calldata cTokens) external returns (uint[] memory);\r\n    function exitMarket(address cTokenAddress) external returns (uint);\r\n    function getAssetsIn(address account) external view returns (address[] memory);\r\n    function getAccountLiquidity(address account) external view returns (uint, uint, uint);\r\n}\r\n\r\ninterface CompOracleInterface {\r\n    function getUnderlyingPrice(address) external view returns (uint);\r\n}\r\n\r\n\r\ncontract DSMath {\r\n\r\n    function add(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x + y) >= x, \"math-not-safe\");\r\n    }\r\n\r\n    function mul(uint x, uint y) internal pure returns (uint z) {\r\n        require(y == 0 || (z = x * y) / y == x, \"math-not-safe\");\r\n    }\r\n\r\n    uint constant WAD = 10 ** 18;\r\n    uint constant RAY = 10 ** 27;\r\n\r\n    function rmul(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, y), RAY / 2) / RAY;\r\n    }\r\n\r\n    function rdiv(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, RAY), y / 2) / y;\r\n    }\r\n\r\n    function wmul(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, y), WAD / 2) / WAD;\r\n    }\r\n\r\n    function wdiv(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, WAD), y / 2) / y;\r\n    }\r\n\r\n}\r\n\r\n\r\ncontract Helper is DSMath {\r\n\r\n    /**\r\n     * @dev setting allowance to compound for the \"user proxy\" if required\r\n     */\r\n    function setApproval(address erc20, uint srcAmt, address to) internal {\r\n        TokenInterface erc20Contract = TokenInterface(erc20);\r\n        uint tokenAllowance = erc20Contract.allowance(address(this), to);\r\n        if (srcAmt > tokenAllowance) {\r\n            erc20Contract.approve(to, 2**255);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev get ethereum address for trade\r\n     */\r\n    function getAddressETH() public pure returns (address eth) {\r\n        eth = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\r\n    }\r\n\r\n        /**\r\n     * @dev get MakerDAO CDP engine\r\n     */\r\n    function getSaiTubAddress() public pure returns (address sai) {\r\n        sai = 0x448a5065aeBB8E423F0896E6c5D525C040f59af3;\r\n    }\r\n\r\n    /**\r\n     * @dev get MakerDAO Oracle for ETH price\r\n     */\r\n    function getOracleAddress() public pure returns (address oracle) {\r\n        oracle = 0x729D19f657BD0614b4985Cf1D82531c67569197B;\r\n    }\r\n\r\n    /**\r\n     * @dev get uniswap MKR exchange\r\n     */\r\n    function getUniswapMKRExchange() public pure returns (address ume) {\r\n        ume = 0x2C4Bd064b998838076fa341A83d007FC2FA50957;\r\n    }\r\n\r\n    /**\r\n     * @dev get uniswap DAI exchange\r\n     */\r\n    function getUniswapDAIExchange() public pure returns (address ude) {\r\n        ude = 0x09cabEC1eAd1c0Ba254B09efb3EE13841712bE14;\r\n    }\r\n\r\n    /**\r\n     * @dev get uniswap DAI exchange\r\n     */\r\n    function getBridgeAddress() public pure returns (address bridge) {\r\n        bridge = 0x9807554C441Bb37F549fc7F77165E5be49e55eD5;\r\n    }\r\n\r\n    /**\r\n     * @dev get Compound Comptroller Address\r\n     */\r\n    function getComptrollerAddress() public pure returns (address troller) {\r\n        troller = 0x3d9819210A31b4961b30EF54bE2aeD79B9c9Cd3B;\r\n    }\r\n\r\n    /**\r\n     * @dev get Compound Comptroller Address\r\n     */\r\n    function getCompOracleAddress() public pure returns (address troller) {\r\n        troller = 0xe7664229833AE4Abf4E269b8F23a86B657E2338D;\r\n    }\r\n\r\n    /**\r\n     * @dev get Compound Comptroller Address\r\n     */\r\n    function getCETHAddress() public pure returns (address cEth) {\r\n        cEth = 0x4Ddc2D193948926D02f9B1fE9e1daa0718270ED5;\r\n    }\r\n\r\n    /**\r\n     * @dev get Compound Comptroller Address\r\n     */\r\n    function getDAIAddress() public pure returns (address dai) {\r\n        dai = 0x89d24A6b4CcB1B6fAA2625fE562bDD9a23260359;\r\n    }\r\n\r\n    /**\r\n     * @dev get Compound Comptroller Address\r\n     */\r\n    function getCDAIAddress() public pure returns (address cDai) {\r\n        cDai = 0xF5DCe57282A584D2746FaF1593d3121Fcac444dC;\r\n    }\r\n\r\n    /**\r\n     * @dev get CDP bytes by CDP ID\r\n     */\r\n    function getCDPBytes(uint cdpNum) public pure returns (bytes32 cup) {\r\n        cup = bytes32(cdpNum);\r\n    }\r\n\r\n}\r\n\r\n\r\ncontract MakerHelper is Helper {\r\n\r\n    event LogOpen(uint cdpNum, address owner);\r\n    event LogLock(uint cdpNum, uint amtETH, uint amtPETH, address owner);\r\n    event LogFree(uint cdpNum, uint amtETH, uint amtPETH, address owner);\r\n    event LogDraw(uint cdpNum, uint amtDAI, address owner);\r\n    event LogWipe(uint cdpNum, uint daiAmt, uint mkrFee, uint daiFee, address owner);\r\n    event LogShut(uint cdpNum);\r\n\r\n    function setMakerAllowance(TokenInterface _token, address _spender) internal {\r\n        if (_token.allowance(address(this), _spender) != uint(-1)) {\r\n            _token.approve(_spender, uint(-1));\r\n        }\r\n    }\r\n\r\n    function isCupOwner(bytes32 cup) internal view returns(bool isOwner) {\r\n        TubInterface tub = TubInterface(getSaiTubAddress());\r\n        (address lad,,,) = tub.cups(cup);\r\n        isOwner = lad == address(this);\r\n    }\r\n\r\n    function getCDPStats(bytes32 cup) public view returns (uint ethCol, uint daiDebt) {\r\n        TubInterface tub = TubInterface(getSaiTubAddress());\r\n        (, uint pethCol, uint debt,) = tub.cups(cup);\r\n        ethCol = rmul(pethCol, tub.per()); // get ETH col from PETH col\r\n        daiDebt = debt;\r\n    }\r\n\r\n    /**\r\n     * @dev get final Ratio of Maker CDP\r\n     * @param ethCol amount of ETH Col to add in existing Col\r\n     * @param daiDebt amount of DAI Debt to add in existing Debt\r\n     */\r\n    function getMakerRatio(bytes32 cup, uint ethCol, uint daiDebt) public view returns (uint ratio) {\r\n        (uint makerCol, uint makerDebt) = getCDPStats(cup);\r\n        makerCol += ethCol;\r\n        makerDebt += daiDebt;\r\n        uint usdPerEth = uint(MakerOracleInterface(getOracleAddress()).read());\r\n        uint makerColInUSD = wmul(makerCol, usdPerEth);\r\n        ratio = wdiv(makerDebt, makerColInUSD);\r\n    }\r\n\r\n}\r\n\r\n\r\ncontract CompoundHelper is MakerHelper {\r\n\r\n    event LogMint(address erc20, address cErc20, uint tokenAmt, address owner);\r\n    event LogRedeem(address erc20, address cErc20, uint tokenAmt, address owner);\r\n    event LogBorrow(address erc20, address cErc20, uint tokenAmt, address owner);\r\n    event LogRepay(address erc20, address cErc20, uint tokenAmt, address owner);\r\n\r\n    function isCompoundOk(bytes32 cup, uint ethCol, uint daiAmt) internal returns (bool isOk) {\r\n        uint daiCompOracle = CompOracleInterface(getCompOracleAddress()).getUnderlyingPrice(getCDAIAddress()); // DAI in ETH\r\n        uint debtInEth = wmul(daiAmt, daiCompOracle);\r\n        if (ethCol == 0) {\r\n            (ethCol,) = getCDPStats(cup);\r\n        }\r\n        (, uint totalBorrow, uint maxBorrow,) = getCompRatio(address(this));\r\n        totalBorrow += debtInEth;\r\n        maxBorrow += wmul(ethCol, 750000000000000000);\r\n        isOk = totalBorrow < maxBorrow;\r\n    }\r\n\r\n    /**\r\n     * @dev get user's token supply and borrow in ETH\r\n     */\r\n    function compSupplyBorrow(address cTokenAdd, address user) public returns(uint supplyInEth, uint borrowInEth) {\r\n        CTokenInterface cTokenContract = CTokenInterface(cTokenAdd);\r\n        uint tokenPriceInEth = CompOracleInterface(getCompOracleAddress()).getUnderlyingPrice(cTokenAdd);\r\n        uint cTokenBal = cTokenContract.balanceOf(user);\r\n        uint cTokenExchangeRate = cTokenContract.exchangeRateCurrent();\r\n        uint tokenSupply = wmul(cTokenBal, cTokenExchangeRate);\r\n        supplyInEth = wmul(tokenSupply, tokenPriceInEth);\r\n        uint tokenBorrowed = cTokenContract.borrowBalanceCurrent(user);\r\n        borrowInEth = wmul(tokenBorrowed, tokenPriceInEth);\r\n    }\r\n\r\n    /**\r\n     * @dev get users overall details for Compound\r\n     */\r\n    function getCompRatio(address user) public returns (uint totalSupply, uint totalBorrow, uint maxBorrow, uint ratio) {\r\n        BridgeInterface bridgeContract = BridgeInterface(getBridgeAddress());\r\n        uint arrLength = bridgeContract.cArrLength();\r\n        for (uint i = 0; i < arrLength; i++) {\r\n            (address cTokenAdd, uint factor) = bridgeContract.cTokenAddr(i);\r\n            (uint supplyInEth, uint borrowInEth) = compSupplyBorrow(cTokenAdd, user);\r\n            totalSupply += supplyInEth;\r\n            totalBorrow += borrowInEth;\r\n            maxBorrow += wmul(supplyInEth, factor);\r\n        }\r\n        ratio = wdiv(totalBorrow, totalSupply);\r\n    }\r\n\r\n    /**\r\n     * @dev get users overall and basic stats for Compound\r\n     */\r\n    function getCompoundStats(address user) public returns (uint ethColFree, uint daiDebt, uint totalSupply, uint totalBorrow, uint maxBorrow, uint daiInEth) {\r\n        CTokenInterface cEthContract = CTokenInterface(getCETHAddress());\r\n        CERC20Interface cDaiContract = CERC20Interface(getCDAIAddress());\r\n        uint cEthBal = cEthContract.balanceOf(user);\r\n        uint cEthExchangeRate = cEthContract.exchangeRateCurrent();\r\n        uint ethCol = wmul(cEthBal, cEthExchangeRate);\r\n        ethCol = wdiv(ethCol, cEthExchangeRate) <= cEthBal ? ethCol : ethCol - 1;\r\n        daiDebt = cDaiContract.borrowBalanceCurrent(user);\r\n        daiInEth = CompOracleInterface(getCompOracleAddress()).getUnderlyingPrice(getCDAIAddress());\r\n        uint compRatio;\r\n        (totalSupply, totalBorrow, maxBorrow, compRatio) = getCompRatio(user);\r\n        ethColFree = wdiv(wmul(daiDebt, daiInEth), compRatio);\r\n        if (ethColFree > ethCol) {\r\n            ethColFree = ethCol;\r\n            daiDebt = wdiv(wmul(ethColFree, compRatio), daiInEth);\r\n        }\r\n    }\r\n\r\n    function enterMarket(address cErc20) internal {\r\n        ComptrollerInterface troller = ComptrollerInterface(getComptrollerAddress());\r\n        address[] memory markets = troller.getAssetsIn(address(this));\r\n        bool isEntered = false;\r\n        for (uint i = 0; i < markets.length; i++) {\r\n            if (markets[i] == cErc20) {\r\n                isEntered = true;\r\n            }\r\n        }\r\n        if (!isEntered) {\r\n            address[] memory toEnter = new address[](1);\r\n            toEnter[0] = cErc20;\r\n            troller.enterMarkets(toEnter);\r\n        }\r\n    }\r\n\r\n}\r\n\r\n\r\ncontract MakerResolver is CompoundHelper {\r\n\r\n    function open()  internal returns (bytes32) {\r\n        bytes32 cup = TubInterface(getSaiTubAddress()).open();\r\n        emit LogOpen(uint(cup), address(this));\r\n        return cup;\r\n    }\r\n\r\n    function lock(bytes32 cup, uint ethAmt) internal {\r\n        if (ethAmt > 0) {\r\n            address tubAddr = getSaiTubAddress();\r\n\r\n            TubInterface tub = TubInterface(tubAddr);\r\n            TokenInterface weth = tub.gem();\r\n            TokenInterface peth = tub.skr();\r\n\r\n            weth.deposit.value(ethAmt)();\r\n\r\n            uint ink = rdiv(ethAmt, tub.per());\r\n            ink = rmul(ink, tub.per()) <= ethAmt ? ink : ink - 1;\r\n\r\n            setMakerAllowance(weth, tubAddr);\r\n            tub.join(ink);\r\n\r\n            setMakerAllowance(peth, tubAddr);\r\n            tub.lock(cup, ink);\r\n\r\n            emit LogLock(\r\n                uint(cup),\r\n                ethAmt,\r\n                ink,\r\n                address(this)\r\n            );\r\n        }\r\n    }\r\n\r\n    function free(bytes32 cup, uint jam) internal {\r\n        if (jam > 0) {\r\n            address tubAddr = getSaiTubAddress();\r\n\r\n            TubInterface tub = TubInterface(tubAddr);\r\n            TokenInterface peth = tub.skr();\r\n            TokenInterface weth = tub.gem();\r\n\r\n            uint ink = rdiv(jam, tub.per());\r\n            ink = rmul(ink, tub.per()) <= jam ? ink : ink - 1;\r\n            tub.free(cup, ink);\r\n\r\n            setMakerAllowance(peth, tubAddr);\r\n\r\n            tub.exit(ink);\r\n            uint freeJam = weth.balanceOf(address(this)); // convert previous WETH into ETH as well\r\n            weth.withdraw(freeJam);\r\n\r\n            emit LogFree(\r\n                uint(cup),\r\n                freeJam,\r\n                ink,\r\n                address(this)\r\n            );\r\n        }\r\n    }\r\n\r\n    function draw(bytes32 cup, uint _wad) public {\r\n        if (_wad > 0) {\r\n            TubInterface tub = TubInterface(getSaiTubAddress());\r\n\r\n            tub.draw(cup, _wad);\r\n            TokenInterface dai = tub.sai();\r\n            setMakerAllowance(dai, getBridgeAddress());\r\n            BridgeInterface(getBridgeAddress()).transferBackDAI(_wad);\r\n\r\n            emit LogDraw(uint(cup), _wad, address(this));\r\n        }\r\n    }\r\n\r\n    function wipe(bytes32 cup, uint _wad, uint ethCol) internal returns (uint daiAmt) {\r\n        if (_wad > 0) {\r\n            TubInterface tub = TubInterface(getSaiTubAddress());\r\n            UniswapExchange daiEx = UniswapExchange(getUniswapDAIExchange());\r\n            UniswapExchange mkrEx = UniswapExchange(getUniswapMKRExchange());\r\n            TokenInterface dai = tub.sai();\r\n            TokenInterface mkr = tub.gov();\r\n\r\n            setMakerAllowance(dai, getSaiTubAddress());\r\n            setMakerAllowance(mkr, getSaiTubAddress());\r\n            setMakerAllowance(dai, getUniswapDAIExchange());\r\n\r\n            (bytes32 val, bool ok) = tub.pep().peek();\r\n\r\n            // MKR required for wipe = Stability fees accrued in Dai / MKRUSD value\r\n            uint mkrFeeHelper = rdiv(tub.rap(cup), tub.tab(cup));\r\n            uint mkrFee = wdiv(rmul(_wad, mkrFeeHelper), uint(val));\r\n\r\n            uint daiFeeAmt = daiEx.getTokenToEthOutputPrice(mkrEx.getEthToTokenOutputPrice(mkrFee));\r\n            daiAmt = add(_wad, daiFeeAmt);\r\n\r\n            require(isCompoundOk(cup, ethCol, daiAmt), \"Compound Will Liquidate\");\r\n\r\n            BridgeInterface(getBridgeAddress()).transferDAI(daiAmt);\r\n\r\n            if (ok && val != 0) {\r\n                daiEx.tokenToTokenSwapOutput(\r\n                    mkrFee,\r\n                    daiAmt,\r\n                    uint(999000000000000000000),\r\n                    uint(1899063809), // 6th March 2030 GMT // no logic\r\n                    address(mkr)\r\n                );\r\n            }\r\n\r\n            tub.wipe(cup, _wad);\r\n\r\n            emit LogWipe(\r\n                uint(cup),\r\n                daiAmt,\r\n                mkrFee,\r\n                daiFeeAmt,\r\n                address(this)\r\n            );\r\n\r\n        }\r\n    }\r\n\r\n    function wipeAndFree(bytes32 cup, uint jam, uint _wad) internal returns (uint daiAmt) {\r\n        daiAmt = wipe(cup, _wad, 0);\r\n        free(cup, jam);\r\n    }\r\n\r\n    /**\r\n     * @dev close CDP\r\n     */\r\n    function shut(bytes32 cup) internal returns (uint daiAmt) {\r\n        TubInterface tub = TubInterface(getSaiTubAddress());\r\n        daiAmt = wipeAndFree(cup, rmul(tub.ink(cup), tub.per()), tub.tab(cup));\r\n        tub.shut(cup);\r\n        emit LogShut(uint(cup)); // fetch remaining data from WIPE & FREE events\r\n    }\r\n\r\n}\r\n\r\n\r\ncontract CompoundResolver is MakerResolver {\r\n\r\n    /**\r\n     * @dev Deposit ETH and mint Compound Tokens\r\n     */\r\n    function mintCEth(uint tokenAmt) internal {\r\n        enterMarket(getCETHAddress());\r\n        CETHInterface cToken = CETHInterface(getCETHAddress());\r\n        cToken.mint.value(tokenAmt)();\r\n        emit LogMint(\r\n            getAddressETH(),\r\n            getCETHAddress(),\r\n            tokenAmt,\r\n            msg.sender\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev borrow DAI\r\n     */\r\n    function borrowDAIComp(uint tokenAmt) internal {\r\n        enterMarket(getCDAIAddress());\r\n        require(CTokenInterface(getCDAIAddress()).borrow(tokenAmt) == 0, \"got collateral?\");\r\n        setApproval(getDAIAddress(), tokenAmt, getBridgeAddress());\r\n        BridgeInterface(getBridgeAddress()).transferBackDAI(tokenAmt);\r\n        emit LogBorrow(\r\n            getDAIAddress(),\r\n            getCDAIAddress(),\r\n            tokenAmt,\r\n            address(this)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Pay DAI Debt\r\n     */\r\n    function repayToken(uint tokenAmt) internal {\r\n        CERC20Interface cToken = CERC20Interface(getCDAIAddress());\r\n        BridgeInterface(getBridgeAddress()).transferDAI(tokenAmt);\r\n        setApproval(getDAIAddress(), tokenAmt, getCDAIAddress());\r\n        require(cToken.repayBorrow(tokenAmt) == 0, \"transfer approved?\");\r\n        emit LogRepay(\r\n            getDAIAddress(),\r\n            getCDAIAddress(),\r\n            tokenAmt,\r\n            address(this)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Redeem ETH and mint Compound Tokens\r\n     * @param tokenAmt Amount of token To Redeem\r\n     */\r\n    function redeemUnderlying(uint tokenAmt) internal {\r\n        CTokenInterface cToken = CTokenInterface(getCETHAddress());\r\n        setApproval(getCETHAddress(), 2**128, getCETHAddress());\r\n        require(cToken.redeemUnderlying(tokenAmt) == 0, \"something went wrong\");\r\n        emit LogRedeem(\r\n            getAddressETH(),\r\n            getCETHAddress(),\r\n            tokenAmt,\r\n            address(this)\r\n        );\r\n    }\r\n\r\n}\r\n\r\n\r\ncontract Bridge is CompoundResolver {\r\n\r\n    /**\r\n     * @dev convert Maker CDP into Compound Collateral\r\n     * @param toConvert ranges from 0 to 1 and has (18 decimals)\r\n     */\r\n    function makerToCompound(uint cdpId, uint toConvert) public {\r\n        bytes32 cup = bytes32(cdpId);\r\n        isCupOwner(cup);\r\n        (uint ethCol, uint daiDebt) = getCDPStats(cup);\r\n        uint ethFree = ethCol;\r\n        uint daiAmt = daiDebt;\r\n        if (toConvert < 10**18) {\r\n            uint wipeAmt = wmul(daiDebt, toConvert);\r\n            ethFree = wmul(ethCol, toConvert);\r\n            daiAmt = wipe(cup, wipeAmt, ethFree);\r\n            free(cup, ethFree);\r\n        } else {\r\n            daiAmt = shut(cup);\r\n        }\r\n        mintCEth(ethFree);\r\n        borrowDAIComp(daiAmt);\r\n    }\r\n\r\n    /**\r\n     * @dev convert Compound Collateral into Maker CDP\r\n     * @param cdpId = 0, if user don't have any CDP\r\n     * @param toConvert ranges from 0 to 1 and has (18 decimals)\r\n     */\r\n    function compoundToMaker(uint cdpId, uint toConvert) public {\r\n        bytes32 cup = bytes32(cdpId);\r\n        if (cdpId == 0) {\r\n            cup = open();\r\n        } else {\r\n            require(isCupOwner(cup), \"Not CDP Owner\");\r\n        }\r\n\r\n        (uint ethCol, uint daiDebt,, uint totalBorrow, uint maxBorrow, uint daiInEth) = getCompoundStats(address(this));\r\n        uint ethFree = ethCol;\r\n        uint daiAmt = daiDebt;\r\n        if (toConvert < 10**18) {\r\n            daiAmt = wmul(daiDebt, toConvert);\r\n            ethFree = wmul(ethCol, toConvert);\r\n        }\r\n        uint makerFinalRatio = getMakerRatio(cup, ethFree, daiAmt);\r\n        require(makerFinalRatio < 660000000000000000, \"Maker CDP will liquidate\");\r\n        totalBorrow -= wmul(daiAmt, daiInEth);\r\n        maxBorrow -= wmul(ethFree, 750000000000000000);\r\n        require(totalBorrow < maxBorrow, \"Compound position will liquidate\");\r\n        repayToken(daiAmt);\r\n        redeemUnderlying(ethFree);\r\n        lock(cup, ethFree);\r\n        draw(cup, daiAmt);\r\n    }\r\n\r\n}\r\n\r\n\r\ncontract InstaBridge is Bridge {\r\n\r\n    uint public version;\r\n\r\n    /**\r\n     * @dev setting up variables on deployment\r\n     * 1...2...3 versioning in each subsequent deployments\r\n     */\r\n    constructor(uint _version) public {\r\n        version = _version;\r\n    }\r\n\r\n    function() external payable {}\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"cup\",\"type\":\"bytes32\"},{\"name\":\"ethCol\",\"type\":\"uint256\"},{\"name\":\"daiDebt\",\"type\":\"uint256\"}],\"name\":\"getMakerRatio\",\"outputs\":[{\"name\":\"ratio\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"cup\",\"type\":\"bytes32\"},{\"name\":\"_wad\",\"type\":\"uint256\"}],\"name\":\"draw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getComptrollerAddress\",\"outputs\":[{\"name\":\"troller\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"cdpId\",\"type\":\"uint256\"},{\"name\":\"toConvert\",\"type\":\"uint256\"}],\"name\":\"makerToCompound\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getCompoundStats\",\"outputs\":[{\"name\":\"ethColFree\",\"type\":\"uint256\"},{\"name\":\"daiDebt\",\"type\":\"uint256\"},{\"name\":\"totalSupply\",\"type\":\"uint256\"},{\"name\":\"totalBorrow\",\"type\":\"uint256\"},{\"name\":\"maxBorrow\",\"type\":\"uint256\"},{\"name\":\"daiInEth\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCompOracleAddress\",\"outputs\":[{\"name\":\"troller\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"cdpNum\",\"type\":\"uint256\"}],\"name\":\"getCDPBytes\",\"outputs\":[{\"name\":\"cup\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getUniswapMKRExchange\",\"outputs\":[{\"name\":\"ume\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAddressETH\",\"outputs\":[{\"name\":\"eth\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getOracleAddress\",\"outputs\":[{\"name\":\"oracle\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"cdpId\",\"type\":\"uint256\"},{\"name\":\"toConvert\",\"type\":\"uint256\"}],\"name\":\"compoundToMaker\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getCompRatio\",\"outputs\":[{\"name\":\"totalSupply\",\"type\":\"uint256\"},{\"name\":\"totalBorrow\",\"type\":\"uint256\"},{\"name\":\"maxBorrow\",\"type\":\"uint256\"},{\"name\":\"ratio\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCETHAddress\",\"outputs\":[{\"name\":\"cEth\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"cup\",\"type\":\"bytes32\"}],\"name\":\"getCDPStats\",\"outputs\":[{\"name\":\"ethCol\",\"type\":\"uint256\"},{\"name\":\"daiDebt\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getUniswapDAIExchange\",\"outputs\":[{\"name\":\"ude\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getDAIAddress\",\"outputs\":[{\"name\":\"dai\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getSaiTubAddress\",\"outputs\":[{\"name\":\"sai\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"cTokenAdd\",\"type\":\"address\"},{\"name\":\"user\",\"type\":\"address\"}],\"name\":\"compSupplyBorrow\",\"outputs\":[{\"name\":\"supplyInEth\",\"type\":\"uint256\"},{\"name\":\"borrowInEth\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCDAIAddress\",\"outputs\":[{\"name\":\"cDai\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getBridgeAddress\",\"outputs\":[{\"name\":\"bridge\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_version\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"erc20\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"cErc20\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokenAmt\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"LogMint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"erc20\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"cErc20\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokenAmt\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"LogRedeem\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"erc20\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"cErc20\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokenAmt\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"LogBorrow\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"erc20\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"cErc20\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokenAmt\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"LogRepay\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"cdpNum\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"LogOpen\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"cdpNum\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amtETH\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amtPETH\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"LogLock\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"cdpNum\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amtETH\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amtPETH\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"LogFree\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"cdpNum\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amtDAI\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"LogDraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"cdpNum\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"daiAmt\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"mkrFee\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"daiFee\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"LogWipe\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"cdpNum\",\"type\":\"uint256\"}],\"name\":\"LogShut\",\"type\":\"event\"}]","ContractName":"InstaBridge","CompilerVersion":"v0.5.8+commit.23d335f2","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"0000000000000000000000000000000000000000000000000000000000000001","Library":"","SwarmSource":"bzzr://2e8f2ef17c82a65198779db82fa67d2ddd4d9c491e2e8c19f810a17b1bbe824b"}]}