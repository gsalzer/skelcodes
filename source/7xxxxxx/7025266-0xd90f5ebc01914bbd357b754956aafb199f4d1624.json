{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\n/// @title New Child Kydy's Genes\r\ncontract GeneSynthesisInterface {\r\n    /// @dev boolean to check this is the contract we expect to be\r\n    function isGeneSynthesis() public pure returns (bool);\r\n\r\n    /**\r\n     * @dev Synthesizes the genes of yin and yang Kydy, and returns the result as the child's genes. \r\n     * @param gene1 genes of yin Kydy\r\n     * @param gene2 genes of yang Kydy\r\n     * @return the genes of the child\r\n     */\r\n    function synthGenes(uint256 gene1, uint256 gene2) public returns (uint256);\r\n}\r\n\r\n/**\r\n * @title Part of KydyCore that manages special access controls.\r\n * @author VREX Lab Co., Ltd\r\n * @dev See the KydyCore contract documentation to understand how the various contracts are arranged.\r\n */\r\ncontract KydyAccessControl {\r\n    /**\r\n     * This contract defines access control for the following important roles of the Dyverse:\r\n     *\r\n     *     - The CEO: The CEO can assign roles and change the addresses of the smart contracts. \r\n     *         It can also solely unpause the smart contract. \r\n     *\r\n     *     - The CFO: The CFO can withdraw funds from the KydyCore and the auction contracts.\r\n     *\r\n     *     - The COO: The COO can release Generation 0 Kydys and create promotional-type Kydys.\r\n     *\r\n     */\r\n\r\n    /// @dev Used when contract is upgraded. \r\n    event ContractUpgrade(address newContract);\r\n\r\n    // The assigned addresses of each role, as defined in this contract. \r\n    address public ceoAddress;\r\n    address public cfoAddress;\r\n    address public cooAddress;\r\n\r\n    /// @dev Checks if the contract is paused. When paused, most of the functions of this contract will also be stopped.\r\n    bool public paused = false;\r\n\r\n    /// @dev Access modifier for CEO-only\r\n    modifier onlyCEO() {\r\n        require(msg.sender == ceoAddress);\r\n        _;\r\n    }\r\n\r\n    /// @dev Access modifier for CFO-only\r\n    modifier onlyCFO() {\r\n        require(msg.sender == cfoAddress);\r\n        _;\r\n    }\r\n\r\n    /// @dev Access modifier for COO-only\r\n    modifier onlyCOO() {\r\n        require(msg.sender == cooAddress);\r\n        _;\r\n    }\r\n\r\n    /// @dev Access modifier for CEO, CFO, COO\r\n    modifier onlyCLevel() {\r\n        require(\r\n            msg.sender == ceoAddress ||\r\n            msg.sender == cfoAddress ||\r\n            msg.sender == cooAddress\r\n        );\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Assigns a new address to the CEO. Only the current CEO has the authority.\r\n     * @param _newCEO The address of the new CEO\r\n     */\r\n    function setCEO(address _newCEO) external onlyCEO {\r\n        require(_newCEO != address(0));\r\n\r\n        ceoAddress = _newCEO;\r\n    }\r\n\r\n    /**\r\n     * @dev Assigns a new address to the CFO. Only the current CEO has the authority.\r\n     * @param _newCFO The address of the new CFO\r\n     */\r\n    function setCFO(address _newCFO) external onlyCEO {\r\n        require(_newCFO != address(0));\r\n\r\n        cfoAddress = _newCFO;\r\n    }\r\n\r\n    /**\r\n     * @dev Assigns a new address to the COO. Only the current CEO has the authority.\r\n     * @param _newCOO The address of the new COO\r\n     */\r\n    function setCOO(address _newCOO) external onlyCEO {\r\n        require(_newCOO != address(0));\r\n\r\n        cooAddress = _newCOO;\r\n    }\r\n\r\n    /*** Pausable functionality adapted from OpenZeppelin ***/\r\n\r\n    /// @dev Modifier to allow actions only when the contract IS NOT paused\r\n    modifier whenNotPaused() {\r\n        require(!paused);\r\n        _;\r\n    }\r\n\r\n    /// @dev Modifier to allow actions only when the contract IS paused\r\n    modifier whenPaused {\r\n        require(paused);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Called by any \"C-level\" role to pause the contract. Used only when\r\n     *  a bug or exploit is detected to limit the damage.\r\n     */\r\n    function pause() external onlyCLevel whenNotPaused {\r\n        paused = true;\r\n    }\r\n\r\n    /**\r\n     * @dev Unpauses the smart contract. Can only be called by the CEO, since\r\n     *  one reason we may pause the contract is when CFO or COO accounts are\r\n     *  compromised.\r\n     * @notice This is public rather than external so it can be called by\r\n     *  derived contracts.\r\n     */\r\n    function unpause() public onlyCEO whenPaused {\r\n        // can't unpause if contract was upgraded\r\n        paused = false;\r\n    }\r\n}\r\n\r\ncontract ERC165Interface {\r\n    /**\r\n     * @notice Query if a contract implements an interface\r\n     * @param interfaceID The interface identifier, as specified in ERC-165\r\n     * @dev Interface identification is specified in ERC-165. This function\r\n     *  uses less than 30,000 gas.\r\n     * @return `true` if the contract implements `interfaceID` and\r\n     *  `interfaceID` is not 0xffffffff, `false` otherwise\r\n     */\r\n    function supportsInterface(bytes4 interfaceID) external view returns (bool);\r\n}\r\n\r\ncontract ERC165 is ERC165Interface {\r\n    /**\r\n     * @dev a mapping of interface id to whether or not it's supported\r\n     */\r\n    mapping(bytes4 => bool) private _supportedInterfaces;\r\n\r\n    /**\r\n     * @dev implement supportsInterface(bytes4) using a lookup table\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool) {\r\n        return _supportedInterfaces[interfaceId];\r\n    }\r\n\r\n    /**\r\n     * @dev internal method for registering an interface\r\n     */\r\n    function _registerInterface(bytes4 interfaceId) internal {\r\n        require(interfaceId != 0xffffffff);\r\n        _supportedInterfaces[interfaceId] = true;\r\n    }\r\n}\r\n\r\n// Every ERC-721 compliant contract must implement the ERC721 and ERC165 interfaces.\r\n/** \r\n * @title ERC-721 Non-Fungible Token Standard\r\n * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\r\n * Note: the ERC-165 identifier for this interface is 0x80ac58cd.\r\n */\r\ncontract ERC721Basic is ERC165 {\r\n    // Below is MUST\r\n\r\n    /**\r\n     * @dev This emits when ownership of any NFT changes by any mechanism.\r\n     *  This event emits when NFTs are created (`from` == 0) and destroyed\r\n     *  (`to` == 0). Exception: during contract creation, any number of NFTs\r\n     *  may be created and assigned without emitting Transfer. At the time of\r\n     *  any transfer, the approved address for that NFT (if any) is reset to none.\r\n     */\r\n    event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);\r\n\r\n    /**\r\n     * @dev This emits when the approved address for an NFT is changed or\r\n     *  reaffirmed. The zero address indicates there is no approved address.\r\n     *  When a Transfer event emits, this also indicates that the approved\r\n     *  address for that NFT (if any) is reset to none.\r\n     */\r\n    event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);\r\n\r\n    /**\r\n     * @dev This emits when an operator is enabled or disabled for an owner.\r\n     *  The operator can manage all NFTs of the owner.\r\n     */\r\n    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\r\n\r\n    /**\r\n     * @notice Count all NFTs assigned to an owner\r\n     * @dev NFTs assigned to the zero address are considered invalid, and this\r\n     *  function throws for queries about the zero address.\r\n     * @param _owner An address for whom to query the balance\r\n     * @return The number of NFTs owned by `_owner`, possibly zero\r\n     */\r\n    function balanceOf(address _owner) public view returns (uint256);\r\n\r\n    /**\r\n     * @notice Find the owner of an NFT\r\n     * @dev NFTs assigned to zero address are considered invalid, and queries\r\n     *  about them do throw.\r\n     * @param _tokenId The identifier for an NFT\r\n     * @return The address of the owner of the NFT\r\n     */\r\n    function ownerOf(uint256 _tokenId) public view returns (address);\r\n\r\n    /**\r\n     * @notice Transfers the ownership of an NFT from one address to another address\r\n     * @dev Throws unless `msg.sender` is the current owner, an authorized\r\n     *  operator, or the approved address for this NFT. Throws if `_from` is\r\n     *  not the current owner. Throws if `_to` is the zero address. Throws if\r\n     *  `_tokenId` is not a valid NFT. When transfer is complete, this function\r\n     *  checks if `_to` is a smart contract (code size > 0). If so, it calls\r\n     *  `onERC721Received` on `_to` and throws if the return value is not\r\n     *  `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`.\r\n     * @param _from The current owner of the NFT\r\n     * @param _to The new owner\r\n     * @param _tokenId The NFT to transfer\r\n     * @param data Additional data with no specified format, sent in call to `_to`\r\n     */\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes data) public;\r\n\r\n    /**\r\n     * @notice Transfers the ownership of an NFT from one address to another address\r\n     * @dev This works identically to the other function with an extra data parameter,\r\n     *  except this function just sets data to \"\".\r\n     * @param _from The current owner of the NFT\r\n     * @param _to The new owner\r\n     * @param _tokenId The NFT to transfer\r\n     */\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId) public;\r\n\r\n    /**\r\n     * @notice Transfer ownership of an NFT -- THE CALLER IS RESPONSIBLE\r\n     *  TO CONFIRM THAT `_to` IS CAPABLE OF RECEIVING NFTS OR ELSE\r\n     *  THEY MAY BE PERMANENTLY LOST\r\n     * @dev Throws unless `msg.sender` is the current owner, an authorized\r\n     *  operator, or the approved address for this NFT. Throws if `_from` is\r\n     *  not the current owner. Throws if `_to` is the zero address. Throws if\r\n     *  `_tokenId` is not a valid NFT.\r\n     * @param _from The current owner of the NFT\r\n     * @param _to The new owner\r\n     * @param _tokenId The NFT to transfer\r\n     */\r\n    function transferFrom(address _from, address _to, uint256 _tokenId) public;\r\n\r\n    /**\r\n     * @notice Change or reaffirm the approved address for an NFT\r\n     * @dev The zero address indicates there is no approved address.\r\n     *  Throws unless `msg.sender` is the current NFT owner, or an authorized\r\n     *  operator of the current owner.\r\n     * @param _approved The new approved NFT controller\r\n     * @param _tokenId The NFT to approve\r\n     */\r\n    function approve(address _approved, uint256 _tokenId) external;\r\n\r\n    /**\r\n     * @notice Enable or disable approval for a third party (\"operator\") to manage\r\n     *  all of `msg.sender`'s assets\r\n     * @dev Emits the ApprovalForAll event. The contract MUST allow\r\n     *  multiple operators per owner.\r\n     * @param _operator Address to add to the set of authorized operators\r\n     * @param _approved True if the operator is approved, false to revoke approval\r\n     */\r\n    function setApprovalForAll(address _operator, bool _approved) external;\r\n\r\n    /**\r\n     * @notice Get the approved address for a single NFT\r\n     * @dev Throws if `_tokenId` is not a valid NFT.\r\n     * @param _tokenId The NFT to find the approved address for\r\n     * @return The approved address for this NFT, or the zero address if there is none\r\n     */\r\n    function getApproved(uint256 _tokenId) public view returns (address);\r\n\r\n    /**\r\n     * @notice Query if an address is an authorized operator for another address\r\n     * @param _owner The address that owns the NFTs\r\n     * @param _operator The address that acts on behalf of the owner\r\n     * @return True if `_operator` is an approved operator for `_owner`, false otherwise\r\n     */\r\n    function isApprovedForAll(address _owner, address _operator) public view returns (bool);\r\n\r\n    // Below is OPTIONAL\r\n\r\n    // ERC721Metadata\r\n    // The metadata extension is OPTIONAL for ERC-721 smart contracts (see \"caveats\", below). This allows your smart contract to be interrogated for its name and for details about the assets which your NFTs represent.\r\n    \r\n    /**\r\n     * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\r\n     * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\r\n     *  Note: the ERC-165 identifier for this interface is 0x5b5e139f.\r\n     */\r\n\r\n    /// @notice A descriptive name for a collection of NFTs in this contract\r\n    function name() external view returns (string _name);\r\n\r\n    /// @notice An abbreviated name for NFTs in this contract\r\n    function symbol() external view returns (string _symbol);\r\n\r\n    /**\r\n     * @notice A distinct Uniform Resource Identifier (URI) for a given asset.\r\n     * @dev Throws if `_tokenId` is not a valid NFT. URIs are defined in RFC\r\n     *  3986. The URI may point to a JSON file that conforms to the \"ERC721\r\n     *  Metadata JSON Schema\".\r\n     */\r\n    function tokenURI(uint256 _tokenId) external view returns (string);\r\n\r\n    // ERC721Enumerable\r\n    // The enumeration extension is OPTIONAL for ERC-721 smart contracts (see \"caveats\", below). This allows your contract to publish its full list of NFTs and make them discoverable.\r\n\r\n    /**\r\n     * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\r\n     * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\r\n     *  Note: the ERC-165 identifier for this interface is 0x780e9d63.\r\n     */\r\n\r\n    /**\r\n     * @notice Count NFTs tracked by this contract\r\n     * @return A count of valid NFTs tracked by this contract, where each one of\r\n     *  them has an assigned and queryable owner not equal to the zero address\r\n     */\r\n    function totalSupply() public view returns (uint256);\r\n}\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n    * @dev Multiplies two numbers, reverts on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, reverts on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\r\n    * reverts when dividing by zero.\r\n    */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n/**\r\n * Utility library of inline functions on addresses\r\n */\r\nlibrary Address {\r\n    /**\r\n     * Returns whether the target address is a contract\r\n     * @dev This function will return false if invoked during the constructor of a contract,\r\n     * as the code is not actually created until after the constructor finishes.\r\n     * @param account address of the account to check\r\n     * @return whether the target address is a contract\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        uint256 size;\r\n        // XXX Currently there is no better way to check if there is a contract in an address\r\n        // than to check the size of the code at that address.\r\n        // See https://ethereum.stackexchange.com/a/14016/36603\r\n        // for more details about how this works.\r\n        // TODO Check this again before the Serenity release, because all addresses will be\r\n        // contracts then.\r\n        // solium-disable-next-line security/no-inline-assembly\r\n        assembly { size := extcodesize(account) }\r\n        return size > 0;\r\n    }\r\n}\r\n\r\n/**\r\n * @title The base contract of Dyverse. ERC-721 compliant.\r\n * @author VREX Lab Co., Ltd\r\n * @dev See the KydyCore contract for more info on details. \r\n */\r\ncontract KydyBase is KydyAccessControl, ERC721Basic {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n\r\n    /*** EVENT ***/\r\n\r\n    /**\r\n     * @dev The Creation event takes place whenever a new Kydy is created via Synthesis or minted by the COO.  \r\n     */\r\n    event Created(address indexed owner, uint256 kydyId, uint256 yinId, uint256 yangId, uint256 genes);\r\n\r\n    /*** DATA TYPES ***/\r\n\r\n    /**\r\n     * @dev Every Kydy in the Dyverse is a copy of this structure. \r\n     */\r\n    struct Kydy {\r\n        // The Kydy's genetic code is stored into 256-bits and never changes.\r\n        uint256 genes;\r\n\r\n        // The timestamp of the block when this Kydy was created\r\n        uint64 createdTime;\r\n\r\n        // The timestamp of when this Kydy can synthesize again.\r\n        uint64 rechargeEndBlock;\r\n\r\n        // The ID of the parents (Yin, female, and Yang, male). It is 0 for Generation 0 Kydys.\r\n        uint32 yinId;\r\n        uint32 yangId;\r\n\r\n        // The ID of the yang Kydy that the yin Kydy is creating with. \r\n        uint32 synthesizingWithId;\r\n\r\n        // The recharge index that represents the duration of the recharge for this Kydy. \r\n        // After each synthesis, this increases by one for both yin and yang Kydys of the synthesis. \r\n        uint16 rechargeIndex;\r\n\r\n        // The generation index of this Kydy. The newly created Kydy takes the generation index of the parent \r\n        // with a larger generation index. \r\n        uint16 generation;\r\n    }\r\n\r\n    /*** CONSTANTS ***/\r\n\r\n    /**\r\n     * @dev An array table of the recharge duration. Referred to as \"creation time\" for yin \r\n     *  and \"synthesis recharge\" for yang Kydys. Maximum duration is 4 days. \r\n     */\r\n    uint32[14] public recharges = [\r\n        uint32(1 minutes),\r\n        uint32(2 minutes),\r\n        uint32(5 minutes),\r\n        uint32(10 minutes),\r\n        uint32(30 minutes),\r\n        uint32(1 hours),\r\n        uint32(2 hours),\r\n        uint32(4 hours),\r\n        uint32(8 hours),\r\n        uint32(16 hours),\r\n        uint32(1 days),\r\n        uint32(2 days),\r\n        uint32(4 days)\r\n    ];\r\n\r\n    // An approximation of seconds between blocks.\r\n    uint256 public secondsPerBlock = 15;\r\n\r\n    /*** STORAGE ***/\r\n\r\n    /**\r\n     * @dev This array contains the ID of every Kydy as an index. \r\n     */\r\n    Kydy[] kydys;\r\n\r\n    /**\r\n     * @dev This maps each Kydy ID to the address of the owner. Every Kydy must have an owner, even Gen 0 Kydys.\r\n     *  You can view this mapping via `ownerOf()`.\r\n     */\r\n    mapping (uint256 => address) internal kydyIndexToOwner;\r\n\r\n    /**\r\n     * @dev This maps the owner's address to the number of Kydys that the address owns.\r\n     *  You can view this mapping via `balanceOf()`.\r\n     */\r\n    mapping (address => uint256) internal ownershipTokenCount;\r\n\r\n    /**\r\n     * @dev This maps transferring Kydy IDs to the the approved address to call safeTransferFrom().\r\n     *  You can view this mapping via `getApproved()`.\r\n     */\r\n    mapping (uint256 => address) internal kydyIndexToApproved;\r\n\r\n    /**\r\n     * @dev This maps KydyIDs to the address approved to synthesize via synthesizeWithAuto().\r\n     *  You can view this mapping via `getSynthesizeApproved()`.\r\n     */\r\n    mapping (uint256 => address) internal synthesizeAllowedToAddress;\r\n\r\n    /**\r\n     * @dev This maps the owner to operator approvals, for the usage of setApprovalForAll().\r\n     */\r\n    mapping (address => mapping (address => bool)) private _operatorApprovals;\r\n\r\n    /**\r\n     * @dev Returns the owner of the given Kydy ID. Required for ERC-721 compliance.\r\n     * @param _tokenId uint256 ID of the Kydy in query\r\n     * @return the address of the owner of the given Kydy ID\r\n     */\r\n    function ownerOf(uint256 _tokenId) public view returns (address) {\r\n        address owner = kydyIndexToOwner[_tokenId];\r\n        require(owner != address(0));\r\n        return owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the approved address of the receiving owner for a Kydy ID. Required for ERC-721 compliance.\r\n     * @param tokenId uint256 ID of the Kydy in query\r\n     * @return the address of the approved, receiving owner for the given Kydy ID\r\n     */\r\n    function getApproved(uint256 tokenId) public view returns (address) {\r\n        require(_exists(tokenId));\r\n        return kydyIndexToApproved[tokenId];\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the synthesize approved address of the Kydy ID.\r\n     * @param tokenId uint256 ID of the Kydy in query\r\n     * @return the address of the synthesizing approved of the given Kydy ID\r\n     */\r\n    function getSynthesizeApproved(uint256 tokenId) external view returns (address) {\r\n        require(_exists(tokenId));\r\n        return synthesizeAllowedToAddress[tokenId];\r\n    }\r\n\r\n    /**\r\n     * @dev Returns whether an operator is approved by the owner. Required for ERC-721 compliance.\r\n     * @param owner owner address to check whether it is approved\r\n     * @param operator operator address to check whether it is approved\r\n     * @return bool whether the operator is approved or not\r\n     */\r\n    function isApprovedForAll(address owner, address operator) public view returns (bool) {\r\n        return _operatorApprovals[owner][operator];\r\n    }\r\n\r\n    /**\r\n     * @dev Sets or unsets the approval of the operator. Required for ERC-721 compliance.\r\n     * @param to operator address to set the approval\r\n     * @param approved the status to be set\r\n     */\r\n    function setApprovalForAll(address to, bool approved) external {\r\n        require(to != msg.sender);\r\n        _operatorApprovals[msg.sender][to] = approved;\r\n        emit ApprovalForAll(msg.sender, to, approved);\r\n    }\r\n\r\n    /// @dev Assigns ownership of this Kydy to an address.\r\n    function _transfer(address _from, address _to, uint256 _tokenId) internal {\r\n        ownershipTokenCount[_to] = ownershipTokenCount[_to].add(1);\r\n        // Transfers the ownership of this Kydy.\r\n        kydyIndexToOwner[_tokenId] = _to;\r\n\r\n        ownershipTokenCount[_from] = ownershipTokenCount[_from].sub(1);\r\n        // After a transfer, synthesis allowance is also reset.\r\n        delete synthesizeAllowedToAddress[_tokenId];\r\n        // Clears any previously approved transfer.\r\n        delete kydyIndexToApproved[_tokenId];\r\n\r\n        // Emit the transfer event.\r\n        emit Transfer(_from, _to, _tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns whether the given Kydy ID exists\r\n     * @param _tokenId uint256 ID of the Kydy in query\r\n     * @return whether the Kydy exists\r\n     */\r\n    function _exists(uint256 _tokenId) internal view returns (bool) {\r\n        address owner = kydyIndexToOwner[_tokenId];\r\n        return owner != address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns whether the given spender can transfer the Kydy ID\r\n     * @param _spender address of the spender to query\r\n     * @param _tokenId uint256 ID of the Kydy to be transferred\r\n     * @return bool whether the msg.sender is approved\r\n     */\r\n    function _isApprovedOrOwner(address _spender, uint256 _tokenId) internal view returns (bool) {\r\n        address owner = ownerOf(_tokenId);\r\n        // Disable solium check because of\r\n        // https://github.com/duaraghav8/Solium/issues/175\r\n        // solium-disable-next-line operator-whitespace\r\n        return (_spender == owner || getApproved(_tokenId) == _spender || isApprovedForAll(owner, _spender));\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to add a Kydy ID to the new owner's list.\r\n     * @param _to address the new owner's address\r\n     * @param _tokenId uint256 ID of the transferred Kydy \r\n     */\r\n    function _addTokenTo(address _to, uint256 _tokenId) internal {\r\n        // Checks if the owner of the Kydy is 0x0 before the transfer.\r\n        require(kydyIndexToOwner[_tokenId] == address(0));\r\n        // Transfers the ownership to the new owner.\r\n        kydyIndexToOwner[_tokenId] = _to;\r\n        // Increases the total Kydy count of the new owner.\r\n        ownershipTokenCount[_to] = ownershipTokenCount[_to].add(1);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to remove a Kydy ID from the previous owner's list.\r\n     * @param _from address the previous owner's address\r\n     * @param _tokenId uint256 ID of the transferred Kydy \r\n     */\r\n    function _removeTokenFrom(address _from, uint256 _tokenId) internal {\r\n        // Checks the current owner of the Kydy is '_from'.\r\n        require(ownerOf(_tokenId) == _from);\r\n        // Reduces the total Kydy count of the previous owner.\r\n        ownershipTokenCount[_from] = ownershipTokenCount[_from].sub(1);\r\n        // Deletes the transferred Kydy from the current owner's list.\r\n        kydyIndexToOwner[_tokenId] = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to mint a new Kydy.\r\n     * @param _to The address that owns the newly minted Kydy\r\n     * @param _tokenId uint256 ID of the newly minted Kydy\r\n     */\r\n    function _mint(address _to, uint256 _tokenId) internal {\r\n        require(!_exists(_tokenId));\r\n        _addTokenTo(_to, _tokenId);\r\n        emit Transfer(address(0), _to, _tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to clear current approvals of a given Kydy ID.\r\n     * @param _owner owner of the Kydy\r\n     * @param _tokenId uint256 ID of the Kydy to be transferred\r\n     */\r\n    function _clearApproval(address _owner, uint256 _tokenId) internal {\r\n        require(ownerOf(_tokenId) == _owner);\r\n        if (kydyIndexToApproved[_tokenId] != address(0)) {\r\n            kydyIndexToApproved[_tokenId] = address(0);\r\n        }\r\n        if (synthesizeAllowedToAddress[_tokenId] != address(0)) {\r\n            synthesizeAllowedToAddress[_tokenId] = address(0);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function that creates a new Kydy and stores it. \r\n     * @param _yinId The ID of the yin Kydy (zero for Generation 0 Kydy)\r\n     * @param _yangId The ID of the yang Kydy (zero for Generation 0 Kydy)\r\n     * @param _generation The generation number of the new Kydy.\r\n     * @param _genes The Kydy's gene code\r\n     * @param _owner The owner of this Kydy, must be non-zero (except for the ID 0)\r\n     */\r\n    function _createKydy(\r\n        uint256 _yinId,\r\n        uint256 _yangId,\r\n        uint256 _generation,\r\n        uint256 _genes,\r\n        address _owner\r\n    )\r\n        internal\r\n        returns (uint)\r\n    {\r\n        require(_yinId == uint256(uint32(_yinId)));\r\n        require(_yangId == uint256(uint32(_yangId)));\r\n        require(_generation == uint256(uint16(_generation)));\r\n\r\n        // New Kydy's recharge index is its generation / 2.\r\n        uint16 rechargeIndex = uint16(_generation / 2);\r\n        if (rechargeIndex > 13) {\r\n            rechargeIndex = 13;\r\n        }\r\n\r\n        Kydy memory _kyd = Kydy({\r\n            genes: _genes,\r\n            createdTime: uint64(now),\r\n            rechargeEndBlock: 0,\r\n            yinId: uint32(_yinId),\r\n            yangId: uint32(_yangId),\r\n            synthesizingWithId: 0,\r\n            rechargeIndex: rechargeIndex,\r\n            generation: uint16(_generation)\r\n        });\r\n        uint256 newbabyKydyId = kydys.push(_kyd) - 1;\r\n\r\n        // Just in case.\r\n        require(newbabyKydyId == uint256(uint32(newbabyKydyId)));\r\n\r\n        // Emits the Created event.\r\n        emit Created(\r\n            _owner,\r\n            newbabyKydyId,\r\n            uint256(_kyd.yinId),\r\n            uint256(_kyd.yangId),\r\n            _kyd.genes\r\n        );\r\n\r\n        // Here grants ownership, and also emits the Transfer event.\r\n        _mint(_owner, newbabyKydyId);\r\n\r\n        return newbabyKydyId;\r\n    }\r\n\r\n    // Any C-level roles can change the seconds per block\r\n    function setSecondsPerBlock(uint256 secs) external onlyCLevel {\r\n        require(secs < recharges[0]);\r\n        secondsPerBlock = secs;\r\n    }\r\n}\r\n\r\n/**\r\n * @notice This is MUST to be implemented.\r\n *  A wallet/broker/auction application MUST implement the wallet interface if it will accept safe transfers.\r\n * @dev Note: the ERC-165 identifier for this interface is 0x150b7a02.\r\n */\r\ncontract ERC721TokenReceiver {\r\n    /**\r\n     * @notice Handle the receipt of an NFT\r\n     * @dev The ERC721 smart contract calls this function on the recipient\r\n     *  after a `transfer`. This function MAY throw to revert and reject the\r\n     *  transfer. Return of other than the magic value MUST result in the\r\n     *  transaction being reverted.\r\n     *  Note: the contract address is always the message sender.\r\n     * @param _operator The address which called `safeTransferFrom` function\r\n     * @param _from The address which previously owned the token\r\n     * @param _tokenId The NFT identifier which is being transferred\r\n     * @param _data Additional data with no specified format\r\n     * @return `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\r\n     *  unless throwing\r\n     */\r\n    function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes _data) public returns (bytes4);\r\n}\r\n\r\n// File: contracts/lib/Strings.sol\r\n\r\nlibrary Strings {\r\n    // via https://github.com/oraclize/ethereum-api/blob/master/oraclizeAPI_0.5.sol\r\n    function strConcat(string _a, string _b, string _c, string _d, string _e) internal pure returns (string) {\r\n        bytes memory _ba = bytes(_a);\r\n        bytes memory _bb = bytes(_b);\r\n        bytes memory _bc = bytes(_c);\r\n        bytes memory _bd = bytes(_d);\r\n        bytes memory _be = bytes(_e);\r\n        string memory abcde = new string(_ba.length + _bb.length + _bc.length + _bd.length + _be.length);\r\n        bytes memory babcde = bytes(abcde);\r\n        uint k = 0;\r\n        for (uint i = 0; i < _ba.length; i++) babcde[k++] = _ba[i];\r\n        for (i = 0; i < _bb.length; i++) babcde[k++] = _bb[i];\r\n        for (i = 0; i < _bc.length; i++) babcde[k++] = _bc[i];\r\n        for (i = 0; i < _bd.length; i++) babcde[k++] = _bd[i];\r\n        for (i = 0; i < _be.length; i++) babcde[k++] = _be[i];\r\n        return string(babcde);\r\n    }\r\n\r\n    function strConcat(string _a, string _b, string _c, string _d) internal pure returns (string) {\r\n        return strConcat(_a, _b, _c, _d, \"\");\r\n    }\r\n\r\n    function strConcat(string _a, string _b, string _c) internal pure returns (string) {\r\n        return strConcat(_a, _b, _c, \"\", \"\");\r\n    }\r\n\r\n    function strConcat(string _a, string _b) internal pure returns (string) {\r\n        return strConcat(_a, _b, \"\", \"\", \"\");\r\n    }\r\n\r\n    function uint2str(uint i) internal pure returns (string) {\r\n        if (i == 0) return \"0\";\r\n        uint j = i;\r\n        uint len;\r\n        while (j != 0){\r\n            len++;\r\n            j /= 10;\r\n        }\r\n        bytes memory bstr = new bytes(len);\r\n        uint k = len - 1;\r\n        while (i != 0){\r\n            bstr[k--] = byte(48 + i % 10);\r\n            i /= 10;\r\n        }\r\n        return string(bstr);\r\n    }\r\n}\r\n\r\n/**\r\n * @title Part of the KydyCore contract that manages ownership, ERC-721 compliant.\r\n * @author VREX Lab Co., Ltd\r\n * @dev Ref: https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\r\n *  See the KydyCore contract documentation to understand how the various contracts are arranged.\r\n */\r\ncontract KydyOwnership is KydyBase {\r\n    using Strings for string;\r\n\r\n    /// @notice Name and symbol of the non fungible token, as defined in ERC721.\r\n    string public constant _name = \"Dyverse\";\r\n    string public constant _symbol = \"KYDY\";\r\n\r\n    // Base Server Address for Token MetaData URI\r\n    string internal tokenURIBase = \"http://testapi.dyver.se/api/KydyMetadata/\";\r\n\r\n    // Equals to `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\r\n    // which can be also obtained as `ERC721TokenReceiver(0).onERC721Received.selector`\r\n    bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;\r\n\r\n    bytes4 private constant _InterfaceId_ERC165 = 0x01ffc9a7;\r\n    /**\r\n     * 0x01ffc9a7 ===\r\n     *     bytes4(keccak256('supportsInterface(bytes4)'))\r\n     */\r\n\r\n    bytes4 private constant _InterfaceId_ERC721 = 0x80ac58cd;\r\n    /*\r\n     * 0x80ac58cd ===\r\n     *     bytes4(keccak256('balanceOf(address)')) ^\r\n     *     bytes4(keccak256('ownerOf(uint256)')) ^\r\n     *     bytes4(keccak256('approve(address,uint256)')) ^\r\n     *     bytes4(keccak256('getApproved(uint256)')) ^\r\n     *     bytes4(keccak256('setApprovalForAll(address,bool)')) ^\r\n     *     bytes4(keccak256('isApprovedForAll(address,address)')) ^\r\n     *     bytes4(keccak256('transferFrom(address,address,uint256)')) ^\r\n     *     bytes4(keccak256('safeTransferFrom(address,address,uint256)')) ^\r\n     *     bytes4(keccak256('safeTransferFrom(address,address,uint256,bytes)'))\r\n     */\r\n\r\n    bytes4 private constant _InterfaceId_ERC721Metadata = 0x5b5e139f;\r\n    /**\r\n     * 0x5b5e139f ===\r\n     *     bytes4(keccak256('name()')) ^\r\n     *     bytes4(keccak256('symbol()')) ^\r\n     *     bytes4(keccak256('tokenURI(uint256)'))\r\n     */\r\n\r\n    constructor() public {\r\n        _registerInterface(_InterfaceId_ERC165);\r\n        // register the supported interfaces to conform to ERC721 via ERC165\r\n        _registerInterface(_InterfaceId_ERC721);\r\n        // register the supported interfaces to conform to ERC721 via ERC165\r\n        _registerInterface(_InterfaceId_ERC721Metadata);\r\n    }\r\n\r\n    /**\r\n     * @dev Checks if a given address is the current owner of this Kydy.\r\n     * @param _claimant the address which we want to query the ownership of the Kydy ID.\r\n     * @param _tokenId Kydy id, only valid when > 0\r\n     */\r\n    function _owns(address _claimant, uint256 _tokenId) internal view returns (bool) {\r\n        return kydyIndexToOwner[_tokenId] == _claimant;\r\n    }\r\n\r\n    /**\r\n     * @dev Grants an approval to the given address for safeTransferFrom(), overwriting any\r\n     *  previous approval. Setting _approved to address(0) clears all transfer approval.\r\n     *  Note that _approve() does NOT emit the Approval event. This is intentional because\r\n     *  _approve() and safeTransferFrom() are used together when putting Kydys to the auction,\r\n     *  and there is no need to spam the log with Approval events in that case.\r\n     */\r\n    function _approve(uint256 _tokenId, address _approved) internal {\r\n        kydyIndexToApproved[_tokenId] = _approved;\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers a Kydy owned by this contract to the specified address.\r\n     *  Used to rescue lost Kydys. (There is no \"proper\" flow where this contract\r\n     *  should be the owner of any Kydy. This function exists for us to reassign\r\n     *  the ownership of Kydys that users may have accidentally sent to our address.)\r\n     * @param _kydyId ID of the lost Kydy\r\n     * @param _recipient address to send the Kydy to\r\n     */\r\n    function rescueLostKydy(uint256 _kydyId, address _recipient) external onlyCOO whenNotPaused {\r\n        require(_owns(this, _kydyId));\r\n        _transfer(this, _recipient, _kydyId);\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the number of Kydys owned by the given address.\r\n     *  Required for ERC-721 compliance.\r\n     * @param _owner address to query the balance of\r\n     * @return uint256 representing the amount owned by the passed address\r\n     */\r\n    function balanceOf(address _owner) public view returns (uint256) {\r\n        require(_owner != address(0));\r\n        return ownershipTokenCount[_owner];\r\n    }\r\n\r\n    /**\r\n     * @dev Approves another address to transfer the given Kydy ID.\r\n     *  The zero address indicates that there is no approved address.\r\n     *  There can only be one approved address per Kydy at a given time.\r\n     *  Can only be called by the Kydy owner or an approved operator.\r\n     *  Required for ERC-721 compliance.\r\n     * @param to address to be approved for the given Kydy ID\r\n     * @param tokenId uint256 ID of the Kydy to be approved\r\n     */\r\n    function approve(address to, uint256 tokenId) external whenNotPaused {\r\n        address owner = ownerOf(tokenId);\r\n        require(to != owner);\r\n        // Owner or approved operator by owner can approve the another address\r\n        // to transfer the Kydy.\r\n        require(msg.sender == owner || isApprovedForAll(owner, msg.sender));\r\n\r\n        // Approves the given address.\r\n        _approve(tokenId, to);\r\n\r\n        // Emits the Approval event.\r\n        emit Approval(owner, to, tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers the ownership of the Kydy to another address.\r\n     *  Usage of this function is discouraged, use `safeTransferFrom` whenever possible.\r\n     *  Requires the msg sender to be the owner, approved, or operator.\r\n     *  Required for ERC-721 compliance.\r\n     * @param from current owner of the Kydy\r\n     * @param to address to receive the ownership of the given Kydy ID\r\n     * @param tokenId uint256 ID of the Kydy to be transferred\r\n     */\r\n    function transferFrom(address from, address to, uint256 tokenId) public whenNotPaused {\r\n        // Checks the caller is the owner or approved one or an operator.\r\n        require(_isApprovedOrOwner(msg.sender, tokenId));\r\n        // Safety check to prevent from transferring Kydy to 0x0 address.\r\n        require(to != address(0));\r\n\r\n        // Clears approval from current owner.\r\n        _clearApproval(from, tokenId);\r\n        // Resets the ownership of this Kydy from current owner and sets it to 0x0.\r\n        _removeTokenFrom(from, tokenId);\r\n        // Grants the ownership of this Kydy to new owner.\r\n        _addTokenTo(to, tokenId);\r\n\r\n        // Emits the Transfer event.\r\n        emit Transfer(from, to, tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Safely transfers the ownership of a given Kydy to another address.\r\n     *  If the target address is a contract, it must implement `onERC721Received`,\r\n     *  which is called upon a safe transfer, and return the magic value\r\n     *  `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`;\r\n     *  Otherwise, the transfer is reverted.\r\n     *  Requires the msg sender to be the owner, approved, or operator.\r\n     *  Required for ERC-721 compliance.\r\n     * @param from current owner of the Kydy\r\n     * @param to address to receive the ownership of the given Kydy ID\r\n     * @param tokenId uint256 ID of the Kydy to be transferred\r\n     */\r\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\r\n        // solium-disable-next-line arg-overflow\r\n        safeTransferFrom(from, to, tokenId, \"\");\r\n    }\r\n\r\n    /**\r\n     * @dev Safely transfers the ownership of a given Kydy to another address.\r\n     *  If the target address is a contract, it must implement `onERC721Received`,\r\n     *  which is called upon a safe transfer, and return the magic value\r\n     *  `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`;\r\n     *  Otherwise, the transfer is reverted.\r\n     *  Requires the msg sender to be the owner, approved, or operator.\r\n     *  Required for ERC-721 compliance.\r\n     * @param from current owner of the Kydy\r\n     * @param to address to receive the ownership of the given Kydy ID\r\n     * @param tokenId uint256 ID of the Kydy to be transferred\r\n     * @param _data bytes data to send along with a safe transfer check\r\n     */\r\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes _data) public {\r\n        transferFrom(from, to, tokenId);\r\n        // solium-disable-next-line arg-overflow\r\n        require(_checkOnERC721Received(from, to, tokenId, _data));\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to invoke `onERC721Received` on a target address.\r\n     *  This function is not executed if the target address is not a contract.\r\n     * @param _from address representing the previous owner of the given Kydy ID\r\n     * @param _to target address that will receive the Kydys\r\n     * @param _tokenId uint256 ID of the Kydy to be transferred\r\n     * @param _data bytes optional data to send along with the call\r\n     * @return whether the call correctly returned the expected magic value\r\n     */\r\n    function _checkOnERC721Received(address _from, address _to, uint256 _tokenId, bytes _data) internal returns (bool) {\r\n        if (!_to.isContract()) {\r\n            return true;\r\n        }\r\n\r\n        bytes4 retval = ERC721TokenReceiver(_to).onERC721Received(msg.sender, _from, _tokenId, _data);\r\n        return (retval == _ERC721_RECEIVED);\r\n    }\r\n    \r\n    /**\r\n     * @dev Gets the token name.\r\n     *  Required for ERC721Metadata compliance.\r\n     * @return string representing the token name\r\n     */\r\n    function name() external view returns (string) {\r\n        return _name;\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the token symbol.\r\n     *  Required for ERC721Metadata compliance.\r\n     * @return string representing the token symbol\r\n     */\r\n    function symbol() external view returns (string) {\r\n        return _symbol;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns an URI for a given Kydy ID.\r\n     *  Throws if the token ID does not exist. May return an empty string.\r\n     *  Required for ERC721Metadata compliance.\r\n     * @param tokenId uint256 ID of the token to query\r\n     */\r\n    function tokenURI(uint256 tokenId) external view returns (string) {\r\n        require(_exists(tokenId));\r\n        return Strings.strConcat(\r\n            tokenURIBase,\r\n            Strings.uint2str(tokenId)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the total amount of Kydys stored in the contract\r\n     * @return uint256 representing the total amount of Kydys\r\n     */\r\n    function totalSupply() public view returns (uint256) {\r\n        return kydys.length - 1;\r\n    }\r\n\r\n    /**\r\n     * @notice Returns a list of all Kydy IDs assigned to an address.\r\n     * @param _owner The owner whose Kydys we are interested in.\r\n     * @dev This function MUST NEVER be called by smart contract code. It's pretty\r\n     *  expensive (it looks into the entire Kydy array looking for Kydys belonging to owner),\r\n     *  and it also returns a dynamic array, which is only supported for web3 calls, and\r\n     *  not contract-to-contract calls.\r\n     */\r\n    function tokensOfOwner(address _owner) external view returns(uint256[] ownerTokens) {\r\n        uint256 tokenCount = balanceOf(_owner);\r\n\r\n        if (tokenCount == 0) {\r\n            // Return an empty array\r\n            return new uint256[](0);\r\n        } else {\r\n            uint256[] memory result = new uint256[](tokenCount);\r\n            uint256 totalKydys = totalSupply();\r\n            uint256 resultIndex = 0;\r\n\r\n            // All Kydys have IDs starting at 1 and increasing sequentially up to the totalKydy count.\r\n            uint256 kydyId;\r\n\r\n            for (kydyId = 1; kydyId <= totalKydys; kydyId++) {\r\n                if (kydyIndexToOwner[kydyId] == _owner) {\r\n                    result[resultIndex] = kydyId;\r\n                    resultIndex++;\r\n                }\r\n            }\r\n\r\n            return result;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * @title This manages synthesis and creation of Kydys.\r\n * @author VREX Lab Co., Ltd\r\n * @dev Please reference the KydyCore contract for details. \r\n */\r\ncontract KydySynthesis is KydyOwnership {\r\n\r\n    /**\r\n     * @dev The Creating event is emitted when two Kydys synthesize and the creation\r\n     *  timer begins by the yin.\r\n     */\r\n    event Creating(address owner, uint256 yinId, uint256 yangId, uint256 rechargeEndBlock);\r\n\r\n    /**\r\n     * @notice The minimum payment required for synthesizeWithAuto(). This fee is for\r\n     *  the gas cost paid by whoever calls bringKydyHome(), and can be updated by the COO address.\r\n     */\r\n    uint256 public autoCreationFee = 14 finney;\r\n\r\n    // Number of the Kydys that are creating a new Kydy.\r\n    uint256 public creatingKydys;\r\n\r\n    /**\r\n     * @dev The address of the sibling contract that mixes and combines genes of the two parent Kydys. \r\n     */\r\n    GeneSynthesisInterface public geneSynthesis;\r\n\r\n    /**\r\n     * @dev Updates the address of the genetic contract. Only CEO may call this function.\r\n     * @param _address An address of the new GeneSynthesis contract instance.\r\n     */\r\n    function setGeneSynthesisAddress(address _address) external onlyCEO {\r\n        GeneSynthesisInterface candidateContract = GeneSynthesisInterface(_address);\r\n\r\n        // Verifies that the contract is valid.\r\n        require(candidateContract.isGeneSynthesis());\r\n\r\n        // Sets the new GeneSynthesis contract address.\r\n        geneSynthesis = candidateContract;\r\n    }\r\n\r\n    /**\r\n     * @dev Checks that the Kydy is able to synthesize. \r\n     */\r\n    function _isReadyToSynthesize(Kydy _kyd) internal view returns (bool) {\r\n        // Double-checking if there is any pending creation event. \r\n        return (_kyd.synthesizingWithId == 0) && (_kyd.rechargeEndBlock <= uint64(block.number));\r\n    }\r\n\r\n    /**\r\n     * @dev Checks if a yang Kydy has been approved to synthesize with this yin Kydy.\r\n     */\r\n    function _isSynthesizingAllowed(uint256 _yangId, uint256 _yinId) internal view returns (bool) {\r\n        address yinOwner = kydyIndexToOwner[_yinId];\r\n        address yangOwner = kydyIndexToOwner[_yangId];\r\n\r\n        return (yinOwner == yangOwner || synthesizeAllowedToAddress[_yangId] == yinOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Sets the rechargeEndTime for the given Kydy, based on its current rechargeIndex.\r\n     *  The rechargeIndex increases until it hits the cap.\r\n     * @param _kyd A reference to the Kydy that needs its timer to be started.\r\n     */\r\n    function _triggerRecharge(Kydy storage _kyd) internal {\r\n        // Computes the approximation of the end of recharge time in blocks (based on current rechargeIndex).\r\n        _kyd.rechargeEndBlock = uint64((recharges[_kyd.rechargeIndex] / secondsPerBlock) + block.number);\r\n\r\n        // Increases this Kydy's synthesizing count, and the cap is fixed at 12.\r\n        if (_kyd.rechargeIndex < 12) {\r\n            _kyd.rechargeIndex += 1;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Grants approval to another user to synthesize with one of your Kydys.\r\n     * @param _address The approved address of the yin Kydy that can synthesize with your yang Kydy. \r\n     * @param _yangId Your kydy that _address can now synthesize with.\r\n     */\r\n    function approveSynthesizing(address _address, uint256 _yangId)\r\n        external\r\n        whenNotPaused\r\n    {\r\n        require(_owns(msg.sender, _yangId));\r\n        synthesizeAllowedToAddress[_yangId] = _address;\r\n    }\r\n\r\n    /**\r\n     * @dev Updates the minimum payment required for calling bringKydyHome(). Only COO\r\n     *  can call this function. \r\n     */\r\n    function setAutoCreationFee(uint256 value) external onlyCOO {\r\n        autoCreationFee = value;\r\n    }\r\n\r\n    /// @dev Checks if this Kydy is creating and if the creation period is complete. \r\n    function _isReadyToBringKydyHome(Kydy _yin) private view returns (bool) {\r\n        return (_yin.synthesizingWithId != 0) && (_yin.rechargeEndBlock <= uint64(block.number));\r\n    }\r\n\r\n    /**\r\n     * @notice Checks if this Kydy is able to synthesize \r\n     * @param _kydyId reference the ID of the Kydy\r\n     */\r\n    function isReadyToSynthesize(uint256 _kydyId)\r\n        public\r\n        view\r\n        returns (bool)\r\n    {\r\n        require(_kydyId > 0);\r\n        Kydy storage kyd = kydys[_kydyId];\r\n        return _isReadyToSynthesize(kyd);\r\n    }\r\n\r\n    /**\r\n     * @dev Checks if the Kydy is currently creating.\r\n     * @param _kydyId reference the ID of the Kydy\r\n     */\r\n    function isCreating(uint256 _kydyId)\r\n        public\r\n        view\r\n        returns (bool)\r\n    {\r\n        require(_kydyId > 0);\r\n\r\n        return kydys[_kydyId].synthesizingWithId != 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Internal check to see if these yang and yin are a valid couple. \r\n     * @param _yin A reference to the Kydy struct of the potential yin.\r\n     * @param _yinId The yin's ID.\r\n     * @param _yang A reference to the Kydy struct of the potential yang.\r\n     * @param _yangId The yang's ID\r\n     */\r\n    function _isValidCouple(\r\n        Kydy storage _yin,\r\n        uint256 _yinId,\r\n        Kydy storage _yang,\r\n        uint256 _yangId\r\n    )\r\n        private\r\n        view\r\n        returns(bool)\r\n    {\r\n        // Kydy can't synthesize with itself.\r\n        if (_yinId == _yangId) {\r\n            return false;\r\n        }\r\n\r\n        // Kydys can't synthesize with their parents.\r\n        if (_yin.yinId == _yangId || _yin.yangId == _yangId) {\r\n            return false;\r\n        }\r\n        if (_yang.yinId == _yinId || _yang.yangId == _yinId) {\r\n            return false;\r\n        }\r\n\r\n        // Skip sibling check for Gen 0\r\n        if (_yang.yinId == 0 || _yin.yinId == 0) {\r\n            return true;\r\n        }\r\n\r\n        // Kydys can't synthesize with full or half siblings.\r\n        if (_yang.yinId == _yin.yinId || _yang.yinId == _yin.yangId) {\r\n            return false;\r\n        }\r\n        if (_yang.yangId == _yin.yinId || _yang.yangId == _yin.yangId) {\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Internal check to see if these yang and yin Kydys, connected via market, are a valid couple for synthesis. \r\n     */\r\n    function _canSynthesizeWithViaAuction(uint256 _yinId, uint256 _yangId)\r\n        internal\r\n        view\r\n        returns (bool)\r\n    {\r\n        Kydy storage yin = kydys[_yinId];\r\n        Kydy storage yang = kydys[_yangId];\r\n        return _isValidCouple(yin, _yinId, yang, _yangId);\r\n    }\r\n\r\n    /**\r\n     * @dev Checks if the two Kydys can synthesize together, including checks for ownership and synthesizing approvals. \r\n     * @param _yinId ID of the yin Kydy\r\n     * @param _yangId ID of the yang Kydy\r\n     */\r\n    function canSynthesizeWith(uint256 _yinId, uint256 _yangId)\r\n        external\r\n        view\r\n        returns(bool)\r\n    {\r\n        require(_yinId > 0);\r\n        require(_yangId > 0);\r\n        Kydy storage yin = kydys[_yinId];\r\n        Kydy storage yang = kydys[_yangId];\r\n        return _isValidCouple(yin, _yinId, yang, _yangId) &&\r\n            _isSynthesizingAllowed(_yangId, _yinId);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to start synthesizing, when all the conditions are met\r\n     */\r\n    function _synthesizeWith(uint256 _yinId, uint256 _yangId) internal {\r\n        Kydy storage yang = kydys[_yangId];\r\n        Kydy storage yin = kydys[_yinId];\r\n\r\n        // Marks this yin as creating, and make note of who the yang Kydy is.\r\n        yin.synthesizingWithId = uint32(_yangId);\r\n\r\n        // Triggers the recharge for both parents.\r\n        _triggerRecharge(yang);\r\n        _triggerRecharge(yin);\r\n\r\n        // Clears synthesizing permission for both parents, just in case.\r\n        delete synthesizeAllowedToAddress[_yinId];\r\n        delete synthesizeAllowedToAddress[_yangId];\r\n\r\n        // When a Kydy starts creating, this number is increased. \r\n        creatingKydys++;\r\n\r\n        // Emits the Creating event.\r\n        emit Creating(kydyIndexToOwner[_yinId], _yinId, _yangId, yin.rechargeEndBlock);\r\n    }\r\n\r\n    /**\r\n     * @dev Synthesis between two approved Kydys. Requires a pre-payment of the fee to the first caller of bringKydyHome().\r\n     * @param _yinId ID of the Kydy which will be a yin (will start creation if successful)\r\n     * @param _yangId ID of the Kydy which will be a yang (will begin its synthesizing cooldown if successful)\r\n     */\r\n    function synthesizeWithAuto(uint256 _yinId, uint256 _yangId)\r\n        external\r\n        payable\r\n        whenNotPaused\r\n    {\r\n        // Checks for pre-payment.\r\n        require(msg.value >= autoCreationFee);\r\n\r\n        // Caller must be the yin's owner.\r\n        require(_owns(msg.sender, _yinId));\r\n\r\n        // Checks if the caller has valid authority for this synthesis\r\n        require(_isSynthesizingAllowed(_yangId, _yinId));\r\n\r\n        // Gets a reference of the potential yin.\r\n        Kydy storage yin = kydys[_yinId];\r\n\r\n        // Checks that the potential yin is ready to synthesize\r\n        require(_isReadyToSynthesize(yin));\r\n\r\n        // Gets a reference of the potential yang.\r\n        Kydy storage yang = kydys[_yangId];\r\n\r\n        // Checks that the potential yang is ready to synthesize\r\n        require(_isReadyToSynthesize(yang));\r\n\r\n        // Checks that these Kydys are a valid couple.\r\n        require(_isValidCouple(\r\n            yin,\r\n            _yinId,\r\n            yang,\r\n            _yangId\r\n        ));\r\n\r\n        // All checks passed! Yin Kydy starts creating.\r\n        _synthesizeWith(_yinId, _yangId);\r\n\r\n    }\r\n\r\n    /**\r\n     * @notice Let's bring the new Kydy to it's home!\r\n     * @param _yinId A Kydy which is ready to bring the newly created Kydy to home.\r\n     * @return The Kydy ID of the newly created Kydy.\r\n     * @dev The newly created Kydy is transferred to the owner of the yin Kydy. Anyone is welcome to call this function.\r\n     */\r\n    function bringKydyHome(uint256 _yinId)\r\n        external\r\n        whenNotPaused\r\n        returns(uint256)\r\n    {\r\n        // Gets a reference of the yin from storage.\r\n        Kydy storage yin = kydys[_yinId];\r\n\r\n        // Checks that the yin is a valid Kydy.\r\n        require(yin.createdTime != 0);\r\n\r\n        // Checks that the yin is in creation mode, and the creating period is over.\r\n        require(_isReadyToBringKydyHome(yin));\r\n\r\n        // Gets a reference of the yang from storage.\r\n        uint256 yangId = yin.synthesizingWithId;\r\n        Kydy storage yang = kydys[yangId];\r\n\r\n        // Ascertains which has the higher generation number between the two parents.\r\n        uint16 parentGen = yin.generation;\r\n        if (yang.generation > yin.generation) {\r\n            parentGen = yang.generation;\r\n        }\r\n\r\n        // The baby Kydy receives its genes \r\n        uint256 childGenes = geneSynthesis.synthGenes(yin.genes, yang.genes);\r\n\r\n        // The baby Kydy is now on blockchain\r\n        address owner = kydyIndexToOwner[_yinId];\r\n        uint256 kydyId = _createKydy(_yinId, yin.synthesizingWithId, parentGen + 1, childGenes, owner);\r\n\r\n        // Clears the synthesis status of the parents\r\n        delete yin.synthesizingWithId;\r\n\r\n        // When a baby Kydy is created, this number is decreased back. \r\n        creatingKydys--;\r\n\r\n        // Sends the fee to the person who called this. \r\n        msg.sender.transfer(autoCreationFee);\r\n\r\n        // Returns the new Kydy's ID.\r\n        return kydyId;\r\n    }\r\n}\r\n\r\ncontract ERC721Holder is ERC721TokenReceiver {\r\n    function onERC721Received(address, address, uint256, bytes) public returns (bytes4) {\r\n        return this.onERC721Received.selector;\r\n    }\r\n}\r\n\r\n/**\r\n * @title Base auction contract of the Dyverse\r\n * @author VREX Lab Co., Ltd\r\n * @dev Contains necessary functions and variables for the auction.\r\n *  Inherits `ERC721Holder` contract which is the implementation of the `ERC721TokenReceiver`.\r\n *  This is to accept safe transfers.\r\n */\r\ncontract AuctionBase is ERC721Holder {\r\n    using SafeMath for uint256;\r\n\r\n    // Represents an auction on an NFT\r\n    struct Auction {\r\n        // Current owner of NFT\r\n        address seller;\r\n        // Price (in wei) of NFT\r\n        uint128 price;\r\n        // Time when the auction started\r\n        // NOTE: 0 if this auction has been concluded\r\n        uint64 startedAt;\r\n    }\r\n\r\n    // Reference to contract tracking NFT ownership\r\n    ERC721Basic public nonFungibleContract;\r\n\r\n    // The amount owner takes from the sale, (in basis points, which are 1/100 of a percent).\r\n    uint256 public ownerCut;\r\n\r\n    // Maps token ID to it's corresponding auction.\r\n    mapping (uint256 => Auction) tokenIdToAuction;\r\n\r\n    event AuctionCreated(uint256 tokenId, uint256 price);\r\n    event AuctionSuccessful(uint256 tokenId, uint256 totalPrice, address bidder);\r\n    event AuctionCanceled(uint256 tokenId);\r\n\r\n    /// @dev Disables sending funds to this contract.\r\n    function() external {}\r\n\r\n    /// @dev A modifier to check if the given value can fit in 64-bits.\r\n    modifier canBeStoredWith64Bits(uint256 _value) {\r\n        require(_value <= (2**64 - 1));\r\n        _;\r\n    }\r\n\r\n    /// @dev A modifier to check if the given value can fit in 128-bits.\r\n    modifier canBeStoredWith128Bits(uint256 _value) {\r\n        require(_value <= (2**128 - 1));\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the claimant owns the token.\r\n     * @param _claimant An address which to query the ownership of the token.\r\n     * @param _tokenId ID of the token to query the owner of.\r\n     */\r\n    function _owns(address _claimant, uint256 _tokenId) internal view returns (bool) {\r\n        return (nonFungibleContract.ownerOf(_tokenId) == _claimant);\r\n    }\r\n\r\n    /**\r\n     * @dev Escrows the NFT. Grants the ownership of the NFT to this contract safely.\r\n     *  Throws if the escrow fails.\r\n     * @param _owner Current owner of the token.\r\n     * @param _tokenId ID of the token to escrow.\r\n     */\r\n    function _escrow(address _owner, uint256 _tokenId) internal {\r\n        nonFungibleContract.safeTransferFrom(_owner, this, _tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers an NFT owned by this contract to another address safely.\r\n     * @param _receiver The receiving address of NFT.\r\n     * @param _tokenId ID of the token to transfer.\r\n     */\r\n    function _transfer(address _receiver, uint256 _tokenId) internal {\r\n        nonFungibleContract.safeTransferFrom(this, _receiver, _tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Adds an auction to the list of open auctions. \r\n     * @param _tokenId ID of the token to be put on auction.\r\n     * @param _auction Auction information of this token to open.\r\n     */\r\n    function _addAuction(uint256 _tokenId, Auction _auction) internal {\r\n        tokenIdToAuction[_tokenId] = _auction;\r\n\r\n        emit AuctionCreated(\r\n            uint256(_tokenId),\r\n            uint256(_auction.price)\r\n        );\r\n    }\r\n\r\n    /// @dev Cancels the auction which the _seller wants.\r\n    function _cancelAuction(uint256 _tokenId, address _seller) internal {\r\n        _removeAuction(_tokenId);\r\n        _transfer(_seller, _tokenId);\r\n        emit AuctionCanceled(_tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Computes the price and sends it to the seller.\r\n     *  Note that this does NOT transfer the ownership of the token.\r\n     */\r\n    function _bid(uint256 _tokenId, uint256 _bidAmount)\r\n        internal\r\n        returns (uint256)\r\n    {\r\n        // Gets a reference of the token from auction storage.\r\n        Auction storage auction = tokenIdToAuction[_tokenId];\r\n\r\n        // Checks that this auction is currently open\r\n        require(_isOnAuction(auction));\r\n\r\n        // Checks that the bid is greater than or equal to the current token price.\r\n        uint256 price = _currentPrice(auction);\r\n        require(_bidAmount >= price);\r\n\r\n        // Gets a reference of the seller before the auction gets deleted.\r\n        address seller = auction.seller;\r\n\r\n        // Removes the auction before sending the proceeds to the sender\r\n        _removeAuction(_tokenId);\r\n\r\n        // Transfers proceeds to the seller.\r\n        if (price > 0) {\r\n            uint256 auctioneerCut = _computeCut(price);\r\n            uint256 sellerProceeds = price.sub(auctioneerCut);\r\n\r\n            seller.transfer(sellerProceeds);\r\n        }\r\n\r\n        // Computes the excess funds included with the bid and transfers it back to bidder. \r\n        uint256 bidExcess = _bidAmount - price;\r\n\r\n        // Returns the exceeded funds.\r\n        msg.sender.transfer(bidExcess);\r\n\r\n        // Emits the AuctionSuccessful event.\r\n        emit AuctionSuccessful(_tokenId, price, msg.sender);\r\n\r\n        return price;\r\n    }\r\n\r\n    /**\r\n     * @dev Removes an auction from the list of open auctions.\r\n     * @param _tokenId ID of the NFT on auction to be removed.\r\n     */\r\n    function _removeAuction(uint256 _tokenId) internal {\r\n        delete tokenIdToAuction[_tokenId];\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the NFT is on auction.\r\n     * @param _auction An auction to check if it exists.\r\n     */\r\n    function _isOnAuction(Auction storage _auction) internal view returns (bool) {\r\n        return (_auction.startedAt > 0);\r\n    }\r\n\r\n    /// @dev Returns the current price of an NFT on auction.\r\n    function _currentPrice(Auction storage _auction)\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return _auction.price;\r\n    }\r\n\r\n    /**\r\n     * @dev Computes the owner's receiving amount from the sale.\r\n     * @param _price Sale price of the NFT.\r\n     */\r\n    function _computeCut(uint256 _price) internal view returns (uint256) {\r\n        return _price * ownerCut / 10000;\r\n    }\r\n}\r\n\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n\r\n  constructor() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    require(newOwner != address(0));\r\n    emit OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n}\r\n\r\ncontract Pausable is Ownable {\r\n  event Pause();\r\n  event Unpause();\r\n\r\n  bool public paused = false;\r\n\r\n  modifier whenNotPaused() {\r\n    require(!paused);\r\n    _;\r\n  }\r\n\r\n  modifier whenPaused() {\r\n    require(paused);\r\n    _;\r\n  }\r\n\r\n  function pause() onlyOwner whenNotPaused public {\r\n    paused = true;\r\n    emit Pause();\r\n  }\r\n\r\n  function unpause() onlyOwner whenPaused public {\r\n    paused = false;\r\n    emit Unpause();\r\n  }\r\n}\r\n\r\n/**\r\n * @title Auction for NFT.\r\n * @author VREX Lab Co., Ltd\r\n */\r\ncontract Auction is Pausable, AuctionBase {\r\n\r\n    /**\r\n     * @dev Removes all Ether from the contract to the NFT contract.\r\n     */\r\n    function withdrawBalance() external {\r\n        address nftAddress = address(nonFungibleContract);\r\n\r\n        require(\r\n            msg.sender == owner ||\r\n            msg.sender == nftAddress\r\n        );\r\n        nftAddress.transfer(address(this).balance);\r\n    }\r\n\r\n    /**\r\n     * @dev Creates and begins a new auction.\r\n     * @param _tokenId ID of the token to creat an auction, caller must be it's owner.\r\n     * @param _price Price of the token (in wei).\r\n     * @param _seller Seller of this token.\r\n     */\r\n    function createAuction(\r\n        uint256 _tokenId,\r\n        uint256 _price,\r\n        address _seller\r\n    )\r\n        external\r\n        whenNotPaused\r\n        canBeStoredWith128Bits(_price)\r\n    {\r\n        require(_owns(msg.sender, _tokenId));\r\n        _escrow(msg.sender, _tokenId);\r\n        Auction memory auction = Auction(\r\n            _seller,\r\n            uint128(_price),\r\n            uint64(now)\r\n        );\r\n        _addAuction(_tokenId, auction);\r\n    }\r\n\r\n    /**\r\n     * @dev Bids on an open auction, completing the auction and transferring\r\n     *  ownership of the NFT if enough Ether is supplied.\r\n     * @param _tokenId - ID of token to bid on.\r\n     */\r\n    function bid(uint256 _tokenId)\r\n        external\r\n        payable\r\n        whenNotPaused\r\n    {\r\n        _bid(_tokenId, msg.value);\r\n        _transfer(msg.sender, _tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Cancels an auction and returns the NFT to the current owner.\r\n     * @param _tokenId ID of the token on auction to cancel.\r\n     * @param _seller The seller's address.\r\n     */\r\n    function cancelAuction(uint256 _tokenId, address _seller)\r\n        external\r\n    {\r\n        // Requires that this function should only be called from the\r\n        // `cancelSaleAuction()` of NFT ownership contract. This function gets\r\n        // the _seller directly from it's arguments, so if this check doesn't\r\n        // exist, then anyone can cancel the auction! OMG!\r\n        require(msg.sender == address(nonFungibleContract));\r\n        Auction storage auction = tokenIdToAuction[_tokenId];\r\n        require(_isOnAuction(auction));\r\n        address seller = auction.seller;\r\n        require(_seller == seller);\r\n        _cancelAuction(_tokenId, seller);\r\n    }\r\n\r\n    /**\r\n     * @dev Cancels an auction when the contract is paused.\r\n     * Only the owner may do this, and NFTs are returned to the seller. \r\n     * @param _tokenId ID of the token on auction to cancel.\r\n     */\r\n    function cancelAuctionWhenPaused(uint256 _tokenId)\r\n        external\r\n        whenPaused\r\n        onlyOwner\r\n    {\r\n        Auction storage auction = tokenIdToAuction[_tokenId];\r\n        require(_isOnAuction(auction));\r\n        _cancelAuction(_tokenId, auction.seller);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the auction information for an NFT\r\n     * @param _tokenId ID of the NFT on auction\r\n     */\r\n    function getAuction(uint256 _tokenId)\r\n        external\r\n        view\r\n        returns\r\n    (\r\n        address seller,\r\n        uint256 price,\r\n        uint256 startedAt\r\n    ) {\r\n        Auction storage auction = tokenIdToAuction[_tokenId];\r\n        require(_isOnAuction(auction));\r\n        return (\r\n            auction.seller,\r\n            auction.price,\r\n            auction.startedAt\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the current price of the token on auction.\r\n     * @param _tokenId ID of the token\r\n     */\r\n    function getCurrentPrice(uint256 _tokenId)\r\n        external\r\n        view\r\n        returns (uint256)\r\n    {\r\n        Auction storage auction = tokenIdToAuction[_tokenId];\r\n        require(_isOnAuction(auction));\r\n        return _currentPrice(auction);\r\n    }\r\n}\r\n\r\n/**\r\n * @title  Auction for synthesizing\r\n * @author VREX Lab Co., Ltd\r\n * @notice Reset fallback function to prevent accidental fund sending to this contract.\r\n */\r\ncontract SynthesizingAuction is Auction {\r\n\r\n    /**\r\n     * @dev Sanity check that allows us to ensure that we are pointing to the\r\n     *  right auction in our `setSynthesizingAuctionAddress()` call.\r\n     */\r\n    bool public isSynthesizingAuction = true;\r\n\r\n    /**\r\n     * @dev Creates a reference to the NFT ownership contract and checks the owner cut is valid\r\n     * @param _nftAddress Address of a deployed NFT interface contract\r\n     * @param _cut Percent cut which the owner takes on each auction, between 0-10,000.\r\n     */\r\n    constructor(address _nftAddress, uint256 _cut) public {\r\n        require(_cut <= 10000);\r\n        ownerCut = _cut;\r\n\r\n        ERC721Basic candidateContract = ERC721Basic(_nftAddress);\r\n        nonFungibleContract = candidateContract;\r\n    }\r\n\r\n    /**\r\n     * @dev Creates and begins a new auction. Since this function is wrapped,\r\n     *  requires the caller to be KydyCore contract.\r\n     * @param _tokenId ID of token to auction, sender must be it's owner.\r\n     * @param _price Price of the token (in wei).\r\n     * @param _seller Seller of this token.\r\n     */\r\n    function createAuction(\r\n        uint256 _tokenId,\r\n        uint256 _price,\r\n        address _seller\r\n    )\r\n        external\r\n        canBeStoredWith128Bits(_price)\r\n    {\r\n        require(msg.sender == address(nonFungibleContract));\r\n        _escrow(_seller, _tokenId);\r\n        Auction memory auction = Auction(\r\n            _seller,\r\n            uint128(_price),\r\n            uint64(now)\r\n        );\r\n        _addAuction(_tokenId, auction);\r\n    }\r\n\r\n    /**\r\n     * @dev Places a bid for synthesizing. Requires the caller\r\n     *  is the KydyCore contract because all bid functions\r\n     *  should be wrapped. Also returns the Kydy to the\r\n     *  seller rather than the bidder.\r\n     */\r\n    function bid(uint256 _tokenId)\r\n        external\r\n        payable\r\n    {\r\n        require(msg.sender == address(nonFungibleContract));\r\n        address seller = tokenIdToAuction[_tokenId].seller;\r\n        // _bid() checks that the token ID is valid and will throw if bid fails\r\n        _bid(_tokenId, msg.value);\r\n        // Transfers the Kydy back to the seller, and the bidder will get\r\n        // the baby Kydy.\r\n        _transfer(seller, _tokenId);\r\n    }\r\n}\r\n\r\n/**\r\n * @title Auction for sale of Kydys.\r\n * @author VREX Lab Co., Ltd\r\n */\r\ncontract SaleAuction is Auction {\r\n\r\n    /**\r\n     * @dev To make sure we are addressing to the right auction. \r\n     */\r\n    bool public isSaleAuction = true;\r\n\r\n    // Last 5 sale price of Generation 0 Kydys.\r\n    uint256[5] public lastGen0SalePrices;\r\n    \r\n    // Total number of Generation 0 Kydys sold.\r\n    uint256 public gen0SaleCount;\r\n\r\n    /**\r\n     * @dev Creates a reference to the NFT ownership contract and checks the owner cut is valid\r\n     * @param _nftAddress Address of a deployed NFT interface contract\r\n     * @param _cut Percent cut which the owner takes on each auction, between 0-10,000.\r\n     */\r\n    constructor(address _nftAddress, uint256 _cut) public {\r\n        require(_cut <= 10000);\r\n        ownerCut = _cut;\r\n\r\n        ERC721Basic candidateContract = ERC721Basic(_nftAddress);\r\n        nonFungibleContract = candidateContract;\r\n    }\r\n\r\n    /**\r\n     * @dev Creates and begins a new auction.\r\n     * @param _tokenId ID of token to auction, sender must be it's owner.\r\n     * @param _price Price of the token (in wei).\r\n     * @param _seller Seller of this token.\r\n     */\r\n    function createAuction(\r\n        uint256 _tokenId,\r\n        uint256 _price,\r\n        address _seller\r\n    )\r\n        external\r\n        canBeStoredWith128Bits(_price)\r\n    {\r\n        require(msg.sender == address(nonFungibleContract));\r\n        _escrow(_seller, _tokenId);\r\n        Auction memory auction = Auction(\r\n            _seller,\r\n            uint128(_price),\r\n            uint64(now)\r\n        );\r\n        _addAuction(_tokenId, auction);\r\n    }\r\n\r\n    /**\r\n     * @dev Updates lastSalePrice only if the seller is nonFungibleContract. \r\n     */\r\n    function bid(uint256 _tokenId)\r\n        external\r\n        payable\r\n    {\r\n        // _bid verifies token ID\r\n        address seller = tokenIdToAuction[_tokenId].seller;\r\n        uint256 price = _bid(_tokenId, msg.value);\r\n        _transfer(msg.sender, _tokenId);\r\n\r\n        // If the last sale was not Generation 0 Kydy's, the lastSalePrice doesn't change.\r\n        if (seller == address(nonFungibleContract)) {\r\n            // Tracks gen0's latest sale prices.\r\n            lastGen0SalePrices[gen0SaleCount % 5] = price;\r\n            gen0SaleCount++;\r\n        }\r\n    }\r\n\r\n    /// @dev Gives the new average Generation 0 sale price after each Generation 0 Kydy sale.\r\n    function averageGen0SalePrice() external view returns (uint256) {\r\n        uint256 sum = 0;\r\n        for (uint256 i = 0; i < 5; i++) {\r\n            sum = sum.add(lastGen0SalePrices[i]);\r\n        }\r\n        return sum / 5;\r\n    }\r\n}\r\n\r\n/**\r\n * @title This contract defines how sales and synthesis auctions for Kydys are created. \r\n * @author VREX Lab Co., Ltd\r\n */\r\ncontract KydyAuction is KydySynthesis {\r\n\r\n    /**\r\n     * @dev The address of the Auction contract which handles ALL sales of Kydys, both user-generated and Generation 0. \r\n     */\r\n    SaleAuction public saleAuction;\r\n\r\n    /**\r\n     * @dev The address of another Auction contract which handles synthesis auctions. \r\n     */\r\n    SynthesizingAuction public synthesizingAuction;\r\n\r\n    /**\r\n     * @dev Sets the address for the sales auction. Only CEO may call this function. \r\n     * @param _address The address of the sale contract.\r\n     */\r\n    function setSaleAuctionAddress(address _address) external onlyCEO {\r\n        SaleAuction candidateContract = SaleAuction(_address);\r\n\r\n        // Verifies that the contract is correct\r\n        require(candidateContract.isSaleAuction());\r\n\r\n        // Sets the new sale auction contract address.\r\n        saleAuction = candidateContract;\r\n    }\r\n\r\n    /**\r\n     * @dev Sets the address to the synthesis auction. Only CEO may call this function.\r\n     * @param _address The address of the synthesis contract.\r\n     */\r\n    function setSynthesizingAuctionAddress(address _address) external onlyCEO {\r\n        SynthesizingAuction candidateContract = SynthesizingAuction(_address);\r\n\r\n        require(candidateContract.isSynthesizingAuction());\r\n\r\n        synthesizingAuction = candidateContract;\r\n    }\r\n\r\n    /**\r\n     * @dev Creates a Kydy sale.\r\n     */\r\n    function createSaleAuction(\r\n        uint256 _kydyId,\r\n        uint256 _price\r\n    )\r\n        external\r\n        whenNotPaused\r\n    {\r\n        require(_owns(msg.sender, _kydyId));\r\n        require(!isCreating(_kydyId));\r\n        _approve(_kydyId, saleAuction);\r\n \r\n        saleAuction.createAuction(\r\n            _kydyId,\r\n            _price,\r\n            msg.sender\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Creates a synthesis auction. \r\n     */\r\n    function createSynthesizingAuction(\r\n        uint256 _kydyId,\r\n        uint256 _price\r\n    )\r\n        external\r\n        whenNotPaused\r\n    {\r\n        require(_owns(msg.sender, _kydyId));\r\n        require(isReadyToSynthesize(_kydyId));\r\n        _approve(_kydyId, synthesizingAuction);\r\n\r\n        synthesizingAuction.createAuction(\r\n            _kydyId,\r\n            _price,\r\n            msg.sender\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev After bidding for a synthesis auction is accepted, this starts the actual synthesis process.\r\n     * @param _yangId ID of the yang Kydy on the synthesis auction.\r\n     * @param _yinId ID of the yin Kydy owned by the bidder.\r\n     */\r\n    function bidOnSynthesizingAuction(\r\n        uint256 _yangId,\r\n        uint256 _yinId\r\n    )\r\n        external\r\n        payable\r\n        whenNotPaused\r\n    {\r\n        require(_owns(msg.sender, _yinId));\r\n        require(isReadyToSynthesize(_yinId));\r\n        require(_canSynthesizeWithViaAuction(_yinId, _yangId));\r\n\r\n        uint256 currentPrice = synthesizingAuction.getCurrentPrice(_yangId);\r\n\r\n        require (msg.value >= currentPrice + autoCreationFee);\r\n\r\n        synthesizingAuction.bid.value(msg.value - autoCreationFee)(_yangId);\r\n\r\n        _synthesizeWith(uint32(_yinId), uint32(_yangId));\r\n    }\r\n\r\n    /**\r\n     * @dev Cancels a sale and returns the Kydy back to the owner.\r\n     * @param _kydyId ID of the Kydy on sale that the owner wishes to cancel.\r\n     */\r\n    function cancelSaleAuction(\r\n        uint256 _kydyId\r\n    )\r\n        external\r\n        whenNotPaused\r\n    {\r\n        // Checks if the Kydy is in auction. \r\n        require(_owns(saleAuction, _kydyId));\r\n        // Gets the seller of the Kydy.\r\n        (address seller,,) = saleAuction.getAuction(_kydyId);\r\n        // Checks that the caller is the real seller.\r\n        require(msg.sender == seller);\r\n        // Cancels the sale auction of this kydy by it's seller's request.\r\n        saleAuction.cancelAuction(_kydyId, msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @dev Cancels an synthesis auction. \r\n     * @param _kydyId ID of the Kydy on the synthesis auction. \r\n     */\r\n    function cancelSynthesizingAuction(\r\n        uint256 _kydyId\r\n    )\r\n        external\r\n        whenNotPaused\r\n    {\r\n        require(_owns(synthesizingAuction, _kydyId));\r\n        (address seller,,) = synthesizingAuction.getAuction(_kydyId);\r\n        require(msg.sender == seller);\r\n        synthesizingAuction.cancelAuction(_kydyId, msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers the balance. \r\n     */\r\n    function withdrawAuctionBalances() external onlyCLevel {\r\n        saleAuction.withdrawBalance();\r\n        synthesizingAuction.withdrawBalance();\r\n    }\r\n}\r\n\r\n/**\r\n * @title All functions related to creating Kydys\r\n * @author VREX Lab Co., Ltd\r\n */\r\ncontract KydyMinting is KydyAuction {\r\n\r\n    // Limits of the number of Kydys that COO can create.\r\n    uint256 public constant promoCreationLimit = 888;\r\n    uint256 public constant gen0CreationLimit = 8888;\r\n\r\n    uint256 public constant gen0StartingPrice = 10 finney;\r\n\r\n    // Counts the number of Kydys that COO has created.\r\n    uint256 public promoCreatedCount;\r\n    uint256 public gen0CreatedCount;\r\n\r\n    /**\r\n     * @dev Creates promo Kydys, up to a limit. Only COO can call this function.\r\n     * @param _genes Encoded genes of the Kydy to be created.\r\n     * @param _owner Future owner of the created Kydys. COO is the default owner.\r\n     */\r\n    function createPromoKydy(uint256 _genes, address _owner) external onlyCOO {\r\n        address kydyOwner = _owner;\r\n        if (kydyOwner == address(0)) {\r\n            kydyOwner = cooAddress;\r\n        }\r\n        require(promoCreatedCount < promoCreationLimit);\r\n\r\n        promoCreatedCount++;\r\n        _createKydy(0, 0, 0, _genes, kydyOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Creates a new gen0 Kydy with the given genes and\r\n     *  creates an sale auction of it.\r\n     */\r\n    function createGen0Auction(uint256 _genes) external onlyCOO {\r\n        require(gen0CreatedCount < gen0CreationLimit);\r\n\r\n        uint256 kydyId = _createKydy(0, 0, 0, _genes, address(this));\r\n        _approve(kydyId, saleAuction);\r\n\r\n        saleAuction.createAuction(\r\n            kydyId,\r\n            _computeNextGen0Price(),\r\n            address(this)\r\n        );\r\n\r\n        gen0CreatedCount++;\r\n    }\r\n\r\n    /**\r\n     * @dev Computes the next gen0 auction price. It will be\r\n     *  the average of the past 5 prices + 50%.\r\n     */\r\n    function _computeNextGen0Price() internal view returns (uint256) {\r\n        uint256 averagePrice = saleAuction.averageGen0SalePrice();\r\n\r\n        // Sanity check to ensure not to overflow arithmetic.\r\n        require(averagePrice == uint256(uint128(averagePrice)));\r\n\r\n        uint256 nextPrice = averagePrice.add(averagePrice / 2);\r\n\r\n        // New gen0 auction price will not be less than the\r\n        // starting price always.\r\n        if (nextPrice < gen0StartingPrice) {\r\n            nextPrice = gen0StartingPrice;\r\n        }\r\n\r\n        return nextPrice;\r\n    }\r\n}\r\n\r\ncontract KydyTravelInterface {\r\n    function balanceOfUnclaimedTT(address _user) public view returns(uint256);\r\n    function transferTTProduction(address _from, address _to, uint256 _kydyId) public;\r\n    function getProductionOf(address _user) public view returns (uint256);\r\n}\r\n\r\n/**\r\n * @title The Dyverse : A decentralized universe of Kydys, the unique 3D characters and avatars on the Blockchain.\r\n * @author VREX Lab Co., Ltd\r\n * @dev This is the main KydyCore contract. It keeps track of the kydys over the blockchain, and manages\r\n *  general operation of the contracts, metadata and important addresses, including defining who can withdraw \r\n *  the balance from the contract.\r\n */\r\ncontract KydyCore is KydyMinting {\r\n\r\n    // This is the main Kydy contract. To keep the code upgradable and secure, we broke up the code in two different ways.  \r\n    // First, we separated auction and gene combination functions into several sibling contracts. This allows us to securely \r\n    // fix bugs and upgrade contracts, if necessary. Please note that while we try to make most code open source, \r\n    // some code regarding gene combination is not open-source to make it more intriguing for users. \r\n    // However, as always, advanced users will be able to figure out how it works. \r\n    //\r\n    // We also break the core function into a few files, having one contract for each of the major functionalities of the Dyverse. \r\n    // The breakdown is as follows:\r\n    //\r\n    //      - KydyBase: This contract defines the most fundamental core functionalities, including data storage and management.\r\n    //\r\n    //      - KydyAccessControl: This contract manages the roles, addresses and constraints for CEO, CFO and COO.\r\n    //\r\n    //      - KydyOwnership: This contract provides the methods required for basic non-fungible token transactions.\r\n    //\r\n    //      - KydySynthesis: This contract contains how new baby Kydy is created via a process called the Synthesis. \r\n    //\r\n    //      - KydyAuction: This contract manages auction creation and bidding. \r\n    //\r\n    //      - KydyMinting: This contract defines how we create new Generation 0 Kydys. There is a limit of 8,888 Gen 0 Kydys. \r\n\r\n    // Upgraded version of the core contract.\r\n    // Should be used when the core contract is broken and an upgrade is required.\r\n    address public newContractAddress;\r\n\r\n    /// @notice Creates the main Kydy smart contract instance.\r\n    constructor() public {\r\n        // Starts with the contract is paused.\r\n        paused = true;\r\n\r\n        // The creator of the contract is the initial CEO\r\n        ceoAddress = msg.sender;\r\n\r\n        // Starts with the Kydy ID 0 which is invalid one.\r\n        // So we don't have generation-0 parent issues.\r\n        _createKydy(0, 0, 0, uint256(-1), address(0));\r\n    }\r\n\r\n    /**\r\n     * @dev Used to mark the smart contract as upgraded when an upgrade happens. \r\n     * @param _v2Address Upgraded version of the core contract.\r\n     */\r\n    function setNewAddress(address _v2Address) external onlyCEO whenPaused {\r\n        // We'll announce if the upgrade is needed.\r\n        newContractAddress = _v2Address;\r\n        emit ContractUpgrade(_v2Address);\r\n    }\r\n\r\n    /**\r\n     * @dev Rejects all Ether being sent from unregistered addresses, so that users don't accidentally end us Ether.\r\n     */\r\n    function() external payable {\r\n        require(\r\n            msg.sender == address(saleAuction) ||\r\n            msg.sender == address(synthesizingAuction)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Returns all info about a given Kydy. \r\n     * @param _id ID of the Kydy you are enquiring about. \r\n     */\r\n    function getKydy(uint256 _id)\r\n        external\r\n        view\r\n        returns (\r\n        bool isCreating,\r\n        bool isReady,\r\n        uint256 rechargeIndex,\r\n        uint256 nextActionAt,\r\n        uint256 synthesizingWithId,\r\n        uint256 createdTime,\r\n        uint256 yinId,\r\n        uint256 yangId,\r\n        uint256 generation,\r\n        uint256 genes\r\n    ) {\r\n        Kydy storage kyd = kydys[_id];\r\n\r\n        // If this is setted to 0 then it's not at creating mode.\r\n        isCreating = (kyd.synthesizingWithId != 0);\r\n        isReady = (kyd.rechargeEndBlock <= block.number);\r\n        rechargeIndex = uint256(kyd.rechargeIndex);\r\n        nextActionAt = uint256(kyd.rechargeEndBlock);\r\n        synthesizingWithId = uint256(kyd.synthesizingWithId);\r\n        createdTime = uint256(kyd.createdTime);\r\n        yinId = uint256(kyd.yinId);\r\n        yangId = uint256(kyd.yangId);\r\n        generation = uint256(kyd.generation);\r\n        genes = kyd.genes;\r\n    }\r\n\r\n    /**\r\n     * @dev Overrides unpause() to make sure that all external contract addresses are set before unpause. \r\n     * @notice This should be public rather than external.\r\n     */\r\n    function unpause() public onlyCEO whenPaused {\r\n        require(saleAuction != address(0));\r\n        require(synthesizingAuction != address(0));\r\n        require(geneSynthesis != address(0));\r\n        require(newContractAddress == address(0));\r\n\r\n        // Now the contract actually unpauses.\r\n        super.unpause();\r\n    }\r\n\r\n    /// @dev CFO can withdraw the balance available from the contract.\r\n    function withdrawBalance() external onlyCFO {\r\n        uint256 balance = address(this).balance;\r\n\r\n        // Subtracts all creation fees needed to be given to the bringKydyHome() callers,\r\n        // and plus 1 of margin.\r\n        uint256 subtractFees = (creatingKydys + 1) * autoCreationFee;\r\n\r\n        if (balance > subtractFees) {\r\n            cfoAddress.transfer(balance - subtractFees);\r\n        }\r\n    }\r\n\r\n    /// @dev Sets new tokenURI API for token metadata.\r\n    function setNewTokenURI(string _newTokenURI) external onlyCLevel {\r\n        tokenURIBase = _newTokenURI;\r\n    }\r\n\r\n    // An address of Kydy Travel Plugin.\r\n    KydyTravelInterface public travelCore;\r\n\r\n    /**\r\n     * @dev Adds the Kydy Travel Plugin contract to the Kydy Core contract.\r\n     * @notice We have a plan to add some fun features to the Dyverse. \r\n     *  Your Kydy will travel all over our world while you carry on with your life.\r\n     *  During their travel, they will earn some valuable coins which will then be given to you.\r\n     *  Please stay tuned!\r\n     */\r\n    function setTravelCore(address _newTravelCore) external onlyCEO whenPaused {\r\n        travelCore = KydyTravelInterface(_newTravelCore);\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"cfoAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"promoCreatedCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_yinId\",\"type\":\"uint256\"}],\"name\":\"bringKydyHome\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ceoAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"setGeneSynthesisAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"synthesizingAuction\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_kydyId\",\"type\":\"uint256\"},{\"name\":\"_price\",\"type\":\"uint256\"}],\"name\":\"createSaleAuction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"getKydy\",\"outputs\":[{\"name\":\"isCreating\",\"type\":\"bool\"},{\"name\":\"isReady\",\"type\":\"bool\"},{\"name\":\"rechargeIndex\",\"type\":\"uint256\"},{\"name\":\"nextActionAt\",\"type\":\"uint256\"},{\"name\":\"synthesizingWithId\",\"type\":\"uint256\"},{\"name\":\"createdTime\",\"type\":\"uint256\"},{\"name\":\"yinId\",\"type\":\"uint256\"},{\"name\":\"yangId\",\"type\":\"uint256\"},{\"name\":\"generation\",\"type\":\"uint256\"},{\"name\":\"genes\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"},{\"name\":\"_yangId\",\"type\":\"uint256\"}],\"name\":\"approveSynthesizing\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newCEO\",\"type\":\"address\"}],\"name\":\"setCEO\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"recharges\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newCOO\",\"type\":\"address\"}],\"name\":\"setCOO\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getSynthesizeApproved\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_yangId\",\"type\":\"uint256\"},{\"name\":\"_yinId\",\"type\":\"uint256\"}],\"name\":\"bidOnSynthesizingAuction\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newTravelCore\",\"type\":\"address\"}],\"name\":\"setTravelCore\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"gen0CreationLimit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_yinId\",\"type\":\"uint256\"},{\"name\":\"_yangId\",\"type\":\"uint256\"}],\"name\":\"synthesizeWithAuto\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newCFO\",\"type\":\"address\"}],\"name\":\"setCFO\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"secs\",\"type\":\"uint256\"}],\"name\":\"setSecondsPerBlock\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawBalance\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"geneSynthesis\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"newContractAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"setSaleAuctionAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_v2Address\",\"type\":\"address\"}],\"name\":\"setNewAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"secondsPerBlock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"tokensOfOwner\",\"outputs\":[{\"name\":\"ownerTokens\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawAuctionBalances\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"setSynthesizingAuctionAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"autoCreationFee\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_genes\",\"type\":\"uint256\"},{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"createPromoKydy\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_yinId\",\"type\":\"uint256\"},{\"name\":\"_yangId\",\"type\":\"uint256\"}],\"name\":\"canSynthesizeWith\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_kydyId\",\"type\":\"uint256\"},{\"name\":\"_price\",\"type\":\"uint256\"}],\"name\":\"createSynthesizingAuction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_kydyId\",\"type\":\"uint256\"}],\"name\":\"isCreating\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"gen0StartingPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"cooAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"promoCreationLimit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"tokenId\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_kydyId\",\"type\":\"uint256\"}],\"name\":\"cancelSaleAuction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_genes\",\"type\":\"uint256\"}],\"name\":\"createGen0Auction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_kydyId\",\"type\":\"uint256\"},{\"name\":\"_recipient\",\"type\":\"address\"}],\"name\":\"rescueLostKydy\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_kydyId\",\"type\":\"uint256\"}],\"name\":\"cancelSynthesizingAuction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"travelCore\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newTokenURI\",\"type\":\"string\"}],\"name\":\"setNewTokenURI\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"saleAuction\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"creatingKydys\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"gen0CreatedCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"setAutoCreationFee\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_kydyId\",\"type\":\"uint256\"}],\"name\":\"isReadyToSynthesize\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"yinId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"yangId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"rechargeEndBlock\",\"type\":\"uint256\"}],\"name\":\"Creating\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"kydyId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"yinId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"yangId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"genes\",\"type\":\"uint256\"}],\"name\":\"Created\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_approved\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_operator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newContract\",\"type\":\"address\"}],\"name\":\"ContractUpgrade\",\"type\":\"event\"}]","ContractName":"KydyCore","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://984728e95ce5f0c01a687d1e7a73daa4abbc56d2875bd49459d0d51c1a244805"}]}