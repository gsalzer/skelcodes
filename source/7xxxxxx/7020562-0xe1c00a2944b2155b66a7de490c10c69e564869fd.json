{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n\t/**\r\n\t * @dev Multiplies two numbers, throws on overflow.\r\n\t */\r\n\tfunction mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n\t\t// Gas optimization: this is cheaper than asserting 'a' not being zero, but the\r\n\t\t// benefit is lost if 'b' is also tested.\r\n\t\t// See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n\t\tif (a == 0) {\r\n\t\t\treturn 0;\r\n\t\t}\r\n\r\n\t\tc = a * b;\r\n\t\tassert(c / a == b);\r\n\t\treturn c;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Integer division of two numbers, truncating the quotient.\r\n\t */\r\n\tfunction div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\t\t// assert(b > 0); // Solidity automatically throws when dividing by 0\r\n\t\t// uint256 c = a / b;\r\n\t\t// assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\t\treturn a / b;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n\t */\r\n\tfunction sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\t\tassert(b <= a);\r\n\t\treturn a - b;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Adds two numbers, throws on overflow.\r\n\t */\r\n\tfunction add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n\t\tc = a + b;\r\n\t\tassert(c >= a);\r\n\t\treturn c;\r\n\t}\r\n}\r\n\r\n\r\ncontract TheAO {\r\n\taddress public theAO;\r\n\taddress public nameTAOPositionAddress;\r\n\r\n\t// Check whether an address is whitelisted and granted access to transact\r\n\t// on behalf of others\r\n\tmapping (address => bool) public whitelist;\r\n\r\n\tconstructor() public {\r\n\t\ttheAO = msg.sender;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Checks if msg.sender is in whitelist.\r\n\t */\r\n\tmodifier inWhitelist() {\r\n\t\trequire (whitelist[msg.sender] == true);\r\n\t\t_;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Transfer ownership of The AO to new address\r\n\t * @param _theAO The new address to be transferred\r\n\t */\r\n\tfunction transferOwnership(address _theAO) public {\r\n\t\trequire (msg.sender == theAO);\r\n\t\trequire (_theAO != address(0));\r\n\t\ttheAO = _theAO;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Whitelist `_account` address to transact on behalf of others\r\n\t * @param _account The address to whitelist\r\n\t * @param _whitelist Either to whitelist or not\r\n\t */\r\n\tfunction setWhitelist(address _account, bool _whitelist) public {\r\n\t\trequire (msg.sender == theAO);\r\n\t\trequire (_account != address(0));\r\n\t\twhitelist[_account] = _whitelist;\r\n\t}\r\n}\r\n\r\n\r\ninterface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) external; }\r\n\r\n\r\n\r\n\r\ncontract TokenERC20 {\r\n\t// Public variables of the token\r\n\tstring public name;\r\n\tstring public symbol;\r\n\tuint8 public decimals = 18;\r\n\t// 18 decimals is the strongly suggested default, avoid changing it\r\n\tuint256 public totalSupply;\r\n\r\n\t// This creates an array with all balances\r\n\tmapping (address => uint256) public balanceOf;\r\n\tmapping (address => mapping (address => uint256)) public allowance;\r\n\r\n\t// This generates a public event on the blockchain that will notify clients\r\n\tevent Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n\t// This generates a public event on the blockchain that will notify clients\r\n\tevent Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n\r\n\t// This notifies clients about the amount burnt\r\n\tevent Burn(address indexed from, uint256 value);\r\n\r\n\t/**\r\n\t * Constructor function\r\n\t *\r\n\t * Initializes contract with initial supply tokens to the creator of the contract\r\n\t */\r\n\tconstructor (uint256 initialSupply, string tokenName, string tokenSymbol) public {\r\n\t\ttotalSupply = initialSupply * 10 ** uint256(decimals);  // Update total supply with the decimal amount\r\n\t\tbalanceOf[msg.sender] = totalSupply;                // Give the creator all initial tokens\r\n\t\tname = tokenName;                                   // Set the name for display purposes\r\n\t\tsymbol = tokenSymbol;                               // Set the symbol for display purposes\r\n\t}\r\n\r\n\t/**\r\n\t * Internal transfer, only can be called by this contract\r\n\t */\r\n\tfunction _transfer(address _from, address _to, uint _value) internal {\r\n\t\t// Prevent transfer to 0x0 address. Use burn() instead\r\n\t\trequire(_to != 0x0);\r\n\t\t// Check if the sender has enough\r\n\t\trequire(balanceOf[_from] >= _value);\r\n\t\t// Check for overflows\r\n\t\trequire(balanceOf[_to] + _value > balanceOf[_to]);\r\n\t\t// Save this for an assertion in the future\r\n\t\tuint previousBalances = balanceOf[_from] + balanceOf[_to];\r\n\t\t// Subtract from the sender\r\n\t\tbalanceOf[_from] -= _value;\r\n\t\t// Add the same to the recipient\r\n\t\tbalanceOf[_to] += _value;\r\n\t\temit Transfer(_from, _to, _value);\r\n\t\t// Asserts are used to use static analysis to find bugs in your code. They should never fail\r\n\t\tassert(balanceOf[_from] + balanceOf[_to] == previousBalances);\r\n\t}\r\n\r\n\t/**\r\n\t * Transfer tokens\r\n\t *\r\n\t * Send `_value` tokens to `_to` from your account\r\n\t *\r\n\t * @param _to The address of the recipient\r\n\t * @param _value the amount to send\r\n\t */\r\n\tfunction transfer(address _to, uint256 _value) public returns (bool success) {\r\n\t\t_transfer(msg.sender, _to, _value);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * Transfer tokens from other address\r\n\t *\r\n\t * Send `_value` tokens to `_to` in behalf of `_from`\r\n\t *\r\n\t * @param _from The address of the sender\r\n\t * @param _to The address of the recipient\r\n\t * @param _value the amount to send\r\n\t */\r\n\tfunction transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\r\n\t\trequire(_value <= allowance[_from][msg.sender]);     // Check allowance\r\n\t\tallowance[_from][msg.sender] -= _value;\r\n\t\t_transfer(_from, _to, _value);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * Set allowance for other address\r\n\t *\r\n\t * Allows `_spender` to spend no more than `_value` tokens in your behalf\r\n\t *\r\n\t * @param _spender The address authorized to spend\r\n\t * @param _value the max amount they can spend\r\n\t */\r\n\tfunction approve(address _spender, uint256 _value) public returns (bool success) {\r\n\t\tallowance[msg.sender][_spender] = _value;\r\n\t\temit Approval(msg.sender, _spender, _value);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * Set allowance for other address and notify\r\n\t *\r\n\t * Allows `_spender` to spend no more than `_value` tokens in your behalf, and then ping the contract about it\r\n\t *\r\n\t * @param _spender The address authorized to spend\r\n\t * @param _value the max amount they can spend\r\n\t * @param _extraData some extra information to send to the approved contract\r\n\t */\r\n\tfunction approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {\r\n\t\ttokenRecipient spender = tokenRecipient(_spender);\r\n\t\tif (approve(_spender, _value)) {\r\n\t\t\tspender.receiveApproval(msg.sender, _value, this, _extraData);\r\n\t\t\treturn true;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Destroy tokens\r\n\t *\r\n\t * Remove `_value` tokens from the system irreversibly\r\n\t *\r\n\t * @param _value the amount of money to burn\r\n\t */\r\n\tfunction burn(uint256 _value) public returns (bool success) {\r\n\t\trequire(balanceOf[msg.sender] >= _value);   // Check if the sender has enough\r\n\t\tbalanceOf[msg.sender] -= _value;            // Subtract from the sender\r\n\t\ttotalSupply -= _value;                      // Updates totalSupply\r\n\t\temit Burn(msg.sender, _value);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * Destroy tokens from other account\r\n\t *\r\n\t * Remove `_value` tokens from the system irreversibly on behalf of `_from`.\r\n\t *\r\n\t * @param _from the address of the sender\r\n\t * @param _value the amount of money to burn\r\n\t */\r\n\tfunction burnFrom(address _from, uint256 _value) public returns (bool success) {\r\n\t\trequire(balanceOf[_from] >= _value);                // Check if the targeted balance is enough\r\n\t\trequire(_value <= allowance[_from][msg.sender]);    // Check allowance\r\n\t\tbalanceOf[_from] -= _value;                         // Subtract from the targeted balance\r\n\t\tallowance[_from][msg.sender] -= _value;             // Subtract from the sender's allowance\r\n\t\ttotalSupply -= _value;                              // Update totalSupply\r\n\t\temit Burn(_from, _value);\r\n\t\treturn true;\r\n\t}\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title TAOCurrency\r\n */\r\ncontract TAOCurrency is TheAO {\r\n\tusing SafeMath for uint256;\r\n\r\n\t// Public variables of the token\r\n\tstring public name;\r\n\tstring public symbol;\r\n\tuint8 public decimals;\r\n\r\n\t// To differentiate denomination of TAO Currency\r\n\tuint256 public powerOfTen;\r\n\r\n\tuint256 public totalSupply;\r\n\r\n\t// This creates an array with all balances\r\n\t// address is the address of nameId, not the eth public address\r\n\tmapping (address => uint256) public balanceOf;\r\n\r\n\t// This generates a public event on the blockchain that will notify clients\r\n\t// address is the address of TAO/Name Id, not eth public address\r\n\tevent Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n\t// This notifies clients about the amount burnt\r\n\t// address is the address of TAO/Name Id, not eth public address\r\n\tevent Burn(address indexed from, uint256 value);\r\n\r\n\t/**\r\n\t * Constructor function\r\n\t *\r\n\t * Initializes contract with initial supply tokens to the creator of the contract\r\n\t */\r\n\tconstructor (uint256 initialSupply, string tokenName, string tokenSymbol) public {\r\n\t\ttotalSupply = initialSupply;\t\t\t// Update total supply\r\n\t\tbalanceOf[msg.sender] = totalSupply;\t// Give the creator all initial tokens\r\n\t\tname = tokenName;\t\t\t\t\t\t// Set the name for display purposes\r\n\t\tsymbol = tokenSymbol;\t\t\t\t\t// Set the symbol for display purposes\r\n\r\n\t\tpowerOfTen = 0;\r\n\t\tdecimals = 0;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Checks if the calling contract address is The AO\r\n\t *\t\tOR\r\n\t *\t\tIf The AO is set to a Name/TAO, then check if calling address is the Advocate\r\n\t */\r\n\tmodifier onlyTheAO {\r\n\t\trequire (AOLibrary.isTheAO(msg.sender, theAO, nameTAOPositionAddress));\r\n\t\t_;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Check if `_id` is a Name or a TAO\r\n\t */\r\n\tmodifier isNameOrTAO(address _id) {\r\n\t\trequire (AOLibrary.isName(_id) || AOLibrary.isTAO(_id));\r\n\t\t_;\r\n\t}\r\n\r\n\t/***** The AO ONLY METHODS *****/\r\n\t/**\r\n\t * @dev The AO set the NameTAOPosition Address\r\n\t * @param _nameTAOPositionAddress The address of NameTAOPosition\r\n\t */\r\n\tfunction setNameTAOPositionAddress(address _nameTAOPositionAddress) public onlyTheAO {\r\n\t\trequire (_nameTAOPositionAddress != address(0));\r\n\t\tnameTAOPositionAddress = _nameTAOPositionAddress;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Transfer ownership of The AO to new address\r\n\t * @param _theAO The new address to be transferred\r\n\t */\r\n\tfunction transferOwnership(address _theAO) public onlyTheAO {\r\n\t\trequire (_theAO != address(0));\r\n\t\ttheAO = _theAO;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Whitelist `_account` address to transact on behalf of others\r\n\t * @param _account The address to whitelist\r\n\t * @param _whitelist Either to whitelist or not\r\n\t */\r\n\tfunction setWhitelist(address _account, bool _whitelist) public onlyTheAO {\r\n\t\trequire (_account != address(0));\r\n\t\twhitelist[_account] = _whitelist;\r\n\t}\r\n\r\n\t/***** PUBLIC METHODS *****/\r\n\t/**\r\n\t * @dev transfer tokens from other address\r\n\t *\r\n\t * Send `_value` tokens to `_to` in behalf of `_from`\r\n\t *\r\n\t * @param _from The address of the sender\r\n\t * @param _to The address of the recipient\r\n\t * @param _value the amount to send\r\n\t */\r\n\tfunction transferFrom(address _from, address _to, uint256 _value) public inWhitelist isNameOrTAO(_from) isNameOrTAO(_to) returns (bool) {\r\n\t\t_transfer(_from, _to, _value);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Create `mintedAmount` tokens and send it to `target`\r\n\t * @param target Address to receive the tokens\r\n\t * @param mintedAmount The amount of tokens it will receive\r\n\t * @return true on success\r\n\t */\r\n\tfunction mintToken(address target, uint256 mintedAmount) public inWhitelist isNameOrTAO(target) returns (bool) {\r\n\t\t_mintToken(target, mintedAmount);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t *\r\n\t * @dev Whitelisted address remove `_value` tokens from the system irreversibly on behalf of `_from`.\r\n\t *\r\n\t * @param _from the address of the sender\r\n\t * @param _value the amount of money to burn\r\n\t */\r\n\tfunction whitelistBurnFrom(address _from, uint256 _value) public inWhitelist returns (bool success) {\r\n\t\trequire(balanceOf[_from] >= _value);                // Check if the targeted balance is enough\r\n\t\tbalanceOf[_from] = balanceOf[_from].sub(_value);    // Subtract from the targeted balance\r\n\t\ttotalSupply = totalSupply.sub(_value);              // Update totalSupply\r\n\t\temit Burn(_from, _value);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/***** INTERNAL METHODS *****/\r\n\t/**\r\n\t * @dev Send `_value` tokens from `_from` to `_to`\r\n\t * @param _from The address of sender\r\n\t * @param _to The address of the recipient\r\n\t * @param _value The amount to send\r\n\t */\r\n\tfunction _transfer(address _from, address _to, uint256 _value) internal {\r\n\t\trequire (_to != address(0));\t\t\t\t\t\t\t// Prevent transfer to 0x0 address. Use burn() instead\r\n\t\trequire (balanceOf[_from] >= _value);\t\t\t\t\t// Check if the sender has enough\r\n\t\trequire (balanceOf[_to].add(_value) >= balanceOf[_to]); // Check for overflows\r\n\t\tuint256 previousBalances = balanceOf[_from].add(balanceOf[_to]);\r\n\t\tbalanceOf[_from] = balanceOf[_from].sub(_value);        // Subtract from the sender\r\n\t\tbalanceOf[_to] = balanceOf[_to].add(_value);            // Add the same to the recipient\r\n\t\temit Transfer(_from, _to, _value);\r\n\t\tassert(balanceOf[_from].add(balanceOf[_to]) == previousBalances);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Create `mintedAmount` tokens and send it to `target`\r\n\t * @param target Address to receive the tokens\r\n\t * @param mintedAmount The amount of tokens it will receive\r\n\t */\r\n\tfunction _mintToken(address target, uint256 mintedAmount) internal {\r\n\t\tbalanceOf[target] = balanceOf[target].add(mintedAmount);\r\n\t\ttotalSupply = totalSupply.add(mintedAmount);\r\n\t\temit Transfer(0, this, mintedAmount);\r\n\t\temit Transfer(this, target, mintedAmount);\r\n\t}\r\n}\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title TAO\r\n */\r\ncontract TAO {\r\n\tusing SafeMath for uint256;\r\n\r\n\taddress public vaultAddress;\r\n\tstring public name;\t\t\t\t// the name for this TAO\r\n\taddress public originId;\t\t// the ID of the Name that created this TAO. If Name, it's the eth address\r\n\r\n\t// TAO's data\r\n\tstring public datHash;\r\n\tstring public database;\r\n\tstring public keyValue;\r\n\tbytes32 public contentId;\r\n\r\n\t/**\r\n\t * 0 = TAO\r\n\t * 1 = Name\r\n\t */\r\n\tuint8 public typeId;\r\n\r\n\t/**\r\n\t * @dev Constructor function\r\n\t */\r\n\tconstructor (string _name,\r\n\t\taddress _originId,\r\n\t\tstring _datHash,\r\n\t\tstring _database,\r\n\t\tstring _keyValue,\r\n\t\tbytes32 _contentId,\r\n\t\taddress _vaultAddress\r\n\t) public {\r\n\t\tname = _name;\r\n\t\toriginId = _originId;\r\n\t\tdatHash = _datHash;\r\n\t\tdatabase = _database;\r\n\t\tkeyValue = _keyValue;\r\n\t\tcontentId = _contentId;\r\n\r\n\t\t// Creating TAO\r\n\t\ttypeId = 0;\r\n\r\n\t\tvaultAddress = _vaultAddress;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Checks if calling address is Vault contract\r\n\t */\r\n\tmodifier onlyVault {\r\n\t\trequire (msg.sender == vaultAddress);\r\n\t\t_;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Allows Vault to transfer `_amount` of ETH from this TAO to `_recipient`\r\n\t * @param _recipient The recipient address\r\n\t * @param _amount The amount to transfer\r\n\t * @return true on success\r\n\t */\r\n\tfunction transferEth(address _recipient, uint256 _amount) public onlyVault returns (bool) {\r\n\t\t_recipient.transfer(_amount);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Allows Vault to transfer `_amount` of ERC20 Token from this TAO to `_recipient`\r\n\t * @param _erc20TokenAddress The address of ERC20 Token\r\n\t * @param _recipient The recipient address\r\n\t * @param _amount The amount to transfer\r\n\t * @return true on success\r\n\t */\r\n\tfunction transferERC20(address _erc20TokenAddress, address _recipient, uint256 _amount) public onlyVault returns (bool) {\r\n\t\tTokenERC20 _erc20 = TokenERC20(_erc20TokenAddress);\r\n\t\t_erc20.transfer(_recipient, _amount);\r\n\t\treturn true;\r\n\t}\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title Position\r\n */\r\ncontract Position is TheAO {\r\n\tusing SafeMath for uint256;\r\n\r\n\t// Public variables of the token\r\n\tstring public name;\r\n\tstring public symbol;\r\n\tuint8 public decimals = 4;\r\n\r\n\tuint256 constant public MAX_SUPPLY_PER_NAME = 100 * (10 ** 4);\r\n\r\n\tuint256 public totalSupply;\r\n\r\n\t// Mapping from Name ID to bool value whether or not it has received Position Token\r\n\tmapping (address => bool) public receivedToken;\r\n\r\n\t// Mapping from Name ID to its total available balance\r\n\tmapping (address => uint256) public balanceOf;\r\n\r\n\t// Mapping from Name's TAO ID to its staked amount\r\n\tmapping (address => mapping(address => uint256)) public taoStakedBalance;\r\n\r\n\t// Mapping from TAO ID to its total staked amount\r\n\tmapping (address => uint256) public totalTAOStakedBalance;\r\n\r\n\t// This generates a public event on the blockchain that will notify clients\r\n\tevent Mint(address indexed nameId, uint256 value);\r\n\tevent Stake(address indexed nameId, address indexed taoId, uint256 value);\r\n\tevent Unstake(address indexed nameId, address indexed taoId, uint256 value);\r\n\r\n\t/**\r\n\t * Constructor function\r\n\t *\r\n\t * Initializes contract with initial supply tokens to the creator of the contract\r\n\t */\r\n\tconstructor (uint256 initialSupply, string tokenName, string tokenSymbol) public {\r\n\t\ttotalSupply = initialSupply;\t\t\t// Update total supply\r\n\t\tbalanceOf[msg.sender] = totalSupply;\t// Give the creator all initial tokens\r\n\t\tname = tokenName;\t\t\t\t\t\t// Set the name for display purposes\r\n\t\tsymbol = tokenSymbol;\t\t\t\t\t// Set the symbol for display purposes\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Checks if the calling contract address is The AO\r\n\t *\t\tOR\r\n\t *\t\tIf The AO is set to a Name/TAO, then check if calling address is the Advocate\r\n\t */\r\n\tmodifier onlyTheAO {\r\n\t\trequire (AOLibrary.isTheAO(msg.sender, theAO, nameTAOPositionAddress));\r\n\t\t_;\r\n\t}\r\n\r\n\t/***** The AO ONLY METHODS *****/\r\n\t/**\r\n\t * @dev The AO set the NameTAOPosition Address\r\n\t * @param _nameTAOPositionAddress The address of NameTAOPosition\r\n\t */\r\n\tfunction setNameTAOPositionAddress(address _nameTAOPositionAddress) public onlyTheAO {\r\n\t\trequire (_nameTAOPositionAddress != address(0));\r\n\t\tnameTAOPositionAddress = _nameTAOPositionAddress;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Transfer ownership of The AO to new address\r\n\t * @param _theAO The new address to be transferred\r\n\t */\r\n\tfunction transferOwnership(address _theAO) public onlyTheAO {\r\n\t\trequire (_theAO != address(0));\r\n\t\ttheAO = _theAO;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Whitelist `_account` address to transact on behalf of others\r\n\t * @param _account The address to whitelist\r\n\t * @param _whitelist Either to whitelist or not\r\n\t */\r\n\tfunction setWhitelist(address _account, bool _whitelist) public onlyTheAO {\r\n\t\trequire (_account != address(0));\r\n\t\twhitelist[_account] = _whitelist;\r\n\t}\r\n\r\n\t/***** PUBLIC METHODS *****/\r\n\t/**\r\n\t * @dev Create `MAX_SUPPLY_PER_NAME` tokens and send it to `_nameId`\r\n\t * @param _nameId Address to receive the tokens\r\n\t * @return true on success\r\n\t */\r\n\tfunction mintToken(address _nameId) public inWhitelist returns (bool) {\r\n\t\t// Make sure _nameId has not received Position Token\r\n\t\trequire (receivedToken[_nameId] == false);\r\n\r\n\t\treceivedToken[_nameId] = true;\r\n\t\tbalanceOf[_nameId] = balanceOf[_nameId].add(MAX_SUPPLY_PER_NAME);\r\n\t\ttotalSupply = totalSupply.add(MAX_SUPPLY_PER_NAME);\r\n\t\temit Mint(_nameId, MAX_SUPPLY_PER_NAME);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Get staked balance of `_nameId`\r\n\t * @param _nameId The Name ID to be queried\r\n\t * @return total staked balance\r\n\t */\r\n\tfunction stakedBalance(address _nameId) public view returns (uint256) {\r\n\t\treturn MAX_SUPPLY_PER_NAME.sub(balanceOf[_nameId]);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Stake `_value` tokens on `_taoId` from `_nameId`\r\n\t * @param _nameId The Name ID that wants to stake\r\n\t * @param _taoId The TAO ID to stake\r\n\t * @param _value The amount to stake\r\n\t * @return true on success\r\n\t */\r\n\tfunction stake(address _nameId, address _taoId, uint256 _value) public inWhitelist returns (bool) {\r\n\t\trequire (_value > 0 && _value <= MAX_SUPPLY_PER_NAME);\r\n\t\trequire (balanceOf[_nameId] >= _value);\t\t\t\t\t\t\t// Check if the targeted balance is enough\r\n\t\tbalanceOf[_nameId] = balanceOf[_nameId].sub(_value);\t\t\t// Subtract from the targeted balance\r\n\t\ttaoStakedBalance[_nameId][_taoId] = taoStakedBalance[_nameId][_taoId].add(_value);\t// Add to the targeted staked balance\r\n\t\ttotalTAOStakedBalance[_taoId] = totalTAOStakedBalance[_taoId].add(_value);\r\n\t\temit Stake(_nameId, _taoId, _value);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Unstake `_value` tokens from `_nameId`'s `_taoId`\r\n\t * @param _nameId The Name ID that wants to unstake\r\n\t * @param _taoId The TAO ID to unstake\r\n\t * @param _value The amount to unstake\r\n\t * @return true on success\r\n\t */\r\n\tfunction unstake(address _nameId, address _taoId, uint256 _value) public inWhitelist returns (bool) {\r\n\t\trequire (_value > 0 && _value <= MAX_SUPPLY_PER_NAME);\r\n\t\trequire (taoStakedBalance[_nameId][_taoId] >= _value);\t// Check if the targeted staked balance is enough\r\n\t\trequire (totalTAOStakedBalance[_taoId] >= _value);\t// Check if the total targeted staked balance is enough\r\n\t\ttaoStakedBalance[_nameId][_taoId] = taoStakedBalance[_nameId][_taoId].sub(_value);\t// Subtract from the targeted staked balance\r\n\t\ttotalTAOStakedBalance[_taoId] = totalTAOStakedBalance[_taoId].sub(_value);\r\n\t\tbalanceOf[_nameId] = balanceOf[_nameId].add(_value);\t\t\t// Add to the targeted balance\r\n\t\temit Unstake(_nameId, _taoId, _value);\r\n\t\treturn true;\r\n\t}\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title NameTAOLookup\r\n *\r\n */\r\ncontract NameTAOLookup is TheAO {\r\n\taddress public nameFactoryAddress;\r\n\taddress public taoFactoryAddress;\r\n\r\n\tstruct NameTAOInfo {\r\n\t\tstring name;\r\n\t\taddress nameTAOAddress;\r\n\t\tstring parentName;\r\n\t\tuint256 typeId; // 0 = TAO. 1 = Name\r\n\t}\r\n\r\n\tuint256 public internalId;\r\n\tuint256 public totalNames;\r\n\tuint256 public totalTAOs;\r\n\r\n\tmapping (uint256 => NameTAOInfo) internal nameTAOInfos;\r\n\tmapping (bytes32 => uint256) internal internalIdLookup;\r\n\r\n\t/**\r\n\t * @dev Constructor function\r\n\t */\r\n\tconstructor(address _nameFactoryAddress) public {\r\n\t\tnameFactoryAddress = _nameFactoryAddress;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Checks if the calling contract address is The AO\r\n\t *\t\tOR\r\n\t *\t\tIf The AO is set to a Name/TAO, then check if calling address is the Advocate\r\n\t */\r\n\tmodifier onlyTheAO {\r\n\t\trequire (AOLibrary.isTheAO(msg.sender, theAO, nameTAOPositionAddress));\r\n\t\t_;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Check if calling address is Factory\r\n\t */\r\n\tmodifier onlyFactory {\r\n\t\trequire (msg.sender == nameFactoryAddress || msg.sender == taoFactoryAddress);\r\n\t\t_;\r\n\t}\r\n\r\n\t/***** The AO ONLY METHODS *****/\r\n\t/**\r\n\t * @dev The AO set the NameTAOPosition Address\r\n\t * @param _nameTAOPositionAddress The address of NameTAOPosition\r\n\t */\r\n\tfunction setNameTAOPositionAddress(address _nameTAOPositionAddress) public onlyTheAO {\r\n\t\trequire (_nameTAOPositionAddress != address(0));\r\n\t\tnameTAOPositionAddress = _nameTAOPositionAddress;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Transfer ownership of The AO to new address\r\n\t * @param _theAO The new address to be transferred\r\n\t */\r\n\tfunction transferOwnership(address _theAO) public onlyTheAO {\r\n\t\trequire (_theAO != address(0));\r\n\t\ttheAO = _theAO;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Whitelist `_account` address to transact on behalf of others\r\n\t * @param _account The address to whitelist\r\n\t * @param _whitelist Either to whitelist or not\r\n\t */\r\n\tfunction setWhitelist(address _account, bool _whitelist) public onlyTheAO {\r\n\t\trequire (_account != address(0));\r\n\t\twhitelist[_account] = _whitelist;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev The AO set the taoFactoryAddress Address\r\n\t * @param _taoFactoryAddress The address of TAOFactory\r\n\t */\r\n\tfunction setTAOFactoryAddress(address _taoFactoryAddress) public onlyTheAO {\r\n\t\trequire (_taoFactoryAddress != address(0));\r\n\t\ttaoFactoryAddress = _taoFactoryAddress;\r\n\t}\r\n\r\n\t/***** PUBLIC METHODS *****/\r\n\t/**\r\n\t * @dev Check whether or not a name exist in the list\r\n\t * @param _name The name to be checked\r\n\t * @return true if yes, false otherwise\r\n\t */\r\n\tfunction isExist(string _name) public view returns (bool) {\r\n\t\tbytes32 _nameKey = keccak256(abi.encodePacked(_name));\r\n\t\treturn (internalIdLookup[_nameKey] > 0);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Add a new NameTAOInfo\r\n\t * @param _name The name of the Name/TAO\r\n\t * @param _nameTAOAddress The address of the Name/TAO\r\n\t * @param _parentName The parent name of the Name/TAO\r\n\t * @param _typeId If TAO = 0. Name = 1\r\n\t * @return true on success\r\n\t */\r\n\tfunction add(string _name, address _nameTAOAddress, string _parentName, uint256 _typeId) public onlyFactory returns (bool) {\r\n\t\trequire (bytes(_name).length > 0);\r\n\t\trequire (_nameTAOAddress != address(0));\r\n\t\trequire (bytes(_parentName).length > 0);\r\n\t\trequire (_typeId == 0 || _typeId == 1);\r\n\t\trequire (!isExist(_name));\r\n\r\n\t\tinternalId++;\r\n\t\tbytes32 _nameKey = keccak256(abi.encodePacked(_name));\r\n\t\tinternalIdLookup[_nameKey] = internalId;\r\n\t\tNameTAOInfo storage _nameTAOInfo = nameTAOInfos[internalId];\r\n\t\t_nameTAOInfo.name = _name;\r\n\t\t_nameTAOInfo.nameTAOAddress = _nameTAOAddress;\r\n\t\t_nameTAOInfo.parentName = _parentName;\r\n\t\t_nameTAOInfo.typeId = _typeId;\r\n\r\n\t\tif (_typeId == 0) {\r\n\t\t\ttotalTAOs++;\r\n\t\t} else {\r\n\t\t\ttotalNames++;\r\n\t\t}\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Get the NameTAOInfo given a name\r\n\t * @param _name The name to be queried\r\n\t * @return the name of Name/TAO\r\n\t * @return the address of Name/TAO\r\n\t * @return the parent name of Name/TAO\r\n\t * @return type ID. 0 = TAO. 1 = Name\r\n\t */\r\n\tfunction getByName(string _name) public view returns (string, address, string, uint256) {\r\n\t\trequire (isExist(_name));\r\n\t\tbytes32 _nameKey = keccak256(abi.encodePacked(_name));\r\n\t\tNameTAOInfo memory _nameTAOInfo = nameTAOInfos[internalIdLookup[_nameKey]];\r\n\t\treturn (\r\n\t\t\t_nameTAOInfo.name,\r\n\t\t\t_nameTAOInfo.nameTAOAddress,\r\n\t\t\t_nameTAOInfo.parentName,\r\n\t\t\t_nameTAOInfo.typeId\r\n\t\t);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Get the NameTAOInfo given an ID\r\n\t * @param _internalId The internal ID to be queried\r\n\t * @return the name of Name/TAO\r\n\t * @return the address of Name/TAO\r\n\t * @return the parent name of Name/TAO\r\n\t * @return type ID. 0 = TAO. 1 = Name\r\n\t */\r\n\tfunction getByInternalId(uint256 _internalId) public view returns (string, address, string, uint256) {\r\n\t\trequire (nameTAOInfos[_internalId].nameTAOAddress != address(0));\r\n\t\tNameTAOInfo memory _nameTAOInfo = nameTAOInfos[_internalId];\r\n\t\treturn (\r\n\t\t\t_nameTAOInfo.name,\r\n\t\t\t_nameTAOInfo.nameTAOAddress,\r\n\t\t\t_nameTAOInfo.parentName,\r\n\t\t\t_nameTAOInfo.typeId\r\n\t\t);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Return the nameTAOAddress given a _name\r\n\t * @param _name The name to be queried\r\n\t * @return the nameTAOAddress of the name\r\n\t */\r\n\tfunction getAddressByName(string _name) public view returns (address) {\r\n\t\trequire (isExist(_name));\r\n\t\tbytes32 _nameKey = keccak256(abi.encodePacked(_name));\r\n\t\tNameTAOInfo memory _nameTAOInfo = nameTAOInfos[internalIdLookup[_nameKey]];\r\n\t\treturn _nameTAOInfo.nameTAOAddress;\r\n\t}\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title NamePublicKey\r\n */\r\ncontract NamePublicKey {\r\n\tusing SafeMath for uint256;\r\n\r\n\taddress public nameFactoryAddress;\r\n\r\n\tNameFactory internal _nameFactory;\r\n\tNameTAOPosition internal _nameTAOPosition;\r\n\r\n\tstruct PublicKey {\r\n\t\tbool created;\r\n\t\taddress defaultKey;\r\n\t\taddress[] keys;\r\n\t}\r\n\r\n\t// Mapping from nameId to its PublicKey\r\n\tmapping (address => PublicKey) internal publicKeys;\r\n\r\n\t// Event to be broadcasted to public when a publicKey is added to a Name\r\n\tevent AddKey(address indexed nameId, address publicKey, uint256 nonce);\r\n\r\n\t// Event to be broadcasted to public when a publicKey is removed from a Name\r\n\tevent RemoveKey(address indexed nameId, address publicKey, uint256 nonce);\r\n\r\n\t// Event to be broadcasted to public when a publicKey is set as default for a Name\r\n\tevent SetDefaultKey(address indexed nameId, address publicKey, uint256 nonce);\r\n\r\n\t/**\r\n\t * @dev Constructor function\r\n\t */\r\n\tconstructor(address _nameFactoryAddress, address _nameTAOPositionAddress) public {\r\n\t\tnameFactoryAddress = _nameFactoryAddress;\r\n\r\n\t\t_nameFactory = NameFactory(_nameFactoryAddress);\r\n\t\t_nameTAOPosition = NameTAOPosition(_nameTAOPositionAddress);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Check if calling address is Factory\r\n\t */\r\n\tmodifier onlyFactory {\r\n\t\trequire (msg.sender == nameFactoryAddress);\r\n\t\t_;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Check if `_nameId` is a Name\r\n\t */\r\n\tmodifier isName(address _nameId) {\r\n\t\trequire (AOLibrary.isName(_nameId));\r\n\t\t_;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Check if msg.sender is the current advocate of Name ID\r\n\t */\r\n\tmodifier onlyAdvocate(address _id) {\r\n\t\trequire (_nameTAOPosition.senderIsAdvocate(msg.sender, _id));\r\n\t\t_;\r\n\t}\r\n\r\n\t/***** PUBLIC METHODS *****/\r\n\t/**\r\n\t * @dev Check whether or not a Name ID exist in the list of Public Keys\r\n\t * @param _id The ID to be checked\r\n\t * @return true if yes, false otherwise\r\n\t */\r\n\tfunction isExist(address _id) public view returns (bool) {\r\n\t\treturn publicKeys[_id].created;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Store the PublicKey info for a Name\r\n\t * @param _id The ID of the Name\r\n\t * @param _defaultKey The default public key for this Name\r\n\t * @return true on success\r\n\t */\r\n\tfunction add(address _id, address _defaultKey)\r\n\t\tpublic\r\n\t\tisName(_id)\r\n\t\tonlyFactory returns (bool) {\r\n\t\trequire (!isExist(_id));\r\n\t\trequire (_defaultKey != address(0));\r\n\r\n\t\tPublicKey storage _publicKey = publicKeys[_id];\r\n\t\t_publicKey.created = true;\r\n\t\t_publicKey.defaultKey = _defaultKey;\r\n\t\t_publicKey.keys.push(_defaultKey);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Get total publicKeys count for a Name\r\n\t * @param _id The ID of the Name\r\n\t * @return total publicKeys count\r\n\t */\r\n\tfunction getTotalPublicKeysCount(address _id) public isName(_id) view returns (uint256) {\r\n\t\trequire (isExist(_id));\r\n\t\treturn publicKeys[_id].keys.length;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Check whether or not a publicKey exist in the list for a Name\r\n\t * @param _id The ID of the Name\r\n\t * @param _key The publicKey to check\r\n\t * @return true if yes. false otherwise\r\n\t */\r\n\tfunction isKeyExist(address _id, address _key) isName(_id) public view returns (bool) {\r\n\t\trequire (isExist(_id));\r\n\t\trequire (_key != address(0));\r\n\r\n\t\tPublicKey memory _publicKey = publicKeys[_id];\r\n\t\tfor (uint256 i = 0; i < _publicKey.keys.length; i++) {\r\n\t\t\tif (_publicKey.keys[i] == _key) {\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Add publicKey to list for a Name\r\n\t * @param _id The ID of the Name\r\n\t * @param _key The publicKey to be added\r\n\t */\r\n\tfunction addKey(address _id, address _key) public isName(_id) onlyAdvocate(_id) {\r\n\t\trequire (!isKeyExist(_id, _key));\r\n\r\n\t\tPublicKey storage _publicKey = publicKeys[_id];\r\n\t\t_publicKey.keys.push(_key);\r\n\r\n\t\tuint256 _nonce = _nameFactory.incrementNonce(_id);\r\n\t\trequire (_nonce > 0);\r\n\r\n\t\temit AddKey(_id, _key, _nonce);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Get default public key of a Name\r\n\t * @param _id The ID of the Name\r\n\t * @return the default public key\r\n\t */\r\n\tfunction getDefaultKey(address _id) public isName(_id) view returns (address) {\r\n\t\trequire (isExist(_id));\r\n\t\treturn publicKeys[_id].defaultKey;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Get list of publicKeys of a Name\r\n\t * @param _id The ID of the Name\r\n\t * @param _from The starting index\r\n\t * @param _to The ending index\r\n\t * @return list of publicKeys\r\n\t */\r\n\tfunction getKeys(address _id, uint256 _from, uint256 _to) public isName(_id) view returns (address[]) {\r\n\t\trequire (isExist(_id));\r\n\t\trequire (_from >= 0 && _to >= _from);\r\n\r\n\t\tPublicKey memory _publicKey = publicKeys[_id];\r\n\t\trequire (_publicKey.keys.length > 0);\r\n\r\n\t\taddress[] memory _keys = new address[](_to.sub(_from).add(1));\r\n\t\tif (_to > _publicKey.keys.length.sub(1)) {\r\n\t\t\t_to = _publicKey.keys.length.sub(1);\r\n\t\t}\r\n\t\tfor (uint256 i = _from; i <= _to; i++) {\r\n\t\t\t_keys[i.sub(_from)] = _publicKey.keys[i];\r\n\t\t}\r\n\t\treturn _keys;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Remove publicKey from the list\r\n\t * @param _id The ID of the Name\r\n\t * @param _key The publicKey to be removed\r\n\t */\r\n\tfunction removeKey(address _id, address _key) public isName(_id) onlyAdvocate(_id) {\r\n\t\trequire (isExist(_id));\r\n\t\trequire (isKeyExist(_id, _key));\r\n\r\n\t\tPublicKey storage _publicKey = publicKeys[_id];\r\n\r\n\t\t// Can't remove default key\r\n\t\trequire (_key != _publicKey.defaultKey);\r\n\t\trequire (_publicKey.keys.length > 1);\r\n\r\n\t\tfor (uint256 i = 0; i < _publicKey.keys.length; i++) {\r\n\t\t\tif (_publicKey.keys[i] == _key) {\r\n\t\t\t\tdelete _publicKey.keys[i];\r\n\t\t\t\t_publicKey.keys.length--;\r\n\r\n\t\t\t\tuint256 _nonce = _nameFactory.incrementNonce(_id);\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\trequire (_nonce > 0);\r\n\r\n\t\temit RemoveKey(_id, _key, _nonce);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Set a publicKey as the default for a Name\r\n\t * @param _id The ID of the Name\r\n\t * @param _defaultKey The defaultKey to be set\r\n\t * @param _signatureV The V part of the signature for this update\r\n\t * @param _signatureR The R part of the signature for this update\r\n\t * @param _signatureS The S part of the signature for this update\r\n\t */\r\n\tfunction setDefaultKey(address _id, address _defaultKey, uint8 _signatureV, bytes32 _signatureR, bytes32 _signatureS) public isName(_id) onlyAdvocate(_id) {\r\n\t\trequire (isExist(_id));\r\n\t\trequire (isKeyExist(_id, _defaultKey));\r\n\r\n\t\tbytes32 _hash = keccak256(abi.encodePacked(address(this), _id, _defaultKey));\r\n\t\trequire (ecrecover(_hash, _signatureV, _signatureR, _signatureS) == msg.sender);\r\n\r\n\t\tPublicKey storage _publicKey = publicKeys[_id];\r\n\t\t_publicKey.defaultKey = _defaultKey;\r\n\r\n\t\tuint256 _nonce = _nameFactory.incrementNonce(_id);\r\n\t\trequire (_nonce > 0);\r\n\t\temit SetDefaultKey(_id, _defaultKey, _nonce);\r\n\t}\r\n}\r\n\r\n\r\n/**\r\n * @title NameFactory\r\n *\r\n * The purpose of this contract is to allow node to create Name\r\n */\r\ncontract NameFactory is TheAO {\r\n\tusing SafeMath for uint256;\r\n\r\n\taddress public positionAddress;\r\n\taddress public nameTAOVaultAddress;\r\n\taddress public nameTAOLookupAddress;\r\n\taddress public namePublicKeyAddress;\r\n\r\n\tPosition internal _position;\r\n\tNameTAOLookup internal _nameTAOLookup;\r\n\tNameTAOPosition internal _nameTAOPosition;\r\n\tNamePublicKey internal _namePublicKey;\r\n\r\n\taddress[] internal names;\r\n\r\n\t// Mapping from eth address to Name ID\r\n\tmapping (address => address) public ethAddressToNameId;\r\n\r\n\t// Mapping from Name ID to its nonce\r\n\tmapping (address => uint256) public nonces;\r\n\r\n\t// Event to be broadcasted to public when a Name is created\r\n\tevent CreateName(address indexed ethAddress, address nameId, uint256 index, string name);\r\n\r\n\t/**\r\n\t * @dev Constructor function\r\n\t */\r\n\tconstructor(address _positionAddress, address _nameTAOVaultAddress) public {\r\n\t\tpositionAddress = _positionAddress;\r\n\t\tnameTAOVaultAddress = _nameTAOVaultAddress;\r\n\t\t_position = Position(positionAddress);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Checks if the calling contract address is The AO\r\n\t *\t\tOR\r\n\t *\t\tIf The AO is set to a Name/TAO, then check if calling address is the Advocate\r\n\t */\r\n\tmodifier onlyTheAO {\r\n\t\trequire (AOLibrary.isTheAO(msg.sender, theAO, nameTAOPositionAddress));\r\n\t\t_;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Checks if calling address can update Name's nonce\r\n\t */\r\n\tmodifier canUpdateNonce {\r\n\t\trequire (msg.sender == nameTAOPositionAddress || msg.sender == namePublicKeyAddress);\r\n\t\t_;\r\n\t}\r\n\r\n\t/***** The AO ONLY METHODS *****/\r\n\t/**\r\n\t * @dev Transfer ownership of The AO to new address\r\n\t * @param _theAO The new address to be transferred\r\n\t */\r\n\tfunction transferOwnership(address _theAO) public onlyTheAO {\r\n\t\trequire (_theAO != address(0));\r\n\t\ttheAO = _theAO;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Whitelist `_account` address to transact on behalf of others\r\n\t * @param _account The address to whitelist\r\n\t * @param _whitelist Either to whitelist or not\r\n\t */\r\n\tfunction setWhitelist(address _account, bool _whitelist) public onlyTheAO {\r\n\t\trequire (_account != address(0));\r\n\t\twhitelist[_account] = _whitelist;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev The AO set the NameTAOLookup Address\r\n\t * @param _nameTAOLookupAddress The address of NameTAOLookup\r\n\t */\r\n\tfunction setNameTAOLookupAddress(address _nameTAOLookupAddress) public onlyTheAO {\r\n\t\trequire (_nameTAOLookupAddress != address(0));\r\n\t\tnameTAOLookupAddress = _nameTAOLookupAddress;\r\n\t\t_nameTAOLookup = NameTAOLookup(nameTAOLookupAddress);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev The AO set the NameTAOPosition Address\r\n\t * @param _nameTAOPositionAddress The address of NameTAOPosition\r\n\t */\r\n\tfunction setNameTAOPositionAddress(address _nameTAOPositionAddress) public onlyTheAO {\r\n\t\trequire (_nameTAOPositionAddress != address(0));\r\n\t\tnameTAOPositionAddress = _nameTAOPositionAddress;\r\n\t\t_nameTAOPosition = NameTAOPosition(nameTAOPositionAddress);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev The AO set the NamePublicKey Address\r\n\t * @param _namePublicKeyAddress The address of NamePublicKey\r\n\t */\r\n\tfunction setNamePublicKeyAddress(address _namePublicKeyAddress) public onlyTheAO {\r\n\t\trequire (_namePublicKeyAddress != address(0));\r\n\t\tnamePublicKeyAddress = _namePublicKeyAddress;\r\n\t\t_namePublicKey = NamePublicKey(namePublicKeyAddress);\r\n\t}\r\n\r\n\t/***** PUBLIC METHODS *****/\r\n\t/**\r\n\t * @dev Increment the nonce of a Name\r\n\t * @param _nameId The ID of the Name\r\n\t * @return current nonce\r\n\t */\r\n\tfunction incrementNonce(address _nameId) public canUpdateNonce returns (uint256) {\r\n\t\t// Check if _nameId exist\r\n\t\trequire (nonces[_nameId] > 0);\r\n\t\tnonces[_nameId]++;\r\n\t\treturn nonces[_nameId];\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Create a Name\r\n\t * @param _name The name of the Name\r\n\t * @param _datHash The datHash to this Name's profile\r\n\t * @param _database The database for this Name\r\n\t * @param _keyValue The key/value pair to be checked on the database\r\n\t * @param _contentId The contentId related to this Name\r\n\t */\r\n\tfunction createName(string _name, string _datHash, string _database, string _keyValue, bytes32 _contentId) public {\r\n\t\trequire (bytes(_name).length > 0);\r\n\t\trequire (!_nameTAOLookup.isExist(_name));\r\n\r\n\t\t// Only one Name per ETH address\r\n\t\trequire (ethAddressToNameId[msg.sender] == address(0));\r\n\r\n\t\t// The address is the Name ID (which is also a TAO ID)\r\n\t\taddress nameId = new Name(_name, msg.sender, _datHash, _database, _keyValue, _contentId, nameTAOVaultAddress);\r\n\r\n\t\t// Increment the nonce\r\n\t\tnonces[nameId]++;\r\n\r\n\t\tethAddressToNameId[msg.sender] = nameId;\r\n\r\n\t\t// Store the name lookup information\r\n\t\trequire (_nameTAOLookup.add(_name, nameId, 'human', 1));\r\n\r\n\t\t// Store the Advocate/Listener/Speaker information\r\n\t\trequire (_nameTAOPosition.add(nameId, nameId, nameId, nameId));\r\n\r\n\t\t// Store the public key information\r\n\t\trequire (_namePublicKey.add(nameId, msg.sender));\r\n\r\n\t\tnames.push(nameId);\r\n\r\n\t\t// Need to mint Position token for this Name\r\n\t\trequire (_position.mintToken(nameId));\r\n\r\n\t\temit CreateName(msg.sender, nameId, names.length.sub(1), _name);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Get Name information\r\n\t * @param _nameId The ID of the Name to be queried\r\n\t * @return The name of the Name\r\n\t * @return The originId of the Name (in this case, it's the creator node's ETH address)\r\n\t * @return The datHash of the Name\r\n\t * @return The database of the Name\r\n\t * @return The keyValue of the Name\r\n\t * @return The contentId of the Name\r\n\t * @return The typeId of the Name\r\n\t */\r\n\tfunction getName(address _nameId) public view returns (string, address, string, string, string, bytes32, uint8) {\r\n\t\tName _name = Name(_nameId);\r\n\t\treturn (\r\n\t\t\t_name.name(),\r\n\t\t\t_name.originId(),\r\n\t\t\t_name.datHash(),\r\n\t\t\t_name.database(),\r\n\t\t\t_name.keyValue(),\r\n\t\t\t_name.contentId(),\r\n\t\t\t_name.typeId()\r\n\t\t);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Get total Names count\r\n\t * @return total Names count\r\n\t */\r\n\tfunction getTotalNamesCount() public view returns (uint256) {\r\n\t\treturn names.length;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Get list of Name IDs\r\n\t * @param _from The starting index\r\n\t * @param _to The ending index\r\n\t * @return list of Name IDs\r\n\t */\r\n\tfunction getNameIds(uint256 _from, uint256 _to) public view returns (address[]) {\r\n\t\trequire (_from >= 0 && _to >= _from);\r\n\t\trequire (names.length > 0);\r\n\r\n\t\taddress[] memory _names = new address[](_to.sub(_from).add(1));\r\n\t\tif (_to > names.length.sub(1)) {\r\n\t\t\t_to = names.length.sub(1);\r\n\t\t}\r\n\t\tfor (uint256 i = _from; i <= _to; i++) {\r\n\t\t\t_names[i.sub(_from)] = names[i];\r\n\t\t}\r\n\t\treturn _names;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Check whether or not the signature is valid\r\n\t * @param _data The signed string data\r\n\t * @param _nonce The signed uint256 nonce (should be Name's current nonce + 1)\r\n\t * @param _validateAddress The ETH address to be validated (optional)\r\n\t * @param _name The name of the Name\r\n\t * @param _signatureV The V part of the signature\r\n\t * @param _signatureR The R part of the signature\r\n\t * @param _signatureS The S part of the signature\r\n\t * @return true if valid. false otherwise\r\n\t */\r\n\tfunction validateNameSignature(\r\n\t\tstring _data,\r\n\t\tuint256 _nonce,\r\n\t\taddress _validateAddress,\r\n\t\tstring _name,\r\n\t\tuint8 _signatureV,\r\n\t\tbytes32 _signatureR,\r\n\t\tbytes32 _signatureS\r\n\t) public view returns (bool) {\r\n\t\trequire (_nameTAOLookup.isExist(_name));\r\n\t\taddress _nameId = _nameTAOLookup.getAddressByName(_name);\r\n\t\taddress _signatureAddress = AOLibrary.getValidateSignatureAddress(address(this), _data, _nonce, _signatureV, _signatureR, _signatureS);\r\n\t\tif (_validateAddress != address(0)) {\r\n\t\t\treturn (\r\n\t\t\t\t_nonce == nonces[_nameId].add(1) &&\r\n\t\t\t\t_signatureAddress == _validateAddress &&\r\n\t\t\t\t_namePublicKey.isKeyExist(_nameId, _validateAddress)\r\n\t\t\t);\r\n\t\t} else {\r\n\t\t\treturn (\r\n\t\t\t\t_nonce == nonces[_nameId].add(1) &&\r\n\t\t\t\t_signatureAddress == _namePublicKey.getDefaultKey(_nameId)\r\n\t\t\t);\r\n\t\t}\r\n\t}\r\n}\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title AOStringSetting\r\n *\r\n * This contract stores all AO string setting variables\r\n */\r\ncontract AOStringSetting is TheAO {\r\n\t// Mapping from settingId to it's actual string value\r\n\tmapping (uint256 => string) public settingValue;\r\n\r\n\t// Mapping from settingId to it's potential string value that is at pending state\r\n\tmapping (uint256 => string) public pendingValue;\r\n\r\n\t/**\r\n\t * @dev Constructor function\r\n\t */\r\n\tconstructor() public {}\r\n\r\n\t/**\r\n\t * @dev Checks if the calling contract address is The AO\r\n\t *\t\tOR\r\n\t *\t\tIf The AO is set to a Name/TAO, then check if calling address is the Advocate\r\n\t */\r\n\tmodifier onlyTheAO {\r\n\t\trequire (AOLibrary.isTheAO(msg.sender, theAO, nameTAOPositionAddress));\r\n\t\t_;\r\n\t}\r\n\r\n\t/***** The AO ONLY METHODS *****/\r\n\t/**\r\n\t * @dev The AO set the NameTAOPosition Address\r\n\t * @param _nameTAOPositionAddress The address of NameTAOPosition\r\n\t */\r\n\tfunction setNameTAOPositionAddress(address _nameTAOPositionAddress) public onlyTheAO {\r\n\t\trequire (_nameTAOPositionAddress != address(0));\r\n\t\tnameTAOPositionAddress = _nameTAOPositionAddress;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Transfer ownership of The AO to new address\r\n\t * @param _theAO The new address to be transferred\r\n\t */\r\n\tfunction transferOwnership(address _theAO) public onlyTheAO {\r\n\t\trequire (_theAO != address(0));\r\n\t\ttheAO = _theAO;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Whitelist `_account` address to transact on behalf of others\r\n\t * @param _account The address to whitelist\r\n\t * @param _whitelist Either to whitelist or not\r\n\t */\r\n\tfunction setWhitelist(address _account, bool _whitelist) public onlyTheAO {\r\n\t\trequire (_account != address(0));\r\n\t\twhitelist[_account] = _whitelist;\r\n\t}\r\n\r\n\t/***** PUBLIC METHODS *****/\r\n\t/**\r\n\t * @dev Set pending value\r\n\t * @param _settingId The ID of the setting\r\n\t * @param _value The string value to be set\r\n\t */\r\n\tfunction setPendingValue(uint256 _settingId, string _value) public inWhitelist {\r\n\t\tpendingValue[_settingId] = _value;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Move value from pending to setting\r\n\t * @param _settingId The ID of the setting\r\n\t */\r\n\tfunction movePendingToSetting(uint256 _settingId) public inWhitelist {\r\n\t\tstring memory _tempValue = pendingValue[_settingId];\r\n\t\tdelete pendingValue[_settingId];\r\n\t\tsettingValue[_settingId] = _tempValue;\r\n\t}\r\n}\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title AOBytesSetting\r\n *\r\n * This contract stores all AO bytes32 setting variables\r\n */\r\ncontract AOBytesSetting is TheAO {\r\n\t// Mapping from settingId to it's actual bytes32 value\r\n\tmapping (uint256 => bytes32) public settingValue;\r\n\r\n\t// Mapping from settingId to it's potential bytes32 value that is at pending state\r\n\tmapping (uint256 => bytes32) public pendingValue;\r\n\r\n\t/**\r\n\t * @dev Constructor function\r\n\t */\r\n\tconstructor() public {}\r\n\r\n\t/**\r\n\t * @dev Checks if the calling contract address is The AO\r\n\t *\t\tOR\r\n\t *\t\tIf The AO is set to a Name/TAO, then check if calling address is the Advocate\r\n\t */\r\n\tmodifier onlyTheAO {\r\n\t\trequire (AOLibrary.isTheAO(msg.sender, theAO, nameTAOPositionAddress));\r\n\t\t_;\r\n\t}\r\n\r\n\t/***** The AO ONLY METHODS *****/\r\n\t/**\r\n\t * @dev The AO set the NameTAOPosition Address\r\n\t * @param _nameTAOPositionAddress The address of NameTAOPosition\r\n\t */\r\n\tfunction setNameTAOPositionAddress(address _nameTAOPositionAddress) public onlyTheAO {\r\n\t\trequire (_nameTAOPositionAddress != address(0));\r\n\t\tnameTAOPositionAddress = _nameTAOPositionAddress;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Transfer ownership of The AO to new address\r\n\t * @param _theAO The new address to be transferred\r\n\t */\r\n\tfunction transferOwnership(address _theAO) public onlyTheAO {\r\n\t\trequire (_theAO != address(0));\r\n\t\ttheAO = _theAO;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Whitelist `_account` address to transact on behalf of others\r\n\t * @param _account The address to whitelist\r\n\t * @param _whitelist Either to whitelist or not\r\n\t */\r\n\tfunction setWhitelist(address _account, bool _whitelist) public onlyTheAO {\r\n\t\trequire (_account != address(0));\r\n\t\twhitelist[_account] = _whitelist;\r\n\t}\r\n\r\n\t/***** PUBLIC METHODS *****/\r\n\t/**\r\n\t * @dev Set pending value\r\n\t * @param _settingId The ID of the setting\r\n\t * @param _value The bytes32 value to be set\r\n\t */\r\n\tfunction setPendingValue(uint256 _settingId, bytes32 _value) public inWhitelist {\r\n\t\tpendingValue[_settingId] = _value;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Move value from pending to setting\r\n\t * @param _settingId The ID of the setting\r\n\t */\r\n\tfunction movePendingToSetting(uint256 _settingId) public inWhitelist {\r\n\t\tbytes32 _tempValue = pendingValue[_settingId];\r\n\t\tdelete pendingValue[_settingId];\r\n\t\tsettingValue[_settingId] = _tempValue;\r\n\t}\r\n}\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title AOAddressSetting\r\n *\r\n * This contract stores all AO address setting variables\r\n */\r\ncontract AOAddressSetting is TheAO {\r\n\t// Mapping from settingId to it's actual address value\r\n\tmapping (uint256 => address) public settingValue;\r\n\r\n\t// Mapping from settingId to it's potential address value that is at pending state\r\n\tmapping (uint256 => address) public pendingValue;\r\n\r\n\t/**\r\n\t * @dev Constructor function\r\n\t */\r\n\tconstructor() public {}\r\n\r\n\t/**\r\n\t * @dev Checks if the calling contract address is The AO\r\n\t *\t\tOR\r\n\t *\t\tIf The AO is set to a Name/TAO, then check if calling address is the Advocate\r\n\t */\r\n\tmodifier onlyTheAO {\r\n\t\trequire (AOLibrary.isTheAO(msg.sender, theAO, nameTAOPositionAddress));\r\n\t\t_;\r\n\t}\r\n\r\n\t/***** The AO ONLY METHODS *****/\r\n\t/**\r\n\t * @dev The AO set the NameTAOPosition Address\r\n\t * @param _nameTAOPositionAddress The address of NameTAOPosition\r\n\t */\r\n\tfunction setNameTAOPositionAddress(address _nameTAOPositionAddress) public onlyTheAO {\r\n\t\trequire (_nameTAOPositionAddress != address(0));\r\n\t\tnameTAOPositionAddress = _nameTAOPositionAddress;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Transfer ownership of The AO to new address\r\n\t * @param _theAO The new address to be transferred\r\n\t */\r\n\tfunction transferOwnership(address _theAO) public onlyTheAO {\r\n\t\trequire (_theAO != address(0));\r\n\t\ttheAO = _theAO;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Whitelist `_account` address to transact on behalf of others\r\n\t * @param _account The address to whitelist\r\n\t * @param _whitelist Either to whitelist or not\r\n\t */\r\n\tfunction setWhitelist(address _account, bool _whitelist) public onlyTheAO {\r\n\t\trequire (_account != address(0));\r\n\t\twhitelist[_account] = _whitelist;\r\n\t}\r\n\r\n\t/***** PUBLIC METHODS *****/\r\n\t/**\r\n\t * @dev Set pending value\r\n\t * @param _settingId The ID of the setting\r\n\t * @param _value The address value to be set\r\n\t */\r\n\tfunction setPendingValue(uint256 _settingId, address _value) public inWhitelist {\r\n\t\tpendingValue[_settingId] = _value;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Move value from pending to setting\r\n\t * @param _settingId The ID of the setting\r\n\t */\r\n\tfunction movePendingToSetting(uint256 _settingId) public inWhitelist {\r\n\t\taddress _tempValue = pendingValue[_settingId];\r\n\t\tdelete pendingValue[_settingId];\r\n\t\tsettingValue[_settingId] = _tempValue;\r\n\t}\r\n}\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title AOBoolSetting\r\n *\r\n * This contract stores all AO bool setting variables\r\n */\r\ncontract AOBoolSetting is TheAO {\r\n\t// Mapping from settingId to it's actual bool value\r\n\tmapping (uint256 => bool) public settingValue;\r\n\r\n\t// Mapping from settingId to it's potential bool value that is at pending state\r\n\tmapping (uint256 => bool) public pendingValue;\r\n\r\n\t/**\r\n\t * @dev Constructor function\r\n\t */\r\n\tconstructor() public {}\r\n\r\n\t/**\r\n\t * @dev Checks if the calling contract address is The AO\r\n\t *\t\tOR\r\n\t *\t\tIf The AO is set to a Name/TAO, then check if calling address is the Advocate\r\n\t */\r\n\tmodifier onlyTheAO {\r\n\t\trequire (AOLibrary.isTheAO(msg.sender, theAO, nameTAOPositionAddress));\r\n\t\t_;\r\n\t}\r\n\r\n\t/***** The AO ONLY METHODS *****/\r\n\t/**\r\n\t * @dev The AO set the NameTAOPosition Address\r\n\t * @param _nameTAOPositionAddress The address of NameTAOPosition\r\n\t */\r\n\tfunction setNameTAOPositionAddress(address _nameTAOPositionAddress) public onlyTheAO {\r\n\t\trequire (_nameTAOPositionAddress != address(0));\r\n\t\tnameTAOPositionAddress = _nameTAOPositionAddress;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Transfer ownership of The AO to new address\r\n\t * @param _theAO The new address to be transferred\r\n\t */\r\n\tfunction transferOwnership(address _theAO) public onlyTheAO {\r\n\t\trequire (_theAO != address(0));\r\n\t\ttheAO = _theAO;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Whitelist `_account` address to transact on behalf of others\r\n\t * @param _account The address to whitelist\r\n\t * @param _whitelist Either to whitelist or not\r\n\t */\r\n\tfunction setWhitelist(address _account, bool _whitelist) public onlyTheAO {\r\n\t\trequire (_account != address(0));\r\n\t\twhitelist[_account] = _whitelist;\r\n\t}\r\n\r\n\t/***** PUBLIC METHODS *****/\r\n\t/**\r\n\t * @dev Set pending value\r\n\t * @param _settingId The ID of the setting\r\n\t * @param _value The bool value to be set\r\n\t */\r\n\tfunction setPendingValue(uint256 _settingId, bool _value) public inWhitelist {\r\n\t\tpendingValue[_settingId] = _value;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Move value from pending to setting\r\n\t * @param _settingId The ID of the setting\r\n\t */\r\n\tfunction movePendingToSetting(uint256 _settingId) public inWhitelist {\r\n\t\tbool _tempValue = pendingValue[_settingId];\r\n\t\tdelete pendingValue[_settingId];\r\n\t\tsettingValue[_settingId] = _tempValue;\r\n\t}\r\n}\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title AOUintSetting\r\n *\r\n * This contract stores all AO uint256 setting variables\r\n */\r\ncontract AOUintSetting is TheAO {\r\n\t// Mapping from settingId to it's actual uint256 value\r\n\tmapping (uint256 => uint256) public settingValue;\r\n\r\n\t// Mapping from settingId to it's potential uint256 value that is at pending state\r\n\tmapping (uint256 => uint256) public pendingValue;\r\n\r\n\t/**\r\n\t * @dev Constructor function\r\n\t */\r\n\tconstructor() public {}\r\n\r\n\t/**\r\n\t * @dev Checks if the calling contract address is The AO\r\n\t *\t\tOR\r\n\t *\t\tIf The AO is set to a Name/TAO, then check if calling address is the Advocate\r\n\t */\r\n\tmodifier onlyTheAO {\r\n\t\trequire (AOLibrary.isTheAO(msg.sender, theAO, nameTAOPositionAddress));\r\n\t\t_;\r\n\t}\r\n\r\n\t/***** The AO ONLY METHODS *****/\r\n\t/**\r\n\t * @dev The AO set the NameTAOPosition Address\r\n\t * @param _nameTAOPositionAddress The address of NameTAOPosition\r\n\t */\r\n\tfunction setNameTAOPositionAddress(address _nameTAOPositionAddress) public onlyTheAO {\r\n\t\trequire (_nameTAOPositionAddress != address(0));\r\n\t\tnameTAOPositionAddress = _nameTAOPositionAddress;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Transfer ownership of The AO to new address\r\n\t * @param _theAO The new address to be transferred\r\n\t */\r\n\tfunction transferOwnership(address _theAO) public onlyTheAO {\r\n\t\trequire (_theAO != address(0));\r\n\t\ttheAO = _theAO;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Whitelist `_account` address to transact on behalf of others\r\n\t * @param _account The address to whitelist\r\n\t * @param _whitelist Either to whitelist or not\r\n\t */\r\n\tfunction setWhitelist(address _account, bool _whitelist) public onlyTheAO {\r\n\t\trequire (_account != address(0));\r\n\t\twhitelist[_account] = _whitelist;\r\n\t}\r\n\r\n\t/***** PUBLIC METHODS *****/\r\n\t/**\r\n\t * @dev Set pending value\r\n\t * @param _settingId The ID of the setting\r\n\t * @param _value The uint256 value to be set\r\n\t */\r\n\tfunction setPendingValue(uint256 _settingId, uint256 _value) public inWhitelist {\r\n\t\tpendingValue[_settingId] = _value;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Move value from pending to setting\r\n\t * @param _settingId The ID of the setting\r\n\t */\r\n\tfunction movePendingToSetting(uint256 _settingId) public inWhitelist {\r\n\t\tuint256 _tempValue = pendingValue[_settingId];\r\n\t\tdelete pendingValue[_settingId];\r\n\t\tsettingValue[_settingId] = _tempValue;\r\n\t}\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title AOSettingAttribute\r\n *\r\n * This contract stores all AO setting data/state\r\n */\r\ncontract AOSettingAttribute is TheAO {\r\n\tNameTAOPosition internal _nameTAOPosition;\r\n\r\n\tstruct SettingData {\r\n\t\tuint256 settingId;\t\t\t\t// Identifier of this setting\r\n\t\taddress creatorNameId;\t\t\t// The nameId that created the setting\r\n\t\taddress creatorTAOId;\t\t// The taoId that created the setting\r\n\t\taddress associatedTAOId;\t// The taoId that the setting affects\r\n\t\tstring settingName;\t\t\t\t// The human-readable name of the setting\r\n\t\t/**\r\n\t\t * 1 => uint256\r\n\t\t * 2 => bool\r\n\t\t * 3 => address\r\n\t\t * 4 => bytes32\r\n\t\t * 5 => string (catch all)\r\n\t\t */\r\n\t\tuint8 settingType;\r\n\t\tbool pendingCreate;\t\t\t\t// State when associatedTAOId has not accepted setting\r\n\t\tbool locked;\t\t\t\t\t// State when pending anything (cannot change if locked)\r\n\t\tbool rejected;\t\t\t\t\t// State when associatedTAOId rejected this setting\r\n\t\tstring settingDataJSON;\t\t\t// Catch-all\r\n\t}\r\n\r\n\tstruct SettingState {\r\n\t\tuint256 settingId;\t\t\t\t// Identifier of this setting\r\n\t\tbool pendingUpdate;\t\t\t\t// State when setting is in process of being updated\r\n\t\taddress updateAdvocateNameId;\t// The nameId of the Advocate that performed the update\r\n\r\n\t\t/**\r\n\t\t * A child of the associatedTAOId with the update Logos.\r\n\t\t * This tells the setting contract that there is a proposal TAO that is a Child TAO\r\n\t\t * of the associated TAO, which will be responsible for deciding if the update to the\r\n\t\t * setting is accepted or rejected.\r\n\t\t */\r\n\t\taddress proposalTAOId;\r\n\r\n\t\t/**\r\n\t\t * Signature of the proposalTAOId and update value by the associatedTAOId\r\n\t\t * Advocate's Name's address.\r\n\t\t */\r\n\t\tstring updateSignature;\r\n\r\n\t\t/**\r\n\t\t * The proposalTAOId moves here when setting value changes successfully\r\n\t\t */\r\n\t\taddress lastUpdateTAOId;\r\n\r\n\t\tstring settingStateJSON;\t\t// Catch-all\r\n\t}\r\n\r\n\tstruct SettingDeprecation {\r\n\t\tuint256 settingId;\t\t\t\t// Identifier of this setting\r\n\t\taddress creatorNameId;\t\t\t// The nameId that created this deprecation\r\n\t\taddress creatorTAOId;\t\t// The taoId that created this deprecation\r\n\t\taddress associatedTAOId;\t// The taoId that the setting affects\r\n\t\tbool pendingDeprecated;\t\t\t// State when associatedTAOId has not accepted setting\r\n\t\tbool locked;\t\t\t\t\t// State when pending anything (cannot change if locked)\r\n\t\tbool rejected;\t\t\t\t\t// State when associatedTAOId rejected this setting\r\n\t\tbool migrated;\t\t\t\t\t// State when this setting is fully migrated\r\n\r\n\t\t// holds the pending new settingId value when a deprecation is set\r\n\t\tuint256 pendingNewSettingId;\r\n\r\n\t\t// holds the new settingId that has been approved by associatedTAOId\r\n\t\tuint256 newSettingId;\r\n\r\n\t\t// holds the pending new contract address for this setting\r\n\t\taddress pendingNewSettingContractAddress;\r\n\r\n\t\t// holds the new contract address for this setting\r\n\t\taddress newSettingContractAddress;\r\n\t}\r\n\r\n\tstruct AssociatedTAOSetting {\r\n\t\tbytes32 associatedTAOSettingId;\t\t// Identifier\r\n\t\taddress associatedTAOId;\t\t\t// The TAO ID that the setting is associated to\r\n\t\tuint256 settingId;\t\t\t\t\t\t// The Setting ID that is associated with the TAO ID\r\n\t}\r\n\r\n\tstruct CreatorTAOSetting {\r\n\t\tbytes32 creatorTAOSettingId;\t\t// Identifier\r\n\t\taddress creatorTAOId;\t\t\t\t// The TAO ID that the setting was created from\r\n\t\tuint256 settingId;\t\t\t\t\t\t// The Setting ID created from the TAO ID\r\n\t}\r\n\r\n\tstruct AssociatedTAOSettingDeprecation {\r\n\t\tbytes32 associatedTAOSettingDeprecationId;\t\t// Identifier\r\n\t\taddress associatedTAOId;\t\t\t\t\t\t// The TAO ID that the setting is associated to\r\n\t\tuint256 settingId;\t\t\t\t\t\t\t\t\t// The Setting ID that is associated with the TAO ID\r\n\t}\r\n\r\n\tstruct CreatorTAOSettingDeprecation {\r\n\t\tbytes32 creatorTAOSettingDeprecationId;\t\t\t// Identifier\r\n\t\taddress creatorTAOId;\t\t\t\t\t\t\t// The TAO ID that the setting was created from\r\n\t\tuint256 settingId;\t\t\t\t\t\t\t\t\t// The Setting ID created from the TAO ID\r\n\t}\r\n\r\n\t// Mapping from settingId to it's data\r\n\tmapping (uint256 => SettingData) internal settingDatas;\r\n\r\n\t// Mapping from settingId to it's state\r\n\tmapping (uint256 => SettingState) internal settingStates;\r\n\r\n\t// Mapping from settingId to it's deprecation info\r\n\tmapping (uint256 => SettingDeprecation) internal settingDeprecations;\r\n\r\n\t// Mapping from associatedTAOSettingId to AssociatedTAOSetting\r\n\tmapping (bytes32 => AssociatedTAOSetting) internal associatedTAOSettings;\r\n\r\n\t// Mapping from creatorTAOSettingId to CreatorTAOSetting\r\n\tmapping (bytes32 => CreatorTAOSetting) internal creatorTAOSettings;\r\n\r\n\t// Mapping from associatedTAOSettingDeprecationId to AssociatedTAOSettingDeprecation\r\n\tmapping (bytes32 => AssociatedTAOSettingDeprecation) internal associatedTAOSettingDeprecations;\r\n\r\n\t// Mapping from creatorTAOSettingDeprecationId to CreatorTAOSettingDeprecation\r\n\tmapping (bytes32 => CreatorTAOSettingDeprecation) internal creatorTAOSettingDeprecations;\r\n\r\n\t/**\r\n\t * @dev Constructor function\r\n\t */\r\n\tconstructor(address _nameTAOPositionAddress) public {\r\n\t\tnameTAOPositionAddress = _nameTAOPositionAddress;\r\n\t\t_nameTAOPosition = NameTAOPosition(_nameTAOPositionAddress);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Checks if the calling contract address is The AO\r\n\t *\t\tOR\r\n\t *\t\tIf The AO is set to a Name/TAO, then check if calling address is the Advocate\r\n\t */\r\n\tmodifier onlyTheAO {\r\n\t\trequire (AOLibrary.isTheAO(msg.sender, theAO, nameTAOPositionAddress));\r\n\t\t_;\r\n\t}\r\n\r\n\t/***** The AO ONLY METHODS *****/\r\n\t/**\r\n\t * @dev Transfer ownership of The AO to new address\r\n\t * @param _theAO The new address to be transferred\r\n\t */\r\n\tfunction transferOwnership(address _theAO) public onlyTheAO {\r\n\t\trequire (_theAO != address(0));\r\n\t\ttheAO = _theAO;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Whitelist `_account` address to transact on behalf of others\r\n\t * @param _account The address to whitelist\r\n\t * @param _whitelist Either to whitelist or not\r\n\t */\r\n\tfunction setWhitelist(address _account, bool _whitelist) public onlyTheAO {\r\n\t\trequire (_account != address(0));\r\n\t\twhitelist[_account] = _whitelist;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Add setting data/state\r\n\t * @param _settingId The ID of the setting\r\n\t * @param _creatorNameId The nameId that created the setting\r\n\t * @param _settingType The type of this setting. 1 => uint256, 2 => bool, 3 => address, 4 => bytes32, 5 => string\r\n\t * @param _settingName The human-readable name of the setting\r\n\t * @param _creatorTAOId The taoId that created the setting\r\n\t * @param _associatedTAOId The taoId that the setting affects\r\n\t * @param _extraData Catch-all string value to be stored if exist\r\n\t * @return The ID of the \"Associated\" setting\r\n\t * @return The ID of the \"Creator\" setting\r\n\t */\r\n\tfunction add(uint256 _settingId, address _creatorNameId, uint8 _settingType, string _settingName, address _creatorTAOId, address _associatedTAOId, string _extraData) public inWhitelist returns (bytes32, bytes32) {\r\n\t\t// Store setting data/state\r\n\t\trequire (_storeSettingDataState(_settingId, _creatorNameId, _settingType, _settingName, _creatorTAOId, _associatedTAOId, _extraData));\r\n\r\n\t\t// Store the associatedTAOSetting info\r\n\t\tbytes32 _associatedTAOSettingId = keccak256(abi.encodePacked(this, _associatedTAOId, _settingId));\r\n\t\tAssociatedTAOSetting storage _associatedTAOSetting = associatedTAOSettings[_associatedTAOSettingId];\r\n\t\t_associatedTAOSetting.associatedTAOSettingId = _associatedTAOSettingId;\r\n\t\t_associatedTAOSetting.associatedTAOId = _associatedTAOId;\r\n\t\t_associatedTAOSetting.settingId = _settingId;\r\n\r\n\t\t// Store the creatorTAOSetting info\r\n\t\tbytes32 _creatorTAOSettingId = keccak256(abi.encodePacked(this, _creatorTAOId, _settingId));\r\n\t\tCreatorTAOSetting storage _creatorTAOSetting = creatorTAOSettings[_creatorTAOSettingId];\r\n\t\t_creatorTAOSetting.creatorTAOSettingId = _creatorTAOSettingId;\r\n\t\t_creatorTAOSetting.creatorTAOId = _creatorTAOId;\r\n\t\t_creatorTAOSetting.settingId = _settingId;\r\n\r\n\t\treturn (_associatedTAOSettingId, _creatorTAOSettingId);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Get Setting Data of a setting ID\r\n\t * @param _settingId The ID of the setting\r\n\t */\r\n\tfunction getSettingData(uint256 _settingId) public view returns (uint256, address, address, address, string, uint8, bool, bool, bool, string) {\r\n\t\tSettingData memory _settingData = settingDatas[_settingId];\r\n\t\treturn (\r\n\t\t\t_settingData.settingId,\r\n\t\t\t_settingData.creatorNameId,\r\n\t\t\t_settingData.creatorTAOId,\r\n\t\t\t_settingData.associatedTAOId,\r\n\t\t\t_settingData.settingName,\r\n\t\t\t_settingData.settingType,\r\n\t\t\t_settingData.pendingCreate,\r\n\t\t\t_settingData.locked,\r\n\t\t\t_settingData.rejected,\r\n\t\t\t_settingData.settingDataJSON\r\n\t\t);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Get Associated TAO Setting info\r\n\t * @param _associatedTAOSettingId The ID of the associated tao setting\r\n\t */\r\n\tfunction getAssociatedTAOSetting(bytes32 _associatedTAOSettingId) public view returns (bytes32, address, uint256) {\r\n\t\tAssociatedTAOSetting memory _associatedTAOSetting = associatedTAOSettings[_associatedTAOSettingId];\r\n\t\treturn (\r\n\t\t\t_associatedTAOSetting.associatedTAOSettingId,\r\n\t\t\t_associatedTAOSetting.associatedTAOId,\r\n\t\t\t_associatedTAOSetting.settingId\r\n\t\t);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Get Creator TAO Setting info\r\n\t * @param _creatorTAOSettingId The ID of the creator tao setting\r\n\t */\r\n\tfunction getCreatorTAOSetting(bytes32 _creatorTAOSettingId) public view returns (bytes32, address, uint256) {\r\n\t\tCreatorTAOSetting memory _creatorTAOSetting = creatorTAOSettings[_creatorTAOSettingId];\r\n\t\treturn (\r\n\t\t\t_creatorTAOSetting.creatorTAOSettingId,\r\n\t\t\t_creatorTAOSetting.creatorTAOId,\r\n\t\t\t_creatorTAOSetting.settingId\r\n\t\t);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Advocate of Setting's _associatedTAOId approves setting creation\r\n\t * @param _settingId The ID of the setting to approve\r\n\t * @param _associatedTAOAdvocate The advocate of the associated TAO\r\n\t * @param _approved Whether to approve or reject\r\n\t * @return true on success\r\n\t */\r\n\tfunction approveAdd(uint256 _settingId, address _associatedTAOAdvocate, bool _approved) public inWhitelist returns (bool) {\r\n\t\t// Make sure setting exists and needs approval\r\n\t\tSettingData storage _settingData = settingDatas[_settingId];\r\n\t\trequire (_settingData.settingId == _settingId &&\r\n\t\t\t_settingData.pendingCreate == true &&\r\n\t\t\t_settingData.locked == true &&\r\n\t\t\t_settingData.rejected == false &&\r\n\t\t\t_associatedTAOAdvocate != address(0) &&\r\n\t\t\t_associatedTAOAdvocate == _nameTAOPosition.getAdvocate(_settingData.associatedTAOId)\r\n\t\t);\r\n\r\n\t\tif (_approved) {\r\n\t\t\t// Unlock the setting so that advocate of creatorTAOId can finalize the creation\r\n\t\t\t_settingData.locked = false;\r\n\t\t} else {\r\n\t\t\t// Reject the setting\r\n\t\t\t_settingData.pendingCreate = false;\r\n\t\t\t_settingData.rejected = true;\r\n\t\t}\r\n\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Advocate of Setting's _creatorTAOId finalizes the setting creation once the setting is approved\r\n\t * @param _settingId The ID of the setting to be finalized\r\n\t * @param _creatorTAOAdvocate The advocate of the creator TAO\r\n\t * @return true on success\r\n\t */\r\n\tfunction finalizeAdd(uint256 _settingId, address _creatorTAOAdvocate) public inWhitelist returns (bool) {\r\n\t\t// Make sure setting exists and needs approval\r\n\t\tSettingData storage _settingData = settingDatas[_settingId];\r\n\t\trequire (_settingData.settingId == _settingId &&\r\n\t\t\t_settingData.pendingCreate == true &&\r\n\t\t\t_settingData.locked == false &&\r\n\t\t\t_settingData.rejected == false &&\r\n\t\t\t_creatorTAOAdvocate != address(0) &&\r\n\t\t\t_creatorTAOAdvocate == _nameTAOPosition.getAdvocate(_settingData.creatorTAOId)\r\n\t\t);\r\n\r\n\t\t// Update the setting data\r\n\t\t_settingData.pendingCreate = false;\r\n\t\t_settingData.locked = true;\r\n\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Store setting update data\r\n\t * @param _settingId The ID of the setting to be updated\r\n\t * @param _settingType The type of this setting\r\n\t * @param _associatedTAOAdvocate The setting's associatedTAOId's advocate's name address\r\n\t * @param _proposalTAOId The child of the associatedTAOId with the update Logos\r\n\t * @param _updateSignature A signature of the proposalTAOId and update value by _associatedTAOAdvocate\r\n\t * @param _extraData Catch-all string value to be stored if exist\r\n\t * @return true on success\r\n\t */\r\n\tfunction update(uint256 _settingId, uint8 _settingType, address _associatedTAOAdvocate, address _proposalTAOId, string _updateSignature, string _extraData) public inWhitelist returns (bool) {\r\n\t\t// Make sure setting is created\r\n\t\tSettingData memory _settingData = settingDatas[_settingId];\r\n\t\trequire (_settingData.settingId == _settingId &&\r\n\t\t\t_settingData.settingType == _settingType &&\r\n\t\t\t_settingData.pendingCreate == false &&\r\n\t\t\t_settingData.locked == true &&\r\n\t\t\t_settingData.rejected == false &&\r\n\t\t\t_associatedTAOAdvocate != address(0) &&\r\n\t\t\t_associatedTAOAdvocate == _nameTAOPosition.getAdvocate(_settingData.associatedTAOId) &&\r\n\t\t\tbytes(_updateSignature).length > 0\r\n\t\t);\r\n\r\n\t\t// Make sure setting is not in the middle of updating\r\n\t\tSettingState storage _settingState = settingStates[_settingId];\r\n\t\trequire (_settingState.pendingUpdate == false);\r\n\r\n\t\t// Make sure setting is not yet deprecated\r\n\t\tSettingDeprecation memory _settingDeprecation = settingDeprecations[_settingId];\r\n\t\tif (_settingDeprecation.settingId == _settingId) {\r\n\t\t\trequire (_settingDeprecation.migrated == false);\r\n\t\t}\r\n\r\n\t\t// Store the SettingState data\r\n\t\t_settingState.pendingUpdate = true;\r\n\t\t_settingState.updateAdvocateNameId = _associatedTAOAdvocate;\r\n\t\t_settingState.proposalTAOId = _proposalTAOId;\r\n\t\t_settingState.updateSignature = _updateSignature;\r\n\t\t_settingState.settingStateJSON = _extraData;\r\n\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Get setting state\r\n\t * @param _settingId The ID of the setting\r\n\t */\r\n\tfunction getSettingState(uint256 _settingId) public view returns (uint256, bool, address, address, string, address, string) {\r\n\t\tSettingState memory _settingState = settingStates[_settingId];\r\n\t\treturn (\r\n\t\t\t_settingState.settingId,\r\n\t\t\t_settingState.pendingUpdate,\r\n\t\t\t_settingState.updateAdvocateNameId,\r\n\t\t\t_settingState.proposalTAOId,\r\n\t\t\t_settingState.updateSignature,\r\n\t\t\t_settingState.lastUpdateTAOId,\r\n\t\t\t_settingState.settingStateJSON\r\n\t\t);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Advocate of Setting's proposalTAOId approves the setting update\r\n\t * @param _settingId The ID of the setting to be approved\r\n\t * @param _proposalTAOAdvocate The advocate of the proposal TAO\r\n\t * @param _approved Whether to approve or reject\r\n\t * @return true on success\r\n\t */\r\n\tfunction approveUpdate(uint256 _settingId, address _proposalTAOAdvocate, bool _approved) public inWhitelist returns (bool) {\r\n\t\t// Make sure setting is created\r\n\t\tSettingData storage _settingData = settingDatas[_settingId];\r\n\t\trequire (_settingData.settingId == _settingId && _settingData.pendingCreate == false && _settingData.locked == true && _settingData.rejected == false);\r\n\r\n\t\t// Make sure setting update exists and needs approval\r\n\t\tSettingState storage _settingState = settingStates[_settingId];\r\n\t\trequire (_settingState.settingId == _settingId &&\r\n\t\t\t_settingState.pendingUpdate == true &&\r\n\t\t\t_proposalTAOAdvocate != address(0) &&\r\n\t\t\t_proposalTAOAdvocate == _nameTAOPosition.getAdvocate(_settingState.proposalTAOId)\r\n\t\t);\r\n\r\n\t\tif (_approved) {\r\n\t\t\t// Unlock the setting so that advocate of associatedTAOId can finalize the update\r\n\t\t\t_settingData.locked = false;\r\n\t\t} else {\r\n\t\t\t// Set pendingUpdate to false\r\n\t\t\t_settingState.pendingUpdate = false;\r\n\t\t\t_settingState.proposalTAOId = address(0);\r\n\t\t}\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Advocate of Setting's _associatedTAOId finalizes the setting update once the setting is approved\r\n\t * @param _settingId The ID of the setting to be finalized\r\n\t * @param _associatedTAOAdvocate The advocate of the associated TAO\r\n\t * @return true on success\r\n\t */\r\n\tfunction finalizeUpdate(uint256 _settingId, address _associatedTAOAdvocate) public inWhitelist returns (bool) {\r\n\t\t// Make sure setting is created\r\n\t\tSettingData storage _settingData = settingDatas[_settingId];\r\n\t\trequire (_settingData.settingId == _settingId &&\r\n\t\t\t_settingData.pendingCreate == false &&\r\n\t\t\t_settingData.locked == false &&\r\n\t\t\t_settingData.rejected == false &&\r\n\t\t\t_associatedTAOAdvocate != address(0) &&\r\n\t\t\t_associatedTAOAdvocate == _nameTAOPosition.getAdvocate(_settingData.associatedTAOId)\r\n\t\t);\r\n\r\n\t\t// Make sure setting update exists and needs approval\r\n\t\tSettingState storage _settingState = settingStates[_settingId];\r\n\t\trequire (_settingState.settingId == _settingId && _settingState.pendingUpdate == true && _settingState.proposalTAOId != address(0));\r\n\r\n\t\t// Update the setting data\r\n\t\t_settingData.locked = true;\r\n\r\n\t\t// Update the setting state\r\n\t\t_settingState.pendingUpdate = false;\r\n\t\t_settingState.updateAdvocateNameId = _associatedTAOAdvocate;\r\n\t\taddress _proposalTAOId = _settingState.proposalTAOId;\r\n\t\t_settingState.proposalTAOId = address(0);\r\n\t\t_settingState.lastUpdateTAOId = _proposalTAOId;\r\n\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Add setting deprecation\r\n\t * @param _settingId The ID of the setting\r\n\t * @param _creatorNameId The nameId that created the setting\r\n\t * @param _creatorTAOId The taoId that created the setting\r\n\t * @param _associatedTAOId The taoId that the setting affects\r\n\t * @param _newSettingId The new settingId value to route\r\n\t * @param _newSettingContractAddress The address of the new setting contract to route\r\n\t * @return The ID of the \"Associated\" setting deprecation\r\n\t * @return The ID of the \"Creator\" setting deprecation\r\n\t */\r\n\tfunction addDeprecation(uint256 _settingId, address _creatorNameId, address _creatorTAOId, address _associatedTAOId, uint256 _newSettingId, address _newSettingContractAddress) public inWhitelist returns (bytes32, bytes32) {\r\n\t\trequire (_storeSettingDeprecation(_settingId, _creatorNameId, _creatorTAOId, _associatedTAOId, _newSettingId, _newSettingContractAddress));\r\n\r\n\t\t// Store the associatedTAOSettingDeprecation info\r\n\t\tbytes32 _associatedTAOSettingDeprecationId = keccak256(abi.encodePacked(this, _associatedTAOId, _settingId));\r\n\t\tAssociatedTAOSettingDeprecation storage _associatedTAOSettingDeprecation = associatedTAOSettingDeprecations[_associatedTAOSettingDeprecationId];\r\n\t\t_associatedTAOSettingDeprecation.associatedTAOSettingDeprecationId = _associatedTAOSettingDeprecationId;\r\n\t\t_associatedTAOSettingDeprecation.associatedTAOId = _associatedTAOId;\r\n\t\t_associatedTAOSettingDeprecation.settingId = _settingId;\r\n\r\n\t\t// Store the creatorTAOSettingDeprecation info\r\n\t\tbytes32 _creatorTAOSettingDeprecationId = keccak256(abi.encodePacked(this, _creatorTAOId, _settingId));\r\n\t\tCreatorTAOSettingDeprecation storage _creatorTAOSettingDeprecation = creatorTAOSettingDeprecations[_creatorTAOSettingDeprecationId];\r\n\t\t_creatorTAOSettingDeprecation.creatorTAOSettingDeprecationId = _creatorTAOSettingDeprecationId;\r\n\t\t_creatorTAOSettingDeprecation.creatorTAOId = _creatorTAOId;\r\n\t\t_creatorTAOSettingDeprecation.settingId = _settingId;\r\n\r\n\t\treturn (_associatedTAOSettingDeprecationId, _creatorTAOSettingDeprecationId);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Get Setting Deprecation info of a setting ID\r\n\t * @param _settingId The ID of the setting\r\n\t */\r\n\tfunction getSettingDeprecation(uint256 _settingId) public view returns (uint256, address, address, address, bool, bool, bool, bool, uint256, uint256, address, address) {\r\n\t\tSettingDeprecation memory _settingDeprecation = settingDeprecations[_settingId];\r\n\t\treturn (\r\n\t\t\t_settingDeprecation.settingId,\r\n\t\t\t_settingDeprecation.creatorNameId,\r\n\t\t\t_settingDeprecation.creatorTAOId,\r\n\t\t\t_settingDeprecation.associatedTAOId,\r\n\t\t\t_settingDeprecation.pendingDeprecated,\r\n\t\t\t_settingDeprecation.locked,\r\n\t\t\t_settingDeprecation.rejected,\r\n\t\t\t_settingDeprecation.migrated,\r\n\t\t\t_settingDeprecation.pendingNewSettingId,\r\n\t\t\t_settingDeprecation.newSettingId,\r\n\t\t\t_settingDeprecation.pendingNewSettingContractAddress,\r\n\t\t\t_settingDeprecation.newSettingContractAddress\r\n\t\t);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Get Associated TAO Setting Deprecation info\r\n\t * @param _associatedTAOSettingDeprecationId The ID of the associated tao setting deprecation\r\n\t */\r\n\tfunction getAssociatedTAOSettingDeprecation(bytes32 _associatedTAOSettingDeprecationId) public view returns (bytes32, address, uint256) {\r\n\t\tAssociatedTAOSettingDeprecation memory _associatedTAOSettingDeprecation = associatedTAOSettingDeprecations[_associatedTAOSettingDeprecationId];\r\n\t\treturn (\r\n\t\t\t_associatedTAOSettingDeprecation.associatedTAOSettingDeprecationId,\r\n\t\t\t_associatedTAOSettingDeprecation.associatedTAOId,\r\n\t\t\t_associatedTAOSettingDeprecation.settingId\r\n\t\t);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Get Creator TAO Setting Deprecation info\r\n\t * @param _creatorTAOSettingDeprecationId The ID of the creator tao setting deprecation\r\n\t */\r\n\tfunction getCreatorTAOSettingDeprecation(bytes32 _creatorTAOSettingDeprecationId) public view returns (bytes32, address, uint256) {\r\n\t\tCreatorTAOSettingDeprecation memory _creatorTAOSettingDeprecation = creatorTAOSettingDeprecations[_creatorTAOSettingDeprecationId];\r\n\t\treturn (\r\n\t\t\t_creatorTAOSettingDeprecation.creatorTAOSettingDeprecationId,\r\n\t\t\t_creatorTAOSettingDeprecation.creatorTAOId,\r\n\t\t\t_creatorTAOSettingDeprecation.settingId\r\n\t\t);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Advocate of SettingDeprecation's _associatedTAOId approves deprecation\r\n\t * @param _settingId The ID of the setting to approve\r\n\t * @param _associatedTAOAdvocate The advocate of the associated TAO\r\n\t * @param _approved Whether to approve or reject\r\n\t * @return true on success\r\n\t */\r\n\tfunction approveDeprecation(uint256 _settingId, address _associatedTAOAdvocate, bool _approved) public inWhitelist returns (bool) {\r\n\t\t// Make sure setting exists and needs approval\r\n\t\tSettingDeprecation storage _settingDeprecation = settingDeprecations[_settingId];\r\n\t\trequire (_settingDeprecation.settingId == _settingId &&\r\n\t\t\t_settingDeprecation.migrated == false &&\r\n\t\t\t_settingDeprecation.pendingDeprecated == true &&\r\n\t\t\t_settingDeprecation.locked == true &&\r\n\t\t\t_settingDeprecation.rejected == false &&\r\n\t\t\t_associatedTAOAdvocate != address(0) &&\r\n\t\t\t_associatedTAOAdvocate == _nameTAOPosition.getAdvocate(_settingDeprecation.associatedTAOId)\r\n\t\t);\r\n\r\n\t\tif (_approved) {\r\n\t\t\t// Unlock the setting so that advocate of creatorTAOId can finalize the creation\r\n\t\t\t_settingDeprecation.locked = false;\r\n\t\t} else {\r\n\t\t\t// Reject the setting\r\n\t\t\t_settingDeprecation.pendingDeprecated = false;\r\n\t\t\t_settingDeprecation.rejected = true;\r\n\t\t}\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Advocate of SettingDeprecation's _creatorTAOId finalizes the deprecation once the setting deprecation is approved\r\n\t * @param _settingId The ID of the setting to be finalized\r\n\t * @param _creatorTAOAdvocate The advocate of the creator TAO\r\n\t * @return true on success\r\n\t */\r\n\tfunction finalizeDeprecation(uint256 _settingId, address _creatorTAOAdvocate) public inWhitelist returns (bool) {\r\n\t\t// Make sure setting exists and needs approval\r\n\t\tSettingDeprecation storage _settingDeprecation = settingDeprecations[_settingId];\r\n\t\trequire (_settingDeprecation.settingId == _settingId &&\r\n\t\t\t_settingDeprecation.migrated == false &&\r\n\t\t\t_settingDeprecation.pendingDeprecated == true &&\r\n\t\t\t_settingDeprecation.locked == false &&\r\n\t\t\t_settingDeprecation.rejected == false &&\r\n\t\t\t_creatorTAOAdvocate != address(0) &&\r\n\t\t\t_creatorTAOAdvocate == _nameTAOPosition.getAdvocate(_settingDeprecation.creatorTAOId)\r\n\t\t);\r\n\r\n\t\t// Update the setting data\r\n\t\t_settingDeprecation.pendingDeprecated = false;\r\n\t\t_settingDeprecation.locked = true;\r\n\t\t_settingDeprecation.migrated = true;\r\n\t\tuint256 _newSettingId = _settingDeprecation.pendingNewSettingId;\r\n\t\t_settingDeprecation.pendingNewSettingId = 0;\r\n\t\t_settingDeprecation.newSettingId = _newSettingId;\r\n\r\n\t\taddress _newSettingContractAddress = _settingDeprecation.pendingNewSettingContractAddress;\r\n\t\t_settingDeprecation.pendingNewSettingContractAddress = address(0);\r\n\t\t_settingDeprecation.newSettingContractAddress = _newSettingContractAddress;\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Check if a setting exist and not rejected\r\n\t * @param _settingId The ID of the setting\r\n\t * @return true if exist. false otherwise\r\n\t */\r\n\tfunction settingExist(uint256 _settingId) public view returns (bool) {\r\n\t\tSettingData memory _settingData = settingDatas[_settingId];\r\n\t\treturn (_settingData.settingId == _settingId && _settingData.rejected == false);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Get the latest ID of a deprecated setting, if exist\r\n\t * @param _settingId The ID of the setting\r\n\t * @return The latest setting ID\r\n\t */\r\n\tfunction getLatestSettingId(uint256 _settingId) public view returns (uint256) {\r\n\t\t(,,,,,,, bool _migrated,, uint256 _newSettingId,,) = getSettingDeprecation(_settingId);\r\n\t\twhile (_migrated && _newSettingId > 0) {\r\n\t\t\t_settingId = _newSettingId;\r\n\t\t\t(,,,,,,, _migrated,, _newSettingId,,) = getSettingDeprecation(_settingId);\r\n\t\t}\r\n\t\treturn _settingId;\r\n\t}\r\n\r\n\t/***** Internal Method *****/\r\n\t/**\r\n\t * @dev Store setting data/state\r\n\t * @param _settingId The ID of the setting\r\n\t * @param _creatorNameId The nameId that created the setting\r\n\t * @param _settingType The type of this setting. 1 => uint256, 2 => bool, 3 => address, 4 => bytes32, 5 => string\r\n\t * @param _settingName The human-readable name of the setting\r\n\t * @param _creatorTAOId The taoId that created the setting\r\n\t * @param _associatedTAOId The taoId that the setting affects\r\n\t * @param _extraData Catch-all string value to be stored if exist\r\n\t * @return true on success\r\n\t */\r\n\tfunction _storeSettingDataState(uint256 _settingId, address _creatorNameId, uint8 _settingType, string _settingName, address _creatorTAOId, address _associatedTAOId, string _extraData) internal returns (bool) {\r\n\t\t// Store setting data\r\n\t\tSettingData storage _settingData = settingDatas[_settingId];\r\n\t\t_settingData.settingId = _settingId;\r\n\t\t_settingData.creatorNameId = _creatorNameId;\r\n\t\t_settingData.creatorTAOId = _creatorTAOId;\r\n\t\t_settingData.associatedTAOId = _associatedTAOId;\r\n\t\t_settingData.settingName = _settingName;\r\n\t\t_settingData.settingType = _settingType;\r\n\t\t_settingData.pendingCreate = true;\r\n\t\t_settingData.locked = true;\r\n\t\t_settingData.settingDataJSON = _extraData;\r\n\r\n\t\t// Store setting state\r\n\t\tSettingState storage _settingState = settingStates[_settingId];\r\n\t\t_settingState.settingId = _settingId;\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Store setting deprecation\r\n\t * @param _settingId The ID of the setting\r\n\t * @param _creatorNameId The nameId that created the setting\r\n\t * @param _creatorTAOId The taoId that created the setting\r\n\t * @param _associatedTAOId The taoId that the setting affects\r\n\t * @param _newSettingId The new settingId value to route\r\n\t * @param _newSettingContractAddress The address of the new setting contract to route\r\n\t * @return true on success\r\n\t */\r\n\tfunction _storeSettingDeprecation(uint256 _settingId, address _creatorNameId, address _creatorTAOId, address _associatedTAOId, uint256 _newSettingId, address _newSettingContractAddress) internal returns (bool) {\r\n\t\t// Make sure this setting exists\r\n\t\trequire (settingDatas[_settingId].creatorNameId != address(0) && settingDatas[_settingId].rejected == false && settingDatas[_settingId].pendingCreate == false);\r\n\r\n\t\t// Make sure deprecation is not yet exist for this setting Id\r\n\t\trequire (settingDeprecations[_settingId].creatorNameId == address(0));\r\n\r\n\t\t// Make sure newSettingId exists\r\n\t\trequire (settingDatas[_newSettingId].creatorNameId != address(0) && settingDatas[_newSettingId].rejected == false && settingDatas[_newSettingId].pendingCreate == false);\r\n\r\n\t\t// Make sure the settingType matches\r\n\t\trequire (settingDatas[_settingId].settingType == settingDatas[_newSettingId].settingType);\r\n\r\n\t\t// Store setting deprecation info\r\n\t\tSettingDeprecation storage _settingDeprecation = settingDeprecations[_settingId];\r\n\t\t_settingDeprecation.settingId = _settingId;\r\n\t\t_settingDeprecation.creatorNameId = _creatorNameId;\r\n\t\t_settingDeprecation.creatorTAOId = _creatorTAOId;\r\n\t\t_settingDeprecation.associatedTAOId = _associatedTAOId;\r\n\t\t_settingDeprecation.pendingDeprecated = true;\r\n\t\t_settingDeprecation.locked = true;\r\n\t\t_settingDeprecation.pendingNewSettingId = _newSettingId;\r\n\t\t_settingDeprecation.pendingNewSettingContractAddress = _newSettingContractAddress;\r\n\t\treturn true;\r\n\t}\r\n}\r\n\r\n\r\n\r\n\r\n/**\r\n * @title AOTokenInterface\r\n */\r\ncontract AOTokenInterface is TheAO, TokenERC20 {\r\n\tusing SafeMath for uint256;\r\n\r\n\t// To differentiate denomination of AO\r\n\tuint256 public powerOfTen;\r\n\r\n\t/***** NETWORK TOKEN VARIABLES *****/\r\n\tuint256 public sellPrice;\r\n\tuint256 public buyPrice;\r\n\r\n\tmapping (address => bool) public frozenAccount;\r\n\tmapping (address => uint256) public stakedBalance;\r\n\tmapping (address => uint256) public escrowedBalance;\r\n\r\n\t// This generates a public event on the blockchain that will notify clients\r\n\tevent FrozenFunds(address target, bool frozen);\r\n\tevent Stake(address indexed from, uint256 value);\r\n\tevent Unstake(address indexed from, uint256 value);\r\n\tevent Escrow(address indexed from, address indexed to, uint256 value);\r\n\tevent Unescrow(address indexed from, uint256 value);\r\n\r\n\t/**\r\n\t * @dev Constructor function\r\n\t */\r\n\tconstructor(uint256 initialSupply, string tokenName, string tokenSymbol)\r\n\t\tTokenERC20(initialSupply, tokenName, tokenSymbol) public {\r\n\t\tpowerOfTen = 0;\r\n\t\tdecimals = 0;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Checks if the calling contract address is The AO\r\n\t *\t\tOR\r\n\t *\t\tIf The AO is set to a Name/TAO, then check if calling address is the Advocate\r\n\t */\r\n\tmodifier onlyTheAO {\r\n\t\trequire (AOLibrary.isTheAO(msg.sender, theAO, nameTAOPositionAddress));\r\n\t\t_;\r\n\t}\r\n\r\n\t/***** The AO ONLY METHODS *****/\r\n\t/**\r\n\t * @dev The AO set the NameTAOPosition Address\r\n\t * @param _nameTAOPositionAddress The address of NameTAOPosition\r\n\t */\r\n\tfunction setNameTAOPositionAddress(address _nameTAOPositionAddress) public onlyTheAO {\r\n\t\trequire (_nameTAOPositionAddress != address(0));\r\n\t\tnameTAOPositionAddress = _nameTAOPositionAddress;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Transfer ownership of The AO to new address\r\n\t * @param _theAO The new address to be transferred\r\n\t */\r\n\tfunction transferOwnership(address _theAO) public onlyTheAO {\r\n\t\trequire (_theAO != address(0));\r\n\t\ttheAO = _theAO;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Whitelist `_account` address to transact on behalf of others\r\n\t * @param _account The address to whitelist\r\n\t * @param _whitelist Either to whitelist or not\r\n\t */\r\n\tfunction setWhitelist(address _account, bool _whitelist) public onlyTheAO {\r\n\t\trequire (_account != address(0));\r\n\t\twhitelist[_account] = _whitelist;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Prevent/Allow target from sending & receiving tokens\r\n\t * @param target Address to be frozen\r\n\t * @param freeze Either to freeze it or not\r\n\t */\r\n\tfunction freezeAccount(address target, bool freeze) public onlyTheAO {\r\n\t\tfrozenAccount[target] = freeze;\r\n\t\temit FrozenFunds(target, freeze);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Allow users to buy tokens for `newBuyPrice` eth and sell tokens for `newSellPrice` eth\r\n\t * @param newSellPrice Price users can sell to the contract\r\n\t * @param newBuyPrice Price users can buy from the contract\r\n\t */\r\n\tfunction setPrices(uint256 newSellPrice, uint256 newBuyPrice) public onlyTheAO {\r\n\t\tsellPrice = newSellPrice;\r\n\t\tbuyPrice = newBuyPrice;\r\n\t}\r\n\r\n\t/***** NETWORK TOKEN WHITELISTED ADDRESS ONLY METHODS *****/\r\n\t/**\r\n\t * @dev Create `mintedAmount` tokens and send it to `target`\r\n\t * @param target Address to receive the tokens\r\n\t * @param mintedAmount The amount of tokens it will receive\r\n\t * @return true on success\r\n\t */\r\n\tfunction mintToken(address target, uint256 mintedAmount) public inWhitelist returns (bool) {\r\n\t\t_mintToken(target, mintedAmount);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Stake `_value` tokens on behalf of `_from`\r\n\t * @param _from The address of the target\r\n\t * @param _value The amount to stake\r\n\t * @return true on success\r\n\t */\r\n\tfunction stakeFrom(address _from, uint256 _value) public inWhitelist returns (bool) {\r\n\t\trequire (balanceOf[_from] >= _value);\t\t\t\t\t\t// Check if the targeted balance is enough\r\n\t\tbalanceOf[_from] = balanceOf[_from].sub(_value);\t\t\t// Subtract from the targeted balance\r\n\t\tstakedBalance[_from] = stakedBalance[_from].add(_value);\t// Add to the targeted staked balance\r\n\t\temit Stake(_from, _value);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Unstake `_value` tokens on behalf of `_from`\r\n\t * @param _from The address of the target\r\n\t * @param _value The amount to unstake\r\n\t * @return true on success\r\n\t */\r\n\tfunction unstakeFrom(address _from, uint256 _value) public inWhitelist returns (bool) {\r\n\t\trequire (stakedBalance[_from] >= _value);\t\t\t\t\t// Check if the targeted staked balance is enough\r\n\t\tstakedBalance[_from] = stakedBalance[_from].sub(_value);\t// Subtract from the targeted staked balance\r\n\t\tbalanceOf[_from] = balanceOf[_from].add(_value);\t\t\t// Add to the targeted balance\r\n\t\temit Unstake(_from, _value);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Store `_value` from `_from` to `_to` in escrow\r\n\t * @param _from The address of the sender\r\n\t * @param _to The address of the recipient\r\n\t * @param _value The amount of network tokens to put in escrow\r\n\t * @return true on success\r\n\t */\r\n\tfunction escrowFrom(address _from, address _to, uint256 _value) public inWhitelist returns (bool) {\r\n\t\trequire (balanceOf[_from] >= _value);\t\t\t\t\t\t// Check if the targeted balance is enough\r\n\t\tbalanceOf[_from] = balanceOf[_from].sub(_value);\t\t\t// Subtract from the targeted balance\r\n\t\tescrowedBalance[_to] = escrowedBalance[_to].add(_value);\t// Add to the targeted escrowed balance\r\n\t\temit Escrow(_from, _to, _value);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Create `mintedAmount` tokens and send it to `target` escrow balance\r\n\t * @param target Address to receive the tokens\r\n\t * @param mintedAmount The amount of tokens it will receive in escrow\r\n\t */\r\n\tfunction mintTokenEscrow(address target, uint256 mintedAmount) public inWhitelist returns (bool) {\r\n\t\tescrowedBalance[target] = escrowedBalance[target].add(mintedAmount);\r\n\t\ttotalSupply = totalSupply.add(mintedAmount);\r\n\t\temit Escrow(this, target, mintedAmount);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Release escrowed `_value` from `_from`\r\n\t * @param _from The address of the sender\r\n\t * @param _value The amount of escrowed network tokens to be released\r\n\t * @return true on success\r\n\t */\r\n\tfunction unescrowFrom(address _from, uint256 _value) public inWhitelist returns (bool) {\r\n\t\trequire (escrowedBalance[_from] >= _value);\t\t\t\t\t\t// Check if the targeted escrowed balance is enough\r\n\t\tescrowedBalance[_from] = escrowedBalance[_from].sub(_value);\t// Subtract from the targeted escrowed balance\r\n\t\tbalanceOf[_from] = balanceOf[_from].add(_value);\t\t\t\t// Add to the targeted balance\r\n\t\temit Unescrow(_from, _value);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t *\r\n\t * @dev Whitelisted address remove `_value` tokens from the system irreversibly on behalf of `_from`.\r\n\t *\r\n\t * @param _from the address of the sender\r\n\t * @param _value the amount of money to burn\r\n\t */\r\n\tfunction whitelistBurnFrom(address _from, uint256 _value) public inWhitelist returns (bool success) {\r\n\t\trequire(balanceOf[_from] >= _value);                // Check if the targeted balance is enough\r\n\t\tbalanceOf[_from] = balanceOf[_from].sub(_value);    // Subtract from the targeted balance\r\n\t\ttotalSupply = totalSupply.sub(_value);              // Update totalSupply\r\n\t\temit Burn(_from, _value);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Whitelisted address transfer tokens from other address\r\n\t *\r\n\t * Send `_value` tokens to `_to` on behalf of `_from`\r\n\t *\r\n\t * @param _from The address of the sender\r\n\t * @param _to The address of the recipient\r\n\t * @param _value the amount to send\r\n\t */\r\n\tfunction whitelistTransferFrom(address _from, address _to, uint256 _value) public inWhitelist returns (bool success) {\r\n\t\t_transfer(_from, _to, _value);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/***** PUBLIC METHODS *****/\r\n\t/**\r\n\t * @dev Buy tokens from contract by sending ether\r\n\t */\r\n\tfunction buy() public payable {\r\n\t\trequire (buyPrice > 0);\r\n\t\tuint256 amount = msg.value.div(buyPrice);\r\n\t\t_transfer(this, msg.sender, amount);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Sell `amount` tokens to contract\r\n\t * @param amount The amount of tokens to be sold\r\n\t */\r\n\tfunction sell(uint256 amount) public {\r\n\t\trequire (sellPrice > 0);\r\n\t\taddress myAddress = this;\r\n\t\trequire (myAddress.balance >= amount.mul(sellPrice));\r\n\t\t_transfer(msg.sender, this, amount);\r\n\t\tmsg.sender.transfer(amount.mul(sellPrice));\r\n\t}\r\n\r\n\t/***** INTERNAL METHODS *****/\r\n\t/**\r\n\t * @dev Send `_value` tokens from `_from` to `_to`\r\n\t * @param _from The address of sender\r\n\t * @param _to The address of the recipient\r\n\t * @param _value The amount to send\r\n\t */\r\n\tfunction _transfer(address _from, address _to, uint256 _value) internal {\r\n\t\trequire (_to != address(0));\t\t\t\t\t\t\t// Prevent transfer to 0x0 address. Use burn() instead\r\n\t\trequire (balanceOf[_from] >= _value);\t\t\t\t\t// Check if the sender has enough\r\n\t\trequire (balanceOf[_to].add(_value) >= balanceOf[_to]); // Check for overflows\r\n\t\trequire (!frozenAccount[_from]);\t\t\t\t\t\t// Check if sender is frozen\r\n\t\trequire (!frozenAccount[_to]);\t\t\t\t\t\t\t// Check if recipient is frozen\r\n\t\tuint256 previousBalances = balanceOf[_from].add(balanceOf[_to]);\r\n\t\tbalanceOf[_from] = balanceOf[_from].sub(_value);        // Subtract from the sender\r\n\t\tbalanceOf[_to] = balanceOf[_to].add(_value);            // Add the same to the recipient\r\n\t\temit Transfer(_from, _to, _value);\r\n\t\tassert(balanceOf[_from].add(balanceOf[_to]) == previousBalances);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Create `mintedAmount` tokens and send it to `target`\r\n\t * @param target Address to receive the tokens\r\n\t * @param mintedAmount The amount of tokens it will receive\r\n\t */\r\n\tfunction _mintToken(address target, uint256 mintedAmount) internal {\r\n\t\tbalanceOf[target] = balanceOf[target].add(mintedAmount);\r\n\t\ttotalSupply = totalSupply.add(mintedAmount);\r\n\t\temit Transfer(0, this, mintedAmount);\r\n\t\temit Transfer(this, target, mintedAmount);\r\n\t}\r\n}\r\n\r\n\r\n\r\n\r\n/**\r\n * @title AOToken\r\n */\r\ncontract AOToken is AOTokenInterface {\r\n\tusing SafeMath for uint256;\r\n\r\n\taddress public settingTAOId;\r\n\taddress public aoSettingAddress;\r\n\t// AO Dev Team addresses to receive Primordial/Network Tokens\r\n\taddress public aoDevTeam1 = 0x5C63644D01Ba385eBAc5bcf2DDc1e6dBC1182b52;\r\n\taddress public aoDevTeam2 = 0x156C79bf4347D1891da834Ea30662A14177CbF28;\r\n\r\n\tAOSetting internal _aoSetting;\r\n\r\n\t/***** PRIMORDIAL TOKEN VARIABLES *****/\r\n\tuint256 public primordialTotalSupply;\r\n\tuint256 public primordialTotalBought;\r\n\tuint256 public primordialSellPrice;\r\n\tuint256 public primordialBuyPrice;\r\n\r\n\t// Total available primordial token for sale 1,125,899,906,842,620 AO+\r\n\tuint256 constant public TOTAL_PRIMORDIAL_FOR_SALE = 1125899906842620;\r\n\r\n\tmapping (address => uint256) public primordialBalanceOf;\r\n\tmapping (address => mapping (address => uint256)) public primordialAllowance;\r\n\r\n\t// Mapping from owner's lot weighted multiplier to the amount of staked tokens\r\n\tmapping (address => mapping (uint256 => uint256)) public primordialStakedBalance;\r\n\r\n\tevent PrimordialTransfer(address indexed from, address indexed to, uint256 value);\r\n\tevent PrimordialApproval(address indexed _owner, address indexed _spender, uint256 _value);\r\n\tevent PrimordialBurn(address indexed from, uint256 value);\r\n\tevent PrimordialStake(address indexed from, uint256 value, uint256 weightedMultiplier);\r\n\tevent PrimordialUnstake(address indexed from, uint256 value, uint256 weightedMultiplier);\r\n\r\n\tuint256 public totalLots;\r\n\tuint256 public totalBurnLots;\r\n\tuint256 public totalConvertLots;\r\n\r\n\tbool public networkExchangeEnded;\r\n\r\n\t/**\r\n\t * Stores Lot creation data (during network exchange)\r\n\t */\r\n\tstruct Lot {\r\n\t\tbytes32 lotId;\r\n\t\tuint256 multiplier;\t// This value is in 10^6, so 1000000 = 1\r\n\t\taddress lotOwner;\r\n\t\tuint256 tokenAmount;\r\n\t}\r\n\r\n\t/**\r\n\t * Struct to store info when account burns primordial token\r\n\t */\r\n\tstruct BurnLot {\r\n\t\tbytes32 burnLotId;\r\n\t\taddress lotOwner;\r\n\t\tuint256 tokenAmount;\r\n\t}\r\n\r\n\t/**\r\n\t * Struct to store info when account converts network token to primordial token\r\n\t */\r\n\tstruct ConvertLot {\r\n\t\tbytes32 convertLotId;\r\n\t\taddress lotOwner;\r\n\t\tuint256 tokenAmount;\r\n\t}\r\n\r\n\t// Mapping from Lot ID to Lot object\r\n\tmapping (bytes32 => Lot) internal lots;\r\n\r\n\t// Mapping from Burn Lot ID to BurnLot object\r\n\tmapping (bytes32 => BurnLot) internal burnLots;\r\n\r\n\t// Mapping from Convert Lot ID to ConvertLot object\r\n\tmapping (bytes32 => ConvertLot) internal convertLots;\r\n\r\n\t// Mapping from owner to list of owned lot IDs\r\n\tmapping (address => bytes32[]) internal ownedLots;\r\n\r\n\t// Mapping from owner to list of owned burn lot IDs\r\n\tmapping (address => bytes32[]) internal ownedBurnLots;\r\n\r\n\t// Mapping from owner to list of owned convert lot IDs\r\n\tmapping (address => bytes32[]) internal ownedConvertLots;\r\n\r\n\t// Mapping from owner to his/her current weighted multiplier\r\n\tmapping (address => uint256) internal ownerWeightedMultiplier;\r\n\r\n\t// Mapping from owner to his/her max multiplier (multiplier of account's first Lot)\r\n\tmapping (address => uint256) internal ownerMaxMultiplier;\r\n\r\n\t// Event to be broadcasted to public when a lot is created\r\n\t// multiplier value is in 10^6 to account for 6 decimal points\r\n\tevent LotCreation(address indexed lotOwner, bytes32 indexed lotId, uint256 multiplier, uint256 primordialTokenAmount, uint256 networkTokenBonusAmount);\r\n\r\n\t// Event to be broadcasted to public when burn lot is created (when account burns primordial tokens)\r\n\tevent BurnLotCreation(address indexed lotOwner, bytes32 indexed burnLotId, uint256 burnTokenAmount, uint256 multiplierAfterBurn);\r\n\r\n\t// Event to be broadcasted to public when convert lot is created (when account convert network tokens to primordial tokens)\r\n\tevent ConvertLotCreation(address indexed lotOwner, bytes32 indexed convertLotId, uint256 convertTokenAmount, uint256 multiplierAfterBurn);\r\n\r\n\t/**\r\n\t * @dev Constructor function\r\n\t */\r\n\tconstructor(uint256 initialSupply, string tokenName, string tokenSymbol, address _settingTAOId, address _aoSettingAddress)\r\n\t\tAOTokenInterface(initialSupply, tokenName, tokenSymbol) public {\r\n\t\tsettingTAOId = _settingTAOId;\r\n\t\taoSettingAddress = _aoSettingAddress;\r\n\t\t_aoSetting = AOSetting(_aoSettingAddress);\r\n\r\n\t\tpowerOfTen = 0;\r\n\t\tdecimals = 0;\r\n\t\tsetPrimordialPrices(0, 10000); // Set Primordial buy price to 10000 Wei/token\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Checks if buyer can buy primordial token\r\n\t */\r\n\tmodifier canBuyPrimordial(uint256 _sentAmount) {\r\n\t\trequire (networkExchangeEnded == false && primordialTotalBought < TOTAL_PRIMORDIAL_FOR_SALE && primordialBuyPrice > 0 && _sentAmount > 0);\r\n\t\t_;\r\n\t}\r\n\r\n\t/***** The AO ONLY METHODS *****/\r\n\t/**\r\n\t * @dev Set AO Dev team addresses to receive Primordial/Network tokens during network exchange\r\n\t * @param _aoDevTeam1 The first AO dev team address\r\n\t * @param _aoDevTeam2 The second AO dev team address\r\n\t */\r\n\tfunction setAODevTeamAddresses(address _aoDevTeam1, address _aoDevTeam2) public onlyTheAO {\r\n\t\taoDevTeam1 = _aoDevTeam1;\r\n\t\taoDevTeam2 = _aoDevTeam2;\r\n\t}\r\n\r\n\t/***** PRIMORDIAL TOKEN The AO ONLY METHODS *****/\r\n\t/**\r\n\t * @dev Allow users to buy Primordial tokens for `newBuyPrice` eth and sell Primordial tokens for `newSellPrice` eth\r\n\t * @param newPrimordialSellPrice Price users can sell to the contract\r\n\t * @param newPrimordialBuyPrice Price users can buy from the contract\r\n\t */\r\n\tfunction setPrimordialPrices(uint256 newPrimordialSellPrice, uint256 newPrimordialBuyPrice) public onlyTheAO {\r\n\t\tprimordialSellPrice = newPrimordialSellPrice;\r\n\t\tprimordialBuyPrice = newPrimordialBuyPrice;\r\n\t}\r\n\r\n\t/***** PRIMORDIAL TOKEN WHITELISTED ADDRESS ONLY METHODS *****/\r\n\t/**\r\n\t * @dev Stake `_value` Primordial tokens at `_weightedMultiplier ` multiplier on behalf of `_from`\r\n\t * @param _from The address of the target\r\n\t * @param _value The amount of Primordial tokens to stake\r\n\t * @param _weightedMultiplier The weighted multiplier of the Primordial tokens\r\n\t * @return true on success\r\n\t */\r\n\tfunction stakePrimordialTokenFrom(address _from, uint256 _value, uint256 _weightedMultiplier) public inWhitelist returns (bool) {\r\n\t\t// Check if the targeted balance is enough\r\n\t\trequire (primordialBalanceOf[_from] >= _value);\r\n\t\t// Make sure the weighted multiplier is the same as account's current weighted multiplier\r\n\t\trequire (_weightedMultiplier == ownerWeightedMultiplier[_from]);\r\n\t\t// Subtract from the targeted balance\r\n\t\tprimordialBalanceOf[_from] = primordialBalanceOf[_from].sub(_value);\r\n\t\t// Add to the targeted staked balance\r\n\t\tprimordialStakedBalance[_from][_weightedMultiplier] = primordialStakedBalance[_from][_weightedMultiplier].add(_value);\r\n\t\temit PrimordialStake(_from, _value, _weightedMultiplier);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Unstake `_value` Primordial tokens at `_weightedMultiplier` on behalf of `_from`\r\n\t * @param _from The address of the target\r\n\t * @param _value The amount to unstake\r\n\t * @param _weightedMultiplier The weighted multiplier of the Primordial tokens\r\n\t * @return true on success\r\n\t */\r\n\tfunction unstakePrimordialTokenFrom(address _from, uint256 _value, uint256 _weightedMultiplier) public inWhitelist returns (bool) {\r\n\t\t// Check if the targeted staked balance is enough\r\n\t\trequire (primordialStakedBalance[_from][_weightedMultiplier] >= _value);\r\n\t\t// Subtract from the targeted staked balance\r\n\t\tprimordialStakedBalance[_from][_weightedMultiplier] = primordialStakedBalance[_from][_weightedMultiplier].sub(_value);\r\n\t\t// Add to the targeted balance\r\n\t\tprimordialBalanceOf[_from] = primordialBalanceOf[_from].add(_value);\r\n\t\temit PrimordialUnstake(_from, _value, _weightedMultiplier);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Send `_value` primordial tokens to `_to` on behalf of `_from`\r\n\t * @param _from The address of the sender\r\n\t * @param _to The address of the recipient\r\n\t * @param _value The amount to send\r\n\t * @return true on success\r\n\t */\r\n\tfunction whitelistTransferPrimordialTokenFrom(address _from, address _to, uint256 _value) public inWhitelist returns (bool) {\r\n\t\tbytes32 _createdLotId = _createWeightedMultiplierLot(_to, _value, ownerWeightedMultiplier[_from]);\r\n\t\tLot memory _lot = lots[_createdLotId];\r\n\r\n\t\t// Make sure the new lot is created successfully\r\n\t\trequire (_lot.lotOwner == _to);\r\n\r\n\t\t// Update the weighted multiplier of the recipient\r\n\t\townerWeightedMultiplier[_to] = AOLibrary.calculateWeightedMultiplier(ownerWeightedMultiplier[_to], primordialBalanceOf[_to], ownerWeightedMultiplier[_from], _value);\r\n\r\n\t\t// Transfer the Primordial tokens\r\n\t\trequire (_transferPrimordialToken(_from, _to, _value));\r\n\t\temit LotCreation(_lot.lotOwner, _lot.lotId, _lot.multiplier, _lot.tokenAmount, 0);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/***** PUBLIC METHODS *****/\r\n\t/***** Primordial TOKEN PUBLIC METHODS *****/\r\n\t/**\r\n\t * @dev Buy Primordial tokens from contract by sending ether\r\n\t */\r\n\tfunction buyPrimordialToken() public payable canBuyPrimordial(msg.value) {\r\n\t\t(uint256 tokenAmount, uint256 remainderBudget, bool shouldEndNetworkExchange) = _calculateTokenAmountAndRemainderBudget(msg.value);\r\n\t\trequire (tokenAmount > 0);\r\n\r\n\t\t// Ends network exchange if necessary\r\n\t\tif (shouldEndNetworkExchange) {\r\n\t\t\tnetworkExchangeEnded = true;\r\n\t\t}\r\n\r\n\t\t// Send the primordial token to buyer and reward AO devs\r\n\t\t_sendPrimordialTokenAndRewardDev(tokenAmount, msg.sender);\r\n\r\n\t\t// Send remainder budget back to buyer if exist\r\n\t\tif (remainderBudget > 0) {\r\n\t\t\tmsg.sender.transfer(remainderBudget);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Send `_value` Primordial tokens to `_to` from your account\r\n\t * @param _to The address of the recipient\r\n\t * @param _value The amount to send\r\n\t * @return true on success\r\n\t */\r\n\tfunction transferPrimordialToken(address _to, uint256 _value) public returns (bool success) {\r\n\t\tbytes32 _createdLotId = _createWeightedMultiplierLot(_to, _value, ownerWeightedMultiplier[msg.sender]);\r\n\t\tLot memory _lot = lots[_createdLotId];\r\n\r\n\t\t// Make sure the new lot is created successfully\r\n\t\trequire (_lot.lotOwner == _to);\r\n\r\n\t\t// Update the weighted multiplier of the recipient\r\n\t\townerWeightedMultiplier[_to] = AOLibrary.calculateWeightedMultiplier(ownerWeightedMultiplier[_to], primordialBalanceOf[_to], ownerWeightedMultiplier[msg.sender], _value);\r\n\r\n\t\t// Transfer the Primordial tokens\r\n\t\trequire (_transferPrimordialToken(msg.sender, _to, _value));\r\n\t\temit LotCreation(_lot.lotOwner, _lot.lotId, _lot.multiplier, _lot.tokenAmount, 0);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Send `_value` Primordial tokens to `_to` from `_from`\r\n\t * @param _from The address of the sender\r\n\t * @param _to The address of the recipient\r\n\t * @param _value The amount to send\r\n\t * @return true on success\r\n\t */\r\n\tfunction transferPrimordialTokenFrom(address _from, address _to, uint256 _value) public returns (bool success) {\r\n\t\trequire (_value <= primordialAllowance[_from][msg.sender]);\r\n\t\tprimordialAllowance[_from][msg.sender] = primordialAllowance[_from][msg.sender].sub(_value);\r\n\r\n\t\tbytes32 _createdLotId = _createWeightedMultiplierLot(_to, _value, ownerWeightedMultiplier[_from]);\r\n\t\tLot memory _lot = lots[_createdLotId];\r\n\r\n\t\t// Make sure the new lot is created successfully\r\n\t\trequire (_lot.lotOwner == _to);\r\n\r\n\t\t// Update the weighted multiplier of the recipient\r\n\t\townerWeightedMultiplier[_to] = AOLibrary.calculateWeightedMultiplier(ownerWeightedMultiplier[_to], primordialBalanceOf[_to], ownerWeightedMultiplier[_from], _value);\r\n\r\n\t\t// Transfer the Primordial tokens\r\n\t\trequire (_transferPrimordialToken(_from, _to, _value));\r\n\t\temit LotCreation(_lot.lotOwner, _lot.lotId, _lot.multiplier, _lot.tokenAmount, 0);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Allows `_spender` to spend no more than `_value` Primordial tokens in your behalf\r\n\t * @param _spender The address authorized to spend\r\n\t * @param _value The max amount they can spend\r\n\t * @return true on success\r\n\t */\r\n\tfunction approvePrimordialToken(address _spender, uint256 _value) public returns (bool success) {\r\n\t\tprimordialAllowance[msg.sender][_spender] = _value;\r\n\t\temit PrimordialApproval(msg.sender, _spender, _value);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Allows `_spender` to spend no more than `_value` Primordial tokens in your behalf, and then ping the contract about it\r\n\t * @param _spender The address authorized to spend\r\n\t * @param _value The max amount they can spend\r\n\t * @param _extraData some extra information to send to the approved contract\r\n\t * @return true on success\r\n\t */\r\n\tfunction approvePrimordialTokenAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {\r\n\t\ttokenRecipient spender = tokenRecipient(_spender);\r\n\t\tif (approvePrimordialToken(_spender, _value)) {\r\n\t\t\tspender.receiveApproval(msg.sender, _value, this, _extraData);\r\n\t\t\treturn true;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Remove `_value` Primordial tokens from the system irreversibly\r\n\t *\t\tand re-weight the account's multiplier after burn\r\n\t * @param _value The amount to burn\r\n\t * @return true on success\r\n\t */\r\n\tfunction burnPrimordialToken(uint256 _value) public returns (bool success) {\r\n\t\trequire (primordialBalanceOf[msg.sender] >= _value);\r\n\t\trequire (calculateMaximumBurnAmount(msg.sender) >= _value);\r\n\r\n\t\t// Update the account's multiplier\r\n\t\townerWeightedMultiplier[msg.sender] = calculateMultiplierAfterBurn(msg.sender, _value);\r\n\t\tprimordialBalanceOf[msg.sender] = primordialBalanceOf[msg.sender].sub(_value);\r\n\t\tprimordialTotalSupply = primordialTotalSupply.sub(_value);\r\n\r\n\t\t// Store burn lot info\r\n\t\t_createBurnLot(msg.sender, _value);\r\n\t\temit PrimordialBurn(msg.sender, _value);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Remove `_value` Primordial tokens from the system irreversibly on behalf of `_from`\r\n\t *\t\tand re-weight `_from`'s multiplier after burn\r\n\t * @param _from The address of sender\r\n\t * @param _value The amount to burn\r\n\t * @return true on success\r\n\t */\r\n\tfunction burnPrimordialTokenFrom(address _from, uint256 _value) public returns (bool success) {\r\n\t\trequire (primordialBalanceOf[_from] >= _value);\r\n\t\trequire (primordialAllowance[_from][msg.sender] >= _value);\r\n\t\trequire (calculateMaximumBurnAmount(_from) >= _value);\r\n\r\n\t\t// Update `_from`'s multiplier\r\n\t\townerWeightedMultiplier[_from] = calculateMultiplierAfterBurn(_from, _value);\r\n\t\tprimordialBalanceOf[_from] = primordialBalanceOf[_from].sub(_value);\r\n\t\tprimordialAllowance[_from][msg.sender] = primordialAllowance[_from][msg.sender].sub(_value);\r\n\t\tprimordialTotalSupply = primordialTotalSupply.sub(_value);\r\n\r\n\t\t// Store burn lot info\r\n\t\t_createBurnLot(_from, _value);\r\n\t\temit PrimordialBurn(_from, _value);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Return all lot IDs owned by an address\r\n\t * @param _lotOwner The address of the lot owner\r\n\t * @return array of lot IDs\r\n\t */\r\n\tfunction lotIdsByAddress(address _lotOwner) public view returns (bytes32[]) {\r\n\t\treturn ownedLots[_lotOwner];\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Return the total lots owned by an address\r\n\t * @param _lotOwner The address of the lot owner\r\n\t * @return total lots owner by the address\r\n\t */\r\n\tfunction totalLotsByAddress(address _lotOwner) public view returns (uint256) {\r\n\t\treturn ownedLots[_lotOwner].length;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Return the lot information at a given index of the lots list of the requested owner\r\n\t * @param _lotOwner The address owning the lots list to be accessed\r\n\t * @param _index uint256 representing the index to be accessed of the requested lots list\r\n\t * @return id of the lot\r\n\t * @return The address of the lot owner\r\n\t * @return multiplier of the lot in (10 ** 6)\r\n\t * @return Primordial token amount in the lot\r\n\t */\r\n\tfunction lotOfOwnerByIndex(address _lotOwner, uint256 _index) public view returns (bytes32, address, uint256, uint256) {\r\n\t\trequire (_index < ownedLots[_lotOwner].length);\r\n\t\tLot memory _lot = lots[ownedLots[_lotOwner][_index]];\r\n\t\treturn (_lot.lotId, _lot.lotOwner, _lot.multiplier, _lot.tokenAmount);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Return the lot information at a given ID\r\n\t * @param _lotId The lot ID in question\r\n\t * @return id of the lot\r\n\t * @return The lot owner address\r\n\t * @return multiplier of the lot in (10 ** 6)\r\n\t * @return Primordial token amount in the lot\r\n\t */\r\n\tfunction lotById(bytes32 _lotId) public view returns (bytes32, address, uint256, uint256) {\r\n\t\tLot memory _lot = lots[_lotId];\r\n\t\treturn (_lot.lotId, _lot.lotOwner, _lot.multiplier, _lot.tokenAmount);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Return all Burn Lot IDs owned by an address\r\n\t * @param _lotOwner The address of the burn lot owner\r\n\t * @return array of Burn Lot IDs\r\n\t */\r\n\tfunction burnLotIdsByAddress(address _lotOwner) public view returns (bytes32[]) {\r\n\t\treturn ownedBurnLots[_lotOwner];\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Return the total burn lots owned by an address\r\n\t * @param _lotOwner The address of the burn lot owner\r\n\t * @return total burn lots owner by the address\r\n\t */\r\n\tfunction totalBurnLotsByAddress(address _lotOwner) public view returns (uint256) {\r\n\t\treturn ownedBurnLots[_lotOwner].length;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Return the burn lot information at a given ID\r\n\t * @param _burnLotId The burn lot ID in question\r\n\t * @return id of the lot\r\n\t * @return The address of the burn lot owner\r\n\t * @return Primordial token amount in the burn lot\r\n\t */\r\n\tfunction burnLotById(bytes32 _burnLotId) public view returns (bytes32, address, uint256) {\r\n\t\tBurnLot memory _burnLot = burnLots[_burnLotId];\r\n\t\treturn (_burnLot.burnLotId, _burnLot.lotOwner, _burnLot.tokenAmount);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Return all Convert Lot IDs owned by an address\r\n\t * @param _lotOwner The address of the convert lot owner\r\n\t * @return array of Convert Lot IDs\r\n\t */\r\n\tfunction convertLotIdsByAddress(address _lotOwner) public view returns (bytes32[]) {\r\n\t\treturn ownedConvertLots[_lotOwner];\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Return the total convert lots owned by an address\r\n\t * @param _lotOwner The address of the convert lot owner\r\n\t * @return total convert lots owner by the address\r\n\t */\r\n\tfunction totalConvertLotsByAddress(address _lotOwner) public view returns (uint256) {\r\n\t\treturn ownedConvertLots[_lotOwner].length;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Return the convert lot information at a given ID\r\n\t * @param _convertLotId The convert lot ID in question\r\n\t * @return id of the lot\r\n\t * @return The address of the convert lot owner\r\n\t * @return Primordial token amount in the convert lot\r\n\t */\r\n\tfunction convertLotById(bytes32 _convertLotId) public view returns (bytes32, address, uint256) {\r\n\t\tConvertLot memory _convertLot = convertLots[_convertLotId];\r\n\t\treturn (_convertLot.convertLotId, _convertLot.lotOwner, _convertLot.tokenAmount);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Return the average weighted multiplier of all lots owned by an address\r\n\t * @param _lotOwner The address of the lot owner\r\n\t * @return the weighted multiplier of the address (in 10 ** 6)\r\n\t */\r\n\tfunction weightedMultiplierByAddress(address _lotOwner) public view returns (uint256) {\r\n\t\treturn ownerWeightedMultiplier[_lotOwner];\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Return the max multiplier of an address\r\n\t * @param _target The address to query\r\n\t * @return the max multiplier of the address (in 10 ** 6)\r\n\t */\r\n\tfunction maxMultiplierByAddress(address _target) public view returns (uint256) {\r\n\t\treturn (ownedLots[_target].length > 0) ? ownerMaxMultiplier[_target] : 0;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Calculate the primordial token multiplier, bonus network token percentage, and the\r\n\t *\t\tbonus network token amount on a given lot when someone purchases primordial token\r\n\t *\t\tduring network exchange\r\n\t * @param _purchaseAmount The amount of primordial token intended to be purchased\r\n\t * @return The multiplier in (10 ** 6)\r\n\t * @return The bonus percentage\r\n\t * @return The amount of network token as bonus\r\n\t */\r\n\tfunction calculateMultiplierAndBonus(uint256 _purchaseAmount) public view returns (uint256, uint256, uint256) {\r\n\t\t(uint256 startingPrimordialMultiplier, uint256 endingPrimordialMultiplier, uint256 startingNetworkTokenBonusMultiplier, uint256 endingNetworkTokenBonusMultiplier) = _getSettingVariables();\r\n\t\treturn (\r\n\t\t\tAOLibrary.calculatePrimordialMultiplier(_purchaseAmount, TOTAL_PRIMORDIAL_FOR_SALE, primordialTotalBought, startingPrimordialMultiplier, endingPrimordialMultiplier),\r\n\t\t\tAOLibrary.calculateNetworkTokenBonusPercentage(_purchaseAmount, TOTAL_PRIMORDIAL_FOR_SALE, primordialTotalBought, startingNetworkTokenBonusMultiplier, endingNetworkTokenBonusMultiplier),\r\n\t\t\tAOLibrary.calculateNetworkTokenBonusAmount(_purchaseAmount, TOTAL_PRIMORDIAL_FOR_SALE, primordialTotalBought, startingNetworkTokenBonusMultiplier, endingNetworkTokenBonusMultiplier)\r\n\t\t);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Calculate the maximum amount of Primordial an account can burn\r\n\t * @param _account The address of the account\r\n\t * @return The maximum primordial token amount to burn\r\n\t */\r\n\tfunction calculateMaximumBurnAmount(address _account) public view returns (uint256) {\r\n\t\treturn AOLibrary.calculateMaximumBurnAmount(primordialBalanceOf[_account], ownerWeightedMultiplier[_account], ownerMaxMultiplier[_account]);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Calculate account's new multiplier after burn `_amountToBurn` primordial tokens\r\n\t * @param _account The address of the account\r\n\t * @param _amountToBurn The amount of primordial token to burn\r\n\t * @return The new multiplier in (10 ** 6)\r\n\t */\r\n\tfunction calculateMultiplierAfterBurn(address _account, uint256 _amountToBurn) public view returns (uint256) {\r\n\t\trequire (calculateMaximumBurnAmount(_account) >= _amountToBurn);\r\n\t\treturn AOLibrary.calculateMultiplierAfterBurn(primordialBalanceOf[_account], ownerWeightedMultiplier[_account], _amountToBurn);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Calculate account's new multiplier after converting `amountToConvert` network token to primordial token\r\n\t * @param _account The address of the account\r\n\t * @param _amountToConvert The amount of network token to convert\r\n\t * @return The new multiplier in (10 ** 6)\r\n\t */\r\n\tfunction calculateMultiplierAfterConversion(address _account, uint256 _amountToConvert) public view returns (uint256) {\r\n\t\treturn AOLibrary.calculateMultiplierAfterConversion(primordialBalanceOf[_account], ownerWeightedMultiplier[_account], _amountToConvert);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Convert `_value` of network tokens to primordial tokens\r\n\t *\t\tand re-weight the account's multiplier after conversion\r\n\t * @param _value The amount to convert\r\n\t * @return true on success\r\n\t */\r\n\tfunction convertToPrimordial(uint256 _value) public returns (bool success) {\r\n\t\trequire (balanceOf[msg.sender] >= _value);\r\n\r\n\t\t// Update the account's multiplier\r\n\t\townerWeightedMultiplier[msg.sender] = calculateMultiplierAfterConversion(msg.sender, _value);\r\n\t\t// Burn network token\r\n\t\tburn(_value);\r\n\t\t// mint primordial token\r\n\t\t_mintPrimordialToken(msg.sender, _value);\r\n\r\n\t\t// Store convert lot info\r\n\t\ttotalConvertLots++;\r\n\r\n\t\t// Generate convert lot Id\r\n\t\tbytes32 convertLotId = keccak256(abi.encodePacked(this, msg.sender, totalConvertLots));\r\n\r\n\t\t// Make sure no one owns this lot yet\r\n\t\trequire (convertLots[convertLotId].lotOwner == address(0));\r\n\r\n\t\tConvertLot storage convertLot = convertLots[convertLotId];\r\n\t\tconvertLot.convertLotId = convertLotId;\r\n\t\tconvertLot.lotOwner = msg.sender;\r\n\t\tconvertLot.tokenAmount = _value;\r\n\t\townedConvertLots[msg.sender].push(convertLotId);\r\n\t\temit ConvertLotCreation(convertLot.lotOwner, convertLot.convertLotId, convertLot.tokenAmount, ownerWeightedMultiplier[convertLot.lotOwner]);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/***** NETWORK TOKEN & PRIMORDIAL TOKEN METHODS *****/\r\n\t/**\r\n\t * @dev Send `_value` network tokens and `_primordialValue` primordial tokens to `_to` from your account\r\n\t * @param _to The address of the recipient\r\n\t * @param _value The amount of network tokens to send\r\n\t * @param _primordialValue The amount of Primordial tokens to send\r\n\t * @return true on success\r\n\t */\r\n\tfunction transferTokens(address _to, uint256 _value, uint256 _primordialValue) public returns (bool success) {\r\n\t\trequire (super.transfer(_to, _value));\r\n\t\trequire (transferPrimordialToken(_to, _primordialValue));\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Send `_value` network tokens and `_primordialValue` primordial tokens to `_to` from `_from`\r\n\t * @param _from The address of the sender\r\n\t * @param _to The address of the recipient\r\n\t * @param _value The amount of network tokens tokens to send\r\n\t * @param _primordialValue The amount of Primordial tokens to send\r\n\t * @return true on success\r\n\t */\r\n\tfunction transferTokensFrom(address _from, address _to, uint256 _value, uint256 _primordialValue) public returns (bool success) {\r\n\t\trequire (super.transferFrom(_from, _to, _value));\r\n\t\trequire (transferPrimordialTokenFrom(_from, _to, _primordialValue));\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Allows `_spender` to spend no more than `_value` network tokens and `_primordialValue` Primordial tokens in your behalf\r\n\t * @param _spender The address authorized to spend\r\n\t * @param _value The max amount of network tokens they can spend\r\n\t * @param _primordialValue The max amount of network tokens they can spend\r\n\t * @return true on success\r\n\t */\r\n\tfunction approveTokens(address _spender, uint256 _value, uint256 _primordialValue) public returns (bool success) {\r\n\t\trequire (super.approve(_spender, _value));\r\n\t\trequire (approvePrimordialToken(_spender, _primordialValue));\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Allows `_spender` to spend no more than `_value` network tokens and `_primordialValue` Primordial tokens in your behalf, and then ping the contract about it\r\n\t * @param _spender The address authorized to spend\r\n\t * @param _value The max amount of network tokens they can spend\r\n\t * @param _primordialValue The max amount of Primordial Tokens they can spend\r\n\t * @param _extraData some extra information to send to the approved contract\r\n\t * @return true on success\r\n\t */\r\n\tfunction approveTokensAndCall(address _spender, uint256 _value, uint256 _primordialValue, bytes _extraData) public returns (bool success) {\r\n\t\trequire (super.approveAndCall(_spender, _value, _extraData));\r\n\t\trequire (approvePrimordialTokenAndCall(_spender, _primordialValue, _extraData));\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Remove `_value` network tokens and `_primordialValue` Primordial tokens from the system irreversibly\r\n\t * @param _value The amount of network tokens to burn\r\n\t * @param _primordialValue The amount of Primordial tokens to burn\r\n\t * @return true on success\r\n\t */\r\n\tfunction burnTokens(uint256 _value, uint256 _primordialValue) public returns (bool success) {\r\n\t\trequire (super.burn(_value));\r\n\t\trequire (burnPrimordialToken(_primordialValue));\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Remove `_value` network tokens and `_primordialValue` Primordial tokens from the system irreversibly on behalf of `_from`\r\n\t * @param _from The address of sender\r\n\t * @param _value The amount of network tokens to burn\r\n\t * @param _primordialValue The amount of Primordial tokens to burn\r\n\t * @return true on success\r\n\t */\r\n\tfunction burnTokensFrom(address _from, uint256 _value, uint256 _primordialValue) public returns (bool success) {\r\n\t\trequire (super.burnFrom(_from, _value));\r\n\t\trequire (burnPrimordialTokenFrom(_from, _primordialValue));\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/***** INTERNAL METHODS *****/\r\n\t/***** PRIMORDIAL TOKEN INTERNAL METHODS *****/\r\n\t/**\r\n\t * @dev Calculate the amount of token the buyer will receive and remaining budget if exist\r\n\t *\t\twhen he/she buys primordial token\r\n\t * @param _budget The amount of ETH sent by buyer\r\n\t * @return uint256 of the tokenAmount the buyer will receiver\r\n\t * @return uint256 of the remaining budget, if exist\r\n\t * @return bool whether or not the network exchange should end\r\n\t */\r\n\tfunction _calculateTokenAmountAndRemainderBudget(uint256 _budget) internal view returns (uint256, uint256, bool) {\r\n\t\t// Calculate the amount of tokens\r\n\t\tuint256 tokenAmount = _budget.div(primordialBuyPrice);\r\n\r\n\t\t// If we need to return ETH to the buyer, in the case\r\n\t\t// where the buyer sends more ETH than available primordial token to be purchased\r\n\t\tuint256 remainderEth = 0;\r\n\r\n\t\t// Make sure primordialTotalBought is not overflowing\r\n\t\tbool shouldEndNetworkExchange = false;\r\n\t\tif (primordialTotalBought.add(tokenAmount) >= TOTAL_PRIMORDIAL_FOR_SALE) {\r\n\t\t\ttokenAmount = TOTAL_PRIMORDIAL_FOR_SALE.sub(primordialTotalBought);\r\n\t\t\tshouldEndNetworkExchange = true;\r\n\t\t\tremainderEth = msg.value.sub(tokenAmount.mul(primordialBuyPrice));\r\n\t\t}\r\n\t\treturn (tokenAmount, remainderEth, shouldEndNetworkExchange);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Actually sending the primordial token to buyer and reward AO devs accordingly\r\n\t * @param tokenAmount The amount of primordial token to be sent to buyer\r\n\t * @param to The recipient of the token\r\n\t */\r\n\tfunction _sendPrimordialTokenAndRewardDev(uint256 tokenAmount, address to) internal {\r\n\t\t(uint256 startingPrimordialMultiplier,, uint256 startingNetworkTokenBonusMultiplier, uint256 endingNetworkTokenBonusMultiplier) = _getSettingVariables();\r\n\r\n\t\t// Update primordialTotalBought\r\n\t\t(uint256 multiplier, uint256 networkTokenBonusPercentage, uint256 networkTokenBonusAmount) = calculateMultiplierAndBonus(tokenAmount);\r\n\t\tprimordialTotalBought = primordialTotalBought.add(tokenAmount);\r\n\t\t_createPrimordialLot(to, tokenAmount, multiplier, networkTokenBonusAmount);\r\n\r\n\t\t// Calculate The AO and AO Dev Team's portion of Primordial and Network Token Bonus\r\n\t\tuint256 inverseMultiplier = startingPrimordialMultiplier.sub(multiplier); // Inverse of the buyer's multiplier\r\n\t\tuint256 theAONetworkTokenBonusAmount = (startingNetworkTokenBonusMultiplier.sub(networkTokenBonusPercentage).add(endingNetworkTokenBonusMultiplier)).mul(tokenAmount).div(AOLibrary.PERCENTAGE_DIVISOR());\r\n\t\tif (aoDevTeam1 != address(0)) {\r\n\t\t\t_createPrimordialLot(aoDevTeam1, tokenAmount.div(2), inverseMultiplier, theAONetworkTokenBonusAmount.div(2));\r\n\t\t}\r\n\t\tif (aoDevTeam2 != address(0)) {\r\n\t\t\t_createPrimordialLot(aoDevTeam2, tokenAmount.div(2), inverseMultiplier, theAONetworkTokenBonusAmount.div(2));\r\n\t\t}\r\n\t\t_mintToken(theAO, theAONetworkTokenBonusAmount);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Create a lot with `primordialTokenAmount` of primordial tokens with `_multiplier` for an `account`\r\n\t *\t\tduring network exchange, and reward `_networkTokenBonusAmount` if exist\r\n\t * @param _account Address of the lot owner\r\n\t * @param _primordialTokenAmount The amount of primordial tokens to be stored in the lot\r\n\t * @param _multiplier The multiplier for this lot in (10 ** 6)\r\n\t * @param _networkTokenBonusAmount The network token bonus amount\r\n\t */\r\n\tfunction _createPrimordialLot(address _account, uint256 _primordialTokenAmount, uint256 _multiplier, uint256 _networkTokenBonusAmount) internal {\r\n\t\ttotalLots++;\r\n\r\n\t\t// Generate lotId\r\n\t\tbytes32 lotId = keccak256(abi.encodePacked(this, _account, totalLots));\r\n\r\n\t\t// Make sure no one owns this lot yet\r\n\t\trequire (lots[lotId].lotOwner == address(0));\r\n\r\n\t\tLot storage lot = lots[lotId];\r\n\t\tlot.lotId = lotId;\r\n\t\tlot.multiplier = _multiplier;\r\n\t\tlot.lotOwner = _account;\r\n\t\tlot.tokenAmount = _primordialTokenAmount;\r\n\t\townedLots[_account].push(lotId);\r\n\t\townerWeightedMultiplier[_account] = AOLibrary.calculateWeightedMultiplier(ownerWeightedMultiplier[_account], primordialBalanceOf[_account], lot.multiplier, lot.tokenAmount);\r\n\t\t// If this is the first lot, set this as the max multiplier of the account\r\n\t\tif (ownedLots[_account].length == 1) {\r\n\t\t\townerMaxMultiplier[_account] = lot.multiplier;\r\n\t\t}\r\n\t\t_mintPrimordialToken(_account, lot.tokenAmount);\r\n\t\t_mintToken(_account, _networkTokenBonusAmount);\r\n\r\n\t\temit LotCreation(lot.lotOwner, lot.lotId, lot.multiplier, lot.tokenAmount, _networkTokenBonusAmount);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Create `mintedAmount` Primordial tokens and send it to `target`\r\n\t * @param target Address to receive the Primordial tokens\r\n\t * @param mintedAmount The amount of Primordial tokens it will receive\r\n\t */\r\n\tfunction _mintPrimordialToken(address target, uint256 mintedAmount) internal {\r\n\t\tprimordialBalanceOf[target] = primordialBalanceOf[target].add(mintedAmount);\r\n\t\tprimordialTotalSupply = primordialTotalSupply.add(mintedAmount);\r\n\t\temit PrimordialTransfer(0, this, mintedAmount);\r\n\t\temit PrimordialTransfer(this, target, mintedAmount);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Create a lot with `tokenAmount` of tokens at `weightedMultiplier` for an `account`\r\n\t * @param _account Address of lot owner\r\n\t * @param _tokenAmount The amount of tokens\r\n\t * @param _weightedMultiplier The multiplier of the lot (in 10^6)\r\n\t * @return bytes32 of new created lot ID\r\n\t */\r\n\tfunction _createWeightedMultiplierLot(address _account, uint256 _tokenAmount, uint256 _weightedMultiplier) internal returns (bytes32) {\r\n\t\trequire (_account != address(0));\r\n\t\trequire (_tokenAmount > 0);\r\n\r\n\t\ttotalLots++;\r\n\r\n\t\t// Generate lotId\r\n\t\tbytes32 lotId = keccak256(abi.encodePacked(this, _account, totalLots));\r\n\r\n\t\t// Make sure no one owns this lot yet\r\n\t\trequire (lots[lotId].lotOwner == address(0));\r\n\r\n\t\tLot storage lot = lots[lotId];\r\n\t\tlot.lotId = lotId;\r\n\t\tlot.multiplier = _weightedMultiplier;\r\n\t\tlot.lotOwner = _account;\r\n\t\tlot.tokenAmount = _tokenAmount;\r\n\t\townedLots[_account].push(lotId);\r\n\t\t// If this is the first lot, set this as the max multiplier of the account\r\n\t\tif (ownedLots[_account].length == 1) {\r\n\t\t\townerMaxMultiplier[_account] = lot.multiplier;\r\n\t\t}\r\n\t\treturn lotId;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Send `_value` Primordial tokens from `_from` to `_to`\r\n\t * @param _from The address of sender\r\n\t * @param _to The address of the recipient\r\n\t * @param _value The amount to send\r\n\t */\r\n\tfunction _transferPrimordialToken(address _from, address _to, uint256 _value) internal returns (bool) {\r\n\t\trequire (_to != address(0));\t\t\t\t\t\t\t\t\t// Prevent transfer to 0x0 address. Use burn() instead\r\n\t\trequire (primordialBalanceOf[_from] >= _value);\t\t\t\t\t\t// Check if the sender has enough\r\n\t\trequire (primordialBalanceOf[_to].add(_value) >= primordialBalanceOf[_to]);\t// Check for overflows\r\n\t\trequire (!frozenAccount[_from]);\t\t\t\t\t\t\t\t// Check if sender is frozen\r\n\t\trequire (!frozenAccount[_to]);\t\t\t\t\t\t\t\t\t// Check if recipient is frozen\r\n\t\tuint256 previousBalances = primordialBalanceOf[_from].add(primordialBalanceOf[_to]);\r\n\t\tprimordialBalanceOf[_from] = primordialBalanceOf[_from].sub(_value);\t\t\t// Subtract from the sender\r\n\t\tprimordialBalanceOf[_to] = primordialBalanceOf[_to].add(_value);\t\t\t\t// Add the same to the recipient\r\n\t\temit PrimordialTransfer(_from, _to, _value);\r\n\t\tassert(primordialBalanceOf[_from].add(primordialBalanceOf[_to]) == previousBalances);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Store burn lot information\r\n\t * @param _account The address of the account\r\n\t * @param _tokenAmount The amount of primordial tokens to burn\r\n\t */\r\n\tfunction _createBurnLot(address _account, uint256 _tokenAmount) internal {\r\n\t\ttotalBurnLots++;\r\n\r\n\t\t// Generate burn lot Id\r\n\t\tbytes32 burnLotId = keccak256(abi.encodePacked(this, _account, totalBurnLots));\r\n\r\n\t\t// Make sure no one owns this lot yet\r\n\t\trequire (burnLots[burnLotId].lotOwner == address(0));\r\n\r\n\t\tBurnLot storage burnLot = burnLots[burnLotId];\r\n\t\tburnLot.burnLotId = burnLotId;\r\n\t\tburnLot.lotOwner = _account;\r\n\t\tburnLot.tokenAmount = _tokenAmount;\r\n\t\townedBurnLots[_account].push(burnLotId);\r\n\t\temit BurnLotCreation(burnLot.lotOwner, burnLot.burnLotId, burnLot.tokenAmount, ownerWeightedMultiplier[burnLot.lotOwner]);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Get setting variables\r\n\t * @return startingPrimordialMultiplier The starting multiplier used to calculate primordial token\r\n\t * @return endingPrimordialMultiplier The ending multiplier used to calculate primordial token\r\n\t * @return startingNetworkTokenBonusMultiplier The starting multiplier used to calculate network token bonus\r\n\t * @return endingNetworkTokenBonusMultiplier The ending multiplier used to calculate network token bonus\r\n\t */\r\n\tfunction _getSettingVariables() internal view returns (uint256, uint256, uint256, uint256) {\r\n\t\t(uint256 startingPrimordialMultiplier,,,,) = _aoSetting.getSettingValuesByTAOName(settingTAOId, 'startingPrimordialMultiplier');\r\n\t\t(uint256 endingPrimordialMultiplier,,,,) = _aoSetting.getSettingValuesByTAOName(settingTAOId, 'endingPrimordialMultiplier');\r\n\r\n\t\t(uint256 startingNetworkTokenBonusMultiplier,,,,) = _aoSetting.getSettingValuesByTAOName(settingTAOId, 'startingNetworkTokenBonusMultiplier');\r\n\t\t(uint256 endingNetworkTokenBonusMultiplier,,,,) = _aoSetting.getSettingValuesByTAOName(settingTAOId, 'endingNetworkTokenBonusMultiplier');\r\n\r\n\t\treturn (startingPrimordialMultiplier, endingPrimordialMultiplier, startingNetworkTokenBonusMultiplier, endingNetworkTokenBonusMultiplier);\r\n\t}\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title AOTreasury\r\n *\r\n * The purpose of this contract is to list all of the valid denominations of AO Token and do the conversion between denominations\r\n */\r\ncontract AOTreasury is TheAO {\r\n\tusing SafeMath for uint256;\r\n\r\n\tbool public paused;\r\n\tbool public killed;\r\n\r\n\tstruct Denomination {\r\n\t\tbytes8 name;\r\n\t\taddress denominationAddress;\r\n\t}\r\n\r\n\t// Mapping from denomination index to Denomination object\r\n\t// The list is in order from lowest denomination to highest denomination\r\n\t// i.e, denominations[1] is the base denomination\r\n\tmapping (uint256 => Denomination) internal denominations;\r\n\r\n\t// Mapping from denomination ID to index of denominations\r\n\tmapping (bytes8 => uint256) internal denominationIndex;\r\n\r\n\tuint256 public totalDenominations;\r\n\r\n\t// Event to be broadcasted to public when a token exchange happens\r\n\tevent Exchange(address indexed account, uint256 amount, bytes8 fromDenominationName, bytes8 toDenominationName);\r\n\r\n\t// Event to be broadcasted to public when emergency mode is triggered\r\n\tevent EscapeHatch();\r\n\r\n\t/**\r\n\t * @dev Constructor function\r\n\t */\r\n\tconstructor() public {}\r\n\r\n\t/**\r\n\t * @dev Checks if the calling contract address is The AO\r\n\t *\t\tOR\r\n\t *\t\tIf The AO is set to a Name/TAO, then check if calling address is the Advocate\r\n\t */\r\n\tmodifier onlyTheAO {\r\n\t\trequire (AOLibrary.isTheAO(msg.sender, theAO, nameTAOPositionAddress));\r\n\t\t_;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Checks if contract is currently active\r\n\t */\r\n\tmodifier isContractActive {\r\n\t\trequire (paused == false && killed == false);\r\n\t\t_;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Checks if denomination is valid\r\n\t */\r\n\tmodifier isValidDenomination(bytes8 denominationName) {\r\n\t\trequire (denominationIndex[denominationName] > 0 && denominations[denominationIndex[denominationName]].denominationAddress != address(0));\r\n\t\t_;\r\n\t}\r\n\r\n\t/***** The AO ONLY METHODS *****/\r\n\t/**\r\n\t * @dev The AO set the NameTAOPosition Address\r\n\t * @param _nameTAOPositionAddress The address of NameTAOPosition\r\n\t */\r\n\tfunction setNameTAOPositionAddress(address _nameTAOPositionAddress) public onlyTheAO {\r\n\t\trequire (_nameTAOPositionAddress != address(0));\r\n\t\tnameTAOPositionAddress = _nameTAOPositionAddress;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Transfer ownership of The AO to new address\r\n\t * @param _theAO The new address to be transferred\r\n\t */\r\n\tfunction transferOwnership(address _theAO) public onlyTheAO {\r\n\t\trequire (_theAO != address(0));\r\n\t\ttheAO = _theAO;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Whitelist `_account` address to transact on behalf of others\r\n\t * @param _account The address to whitelist\r\n\t * @param _whitelist Either to whitelist or not\r\n\t */\r\n\tfunction setWhitelist(address _account, bool _whitelist) public onlyTheAO {\r\n\t\trequire (_account != address(0));\r\n\t\twhitelist[_account] = _whitelist;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev The AO pauses/unpauses contract\r\n\t * @param _paused Either to pause contract or not\r\n\t */\r\n\tfunction setPaused(bool _paused) public onlyTheAO {\r\n\t\tpaused = _paused;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev The AO triggers emergency mode.\r\n\t *\r\n\t */\r\n\tfunction escapeHatch() public onlyTheAO {\r\n\t\trequire (killed == false);\r\n\t\tkilled = true;\r\n\t\temit EscapeHatch();\r\n\t}\r\n\r\n\t/**\r\n\t * @dev The AO adds denomination and the contract address associated with it\r\n\t * @param denominationName The name of the denomination, i.e ao, kilo, mega, etc.\r\n\t * @param denominationAddress The address of the denomination token\r\n\t * @return true on success\r\n\t */\r\n\tfunction addDenomination(bytes8 denominationName, address denominationAddress) public onlyTheAO returns (bool) {\r\n\t\trequire (denominationName.length != 0);\r\n\t\trequire (denominationAddress != address(0));\r\n\t\trequire (denominationIndex[denominationName] == 0);\r\n\t\ttotalDenominations++;\r\n\t\t// Make sure the new denomination is higher than the previous\r\n\t\tif (totalDenominations > 1) {\r\n\t\t\tAOTokenInterface _lastDenominationToken = AOTokenInterface(denominations[totalDenominations - 1].denominationAddress);\r\n\t\t\tAOTokenInterface _newDenominationToken = AOTokenInterface(denominationAddress);\r\n\t\t\trequire (_newDenominationToken.powerOfTen() > _lastDenominationToken.powerOfTen());\r\n\t\t}\r\n\t\tdenominations[totalDenominations].name = denominationName;\r\n\t\tdenominations[totalDenominations].denominationAddress = denominationAddress;\r\n\t\tdenominationIndex[denominationName] = totalDenominations;\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev The AO updates denomination address or activates/deactivates the denomination\r\n\t * @param denominationName The name of the denomination, i.e ao, kilo, mega, etc.\r\n\t * @param denominationAddress The address of the denomination token\r\n\t * @return true on success\r\n\t */\r\n\tfunction updateDenomination(bytes8 denominationName, address denominationAddress) public onlyTheAO returns (bool) {\r\n\t\trequire (denominationName.length != 0);\r\n\t\trequire (denominationIndex[denominationName] > 0);\r\n\t\trequire (denominationAddress != address(0));\r\n\t\tuint256 _denominationNameIndex = denominationIndex[denominationName];\r\n\t\tAOTokenInterface _newDenominationToken = AOTokenInterface(denominationAddress);\r\n\t\tif (_denominationNameIndex > 1) {\r\n\t\t\tAOTokenInterface _prevDenominationToken = AOTokenInterface(denominations[_denominationNameIndex - 1].denominationAddress);\r\n\t\t\trequire (_newDenominationToken.powerOfTen() > _prevDenominationToken.powerOfTen());\r\n\t\t}\r\n\t\tif (_denominationNameIndex < totalDenominations) {\r\n\t\t\tAOTokenInterface _lastDenominationToken = AOTokenInterface(denominations[totalDenominations].denominationAddress);\r\n\t\t\trequire (_newDenominationToken.powerOfTen() < _lastDenominationToken.powerOfTen());\r\n\t\t}\r\n\t\tdenominations[denominationIndex[denominationName]].denominationAddress = denominationAddress;\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/***** PUBLIC METHODS *****/\r\n\t/**\r\n\t * @dev Get denomination info based on name\r\n\t * @param denominationName The name to be queried\r\n\t * @return the denomination short name\r\n\t * @return the denomination address\r\n\t * @return the denomination public name\r\n\t * @return the denomination symbol\r\n\t * @return the denomination num of decimals\r\n\t * @return the denomination multiplier (power of ten)\r\n\t */\r\n\tfunction getDenominationByName(bytes8 denominationName) public view returns (bytes8, address, string, string, uint8, uint256) {\r\n\t\trequire (denominationName.length != 0);\r\n\t\trequire (denominationIndex[denominationName] > 0);\r\n\t\trequire (denominations[denominationIndex[denominationName]].denominationAddress != address(0));\r\n\t\tAOTokenInterface _ao = AOTokenInterface(denominations[denominationIndex[denominationName]].denominationAddress);\r\n\t\treturn (\r\n\t\t\tdenominations[denominationIndex[denominationName]].name,\r\n\t\t\tdenominations[denominationIndex[denominationName]].denominationAddress,\r\n\t\t\t_ao.name(),\r\n\t\t\t_ao.symbol(),\r\n\t\t\t_ao.decimals(),\r\n\t\t\t_ao.powerOfTen()\r\n\t\t);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Get denomination info by index\r\n\t * @param index The index to be queried\r\n\t * @return the denomination short name\r\n\t * @return the denomination address\r\n\t * @return the denomination public name\r\n\t * @return the denomination symbol\r\n\t * @return the denomination num of decimals\r\n\t * @return the denomination multiplier (power of ten)\r\n\t */\r\n\tfunction getDenominationByIndex(uint256 index) public view returns (bytes8, address, string, string, uint8, uint256) {\r\n\t\trequire (index > 0 && index <= totalDenominations);\r\n\t\trequire (denominations[index].denominationAddress != address(0));\r\n\t\tAOTokenInterface _ao = AOTokenInterface(denominations[index].denominationAddress);\r\n\t\treturn (\r\n\t\t\tdenominations[index].name,\r\n\t\t\tdenominations[index].denominationAddress,\r\n\t\t\t_ao.name(),\r\n\t\t\t_ao.symbol(),\r\n\t\t\t_ao.decimals(),\r\n\t\t\t_ao.powerOfTen()\r\n\t\t);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Get base denomination info\r\n\t * @return the denomination short name\r\n\t * @return the denomination address\r\n\t * @return the denomination public name\r\n\t * @return the denomination symbol\r\n\t * @return the denomination num of decimals\r\n\t * @return the denomination multiplier (power of ten)\r\n\t */\r\n\tfunction getBaseDenomination() public view returns (bytes8, address, string, string, uint8, uint256) {\r\n\t\trequire (totalDenominations > 1);\r\n\t\treturn getDenominationByIndex(1);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev convert token from `denominationName` denomination to base denomination,\r\n\t *\t\tin this case it's similar to web3.toWei() functionality\r\n\t *\r\n\t * Example:\r\n\t * 9.1 Kilo should be entered as 9 integerAmount and 100 fractionAmount\r\n\t * 9.02 Kilo should be entered as 9 integerAmount and 20 fractionAmount\r\n\t * 9.001 Kilo should be entered as 9 integerAmount and 1 fractionAmount\r\n\t *\r\n\t * @param integerAmount uint256 of the integer amount to be converted\r\n\t * @param fractionAmount uint256 of the frational amount to be converted\r\n\t * @param denominationName bytes8 name of the token denomination\r\n\t * @return uint256 converted amount in base denomination from target denomination\r\n\t */\r\n\tfunction toBase(uint256 integerAmount, uint256 fractionAmount, bytes8 denominationName) public view returns (uint256) {\r\n\t\tif (denominationName.length > 0 &&\r\n\t\t\tdenominationIndex[denominationName] > 0 &&\r\n\t\t\tdenominations[denominationIndex[denominationName]].denominationAddress != address(0) &&\r\n\t\t\t(integerAmount > 0 || fractionAmount > 0)) {\r\n\r\n\t\t\tDenomination memory _denomination = denominations[denominationIndex[denominationName]];\r\n\t\t\tAOTokenInterface _denominationToken = AOTokenInterface(_denomination.denominationAddress);\r\n\t\t\tuint8 fractionNumDigits = _numDigits(fractionAmount);\r\n\t\t\trequire (fractionNumDigits <= _denominationToken.decimals());\r\n\t\t\tuint256 baseInteger = integerAmount.mul(10 ** _denominationToken.powerOfTen());\r\n\t\t\tif (_denominationToken.decimals() == 0) {\r\n\t\t\t\tfractionAmount = 0;\r\n\t\t\t}\r\n\t\t\treturn baseInteger.add(fractionAmount);\r\n\t\t} else {\r\n\t\t\treturn 0;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @dev convert token from base denomination to `denominationName` denomination,\r\n\t *\t\tin this case it's similar to web3.fromWei() functionality\r\n\t * @param integerAmount uint256 of the base amount to be converted\r\n\t * @param denominationName bytes8 name of the target token denomination\r\n\t * @return uint256 of the converted integer amount in target denomination\r\n\t * @return uint256 of the converted fraction amount in target denomination\r\n\t */\r\n\tfunction fromBase(uint256 integerAmount, bytes8 denominationName) public isValidDenomination(denominationName) view returns (uint256, uint256) {\r\n\t\tDenomination memory _denomination = denominations[denominationIndex[denominationName]];\r\n\t\tAOTokenInterface _denominationToken = AOTokenInterface(_denomination.denominationAddress);\r\n\t\tuint256 denominationInteger = integerAmount.div(10 ** _denominationToken.powerOfTen());\r\n\t\tuint256 denominationFraction = integerAmount.sub(denominationInteger.mul(10 ** _denominationToken.powerOfTen()));\r\n\t\treturn (denominationInteger, denominationFraction);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev exchange `amount` token from `fromDenominationName` denomination to token in `toDenominationName` denomination\r\n\t * @param amount The amount of token to exchange\r\n\t * @param fromDenominationName The origin denomination\r\n\t * @param toDenominationName The target denomination\r\n\t */\r\n\tfunction exchange(uint256 amount, bytes8 fromDenominationName, bytes8 toDenominationName) public isContractActive isValidDenomination(fromDenominationName) isValidDenomination(toDenominationName) {\r\n\t\trequire (amount > 0);\r\n\t\tDenomination memory _fromDenomination = denominations[denominationIndex[fromDenominationName]];\r\n\t\tDenomination memory _toDenomination = denominations[denominationIndex[toDenominationName]];\r\n\t\tAOTokenInterface _fromDenominationToken = AOTokenInterface(_fromDenomination.denominationAddress);\r\n\t\tAOTokenInterface _toDenominationToken = AOTokenInterface(_toDenomination.denominationAddress);\r\n\t\trequire (_fromDenominationToken.whitelistBurnFrom(msg.sender, amount));\r\n\t\trequire (_toDenominationToken.mintToken(msg.sender, amount));\r\n\t\temit Exchange(msg.sender, amount, fromDenominationName, toDenominationName);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Return the highest possible denomination given a base amount\r\n\t * @param amount The amount to be converted\r\n\t * @return the denomination short name\r\n\t * @return the denomination address\r\n\t * @return the integer amount at the denomination level\r\n\t * @return the fraction amount at the denomination level\r\n\t * @return the denomination public name\r\n\t * @return the denomination symbol\r\n\t * @return the denomination num of decimals\r\n\t * @return the denomination multiplier (power of ten)\r\n\t */\r\n\tfunction toHighestDenomination(uint256 amount) public view returns (bytes8, address, uint256, uint256, string, string, uint8, uint256) {\r\n\t\tuint256 integerAmount;\r\n\t\tuint256 fractionAmount;\r\n\t\tuint256 index;\r\n\t\tfor (uint256 i=totalDenominations; i>0; i--) {\r\n\t\t\tDenomination memory _denomination = denominations[i];\r\n\t\t\t(integerAmount, fractionAmount) = fromBase(amount, _denomination.name);\r\n\t\t\tif (integerAmount > 0) {\r\n\t\t\t\tindex = i;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\trequire (index > 0 && index <= totalDenominations);\r\n\t\trequire (integerAmount > 0 || fractionAmount > 0);\r\n\t\trequire (denominations[index].denominationAddress != address(0));\r\n\t\tAOTokenInterface _ao = AOTokenInterface(denominations[index].denominationAddress);\r\n\t\treturn (\r\n\t\t\tdenominations[index].name,\r\n\t\t\tdenominations[index].denominationAddress,\r\n\t\t\tintegerAmount,\r\n\t\t\tfractionAmount,\r\n\t\t\t_ao.name(),\r\n\t\t\t_ao.symbol(),\r\n\t\t\t_ao.decimals(),\r\n\t\t\t_ao.powerOfTen()\r\n\t\t);\r\n\t}\r\n\r\n\t/***** INTERNAL METHOD *****/\r\n\t/**\r\n\t * @dev count num of digits\r\n\t * @param number uint256 of the nuumber to be checked\r\n\t * @return uint8 num of digits\r\n\t */\r\n\tfunction _numDigits(uint256 number) internal pure returns (uint8) {\r\n\t\tuint8 digits = 0;\r\n\t\twhile(number != 0) {\r\n\t\t\tnumber = number.div(10);\r\n\t\t\tdigits++;\r\n\t\t}\r\n\t\treturn digits;\r\n\t}\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract Pathos is TAOCurrency {\r\n\t/**\r\n\t * @dev Constructor function\r\n\t */\r\n\tconstructor(uint256 initialSupply, string tokenName, string tokenSymbol)\r\n\t\tTAOCurrency(initialSupply, tokenName, tokenSymbol) public {}\r\n}\r\n\r\n\r\n\r\n\r\n\r\ncontract Ethos is TAOCurrency {\r\n\t/**\r\n\t * @dev Constructor function\r\n\t */\r\n\tconstructor(uint256 initialSupply, string tokenName, string tokenSymbol)\r\n\t\tTAOCurrency(initialSupply, tokenName, tokenSymbol) public {}\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title TAOController\r\n */\r\ncontract TAOController {\r\n\tNameFactory internal _nameFactory;\r\n\tNameTAOPosition internal _nameTAOPosition;\r\n\r\n\t/**\r\n\t * @dev Constructor function\r\n\t */\r\n\tconstructor(address _nameFactoryAddress, address _nameTAOPositionAddress) public {\r\n\t\t_nameFactory = NameFactory(_nameFactoryAddress);\r\n\t\t_nameTAOPosition = NameTAOPosition(_nameTAOPositionAddress);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Check if `_taoId` is a TAO\r\n\t */\r\n\tmodifier isTAO(address _taoId) {\r\n\t\trequire (AOLibrary.isTAO(_taoId));\r\n\t\t_;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Check if `_nameId` is a Name\r\n\t */\r\n\tmodifier isName(address _nameId) {\r\n\t\trequire (AOLibrary.isName(_nameId));\r\n\t\t_;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Check if `_id` is a Name or a TAO\r\n\t */\r\n\tmodifier isNameOrTAO(address _id) {\r\n\t\trequire (AOLibrary.isName(_id) || AOLibrary.isTAO(_id));\r\n\t\t_;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Check is msg.sender address is a Name\r\n\t */\r\n\t modifier senderIsName() {\r\n\t\trequire (_nameFactory.ethAddressToNameId(msg.sender) != address(0));\r\n\t\t_;\r\n\t }\r\n\r\n\t/**\r\n\t * @dev Check if msg.sender is the current advocate of TAO ID\r\n\t */\r\n\tmodifier onlyAdvocate(address _id) {\r\n\t\trequire (_nameTAOPosition.senderIsAdvocate(msg.sender, _id));\r\n\t\t_;\r\n\t}\r\n}\r\n\r\n\r\n\t\t// Store the name lookup for a Name/TAO\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title TAOFamily\r\n */\r\ncontract TAOFamily is TAOController {\r\n\tusing SafeMath for uint256;\r\n\r\n\taddress public taoFactoryAddress;\r\n\r\n\tTAOFactory internal _taoFactory;\r\n\r\n\tstruct Child {\r\n\t\taddress taoId;\r\n\t\tbool approved;\t\t// If false, then waiting for parent TAO approval\r\n\t\tbool connected;\t\t// If false, then parent TAO want to remove this child TAO\r\n\t}\r\n\r\n\tstruct Family {\r\n\t\taddress taoId;\r\n\t\taddress parentId;\t// The parent of this TAO ID (could be a Name or TAO)\r\n\t\tuint256 childMinLogos;\r\n\t\tmapping (uint256 => Child) children;\r\n\t\tmapping (address => uint256) childInternalIdLookup;\r\n\t\tuint256 totalChildren;\r\n\t\tuint256 childInternalId;\r\n\t}\r\n\r\n\tmapping (address => Family) internal families;\r\n\r\n\t// Event to be broadcasted to public when Advocate updates min required Logos to create a child TAO\r\n\tevent UpdateChildMinLogos(address indexed taoId, uint256 childMinLogos, uint256 nonce);\r\n\r\n\t// Event to be broadcasted to public when a TAO adds a child TAO\r\n\tevent AddChild(address indexed taoId, address childId, bool approved, bool connected, uint256 nonce);\r\n\r\n\t// Event to be broadcasted to public when a TAO approves a child TAO\r\n\tevent ApproveChild(address indexed taoId, address childId, uint256 nonce);\r\n\r\n\t// Event to be broadcasted to public when a TAO removes a child TAO\r\n\tevent RemoveChild(address indexed taoId, address childId, uint256 nonce);\r\n\r\n\t/**\r\n\t * @dev Constructor function\r\n\t */\r\n\tconstructor(address _nameFactoryAddress, address _nameTAOPositionAddress, address _taoFactoryAddress)\r\n\t\tTAOController(_nameFactoryAddress, _nameTAOPositionAddress) public {\r\n\t\ttaoFactoryAddress = _taoFactoryAddress;\r\n\t\t_taoFactory = TAOFactory(_taoFactoryAddress);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Check if calling address is Factory\r\n\t */\r\n\tmodifier onlyFactory {\r\n\t\trequire (msg.sender == taoFactoryAddress);\r\n\t\t_;\r\n\t}\r\n\r\n\t/***** PUBLIC METHODS *****/\r\n\t/**\r\n\t * @dev Check whether or not a TAO ID exist in the list of families\r\n\t * @param _id The ID to be checked\r\n\t * @return true if yes, false otherwise\r\n\t */\r\n\tfunction isExist(address _id) public view returns (bool) {\r\n\t\treturn families[_id].taoId != address(0);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Store the Family info for a TAO\r\n\t * @param _id The ID of the TAO\r\n\t * @param _parentId The parent ID of this TAO\r\n\t * @param _childMinLogos The min required Logos to create a TAO\r\n\t * @return true on success\r\n\t */\r\n\tfunction add(address _id, address _parentId, uint256 _childMinLogos)\r\n\t\tpublic\r\n\t\tisTAO(_id)\r\n\t\tisNameOrTAO(_parentId)\r\n\t\tonlyFactory returns (bool) {\r\n\t\trequire (!isExist(_id));\r\n\r\n\t\tFamily storage _family = families[_id];\r\n\t\t_family.taoId = _id;\r\n\t\t_family.parentId = _parentId;\r\n\t\t_family.childMinLogos = _childMinLogos;\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Get Family info given a TAO ID\r\n\t * @param _id The ID of the TAO\r\n\t * @return the parent ID of this TAO (could be a Name/TAO)\r\n\t * @return the min required Logos to create a child TAO\r\n\t * @return the total child TAOs count\r\n\t */\r\n\tfunction getFamilyById(address _id) public view returns (address, uint256, uint256) {\r\n\t\trequire (isExist(_id));\r\n\t\tFamily memory _family = families[_id];\r\n\t\treturn (\r\n\t\t\t_family.parentId,\r\n\t\t\t_family.childMinLogos,\r\n\t\t\t_family.totalChildren\r\n\t\t);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Set min required Logos to create a child from this TAO\r\n\t * @param _childMinLogos The min Logos to set\r\n\t * @return the nonce for this transaction\r\n\t */\r\n\tfunction updateChildMinLogos(address _id, uint256 _childMinLogos)\r\n\t\tpublic\r\n\t\tisTAO(_id)\r\n\t\tsenderIsName()\r\n\t\tonlyAdvocate(_id) {\r\n\t\trequire (isExist(_id));\r\n\r\n\t\tFamily storage _family = families[_id];\r\n\t\t_family.childMinLogos = _childMinLogos;\r\n\r\n\t\tuint256 _nonce = _taoFactory.incrementNonce(_id);\r\n\t\trequire (_nonce > 0);\r\n\t\temit UpdateChildMinLogos(_id, _family.childMinLogos, _nonce);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Check if `_childId` is a child TAO of `_taoId`\r\n\t * @param _taoId The TAO ID to be checked\r\n\t * @param _childId The child TAO ID to check\r\n\t * @return true if yes. Otherwise return false.\r\n\t */\r\n\tfunction isChild(address _taoId, address _childId) public view returns (bool) {\r\n\t\trequire (isExist(_taoId) && isExist(_childId));\r\n\t\tFamily storage _family = families[_taoId];\r\n\t\tFamily memory _childFamily = families[_childId];\r\n\t\tuint256 _childInternalId = _family.childInternalIdLookup[_childId];\r\n\t\treturn (\r\n\t\t\t_childInternalId > 0 &&\r\n\t\t\t_family.children[_childInternalId].approved &&\r\n\t\t\t_family.children[_childInternalId].connected &&\r\n\t\t\t_childFamily.parentId == _taoId\r\n\t\t);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Add child TAO\r\n\t * @param _taoId The TAO ID to be added to\r\n\t * @param _childId The ID to be added to as child TAO\r\n\t */\r\n\tfunction addChild(address _taoId, address _childId)\r\n\t\tpublic\r\n\t\tisTAO(_taoId)\r\n\t\tisTAO(_childId)\r\n\t\tonlyFactory returns (bool) {\r\n\t\trequire (!isChild(_taoId, _childId));\r\n\t\tFamily storage _family = families[_taoId];\r\n\t\trequire (_family.childInternalIdLookup[_childId] == 0);\r\n\r\n\t\t_family.childInternalId++;\r\n\t\t_family.childInternalIdLookup[_childId] = _family.childInternalId;\r\n\t\tuint256 _nonce = _taoFactory.incrementNonce(_taoId);\r\n\t\trequire (_nonce > 0);\r\n\r\n\t\tChild storage _child = _family.children[_family.childInternalId];\r\n\t\t_child.taoId = _childId;\r\n\r\n\t\t// If _taoId's Advocate == _childId's Advocate, then the child is automatically approved and connected\r\n\t\t// Otherwise, child TAO needs parent TAO approval\r\n\t\taddress _taoAdvocate = _nameTAOPosition.getAdvocate(_taoId);\r\n\t\taddress _childAdvocate = _nameTAOPosition.getAdvocate(_childId);\r\n\t\tif (_taoAdvocate == _childAdvocate) {\r\n\t\t\t_family.totalChildren++;\r\n\t\t\t_child.approved = true;\r\n\t\t\t_child.connected = true;\r\n\r\n\t\t\tFamily storage _childFamily = families[_childId];\r\n\t\t\t_childFamily.parentId = _taoId;\r\n\t\t}\r\n\r\n\t\temit AddChild(_taoId, _childId, _child.approved, _child.connected, _nonce);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Advocate of `_taoId` approves child `_childId`\r\n\t * @param _taoId The TAO ID to be checked\r\n\t * @param _childId The child TAO ID to be approved\r\n\t */\r\n\tfunction approveChild(address _taoId, address _childId)\r\n\t\tpublic\r\n\t\tisTAO(_taoId)\r\n\t\tisTAO(_childId)\r\n\t\tsenderIsName()\r\n\t\tonlyAdvocate(_taoId) {\r\n\t\trequire (isExist(_taoId) && isExist(_childId));\r\n\t\tFamily storage _family = families[_taoId];\r\n\t\tFamily storage _childFamily = families[_childId];\r\n\t\tuint256 _childInternalId = _family.childInternalIdLookup[_childId];\r\n\r\n\t\trequire (_childInternalId > 0 &&\r\n\t\t\t!_family.children[_childInternalId].approved &&\r\n\t\t\t!_family.children[_childInternalId].connected\r\n\t\t);\r\n\r\n\t\t_family.totalChildren++;\r\n\r\n\t\tChild storage _child = _family.children[_childInternalId];\r\n\t\t_child.approved = true;\r\n\t\t_child.connected = true;\r\n\r\n\t\t_childFamily.parentId = _taoId;\r\n\r\n\t\tuint256 _nonce = _taoFactory.incrementNonce(_taoId);\r\n\t\trequire (_nonce > 0);\r\n\r\n\t\temit ApproveChild(_taoId, _childId, _nonce);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Advocate of `_taoId` removes child `_childId`\r\n\t * @param _taoId The TAO ID to be checked\r\n\t * @param _childId The child TAO ID to be removed\r\n\t */\r\n\tfunction removeChild(address _taoId, address _childId)\r\n\t\tpublic\r\n\t\tisTAO(_taoId)\r\n\t\tisTAO(_childId)\r\n\t\tsenderIsName()\r\n\t\tonlyAdvocate(_taoId) {\r\n\t\trequire (isChild(_taoId, _childId));\r\n\r\n\t\tFamily storage _family = families[_taoId];\r\n\t\t_family.totalChildren--;\r\n\r\n\t\tChild storage _child = _family.children[_family.childInternalIdLookup[_childId]];\r\n\t\t_child.connected = false;\r\n\t\t_family.childInternalIdLookup[_childId] = 0;\r\n\r\n\t\tFamily storage _childFamily = families[_childId];\r\n\t\t_childFamily.parentId = address(0);\r\n\r\n\t\tuint256 _nonce = _taoFactory.incrementNonce(_taoId);\r\n\t\trequire (_nonce > 0);\r\n\r\n\t\temit RemoveChild(_taoId, _childId, _nonce);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Get list of child TAO IDs\r\n\t * @param _taoId The TAO ID to be checked\r\n\t * @param _from The starting index (start from 1)\r\n\t * @param _to The ending index, (max is childInternalId)\r\n\t * @return list of child TAO IDs\r\n\t */\r\n\tfunction getChildIds(address _taoId, uint256 _from, uint256 _to) public view returns (address[]) {\r\n\t\trequire (isExist(_taoId));\r\n\t\tFamily storage _family = families[_taoId];\r\n\t\trequire (_from >= 1 && _to >= _from && _family.childInternalId >= _to);\r\n\t\taddress[] memory _childIds = new address[](_to.sub(_from).add(1));\r\n\t\tfor (uint256 i = _from; i <= _to; i++) {\r\n\t\t\t_childIds[i.sub(_from)] = _family.children[i].approved && _family.children[i].connected ? _family.children[i].taoId : address(0);\r\n\t\t}\r\n\t\treturn _childIds;\r\n\t}\r\n}\r\n\t\t\t// Store TAO's child information\r\n\r\n\r\n\r\n/**\r\n * @title TAOFactory\r\n *\r\n * The purpose of this contract is to allow node to create TAO\r\n */\r\ncontract TAOFactory is TheAO, TAOController {\r\n\tusing SafeMath for uint256;\r\n\taddress[] internal taos;\r\n\r\n\taddress public taoFamilyAddress;\r\n\taddress public nameTAOVaultAddress;\r\n\taddress public settingTAOId;\r\n\r\n\tNameTAOLookup internal _nameTAOLookup;\r\n\tTAOFamily internal _taoFamily;\r\n\tAOSetting internal _aoSetting;\r\n\tLogos internal _logos;\r\n\r\n\t// Mapping from TAO ID to its nonce\r\n\tmapping (address => uint256) public nonces;\r\n\r\n\t// Event to be broadcasted to public when Advocate creates a TAO\r\n\tevent CreateTAO(address indexed ethAddress, address advocateId, address taoId, uint256 index, address parent, uint8 parentTypeId);\r\n\r\n\t/**\r\n\t * @dev Constructor function\r\n\t */\r\n\tconstructor(address _nameFactoryAddress, address _nameTAOLookupAddress, address _nameTAOPositionAddress, address _aoSettingAddress, address _logosAddress, address _nameTAOVaultAddress)\r\n\t\tTAOController(_nameFactoryAddress, _nameTAOPositionAddress) public {\r\n\t\tnameTAOPositionAddress = _nameTAOPositionAddress;\r\n\t\tnameTAOVaultAddress = _nameTAOVaultAddress;\r\n\r\n\t\t_nameTAOLookup = NameTAOLookup(_nameTAOLookupAddress);\r\n\t\t_nameTAOPosition = NameTAOPosition(_nameTAOPositionAddress);\r\n\t\t_aoSetting = AOSetting(_aoSettingAddress);\r\n\t\t_logos = Logos(_logosAddress);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Checks if the calling contract address is The AO\r\n\t *\t\tOR\r\n\t *\t\tIf The AO is set to a Name/TAO, then check if calling address is the Advocate\r\n\t */\r\n\tmodifier onlyTheAO {\r\n\t\trequire (AOLibrary.isTheAO(msg.sender, theAO, nameTAOPositionAddress));\r\n\t\t_;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Checks if calling address can update TAO's nonce\r\n\t */\r\n\tmodifier canUpdateNonce {\r\n\t\trequire (msg.sender == nameTAOPositionAddress || msg.sender == taoFamilyAddress);\r\n\t\t_;\r\n\t}\r\n\r\n\t/***** The AO ONLY METHODS *****/\r\n\t/**\r\n\t * @dev Transfer ownership of The AO to new address\r\n\t * @param _theAO The new address to be transferred\r\n\t */\r\n\tfunction transferOwnership(address _theAO) public onlyTheAO {\r\n\t\trequire (_theAO != address(0));\r\n\t\ttheAO = _theAO;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Whitelist `_account` address to transact on behalf of others\r\n\t * @param _account The address to whitelist\r\n\t * @param _whitelist Either to whitelist or not\r\n\t */\r\n\tfunction setWhitelist(address _account, bool _whitelist) public onlyTheAO {\r\n\t\trequire (_account != address(0));\r\n\t\twhitelist[_account] = _whitelist;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev The AO set the TAOFamily Address\r\n\t * @param _taoFamilyAddress The address of TAOFamily\r\n\t */\r\n\tfunction setTAOFamilyAddress(address _taoFamilyAddress) public onlyTheAO {\r\n\t\trequire (_taoFamilyAddress != address(0));\r\n\t\ttaoFamilyAddress = _taoFamilyAddress;\r\n\t\t_taoFamily = TAOFamily(taoFamilyAddress);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev The AO set settingTAOId (The TAO ID that holds the setting values)\r\n\t * @param _settingTAOId The address of settingTAOId\r\n\t */\r\n\tfunction setSettingTAOId(address _settingTAOId) public onlyTheAO isTAO(_settingTAOId) {\r\n\t\tsettingTAOId = _settingTAOId;\r\n\t}\r\n\r\n\t/***** PUBLIC METHODS *****/\r\n\t/**\r\n\t * @dev Increment the nonce of a TAO\r\n\t * @param _taoId The ID of the TAO\r\n\t * @return current nonce\r\n\t */\r\n\tfunction incrementNonce(address _taoId) public canUpdateNonce returns (uint256) {\r\n\t\t// Check if _taoId exist\r\n\t\trequire (nonces[_taoId] > 0);\r\n\t\tnonces[_taoId]++;\r\n\t\treturn nonces[_taoId];\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Name creates a TAO\r\n\t * @param _name The name of the TAO\r\n\t * @param _datHash The datHash of this TAO\r\n\t * @param _database The database for this TAO\r\n\t * @param _keyValue The key/value pair to be checked on the database\r\n\t * @param _contentId The contentId related to this TAO\r\n\t * @param _parentId The parent of this TAO (has to be a Name or TAO)\r\n\t * @param _childMinLogos The min required Logos to create a child from this TAO\r\n\t */\r\n\tfunction createTAO(\r\n\t\tstring _name,\r\n\t\tstring _datHash,\r\n\t\tstring _database,\r\n\t\tstring _keyValue,\r\n\t\tbytes32 _contentId,\r\n\t\taddress _parentId,\r\n\t\tuint256 _childMinLogos\r\n\t) public senderIsName() isNameOrTAO(_parentId) {\r\n\t\trequire (bytes(_name).length > 0);\r\n\t\trequire (!_nameTAOLookup.isExist(_name));\r\n\r\n\t\taddress _nameId = _nameFactory.ethAddressToNameId(msg.sender);\r\n\r\n\t\tuint256 _parentCreateChildTAOMinLogos;\r\n\t\tuint256 _createChildTAOMinLogos = _getSettingVariables();\r\n\t\tif (AOLibrary.isTAO(_parentId)) {\r\n\t\t\t(, _parentCreateChildTAOMinLogos,) = _taoFamily.getFamilyById(_parentId);\r\n\t\t}\r\n\t\tif (_parentCreateChildTAOMinLogos > 0) {\r\n\t\t\trequire (_logos.sumBalanceOf(_nameId) >= _parentCreateChildTAOMinLogos);\r\n\t\t} else if (_createChildTAOMinLogos > 0) {\r\n\t\t\trequire (_logos.sumBalanceOf(_nameId) >= _createChildTAOMinLogos);\r\n\t\t}\r\n\r\n\t\t// Create the TAO\r\n\t\taddress taoId = new TAO(_name, _nameId, _datHash, _database, _keyValue, _contentId, nameTAOVaultAddress);\r\n\r\n\t\t// Increment the nonce\r\n\t\tnonces[taoId]++;\r\n\r\n\t\t// Store the name lookup information\r\n\t\trequire (_nameTAOLookup.add(_name, taoId, TAO(_parentId).name(), 0));\r\n\r\n\t\t// Store the Advocate/Listener/Speaker information\r\n\t\trequire (_nameTAOPosition.add(taoId, _nameId, _nameId, _nameId));\r\n\r\n\t\trequire (_taoFamily.add(taoId, _parentId, _childMinLogos));\r\n\t\ttaos.push(taoId);\r\n\r\n\t\temit CreateTAO(msg.sender, _nameId, taoId, taos.length.sub(1), _parentId, TAO(_parentId).typeId());\r\n\r\n\t\tif (AOLibrary.isTAO(_parentId)) {\r\n\t\t\trequire (_taoFamily.addChild(_parentId, taoId));\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Get TAO information\r\n\t * @param _taoId The ID of the TAO to be queried\r\n\t * @return The name of the TAO\r\n\t * @return The origin Name ID that created the TAO\r\n\t * @return The name of Name that created the TAO\r\n\t * @return The datHash of the TAO\r\n\t * @return The database of the TAO\r\n\t * @return The keyValue of the TAO\r\n\t * @return The contentId of the TAO\r\n\t * @return The typeId of the TAO\r\n\t */\r\n\tfunction getTAO(address _taoId) public view returns (string, address, string, string, string, string, bytes32, uint8) {\r\n\t\tTAO _tao = TAO(_taoId);\r\n\t\treturn (\r\n\t\t\t_tao.name(),\r\n\t\t\t_tao.originId(),\r\n\t\t\tName(_tao.originId()).name(),\r\n\t\t\t_tao.datHash(),\r\n\t\t\t_tao.database(),\r\n\t\t\t_tao.keyValue(),\r\n\t\t\t_tao.contentId(),\r\n\t\t\t_tao.typeId()\r\n\t\t);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Get total TAOs count\r\n\t * @return total TAOs count\r\n\t */\r\n\tfunction getTotalTAOsCount() public view returns (uint256) {\r\n\t\treturn taos.length;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Get list of TAO IDs\r\n\t * @param _from The starting index\r\n\t * @param _to The ending index\r\n\t * @return list of TAO IDs\r\n\t */\r\n\tfunction getTAOIds(uint256 _from, uint256 _to) public view returns (address[]) {\r\n\t\trequire (_from >= 0 && _to >= _from && taos.length > _to);\r\n\r\n\t\taddress[] memory _taos = new address[](_to.sub(_from).add(1));\r\n\t\tfor (uint256 i = _from; i <= _to; i++) {\r\n\t\t\t_taos[i.sub(_from)] = taos[i];\r\n\t\t}\r\n\t\treturn _taos;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Check whether or not the signature is valid\r\n\t * @param _data The signed string data\r\n\t * @param _nonce The signed uint256 nonce (should be TAO's current nonce + 1)\r\n\t * @param _validateAddress The ETH address to be validated (optional)\r\n\t * @param _name The Name of the TAO\r\n\t * @param _signatureV The V part of the signature\r\n\t * @param _signatureR The R part of the signature\r\n\t * @param _signatureS The S part of the signature\r\n\t * @return true if valid. false otherwise\r\n\t * @return The name of the Name that created the signature\r\n\t * @return The Position of the Name that created the signature.\r\n\t *\t\t\t0 == unknown. 1 == Advocate. 2 == Listener. 3 == Speaker\r\n\t */\r\n\tfunction validateTAOSignature(\r\n\t\tstring _data,\r\n\t\tuint256 _nonce,\r\n\t\taddress _validateAddress,\r\n\t\tstring _name,\r\n\t\tuint8 _signatureV,\r\n\t\tbytes32 _signatureR,\r\n\t\tbytes32 _signatureS\r\n\t) public isTAO(_getTAOIdByName(_name)) view returns (bool, string, uint256) {\r\n\t\taddress _signatureAddress = AOLibrary.getValidateSignatureAddress(address(this), _data, _nonce, _signatureV, _signatureR, _signatureS);\r\n\t\tif (_isTAOSignatureAddressValid(_validateAddress, _signatureAddress, _getTAOIdByName(_name), _nonce)) {\r\n\t\t\treturn (true, Name(_nameFactory.ethAddressToNameId(_signatureAddress)).name(), _nameTAOPosition.determinePosition(_signatureAddress, _getTAOIdByName(_name)));\r\n\t\t} else {\r\n\t\t\treturn (false, \"\", 0);\r\n\t\t}\r\n\t}\r\n\r\n\t/***** INTERNAL METHOD *****/\r\n\t/**\r\n\t * @dev Check whether or not the address recovered from the signature is valid\r\n\t * @param _validateAddress The ETH address to be validated (optional)\r\n\t * @param _signatureAddress The address recovered from the signature\r\n\t * @param _taoId The ID of the TAO\r\n\t * @param _nonce The signed uint256 nonce\r\n\t * @return true if valid. false otherwise\r\n\t */\r\n\tfunction _isTAOSignatureAddressValid(\r\n\t\taddress _validateAddress,\r\n\t\taddress _signatureAddress,\r\n\t\taddress _taoId,\r\n\t\tuint256 _nonce\r\n\t) internal view returns (bool) {\r\n\t\tif (_validateAddress != address(0)) {\r\n\t\t\treturn (_nonce == nonces[_taoId].add(1) &&\r\n\t\t\t\t_signatureAddress == _validateAddress &&\r\n\t\t\t\t_nameTAOPosition.senderIsPosition(_validateAddress, _taoId)\r\n\t\t\t);\r\n\t\t} else {\r\n\t\t\treturn (\r\n\t\t\t\t_nonce == nonces[_taoId].add(1) &&\r\n\t\t\t\t_nameTAOPosition.senderIsPosition(_signatureAddress, _taoId)\r\n\t\t\t);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Internal function to get the TAO Id by name\r\n\t * @param _name The name of the TAO\r\n\t * @return the TAO ID\r\n\t */\r\n\tfunction _getTAOIdByName(string _name) internal view returns (address) {\r\n\t\treturn _nameTAOLookup.getAddressByName(_name);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Get setting variables\r\n\t * @return createChildTAOMinLogos The minimum required Logos to create a TAO\r\n\t */\r\n\tfunction _getSettingVariables() internal view returns (uint256) {\r\n\t\t(uint256 createChildTAOMinLogos,,,,) = _aoSetting.getSettingValuesByTAOName(settingTAOId, 'createChildTAOMinLogos');\r\n\t\treturn createChildTAOMinLogos;\r\n\t}\r\n}\r\n\r\n\r\n/**\r\n * @title NameTAOPosition\r\n */\r\ncontract NameTAOPosition is TheAO {\r\n\taddress public nameFactoryAddress;\r\n\taddress public taoFactoryAddress;\r\n\r\n\tNameFactory internal _nameFactory;\r\n\tTAOFactory internal _taoFactory;\r\n\r\n\tstruct Position {\r\n\t\taddress advocateId;\r\n\t\taddress listenerId;\r\n\t\taddress speakerId;\r\n\t\tbool created;\r\n\t}\r\n\r\n\tmapping (address => Position) internal positions;\r\n\r\n\t// Event to be broadcasted to public when current Advocate of TAO sets New Advocate\r\n\tevent SetAdvocate(address indexed taoId, address oldAdvocateId, address newAdvocateId, uint256 nonce);\r\n\r\n\t// Event to be broadcasted to public when current Advocate of Name/TAO sets New Listener\r\n\tevent SetListener(address indexed taoId, address oldListenerId, address newListenerId, uint256 nonce);\r\n\r\n\t// Event to be broadcasted to public when current Advocate of Name/TAO sets New Speaker\r\n\tevent SetSpeaker(address indexed taoId, address oldSpeakerId, address newSpeakerId, uint256 nonce);\r\n\r\n\t/**\r\n\t * @dev Constructor function\r\n\t */\r\n\tconstructor(address _nameFactoryAddress) public {\r\n\t\tnameFactoryAddress = _nameFactoryAddress;\r\n\t\t_nameFactory = NameFactory(_nameFactoryAddress);\r\n\t\tnameTAOPositionAddress = address(this);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Checks if the calling contract address is The AO\r\n\t *\t\tOR\r\n\t *\t\tIf The AO is set to a Name/TAO, then check if calling address is the Advocate\r\n\t */\r\n\tmodifier onlyTheAO {\r\n\t\trequire (AOLibrary.isTheAO(msg.sender, theAO, nameTAOPositionAddress));\r\n\t\t_;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Check if calling address is Factory\r\n\t */\r\n\tmodifier onlyFactory {\r\n\t\trequire (msg.sender == nameFactoryAddress || msg.sender == taoFactoryAddress);\r\n\t\t_;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Check if `_taoId` is a TAO\r\n\t */\r\n\tmodifier isTAO(address _taoId) {\r\n\t\trequire (AOLibrary.isTAO(_taoId));\r\n\t\t_;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Check if `_nameId` is a Name\r\n\t */\r\n\tmodifier isName(address _nameId) {\r\n\t\trequire (AOLibrary.isName(_nameId));\r\n\t\t_;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Check if `_id` is a Name or a TAO\r\n\t */\r\n\tmodifier isNameOrTAO(address _id) {\r\n\t\trequire (AOLibrary.isName(_id) || AOLibrary.isTAO(_id));\r\n\t\t_;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Check is msg.sender address is a Name\r\n\t */\r\n\t modifier senderIsName() {\r\n\t\trequire (_nameFactory.ethAddressToNameId(msg.sender) != address(0));\r\n\t\t_;\r\n\t }\r\n\r\n\t/**\r\n\t * @dev Check if msg.sender is the current advocate of a Name/TAO ID\r\n\t */\r\n\tmodifier onlyAdvocate(address _id) {\r\n\t\trequire (senderIsAdvocate(msg.sender, _id));\r\n\t\t_;\r\n\t}\r\n\r\n\t/***** The AO ONLY METHODS *****/\r\n\t/**\r\n\t * @dev Transfer ownership of The AO to new address\r\n\t * @param _theAO The new address to be transferred\r\n\t */\r\n\tfunction transferOwnership(address _theAO) public onlyTheAO {\r\n\t\trequire (_theAO != address(0));\r\n\t\ttheAO = _theAO;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Whitelist `_account` address to transact on behalf of others\r\n\t * @param _account The address to whitelist\r\n\t * @param _whitelist Either to whitelist or not\r\n\t */\r\n\tfunction setWhitelist(address _account, bool _whitelist) public onlyTheAO {\r\n\t\trequire (_account != address(0));\r\n\t\twhitelist[_account] = _whitelist;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev The AO set the taoFactoryAddress Address\r\n\t * @param _taoFactoryAddress The address of TAOFactory\r\n\t */\r\n\tfunction setTAOFactoryAddress(address _taoFactoryAddress) public onlyTheAO {\r\n\t\trequire (_taoFactoryAddress != address(0));\r\n\t\ttaoFactoryAddress = _taoFactoryAddress;\r\n\t\t_taoFactory = TAOFactory(_taoFactoryAddress);\r\n\t}\r\n\r\n\t/***** PUBLIC METHODS *****/\r\n\t/**\r\n\t * @dev Check whether or not a Name/TAO ID exist in the list\r\n\t * @param _id The ID to be checked\r\n\t * @return true if yes, false otherwise\r\n\t */\r\n\tfunction isExist(address _id) public view returns (bool) {\r\n\t\treturn positions[_id].created;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Check whether or not eth address is advocate of _id\r\n\t * @param _sender The eth address to check\r\n\t * @param _id The ID to be checked\r\n\t * @return true if yes, false otherwise\r\n\t */\r\n\tfunction senderIsAdvocate(address _sender, address _id) public view returns (bool) {\r\n\t\treturn (positions[_id].created && positions[_id].advocateId == _nameFactory.ethAddressToNameId(_sender));\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Check whether or not eth address is either Advocate/Listener/Speaker of _id\r\n\t * @param _sender The eth address to check\r\n\t * @param _id The ID to be checked\r\n\t * @return true if yes, false otherwise\r\n\t */\r\n\tfunction senderIsPosition(address _sender, address _id) public view returns (bool) {\r\n\t\taddress _nameId = _nameFactory.ethAddressToNameId(_sender);\r\n\t\tif (_nameId == address(0)) {\r\n\t\t\treturn false;\r\n\t\t} else {\r\n\t\t\treturn (positions[_id].created &&\r\n\t\t\t\t(positions[_id].advocateId == _nameId ||\r\n\t\t\t\t positions[_id].listenerId == _nameId ||\r\n\t\t\t\t positions[_id].speakerId == _nameId\r\n\t\t\t\t)\r\n\t\t\t);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Check whether or not _nameId is advocate of _id\r\n\t * @param _nameId The name ID to be checked\r\n\t * @param _id The ID to be checked\r\n\t * @return true if yes, false otherwise\r\n\t */\r\n\tfunction nameIsAdvocate(address _nameId, address _id) public view returns (bool) {\r\n\t\treturn (positions[_id].created && positions[_id].advocateId == _nameId);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Determine whether or not `_sender` is Advocate/Listener/Speaker of the Name/TAO\r\n\t * @param _sender The ETH address that to check\r\n\t * @param _id The ID of the Name/TAO\r\n\t * @return 1 if Advocate. 2 if Listener. 3 if Speaker\r\n\t */\r\n\tfunction determinePosition(address _sender, address _id) public view returns (uint256) {\r\n\t\trequire (senderIsPosition(_sender, _id));\r\n\t\tPosition memory _position = positions[_id];\r\n\t\taddress _nameId = _nameFactory.ethAddressToNameId(_sender);\r\n\t\tif (_nameId == _position.advocateId) {\r\n\t\t\treturn 1;\r\n\t\t} else if (_nameId == _position.listenerId) {\r\n\t\t\treturn 2;\r\n\t\t} else {\r\n\t\t\treturn 3;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Add Position for a Name/TAO\r\n\t * @param _id The ID of the Name/TAO\r\n\t * @param _advocateId The Advocate ID of the Name/TAO\r\n\t * @param _listenerId The Listener ID of the Name/TAO\r\n\t * @param _speakerId The Speaker ID of the Name/TAO\r\n\t * @return true on success\r\n\t */\r\n\tfunction add(address _id, address _advocateId, address _listenerId, address _speakerId)\r\n\t\tpublic\r\n\t\tisNameOrTAO(_id)\r\n\t\tisName(_advocateId)\r\n\t\tisNameOrTAO(_listenerId)\r\n\t\tisNameOrTAO(_speakerId)\r\n\t\tonlyFactory returns (bool) {\r\n\t\trequire (!isExist(_id));\r\n\r\n\t\tPosition storage _position = positions[_id];\r\n\t\t_position.advocateId = _advocateId;\r\n\t\t_position.listenerId = _listenerId;\r\n\t\t_position.speakerId = _speakerId;\r\n\t\t_position.created = true;\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Get Name/TAO's Position info\r\n\t * @param _id The ID of the Name/TAO\r\n\t * @return the Advocate ID of Name/TAO\r\n\t * @return the Listener ID of Name/TAO\r\n\t * @return the Speaker ID of Name/TAO\r\n\t */\r\n\tfunction getPositionById(address _id) public view returns (address, address, address) {\r\n\t\trequire (isExist(_id));\r\n\t\tPosition memory _position = positions[_id];\r\n\t\treturn (\r\n\t\t\t_position.advocateId,\r\n\t\t\t_position.listenerId,\r\n\t\t\t_position.speakerId\r\n\t\t);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Get Name/TAO's Advocate\r\n\t * @param _id The ID of the Name/TAO\r\n\t * @return the Advocate ID of Name/TAO\r\n\t */\r\n\tfunction getAdvocate(address _id) public view returns (address) {\r\n\t\trequire (isExist(_id));\r\n\t\tPosition memory _position = positions[_id];\r\n\t\treturn _position.advocateId;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Get Name/TAO's Listener\r\n\t * @param _id The ID of the Name/TAO\r\n\t * @return the Listener ID of Name/TAO\r\n\t */\r\n\tfunction getListener(address _id) public view returns (address) {\r\n\t\trequire (isExist(_id));\r\n\t\tPosition memory _position = positions[_id];\r\n\t\treturn _position.listenerId;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Get Name/TAO's Speaker\r\n\t * @param _id The ID of the Name/TAO\r\n\t * @return the Speaker ID of Name/TAO\r\n\t */\r\n\tfunction getSpeaker(address _id) public view returns (address) {\r\n\t\trequire (isExist(_id));\r\n\t\tPosition memory _position = positions[_id];\r\n\t\treturn _position.speakerId;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Set Advocate for a TAO\r\n\t * @param _taoId The ID of the TAO\r\n\t * @param _newAdvocateId The new advocate ID to be set\r\n\t */\r\n\tfunction setAdvocate(address _taoId, address _newAdvocateId)\r\n\t\tpublic\r\n\t\tisTAO(_taoId)\r\n\t\tisName(_newAdvocateId)\r\n\t\tsenderIsName()\r\n\t\tonlyAdvocate(_taoId) {\r\n\r\n\t\tPosition storage _position = positions[_taoId];\r\n\t\taddress _currentAdvocateId = _position.advocateId;\r\n\t\t_position.advocateId = _newAdvocateId;\r\n\r\n\t\tuint256 _nonce = _taoFactory.incrementNonce(_taoId);\r\n\t\trequire (_nonce > 0);\r\n\t\temit SetAdvocate(_taoId, _currentAdvocateId, _position.advocateId, _nonce);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Set Listener for a Name/TAO\r\n\t * @param _id The ID of the Name/TAO\r\n\t * @param _newListenerId The new listener ID to be set\r\n\t */\r\n\tfunction setListener(address _id, address _newListenerId)\r\n\t\tpublic\r\n\t\tisNameOrTAO(_id)\r\n\t\tisNameOrTAO(_newListenerId)\r\n\t\tsenderIsName()\r\n\t\tonlyAdvocate(_id) {\r\n\r\n\t\t// If _id is a Name, then new Listener can only be a Name\r\n\t\t// If _id is a TAO, then new Listener can be a TAO/Name\r\n\t\tbool _isName = false;\r\n\t\tif (AOLibrary.isName(_id)) {\r\n\t\t\t_isName = true;\r\n\t\t\trequire (AOLibrary.isName(_newListenerId));\r\n\t\t}\r\n\r\n\t\tPosition storage _position = positions[_id];\r\n\t\taddress _currentListenerId = _position.listenerId;\r\n\t\t_position.listenerId = _newListenerId;\r\n\r\n\t\tif (_isName) {\r\n\t\t\tuint256 _nonce = _nameFactory.incrementNonce(_id);\r\n\t\t} else {\r\n\t\t\t_nonce = _taoFactory.incrementNonce(_id);\r\n\t\t}\r\n\t\temit SetListener(_id, _currentListenerId, _position.listenerId, _nonce);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Set Speaker for a Name/TAO\r\n\t * @param _id The ID of the Name/TAO\r\n\t * @param _newSpeakerId The new speaker ID to be set\r\n\t */\r\n\tfunction setSpeaker(address _id, address _newSpeakerId)\r\n\t\tpublic\r\n\t\tisNameOrTAO(_id)\r\n\t\tisNameOrTAO(_newSpeakerId)\r\n\t\tsenderIsName()\r\n\t\tonlyAdvocate(_id) {\r\n\r\n\t\t// If _id is a Name, then new Speaker can only be a Name\r\n\t\t// If _id is a TAO, then new Speaker can be a TAO/Name\r\n\t\tbool _isName = false;\r\n\t\tif (AOLibrary.isName(_id)) {\r\n\t\t\t_isName = true;\r\n\t\t\trequire (AOLibrary.isName(_newSpeakerId));\r\n\t\t}\r\n\r\n\t\tPosition storage _position = positions[_id];\r\n\t\taddress _currentSpeakerId = _position.speakerId;\r\n\t\t_position.speakerId = _newSpeakerId;\r\n\r\n\t\tif (_isName) {\r\n\t\t\tuint256 _nonce = _nameFactory.incrementNonce(_id);\r\n\t\t} else {\r\n\t\t\t_nonce = _taoFactory.incrementNonce(_id);\r\n\t\t}\r\n\t\temit SetSpeaker(_id, _currentSpeakerId, _position.speakerId, _nonce);\r\n\t}\r\n}\r\n\r\n\r\n/**\r\n * @title AOSetting\r\n *\r\n * This contract stores all AO setting variables\r\n */\r\ncontract AOSetting {\r\n\taddress public aoSettingAttributeAddress;\r\n\taddress public aoUintSettingAddress;\r\n\taddress public aoBoolSettingAddress;\r\n\taddress public aoAddressSettingAddress;\r\n\taddress public aoBytesSettingAddress;\r\n\taddress public aoStringSettingAddress;\r\n\r\n\tNameFactory internal _nameFactory;\r\n\tNameTAOPosition internal _nameTAOPosition;\r\n\tAOSettingAttribute internal _aoSettingAttribute;\r\n\tAOUintSetting internal _aoUintSetting;\r\n\tAOBoolSetting internal _aoBoolSetting;\r\n\tAOAddressSetting internal _aoAddressSetting;\r\n\tAOBytesSetting internal _aoBytesSetting;\r\n\tAOStringSetting internal _aoStringSetting;\r\n\r\n\tuint256 public totalSetting;\r\n\r\n\t/**\r\n\t * Mapping from associatedTAOId's setting name to Setting ID.\r\n\t *\r\n\t * Instead of concatenating the associatedTAOID and setting name to create a unique ID for lookup,\r\n\t * use nested mapping to achieve the same result.\r\n\t *\r\n\t * The setting's name needs to be converted to bytes32 since solidity does not support mapping by string.\r\n\t */\r\n\tmapping (address => mapping (bytes32 => uint256)) internal nameSettingLookup;\r\n\r\n\t// Mapping from updateHashKey to it's settingId\r\n\tmapping (bytes32 => uint256) public updateHashLookup;\r\n\r\n\t// Event to be broadcasted to public when a setting is created and waiting for approval\r\n\tevent SettingCreation(uint256 indexed settingId, address indexed creatorNameId, address creatorTAOId, address associatedTAOId, string settingName, uint8 settingType, bytes32 associatedTAOSettingId, bytes32 creatorTAOSettingId);\r\n\r\n\t// Event to be broadcasted to public when setting creation is approved/rejected by the advocate of associatedTAOId\r\n\tevent ApproveSettingCreation(uint256 indexed settingId, address associatedTAOId, address associatedTAOAdvocate, bool approved);\r\n\t// Event to be broadcasted to public when setting creation is finalized by the advocate of creatorTAOId\r\n\tevent FinalizeSettingCreation(uint256 indexed settingId, address creatorTAOId, address creatorTAOAdvocate);\r\n\r\n\t// Event to be broadcasted to public when a proposed update for a setting is created\r\n\tevent SettingUpdate(uint256 indexed settingId, address indexed updateAdvocateNameId, address proposalTAOId);\r\n\r\n\t// Event to be broadcasted to public when setting update is approved/rejected by the advocate of proposalTAOId\r\n\tevent ApproveSettingUpdate(uint256 indexed settingId, address proposalTAOId, address proposalTAOAdvocate, bool approved);\r\n\r\n\t// Event to be broadcasted to public when setting update is finalized by the advocate of associatedTAOId\r\n\tevent FinalizeSettingUpdate(uint256 indexed settingId, address associatedTAOId, address associatedTAOAdvocate);\r\n\r\n\t// Event to be broadcasted to public when a setting deprecation is created and waiting for approval\r\n\tevent SettingDeprecation(uint256 indexed settingId, address indexed creatorNameId, address creatorTAOId, address associatedTAOId, uint256 newSettingId, address newSettingContractAddress, bytes32 associatedTAOSettingDeprecationId, bytes32 creatorTAOSettingDeprecationId);\r\n\r\n\t// Event to be broadcasted to public when setting deprecation is approved/rejected by the advocate of associatedTAOId\r\n\tevent ApproveSettingDeprecation(uint256 indexed settingId, address associatedTAOId, address associatedTAOAdvocate, bool approved);\r\n\r\n\t// Event to be broadcasted to public when setting deprecation is finalized by the advocate of creatorTAOId\r\n\tevent FinalizeSettingDeprecation(uint256 indexed settingId, address creatorTAOId, address creatorTAOAdvocate);\r\n\r\n\t/**\r\n\t * @dev Constructor function\r\n\t */\r\n\tconstructor(address _nameFactoryAddress,\r\n\t\taddress _nameTAOPositionAddress,\r\n\t\taddress _aoSettingAttributeAddress,\r\n\t\taddress _aoUintSettingAddress,\r\n\t\taddress _aoBoolSettingAddress,\r\n\t\taddress _aoAddressSettingAddress,\r\n\t\taddress _aoBytesSettingAddress,\r\n\t\taddress _aoStringSettingAddress) public {\r\n\t\taoSettingAttributeAddress = _aoSettingAttributeAddress;\r\n\t\taoUintSettingAddress = _aoUintSettingAddress;\r\n\t\taoBoolSettingAddress = _aoBoolSettingAddress;\r\n\t\taoAddressSettingAddress = _aoAddressSettingAddress;\r\n\t\taoBytesSettingAddress = _aoBytesSettingAddress;\r\n\t\taoStringSettingAddress = _aoStringSettingAddress;\r\n\r\n\t\t_nameFactory = NameFactory(_nameFactoryAddress);\r\n\t\t_nameTAOPosition = NameTAOPosition(_nameTAOPositionAddress);\r\n\t\t_aoSettingAttribute = AOSettingAttribute(_aoSettingAttributeAddress);\r\n\t\t_aoUintSetting = AOUintSetting(_aoUintSettingAddress);\r\n\t\t_aoBoolSetting = AOBoolSetting(_aoBoolSettingAddress);\r\n\t\t_aoAddressSetting = AOAddressSetting(_aoAddressSettingAddress);\r\n\t\t_aoBytesSetting = AOBytesSetting(_aoBytesSettingAddress);\r\n\t\t_aoStringSetting = AOStringSetting(_aoStringSettingAddress);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Check if `_taoId` is a TAO\r\n\t */\r\n\tmodifier isTAO(address _taoId) {\r\n\t\trequire (AOLibrary.isTAO(_taoId));\r\n\t\t_;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Check if `_settingName` of `_associatedTAOId` is taken\r\n\t */\r\n\tmodifier settingNameNotTaken(string _settingName, address _associatedTAOId) {\r\n\t\trequire (settingNameExist(_settingName, _associatedTAOId) == false);\r\n\t\t_;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Check if msg.sender is the current advocate of Name ID\r\n\t */\r\n\tmodifier onlyAdvocate(address _id) {\r\n\t\trequire (_nameTAOPosition.senderIsAdvocate(msg.sender, _id));\r\n\t\t_;\r\n\t}\r\n\r\n\t/***** Public Methods *****/\r\n\t/**\r\n\t * @dev Check whether or not a setting name of an associatedTAOId exist\r\n\t * @param _settingName The human-readable name of the setting\r\n\t * @param _associatedTAOId The taoId that the setting affects\r\n\t * @return true if yes. false otherwise\r\n\t */\r\n\tfunction settingNameExist(string _settingName, address _associatedTAOId) public view returns (bool) {\r\n\t\treturn (nameSettingLookup[_associatedTAOId][keccak256(abi.encodePacked(this, _settingName))] > 0);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Advocate of _creatorTAOId adds a uint setting\r\n\t * @param _settingName The human-readable name of the setting\r\n\t * @param _value The uint256 value of the setting\r\n\t * @param _creatorTAOId The taoId that created the setting\r\n\t * @param _associatedTAOId The taoId that the setting affects\r\n\t * @param _extraData Catch-all string value to be stored if exist\r\n\t */\r\n\tfunction addUintSetting(string _settingName, uint256 _value, address _creatorTAOId, address _associatedTAOId, string _extraData) public isTAO(_creatorTAOId) isTAO(_associatedTAOId) settingNameNotTaken(_settingName, _associatedTAOId) onlyAdvocate(_creatorTAOId) {\r\n\t\t// Update global variables\r\n\t\ttotalSetting++;\r\n\r\n\t\t// Store the value as pending value\r\n\t\t_aoUintSetting.setPendingValue(totalSetting, _value);\r\n\r\n\t\t// Store setting creation data\r\n\t\t_storeSettingCreation(_nameFactory.ethAddressToNameId(msg.sender), 1, _settingName, _creatorTAOId, _associatedTAOId, _extraData);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Advocate of _creatorTAOId adds a bool setting\r\n\t * @param _settingName The human-readable name of the setting\r\n\t * @param _value The bool value of the setting\r\n\t * @param _creatorTAOId The taoId that created the setting\r\n\t * @param _associatedTAOId The taoId that the setting affects\r\n\t * @param _extraData Catch-all string value to be stored if exist\r\n\t */\r\n\tfunction addBoolSetting(string _settingName, bool _value, address _creatorTAOId, address _associatedTAOId, string _extraData) public isTAO(_creatorTAOId) isTAO(_associatedTAOId) settingNameNotTaken(_settingName, _associatedTAOId) onlyAdvocate(_creatorTAOId) {\r\n\t\t// Update global variables\r\n\t\ttotalSetting++;\r\n\r\n\t\t// Store the value as pending value\r\n\t\t_aoBoolSetting.setPendingValue(totalSetting, _value);\r\n\r\n\t\t// Store setting creation data\r\n\t\t_storeSettingCreation(_nameFactory.ethAddressToNameId(msg.sender), 2, _settingName, _creatorTAOId, _associatedTAOId, _extraData);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Advocate of _creatorTAOId adds an address setting\r\n\t * @param _settingName The human-readable name of the setting\r\n\t * @param _value The address value of the setting\r\n\t * @param _creatorTAOId The taoId that created the setting\r\n\t * @param _associatedTAOId The taoId that the setting affects\r\n\t * @param _extraData Catch-all string value to be stored if exist\r\n\t */\r\n\tfunction addAddressSetting(string _settingName, address _value, address _creatorTAOId, address _associatedTAOId, string _extraData) public isTAO(_creatorTAOId) isTAO(_associatedTAOId) settingNameNotTaken(_settingName, _associatedTAOId) onlyAdvocate(_creatorTAOId) {\r\n\t\t// Update global variables\r\n\t\ttotalSetting++;\r\n\r\n\t\t// Store the value as pending value\r\n\t\t_aoAddressSetting.setPendingValue(totalSetting, _value);\r\n\r\n\t\t// Store setting creation data\r\n\t\t_storeSettingCreation(_nameFactory.ethAddressToNameId(msg.sender), 3, _settingName, _creatorTAOId, _associatedTAOId, _extraData);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Advocate of _creatorTAOId adds a bytes32 setting\r\n\t * @param _settingName The human-readable name of the setting\r\n\t * @param _value The bytes32 value of the setting\r\n\t * @param _creatorTAOId The taoId that created the setting\r\n\t * @param _associatedTAOId The taoId that the setting affects\r\n\t * @param _extraData Catch-all string value to be stored if exist\r\n\t */\r\n\tfunction addBytesSetting(string _settingName, bytes32 _value, address _creatorTAOId, address _associatedTAOId, string _extraData) public isTAO(_creatorTAOId) isTAO(_associatedTAOId) settingNameNotTaken(_settingName, _associatedTAOId) onlyAdvocate(_creatorTAOId) {\r\n\t\t// Update global variables\r\n\t\ttotalSetting++;\r\n\r\n\t\t// Store the value as pending value\r\n\t\t_aoBytesSetting.setPendingValue(totalSetting, _value);\r\n\r\n\t\t// Store setting creation data\r\n\t\t_storeSettingCreation(_nameFactory.ethAddressToNameId(msg.sender), 4, _settingName, _creatorTAOId, _associatedTAOId, _extraData);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Advocate of _creatorTAOId adds a string setting\r\n\t * @param _settingName The human-readable name of the setting\r\n\t * @param _value The string value of the setting\r\n\t * @param _creatorTAOId The taoId that created the setting\r\n\t * @param _associatedTAOId The taoId that the setting affects\r\n\t * @param _extraData Catch-all string value to be stored if exist\r\n\t */\r\n\tfunction addStringSetting(string _settingName, string _value, address _creatorTAOId, address _associatedTAOId, string _extraData) public isTAO(_creatorTAOId) isTAO(_associatedTAOId) settingNameNotTaken(_settingName, _associatedTAOId) onlyAdvocate(_creatorTAOId) {\r\n\t\t// Update global variables\r\n\t\ttotalSetting++;\r\n\r\n\t\t// Store the value as pending value\r\n\t\t_aoStringSetting.setPendingValue(totalSetting, _value);\r\n\r\n\t\t// Store setting creation data\r\n\t\t_storeSettingCreation(_nameFactory.ethAddressToNameId(msg.sender), 5, _settingName, _creatorTAOId, _associatedTAOId, _extraData);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Advocate of Setting's _associatedTAOId approves setting creation\r\n\t * @param _settingId The ID of the setting to approve\r\n\t * @param _approved Whether to approve or reject\r\n\t */\r\n\tfunction approveSettingCreation(uint256 _settingId, bool _approved) public {\r\n\t\taddress _associatedTAOAdvocate = _nameFactory.ethAddressToNameId(msg.sender);\r\n\t\trequire (_aoSettingAttribute.approveAdd(_settingId, _associatedTAOAdvocate, _approved));\r\n\r\n\t\t(,,,address _associatedTAOId, string memory _settingName,,,,,) = _aoSettingAttribute.getSettingData(_settingId);\r\n\t\tif (!_approved) {\r\n\t\t\t// Clear the settingName from nameSettingLookup so it can be added again in the future\r\n\t\t\tdelete nameSettingLookup[_associatedTAOId][keccak256(abi.encodePacked(this, _settingName))];\r\n\t\t}\r\n\t\temit ApproveSettingCreation(_settingId, _associatedTAOId, _associatedTAOAdvocate, _approved);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Advocate of Setting's _creatorTAOId finalizes the setting creation once the setting is approved\r\n\t * @param _settingId The ID of the setting to be finalized\r\n\t */\r\n\tfunction finalizeSettingCreation(uint256 _settingId) public {\r\n\t\taddress _creatorTAOAdvocate = _nameFactory.ethAddressToNameId(msg.sender);\r\n\t\trequire (_aoSettingAttribute.finalizeAdd(_settingId, _creatorTAOAdvocate));\r\n\r\n\t\t(,,address _creatorTAOId,,, uint8 _settingType,,,,) = _aoSettingAttribute.getSettingData(_settingId);\r\n\r\n\t\t_movePendingToSetting(_settingId, _settingType);\r\n\r\n\t\temit FinalizeSettingCreation(_settingId, _creatorTAOId, _creatorTAOAdvocate);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Advocate of Setting's _associatedTAOId submits a uint256 setting update after an update has been proposed\r\n\t * @param _settingId The ID of the setting to be updated\r\n\t * @param _newValue The new uint256 value for this setting\r\n\t * @param _proposalTAOId The child of the associatedTAOId with the update Logos\r\n\t * @param _updateSignature A signature of the proposalTAOId and update value by associatedTAOId's advocate's name address\r\n\t * @param _extraData Catch-all string value to be stored if exist\r\n\t */\r\n\tfunction updateUintSetting(uint256 _settingId, uint256 _newValue, address _proposalTAOId, string _updateSignature, string _extraData) public isTAO(_proposalTAOId) {\r\n\t\t// Store the setting state data\r\n\t\trequire (_aoSettingAttribute.update(_settingId, 1, _nameFactory.ethAddressToNameId(msg.sender), _proposalTAOId, _updateSignature, _extraData));\r\n\r\n\t\t// Store the value as pending value\r\n\t\t_aoUintSetting.setPendingValue(_settingId, _newValue);\r\n\r\n\t\t// Store the update hash key lookup\r\n\t\tupdateHashLookup[keccak256(abi.encodePacked(this, _proposalTAOId, _aoUintSetting.settingValue(_settingId), _newValue, _extraData, _settingId))] = _settingId;\r\n\r\n\t\temit SettingUpdate(_settingId, _nameFactory.ethAddressToNameId(msg.sender), _proposalTAOId);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Advocate of Setting's _associatedTAOId submits a bool setting update after an update has been proposed\r\n\t * @param _settingId The ID of the setting to be updated\r\n\t * @param _newValue The new bool value for this setting\r\n\t * @param _proposalTAOId The child of the associatedTAOId with the update Logos\r\n\t * @param _updateSignature A signature of the proposalTAOId and update value by associatedTAOId's advocate's name address\r\n\t * @param _extraData Catch-all string value to be stored if exist\r\n\t */\r\n\tfunction updateBoolSetting(uint256 _settingId, bool _newValue, address _proposalTAOId, string _updateSignature, string _extraData) public isTAO(_proposalTAOId) {\r\n\t\t// Store the setting state data\r\n\t\trequire (_aoSettingAttribute.update(_settingId, 2, _nameFactory.ethAddressToNameId(msg.sender), _proposalTAOId, _updateSignature, _extraData));\r\n\r\n\t\t// Store the value as pending value\r\n\t\t_aoBoolSetting.setPendingValue(_settingId, _newValue);\r\n\r\n\t\t// Store the update hash key lookup\r\n\t\tupdateHashLookup[keccak256(abi.encodePacked(this, _proposalTAOId, _aoBoolSetting.settingValue(_settingId), _newValue, _extraData, _settingId))] = _settingId;\r\n\r\n\t\temit SettingUpdate(_settingId, _nameFactory.ethAddressToNameId(msg.sender), _proposalTAOId);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Advocate of Setting's _associatedTAOId submits an address setting update after an update has been proposed\r\n\t * @param _settingId The ID of the setting to be updated\r\n\t * @param _newValue The new address value for this setting\r\n\t * @param _proposalTAOId The child of the associatedTAOId with the update Logos\r\n\t * @param _updateSignature A signature of the proposalTAOId and update value by associatedTAOId's advocate's name address\r\n\t * @param _extraData Catch-all string value to be stored if exist\r\n\t */\r\n\tfunction updateAddressSetting(uint256 _settingId, address _newValue, address _proposalTAOId, string _updateSignature, string _extraData) public isTAO(_proposalTAOId) {\r\n\t\t// Store the setting state data\r\n\t\trequire (_aoSettingAttribute.update(_settingId, 3, _nameFactory.ethAddressToNameId(msg.sender), _proposalTAOId, _updateSignature, _extraData));\r\n\r\n\t\t// Store the value as pending value\r\n\t\t_aoAddressSetting.setPendingValue(_settingId, _newValue);\r\n\r\n\t\t// Store the update hash key lookup\r\n\t\tupdateHashLookup[keccak256(abi.encodePacked(this, _proposalTAOId, _aoAddressSetting.settingValue(_settingId), _newValue, _extraData, _settingId))] = _settingId;\r\n\r\n\t\temit SettingUpdate(_settingId, _nameFactory.ethAddressToNameId(msg.sender), _proposalTAOId);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Advocate of Setting's _associatedTAOId submits a bytes32 setting update after an update has been proposed\r\n\t * @param _settingId The ID of the setting to be updated\r\n\t * @param _newValue The new bytes32 value for this setting\r\n\t * @param _proposalTAOId The child of the associatedTAOId with the update Logos\r\n\t * @param _updateSignature A signature of the proposalTAOId and update value by associatedTAOId's advocate's name address\r\n\t * @param _extraData Catch-all string value to be stored if exist\r\n\t */\r\n\tfunction updateBytesSetting(uint256 _settingId, bytes32 _newValue, address _proposalTAOId, string _updateSignature, string _extraData) public isTAO(_proposalTAOId) {\r\n\t\t// Store the setting state data\r\n\t\trequire (_aoSettingAttribute.update(_settingId, 4, _nameFactory.ethAddressToNameId(msg.sender), _proposalTAOId, _updateSignature, _extraData));\r\n\r\n\t\t// Store the value as pending value\r\n\t\t_aoBytesSetting.setPendingValue(_settingId, _newValue);\r\n\r\n\t\t// Store the update hash key lookup\r\n\t\tupdateHashLookup[keccak256(abi.encodePacked(this, _proposalTAOId, _aoBytesSetting.settingValue(_settingId), _newValue, _extraData, _settingId))] = _settingId;\r\n\r\n\t\temit SettingUpdate(_settingId, _nameFactory.ethAddressToNameId(msg.sender), _proposalTAOId);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Advocate of Setting's _associatedTAOId submits a string setting update after an update has been proposed\r\n\t * @param _settingId The ID of the setting to be updated\r\n\t * @param _newValue The new string value for this setting\r\n\t * @param _proposalTAOId The child of the associatedTAOId with the update Logos\r\n\t * @param _updateSignature A signature of the proposalTAOId and update value by associatedTAOId's advocate's name address\r\n\t * @param _extraData Catch-all string value to be stored if exist\r\n\t */\r\n\tfunction updateStringSetting(uint256 _settingId, string _newValue, address _proposalTAOId, string _updateSignature, string _extraData) public isTAO(_proposalTAOId) {\r\n\t\t// Store the setting state data\r\n\t\trequire (_aoSettingAttribute.update(_settingId, 5, _nameFactory.ethAddressToNameId(msg.sender), _proposalTAOId, _updateSignature, _extraData));\r\n\r\n\t\t// Store the value as pending value\r\n\t\t_aoStringSetting.setPendingValue(_settingId, _newValue);\r\n\r\n\t\t// Store the update hash key lookup\r\n\t\tupdateHashLookup[keccak256(abi.encodePacked(this, _proposalTAOId, _aoStringSetting.settingValue(_settingId), _newValue, _extraData, _settingId))] = _settingId;\r\n\r\n\t\temit SettingUpdate(_settingId, _nameFactory.ethAddressToNameId(msg.sender), _proposalTAOId);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Advocate of Setting's proposalTAOId approves the setting update\r\n\t * @param _settingId The ID of the setting to be approved\r\n\t * @param _approved Whether to approve or reject\r\n\t */\r\n\tfunction approveSettingUpdate(uint256 _settingId, bool _approved) public {\r\n\t\taddress _proposalTAOAdvocate = _nameFactory.ethAddressToNameId(msg.sender);\r\n\t\t(,,, address _proposalTAOId,,,) = _aoSettingAttribute.getSettingState(_settingId);\r\n\r\n\t\trequire (_aoSettingAttribute.approveUpdate(_settingId, _proposalTAOAdvocate, _approved));\r\n\r\n\t\temit ApproveSettingUpdate(_settingId, _proposalTAOId, _proposalTAOAdvocate, _approved);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Advocate of Setting's _associatedTAOId finalizes the setting update once the setting is approved\r\n\t * @param _settingId The ID of the setting to be finalized\r\n\t */\r\n\tfunction finalizeSettingUpdate(uint256 _settingId) public {\r\n\t\taddress _associatedTAOAdvocate = _nameFactory.ethAddressToNameId(msg.sender);\r\n\t\trequire (_aoSettingAttribute.finalizeUpdate(_settingId, _associatedTAOAdvocate));\r\n\r\n\t\t(,,, address _associatedTAOId,, uint8 _settingType,,,,) = _aoSettingAttribute.getSettingData(_settingId);\r\n\r\n\t\t_movePendingToSetting(_settingId, _settingType);\r\n\r\n\t\temit FinalizeSettingUpdate(_settingId, _associatedTAOId, _associatedTAOAdvocate);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Advocate of _creatorTAOId adds a setting deprecation\r\n\t * @param _settingId The ID of the setting to be deprecated\r\n\t * @param _newSettingId The new setting ID to route\r\n\t * @param _newSettingContractAddress The new setting contract address to route\r\n\t * @param _creatorTAOId The taoId that created the setting\r\n\t * @param _associatedTAOId The taoId that the setting affects\r\n\t */\r\n\tfunction addSettingDeprecation(uint256 _settingId, uint256 _newSettingId, address _newSettingContractAddress, address _creatorTAOId, address _associatedTAOId) public isTAO(_creatorTAOId) isTAO(_associatedTAOId) onlyAdvocate(_creatorTAOId) {\r\n\t\t(bytes32 _associatedTAOSettingDeprecationId, bytes32 _creatorTAOSettingDeprecationId) = _aoSettingAttribute.addDeprecation(_settingId, _nameFactory.ethAddressToNameId(msg.sender), _creatorTAOId, _associatedTAOId, _newSettingId, _newSettingContractAddress);\r\n\r\n\t\temit SettingDeprecation(_settingId, _nameFactory.ethAddressToNameId(msg.sender), _creatorTAOId, _associatedTAOId, _newSettingId, _newSettingContractAddress, _associatedTAOSettingDeprecationId, _creatorTAOSettingDeprecationId);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Advocate of SettingDeprecation's _associatedTAOId approves setting deprecation\r\n\t * @param _settingId The ID of the setting to approve\r\n\t * @param _approved Whether to approve or reject\r\n\t */\r\n\tfunction approveSettingDeprecation(uint256 _settingId, bool _approved) public {\r\n\t\taddress _associatedTAOAdvocate = _nameFactory.ethAddressToNameId(msg.sender);\r\n\t\trequire (_aoSettingAttribute.approveDeprecation(_settingId, _associatedTAOAdvocate, _approved));\r\n\r\n\t\t(,,, address _associatedTAOId,,,,,,,,) = _aoSettingAttribute.getSettingDeprecation(_settingId);\r\n\t\temit ApproveSettingDeprecation(_settingId, _associatedTAOId, _associatedTAOAdvocate, _approved);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Advocate of SettingDeprecation's _creatorTAOId finalizes the setting deprecation once the setting deprecation is approved\r\n\t * @param _settingId The ID of the setting to be finalized\r\n\t */\r\n\tfunction finalizeSettingDeprecation(uint256 _settingId) public {\r\n\t\taddress _creatorTAOAdvocate = _nameFactory.ethAddressToNameId(msg.sender);\r\n\t\trequire (_aoSettingAttribute.finalizeDeprecation(_settingId, _creatorTAOAdvocate));\r\n\r\n\t\t(,, address _creatorTAOId,,,,,,,,,) = _aoSettingAttribute.getSettingDeprecation(_settingId);\r\n\t\temit FinalizeSettingDeprecation(_settingId, _creatorTAOId, _creatorTAOAdvocate);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Get setting Id given an associatedTAOId and settingName\r\n\t * @param _associatedTAOId The ID of the AssociatedTAO\r\n\t * @param _settingName The name of the setting\r\n\t * @return the ID of the setting\r\n\t */\r\n\tfunction getSettingIdByTAOName(address _associatedTAOId, string _settingName) public view returns (uint256) {\r\n\t\treturn nameSettingLookup[_associatedTAOId][keccak256(abi.encodePacked(this, _settingName))];\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Get setting values by setting ID.\r\n\t *\t\tWill throw error if the setting is not exist or rejected.\r\n\t * @param _settingId The ID of the setting\r\n\t * @return the uint256 value of this setting ID\r\n\t * @return the bool value of this setting ID\r\n\t * @return the address value of this setting ID\r\n\t * @return the bytes32 value of this setting ID\r\n\t * @return the string value of this setting ID\r\n\t */\r\n\tfunction getSettingValuesById(uint256 _settingId) public view returns (uint256, bool, address, bytes32, string) {\r\n\t\trequire (_aoSettingAttribute.settingExist(_settingId));\r\n\t\t_settingId = _aoSettingAttribute.getLatestSettingId(_settingId);\r\n\t\treturn (\r\n\t\t\t_aoUintSetting.settingValue(_settingId),\r\n\t\t\t_aoBoolSetting.settingValue(_settingId),\r\n\t\t\t_aoAddressSetting.settingValue(_settingId),\r\n\t\t\t_aoBytesSetting.settingValue(_settingId),\r\n\t\t\t_aoStringSetting.settingValue(_settingId)\r\n\t\t);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Get setting values by taoId and settingName.\r\n\t *\t\tWill throw error if the setting is not exist or rejected.\r\n\t * @param _taoId The ID of the TAO\r\n\t * @param _settingName The name of the setting\r\n\t * @return the uint256 value of this setting ID\r\n\t * @return the bool value of this setting ID\r\n\t * @return the address value of this setting ID\r\n\t * @return the bytes32 value of this setting ID\r\n\t * @return the string value of this setting ID\r\n\t */\r\n\tfunction getSettingValuesByTAOName(address _taoId, string _settingName) public view returns (uint256, bool, address, bytes32, string) {\r\n\t\treturn getSettingValuesById(getSettingIdByTAOName(_taoId, _settingName));\r\n\t}\r\n\r\n\t/***** Internal Method *****/\r\n\t/**\r\n\t * @dev Store setting creation data\r\n\t * @param _creatorNameId The nameId that created the setting\r\n\t * @param _settingType The type of this setting. 1 => uint256, 2 => bool, 3 => address, 4 => bytes32, 5 => string\r\n\t * @param _settingName The human-readable name of the setting\r\n\t * @param _creatorTAOId The taoId that created the setting\r\n\t * @param _associatedTAOId The taoId that the setting affects\r\n\t * @param _extraData Catch-all string value to be stored if exist\r\n\t */\r\n\tfunction _storeSettingCreation(address _creatorNameId, uint8 _settingType, string _settingName, address _creatorTAOId, address _associatedTAOId, string _extraData) internal {\r\n\t\t// Make sure _settingType is in supported list\r\n\t\trequire (_settingType >= 1 && _settingType <= 5);\r\n\r\n\t\t// Store nameSettingLookup\r\n\t\tnameSettingLookup[_associatedTAOId][keccak256(abi.encodePacked(this, _settingName))] = totalSetting;\r\n\r\n\t\t// Store setting data/state\r\n\t\t(bytes32 _associatedTAOSettingId, bytes32 _creatorTAOSettingId) = _aoSettingAttribute.add(totalSetting, _creatorNameId, _settingType, _settingName, _creatorTAOId, _associatedTAOId, _extraData);\r\n\r\n\t\temit SettingCreation(totalSetting, _creatorNameId, _creatorTAOId, _associatedTAOId, _settingName, _settingType, _associatedTAOSettingId, _creatorTAOSettingId);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Move value of _settingId from pending variable to setting variable\r\n\t * @param _settingId The ID of the setting\r\n\t * @param _settingType The type of the setting\r\n\t */\r\n\tfunction _movePendingToSetting(uint256 _settingId, uint8 _settingType) internal {\r\n\t\t// If settingType == uint256\r\n\t\tif (_settingType == 1) {\r\n\t\t\t_aoUintSetting.movePendingToSetting(_settingId);\r\n\t\t} else if (_settingType == 2) {\r\n\t\t\t// Else if settingType == bool\r\n\t\t\t_aoBoolSetting.movePendingToSetting(_settingId);\r\n\t\t} else if (_settingType == 3) {\r\n\t\t\t// Else if settingType == address\r\n\t\t\t_aoAddressSetting.movePendingToSetting(_settingId);\r\n\t\t} else if (_settingType == 4) {\r\n\t\t\t// Else if settingType == bytes32\r\n\t\t\t_aoBytesSetting.movePendingToSetting(_settingId);\r\n\t\t} else {\r\n\t\t\t// Else if settingType == string\r\n\t\t\t_aoStringSetting.movePendingToSetting(_settingId);\r\n\t\t}\r\n\t}\r\n}\r\n\r\n\r\n\r\n\r\n/**\r\n * @title AOEarning\r\n *\r\n * This contract stores the earning from staking/hosting content on AO\r\n */\r\ncontract AOEarning is TheAO {\r\n\tusing SafeMath for uint256;\r\n\r\n\taddress public settingTAOId;\r\n\taddress public aoSettingAddress;\r\n\taddress public baseDenominationAddress;\r\n\taddress public treasuryAddress;\r\n\taddress public nameFactoryAddress;\r\n\taddress public pathosAddress;\r\n\taddress public ethosAddress;\r\n\r\n\tbool public paused;\r\n\tbool public killed;\r\n\r\n\tAOToken internal _baseAO;\r\n\tAOTreasury internal _treasury;\r\n\tNameFactory internal _nameFactory;\r\n\tPathos internal _pathos;\r\n\tEthos internal _ethos;\r\n\tAOSetting internal _aoSetting;\r\n\r\n\t// Total earning from staking content from all nodes\r\n\tuint256 public totalStakeContentEarning;\r\n\r\n\t// Total earning from hosting content from all nodes\r\n\tuint256 public totalHostContentEarning;\r\n\r\n\t// Total The AO earning\r\n\tuint256 public totalTheAOEarning;\r\n\r\n\t// Mapping from address to his/her earning from content that he/she staked\r\n\tmapping (address => uint256) public stakeContentEarning;\r\n\r\n\t// Mapping from address to his/her earning from content that he/she hosted\r\n\tmapping (address => uint256) public hostContentEarning;\r\n\r\n\t// Mapping from address to his/her network price earning\r\n\t// i.e, when staked amount = filesize\r\n\tmapping (address => uint256) public networkPriceEarning;\r\n\r\n\t// Mapping from address to his/her content price earning\r\n\t// i.e, when staked amount > filesize\r\n\tmapping (address => uint256) public contentPriceEarning;\r\n\r\n\t// Mapping from address to his/her inflation bonus\r\n\tmapping (address => uint256) public inflationBonusAccrued;\r\n\r\n\tstruct Earning {\r\n\t\tbytes32 purchaseId;\r\n\t\tuint256 paymentEarning;\r\n\t\tuint256 inflationBonus;\r\n\t\tuint256 pathosAmount;\r\n\t\tuint256 ethosAmount;\r\n\t}\r\n\r\n\t// Mapping from address to earning from staking content of a purchase ID\r\n\tmapping (address => mapping(bytes32 => Earning)) public stakeEarnings;\r\n\r\n\t// Mapping from address to earning from hosting content of a purchase ID\r\n\tmapping (address => mapping(bytes32 => Earning)) public hostEarnings;\r\n\r\n\t// Mapping from purchase ID to earning for The AO\r\n\tmapping (bytes32 => Earning) public theAOEarnings;\r\n\r\n\t// Mapping from stake ID to it's total earning from staking\r\n\tmapping (bytes32 => uint256) public totalStakedContentStakeEarning;\r\n\r\n\t// Mapping from stake ID to it's total earning from hosting\r\n\tmapping (bytes32 => uint256) public totalStakedContentHostEarning;\r\n\r\n\t// Mapping from stake ID to it's total earning earned by The AO\r\n\tmapping (bytes32 => uint256) public totalStakedContentTheAOEarning;\r\n\r\n\t// Mapping from content host ID to it's total earning\r\n\tmapping (bytes32 => uint256) public totalHostContentEarningById;\r\n\r\n\t// Event to be broadcasted to public when content creator/host earns the payment split in escrow when request node buys the content\r\n\t// recipientType:\r\n\t// 0 => Content Creator (Stake Owner)\r\n\t// 1 => Node Host\r\n\t// 2 => The AO\r\n\tevent PaymentEarningEscrowed(address indexed recipient, bytes32 indexed purchaseId, uint256 totalPaymentAmount, uint256 recipientProfitPercentage, uint256 recipientPaymentEarning, uint8 recipientType);\r\n\r\n\t// Event to be broadcasted to public when content creator/host/The AO earns inflation bonus in escrow when request node buys the content\r\n\t// recipientType:\r\n\t// 0 => Content Creator (Stake Owner)\r\n\t// 1 => Node Host\r\n\t// 2 => The AO\r\n\tevent InflationBonusEscrowed(address indexed recipient, bytes32 indexed purchaseId, uint256 totalInflationBonusAmount, uint256 recipientProfitPercentage, uint256 recipientInflationBonus, uint8 recipientType);\r\n\r\n\t// Event to be broadcasted to public when content creator/host/The AO earning is released from escrow\r\n\t// recipientType:\r\n\t// 0 => Content Creator (Stake Owner)\r\n\t// 1 => Node Host\r\n\t// 2 => The AO\r\n\tevent EarningUnescrowed(address indexed recipient, bytes32 indexed purchaseId, uint256 paymentEarning, uint256 inflationBonus, uint8 recipientType);\r\n\r\n\t// Event to be broadcasted to public when content creator's Name earns Pathos when a node buys a content\r\n\tevent PathosEarned(address indexed nameId, bytes32 indexed purchaseId, uint256 amount);\r\n\r\n\t// Event to be broadcasted to public when host's Name earns Ethos when a node buys a content\r\n\tevent EthosEarned(address indexed nameId, bytes32 indexed purchaseId, uint256 amount);\r\n\r\n\t// Event to be broadcasted to public when emergency mode is triggered\r\n\tevent EscapeHatch();\r\n\r\n\t/**\r\n\t * @dev Constructor function\r\n\t * @param _settingTAOId The TAO ID that controls the setting\r\n\t * @param _aoSettingAddress The address of AOSetting\r\n\t * @param _baseDenominationAddress The address of AO base token\r\n\t * @param _treasuryAddress The address of AOTreasury\r\n\t * @param _nameFactoryAddress The address of NameFactory\r\n\t * @param _pathosAddress The address of Pathos\r\n\t * @param _ethosAddress The address of Ethos\r\n\t */\r\n\tconstructor(address _settingTAOId, address _aoSettingAddress, address _baseDenominationAddress, address _treasuryAddress, address _nameFactoryAddress, address _pathosAddress, address _ethosAddress) public {\r\n\t\tsettingTAOId = _settingTAOId;\r\n\t\taoSettingAddress = _aoSettingAddress;\r\n\t\tbaseDenominationAddress = _baseDenominationAddress;\r\n\t\ttreasuryAddress = _treasuryAddress;\r\n\t\tpathosAddress = _pathosAddress;\r\n\t\tethosAddress = _ethosAddress;\r\n\r\n\t\t_aoSetting = AOSetting(_aoSettingAddress);\r\n\t\t_baseAO = AOToken(_baseDenominationAddress);\r\n\t\t_treasury = AOTreasury(_treasuryAddress);\r\n\t\t_nameFactory = NameFactory(_nameFactoryAddress);\r\n\t\t_pathos = Pathos(_pathosAddress);\r\n\t\t_ethos = Ethos(_ethosAddress);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Checks if the calling contract address is The AO\r\n\t *\t\tOR\r\n\t *\t\tIf The AO is set to a Name/TAO, then check if calling address is the Advocate\r\n\t */\r\n\tmodifier onlyTheAO {\r\n\t\trequire (AOLibrary.isTheAO(msg.sender, theAO, nameTAOPositionAddress));\r\n\t\t_;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Checks if contract is currently active\r\n\t */\r\n\tmodifier isContractActive {\r\n\t\trequire (paused == false && killed == false);\r\n\t\t_;\r\n\t}\r\n\r\n\t/***** The AO ONLY METHODS *****/\r\n\t/**\r\n\t * @dev The AO set the NameTAOPosition Address\r\n\t * @param _nameTAOPositionAddress The address of NameTAOPosition\r\n\t */\r\n\tfunction setNameTAOPositionAddress(address _nameTAOPositionAddress) public onlyTheAO {\r\n\t\trequire (_nameTAOPositionAddress != address(0));\r\n\t\tnameTAOPositionAddress = _nameTAOPositionAddress;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Transfer ownership of The AO to new address\r\n\t * @param _theAO The new address to be transferred\r\n\t */\r\n\tfunction transferOwnership(address _theAO) public onlyTheAO {\r\n\t\trequire (_theAO != address(0));\r\n\t\ttheAO = _theAO;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Whitelist `_account` address to transact on behalf of others\r\n\t * @param _account The address to whitelist\r\n\t * @param _whitelist Either to whitelist or not\r\n\t */\r\n\tfunction setWhitelist(address _account, bool _whitelist) public onlyTheAO {\r\n\t\trequire (_account != address(0));\r\n\t\twhitelist[_account] = _whitelist;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev The AO pauses/unpauses contract\r\n\t * @param _paused Either to pause contract or not\r\n\t */\r\n\tfunction setPaused(bool _paused) public onlyTheAO {\r\n\t\tpaused = _paused;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev The AO triggers emergency mode.\r\n\t *\r\n\t */\r\n\tfunction escapeHatch() public onlyTheAO {\r\n\t\trequire (killed == false);\r\n\t\tkilled = true;\r\n\t\temit EscapeHatch();\r\n\t}\r\n\r\n\t/**\r\n\t * @dev The AO updates base denomination address\r\n\t * @param _newBaseDenominationAddress The new address\r\n\t */\r\n\tfunction setBaseDenominationAddress(address _newBaseDenominationAddress) public onlyTheAO {\r\n\t\trequire (AOToken(_newBaseDenominationAddress).powerOfTen() == 0);\r\n\t\tbaseDenominationAddress = _newBaseDenominationAddress;\r\n\t\t_baseAO = AOToken(baseDenominationAddress);\r\n\t}\r\n\r\n\t/***** PUBLIC METHODS *****/\r\n\t/**\r\n\t * @dev Calculate the content creator/host/The AO earning when request node buys the content.\r\n\t *\t\tAlso at this stage, all of the earnings are stored in escrow\r\n\t * @param _buyer The request node address that buys the content\r\n\t * @param _purchaseId The ID of the purchase receipt object\r\n\t * @param _networkAmountStaked The amount of network tokens at stake\r\n\t * @param _primordialAmountStaked The amount of primordial tokens at stake\r\n\t * @param _primordialWeightedMultiplierStaked The weighted multiplier of primordial tokens at stake\r\n\t * @param _profitPercentage The content creator's profit percentage\r\n\t * @param _stakeOwner The address of the stake owner\r\n\t * @param _host The address of the host\r\n\t * @param _isAOContentUsageType whether or not the content is of AO Content Usage Type\r\n\t */\r\n\tfunction calculateEarning(\r\n\t\taddress _buyer,\r\n\t\tbytes32 _purchaseId,\r\n\t\tuint256 _networkAmountStaked,\r\n\t\tuint256 _primordialAmountStaked,\r\n\t\tuint256 _primordialWeightedMultiplierStaked,\r\n\t\tuint256 _profitPercentage,\r\n\t\taddress _stakeOwner,\r\n\t\taddress _host,\r\n\t\tbool _isAOContentUsageType\r\n\t) public isContractActive inWhitelist returns (bool) {\r\n\t\t// Split the payment earning between content creator and host and store them in escrow\r\n\t\t_escrowPaymentEarning(_buyer, _purchaseId, _networkAmountStaked.add(_primordialAmountStaked), _profitPercentage, _stakeOwner, _host, _isAOContentUsageType);\r\n\r\n\t\t// Calculate the inflation bonus earning for content creator/node/The AO in escrow\r\n\t\t_escrowInflationBonus(_purchaseId, _calculateInflationBonus(_networkAmountStaked, _primordialAmountStaked, _primordialWeightedMultiplierStaked), _profitPercentage, _stakeOwner, _host, _isAOContentUsageType);\r\n\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Release the payment earning and inflation bonus that is in escrow for specific purchase ID\r\n\t * @param _stakeId The ID of the staked content\r\n\t * @param _contentHostId The ID of the hosted content\r\n\t * @param _purchaseId The purchase receipt ID to check\r\n\t * @param _buyerPaidMoreThanFileSize Whether or not the request node paid more than filesize when buying the content\r\n\t * @param _stakeOwner The address of the stake owner\r\n\t * @param _host The address of the node that host the file\r\n\t * @return true on success\r\n\t */\r\n\tfunction releaseEarning(bytes32 _stakeId, bytes32 _contentHostId, bytes32 _purchaseId, bool _buyerPaidMoreThanFileSize, address _stakeOwner, address _host) public isContractActive inWhitelist returns (bool) {\r\n\t\t// Release the earning in escrow for stake owner\r\n\t\t_releaseEarning(_stakeId, _contentHostId, _purchaseId, _buyerPaidMoreThanFileSize, _stakeOwner, 0);\r\n\r\n\t\t// Release the earning in escrow for host\r\n\t\t_releaseEarning(_stakeId, _contentHostId, _purchaseId, _buyerPaidMoreThanFileSize, _host, 1);\r\n\r\n\t\t// Release the earning in escrow for The AO\r\n\t\t_releaseEarning(_stakeId, _contentHostId, _purchaseId, _buyerPaidMoreThanFileSize, theAO, 2);\r\n\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/***** INTERNAL METHODS *****/\r\n\t/**\r\n\t * @dev Calculate the payment split for content creator/host and store them in escrow\r\n\t * @param _buyer the request node address that buys the content\r\n\t * @param _purchaseId The ID of the purchase receipt object\r\n\t * @param _totalStaked The total staked amount of the content\r\n\t * @param _profitPercentage The content creator's profit percentage\r\n\t * @param _stakeOwner The address of the stake owner\r\n\t * @param _host The address of the host\r\n\t * @param _isAOContentUsageType whether or not the content is of AO Content Usage Type\r\n\t */\r\n\tfunction _escrowPaymentEarning(address _buyer, bytes32 _purchaseId, uint256 _totalStaked, uint256 _profitPercentage, address _stakeOwner, address _host, bool _isAOContentUsageType) internal {\r\n\t\t(uint256 _stakeOwnerEarning, uint256 _pathosAmount) = _escrowStakeOwnerPaymentEarning(_buyer, _purchaseId, _totalStaked, _profitPercentage, _stakeOwner, _isAOContentUsageType);\r\n\t\t(uint256 _ethosAmount) = _escrowHostPaymentEarning(_buyer, _purchaseId, _totalStaked, _profitPercentage, _host, _isAOContentUsageType, _stakeOwnerEarning);\r\n\r\n\t\t_escrowTheAOPaymentEarning(_purchaseId, _totalStaked, _pathosAmount, _ethosAmount);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Calculate the inflation bonus amount\r\n\t * @param _networkAmountStaked The amount of network tokens at stake\r\n\t * @param _primordialAmountStaked The amount of primordial tokens at stake\r\n\t * @param _primordialWeightedMultiplierStaked The weighted multiplier of primordial tokens at stake\r\n\t * @return the bonus network amount\r\n\t */\r\n\tfunction _calculateInflationBonus(uint256 _networkAmountStaked, uint256 _primordialAmountStaked, uint256 _primordialWeightedMultiplierStaked) internal view returns (uint256) {\r\n\t\t(uint256 inflationRate,,) = _getSettingVariables();\r\n\r\n\t\tuint256 _networkBonus = _networkAmountStaked.mul(inflationRate).div(AOLibrary.PERCENTAGE_DIVISOR());\r\n\t\tuint256 _primordialBonus = _primordialAmountStaked.mul(_primordialWeightedMultiplierStaked).div(AOLibrary.MULTIPLIER_DIVISOR()).mul(inflationRate).div(AOLibrary.PERCENTAGE_DIVISOR());\r\n\t\treturn _networkBonus.add(_primordialBonus);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Mint the inflation bonus for content creator/host/The AO and store them in escrow\r\n\t * @param _purchaseId The ID of the purchase receipt object\r\n\t * @param _inflationBonusAmount The amount of inflation bonus earning\r\n\t * @param _profitPercentage The content creator's profit percentage\r\n\t * @param _stakeOwner The address of the stake owner\r\n\t * @param _host The address of the host\r\n\t * @param _isAOContentUsageType whether or not the content is of AO Content Usage Type\r\n\t */\r\n\tfunction _escrowInflationBonus(\r\n\t\tbytes32 _purchaseId,\r\n\t\tuint256 _inflationBonusAmount,\r\n\t\tuint256 _profitPercentage,\r\n\t\taddress _stakeOwner,\r\n\t\taddress _host,\r\n\t\tbool _isAOContentUsageType\r\n\t) internal {\r\n\t\t(, uint256 theAOCut,) = _getSettingVariables();\r\n\r\n\t\tif (_inflationBonusAmount > 0) {\r\n\t\t\t// Store how much the content creator earns in escrow\r\n\t\t\tuint256 _stakeOwnerInflationBonus = _isAOContentUsageType ? (_inflationBonusAmount.mul(_profitPercentage)).div(AOLibrary.PERCENTAGE_DIVISOR()) : 0;\r\n\t\t\tEarning storage _stakeEarning = stakeEarnings[_stakeOwner][_purchaseId];\r\n\t\t\t_stakeEarning.inflationBonus = _stakeOwnerInflationBonus;\r\n\t\t\trequire (_baseAO.mintTokenEscrow(_stakeOwner, _stakeEarning.inflationBonus));\r\n\t\t\temit InflationBonusEscrowed(_stakeOwner, _purchaseId, _inflationBonusAmount, _profitPercentage, _stakeEarning.inflationBonus, 0);\r\n\r\n\t\t\t// Store how much the host earns in escrow\r\n\t\t\tEarning storage _hostEarning = hostEarnings[_host][_purchaseId];\r\n\t\t\t_hostEarning.inflationBonus = _inflationBonusAmount.sub(_stakeOwnerInflationBonus);\r\n\t\t\trequire (_baseAO.mintTokenEscrow(_host, _hostEarning.inflationBonus));\r\n\t\t\temit InflationBonusEscrowed(_host, _purchaseId, _inflationBonusAmount, AOLibrary.PERCENTAGE_DIVISOR().sub(_profitPercentage), _hostEarning.inflationBonus, 1);\r\n\r\n\t\t\t// Store how much the The AO earns in escrow\r\n\t\t\tEarning storage _theAOEarning = theAOEarnings[_purchaseId];\r\n\t\t\t_theAOEarning.inflationBonus = (_inflationBonusAmount.mul(theAOCut)).div(AOLibrary.PERCENTAGE_DIVISOR());\r\n\t\t\trequire (_baseAO.mintTokenEscrow(theAO, _theAOEarning.inflationBonus));\r\n\t\t\temit InflationBonusEscrowed(theAO, _purchaseId, _inflationBonusAmount, theAOCut, _theAOEarning.inflationBonus, 2);\r\n\t\t} else {\r\n\t\t\temit InflationBonusEscrowed(_stakeOwner, _purchaseId, 0, _profitPercentage, 0, 0);\r\n\t\t\temit InflationBonusEscrowed(_host, _purchaseId, 0, AOLibrary.PERCENTAGE_DIVISOR().sub(_profitPercentage), 0, 1);\r\n\t\t\temit InflationBonusEscrowed(theAO, _purchaseId, 0, theAOCut, 0, 2);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Release the escrowed earning for a specific purchase ID for an account\r\n\t * @param _stakeId The ID of the staked content\r\n\t * @param _contentHostId The ID of the hosted content\r\n\t * @param _purchaseId The purchase receipt ID\r\n\t * @param _buyerPaidMoreThanFileSize Whether or not the request node paid more than filesize when buying the content\r\n\t * @param _account The address of account that made the earning (content creator/host)\r\n\t * @param _recipientType The type of the earning recipient (0 => content creator. 1 => host. 2 => theAO)\r\n\t */\r\n\tfunction _releaseEarning(bytes32 _stakeId, bytes32 _contentHostId, bytes32 _purchaseId, bool _buyerPaidMoreThanFileSize, address _account, uint8 _recipientType) internal {\r\n\t\t// Make sure the recipient type is valid\r\n\t\trequire (_recipientType >= 0 && _recipientType <= 2);\r\n\r\n\t\tuint256 _paymentEarning;\r\n\t\tuint256 _inflationBonus;\r\n\t\tuint256 _totalEarning;\r\n\t\tuint256 _pathosAmount;\r\n\t\tuint256 _ethosAmount;\r\n\t\tif (_recipientType == 0) {\r\n\t\t\tEarning storage _earning = stakeEarnings[_account][_purchaseId];\r\n\t\t\t_paymentEarning = _earning.paymentEarning;\r\n\t\t\t_inflationBonus = _earning.inflationBonus;\r\n\t\t\t_pathosAmount = _earning.pathosAmount;\r\n\t\t\t_earning.paymentEarning = 0;\r\n\t\t\t_earning.inflationBonus = 0;\r\n\t\t\t_earning.pathosAmount = 0;\r\n\t\t\t_earning.ethosAmount = 0;\r\n\t\t\t_totalEarning = _paymentEarning.add(_inflationBonus);\r\n\r\n\t\t\t// Update the global var settings\r\n\t\t\ttotalStakeContentEarning = totalStakeContentEarning.add(_totalEarning);\r\n\t\t\tstakeContentEarning[_account] = stakeContentEarning[_account].add(_totalEarning);\r\n\t\t\ttotalStakedContentStakeEarning[_stakeId] = totalStakedContentStakeEarning[_stakeId].add(_totalEarning);\r\n\t\t\tif (_buyerPaidMoreThanFileSize) {\r\n\t\t\t\tcontentPriceEarning[_account] = contentPriceEarning[_account].add(_totalEarning);\r\n\t\t\t} else {\r\n\t\t\t\tnetworkPriceEarning[_account] = networkPriceEarning[_account].add(_totalEarning);\r\n\t\t\t}\r\n\t\t\tinflationBonusAccrued[_account] = inflationBonusAccrued[_account].add(_inflationBonus);\r\n\r\n\t\t\t// Reward the content creator/stake owner with some Pathos\r\n\t\t\trequire (_pathos.mintToken(_nameFactory.ethAddressToNameId(_account), _pathosAmount));\r\n\t\t\temit PathosEarned(_nameFactory.ethAddressToNameId(_account), _purchaseId, _pathosAmount);\r\n\t\t} else if (_recipientType == 1) {\r\n\t\t\t_earning = hostEarnings[_account][_purchaseId];\r\n\t\t\t_paymentEarning = _earning.paymentEarning;\r\n\t\t\t_inflationBonus = _earning.inflationBonus;\r\n\t\t\t_ethosAmount = _earning.ethosAmount;\r\n\t\t\t_earning.paymentEarning = 0;\r\n\t\t\t_earning.inflationBonus = 0;\r\n\t\t\t_earning.pathosAmount = 0;\r\n\t\t\t_earning.ethosAmount = 0;\r\n\t\t\t_totalEarning = _paymentEarning.add(_inflationBonus);\r\n\r\n\t\t\t// Update the global var settings\r\n\t\t\ttotalHostContentEarning = totalHostContentEarning.add(_totalEarning);\r\n\t\t\thostContentEarning[_account] = hostContentEarning[_account].add(_totalEarning);\r\n\t\t\ttotalStakedContentHostEarning[_stakeId] = totalStakedContentHostEarning[_stakeId].add(_totalEarning);\r\n\t\t\ttotalHostContentEarningById[_contentHostId] = totalHostContentEarningById[_contentHostId].add(_totalEarning);\r\n\t\t\tif (_buyerPaidMoreThanFileSize) {\r\n\t\t\t\tcontentPriceEarning[_account] = contentPriceEarning[_account].add(_totalEarning);\r\n\t\t\t} else {\r\n\t\t\t\tnetworkPriceEarning[_account] = networkPriceEarning[_account].add(_totalEarning);\r\n\t\t\t}\r\n\t\t\tinflationBonusAccrued[_account] = inflationBonusAccrued[_account].add(_inflationBonus);\r\n\r\n\t\t\t// Reward the host node with some Ethos\r\n\t\t\trequire (_ethos.mintToken(_nameFactory.ethAddressToNameId(_account), _ethosAmount));\r\n\t\t\temit EthosEarned(_nameFactory.ethAddressToNameId(_account), _purchaseId, _ethosAmount);\r\n\t\t} else {\r\n\t\t\t_earning = theAOEarnings[_purchaseId];\r\n\t\t\t_paymentEarning = _earning.paymentEarning;\r\n\t\t\t_inflationBonus = _earning.inflationBonus;\r\n\t\t\t_earning.paymentEarning = 0;\r\n\t\t\t_earning.inflationBonus = 0;\r\n\t\t\t_earning.pathosAmount = 0;\r\n\t\t\t_earning.ethosAmount = 0;\r\n\t\t\t_totalEarning = _paymentEarning.add(_inflationBonus);\r\n\r\n\t\t\t// Update the global var settings\r\n\t\t\ttotalTheAOEarning = totalTheAOEarning.add(_totalEarning);\r\n\t\t\tinflationBonusAccrued[_account] = inflationBonusAccrued[_account].add(_inflationBonus);\r\n\t\t\ttotalStakedContentTheAOEarning[_stakeId] = totalStakedContentTheAOEarning[_stakeId].add(_totalEarning);\r\n\t\t}\r\n\t\trequire (_baseAO.unescrowFrom(_account, _totalEarning));\r\n\t\temit EarningUnescrowed(_account, _purchaseId, _paymentEarning, _inflationBonus, _recipientType);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Get setting variables\r\n\t * @return inflationRate The rate to use when calculating inflation bonus\r\n\t * @return theAOCut The rate to use when calculating the AO earning\r\n\t * @return theAOEthosEarnedRate The rate to use when calculating the Ethos to AO rate for the AO\r\n\t */\r\n\tfunction _getSettingVariables() internal view returns (uint256, uint256, uint256) {\r\n\t\t(uint256 inflationRate,,,,) = _aoSetting.getSettingValuesByTAOName(settingTAOId, 'inflationRate');\r\n\t\t(uint256 theAOCut,,,,) = _aoSetting.getSettingValuesByTAOName(settingTAOId, 'theAOCut');\r\n\t\t(uint256 theAOEthosEarnedRate,,,,) = _aoSetting.getSettingValuesByTAOName(settingTAOId, 'theAOEthosEarnedRate');\r\n\r\n\t\treturn (inflationRate, theAOCut, theAOEthosEarnedRate);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Calculate the payment split for content creator and store them in escrow\r\n\t * @param _buyer the request node address that buys the content\r\n\t * @param _purchaseId The ID of the purchase receipt object\r\n\t * @param _totalStaked The total staked amount of the content\r\n\t * @param _profitPercentage The content creator's profit percentage\r\n\t * @param _stakeOwner The address of the stake owner\r\n\t * @param _isAOContentUsageType whether or not the content is of AO Content Usage Type\r\n\t * @return The stake owner's earning amount\r\n\t * @return The pathos earned from this transaction\r\n\t */\r\n\tfunction _escrowStakeOwnerPaymentEarning(address _buyer, bytes32 _purchaseId, uint256 _totalStaked, uint256 _profitPercentage, address _stakeOwner, bool _isAOContentUsageType) internal returns (uint256, uint256) {\r\n\t\t(uint256 inflationRate,,) = _getSettingVariables();\r\n\r\n\t\tEarning storage _stakeEarning = stakeEarnings[_stakeOwner][_purchaseId];\r\n\t\t_stakeEarning.purchaseId = _purchaseId;\r\n\t\t// Store how much the content creator (stake owner) earns in escrow\r\n\t\t// If content is AO Content Usage Type, stake owner earns 0%\r\n\t\t// and all profit goes to the serving host node\r\n\t\t_stakeEarning.paymentEarning = _isAOContentUsageType ? (_totalStaked.mul(_profitPercentage)).div(AOLibrary.PERCENTAGE_DIVISOR()) : 0;\r\n\t\t// Pathos = Price X Node Share X Inflation Rate\r\n\t\t_stakeEarning.pathosAmount = _totalStaked.mul(AOLibrary.PERCENTAGE_DIVISOR().sub(_profitPercentage)).mul(inflationRate).div(AOLibrary.PERCENTAGE_DIVISOR()).div(AOLibrary.PERCENTAGE_DIVISOR());\r\n\t\trequire (_baseAO.escrowFrom(_buyer, _stakeOwner, _stakeEarning.paymentEarning));\r\n\t\temit PaymentEarningEscrowed(_stakeOwner, _purchaseId, _totalStaked, _profitPercentage, _stakeEarning.paymentEarning, 0);\r\n\t\treturn (_stakeEarning.paymentEarning, _stakeEarning.pathosAmount);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Calculate the payment split for host node and store them in escrow\r\n\t * @param _buyer the request node address that buys the content\r\n\t * @param _purchaseId The ID of the purchase receipt object\r\n\t * @param _totalStaked The total staked amount of the content\r\n\t * @param _profitPercentage The content creator's profit percentage\r\n\t * @param _host The address of the host node\r\n\t * @param _isAOContentUsageType whether or not the content is of AO Content Usage Type\r\n\t * @param _stakeOwnerEarning The stake owner's earning amount\r\n\t * @return The ethos earned from this transaction\r\n\t */\r\n\tfunction _escrowHostPaymentEarning(address _buyer, bytes32 _purchaseId, uint256 _totalStaked, uint256 _profitPercentage, address _host, bool _isAOContentUsageType, uint256 _stakeOwnerEarning) internal returns (uint256) {\r\n\t\t(uint256 inflationRate,,) = _getSettingVariables();\r\n\r\n\t\t// Store how much the node host earns in escrow\r\n\t\tEarning storage _hostEarning = hostEarnings[_host][_purchaseId];\r\n\t\t_hostEarning.purchaseId = _purchaseId;\r\n\t\t_hostEarning.paymentEarning = _totalStaked.sub(_stakeOwnerEarning);\r\n\t\t// Ethos = Price X Creator Share X Inflation Rate\r\n\t\t_hostEarning.ethosAmount = _totalStaked.mul(_profitPercentage).mul(inflationRate).div(AOLibrary.PERCENTAGE_DIVISOR()).div(AOLibrary.PERCENTAGE_DIVISOR());\r\n\r\n\t\tif (_isAOContentUsageType) {\r\n\t\t\trequire (_baseAO.escrowFrom(_buyer, _host, _hostEarning.paymentEarning));\r\n\t\t} else {\r\n\t\t\t// If not AO Content usage type, we want to mint to the host\r\n\t\t\trequire (_baseAO.mintTokenEscrow(_host, _hostEarning.paymentEarning));\r\n\t\t}\r\n\t\temit PaymentEarningEscrowed(_host, _purchaseId, _totalStaked, AOLibrary.PERCENTAGE_DIVISOR().sub(_profitPercentage), _hostEarning.paymentEarning, 1);\r\n\t\treturn _hostEarning.ethosAmount;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Calculate the earning for The AO and store them in escrow\r\n\t * @param _purchaseId The ID of the purchase receipt object\r\n\t * @param _totalStaked The total staked amount of the content\r\n\t * @param _pathosAmount The amount of pathos earned by stake owner\r\n\t * @param _ethosAmount The amount of ethos earned by host node\r\n\t */\r\n\tfunction _escrowTheAOPaymentEarning(bytes32 _purchaseId, uint256 _totalStaked, uint256 _pathosAmount, uint256 _ethosAmount) internal {\r\n\t\t(,,uint256 theAOEthosEarnedRate) = _getSettingVariables();\r\n\r\n\t\t// Store how much The AO earns in escrow\r\n\t\tEarning storage _theAOEarning = theAOEarnings[_purchaseId];\r\n\t\t_theAOEarning.purchaseId = _purchaseId;\r\n\t\t// Pathos + X% of Ethos\r\n\t\t_theAOEarning.paymentEarning = _pathosAmount.add(_ethosAmount.mul(theAOEthosEarnedRate).div(AOLibrary.PERCENTAGE_DIVISOR()));\r\n\t\trequire (_baseAO.mintTokenEscrow(theAO, _theAOEarning.paymentEarning));\r\n\t\temit PaymentEarningEscrowed(theAO, _purchaseId, _totalStaked, 0, _theAOEarning.paymentEarning, 2);\r\n\t}\r\n}\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title AOContent\r\n *\r\n * The purpose of this contract is to allow content creator to stake network ERC20 AO tokens and/or primordial AO Tokens\r\n * on his/her content\r\n */\r\ncontract AOContent is TheAO {\r\n\tusing SafeMath for uint256;\r\n\r\n\tuint256 public totalContents;\r\n\tuint256 public totalContentHosts;\r\n\tuint256 public totalStakedContents;\r\n\tuint256 public totalPurchaseReceipts;\r\n\r\n\taddress public settingTAOId;\r\n\taddress public baseDenominationAddress;\r\n\taddress public treasuryAddress;\r\n\r\n\tAOToken internal _baseAO;\r\n\tAOTreasury internal _treasury;\r\n\tAOEarning internal _earning;\r\n\tAOSetting internal _aoSetting;\r\n\tNameTAOPosition internal _nameTAOPosition;\r\n\r\n\tbool public paused;\r\n\tbool public killed;\r\n\r\n\tstruct Content {\r\n\t\tbytes32 contentId;\r\n\t\taddress creator;\r\n\t\t/**\r\n\t\t * baseChallenge is the content's PUBLIC KEY\r\n\t\t * When a request node wants to be a host, it is required to send a signed base challenge (its content's PUBLIC KEY)\r\n\t\t * so that the contract can verify the authenticity of the content by comparing what the contract has and what the request node\r\n\t\t * submit\r\n\t\t */\r\n\t\tstring baseChallenge;\r\n\t\tuint256 fileSize;\r\n\t\tbytes32 contentUsageType; // i.e AO Content, Creative Commons, or T(AO) Content\r\n\t\taddress taoId;\r\n\t\tbytes32 taoContentState; // i.e Submitted, Pending Review, Accepted to TAO\r\n\t\tuint8 updateTAOContentStateV;\r\n\t\tbytes32 updateTAOContentStateR;\r\n\t\tbytes32 updateTAOContentStateS;\r\n\t\tstring extraData;\r\n\t}\r\n\r\n\tstruct StakedContent {\r\n\t\tbytes32 stakeId;\r\n\t\tbytes32 contentId;\r\n\t\taddress stakeOwner;\r\n\t\tuint256 networkAmount; // total network token staked in base denomination\r\n\t\tuint256 primordialAmount;\t// the amount of primordial AO Token to stake (always in base denomination)\r\n\t\tuint256 primordialWeightedMultiplier;\r\n\t\tuint256 profitPercentage; // support up to 4 decimals, 100% = 1000000\r\n\t\tbool active; // true if currently staked, false when unstaked\r\n\t\tuint256 createdOnTimestamp;\r\n\t}\r\n\r\n\tstruct ContentHost {\r\n\t\tbytes32 contentHostId;\r\n\t\tbytes32 stakeId;\r\n\t\taddress host;\r\n\t\t/**\r\n\t\t * encChallenge is the content's PUBLIC KEY unique to the host\r\n\t\t */\r\n\t\tstring encChallenge;\r\n\t\tstring contentDatKey;\r\n\t\tstring metadataDatKey;\r\n\t}\r\n\r\n\tstruct PurchaseReceipt {\r\n\t\tbytes32 purchaseId;\r\n\t\tbytes32 contentHostId;\r\n\t\taddress buyer;\r\n\t\tuint256 price;\r\n\t\tuint256 amountPaidByBuyer;\t// total network token paid in base denomination\r\n\t\tuint256 amountPaidByAO; // total amount paid by AO\r\n\t\tstring publicKey; // The public key provided by request node\r\n\t\taddress publicAddress; // The public address provided by request node\r\n\t\tuint256 createdOnTimestamp;\r\n\t}\r\n\r\n\t// Mapping from Content index to the Content object\r\n\tmapping (uint256 => Content) internal contents;\r\n\r\n\t// Mapping from content ID to index of the contents list\r\n\tmapping (bytes32 => uint256) internal contentIndex;\r\n\r\n\t// Mapping from StakedContent index to the StakedContent object\r\n\tmapping (uint256 => StakedContent) internal stakedContents;\r\n\r\n\t// Mapping from stake ID to index of the stakedContents list\r\n\tmapping (bytes32 => uint256) internal stakedContentIndex;\r\n\r\n\t// Mapping from ContentHost index to the ContentHost object\r\n\tmapping (uint256 => ContentHost) internal contentHosts;\r\n\r\n\t// Mapping from content host ID to index of the contentHosts list\r\n\tmapping (bytes32 => uint256) internal contentHostIndex;\r\n\r\n\t// Mapping from PurchaseReceipt index to the PurchaseReceipt object\r\n\tmapping (uint256 => PurchaseReceipt) internal purchaseReceipts;\r\n\r\n\t// Mapping from purchase ID to index of the purchaseReceipts list\r\n\tmapping (bytes32 => uint256) internal purchaseReceiptIndex;\r\n\r\n\t// Mapping from buyer's content host ID to the buy ID\r\n\t// To check whether or not buyer has bought/paid for a content\r\n\tmapping (address => mapping (bytes32 => bytes32)) public buyerPurchaseReceipts;\r\n\r\n\t// Event to be broadcasted to public when `content` is stored\r\n\tevent StoreContent(address indexed creator, bytes32 indexed contentId, uint256 fileSize, bytes32 contentUsageType);\r\n\r\n\t// Event to be broadcasted to public when `stakeOwner` stakes a new content\r\n\tevent StakeContent(address indexed stakeOwner, bytes32 indexed stakeId, bytes32 indexed contentId, uint256 baseNetworkAmount, uint256 primordialAmount, uint256 primordialWeightedMultiplier, uint256 profitPercentage, uint256 createdOnTimestamp);\r\n\r\n\t// Event to be broadcasted to public when a node hosts a content\r\n\tevent HostContent(address indexed host, bytes32 indexed contentHostId, bytes32 stakeId, string contentDatKey, string metadataDatKey);\r\n\r\n\t// Event to be broadcasted to public when `stakeOwner` updates the staked content's profit percentage\r\n\tevent SetProfitPercentage(address indexed stakeOwner, bytes32 indexed stakeId, uint256 newProfitPercentage);\r\n\r\n\t// Event to be broadcasted to public when `stakeOwner` unstakes some network/primordial token from an existing content\r\n\tevent UnstakePartialContent(address indexed stakeOwner, bytes32 indexed stakeId, bytes32 indexed contentId, uint256 remainingNetworkAmount, uint256 remainingPrimordialAmount, uint256 primordialWeightedMultiplier);\r\n\r\n\t// Event to be broadcasted to public when `stakeOwner` unstakes all token amount on an existing content\r\n\tevent UnstakeContent(address indexed stakeOwner, bytes32 indexed stakeId);\r\n\r\n\t// Event to be broadcasted to public when `stakeOwner` re-stakes an existing content\r\n\tevent StakeExistingContent(address indexed stakeOwner, bytes32 indexed stakeId, bytes32 indexed contentId, uint256 currentNetworkAmount, uint256 currentPrimordialAmount, uint256 currentPrimordialWeightedMultiplier);\r\n\r\n\t// Event to be broadcasted to public when a request node buys a content\r\n\tevent BuyContent(address indexed buyer, bytes32 indexed purchaseId, bytes32 indexed contentHostId, uint256 price, uint256 amountPaidByAO, uint256 amountPaidByBuyer, string publicKey, address publicAddress, uint256 createdOnTimestamp);\r\n\r\n\t// Event to be broadcasted to public when Advocate/Listener/Speaker wants to update the TAO Content's State\r\n\tevent UpdateTAOContentState(bytes32 indexed contentId, address indexed taoId, address signer, bytes32 taoContentState);\r\n\r\n\t// Event to be broadcasted to public when emergency mode is triggered\r\n\tevent EscapeHatch();\r\n\r\n\t/**\r\n\t * @dev Constructor function\r\n\t * @param _settingTAOId The TAO ID that controls the setting\r\n\t * @param _aoSettingAddress The address of AOSetting\r\n\t * @param _baseDenominationAddress The address of AO base token\r\n\t * @param _treasuryAddress The address of AOTreasury\r\n\t * @param _earningAddress The address of AOEarning\r\n\t * @param _nameTAOPositionAddress The address of NameTAOPosition\r\n\t */\r\n\tconstructor(address _settingTAOId, address _aoSettingAddress, address _baseDenominationAddress, address _treasuryAddress, address _earningAddress, address _nameTAOPositionAddress) public {\r\n\t\tsettingTAOId = _settingTAOId;\r\n\t\tbaseDenominationAddress = _baseDenominationAddress;\r\n\t\ttreasuryAddress = _treasuryAddress;\r\n\t\tnameTAOPositionAddress = _nameTAOPositionAddress;\r\n\r\n\t\t_baseAO = AOToken(_baseDenominationAddress);\r\n\t\t_treasury = AOTreasury(_treasuryAddress);\r\n\t\t_earning = AOEarning(_earningAddress);\r\n\t\t_aoSetting = AOSetting(_aoSettingAddress);\r\n\t\t_nameTAOPosition = NameTAOPosition(_nameTAOPositionAddress);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Checks if the calling contract address is The AO\r\n\t *\t\tOR\r\n\t *\t\tIf The AO is set to a Name/TAO, then check if calling address is the Advocate\r\n\t */\r\n\tmodifier onlyTheAO {\r\n\t\trequire (AOLibrary.isTheAO(msg.sender, theAO, nameTAOPositionAddress));\r\n\t\t_;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Checks if contract is currently active\r\n\t */\r\n\tmodifier isContractActive {\r\n\t\trequire (paused == false && killed == false);\r\n\t\t_;\r\n\t}\r\n\r\n\t/***** The AO ONLY METHODS *****/\r\n\t/**\r\n\t * @dev Transfer ownership of The AO to new address\r\n\t * @param _theAO The new address to be transferred\r\n\t */\r\n\tfunction transferOwnership(address _theAO) public onlyTheAO {\r\n\t\trequire (_theAO != address(0));\r\n\t\ttheAO = _theAO;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Whitelist `_account` address to transact on behalf of others\r\n\t * @param _account The address to whitelist\r\n\t * @param _whitelist Either to whitelist or not\r\n\t */\r\n\tfunction setWhitelist(address _account, bool _whitelist) public onlyTheAO {\r\n\t\trequire (_account != address(0));\r\n\t\twhitelist[_account] = _whitelist;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev The AO pauses/unpauses contract\r\n\t * @param _paused Either to pause contract or not\r\n\t */\r\n\tfunction setPaused(bool _paused) public onlyTheAO {\r\n\t\tpaused = _paused;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev The AO triggers emergency mode.\r\n\t *\r\n\t */\r\n\tfunction escapeHatch() public onlyTheAO {\r\n\t\trequire (killed == false);\r\n\t\tkilled = true;\r\n\t\temit EscapeHatch();\r\n\t}\r\n\r\n\t/**\r\n\t * @dev The AO updates base denomination address\r\n\t * @param _newBaseDenominationAddress The new address\r\n\t */\r\n\tfunction setBaseDenominationAddress(address _newBaseDenominationAddress) public onlyTheAO {\r\n\t\trequire (AOToken(_newBaseDenominationAddress).powerOfTen() == 0);\r\n\t\tbaseDenominationAddress = _newBaseDenominationAddress;\r\n\t\t_baseAO = AOToken(baseDenominationAddress);\r\n\t}\r\n\r\n\t/***** PUBLIC METHODS *****/\r\n\t/**\r\n\t * @dev Stake `_networkIntegerAmount` + `_networkFractionAmount` of network token in `_denomination` and/or `_primordialAmount` primordial Tokens for an AO Content\r\n\t * @param _networkIntegerAmount The integer amount of network token to stake\r\n\t * @param _networkFractionAmount The fraction amount of network token to stake\r\n\t * @param _denomination The denomination of the network token, i.e ao, kilo, mega, etc.\r\n\t * @param _primordialAmount The amount of primordial Token to stake\r\n\t * @param _baseChallenge The base challenge string (PUBLIC KEY) of the content\r\n\t * @param _encChallenge The encrypted challenge string (PUBLIC KEY) of the content unique to the host\r\n\t * @param _contentDatKey The dat key of the content\r\n\t * @param _metadataDatKey The dat key of the content's metadata\r\n\t * @param _fileSize The size of the file\r\n\t * @param _profitPercentage The percentage of profit the stake owner's media will charge\r\n\t */\r\n\tfunction stakeAOContent(\r\n\t\tuint256 _networkIntegerAmount,\r\n\t\tuint256 _networkFractionAmount,\r\n\t\tbytes8 _denomination,\r\n\t\tuint256 _primordialAmount,\r\n\t\tstring _baseChallenge,\r\n\t\tstring _encChallenge,\r\n\t\tstring _contentDatKey,\r\n\t\tstring _metadataDatKey,\r\n\t\tuint256 _fileSize,\r\n\t\tuint256 _profitPercentage)\r\n\t\tpublic isContractActive {\r\n\t\trequire (AOLibrary.canStake(treasuryAddress, _networkIntegerAmount, _networkFractionAmount, _denomination, _primordialAmount, _baseChallenge, _encChallenge, _contentDatKey, _metadataDatKey, _fileSize, _profitPercentage));\r\n\t\t(bytes32 _contentUsageType_aoContent,,,,,) = _getSettingVariables();\r\n\r\n\t\t/**\r\n\t\t * 1. Store this content\r\n\t\t * 2. Stake the network/primordial token on content\r\n\t\t * 3. Add the node info that hosts this content (in this case the creator himself)\r\n\t\t */\r\n\t\t_hostContent(\r\n\t\t\tmsg.sender,\r\n\t\t\t_stakeContent(\r\n\t\t\t\tmsg.sender,\r\n\t\t\t\t_storeContent(\r\n\t\t\t\t\tmsg.sender,\r\n\t\t\t\t\t_baseChallenge,\r\n\t\t\t\t\t_fileSize,\r\n\t\t\t\t\t_contentUsageType_aoContent,\r\n\t\t\t\t\taddress(0)\r\n\t\t\t\t),\r\n\t\t\t\t_networkIntegerAmount,\r\n\t\t\t\t_networkFractionAmount,\r\n\t\t\t\t_denomination,\r\n\t\t\t\t_primordialAmount,\r\n\t\t\t\t_profitPercentage\r\n\t\t\t),\r\n\t\t\t_encChallenge,\r\n\t\t\t_contentDatKey,\r\n\t\t\t_metadataDatKey\r\n\t\t);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Stake `_networkIntegerAmount` + `_networkFractionAmount` of network token in `_denomination` and/or `_primordialAmount` primordial Tokens for a Creative Commons Content\r\n\t * @param _networkIntegerAmount The integer amount of network token to stake\r\n\t * @param _networkFractionAmount The fraction amount of network token to stake\r\n\t * @param _denomination The denomination of the network token, i.e ao, kilo, mega, etc.\r\n\t * @param _primordialAmount The amount of primordial Token to stake\r\n\t * @param _baseChallenge The base challenge string (PUBLIC KEY) of the content\r\n\t * @param _encChallenge The encrypted challenge string (PUBLIC KEY) of the content unique to the host\r\n\t * @param _contentDatKey The dat key of the content\r\n\t * @param _metadataDatKey The dat key of the content's metadata\r\n\t * @param _fileSize The size of the file\r\n\t */\r\n\tfunction stakeCreativeCommonsContent(\r\n\t\tuint256 _networkIntegerAmount,\r\n\t\tuint256 _networkFractionAmount,\r\n\t\tbytes8 _denomination,\r\n\t\tuint256 _primordialAmount,\r\n\t\tstring _baseChallenge,\r\n\t\tstring _encChallenge,\r\n\t\tstring _contentDatKey,\r\n\t\tstring _metadataDatKey,\r\n\t\tuint256 _fileSize)\r\n\t\tpublic isContractActive {\r\n\t\trequire (AOLibrary.canStake(treasuryAddress, _networkIntegerAmount, _networkFractionAmount, _denomination, _primordialAmount, _baseChallenge, _encChallenge, _contentDatKey, _metadataDatKey, _fileSize, 0));\r\n\t\trequire (_treasury.toBase(_networkIntegerAmount, _networkFractionAmount, _denomination).add(_primordialAmount) == _fileSize);\r\n\r\n\t\t(,bytes32 _contentUsageType_creativeCommons,,,,) = _getSettingVariables();\r\n\r\n\t\t/**\r\n\t\t * 1. Store this content\r\n\t\t * 2. Stake the network/primordial token on content\r\n\t\t * 3. Add the node info that hosts this content (in this case the creator himself)\r\n\t\t */\r\n\t\t_hostContent(\r\n\t\t\tmsg.sender,\r\n\t\t\t_stakeContent(\r\n\t\t\t\tmsg.sender,\r\n\t\t\t\t_storeContent(\r\n\t\t\t\t\tmsg.sender,\r\n\t\t\t\t\t_baseChallenge,\r\n\t\t\t\t\t_fileSize,\r\n\t\t\t\t\t_contentUsageType_creativeCommons,\r\n\t\t\t\t\taddress(0)\r\n\t\t\t\t),\r\n\t\t\t\t_networkIntegerAmount,\r\n\t\t\t\t_networkFractionAmount,\r\n\t\t\t\t_denomination,\r\n\t\t\t\t_primordialAmount,\r\n\t\t\t\t0\r\n\t\t\t),\r\n\t\t\t_encChallenge,\r\n\t\t\t_contentDatKey,\r\n\t\t\t_metadataDatKey\r\n\t\t);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Stake `_networkIntegerAmount` + `_networkFractionAmount` of network token in `_denomination` and/or `_primordialAmount` primordial Tokens for a T(AO) Content\r\n\t * @param _networkIntegerAmount The integer amount of network token to stake\r\n\t * @param _networkFractionAmount The fraction amount of network token to stake\r\n\t * @param _denomination The denomination of the network token, i.e ao, kilo, mega, etc.\r\n\t * @param _primordialAmount The amount of primordial Token to stake\r\n\t * @param _baseChallenge The base challenge string (PUBLIC KEY) of the content\r\n\t * @param _encChallenge The encrypted challenge string (PUBLIC KEY) of the content unique to the host\r\n\t * @param _contentDatKey The dat key of the content\r\n\t * @param _metadataDatKey The dat key of the content's metadata\r\n\t * @param _fileSize The size of the file\r\n\t * @param _taoId The TAO (TAO) ID for this content (if this is a T(AO) Content)\r\n\t */\r\n\tfunction stakeTAOContent(\r\n\t\tuint256 _networkIntegerAmount,\r\n\t\tuint256 _networkFractionAmount,\r\n\t\tbytes8 _denomination,\r\n\t\tuint256 _primordialAmount,\r\n\t\tstring _baseChallenge,\r\n\t\tstring _encChallenge,\r\n\t\tstring _contentDatKey,\r\n\t\tstring _metadataDatKey,\r\n\t\tuint256 _fileSize,\r\n\t\taddress _taoId)\r\n\t\tpublic isContractActive {\r\n\t\trequire (AOLibrary.canStake(treasuryAddress, _networkIntegerAmount, _networkFractionAmount, _denomination, _primordialAmount, _baseChallenge, _encChallenge, _contentDatKey, _metadataDatKey, _fileSize, 0));\r\n\t\trequire (\r\n\t\t\t_treasury.toBase(_networkIntegerAmount, _networkFractionAmount, _denomination).add(_primordialAmount) == _fileSize &&\r\n\t\t\t_nameTAOPosition.senderIsPosition(msg.sender, _taoId)\r\n\t\t);\r\n\r\n\t\t(,,bytes32 _contentUsageType_taoContent,,,) = _getSettingVariables();\r\n\r\n\t\t/**\r\n\t\t * 1. Store this content\r\n\t\t * 2. Stake the network/primordial token on content\r\n\t\t * 3. Add the node info that hosts this content (in this case the creator himself)\r\n\t\t */\r\n\t\t_hostContent(\r\n\t\t\tmsg.sender,\r\n\t\t\t_stakeContent(\r\n\t\t\t\tmsg.sender,\r\n\t\t\t\t_storeContent(\r\n\t\t\t\t\tmsg.sender,\r\n\t\t\t\t\t_baseChallenge,\r\n\t\t\t\t\t_fileSize,\r\n\t\t\t\t\t_contentUsageType_taoContent,\r\n\t\t\t\t\t_taoId\r\n\t\t\t\t),\r\n\t\t\t\t_networkIntegerAmount,\r\n\t\t\t\t_networkFractionAmount,\r\n\t\t\t\t_denomination,\r\n\t\t\t\t_primordialAmount,\r\n\t\t\t\t0\r\n\t\t\t),\r\n\t\t\t_encChallenge,\r\n\t\t\t_contentDatKey,\r\n\t\t\t_metadataDatKey\r\n\t\t);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Set profit percentage on existing staked content\r\n\t *\t\tWill throw error if this is a Creative Commons/T(AO) Content\r\n\t * @param _stakeId The ID of the staked content\r\n\t * @param _profitPercentage The new value to be set\r\n\t */\r\n\tfunction setProfitPercentage(bytes32 _stakeId, uint256 _profitPercentage) public isContractActive {\r\n\t\trequire (_profitPercentage <= AOLibrary.PERCENTAGE_DIVISOR());\r\n\r\n\t\t// Make sure the staked content exist\r\n\t\trequire (stakedContentIndex[_stakeId] > 0);\r\n\r\n\t\tStakedContent storage _stakedContent = stakedContents[stakedContentIndex[_stakeId]];\r\n\t\t// Make sure the staked content owner is the same as the sender\r\n\t\trequire (_stakedContent.stakeOwner == msg.sender);\r\n\r\n\t\t// Make sure we are updating profit percentage for AO Content only\r\n\t\t// Creative Commons/T(AO) Content has 0 profit percentage\r\n\t\trequire (_isAOContentUsageType(_stakedContent.contentId));\r\n\r\n\t\t_stakedContent.profitPercentage = _profitPercentage;\r\n\r\n\t\temit SetProfitPercentage(msg.sender, _stakeId, _profitPercentage);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Set extra data on existing content\r\n\t * @param _contentId The ID of the content\r\n\t * @param _extraData some extra information to send to the contract for a content\r\n\t */\r\n\tfunction setContentExtraData(bytes32 _contentId, string _extraData) public isContractActive {\r\n\t\t// Make sure the content exist\r\n\t\trequire (contentIndex[_contentId] > 0);\r\n\r\n\t\tContent storage _content = contents[contentIndex[_contentId]];\r\n\t\t// Make sure the content creator is the same as the sender\r\n\t\trequire (_content.creator == msg.sender);\r\n\r\n\t\t_content.extraData = _extraData;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Return content info at a given ID\r\n\t * @param _contentId The ID of the content\r\n\t * @return address of the creator\r\n\t * @return file size of the content\r\n\t * @return the content usage type, i.e AO Content, Creative Commons, or T(AO) Content\r\n\t * @return The TAO ID for this content (if this is a T(AO) Content)\r\n\t * @return The TAO Content state, i.e Submitted, Pending Review, or Accepted to TAO\r\n\t * @return The V part of signature that is used to update the TAO Content State\r\n\t * @return The R part of signature that is used to update the TAO Content State\r\n\t * @return The S part of signature that is used to update the TAO Content State\r\n\t * @return the extra information sent to the contract when creating a content\r\n\t */\r\n\tfunction contentById(bytes32 _contentId) public view returns (address, uint256, bytes32, address, bytes32, uint8, bytes32, bytes32, string) {\r\n\t\t// Make sure the content exist\r\n\t\trequire (contentIndex[_contentId] > 0);\r\n\t\tContent memory _content = contents[contentIndex[_contentId]];\r\n\t\treturn (\r\n\t\t\t_content.creator,\r\n\t\t\t_content.fileSize,\r\n\t\t\t_content.contentUsageType,\r\n\t\t\t_content.taoId,\r\n\t\t\t_content.taoContentState,\r\n\t\t\t_content.updateTAOContentStateV,\r\n\t\t\t_content.updateTAOContentStateR,\r\n\t\t\t_content.updateTAOContentStateS,\r\n\t\t\t_content.extraData\r\n\t\t);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Return content host info at a given ID\r\n\t * @param _contentHostId The ID of the hosted content\r\n\t * @return The ID of the staked content\r\n\t * @return address of the host\r\n\t * @return the dat key of the content\r\n\t * @return the dat key of the content's metadata\r\n\t */\r\n\tfunction contentHostById(bytes32 _contentHostId) public view returns (bytes32, address, string, string) {\r\n\t\t// Make sure the content host exist\r\n\t\trequire (contentHostIndex[_contentHostId] > 0);\r\n\t\tContentHost memory _contentHost = contentHosts[contentHostIndex[_contentHostId]];\r\n\t\treturn (\r\n\t\t\t_contentHost.stakeId,\r\n\t\t\t_contentHost.host,\r\n\t\t\t_contentHost.contentDatKey,\r\n\t\t\t_contentHost.metadataDatKey\r\n\t\t);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Return staked content information at a given ID\r\n\t * @param _stakeId The ID of the staked content\r\n\t * @return The ID of the content being staked\r\n\t * @return address of the staked content's owner\r\n\t * @return the network base token amount staked for this content\r\n\t * @return the primordial token amount staked for this content\r\n\t * @return the primordial weighted multiplier of the staked content\r\n\t * @return the profit percentage of the content\r\n\t * @return status of the staked content\r\n\t * @return the timestamp when the staked content was created\r\n\t */\r\n\tfunction stakedContentById(bytes32 _stakeId) public view returns (bytes32, address, uint256, uint256, uint256, uint256, bool, uint256) {\r\n\t\t// Make sure the staked content exist\r\n\t\trequire (stakedContentIndex[_stakeId] > 0);\r\n\r\n\t\tStakedContent memory _stakedContent = stakedContents[stakedContentIndex[_stakeId]];\r\n\t\treturn (\r\n\t\t\t_stakedContent.contentId,\r\n\t\t\t_stakedContent.stakeOwner,\r\n\t\t\t_stakedContent.networkAmount,\r\n\t\t\t_stakedContent.primordialAmount,\r\n\t\t\t_stakedContent.primordialWeightedMultiplier,\r\n\t\t\t_stakedContent.profitPercentage,\r\n\t\t\t_stakedContent.active,\r\n\t\t\t_stakedContent.createdOnTimestamp\r\n\t\t);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Unstake existing staked content and refund partial staked amount to the stake owner\r\n\t *\t\tUse unstakeContent() to unstake all staked token amount. unstakePartialContent() can unstake only up to\r\n\t *\t\tthe mininum required to pay the fileSize\r\n\t * @param _stakeId The ID of the staked content\r\n\t * @param _networkIntegerAmount The integer amount of network token to unstake\r\n\t * @param _networkFractionAmount The fraction amount of network token to unstake\r\n\t * @param _denomination The denomination of the network token, i.e ao, kilo, mega, etc.\r\n\t * @param _primordialAmount The amount of primordial Token to unstake\r\n\t */\r\n\tfunction unstakePartialContent(bytes32 _stakeId, uint256 _networkIntegerAmount, uint256 _networkFractionAmount, bytes8 _denomination, uint256 _primordialAmount) public isContractActive {\r\n\t\t// Make sure the staked content exist\r\n\t\trequire (stakedContentIndex[_stakeId] > 0);\r\n\t\trequire (_networkIntegerAmount > 0 || _networkFractionAmount > 0 || _primordialAmount > 0);\r\n\r\n\t\tStakedContent storage _stakedContent = stakedContents[stakedContentIndex[_stakeId]];\r\n\t\tuint256 _fileSize = contents[contentIndex[_stakedContent.contentId]].fileSize;\r\n\r\n\t\t// Make sure the staked content owner is the same as the sender\r\n\t\trequire (_stakedContent.stakeOwner == msg.sender);\r\n\t\t// Make sure the staked content is currently active (staked) with some amounts\r\n\t\trequire (_stakedContent.active == true && (_stakedContent.networkAmount > 0 || (_stakedContent.primordialAmount > 0 && _stakedContent.primordialWeightedMultiplier > 0)));\r\n\t\t// Make sure the staked content has enough balance to unstake\r\n\t\trequire (AOLibrary.canUnstakePartial(treasuryAddress, _networkIntegerAmount, _networkFractionAmount, _denomination, _primordialAmount, _stakedContent.networkAmount, _stakedContent.primordialAmount, _fileSize));\r\n\r\n\t\tif (_denomination[0] != 0 && (_networkIntegerAmount > 0 || _networkFractionAmount > 0)) {\r\n\t\t\tuint256 _unstakeNetworkAmount = _treasury.toBase(_networkIntegerAmount, _networkFractionAmount, _denomination);\r\n\t\t\t_stakedContent.networkAmount = _stakedContent.networkAmount.sub(_unstakeNetworkAmount);\r\n\t\t\trequire (_baseAO.unstakeFrom(msg.sender, _unstakeNetworkAmount));\r\n\t\t}\r\n\t\tif (_primordialAmount > 0) {\r\n\t\t\t_stakedContent.primordialAmount = _stakedContent.primordialAmount.sub(_primordialAmount);\r\n\t\t\trequire (_baseAO.unstakePrimordialTokenFrom(msg.sender, _primordialAmount, _stakedContent.primordialWeightedMultiplier));\r\n\t\t}\r\n\t\temit UnstakePartialContent(_stakedContent.stakeOwner, _stakedContent.stakeId, _stakedContent.contentId, _stakedContent.networkAmount, _stakedContent.primordialAmount, _stakedContent.primordialWeightedMultiplier);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Unstake existing staked content and refund the total staked amount to the stake owner\r\n\t * @param _stakeId The ID of the staked content\r\n\t */\r\n\tfunction unstakeContent(bytes32 _stakeId) public isContractActive {\r\n\t\t// Make sure the staked content exist\r\n\t\trequire (stakedContentIndex[_stakeId] > 0);\r\n\r\n\t\tStakedContent storage _stakedContent = stakedContents[stakedContentIndex[_stakeId]];\r\n\t\t// Make sure the staked content owner is the same as the sender\r\n\t\trequire (_stakedContent.stakeOwner == msg.sender);\r\n\t\t// Make sure the staked content is currently active (staked) with some amounts\r\n\t\trequire (_stakedContent.active == true && (_stakedContent.networkAmount > 0 || (_stakedContent.primordialAmount > 0 && _stakedContent.primordialWeightedMultiplier > 0)));\r\n\r\n\t\t_stakedContent.active = false;\r\n\r\n\t\tif (_stakedContent.networkAmount > 0) {\r\n\t\t\tuint256 _unstakeNetworkAmount = _stakedContent.networkAmount;\r\n\t\t\t_stakedContent.networkAmount = 0;\r\n\t\t\trequire (_baseAO.unstakeFrom(msg.sender, _unstakeNetworkAmount));\r\n\t\t}\r\n\t\tif (_stakedContent.primordialAmount > 0) {\r\n\t\t\tuint256 _primordialAmount = _stakedContent.primordialAmount;\r\n\t\t\tuint256 _primordialWeightedMultiplier = _stakedContent.primordialWeightedMultiplier;\r\n\t\t\t_stakedContent.primordialAmount = 0;\r\n\t\t\t_stakedContent.primordialWeightedMultiplier = 0;\r\n\t\t\trequire (_baseAO.unstakePrimordialTokenFrom(msg.sender, _primordialAmount, _primordialWeightedMultiplier));\r\n\t\t}\r\n\t\temit UnstakeContent(_stakedContent.stakeOwner, _stakeId);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Stake existing content with more tokens (this is to increase the price)\r\n\t *\r\n\t * @param _stakeId The ID of the staked content\r\n\t * @param _networkIntegerAmount The integer amount of network token to stake\r\n\t * @param _networkFractionAmount The fraction amount of network token to stake\r\n\t * @param _denomination The denomination of the network token, i.e ao, kilo, mega, etc.\r\n\t * @param _primordialAmount The amount of primordial Token to stake. (The primordial weighted multiplier has to match the current staked weighted multiplier)\r\n\t */\r\n\tfunction stakeExistingContent(bytes32 _stakeId, uint256 _networkIntegerAmount, uint256 _networkFractionAmount, bytes8 _denomination, uint256 _primordialAmount) public isContractActive {\r\n\t\t// Make sure the staked content exist\r\n\t\trequire (stakedContentIndex[_stakeId] > 0);\r\n\r\n\t\tStakedContent storage _stakedContent = stakedContents[stakedContentIndex[_stakeId]];\r\n\t\tuint256 _fileSize = contents[contentIndex[_stakedContent.contentId]].fileSize;\r\n\r\n\t\t// Make sure the staked content owner is the same as the sender\r\n\t\trequire (_stakedContent.stakeOwner == msg.sender);\r\n\t\trequire (_networkIntegerAmount > 0 || _networkFractionAmount > 0 || _primordialAmount > 0);\r\n\t\trequire (AOLibrary.canStakeExisting(treasuryAddress, _isAOContentUsageType(_stakedContent.contentId), _fileSize, _stakedContent.networkAmount.add(_stakedContent.primordialAmount), _networkIntegerAmount, _networkFractionAmount, _denomination, _primordialAmount));\r\n\r\n\t\t// Make sure we can stake primordial token\r\n\t\t// If we are currently staking an active staked content, then the stake owner's weighted multiplier has to match `stakedContent.primordialWeightedMultiplier`\r\n\t\t// i.e, can't use a combination of different weighted multiplier. Stake owner has to call unstakeContent() to unstake all tokens first\r\n\t\tif (_primordialAmount > 0 && _stakedContent.active && _stakedContent.primordialAmount > 0 && _stakedContent.primordialWeightedMultiplier > 0) {\r\n\t\t\trequire (_baseAO.weightedMultiplierByAddress(msg.sender) == _stakedContent.primordialWeightedMultiplier);\r\n\t\t}\r\n\r\n\t\t_stakedContent.active = true;\r\n\t\tif (_denomination[0] != 0 && (_networkIntegerAmount > 0 || _networkFractionAmount > 0)) {\r\n\t\t\tuint256 _stakeNetworkAmount = _treasury.toBase(_networkIntegerAmount, _networkFractionAmount, _denomination);\r\n\t\t\t_stakedContent.networkAmount = _stakedContent.networkAmount.add(_stakeNetworkAmount);\r\n\t\t\trequire (_baseAO.stakeFrom(_stakedContent.stakeOwner, _stakeNetworkAmount));\r\n\t\t}\r\n\t\tif (_primordialAmount > 0) {\r\n\t\t\t_stakedContent.primordialAmount = _stakedContent.primordialAmount.add(_primordialAmount);\r\n\r\n\t\t\t// Primordial Token is the base AO Token\r\n\t\t\t_stakedContent.primordialWeightedMultiplier = _baseAO.weightedMultiplierByAddress(_stakedContent.stakeOwner);\r\n\t\t\trequire (_baseAO.stakePrimordialTokenFrom(_stakedContent.stakeOwner, _primordialAmount, _stakedContent.primordialWeightedMultiplier));\r\n\t\t}\r\n\r\n\t\temit StakeExistingContent(msg.sender, _stakedContent.stakeId, _stakedContent.contentId, _stakedContent.networkAmount, _stakedContent.primordialAmount, _stakedContent.primordialWeightedMultiplier);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Determine the content price hosted by a host\r\n\t * @param _contentHostId The content host ID to be checked\r\n\t * @return the price of the content\r\n\t */\r\n\tfunction contentHostPrice(bytes32 _contentHostId) public isContractActive view returns (uint256) {\r\n\t\t// Make sure content host exist\r\n\t\trequire (contentHostIndex[_contentHostId] > 0);\r\n\r\n\t\tbytes32 _stakeId = contentHosts[contentHostIndex[_contentHostId]].stakeId;\r\n\t\tStakedContent memory _stakedContent = stakedContents[stakedContentIndex[_stakeId]];\r\n\t\t// Make sure content is currently staked\r\n\t\trequire (_stakedContent.active == true && (_stakedContent.networkAmount > 0 || (_stakedContent.primordialAmount > 0 && _stakedContent.primordialWeightedMultiplier > 0)));\r\n\t\treturn _stakedContent.networkAmount.add(_stakedContent.primordialAmount);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Determine the how much the content is paid by AO given a contentHostId\r\n\t * @param _contentHostId The content host ID to be checked\r\n\t * @return the amount paid by AO\r\n\t */\r\n\tfunction contentHostPaidByAO(bytes32 _contentHostId) public isContractActive view returns (uint256) {\r\n\t\tbytes32 _stakeId = contentHosts[contentHostIndex[_contentHostId]].stakeId;\r\n\t\tbytes32 _contentId = stakedContents[stakedContentIndex[_stakeId]].contentId;\r\n\t\tif (_isAOContentUsageType(_contentId)) {\r\n\t\t\treturn 0;\r\n\t\t} else {\r\n\t\t\treturn contentHostPrice(_contentHostId);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Bring content in to the requesting node by sending network tokens to the contract to pay for the content\r\n\t * @param _contentHostId The ID of hosted content\r\n\t * @param _networkIntegerAmount The integer amount of network token to pay\r\n\t * @param _networkFractionAmount The fraction amount of network token to pay\r\n\t * @param _denomination The denomination of the network token, i.e ao, kilo, mega, etc.\r\n\t * @param _publicKey The public key of the request node\r\n\t * @param _publicAddress The public address of the request node\r\n\t */\r\n\tfunction buyContent(bytes32 _contentHostId, uint256 _networkIntegerAmount, uint256 _networkFractionAmount, bytes8 _denomination, string _publicKey, address _publicAddress) public isContractActive {\r\n\t\t// Make sure the content host exist\r\n\t\trequire (contentHostIndex[_contentHostId] > 0);\r\n\r\n\t\t// Make sure public key is not empty\r\n\t\trequire (bytes(_publicKey).length > 0);\r\n\r\n\t\t// Make sure public address is valid\r\n\t\trequire (_publicAddress != address(0));\r\n\r\n\t\tContentHost memory _contentHost = contentHosts[contentHostIndex[_contentHostId]];\r\n\t\tStakedContent memory _stakedContent = stakedContents[stakedContentIndex[_contentHost.stakeId]];\r\n\r\n\t\t// Make sure the content currently has stake\r\n\t\trequire (_stakedContent.active == true && (_stakedContent.networkAmount > 0 || (_stakedContent.primordialAmount > 0 && _stakedContent.primordialWeightedMultiplier > 0)));\r\n\r\n\t\t// Make sure the buyer has not bought this content previously\r\n\t\trequire (buyerPurchaseReceipts[msg.sender][_contentHostId][0] == 0);\r\n\r\n\t\t// Make sure the token amount can pay for the content price\r\n\t\tif (_isAOContentUsageType(_stakedContent.contentId)) {\r\n\t\t\trequire (AOLibrary.canBuy(treasuryAddress, _stakedContent.networkAmount.add(_stakedContent.primordialAmount), _networkIntegerAmount, _networkFractionAmount, _denomination));\r\n\t\t}\r\n\r\n\t\t// Increment totalPurchaseReceipts;\r\n\t\ttotalPurchaseReceipts++;\r\n\r\n\t\t// Generate purchaseId\r\n\t\tbytes32 _purchaseId = keccak256(abi.encodePacked(this, msg.sender, _contentHostId));\r\n\t\tPurchaseReceipt storage _purchaseReceipt = purchaseReceipts[totalPurchaseReceipts];\r\n\r\n\t\t// Make sure the node doesn't buy the same content twice\r\n\t\trequire (_purchaseReceipt.buyer == address(0));\r\n\r\n\t\t_purchaseReceipt.purchaseId = _purchaseId;\r\n\t\t_purchaseReceipt.contentHostId = _contentHostId;\r\n\t\t_purchaseReceipt.buyer = msg.sender;\r\n\t\t// Update the receipt with the correct network amount\r\n\t\t_purchaseReceipt.price = _stakedContent.networkAmount.add(_stakedContent.primordialAmount);\r\n\t\t_purchaseReceipt.amountPaidByAO = contentHostPaidByAO(_contentHostId);\r\n\t\t_purchaseReceipt.amountPaidByBuyer = _purchaseReceipt.price.sub(_purchaseReceipt.amountPaidByAO);\r\n\t\t_purchaseReceipt.publicKey = _publicKey;\r\n\t\t_purchaseReceipt.publicAddress = _publicAddress;\r\n\t\t_purchaseReceipt.createdOnTimestamp = now;\r\n\r\n\t\tpurchaseReceiptIndex[_purchaseId] = totalPurchaseReceipts;\r\n\t\tbuyerPurchaseReceipts[msg.sender][_contentHostId] = _purchaseId;\r\n\r\n\t\t// Calculate content creator/host/The AO earning from this purchase and store them in escrow\r\n\t\trequire (_earning.calculateEarning(\r\n\t\t\tmsg.sender,\r\n\t\t\t_purchaseId,\r\n\t\t\t_stakedContent.networkAmount,\r\n\t\t\t_stakedContent.primordialAmount,\r\n\t\t\t_stakedContent.primordialWeightedMultiplier,\r\n\t\t\t_stakedContent.profitPercentage,\r\n\t\t\t_stakedContent.stakeOwner,\r\n\t\t\t_contentHost.host,\r\n\t\t\t_isAOContentUsageType(_stakedContent.contentId)\r\n\t\t));\r\n\r\n\t\temit BuyContent(_purchaseReceipt.buyer, _purchaseReceipt.purchaseId, _purchaseReceipt.contentHostId, _purchaseReceipt.price, _purchaseReceipt.amountPaidByAO, _purchaseReceipt.amountPaidByBuyer, _purchaseReceipt.publicKey, _purchaseReceipt.publicAddress, _purchaseReceipt.createdOnTimestamp);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Return purchase receipt info at a given ID\r\n\t * @param _purchaseId The ID of the purchased content\r\n\t * @return The ID of the content host\r\n\t * @return address of the buyer\r\n\t * @return price of the content\r\n\t * @return amount paid by AO\r\n\t * @return amount paid by Buyer\r\n\t * @return request node's public key\r\n\t * @return request node's public address\r\n\t * @return created on timestamp\r\n\t */\r\n\tfunction purchaseReceiptById(bytes32 _purchaseId) public view returns (bytes32, address, uint256, uint256, uint256, string, address, uint256) {\r\n\t\t// Make sure the purchase receipt exist\r\n\t\trequire (purchaseReceiptIndex[_purchaseId] > 0);\r\n\t\tPurchaseReceipt memory _purchaseReceipt = purchaseReceipts[purchaseReceiptIndex[_purchaseId]];\r\n\t\treturn (\r\n\t\t\t_purchaseReceipt.contentHostId,\r\n\t\t\t_purchaseReceipt.buyer,\r\n\t\t\t_purchaseReceipt.price,\r\n\t\t\t_purchaseReceipt.amountPaidByAO,\r\n\t\t\t_purchaseReceipt.amountPaidByBuyer,\r\n\t\t\t_purchaseReceipt.publicKey,\r\n\t\t\t_purchaseReceipt.publicAddress,\r\n\t\t\t_purchaseReceipt.createdOnTimestamp\r\n\t\t);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Request node wants to become a distribution node after buying the content\r\n\t *\t\tAlso, if this transaction succeeds, contract will release all of the earnings that are\r\n\t *\t\tcurrently in escrow for content creator/host/The AO\r\n\t */\r\n\tfunction becomeHost(\r\n\t\tbytes32 _purchaseId,\r\n\t\tuint8 _baseChallengeV,\r\n\t\tbytes32 _baseChallengeR,\r\n\t\tbytes32 _baseChallengeS,\r\n\t\tstring _encChallenge,\r\n\t\tstring _contentDatKey,\r\n\t\tstring _metadataDatKey\r\n\t) public isContractActive {\r\n\t\t// Make sure the purchase receipt exist\r\n\t\trequire (purchaseReceiptIndex[_purchaseId] > 0);\r\n\r\n\t\tPurchaseReceipt memory _purchaseReceipt = purchaseReceipts[purchaseReceiptIndex[_purchaseId]];\r\n\t\tbytes32 _stakeId = contentHosts[contentHostIndex[_purchaseReceipt.contentHostId]].stakeId;\r\n\t\tbytes32 _contentId = stakedContents[stakedContentIndex[_stakeId]].contentId;\r\n\r\n\t\t// Make sure the purchase receipt owner is the same as the sender\r\n\t\trequire (_purchaseReceipt.buyer == msg.sender);\r\n\r\n\t\t// Verify that the file is not tampered by validating the base challenge signature\r\n\t\t// The signed base challenge key should match the one from content creator\r\n\t\tContent memory _content = contents[contentIndex[_contentId]];\r\n\t\trequire (AOLibrary.getBecomeHostSignatureAddress(address(this), _content.baseChallenge, _baseChallengeV, _baseChallengeR, _baseChallengeS) == _purchaseReceipt.publicAddress);\r\n\r\n\t\t_hostContent(msg.sender, _stakeId, _encChallenge, _contentDatKey, _metadataDatKey);\r\n\r\n\t\t// Release earning from escrow\r\n\t\trequire (_earning.releaseEarning(\r\n\t\t\t_stakeId,\r\n\t\t\t_purchaseReceipt.contentHostId,\r\n\t\t\t_purchaseId,\r\n\t\t\t(_purchaseReceipt.amountPaidByBuyer > _content.fileSize),\r\n\t\t\tstakedContents[stakedContentIndex[_stakeId]].stakeOwner,\r\n\t\t\tcontentHosts[contentHostIndex[_purchaseReceipt.contentHostId]].host)\r\n\t\t);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Update the TAO Content State of a T(AO) Content\r\n\t * @param _contentId The ID of the Content\r\n\t * @param _taoId The ID of the TAO that initiates the update\r\n\t * @param _taoContentState The TAO Content state value, i.e Submitted, Pending Review, or Accepted to TAO\r\n\t * @param _updateTAOContentStateV The V part of the signature for this update\r\n\t * @param _updateTAOContentStateR The R part of the signature for this update\r\n\t * @param _updateTAOContentStateS The S part of the signature for this update\r\n\t */\r\n\tfunction updateTAOContentState(\r\n\t\tbytes32 _contentId,\r\n\t\taddress _taoId,\r\n\t\tbytes32 _taoContentState,\r\n\t\tuint8 _updateTAOContentStateV,\r\n\t\tbytes32 _updateTAOContentStateR,\r\n\t\tbytes32 _updateTAOContentStateS\r\n\t) public isContractActive {\r\n\t\t// Make sure the content exist\r\n\t\trequire (contentIndex[_contentId] > 0);\r\n\t\trequire (AOLibrary.isTAO(_taoId));\r\n\t\t(,, bytes32 _contentUsageType_taoContent, bytes32 taoContentState_submitted, bytes32 taoContentState_pendingReview, bytes32 taoContentState_acceptedToTAO) = _getSettingVariables();\r\n\t\trequire (_taoContentState == taoContentState_submitted || _taoContentState == taoContentState_pendingReview || _taoContentState == taoContentState_acceptedToTAO);\r\n\r\n\t\taddress _signatureAddress = AOLibrary.getUpdateTAOContentStateSignatureAddress(address(this), _contentId, _taoId, _taoContentState, _updateTAOContentStateV, _updateTAOContentStateR, _updateTAOContentStateS);\r\n\r\n\t\tContent storage _content = contents[contentIndex[_contentId]];\r\n\t\t// Make sure that the signature address is one of content's TAO ID's Advocate/Listener/Speaker\r\n\t\trequire (_signatureAddress == msg.sender && _nameTAOPosition.senderIsPosition(_signatureAddress, _content.taoId));\r\n\t\trequire (_content.contentUsageType == _contentUsageType_taoContent);\r\n\r\n\t\t_content.taoContentState = _taoContentState;\r\n\t\t_content.updateTAOContentStateV = _updateTAOContentStateV;\r\n\t\t_content.updateTAOContentStateR = _updateTAOContentStateR;\r\n\t\t_content.updateTAOContentStateS = _updateTAOContentStateS;\r\n\r\n\t\temit UpdateTAOContentState(_contentId, _taoId, _signatureAddress, _taoContentState);\r\n\t}\r\n\r\n\t/***** INTERNAL METHODS *****/\r\n\t/**\r\n\t * @dev Store the content information (content creation during staking)\r\n\t * @param _creator the address of the content creator\r\n\t * @param _baseChallenge The base challenge string (PUBLIC KEY) of the content\r\n\t * @param _fileSize The size of the file\r\n\t * @param _contentUsageType The content usage type, i.e AO Content, Creative Commons, or T(AO) Content\r\n\t * @param _taoId The TAO (TAO) ID for this content (if this is a T(AO) Content)\r\n\t * @return the ID of the content\r\n\t */\r\n\tfunction _storeContent(address _creator, string _baseChallenge, uint256 _fileSize, bytes32 _contentUsageType, address _taoId) internal returns (bytes32) {\r\n\t\t// Increment totalContents\r\n\t\ttotalContents++;\r\n\r\n\t\t// Generate contentId\r\n\t\tbytes32 _contentId = keccak256(abi.encodePacked(this, _creator, totalContents));\r\n\t\tContent storage _content = contents[totalContents];\r\n\r\n\t\t// Make sure the node does't store the same content twice\r\n\t\trequire (_content.creator == address(0));\r\n\r\n\t\t(,,bytes32 contentUsageType_taoContent, bytes32 taoContentState_submitted,,) = _getSettingVariables();\r\n\r\n\t\t_content.contentId = _contentId;\r\n\t\t_content.creator = _creator;\r\n\t\t_content.baseChallenge = _baseChallenge;\r\n\t\t_content.fileSize = _fileSize;\r\n\t\t_content.contentUsageType = _contentUsageType;\r\n\r\n\t\t// If this is a TAO Content\r\n\t\tif (_contentUsageType == contentUsageType_taoContent) {\r\n\t\t\t_content.taoContentState = taoContentState_submitted;\r\n\t\t\t_content.taoId = _taoId;\r\n\t\t}\r\n\r\n\t\tcontentIndex[_contentId] = totalContents;\r\n\r\n\t\temit StoreContent(_content.creator, _content.contentId, _content.fileSize, _content.contentUsageType);\r\n\t\treturn _content.contentId;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Add the distribution node info that hosts the content\r\n\t * @param _host the address of the host\r\n\t * @param _stakeId The ID of the staked content\r\n\t * @param _encChallenge The encrypted challenge string (PUBLIC KEY) of the content unique to the host\r\n\t * @param _contentDatKey The dat key of the content\r\n\t * @param _metadataDatKey The dat key of the content's metadata\r\n\t */\r\n\tfunction _hostContent(address _host, bytes32 _stakeId, string _encChallenge, string _contentDatKey, string _metadataDatKey) internal {\r\n\t\trequire (bytes(_encChallenge).length > 0);\r\n\t\trequire (bytes(_contentDatKey).length > 0);\r\n\t\trequire (bytes(_metadataDatKey).length > 0);\r\n\t\trequire (stakedContentIndex[_stakeId] > 0);\r\n\r\n\t\t// Increment totalContentHosts\r\n\t\ttotalContentHosts++;\r\n\r\n\t\t// Generate contentId\r\n\t\tbytes32 _contentHostId = keccak256(abi.encodePacked(this, _host, _stakeId));\r\n\r\n\t\tContentHost storage _contentHost = contentHosts[totalContentHosts];\r\n\r\n\t\t// Make sure the node doesn't host the same content twice\r\n\t\trequire (_contentHost.host == address(0));\r\n\r\n\t\t_contentHost.contentHostId = _contentHostId;\r\n\t\t_contentHost.stakeId = _stakeId;\r\n\t\t_contentHost.host = _host;\r\n\t\t_contentHost.encChallenge = _encChallenge;\r\n\t\t_contentHost.contentDatKey = _contentDatKey;\r\n\t\t_contentHost.metadataDatKey = _metadataDatKey;\r\n\r\n\t\tcontentHostIndex[_contentHostId] = totalContentHosts;\r\n\r\n\t\temit HostContent(_contentHost.host, _contentHost.contentHostId, _contentHost.stakeId, _contentHost.contentDatKey, _contentHost.metadataDatKey);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev actual staking the content\r\n\t * @param _stakeOwner the address that stake the content\r\n\t * @param _contentId The ID of the content\r\n\t * @param _networkIntegerAmount The integer amount of network token to stake\r\n\t * @param _networkFractionAmount The fraction amount of network token to stake\r\n\t * @param _denomination The denomination of the network token, i.e ao, kilo, mega, etc.\r\n\t * @param _primordialAmount The amount of primordial Token to stake\r\n\t * @param _profitPercentage The percentage of profit the stake owner's media will charge\r\n\t * @return the newly created staked content ID\r\n\t */\r\n\tfunction _stakeContent(address _stakeOwner, bytes32 _contentId, uint256 _networkIntegerAmount, uint256 _networkFractionAmount, bytes8 _denomination, uint256 _primordialAmount, uint256 _profitPercentage) internal returns (bytes32) {\r\n\t\t// Increment totalStakedContents\r\n\t\ttotalStakedContents++;\r\n\r\n\t\t// Generate stakeId\r\n\t\tbytes32 _stakeId = keccak256(abi.encodePacked(this, _stakeOwner, _contentId));\r\n\t\tStakedContent storage _stakedContent = stakedContents[totalStakedContents];\r\n\r\n\t\t// Make sure the node doesn't stake the same content twice\r\n\t\trequire (_stakedContent.stakeOwner == address(0));\r\n\r\n\t\t_stakedContent.stakeId = _stakeId;\r\n\t\t_stakedContent.contentId = _contentId;\r\n\t\t_stakedContent.stakeOwner = _stakeOwner;\r\n\t\t_stakedContent.profitPercentage = _profitPercentage;\r\n\t\t_stakedContent.active = true;\r\n\t\t_stakedContent.createdOnTimestamp = now;\r\n\r\n\t\tstakedContentIndex[_stakeId] = totalStakedContents;\r\n\r\n\t\tif (_denomination[0] != 0 && (_networkIntegerAmount > 0 || _networkFractionAmount > 0)) {\r\n\t\t\t_stakedContent.networkAmount = _treasury.toBase(_networkIntegerAmount, _networkFractionAmount, _denomination);\r\n\t\t\trequire (_baseAO.stakeFrom(_stakeOwner, _stakedContent.networkAmount));\r\n\t\t}\r\n\t\tif (_primordialAmount > 0) {\r\n\t\t\t_stakedContent.primordialAmount = _primordialAmount;\r\n\r\n\t\t\t// Primordial Token is the base AO Token\r\n\t\t\t_stakedContent.primordialWeightedMultiplier = _baseAO.weightedMultiplierByAddress(_stakedContent.stakeOwner);\r\n\t\t\trequire (_baseAO.stakePrimordialTokenFrom(_stakedContent.stakeOwner, _primordialAmount, _stakedContent.primordialWeightedMultiplier));\r\n\t\t}\r\n\r\n\t\temit StakeContent(_stakedContent.stakeOwner, _stakedContent.stakeId, _stakedContent.contentId, _stakedContent.networkAmount, _stakedContent.primordialAmount, _stakedContent.primordialWeightedMultiplier, _stakedContent.profitPercentage, _stakedContent.createdOnTimestamp);\r\n\r\n\t\treturn _stakedContent.stakeId;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Get setting variables\r\n\t * @return contentUsageType_aoContent Content Usage Type = AO Content\r\n\t * @return contentUsageType_creativeCommons Content Usage Type = Creative Commons\r\n\t * @return contentUsageType_taoContent Content Usage Type = T(AO) Content\r\n\t * @return taoContentState_submitted TAO Content State = Submitted\r\n\t * @return taoContentState_pendingReview TAO Content State = Pending Review\r\n\t * @return taoContentState_acceptedToTAO TAO Content State = Accepted to TAO\r\n\t */\r\n\tfunction _getSettingVariables() internal view returns (bytes32, bytes32, bytes32, bytes32, bytes32, bytes32) {\r\n\t\t(,,,bytes32 contentUsageType_aoContent,) = _aoSetting.getSettingValuesByTAOName(settingTAOId, 'contentUsageType_aoContent');\r\n\t\t(,,,bytes32 contentUsageType_creativeCommons,) = _aoSetting.getSettingValuesByTAOName(settingTAOId, 'contentUsageType_creativeCommons');\r\n\t\t(,,,bytes32 contentUsageType_taoContent,) = _aoSetting.getSettingValuesByTAOName(settingTAOId, 'contentUsageType_taoContent');\r\n\t\t(,,,bytes32 taoContentState_submitted,) = _aoSetting.getSettingValuesByTAOName(settingTAOId, 'taoContentState_submitted');\r\n\t\t(,,,bytes32 taoContentState_pendingReview,) = _aoSetting.getSettingValuesByTAOName(settingTAOId, 'taoContentState_pendingReview');\r\n\t\t(,,,bytes32 taoContentState_acceptedToTAO,) = _aoSetting.getSettingValuesByTAOName(settingTAOId, 'taoContentState_acceptedToTAO');\r\n\r\n\t\treturn (\r\n\t\t\tcontentUsageType_aoContent,\r\n\t\t\tcontentUsageType_creativeCommons,\r\n\t\t\tcontentUsageType_taoContent,\r\n\t\t\ttaoContentState_submitted,\r\n\t\t\ttaoContentState_pendingReview,\r\n\t\t\ttaoContentState_acceptedToTAO\r\n\t\t);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Check whether or not the content is of AO Content Usage Type\r\n\t * @param _contentId The ID of the content\r\n\t * @return true if yes. false otherwise\r\n\t */\r\n\tfunction _isAOContentUsageType(bytes32 _contentId) internal view returns (bool) {\r\n\t\t(bytes32 _contentUsageType_aoContent,,,,,) = _getSettingVariables();\r\n\t\treturn contents[contentIndex[_contentId]].contentUsageType == _contentUsageType_aoContent;\r\n\t}\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title Name\r\n */\r\ncontract Name is TAO {\r\n\t/**\r\n\t * @dev Constructor function\r\n\t */\r\n\tconstructor (string _name, address _originId, string _datHash, string _database, string _keyValue, bytes32 _contentId, address _vaultAddress)\r\n\t\tTAO (_name, _originId, _datHash, _database, _keyValue, _contentId, _vaultAddress) public {\r\n\t\t// Creating Name\r\n\t\ttypeId = 1;\r\n\t}\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract Logos is TAOCurrency {\r\n\tNameTAOPosition internal _nameTAOPosition;\r\n\r\n\t// Mapping of a Name ID to the amount of Logos positioned by others to itself\r\n\t// address is the address of nameId, not the eth public address\r\n\tmapping (address => uint256) public positionFromOthers;\r\n\r\n\t// Mapping of Name ID to other Name ID and the amount of Logos positioned by itself\r\n\tmapping (address => mapping(address => uint256)) public positionToOthers;\r\n\r\n\t// Mapping of a Name ID to the total amount of Logos positioned by itself to others\r\n\tmapping (address => uint256) public totalPositionToOthers;\r\n\r\n\t// Mapping of Name ID to it's advocated TAO ID and the amount of Logos earned\r\n\tmapping (address => mapping(address => uint256)) public advocatedTAOLogos;\r\n\r\n\t// Mapping of a Name ID to the total amount of Logos earned from advocated TAO\r\n\tmapping (address => uint256) public totalAdvocatedTAOLogos;\r\n\r\n\t// Event broadcasted to public when `from` address position `value` Logos to `to`\r\n\tevent PositionFrom(address indexed from, address indexed to, uint256 value);\r\n\r\n\t// Event broadcasted to public when `from` address unposition `value` Logos from `to`\r\n\tevent UnpositionFrom(address indexed from, address indexed to, uint256 value);\r\n\r\n\t// Event broadcasted to public when `nameId` receives `amount` of Logos from advocating `taoId`\r\n\tevent AddAdvocatedTAOLogos(address indexed nameId, address indexed taoId, uint256 amount);\r\n\r\n\t// Event broadcasted to public when Logos from advocating `taoId` is transferred from `fromNameId` to `toNameId`\r\n\tevent TransferAdvocatedTAOLogos(address indexed fromNameId, address indexed toNameId, address indexed taoId, uint256 amount);\r\n\r\n\t/**\r\n\t * @dev Constructor function\r\n\t */\r\n\tconstructor(uint256 initialSupply, string tokenName, string tokenSymbol, address _nameTAOPositionAddress)\r\n\t\tTAOCurrency(initialSupply, tokenName, tokenSymbol) public {\r\n\t\tnameTAOPositionAddress = _nameTAOPositionAddress;\r\n\t\t_nameTAOPosition = NameTAOPosition(_nameTAOPositionAddress);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Check if `_taoId` is a TAO\r\n\t */\r\n\tmodifier isTAO(address _taoId) {\r\n\t\trequire (AOLibrary.isTAO(_taoId));\r\n\t\t_;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Check if `_nameId` is a Name\r\n\t */\r\n\tmodifier isName(address _nameId) {\r\n\t\trequire (AOLibrary.isName(_nameId));\r\n\t\t_;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Check if msg.sender is the current advocate of _id\r\n\t */\r\n\tmodifier onlyAdvocate(address _id) {\r\n\t\trequire (_nameTAOPosition.senderIsAdvocate(msg.sender, _id));\r\n\t\t_;\r\n\t}\r\n\r\n\t/***** PUBLIC METHODS *****/\r\n\t/**\r\n\t * @dev Get the total sum of Logos for an address\r\n\t * @param _target The address to check\r\n\t * @return The total sum of Logos (own + positioned + advocated TAOs)\r\n\t */\r\n\tfunction sumBalanceOf(address _target) public isNameOrTAO(_target) view returns (uint256) {\r\n\t\treturn balanceOf[_target].add(positionFromOthers[_target]).add(totalAdvocatedTAOLogos[_target]);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev `_from` Name position `_value` Logos onto `_to` Name\r\n\t *\r\n\t * @param _from The address of the sender\r\n\t * @param _to The address of the recipient\r\n\t * @param _value the amount to position\r\n\t * @return true on success\r\n\t */\r\n\tfunction positionFrom(address _from, address _to, uint256 _value) public isName(_from) isName(_to) onlyAdvocate(_from) returns (bool) {\r\n\t\trequire (_from != _to);\t// Can't position Logos to itself\r\n\t\trequire (balanceOf[_from].sub(totalPositionToOthers[_from]) >= _value); // should have enough balance to position\r\n\t\trequire (positionFromOthers[_to].add(_value) >= positionFromOthers[_to]); // check for overflows\r\n\r\n\t\tuint256 previousPositionToOthers = totalPositionToOthers[_from];\r\n\t\tuint256 previousPositionFromOthers = positionFromOthers[_to];\r\n\t\tuint256 previousAvailPositionBalance = balanceOf[_from].sub(totalPositionToOthers[_from]);\r\n\r\n\t\tpositionToOthers[_from][_to] = positionToOthers[_from][_to].add(_value);\r\n\t\ttotalPositionToOthers[_from] = totalPositionToOthers[_from].add(_value);\r\n\t\tpositionFromOthers[_to] = positionFromOthers[_to].add(_value);\r\n\r\n\t\temit PositionFrom(_from, _to, _value);\r\n\t\tassert(totalPositionToOthers[_from].sub(_value) == previousPositionToOthers);\r\n\t\tassert(positionFromOthers[_to].sub(_value) == previousPositionFromOthers);\r\n\t\tassert(balanceOf[_from].sub(totalPositionToOthers[_from]) <= previousAvailPositionBalance);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev `_from` Name unposition `_value` Logos from `_to` Name\r\n\t *\r\n\t * @param _from The address of the sender\r\n\t * @param _to The address of the recipient\r\n\t * @param _value the amount to unposition\r\n\t * @return true on success\r\n\t */\r\n\tfunction unpositionFrom(address _from, address _to, uint256 _value) public isName(_from) isName(_to) onlyAdvocate(_from) returns (bool) {\r\n\t\trequire (_from != _to);\t// Can't unposition Logos to itself\r\n\t\trequire (positionToOthers[_from][_to] >= _value);\r\n\r\n\t\tuint256 previousPositionToOthers = totalPositionToOthers[_from];\r\n\t\tuint256 previousPositionFromOthers = positionFromOthers[_to];\r\n\t\tuint256 previousAvailPositionBalance = balanceOf[_from].sub(totalPositionToOthers[_from]);\r\n\r\n\t\tpositionToOthers[_from][_to] = positionToOthers[_from][_to].sub(_value);\r\n\t\ttotalPositionToOthers[_from] = totalPositionToOthers[_from].sub(_value);\r\n\t\tpositionFromOthers[_to] = positionFromOthers[_to].sub(_value);\r\n\r\n\t\temit UnpositionFrom(_from, _to, _value);\r\n\t\tassert(totalPositionToOthers[_from].add(_value) == previousPositionToOthers);\r\n\t\tassert(positionFromOthers[_to].add(_value) == previousPositionFromOthers);\r\n\t\tassert(balanceOf[_from].sub(totalPositionToOthers[_from]) >= previousAvailPositionBalance);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Add `_amount` logos earned from advocating a TAO `_taoId` to its Advocate\r\n\t * @param _taoId The ID of the advocated TAO\r\n\t * @param _amount the amount to reward\r\n\t * @return true on success\r\n\t */\r\n\tfunction addAdvocatedTAOLogos(address _taoId, uint256 _amount) public inWhitelist isTAO(_taoId) returns (bool) {\r\n\t\trequire (_amount > 0);\r\n\t\taddress _nameId = _nameTAOPosition.getAdvocate(_taoId);\r\n\r\n\t\tadvocatedTAOLogos[_nameId][_taoId] = advocatedTAOLogos[_nameId][_taoId].add(_amount);\r\n\t\ttotalAdvocatedTAOLogos[_nameId] = totalAdvocatedTAOLogos[_nameId].add(_amount);\r\n\r\n\t\temit AddAdvocatedTAOLogos(_nameId, _taoId, _amount);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Transfer logos earned from advocating a TAO `_taoId` from `_fromNameId` to `_toNameId`\r\n\t * @param _fromNameId The ID of the Name that sends the Logos\r\n\t * @param _toNameId The ID of the Name that receives the Logos\r\n\t * @param _taoId The ID of the advocated TAO\r\n\t * @return true on success\r\n\t */\r\n\tfunction transferAdvocatedTAOLogos(address _fromNameId, address _toNameId, address _taoId) public inWhitelist isName(_fromNameId) isName(_toNameId) isTAO(_taoId) returns (bool) {\r\n\t\trequire (_nameTAOPosition.nameIsAdvocate(_toNameId, _taoId));\r\n\t\trequire (advocatedTAOLogos[_fromNameId][_taoId] > 0);\r\n\t\trequire (totalAdvocatedTAOLogos[_fromNameId] >= advocatedTAOLogos[_fromNameId][_taoId]);\r\n\r\n\t\tuint256 _amount = advocatedTAOLogos[_fromNameId][_taoId];\r\n\t\tadvocatedTAOLogos[_fromNameId][_taoId] = advocatedTAOLogos[_fromNameId][_taoId].sub(_amount);\r\n\t\ttotalAdvocatedTAOLogos[_fromNameId] = totalAdvocatedTAOLogos[_fromNameId].sub(_amount);\r\n\t\tadvocatedTAOLogos[_toNameId][_taoId] = advocatedTAOLogos[_toNameId][_taoId].add(_amount);\r\n\t\ttotalAdvocatedTAOLogos[_toNameId] = totalAdvocatedTAOLogos[_toNameId].add(_amount);\r\n\r\n\t\temit TransferAdvocatedTAOLogos(_fromNameId, _toNameId, _taoId, _amount);\r\n\t\treturn true;\r\n\t}\r\n}\r\n\r\n\r\n\r\n/**\r\n * @title AOLibrary\r\n */\r\nlibrary AOLibrary {\r\n\tusing SafeMath for uint256;\r\n\r\n\tuint256 constant private _MULTIPLIER_DIVISOR = 10 ** 6; // 1000000 = 1\r\n\tuint256 constant private _PERCENTAGE_DIVISOR = 10 ** 6; // 100% = 1000000\r\n\r\n\t/**\r\n\t * @dev Check whether or not the given TAO ID is a TAO\r\n\t * @param _taoId The ID of the TAO\r\n\t * @return true if yes. false otherwise\r\n\t */\r\n\tfunction isTAO(address _taoId) public view returns (bool) {\r\n\t\treturn (_taoId != address(0) && bytes(TAO(_taoId).name()).length > 0 && TAO(_taoId).originId() != address(0) && TAO(_taoId).typeId() == 0);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Check whether or not the given Name ID is a Name\r\n\t * @param _nameId The ID of the Name\r\n\t * @return true if yes. false otherwise\r\n\t */\r\n\tfunction isName(address _nameId) public view returns (bool) {\r\n\t\treturn (_nameId != address(0) && bytes(TAO(_nameId).name()).length > 0 && Name(_nameId).originId() != address(0) && Name(_nameId).typeId() == 1);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Checks if the calling contract address is The AO\r\n\t *\t\tOR\r\n\t *\t\tIf The AO is set to a Name/TAO, then check if calling address is the Advocate\r\n\t * @param _sender The address to check\r\n\t * @param _theAO The AO address\r\n\t * @param _nameTAOPositionAddress The address of NameTAOPosition\r\n\t * @return true if yes, false otherwise\r\n\t */\r\n\tfunction isTheAO(address _sender, address _theAO, address _nameTAOPositionAddress) public view returns (bool) {\r\n\t\treturn (_sender == _theAO ||\r\n\t\t\t(\r\n\t\t\t\t(isTAO(_theAO) || isName(_theAO)) &&\r\n\t\t\t\t_nameTAOPositionAddress != address(0) &&\r\n\t\t\t\tNameTAOPosition(_nameTAOPositionAddress).senderIsAdvocate(_sender, _theAO)\r\n\t\t\t)\r\n\t\t);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Return the divisor used to correctly calculate percentage.\r\n\t *\t\tPercentage stored throughout AO contracts covers 4 decimals,\r\n\t *\t\tso 1% is 10000, 1.25% is 12500, etc\r\n\t */\r\n\tfunction PERCENTAGE_DIVISOR() public pure returns (uint256) {\r\n\t\treturn _PERCENTAGE_DIVISOR;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Return the divisor used to correctly calculate multiplier.\r\n\t *\t\tMultiplier stored throughout AO contracts covers 6 decimals,\r\n\t *\t\tso 1 is 1000000, 0.023 is 23000, etc\r\n\t */\r\n\tfunction MULTIPLIER_DIVISOR() public pure returns (uint256) {\r\n\t\treturn _MULTIPLIER_DIVISOR;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Check whether or not content creator can stake a content based on the provided params\r\n\t * @param _treasuryAddress AO treasury contract address\r\n\t * @param _networkIntegerAmount The integer amount of network token to stake\r\n\t * @param _networkFractionAmount The fraction amount of network token to stake\r\n\t * @param _denomination The denomination of the network token, i.e ao, kilo, mega, etc.\r\n\t * @param _primordialAmount The amount of primordial Token to stake\r\n\t * @param _baseChallenge The base challenge string (PUBLIC KEY) of the content\r\n\t * @param _encChallenge The encrypted challenge string (PUBLIC KEY) of the content unique to the host\r\n\t * @param _contentDatKey The dat key of the content\r\n\t * @param _metadataDatKey The dat key of the content's metadata\r\n\t * @param _fileSize The size of the file\r\n\t * @param _profitPercentage The percentage of profit the stake owner's media will charge\r\n\t * @return true if yes. false otherwise\r\n\t */\r\n\tfunction canStake(address _treasuryAddress,\r\n\t\tuint256 _networkIntegerAmount,\r\n\t\tuint256 _networkFractionAmount,\r\n\t\tbytes8 _denomination,\r\n\t\tuint256 _primordialAmount,\r\n\t\tstring _baseChallenge,\r\n\t\tstring _encChallenge,\r\n\t\tstring _contentDatKey,\r\n\t\tstring _metadataDatKey,\r\n\t\tuint256 _fileSize,\r\n\t\tuint256 _profitPercentage) public view returns (bool) {\r\n\t\treturn (\r\n\t\t\tbytes(_baseChallenge).length > 0 &&\r\n\t\t\tbytes(_encChallenge).length > 0 &&\r\n\t\t\tbytes(_contentDatKey).length > 0 &&\r\n\t\t\tbytes(_metadataDatKey).length > 0 &&\r\n\t\t\t_fileSize > 0 &&\r\n\t\t\t(_networkIntegerAmount > 0 || _networkFractionAmount > 0 || _primordialAmount > 0) &&\r\n\t\t\t_stakeAmountValid(_treasuryAddress, _networkIntegerAmount, _networkFractionAmount, _denomination, _primordialAmount, _fileSize) == true &&\r\n\t\t\t_profitPercentage <= _PERCENTAGE_DIVISOR\r\n\t\t);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Check whether or the requested unstake amount is valid\r\n\t * @param _treasuryAddress AO treasury contract address\r\n\t * @param _networkIntegerAmount The integer amount of the network token\r\n\t * @param _networkFractionAmount The fraction amount of the network token\r\n\t * @param _denomination The denomination of the the network token\r\n\t * @param _primordialAmount The amount of primordial token\r\n\t * @param _stakedNetworkAmount The current staked network token amount\r\n\t * @param _stakedPrimordialAmount The current staked primordial token amount\r\n\t * @param _stakedFileSize The file size of the staked content\r\n\t * @return true if can unstake, false otherwise\r\n\t */\r\n\tfunction canUnstakePartial(\r\n\t\taddress _treasuryAddress,\r\n\t\tuint256 _networkIntegerAmount,\r\n\t\tuint256 _networkFractionAmount,\r\n\t\tbytes8 _denomination,\r\n\t\tuint256 _primordialAmount,\r\n\t\tuint256 _stakedNetworkAmount,\r\n\t\tuint256 _stakedPrimordialAmount,\r\n\t\tuint256 _stakedFileSize) public view returns (bool) {\r\n\t\tif (\r\n\t\t\t(_denomination.length > 0 &&\r\n\t\t\t\t(_networkIntegerAmount > 0 || _networkFractionAmount > 0) &&\r\n\t\t\t\t_stakedNetworkAmount < AOTreasury(_treasuryAddress).toBase(_networkIntegerAmount, _networkFractionAmount, _denomination)\r\n\t\t\t) ||\r\n\t\t\t_stakedPrimordialAmount < _primordialAmount ||\r\n\t\t\t(\r\n\t\t\t\t_denomination.length > 0\r\n\t\t\t\t\t&& (_networkIntegerAmount > 0 || _networkFractionAmount > 0)\r\n\t\t\t\t\t&& (_stakedNetworkAmount.sub(AOTreasury(_treasuryAddress).toBase(_networkIntegerAmount, _networkFractionAmount, _denomination)).add(_stakedPrimordialAmount.sub(_primordialAmount)) < _stakedFileSize)\r\n\t\t\t) ||\r\n\t\t\t( _denomination.length == 0 && _networkIntegerAmount == 0 && _networkFractionAmount == 0 && _primordialAmount > 0 && _stakedPrimordialAmount.sub(_primordialAmount) < _stakedFileSize)\r\n\t\t) {\r\n\t\t\treturn false;\r\n\t\t} else {\r\n\t\t\treturn true;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Check whether the network token and/or primordial token is adequate to pay for existing staked content\r\n\t * @param _treasuryAddress AO treasury contract address\r\n\t * @param _isAOContentUsageType whether or not the content is of AO Content usage type\r\n\t * @param _fileSize The size of the file\r\n\t * @param _stakedAmount The total staked amount\r\n\t * @param _networkIntegerAmount The integer amount of the network token\r\n\t * @param _networkFractionAmount The fraction amount of the network token\r\n\t * @param _denomination The denomination of the the network token\r\n\t * @param _primordialAmount The amount of primordial token\r\n\t * @return true when the amount is sufficient, false otherwise\r\n\t */\r\n\tfunction canStakeExisting(\r\n\t\taddress _treasuryAddress,\r\n\t\tbool _isAOContentUsageType,\r\n\t\tuint256 _fileSize,\r\n\t\tuint256 _stakedAmount,\r\n\t\tuint256 _networkIntegerAmount,\r\n\t\tuint256 _networkFractionAmount,\r\n\t\tbytes8 _denomination,\r\n\t\tuint256 _primordialAmount\r\n\t) public view returns (bool) {\r\n\t\tif (_isAOContentUsageType) {\r\n\t\t\treturn AOTreasury(_treasuryAddress).toBase(_networkIntegerAmount, _networkFractionAmount, _denomination).add(_primordialAmount).add(_stakedAmount) >= _fileSize;\r\n\t\t} else {\r\n\t\t\treturn AOTreasury(_treasuryAddress).toBase(_networkIntegerAmount, _networkFractionAmount, _denomination).add(_primordialAmount).add(_stakedAmount) == _fileSize;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Check whether the network token is adequate to pay for existing staked content\r\n\t * @param _treasuryAddress AO treasury contract address\r\n\t * @param _price The price of the content\r\n\t * @param _networkIntegerAmount The integer amount of the network token\r\n\t * @param _networkFractionAmount The fraction amount of the network token\r\n\t * @param _denomination The denomination of the the network token\r\n\t * @return true when the amount is sufficient, false otherwise\r\n\t */\r\n\tfunction canBuy(address _treasuryAddress, uint256 _price, uint256 _networkIntegerAmount, uint256 _networkFractionAmount, bytes8 _denomination) public view returns (bool) {\r\n\t\treturn AOTreasury(_treasuryAddress).toBase(_networkIntegerAmount, _networkFractionAmount, _denomination) >= _price;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Calculate the new weighted multiplier when adding `_additionalPrimordialAmount` at `_additionalWeightedMultiplier` to the current `_currentPrimordialBalance` at `_currentWeightedMultiplier`\r\n\t * @param _currentWeightedMultiplier Account's current weighted multiplier\r\n\t * @param _currentPrimordialBalance Account's current primordial token balance\r\n\t * @param _additionalWeightedMultiplier The weighted multiplier to be added\r\n\t * @param _additionalPrimordialAmount The primordial token amount to be added\r\n\t * @return the new primordial weighted multiplier\r\n\t */\r\n\tfunction calculateWeightedMultiplier(uint256 _currentWeightedMultiplier, uint256 _currentPrimordialBalance, uint256 _additionalWeightedMultiplier, uint256 _additionalPrimordialAmount) public pure returns (uint256) {\r\n\t\tif (_currentWeightedMultiplier > 0) {\r\n\t\t\tuint256 _totalWeightedTokens = (_currentWeightedMultiplier.mul(_currentPrimordialBalance)).add(_additionalWeightedMultiplier.mul(_additionalPrimordialAmount));\r\n\t\t\tuint256 _totalTokens = _currentPrimordialBalance.add(_additionalPrimordialAmount);\r\n\t\t\treturn _totalWeightedTokens.div(_totalTokens);\r\n\t\t} else {\r\n\t\t\treturn _additionalWeightedMultiplier;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Return the address that signed the message when a node wants to become a host\r\n\t * @param _callingContractAddress the address of the calling contract\r\n\t * @param _message the message that was signed\r\n\t * @param _v part of the signature\r\n\t * @param _r part of the signature\r\n\t * @param _s part of the signature\r\n\t * @return the address that signed the message\r\n\t */\r\n\tfunction getBecomeHostSignatureAddress(address _callingContractAddress, string _message, uint8 _v, bytes32 _r, bytes32 _s) public pure returns (address) {\r\n\t\tbytes32 _hash = keccak256(abi.encodePacked(_callingContractAddress, _message));\r\n\t\treturn ecrecover(_hash, _v, _r, _s);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Return the address that signed the TAO content state update\r\n\t * @param _callingContractAddress the address of the calling contract\r\n\t * @param _contentId the ID of the content\r\n\t * @param _taoId the ID of the TAO\r\n\t * @param _taoContentState the TAO Content State value, i.e Submitted, Pending Review, or Accepted to TAO\r\n\t * @param _v part of the signature\r\n\t * @param _r part of the signature\r\n\t * @param _s part of the signature\r\n\t * @return the address that signed the message\r\n\t */\r\n\tfunction getUpdateTAOContentStateSignatureAddress(address _callingContractAddress, bytes32 _contentId, address _taoId, bytes32 _taoContentState, uint8 _v, bytes32 _r, bytes32 _s) public pure returns (address) {\r\n\t\tbytes32 _hash = keccak256(abi.encodePacked(_callingContractAddress, _contentId, _taoId, _taoContentState));\r\n\t\treturn ecrecover(_hash, _v, _r, _s);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Return the staking and earning information of a stake ID\r\n\t * @param _contentAddress The address of AOContent\r\n\t * @param _earningAddress The address of AOEarning\r\n\t * @param _stakeId The ID of the staked content\r\n\t * @return the network base token amount staked for this content\r\n\t * @return the primordial token amount staked for this content\r\n\t * @return the primordial weighted multiplier of the staked content\r\n\t * @return the total earning from staking this content\r\n\t * @return the total earning from hosting this content\r\n\t * @return the total The AO earning of this content\r\n\t */\r\n\tfunction getContentMetrics(address _contentAddress, address _earningAddress, bytes32 _stakeId) public view returns (uint256, uint256, uint256, uint256, uint256, uint256) {\r\n\t\t(uint256 networkAmount, uint256 primordialAmount, uint256 primordialWeightedMultiplier) = getStakingMetrics(_contentAddress, _stakeId);\r\n\t\t(uint256 totalStakeEarning, uint256 totalHostEarning, uint256 totalTheAOEarning) = getEarningMetrics(_earningAddress, _stakeId);\r\n\t\treturn (\r\n\t\t\tnetworkAmount,\r\n\t\t\tprimordialAmount,\r\n\t\t\tprimordialWeightedMultiplier,\r\n\t\t\ttotalStakeEarning,\r\n\t\t\ttotalHostEarning,\r\n\t\t\ttotalTheAOEarning\r\n\t\t);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Return the staking information of a stake ID\r\n\t * @param _contentAddress The address of AOContent\r\n\t * @param _stakeId The ID of the staked content\r\n\t * @return the network base token amount staked for this content\r\n\t * @return the primordial token amount staked for this content\r\n\t * @return the primordial weighted multiplier of the staked content\r\n\t */\r\n\tfunction getStakingMetrics(address _contentAddress, bytes32 _stakeId) public view returns (uint256, uint256, uint256) {\r\n\t\t(,, uint256 networkAmount, uint256 primordialAmount, uint256 primordialWeightedMultiplier,,,) = AOContent(_contentAddress).stakedContentById(_stakeId);\r\n\t\treturn (\r\n\t\t\tnetworkAmount,\r\n\t\t\tprimordialAmount,\r\n\t\t\tprimordialWeightedMultiplier\r\n\t\t);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Return the earning information of a stake ID\r\n\t * @param _earningAddress The address of AOEarning\r\n\t * @param _stakeId The ID of the staked content\r\n\t * @return the total earning from staking this content\r\n\t * @return the total earning from hosting this content\r\n\t * @return the total The AO earning of this content\r\n\t */\r\n\tfunction getEarningMetrics(address _earningAddress, bytes32 _stakeId) public view returns (uint256, uint256, uint256) {\r\n\t\treturn (\r\n\t\t\tAOEarning(_earningAddress).totalStakedContentStakeEarning(_stakeId),\r\n\t\t\tAOEarning(_earningAddress).totalStakedContentHostEarning(_stakeId),\r\n\t\t\tAOEarning(_earningAddress).totalStakedContentTheAOEarning(_stakeId)\r\n\t\t);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Calculate the primordial token multiplier on a given lot\r\n\t *\t\tTotal Primordial Mintable = T\r\n\t *\t\tTotal Primordial Minted = M\r\n\t *\t\tStarting Multiplier = S\r\n\t *\t\tEnding Multiplier = E\r\n\t *\t\tTo Purchase = P\r\n\t *\t\tMultiplier for next Lot of Amount = (1 - ((M + P/2) / T)) x (S-E)\r\n\t *\r\n\t * @param _purchaseAmount The amount of primordial token intended to be purchased\r\n\t * @param _totalPrimordialMintable Total Primordial token intable\r\n\t * @param _totalPrimordialMinted Total Primordial token minted so far\r\n\t * @param _startingMultiplier The starting multiplier in (10 ** 6)\r\n\t * @param _endingMultiplier The ending multiplier in (10 ** 6)\r\n\t * @return The multiplier in (10 ** 6)\r\n\t */\r\n\tfunction calculatePrimordialMultiplier(uint256 _purchaseAmount, uint256 _totalPrimordialMintable, uint256 _totalPrimordialMinted, uint256 _startingMultiplier, uint256 _endingMultiplier) public pure returns (uint256) {\r\n\t\tif (_purchaseAmount > 0 && _purchaseAmount <= _totalPrimordialMintable.sub(_totalPrimordialMinted)) {\r\n\t\t\t/**\r\n\t\t\t * Let temp = M + (P/2)\r\n\t\t\t * Multiplier = (1 - (temp / T)) x (S-E)\r\n\t\t\t */\r\n\t\t\tuint256 temp = _totalPrimordialMinted.add(_purchaseAmount.div(2));\r\n\r\n\t\t\t/**\r\n\t\t\t * Multiply multiplier with _MULTIPLIER_DIVISOR/_MULTIPLIER_DIVISOR to account for 6 decimals\r\n\t\t\t * so, Multiplier = (_MULTIPLIER_DIVISOR/_MULTIPLIER_DIVISOR) * (1 - (temp / T)) * (S-E)\r\n\t\t\t * Multiplier = ((_MULTIPLIER_DIVISOR * (1 - (temp / T))) * (S-E)) / _MULTIPLIER_DIVISOR\r\n\t\t\t * Multiplier = ((_MULTIPLIER_DIVISOR - ((_MULTIPLIER_DIVISOR * temp) / T)) * (S-E)) / _MULTIPLIER_DIVISOR\r\n\t\t\t * Take out the division by _MULTIPLIER_DIVISOR for now and include in later calculation\r\n\t\t\t * Multiplier = (_MULTIPLIER_DIVISOR - ((_MULTIPLIER_DIVISOR * temp) / T)) * (S-E)\r\n\t\t\t */\r\n\t\t\tuint256 multiplier = (_MULTIPLIER_DIVISOR.sub(_MULTIPLIER_DIVISOR.mul(temp).div(_totalPrimordialMintable))).mul(_startingMultiplier.sub(_endingMultiplier));\r\n\t\t\t/**\r\n\t\t\t * Since _startingMultiplier and _endingMultiplier are in 6 decimals\r\n\t\t\t * Need to divide multiplier by _MULTIPLIER_DIVISOR\r\n\t\t\t */\r\n\t\t\treturn multiplier.div(_MULTIPLIER_DIVISOR);\r\n\t\t} else {\r\n\t\t\treturn 0;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Calculate the bonus percentage of network token on a given lot\r\n\t *\t\tTotal Primordial Mintable = T\r\n\t *\t\tTotal Primordial Minted = M\r\n\t *\t\tStarting Network Token Bonus Multiplier = Bs\r\n\t *\t\tEnding Network Token Bonus Multiplier = Be\r\n\t *\t\tTo Purchase = P\r\n\t *\t\tAO Bonus % = B% = (1 - ((M + P/2) / T)) x (Bs-Be)\r\n\t *\r\n\t * @param _purchaseAmount The amount of primordial token intended to be purchased\r\n\t * @param _totalPrimordialMintable Total Primordial token intable\r\n\t * @param _totalPrimordialMinted Total Primordial token minted so far\r\n\t * @param _startingMultiplier The starting Network token bonus multiplier\r\n\t * @param _endingMultiplier The ending Network token bonus multiplier\r\n\t * @return The bonus percentage\r\n\t */\r\n\tfunction calculateNetworkTokenBonusPercentage(uint256 _purchaseAmount, uint256 _totalPrimordialMintable, uint256 _totalPrimordialMinted, uint256 _startingMultiplier, uint256 _endingMultiplier) public pure returns (uint256) {\r\n\t\tif (_purchaseAmount > 0 && _purchaseAmount <= _totalPrimordialMintable.sub(_totalPrimordialMinted)) {\r\n\t\t\t/**\r\n\t\t\t * Let temp = M + (P/2)\r\n\t\t\t * B% = (1 - (temp / T)) x (Bs-Be)\r\n\t\t\t */\r\n\t\t\tuint256 temp = _totalPrimordialMinted.add(_purchaseAmount.div(2));\r\n\r\n\t\t\t/**\r\n\t\t\t * Multiply B% with _PERCENTAGE_DIVISOR/_PERCENTAGE_DIVISOR to account for 6 decimals\r\n\t\t\t * so, B% = (_PERCENTAGE_DIVISOR/_PERCENTAGE_DIVISOR) * (1 - (temp / T)) * (Bs-Be)\r\n\t\t\t * B% = ((_PERCENTAGE_DIVISOR * (1 - (temp / T))) * (Bs-Be)) / _PERCENTAGE_DIVISOR\r\n\t\t\t * B% = ((_PERCENTAGE_DIVISOR - ((_PERCENTAGE_DIVISOR * temp) / T)) * (Bs-Be)) / _PERCENTAGE_DIVISOR\r\n\t\t\t * Take out the division by _PERCENTAGE_DIVISOR for now and include in later calculation\r\n\t\t\t * B% = (_PERCENTAGE_DIVISOR - ((_PERCENTAGE_DIVISOR * temp) / T)) * (Bs-Be)\r\n\t\t\t * But since Bs and Be are in 6 decimals, need to divide by _PERCENTAGE_DIVISOR\r\n\t\t\t * B% = (_PERCENTAGE_DIVISOR - ((_PERCENTAGE_DIVISOR * temp) / T)) * (Bs-Be) / _PERCENTAGE_DIVISOR\r\n\t\t\t */\r\n\t\t\tuint256 bonusPercentage = (_PERCENTAGE_DIVISOR.sub(_PERCENTAGE_DIVISOR.mul(temp).div(_totalPrimordialMintable))).mul(_startingMultiplier.sub(_endingMultiplier)).div(_PERCENTAGE_DIVISOR);\r\n\t\t\treturn bonusPercentage;\r\n\t\t} else {\r\n\t\t\treturn 0;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Calculate the bonus amount of network token on a given lot\r\n\t *\t\tAO Bonus Amount = B% x P\r\n\t *\r\n\t * @param _purchaseAmount The amount of primordial token intended to be purchased\r\n\t * @param _totalPrimordialMintable Total Primordial token intable\r\n\t * @param _totalPrimordialMinted Total Primordial token minted so far\r\n\t * @param _startingMultiplier The starting Network token bonus multiplier\r\n\t * @param _endingMultiplier The ending Network token bonus multiplier\r\n\t * @return The bonus percentage\r\n\t */\r\n\tfunction calculateNetworkTokenBonusAmount(uint256 _purchaseAmount, uint256 _totalPrimordialMintable, uint256 _totalPrimordialMinted, uint256 _startingMultiplier, uint256 _endingMultiplier) public pure returns (uint256) {\r\n\t\tuint256 bonusPercentage = calculateNetworkTokenBonusPercentage(_purchaseAmount, _totalPrimordialMintable, _totalPrimordialMinted, _startingMultiplier, _endingMultiplier);\r\n\t\t/**\r\n\t\t * Since bonusPercentage is in _PERCENTAGE_DIVISOR format, need to divide it with _PERCENTAGE DIVISOR\r\n\t\t * when calculating the network token bonus amount\r\n\t\t */\r\n\t\tuint256 networkTokenBonus = bonusPercentage.mul(_purchaseAmount).div(_PERCENTAGE_DIVISOR);\r\n\t\treturn networkTokenBonus;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Calculate the maximum amount of Primordial an account can burn\r\n\t *\t\t_primordialBalance = P\r\n\t *\t\t_currentWeightedMultiplier = M\r\n\t *\t\t_maximumMultiplier = S\r\n\t *\t\t_amountToBurn = B\r\n\t *\t\tB = ((S x P) - (P x M)) / S\r\n\t *\r\n\t * @param _primordialBalance Account's primordial token balance\r\n\t * @param _currentWeightedMultiplier Account's current weighted multiplier\r\n\t * @param _maximumMultiplier The maximum multiplier of this account\r\n\t * @return The maximum burn amount\r\n\t */\r\n\tfunction calculateMaximumBurnAmount(uint256 _primordialBalance, uint256 _currentWeightedMultiplier, uint256 _maximumMultiplier) public pure returns (uint256) {\r\n\t\treturn (_maximumMultiplier.mul(_primordialBalance).sub(_primordialBalance.mul(_currentWeightedMultiplier))).div(_maximumMultiplier);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Calculate the new multiplier after burning primordial token\r\n\t *\t\t_primordialBalance = P\r\n\t *\t\t_currentWeightedMultiplier = M\r\n\t *\t\t_amountToBurn = B\r\n\t *\t\t_newMultiplier = E\r\n\t *\t\tE = (P x M) / (P - B)\r\n\t *\r\n\t * @param _primordialBalance Account's primordial token balance\r\n\t * @param _currentWeightedMultiplier Account's current weighted multiplier\r\n\t * @param _amountToBurn The amount of primordial token to burn\r\n\t * @return The new multiplier\r\n\t */\r\n\tfunction calculateMultiplierAfterBurn(uint256 _primordialBalance, uint256 _currentWeightedMultiplier, uint256 _amountToBurn) public pure returns (uint256) {\r\n\t\treturn _primordialBalance.mul(_currentWeightedMultiplier).div(_primordialBalance.sub(_amountToBurn));\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Calculate the new multiplier after converting network token to primordial token\r\n\t *\t\t_primordialBalance = P\r\n\t *\t\t_currentWeightedMultiplier = M\r\n\t *\t\t_amountToConvert = C\r\n\t *\t\t_newMultiplier = E\r\n\t *\t\tE = (P x M) / (P + C)\r\n\t *\r\n\t * @param _primordialBalance Account's primordial token balance\r\n\t * @param _currentWeightedMultiplier Account's current weighted multiplier\r\n\t * @param _amountToConvert The amount of network token to convert\r\n\t * @return The new multiplier\r\n\t */\r\n\tfunction calculateMultiplierAfterConversion(uint256 _primordialBalance, uint256 _currentWeightedMultiplier, uint256 _amountToConvert) public pure returns (uint256) {\r\n\t\treturn _primordialBalance.mul(_currentWeightedMultiplier).div(_primordialBalance.add(_amountToConvert));\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Get TAO Currency Balances given a nameId\r\n\t * @param _nameId The ID of the Name\r\n\t * @param _logosAddress The address of Logos\r\n\t * @param _ethosAddress The address of Ethos\r\n\t * @param _pathosAddress The address of Pathos\r\n\t * @return sum Logos balance of the Name ID\r\n\t * @return Ethos balance of the Name ID\r\n\t * @return Pathos balance of the Name ID\r\n\t */\r\n\tfunction getTAOCurrencyBalances(\r\n\t\taddress _nameId,\r\n\t\taddress _logosAddress,\r\n\t\taddress _ethosAddress,\r\n\t\taddress _pathosAddress\r\n\t) public view returns (uint256, uint256, uint256) {\r\n\t\treturn (\r\n\t\t\tLogos(_logosAddress).sumBalanceOf(_nameId),\r\n\t\t\tTAOCurrency(_ethosAddress).balanceOf(_nameId),\r\n\t\t\tTAOCurrency(_pathosAddress).balanceOf(_nameId)\r\n\t\t);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Return the address that signed the data and nonce when validating signature\r\n\t * @param _callingContractAddress the address of the calling contract\r\n\t * @param _data the data that was signed\r\n\t * @param _nonce The signed uint256 nonce\r\n\t * @param _v part of the signature\r\n\t * @param _r part of the signature\r\n\t * @param _s part of the signature\r\n\t * @return the address that signed the message\r\n\t */\r\n\tfunction getValidateSignatureAddress(address _callingContractAddress, string _data, uint256 _nonce, uint8 _v, bytes32 _r, bytes32 _s) public pure returns (address) {\r\n\t\tbytes32 _hash = keccak256(abi.encodePacked(_callingContractAddress, _data, _nonce));\r\n\t\treturn ecrecover(_hash, _v, _r, _s);\r\n\t}\r\n\r\n\t/***** Internal Methods *****/\r\n\t/**\r\n\t * @dev Check whether the network token and/or primordial token is adequate to pay for the filesize\r\n\t * @param _treasuryAddress AO treasury contract address\r\n\t * @param _networkIntegerAmount The integer amount of network token to stake\r\n\t * @param _networkFractionAmount The fraction amount of network token to stake\r\n\t * @param _denomination The denomination of the network token, i.e ao, kilo, mega, etc.\r\n\t * @param _primordialAmount The amount of primordial Token to stake\r\n\t * @param _fileSize The size of the file\r\n\t * @return true when the amount is sufficient, false otherwise\r\n\t */\r\n\tfunction _stakeAmountValid(address _treasuryAddress, uint256 _networkIntegerAmount, uint256 _networkFractionAmount, bytes8 _denomination, uint256 _primordialAmount, uint256 _fileSize) internal view returns (bool) {\r\n\t\treturn AOTreasury(_treasuryAddress).toBase(_networkIntegerAmount, _networkFractionAmount, _denomination).add(_primordialAmount) >= _fileSize;\r\n\t}\r\n}\r\n\r\n\r\ncontract Epiphany is TheAO {\r\n\tstring public what;\r\n\tstring public when;\r\n\tstring public why;\r\n\tstring public who;\r\n\taddress public where;\r\n\tstring public aSign;\r\n\tstring public logos;\r\n\r\n\tconstructor() public {\r\n\t\twhat = 'The AO';\r\n\t\twhen = 'January 6th, 2019 a.d, year 1 a.c. Epiphany. An appearance or manifestation especially of a divine being. An illuminating discovery, realization, or disclosure.';\r\n\t\twhy = 'To Hear, See, and Speak the Human inside Humanity.';\r\n\t\twho = 'You.  Set the world, Free.  Truth';\r\n\t\taSign = '08e2c4e1ccf3bccfb3b8eef14679b28442649a2a733960661210a0b00d9c93bf';\r\n\t\tlogos = '0920c6ab1848df83a332a21e8c9ec1a393e694c396b872aee053722d023e2a32';\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Checks if the calling contract address is The AO\r\n\t *\t\tOR\r\n\t *\t\tIf The AO is set to a Name/TAO, then check if calling address is the Advocate\r\n\t */\r\n\tmodifier onlyTheAO {\r\n\t\trequire (AOLibrary.isTheAO(msg.sender, theAO, nameTAOPositionAddress));\r\n\t\t_;\r\n\t}\r\n\r\n\t/***** The AO ONLY METHODS *****/\r\n\t/**\r\n\t * @dev The AO set the NameTAOPosition Address\r\n\t * @param _nameTAOPositionAddress The address of NameTAOPosition\r\n\t */\r\n\tfunction setNameTAOPositionAddress(address _nameTAOPositionAddress) public onlyTheAO {\r\n\t\trequire (_nameTAOPositionAddress != address(0));\r\n\t\tnameTAOPositionAddress = _nameTAOPositionAddress;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Transfer ownership of The AO to new address\r\n\t * @param _theAO The new address to be transferred\r\n\t */\r\n\tfunction transferOwnership(address _theAO) public onlyTheAO {\r\n\t\trequire (_theAO != address(0));\r\n\t\ttheAO = _theAO;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Whitelist `_account` address to transact on behalf of others\r\n\t * @param _account The address to whitelist\r\n\t * @param _whitelist Either to whitelist or not\r\n\t */\r\n\tfunction setWhitelist(address _account, bool _whitelist) public onlyTheAO {\r\n\t\trequire (_account != address(0));\r\n\t\twhitelist[_account] = _whitelist;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Set `where` value\r\n\t * @param _where The new value to be set\r\n\t */\r\n\tfunction setWhere(address _where) public onlyTheAO {\r\n\t\twhere = _where;\r\n\t}\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_where\",\"type\":\"address\"}],\"name\":\"setWhere\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nameTAOPositionAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_account\",\"type\":\"address\"},{\"name\":\"_whitelist\",\"type\":\"bool\"}],\"name\":\"setWhitelist\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_nameTAOPositionAddress\",\"type\":\"address\"}],\"name\":\"setNameTAOPositionAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"whitelist\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"where\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"theAO\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"why\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"what\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"logos\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"who\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"aSign\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"when\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_theAO\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"}]","ContractName":"Epiphany","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"AOLibrary:d496ac15eef96be11ed25e7705cd49a75df10b22","SwarmSource":"bzzr://eb7f15b02f4877c5c3d14885d56a396869a99376fd1949aa1837afe98c873194"}]}