{"status":"1","message":"OK","result":[{"SourceCode":"{\"Controlled.sol\":{\"content\":\"pragma solidity ^0.4.18;\\n\\ncontract Controlled {\\n\\n  event ControllerChangedEvent(address newController);\\n\\n  /// @notice The address of the controller is the only address that can call\\n  ///  a function with this modifier\\n  modifier onlyController { require(msg.sender == controller); _; }\\n\\n  address public controller;\\n\\n  function Controlled() public { controller = msg.sender;}\\n\\n  /// @notice Changes the controller of the contract\\n  /// @param _newController The new controller of the contract\\n  function changeController(address _newController) public onlyController {\\n    controller = _newController;\\n    emit ControllerChangedEvent(_newController);\\n  }\\n}\\n\"},\"DelegateProxy.sol\":{\"content\":\"pragma solidity ^0.4.18;\\n\\ncontract DelegateProxy {\\n  /**\\n  * @dev Performs a delegatecall and returns whatever the delegatecall returned (entire context execution will return!)\\n  * @param _dst Destination address to perform the delegatecall\\n  * @param _calldata Calldata for the delegatecall\\n  */\\n  function delegatedFwd(address _dst, bytes _calldata) internal {\\n    require(isContract(_dst));\\n    assembly {\\n      let result := delegatecall(sub(gas, 10000), _dst, add(_calldata, 0x20), mload(_calldata), 0, 0)\\n      let size := returndatasize\\n\\n      let ptr := mload(0x40)\\n      returndatacopy(ptr, 0, size)\\n\\n    // revert instead of invalid() bc if the underlying call failed with invalid() it already wasted gas.\\n    // if the call returned error data, forward it\\n      switch result case 0 {revert(ptr, size)}\\n      default {return (ptr, size)}\\n    }\\n  }\\n\\n  function isContract(address _target) internal view returns (bool) {\\n    uint256 size;\\n    assembly {size := extcodesize(_target)}\\n    return size \\u003e 0;\\n  }\\n}\"},\"DSAuth.sol\":{\"content\":\"// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see \\u003chttp://www.gnu.org/licenses/\\u003e.\\n\\npragma solidity ^0.4.13;\\n\\ncontract DSAuthority {\\n  function canCall(\\n    address src, address dst, bytes4 sig\\n  ) public view returns (bool);\\n}\\n\\ncontract DSAuthEvents {\\n  event LogSetAuthority (address indexed authority);\\n  event LogSetOwner     (address indexed owner);\\n}\\n\\ncontract DSAuth is DSAuthEvents {\\n  DSAuthority  public  authority;\\n  address      public  owner;\\n\\n  function DSAuth() public {\\n    owner = msg.sender;\\n    LogSetOwner(msg.sender);\\n  }\\n\\n  function setOwner(address owner_)\\n  public\\n  auth\\n  {\\n    owner = owner_;\\n    LogSetOwner(owner);\\n  }\\n\\n  function setAuthority(DSAuthority authority_)\\n  public\\n  auth\\n  {\\n    authority = authority_;\\n    LogSetAuthority(authority);\\n  }\\n\\n  modifier auth {\\n    require(isAuthorized(msg.sender, msg.sig));\\n    _;\\n  }\\n\\n  function isAuthorized(address src, bytes4 sig) internal view returns (bool) {\\n    if (src == address(this)) {\\n      return true;\\n    } else if (src == owner) {\\n      return true;\\n    } else if (authority == DSAuthority(0)) {\\n      return false;\\n    } else {\\n      return authority.canCall(src, this, sig);\\n    }\\n  }\\n}\\n\"},\"DSGuard.sol\":{\"content\":\"// guard.sol -- simple whitelist implementation of DSAuthority\\n\\n// Copyright (C) 2017  DappHub, LLC\\n\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see \\u003chttp://www.gnu.org/licenses/\\u003e.\\n\\npragma solidity ^0.4.13;\\n\\nimport \\\"./DSAuth.sol\\\";\\n\\ncontract DSGuardEvents {\\n  event LogPermit(\\n    bytes32 indexed src,\\n    bytes32 indexed dst,\\n    bytes32 indexed sig\\n  );\\n  event LogForbid(\\n    bytes32 indexed src,\\n    bytes32 indexed dst,\\n    bytes32 indexed sig\\n  );\\n}\\n\\ncontract DSGuard is DSAuth, DSAuthority, DSGuardEvents {\\n  bytes32 constant public ANY = bytes32(uint(- 1));\\n  mapping(bytes32 =\\u003e mapping(bytes32 =\\u003e mapping(bytes32 =\\u003e bool))) acl;\\n\\n  function canCall(\\n    address src_, address dst_, bytes4 sig\\n  ) public view returns (bool) {\\n    bytes32 src = bytes32(src_);\\n    bytes32 dst = bytes32(dst_);\\n\\n    return acl[src][dst][sig]\\n    || acl[src][dst][ANY]\\n    || acl[src][ANY][sig]\\n    || acl[src][ANY][ANY]\\n    || acl[ANY][dst][sig]\\n    || acl[ANY][dst][ANY]\\n    || acl[ANY][ANY][sig]\\n    || acl[ANY][ANY][ANY];\\n  }\\n\\n  function permit(bytes32 src, bytes32 dst, bytes32 sig) public auth {\\n    acl[src][dst][sig] = true;\\n    LogPermit(src, dst, sig);\\n  }\\n\\n  function forbid(bytes32 src, bytes32 dst, bytes32 sig) public auth {\\n    acl[src][dst][sig] = false;\\n    LogForbid(src, dst, sig);\\n  }\\n\\n  function permit(address src, address dst, bytes32 sig) public {\\n    permit(bytes32(src), bytes32(dst), sig);\\n  }\\n\\n  function forbid(address src, address dst, bytes32 sig) public {\\n    forbid(bytes32(src), bytes32(dst), sig);\\n  }\\n}\\n\\ncontract DSGuardFactory {\\n  mapping(address =\\u003e bool)  public  isGuard;\\n\\n  function newGuard() public returns (DSGuard guard) {\\n    guard = new DSGuard();\\n    guard.setOwner(msg.sender);\\n    isGuard[guard] = true;\\n  }\\n}\\n\"},\"EternalDb.sol\":{\"content\":\"pragma solidity ^0.4.18;\\n\\nimport \\\"./DSAuth.sol\\\";\\n\\n/**\\n * @title Contract to store arbitrary state data, decoupled from any logic related to it\\n *\\n * @dev Original implementation: https://blog.colony.io/writing-upgradeable-contracts-in-solidity-6743f0eecc88\\n * In addition to original implementation, this contract uses DSAuth for more advanced authentication options\\n * It also provides way set/get multiple values in single transaction\\n */\\n\\ncontract EternalDb is DSAuth {\\n\\n  enum Types {UInt, String, Address, Bytes, Bytes32, Boolean, Int}\\n\\n  event EternalDbEvent(bytes32[] records, uint[] values, uint timestamp);\\n\\n  function EternalDb(){\\n  }\\n\\n  ////////////\\n  //UInt\\n  ////////////\\n\\n  mapping(bytes32 =\\u003e uint) UIntStorage;\\n\\n  function getUIntValue(bytes32 record) constant returns (uint){\\n    return UIntStorage[record];\\n  }\\n\\n  function getUIntValues(bytes32[] records) constant returns (uint[] results){\\n    results = new uint[](records.length);\\n    for (uint i = 0; i \\u003c records.length; i++) {\\n      results[i] = UIntStorage[records[i]];\\n    }\\n  }\\n\\n  function setUIntValue(bytes32 record, uint value)\\n  auth\\n  {\\n    UIntStorage[record] = value;\\n    bytes32[] memory records = new bytes32[](1);\\n    records[0] = record;\\n    uint[] memory values = new uint[](1);\\n    values[0] = value;\\n    emit EternalDbEvent(records, values, now);\\n  }\\n\\n  function setUIntValues(bytes32[] records, uint[] values)\\n  auth\\n  {\\n    for (uint i = 0; i \\u003c records.length; i++) {\\n      UIntStorage[records[i]] = values[i];\\n    }\\n    emit EternalDbEvent(records, values, now);\\n  }\\n\\n  function deleteUIntValue(bytes32 record)\\n  auth\\n  {\\n    delete UIntStorage[record];\\n  }\\n\\n  ////////////\\n  //Strings\\n  ////////////\\n\\n  mapping(bytes32 =\\u003e string) StringStorage;\\n\\n  function getStringValue(bytes32 record) constant returns (string){\\n    return StringStorage[record];\\n  }\\n\\n  function setStringValue(bytes32 record, string value)\\n  auth\\n  {\\n    StringStorage[record] = value;\\n  }\\n\\n  function deleteStringValue(bytes32 record)\\n  auth\\n  {\\n    delete StringStorage[record];\\n  }\\n\\n  ////////////\\n  //Address\\n  ////////////\\n\\n  mapping(bytes32 =\\u003e address) AddressStorage;\\n\\n  function getAddressValue(bytes32 record) constant returns (address){\\n    return AddressStorage[record];\\n  }\\n\\n  function setAddressValues(bytes32[] records, address[] values)\\n  auth\\n  {\\n    for (uint i = 0; i \\u003c records.length; i++) {\\n      AddressStorage[records[i]] = values[i];\\n    }\\n  }\\n\\n  function setAddressValue(bytes32 record, address value)\\n  auth\\n  {\\n    AddressStorage[record] = value;\\n  }\\n\\n  function deleteAddressValue(bytes32 record)\\n  auth\\n  {\\n    delete AddressStorage[record];\\n  }\\n\\n  ////////////\\n  //Bytes\\n  ////////////\\n\\n  mapping(bytes32 =\\u003e bytes) BytesStorage;\\n\\n  function getBytesValue(bytes32 record) constant returns (bytes){\\n    return BytesStorage[record];\\n  }\\n\\n  function setBytesValue(bytes32 record, bytes value)\\n  auth\\n  {\\n    BytesStorage[record] = value;\\n  }\\n\\n  function deleteBytesValue(bytes32 record)\\n  auth\\n  {\\n    delete BytesStorage[record];\\n  }\\n\\n  ////////////\\n  //Bytes32\\n  ////////////\\n\\n  mapping(bytes32 =\\u003e bytes32) Bytes32Storage;\\n\\n  function getBytes32Value(bytes32 record) constant returns (bytes32){\\n    return Bytes32Storage[record];\\n  }\\n\\n  function getBytes32Values(bytes32[] records) constant returns (bytes32[] results){\\n    results = new bytes32[](records.length);\\n    for (uint i = 0; i \\u003c records.length; i++) {\\n      results[i] = Bytes32Storage[records[i]];\\n    }\\n  }\\n\\n  function setBytes32Value(bytes32 record, bytes32 value)\\n  auth\\n  {\\n    Bytes32Storage[record] = value;\\n  }\\n\\n  function setBytes32Values(bytes32[] records, bytes32[] values)\\n  auth\\n  {\\n    for (uint i = 0; i \\u003c records.length; i++) {\\n      Bytes32Storage[records[i]] = values[i];\\n    }\\n  }\\n\\n  function deleteBytes32Value(bytes32 record)\\n  auth\\n  {\\n    delete Bytes32Storage[record];\\n  }\\n\\n  ////////////\\n  //Boolean\\n  ////////////\\n\\n  mapping(bytes32 =\\u003e bool) BooleanStorage;\\n\\n  function getBooleanValue(bytes32 record) constant returns (bool){\\n    return BooleanStorage[record];\\n  }\\n\\n  function getBooleanValues(bytes32[] records) constant returns (bool[] results){\\n    results = new bool[](records.length);\\n    for (uint i = 0; i \\u003c records.length; i++) {\\n      results[i] = BooleanStorage[records[i]];\\n    }\\n  }\\n\\n  function setBooleanValue(bytes32 record, bool value)\\n  auth\\n  {\\n    BooleanStorage[record] = value;\\n  }\\n\\n  function setBooleanValues(bytes32[] records, bool[] values)\\n  auth\\n  {\\n    for (uint i = 0; i \\u003c records.length; i++) {\\n      BooleanStorage[records[i]] = values[i];\\n    }\\n  }\\n\\n  function deleteBooleanValue(bytes32 record)\\n  auth\\n  {\\n    delete BooleanStorage[record];\\n  }\\n\\n  ////////////\\n  //Int\\n  ////////////\\n  mapping(bytes32 =\\u003e int) IntStorage;\\n\\n  function getIntValue(bytes32 record) constant returns (int){\\n    return IntStorage[record];\\n  }\\n\\n  function getIntValues(bytes32[] records) constant returns (int[] results){\\n    results = new int[](records.length);\\n    for (uint i = 0; i \\u003c records.length; i++) {\\n      results[i] = IntStorage[records[i]];\\n    }\\n  }\\n\\n  function setIntValue(bytes32 record, int value)\\n  auth\\n  {\\n    IntStorage[record] = value;\\n  }\\n\\n  function setIntValues(bytes32[] records, int[] values)\\n  auth\\n  {\\n    for (uint i = 0; i \\u003c records.length; i++) {\\n      IntStorage[records[i]] = values[i];\\n    }\\n  }\\n\\n  function deleteIntValue(bytes32 record)\\n  auth\\n  {\\n    delete IntStorage[record];\\n  }\\n\\n}\\n\"},\"MiniMeToken.sol\":{\"content\":\"pragma solidity ^0.4.18;\\n\\n/*\\n    Copyright 2016, Jordi Baylina\\n\\n    This program is free software: you can redistribute it and/or modify\\n    it under the terms of the GNU General Public License as published by\\n    the Free Software Foundation, either version 3 of the License, or\\n    (at your option) any later version.\\n\\n    This program is distributed in the hope that it will be useful,\\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n    GNU General Public License for more details.\\n\\n    You should have received a copy of the GNU General Public License\\n    along with this program.  If not, see \\u003chttp://www.gnu.org/licenses/\\u003e.\\n */\\n\\n/// @title MiniMeToken Contract\\n/// @author Jordi Baylina\\n/// @dev This token contract\\u0027s goal is to make it easy for anyone to clone this\\n///  token using the token distribution at a given block, this will allow DAO\\u0027s\\n///  and DApps to upgrade their features in a decentralized manner without\\n///  affecting the original token\\n/// @dev It is ERC20 compliant, but still needs to under go further testing.\\n\\nimport \\\"./Controlled.sol\\\";\\nimport \\\"./TokenController.sol\\\";\\n\\ncontract ApproveAndCallFallBack {\\n  function receiveApproval(address from, uint256 _amount, address _token, bytes _data) public;\\n}\\n\\n/// @dev The actual token contract, the default controller is the msg.sender\\n///  that deploys the contract, so usually this token will be deployed by a\\n///  token controller contract, which Giveth will call a \\\"Campaign\\\"\\ncontract MiniMeToken is Controlled {\\n\\n  string public name;                //The Token\\u0027s name: e.g. DigixDAO Tokens\\n  uint8 public decimals;             //Number of decimals of the smallest unit\\n  string public symbol;              //An identifier: e.g. REP\\n  string public version = \\u0027MMT_0.2\\u0027; //An arbitrary versioning scheme\\n\\n\\n  /// @dev `Checkpoint` is the structure that attaches a block number to a\\n  ///  given value, the block number attached is the one that last changed the\\n  ///  value\\n  struct  Checkpoint {\\n\\n    // `fromBlock` is the block number that the value was generated from\\n    uint128 fromBlock;\\n\\n    // `value` is the amount of tokens at a specific block number\\n    uint128 value;\\n  }\\n\\n  // `parentToken` is the Token address that was cloned to produce this token;\\n  //  it will be 0x0 for a token that was not cloned\\n  MiniMeToken public parentToken;\\n\\n  // `parentSnapShotBlock` is the block number from the Parent Token that was\\n  //  used to determine the initial distribution of the Clone Token\\n  uint public parentSnapShotBlock;\\n\\n  // `creationBlock` is the block number that the Clone Token was created\\n  uint public creationBlock;\\n\\n  // `balances` is the map that tracks the balance of each address, in this\\n  //  contract when the balance changes the block number that the change\\n  //  occurred is also included in the map\\n  mapping (address =\\u003e Checkpoint[]) balances;\\n\\n  // `allowed` tracks any extra transfer rights as in all ERC20 tokens\\n  mapping (address =\\u003e mapping (address =\\u003e uint256)) allowed;\\n\\n  // Tracks the history of the `totalSupply` of the token\\n  Checkpoint[] totalSupplyHistory;\\n\\n  // Flag that determines if the token is transferable or not.\\n  bool public transfersEnabled;\\n\\n  // The factory used to create new clone tokens\\n  MiniMeTokenFactory public tokenFactory;\\n\\n  ////////////////\\n  // Constructor\\n  ////////////////\\n\\n  /// @notice Constructor to create a MiniMeToken\\n  /// @param _tokenFactory The address of the MiniMeTokenFactory contract that\\n  ///  will create the Clone token contracts, the token factory needs to be\\n  ///  deployed first\\n  /// @param _parentToken Address of the parent token, set to 0x0 if it is a\\n  ///  new token\\n  /// @param _parentSnapShotBlock Block of the parent token that will\\n  ///  determine the initial distribution of the clone token, set to 0 if it\\n  ///  is a new token\\n  /// @param _tokenName Name of the new token\\n  /// @param _decimalUnits Number of decimals of the new token\\n  /// @param _tokenSymbol Token Symbol for the new token\\n  /// @param _transfersEnabled If true, tokens will be able to be transferred\\n  function MiniMeToken(\\n    address _tokenFactory,\\n    address _parentToken,\\n    uint _parentSnapShotBlock,\\n    string _tokenName,\\n    uint8 _decimalUnits,\\n    string _tokenSymbol,\\n    bool _transfersEnabled\\n  ) public {\\n    tokenFactory = MiniMeTokenFactory(_tokenFactory);\\n    name = _tokenName;                                 // Set the name\\n    decimals = _decimalUnits;                          // Set the decimals\\n    symbol = _tokenSymbol;                             // Set the symbol\\n    parentToken = MiniMeToken(_parentToken);\\n    parentSnapShotBlock = _parentSnapShotBlock;\\n    transfersEnabled = _transfersEnabled;\\n    creationBlock = block.number;\\n  }\\n\\n\\n  ///////////////////\\n  // ERC20 Methods\\n  ///////////////////\\n\\n  /// @notice Send `_amount` tokens to `_to` from `msg.sender`\\n  /// @param _to The address of the recipient\\n  /// @param _amount The amount of tokens to be transferred\\n  /// @return Whether the transfer was successful or not\\n  function transfer(address _to, uint256 _amount) public returns (bool success) {\\n    require(transfersEnabled);\\n    doTransfer(msg.sender, _to, _amount);\\n    return true;\\n  }\\n\\n  /// @notice Send `_amount` tokens to `_to` from `_from` on the condition it\\n  ///  is approved by `_from`\\n  /// @param _from The address holding the tokens being transferred\\n  /// @param _to The address of the recipient\\n  /// @param _amount The amount of tokens to be transferred\\n  /// @return True if the transfer was successful\\n  function transferFrom(address _from, address _to, uint256 _amount\\n  ) public returns (bool success) {\\n\\n    // The controller of this contract can move tokens around at will,\\n    //  this is important to recognize! Confirm that you trust the\\n    //  controller of this contract, which in most situations should be\\n    //  another open source smart contract or 0x0\\n    if (msg.sender != controller) {\\n      require(transfersEnabled);\\n\\n      // The standard ERC 20 transferFrom functionality\\n      require(allowed[_from][msg.sender] \\u003e= _amount);\\n      allowed[_from][msg.sender] -= _amount;\\n    }\\n    doTransfer(_from, _to, _amount);\\n    return true;\\n  }\\n\\n  /// @dev This is the actual transfer function in the token contract, it can\\n  ///  only be called by other functions in this contract.\\n  /// @param _from The address holding the tokens being transferred\\n  /// @param _to The address of the recipient\\n  /// @param _amount The amount of tokens to be transferred\\n  /// @return True if the transfer was successful\\n  function doTransfer(address _from, address _to, uint _amount\\n  ) internal {\\n\\n    if (_amount == 0) {\\n      Transfer(_from, _to, _amount);    // Follow the spec to louch the event when transfer 0\\n      return;\\n    }\\n\\n    require(parentSnapShotBlock \\u003c block.number);\\n\\n    // Do not allow transfer to 0x0 or the token contract itself\\n    require((_to != 0) \\u0026\\u0026 (_to != address(this)));\\n\\n    // If the amount being transfered is more than the balance of the\\n    //  account the transfer throws\\n    var previousBalanceFrom = balanceOfAt(_from, block.number);\\n\\n    require(previousBalanceFrom \\u003e= _amount);\\n\\n    // Alerts the token controller of the transfer\\n    if (isContract(controller)) {\\n      require(TokenController(controller).onTransfer(_from, _to, _amount));\\n    }\\n\\n    // First update the balance array with the new value for the address\\n    //  sending the tokens\\n    updateValueAtNow(balances[_from], previousBalanceFrom - _amount);\\n\\n    // Then update the balance array with the new value for the address\\n    //  receiving the tokens\\n    var previousBalanceTo = balanceOfAt(_to, block.number);\\n    require(previousBalanceTo + _amount \\u003e= previousBalanceTo); // Check for overflow\\n    updateValueAtNow(balances[_to], previousBalanceTo + _amount);\\n\\n    // An event to make the transfer easy to find on the blockchain\\n    Transfer(_from, _to, _amount);\\n\\n  }\\n\\n  /// @param _owner The address that\\u0027s balance is being requested\\n  /// @return The balance of `_owner` at the current block\\n  function balanceOf(address _owner) public constant returns (uint256 balance) {\\n    return balanceOfAt(_owner, block.number);\\n  }\\n\\n  /// @notice `msg.sender` approves `_spender` to spend `_amount` tokens on\\n  ///  its behalf. This is a modified version of the ERC20 approve function\\n  ///  to be a little bit safer\\n  /// @param _spender The address of the account able to transfer the tokens\\n  /// @param _amount The amount of tokens to be approved for transfer\\n  /// @return True if the approval was successful\\n  function approve(address _spender, uint256 _amount) public returns (bool success) {\\n    require(transfersEnabled);\\n\\n    // To change the approve amount you first have to reduce the addresses`\\n    //  allowance to zero by calling `approve(_spender,0)` if it is not\\n    //  already 0 to mitigate the race condition described here:\\n    //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n    require((_amount == 0) || (allowed[msg.sender][_spender] == 0));\\n\\n    // Alerts the token controller of the approve function call\\n    if (isContract(controller)) {\\n      require(TokenController(controller).onApprove(msg.sender, _spender, _amount));\\n    }\\n\\n    allowed[msg.sender][_spender] = _amount;\\n    Approval(msg.sender, _spender, _amount);\\n    return true;\\n  }\\n\\n  /// @dev This function makes it easy to read the `allowed[]` map\\n  /// @param _owner The address of the account that owns the token\\n  /// @param _spender The address of the account able to transfer the tokens\\n  /// @return Amount of remaining tokens of _owner that _spender is allowed\\n  ///  to spend\\n  function allowance(address _owner, address _spender\\n  ) public constant returns (uint256 remaining) {\\n    return allowed[_owner][_spender];\\n  }\\n\\n  /// @notice `msg.sender` approves `_spender` to send `_amount` tokens on\\n  ///  its behalf, and then a function is triggered in the contract that is\\n  ///  being approved, `_spender`. This allows users to use their tokens to\\n  ///  interact with contracts in one function call instead of two\\n  /// @param _spender The address of the contract able to transfer the tokens\\n  /// @param _amount The amount of tokens to be approved for transfer\\n  /// @return True if the function call was successful\\n  function approveAndCall(address _spender, uint256 _amount, bytes _extraData\\n  ) public returns (bool success) {\\n    require(approve(_spender, _amount));\\n\\n    ApproveAndCallFallBack(_spender).receiveApproval(\\n      msg.sender,\\n      _amount,\\n      this,\\n      _extraData\\n    );\\n\\n    return true;\\n  }\\n\\n  /// @dev This function makes it easy to get the total number of tokens\\n  /// @return The total number of tokens\\n  function totalSupply() public constant returns (uint) {\\n    return totalSupplyAt(block.number);\\n  }\\n\\n\\n  ////////////////\\n  // Query balance and totalSupply in History\\n  ////////////////\\n\\n  /// @dev Queries the balance of `_owner` at a specific `_blockNumber`\\n  /// @param _owner The address from which the balance will be retrieved\\n  /// @param _blockNumber The block number when the balance is queried\\n  /// @return The balance at `_blockNumber`\\n  function balanceOfAt(address _owner, uint _blockNumber) public constant\\n  returns (uint) {\\n\\n    // These next few lines are used when the balance of the token is\\n    //  requested before a check point was ever created for this token, it\\n    //  requires that the `parentToken.balanceOfAt` be queried at the\\n    //  genesis block for that token as this contains initial balance of\\n    //  this token\\n    if ((balances[_owner].length == 0)\\n      || (balances[_owner][0].fromBlock \\u003e _blockNumber)) {\\n      if (address(parentToken) != 0) {\\n        return parentToken.balanceOfAt(_owner, min(_blockNumber, parentSnapShotBlock));\\n      } else {\\n        // Has no parent\\n        return 0;\\n      }\\n\\n      // This will return the expected balance during normal situations\\n    } else {\\n      return getValueAt(balances[_owner], _blockNumber);\\n    }\\n  }\\n\\n  /// @notice Total amount of tokens at a specific `_blockNumber`.\\n  /// @param _blockNumber The block number when the totalSupply is queried\\n  /// @return The total amount of tokens at `_blockNumber`\\n  function totalSupplyAt(uint _blockNumber) public constant returns(uint) {\\n\\n    // These next few lines are used when the totalSupply of the token is\\n    //  requested before a check point was ever created for this token, it\\n    //  requires that the `parentToken.totalSupplyAt` be queried at the\\n    //  genesis block for this token as that contains totalSupply of this\\n    //  token at this block number.\\n    if ((totalSupplyHistory.length == 0)\\n      || (totalSupplyHistory[0].fromBlock \\u003e _blockNumber)) {\\n      if (address(parentToken) != 0) {\\n        return parentToken.totalSupplyAt(min(_blockNumber, parentSnapShotBlock));\\n      } else {\\n        return 0;\\n      }\\n\\n      // This will return the expected totalSupply during normal situations\\n    } else {\\n      return getValueAt(totalSupplyHistory, _blockNumber);\\n    }\\n  }\\n\\n  ////////////////\\n  // Clone Token Method\\n  ////////////////\\n\\n  /// @notice Creates a new clone token with the initial distribution being\\n  ///  this token at `_snapshotBlock`\\n  /// @param _cloneTokenName Name of the clone token\\n  /// @param _cloneDecimalUnits Number of decimals of the smallest unit\\n  /// @param _cloneTokenSymbol Symbol of the clone token\\n  /// @param _snapshotBlock Block when the distribution of the parent token is\\n  ///  copied to set the initial distribution of the new clone token;\\n  ///  if the block is zero than the actual block, the current block is used\\n  /// @param _transfersEnabled True if transfers are allowed in the clone\\n  /// @return The address of the new MiniMeToken Contract\\n  function createCloneToken(\\n    string _cloneTokenName,\\n    uint8 _cloneDecimalUnits,\\n    string _cloneTokenSymbol,\\n    uint _snapshotBlock,\\n    bool _transfersEnabled\\n  ) public returns(address) {\\n    if (_snapshotBlock == 0) _snapshotBlock = block.number;\\n    MiniMeToken cloneToken = tokenFactory.createCloneToken(\\n      this,\\n      _snapshotBlock,\\n      _cloneTokenName,\\n      _cloneDecimalUnits,\\n      _cloneTokenSymbol,\\n      _transfersEnabled\\n    );\\n\\n    cloneToken.changeController(msg.sender);\\n\\n    // An event to make the token easy to find on the blockchain\\n    NewCloneToken(address(cloneToken), _snapshotBlock);\\n    return address(cloneToken);\\n  }\\n\\n  ////////////////\\n  // Generate and destroy tokens\\n  ////////////////\\n\\n  /// @notice Generates `_amount` tokens that are assigned to `_owner`\\n  /// @param _owner The address that will be assigned the new tokens\\n  /// @param _amount The quantity of tokens generated\\n  /// @return True if the tokens are generated correctly\\n  function generateTokens(address _owner, uint _amount\\n  ) public onlyController returns (bool) {\\n    uint curTotalSupply = totalSupply();\\n    require(curTotalSupply + _amount \\u003e= curTotalSupply); // Check for overflow\\n    uint previousBalanceTo = balanceOf(_owner);\\n    require(previousBalanceTo + _amount \\u003e= previousBalanceTo); // Check for overflow\\n    updateValueAtNow(totalSupplyHistory, curTotalSupply + _amount);\\n    updateValueAtNow(balances[_owner], previousBalanceTo + _amount);\\n    Transfer(0, _owner, _amount);\\n    return true;\\n  }\\n\\n\\n  /// @notice Burns `_amount` tokens from `_owner`\\n  /// @param _owner The address that will lose the tokens\\n  /// @param _amount The quantity of tokens to burn\\n  /// @return True if the tokens are burned correctly\\n  function destroyTokens(address _owner, uint _amount\\n  ) onlyController public returns (bool) {\\n    uint curTotalSupply = totalSupply();\\n    require(curTotalSupply \\u003e= _amount);\\n    uint previousBalanceFrom = balanceOf(_owner);\\n    require(previousBalanceFrom \\u003e= _amount);\\n    updateValueAtNow(totalSupplyHistory, curTotalSupply - _amount);\\n    updateValueAtNow(balances[_owner], previousBalanceFrom - _amount);\\n    Transfer(_owner, 0, _amount);\\n    return true;\\n  }\\n\\n  ////////////////\\n  // Enable tokens transfers\\n  ////////////////\\n\\n\\n  /// @notice Enables token holders to transfer their tokens freely if true\\n  /// @param _transfersEnabled True if transfers are allowed in the clone\\n  function enableTransfers(bool _transfersEnabled) public onlyController {\\n    transfersEnabled = _transfersEnabled;\\n  }\\n\\n  ////////////////\\n  // Internal helper functions to query and set a value in a snapshot array\\n  ////////////////\\n\\n  /// @dev `getValueAt` retrieves the number of tokens at a given block number\\n  /// @param checkpoints The history of values being queried\\n  /// @param _block The block number to retrieve the value at\\n  /// @return The number of tokens being queried\\n  function getValueAt(Checkpoint[] storage checkpoints, uint _block\\n  ) constant internal returns (uint) {\\n    if (checkpoints.length == 0) return 0;\\n\\n    // Shortcut for the actual value\\n    if (_block \\u003e= checkpoints[checkpoints.length-1].fromBlock)\\n      return checkpoints[checkpoints.length-1].value;\\n    if (_block \\u003c checkpoints[0].fromBlock) return 0;\\n\\n    // Binary search of the value in the array\\n    uint min = 0;\\n    uint max = checkpoints.length-1;\\n    while (max \\u003e min) {\\n      uint mid = (max + min + 1)/ 2;\\n      if (checkpoints[mid].fromBlock\\u003c=_block) {\\n        min = mid;\\n      } else {\\n        max = mid-1;\\n      }\\n    }\\n    return checkpoints[min].value;\\n  }\\n\\n  /// @dev `updateValueAtNow` used to update the `balances` map and the\\n  ///  `totalSupplyHistory`\\n  /// @param checkpoints The history of data being updated\\n  /// @param _value The new number of tokens\\n  function updateValueAtNow(Checkpoint[] storage checkpoints, uint _value\\n  ) internal  {\\n    if ((checkpoints.length == 0)\\n      || (checkpoints[checkpoints.length -1].fromBlock \\u003c block.number)) {\\n      Checkpoint storage newCheckPoint = checkpoints[ checkpoints.length++ ];\\n      newCheckPoint.fromBlock =  uint128(block.number);\\n      newCheckPoint.value = uint128(_value);\\n    } else {\\n      Checkpoint storage oldCheckPoint = checkpoints[checkpoints.length-1];\\n      oldCheckPoint.value = uint128(_value);\\n    }\\n  }\\n\\n  /// @dev Internal function to determine if an address is a contract\\n  /// @param _addr The address being queried\\n  /// @return True if `_addr` is a contract\\n  function isContract(address _addr) constant internal returns(bool) {\\n    uint size;\\n    if (_addr == 0) return false;\\n    assembly {\\n      size := extcodesize(_addr)\\n    }\\n    return size\\u003e0;\\n  }\\n\\n  /// @dev Helper function to return a min betwen the two uints\\n  function min(uint a, uint b) pure internal returns (uint) {\\n    return a \\u003c b ? a : b;\\n  }\\n\\n  /// @notice The fallback function: If the contract\\u0027s controller has not been\\n  ///  set to 0, then the `proxyPayment` method is called which relays the\\n  ///  ether and creates tokens as described in the token controller contract\\n  function () public payable {\\n    require(isContract(controller));\\n    require(TokenController(controller).proxyPayment.value(msg.value)(msg.sender));\\n  }\\n\\n  //////////\\n  // Safety Methods\\n  //////////\\n\\n  /// @notice This method can be used by the controller to extract mistakenly\\n  ///  sent tokens to this contract.\\n  /// @param _token The address of the token contract that you want to recover\\n  ///  set to 0 in case you want to extract ether.\\n  function claimTokens(address _token) public onlyController {\\n    if (_token == 0x0) {\\n      controller.transfer(this.balance);\\n      return;\\n    }\\n\\n    MiniMeToken token = MiniMeToken(_token);\\n    uint balance = token.balanceOf(this);\\n    token.transfer(controller, balance);\\n    ClaimedTokens(_token, controller, balance);\\n  }\\n\\n  ////////////////\\n  // Events\\n  ////////////////\\n  event ClaimedTokens(address indexed _token, address indexed _controller, uint _amount);\\n  event Transfer(address indexed _from, address indexed _to, uint256 _amount);\\n  event NewCloneToken(address indexed _cloneToken, uint _snapshotBlock);\\n  event Approval(\\n    address indexed _owner,\\n    address indexed _spender,\\n    uint256 _amount\\n  );\\n\\n}\\n\\n\\n////////////////\\n// MiniMeTokenFactory\\n////////////////\\n\\n/// @dev This contract is used to generate clone contracts from a contract.\\n///  In solidity this is the way to create a contract from a contract of the\\n///  same class\\ncontract MiniMeTokenFactory {\\n\\n  /// @notice Update the DApp by creating a new token with new functionalities\\n  ///  the msg.sender becomes the controller of this clone token\\n  /// @param _parentToken Address of the token being cloned\\n  /// @param _snapshotBlock Block of the parent token that will\\n  ///  determine the initial distribution of the clone token\\n  /// @param _tokenName Name of the new token\\n  /// @param _decimalUnits Number of decimals of the new token\\n  /// @param _tokenSymbol Token Symbol for the new token\\n  /// @param _transfersEnabled If true, tokens will be able to be transferred\\n  /// @return The address of the new token contract\\n  function createCloneToken(\\n    address _parentToken,\\n    uint _snapshotBlock,\\n    string _tokenName,\\n    uint8 _decimalUnits,\\n    string _tokenSymbol,\\n    bool _transfersEnabled\\n  ) public returns (MiniMeToken) {\\n    MiniMeToken newToken = new MiniMeToken(\\n      this,\\n      _parentToken,\\n      _snapshotBlock,\\n      _tokenName,\\n      _decimalUnits,\\n      _tokenSymbol,\\n      _transfersEnabled\\n    );\\n\\n    newToken.changeController(msg.sender);\\n    return newToken;\\n  }\\n}\\n\"},\"MutableForwarder.sol\":{\"content\":\"pragma solidity ^0.4.18;\\n\\nimport \\\"./DelegateProxy.sol\\\";\\nimport \\\"./DSAuth.sol\\\";\\n\\n/**\\n * @title Forwarder proxy contract with editable target\\n *\\n * @dev For TCR Registry contracts (Registry.sol, ParamChangeRegistry.sol) we use mutable forwarders instead of using\\n * contracts directly. This is for better upgradeability. Since registry contracts fire all events related to registry\\n * entries, we want to be able to access whole history of events always on the same address. Which would be address of\\n * a MutableForwarder. When a registry contract is replaced with updated one, mutable forwarder just replaces target\\n * and all events stay still accessible on the same address.\\n */\\n\\ncontract MutableForwarder is DelegateProxy, DSAuth {\\n\\n  address public target = 0xBEeFbeefbEefbeEFbeEfbEEfBEeFbeEfBeEfBeef; // checksumed to silence warning\\n\\n  /**\\n   * @dev Replaces targer forwarder contract is pointing to\\n   * Only authenticated user can replace target\\n\\n   * @param _target New target to proxy into\\n  */\\n  function setTarget(address _target) public auth {\\n    target = _target;\\n  }\\n\\n  function() payable {\\n    delegatedFwd(target, msg.data);\\n  }\\n\\n}\"},\"ParamChange.sol\":{\"content\":\"pragma solidity ^0.4.24;\\n\\nimport \\\"./RegistryEntry.sol\\\";\\nimport \\\"./EternalDb.sol\\\";\\n\\n/**\\n * @title Contract created for each submitted TCR parameter change.\\n *\\n * @dev It extends base RegistryEntry with additional state for storing information related to the change.\\n * It also contains logic for applying accepted changes.\\n * Full copy of this contract is NOT deployed with each submission in order to save gas. Only forwarder contracts\\n * pointing into single intance of it.\\n */\\n\\ncontract ParamChange is RegistryEntry {\\n\\n  EternalDb public db;\\n  string private key;\\n  EternalDb.Types private valueType;\\n  uint private value;\\n  uint private originalValue;\\n  uint private appliedOn;\\n\\n  /**\\n   * @dev Constructor for this contract.\\n   * Native constructor is not used, because users create only forwarders into single instance of this contract,\\n   * therefore constructor must be called explicitly.\\n   * Can only be called if the parameter value is within its allowed domain.\\n\\n   * @param _creator Creator of a meme\\n   * @param _version Version of Meme contract\\n   * @param _db EternalDb change will be applied to\\n   * @param _key Key of a changed parameter\\n   * @param _value New value of a parameter\\n   */\\n  function construct(\\n    address _creator,\\n    uint _version,\\n    address _db,\\n    string _key,\\n    uint _value\\n  )\\n  external\\n  {\\n    bytes32 record = sha3(_key);\\n    require(RegistryEntryLib.isChangeAllowed(registry, record, _value));\\n\\n    super.construct(_creator, _version);\\n\\n    db = EternalDb(_db);\\n    key = _key;\\n    value = _value;\\n    valueType = EternalDb.Types.UInt;\\n    originalValue = db.getUIntValue(record);\\n\\n    registry.fireParamChangeConstructedEvent(version,\\n                                             _creator,\\n                                             db,\\n                                             _key,\\n                                             value,\\n                                             deposit,\\n                                             challenge.challengePeriodEnd);\\n  }\\n\\n  /**\\n   * @dev Applies the parameter change into EternalDb\\n   * To be able to make change into a EternalDb, this contract must be given temporary permission to make the change\\n   * This permission is given by ParamChangeRegistry, which holds permanent permission to make changes into the db\\n   * Cannot be called when change was already applied\\n   * Can be called only for whitelisted registry entries\\n   * Can be called only when original value is still current value\\n   * Creator gets deposit back\\n   */\\n  function applyChange()\\n  external\\n  notEmergency\\n  {\\n    require(db.getUIntValue(sha3(key)) == originalValue);\\n    require(appliedOn \\u003c 0);\\n    require(challenge.isWhitelisted());\\n    require(registryToken.transfer(creator, deposit));\\n\\n    db.setUIntValue(sha3(key), value);\\n    appliedOn = now;\\n\\n    registry.fireParamChangeAppliedEvent(version);\\n  }\\n\\n}\\n\"},\"ParamChangeRegistry.sol\":{\"content\":\"pragma solidity ^0.4.24;\\n\\nimport \\\"./Registry.sol\\\";\\nimport \\\"./ParamChange.sol\\\";\\nimport \\\"./DSGuard.sol\\\";\\n\\n/**\\n * @title Central contract for TCR parameter change registry\\n *\\n * @dev Extends Registry contract with additional logic for applying parameter change into a registry EternalDb.\\n */\\n\\ncontract ParamChangeRegistry is Registry {\\n\\n  /**\\n   * @dev Gives ParamChange contract temporary permission to apply its parameter changes into EthernalDb\\n   * Only address of valid ParamChange contract can be passed\\n   * Permission must be taken back right after applying the change\\n\\n   * @param _paramChange Address of ParamChange contract\\n   */\\n\\n  function applyParamChange(ParamChange _paramChange) {\\n    require(isRegistryEntry(_paramChange), \\\"ParamChangeRegistry: not a registry entry\\\");\\n    DSGuard guard = DSGuard(_paramChange.db().authority());\\n    guard.permit(_paramChange, _paramChange.db(), guard.ANY());\\n    _paramChange.applyChange();\\n    guard.forbid(_paramChange, _paramChange.db(), guard.ANY());\\n  }\\n}\\n\\n\"},\"Registry.sol\":{\"content\":\"pragma solidity ^0.4.24;\\n\\nimport \\\"./DSAuth.sol\\\";\\nimport \\\"./EternalDb.sol\\\";\\nimport \\\"./MutableForwarder.sol\\\"; // Keep it included despite not being used (for compiler)\\n\\n/**\\n * @title Central contract for TCR registry\\n *\\n * @dev Manages state about deployed registry entries and factories\\n * Serves as a central point for firing all registry entry events\\n * This contract is not accessed directly, but through MutableForwarder. See MutableForwarder.sol for more comments.\\n */\\n\\ncontract Registry is DSAuth {\\n  address private dummyTarget; // Keep it here, because this contract is deployed as MutableForwarder\\n\\n  bytes32 public constant challengePeriodDurationKey = sha3(\\\"challengePeriodDuration\\\");\\n  bytes32 public constant commitPeriodDurationKey = sha3(\\\"commitPeriodDuration\\\");\\n  bytes32 public constant revealPeriodDurationKey = sha3(\\\"revealPeriodDuration\\\");\\n  bytes32 public constant depositKey = sha3(\\\"deposit\\\");\\n  bytes32 public constant challengeDispensationKey = sha3(\\\"challengeDispensation\\\");\\n  bytes32 public constant voteQuorumKey = sha3(\\\"voteQuorum\\\");\\n  bytes32 public constant maxTotalSupplyKey = sha3(\\\"maxTotalSupply\\\");\\n  bytes32 public constant maxAuctionDurationKey = sha3(\\\"maxAuctionDuration\\\");\\n\\n  event MemeConstructedEvent(address registryEntry, uint version, address creator, bytes metaHash, uint totalSupply, uint deposit, uint challengePeriodEnd);\\n  event MemeMintedEvent(address registryEntry, uint version, address creator, uint tokenStartId, uint tokenEndId, uint totalMinted);\\n\\n  event ChallengeCreatedEvent(address registryEntry, uint version, address challenger, uint commitPeriodEnd, uint revealPeriodEnd, uint rewardPool, bytes metahash);\\n  event VoteCommittedEvent(address registryEntry, uint version, address voter, uint amount);\\n  event VoteRevealedEvent(address registryEntry, uint version, address voter, uint option);\\n  event VoteAmountClaimedEvent(address registryEntry, uint version, address voter);\\n  event VoteRewardClaimedEvent(address registryEntry, uint version, address voter, uint amount);\\n  event ChallengeRewardClaimedEvent(address registryEntry, uint version, address challenger, uint amount);\\n\\n  event ParamChangeConstructedEvent(address registryEntry, uint version, address creator, address db, string key, uint value, uint deposit, uint challengePeriodEnd);\\n  event ParamChangeAppliedEvent(address registryEntry, uint version);\\n\\n  EternalDb public db;\\n  bool private wasConstructed;\\n\\n  /**\\n   * @dev Constructor for this contract.\\n   * Native constructor is not used, because we use a forwarder pointing to single instance of this contract,\\n   * therefore constructor must be called explicitly.\\n\\n   * @param _db Address of EternalDb related to this registry\\n   */\\n  function construct(EternalDb _db)\\n  external\\n  {\\n    require(address(_db) != 0x0, \\\"Registry: Address can\\u0027t be 0x0\\\");\\n    require(!wasConstructed);\\n\\n    db = _db;\\n    wasConstructed = true;\\n    owner = msg.sender;\\n  }\\n\\n  modifier onlyFactory() {\\n    require(isFactory(msg.sender), \\\"Registry: Sender should be factory\\\");\\n    _;\\n  }\\n\\n  modifier onlyRegistryEntry() {\\n    require(isRegistryEntry(msg.sender), \\\"Registry: Sender should registry entry\\\");\\n    _;\\n  }\\n\\n  modifier notEmergency() {\\n    require(!isEmergency(),\\\"Registry: Emergency mode is enable\\\");\\n    _;\\n  }\\n\\n  /**\\n   * @dev Sets whether address is factory allowed to add registry entries into registry\\n   * Must be callable only by authenticated user\\n\\n   * @param _factory Address of a factory contract\\n   * @param _isFactory Whether the address is allowed factory\\n   */\\n  function setFactory(address _factory, bool _isFactory)\\n  external\\n  auth\\n  {\\n    db.setBooleanValue(sha3(\\\"isFactory\\\", _factory), _isFactory);\\n  }\\n\\n  /**\\n   * @dev Adds address as valid registry entry into the Registry\\n   * Must be callable only by allowed factory contract\\n\\n   * @param _registryEntry Address of new registry entry\\n   */\\n  function addRegistryEntry(address _registryEntry)\\n  external\\n  onlyFactory\\n  notEmergency\\n  {\\n    db.setBooleanValue(sha3(\\\"isRegistryEntry\\\", _registryEntry), true);\\n  }\\n\\n  /**\\n   * @dev Sets emergency state to pause all trading operations\\n   * Must be callable only by authenticated user\\n\\n   * @param _isEmergency True if emergency is happening\\n   */\\n  function setEmergency(bool _isEmergency)\\n  external\\n  auth\\n  {\\n    db.setBooleanValue(\\\"isEmergency\\\", _isEmergency);\\n  }\\n\\n  function fireMemeConstructedEvent(uint version, address creator, bytes metaHash, uint totalSupply, uint deposit, uint challengePeriodEnd)\\n  public\\n  onlyRegistryEntry\\n  {\\n    emit MemeConstructedEvent(msg.sender, version, creator, metaHash, totalSupply, deposit, challengePeriodEnd);\\n  }\\n\\n  function fireMemeMintedEvent(uint version, address creator, uint tokenStartId, uint tokenEndId, uint totalMinted)\\n  public\\n  onlyRegistryEntry\\n  {\\n    emit MemeMintedEvent(msg.sender, version, creator, tokenStartId, tokenEndId, totalMinted);\\n  }\\n\\n  function fireChallengeCreatedEvent(uint version, address challenger, uint commitPeriodEnd, uint revealPeriodEnd, uint rewardPool, bytes metahash)\\n  public\\n  onlyRegistryEntry\\n  {\\n    emit ChallengeCreatedEvent(msg.sender, version,  challenger, commitPeriodEnd, revealPeriodEnd, rewardPool, metahash);\\n  }\\n\\n  function fireVoteCommittedEvent(uint version, address voter, uint amount)\\n  public\\n  onlyRegistryEntry\\n  {\\n    emit VoteCommittedEvent(msg.sender, version, voter, amount);\\n  }\\n\\n  function fireVoteRevealedEvent(uint version, address voter, uint option)\\n  public\\n  onlyRegistryEntry\\n  {\\n    emit VoteRevealedEvent(msg.sender, version, voter, option);\\n  }\\n\\n  function fireVoteAmountClaimedEvent(uint version, address voter)\\n  public\\n  onlyRegistryEntry\\n  {\\n    emit VoteAmountClaimedEvent(msg.sender, version, voter);\\n  }\\n\\n  function fireVoteRewardClaimedEvent(uint version, address voter, uint amount)\\n  public\\n  onlyRegistryEntry\\n  {\\n    emit VoteRewardClaimedEvent(msg.sender, version, voter, amount);\\n  }\\n\\n  function fireChallengeRewardClaimedEvent(uint version, address challenger, uint amount)\\n  public\\n  onlyRegistryEntry\\n  {\\n    emit ChallengeRewardClaimedEvent(msg.sender, version, challenger, amount);\\n  }\\n\\n  function fireParamChangeConstructedEvent(uint version, address creator, address db, string key, uint value, uint deposit, uint challengePeriodEnd)\\n  public\\n  onlyRegistryEntry\\n  {\\n    emit ParamChangeConstructedEvent(msg.sender, version, creator, db, key, value, deposit, challengePeriodEnd);\\n  }\\n\\n  function fireParamChangeAppliedEvent(uint version)\\n  public\\n  onlyRegistryEntry\\n  {\\n    emit ParamChangeAppliedEvent(msg.sender, version);\\n  }\\n\\n  /**\\n   * @dev Returns whether address is valid registry entry factory\\n\\n   * @return True if address is factory\\n   */\\n  function isFactory(address factory) public constant returns (bool) {\\n    return db.getBooleanValue(sha3(\\\"isFactory\\\", factory));\\n  }\\n\\n  /**\\n   * @dev Returns whether address is valid registry entry\\n\\n   * @return True if address is registry entry\\n   */\\n  function isRegistryEntry(address registryEntry) public constant returns (bool) {\\n    return db.getBooleanValue(sha3(\\\"isRegistryEntry\\\", registryEntry));\\n  }\\n\\n  /**\\n   * @dev Returns whether emergency stop is happening\\n\\n   * @return True if emergency is happening\\n   */\\n  function isEmergency() public constant returns (bool) {\\n    return db.getBooleanValue(\\\"isEmergency\\\");\\n  }\\n}\\n\"},\"RegistryEntry.sol\":{\"content\":\"pragma solidity ^0.4.24;\\n\\nimport \\\"./Registry.sol\\\";\\nimport \\\"./MiniMeToken.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./RegistryEntryLib.sol\\\";\\n\\n/**\\n * @title Contract created with each submission to a TCR\\n *\\n * @dev It contains all state and logic related to TCR challenging and voting\\n * Full copy of this contract is NOT deployed with each submission in order to save gas. Only forwarder contracts\\n * pointing into single instance of it.\\n * This contract is meant to be extended by domain specific registry entry contracts (Meme, ParamChange)\\n */\\n\\ncontract RegistryEntry is ApproveAndCallFallBack {\\n  using SafeMath for uint;\\n  using RegistryEntryLib for RegistryEntryLib.Challenge;\\n\\n  Registry internal constant registry = Registry(0x770a2dd63d87d24f57fbec86118b0f88914246ed);\\n  MiniMeToken internal constant registryToken = MiniMeToken(0x0cb8d0b37c7487b11d57f1f33defa2b1d3cfccfe);\\n\\n  address internal creator;\\n  uint internal version;\\n  uint internal deposit;\\n  RegistryEntryLib.Challenge internal challenge;\\n\\n  /**\\n   * @dev Modifier that disables function if registry is in emergency state\\n   */\\n  modifier notEmergency() {\\n    require(!registry.isEmergency());\\n    _;\\n  }\\n\\n  /**\\n   * @dev Modifier that disables function if challenge is not whitelisted\\n   */\\n  modifier onlyWhitelisted() {\\n    require(challenge.isWhitelisted());\\n    _;\\n  }\\n\\n  /**\\n   * @dev Constructor for this contract.\\n   * Native constructor is not used, because users create only forwarders into single instance of this contract,\\n   * therefore constructor must be called explicitly.\\n   * Must NOT be callable multiple times\\n   * Transfers TCR entry token deposit from sender into this contract\\n\\n   * @param _creator Creator of a meme\\n   * @param _version Version of Meme contract\\n   */\\n  function construct(\\n                     address _creator,\\n                     uint _version\\n                     )\\n    public\\n  {\\n    require(challenge.challengePeriodEnd == 0);\\n    deposit = registry.db().getUIntValue(registry.depositKey());\\n    require(registryToken.transferFrom(msg.sender, this, deposit));\\n\\n    challenge.challengePeriodEnd = now.add(registry.db().getUIntValue(registry.challengePeriodDurationKey()));\\n\\n    creator = _creator;\\n    version = _version;\\n  }\\n\\n  /**\\n   * @dev Creates a challenge for this TCR entry\\n   * Must be within challenge period\\n   * Entry can be challenged only once\\n   * Transfers token deposit from challenger into this contract\\n   * Forks registry token (DankToken) in order to create single purpose voting token to vote about this challenge\\n\\n   * @param _challenger Address of a challenger\\n   * @param _challengeMetaHash IPFS hash of meta data related to this challenge\\n   */\\n  function createChallenge(\\n                           address _challenger,\\n                           bytes _challengeMetaHash\\n                           )\\n    external\\n    notEmergency\\n  {\\n    require(challenge.isChallengePeriodActive());\\n    require(!challenge.wasChallenged());\\n    require(registryToken.transferFrom(_challenger, this, deposit));\\n\\n    challenge.challenger = _challenger;\\n    challenge.voteQuorum = registry.db().getUIntValue(registry.voteQuorumKey());\\n    uint commitDuration = registry.db().getUIntValue(registry.commitPeriodDurationKey());\\n    uint revealDuration = registry.db().getUIntValue(registry.revealPeriodDurationKey());\\n\\n    challenge.commitPeriodEnd = now.add(commitDuration);\\n    challenge.revealPeriodEnd = challenge.commitPeriodEnd.add(revealDuration);\\n    challenge.rewardPool = uint(100).sub(registry.db().getUIntValue(registry.challengeDispensationKey())).mul(deposit).div(uint(100));\\n    challenge.metaHash = _challengeMetaHash;\\n\\n    registry.fireChallengeCreatedEvent(version,\\n                                       challenge.challenger,\\n                                       challenge.commitPeriodEnd,\\n                                       challenge.revealPeriodEnd,\\n                                       challenge.rewardPool,\\n                                       challenge.metaHash);\\n  }\\n\\n  /**\\n   * @dev Commits encrypted vote to challenged entry\\n   * Locks voter\\u0027s tokens in this contract. Returns when vote is revealed\\n   * Must be within commit period\\n   * Same address can\\u0027t make a second vote for the same challenge\\n\\n   * @param _voter Address of a voter\\n   * @param _amount Amount of tokens to vote with\\n   * @param _secretHash Encrypted vote option with salt. sha3(voteOption, salt)\\n   */\\n  function commitVote(\\n                      address _voter,\\n                      uint _amount,\\n                      bytes32 _secretHash\\n                      )\\n    external\\n    notEmergency\\n  {\\n    require(challenge.isVoteCommitPeriodActive());\\n    require(_amount \\u003e 0);\\n    require(!challenge.hasVoted(_voter));\\n    require(registryToken.transferFrom(_voter, this, _amount));\\n\\n    challenge.vote[_voter].secretHash = _secretHash;\\n    challenge.vote[_voter].amount += _amount;\\n\\n    registry.fireVoteCommittedEvent(version,\\n                                    _voter,\\n                                    challenge.vote[_voter].amount);\\n  }\\n\\n  /**\\n   * @dev Reveals previously committed vote\\n   * Returns registryToken back to the voter\\n   * Must be within reveal period\\n\\n   * @param _voteOption Vote option voter previously voted with\\n   * @param _salt Salt with which user previously encrypted his vote option\\n   */\\n  function revealVote(\\n                      RegistryEntryLib.VoteOption _voteOption,\\n                      string _salt\\n                      )\\n    external\\n    notEmergency\\n  {\\n    address _voter=msg.sender;\\n    require(challenge.isVoteRevealPeriodActive());\\n    require(keccak256(abi.encodePacked(uint(_voteOption), _salt)) == challenge.vote[_voter].secretHash);\\n    require(!challenge.isVoteRevealed(_voter));\\n\\n    challenge.vote[_voter].revealedOn = now;\\n    uint amount = challenge.vote[_voter].amount;\\n    require(registryToken.transfer(_voter, amount));\\n    challenge.vote[_voter].option = _voteOption;\\n\\n    if (_voteOption == RegistryEntryLib.VoteOption.VoteFor) {\\n      challenge.votesFor = challenge.votesFor.add(amount);\\n    } else if (_voteOption == RegistryEntryLib.VoteOption.VoteAgainst) {\\n      challenge.votesAgainst = challenge.votesAgainst.add(amount);\\n    } else {\\n      revert();\\n    }\\n\\n    registry.fireVoteRevealedEvent(version,\\n                                   _voter,\\n                                   uint(challenge.vote[_voter].option));\\n  }\\n\\n   /**\\n   * @dev Refunds vote deposit after reveal period\\n   * Can be called by anybody, to claim voter\\u0027s reward to him\\n   * Can\\u0027t be called if vote was revealed\\n   * Can\\u0027t be called twice for the same vote\\n   * @param _voter Address of a voter\\n   */\\n  function reclaimVoteAmount(address _voter)\\n    public\\n    notEmergency {\\n\\n    require(challenge.isVoteRevealPeriodOver());\\n    require(!challenge.isVoteRevealed(_voter));\\n    require(!challenge.isVoteAmountReclaimed(_voter));\\n\\n    uint amount = challenge.vote[_voter].amount;\\n    require(registryToken.transfer(_voter, amount));\\n\\n    challenge.vote[_voter].reclaimedVoteAmountOn = now;\\n\\n    registry.fireVoteAmountClaimedEvent(version, _voter);\\n  }\\n\\n\\n  /**\\n   * @dev Claims vote reward after reveal period\\n   * Voter has reward only if voted for winning option\\n   * Voter has reward only when revealed the vote\\n   *\\n   * Claims challenger\\u0027s reward after reveal period\\n   * Challenger has reward only if winning option is VoteAgainst\\n\\n   */\\n  function claimRewards(address _user)\\n    external\\n    notEmergency\\n  {\\n    // Challenge reward\\n    if(challenge.isVoteRevealPeriodOver() \\u0026\\u0026\\n       !challenge.isChallengeRewardClaimed() \\u0026\\u0026\\n       !challenge.isWinningOptionVoteFor() \\u0026\\u0026\\n       challenge.challenger == _user){\\n\\n      registryToken.transfer(challenge.challenger, challenge.challengeReward(deposit));\\n\\n      registry.fireChallengeRewardClaimedEvent(version,\\n                                               challenge.challenger,\\n                                               challenge.challengeReward(deposit));\\n    }\\n\\n    // Votes reward\\n    if(challenge.isVoteRevealPeriodOver() \\u0026\\u0026\\n       !challenge.isVoteRewardClaimed(_user) \\u0026\\u0026\\n       challenge.isVoteRevealed(_user) \\u0026\\u0026\\n       challenge.votedWinningVoteOption(_user)){\\n\\n      uint reward = challenge.voteReward(_user);\\n\\n      if(reward \\u003e 0){\\n        registryToken.transfer(_user, reward);\\n        challenge.vote[_user].claimedRewardOn = now;\\n\\n        registry.fireVoteRewardClaimedEvent(version,\\n                                            _user,\\n                                            reward);\\n      }\\n    }\\n  }\\n\\n  /**\\n   * @dev Function returns the current status of this registry entry\\n   */\\n  function status()\\n    external\\n    constant\\n    returns (uint)\\n  {\\n    return uint(challenge.status());\\n  }\\n\\n  /**\\n   * @dev Function called by MiniMeToken when somebody calls approveAndCall on it.\\n   * This way token can be transferred to a recipient in a single transaction together with execution\\n   * of additional logic\\n\\n   * @param _from Sender of transaction approval\\n   * @param _amount Amount of approved tokens to transfer\\n   * @param _token Token that received the approval\\n   * @param _data Bytecode of a function and passed parameters, that should be called after token approval\\n   */\\n  function receiveApproval(\\n                           address _from,\\n                           uint256 _amount,\\n                           address _token,\\n                           bytes _data)\\n    public\\n  {\\n    require(address(this).call(_data));\\n  }\\n\\n  function load() external constant returns (uint,\\n                                             address,\\n                                             uint,\\n                                             address,\\n                                             uint,\\n                                             uint,\\n                                             uint,\\n                                             uint,\\n                                             bytes,\\n                                             uint){\\n    return (deposit,\\n            creator,\\n            version,\\n            challenge.challenger,\\n            challenge.voteQuorum,\\n            challenge.commitPeriodEnd,\\n            challenge.revealPeriodEnd,\\n            challenge.rewardPool,\\n            challenge.metaHash,\\n            challenge.claimedRewardOn);\\n  }\\n\\n  function loadVote(address voter) external constant returns (bytes32,\\n                                                              uint,\\n                                                              uint,\\n                                                              uint,\\n                                                              uint,\\n                                                              uint){\\n    return(challenge.vote[voter].secretHash,\\n           uint(challenge.vote[voter].option),\\n           challenge.vote[voter].amount,\\n           challenge.vote[voter].revealedOn,\\n           challenge.vote[voter].claimedRewardOn,\\n           challenge.vote[voter].reclaimedVoteAmountOn);\\n  }\\n}\\n\"},\"RegistryEntryLib.sol\":{\"content\":\"pragma solidity ^0.4.24;\\n\\nimport \\\"./Registry.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\n\\nlibrary RegistryEntryLib {\\n\\n  using SafeMath for uint;\\n\\n  enum VoteOption {NoVote, VoteFor, VoteAgainst}\\n\\n  enum Status {ChallengePeriod, CommitPeriod, RevealPeriod, Blacklisted, Whitelisted}\\n\\n  struct Vote {\\n    bytes32 secretHash;\\n    VoteOption option;\\n    uint amount;\\n    uint revealedOn;\\n    uint claimedRewardOn;\\n    uint reclaimedVoteAmountOn;\\n  }\\n\\n  struct Challenge {\\n    address challenger;\\n    uint voteQuorum;\\n    uint rewardPool;\\n    bytes metaHash;\\n    uint commitPeriodEnd;\\n    uint revealPeriodEnd;\\n    uint challengePeriodEnd;\\n    uint votesFor;\\n    uint votesAgainst;\\n    uint claimedRewardOn;\\n    mapping(address =\\u003e Vote) vote;\\n  }\\n\\n  // External functions\\n\\n  /**\\n   * @dev Returns date when registry entry was whitelisted\\n   * Since this doesn\\u0027t happen with any transaction, it\\u0027s either reveal or challenge period end\\n\\n   * @return UNIX time of whitelisting\\n   */\\n  /* function whitelistedOn(Challenge storage self) */\\n  /*   external */\\n  /*   constant */\\n  /*   returns (uint) { */\\n  /*   if (!isWhitelisted()) { */\\n  /*     return 0; */\\n  /*   } */\\n  /*   if (self.wasChallenged()) { */\\n  /*     return self.revealPeriodEnd; */\\n  /*   } else { */\\n  /*     return challengePeriodEnd; */\\n  /*   } */\\n  /* } */\\n\\n  // Internal functions\\n\\n  function isVoteRevealPeriodActive(Challenge storage self)\\n    internal\\n    constant\\n    returns (bool) {\\n    return !isVoteCommitPeriodActive(self) \\u0026\\u0026 now \\u003c= self.revealPeriodEnd;\\n  }\\n\\n  function isVoteRevealed(Challenge storage self, address _voter)\\n    internal\\n    constant\\n    returns (bool) {\\n    return self.vote[_voter].revealedOn \\u003e 0;\\n  }\\n\\n  function isVoteRewardClaimed(Challenge storage self, address _voter)\\n    internal\\n    constant\\n    returns (bool) {\\n    return self.vote[_voter].claimedRewardOn \\u003e 0;\\n  }\\n\\n  function isVoteAmountReclaimed(Challenge storage self, address _voter)\\n    internal\\n    constant\\n    returns (bool) {\\n    return self.vote[_voter].reclaimedVoteAmountOn \\u003e 0;\\n  }\\n\\n  function isChallengeRewardClaimed(Challenge storage self)\\n    internal\\n    constant\\n    returns (bool) {\\n    return self.claimedRewardOn \\u003e 0;\\n  }\\n\\n  function isChallengePeriodActive(Challenge storage self)\\n    internal\\n    constant\\n    returns (bool) {\\n    return now \\u003c= self.challengePeriodEnd;\\n  }\\n\\n  function isWhitelisted(Challenge storage self)\\n    internal\\n    constant\\n    returns (bool) {\\n    return status(self) == Status.Whitelisted;\\n  }\\n\\n  function isVoteCommitPeriodActive(Challenge storage self)\\n    internal\\n    constant\\n    returns (bool) {\\n    return now \\u003c= self.commitPeriodEnd;\\n  }\\n\\n  function isVoteRevealPeriodOver(Challenge storage self)\\n    internal\\n    constant\\n    returns (bool) {\\n    return self.revealPeriodEnd \\u003e 0 \\u0026\\u0026 now \\u003e self.revealPeriodEnd;\\n  }\\n\\n  /**\\n   * @dev Returns whether VoteFor is winning vote option\\n   *\\n   * @return True if VoteFor is winning option\\n   */\\n  function isWinningOptionVoteFor(Challenge storage self)\\n    internal\\n    constant\\n    returns (bool) {\\n    return winningVoteOption(self) == VoteOption.VoteFor;\\n  }\\n\\n  function hasVoted(Challenge storage self, address _voter)\\n    internal\\n    constant\\n    returns (bool) {\\n    return self.vote[_voter].amount != 0;\\n  }\\n\\n  function wasChallenged(Challenge storage self)\\n    internal\\n    constant\\n    returns (bool) {\\n    return self.challenger != 0x0;\\n  }\\n\\n  /**\\n   * @dev Returns whether voter voted for winning vote option\\n   * @param _voter Address of a voter\\n   *\\n   * @return True if voter voted for a winning vote option\\n   */\\n  function votedWinningVoteOption(Challenge storage self, address _voter)\\n    internal\\n    constant\\n    returns (bool) {\\n    return self.vote[_voter].option == winningVoteOption(self);\\n  }\\n\\n  /**\\n   * @dev Returns current status of a registry entry\\n\\n   * @return Status\\n   */\\n  function status(Challenge storage self)\\n    internal\\n    constant\\n    returns (Status) {\\n    if (isChallengePeriodActive(self) \\u0026\\u0026 !wasChallenged(self)) {\\n      return Status.ChallengePeriod;\\n    } else if (isVoteCommitPeriodActive(self)) {\\n      return Status.CommitPeriod;\\n    } else if (isVoteRevealPeriodActive(self)) {\\n      return Status.RevealPeriod;\\n    } else if (isVoteRevealPeriodOver(self)) {\\n      if (isWinningOptionVoteFor(self)) {\\n        return Status.Whitelisted;\\n      } else {\\n        return Status.Blacklisted;\\n      }\\n    } else {\\n      return Status.Whitelisted;\\n    }\\n  }\\n\\n  /**\\n   * @dev Returns token reward amount belonging to a challenger\\n   *\\n   * @return Amount of token\\n   */\\n  function challengeReward(Challenge storage self, uint deposit)\\n    internal\\n    constant\\n    returns (uint) {\\n    return deposit.sub(self.rewardPool);\\n  }\\n\\n  /**\\n   * @dev Returns token reward amount belonging to a voter for voting for a winning option\\n   * @param _voter Address of a voter\\n   *\\n   * @return Amount of tokens\\n   */\\n  function voteReward(Challenge storage self, address _voter)\\n    internal\\n    constant\\n    returns (uint) {\\n    uint winningAmount = winningVotesAmount(self);\\n    uint voterAmount = 0;\\n\\n    if (!votedWinningVoteOption(self, _voter)) {\\n      return voterAmount;\\n    }\\n\\n    voterAmount = self.vote[_voter].amount;\\n    return (voterAmount.mul(self.rewardPool)) / winningAmount;\\n  }\\n\\n  /**\\n   * @dev Returns true when parameter key is in a whitelisted set and the parameter\\n   * value is within the allowed set of values.\\n   */\\n  function isChangeAllowed(Registry registry, bytes32 record, uint _value)\\n    internal\\n    constant\\n    returns (bool) {\\n\\n      if(record == registry.challengePeriodDurationKey() || record == registry.commitPeriodDurationKey() ||\\n         record == registry.revealPeriodDurationKey() || record == registry.depositKey()) {\\n        if(_value \\u003e 0) {\\n          return true;\\n        }\\n      }\\n\\n      if(record == registry.challengeDispensationKey() || record == registry.voteQuorumKey() ||\\n         record == registry.maxTotalSupplyKey()) {\\n        if (_value \\u003e= 0 \\u0026\\u0026 _value \\u003c= 100) {\\n          return true;\\n        }\\n      }\\n\\n      // see MemeAuction.sol startAuction\\n      if(record == registry.maxAuctionDurationKey()) {\\n        if(_value \\u003e= 1 minutes) {\\n          return true;\\n        }\\n      }\\n\\n    return false;\\n  }\\n\\n\\n  function bytesToUint(bytes b)\\n    internal\\n    returns (uint256) {\\n    uint256 number;\\n    for(uint i = 0; i \\u003c b.length; i++){\\n      number = number + uint(b[i]) * (2 ** (8 * (b.length - (i + 1))));\\n    }\\n    return number;\\n  }\\n\\n  function stringToUint(string s)\\n    internal\\n    constant\\n    returns (uint result) {\\n    bytes memory b = bytes(s);\\n    uint i;\\n    result = 0;\\n    for (i = 0; i \\u003c b.length; i++) {\\n      uint c = uint(b[i]);\\n      if (c \\u003e= 48 \\u0026\\u0026 c \\u003c= 57) {\\n        result = result * 10 + (c - 48);\\n      }\\n    }\\n  }\\n\\n  // Private functions\\n\\n  function isBlacklisted(Challenge storage self)\\n    private\\n    constant\\n    returns (bool) {\\n    return status(self) == Status.Blacklisted;\\n  }\\n\\n  /**\\n   * @dev Returns winning vote option in held voting according to vote quorum\\n   * If voteQuorum is 50, any majority of votes will win\\n   * If voteQuorum is 24, only 25 votes out of 100 is enough to VoteFor be winning option\\n   *\\n   * @return Winning vote option\\n   */\\n  function winningVoteOption(Challenge storage self)\\n    private\\n    constant\\n    returns (VoteOption) {\\n    if (!isVoteRevealPeriodOver(self)) {\\n      return VoteOption.NoVote;\\n    }\\n\\n    if (self.votesFor.mul(100) \\u003e self.voteQuorum.mul(self.votesFor.add(self.votesAgainst))) {\\n      return VoteOption.VoteFor;\\n    } else {\\n      return VoteOption.VoteAgainst;\\n    }\\n  }\\n\\n  /**\\n   * @dev Returns amount of votes for winning vote option\\n   *\\n   * @return Amount of votes\\n   */\\n  function winningVotesAmount(Challenge storage self)\\n    private\\n    constant\\n    returns (uint) {\\n    VoteOption voteOption = winningVoteOption(self);\\n\\n    if (voteOption == VoteOption.VoteFor) {\\n      return self.votesFor;\\n    } else if (voteOption == VoteOption.VoteAgainst) {\\n      return self.votesAgainst;\\n    } else {\\n      return 0;\\n    }\\n  }\\n\\n}\\n\"},\"SafeMath.sol\":{\"content\":\"pragma solidity ^0.4.18;\\n\\n\\n/**\\n * @title SafeMath\\n * @dev Math operations with safety checks that throw on error\\n */\\nlibrary SafeMath {\\n\\n  /**\\n  * @dev Multiplies two numbers, throws on overflow.\\n  */\\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n    if (a == 0) {\\n      return 0;\\n    }\\n    uint256 c = a * b;\\n    assert(c / a == b);\\n    return c;\\n  }\\n\\n  /**\\n  * @dev Integer division of two numbers, truncating the quotient.\\n  */\\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n    // assert(b \\u003e 0); // Solidity automatically throws when dividing by 0\\n    uint256 c = a / b;\\n    // assert(a == b * c + a % b); // There is no case in which this doesn\\u0027t hold\\n    return c;\\n  }\\n\\n  /**\\n  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\\n  */\\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n    assert(b \\u003c= a);\\n    return a - b;\\n  }\\n\\n  /**\\n  * @dev Adds two numbers, throws on overflow.\\n  */\\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n    uint256 c = a + b;\\n    assert(c \\u003e= a);\\n    return c;\\n  }\\n}\\n\"},\"TokenController.sol\":{\"content\":\"pragma solidity ^0.4.18;\\n\\n/// @dev The token controller contract must implement these functions\\ncontract TokenController {\\n  /// @notice Called when `_owner` sends ether to the MiniMe Token contract\\n  /// @param _owner The address that sent the ether to create tokens\\n  /// @return True if the ether is accepted, false if it throws\\n  function proxyPayment(address _owner) public payable returns(bool);\\n\\n  /// @notice Notifies the controller about a token transfer allowing the\\n  ///  controller to react if desired\\n  /// @param _from The origin of the transfer\\n  /// @param _to The destination of the transfer\\n  /// @param _amount The amount of the transfer\\n  /// @return False if the controller does not authorize the transfer\\n  function onTransfer(address _from, address _to, uint _amount) public returns(bool);\\n\\n  /// @notice Notifies the controller about an approval allowing the\\n  ///  controller to react if desired\\n  /// @param _owner The address that calls `approve()`\\n  /// @param _spender The spender in the `approve()` call\\n  /// @param _amount The amount in the `approve()` call\\n  /// @return False if the controller does not authorize the approval\\n  function onApprove(address _owner, address _spender, uint _amount) public\\n  returns(bool);\\n}\\n\"}}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"challengeDispensationKey\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_isEmergency\",\"type\":\"bool\"}],\"name\":\"setEmergency\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"depositKey\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"factory\",\"type\":\"address\"}],\"name\":\"isFactory\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"owner_\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxAuctionDurationKey\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"db\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"version\",\"type\":\"uint256\"},{\"name\":\"creator\",\"type\":\"address\"},{\"name\":\"db\",\"type\":\"address\"},{\"name\":\"key\",\"type\":\"string\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"deposit\",\"type\":\"uint256\"},{\"name\":\"challengePeriodEnd\",\"type\":\"uint256\"}],\"name\":\"fireParamChangeConstructedEvent\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"version\",\"type\":\"uint256\"},{\"name\":\"voter\",\"type\":\"address\"},{\"name\":\"option\",\"type\":\"uint256\"}],\"name\":\"fireVoteRevealedEvent\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"version\",\"type\":\"uint256\"}],\"name\":\"fireParamChangeAppliedEvent\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isEmergency\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"revealPeriodDurationKey\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"challengePeriodDurationKey\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"registryEntry\",\"type\":\"address\"}],\"name\":\"isRegistryEntry\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_factory\",\"type\":\"address\"},{\"name\":\"_isFactory\",\"type\":\"bool\"}],\"name\":\"setFactory\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_registryEntry\",\"type\":\"address\"}],\"name\":\"addRegistryEntry\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"version\",\"type\":\"uint256\"},{\"name\":\"voter\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"fireVoteRewardClaimedEvent\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"commitPeriodDurationKey\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"authority_\",\"type\":\"address\"}],\"name\":\"setAuthority\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"version\",\"type\":\"uint256\"},{\"name\":\"creator\",\"type\":\"address\"},{\"name\":\"metaHash\",\"type\":\"bytes\"},{\"name\":\"totalSupply\",\"type\":\"uint256\"},{\"name\":\"deposit\",\"type\":\"uint256\"},{\"name\":\"challengePeriodEnd\",\"type\":\"uint256\"}],\"name\":\"fireMemeConstructedEvent\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"version\",\"type\":\"uint256\"},{\"name\":\"voter\",\"type\":\"address\"}],\"name\":\"fireVoteAmountClaimedEvent\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"version\",\"type\":\"uint256\"},{\"name\":\"challenger\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"fireChallengeRewardClaimedEvent\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_paramChange\",\"type\":\"address\"}],\"name\":\"applyParamChange\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"authority\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"version\",\"type\":\"uint256\"},{\"name\":\"voter\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"fireVoteCommittedEvent\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxTotalSupplyKey\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"voteQuorumKey\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"version\",\"type\":\"uint256\"},{\"name\":\"creator\",\"type\":\"address\"},{\"name\":\"tokenStartId\",\"type\":\"uint256\"},{\"name\":\"tokenEndId\",\"type\":\"uint256\"},{\"name\":\"totalMinted\",\"type\":\"uint256\"}],\"name\":\"fireMemeMintedEvent\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"version\",\"type\":\"uint256\"},{\"name\":\"challenger\",\"type\":\"address\"},{\"name\":\"commitPeriodEnd\",\"type\":\"uint256\"},{\"name\":\"revealPeriodEnd\",\"type\":\"uint256\"},{\"name\":\"rewardPool\",\"type\":\"uint256\"},{\"name\":\"metahash\",\"type\":\"bytes\"}],\"name\":\"fireChallengeCreatedEvent\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_db\",\"type\":\"address\"}],\"name\":\"construct\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"registryEntry\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"version\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"creator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"metaHash\",\"type\":\"bytes\"},{\"indexed\":false,\"name\":\"totalSupply\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"deposit\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"challengePeriodEnd\",\"type\":\"uint256\"}],\"name\":\"MemeConstructedEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"registryEntry\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"version\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"creator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokenStartId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokenEndId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"totalMinted\",\"type\":\"uint256\"}],\"name\":\"MemeMintedEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"registryEntry\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"version\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"challenger\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"commitPeriodEnd\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"revealPeriodEnd\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"rewardPool\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"metahash\",\"type\":\"bytes\"}],\"name\":\"ChallengeCreatedEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"registryEntry\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"version\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"voter\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"VoteCommittedEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"registryEntry\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"version\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"voter\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"option\",\"type\":\"uint256\"}],\"name\":\"VoteRevealedEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"registryEntry\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"version\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"voter\",\"type\":\"address\"}],\"name\":\"VoteAmountClaimedEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"registryEntry\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"version\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"voter\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"VoteRewardClaimedEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"registryEntry\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"version\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"challenger\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ChallengeRewardClaimedEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"registryEntry\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"version\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"creator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"db\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"key\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"deposit\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"challengePeriodEnd\",\"type\":\"uint256\"}],\"name\":\"ParamChangeConstructedEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"registryEntry\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"version\",\"type\":\"uint256\"}],\"name\":\"ParamChangeAppliedEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"authority\",\"type\":\"address\"}],\"name\":\"LogSetAuthority\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"LogSetOwner\",\"type\":\"event\"}]","ContractName":"ParamChangeRegistry","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://d3cea2defbcf4dd665d2c102101bbd1ffa6989a69548e5ead6adb8adc6469060"}]}