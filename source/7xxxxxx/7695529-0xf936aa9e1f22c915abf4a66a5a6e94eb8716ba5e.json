{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.25;\r\n\r\n/**\r\n * \r\n * World War Goo - Competitive Idle Game\r\n * \r\n * https://ethergoo.io\r\n * \r\n */\r\n\r\n\r\ncontract Units {\r\n\r\n    GooToken constant goo = GooToken(0xdf0960778c6e6597f197ed9a25f12f5d971da86c);\r\n    Army army = Army(0x0);\r\n    Clans clans = Clans(0x0);\r\n    Factories constant factories = Factories(0xc81068cd335889736fc485592e4d73a82403d44b);\r\n\r\n    mapping(address => mapping(uint256 => UnitsOwned)) public unitsOwned;\r\n    mapping(address => mapping(uint256 => UnitExperience)) public unitExp;\r\n    mapping(address => mapping(uint256 => uint256)) private unitMaxCap;\r\n\r\n    mapping(address => mapping(uint256 => UnitUpgrades)) private unitUpgrades;\r\n    mapping(address => mapping(uint256 => UpgradesOwned)) public upgradesOwned; // For each unitId, which upgrades owned (3 columns of uint64)\r\n\r\n    mapping(uint256 => Unit) public unitList;\r\n    mapping(uint256 => Upgrade) public upgradeList;\r\n    mapping(address => bool) operator;\r\n\r\n    address owner;\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    struct UnitsOwned {\r\n        uint80 units;\r\n        uint8 factoryBuiltFlag; // Incase user sells units, we still want to keep factory\r\n    }\r\n\r\n    struct UnitExperience {\r\n        uint224 experience;\r\n        uint32 level;\r\n    }\r\n\r\n    struct UnitUpgrades {\r\n        uint32 prodIncrease;\r\n        uint32 prodMultiplier;\r\n\r\n        uint32 attackIncrease;\r\n        uint32 attackMultiplier;\r\n        uint32 defenseIncrease;\r\n        uint32 defenseMultiplier;\r\n        uint32 lootingIncrease;\r\n        uint32 lootingMultiplier;\r\n    }\r\n\r\n    struct UpgradesOwned {\r\n        uint64 column0;\r\n        uint64 column1;\r\n        uint64 column2;\r\n    }\r\n\r\n\r\n    // Unit & Upgrade data:\r\n    \r\n    struct Unit {\r\n        uint256 unitId;\r\n        uint224 gooCost;\r\n        uint256 baseProduction;\r\n        uint80 attack;\r\n        uint80 defense;\r\n        uint80 looting;\r\n    }\r\n\r\n    struct Upgrade {\r\n        uint256 upgradeId;\r\n        uint224 gooCost;\r\n        uint256 unitId;\r\n        uint256 column; // Columns of upgrades (1st & 2nd are unit specific, then 3rd is capacity)\r\n        uint256 prerequisiteUpgrade;\r\n\r\n        uint256 unitMaxCapacityGain;\r\n        uint32 prodIncrease;\r\n        uint32 prodMultiplier;\r\n        uint32 attackIncrease;\r\n        uint32 attackMultiplier;\r\n        uint32 defenseIncrease;\r\n        uint32 defenseMultiplier;\r\n        uint32 lootingIncrease;\r\n        uint32 lootingMultiplier;\r\n    }\r\n\r\n    function setArmy(address armyContract) external {\r\n        require(msg.sender == owner);\r\n        army = Army(armyContract);\r\n    }\r\n\r\n    function setClans(address clansContract) external {\r\n        require(msg.sender == owner);\r\n        clans = Clans(clansContract);\r\n    }\r\n\r\n    function setOperator(address gameContract, bool isOperator) external {\r\n        require(msg.sender == owner);\r\n        operator[gameContract] = isOperator;\r\n    }\r\n\r\n    function mintUnitExternal(uint256 unit, uint80 amount, address player, uint8 chosenPosition) external {\r\n        require(operator[msg.sender]);\r\n        mintUnit(unit, amount, player, chosenPosition);\r\n    }\r\n\r\n    function mintUnit(uint256 unit, uint80 amount, address player, uint8 chosenPosition) internal {\r\n        UnitsOwned storage existingUnits = unitsOwned[player][unit];\r\n        if (existingUnits.factoryBuiltFlag == 0) {\r\n            // Edge case to create factory for player (on empty tile) where it is their first unit\r\n            uint256[] memory existingFactories = factories.getFactories(player);\r\n            uint256 length = existingFactories.length;\r\n\r\n            // Provided position is not valid so find valid factory position\r\n            if (chosenPosition >= factories.MAX_SIZE() || (chosenPosition < length && existingFactories[chosenPosition] > 0)) {\r\n                chosenPosition = 0;\r\n                while (chosenPosition < length && existingFactories[chosenPosition] > 0) {\r\n                    chosenPosition++;\r\n                }\r\n            }\r\n\r\n            factories.addFactory(player, chosenPosition, unit);\r\n            unitsOwned[player][unit] = UnitsOwned(amount, 1); // 1 = Flag to say factory exists\r\n        } else {\r\n            existingUnits.units += amount;\r\n        }\r\n\r\n        (uint80 attackStats, uint80 defenseStats, uint80 lootingStats) = getUnitsCurrentBattleStats(player, unit);\r\n        if (attackStats > 0 || defenseStats > 0 || lootingStats > 0) {\r\n            army.increasePlayersArmyPowerTrio(player, attackStats * amount, defenseStats * amount, lootingStats * amount);\r\n        } else {\r\n            uint256 prodIncrease = getUnitsCurrentProduction(player, unit) * amount;\r\n            goo.increasePlayersGooProduction(player, prodIncrease / 100);\r\n        }\r\n    }\r\n\r\n\r\n    function deleteUnitExternal(uint80 amount, uint256 unit, address player) external {\r\n        require(operator[msg.sender]);\r\n        deleteUnit(amount, unit, player);\r\n    }\r\n\r\n    function deleteUnit(uint80 amount, uint256 unit, address player) internal {\r\n        (uint80 attackStats, uint80 defenseStats, uint80 lootingStats) = getUnitsCurrentBattleStats(player, unit);\r\n        if (attackStats > 0 || defenseStats > 0 || lootingStats > 0) {\r\n            army.decreasePlayersArmyPowerTrio(player, attackStats * amount, defenseStats * amount, lootingStats * amount);\r\n        } else {\r\n            uint256 prodDecrease = getUnitsCurrentProduction(player, unit) * amount;\r\n            goo.decreasePlayersGooProduction(player, prodDecrease / 100);\r\n        }\r\n        unitsOwned[player][unit].units -= amount;\r\n    }\r\n\r\n\r\n    function getUnitsCurrentBattleStats(address player, uint256 unitId) internal view returns (uint80 attack, uint80 defense, uint80 looting) {\r\n        Unit memory unit = unitList[unitId];\r\n        UnitUpgrades memory existingUpgrades = unitUpgrades[player][unitId];\r\n        attack = (unit.attack + existingUpgrades.attackIncrease) * (100 + existingUpgrades.attackMultiplier);\r\n        defense = (unit.defense + existingUpgrades.defenseIncrease) * (100 + existingUpgrades.defenseMultiplier);\r\n        looting = (unit.looting + existingUpgrades.lootingIncrease) * (100 + existingUpgrades.lootingMultiplier);\r\n    }\r\n    \r\n    function getUnitsCurrentProduction(address player, uint256 unitId) public view returns (uint256) {\r\n        UnitUpgrades memory existingUpgrades = unitUpgrades[player][unitId];\r\n        return (unitList[unitId].baseProduction + existingUpgrades.prodIncrease) * (100 + existingUpgrades.prodMultiplier);\r\n    }\r\n\r\n\r\n    function buyUnit(uint256 unitId, uint80 amount, uint8 position) external {\r\n        uint224 gooCost = SafeMath224.mul(unitList[unitId].gooCost, amount);\r\n        require(gooCost > 0); // Valid unit\r\n\r\n        uint80 newTotal = unitsOwned[msg.sender][unitId].units + amount;\r\n        if (newTotal > 99) {\r\n            require(newTotal < 99 + unitMaxCap[msg.sender][unitId]);\r\n        }\r\n\r\n        // Clan discount\r\n        uint224 unitDiscount = clans.getPlayersClanUpgrade(msg.sender, 1); // class 1 = unit discount\r\n        uint224 reducedGooCost = gooCost - ((gooCost * unitDiscount) / 100);\r\n        uint224 seventyFivePercentRefund = (gooCost * 3) / 4;\r\n\r\n        // Update players goo\r\n        goo.updatePlayersGooFromPurchase(msg.sender, reducedGooCost);\r\n        goo.mintGoo(seventyFivePercentRefund, this); // 75% refund is stored (in this contract) for when player sells unit\r\n        army.depositSpentGoo(reducedGooCost - seventyFivePercentRefund); // Upto 25% Goo spent goes to divs (Remaining is discount + 75% player gets back when selling unit)\r\n        mintUnit(unitId, amount, msg.sender, position);\r\n    }\r\n\r\n\r\n    function sellUnit(uint256 unitId, uint80 amount) external {\r\n        require(unitsOwned[msg.sender][unitId].units >= amount && amount > 0);\r\n\r\n        uint224 gooCost = unitList[unitId].gooCost;\r\n        require(gooCost > 0);\r\n\r\n        goo.updatePlayersGoo(msg.sender);\r\n        deleteUnit(amount, unitId, msg.sender);\r\n        goo.transfer(msg.sender, (gooCost * amount * 3) / 4); // Refund 75%\r\n    }\r\n\r\n\r\n    function grantArmyExp(address player, uint256 unitId, uint224 amount) external returns(bool) {\r\n        require(operator[msg.sender]);\r\n\r\n        UnitExperience memory existingExp = unitExp[player][unitId];\r\n        uint224 expRequirement = (existingExp.level + 1) * 80; // Lvl 1: 80; Lvl 2: 160, Lvl 3: 240 (480 in total) etc.\r\n\r\n        if (existingExp.experience + amount >= expRequirement) {\r\n            existingExp.experience = (existingExp.experience + amount) - expRequirement;\r\n            existingExp.level++;\r\n            unitExp[player][unitId] = existingExp;\r\n\r\n            // Grant buff to unit (5% additive multiplier)\r\n            UnitUpgrades memory existingUpgrades = unitUpgrades[player][unitId];\r\n            existingUpgrades.attackMultiplier += 5;\r\n            existingUpgrades.defenseMultiplier += 5;\r\n            existingUpgrades.lootingMultiplier += 5;\r\n            unitUpgrades[player][unitId] = existingUpgrades;\r\n\r\n            // Increase player's army power\r\n            uint80 multiplierGain = unitsOwned[player][unitId].units * 5;\r\n\r\n            Unit memory unit = unitList[unitId];\r\n            uint80 attackGain = multiplierGain * (unit.attack + existingUpgrades.attackIncrease);\r\n            uint80 defenseGain = multiplierGain * (unit.defense + existingUpgrades.defenseIncrease);\r\n            uint80 lootingGain = multiplierGain * (unit.looting + existingUpgrades.lootingIncrease);\r\n            army.increasePlayersArmyPowerTrio(player, attackGain, defenseGain, lootingGain);\r\n            return true;\r\n        } else {\r\n            unitExp[player][unitId].experience += amount;\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function increaseUnitCapacity(address player, uint256 upgradeGain, uint256 unitId) external {\r\n        require(operator[msg.sender]);\r\n        unitMaxCap[player][unitId] += upgradeGain;\r\n    }\r\n\r\n    function decreaseUnitCapacity(address player, uint256 upgradeGain, uint256 unitId) external {\r\n        require(operator[msg.sender]);\r\n        unitMaxCap[player][unitId] -= upgradeGain;\r\n    }\r\n\r\n\r\n    function increaseUpgradesExternal(address player, uint256 unitId, uint32 prodIncrease, uint32 prodMultiplier, uint32 attackIncrease, uint32 attackMultiplier, uint32 defenseIncrease, uint32 defenseMultiplier, uint32 lootingIncrease, uint32 lootingMultiplier) external {\r\n        require(operator[msg.sender]);\r\n        Upgrade memory upgrade = Upgrade(0,0,0,0,0,0, prodIncrease, prodMultiplier, attackIncrease, attackMultiplier, defenseIncrease, defenseMultiplier, lootingIncrease, lootingMultiplier);\r\n        increaseUpgrades(player, upgrade, unitId);\r\n    }\r\n\r\n\r\n    function increaseUpgrades(address player, Upgrade upgrade, uint256 unitId) internal {\r\n        uint80 units = unitsOwned[player][unitId].units;\r\n        UnitUpgrades memory existingUpgrades = unitUpgrades[player][unitId];\r\n\r\n        Unit memory unit = unitList[unitId];\r\n        if (unit.baseProduction > 0) {\r\n            // Increase goo production\r\n            uint256 prodGain = units * upgrade.prodMultiplier * (unit.baseProduction + existingUpgrades.prodIncrease); // Multiplier gains\r\n            prodGain += units * upgrade.prodIncrease * (100 + existingUpgrades.prodMultiplier); // Base prod gains\r\n\r\n            goo.updatePlayersGoo(player);\r\n            goo.increasePlayersGooProduction(player, prodGain / 100);\r\n        } else {\r\n            // Increase army power\r\n            uint80 attackGain = units * upgrade.attackMultiplier * (unit.attack + existingUpgrades.attackIncrease); // Multiplier gains\r\n            uint80 defenseGain = units * upgrade.defenseMultiplier * (unit.defense + existingUpgrades.defenseIncrease); // Multiplier gains\r\n            uint80 lootingGain = units * upgrade.lootingMultiplier * (unit.looting + existingUpgrades.lootingIncrease); // Multiplier gains\r\n\r\n            attackGain += units * upgrade.attackIncrease * (100 + existingUpgrades.attackMultiplier); // + Base gains\r\n            defenseGain += units * upgrade.defenseIncrease * (100 + existingUpgrades.defenseMultiplier); // + Base gains\r\n            lootingGain += units * upgrade.lootingIncrease * (100 + existingUpgrades.lootingMultiplier); // + Base gains\r\n\r\n            army.increasePlayersArmyPowerTrio(player, attackGain, defenseGain, lootingGain);\r\n        }\r\n\r\n        existingUpgrades.prodIncrease += upgrade.prodIncrease;\r\n        existingUpgrades.prodMultiplier += upgrade.prodMultiplier;\r\n        existingUpgrades.attackIncrease += upgrade.attackIncrease;\r\n        existingUpgrades.attackMultiplier += upgrade.attackMultiplier;\r\n        existingUpgrades.defenseIncrease += upgrade.defenseIncrease;\r\n        existingUpgrades.defenseMultiplier += upgrade.defenseMultiplier;\r\n        existingUpgrades.lootingIncrease += upgrade.lootingIncrease;\r\n        existingUpgrades.lootingMultiplier += upgrade.lootingMultiplier;\r\n        unitUpgrades[player][unitId] = existingUpgrades;\r\n    }\r\n\r\n\r\n    function decreaseUpgradesExternal(address player, uint256 unitId, uint32 prodIncrease, uint32 prodMultiplier, uint32 attackIncrease, uint32 attackMultiplier, uint32 defenseIncrease, uint32 defenseMultiplier, uint32 lootingIncrease, uint32 lootingMultiplier) external {\r\n        require(operator[msg.sender]);\r\n        Upgrade memory upgrade = Upgrade(0,0,0,0,0,0, prodIncrease, prodMultiplier, attackIncrease, attackMultiplier, defenseIncrease, defenseMultiplier, lootingIncrease, lootingMultiplier);\r\n        decreaseUpgrades(player, upgrade, unitId);\r\n    }\r\n\r\n\r\n    function decreaseUpgrades(address player, Upgrade upgrade, uint256 unitId) internal {\r\n        uint80 units = unitsOwned[player][unitId].units;\r\n        UnitUpgrades memory existingUpgrades = unitUpgrades[player][unitId];\r\n\r\n        Unit memory unit = unitList[unitId];\r\n        if (unit.baseProduction > 0) {\r\n            // Decrease goo production\r\n            uint256 prodLoss = units * upgrade.prodMultiplier * (unit.baseProduction + existingUpgrades.prodIncrease); // Multiplier losses\r\n            prodLoss += units * upgrade.prodIncrease * (100 + existingUpgrades.prodMultiplier); // Base prod losses\r\n\r\n            goo.updatePlayersGoo(player);\r\n            goo.decreasePlayersGooProduction(player, prodLoss / 100);\r\n        } else {\r\n            // Decrease army power\r\n            uint80 attackLoss = units * upgrade.attackMultiplier * (unit.attack + existingUpgrades.attackIncrease); // Multiplier losses\r\n            uint80 defenseLoss = units * upgrade.defenseMultiplier * (unit.defense + existingUpgrades.defenseIncrease); // Multiplier losses\r\n            uint80 lootingLoss = units * upgrade.lootingMultiplier * (unit.looting + existingUpgrades.lootingIncrease); // Multiplier losses\r\n\r\n            attackLoss += units * upgrade.attackIncrease * (100 + existingUpgrades.attackMultiplier); // + Base losses\r\n            defenseLoss += units * upgrade.defenseIncrease * (100 + existingUpgrades.defenseMultiplier); // + Base losses\r\n            lootingLoss += units * upgrade.lootingIncrease * (100 + existingUpgrades.lootingMultiplier); // + Base losses\r\n            army.decreasePlayersArmyPowerTrio(player, attackLoss, defenseLoss, lootingLoss);\r\n        }\r\n\r\n        existingUpgrades.prodIncrease -= upgrade.prodIncrease;\r\n        existingUpgrades.prodMultiplier -= upgrade.prodMultiplier;\r\n        existingUpgrades.attackIncrease -= upgrade.attackIncrease;\r\n        existingUpgrades.attackMultiplier -= upgrade.attackMultiplier;\r\n        existingUpgrades.defenseIncrease -= upgrade.defenseIncrease;\r\n        existingUpgrades.defenseMultiplier -= upgrade.defenseMultiplier;\r\n        existingUpgrades.lootingIncrease -= upgrade.lootingIncrease;\r\n        existingUpgrades.lootingMultiplier -= upgrade.lootingMultiplier;\r\n        unitUpgrades[player][unitId] = existingUpgrades;\r\n    }\r\n\r\n    function swapUpgradesExternal(address player, uint256 unitId, uint32[8] upgradeGains, uint32[8] upgradeLosses) external {\r\n        require(operator[msg.sender]);\r\n\r\n        UnitUpgrades memory existingUpgrades = unitUpgrades[player][unitId];\r\n        Unit memory unit = unitList[unitId];\r\n\r\n        if (unit.baseProduction > 0) {\r\n            // Change goo production\r\n            gooProductionChange(player, unitId, existingUpgrades, unit.baseProduction, upgradeGains, upgradeLosses);\r\n        } else {\r\n            // Change army power\r\n            armyPowerChange(player, existingUpgrades, unit, upgradeGains, upgradeLosses);\r\n        }\r\n    }\r\n    \r\n    function armyPowerChange(address player, UnitUpgrades existingUpgrades, Unit unit, uint32[8] upgradeGains, uint32[8] upgradeLosses) internal {\r\n        int256 existingAttack = int256((unit.attack + existingUpgrades.attackIncrease) * (100 + existingUpgrades.attackMultiplier));\r\n        int256 existingDefense = int256((unit.defense + existingUpgrades.defenseIncrease) * (100 + existingUpgrades.defenseMultiplier));\r\n        int256 existingLooting = int256((unit.looting + existingUpgrades.lootingIncrease) * (100 + existingUpgrades.lootingMultiplier));\r\n    \r\n        existingUpgrades.attackIncrease = uint32(int(existingUpgrades.attackIncrease) + (int32(upgradeGains[2]) - int32(upgradeLosses[2])));\r\n        existingUpgrades.attackMultiplier = uint32(int(existingUpgrades.attackMultiplier) + (int32(upgradeGains[3]) - int32(upgradeLosses[3])));\r\n        existingUpgrades.defenseIncrease = uint32(int(existingUpgrades.defenseIncrease) + (int32(upgradeGains[4]) - int32(upgradeLosses[4])));\r\n        existingUpgrades.defenseMultiplier = uint32(int(existingUpgrades.defenseMultiplier) + (int32(upgradeGains[5]) - int32(upgradeLosses[5])));\r\n        existingUpgrades.lootingIncrease = uint32(int(existingUpgrades.lootingIncrease) + (int32(upgradeGains[6]) - int32(upgradeLosses[6])));\r\n        existingUpgrades.lootingMultiplier = uint32(int(existingUpgrades.lootingMultiplier) + (int32(upgradeGains[7]) - int32(upgradeLosses[7])));\r\n        \r\n        int256 attackChange = ((int256(unit.attack) + existingUpgrades.attackIncrease) * (100 + existingUpgrades.attackMultiplier)) - existingAttack;\r\n        int256 defenseChange = ((int256(unit.defense) + existingUpgrades.defenseIncrease) * (100 + existingUpgrades.defenseMultiplier)) - existingDefense;\r\n        int256 lootingChange = ((int256(unit.looting) + existingUpgrades.lootingIncrease) * (100 + existingUpgrades.lootingMultiplier)) - existingLooting;\r\n        \r\n        uint256 unitId = unit.unitId;\r\n        int256 units = int256(unitsOwned[player][unitId].units);\r\n        \r\n        army.changePlayersArmyPowerTrio(player, units * attackChange, units * defenseChange, units * lootingChange);\r\n        unitUpgrades[player][unitId] = existingUpgrades;\r\n    }\r\n    \r\n    function gooProductionChange(address player, uint256 unitId, UnitUpgrades existingUpgrades, uint256 baseProduction, uint32[8] upgradeGains, uint32[8] upgradeLosses) internal {\r\n        goo.updatePlayersGoo(player);\r\n        \r\n        int256 existingProd = int256((baseProduction + existingUpgrades.prodIncrease) * (100 + existingUpgrades.prodMultiplier));\r\n        existingUpgrades.prodIncrease = uint32(int(existingUpgrades.prodIncrease) + (int32(upgradeGains[0]) - int32(upgradeLosses[0])));\r\n        existingUpgrades.prodMultiplier = uint32(int(existingUpgrades.prodMultiplier) + (int32(upgradeGains[1]) - int32(upgradeLosses[1])));            \r\n        \r\n        int256 prodChange = ((int256(baseProduction) + existingUpgrades.prodIncrease) * (100 + existingUpgrades.prodMultiplier)) - existingProd;\r\n        if (prodChange > 0) {\r\n            goo.increasePlayersGooProduction(player, (unitsOwned[player][unitId].units * uint256(prodChange)) / 100);\r\n        } else {\r\n            goo.decreasePlayersGooProduction(player, (unitsOwned[player][unitId].units * uint256(-prodChange)) / 100);\r\n        }\r\n        \r\n        unitUpgrades[player][unitId] = existingUpgrades;\r\n    }\r\n\r\n    function addUnit(uint256 id, uint224 baseGooCost, uint256 baseGooProduction, uint80 baseAttack, uint80 baseDefense, uint80 baseLooting) external {\r\n        require(operator[msg.sender]);\r\n        unitList[id] = Unit(id, baseGooCost, baseGooProduction, baseAttack, baseDefense, baseLooting);\r\n    }\r\n\r\n\r\n    function addUpgrade(uint256 id, uint224 gooCost, uint256 unit, uint256 column, uint256 prereq, uint256 unitMaxCapacityGain, uint32[8] upgradeGains) external {\r\n        require(operator[msg.sender]);\r\n        upgradeList[id] = Upgrade(id, gooCost, unit, column, prereq, unitMaxCapacityGain, upgradeGains[0], upgradeGains[1], upgradeGains[2], upgradeGains[3], upgradeGains[4], upgradeGains[5], upgradeGains[6], upgradeGains[7]);\r\n    }\r\n\r\n    function buyUpgrade(uint64 upgradeId) external {\r\n        Upgrade memory upgrade = upgradeList[upgradeId];\r\n        uint256 unitId = upgrade.unitId;\r\n        UpgradesOwned memory ownedUpgrades = upgradesOwned[msg.sender][unitId];\r\n\r\n        uint64 latestUpgradeOwnedForColumn;\r\n        if (upgrade.column == 0) {\r\n            latestUpgradeOwnedForColumn = ownedUpgrades.column0;\r\n            ownedUpgrades.column0 = upgradeId;  // Update upgradesOwned\r\n        } else if (upgrade.column == 1) {\r\n            latestUpgradeOwnedForColumn = ownedUpgrades.column1;\r\n            ownedUpgrades.column1 = upgradeId;  // Update upgradesOwned\r\n        } else if (upgrade.column == 2) {\r\n            latestUpgradeOwnedForColumn = ownedUpgrades.column2;\r\n            ownedUpgrades.column2 = upgradeId;  // Update upgradesOwned\r\n        }\r\n        upgradesOwned[msg.sender][unitId] = ownedUpgrades;\r\n\r\n        require(unitId > 0); // Valid upgrade\r\n        require(latestUpgradeOwnedForColumn < upgradeId); // Haven't already purchased\r\n        require(latestUpgradeOwnedForColumn >= upgrade.prerequisiteUpgrade); // Own prequisite\r\n\r\n        // Clan discount\r\n        uint224 upgradeDiscount = clans.getPlayersClanUpgrade(msg.sender, 0); // class 0 = upgrade discount\r\n        uint224 reducedUpgradeCost = upgrade.gooCost - ((upgrade.gooCost * upgradeDiscount) / 100);\r\n\r\n        // Update players goo\r\n        goo.updatePlayersGooFromPurchase(msg.sender, reducedUpgradeCost);\r\n        army.depositSpentGoo(reducedUpgradeCost); // Transfer to goo bankroll\r\n\r\n        // Update stats for upgrade\r\n        if (upgrade.column == 2) {\r\n            unitMaxCap[msg.sender][unitId] += upgrade.unitMaxCapacityGain;\r\n        } else if (upgrade.column == 1) {\r\n            increaseUpgrades(msg.sender, upgrade, unitId);\r\n        } else if (upgrade.column == 0) {\r\n            increaseUpgrades(msg.sender, upgrade, unitId);\r\n        }\r\n    }\r\n\r\n}\r\n\r\n\r\n\r\n\r\ncontract GooToken {\r\n    function transfer(address to, uint256 tokens) external returns (bool);\r\n    function increasePlayersGooProduction(address player, uint256 increase) external;\r\n    function decreasePlayersGooProduction(address player, uint256 decrease) external;\r\n    function updatePlayersGooFromPurchase(address player, uint224 purchaseCost) external;\r\n    function updatePlayersGoo(address player) external;\r\n    function mintGoo(uint224 amount, address player) external;\r\n}\r\n\r\ncontract Army {\r\n    function depositSpentGoo(uint224 gooSpent) external;\r\n    function increasePlayersArmyPowerTrio(address player, uint80 attackGain, uint80 defenseGain, uint80 lootingGain) public;\r\n    function decreasePlayersArmyPowerTrio(address player, uint80 attackLoss, uint80 defenseLoss, uint80 lootingLoss) public;\r\n    function changePlayersArmyPowerTrio(address player, int attackChange, int defenseChange, int lootingChange) public;\r\n\r\n}\r\n\r\ncontract Clans {\r\n    mapping(uint256 => uint256) public clanTotalArmyPower;\r\n    function totalSupply() external view returns (uint256);\r\n    function depositGoo(uint256 amount, uint256 clanId) external;\r\n    function getPlayerFees(address player) external view returns (uint224 clansFee, uint224 leadersFee, address leader, uint224 referalsFee, address referer);\r\n    function getPlayersClanUpgrade(address player, uint256 upgradeClass) external view returns (uint224 upgradeGain);\r\n    function mintGoo(address player, uint256 amount) external;\r\n    function increaseClanPower(address player, uint256 amount) external;\r\n    function decreaseClanPower(address player, uint256 amount) external;\r\n}\r\n\r\ncontract Factories {\r\n    uint256 public constant MAX_SIZE = 40;\r\n    function getFactories(address player) external returns (uint256[]);\r\n    function addFactory(address player, uint8 position, uint256 unitId) external;\r\n}\r\n\r\n\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint224 a, uint224 b) internal pure returns (uint224) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint224 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n\r\nlibrary SafeMath224 {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint224 a, uint224 b) internal pure returns (uint224) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint224 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint224 a, uint224 b) internal pure returns (uint224) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint224 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint224 a, uint224 b) internal pure returns (uint224) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint224 a, uint224 b) internal pure returns (uint224) {\r\n    uint224 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"upgradesOwned\",\"outputs\":[{\"name\":\"column0\",\"type\":\"uint64\"},{\"name\":\"column1\",\"type\":\"uint64\"},{\"name\":\"column2\",\"type\":\"uint64\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"unitList\",\"outputs\":[{\"name\":\"unitId\",\"type\":\"uint256\"},{\"name\":\"gooCost\",\"type\":\"uint224\"},{\"name\":\"baseProduction\",\"type\":\"uint256\"},{\"name\":\"attack\",\"type\":\"uint80\"},{\"name\":\"defense\",\"type\":\"uint80\"},{\"name\":\"looting\",\"type\":\"uint80\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"unitExp\",\"outputs\":[{\"name\":\"experience\",\"type\":\"uint224\"},{\"name\":\"level\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint80\"},{\"name\":\"unit\",\"type\":\"uint256\"},{\"name\":\"player\",\"type\":\"address\"}],\"name\":\"deleteUnitExternal\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"upgradeList\",\"outputs\":[{\"name\":\"upgradeId\",\"type\":\"uint256\"},{\"name\":\"gooCost\",\"type\":\"uint224\"},{\"name\":\"unitId\",\"type\":\"uint256\"},{\"name\":\"column\",\"type\":\"uint256\"},{\"name\":\"prerequisiteUpgrade\",\"type\":\"uint256\"},{\"name\":\"unitMaxCapacityGain\",\"type\":\"uint256\"},{\"name\":\"prodIncrease\",\"type\":\"uint32\"},{\"name\":\"prodMultiplier\",\"type\":\"uint32\"},{\"name\":\"attackIncrease\",\"type\":\"uint32\"},{\"name\":\"attackMultiplier\",\"type\":\"uint32\"},{\"name\":\"defenseIncrease\",\"type\":\"uint32\"},{\"name\":\"defenseMultiplier\",\"type\":\"uint32\"},{\"name\":\"lootingIncrease\",\"type\":\"uint32\"},{\"name\":\"lootingMultiplier\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"armyContract\",\"type\":\"address\"}],\"name\":\"setArmy\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"unit\",\"type\":\"uint256\"},{\"name\":\"amount\",\"type\":\"uint80\"},{\"name\":\"player\",\"type\":\"address\"},{\"name\":\"chosenPosition\",\"type\":\"uint8\"}],\"name\":\"mintUnitExternal\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"player\",\"type\":\"address\"},{\"name\":\"unitId\",\"type\":\"uint256\"},{\"name\":\"upgradeGains\",\"type\":\"uint32[8]\"},{\"name\":\"upgradeLosses\",\"type\":\"uint32[8]\"}],\"name\":\"swapUpgradesExternal\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"unitId\",\"type\":\"uint256\"},{\"name\":\"amount\",\"type\":\"uint80\"},{\"name\":\"position\",\"type\":\"uint8\"}],\"name\":\"buyUnit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"upgradeId\",\"type\":\"uint64\"}],\"name\":\"buyUpgrade\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"player\",\"type\":\"address\"},{\"name\":\"upgradeGain\",\"type\":\"uint256\"},{\"name\":\"unitId\",\"type\":\"uint256\"}],\"name\":\"increaseUnitCapacity\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"gameContract\",\"type\":\"address\"},{\"name\":\"isOperator\",\"type\":\"bool\"}],\"name\":\"setOperator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"player\",\"type\":\"address\"},{\"name\":\"unitId\",\"type\":\"uint256\"},{\"name\":\"amount\",\"type\":\"uint224\"}],\"name\":\"grantArmyExp\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"player\",\"type\":\"address\"},{\"name\":\"unitId\",\"type\":\"uint256\"},{\"name\":\"prodIncrease\",\"type\":\"uint32\"},{\"name\":\"prodMultiplier\",\"type\":\"uint32\"},{\"name\":\"attackIncrease\",\"type\":\"uint32\"},{\"name\":\"attackMultiplier\",\"type\":\"uint32\"},{\"name\":\"defenseIncrease\",\"type\":\"uint32\"},{\"name\":\"defenseMultiplier\",\"type\":\"uint32\"},{\"name\":\"lootingIncrease\",\"type\":\"uint32\"},{\"name\":\"lootingMultiplier\",\"type\":\"uint32\"}],\"name\":\"decreaseUpgradesExternal\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"player\",\"type\":\"address\"},{\"name\":\"unitId\",\"type\":\"uint256\"},{\"name\":\"prodIncrease\",\"type\":\"uint32\"},{\"name\":\"prodMultiplier\",\"type\":\"uint32\"},{\"name\":\"attackIncrease\",\"type\":\"uint32\"},{\"name\":\"attackMultiplier\",\"type\":\"uint32\"},{\"name\":\"defenseIncrease\",\"type\":\"uint32\"},{\"name\":\"defenseMultiplier\",\"type\":\"uint32\"},{\"name\":\"lootingIncrease\",\"type\":\"uint32\"},{\"name\":\"lootingMultiplier\",\"type\":\"uint32\"}],\"name\":\"increaseUpgradesExternal\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"unitsOwned\",\"outputs\":[{\"name\":\"units\",\"type\":\"uint80\"},{\"name\":\"factoryBuiltFlag\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"player\",\"type\":\"address\"},{\"name\":\"upgradeGain\",\"type\":\"uint256\"},{\"name\":\"unitId\",\"type\":\"uint256\"}],\"name\":\"decreaseUnitCapacity\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"id\",\"type\":\"uint256\"},{\"name\":\"baseGooCost\",\"type\":\"uint224\"},{\"name\":\"baseGooProduction\",\"type\":\"uint256\"},{\"name\":\"baseAttack\",\"type\":\"uint80\"},{\"name\":\"baseDefense\",\"type\":\"uint80\"},{\"name\":\"baseLooting\",\"type\":\"uint80\"}],\"name\":\"addUnit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"player\",\"type\":\"address\"},{\"name\":\"unitId\",\"type\":\"uint256\"}],\"name\":\"getUnitsCurrentProduction\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"id\",\"type\":\"uint256\"},{\"name\":\"gooCost\",\"type\":\"uint224\"},{\"name\":\"unit\",\"type\":\"uint256\"},{\"name\":\"column\",\"type\":\"uint256\"},{\"name\":\"prereq\",\"type\":\"uint256\"},{\"name\":\"unitMaxCapacityGain\",\"type\":\"uint256\"},{\"name\":\"upgradeGains\",\"type\":\"uint32[8]\"}],\"name\":\"addUpgrade\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"unitId\",\"type\":\"uint256\"},{\"name\":\"amount\",\"type\":\"uint80\"}],\"name\":\"sellUnit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"clansContract\",\"type\":\"address\"}],\"name\":\"setClans\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"}]","ContractName":"Units","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://3bd0a86cbd4ae0e47ee49e040608015de08b9b9713307e3094cf6c2945d07159"}]}