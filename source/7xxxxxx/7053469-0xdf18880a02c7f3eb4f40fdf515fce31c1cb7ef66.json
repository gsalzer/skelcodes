{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\n/*\r\n*   gibmireinbier\r\n*   0xA4a799086aE18D7db6C4b57f496B081b44888888\r\n*   gibmireinbier@gmail.com\r\n*/\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n    int256 constant private INT256_MIN = -2**255;\r\n\r\n    /**\r\n    * @dev Multiplies two unsigned integers, reverts on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Multiplies two signed integers, reverts on overflow.\r\n    */\r\n    function mul(int256 a, int256 b) internal pure returns (int256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        require(!(a == -1 && b == INT256_MIN)); // This is the only case of overflow not detected by the check below\r\n\r\n        int256 c = a * b;\r\n        require(c / a == b);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two signed integers truncating the quotient, reverts on division by zero.\r\n    */\r\n    function div(int256 a, int256 b) internal pure returns (int256) {\r\n        require(b != 0); // Solidity only automatically asserts when dividing by 0\r\n        require(!(b == -1 && a == INT256_MIN)); // This is the only case of overflow\r\n\r\n        int256 c = a / b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two signed integers, reverts on overflow.\r\n    */\r\n    function sub(int256 a, int256 b) internal pure returns (int256) {\r\n        int256 c = a - b;\r\n        require((b >= 0 && c <= a) || (b < 0 && c > a));\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two unsigned integers, reverts on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two signed integers, reverts on overflow.\r\n    */\r\n    function add(int256 a, int256 b) internal pure returns (int256) {\r\n        int256 c = a + b;\r\n        require((b >= 0 && c >= a) || (b < 0 && c < a));\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\r\n    * reverts when dividing by zero.\r\n    */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}\r\n\r\ninterface F2mInterface {\r\n    function joinNetwork(address[6] _contract) public;\r\n    // one time called\r\n    function disableRound0() public;\r\n    function activeBuy() public;\r\n    // Dividends from all sources (DApps, Donate ...)\r\n    function pushDividends() public payable;\r\n    /**\r\n     * Converts all of caller's dividends to tokens.\r\n     */\r\n    //function reinvest() public;\r\n    //function buy() public payable;\r\n    function buyFor(address _buyer) public payable;\r\n    function sell(uint256 _tokenAmount) public;\r\n    function exit() public;\r\n    function devTeamWithdraw() public returns(uint256);\r\n    function withdrawFor(address sender) public returns(uint256);\r\n    function transfer(address _to, uint256 _tokenAmount) public returns(bool);\r\n    /*----------  ADMINISTRATOR ONLY FUNCTIONS  ----------*/\r\n    function setAutoBuy() public;\r\n    /*==========================================\r\n    =            public FUNCTIONS            =\r\n    ==========================================*/\r\n    // function totalEthBalance() public view returns(uint256);\r\n    function ethBalance(address _address) public view returns(uint256);\r\n    function myBalance() public view returns(uint256);\r\n    function myEthBalance() public view returns(uint256);\r\n\r\n    function swapToken() public;\r\n    function setNewToken(address _newTokenAddress) public;\r\n}\r\n\r\ninterface CitizenInterface {\r\n \r\n    function joinNetwork(address[6] _contract) public;\r\n    /*----------  ADMINISTRATOR ONLY FUNCTIONS  ----------*/\r\n    function devTeamWithdraw() public;\r\n\r\n    /*----------  WRITE FUNCTIONS  ----------*/\r\n    function updateUsername(string _sNewUsername) public;\r\n    //Sources: Token contract, DApps\r\n    function pushRefIncome(address _sender) public payable;\r\n    function withdrawFor(address _sender) public payable returns(uint256);\r\n    function devTeamReinvest() public returns(uint256);\r\n\r\n    /*----------  READ FUNCTIONS  ----------*/\r\n    function getRefWallet(address _address) public view returns(uint256);\r\n}\r\n\r\ninterface LotteryInterface {\r\n    function joinNetwork(address[6] _contract) public;\r\n    // call one time\r\n    function activeFirstRound() public;\r\n    // Core Functions\r\n    function pushToPot() public payable;\r\n    function finalizeable() public view returns(bool);\r\n    // bounty\r\n    function finalize() public;\r\n    function buy(string _sSalt) public payable;\r\n    function buyFor(string _sSalt, address _sender) public payable;\r\n    //function withdraw() public;\r\n    function withdrawFor(address _sender) public returns(uint256);\r\n\r\n    function getRewardBalance(address _buyer) public view returns(uint256);\r\n    function getTotalPot() public view returns(uint256);\r\n    // EarlyIncome\r\n    function getEarlyIncomeByAddress(address _buyer) public view returns(uint256);\r\n    // included claimed amount\r\n    // function getEarlyIncomeByAddressRound(address _buyer, uint256 _rId) public view returns(uint256);\r\n    function getCurEarlyIncomeByAddress(address _buyer) public view returns(uint256);\r\n    // function getCurEarlyIncomeByAddressRound(address _buyer, uint256 _rId) public view returns(uint256);\r\n    function getCurRoundId() public view returns(uint256);\r\n    // set endRound, prepare to upgrade new version\r\n    function setLastRound(uint256 _lastRoundId) public;\r\n    function getPInvestedSumByRound(uint256 _rId, address _buyer) public view returns(uint256);\r\n    function cashoutable(address _address) public view returns(bool);\r\n    function isLastRound() public view returns(bool);\r\n}\r\n\r\ninterface DevTeamInterface {\r\n    function setF2mAddress(address _address) public;\r\n    function setLotteryAddress(address _address) public;\r\n    function setCitizenAddress(address _address) public;\r\n    function setBankAddress(address _address) public;\r\n    function setRewardAddress(address _address) public;\r\n    function setWhitelistAddress(address _address) public;\r\n\r\n    function setupNetwork() public;\r\n}\r\n\r\ncontract Bank {\r\n    using SafeMath for uint256;\r\n\r\n    mapping(address => uint256) public balance;\r\n    mapping(address => uint256) public claimedSum;\r\n    mapping(address => uint256) public donateSum;\r\n    mapping(address => bool) public isMember;\r\n    address[] public member;\r\n\r\n    uint256 public TIME_OUT = 7 * 24 * 60 * 60;\r\n    mapping(address => uint256) public lastClaim;\r\n\r\n    CitizenInterface public citizenContract;\r\n    LotteryInterface public lotteryContract;\r\n    F2mInterface public f2mContract;\r\n    DevTeamInterface public devTeamContract;\r\n\r\n    constructor (address _devTeam)\r\n        public\r\n    {\r\n        // add administrators here\r\n        devTeamContract = DevTeamInterface(_devTeam);\r\n        devTeamContract.setBankAddress(address(this));\r\n    }\r\n\r\n    // _contract = [f2mAddress, bankAddress, citizenAddress, lotteryAddress, rewardAddress, whitelistAddress];\r\n    function joinNetwork(address[6] _contract)\r\n        public\r\n    {\r\n        require(address(citizenContract) == 0x0,\"already setup\");\r\n        f2mContract = F2mInterface(_contract[0]);\r\n        //bankContract = BankInterface(bankAddress);\r\n        citizenContract = CitizenInterface(_contract[2]);\r\n        lotteryContract = LotteryInterface(_contract[3]);\r\n    }\r\n\r\n    // Core functions\r\n\r\n    function pushToBank(address _player)\r\n        public\r\n        payable\r\n    {\r\n        uint256 _amount = msg.value;\r\n        lastClaim[_player] = block.timestamp;\r\n        balance[_player] = _amount.add(balance[_player]);\r\n    }\r\n\r\n    function collectDividends(address _member)\r\n        public\r\n        returns(uint256)\r\n    {\r\n        require(_member != address(devTeamContract), \"no right\");\r\n        uint256 collected = f2mContract.withdrawFor(_member);\r\n        claimedSum[_member] += collected;\r\n        return collected;\r\n    }\r\n\r\n    function collectRef(address _member)\r\n        public\r\n        returns(uint256)\r\n    {\r\n        require(_member != address(devTeamContract), \"no right\");\r\n        uint256 collected = citizenContract.withdrawFor(_member);\r\n        claimedSum[_member] += collected;\r\n        return collected;\r\n    }\r\n\r\n    function collectReward(address _member)\r\n        public\r\n        returns(uint256)\r\n    {\r\n        require(_member != address(devTeamContract), \"no right\");\r\n        uint256 collected = lotteryContract.withdrawFor(_member);\r\n        claimedSum[_member] += collected;\r\n        return collected;\r\n    }\r\n\r\n    function collectIncome(address _member)\r\n        public\r\n        returns(uint256)\r\n    {\r\n        require(_member != address(devTeamContract), \"no right\");\r\n        //lastClaim[_member] = block.timestamp;\r\n        uint256 collected = collectDividends(_member) + collectRef(_member) + collectReward(_member);\r\n        return collected;\r\n    }\r\n\r\n    function restTime(address _member)\r\n        public\r\n        view\r\n        returns(uint256)\r\n    {\r\n        uint256 timeDist = block.timestamp - lastClaim[_member];\r\n        if (timeDist >= TIME_OUT) return 0;\r\n        return TIME_OUT - timeDist;\r\n    }\r\n\r\n    function timeout(address _member)\r\n        public\r\n        view\r\n        returns(bool)\r\n    {\r\n        return lastClaim[_member] > 0 && restTime(_member) == 0;\r\n    }\r\n\r\n    function memberLog()\r\n        private\r\n    {\r\n        address _member = msg.sender;\r\n        lastClaim[_member] = block.timestamp;\r\n        if (isMember[_member]) return;\r\n        member.push(_member);\r\n        isMember[_member] = true;\r\n    }\r\n\r\n    function cashoutable()\r\n        public\r\n        view\r\n        returns(bool)\r\n    {\r\n        return lotteryContract.cashoutable(msg.sender);\r\n    }\r\n\r\n    function cashout()\r\n        public\r\n    {\r\n        address _sender = msg.sender;\r\n        uint256 _amount = balance[_sender];\r\n        require(_amount > 0, \"nothing to cashout\");\r\n        balance[_sender] = 0;\r\n        memberLog();\r\n        require(cashoutable() && _amount > 0, \"need 1 ticket or wait to new round\");\r\n        _sender.transfer(_amount);\r\n    }\r\n\r\n    // ref => devTeam\r\n    // div => div\r\n    // lottery => div\r\n    function checkTimeout(address _member)\r\n        public\r\n    {\r\n        require(timeout(_member), \"member still got time to withdraw\");\r\n        require(_member != address(devTeamContract), \"no right\");\r\n        uint256 _curBalance = balance[_member];\r\n        uint256 _refIncome = collectRef(_member);\r\n        uint256 _divIncome = collectDividends(_member);\r\n        uint256 _rewardIncome = collectReward(_member);\r\n        donateSum[_member] += _refIncome + _divIncome + _rewardIncome;\r\n        balance[_member] = _curBalance;\r\n        f2mContract.pushDividends.value(_divIncome + _rewardIncome)();\r\n        citizenContract.pushRefIncome.value(_refIncome)(0x0);\r\n    }\r\n\r\n    function withdraw() \r\n        public\r\n    {\r\n        address _member = msg.sender;\r\n        collectIncome(_member);\r\n        cashout();\r\n        //lastClaim[_member] = block.timestamp;\r\n    } \r\n\r\n    function lotteryReinvest(string _sSalt, uint256 _amount)\r\n        public\r\n        payable\r\n    {\r\n        address _sender = msg.sender;\r\n        uint256 _deposit = msg.value;\r\n        uint256 _curBalance = balance[_sender];\r\n        uint256 investAmount;\r\n        uint256 collected = 0;\r\n        if (_deposit == 0) {\r\n            if (_amount > balance[_sender]) \r\n                collected = collectIncome(_sender);\r\n            require(_amount <= _curBalance + collected, \"balance not enough\");\r\n            investAmount = _amount;//_curBalance + collected;\r\n        } else {\r\n            collected = collectIncome(_sender);\r\n            investAmount = _deposit.add(_curBalance).add(collected);\r\n        }\r\n        balance[_sender] = _curBalance.add(collected + _deposit).sub(investAmount);\r\n        lastClaim [_sender] = block.timestamp;\r\n        lotteryContract.buyFor.value(investAmount)(_sSalt, _sender);\r\n    }\r\n\r\n    function tokenReinvest(uint256 _amount) \r\n        public\r\n        payable\r\n    {\r\n        address _sender = msg.sender;\r\n        uint256 _deposit = msg.value;\r\n        uint256 _curBalance = balance[_sender];\r\n        uint256 investAmount;\r\n        uint256 collected = 0;\r\n        if (_deposit == 0) {\r\n            if (_amount > balance[_sender]) \r\n                collected = collectIncome(_sender);\r\n            require(_amount <= _curBalance + collected, \"balance not enough\");\r\n            investAmount = _amount;//_curBalance + collected;\r\n        } else {\r\n            collected = collectIncome(_sender);\r\n            investAmount = _deposit.add(_curBalance).add(collected);\r\n        }\r\n        balance[_sender] = _curBalance.add(collected + _deposit).sub(investAmount);\r\n        lastClaim [_sender] = block.timestamp;\r\n        f2mContract.buyFor.value(investAmount)(_sender);\r\n    }\r\n\r\n    // Read\r\n    function getDivBalance(address _sender)\r\n        public\r\n        view\r\n        returns(uint256)\r\n    {\r\n        uint256 _amount = f2mContract.ethBalance(_sender);\r\n        return _amount;\r\n    }\r\n\r\n    function getEarlyIncomeBalance(address _sender)\r\n        public\r\n        view\r\n        returns(uint256)\r\n    {\r\n        uint256 _amount = lotteryContract.getCurEarlyIncomeByAddress(_sender);\r\n        return _amount;\r\n    }\r\n\r\n    function getRewardBalance(address _sender)\r\n        public\r\n        view\r\n        returns(uint256)\r\n    {\r\n        uint256 _amount = lotteryContract.getRewardBalance(_sender);\r\n        return _amount;\r\n    }\r\n\r\n    function getRefBalance(address _sender)\r\n        public\r\n        view\r\n        returns(uint256)\r\n    {\r\n        uint256 _amount = citizenContract.getRefWallet(_sender);\r\n        return _amount;\r\n    }\r\n\r\n    function getBalance(address _sender)\r\n        public\r\n        view\r\n        returns(uint256)\r\n    {\r\n        uint256 _sum = getUnclaimedBalance(_sender);\r\n        return _sum + balance[_sender];\r\n    }\r\n\r\n    function getUnclaimedBalance(address _sender)\r\n        public\r\n        view\r\n        returns(uint256)\r\n    {\r\n        uint256 _sum = getDivBalance(_sender) + getRefBalance(_sender) + getRewardBalance(_sender) + getEarlyIncomeBalance(_sender);\r\n        return _sum;\r\n    }\r\n\r\n    function getClaimedBalance(address _sender)\r\n        public\r\n        view\r\n        returns(uint256)\r\n    {\r\n        return balance[_sender];\r\n    }\r\n\r\n    function getTotalMember() \r\n        public\r\n        view\r\n        returns(uint256)\r\n    {\r\n        return member.length;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"cashoutable\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"tokenReinvest\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"devTeamContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"f2mContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_contract\",\"type\":\"address[6]\"}],\"name\":\"joinNetwork\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"lastClaim\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_sSalt\",\"type\":\"string\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"lotteryReinvest\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_sender\",\"type\":\"address\"}],\"name\":\"getEarlyIncomeBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_member\",\"type\":\"address\"}],\"name\":\"collectReward\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"cashout\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_sender\",\"type\":\"address\"}],\"name\":\"getUnclaimedBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"claimedSum\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_member\",\"type\":\"address\"}],\"name\":\"restTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"member\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"isMember\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_member\",\"type\":\"address\"}],\"name\":\"collectRef\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_member\",\"type\":\"address\"}],\"name\":\"timeout\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lotteryContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_member\",\"type\":\"address\"}],\"name\":\"collectIncome\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_sender\",\"type\":\"address\"}],\"name\":\"getRefBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_member\",\"type\":\"address\"}],\"name\":\"collectDividends\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"citizenContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"donateSum\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_member\",\"type\":\"address\"}],\"name\":\"checkTimeout\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_sender\",\"type\":\"address\"}],\"name\":\"getClaimedBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_sender\",\"type\":\"address\"}],\"name\":\"getRewardBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"balance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_player\",\"type\":\"address\"}],\"name\":\"pushToBank\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_sender\",\"type\":\"address\"}],\"name\":\"getBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_sender\",\"type\":\"address\"}],\"name\":\"getDivBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTotalMember\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TIME_OUT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_devTeam\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"}]","ContractName":"Bank","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"00000000000000000000000096504e1f83e380984b1d4eccc0e8b9f0559b2ad2","Library":"","SwarmSource":"bzzr://1c4e75e2a7091d329840746beb1d489442a08110a18186678d3ceda713cd8b2f"}]}