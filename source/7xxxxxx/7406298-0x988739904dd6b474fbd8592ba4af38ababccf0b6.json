{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.5.3;\r\n\r\n// File: contracts/ownerships/ClusterRole.sol\r\n\r\ncontract ClusterRole {\r\n    address payable private _cluster;\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the cluster.\r\n     */\r\n    modifier onlyCluster() {\r\n        require(isCluster(), \"onlyCluster: only cluster can call this method.\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev The Cluster Role sets the original `cluster` of the contract to the sender\r\n     * account.\r\n     */\r\n    constructor () internal {\r\n        _cluster = msg.sender;\r\n    }\r\n\r\n    /**\r\n     * @return the address of the cluster contract.\r\n     */\r\n    function cluster() public view returns (address payable) {\r\n        return _cluster;\r\n    }\r\n\r\n    /**\r\n     * @return true if `msg.sender` is the owner of the contract.\r\n     */\r\n    function isCluster() public view returns (bool) {\r\n        return msg.sender == _cluster;\r\n    }\r\n}\r\n\r\n// File: contracts/ownerships/Roles.sol\r\n\r\nlibrary Roles {\r\n    struct Role {\r\n        mapping (address => bool) bearer;\r\n    }\r\n\r\n    /**\r\n     * @dev give an account access to this role\r\n     */\r\n    function add(Role storage role, address account) internal {\r\n        require(account != address(0));\r\n        require(!has(role, account));\r\n\r\n        role.bearer[account] = true;\r\n    }\r\n\r\n    /**\r\n     * @dev remove an account's access to this role\r\n     */\r\n    function remove(Role storage role, address account) internal {\r\n        require(account != address(0));\r\n        require(has(role, account));\r\n\r\n        role.bearer[account] = false;\r\n    }\r\n\r\n    /**\r\n     * @dev check if an account has this role\r\n     * @return bool\r\n     */\r\n    function has(Role storage role, address account) internal view returns (bool) {\r\n        require(account != address(0));\r\n        return role.bearer[account];\r\n    }\r\n}\r\n\r\n// File: contracts/ownerships/ArbiterRole.sol\r\n\r\ncontract ArbiterRole is ClusterRole {\r\n    using Roles for Roles.Role;\r\n\r\n    uint256 private _arbitersAmount;\r\n\r\n    event ArbiterAdded(address indexed arbiter);\r\n    event ArbiterRemoved(address indexed arbiter);\r\n\r\n    Roles.Role private _arbiters;\r\n\r\n    modifier onlyArbiter() {\r\n        require(isArbiter(msg.sender), \"onlyArbiter: only arbiter can call this method.\");\r\n        _;\r\n    }\r\n\r\n    // -----------------------------------------\r\n    // EXTERNAL\r\n    // -----------------------------------------\r\n\r\n    function addArbiter(address arbiter) public onlyCluster {\r\n        _addArbiter(arbiter);\r\n        _arbitersAmount++;\r\n    }\r\n\r\n    function removeArbiter(address arbiter) public onlyCluster {\r\n        _removeArbiter(arbiter);\r\n        _arbitersAmount--;\r\n    }\r\n\r\n    // -----------------------------------------\r\n    // INTERNAL\r\n    // -----------------------------------------\r\n\r\n    function _addArbiter(address arbiter) private {\r\n        _arbiters.add(arbiter);\r\n        emit ArbiterAdded(arbiter);\r\n    }\r\n\r\n    function _removeArbiter(address arbiter) private {\r\n        _arbiters.remove(arbiter);\r\n        emit ArbiterRemoved(arbiter);\r\n    }\r\n\r\n    // -----------------------------------------\r\n    // GETTERS\r\n    // -----------------------------------------\r\n\r\n    function isArbiter(address account) public view returns (bool) {\r\n        return _arbiters.has(account);\r\n    }\r\n\r\n    function getArbitersAmount() external view returns (uint256) {\r\n        return _arbitersAmount;\r\n    }\r\n}\r\n\r\n// File: contracts/interfaces/ICluster.sol\r\n\r\ninterface ICluster {\r\n    function withdrawEth() external;\r\n\r\n    function addArbiter(address newArbiter) external;\r\n\r\n    function removeArbiter(address arbiter) external;\r\n\r\n    function addCrowdsale(\r\n        uint256 rate,\r\n        address token,\r\n        uint256 openingTime,\r\n        uint256 closingTime,\r\n        address payable operator,\r\n        uint256[] calldata bonusFinishTimestamp,\r\n        uint256[] calldata bonuses,\r\n        uint256 minInvestmentAmount,\r\n        uint256 fee\r\n    ) external returns (address);\r\n\r\n    function emergencyExit(address crowdsale, address payable newContract) external;\r\n\r\n    function openDispute(address crowdsale, bytes32 hash, string calldata reason) external payable returns (uint256);\r\n\r\n    function solveDispute(address crowdsale, bytes32 hash, address investor, bool investorWins) external;\r\n\r\n    function getArbitersPoolAddress() external view returns (address);\r\n\r\n    function getAllCrowdsalesAddresses() external view returns (address[] memory crowdsales);\r\n\r\n    function getCrowdsaleMilestones(address crowdsale) external view returns(bytes32[] memory milestonesHashArray);\r\n\r\n    function getOperatorCrowdsaleAddresses(address operator) external view returns (address[] memory crowdsales);\r\n\r\n    function owner() external view returns (address payable);\r\n\r\n    function isOwner() external view returns (bool);\r\n\r\n    function transferOwnership(address payable newOwner) external;\r\n\r\n    function isBackEnd(address account) external view returns (bool);\r\n\r\n    function addBackEnd(address account) external;\r\n\r\n    function removeBackEnd(address account) external;\r\n}\r\n\r\n// File: contracts/ArbitersPool.sol\r\n\r\ncontract ArbitersPool is ArbiterRole {\r\n    uint256 private _disputsAmount;\r\n    uint256 private constant _necessaryVoices = 3;\r\n\r\n    enum DisputeStatus { WAITING, SOLVED }\r\n    enum Choice { OPERATOR_WINS, INVESTOR_WINS }\r\n\r\n    ICluster private _clusterInterface;\r\n\r\n    struct Vote {\r\n        address arbiter;\r\n        Choice choice;\r\n    }\r\n\r\n    struct Dispute {\r\n        address investor;\r\n        address crowdsale;\r\n        bytes32 milestoneHash;\r\n        string reason;\r\n        uint256 votesAmount;\r\n        DisputeStatus status;\r\n        mapping (address => bool) hasVoted;\r\n        mapping (uint256 => Vote) choices;\r\n    }\r\n\r\n    mapping (uint256 => Dispute) private _disputesById;\r\n    mapping (address => uint256[]) private _disputesByInvestor;\r\n    mapping (bytes32 => uint256[]) private _disputesByMilestone;\r\n\r\n    event Voted(uint256 indexed disputeId, address indexed arbiter, Choice choice);\r\n    event NewDisputeCreated(uint256 disputeId, address indexed crowdsale, bytes32 indexed hash, address indexed investor);\r\n    event DisputeSolved(uint256 disputeId, Choice choice, address indexed crowdsale, bytes32 indexed hash, address indexed investor);\r\n\r\n    constructor () public {\r\n        _clusterInterface = ICluster(msg.sender);\r\n    }\r\n\r\n    function createDispute(bytes32 milestoneHash, address crowdsale, address investor, string calldata reason) external onlyCluster returns (uint256) {\r\n        Dispute memory dispute = Dispute(\r\n            investor,\r\n            crowdsale,\r\n            milestoneHash,\r\n            reason,\r\n            0,\r\n            DisputeStatus.WAITING\r\n        );\r\n\r\n        uint256 thisDisputeId = _disputsAmount;\r\n        _disputsAmount++;\r\n\r\n        _disputesById[thisDisputeId] = dispute;\r\n        _disputesByMilestone[milestoneHash].push(thisDisputeId);\r\n        _disputesByInvestor[investor].push(thisDisputeId);\r\n\r\n        emit NewDisputeCreated(thisDisputeId, crowdsale, milestoneHash, investor);\r\n\r\n        return thisDisputeId;\r\n    }\r\n\r\n    function voteDispute(uint256 id, Choice choice) public onlyArbiter {\r\n        require(_disputsAmount > id, \"voteDispute: invalid number of dispute.\");\r\n        require(_disputesById[id].hasVoted[msg.sender] == false, \"voteDispute: arbiter was already voted.\");\r\n        require(_disputesById[id].status == DisputeStatus.WAITING, \"voteDispute: dispute was already closed.\");\r\n        require(_disputesById[id].votesAmount < _necessaryVoices, \"voteDispute: dispute was already voted and finished.\");\r\n\r\n        _disputesById[id].hasVoted[msg.sender] = true;\r\n\r\n        // updating the votes amount\r\n        _disputesById[id].votesAmount++;\r\n\r\n        // storing info about this vote\r\n        uint256 votesAmount = _disputesById[id].votesAmount;\r\n        _disputesById[id].choices[votesAmount] = Vote(msg.sender, choice);\r\n\r\n        // checking, if the second arbiter voted the same result with the 1st voted arbiter, then dispute will be solved without 3rd vote\r\n        if (_disputesById[id].votesAmount == 2 && _disputesById[id].choices[0].choice == choice) {\r\n            _executeDispute(id, choice);\r\n        } else if (_disputesById[id].votesAmount == _necessaryVoices) {\r\n            Choice winner = _calculateWinner(id);\r\n            _executeDispute(id, winner);\r\n        }\r\n\r\n        emit Voted(id, msg.sender, choice);\r\n    }\r\n\r\n    // -----------------------------------------\r\n    // INTERNAL\r\n    // -----------------------------------------\r\n\r\n    function _calculateWinner(uint256 id) private view returns (Choice choice) {\r\n        uint256 votesForInvestor = 0;\r\n        for (uint256 i = 0; i < _necessaryVoices; i++) {\r\n            if (_disputesById[id].choices[i].choice == Choice.INVESTOR_WINS) {\r\n                votesForInvestor++;\r\n            }\r\n        }\r\n\r\n        return votesForInvestor >= 2 ? Choice.INVESTOR_WINS : Choice.OPERATOR_WINS;\r\n    }\r\n\r\n    function _executeDispute(uint256 id, Choice choice) private {\r\n        _disputesById[id].status = DisputeStatus.SOLVED;\r\n        _clusterInterface.solveDispute(\r\n            _disputesById[id].crowdsale,\r\n            _disputesById[id].milestoneHash,\r\n            _disputesById[id].investor,\r\n            choice == Choice.INVESTOR_WINS\r\n        );\r\n\r\n        emit DisputeSolved(\r\n            id,\r\n            choice,\r\n            _disputesById[id].crowdsale,\r\n            _disputesById[id].milestoneHash,\r\n            _disputesById[id].investor\r\n        );\r\n    }\r\n\r\n    // -----------------------------------------\r\n    // GETTERS\r\n    // -----------------------------------------\r\n\r\n    function getDisputesAmount() external view returns (uint256) {\r\n        return _disputsAmount;\r\n    }\r\n\r\n    function getDisputeDetails(uint256 id) external view returns (bytes32, address, address, string memory, uint256, DisputeStatus status) {\r\n        Dispute memory dispute = _disputesById[id];\r\n        return (\r\n            dispute.milestoneHash,\r\n            dispute.crowdsale,\r\n            dispute.investor,\r\n            dispute.reason,\r\n            dispute.votesAmount,\r\n            dispute.status\r\n        );\r\n    }\r\n\r\n    function getMilestoneDisputes(bytes32 hash) external view returns (uint256[] memory disputesIDs) {\r\n        uint256 disputesLength = _disputesByMilestone[hash].length;\r\n        disputesIDs = new uint256[](disputesLength);\r\n\r\n        for (uint256 i = 0; i < disputesLength; i++) {\r\n            disputesIDs[i] = _disputesByMilestone[hash][i];\r\n        }\r\n\r\n        return disputesIDs;\r\n    }\r\n\r\n    function getInvestorDisputes(address investor) external view returns (uint256[] memory disputesIDs) {\r\n        uint256 disputesLength = _disputesByInvestor[investor].length;\r\n        disputesIDs = new uint256[](disputesLength);\r\n\r\n        for (uint256 i = 0; i < disputesLength; i++) {\r\n            disputesIDs[i] = _disputesByInvestor[investor][i];\r\n        }\r\n\r\n        return disputesIDs;\r\n    }\r\n\r\n    function getDisputeVotes(uint256 id) external view returns(address[] memory arbiters, Choice[] memory choices) {\r\n        uint256 votedArbitersAmount = _disputesById[id].votesAmount;\r\n        arbiters = new address[](votedArbitersAmount);\r\n        choices = new Choice[](votedArbitersAmount);\r\n\r\n        for (uint256 i = 0; i < votedArbitersAmount; i++) {\r\n            arbiters[i] = _disputesById[id].choices[i].arbiter;\r\n            choices[i] = _disputesById[id].choices[i].choice;\r\n        }\r\n\r\n        return (\r\n            arbiters,\r\n            choices\r\n        );\r\n    }\r\n\r\n    function hasDisputeSolved(uint256 id) external view returns (bool) {\r\n        return _disputesById[id].status == DisputeStatus.SOLVED;\r\n    }\r\n\r\n    function hasArbiterVoted(uint256 id, address arbiter) external view returns (bool) {\r\n        return _disputesById[id].hasVoted[arbiter];\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"isCluster\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"hash\",\"type\":\"bytes32\"}],\"name\":\"getMilestoneDisputes\",\"outputs\":[{\"name\":\"disputesIDs\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"arbiter\",\"type\":\"address\"}],\"name\":\"removeArbiter\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getDisputesAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"hasDisputeSolved\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"id\",\"type\":\"uint256\"},{\"name\":\"choice\",\"type\":\"uint8\"}],\"name\":\"voteDispute\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"investor\",\"type\":\"address\"}],\"name\":\"getInvestorDisputes\",\"outputs\":[{\"name\":\"disputesIDs\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"arbiter\",\"type\":\"address\"}],\"name\":\"addArbiter\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"id\",\"type\":\"uint256\"},{\"name\":\"arbiter\",\"type\":\"address\"}],\"name\":\"hasArbiterVoted\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"milestoneHash\",\"type\":\"bytes32\"},{\"name\":\"crowdsale\",\"type\":\"address\"},{\"name\":\"investor\",\"type\":\"address\"},{\"name\":\"reason\",\"type\":\"string\"}],\"name\":\"createDispute\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getDisputeVotes\",\"outputs\":[{\"name\":\"arbiters\",\"type\":\"address[]\"},{\"name\":\"choices\",\"type\":\"uint8[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getArbitersAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"cluster\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getDisputeDetails\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"},{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"string\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"status\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isArbiter\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"disputeId\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"arbiter\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"choice\",\"type\":\"uint8\"}],\"name\":\"Voted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"disputeId\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"crowdsale\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"hash\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"investor\",\"type\":\"address\"}],\"name\":\"NewDisputeCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"disputeId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"choice\",\"type\":\"uint8\"},{\"indexed\":true,\"name\":\"crowdsale\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"hash\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"investor\",\"type\":\"address\"}],\"name\":\"DisputeSolved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"arbiter\",\"type\":\"address\"}],\"name\":\"ArbiterAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"arbiter\",\"type\":\"address\"}],\"name\":\"ArbiterRemoved\",\"type\":\"event\"}]","ContractName":"ArbitersPool","CompilerVersion":"v0.5.3+commit.10d17f24","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://66c0641395d531498f791c465ecd9c40cbb051eca45c3f6b5c16d95ea116c1b1"}]}