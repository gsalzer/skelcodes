{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.6;\r\npragma experimental ABIEncoderV2;\r\n\r\nlibrary SafeMath {\r\n\r\n    function mul(uint a, uint b) internal pure returns (uint) {\r\n        uint c = a * b;\r\n        assert(a == 0 || c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint a, uint b) internal pure returns (uint) {\r\n        assert(b > 0);\r\n        uint c = a / b;\r\n        assert(a == b * c + a % b);\r\n        return c;\r\n    }\r\n\r\n    function sub(uint a, uint b) internal pure returns (uint) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint a, uint b) internal pure returns (uint) {\r\n        uint c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n\r\n    function max64(uint64 a, uint64 b) internal pure returns (uint64) {\r\n        return a >= b ? a : b;\r\n    }\r\n\r\n    function min64(uint64 a, uint64 b) internal pure returns (uint64) {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n    function max256(uint a, uint b) internal pure returns (uint) {\r\n        return a >= b ? a : b;\r\n    }\r\n\r\n    function min256(uint a, uint b) internal pure returns (uint) {\r\n        return a < b ? a : b;\r\n    }\r\n}\r\n\r\ninterface GeneralERC20 {\r\n\tfunction transfer(address to, uint256 value) external;\r\n\tfunction transferFrom(address from, address to, uint256 value) external;\r\n\tfunction approve(address spender, uint256 value) external;\r\n\tfunction balanceOf(address spender) external view returns (uint);\r\n}\r\n\r\nlibrary SafeERC20 {\r\n\tfunction checkSuccess()\r\n\t\tprivate\r\n\t\tpure\r\n\t\treturns (bool)\r\n\t{\r\n\t\tuint256 returnValue = 0;\r\n\r\n\t\tassembly {\r\n\t\t\t// check number of bytes returned from last function call\r\n\t\t\tswitch returndatasize\r\n\r\n\t\t\t// no bytes returned: assume success\r\n\t\t\tcase 0x0 {\r\n\t\t\t\treturnValue := 1\r\n\t\t\t}\r\n\r\n\t\t\t// 32 bytes returned: check if non-zero\r\n\t\t\tcase 0x20 {\r\n\t\t\t\t// copy 32 bytes into scratch space\r\n\t\t\t\treturndatacopy(0x0, 0x0, 0x20)\r\n\r\n\t\t\t\t// load those bytes into returnValue\r\n\t\t\t\treturnValue := mload(0x0)\r\n\t\t\t}\r\n\r\n\t\t\t// not sure what was returned: don't mark as success\r\n\t\t\tdefault { }\r\n\t\t}\r\n\r\n\t\treturn returnValue != 0;\r\n\t}\r\n\r\n\tfunction transfer(address token, address to, uint256 amount) internal {\r\n\t\tGeneralERC20(token).transfer(to, amount);\r\n\t\trequire(checkSuccess());\r\n\t}\r\n\r\n\tfunction transferFrom(address token, address from, address to, uint256 amount) internal {\r\n\t\tGeneralERC20(token).transferFrom(from, to, amount);\r\n\t\trequire(checkSuccess());\r\n\t}\r\n\r\n\tfunction approve(address token, address spender, uint256 amount) internal {\r\n\t\tGeneralERC20(token).approve(spender, amount);\r\n\t\trequire(checkSuccess());\r\n\t}\r\n}\r\n\r\nlibrary MerkleProof {\r\n\tfunction isContained(bytes32 valueHash, bytes32[] memory proof, bytes32 root) internal pure returns (bool) {\r\n\t\tbytes32 cursor = valueHash;\r\n\r\n\t\tfor (uint256 i = 0; i < proof.length; i++) {\r\n\t\t\tif (cursor < proof[i]) {\r\n\t\t\t\tcursor = keccak256(abi.encodePacked(cursor, proof[i]));\r\n\t\t\t} else {\r\n\t\t\t\tcursor = keccak256(abi.encodePacked(proof[i], cursor));\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn cursor == root;\r\n\t}\r\n}\r\n\r\n\r\nlibrary SignatureValidator {\r\n\tenum SignatureMode {\r\n\t\tNO_SIG,\r\n\t\tEIP712,\r\n\t\tGETH,\r\n\t\tTREZOR,\r\n\t\tADEX\r\n\t}\r\n\r\n\tfunction recoverAddr(bytes32 hash, bytes32[3] memory signature) internal pure returns (address) {\r\n\t\tSignatureMode mode = SignatureMode(uint8(signature[0][0]));\r\n\r\n\t\tif (mode == SignatureMode.NO_SIG) {\r\n\t\t\treturn address(0x0);\r\n\t\t}\r\n\r\n\t\tuint8 v = uint8(signature[0][1]);\r\n\r\n\t\tif (mode == SignatureMode.GETH) {\r\n\t\t\thash = keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\r\n\t\t} else if (mode == SignatureMode.TREZOR) {\r\n\t\t\thash = keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n\\x20\", hash));\r\n\t\t} else if (mode == SignatureMode.ADEX) {\r\n\t\t\thash = keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n108By signing this message, you acknowledge signing an AdEx bid with the hash:\\n\", hash));\r\n\t\t}\r\n\r\n\t\treturn ecrecover(hash, v, signature[1], signature[2]);\r\n\t}\r\n\r\n\t/// @dev Validates that a hash was signed by a specified signer.\r\n\t/// @param hash Hash which was signed.\r\n\t/// @param signer Address of the signer.\r\n\t/// @param signature ECDSA signature along with the mode [{mode}{v}, {r}, {s}]\r\n\t/// @return Returns whether signature is from a specified user.\r\n\tfunction isValidSignature(bytes32 hash, address signer, bytes32[3] memory signature) internal pure returns (bool) {\r\n\t\treturn recoverAddr(hash, signature) == signer;\r\n\t}\r\n}\r\n\r\n\r\nlibrary ChannelLibrary {\r\n\tuint constant MAX_VALIDITY = 365 days;\r\n\r\n\t// Both numbers are inclusive\r\n\tuint constant MIN_VALIDATOR_COUNT = 2;\r\n\t// This is an arbitrary number, but we impose this limit to restrict on-chain load; also to ensure the *3 operation is safe\r\n\tuint constant MAX_VALIDATOR_COUNT = 25;\r\n\r\n\tenum State {\r\n\t\tUnknown,\r\n\t\tActive,\r\n\t\tExpired\r\n\t}\r\n\r\n\tstruct Channel {\r\n\t\taddress creator;\r\n\r\n\t\taddress tokenAddr;\r\n\t\tuint tokenAmount;\r\n\r\n\t\tuint validUntil;\r\n\r\n\t\taddress[] validators;\r\n\r\n\t\t// finally, arbitrary bytes32 that allows to... @TODO document that this acts as a nonce\r\n\t\tbytes32 spec;\r\n\t}\r\n\r\n\tfunction hash(Channel memory channel)\r\n\t\tinternal\r\n\t\tview\r\n\t\treturns (bytes32)\r\n\t{\r\n\t\t// In this version of solidity, we can no longer keccak256() directly\r\n\t\treturn keccak256(abi.encode(\r\n\t\t\taddress(this),\r\n\t\t\tchannel.creator,\r\n\t\t\tchannel.tokenAddr,\r\n\t\t\tchannel.tokenAmount,\r\n\t\t\tchannel.validUntil,\r\n\t\t\tchannel.validators,\r\n\t\t\tchannel.spec\r\n\t\t));\r\n\t}\r\n\r\n\tfunction isValid(Channel memory channel, uint currentTime)\r\n\t\tinternal\r\n\t\tpure\r\n\t\treturns (bool)\r\n\t{\r\n\t\t// NOTE: validators[] can be sybil'd by passing the same addr a few times\r\n\t\t// this does not matter since you can sybil validators[] anyway, and that is mitigated off-chain\r\n\t\tif (channel.validators.length < MIN_VALIDATOR_COUNT) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tif (channel.validators.length > MAX_VALIDATOR_COUNT) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tif (channel.validUntil < currentTime) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tif (channel.validUntil > currentTime + MAX_VALIDITY) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction isSignedBySupermajority(Channel memory channel, bytes32 toSign, bytes32[3][] memory signatures) \r\n\t\tinternal\r\n\t\tpure\r\n\t\treturns (bool)\r\n\t{\r\n\t\t// NOTE: each element of signatures[] must signed by the elem with the same index in validators[]\r\n\t\t// In case someone didn't sign, pass SignatureMode.NO_SIG\r\n\t\tif (signatures.length != channel.validators.length) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\tuint signs = 0;\r\n\t\tfor (uint i=0; i<signatures.length; i++) {\r\n\t\t\t// NOTE: if a validator has not signed, you can just use SignatureMode.NO_SIG\r\n\t\t\tif (SignatureValidator.isValidSignature(toSign, channel.validators[i], signatures[i])) {\r\n\t\t\t\tsigns++;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn signs*3 >= channel.validators.length*2;\r\n\t}\r\n}\r\n\r\n// AUDIT: Things we should look for\r\n// 1) every time we check the state, the function should either revert or change the state\r\n// 2) state transition: channelOpen locks up tokens, then all of the tokens can be withdrawn on channelExpiredWithdraw, except how many were withdrawn using channelWithdraw\r\n// 3) external calls (everything using SafeERC20) should be at the end\r\n// 4) channel can always be 100% drained with Withdraw/ExpiredWithdraw\r\n\r\ncontract AdExCore {\r\n\tusing SafeMath for uint;\r\n\tusing ChannelLibrary for ChannelLibrary.Channel;\r\n\r\n \t// channelId => channelState\r\n\tmapping (bytes32 => ChannelLibrary.State) public states;\r\n\t\r\n\t// withdrawn per channel (channelId => uint)\r\n\tmapping (bytes32 => uint) public withdrawn;\r\n\t// withdrawn per channel user (channelId => (account => uint))\r\n\tmapping (bytes32 => mapping (address => uint)) public withdrawnPerUser;\r\n\r\n\t// Events\r\n\tevent LogChannelOpen(bytes32 indexed channelId);\r\n\tevent LogChannelWithdrawExpired(bytes32 indexed channelId, uint amount);\r\n\tevent LogChannelWithdraw(bytes32 indexed channelId, uint amount);\r\n\r\n\t// All functions are public\r\n\tfunction channelOpen(ChannelLibrary.Channel memory channel)\r\n\t\tpublic\r\n\t{\r\n\t\tbytes32 channelId = channel.hash();\r\n\t\trequire(states[channelId] == ChannelLibrary.State.Unknown, \"INVALID_STATE\");\r\n\t\trequire(msg.sender == channel.creator, \"INVALID_CREATOR\");\r\n\t\trequire(channel.isValid(now), \"INVALID_CHANNEL\");\r\n\t\t\r\n\t\tstates[channelId] = ChannelLibrary.State.Active;\r\n\r\n\t\tSafeERC20.transferFrom(channel.tokenAddr, msg.sender, address(this), channel.tokenAmount);\r\n\r\n\t\temit LogChannelOpen(channelId);\r\n\t}\r\n\r\n\tfunction channelWithdrawExpired(ChannelLibrary.Channel memory channel)\r\n\t\tpublic\r\n\t{\r\n\t\tbytes32 channelId = channel.hash();\r\n\t\trequire(states[channelId] == ChannelLibrary.State.Active, \"INVALID_STATE\");\r\n\t\trequire(now > channel.validUntil, \"NOT_EXPIRED\");\r\n\t\trequire(msg.sender == channel.creator, \"INVALID_CREATOR\");\r\n\t\t\r\n\t\tuint toWithdraw = channel.tokenAmount.sub(withdrawn[channelId]);\r\n\r\n\t\t// NOTE: we will not update withdrawn, since a WithdrawExpired does not count towards normal withdrawals\r\n\t\tstates[channelId] = ChannelLibrary.State.Expired;\r\n\t\t\r\n\t\tSafeERC20.transfer(channel.tokenAddr, msg.sender, toWithdraw);\r\n\r\n\t\temit LogChannelWithdrawExpired(channelId, toWithdraw);\r\n\t}\r\n\r\n\tfunction channelWithdraw(ChannelLibrary.Channel memory channel, bytes32 stateRoot, bytes32[3][] memory signatures, bytes32[] memory proof, uint amountInTree)\r\n\t\tpublic\r\n\t{\r\n\t\tbytes32 channelId = channel.hash();\r\n\t\trequire(states[channelId] == ChannelLibrary.State.Active, \"INVALID_STATE\");\r\n\t\trequire(now <= channel.validUntil, \"EXPIRED\");\r\n\r\n\t\tbytes32 hashToSign = keccak256(abi.encode(channelId, stateRoot));\r\n\t\trequire(channel.isSignedBySupermajority(hashToSign, signatures), \"NOT_SIGNED_BY_VALIDATORS\");\r\n\r\n\t\tbytes32 balanceLeaf = keccak256(abi.encode(msg.sender, amountInTree));\r\n\t\trequire(MerkleProof.isContained(balanceLeaf, proof, stateRoot), \"BALANCELEAF_NOT_FOUND\");\r\n\r\n\t\t// The user can withdraw their constantly increasing balance at any time (essentially prevent users from double spending)\r\n\t\tuint toWithdraw = amountInTree.sub(withdrawnPerUser[channelId][msg.sender]);\r\n\t\twithdrawnPerUser[channelId][msg.sender] = amountInTree;\r\n\r\n\t\t// Ensure that it's not possible to withdraw more than the channel deposit (e.g. malicious validators sign such a state)\r\n\t\twithdrawn[channelId] = withdrawn[channelId].add(toWithdraw);\r\n\t\trequire(withdrawn[channelId] <= channel.tokenAmount, \"WITHDRAWING_MORE_THAN_CHANNEL\");\r\n\r\n\t\tSafeERC20.transfer(channel.tokenAddr, msg.sender, toWithdraw);\r\n\r\n\t\temit LogChannelWithdraw(channelId, toWithdraw);\r\n\t}\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"withdrawn\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"withdrawnPerUser\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"components\":[{\"name\":\"creator\",\"type\":\"address\"},{\"name\":\"tokenAddr\",\"type\":\"address\"},{\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"name\":\"validUntil\",\"type\":\"uint256\"},{\"name\":\"validators\",\"type\":\"address[]\"},{\"name\":\"spec\",\"type\":\"bytes32\"}],\"name\":\"channel\",\"type\":\"tuple\"}],\"name\":\"channelOpen\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"components\":[{\"name\":\"creator\",\"type\":\"address\"},{\"name\":\"tokenAddr\",\"type\":\"address\"},{\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"name\":\"validUntil\",\"type\":\"uint256\"},{\"name\":\"validators\",\"type\":\"address[]\"},{\"name\":\"spec\",\"type\":\"bytes32\"}],\"name\":\"channel\",\"type\":\"tuple\"},{\"name\":\"stateRoot\",\"type\":\"bytes32\"},{\"name\":\"signatures\",\"type\":\"bytes32[3][]\"},{\"name\":\"proof\",\"type\":\"bytes32[]\"},{\"name\":\"amountInTree\",\"type\":\"uint256\"}],\"name\":\"channelWithdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"components\":[{\"name\":\"creator\",\"type\":\"address\"},{\"name\":\"tokenAddr\",\"type\":\"address\"},{\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"name\":\"validUntil\",\"type\":\"uint256\"},{\"name\":\"validators\",\"type\":\"address[]\"},{\"name\":\"spec\",\"type\":\"bytes32\"}],\"name\":\"channel\",\"type\":\"tuple\"}],\"name\":\"channelWithdrawExpired\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"states\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"channelId\",\"type\":\"bytes32\"}],\"name\":\"LogChannelOpen\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"channelId\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"LogChannelWithdrawExpired\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"channelId\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"LogChannelWithdraw\",\"type\":\"event\"}]","ContractName":"AdExCore","CompilerVersion":"v0.5.6+commit.b259423e","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://0d017a11175d52c641bf2f5c7906c013244f408b84bd129aa5bbff3744029475"}]}