{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity >0.4.99 <0.6.0;\r\n\r\ncontract Parameters {\r\n\r\n    uint public constant PRICE_OF_TOKEN = 0.01 ether;\r\n    uint public constant MAX_TOKENS_BUY = 80;\r\n    uint public constant MIN_TICKETS_BUY_FOR_ROUND = 80;\r\n\r\n    uint public maxNumberStepCircle = 40;\r\n\r\n    uint public currentRound;\r\n    uint public totalEthRaised;\r\n    uint public totalTicketBuyed;\r\n\r\n    uint public uniquePlayer;\r\n\r\n    uint public numberCurrentTwist;\r\n\r\n    bool public isTwist;\r\n\r\n    bool public isDemo;\r\n    uint public simulateDate;\r\n\r\n}\r\n\r\nlibrary Zero {\r\n    function requireNotZero(address addr) internal pure {\r\n        require(addr != address(0), \"require not zero address\");\r\n    }\r\n\r\n    function requireNotZero(uint val) internal pure {\r\n        require(val != 0, \"require not zero value\");\r\n    }\r\n\r\n    function notZero(address addr) internal pure returns(bool) {\r\n        return !(addr == address(0));\r\n    }\r\n\r\n    function isZero(address addr) internal pure returns(bool) {\r\n        return addr == address(0);\r\n    }\r\n\r\n    function isZero(uint a) internal pure returns(bool) {\r\n        return a == 0;\r\n    }\r\n\r\n    function notZero(uint a) internal pure returns(bool) {\r\n        return a != 0;\r\n    }\r\n}\r\n\r\nlibrary Address {\r\n    function toAddress(bytes memory source) internal pure returns(address addr) {\r\n        assembly { addr := mload(add(source,0x14)) }\r\n        return addr;\r\n    }\r\n\r\n    function isNotContract(address addr) internal view returns(bool) {\r\n        uint length;\r\n        assembly { length := extcodesize(addr) }\r\n        return length == 0;\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n\r\n    /**\r\n    * @dev Multiplies two numbers, reverts on overflow.\r\n    */\r\n    function mul(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n        if (_a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = _a * _b;\r\n        require(c / _a == _b);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\r\n    */\r\n    function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n        require(_b > 0); // Solidity only automatically asserts when dividing by 0\r\n        uint256 c = _a / _b;\r\n        // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n        require(_b <= _a);\r\n        uint256 c = _a - _b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, reverts on overflow.\r\n    */\r\n    function add(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n        uint256 c = _a + _b;\r\n        require(c >= _a);\r\n\r\n        return c;\r\n    }\r\n\r\n}\r\n\r\nlibrary Percent {\r\n    struct percent {\r\n        uint num;\r\n        uint den;\r\n    }\r\n\r\n    function mul(percent storage p, uint a) internal view returns (uint) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        return a*p.num/p.den;\r\n    }\r\n\r\n    function div(percent storage p, uint a) internal view returns (uint) {\r\n        return a/p.num*p.den;\r\n    }\r\n\r\n    function sub(percent storage p, uint a) internal view returns (uint) {\r\n        uint b = mul(p, a);\r\n        if (b >= a) {\r\n            return 0;\r\n        }\r\n        return a - b;\r\n    }\r\n\r\n    function add(percent storage p, uint a) internal view returns (uint) {\r\n        return a + mul(p, a);\r\n    }\r\n\r\n    function toMemory(percent storage p) internal view returns (Percent.percent memory) {\r\n        return Percent.percent(p.num, p.den);\r\n    }\r\n\r\n    function mmul(percent memory p, uint a) internal pure returns (uint) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        return a*p.num/p.den;\r\n    }\r\n\r\n    function mdiv(percent memory p, uint a) internal pure returns (uint) {\r\n        return a/p.num*p.den;\r\n    }\r\n\r\n    function msub(percent memory p, uint a) internal pure returns (uint) {\r\n        uint b = mmul(p, a);\r\n        if (b >= a) {\r\n            return 0;\r\n        }\r\n        return a - b;\r\n    }\r\n\r\n    function madd(percent memory p, uint a) internal pure returns (uint) {\r\n        return a + mmul(p, a);\r\n    }\r\n}\r\n\r\n\r\ncontract Accessibility {\r\n    address private owner;\r\n    event OwnerChanged(address indexed previousOwner, address indexed newOwner);\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"access denied\");\r\n        _;\r\n    }\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    function changeOwner(address _newOwner) onlyOwner public {\r\n        require(_newOwner != address(0));\r\n        emit OwnerChanged(owner, _newOwner);\r\n        owner = _newOwner;\r\n    }\r\n}\r\n\r\n\r\ncontract TicketsStorage is Accessibility, Parameters  {\r\n    using SafeMath for uint;\r\n    using Percent for Percent.percent;\r\n\r\n    struct Ticket {\r\n        address payable wallet;\r\n        uint winnerRound;\r\n    }\r\n\r\n    struct CountWinner {\r\n        uint countWinnerRound_1;\r\n        uint countWinnerRound_2;\r\n        uint countWinnerRound_3;\r\n        uint countWinnerRound_4;\r\n        uint countWinnerRound_5;\r\n    }\r\n\r\n    struct PayEachWinner {\r\n        uint payEachWinner_1;\r\n        uint payEachWinner_2;\r\n        uint payEachWinner_3;\r\n        uint payEachWinner_4;\r\n        uint payEachWinner_5;\r\n    }\r\n\r\n    uint private stepEntropy = 1;\r\n    uint private precisionPay = 4;\r\n\r\n    uint private remainStepTS;\r\n    uint private countStepTS;\r\n\r\n    mapping (uint => CountWinner) countWinner;\r\n    // currentRound -> CountWinner\r\n\r\n    mapping (uint => PayEachWinner) payEachWinner;\r\n    // currentRound -> PayEachWinner\r\n\r\n    mapping (uint => uint) private countTickets;\r\n    // currentRound -> number ticket\r\n\r\n    mapping (uint => mapping (uint => Ticket)) private tickets;\r\n    // currentRound -> number ticket -> Ticket\r\n\r\n    mapping (uint => mapping (address => uint)) private balancePlayer;\r\n    // currentRound -> wallet -> balance player\r\n\r\n    mapping (uint => mapping (address => uint)) private balanceWinner;\r\n    // currentRound -> wallet -> balance winner\r\n\r\n    mapping (uint => uint[]) private happyTickets;\r\n    // currentRound -> array happy tickets\r\n\r\n    Percent.percent private percentTicketPrize_2 = Percent.percent(1,100);            // 1.0 %\r\n    Percent.percent private percentTicketPrize_3 = Percent.percent(4,100);            // 4.0 %\r\n    Percent.percent private percentTicketPrize_4 = Percent.percent(10,100);            // 10.0 %\r\n    Percent.percent private percentTicketPrize_5 = Percent.percent(35,100);            // 35.0 %\r\n\r\n    Percent.percent private percentAmountPrize_1 = Percent.percent(1797,10000);            // 17.97%\r\n    Percent.percent private percentAmountPrize_2 = Percent.percent(1000,10000);            // 10.00%\r\n    Percent.percent private percentAmountPrize_3 = Percent.percent(1201,10000);            // 12.01%\r\n    Percent.percent private percentAmountPrize_4 = Percent.percent(2000,10000);            // 20.00%\r\n    Percent.percent private percentAmountPrize_5 = Percent.percent(3502,10000);            // 35.02%\r\n\r\n\r\n    event LogMakeDistribution(uint roundLottery, uint roundDistibution, uint countWinnerRound, uint payEachWinner);\r\n    event LogHappyTicket(uint roundLottery, uint roundDistibution, uint happyTicket);\r\n\r\n    function isWinner(uint round, uint numberTicket) public view returns (bool) {\r\n        return tickets[round][numberTicket].winnerRound > 0;\r\n    }\r\n\r\n    function getBalancePlayer(uint round, address wallet) public view returns (uint) {\r\n        return balancePlayer[round][wallet];\r\n    }\r\n\r\n    function getBalanceWinner(uint round, address wallet) public view returns (uint) {\r\n        return balanceWinner[round][wallet];\r\n    }\r\n\r\n    function ticketInfo(uint round, uint numberTicket) public view returns(address payable wallet, uint winnerRound) {\r\n        Ticket memory ticket = tickets[round][numberTicket];\r\n        wallet = ticket.wallet;\r\n        winnerRound = ticket.winnerRound;\r\n    }\r\n\r\n    function newTicket(uint round, address payable wallet, uint priceOfToken) public onlyOwner {\r\n        countTickets[round]++;\r\n        Ticket storage ticket = tickets[round][countTickets[round]];\r\n        ticket.wallet = wallet;\r\n        balancePlayer[round][wallet] = balancePlayer[round][wallet].add(priceOfToken);\r\n    }\r\n\r\n    function clearRound(uint round) public {\r\n        countTickets[round] = 0;\r\n        countWinner[round] = CountWinner(0,0,0,0,0);\r\n        payEachWinner[round] = PayEachWinner(0,0,0,0,0);\r\n        stepEntropy = 1;\r\n        remainStepTS = 0;\r\n        countStepTS = 0;\r\n    }\r\n\r\n    function makeDistribution(uint round, uint priceOfToken) public onlyOwner {\r\n        uint count = countTickets[round];\r\n        uint amountEthCurrentRound = count.mul(priceOfToken);\r\n\r\n        makeCountWinnerRound(round, count);\r\n        makePayEachWinner(round, amountEthCurrentRound);\r\n\r\n        CountWinner memory cw = countWinner[round];\r\n        PayEachWinner memory pw = payEachWinner[round];\r\n\r\n        emit LogMakeDistribution(round, 1, cw.countWinnerRound_1, pw.payEachWinner_1);\r\n        emit LogMakeDistribution(round, 2, cw.countWinnerRound_2, pw.payEachWinner_2);\r\n        emit LogMakeDistribution(round, 3, cw.countWinnerRound_3, pw.payEachWinner_3);\r\n        emit LogMakeDistribution(round, 4, cw.countWinnerRound_4, pw.payEachWinner_4);\r\n        emit LogMakeDistribution(round, 5, cw.countWinnerRound_5, pw.payEachWinner_5);\r\n\r\n        if (happyTickets[round].length > 0) {\r\n            delete happyTickets[round];\r\n        }\r\n    }\r\n\r\n    function makeCountWinnerRound(uint round, uint cntTickets) internal {\r\n        uint cw_1 = 1;\r\n        uint cw_2 = percentTicketPrize_2.mmul(cntTickets);\r\n        uint cw_3 = percentTicketPrize_3.mmul(cntTickets);\r\n        uint cw_4 = percentTicketPrize_4.mmul(cntTickets);\r\n        uint cw_5 = percentTicketPrize_5.mmul(cntTickets);\r\n\r\n        countWinner[round] = CountWinner(cw_1, cw_2, cw_3, cw_4, cw_5);\r\n    }\r\n\r\n    function makePayEachWinner(uint round, uint amountEth) internal {\r\n        CountWinner memory cw = countWinner[round];\r\n\r\n        uint pw_1 = roundEth(percentAmountPrize_1.mmul(amountEth).div(cw.countWinnerRound_1), precisionPay);\r\n        uint pw_2 = roundEth(percentAmountPrize_2.mmul(amountEth).div(cw.countWinnerRound_2), precisionPay);\r\n        uint pw_3 = roundEth(percentAmountPrize_3.mmul(amountEth).div(cw.countWinnerRound_3), precisionPay);\r\n        uint pw_4 = roundEth(percentAmountPrize_4.mmul(amountEth).div(cw.countWinnerRound_4), precisionPay);\r\n        uint pw_5 = roundEth(percentAmountPrize_5.mmul(amountEth).div(cw.countWinnerRound_5), precisionPay);\r\n\r\n        payEachWinner[round] = PayEachWinner(pw_1, pw_2, pw_3, pw_4, pw_5);\r\n\r\n    }\r\n\r\n    function getCountTickets(uint round) public view returns (uint) {\r\n        return countTickets[round];\r\n    }\r\n\r\n    function getCountTwist(uint countsTickets, uint maxCountTicketByStep) public returns(uint countTwist) {\r\n        countTwist = countsTickets.div(2).div(maxCountTicketByStep);\r\n        if (countsTickets > countTwist.mul(2).mul(maxCountTicketByStep)) {\r\n            remainStepTS = countsTickets.sub(countTwist.mul(2).mul(maxCountTicketByStep));\r\n            countTwist++;\r\n        }\r\n        countStepTS = countTwist;\r\n\r\n    }\r\n\r\n    function getMemberArrayHappyTickets(uint round, uint index) public view returns (uint value) {\r\n        value =  happyTickets[round][index];\r\n    }\r\n\r\n    function getLengthArrayHappyTickets(uint round) public view returns (uint length) {\r\n        length = happyTickets[round].length;\r\n    }\r\n\r\n    function getStepTransfer() public view returns (uint stepTransfer, uint remainTicket) {\r\n        stepTransfer = countStepTS;\r\n        remainTicket = remainStepTS;\r\n    }\r\n\r\n    function getCountWinnersDistrib(uint round) public view returns (uint countWinnerRound_1, uint countWinnerRound_2, uint countWinnerRound_3, uint countWinnerRound_4, uint countWinnerRound_5) {\r\n        CountWinner memory cw = countWinner[round];\r\n\r\n        countWinnerRound_1 = cw.countWinnerRound_1;\r\n        countWinnerRound_2 = cw.countWinnerRound_2;\r\n        countWinnerRound_3 = cw.countWinnerRound_3;\r\n        countWinnerRound_4 = cw.countWinnerRound_4;\r\n        countWinnerRound_5 = cw.countWinnerRound_5;\r\n    }\r\n\r\n    function getPayEachWinnersDistrib(uint round) public view returns (uint payEachWinner_1, uint payEachWinner_2, uint payEachWinner_3, uint payEachWinner_4, uint payEachWinner_5) {\r\n        PayEachWinner memory pw = payEachWinner[round];\r\n\r\n        payEachWinner_1 = pw.payEachWinner_1;\r\n        payEachWinner_2 = pw.payEachWinner_2;\r\n        payEachWinner_3 = pw.payEachWinner_3;\r\n        payEachWinner_4 = pw.payEachWinner_4;\r\n        payEachWinner_5 = pw.payEachWinner_5;\r\n    }\r\n\r\n    function addBalanceWinner(uint round, uint amountPrize, uint happyNumber) public onlyOwner {\r\n        balanceWinner[round][tickets[round][happyNumber].wallet] = balanceWinner[round][tickets[round][happyNumber].wallet].add(amountPrize);\r\n    }\r\n\r\n    function setWinnerRountForTicket(uint round, uint winnerRound, uint happyNumber) public onlyOwner {\r\n        tickets[round][happyNumber].winnerRound = winnerRound;\r\n    }\r\n\r\n    //            tickets[round][happyNumber].winnerRound = winnerRound;\r\n\r\n    function addHappyNumber(uint round, uint numCurTwist, uint happyNumber) public onlyOwner {\r\n        happyTickets[round].push(happyNumber);\r\n        emit LogHappyTicket(round, numCurTwist, happyNumber);\r\n    }\r\n\r\n    function findHappyNumber(uint round) public onlyOwner returns(uint) {\r\n        stepEntropy++;\r\n        uint happyNumber = getRandomNumberTicket(stepEntropy, round);\r\n        while (tickets[round][happyNumber].winnerRound > 0) {\r\n            stepEntropy++;\r\n            happyNumber++;\r\n            if (happyNumber > countTickets[round]) {\r\n                happyNumber = 1;\r\n            }\r\n        }\r\n        return happyNumber;\r\n    }\r\n\r\n    function getRandomNumberTicket(uint entropy, uint round) public view returns(uint) {\r\n        require(countTickets[round] > 0, \"number of tickets must be greater than 0\");\r\n        uint randomFirst = maxRandom(block.number, msg.sender).div(now);\r\n        uint randomNumber = randomFirst.mul(entropy) % (countTickets[round]);\r\n        if (randomNumber == 0) { randomNumber = 1;}\r\n        return randomNumber;\r\n    }\r\n\r\n    function random(uint upper, uint blockn, address entropy) internal view returns (uint randomNumber) {\r\n        return maxRandom(blockn, entropy) % upper;\r\n    }\r\n\r\n    function maxRandom(uint blockn, address entropy) internal view returns (uint randomNumber) {\r\n        return uint(keccak256(\r\n                abi.encodePacked(\r\n                    blockhash(blockn),\r\n                    entropy)\r\n            ));\r\n    }\r\n\r\n    function roundEth(uint numerator, uint precision) internal pure returns(uint round) {\r\n        if (precision > 0 && precision < 18) {\r\n            uint256 _numerator = numerator / 10 ** (18 - precision - 1);\r\n            //            _numerator = (_numerator + 5) / 10;\r\n            _numerator = (_numerator) / 10;\r\n            round = (_numerator) * 10 ** (18 - precision);\r\n        }\r\n    }\r\n\r\n\r\n}\r\n\r\ncontract SundayLottery is Accessibility, Parameters {\r\n    using SafeMath for uint;\r\n\r\n    using Address for *;\r\n    using Zero for *;\r\n\r\n    TicketsStorage private m_tickets;\r\n    mapping (address => bool) private notUnigue;\r\n\r\n\r\n    address payable public administrationWallet;\r\n\r\n    uint private countWinnerRound_1;\r\n    uint private countWinnerRound_2;\r\n    uint private countWinnerRound_3;\r\n    uint private countWinnerRound_4;\r\n    uint private countWinnerRound_5;\r\n\r\n    uint private payEachWinner_1;\r\n    uint private payEachWinner_2;\r\n    uint private payEachWinner_3;\r\n    uint private payEachWinner_4;\r\n    uint private payEachWinner_5;\r\n\r\n    uint private remainStep;\r\n    uint private countStep;\r\n\r\n    // more events for easy read from blockchain\r\n    event LogNewTicket(address indexed addr, uint when, uint round);\r\n    event LogBalanceChanged(uint when, uint balance);\r\n    event LogChangeTime(uint newDate, uint oldDate);\r\n    event LogRefundEth(address indexed player, uint value);\r\n    event LogWinnerDefine(uint roundLottery, uint typeWinner, uint step);\r\n    event ChangeAddressWallet(address indexed owner, address indexed newAddress, address indexed oldAddress);\r\n    event SendToAdministrationWallet(uint balanceContract);\r\n    event Play(uint currentRound, uint numberCurrentTwist);\r\n\r\n    modifier balanceChanged {\r\n        _;\r\n        emit LogBalanceChanged(getCurrentDate(), address(this).balance);\r\n    }\r\n\r\n    modifier notFromContract() {\r\n        require(msg.sender.isNotContract(), \"only externally accounts\");\r\n        _;\r\n    }\r\n\r\n    constructor(address payable _administrationWallet) public {\r\n        require(_administrationWallet != address(0));\r\n        administrationWallet = _administrationWallet;\r\n        m_tickets = new TicketsStorage();\r\n        currentRound = 1;\r\n        m_tickets.clearRound(currentRound);\r\n    }\r\n\r\n    function() external payable {\r\n        if (msg.value >= PRICE_OF_TOKEN) {\r\n            buyTicket(msg.sender);\r\n        } else if (msg.value.isZero()) {\r\n            makeTwists();\r\n        } else {\r\n            refundEth(msg.sender, msg.value);\r\n        }\r\n    }\r\n\r\n    function getMemberArrayHappyTickets(uint round, uint index) public view returns (uint value) {\r\n        value =  m_tickets.getMemberArrayHappyTickets(round, index);\r\n    }\r\n\r\n    function getLengthArrayHappyTickets(uint round) public view returns (uint length) {\r\n        length =  m_tickets.getLengthArrayHappyTickets(round);\r\n    }\r\n\r\n    function getTicketInfo(uint round, uint index) public view returns (address payable wallet, uint winnerRound) {\r\n        (wallet, winnerRound) =  m_tickets.ticketInfo(round, index);\r\n    }\r\n\r\n    function getCountWinnersDistrib() public view returns (uint countWinRound_1, uint countWinRound_2,\r\n        uint countWinRound_3, uint countWinRound_4, uint countWinRound_5) {\r\n        (countWinRound_1, countWinRound_2, countWinRound_3,\r\n        countWinRound_4, countWinRound_5) = m_tickets.getCountWinnersDistrib(currentRound);\r\n    }\r\n\r\n    function getPayEachWinnersDistrib() public view returns (uint payEachWin_1, uint payEachWin_2,\r\n        uint payEachWin_3, uint payEachWin_4, uint payEachWin_5) {\r\n        (payEachWin_1, payEachWin_2, payEachWin_3,\r\n        payEachWin_4, payEachWin_5) = m_tickets.getPayEachWinnersDistrib(currentRound);\r\n    }\r\n\r\n    function getStepTransfer() public view returns (uint stepTransferVal, uint remainTicketVal) {\r\n        (stepTransferVal, remainTicketVal) = m_tickets.getStepTransfer();\r\n    }\r\n\r\n    function loadWinnersPerRound() internal {\r\n        (countWinnerRound_1, countWinnerRound_2, countWinnerRound_3,\r\n        countWinnerRound_4, countWinnerRound_5) = getCountWinnersDistrib();\r\n    }\r\n\r\n    function loadPayEachWinners() internal {\r\n        (payEachWinner_1, payEachWinner_2, payEachWinner_3,\r\n        payEachWinner_4, payEachWinner_5) = getPayEachWinnersDistrib();\r\n    }\r\n\r\n    function loadCountStep() internal {\r\n        (countStep, remainStep) = m_tickets.getStepTransfer();\r\n    }\r\n\r\n    function balanceETH() external view returns(uint) {\r\n        return address(this).balance;\r\n    }\r\n\r\n    function refundEth(address payable _player, uint _value) internal returns (bool) {\r\n        require(_player.notZero());\r\n        _player.transfer(_value);\r\n        emit LogRefundEth(_player, _value);\r\n    }\r\n\r\n    function buyTicket(address payable _addressPlayer) public payable notFromContract balanceChanged {\r\n        uint investment = msg.value;\r\n        require(investment >= PRICE_OF_TOKEN, \"investment must be >= PRICE_OF_TOKEN\");\r\n        require(!isTwist, \"ticket purchase is prohibited during the twist\");\r\n\r\n        uint tickets = investment.div(PRICE_OF_TOKEN);\r\n        if (tickets > MAX_TOKENS_BUY) {\r\n            tickets = MAX_TOKENS_BUY;\r\n        }\r\n        uint requireEth = tickets.mul(PRICE_OF_TOKEN);\r\n        if (investment > requireEth) {\r\n            refundEth(msg.sender, investment.sub(requireEth));\r\n        }\r\n\r\n        if (tickets > 0) {\r\n            uint currentDate = now;\r\n            while (tickets != 0) {\r\n                m_tickets.newTicket(currentRound, _addressPlayer, PRICE_OF_TOKEN);\r\n                emit LogNewTicket(_addressPlayer, currentDate, currentRound);\r\n                currentDate++;\r\n                totalTicketBuyed++;\r\n                tickets--;\r\n            }\r\n        }\r\n\r\n        if (!notUnigue[_addressPlayer]) {\r\n            notUnigue[_addressPlayer] = true;\r\n            uniquePlayer++;\r\n        }\r\n        totalEthRaised = totalEthRaised.add(requireEth);\r\n    }\r\n\r\n    function makeTwists() public notFromContract {\r\n        uint countTickets = m_tickets.getCountTickets(currentRound);\r\n        require(countTickets > MIN_TICKETS_BUY_FOR_ROUND, \"the number of tickets purchased must be >= MIN_TICKETS_BUY_FOR_ROUND\");\r\n        require(isSunday(getCurrentDate()), \"you can only play on Sunday\");\r\n        if (!isTwist) {\r\n            numberCurrentTwist = m_tickets.getCountTwist(countTickets, maxNumberStepCircle);\r\n            m_tickets.makeDistribution(currentRound, PRICE_OF_TOKEN);\r\n            isTwist = true;\r\n            loadWinnersPerRound();\r\n            loadPayEachWinners();\r\n            loadCountStep();\r\n        } else {\r\n            if (numberCurrentTwist > 0) {\r\n                play(currentRound, maxNumberStepCircle);\r\n                emit Play(currentRound, numberCurrentTwist);\r\n                numberCurrentTwist--;\r\n                if (numberCurrentTwist == 0) {\r\n                    isTwist = false;\r\n                    currentRound++;\r\n                    m_tickets.clearRound(currentRound);\r\n                    sendToAdministration();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    function play(uint round, uint maxCountTicketByStep) internal {\r\n        uint countTransfer = 0;\r\n        uint numberTransfer = 0;\r\n        if (remainStep > 0) {\r\n            if (countStep > 1) {\r\n                countTransfer = maxCountTicketByStep;\r\n            } else {\r\n                countTransfer = remainStep;\r\n            }\r\n        } else {\r\n            countTransfer = maxCountTicketByStep;\r\n        }\r\n\r\n        if (countStep > 0) {\r\n            if (countWinnerRound_1 > 0 && numberTransfer < countTransfer) {\r\n                if (transferPrize(payEachWinner_1, round, 1)) {\r\n                    countWinnerRound_1--;\r\n                    emit LogWinnerDefine(round, 1, numberTransfer);\r\n                }\r\n                numberTransfer++;\r\n            }\r\n            if (countWinnerRound_2 > 0 && numberTransfer < countTransfer) {\r\n                while (numberTransfer < countTransfer && countWinnerRound_2 > 0) {\r\n                    if (transferPrize(payEachWinner_2, round, 2)) {\r\n                        countWinnerRound_2--;\r\n                        emit LogWinnerDefine(round, 2, numberTransfer);\r\n                    }\r\n                    numberTransfer++;\r\n                }\r\n            }\r\n            if (countWinnerRound_3 > 0 && numberTransfer < countTransfer) {\r\n                while (numberTransfer < countTransfer && countWinnerRound_3 > 0) {\r\n                    if (transferPrize(payEachWinner_3, round, 3)) {\r\n                        countWinnerRound_3--;\r\n                        emit LogWinnerDefine(round, 3, numberTransfer);\r\n                    }\r\n                    numberTransfer++;\r\n                }\r\n            }\r\n            if (countWinnerRound_4 > 0 && numberTransfer < countTransfer) {\r\n                while (numberTransfer < countTransfer && countWinnerRound_4 > 0) {\r\n                    if (transferPrize(payEachWinner_4, round, 4)) {\r\n                        countWinnerRound_4--;\r\n                        emit LogWinnerDefine(round, 4, numberTransfer);\r\n                    }\r\n                    numberTransfer++;\r\n                }\r\n            }\r\n            if (countWinnerRound_5 > 0 && numberTransfer < countTransfer) {\r\n                while (numberTransfer < countTransfer && countWinnerRound_5 > 0) {\r\n                    if (transferPrize(payEachWinner_5, round, 5)) {\r\n                        countWinnerRound_5--;\r\n                        emit LogWinnerDefine(round, 5, numberTransfer);\r\n                    }\r\n                    numberTransfer++;\r\n                }\r\n            }\r\n\r\n            countStep--;\r\n        }\r\n    }\r\n\r\n    function transferPrize(uint amountPrize, uint round, uint winnerRound) internal returns(bool) {\r\n        if (address(this).balance > amountPrize) {\r\n            uint happyNumber = m_tickets.findHappyNumber(round);\r\n            m_tickets.addHappyNumber(currentRound, numberCurrentTwist, happyNumber);\r\n            m_tickets.addBalanceWinner(currentRound, amountPrize, happyNumber);\r\n            m_tickets.setWinnerRountForTicket(currentRound, winnerRound, happyNumber);\r\n            (address payable wallet, ) =  m_tickets.ticketInfo(round, happyNumber);\r\n            wallet.transfer(amountPrize);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function setMaxNumberStepCircle(uint256 _number) external onlyOwner {\r\n        require(_number > 0);\r\n        maxNumberStepCircle = _number;\r\n    }\r\n\r\n    function getBalancePlayer(uint round, address wallet) external view returns (uint) {\r\n        return m_tickets.getBalancePlayer(round, wallet);\r\n    }\r\n\r\n    function getBalanceWinner(uint round, address wallet) external view returns (uint) {\r\n        return m_tickets.getBalanceWinner(round, wallet);\r\n    }\r\n\r\n    function getCurrentDate() public view returns (uint) {\r\n        if (isDemo) {\r\n            return simulateDate;\r\n        }\r\n        return now;\r\n    }\r\n\r\n    function setSimulateDate(uint _newDate) external onlyOwner {\r\n        if (isDemo) {\r\n            require(_newDate > simulateDate);\r\n            emit LogChangeTime(_newDate, simulateDate);\r\n            simulateDate = _newDate;\r\n        }\r\n    }\r\n\r\n    function setDemo() external onlyOwner {\r\n        if (uniquePlayer == 0) {\r\n            isDemo = true;\r\n        }\r\n    }\r\n\r\n    function isSunday(uint timestamp) public pure returns (bool) {\r\n        uint numberDay = (timestamp / (1 days) + 4) % 7;\r\n        if (numberDay == 0) {\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function getCountTickets(uint round) public view returns (uint countTickets) {\r\n        countTickets = m_tickets.getCountTickets(round);\r\n    }\r\n\r\n    function setAdministrationWallet(address payable _newWallet) external onlyOwner {\r\n        require(_newWallet != address(0));\r\n        address payable _oldWallet = administrationWallet;\r\n        administrationWallet = _newWallet;\r\n        emit ChangeAddressWallet(msg.sender, _newWallet, _oldWallet);\r\n    }\r\n\r\n    function sendToAdministration() internal {\r\n        require(administrationWallet != address(0), \"wallet address is not 0\");\r\n        uint amount = address(this).balance;\r\n\r\n        if (amount > 0) {\r\n            if (administrationWallet.send(amount)) {\r\n                emit SendToAdministrationWallet(amount);\r\n            }\r\n        }\r\n    }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"simulateDate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"PRICE_OF_TOKEN\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"round\",\"type\":\"uint256\"}],\"name\":\"getCountTickets\",\"outputs\":[{\"name\":\"countTickets\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"numberCurrentTwist\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"isSunday\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"round\",\"type\":\"uint256\"},{\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getMemberArrayHappyTickets\",\"outputs\":[{\"name\":\"value\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCountWinnersDistrib\",\"outputs\":[{\"name\":\"countWinRound_1\",\"type\":\"uint256\"},{\"name\":\"countWinRound_2\",\"type\":\"uint256\"},{\"name\":\"countWinRound_3\",\"type\":\"uint256\"},{\"name\":\"countWinRound_4\",\"type\":\"uint256\"},{\"name\":\"countWinRound_5\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getPayEachWinnersDistrib\",\"outputs\":[{\"name\":\"payEachWin_1\",\"type\":\"uint256\"},{\"name\":\"payEachWin_2\",\"type\":\"uint256\"},{\"name\":\"payEachWin_3\",\"type\":\"uint256\"},{\"name\":\"payEachWin_4\",\"type\":\"uint256\"},{\"name\":\"payEachWin_5\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getStepTransfer\",\"outputs\":[{\"name\":\"stepTransferVal\",\"type\":\"uint256\"},{\"name\":\"remainTicketVal\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"round\",\"type\":\"uint256\"},{\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getTicketInfo\",\"outputs\":[{\"name\":\"wallet\",\"type\":\"address\"},{\"name\":\"winnerRound\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"round\",\"type\":\"uint256\"},{\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"getBalanceWinner\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"setDemo\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"makeTwists\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"uniquePlayer\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newDate\",\"type\":\"uint256\"}],\"name\":\"setSimulateDate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentRound\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCurrentDate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalTicketBuyed\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addressPlayer\",\"type\":\"address\"}],\"name\":\"buyTicket\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newWallet\",\"type\":\"address\"}],\"name\":\"setAdministrationWallet\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalEthRaised\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"administrationWallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isTwist\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isDemo\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"round\",\"type\":\"uint256\"}],\"name\":\"getLengthArrayHappyTickets\",\"outputs\":[{\"name\":\"length\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_TOKENS_BUY\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"balanceETH\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MIN_TICKETS_BUY_FOR_ROUND\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_number\",\"type\":\"uint256\"}],\"name\":\"setMaxNumberStepCircle\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"round\",\"type\":\"uint256\"},{\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"getBalancePlayer\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxNumberStepCircle\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_administrationWallet\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"when\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"round\",\"type\":\"uint256\"}],\"name\":\"LogNewTicket\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"when\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"balance\",\"type\":\"uint256\"}],\"name\":\"LogBalanceChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newDate\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"oldDate\",\"type\":\"uint256\"}],\"name\":\"LogChangeTime\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"player\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"LogRefundEth\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"roundLottery\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"typeWinner\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"step\",\"type\":\"uint256\"}],\"name\":\"LogWinnerDefine\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newAddress\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"oldAddress\",\"type\":\"address\"}],\"name\":\"ChangeAddressWallet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"balanceContract\",\"type\":\"uint256\"}],\"name\":\"SendToAdministrationWallet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"currentRound\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"numberCurrentTwist\",\"type\":\"uint256\"}],\"name\":\"Play\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerChanged\",\"type\":\"event\"}]","ContractName":"SundayLottery","CompilerVersion":"v0.5.7+commit.6da8b019","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000009c9ab524379b0e426ac71a060a04b4fc52a58a5","Library":"","SwarmSource":"bzzr://6b6d494245a0bb3eabd46c14e6490c0350ab146fee57806d4e399b43a8e4707f"}]}