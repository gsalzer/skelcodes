{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.3;\r\n\r\n// File: contracts/utility/Ownable.sol\r\n\r\ncontract Ownable {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n     * account.\r\n     */\r\n    constructor () internal {\r\n        _owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), _owner);\r\n    }\r\n\r\n    /**\r\n     * @return the address of the owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner());\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @return true if `msg.sender` is the owner of the contract.\r\n     */\r\n    function isOwner() public view returns (bool) {\r\n        return msg.sender == _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0));\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\n// File: contracts/utility/Approvable.sol\r\n\r\ncontract Approvable is Ownable {\r\n    mapping(address => bool) private _approvedAddress;\r\n\r\n\r\n    modifier onlyApproved() {\r\n        require(isApproved());\r\n        _;\r\n    }\r\n\r\n    function isApproved() public view returns(bool) {\r\n        return _approvedAddress[msg.sender] || isOwner();\r\n    }\r\n\r\n    function approveAddress(address _address) public onlyOwner {\r\n        _approvedAddress[_address] = true;\r\n    }\r\n\r\n    function revokeApproval(address _address) public onlyOwner {\r\n        _approvedAddress[_address] = false;\r\n    }\r\n}\r\n\r\n// File: contracts/utility/StoringCreationMeta.sol\r\n\r\ncontract StoringCreationMeta {\r\n    uint public creationBlock;\r\n    uint public creationTime;\r\n\r\n    constructor() internal {\r\n        creationBlock = block.number;\r\n        creationTime = block.timestamp;\r\n    }\r\n}\r\n\r\n// File: contracts/NodeRegistry.sol\r\n\r\ncontract NodeRegistry is StoringCreationMeta, Approvable {\r\n    mapping(address => string) public nodeIp;\r\n    mapping(address => string) public nodeWs;\r\n\r\n    mapping(address => uint) public nodeCountLimit;\r\n\r\n    struct NodeList {\r\n        address[] items;\r\n        mapping(address => uint) position;\r\n    }\r\n    mapping(address => NodeList) userNodes;\r\n    NodeList availableNodes;\r\n\r\n    modifier onlyRegisteredNode() {\r\n        require(\r\n            availableNodes.position[msg.sender] > 0,\r\n            \"Node not registered.\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    function registerNodes(address[] memory _nodeAddresses) public {\r\n        NodeList storage _nodes = userNodes[msg.sender];\r\n\r\n        require(\r\n            nodeCountLimit[msg.sender] >=\r\n            _nodes.items.length + _nodeAddresses.length,\r\n            \"Over the limit.\"\r\n        );\r\n\r\n        for(uint i = 0; i < _nodeAddresses.length; i++) {\r\n            // If it doesn't exist already\r\n            if(_nodes.position[_nodeAddresses[i]] == 0) {\r\n                registerNode(_nodeAddresses[i]);\r\n            }\r\n        }\r\n    }\r\n\r\n    function deregisterNodes(address[] memory _nodeAddresses) public {\r\n        for(uint i = 0; i < _nodeAddresses.length; i++) {\r\n            deregisterNode(_nodeAddresses[i]);\r\n        }\r\n    }\r\n\r\n    function deregisterNode(address _nodeAddress) private {\r\n        NodeList storage _nodes = userNodes[msg.sender];\r\n\r\n        if(_nodes.position[_nodeAddress] == 0) {\r\n            revert(\"Node not registered.\");\r\n        }\r\n\r\n        removeFromList(_nodes, _nodeAddress);\r\n        removeFromList(availableNodes, _nodeAddress);\r\n\r\n        delete nodeIp[_nodeAddress];\r\n        delete nodeWs[_nodeAddress];\r\n    }\r\n\r\n    function removeFromList(NodeList storage _nodes, address _item) private {\r\n        uint nIndex = _nodes.position[_item] - 1;\r\n        uint lastIndex = _nodes.items.length - 1;\r\n        address lastItem = _nodes.items[lastIndex];\r\n\r\n        _nodes.items[nIndex] = lastItem;\r\n        _nodes.position[lastItem] = nIndex + 1;\r\n        _nodes.position[_item] = 0;\r\n\r\n        _nodes.items.pop();\r\n    }\r\n\r\n    function registerNode(address _nodeAddress) private {\r\n        NodeList storage _nodes = userNodes[msg.sender];\r\n\r\n        if(availableNodes.position[_nodeAddress] != 0) {\r\n            revert(\"Node already registered by another user.\");\r\n        }\r\n\r\n        // Save to user nodes\r\n        _nodes.items.push(_nodeAddress);\r\n        _nodes.position[_nodeAddress] = _nodes.items.length;\r\n\r\n        // Save to global nodes\r\n        availableNodes.items.push(_nodeAddress);\r\n        availableNodes.position[_nodeAddress] = availableNodes.items.length;\r\n    }\r\n\r\n    function getAvailableNodes() public view returns(address[] memory) {\r\n        return availableNodes.items;\r\n    }\r\n\r\n    function getUserNodes(address _user) public view returns(address[] memory) {\r\n        return userNodes[_user].items;\r\n    }\r\n\r\n    function setNodeLimits(address[] memory _users, uint[] memory _limits) public onlyApproved {\r\n        require(_users.length == _limits.length, \"Length mismatch.\");\r\n\r\n        for(uint i = 0; i < _users.length; ++i) {\r\n            _setNodeLimit(_users[i], _limits[i]);\r\n        }\r\n    }\r\n\r\n    function _setNodeLimit(address _user, uint _limit) private {\r\n        nodeCountLimit[_user] = _limit;\r\n\r\n        _pruneUserNodes(_user, _limit);\r\n    }\r\n\r\n    function _pruneUserNodes(address _user, uint _limit) private view {\r\n        if (_limit >= nodeCountLimit[_user]) {\r\n            return;\r\n        }\r\n    }\r\n\r\n    function registerNodeIp(string memory _ip) public onlyRegisteredNode {\r\n        nodeIp[msg.sender] = _ip;\r\n    }\r\n\r\n    function registerNodeWs(string memory _ws) public onlyRegisteredNode {\r\n        nodeWs[msg.sender] = _ws;\r\n    }\r\n\r\n    function registerNodeIpAndWs(string memory _ip, string memory _ws) public onlyRegisteredNode {\r\n        nodeIp[msg.sender] = _ip;\r\n        nodeWs[msg.sender] = _ws;\r\n    }\r\n\r\n    function getNodeIpAndWs(address _node) public view returns(string memory, string memory) {\r\n        return (nodeIp[_node], nodeWs[_node]);\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_users\",\"type\":\"address[]\"},{\"name\":\"_limits\",\"type\":\"uint256[]\"}],\"name\":\"setNodeLimits\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"creationBlock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getUserNodes\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isApproved\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_ws\",\"type\":\"string\"}],\"name\":\"registerNodeWs\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_node\",\"type\":\"address\"}],\"name\":\"getNodeIpAndWs\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"},{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAvailableNodes\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"revokeApproval\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"nodeCountLimit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_ip\",\"type\":\"string\"}],\"name\":\"registerNodeIp\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_nodeAddresses\",\"type\":\"address[]\"}],\"name\":\"registerNodes\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_ip\",\"type\":\"string\"},{\"name\":\"_ws\",\"type\":\"string\"}],\"name\":\"registerNodeIpAndWs\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_nodeAddresses\",\"type\":\"address[]\"}],\"name\":\"deregisterNodes\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"nodeWs\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"creationTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"nodeIp\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"approveAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"NodeRegistry","CompilerVersion":"v0.5.3+commit.10d17f24","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://b8a65109c131f6ceec1c4dedaa71c3543bc505a834b06e0996903af7635ffbd3"}]}