{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.25;\r\n\r\n/* This Source Code Form is subject to the terms of the Mozilla external\r\n * License, v. 2.0. If a copy of the MPL was not distributed with this\r\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\r\n *\r\n * This code has not been reviewed.\r\n * Do not use or deploy this code before reviewing it personally first.\r\n */\r\n\r\ninterface ERC777Token {\r\n  function name() external view returns (string);\r\n  function symbol() external view returns (string);\r\n  function totalSupply() external view returns (uint256);\r\n  function balanceOf(address owner) external view returns (uint256);\r\n  function granularity() external view returns (uint256);\r\n\r\n  function defaultOperators() external view returns (address[]);\r\n  function isOperatorFor(address operator, address tokenHolder) external view returns (bool);\r\n  function authorizeOperator(address operator) external;\r\n  function revokeOperator(address operator) external;\r\n\r\n  function send(address to, uint256 amount, bytes holderData) external;\r\n  function operatorSend(address from, address to, uint256 amount, bytes holderData, bytes operatorData) external;\r\n\r\n  function burn(uint256 amount, bytes holderData) external;\r\n  function operatorBurn(address from, uint256 amount, bytes holderData, bytes operatorData) external;\r\n\r\n  event Sent(\r\n    address indexed operator,\r\n    address indexed from,\r\n    address indexed to,\r\n    uint256 amount,\r\n    bytes holderData,\r\n    bytes operatorData\r\n  );\r\n  event Minted(address indexed operator, address indexed to, uint256 amount, bytes operatorData);\r\n  event Burned(address indexed operator, address indexed from, uint256 amount, bytes holderData, bytes operatorData);\r\n  event AuthorizedOperator(address indexed operator, address indexed tokenHolder);\r\n  event RevokedOperator(address indexed operator, address indexed tokenHolder);\r\n}\r\n\r\n/// @title DelegatedTransferOperatorV4\r\n/// @author Roger Wu (Roger-Wu)\r\n/// @dev A DelegatedTransferOperator contract that has the following features:\r\n///   1. To prevent replay attack, we check if a _nonce has been used by a token holder.\r\n///   2. Minimize the gas by making functions inline and remove trivial event.\r\n///   3. Add _userData.\r\ncontract DelegatedTransferOperatorV4 {\r\n  mapping(address => uint256) public usedNonce;\r\n  ERC777Token public tokenContract;\r\n\r\n  constructor(address _tokenAddress) public {\r\n    tokenContract = ERC777Token(_tokenAddress);\r\n  }\r\n\r\n  /**\r\n    * @notice Submit a presigned transfer\r\n    * @param _to address The address which you want to transfer to.\r\n    * @param _delegate address The address which is allowed to send this transaction.\r\n    * @param _value uint256 The amount of tokens to be transferred.\r\n    * @param _fee uint256 The amount of tokens paid to msg.sender, by the owner.\r\n    * @param _nonce uint256 Presigned transaction number.\r\n    * @param _userData bytes Data generated by the user to be sent to the recipient.\r\n    * @param _sig_r bytes32 The r of the signature.\r\n    * @param _sig_s bytes32 The s of the signature.\r\n    * @param _sig_v uint8 The v of the signature.\r\n    * @notice some rules:\r\n    * 1. If _to is address(0), the tx will fail when doSend().\r\n    * 2. If _delegate == address(0), then anyone can be the delegate.\r\n    * 3. _nonce must be greater than the last used nonce by the token holder,\r\n    *    but nonces don't have to be serial numbers.\r\n    *    We recommend using unix time as nonce.\r\n    * 4. _sig_v should be 27 or 28.\r\n    */\r\n  function transferPreSigned(\r\n    address _to,\r\n    address _delegate,\r\n    uint256 _value,\r\n    uint256 _fee,\r\n    uint256 _nonce,\r\n    bytes _userData,\r\n    bytes32 _sig_r,\r\n    bytes32 _sig_s,\r\n    uint8 _sig_v\r\n  )\r\n    external\r\n  {\r\n    require(\r\n      _delegate == address(0) || _delegate == msg.sender,\r\n      \"_delegate should be address(0) or msg.sender\"\r\n    );\r\n\r\n    // address _signer = recover(_hash, _signature);\r\n    address _signer = (_sig_v != 27 && _sig_v != 28) ?\r\n      address(0) :\r\n      ecrecover(\r\n        keccak256(abi.encodePacked(\r\n          address(this),\r\n          _to,\r\n          _delegate,\r\n          _value,\r\n          _fee,\r\n          _nonce,\r\n          _userData\r\n        )),\r\n        _sig_v, _sig_r, _sig_s\r\n      );\r\n\r\n    require(\r\n      _signer != address(0),\r\n      \"_signature is invalid.\"\r\n    );\r\n\r\n    require(\r\n      _nonce > usedNonce[_signer],\r\n      \"_nonce must be greater than the last used nonce of the token holder.\"\r\n    );\r\n\r\n    usedNonce[_signer] = _nonce;\r\n\r\n    tokenContract.operatorSend(_signer, _to, _value, _userData, \"\");\r\n    if (_fee > 0) {\r\n      tokenContract.operatorSend(_signer, msg.sender, _fee, _userData, \"\");\r\n    }\r\n  }\r\n\r\n  /**\r\n    * @notice Hash (keccak256) of the payload used by transferPreSigned\r\n    * @param _operator address The address of the operator.\r\n    * @param _to address The address which you want to transfer to.\r\n    * @param _delegate address The address of the delegate.\r\n    * @param _value uint256 The amount of tokens to be transferred.\r\n    * @param _fee uint256 The amount of tokens paid to msg.sender, by the owner.\r\n    * @param _nonce uint256 Presigned transaction number.\r\n    * @param _userData bytes Data generated by the user to be sent to the recipient.\r\n    */\r\n  function transferPreSignedHashing(\r\n    address _operator,\r\n    address _to,\r\n    address _delegate,\r\n    uint256 _value,\r\n    uint256 _fee,\r\n    uint256 _nonce,\r\n    bytes _userData\r\n  )\r\n    public\r\n    pure\r\n    returns (bytes32)\r\n  {\r\n    return keccak256(abi.encodePacked(\r\n      _operator,\r\n      _to,\r\n      _delegate,\r\n      _value,\r\n      _fee,\r\n      _nonce,\r\n      _userData\r\n    ));\r\n  }\r\n\r\n  /**\r\n    * @notice Recover signer address from a message by using his signature\r\n    * @param hash bytes32 message, the hash is the signed message. What is recovered is the signer address.\r\n    * @param sig bytes signature, the signature is generated using web3.eth.sign()\r\n    */\r\n  function recover(bytes32 hash, bytes sig) public pure returns (address) {\r\n    bytes32 r;\r\n    bytes32 s;\r\n    uint8 v;\r\n\r\n    // Check the signature length\r\n    if (sig.length != 65) {\r\n      return (address(0));\r\n    }\r\n\r\n    // Divide the signature in r, s and v variables\r\n    // ecrecover takes the signature parameters, and the only way to get them\r\n    // currently is to use assembly.\r\n    // solium-disable-next-line security/no-inline-assembly\r\n    assembly {\r\n      r := mload(add(sig, 0x20))\r\n      s := mload(add(sig, 0x40))\r\n      v := byte(0, mload(add(sig, 0x60)))\r\n    }\r\n\r\n    // Version of signature should be 27 or 28, but 0 and 1 are also possible versions\r\n    if (v < 27) {\r\n      v += 27;\r\n    }\r\n\r\n    // If the version is correct return the signer address\r\n    if (v != 27 && v != 28) {\r\n      return (address(0));\r\n    } else {\r\n      return ecrecover(hash, v, r, s);\r\n    }\r\n  }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"hash\",\"type\":\"bytes32\"},{\"name\":\"sig\",\"type\":\"bytes\"}],\"name\":\"recover\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"usedNonce\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_delegate\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_fee\",\"type\":\"uint256\"},{\"name\":\"_nonce\",\"type\":\"uint256\"},{\"name\":\"_userData\",\"type\":\"bytes\"},{\"name\":\"_sig_r\",\"type\":\"bytes32\"},{\"name\":\"_sig_s\",\"type\":\"bytes32\"},{\"name\":\"_sig_v\",\"type\":\"uint8\"}],\"name\":\"transferPreSigned\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_operator\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_delegate\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_fee\",\"type\":\"uint256\"},{\"name\":\"_nonce\",\"type\":\"uint256\"},{\"name\":\"_userData\",\"type\":\"bytes\"}],\"name\":\"transferPreSignedHashing\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_tokenAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"}]","ContractName":"DelegatedTransferOperatorV4","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000067ab11058ef23d0a19178f61a050d3c38f81ae21","Library":"","SwarmSource":"bzzr://283dd8b1a64158f1778f429c523f8a11133863ad446c2f58c1e88eb8aa2172d1"}]}