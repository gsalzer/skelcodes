{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity >0.4.99 <0.6.0;\r\n\r\nlibrary Zero {\r\n    function requireNotZero(address addr) internal pure {\r\n        require(addr != address(0), \"require not zero address\");\r\n    }\r\n\r\n    function requireNotZero(uint val) internal pure {\r\n        require(val != 0, \"require not zero value\");\r\n    }\r\n\r\n    function notZero(address addr) internal pure returns(bool) {\r\n        return !(addr == address(0));\r\n    }\r\n\r\n    function isZero(address addr) internal pure returns(bool) {\r\n        return addr == address(0);\r\n    }\r\n\r\n    function isZero(uint a) internal pure returns(bool) {\r\n        return a == 0;\r\n    }\r\n\r\n    function notZero(uint a) internal pure returns(bool) {\r\n        return a != 0;\r\n    }\r\n}\r\n\r\nlibrary Address {\r\n    function toAddress(bytes memory source) internal pure returns(address addr) {\r\n        assembly { addr := mload(add(source,0x14)) }\r\n        return addr;\r\n    }\r\n\r\n    function isNotContract(address addr) internal view returns(bool) {\r\n        uint length;\r\n        assembly { length := extcodesize(addr) }\r\n        return length == 0;\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n\r\n    /**\r\n    * @dev Multiplies two numbers, reverts on overflow.\r\n    */\r\n    function mul(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n        if (_a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = _a * _b;\r\n        require(c / _a == _b);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\r\n    */\r\n    function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n        require(_b > 0); // Solidity only automatically asserts when dividing by 0\r\n        uint256 c = _a / _b;\r\n        // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n        require(_b <= _a);\r\n        uint256 c = _a - _b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, reverts on overflow.\r\n    */\r\n    function add(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n        uint256 c = _a + _b;\r\n        require(c >= _a);\r\n\r\n        return c;\r\n    }\r\n\r\n}\r\n\r\ncontract Accessibility {\r\n    address private owner;\r\n    event OwnerChanged(address indexed previousOwner, address indexed newOwner);\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"access denied\");\r\n        _;\r\n    }\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    function changeOwner(address _newOwner) onlyOwner public {\r\n        require(_newOwner != address(0));\r\n        emit OwnerChanged(owner, _newOwner);\r\n        owner = _newOwner;\r\n    }\r\n}\r\n\r\n\r\ncontract TicketsStorage is Accessibility  {\r\n    using SafeMath for uint;\r\n\r\n    struct Ticket {\r\n        address payable wallet;\r\n        bool isWinner;\r\n        uint numberTicket;\r\n    }\r\n\r\n    uint private entropyNumber = 121;\r\n\r\n    mapping (uint => uint) private countTickets;\r\n    // currentRound -> number ticket\r\n\r\n    mapping (uint => mapping (uint => Ticket)) private tickets;\r\n    // currentRound -> number ticket -> Ticket\r\n\r\n    mapping (uint => mapping (address => uint)) private balancePlayer;\r\n    // currentRound -> wallet -> balance player\r\n\r\n    mapping (address => mapping (uint => uint)) private balanceWinner;\r\n    // wallet -> balance winner\r\n\r\n    event LogHappyTicket(uint roundLottery, uint happyTicket);\r\n\r\n    function checkWinner(uint round, uint numberTicket) public view returns (bool) {\r\n        return tickets[round][numberTicket].isWinner;\r\n    }\r\n\r\n    function getBalancePlayer(uint round, address wallet) public view returns (uint) {\r\n        return balancePlayer[round][wallet];\r\n    }\r\n\r\n    function ticketInfo(uint round, uint index) public view returns(address payable wallet, bool isWinner, uint numberTicket) {\r\n        Ticket memory ticket = tickets[round][index];\r\n        wallet = ticket.wallet;\r\n        isWinner = ticket.isWinner;\r\n        numberTicket = ticket.numberTicket;\r\n    }\r\n\r\n    function newTicket(uint round, address payable wallet, uint priceOfToken) public onlyOwner {\r\n        countTickets[round]++;\r\n        Ticket storage ticket = tickets[round][countTickets[round]];\r\n        ticket.wallet = wallet;\r\n        ticket.numberTicket = countTickets[round];\r\n        balancePlayer[round][wallet] = balancePlayer[round][wallet].add(priceOfToken);\r\n    }\r\n\r\n    function clearRound(uint round) public {\r\n        countTickets[round] = 0;\r\n        if (entropyNumber == 330) {\r\n            entropyNumber = 121;\r\n        }\r\n    }\r\n\r\n    function getCountTickets(uint round) public view returns (uint) {\r\n        return countTickets[round];\r\n    }\r\n\r\n    function addBalanceWinner(uint round, uint amountPrize, uint happyNumber) public onlyOwner {\r\n        address walletTicket = tickets[round][happyNumber].wallet;\r\n        balanceWinner[walletTicket][round] = balanceWinner[walletTicket][round].add(amountPrize);\r\n        tickets[round][happyNumber].isWinner = true;\r\n    }\r\n\r\n    function getBalanceWinner(address wallet, uint round) public view returns (uint) {\r\n        return balanceWinner[wallet][round];\r\n    }\r\n\r\n    function findHappyNumber(uint round, uint typeStep) public onlyOwner returns(uint) {\r\n        require(countTickets[round] > 0, \"number of tickets must be greater than 0\");\r\n        uint happyNumber = 0;\r\n        if (typeStep == 3) {\r\n            happyNumber = getRandomNumber(11);\r\n        } else if (typeStep == 1) {\r\n            happyNumber = getRandomNumber(3);\r\n        } else if (typeStep == 2) {\r\n            happyNumber = getRandomNumber(6);\r\n        } else {\r\n            happyNumber = getRandomNumber(2);\r\n        }\r\n        emit LogHappyTicket(round, happyNumber);\r\n        return happyNumber;\r\n    }\r\n\r\n    function getRandomNumber(uint step) internal returns(uint) {\r\n        entropyNumber = entropyNumber.add(1);\r\n        uint randomFirst = maxRandom(block.number, msg.sender).div(now);\r\n        uint randomNumber = randomFirst.mul(entropyNumber) % (66);\r\n        randomNumber = randomNumber % step;\r\n        return randomNumber + 1;\r\n    }\r\n\r\n    function maxRandom(uint blockn, address entropyAddress) internal view returns (uint randomNumber) {\r\n        return uint(keccak256(\r\n                abi.encodePacked(\r\n                    blockhash(blockn),\r\n                    entropyAddress)\r\n            ));\r\n    }\r\n\r\n}\r\n\r\ncontract SundayLottery is Accessibility {\r\n    using SafeMath for uint;\r\n\r\n    using Address for *;\r\n    using Zero for *;\r\n\r\n    TicketsStorage private m_tickets;\r\n    mapping (address => bool) private notUnigue;\r\n\r\n    enum StepLottery {TWO, THREE, SIX, ELEVEN}\r\n    StepLottery stepLottery;\r\n    uint[] private step = [2, 3, 6, 11];\r\n    uint[] private priceTicket = [0.05 ether, 0.02 ether, 0.01 ether, 0.01 ether];\r\n    uint[] private prizePool = [0.09 ether, 0.05 ether, 0.05 ether, 0.1 ether];\r\n\r\n    address payable public administrationWallet;\r\n\r\n    uint private canBuyTickets = 0;\r\n\r\n    uint public priceOfToken = 0.01 ether;\r\n\r\n    uint private amountPrize;\r\n\r\n    uint public currentRound;\r\n    uint public totalEthRaised;\r\n    uint public totalTicketBuyed;\r\n\r\n    uint public uniquePlayer;\r\n\r\n    // more events for easy read from blockchain\r\n    event LogNewTicket(address indexed addr, uint when, uint round, uint price);\r\n    event LogBalanceChanged(uint when, uint balance);\r\n    event LogChangeTime(uint newDate, uint oldDate);\r\n    event LogRefundEth(address indexed player, uint value);\r\n    event LogWinnerDefine(uint roundLottery, address indexed wallet, uint happyNumber);\r\n    event ChangeAddressWallet(address indexed owner, address indexed newAddress, address indexed oldAddress);\r\n    event SendToAdministrationWallet(uint balanceContract);\r\n\r\n    modifier balanceChanged {\r\n        _;\r\n        emit LogBalanceChanged(getCurrentDate(), address(this).balance);\r\n    }\r\n\r\n    modifier notFromContract() {\r\n        require(msg.sender.isNotContract(), \"only externally accounts\");\r\n        _;\r\n    }\r\n\r\n    constructor(address payable _administrationWallet, uint _step) public {\r\n        require(_administrationWallet != address(0));\r\n        administrationWallet = _administrationWallet;\r\n        m_tickets = new TicketsStorage();\r\n        currentRound = 1;\r\n        m_tickets.clearRound(currentRound);\r\n        setStepLottery(_step);\r\n    }\r\n\r\n    function() external payable {\r\n        if (msg.value >= priceOfToken) {\r\n            buyTicket(msg.sender);\r\n        } else {\r\n            refundEth(msg.sender, msg.value);\r\n        }\r\n    }\r\n\r\n    function buyTicket(address payable _addressPlayer) public payable notFromContract balanceChanged returns (uint buyTickets) {\r\n        uint investment = msg.value;\r\n        require(investment >= priceOfToken, \"investment must be >= PRICE OF TOKEN\");\r\n\r\n        uint tickets = investment.div(priceOfToken);\r\n        if (tickets > canBuyTickets) {\r\n            tickets = canBuyTickets;\r\n            canBuyTickets = 0;\r\n        } else {\r\n            canBuyTickets = canBuyTickets.sub(tickets);\r\n        }\r\n\r\n        uint requireEth = tickets.mul(priceOfToken);\r\n        if (investment > requireEth) {\r\n            refundEth(msg.sender, investment.sub(requireEth));\r\n        }\r\n\r\n        buyTickets = tickets;\r\n        if (tickets > 0) {\r\n            uint currentDate = now;\r\n            while (tickets != 0) {\r\n                m_tickets.newTicket(currentRound, _addressPlayer, priceOfToken);\r\n                emit LogNewTicket(_addressPlayer, currentDate, currentRound, priceOfToken);\r\n                totalTicketBuyed++;\r\n                tickets--;\r\n            }\r\n        }\r\n\r\n        if (!notUnigue[_addressPlayer]) {\r\n            notUnigue[_addressPlayer] = true;\r\n            uniquePlayer++;\r\n        }\r\n        totalEthRaised = totalEthRaised.add(requireEth);\r\n\r\n        if (canBuyTickets.isZero()) {\r\n            makeTwists();\r\n        }\r\n    }\r\n\r\n    function makeTwists() internal notFromContract {\r\n        play(currentRound);\r\n        sendToAdministration();\r\n        canBuyTickets = step[getStepLottery()];\r\n        currentRound++;\r\n        m_tickets.clearRound(currentRound);\r\n    }\r\n\r\n    function play(uint round) internal {\r\n        if (address(this).balance >= amountPrize) {\r\n            uint happyNumber = m_tickets.findHappyNumber(round, getStepLottery());\r\n            m_tickets.addBalanceWinner(currentRound, amountPrize, happyNumber);\r\n            (address payable wallet,,) =  m_tickets.ticketInfo(round, happyNumber);\r\n            wallet.transfer(amountPrize);\r\n            emit LogWinnerDefine(round, wallet, happyNumber);\r\n        }\r\n    }\r\n\r\n    function setStepLottery(uint newStep) public onlyOwner {\r\n        require(uint(StepLottery.ELEVEN) >= newStep);\r\n        require(getCountTickets(currentRound) == 0);\r\n        stepLottery = StepLottery(newStep);\r\n        initCanBuyTicket();\r\n    }\r\n\r\n    function getStepLottery() public view returns (uint currentStep) {\r\n        currentStep = uint(stepLottery);\r\n    }\r\n\r\n    function initCanBuyTicket() internal {\r\n        uint currentStepLottery = getStepLottery();\r\n        canBuyTickets = step[currentStepLottery];\r\n        priceOfToken = priceTicket[currentStepLottery];\r\n        amountPrize = prizePool[currentStepLottery];\r\n    }\r\n\r\n    function getTicketInfo(uint round, uint index) public view returns (address payable wallet, bool isWinner, uint numberTicket) {\r\n        (wallet, isWinner, numberTicket) =  m_tickets.ticketInfo(round, index);\r\n    }\r\n\r\n    function balanceETH() external view returns(uint) {\r\n        return address(this).balance;\r\n    }\r\n\r\n    function refundEth(address payable _player, uint _value) internal returns (bool) {\r\n        require(_player.notZero());\r\n        _player.transfer(_value);\r\n        emit LogRefundEth(_player, _value);\r\n    }\r\n\r\n    function getBalancePlayer(uint round, address wallet) external view returns (uint) {\r\n        return m_tickets.getBalancePlayer(round, wallet);\r\n    }\r\n\r\n    function getBalanceWinner(address wallet, uint round) external view returns (uint) {\r\n        return m_tickets.getBalanceWinner(wallet, round);\r\n    }\r\n\r\n    function checkWinner(uint round, uint numberTicket) public view returns (bool) {\r\n        return m_tickets.checkWinner(round, numberTicket);\r\n    }\r\n\r\n    function getCurrentDate() public view returns (uint) {\r\n        return now;\r\n    }\r\n\r\n    function getCountTickets(uint round) public view returns (uint countTickets) {\r\n        countTickets = m_tickets.getCountTickets(round);\r\n    }\r\n\r\n    function setAdministrationWallet(address payable _newWallet) external onlyOwner {\r\n        require(_newWallet != address(0));\r\n        address payable _oldWallet = administrationWallet;\r\n        administrationWallet = _newWallet;\r\n        emit ChangeAddressWallet(msg.sender, _newWallet, _oldWallet);\r\n    }\r\n\r\n    function sendToAdministration() internal {\r\n        require(administrationWallet != address(0), \"address of wallet is 0x0\");\r\n        uint amount = address(this).balance;\r\n\r\n        if (amount > 0) {\r\n            if (administrationWallet.send(amount)) {\r\n                emit SendToAdministrationWallet(amount);\r\n            }\r\n        }\r\n    }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"wallet\",\"type\":\"address\"},{\"name\":\"round\",\"type\":\"uint256\"}],\"name\":\"getBalanceWinner\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newStep\",\"type\":\"uint256\"}],\"name\":\"setStepLottery\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"round\",\"type\":\"uint256\"}],\"name\":\"getCountTickets\",\"outputs\":[{\"name\":\"countTickets\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"priceOfToken\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"round\",\"type\":\"uint256\"},{\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getTicketInfo\",\"outputs\":[{\"name\":\"wallet\",\"type\":\"address\"},{\"name\":\"isWinner\",\"type\":\"bool\"},{\"name\":\"numberTicket\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getStepLottery\",\"outputs\":[{\"name\":\"currentStep\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"uniquePlayer\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentRound\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"round\",\"type\":\"uint256\"},{\"name\":\"numberTicket\",\"type\":\"uint256\"}],\"name\":\"checkWinner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCurrentDate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalTicketBuyed\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addressPlayer\",\"type\":\"address\"}],\"name\":\"buyTicket\",\"outputs\":[{\"name\":\"buyTickets\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newWallet\",\"type\":\"address\"}],\"name\":\"setAdministrationWallet\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalEthRaised\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"administrationWallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"balanceETH\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"round\",\"type\":\"uint256\"},{\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"getBalancePlayer\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_administrationWallet\",\"type\":\"address\"},{\"name\":\"_step\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"when\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"round\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"LogNewTicket\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"when\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"balance\",\"type\":\"uint256\"}],\"name\":\"LogBalanceChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newDate\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"oldDate\",\"type\":\"uint256\"}],\"name\":\"LogChangeTime\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"player\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"LogRefundEth\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"roundLottery\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"wallet\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"happyNumber\",\"type\":\"uint256\"}],\"name\":\"LogWinnerDefine\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newAddress\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"oldAddress\",\"type\":\"address\"}],\"name\":\"ChangeAddressWallet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"balanceContract\",\"type\":\"uint256\"}],\"name\":\"SendToAdministrationWallet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerChanged\",\"type\":\"event\"}]","ContractName":"SundayLottery","CompilerVersion":"v0.5.7+commit.6da8b019","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000fe56ffcb337d5676fd3edb4263e79d3bd90a61a30000000000000000000000000000000000000000000000000000000000000003","Library":"","SwarmSource":"bzzr://5bb78130d7e25ef82c3cd4eb42b732ce4853def59be7ba45916be6b3e1f89de5"}]}