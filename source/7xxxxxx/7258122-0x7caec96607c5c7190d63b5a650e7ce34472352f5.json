{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.25;\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, reverts on overflow.\r\n  */\r\n  function mul(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (_a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    uint256 c = _a * _b;\r\n    require(c / _a == _b);\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\r\n  */\r\n  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    require(_b > 0); // Solidity only automatically asserts when dividing by 0\r\n    uint256 c = _a / _b;\r\n    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    require(_b <= _a);\r\n    uint256 c = _a - _b;\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, reverts on overflow.\r\n  */\r\n  function add(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    uint256 c = _a + _b;\r\n    require(c >= _a);\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\r\n  * reverts when dividing by zero.\r\n  */\r\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b != 0);\r\n    return a % b;\r\n  }\r\n}\r\n\r\ncontract DSMath {\r\n    function add(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x + y) >= x, \"ds-math-add-overflow\");\r\n    }\r\n    function sub(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x - y) <= x, \"ds-math-sub-underflow\");\r\n    }\r\n    function mul(uint x, uint y) internal pure returns (uint z) {\r\n        require(y == 0 || (z = x * y) / y == x, \"ds-math-mul-overflow\");\r\n    }\r\n\r\n    function min(uint x, uint y) internal pure returns (uint z) {\r\n        return x <= y ? x : y;\r\n    }\r\n    function max(uint x, uint y) internal pure returns (uint z) {\r\n        return x >= y ? x : y;\r\n    }\r\n    function imin(int x, int y) internal pure returns (int z) {\r\n        return x <= y ? x : y;\r\n    }\r\n    function imax(int x, int y) internal pure returns (int z) {\r\n        return x >= y ? x : y;\r\n    }\r\n\r\n    uint constant WAD = 10 ** 18;\r\n    uint constant RAY = 10 ** 27;\r\n\r\n    function wmul(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, y), WAD / 2) / WAD;\r\n    }\r\n    function rmul(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, y), RAY / 2) / RAY;\r\n    }\r\n    function wdiv(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, WAD), y / 2) / y;\r\n    }\r\n    function rdiv(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, RAY), y / 2) / y;\r\n    }\r\n\r\n    // This famous algorithm is called \"exponentiation by squaring\"\r\n    // and calculates x^n with x as fixed-point and n as regular unsigned.\r\n    //\r\n    // It's O(log n), instead of O(n) for naive repeated multiplication.\r\n    //\r\n    // These facts are why it works:\r\n    //\r\n    //  If n is even, then x^n = (x^2)^(n/2).\r\n    //  If n is odd,  then x^n = x * x^(n-1),\r\n    //   and applying the equation for even x gives\r\n    //    x^n = x * (x^2)^((n-1) / 2).\r\n    //\r\n    //  Also, EVM division is flooring and\r\n    //    floor[(n-1) / 2] = floor[n / 2].\r\n    //\r\n    function rpow(uint x, uint n) internal pure returns (uint z) {\r\n        z = n % 2 != 0 ? x : RAY;\r\n\r\n        for (n /= 2; n != 0; n /= 2) {\r\n            x = rmul(x, x);\r\n\r\n            if (n % 2 != 0) {\r\n                z = rmul(z, x);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n * Altered from https://github.com/OpenZeppelin/openzeppelin-solidity/blob/a466e76d26c394b1faa6e2797aefe34668566392/contracts/token/ERC20/ERC20.sol\r\n */\r\ninterface ERC20 {\r\n  function totalSupply() public view returns (uint256);\r\n\r\n  function balanceOf(address _who) public view returns (uint256);\r\n\r\n  function allowance(address _owner, address _spender)\r\n    public view returns (uint256);\r\n\r\n  function transfer(address _to, uint256 _value) public returns (bool);\r\n\r\n  function approve(address _spender, uint256 _value) public returns (bool);\r\n\r\n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool);\r\n\r\n  event Transfer(\r\n    address indexed from,\r\n    address indexed to,\r\n    uint256 value\r\n  );\r\n\r\n  event Approval(\r\n    address indexed owner,\r\n    address indexed spender,\r\n    uint256 value\r\n  );\r\n}\r\n\r\n/// @dev Just adds extra functions that we use elsewhere\r\ncontract ERC20WithFields is ERC20 {\r\n    string public symbol;\r\n    string public name;\r\n    uint8 public decimals;\r\n}\r\n\r\n\r\n/**\r\n * @title Standard ERC20 token\r\n *\r\n * @dev Implementation of the basic standard token.\r\n * https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md\r\n * Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\r\n * Rearranged from https://github.com/OpenZeppelin/openzeppelin-solidity/blob/a466e76d26c394b1faa6e2797aefe34668566392/contracts/token/ERC20/StandardToken.sol\r\n */\r\ncontract StandardToken is ERC20 {\r\n    using SafeMath for uint256;\r\n\r\n    mapping (address => uint256) balances;\r\n\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n\r\n    uint256 totalSupply_;\r\n\r\n    /**\r\n     * @dev Total number of tokens in existence\r\n     */\r\n    function totalSupply() public view returns (uint256) {\r\n        return totalSupply_;\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the balance of the specified address.\r\n     * @param _owner The address to query the the balance of.\r\n     * @return An uint256 representing the amount owned by the passed address.\r\n     */\r\n    function balanceOf(address _owner) public view returns (uint256) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    /**\r\n     * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n     * @param _owner address The address which owns the funds.\r\n     * @param _spender address The address which will spend the funds.\r\n     * @return A uint256 specifying the amount of tokens still available for the spender.\r\n     */\r\n    function allowance(\r\n        address _owner,\r\n        address _spender\r\n    )\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n    /**\r\n    * @dev Transfer token for a specified address\r\n    * @param _to The address to transfer to.\r\n    * @param _value The amount to be transferred.\r\n    */\r\n    function transfer(address _to, uint256 _value) public returns (bool) {\r\n        require(_value <= balances[msg.sender]);\r\n        require(_to != address(0));\r\n\r\n        balances[msg.sender] = balances[msg.sender].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n        emit Transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n    * Beware that changing an allowance with this method brings the risk that someone may use both the old\r\n    * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\r\n    * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\r\n    * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n    * @param _spender The address which will spend the funds.\r\n        * @param _value The amount of tokens to be spent.\r\n        */\r\n    function approve(address _spender, uint256 _value) public returns (bool) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        emit Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev Transfer tokens from one address to another\r\n    * @param _from address The address which you want to send tokens from\r\n    * @param _to address The address which you want to transfer to\r\n    * @param _value uint256 the amount of tokens to be transferred\r\n    */\r\n    function transferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _value\r\n    )\r\n        public\r\n        returns (bool)\r\n    {\r\n        require(_value <= balances[_from]);\r\n        require(_value <= allowed[_from][msg.sender]);\r\n        require(_to != address(0));\r\n\r\n        balances[_from] = balances[_from].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n        emit Approval(_from, msg.sender, allowed[_from][msg.sender]);\r\n        emit Transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev Increase the amount of tokens that an owner allowed to a spender.\r\n    * approve should be called when allowed[_spender] == 0. To increment\r\n    * allowed value is better to use this function to avoid 2 calls (and wait until\r\n    * the first transaction is mined)\r\n    * From MonolithDAO Token.sol\r\n    * @param _spender The address which will spend the funds.\r\n    * @param _addedValue The amount of tokens to increase the allowance by.\r\n    */\r\n    function increaseApproval(\r\n        address _spender,\r\n        uint256 _addedValue\r\n    )\r\n        public\r\n        returns (bool)\r\n    {\r\n        allowed[msg.sender][_spender] = (allowed[msg.sender][_spender].add(_addedValue));\r\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Decrease the amount of tokens that an owner allowed to a spender.\r\n     * approve should be called when allowed[_spender] == 0. To decrement\r\n     * allowed value is better to use this function to avoid 2 calls (and wait until\r\n     * the first transaction is mined)\r\n     * From MonolithDAO Token.sol\r\n     * @param _spender The address which will spend the funds.\r\n     * @param _subtractedValue The amount of tokens to decrease the allowance by.\r\n     */\r\n    function decreaseApproval(\r\n        address _spender,\r\n        uint256 _subtractedValue\r\n    )\r\n        public\r\n        returns (bool)\r\n    {\r\n        uint256 oldValue = allowed[msg.sender][_spender];\r\n        if (_subtractedValue >= oldValue) {\r\n            allowed[msg.sender][_spender] = 0;\r\n        } else {\r\n            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\r\n        }\r\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function that mints an amount of the token and assigns it to\r\n    * an account. This encapsulates the modification of balances such that the\r\n    * proper events are emitted.\r\n    * @param _account The account that will receive the created tokens.\r\n    * @param _amount The amount that will be created.\r\n     */\r\n    function _mint(address _account, uint256 _amount) internal {\r\n        require(_account != 0);\r\n        totalSupply_ = totalSupply_.add(_amount);\r\n        balances[_account] = balances[_account].add(_amount);\r\n        emit Transfer(address(0), _account, _amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function that burns an amount of the token of a given\r\n     * account.\r\n     * @param _account The account whose tokens will be burnt.\r\n     * @param _amount The amount that will be burnt.\r\n     */\r\n    function _burn(address _account, uint256 _amount) internal {\r\n        require(_account != 0);\r\n        require(_amount <= balances[_account]);\r\n\r\n        totalSupply_ = totalSupply_.sub(_amount);\r\n        balances[_account] = balances[_account].sub(_amount);\r\n        emit Transfer(_account, address(0), _amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function that burns an amount of the token of a given\r\n     * account, deducting from the sender's allowance for said account. Uses the\r\n     * internal _burn function.\r\n     * @param _account The account whose tokens will be burnt.\r\n     * @param _amount The amount that will be burnt.\r\n     */\r\n    function _burnFrom(address _account, uint256 _amount) internal {\r\n        require(_amount <= allowed[_account][msg.sender]);\r\n        allowed[_account][msg.sender] = allowed[_account][msg.sender].sub(_amount);\r\n        emit Approval(_account, msg.sender, allowed[_account][msg.sender]);\r\n        _burn(_account, _amount);\r\n    }\r\n}\r\n\r\n\r\ncontract PreminedToken is StandardToken {\r\n    string public symbol;\r\n    string public  name;\r\n    uint8 public decimals;\r\n\r\n    constructor(string _symbol, uint8 _decimals, string _name) public {\r\n        symbol = _symbol;\r\n        decimals = _decimals;\r\n        name = _name;\r\n        totalSupply_ = 1000000 * 10**uint(decimals);\r\n        balances[msg.sender] = totalSupply_;\r\n        emit Transfer(address(0), msg.sender, totalSupply_);\r\n    }\r\n}\r\n\r\n\r\n/// @dev Just a wrapper for premined tokens which can actually be burnt\r\ncontract BurnableToken is PreminedToken {\r\n    constructor(string _symbol, uint8 _decimals, string _name)\r\n        public\r\n        PreminedToken(_symbol, _decimals, _name)\r\n    {}\r\n\r\n    function burn(uint _amount) public {\r\n        _burn(msg.sender, _amount);\r\n    }\r\n    \r\n    function burnFrom(address from, uint256 value) public {\r\n        _burnFrom(from, value);\r\n    }\r\n}\r\n\r\n\r\n/// @notice Must return a value for an asset\r\ninterface PriceSourceInterface {\r\n    event PriceUpdate(address[] token, uint[] price);\r\n\r\n    function getQuoteAsset() external view returns (address);\r\n    function getLastUpdate() external view returns (uint);\r\n\r\n    /// @notice Returns false if asset not applicable, or price not recent\r\n    function hasValidPrice(address) public view returns (bool);\r\n    function hasValidPrices(address[]) public view returns (bool);\r\n\r\n    /// @notice Return the last known price, and when it was issued\r\n    function getPrice(address _asset) public view returns (uint price, uint timestamp);\r\n    function getPrices(address[] _assets) public view returns (uint[] prices, uint[] timestamps);\r\n\r\n    /// @notice Get price info, and revert if not valid\r\n    function getPriceInfo(address _asset) view returns (uint price, uint decimals);\r\n    function getInvertedPriceInfo(address ofAsset) view returns (uint price, uint decimals);\r\n\r\n    function getReferencePriceInfo(address _base, address _quote) public view returns (uint referencePrice, uint decimal);\r\n    function getOrderPriceInfo(address sellAsset, address buyAsset, uint sellQuantity, uint buyQuantity) public view returns (uint orderPrice);\r\n    function existsPriceOnAssetPair(address sellAsset, address buyAsset) public view returns (bool isExistent);\r\n    function convertQuantity(\r\n        uint fromAssetQuantity,\r\n        address fromAsset,\r\n        address toAsset\r\n    ) public view returns (uint);\r\n}\r\n\r\n\r\ncontract DSAuthority {\r\n    function canCall(\r\n        address src, address dst, bytes4 sig\r\n    ) public view returns (bool);\r\n}\r\n\r\ncontract DSAuthEvents {\r\n    event LogSetAuthority (address indexed authority);\r\n    event LogSetOwner     (address indexed owner);\r\n}\r\n\r\ncontract DSAuth is DSAuthEvents {\r\n    DSAuthority  public  authority;\r\n    address      public  owner;\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n        emit LogSetOwner(msg.sender);\r\n    }\r\n\r\n    function setOwner(address owner_)\r\n        public\r\n        auth\r\n    {\r\n        owner = owner_;\r\n        emit LogSetOwner(owner);\r\n    }\r\n\r\n    function setAuthority(DSAuthority authority_)\r\n        public\r\n        auth\r\n    {\r\n        authority = authority_;\r\n        emit LogSetAuthority(address(authority));\r\n    }\r\n\r\n    modifier auth {\r\n        require(isAuthorized(msg.sender, msg.sig), \"ds-auth-unauthorized\");\r\n        _;\r\n    }\r\n\r\n    function isAuthorized(address src, bytes4 sig) internal view returns (bool) {\r\n        if (src == address(this)) {\r\n            return true;\r\n        } else if (src == owner) {\r\n            return true;\r\n        } else if (authority == DSAuthority(0)) {\r\n            return false;\r\n        } else {\r\n            return authority.canCall(src, address(this), sig);\r\n        }\r\n    }\r\n}\r\n\r\ncontract DSGuardEvents {\r\n    event LogPermit(\r\n        bytes32 indexed src,\r\n        bytes32 indexed dst,\r\n        bytes32 indexed sig\r\n    );\r\n\r\n    event LogForbid(\r\n        bytes32 indexed src,\r\n        bytes32 indexed dst,\r\n        bytes32 indexed sig\r\n    );\r\n}\r\n\r\ncontract DSGuard is DSAuth, DSAuthority, DSGuardEvents {\r\n    bytes32 constant public ANY = bytes32(uint(-1));\r\n\r\n    mapping (bytes32 => mapping (bytes32 => mapping (bytes32 => bool))) acl;\r\n\r\n    function canCall(\r\n        address src_, address dst_, bytes4 sig\r\n    ) public view returns (bool) {\r\n        bytes32 src = bytes32(bytes20(src_));\r\n        bytes32 dst = bytes32(bytes20(dst_));\r\n\r\n        return acl[src][dst][sig]\r\n            || acl[src][dst][ANY]\r\n            || acl[src][ANY][sig]\r\n            || acl[src][ANY][ANY]\r\n            || acl[ANY][dst][sig]\r\n            || acl[ANY][dst][ANY]\r\n            || acl[ANY][ANY][sig]\r\n            || acl[ANY][ANY][ANY];\r\n    }\r\n\r\n    function permit(bytes32 src, bytes32 dst, bytes32 sig) public auth {\r\n        acl[src][dst][sig] = true;\r\n        emit LogPermit(src, dst, sig);\r\n    }\r\n\r\n    function forbid(bytes32 src, bytes32 dst, bytes32 sig) public auth {\r\n        acl[src][dst][sig] = false;\r\n        emit LogForbid(src, dst, sig);\r\n    }\r\n\r\n    function permit(address src, address dst, bytes32 sig) public {\r\n        permit(bytes32(bytes20(src)), bytes32(bytes20(dst)), sig);\r\n    }\r\n    function forbid(address src, address dst, bytes32 sig) public {\r\n        forbid(bytes32(bytes20(src)), bytes32(bytes20(dst)), sig);\r\n    }\r\n\r\n}\r\n\r\ncontract DSGuardFactory {\r\n    mapping (address => bool)  public  isGuard;\r\n\r\n    function newGuard() public returns (DSGuard guard) {\r\n        guard = new DSGuard();\r\n        guard.setOwner(msg.sender);\r\n        isGuard[address(guard)] = true;\r\n    }\r\n}\r\n\r\n/// @notice Has one Hub\r\ncontract Spoke is DSAuth {\r\n    Hub public hub;\r\n    Hub.Routes public routes;\r\n    bool public initialized;\r\n\r\n    modifier onlyInitialized() {\r\n        require(initialized, \"Component not yet initialized\");\r\n        _;\r\n    }\r\n\r\n    modifier notShutDown() {\r\n        require(!hub.isShutDown(), \"Hub is shut down\");\r\n        _;\r\n    }\r\n\r\n    constructor(address _hub) {\r\n        hub = Hub(_hub);\r\n        setAuthority(hub);\r\n        setOwner(hub); // temporary, to allow initialization\r\n    }\r\n\r\n    function initialize(address[12] _spokes) external auth {\r\n        require(msg.sender == address(hub));\r\n        require(!initialized, \"Already initialized\");\r\n        routes = Hub.Routes(\r\n            _spokes[0],\r\n            _spokes[1],\r\n            _spokes[2],\r\n            _spokes[3],\r\n            _spokes[4],\r\n            _spokes[5],\r\n            _spokes[6],\r\n            _spokes[7],\r\n            _spokes[8],\r\n            _spokes[9],\r\n            _spokes[10],\r\n            _spokes[11]\r\n        );\r\n        initialized = true;\r\n        setOwner(address(0));\r\n    }\r\n\r\n    function engine() public view returns (address) { return routes.engine; }\r\n    function mlnToken() public view returns (address) { return routes.mlnToken; }\r\n    function priceSource() public view returns (address) { return routes.priceSource; }\r\n    function version() public view returns (address) { return routes.version; }\r\n    function registry() public view returns (address) { return routes.registry; }\r\n}\r\n\r\n\r\n/// @notice Router for communication between components\r\n/// @notice Has one or more Spokes\r\ncontract Hub is DSGuard {\r\n\r\n    event FundShutDown();\r\n\r\n    struct Routes {\r\n        address accounting;\r\n        address feeManager;\r\n        address participation;\r\n        address policyManager;\r\n        address shares;\r\n        address trading;\r\n        address vault;\r\n        address priceSource;\r\n        address registry;\r\n        address version;\r\n        address engine;\r\n        address mlnToken;\r\n    }\r\n\r\n    Routes public routes;\r\n    address public manager;\r\n    address public creator;\r\n    string public name;\r\n    bool public isShutDown;\r\n    bool public spokesSet;\r\n    bool public routingSet;\r\n    bool public permissionsSet;\r\n    uint public creationTime;\r\n    mapping (address => bool) public isSpoke;\r\n\r\n    constructor(address _manager, string _name) {\r\n        creator = msg.sender;\r\n        manager = _manager;\r\n        name = _name;\r\n        creationTime = block.timestamp;\r\n    }\r\n\r\n    modifier onlyCreator() {\r\n        require(msg.sender == creator, \"Only creator can do this\");\r\n        _;\r\n    }\r\n\r\n    function shutDownFund() external {\r\n        require(msg.sender == routes.version);\r\n        isShutDown = true;\r\n        emit FundShutDown();\r\n    }\r\n\r\n    function setSpokes(address[12] _spokes) external onlyCreator {\r\n        require(!spokesSet, \"Spokes already set\");\r\n        for (uint i = 0; i < _spokes.length; i++) {\r\n            isSpoke[_spokes[i]] = true;\r\n        }\r\n        routes.accounting = _spokes[0];\r\n        routes.feeManager = _spokes[1];\r\n        routes.participation = _spokes[2];\r\n        routes.policyManager = _spokes[3];\r\n        routes.shares = _spokes[4];\r\n        routes.trading = _spokes[5];\r\n        routes.vault = _spokes[6];\r\n        routes.priceSource = _spokes[7];\r\n        routes.registry = _spokes[8];\r\n        routes.version = _spokes[9];\r\n        routes.engine = _spokes[10];\r\n        routes.mlnToken = _spokes[11];\r\n        spokesSet = true;\r\n    }\r\n\r\n    function setRouting() external onlyCreator {\r\n        require(spokesSet, \"Spokes must be set\");\r\n        require(!routingSet, \"Routing already set\");\r\n        address[12] memory spokes = [\r\n            routes.accounting, routes.feeManager, routes.participation,\r\n            routes.policyManager, routes.shares, routes.trading,\r\n            routes.vault, routes.priceSource, routes.registry,\r\n            routes.version, routes.engine, routes.mlnToken\r\n        ];\r\n        Spoke(routes.accounting).initialize(spokes);\r\n        Spoke(routes.feeManager).initialize(spokes);\r\n        Spoke(routes.participation).initialize(spokes);\r\n        Spoke(routes.policyManager).initialize(spokes);\r\n        Spoke(routes.shares).initialize(spokes);\r\n        Spoke(routes.trading).initialize(spokes);\r\n        Spoke(routes.vault).initialize(spokes);\r\n        routingSet = true;\r\n    }\r\n\r\n    function setPermissions() external onlyCreator {\r\n        require(spokesSet, \"Spokes must be set\");\r\n        require(routingSet, \"Routing must be set\");\r\n        require(!permissionsSet, \"Permissioning already set\");\r\n        permit(routes.participation, routes.vault, bytes4(keccak256('withdraw(address,uint256)')));\r\n        permit(routes.trading, routes.vault, bytes4(keccak256('withdraw(address,uint256)')));\r\n        permit(routes.participation, routes.shares, bytes4(keccak256('createFor(address,uint256)')));\r\n        permit(routes.participation, routes.shares, bytes4(keccak256('destroyFor(address,uint256)')));\r\n        permit(routes.feeManager, routes.shares, bytes4(keccak256('createFor(address,uint256)')));\r\n        permit(routes.participation, routes.accounting, bytes4(keccak256('addAssetToOwnedAssets(address)')));\r\n        permit(routes.trading, routes.accounting, bytes4(keccak256('addAssetToOwnedAssets(address)')));\r\n        permit(routes.trading, routes.accounting, bytes4(keccak256('removeFromOwnedAssets(address)')));\r\n        permit(routes.accounting, routes.feeManager, bytes4(keccak256('rewardAllFees()')));\r\n        permit(manager, routes.policyManager, bytes4(keccak256('register(bytes4,address)')));\r\n        permit(manager, routes.policyManager, bytes4(keccak256('batchRegister(bytes4[],address[])')));\r\n        permit(manager, routes.participation, bytes4(keccak256('enableInvestment(address[])')));\r\n        permit(manager, routes.participation, bytes4(keccak256('disableInvestment(address[])')));\r\n        permissionsSet = true;\r\n    }\r\n\r\n    function vault() external view returns (address) { return routes.vault; }\r\n    function accounting() external view returns (address) { return routes.accounting; }\r\n    function priceSource() external view returns (address) { return routes.priceSource; }\r\n    function participation() external view returns (address) { return routes.participation; }\r\n    function trading() external view returns (address) { return routes.trading; }\r\n    function shares() external view returns (address) { return routes.shares; }\r\n    function registry() external view returns (address) { return routes.registry; }\r\n    function policyManager() external view returns (address) { return routes.policyManager; }\r\n}\r\n\r\n\r\n\r\n\r\ncontract Registry is DSAuth {\r\n\r\n    // EVENTS\r\n    event AssetUpsert (\r\n        address indexed asset,\r\n        string name,\r\n        string symbol,\r\n        uint decimals,\r\n        string url,\r\n        uint reserveMin,\r\n        uint[] standards,\r\n        bytes4[] sigs\r\n    );\r\n\r\n    event ExchangeAdapterUpsert (\r\n        address indexed exchange,\r\n        address indexed adapter,\r\n        bool takesCustody,\r\n        bytes4[] sigs\r\n    );\r\n\r\n    event AssetRemoval (address indexed asset);\r\n    event EfxWrapperRegistryChange(address indexed registry);\r\n    event EngineChange(address indexed engine);\r\n    event ExchangeAdapterRemoval (address indexed exchange);\r\n    event IncentiveChange(uint incentiveAmount);\r\n    event MGMChange(address indexed MGM);\r\n    event MlnTokenChange(address indexed mlnToken);\r\n    event NativeAssetChange(address indexed nativeAsset);\r\n    event PriceSourceChange(address indexed priceSource);\r\n    event VersionRegistration(address indexed version);\r\n\r\n    // TYPES\r\n    struct Asset {\r\n        bool exists;\r\n        string name;\r\n        string symbol;\r\n        uint decimals;\r\n        string url;\r\n        uint reserveMin;\r\n        uint[] standards;\r\n        bytes4[] sigs;\r\n    }\r\n\r\n    struct Exchange {\r\n        bool exists;\r\n        address exchangeAddress;\r\n        bool takesCustody;\r\n        bytes4[] sigs;\r\n    }\r\n\r\n    struct Version {\r\n        bool exists;\r\n        bytes32 name;\r\n    }\r\n\r\n    // CONSTANTS\r\n    uint public constant MAX_REGISTERED_ENTITIES = 20;\r\n    uint public constant MAX_FUND_NAME_BYTES = 66;\r\n\r\n    // FIELDS\r\n    mapping (address => Asset) public assetInformation;\r\n    address[] public registeredAssets;\r\n\r\n    // Mapping from adapter address to exchange Information (Adapters are unique)\r\n    mapping (address => Exchange) public exchangeInformation;\r\n    address[] public registeredExchangeAdapters;\r\n\r\n    mapping (address => Version) public versionInformation;\r\n    address[] public registeredVersions;\r\n\r\n    mapping (address => bool) public isFeeRegistered;\r\n\r\n    mapping (address => address) public fundsToVersions;\r\n    mapping (bytes32 => bool) public versionNameExists;\r\n    mapping (bytes32 => address) public fundNameHashToOwner;\r\n\r\n\r\n    uint public incentive = 10 finney;\r\n    address public priceSource;\r\n    address public mlnToken;\r\n    address public nativeAsset;\r\n    address public engine;\r\n    address public ethfinexWrapperRegistry;\r\n    address public MGM;\r\n\r\n    modifier onlyVersion() {\r\n        require(\r\n            versionInformation[msg.sender].exists,\r\n            \"Only a Version can do this\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    // METHODS\r\n\r\n    constructor(address _postDeployOwner) {\r\n        setOwner(_postDeployOwner);\r\n    }\r\n\r\n    // PUBLIC METHODS\r\n\r\n    /// @notice Whether _name has only valid characters\r\n    function isValidFundName(string _name) public view returns (bool) {\r\n        bytes memory b = bytes(_name);\r\n        if (b.length > MAX_FUND_NAME_BYTES) return false;\r\n        for (uint i; i < b.length; i++){\r\n            bytes1 char = b[i];\r\n            if(\r\n                !(char >= 0x30 && char <= 0x39) && // 9-0\r\n                !(char >= 0x41 && char <= 0x5A) && // A-Z\r\n                !(char >= 0x61 && char <= 0x7A) && // a-z\r\n                !(char == 0x20 || char == 0x2D) && // space, dash\r\n                !(char == 0x2E || char == 0x5F) && // period, underscore\r\n                !(char == 0x2A) // *\r\n            ) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /// @notice Whether _user can use _name for their fund\r\n    function canUseFundName(address _user, string _name) public view returns (bool) {\r\n        bytes32 nameHash = keccak256(_name);\r\n        return (\r\n            isValidFundName(_name) &&\r\n            (\r\n                fundNameHashToOwner[nameHash] == address(0) ||\r\n                fundNameHashToOwner[nameHash] == _user\r\n            )\r\n        );\r\n    }\r\n\r\n    function reserveFundName(address _owner, string _name)\r\n        external\r\n        onlyVersion\r\n    {\r\n        require(canUseFundName(_owner, _name), \"Fund name cannot be used\");\r\n        fundNameHashToOwner[keccak256(_name)] = _owner;\r\n    }\r\n\r\n    function registerFund(address _fund, address _owner, string _name)\r\n        external\r\n        onlyVersion\r\n    {\r\n        require(canUseFundName(_owner, _name), \"Fund name cannot be used\");\r\n        fundsToVersions[_fund] = msg.sender;\r\n    }\r\n\r\n    /// @notice Registers an Asset information entry\r\n    /// @dev Pre: Only registrar owner should be able to register\r\n    /// @dev Post: Address _asset is registered\r\n    /// @param _asset Address of asset to be registered\r\n    /// @param _name Human-readable name of the Asset\r\n    /// @param _symbol Human-readable symbol of the Asset\r\n    /// @param _url Url for extended information of the asset\r\n    /// @param _standards Integers of EIP standards this asset adheres to\r\n    /// @param _sigs Function signatures for whitelisted asset functions\r\n    function registerAsset(\r\n        address _asset,\r\n        string _name,\r\n        string _symbol,\r\n        string _url,\r\n        uint _reserveMin,\r\n        uint[] _standards,\r\n        bytes4[] _sigs\r\n    ) external auth {\r\n        require(registeredAssets.length < MAX_REGISTERED_ENTITIES);\r\n        require(!assetInformation[_asset].exists);\r\n        assetInformation[_asset].exists = true;\r\n        registeredAssets.push(_asset);\r\n        updateAsset(\r\n            _asset,\r\n            _name,\r\n            _symbol,\r\n            _url,\r\n            _reserveMin,\r\n            _standards,\r\n            _sigs\r\n        );\r\n    }\r\n\r\n    /// @notice Register an exchange information entry (A mapping from exchange adapter -> Exchange information)\r\n    /// @dev Adapters are unique so are used as the mapping key. There may be different adapters for same exchange (0x / Ethfinex)\r\n    /// @dev Pre: Only registrar owner should be able to register\r\n    /// @dev Post: Address _exchange is registered\r\n    /// @param _exchange Address of the exchange for the adapter\r\n    /// @param _adapter Address of exchange adapter\r\n    /// @param _takesCustody Whether this exchange takes custody of tokens before trading\r\n    /// @param _sigs Function signatures for whitelisted exchange functions\r\n    function registerExchangeAdapter(\r\n        address _exchange,\r\n        address _adapter,\r\n        bool _takesCustody,\r\n        bytes4[] _sigs\r\n    ) external auth {\r\n        require(!exchangeInformation[_adapter].exists, \"Adapter already exists\");\r\n        exchangeInformation[_adapter].exists = true;\r\n        require(registeredExchangeAdapters.length < MAX_REGISTERED_ENTITIES, \"Exchange limit reached\");\r\n        registeredExchangeAdapters.push(_adapter);\r\n        updateExchangeAdapter(\r\n            _exchange,\r\n            _adapter,\r\n            _takesCustody,\r\n            _sigs\r\n        );\r\n    }\r\n\r\n    /// @notice Versions cannot be removed from registry\r\n    /// @param _version Address of the version contract\r\n    /// @param _name Name of the version\r\n    function registerVersion(\r\n        address _version,\r\n        bytes32 _name\r\n    ) external auth {\r\n        require(!versionInformation[_version].exists, \"Version already exists\");\r\n        require(!versionNameExists[_name], \"Version name already exists\");\r\n        versionInformation[_version].exists = true;\r\n        versionNameExists[_name] = true;\r\n        versionInformation[_version].name = _name;\r\n        registeredVersions.push(_version);\r\n        emit VersionRegistration(_version);\r\n    }\r\n\r\n    function setIncentive(uint _weiAmount) external auth {\r\n        incentive = _weiAmount;\r\n        emit IncentiveChange(_weiAmount);\r\n    }\r\n\r\n    function setPriceSource(address _priceSource) external auth {\r\n        priceSource = _priceSource;\r\n        emit PriceSourceChange(_priceSource);\r\n    }\r\n\r\n    function setMlnToken(address _mlnToken) external auth {\r\n        mlnToken = _mlnToken;\r\n        emit MlnTokenChange(_mlnToken);\r\n    }\r\n\r\n    function setNativeAsset(address _nativeAsset) external auth {\r\n        nativeAsset = _nativeAsset;\r\n        emit NativeAssetChange(_nativeAsset);\r\n    }\r\n\r\n    function setEngine(address _engine) external auth {\r\n        engine = _engine;\r\n        emit EngineChange(_engine);\r\n    }\r\n\r\n    function setMGM(address _MGM) external auth {\r\n        MGM = _MGM;\r\n        emit MGMChange(_MGM);\r\n    }\r\n\r\n    function setEthfinexWrapperRegistry(address _registry) external auth {\r\n        ethfinexWrapperRegistry = _registry;\r\n        emit EfxWrapperRegistryChange(_registry);\r\n    }\r\n\r\n    /// @notice Updates description information of a registered Asset\r\n    /// @dev Pre: Owner can change an existing entry\r\n    /// @dev Post: Changed Name, Symbol, URL and/or IPFSHash\r\n    /// @param _asset Address of the asset to be updated\r\n    /// @param _name Human-readable name of the Asset\r\n    /// @param _symbol Human-readable symbol of the Asset\r\n    /// @param _url Url for extended information of the asset\r\n    function updateAsset(\r\n        address _asset,\r\n        string _name,\r\n        string _symbol,\r\n        string _url,\r\n        uint _reserveMin,\r\n        uint[] _standards,\r\n        bytes4[] _sigs\r\n    ) public auth {\r\n        require(assetInformation[_asset].exists);\r\n        Asset asset = assetInformation[_asset];\r\n        asset.name = _name;\r\n        asset.symbol = _symbol;\r\n        asset.decimals = ERC20WithFields(_asset).decimals();\r\n        asset.url = _url;\r\n        asset.reserveMin = _reserveMin;\r\n        asset.standards = _standards;\r\n        asset.sigs = _sigs;\r\n        emit AssetUpsert(\r\n            _asset,\r\n            _name,\r\n            _symbol,\r\n            asset.decimals,\r\n            _url,\r\n            _reserveMin,\r\n            _standards,\r\n            _sigs\r\n        );\r\n    }\r\n\r\n    function updateExchangeAdapter(\r\n        address _exchange,\r\n        address _adapter,\r\n        bool _takesCustody,\r\n        bytes4[] _sigs\r\n    ) public auth {\r\n        require(exchangeInformation[_adapter].exists, \"Exchange with adapter doesn't exist\");\r\n        Exchange exchange = exchangeInformation[_adapter];\r\n        exchange.exchangeAddress = _exchange;\r\n        exchange.takesCustody = _takesCustody;\r\n        exchange.sigs = _sigs;\r\n        emit ExchangeAdapterUpsert(\r\n            _exchange,\r\n            _adapter,\r\n            _takesCustody,\r\n            _sigs\r\n        );\r\n    }\r\n\r\n    /// @notice Deletes an existing entry\r\n    /// @dev Owner can delete an existing entry\r\n    /// @param _asset address for which specific information is requested\r\n    function removeAsset(\r\n        address _asset,\r\n        uint _assetIndex\r\n    ) external auth {\r\n        require(assetInformation[_asset].exists);\r\n        require(registeredAssets[_assetIndex] == _asset);\r\n        delete assetInformation[_asset];\r\n        delete registeredAssets[_assetIndex];\r\n        for (uint i = _assetIndex; i < registeredAssets.length-1; i++) {\r\n            registeredAssets[i] = registeredAssets[i+1];\r\n        }\r\n        registeredAssets.length--;\r\n        emit AssetRemoval(_asset);\r\n    }\r\n\r\n    /// @notice Deletes an existing entry\r\n    /// @dev Owner can delete an existing entry\r\n    /// @param _adapter address of the adapter of the exchange that is to be removed\r\n    /// @param _adapterIndex index of the exchange in array\r\n    function removeExchangeAdapter(\r\n        address _adapter,\r\n        uint _adapterIndex\r\n    ) external auth {\r\n        require(exchangeInformation[_adapter].exists, \"Exchange with adapter doesn't exist\");\r\n        require(registeredExchangeAdapters[_adapterIndex] == _adapter, \"Incorrect adapter index\");\r\n        delete exchangeInformation[_adapter];\r\n        delete registeredExchangeAdapters[_adapterIndex];\r\n        for (uint i = _adapterIndex; i < registeredExchangeAdapters.length-1; i++) {\r\n            registeredExchangeAdapters[i] = registeredExchangeAdapters[i+1];\r\n        }\r\n        registeredExchangeAdapters.length--;\r\n        emit ExchangeAdapterRemoval(_adapter);\r\n    }\r\n\r\n    function registerFees(address[] _fees) external auth {\r\n        for (uint i; i < _fees.length; i++) {\r\n            isFeeRegistered[_fees[i]] = true;\r\n        }\r\n    }\r\n\r\n    function deregisterFees(address[] _fees) external auth {\r\n        for (uint i; i < _fees.length; i++) {\r\n            delete isFeeRegistered[_fees[i]];\r\n        }\r\n    }\r\n\r\n    // PUBLIC VIEW METHODS\r\n\r\n    // get asset specific information\r\n    function getName(address _asset) external view returns (string) {\r\n        return assetInformation[_asset].name;\r\n    }\r\n    function getSymbol(address _asset) external view returns (string) {\r\n        return assetInformation[_asset].symbol;\r\n    }\r\n    function getDecimals(address _asset) external view returns (uint) {\r\n        return assetInformation[_asset].decimals;\r\n    }\r\n    function getReserveMin(address _asset) external view returns (uint) {\r\n        return assetInformation[_asset].reserveMin;\r\n    }\r\n    function assetIsRegistered(address _asset) external view returns (bool) {\r\n        return assetInformation[_asset].exists;\r\n    }\r\n    function getRegisteredAssets() external view returns (address[]) {\r\n        return registeredAssets;\r\n    }\r\n    function assetMethodIsAllowed(address _asset, bytes4 _sig)\r\n        external\r\n        view\r\n        returns (bool)\r\n    {\r\n        bytes4[] memory signatures = assetInformation[_asset].sigs;\r\n        for (uint i = 0; i < signatures.length; i++) {\r\n            if (signatures[i] == _sig) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    // get exchange-specific information\r\n    function exchangeAdapterIsRegistered(address _adapter) external view returns (bool) {\r\n        return exchangeInformation[_adapter].exists;\r\n    }\r\n    function getRegisteredExchangeAdapters() external view returns (address[]) {\r\n        return registeredExchangeAdapters;\r\n    }\r\n    function getExchangeInformation(address _adapter)\r\n        public\r\n        view\r\n        returns (address, bool)\r\n    {\r\n        Exchange exchange = exchangeInformation[_adapter];\r\n        return (\r\n            exchange.exchangeAddress,\r\n            exchange.takesCustody\r\n        );\r\n    }\r\n    function exchangeForAdapter(address _adapter) external view returns (address) {\r\n        Exchange exchange = exchangeInformation[_adapter];\r\n        return exchange.exchangeAddress;\r\n    }\r\n    function getAdapterFunctionSignatures(address _adapter)\r\n        public\r\n        view\r\n        returns (bytes4[])\r\n    {\r\n        return exchangeInformation[_adapter].sigs;\r\n    }\r\n    function adapterMethodIsAllowed(\r\n        address _adapter, bytes4 _sig\r\n    )\r\n        external\r\n        view\r\n        returns (bool)\r\n    {\r\n        bytes4[] memory signatures = exchangeInformation[_adapter].sigs;\r\n        for (uint i = 0; i < signatures.length; i++) {\r\n            if (signatures[i] == _sig) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    // get version and fund information\r\n    function getRegisteredVersions() external view returns (address[]) {\r\n        return registeredVersions;\r\n    }\r\n\r\n    function isFund(address _who) external view returns (bool) {\r\n        if (fundsToVersions[_who] != address(0)) {\r\n            return true; // directly from a hub\r\n        } else {\r\n            address hub = Hub(Spoke(_who).hub());\r\n            require(\r\n                Hub(hub).isSpoke(_who),\r\n                \"Call from either a spoke or hub\"\r\n            );\r\n            return fundsToVersions[hub] != address(0);\r\n        }\r\n    }\r\n\r\n    function isFundFactory(address _who) external view returns (bool) {\r\n        return versionInformation[_who].exists;\r\n    }\r\n}\r\n\r\n\r\n/// @notice Liquidity contract and token sink\r\ncontract Engine is DSMath {\r\n\r\n    event RegistryChange(address registry);\r\n    event SetAmguPrice(uint amguPrice);\r\n    event AmguPaid(uint amount);\r\n    event Thaw(uint amount);\r\n    event Burn(uint amount);\r\n\r\n    uint public constant MLN_DECIMALS = 18;\r\n\r\n    Registry public registry;\r\n    uint public amguPrice;\r\n    uint public frozenEther;\r\n    uint public liquidEther;\r\n    uint public lastThaw;\r\n    uint public thawingDelay;\r\n    uint public totalEtherConsumed;\r\n    uint public totalAmguConsumed;\r\n    uint public totalMlnBurned;\r\n\r\n    constructor(uint _delay, address _registry) {\r\n        lastThaw = block.timestamp;\r\n        thawingDelay = _delay;\r\n        _setRegistry(_registry);\r\n    }\r\n\r\n    modifier onlyMGM() {\r\n        require(\r\n            msg.sender == registry.MGM(),\r\n            \"Only MGM can call this\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    /// @dev Registry owner is MTC\r\n    modifier onlyMTC() {\r\n        require(\r\n            msg.sender == registry.owner(),\r\n            \"Only MTC can call this\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    function _setRegistry(address _registry) internal {\r\n        registry = Registry(_registry);\r\n        emit RegistryChange(registry);\r\n    }\r\n\r\n    /// @dev only callable by MTC\r\n    function setRegistry(address _registry)\r\n        external\r\n        onlyMTC\r\n    {\r\n        _setRegistry(_registry);\r\n    }\r\n\r\n    /// @dev set price of AMGU in MLN (base units)\r\n    /// @dev only callable by MGM\r\n    function setAmguPrice(uint _price)\r\n        external\r\n        onlyMGM\r\n    {\r\n        amguPrice = _price;\r\n        emit SetAmguPrice(_price);\r\n    }\r\n\r\n    function getAmguPrice() public view returns (uint) { return amguPrice; }\r\n\r\n    function premiumPercent() public view returns (uint) {\r\n        if (liquidEther < 1 ether) {\r\n            return 0;\r\n        } else if (liquidEther >= 1 ether && liquidEther < 5 ether) {\r\n            return 5;\r\n        } else if (liquidEther >= 5 ether && liquidEther < 10 ether) {\r\n            return 10;\r\n        } else if (liquidEther >= 10 ether) {\r\n            return 15;\r\n        }\r\n    }\r\n\r\n    function payAmguInEther() external payable {\r\n        require(\r\n            registry.isFundFactory(msg.sender) ||\r\n            registry.isFund(msg.sender),\r\n            \"Sender must be a fund or the factory\"\r\n        );\r\n        uint mlnPerAmgu = getAmguPrice();\r\n        uint ethPerMln;\r\n        (ethPerMln,) = priceSource().getPrice(address(mlnToken()));\r\n        uint amguConsumed;\r\n        if (mlnPerAmgu > 0 && ethPerMln > 0) {\r\n            amguConsumed = (mul(msg.value, 10 ** uint(MLN_DECIMALS))) / (mul(ethPerMln, mlnPerAmgu));\r\n        } else {\r\n            amguConsumed = 0;\r\n        }\r\n        totalEtherConsumed = add(totalEtherConsumed, msg.value);\r\n        totalAmguConsumed = add(totalAmguConsumed, amguConsumed);\r\n        frozenEther = add(frozenEther, msg.value);\r\n        emit AmguPaid(amguConsumed);\r\n    }\r\n\r\n    /// @notice Move frozen ether to liquid pool after delay\r\n    /// @dev Delay only restarts when this function is called\r\n    function thaw() external {\r\n        require(\r\n            block.timestamp >= add(lastThaw, thawingDelay),\r\n            \"Thawing delay has not passed\"\r\n        );\r\n        require(frozenEther > 0, \"No frozen ether to thaw\");\r\n        lastThaw = block.timestamp;\r\n        liquidEther = add(liquidEther, frozenEther);\r\n        emit Thaw(frozenEther);\r\n        frozenEther = 0;\r\n    }\r\n\r\n    /// @return ETH per MLN including premium\r\n    function enginePrice() public view returns (uint) {\r\n        uint ethPerMln;\r\n        (ethPerMln, ) = priceSource().getPrice(address(mlnToken()));\r\n        uint premium = (mul(ethPerMln, premiumPercent()) / 100);\r\n        return add(ethPerMln, premium);\r\n    }\r\n\r\n    function ethPayoutForMlnAmount(uint mlnAmount) public view returns (uint) {\r\n        return mul(mlnAmount, enginePrice()) / 10 ** uint(MLN_DECIMALS);\r\n    }\r\n\r\n    /// @notice MLN must be approved first\r\n    function sellAndBurnMln(uint mlnAmount) external {\r\n        require(registry.isFund(msg.sender), \"Only funds can use the engine\");\r\n        require(\r\n            mlnToken().transferFrom(msg.sender, address(this), mlnAmount),\r\n            \"MLN transferFrom failed\"\r\n        );\r\n        uint ethToSend = ethPayoutForMlnAmount(mlnAmount);\r\n        require(ethToSend > 0, \"No ether to pay out\");\r\n        require(liquidEther >= ethToSend, \"Not enough liquid ether to send\");\r\n        liquidEther = sub(liquidEther, ethToSend);\r\n        totalMlnBurned = add(totalMlnBurned, mlnAmount);\r\n        msg.sender.transfer(ethToSend);\r\n        mlnToken().burn(mlnAmount);\r\n        emit Burn(mlnAmount);\r\n    }\r\n\r\n    /// @dev Get MLN from the registry\r\n    function mlnToken()\r\n        public\r\n        view\r\n        returns (BurnableToken)\r\n    {\r\n        return BurnableToken(registry.mlnToken());\r\n    }\r\n\r\n    /// @dev Get PriceSource from the registry\r\n    function priceSource()\r\n        public\r\n        view\r\n        returns (PriceSourceInterface)\r\n    {\r\n        return PriceSourceInterface(registry.priceSource());\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"priceSource\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalEtherConsumed\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalAmguConsumed\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"thaw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"payAmguInEther\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAmguPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalMlnBurned\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"registry\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"mlnAmount\",\"type\":\"uint256\"}],\"name\":\"ethPayoutForMlnAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"liquidEther\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"frozenEther\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"mlnToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MLN_DECIMALS\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"mlnAmount\",\"type\":\"uint256\"}],\"name\":\"sellAndBurnMln\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_registry\",\"type\":\"address\"}],\"name\":\"setRegistry\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastThaw\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"premiumPercent\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"amguPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"enginePrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_price\",\"type\":\"uint256\"}],\"name\":\"setAmguPrice\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"thawingDelay\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_delay\",\"type\":\"uint256\"},{\"name\":\"_registry\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"registry\",\"type\":\"address\"}],\"name\":\"RegistryChange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"amguPrice\",\"type\":\"uint256\"}],\"name\":\"SetAmguPrice\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"AmguPaid\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Thaw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Burn\",\"type\":\"event\"}]","ContractName":"Engine","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000000000000000000000000000000000000000278d000000000000000000000000001bfd21f7db126a5966d2c09492676807a68859ba","Library":"","SwarmSource":"bzzr://86e23a025da3dbfd60ddcbc7cd11bc0f4d67c99a0f9d119e4877aba3a45f1154"}]}