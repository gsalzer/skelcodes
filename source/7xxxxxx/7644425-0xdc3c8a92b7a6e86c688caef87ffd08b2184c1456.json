{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.5.0;\r\n\r\ncontract OwnedI {\r\n    function getOwner() public view returns(address owner);\r\n    function changeOwner(address newOwner) public returns (bool success);\r\n}\r\n\r\ncontract Owned is OwnedI {\r\n\r\n    address private contractOwner;\r\n\r\n    event LogOwnerChanged(\r\n        address oldOwner,\r\n        address newOwner);\r\n\r\n    modifier onlyOwner {\r\n        require(msg.sender == contractOwner, \"Owned:sender should be owner\");\r\n        _;\r\n    }\r\n\r\n    constructor() public {\r\n        contractOwner = msg.sender;\r\n    }\r\n\r\n    function getOwner() public view returns(address owner) {\r\n        return contractOwner;\r\n    }\r\n\r\n    function changeOwner(address newOwner)\r\n        public\r\n        onlyOwner\r\n        returns(bool success)\r\n    {\r\n        require(newOwner != address(0), \"Owned:invalid address\");\r\n        emit LogOwnerChanged(contractOwner, newOwner);\r\n        contractOwner = newOwner;\r\n        return true;\r\n    }\r\n\r\n}\r\n\r\n\r\ncontract SolidifiedDepositableFactoryI {\r\n  function deployDepositableContract(address _userAddress, address _mainHub)\r\n   public\r\n   returns(address depositable);\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n  function mul(uint256 a, uint256 b) internal view returns (uint256) {\r\n    uint256 c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal view returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal view returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal view returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n\r\ncontract DeployerI {\r\n\r\n    mapping(address => uint) public deployedContractPointers;\r\n    address[] public deployedContracts;\r\n\r\n    function getDeployedContractsCount() public view returns(uint count);\r\n    function isDeployedContract(address deployed) public view returns(bool isIndeed);\r\n\r\n}\r\n\r\ncontract Deployer is DeployerI {\r\n\r\n    using SafeMath for uint;\r\n\r\n    mapping(address => uint) public deployedContractPointers;\r\n    address[] public deployedContracts;\r\n\r\n    event LogDeployedContract(address sender, address deployed);\r\n\r\n    modifier onlyDeployed {\r\n        require(isDeployedContract(msg.sender), \"Deployer:sender should be deployed contract\");\r\n        _;\r\n    }\r\n\r\n    function getDeployedContractsCount() public view returns(uint count) {\r\n        return deployedContracts.length;\r\n    }\r\n\r\n    function insertDeployedContract(address deployed) internal returns(bool success) {\r\n        require(!isDeployedContract(deployed), \"Deployer:deployed is already inserted\");\r\n        deployedContractPointers[deployed] = deployedContracts.push(deployed).sub(uint(1));\r\n        emit LogDeployedContract(msg.sender, deployed);\r\n        return true;\r\n    }\r\n\r\n    function isDeployedContract(address deployed) public view returns(bool isIndeed) {\r\n        if(deployedContracts.length == 0) return false;\r\n        return deployedContracts[deployedContractPointers[deployed]] == deployed;\r\n    }\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\n/*\r\nManage a privileged user \"controllerAddress\" which is expected to be a centralized server.\r\n*/\r\n\r\ncontract ControlledI is OwnedI {\r\n\r\n    function getController() public view returns(address controller);\r\n    function changeController(address newController) public returns(bool success);\r\n}\r\n\r\ncontract Controlled is ControlledI, Owned {\r\n\r\n    address private controllerAddress;\r\n\r\n    event LogControllerChanged(\r\n        address sender,\r\n        address oldController,\r\n        address newController);\r\n\r\n    modifier onlyController {\r\n        require(msg.sender == controllerAddress, \"Controlled:Sender is not controller\");\r\n        _;\r\n    }\r\n\r\n    constructor(address controller) public {\r\n        controllerAddress = controller;\r\n        if(controllerAddress == address(0)) controllerAddress = msg.sender;\r\n    }\r\n\r\n    function getController() public view returns(address controller) {\r\n        return controllerAddress;\r\n    }\r\n\r\n    function changeController(address newController)\r\n        public\r\n        onlyOwner\r\n        returns(bool success)\r\n    {\r\n        require(newController != address(0), \"Controlled:Invalid address\");\r\n        require(newController != controllerAddress, \"Controlled:New controller should be different than controller\");\r\n        emit LogControllerChanged(msg.sender, controllerAddress, newController);\r\n        controllerAddress = newController;\r\n        return true;\r\n    }\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\ncontract StoppableI is OwnedI {\r\n    function isRunning() public view returns(bool contractRunning);\r\n    function setRunSwitch(bool onOff) public returns(bool success);\r\n}\r\n\r\ncontract Stoppable is StoppableI, Owned {\r\n    bool private running;\r\n\r\n    modifier onlyIfRunning\r\n    {\r\n        require(running);\r\n        _;\r\n    }\r\n\r\n    event LogSetRunSwitch(address sender, bool isRunning);\r\n\r\n    constructor() public {\r\n        running = true;\r\n    }\r\n\r\n    function isRunning()\r\n        public\r\n        view\r\n        returns(bool contractRunning)\r\n    {\r\n        return running;\r\n    }\r\n\r\n    function setRunSwitch(bool onOff)\r\n        public\r\n        onlyOwner\r\n        returns(bool success)\r\n    {\r\n        emit LogSetRunSwitch(msg.sender, onOff);\r\n        running = onOff;\r\n        return true;\r\n    }\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\n/** @title Solidified Vault\r\n    @author JG Carvalho\r\n **/\r\ncontract SolidifiedVault {\r\n\r\n    /*\r\n     *  Events\r\n     */\r\n    event Confirmation(address indexed sender, uint indexed transactionId);\r\n    event Revocation(address indexed sender, uint indexed transactionId);\r\n    event Submission(uint indexed transactionId);\r\n    event Execution(uint indexed transactionId);\r\n    event ExecutionFailure(uint indexed transactionId);\r\n    event Deposit(address indexed sender, uint value);\r\n    event OwnerAddition(address indexed owner);\r\n    event OwnerRemoval(address indexed owner);\r\n    event RequirementChange(uint required);\r\n\r\n    /*\r\n     *  views\r\n     */\r\n    uint constant public MAX_OWNER_COUNT = 3;\r\n\r\n    /*\r\n     *  Storage\r\n     */\r\n    mapping (uint => Transaction) public transactions;\r\n    mapping (uint => mapping (address => bool)) public confirmations;\r\n    mapping (address => bool) public isOwner;\r\n    address[] public owners;\r\n    uint public required;\r\n    uint public transactionCount;\r\n\r\n    struct Transaction {\r\n        address destination;\r\n        uint value;\r\n        bool executed;\r\n    }\r\n\r\n    /*\r\n     *  Modifiers\r\n     */\r\n    modifier onlyWallet() {\r\n        require(msg.sender == address(this), \"Vault: sender should be wallet\");\r\n        _;\r\n    }\r\n\r\n    modifier ownerDoesNotExist(address owner) {\r\n        require(!isOwner[owner], \"Vault:sender shouldn't be owner\");\r\n        _;\r\n    }\r\n\r\n    modifier ownerExists(address owner) {\r\n        require(isOwner[owner], \"Vault:sender should be owner\");\r\n        _;\r\n    }\r\n\r\n    modifier transactionExists(uint transactionId) {\r\n        require(transactions[transactionId].destination != address(0),\"Vault:transaction should exist\");\r\n        _;\r\n    }\r\n\r\n    modifier confirmed(uint transactionId, address owner) {\r\n        require(confirmations[transactionId][owner], \"Vault:transaction should be confirmed\");\r\n        _;\r\n    }\r\n\r\n    modifier notConfirmed(uint transactionId, address owner) {\r\n        require(!confirmations[transactionId][owner], \"Vault:transaction is already confirmed\");\r\n        _;\r\n    }\r\n\r\n    modifier notExecuted(uint transactionId) {\r\n        require(!transactions[transactionId].executed, \"Vault:transaction has already executed\");\r\n        _;\r\n    }\r\n\r\n    modifier notNull(address _address) {\r\n        require(_address != address(0), \"Vault:address shouldn't be null\");\r\n        _;\r\n    }\r\n\r\n    modifier validRequirement(uint ownerCount, uint _required) {\r\n        require(ownerCount <= MAX_OWNER_COUNT\r\n            && _required <= ownerCount\r\n            && _required != 0\r\n            && ownerCount != 0, \"Vault:invalid requirement\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n      @dev Fallback function allows to deposit ether.\r\n    **/\r\n    function()\r\n        external\r\n        payable\r\n    {\r\n        if (msg.value > 0)\r\n            emit Deposit(msg.sender, msg.value);\r\n    }\r\n\r\n    /*\r\n     * Public functions\r\n     */\r\n     /**\r\n     @dev Contract constructor sets initial owners and required number of confirmations.\r\n     @param _owners List of initial owners.\r\n     @param _required Number of required confirmations.\r\n     **/\r\n    constructor(address[] memory _owners, uint _required)\r\n        public\r\n        validRequirement(_owners.length, _required)\r\n    {\r\n        for (uint i=0; i<_owners.length; i++) {\r\n            require(!isOwner[_owners[i]] && _owners[i] != address(0), \"Vault:Invalid owner\");\r\n            isOwner[_owners[i]] = true;\r\n        }\r\n        owners = _owners;\r\n        required = _required;\r\n    }\r\n\r\n\r\n    /// @dev Allows an owner to submit and confirm a transaction.\r\n    /// @param destination Transaction target address.\r\n    /// @param value Transaction ether value.\r\n    /// @return Returns transaction ID.\r\n    function submitTransaction(address destination, uint value)\r\n        public\r\n        returns (uint transactionId)\r\n    {\r\n        transactionId = addTransaction(destination, value);\r\n        confirmTransaction(transactionId);\r\n    }\r\n\r\n    /// @dev Allows an owner to confirm a transaction.\r\n    /// @param transactionId Transaction ID.\r\n    function confirmTransaction(uint transactionId)\r\n        public\r\n        ownerExists(msg.sender)\r\n        transactionExists(transactionId)\r\n        notConfirmed(transactionId, msg.sender)\r\n    {\r\n        confirmations[transactionId][msg.sender] = true;\r\n        emit Confirmation(msg.sender, transactionId);\r\n        executeTransaction(transactionId);\r\n    }\r\n\r\n    /// @dev Allows an owner to revoke a confirmation for a transaction.\r\n    /// @param transactionId Transaction ID.\r\n    function revokeConfirmation(uint transactionId)\r\n        public\r\n        ownerExists(msg.sender)\r\n        confirmed(transactionId, msg.sender)\r\n        notExecuted(transactionId)\r\n    {\r\n        confirmations[transactionId][msg.sender] = false;\r\n        emit Revocation(msg.sender, transactionId);\r\n    }\r\n\r\n    /// @dev Allows anyone to execute a confirmed transaction.\r\n    /// @param transactionId Transaction ID.\r\n    function executeTransaction(uint transactionId)\r\n        public\r\n        ownerExists(msg.sender)\r\n        confirmed(transactionId, msg.sender)\r\n        notExecuted(transactionId)\r\n    {\r\n        if (isConfirmed(transactionId)) {\r\n            Transaction storage txn = transactions[transactionId];\r\n            txn.executed = true;\r\n            (bool exec, bytes memory _) = txn.destination.call.value(txn.value)(\"\");\r\n            if (exec)\r\n                emit Execution(transactionId);\r\n            else {\r\n                emit ExecutionFailure(transactionId);\r\n                txn.executed = false;\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @dev Returns the confirmation status of a transaction.\r\n    /// @param transactionId Transaction ID.\r\n    /// @return Confirmation status.\r\n    function isConfirmed(uint transactionId)\r\n        public\r\n        view\r\n        returns (bool)\r\n    {\r\n        uint count = 0;\r\n        for (uint i=0; i<owners.length; i++) {\r\n            if (confirmations[transactionId][owners[i]])\r\n                count += 1;\r\n            if (count == required)\r\n                return true;\r\n        }\r\n    }\r\n\r\n    /*\r\n     * Internal functions\r\n     */\r\n    /// @dev Adds a new transaction to the transaction mapping, if transaction does not exist yet.\r\n    /// @param destination Transaction target address.\r\n    /// @param value Transaction ether value.\r\n    /// @return Returns transaction ID.\r\n    function addTransaction(address destination, uint value)\r\n        internal\r\n        notNull(destination)\r\n        returns (uint transactionId)\r\n    {\r\n        transactionId = transactionCount;\r\n        transactions[transactionId] = Transaction({\r\n            destination: destination,\r\n            value: value,\r\n            executed: false\r\n        });\r\n        transactionCount += 1;\r\n        emit Submission(transactionId);\r\n    }\r\n\r\n    /*\r\n     * Web3 call functions\r\n     */\r\n    /// @dev Returns number of confirmations of a transaction.\r\n    /// @param transactionId Transaction ID.\r\n    /// @return Number of confirmations.\r\n    function getConfirmationCount(uint transactionId)\r\n        public\r\n        view\r\n        returns (uint count)\r\n    {\r\n        for (uint i=0; i<owners.length; i++)\r\n            if (confirmations[transactionId][owners[i]])\r\n                count += 1;\r\n    }\r\n\r\n    /// @dev Returns total number of transactions after filers are applied.\r\n    /// @param pending Include pending transactions.\r\n    /// @param executed Include executed transactions.\r\n    /// @return Total number of transactions after filters are applied.\r\n    function getTransactionCount(bool pending, bool executed)\r\n        public\r\n        view\r\n        returns (uint count)\r\n    {\r\n        for (uint i=0; i<transactionCount; i++)\r\n            if (   pending && !transactions[i].executed\r\n                || executed && transactions[i].executed)\r\n                count += 1;\r\n    }\r\n\r\n    /// @dev Returns list of owners.\r\n    /// @return List of owner addresses.\r\n    function getOwners()\r\n        public\r\n        view\r\n        returns (address[] memory)\r\n    {\r\n        return owners;\r\n    }\r\n\r\n    /// @dev Returns array with owner addresses, which confirmed transaction.\r\n    /// @param transactionId Transaction ID.\r\n    /// @return Returns array of owner addresses.\r\n    function getConfirmations(uint transactionId)\r\n        public\r\n        view\r\n        returns (address[] memory _confirmations)\r\n    {\r\n        address[] memory confirmationsTemp = new address[](owners.length);\r\n        uint count = 0;\r\n        uint i;\r\n        for (i=0; i<owners.length; i++)\r\n            if (confirmations[transactionId][owners[i]]) {\r\n                confirmationsTemp[count] = owners[i];\r\n                count += 1;\r\n            }\r\n        _confirmations = new address[](count);\r\n        for (i=0; i<count; i++)\r\n            _confirmations[i] = confirmationsTemp[i];\r\n    }\r\n\r\n    /// @dev Returns list of transaction IDs in defined range.\r\n    /// @param from Index start position of transaction array.\r\n    /// @param to Index end position of transaction array.\r\n    /// @param pending Include pending transactions.\r\n    /// @param executed Include executed transactions.\r\n    /// @return Returns array of transaction IDs.\r\n    function getTransactionIds(uint from, uint to, bool pending, bool executed)\r\n        public\r\n        view\r\n        returns (uint[] memory _transactionIds)\r\n    {\r\n        uint[] memory transactionIdsTemp = new uint[](transactionCount);\r\n        uint count = 0;\r\n        uint i;\r\n        for (i=0; i<transactionCount; i++)\r\n            if (   pending && !transactions[i].executed\r\n                || executed && transactions[i].executed)\r\n            {\r\n                transactionIdsTemp[count] = i;\r\n                count += 1;\r\n            }\r\n        _transactionIds = new uint[](to - from);\r\n        for (i=from; i<to; i++)\r\n            _transactionIds[i - from] = transactionIdsTemp[i];\r\n    }\r\n}\r\n\r\n\r\ncontract SolidifiedMain is Controlled, Deployer, Stoppable {\r\n\r\n  using SafeMath for uint;\r\n\r\n  // VARIABLES\r\n  address public depositableFactoryAddress;\r\n  address payable public vault;\r\n\r\n  mapping(address => UserStruct) public userStructs;\r\n  mapping(address => address) public depositAddresses; //maps user address to depositAddress\r\n\r\n  struct UserStruct {\r\n    uint balance;\r\n    uint pointer;\r\n  }\r\n  address[] public userList;\r\n\r\n  //EVENTS\r\n  event LogUserDeposit(address user, address depositAddress, uint amount);\r\n  event LogUserCreditCollected(address user, uint amount, bytes32 ref);\r\n  event LogUserCreditDeposit(address user, uint amount, bytes32 ref);\r\n  event LogDepositableDeployed(address user, address depositableAddress, uint id);\r\n  event LogRequestWithdraw(address user, uint amount);\r\n  event LogUserInserted(address user, uint userId);\r\n  event LogVaultAddressChanged(address newAddress, address sender);\r\n  event LogDepositableFactoryAddressChanged(address newAddress, address sender);\r\n\r\n  // CONSTRUCTOR\r\n  /**\r\n  @dev Constructor function\r\n  @param controller address Address of the controller\r\n  @param _depositableFactoryAddress address Address of the depositable factoryAddress\r\n  @param _vault address Address of the vault\r\n  **/\r\n  constructor(address controller,\r\n      address _depositableFactoryAddress,\r\n      address payable _vault)\r\n      public\r\n    Controlled(controller) {\r\n      vault = _vault;\r\n      depositableFactoryAddress = _depositableFactoryAddress;\r\n    }\r\n\r\n  //PUBLIC FUNCTIONS\r\n\r\n  /**\r\n  @dev Allows the contract to receive an deposit for specif user\r\n  @param _userAddress address Address of the user to be deposited\r\n  **/\r\n  function receiveDeposit(address _userAddress)\r\n    payable\r\n    public\r\n    onlyDeployed\r\n    onlyIfRunning\r\n  {\r\n    require(msg.sender == depositAddresses[_userAddress], \"Main:sender should be deposit address\");\r\n    userStructs[_userAddress].balance = userStructs[_userAddress].balance.add(msg.value);\r\n\r\n    vault.transfer(msg.value);\r\n    emit LogUserDeposit(_userAddress, msg.sender, msg.value);\r\n  }\r\n\r\n  /**\r\n  @dev Allows the controller to collect/lock user funds\r\n  @param _userAddress address Adress of the user to collect credit from\r\n  @param amount uint256 Amount to be collected\r\n  @param ref bytes32 Referece for the reason for collection\r\n  **/\r\n  function collectUserCredit(address _userAddress, uint256 amount, bytes32 ref)\r\n    public\r\n    onlyController\r\n    onlyIfRunning\r\n  {\r\n      require(userStructs[_userAddress].balance >= amount, \"Main:user does not have enough balance\");\r\n      userStructs[_userAddress].balance = userStructs[_userAddress].balance.sub(amount);\r\n      emit LogUserCreditCollected(_userAddress, amount, ref);\r\n  }\r\n\r\n  /**\r\n  @dev Allows controller to deposit funds for user\r\n  @param _userAddress address Adress of the user to collect credit from\r\n  @param amount uint256 Amount to be collected\r\n  @param ref bytes32 Referece for the reason for collection\r\n  **/\r\n  function depositUserCredit(address _userAddress, uint256 amount, bytes32 ref)\r\n    public\r\n    onlyController\r\n    onlyIfRunning\r\n  {\r\n      userStructs[_userAddress].balance = userStructs[_userAddress].balance.add(amount);\r\n      emit LogUserCreditDeposit(_userAddress, amount, ref);\r\n  }\r\n\r\n  /**\r\n  @dev Deploys a new depositable contract, which users can send ether to.\r\n  @param _userAddress address Address of the user that will be credited the money\r\n  @return An address of the new depositable address\r\n  **/\r\n  function deployDepositableContract(address _userAddress)\r\n    public\r\n    onlyController\r\n    onlyIfRunning\r\n    returns(address depositable)\r\n  {\r\n      if(!isUser(_userAddress)) require(insertNewUser(_userAddress), \"Main:inserting user has failed\");\r\n      require(depositAddresses[_userAddress] == address(0), \"Main:invalid address\");\r\n      SolidifiedDepositableFactoryI f = SolidifiedDepositableFactoryI(depositableFactoryAddress);\r\n      address d = f.deployDepositableContract(_userAddress, address(this));\r\n\r\n      require(insertDeployedContract(d), \"Main:insert contract failed\");\r\n      require(registerDepositAddress(_userAddress, d), \"Main:contract registration failed\");\r\n\r\n      emit LogDepositableDeployed(_userAddress, d,getDeployedContractsCount());\r\n\r\n      return d;\r\n  }\r\n\r\n  /**\r\n  @dev Request a eth withdraw in the vault for specif user\r\n  @param _userAddress address Adress of the user to withdraw\r\n  @param amount uint256 Amount to be withdrawn\r\n  **/\r\n  function requestWithdraw(address _userAddress, uint amount)\r\n    public\r\n    onlyController\r\n    onlyIfRunning\r\n  {\r\n    require(userStructs[_userAddress].balance >= amount,\"Main:user does not have enough balance\");\r\n    userStructs[_userAddress].balance = userStructs[_userAddress].balance.sub(amount);\r\n    (bool success, bytes memory _) = vault.call(abi.encodeWithSignature(\"submitTransaction(address,uint256)\",_userAddress,amount));\r\n    require(success, \"Main:low level call failed\");\r\n\r\n    emit LogRequestWithdraw(_userAddress, amount);\r\n  }\r\n\r\n  /**\r\n  @dev Register a deposit address for a specif user, so all Eth deposited in that\r\n  address will be credited only to the user.\r\n  @param _userAddress address Address of the user\r\n  @param _depositAddress address Address of the depositable contract\r\n  **/\r\n  function registerDepositAddress(address _userAddress, address _depositAddress)\r\n    public\r\n    onlyController\r\n    onlyIfRunning\r\n    returns(bool success)\r\n  {\r\n    depositAddresses[_userAddress] = _depositAddress;\r\n    return true;\r\n  }\r\n\r\n  /**\r\n  @dev Allows to disconnect an user address from a deposit address\r\n  @param _userAddress address Address of the user\r\n  **/\r\n  function deregisterUserDepositAddress(address _userAddress)\r\n    public\r\n    onlyController\r\n    onlyIfRunning\r\n  {\r\n    depositAddresses[_userAddress] = address(0);\r\n  }\r\n\r\n  /**\r\n  @dev Allows to register a new user into the system\r\n  @param user address Address of the user\r\n  **/\r\n  function insertNewUser(address user)\r\n    public\r\n    onlyController\r\n    onlyIfRunning\r\n    returns(bool success)\r\n  {\r\n    require(!isUser(user), \"Main:address is already user\");\r\n    userStructs[user].pointer = userList.push(user).sub(uint(1));\r\n    emit LogUserInserted(user, userStructs[user].pointer);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n  @dev Change the vault address\r\n  @param _newVault address Address of the new vault\r\n  **/\r\n  function changeVaultAddress(address payable _newVault)\r\n    public\r\n    onlyOwner\r\n    onlyIfRunning\r\n  {\r\n    require(_newVault != address(0),\"Main:invalid address\");\r\n    vault = _newVault;\r\n    emit LogVaultAddressChanged(_newVault, msg.sender);\r\n  }\r\n\r\n  /**\r\n  @dev Change depositable factory address\r\n  @param _newAddress address Address of the new depositable factory\r\n  **/\r\n  function changeDespositableFactoryAddress(address _newAddress)\r\n    public\r\n    onlyController\r\n    onlyIfRunning\r\n  {\r\n    require(_newAddress != address(0),\"Main:invalid address\");\r\n    depositableFactoryAddress = _newAddress;\r\n\r\n    emit LogDepositableFactoryAddressChanged(_newAddress, msg.sender);\r\n  }\r\n\r\n  /**\r\n  @dev Check if an address is a registered user\r\n  @param user address Address of the user\r\n  @return true if address is user\r\n  **/\r\n  function isUser(address user) public view returns(bool isIndeed) {\r\n      if(userList.length ==0) return false;\r\n      return(userList[userStructs[user].pointer] == user);\r\n  }\r\n\r\n  /**\r\n  @dev Checks the depositable Factory address of a specif user\r\n  @return The depositable factory address\r\n  **/\r\n  function getDepositableFactoryAddress()\r\n    public\r\n    view\r\n    returns(address factoryAddress)\r\n  {\r\n    return depositableFactoryAddress;\r\n  }\r\n\r\n  /**\r\n  @dev Getter for the vault address\r\n  @return The address of the vault\r\n  **/\r\n  function getVaultAddress()\r\n    public\r\n    view\r\n    returns(address vaultAddress)\r\n  {\r\n    return vault;\r\n  }\r\n\r\n  /**\r\n  @dev Checks the depositable Factory address of a specif user\r\n  @param _userAddress address Address of the user\r\n  @return The depositable address of the user.\r\n  **/\r\n  function getDepositAddressForUser(address _userAddress)\r\n    public\r\n    view\r\n    returns(address depositAddress)\r\n  {\r\n    return depositAddresses[_userAddress];\r\n  }\r\n\r\n  /**\r\n  @dev Checks the balance of specif user\r\n  @param _userAddress address Address of the user\r\n  @return uint representing the balance\r\n  **/\r\n  function getUserBalance(address _userAddress)\r\n    public\r\n    view\r\n    returns(uint256 balance)\r\n  {\r\n    return userStructs[_userAddress].balance;\r\n  }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"userStructs\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"},{\"name\":\"pointer\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isRunning\",\"outputs\":[{\"name\":\"contractRunning\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_userAddress\",\"type\":\"address\"}],\"name\":\"deregisterUserDepositAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newAddress\",\"type\":\"address\"}],\"name\":\"changeDespositableFactoryAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getController\",\"outputs\":[{\"name\":\"controller\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_userAddress\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"requestWithdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newController\",\"type\":\"address\"}],\"name\":\"changeController\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"user\",\"type\":\"address\"}],\"name\":\"isUser\",\"outputs\":[{\"name\":\"isIndeed\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_userAddress\",\"type\":\"address\"}],\"name\":\"receiveDeposit\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_userAddress\",\"type\":\"address\"}],\"name\":\"getUserBalance\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getDeployedContractsCount\",\"outputs\":[{\"name\":\"count\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_userAddress\",\"type\":\"address\"}],\"name\":\"getDepositAddressForUser\",\"outputs\":[{\"name\":\"depositAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"deployed\",\"type\":\"address\"}],\"name\":\"isDeployedContract\",\"outputs\":[{\"name\":\"isIndeed\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getVaultAddress\",\"outputs\":[{\"name\":\"vaultAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_userAddress\",\"type\":\"address\"}],\"name\":\"deployDepositableContract\",\"outputs\":[{\"name\":\"depositable\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getOwner\",\"outputs\":[{\"name\":\"owner\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_userAddress\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"ref\",\"type\":\"bytes32\"}],\"name\":\"depositUserCredit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_userAddress\",\"type\":\"address\"},{\"name\":\"_depositAddress\",\"type\":\"address\"}],\"name\":\"registerDepositAddress\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"deployedContracts\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"userList\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"depositAddresses\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newVault\",\"type\":\"address\"}],\"name\":\"changeVaultAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"depositableFactoryAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_userAddress\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"ref\",\"type\":\"bytes32\"}],\"name\":\"collectUserCredit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getDepositableFactoryAddress\",\"outputs\":[{\"name\":\"factoryAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"onOff\",\"type\":\"bool\"}],\"name\":\"setRunSwitch\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"vault\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"user\",\"type\":\"address\"}],\"name\":\"insertNewUser\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"deployedContractPointers\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"controller\",\"type\":\"address\"},{\"name\":\"_depositableFactoryAddress\",\"type\":\"address\"},{\"name\":\"_vault\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"depositAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"LogUserDeposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"ref\",\"type\":\"bytes32\"}],\"name\":\"LogUserCreditCollected\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"ref\",\"type\":\"bytes32\"}],\"name\":\"LogUserCreditDeposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"depositableAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"LogDepositableDeployed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"LogRequestWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"userId\",\"type\":\"uint256\"}],\"name\":\"LogUserInserted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"LogVaultAddressChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"LogDepositableFactoryAddressChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"isRunning\",\"type\":\"bool\"}],\"name\":\"LogSetRunSwitch\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"deployed\",\"type\":\"address\"}],\"name\":\"LogDeployedContract\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"oldController\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newController\",\"type\":\"address\"}],\"name\":\"LogControllerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"LogOwnerChanged\",\"type\":\"event\"}]","ContractName":"SolidifiedMain","CompilerVersion":"v0.5.0+commit.1d4f565a","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"0000000000000000000000001096f5efabb3af0a796a305611e890f9f0fbcc87000000000000000000000000960caf296e593e9d9b204a7ad29e933e9be3e119000000000000000000000000b4d62dbbd72ed93dfd7af468bae0966d51c60bb4","Library":"","SwarmSource":"bzzr://849b3434e3b04767d3904008cd5e235cc3fd4ab6587f185fc64b2c8b3e22c1c4"}]}