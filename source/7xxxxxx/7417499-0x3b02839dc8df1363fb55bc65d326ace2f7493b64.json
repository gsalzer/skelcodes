{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.0;\r\n\r\nlibrary Math {\r\n    /**\r\n    * @dev Returns the largest of two numbers.\r\n    */\r\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a >= b ? a : b;\r\n    }\r\n\r\n    /**\r\n    * @dev Returns the smallest of two numbers.\r\n    */\r\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n    /**\r\n    * @dev Calculates the average of two numbers. Since these are integers,\r\n    * averages of an even and odd number cannot be represented, and will be\r\n    * rounded down.\r\n    */\r\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // (a + b) / 2 can overflow, so we distribute\r\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\r\n    }\r\n}\r\n\r\nlibrary SafeMath {\r\n    /**\r\n    * @dev Multiplies two unsigned integers, reverts on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two unsigned integers, reverts on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\r\n    * reverts when dividing by zero.\r\n    */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}\r\n\r\ninterface IERC20 {\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n\r\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address who) external view returns (uint256);\r\n\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\nlibrary SafeERC20 {\r\n    using SafeMath for uint256;\r\n\r\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\r\n        require(token.transfer(to, value));\r\n    }\r\n\r\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\r\n        require(token.transferFrom(from, to, value));\r\n    }\r\n\r\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\r\n        // safeApprove should only be called when setting an initial allowance,\r\n        // or when resetting it to zero. To increase and decrease it, use\r\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\r\n        require((value == 0) || (token.allowance(address(this), spender) == 0));\r\n        require(token.approve(spender, value));\r\n    }\r\n\r\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\r\n        require(token.approve(spender, newAllowance));\r\n    }\r\n\r\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value);\r\n        require(token.approve(spender, newAllowance));\r\n    }\r\n}\r\n\r\ninterface IBNB {\r\n    function balanceOf(address who) external view returns (uint256);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function transfer(address to, uint256 value) external;\r\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\r\n}\r\n\r\ncontract TestR {\r\n    using Math for uint256;\r\n    using SafeMath for uint256;\r\n    using SafeERC20 for IERC20;\r\n\r\n    // Total Test (700 million).\r\n    uint256 constant public TOTAL_Test = 7*10**26;\r\n\r\n    // BNB soft goal (200,000 BNB).\r\n    uint256 constant public BNB_SOFT_GOAL = 2*10**23;\r\n\r\n    // Max batch number;\r\n    uint256 constant public MAX_BATCH_NUMBER = 1000;\r\n\r\n    IERC20 public testToken;         // Test token.\r\n    IBNB public bnbToken;         // BNB token.\r\n    uint256 public startBlock;\r\n    uint256 public endBlock;\r\n    address public owner;\r\n    uint256 public currentBNB;\r\n    uint256 public stockOfTest;      // All stock of Test.\r\n    uint256 public batchNumber;     // Exchange batch number.\r\n    uint256 public ramainingStock;  // Ramaining stock of current batch.\r\n    uint256 public totalStock;      // Total stock of current batch.\r\n\r\n    bool public closed = false;\r\n    bool public goalReached = false;\r\n\r\n    struct Record {\r\n        uint256 bnb;\r\n        uint256 test;\r\n    }\r\n\r\n    mapping (address => Record) public records;\r\n\r\n    /** \r\n     * EVENTS\r\n     */\r\n    event Exchange(address indexed sender, uint256 bnb, uint256 test);\r\n    event Withdrawal(address indexed sender, uint256 bnb, uint256 test);\r\n\r\n    // Initialize the contract\r\n    constructor(address testAddress, address bnbAddress, uint256 start, uint256 end) public {\r\n        testToken = IERC20(testAddress);\r\n        bnbToken = IBNB(bnbAddress);\r\n        startBlock = start;\r\n        endBlock = end;\r\n        owner = msg.sender;\r\n        currentBNB = 0;\r\n        stockOfTest = TOTAL_Test;\r\n        batchNumber = 1;\r\n        ramainingStock = 1522108 * 10**18;\r\n        totalStock = 1522108 * 10**18;\r\n    }\r\n\r\n    // Get exchange ratio, 1 BNB to n Test.\r\n    function ratio() public view returns (uint256) {\r\n        (uint256 test,,,) = _calc(10**18, batchNumber, ramainingStock, totalStock);\r\n        return test;\r\n    }\r\n\r\n    // Get exchange ratio with batch number, 1 BNB to n Test.\r\n    function ratio(uint256 bn) public pure returns (uint256) {\r\n        require(bn <= MAX_BATCH_NUMBER, \"The batch number is too large.\");\r\n        uint256 stock = _calcBatchStock(bn);\r\n        (uint256 test,,,) = _calc(10**18, bn, stock, stock);\r\n        return test;\r\n    }\r\n\r\n    // Get batch stock with batch number.\r\n    function batchStock(uint256 bn) public pure returns (uint256) {\r\n        require(bn <= MAX_BATCH_NUMBER, \"The batch number is too large.\");\r\n        return _calcBatchStock(bn);\r\n    }\r\n\r\n    // Exchange BNB for Test\r\n    function exchange() public returns (bool) {\r\n        uint256 bnb = bnbToken\r\n            .balanceOf(msg.sender)\r\n            .min(bnbToken.allowance(msg.sender, address(this)));\r\n        require(bnb > 0, \"Lack of allowance or balance.\");\r\n        require(bnb % 10**18 == 0, \"BNB must be an integer.\");\r\n        require(block.number <= endBlock, \"End of time.\");\r\n        require(batchNumber <= MAX_BATCH_NUMBER, \"Invalid batch number.\");\r\n        require(!closed, \"Resonance closed.\");\r\n\r\n        uint256 test;\r\n        uint256 bn;\r\n        uint256 rs;\r\n        uint256 ts;\r\n        (test, bn, rs, ts) = _calc(bnb, batchNumber, ramainingStock, totalStock);\r\n        require(testToken.balanceOf(address(this)) >= test, \"Lack of Test token.\");\r\n        require(bn <= MAX_BATCH_NUMBER + 1, \"Invalid batch number.\");\r\n\r\n        batchNumber = bn;\r\n        ramainingStock = rs;\r\n        totalStock = ts;\r\n        currentBNB = currentBNB.add(bnb); // Add current BNB.\r\n        stockOfTest = stockOfTest.sub(test);\r\n\r\n        Record storage record = records[msg.sender];\r\n        record.bnb = record.bnb.add(bnb);\r\n        record.test = record.test.add(test);\r\n        records[msg.sender] = record; // Record the exchange.\r\n\r\n        require(bnbToken.transferFrom(msg.sender, address(this), bnb));\r\n        testToken.safeTransfer(msg.sender, test);\r\n\r\n        emit Exchange(msg.sender, bnb, test);\r\n        return true;\r\n    }\r\n\r\n    // Close resonance\r\n    function close() public returns (bool) {\r\n        require(msg.sender == owner, \"Invalid sender.\");\r\n        require(!closed, \"Already closed.\");\r\n\r\n        require(\r\n            block.number > endBlock || batchNumber == MAX_BATCH_NUMBER + 1,\r\n            \"Condition unmet.\"\r\n        );\r\n\r\n        if (currentBNB >= BNB_SOFT_GOAL) {\r\n            goalReached = true;\r\n        }\r\n        closed = true;\r\n\r\n        return true;\r\n    }\r\n\r\n    // Withdraws all BNB and Test.\r\n    function withdraw() public returns (bool) {\r\n        require(closed, \"Is underway.\");\r\n\r\n        if (goalReached) {\r\n            if (msg.sender == owner) {\r\n                uint256 test = testToken.balanceOf(address(this));\r\n                uint256 bnb = bnbToken.balanceOf(address(this));\r\n                require(test > 0 || bnb > 0, \"The balance is empty.\");\r\n\r\n                if (test > 0) testToken.safeTransfer(msg.sender, test);\r\n                if (bnb > 0) bnbToken.transfer(msg.sender, bnb);\r\n                emit Withdrawal(msg.sender, bnb, test);\r\n                return true;\r\n            } else {\r\n                revert(\"Bad withdraw.\");\r\n            }\r\n        } else {\r\n            Record storage record = records[msg.sender];\r\n            require(record.bnb > 0, \"The balance is empty.\");\r\n\r\n            uint256 bnb = record.bnb;\r\n            delete records[msg.sender];\r\n            bnbToken.transfer(msg.sender, bnb);\r\n            emit Withdrawal(msg.sender, bnb, 0);\r\n            return true;\r\n        }\r\n    }\r\n\r\n    function _calc(uint256 bnb, uint256 batchNum, uint256 curBatchRemainingStock, uint256 curBatchTotalStock)\r\n        private\r\n        pure \r\n        returns (uint256, uint256, uint256, uint256) {\r\n        uint256 test = 0;\r\n        uint256 rBNB = bnb;\r\n        uint256 num = batchNum;\r\n        uint256 rBatchStock = curBatchRemainingStock;\r\n        uint256 tBatchStock = curBatchTotalStock;\r\n        uint256 rBatchBNB = curBatchRemainingStock * 70000 * 10**18 / curBatchTotalStock / 100;\r\n\r\n        while (rBNB > 0) {\r\n            if (rBNB == rBatchBNB) {\r\n                test = test.add(rBatchStock);\r\n                rBNB = 0;\r\n                num = num.add(1);\r\n                rBatchStock = _calcBatchStock(num) * 10**18;\r\n                tBatchStock = rBatchStock;\r\n            } else if (rBNB > rBatchBNB) {\r\n                test = test.add(rBatchStock);\r\n                rBNB = rBNB.sub(rBatchBNB);\r\n                num = num.add(1);\r\n                rBatchStock = _calcBatchStock(num) * 10**18;\r\n                tBatchStock = rBatchStock;\r\n                rBatchBNB = 700 * 10**18;\r\n            } else {\r\n                uint256 t = (rBNB * 100 * tBatchStock) / (70000 * 10**18);\r\n                test = test.add(t);\r\n                rBatchStock = rBatchStock.sub(t);\r\n                rBatchBNB = rBatchBNB.sub(rBNB);\r\n                rBNB = 0;\r\n            }\r\n        }\r\n        return (test, num, rBatchStock, tBatchStock);\r\n    }\r\n\r\n    function _calcBatchStock(uint256 n) private pure returns (uint256) {\r\n        uint256 a = 108722;\r\n        uint256 b = 1166736111111111111;\r\n        uint256 c = 70000 * 20;\r\n        if (n == 1) {\r\n            return c * a / 10**5;\r\n        } else {\r\n            uint256 d = 250000 - (n - 1 - 500)**2;\r\n            uint256 e = c - n**2 * b / 10**18;\r\n            return (e * 10 - d * 22) * a / 10 / 10**5;\r\n        }\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"bn\",\"type\":\"uint256\"}],\"name\":\"ratio\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ramainingStock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"endBlock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bnbToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"close\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"records\",\"outputs\":[{\"name\":\"bnb\",\"type\":\"uint256\"},{\"name\":\"test\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startBlock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"closed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"testToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ratio\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"goalReached\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TOTAL_Test\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalStock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_BATCH_NUMBER\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentBNB\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"batchNumber\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"stockOfTest\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"exchange\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"bn\",\"type\":\"uint256\"}],\"name\":\"batchStock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"BNB_SOFT_GOAL\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"testAddress\",\"type\":\"address\"},{\"name\":\"bnbAddress\",\"type\":\"address\"},{\"name\":\"start\",\"type\":\"uint256\"},{\"name\":\"end\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"bnb\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"test\",\"type\":\"uint256\"}],\"name\":\"Exchange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"bnb\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"test\",\"type\":\"uint256\"}],\"name\":\"Withdrawal\",\"type\":\"event\"}]","ContractName":"TestR","CompilerVersion":"v0.5.1+commit.c8a2cb62","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000d12b61989e4652f4af10b0bb400395f18cc90102000000000000000000000000b8c77482e45f1f44de1745f52c74426c631bdd520000000000000000000000000000000000000000000000000000000000712e890000000000000000000000000000000000000000000000000000000000715599","Library":"","SwarmSource":"bzzr://043270834fb91fed269cddf1eb0ed54024a1332e277a83170497ffae5636a2da"}]}