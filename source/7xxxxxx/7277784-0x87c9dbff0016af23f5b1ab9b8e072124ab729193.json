{"status":"1","message":"OK","result":[{"SourceCode":"// File: contracts/library/ERC20.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\ninterface ERC20 {\r\n\r\n    function totalSupply() public view returns (uint);\r\n    function balanceOf(address owner) public view returns (uint);\r\n    function allowance(address owner, address spender) public view returns (uint);\r\n    function transfer(address to, uint value) public returns (bool);\r\n    function transferFrom(address from, address to, uint value) public returns (bool);\r\n    function approve(address spender, uint value) public returns (bool);\r\n\r\n}\r\n\r\n// File: contracts/library/Ownable.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\ncontract Ownable {\r\n\r\n    address public owner;\r\n\r\n    modifier onlyOwner {\r\n        require(isOwner(msg.sender));\r\n        _;\r\n    }\r\n\r\n    function Ownable() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    function transferOwnership(address _newOwner) public onlyOwner {\r\n        owner = _newOwner;\r\n    }\r\n\r\n    function isOwner(address _address) public view returns (bool) {\r\n        return owner == _address;\r\n    }\r\n}\r\n\r\n// File: contracts/library/SafeMath.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\nlibrary SafeMath {\r\n\r\n    function mul(uint a, uint b) internal pure returns (uint) {\r\n        uint c = a * b;\r\n        assert(a == 0 || c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint a, uint b) internal pure returns (uint) {\r\n        assert(b > 0);\r\n        uint c = a / b;\r\n        assert(a == b * c + a % b);\r\n        return c;\r\n    }\r\n\r\n    function sub(uint a, uint b) internal pure returns (uint) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint a, uint b) internal pure returns (uint) {\r\n        uint c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n\r\n    function max64(uint64 a, uint64 b) internal pure returns (uint64) {\r\n        return a >= b ? a : b;\r\n    }\r\n\r\n    function min64(uint64 a, uint64 b) internal pure returns (uint64) {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n    function max256(uint a, uint b) internal pure returns (uint) {\r\n        return a >= b ? a : b;\r\n    }\r\n\r\n    function min256(uint a, uint b) internal pure returns (uint) {\r\n        return a < b ? a : b;\r\n    }\r\n}\r\n\r\n// File: contracts/library/Pausable.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\n/**\r\n * @title Pausable\r\n * @dev Base contract which allows children to implement an emergency stop mechanism.\r\n */\r\ncontract Pausable is Ownable {\r\n  event Pause();\r\n  event Unpause();\r\n\r\n  bool public paused = false;\r\n\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is not paused.\r\n   */\r\n  modifier whenNotPaused() {\r\n    require(!paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is paused.\r\n   */\r\n  modifier whenPaused() {\r\n    require(paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to pause, triggers stopped state\r\n   */\r\n  function pause() onlyOwner whenNotPaused public {\r\n    paused = true;\r\n    emit Pause();\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to unpause, returns to normal state\r\n   */\r\n  function unpause() onlyOwner whenPaused public {\r\n    paused = false;\r\n    emit Unpause();\r\n  }\r\n}\r\n\r\n// File: contracts/library/Whitelist.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\n\r\n/**\r\n * @title Whitelist\r\n * @dev The Whitelist contract has a whitelist of addresses, and provides basic authorization control functions.\r\n * @dev This simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Whitelist is Ownable {\r\n  mapping(address => bool) public whitelist;\r\n\r\n  event WhitelistedAddressAdded(address addr);\r\n  event WhitelistedAddressRemoved(address addr);\r\n\r\n  /**\r\n   * @dev Throws if called by any account that's not whitelisted.\r\n   */\r\n  modifier onlyWhitelisted() {\r\n    require(whitelist[msg.sender]);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev add an address to the whitelist\r\n   * @param addr address\r\n   * @return true if the address was added to the whitelist, false if the address was already in the whitelist\r\n   */\r\n  function addAddressToWhitelist(address addr) onlyOwner public returns(bool success) {\r\n    if (!whitelist[addr]) {\r\n      whitelist[addr] = true;\r\n      emit WhitelistedAddressAdded(addr);\r\n      success = true;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev add addresses to the whitelist\r\n   * @param addrs addresses\r\n   * @return true if at least one address was added to the whitelist,\r\n   * false if all addresses were already in the whitelist\r\n   */\r\n  function addAddressesToWhitelist(address[] addrs) onlyOwner public returns(bool success) {\r\n    for (uint256 i = 0; i < addrs.length; i++) {\r\n      if (addAddressToWhitelist(addrs[i])) {\r\n        success = true;\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev remove an address from the whitelist\r\n   * @param addr address\r\n   * @return true if the address was removed from the whitelist,\r\n   * false if the address wasn't in the whitelist in the first place\r\n   */\r\n  function removeAddressFromWhitelist(address addr) onlyOwner public returns(bool success) {\r\n    if (whitelist[addr]) {\r\n      whitelist[addr] = false;\r\n      emit WhitelistedAddressRemoved(addr);\r\n      success = true;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev remove addresses from the whitelist\r\n   * @param addrs addresses\r\n   * @return true if at least one address was removed from the whitelist,\r\n   * false if all addresses weren't in the whitelist in the first place\r\n   */\r\n  function removeAddressesFromWhitelist(address[] addrs) onlyOwner public returns(bool success) {\r\n    for (uint256 i = 0; i < addrs.length; i++) {\r\n      if (removeAddressFromWhitelist(addrs[i])) {\r\n        success = true;\r\n      }\r\n    }\r\n  }\r\n\r\n}\r\n\r\n// File: contracts/Staking.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title Staking and voting contract.\r\n * @author IoTeX Team\r\n *\r\n */\r\ncontract Staking is Pausable, Whitelist {\r\n    using SafeMath for uint256;\r\n\r\n    // Events to be emitted\r\n    event BucketCreated(uint256 bucketIndex, bytes12 canName, uint256 amount, uint256 stakeDuration, bool nonDecay, bytes data);\r\n    event BucketUpdated(uint256 bucketIndex, bytes12 canName, uint256 stakeDuration, uint256 stakeStartTime, bool nonDecay, address bucketOwner, bytes data);\r\n    event BucketUnstake(uint256 bucketIndex, bytes12 canName, uint256 amount, bytes data);\r\n    event BucketWithdraw(uint256 bucketIndex, bytes12 canName, uint256 amount, bytes data);\r\n    // TODO add change owner event which is not covered by BucketUpdated event\r\n\r\n    // IOTX used for staking\r\n    ERC20 stakingToken;\r\n\r\n    // Unit is epoch\r\n    uint256 public constant minStakeDuration = 0;\r\n    uint256 public constant maxStakeDuration = 350;\r\n    uint256 public constant minStakeAmount = 100 * 10 ** 18;\r\n    uint256 public constant unStakeDuration = 3;\r\n\r\n    uint256 public constant maxBucketsPerAddr = 500;\r\n    uint256 public constant secondsPerEpoch = 86400;\r\n\r\n    // Core data structure to track staking/voting status\r\n    struct Bucket {\r\n        bytes12 canName;            // Candidate name, which maps to public keys by NameRegistration.sol\r\n        uint256 stakedAmount;       // Number of tokens\r\n        uint256 stakeDuration;      // Stake duration, unit: second since epoch\r\n        uint256 stakeStartTime;     // Staking start time, unit: second since epoch\r\n        bool nonDecay;              // Nondecay staking -- staking for N epochs consistently without decaying\r\n        uint256 unstakeStartTime;   // unstake timestamp, unit: second since epoch\r\n        address bucketOwner;        // Owner of this bucket, usually the one who created it but can be someone else\r\n        uint256 createTime;         // bucket firstly create time\r\n        uint256 prev;               // Prev non-zero bucket index\r\n        uint256 next;               // Next non-zero bucket index\r\n    }\r\n    mapping(uint256 => Bucket) public buckets;\r\n    uint256 bucketCount; // number of total buckets. used to track the last used index for the bucket\r\n\r\n    // Map from owner address to array of bucket indexes.\r\n    mapping(address => uint256[]) public stakeholders;\r\n\r\n    /**\r\n     * @dev Modifier that checks that this given bucket can be updated/deleted by msg.sender\r\n     * @param _address address to transfer tokens from\r\n     * @param _bucketIndex uint256 the index of the bucket\r\n     */\r\n    modifier canTouchBucket(address _address, uint256 _bucketIndex) {\r\n        require(_address != address(0));\r\n        require(buckets[_bucketIndex].bucketOwner == msg.sender, \"sender is not the owner.\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier that check if a duration meets requirement\r\n     * @param _duration uint256 duration to check\r\n     */\r\n    modifier checkStakeDuration(uint256 _duration) {\r\n        require(_duration >= minStakeDuration && _duration <= maxStakeDuration, \"The stake duration is too small or large\");\r\n        require(_duration % 7 == 0, \"The stake duration should be multiple of 7\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Constructor function\r\n     * @param _stakingTokenAddr address The address of the token contract used for staking\r\n     */\r\n    constructor(address _stakingTokenAddr) public {\r\n        stakingToken = ERC20(_stakingTokenAddr);\r\n        // create one bucket to initialize the double linked list\r\n        buckets[0] = Bucket(\"\", 1, 0, block.timestamp, true, 0, msg.sender, block.timestamp, 0, 0);\r\n        stakeholders[msg.sender].push(0);\r\n        bucketCount = 1;\r\n    }\r\n\r\n    function getActiveBucketIdxImpl(uint256 _prevIndex, uint256 _limit) internal returns(uint256 count, uint256[] indexes) {\r\n        require (_limit > 0 && _limit < 5000);\r\n        Bucket memory bucket = buckets[_prevIndex];\r\n        require(bucket.next > 0, \"cannot find bucket based on input index.\");\r\n\r\n        indexes = new uint256[](_limit);\r\n        uint256 i = 0;\r\n        for (i = 0; i < _limit; i++) {\r\n            while (bucket.next > 0 && buckets[bucket.next].unstakeStartTime > 0) { // unstaked.\r\n                bucket = buckets[bucket.next]; // skip\r\n            }\r\n            if (bucket.next == 0) { // no new bucket\r\n                break;\r\n            }\r\n            indexes[i] = bucket.next;\r\n            bucket = buckets[bucket.next];\r\n        }\r\n        return (i, indexes);\r\n    }\r\n\r\n    function getActiveBucketIdx(uint256 _prevIndex, uint256 _limit) external view returns(uint256 count, uint256[] indexes) {\r\n        return getActiveBucketIdxImpl(_prevIndex, _limit);\r\n    }\r\n\r\n    /**\r\n     * @dev Get active buckets for a range of indexes\r\n     * @param _prevIndex uint256 the starting index. starting from 0, ending at the last. (putting 0,2 will return 1,2.)\r\n     * @param _limit uint256 the number of non zero buckets to fetch after the start index\r\n     * @return (uint256, uint256[], uint256[], uint256[], uint256[], bytes, address[])\r\n     *  count, index array, stakeStartTime array, duration array, decay array, stakedAmount array, concat stakedFor, ownerAddress array\r\n     */\r\n    function getActiveBuckets(uint256 _prevIndex, uint256 _limit) external view returns(uint256 count,\r\n            uint256[] indexes, uint256[] stakeStartTimes, uint256[] stakeDurations, bool[] decays, uint256[] stakedAmounts, bytes12[] canNames, address[] owners) {\r\n\r\n        (count, indexes) = getActiveBucketIdxImpl(_prevIndex, _limit);\r\n        stakeStartTimes = new uint256[](count);\r\n        stakeDurations = new uint256[](count);\r\n        decays = new bool[](count);\r\n        stakedAmounts = new uint256[](count);\r\n        canNames = new bytes12[](count);\r\n        owners = new address[](count);\r\n\r\n        for (uint256 i = 0; i < count; i++) {\r\n            Bucket memory bucket = buckets[indexes[i]];\r\n            stakeStartTimes[i] = bucket.stakeStartTime;\r\n            stakeDurations[i] = bucket.stakeDuration;\r\n            decays[i] = !bucket.nonDecay;\r\n            stakedAmounts[i] = bucket.stakedAmount;\r\n            canNames[i] = bucket.canName;\r\n            owners[i] = bucket.bucketOwner;\r\n\r\n        }\r\n\r\n        return (count, indexes, stakeStartTimes, stakeDurations, decays, stakedAmounts, canNames, owners);\r\n    }\r\n\r\n\r\n    function getActiveBucketCreateTimes(uint256 _prevIndex, uint256 _limit) external view returns(uint256 count,\r\n            uint256[] indexes, uint256[] createTimes) {\r\n        (count, indexes) = getActiveBucketIdxImpl(_prevIndex, _limit);\r\n        createTimes = new uint256[](count);\r\n        for (uint256 i = 0; i < count; i++) {\r\n            createTimes[i] = buckets[indexes[i]].createTime;\r\n        }\r\n        return (count, indexes, createTimes);\r\n    }\r\n\r\n    /**\r\n     * @dev Get bucket indexes from a given address\r\n     * @param _owner address onwer of the buckets\r\n     * @return (uint256[])\r\n     */\r\n    function getBucketIndexesByAddress(address _owner) external view returns(uint256[]) {\r\n        return stakeholders[_owner];\r\n    }\r\n\r\n    /**\r\n     * @notice Extend the stake to stakeDuration from current time and/or set nonDecay.\r\n     * @notice MUST trigger BucketUpdated event\r\n     * @param _bucketIndex uint256 the index of the bucket\r\n     * @param _stakeDuration uint256 the desired duration of staking.\r\n     * @param _nonDecay bool if auto restake\r\n     * @param _data bytes optional data to include in the emitted event\r\n     */\r\n    function restake(uint256 _bucketIndex, uint256 _stakeDuration, bool _nonDecay, bytes _data)\r\n            external whenNotPaused canTouchBucket(msg.sender, _bucketIndex) checkStakeDuration(_stakeDuration) {\r\n        require(block.timestamp.add(_stakeDuration * secondsPerEpoch) >=\r\n                buckets[_bucketIndex].stakeStartTime.add(buckets[_bucketIndex].stakeDuration * secondsPerEpoch),\r\n                \"current stake duration not finished.\");\r\n        if (buckets[_bucketIndex].nonDecay) {\r\n          require(_stakeDuration >= buckets[_bucketIndex].stakeDuration, \"cannot reduce the stake duration.\");\r\n        }\r\n        buckets[_bucketIndex].stakeDuration = _stakeDuration;\r\n        buckets[_bucketIndex].stakeStartTime = block.timestamp;\r\n        buckets[_bucketIndex].nonDecay = _nonDecay;\r\n        buckets[_bucketIndex].unstakeStartTime = 0;\r\n        emitBucketUpdated(_bucketIndex, _data);\r\n    }\r\n\r\n    /*\r\n     * @notice Vote for another candidate with the tokens that are already staked in the given bucket\r\n     * @notice MUST trigger BucketUpdated event\r\n     * @param _bucketIndex uint256 the index of the bucket\r\n     * @param canName bytes the IoTeX address of the candidate the tokens are staked for\r\n     * @param _data bytes optional data to include in the emitted event\r\n     */\r\n    function revote(uint256 _bucketIndex, bytes12 _canName, bytes _data)\r\n            external whenNotPaused canTouchBucket(msg.sender, _bucketIndex) {\r\n        require(buckets[_bucketIndex].unstakeStartTime == 0, \"cannot revote during unstaking.\");\r\n        buckets[_bucketIndex].canName = _canName;\r\n        emitBucketUpdated(_bucketIndex, _data);\r\n    }\r\n\r\n    /*\r\n     * @notice Set the new owner of a given bucket, the sender must be whitelisted to do so to avoid spam\r\n     * @notice MUST trigger BucketUpdated event\r\n     * @param _name bytes12 the name of the candidate the tokens are staked for\r\n     * @param _bucketIndex uint256 optional data to include in the Stake event\r\n     * @param _data bytes optional data to include in the emitted event\r\n     */\r\n    function setBucketOwner(uint256 _bucketIndex, address _newOwner, bytes _data)\r\n            external whenNotPaused onlyWhitelisted canTouchBucket(msg.sender, _bucketIndex) {\r\n        removeBucketIndex(_bucketIndex);\r\n        buckets[_bucketIndex].bucketOwner = _newOwner;\r\n        stakeholders[_newOwner].push(_bucketIndex);\r\n        // TODO split event.\r\n        emitBucketUpdated(_bucketIndex, _data);\r\n    }\r\n\r\n    /**\r\n     * @notice Unstake a certain amount of tokens from a given bucket.\r\n     * @notice MUST trigger BucketUnstake event\r\n     * @param _bucketIndex uint256 the index of the bucket\r\n     * @param _data bytes optional data to include in the emitted event\r\n     */\r\n    function unstake(uint256 _bucketIndex, bytes _data)\r\n            external whenNotPaused canTouchBucket(msg.sender, _bucketIndex) {\r\n        require(_bucketIndex > 0, \"bucket 0 cannot be unstaked and withdrawn.\");\r\n        require(!buckets[_bucketIndex].nonDecay, \"Cannot unstake with nonDecay flag. Need to disable non-decay mode first.\");\r\n        require(buckets[_bucketIndex].stakeStartTime.add(buckets[_bucketIndex].stakeDuration * secondsPerEpoch) <= block.timestamp,\r\n            \"Staking time does not expire yet. Please wait until staking expires.\");\r\n        require(buckets[_bucketIndex].unstakeStartTime == 0, \"Unstaked already. No need to unstake again.\");\r\n        buckets[_bucketIndex].unstakeStartTime = block.timestamp;\r\n        emit BucketUnstake(_bucketIndex, buckets[_bucketIndex].canName, buckets[_bucketIndex].stakedAmount, _data);\r\n    }\r\n\r\n    /**\r\n     * @notice this SHOULD return the given amount of tokens to the user, if unstaking is currently not possible the function MUST revert\r\n     * @notice MUST trigger BucketWithdraw event\r\n     * @param _bucketIndex uint256 the index of the bucket\r\n     * @param _data bytes optional data to include in the emitted event\r\n     */\r\n    function withdraw(uint256 _bucketIndex, bytes _data)\r\n            external whenNotPaused canTouchBucket(msg.sender, _bucketIndex) {\r\n        require(buckets[_bucketIndex].unstakeStartTime > 0, \"Please unstake first before withdraw.\");\r\n        require(\r\n            buckets[_bucketIndex].unstakeStartTime.add(unStakeDuration * secondsPerEpoch) <= block.timestamp,\r\n            \"Stakeholder needs to wait for 3 days before withdrawing tokens.\");\r\n\r\n        // fix double linked list\r\n        uint256 prev = buckets[_bucketIndex].prev;\r\n        uint256 next = buckets[_bucketIndex].next;\r\n        buckets[prev].next = next;\r\n        buckets[next].prev = prev;\r\n\r\n        uint256 amount = buckets[_bucketIndex].stakedAmount;\r\n        bytes12 canName = buckets[_bucketIndex].canName;\r\n        address bucketowner = buckets[_bucketIndex].bucketOwner;\r\n        buckets[_bucketIndex].stakedAmount = 0;\r\n        removeBucketIndex(_bucketIndex);\r\n        delete buckets[_bucketIndex];\r\n\r\n        require(stakingToken.transfer(bucketowner, amount), \"Unable to withdraw stake\");\r\n        emit BucketWithdraw(_bucketIndex, canName, amount, _data);\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the total of tokens staked from all addresses\r\n     * @return uint256 The number of tokens staked from all addresses\r\n     */\r\n    function totalStaked() public view returns (uint256) {\r\n        return stakingToken.balanceOf(this);\r\n    }\r\n\r\n    /**\r\n     * @notice Address of the token being used by the staking interface\r\n     * @return address The address of the ERC20 token used for staking\r\n     */\r\n    function token() public view returns(address) {\r\n        return stakingToken;\r\n    }\r\n\r\n    /**\r\n     * @notice Emit BucketUpdated event\r\n     */\r\n    function emitBucketUpdated(uint256 _bucketIndex, bytes _data) internal {\r\n        Bucket memory b = buckets[_bucketIndex];\r\n        emit BucketUpdated(_bucketIndex, b.canName, b.stakeDuration, b.stakeStartTime, b.nonDecay, b.bucketOwner, _data);\r\n    }\r\n\r\n    /**\r\n     * @dev  Create a bucket and vote for a given canName.\r\n     * @param _canName bytes The IoTeX address of the candidate the stake is being created for\r\n     * @param _amount uint256 The duration to lock the tokens for\r\n     * @param _stakeDuration bytes the desired duration of the staking\r\n     * @param _nonDecay bool if auto restake\r\n     * @param _data bytes optional data to include in the emitted event\r\n     * @return uint236 the index of new bucket\r\n     */\r\n    function createBucket(bytes12 _canName, uint256 _amount, uint256 _stakeDuration, bool _nonDecay, bytes _data)\r\n            external whenNotPaused checkStakeDuration(_stakeDuration) returns (uint256) {\r\n        require(_amount >= minStakeAmount, \"amount should >= 100.\");\r\n        require(stakeholders[msg.sender].length <= maxBucketsPerAddr, \"One address can have up limited buckets\");\r\n        require(stakingToken.transferFrom(msg.sender, this, _amount), \"Stake required\"); // transfer token to contract\r\n        // add a new bucket to the end of buckets array and fix the double linked list.\r\n        buckets[bucketCount] = Bucket(_canName, _amount, _stakeDuration, block.timestamp, _nonDecay, 0, msg.sender, block.timestamp, buckets[0].prev, 0);\r\n        buckets[buckets[0].prev].next = bucketCount;\r\n        buckets[0].prev = bucketCount;\r\n        stakeholders[msg.sender].push(bucketCount);\r\n        bucketCount++;\r\n        emit BucketCreated(bucketCount-1, _canName, _amount, _stakeDuration, _nonDecay, _data);\r\n        return bucketCount-1;\r\n    }\r\n\r\n    /**\r\n     * @dev Remove the bucket index from stakeholders map\r\n     * @param _bucketidx uint256 the bucket index\r\n     */\r\n    function removeBucketIndex(uint256 _bucketidx) internal {\r\n        address owner = buckets[_bucketidx].bucketOwner;\r\n        require(stakeholders[owner].length > 0, \"Expect the owner has at least one bucket index\");\r\n\r\n        uint256 i = 0;\r\n        for (; i < stakeholders[owner].length; i++) {\r\n          if(stakeholders[owner][i] == _bucketidx) {\r\n                break;\r\n          }\r\n        }\r\n        for (; i < stakeholders[owner].length - 1; i++) {\r\n          stakeholders[owner][i] = stakeholders[owner][i + 1];\r\n        }\r\n        stakeholders[owner].length--;\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_bucketIndex\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_prevIndex\",\"type\":\"uint256\"},{\"name\":\"_limit\",\"type\":\"uint256\"}],\"name\":\"getActiveBuckets\",\"outputs\":[{\"name\":\"count\",\"type\":\"uint256\"},{\"name\":\"indexes\",\"type\":\"uint256[]\"},{\"name\":\"stakeStartTimes\",\"type\":\"uint256[]\"},{\"name\":\"stakeDurations\",\"type\":\"uint256[]\"},{\"name\":\"decays\",\"type\":\"bool[]\"},{\"name\":\"stakedAmounts\",\"type\":\"uint256[]\"},{\"name\":\"canNames\",\"type\":\"bytes12[]\"},{\"name\":\"owners\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addrs\",\"type\":\"address[]\"}],\"name\":\"removeAddressesFromWhitelist\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"removeAddressFromWhitelist\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_prevIndex\",\"type\":\"uint256\"},{\"name\":\"_limit\",\"type\":\"uint256\"}],\"name\":\"getActiveBucketCreateTimes\",\"outputs\":[{\"name\":\"count\",\"type\":\"uint256\"},{\"name\":\"indexes\",\"type\":\"uint256[]\"},{\"name\":\"createTimes\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"stakeholders\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"secondsPerEpoch\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minStakeDuration\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxStakeDuration\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_bucketIndex\",\"type\":\"uint256\"},{\"name\":\"_stakeDuration\",\"type\":\"uint256\"},{\"name\":\"_nonDecay\",\"type\":\"bool\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"restake\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"addAddressToWhitelist\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"getBucketIndexesByAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalStaked\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_prevIndex\",\"type\":\"uint256\"},{\"name\":\"_limit\",\"type\":\"uint256\"}],\"name\":\"getActiveBucketIdx\",\"outputs\":[{\"name\":\"count\",\"type\":\"uint256\"},{\"name\":\"indexes\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"whitelist\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"buckets\",\"outputs\":[{\"name\":\"canName\",\"type\":\"bytes12\"},{\"name\":\"stakedAmount\",\"type\":\"uint256\"},{\"name\":\"stakeDuration\",\"type\":\"uint256\"},{\"name\":\"stakeStartTime\",\"type\":\"uint256\"},{\"name\":\"nonDecay\",\"type\":\"bool\"},{\"name\":\"unstakeStartTime\",\"type\":\"uint256\"},{\"name\":\"bucketOwner\",\"type\":\"address\"},{\"name\":\"createTime\",\"type\":\"uint256\"},{\"name\":\"prev\",\"type\":\"uint256\"},{\"name\":\"next\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_bucketIndex\",\"type\":\"uint256\"},{\"name\":\"_newOwner\",\"type\":\"address\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"setBucketOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"unStakeDuration\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_bucketIndex\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"unstake\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_bucketIndex\",\"type\":\"uint256\"},{\"name\":\"_canName\",\"type\":\"bytes12\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"revote\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addrs\",\"type\":\"address[]\"}],\"name\":\"addAddressesToWhitelist\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_canName\",\"type\":\"bytes12\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_stakeDuration\",\"type\":\"uint256\"},{\"name\":\"_nonDecay\",\"type\":\"bool\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"createBucket\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minStakeAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxBucketsPerAddr\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_stakingTokenAddr\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"bucketIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"canName\",\"type\":\"bytes12\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"stakeDuration\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"nonDecay\",\"type\":\"bool\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"BucketCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"bucketIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"canName\",\"type\":\"bytes12\"},{\"indexed\":false,\"name\":\"stakeDuration\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"stakeStartTime\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"nonDecay\",\"type\":\"bool\"},{\"indexed\":false,\"name\":\"bucketOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"BucketUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"bucketIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"canName\",\"type\":\"bytes12\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"BucketUnstake\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"bucketIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"canName\",\"type\":\"bytes12\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"BucketWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"WhitelistedAddressAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"WhitelistedAddressRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpause\",\"type\":\"event\"}]","ContractName":"Staking","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"0000000000000000000000006fb3e0a217407efff7ca062d46c26e5d60a14d69","EVMVersion":"Default","Library":"","LicenseType":"GNU LGPLv3","Proxy":"0","Implementation":"","SwarmSource":"bzzr://70b08503648f3f587cc005b2109e5e13cc170fbaec9a9da2c254685b42476651"}]}