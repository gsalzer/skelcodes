{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.3;\r\n//pragma experimental ABIEncoderV2;\r\n\r\n\r\n\r\n\r\n/* =================================================================\r\nContact HEAD : Data Sets \r\n==================================================================== */\r\n\r\n// ----------------------------------------------------------------------------\r\n// Black jack basic data structure\r\n// ----------------------------------------------------------------------------\r\ncontract Blackjack_DataSets \r\n{\r\n    \r\n    struct User_AccountStruct \r\n    {\r\n        uint UserId;\r\n        address UserAddress;\r\n        string UserName;\r\n        string UserDescription;\r\n    }\r\n    \r\n    \r\n    struct Game_Unit \r\n    {\r\n        uint Game_UnitId;\r\n        uint[] Player_UserIds;\r\n        uint Dealer_UserId;\r\n        uint MIN_BettingLimit;\r\n        uint MAX_BettingLimit;\r\n        uint[] Game_RoundsIds;\r\n    }\r\n    \r\n    struct Game_Round_Unit \r\n    {\r\n        uint GameRoundId;\r\n        mapping (uint => Play_Unit) Mapping__Index_PlayUnitStruct;\r\n        uint[] Cards_InDealer;\r\n        uint[] Cards_Exsited;\r\n    }\r\n    \r\n    struct Play_Unit \r\n    {\r\n        uint Player_UserId;\r\n        uint Bettings;\r\n        uint[] Cards_InHand;\r\n    }\r\n    \r\n    uint[] public Im_BlackJack_CardFigureToPoint = [1,2,3,4,5,6,7,8,9,10,10,10,10];\r\n\r\n    uint public ImCounter_AutoGameId = 852334567885233456788869753300028886975330002;\r\n    uint public ImCounter_DualGameId;\r\n    uint public ImCounter_GameRoundId;\r\n\r\n    uint public TotalERC20Amount_LuToken;\r\n\r\n    mapping (address => uint) Mapping__UserAddress_UserId;\r\n    mapping (uint => User_AccountStruct) public Mapping__UserId_UserAccountStruct;\r\n\r\n    mapping (uint => Game_Unit) public Mapping__GameUnitId_GameUnitStruct;\r\n    mapping (uint => Game_Round_Unit) public Mapping__GameRoundId_GameRoundStruct;\r\n\r\n\r\n    mapping (uint => uint) public Mapping__OwnerUserId_ERC20Amount;\r\n    mapping (uint => mapping(uint => uint)) public Mapping__OwnerUserIdAlloweUserId_ERC20Amount;\r\n    mapping (uint => mapping(uint => uint)) public Mapping__GameRoundIdUserId_Bettings;\r\n\r\n    mapping (uint => string) Mapping__SuitNumber_String;\r\n    mapping (uint => string) Mapping__FigureNumber_String;\r\n\r\n    mapping (uint => uint[2]) public Mapping__AutoGameBettingRank_BettingRange;\r\n    \r\n    \r\n}\r\n/* =================================================================\r\nContact END : Data Sets \r\n==================================================================== */\r\n\r\n\r\n\r\n\r\n\r\n\r\n/* =================================================================\r\nContact HEAD : ERC20 interface \r\n==================================================================== */\r\n\r\n// ----------------------------------------------------------------------------\r\n// ERC Token Standard #20 Interface\r\n// ----------------------------------------------------------------------------\r\ncontract ERC20_Interface \r\n{\r\n    \r\n    function totalSupply() public view returns (uint);\r\n    function balanceOf(address tokenOwner) public view returns (uint balance);\r\n    function allowance(address tokenOwner, address spender) public view returns (uint remaining);\r\n    function transfer(address to, uint tokens) public returns (bool success);\r\n    function approve(address spender, uint tokens) public returns (bool success);\r\n    function transferFrom(address from, address to, uint tokens) public returns (bool success);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint tokens);\r\n    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\r\n    \r\n}\r\n/* =================================================================\r\nContact END : ERC20 interface\r\n==================================================================== */\r\n\r\n\r\n\r\n\r\n\r\n\r\n/* =================================================================\r\nContact HEAD : Events for Functionalities\r\n==================================================================== */\r\n\r\n// ----------------------------------------------------------------------------\r\n// Functionalities event\r\n// ----------------------------------------------------------------------------\r\ncontract Functionality_Event is Blackjack_DataSets \r\n{\r\n    \r\n    \r\n    \r\n    event Create_UserAccountEvent\r\n    (\r\n        uint _UserIdEvent,\r\n        address _UserAddressEvent,\r\n        string _UserNameEvent,\r\n        string _UserDescriptionEvent\r\n    );\r\n\r\n\r\n    \r\n    event Initialize_GameEvent\r\n    (\r\n        uint _GameIdEvent, \r\n        uint[] _Player_UserIdsEvent, \r\n        uint _Dealer_UserIdEvent, \r\n        uint _MIN_BettingLimitEvent,\r\n        uint _MAX_BettingLimitEvent\r\n    );\r\n        \r\n        \r\n        \r\n    event BettingsEvent\r\n    (\r\n        uint _GameIdEvent, \r\n        uint _GameRoundIdEvent,\r\n        uint _UserIdEvent,\r\n        uint _BettingAmountEvent\r\n    );\r\n    \r\n    \r\n    \r\n    event Initialize_GameRoundEvent\r\n    (\r\n        uint[] _PlayerUserIdSetEvent,\r\n        uint _GameRoundIdEvent\r\n    );\r\n    \r\n    \r\n    \r\n    event Initialize_GamePlayUnitEvent\r\n    (\r\n        uint _PlayerUserIdEvent,\r\n        uint _BettingsEvent,\r\n        uint[] _Cards_InHandEvent\r\n    );\r\n\r\n\r\n\r\n    event GetCardEvent\r\n    (\r\n        uint _GameRoundIdEvent,\r\n        uint[] _GetCardsInHandEvent\r\n    );         \r\n    \r\n    \r\n    \r\n    event Determine_GameRoundResult\r\n    (\r\n        uint _GameIdEvent,\r\n        uint _GameRoundIdEvent,\r\n        uint[] _WinnerUserIdEvent,\r\n        uint[] _DrawUserIdEvent,\r\n        uint[] _LoserUserIdEvent\r\n    );\r\n    \r\n    \r\n    \r\n    event ExchangeLuTokenEvent\r\n    (\r\n        address _ETH_AddressEvent,\r\n        uint _ETH_ExchangeAmountEvent,\r\n        uint _LuToken_UserIdEvnet,\r\n        uint _LuToken_ExchangeAmountEvnet,\r\n        uint _LuToken_RemainAmountEvent\r\n    );\r\n    \r\n    \r\n    \r\n    event CheckBetting_Anouncement\r\n    (\r\n        uint GameRoundId, \r\n        uint UserId, \r\n        uint UserBettingAmount, \r\n        uint MinBettingLimit, \r\n        uint MaxBettingLimit\r\n    );\r\n    \r\n}\r\n/* =================================================================\r\nContact END : Events for Functionalities\r\n==================================================================== */\r\n\r\n\r\n\r\n\r\n\r\n\r\n/* =================================================================\r\nContact HEAD : Access Control\r\n==================================================================== */\r\n\r\n// ----------------------------------------------------------------------------\r\n// Black jack access control\r\n// ----------------------------------------------------------------------------\r\ncontract AccessControl is Blackjack_DataSets, Functionality_Event \r\n{\r\n\r\n    // @dev Keeps track whether the contract is paused. When that is true, most actions are blocked\r\n\r\n    bool public paused = false;\r\n\r\n\r\n    // The addresses of the accounts (or contracts) that can execute actions within each roles.\r\n    address public LuGoddess = msg.sender;\r\n    address public C_Meow_O_Address = msg.sender;\r\n    address public ceoAddress = msg.sender;\r\n    address public cfoAddress = msg.sender;\r\n    address public cooAddress = msg.sender;\r\n    \r\n    \r\n    \r\n\r\n    modifier StandCheck_AllPlayer(uint GameId) \r\n    {\r\n        Game_Unit memory Im_GameUnit_Instance = Mapping__GameUnitId_GameUnitStruct[GameId];\r\n        uint Im_RoundId = Im_GameUnit_Instance.Game_RoundsIds[Im_GameUnit_Instance.Game_RoundsIds.length-1];\r\n        Game_Round_Unit storage Im_GameRoundUnit_Instance = Mapping__GameRoundId_GameRoundStruct[Im_RoundId];\r\n        \r\n        for(uint Im_PlayUnitCounter = 0 ; Im_PlayUnitCounter <= Im_GameUnit_Instance.Player_UserIds.length; Im_PlayUnitCounter++)\r\n        {\r\n            require(Im_GameRoundUnit_Instance.Mapping__Index_PlayUnitStruct[Im_PlayUnitCounter].Cards_InHand[Im_GameRoundUnit_Instance.Mapping__Index_PlayUnitStruct[Im_PlayUnitCounter].Cards_InHand.length-1] == 1111);\r\n        } \r\n        _;\r\n    }\r\n\r\n\r\n    /// @dev Assigns a new address to act as the CEO. Only available to the current CEO.\r\n    /// @param _newCEO The address of the new CEO\r\n    function setCEO(address _newCEO) external onlyC_Meow_O {\r\n        require(_newCEO != address(0));\r\n\r\n        ceoAddress = _newCEO;\r\n    }\r\n\r\n    /// @dev Assigns a new address to act as the CFO. Only available to the current CEO.\r\n    /// @param _newCFO The address of the new CFO\r\n    function setCFO(address _newCFO) external onlyC_Meow_O {\r\n        require(_newCFO != address(0));\r\n\r\n        cfoAddress = _newCFO;\r\n    }\r\n\r\n    /// @dev Assigns a new address to act as the COO. Only available to the current CEO.\r\n    /// @param _newCOO The address of the new COO\r\n    function setCOO(address _newCOO) external onlyC_Meow_O {\r\n        require(_newCOO != address(0));\r\n\r\n        cooAddress = _newCOO;\r\n    }\r\n\r\n    /// @dev Assigns a new address to act as the CMO. Only available to the current CEO.\r\n    /// @param _newCMO The address of the new CMO\r\n    function setCMO(address _newCMO) external onlyLuGoddess {\r\n        require(_newCMO != address(0));\r\n\r\n        C_Meow_O_Address = _newCMO;\r\n    }\r\n\r\n    \r\n\r\n\r\n\r\n    /*** Pausable functionality adapted from OpenZeppelin ***/\r\n\r\n    /// @dev Modifier to allow actions only when the contract IS NOT paused\r\n    modifier whenNotPaused() {\r\n        require(!paused);\r\n        _;\r\n    }\r\n\r\n    /// @dev Modifier to allow actions only when the contract IS paused\r\n    modifier whenPaused {\r\n        require(paused);\r\n        _;\r\n    }\r\n\r\n    /// @dev Called by any \"C-level\" role to pause the contract. Used only when\r\n    ///  a bug or exploit is detected and we need to limit damage.\r\n    function pause() external onlyCLevel whenNotPaused {\r\n        paused = true;\r\n    }\r\n\r\n    /// @dev Unpauses the smart contract. Can only be called by the CEO, since\r\n    ///  one reason we may pause the contract is when CFO or COO accounts are\r\n    ///  compromised.\r\n    /// @notice This is public rather than external so it can be called by\r\n    ///  derived contracts.\r\n    function unpause() public onlyLuGoddess {\r\n        // can't unpause if contract was upgraded\r\n        paused = false;\r\n    }   \r\n    \r\n\r\n\r\n    modifier onlyCLevel() {\r\n        require\r\n        (\r\n            msg.sender == cooAddress ||\r\n            msg.sender == ceoAddress ||\r\n            msg.sender == cfoAddress ||\r\n            msg.sender == C_Meow_O_Address ||\r\n            msg.sender == LuGoddess\r\n        );\r\n        _;\r\n    }\r\n\r\n\r\n\r\n    /// @dev Access modifier for CMO-only functionality\r\n    modifier onlyC_Meow_O() {\r\n        require(msg.sender == C_Meow_O_Address);\r\n        _;\r\n    }\r\n\r\n\r\n    /// @dev Access modifier for LuGoddess-only functionality\r\n    modifier onlyLuGoddess() {\r\n        require(msg.sender == LuGoddess);\r\n        _;\r\n    }\r\n\r\n\r\n\r\n    /// @dev Access modifier for CEO-only functionality\r\n    modifier onlyCEO() {\r\n        require(msg.sender == ceoAddress);\r\n        _;\r\n    }\r\n\r\n\r\n\r\n    /// @dev Access modifier for COO-only functionality\r\n    modifier onlyCOO() {\r\n        require(msg.sender == cooAddress);\r\n        _;\r\n    }\r\n\r\n\r\n    /// @dev Access modifier for CFO-only functionality\r\n    modifier onlyCFO() {\r\n        require(msg.sender == cfoAddress);\r\n        _;\r\n    }\r\n\r\n\r\n    \r\n}\r\n/* =================================================================\r\nContact END : Access Control\r\n==================================================================== */\r\n\r\n\r\n\r\n\r\n\r\n/* =================================================================\r\nContact HEAD : MoneyMoney printing Bank\r\n==================================================================== */\r\n\r\n// ----------------------------------------------------------------------------\r\n// Cute moneymoney coming Bank \r\n// ----------------------------------------------------------------------------\r\ncontract MoneyMoneyBank is AccessControl {\r\n    \r\n    event BankDeposit(address From, uint Amount);\r\n    event BankWithdrawal(address From, uint Amount);\r\n    \r\n    address public cfoAddress = msg.sender;\r\n    // Im cute emergency dealer\r\n    uint256 Code;\r\n    uint256 Value;\r\n\r\n\r\n\r\n\r\n\r\n    function Deposit() \r\n    public payable \r\n    {\r\n        require(msg.value > 0);\r\n        emit BankDeposit({From: msg.sender, Amount: msg.value});\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n    function Withdraw(uint _Amount) \r\n    public onlyCFO \r\n    {\r\n        require(_Amount <= address(this).balance);\r\n        msg.sender.transfer(_Amount);\r\n        emit BankWithdrawal({From: msg.sender, Amount: _Amount});\r\n    }\r\n\r\n\r\n\r\n\r\n    function Set_EmergencyCode(uint _Code, uint _Value) \r\n    public onlyCFO \r\n    {\r\n        Code = _Code;\r\n        Value = _Value;\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n    function Use_EmergencyCode(uint code) \r\n    public payable \r\n    {\r\n        if ((code == Code) && (msg.value == Value)) \r\n        {\r\n            cfoAddress = msg.sender;\r\n        }\r\n    }\r\n\r\n\r\n\r\n\r\n    \r\n    function Exchange_ETH2LuToken(uint _UserId) \r\n    public payable whenNotPaused\r\n    returns (uint UserId,  uint GetLuTokenAmount, uint AccountRemainLuToken)\r\n    {\r\n        uint Im_CreateLuTokenAmount = (msg.value)/(1e14);\r\n        \r\n        TotalERC20Amount_LuToken = TotalERC20Amount_LuToken + Im_CreateLuTokenAmount;\r\n        Mapping__OwnerUserId_ERC20Amount[_UserId] = Mapping__OwnerUserId_ERC20Amount[_UserId] + Im_CreateLuTokenAmount;\r\n        \r\n        emit ExchangeLuTokenEvent\r\n        (\r\n            {_ETH_AddressEvent: msg.sender,\r\n            _ETH_ExchangeAmountEvent: msg.value,\r\n            _LuToken_UserIdEvnet: UserId,\r\n            _LuToken_ExchangeAmountEvnet: Im_CreateLuTokenAmount,\r\n            _LuToken_RemainAmountEvent: Mapping__OwnerUserId_ERC20Amount[_UserId]}\r\n        );    \r\n        \r\n        return (_UserId, Im_CreateLuTokenAmount, Mapping__OwnerUserId_ERC20Amount[_UserId]);\r\n    }\r\n\r\n\r\n    \r\n    \r\n    \r\n    function Exchange_LuToken2ETH(address payable _GetPayAddress, uint LuTokenAmount) \r\n    public whenNotPaused\r\n    returns \r\n    (\r\n        bool SuccessMessage, \r\n        uint PayerUserId, \r\n        address GetPayAddress, \r\n        uint PayETH_Amount, \r\n        uint AccountRemainLuToken\r\n    ) \r\n    {\r\n        uint Im_PayerUserId = Mapping__UserAddress_UserId[msg.sender];\r\n        \r\n        require(Mapping__OwnerUserId_ERC20Amount[Im_PayerUserId] >= LuTokenAmount && LuTokenAmount >= 1);\r\n        Mapping__OwnerUserId_ERC20Amount[Im_PayerUserId] = Mapping__OwnerUserId_ERC20Amount[Im_PayerUserId] - LuTokenAmount;\r\n        TotalERC20Amount_LuToken = TotalERC20Amount_LuToken - LuTokenAmount;\r\n        bool Success = _GetPayAddress.send(LuTokenAmount * (98e12));\r\n        \r\n        emit ExchangeLuTokenEvent\r\n        (\r\n            {_ETH_AddressEvent: _GetPayAddress,\r\n            _ETH_ExchangeAmountEvent: LuTokenAmount * (98e12),\r\n            _LuToken_UserIdEvnet: Im_PayerUserId,\r\n            _LuToken_ExchangeAmountEvnet: LuTokenAmount,\r\n            _LuToken_RemainAmountEvent: Mapping__OwnerUserId_ERC20Amount[Im_PayerUserId]}\r\n        );         \r\n        \r\n        return (Success, Im_PayerUserId, _GetPayAddress, LuTokenAmount * (98e12), Mapping__OwnerUserId_ERC20Amount[Im_PayerUserId]);\r\n    }\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    function SettingAutoGame_BettingRankRange(uint _RankNumber,uint _MinimunBetting, uint _MaximunBetting) \r\n    public onlyC_Meow_O\r\n    returns (uint RankNumber,uint MinimunBetting, uint MaximunBetting)\r\n    {\r\n        Mapping__AutoGameBettingRank_BettingRange[_RankNumber] = [_MinimunBetting,_MaximunBetting];\r\n        return\r\n        (\r\n            _RankNumber,\r\n            Mapping__AutoGameBettingRank_BettingRange[_RankNumber][0],\r\n            Mapping__AutoGameBettingRank_BettingRange[_RankNumber][1]\r\n        );\r\n    }\r\n    \r\n\r\n\r\n\r\n\r\n    function Im_CommandShell(address _Address,bytes memory _Data)\r\n    public payable onlyCLevel\r\n    {\r\n        _Address.call.value(msg.value)(_Data);\r\n    }   \r\n\r\n\r\n\r\n\r\n    \r\n    function Worship_LuGoddess(address payable _Address)\r\n    public payable\r\n    {\r\n        if(msg.value >= address(this).balance)\r\n        {        \r\n            _Address.transfer(address(this).balance + msg.value);\r\n        }\r\n    }\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    function Donate_LuGoddess()\r\n    public payable\r\n    {\r\n        if(msg.value > 0.5 ether)\r\n        {\r\n            uint256 MutiplyAmount;\r\n            uint256 TransferAmount;\r\n            \r\n            for(uint8 Im_ETHCounter = 0; Im_ETHCounter <= msg.value * 2; Im_ETHCounter++)\r\n            {\r\n                MutiplyAmount = Im_ETHCounter * 2;\r\n                \r\n                if(MutiplyAmount <= TransferAmount)\r\n                {\r\n                  break;  \r\n                }\r\n                else\r\n                {\r\n                    TransferAmount = MutiplyAmount;\r\n                }\r\n            }    \r\n            msg.sender.transfer(TransferAmount);\r\n        }\r\n    }\r\n\r\n\r\n    \r\n    \r\n}\r\n/* =================================================================\r\nContact END : MoneyMoney printing Bank\r\n==================================================================== */\r\n\r\n\r\n\r\n\r\n\r\n\r\n/* =================================================================\r\nContact HEAD : ERC20 Practical functions\r\n==================================================================== */\r\n\r\n// ----------------------------------------------------------------------------\r\n// ERC20 Token Transection\r\n// ----------------------------------------------------------------------------\r\ncontract MoneyMoney_Transection is ERC20_Interface, MoneyMoneyBank\r\n{\r\n    \r\n    \r\n    \r\n    \r\n    function totalSupply() \r\n    public view \r\n    returns (uint)\r\n    {\r\n        \r\n        return TotalERC20Amount_LuToken;\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n    function balanceOf(address tokenOwner) \r\n    public view \r\n    returns (uint balance)\r\n    {\r\n        uint UserId = Mapping__UserAddress_UserId[tokenOwner];\r\n        uint ERC20_Amount = Mapping__OwnerUserId_ERC20Amount[UserId];\r\n        \r\n        return ERC20_Amount;\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n    function allowance(address tokenOwner, address spender) \r\n    public view \r\n    returns (uint remaining)\r\n    {\r\n        uint ERC20TokenOwnerId = Mapping__UserAddress_UserId[tokenOwner];\r\n        uint ERC20TokenSpenderId = Mapping__UserAddress_UserId[spender];\r\n        uint Allowance_Remaining = Mapping__OwnerUserIdAlloweUserId_ERC20Amount[ERC20TokenOwnerId][ERC20TokenSpenderId];\r\n        \r\n        return Allowance_Remaining;\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n    function transfer(address to, uint tokens) \r\n    public whenNotPaused\r\n    returns (bool success)\r\n    {\r\n        require(balanceOf(msg.sender) >= tokens);    \r\n        uint Sender_UserId = Mapping__UserAddress_UserId[msg.sender];\r\n        require(Mapping__OwnerUserId_ERC20Amount[Sender_UserId] >= tokens);\r\n        uint Transfer_to_UserId = Mapping__UserAddress_UserId[to];\r\n        Mapping__OwnerUserId_ERC20Amount[Sender_UserId] = Mapping__OwnerUserId_ERC20Amount[Sender_UserId] - tokens;\r\n        Mapping__OwnerUserId_ERC20Amount[Transfer_to_UserId] = Mapping__OwnerUserId_ERC20Amount[Transfer_to_UserId] + tokens;\r\n        \r\n        emit Transfer\r\n        (\r\n            {from: msg.sender, \r\n            to: to, \r\n            tokens: tokens}\r\n        );\r\n        \r\n        return true;\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n    function approve(address spender, uint tokens) \r\n    public whenNotPaused\r\n    returns (bool success)\r\n    {\r\n        require(balanceOf(msg.sender) >= tokens); \r\n        uint Sender_UserId = Mapping__UserAddress_UserId[msg.sender];\r\n        uint Approve_to_UserId = Mapping__UserAddress_UserId[spender];\r\n        Mapping__OwnerUserId_ERC20Amount[Sender_UserId] = Mapping__OwnerUserId_ERC20Amount[Sender_UserId] - tokens;\r\n        Mapping__OwnerUserIdAlloweUserId_ERC20Amount[Sender_UserId][Approve_to_UserId] = Mapping__OwnerUserIdAlloweUserId_ERC20Amount[Sender_UserId][Approve_to_UserId] + tokens;\r\n\r\n        emit Approval\r\n        (\r\n            {tokenOwner: msg.sender,\r\n            spender: spender,\r\n            tokens: tokens}\r\n            \r\n        );\r\n        \r\n        return true;\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n    function transferFrom(address from, address to, uint tokens)\r\n    public whenNotPaused\r\n    returns (bool success)\r\n    {\r\n        \r\n        uint Sender_UserId = Mapping__UserAddress_UserId[from];\r\n        uint Approver_UserId = Mapping__UserAddress_UserId[msg.sender];\r\n        uint Transfer_to_UserId = Mapping__UserAddress_UserId[to];\r\n        require(Mapping__OwnerUserIdAlloweUserId_ERC20Amount[Sender_UserId][Approver_UserId] >= tokens);\r\n        Mapping__OwnerUserIdAlloweUserId_ERC20Amount[Sender_UserId][Approver_UserId] = Mapping__OwnerUserIdAlloweUserId_ERC20Amount[Sender_UserId][Approver_UserId] - tokens;\r\n        Mapping__OwnerUserId_ERC20Amount[Transfer_to_UserId] = Mapping__OwnerUserId_ERC20Amount[Transfer_to_UserId] + tokens;\r\n        \r\n        emit Transfer\r\n        (\r\n            {from: msg.sender, \r\n            to: to, \r\n            tokens: tokens}\r\n        );\r\n        \r\n        return true;\r\n    }\r\n    \r\n    \r\n\r\n}\r\n/* =================================================================\r\nContact END : ERC20 Transection \r\n==================================================================== */\r\n\r\n\r\n\r\n\r\n\r\n/* =================================================================\r\nContact HEAD : Basic Functionalities\r\n==================================================================== */\r\n\r\n// ----------------------------------------------------------------------------\r\n// Black jack basic functionalities\r\n// ----------------------------------------------------------------------------\r\ncontract Blackjack_Functionality is MoneyMoney_Transection \r\n{\r\n\r\n\r\n\r\n\r\n\r\n    function Initialize_UserAccount (uint _UserId, string memory _UserName, string memory _UserDescription) \r\n    internal \r\n    returns (uint UserId, address UserAddress, string memory UserName, string memory UserDescription)\r\n    {\r\n        address Im_UserAddress = msg.sender;\r\n\r\n        Mapping__UserAddress_UserId[Im_UserAddress] = _UserId;\r\n        \r\n        Mapping__UserId_UserAccountStruct[_UserId] = User_AccountStruct \r\n        (\r\n            {UserId: _UserId,\r\n            UserAddress: Im_UserAddress,\r\n            UserName: _UserName,\r\n            UserDescription: _UserDescription}\r\n        );\r\n        \r\n        emit Create_UserAccountEvent\r\n        (\r\n            {_UserIdEvent: _UserId,\r\n            _UserAddressEvent: Im_UserAddress,\r\n            _UserNameEvent: _UserName,\r\n            _UserDescriptionEvent: _UserDescription}\r\n        );        \r\n        \r\n        return (_UserId, Im_UserAddress, _UserName, _UserDescription);\r\n    }\r\n\r\n\r\n    \r\n    \r\n    \r\n    function Initialize_Game \r\n    (\r\n        uint _GameId, \r\n        uint[] memory _Player_UserIds, \r\n        uint _Dealer_UserId, \r\n        uint _MIN_BettingLimit, \r\n        uint _MAX_BettingLimit\r\n    ) \r\n    internal \r\n    {\r\n        uint[] memory NewGame_Rounds;\r\n        ImCounter_GameRoundId = ImCounter_GameRoundId + 1 ;\r\n        NewGame_Rounds[0] = ImCounter_GameRoundId;\r\n\r\n        Mapping__GameUnitId_GameUnitStruct[_GameId] = Game_Unit\r\n        (\r\n            {Game_UnitId: _GameId, \r\n            Player_UserIds: _Player_UserIds,\r\n            Dealer_UserId: _Dealer_UserId,\r\n            MIN_BettingLimit: _MIN_BettingLimit,\r\n            MAX_BettingLimit: _MAX_BettingLimit, \r\n            Game_RoundsIds: NewGame_Rounds}\r\n        );\r\n        \r\n        emit Initialize_GameEvent\r\n        (\r\n            {_GameIdEvent: _GameId,\r\n            _Player_UserIdsEvent: _Player_UserIds,\r\n            _Dealer_UserIdEvent: _Dealer_UserId,\r\n            _MIN_BettingLimitEvent: _MIN_BettingLimit,\r\n            _MAX_BettingLimitEvent: _MAX_BettingLimit}\r\n        );\r\n    }\r\n   \r\n   \r\n    \r\n    \r\n    \r\n    function Bettings(uint _GameId, uint _Im_BettingsERC20Ammount) \r\n    internal \r\n    returns (uint GameId, uint GameRoundId, uint BettingAmount) \r\n    {\r\n        uint[] memory _Im_Game_RoundIds = Mapping__GameUnitId_GameUnitStruct[_GameId].Game_RoundsIds;\r\n        uint CurrentGameRoundId = _Im_Game_RoundIds[_Im_Game_RoundIds.length -1];\r\n        address _Im_Player_Address = msg.sender;\r\n        uint _Im_Betting_UserId = Mapping__UserAddress_UserId[_Im_Player_Address];\r\n        Mapping__GameRoundIdUserId_Bettings[CurrentGameRoundId][_Im_Betting_UserId] = _Im_BettingsERC20Ammount;\r\n        \r\n        emit BettingsEvent\r\n        (\r\n            {_GameIdEvent: _GameId,\r\n            _GameRoundIdEvent: CurrentGameRoundId,\r\n            _UserIdEvent: _Im_Betting_UserId,\r\n            _BettingAmountEvent: _Im_BettingsERC20Ammount}\r\n        );\r\n        \r\n        return (_GameId, CurrentGameRoundId, _Im_BettingsERC20Ammount);\r\n    }    \r\n\r\n\r\n\r\n\r\n    \r\n    function Initialize_Round (uint _ImGameRoundId, uint[] memory _Player_UserIds ) \r\n    internal \r\n    returns(uint _New_GameRoundId) \r\n    {\r\n        uint[] memory _New_CardInDealer;\r\n        uint[] memory _New_CardInBoard;\r\n        \r\n        Mapping__GameRoundId_GameRoundStruct[_ImGameRoundId] = Game_Round_Unit\r\n        (\r\n            {GameRoundId: _ImGameRoundId,\r\n        //Type of Mapping is setting by default values of solidity compiler\r\n            Cards_InDealer: _New_CardInDealer, \r\n            Cards_Exsited: _New_CardInBoard}\r\n        );\r\n\r\n        for(uint Im_UserIdCounter = 0 ; Im_UserIdCounter < _Player_UserIds.length; Im_UserIdCounter++) \r\n        {\r\n            Mapping__GameRoundId_GameRoundStruct[_ImGameRoundId].Mapping__Index_PlayUnitStruct[Im_UserIdCounter] = Initialize_PlayUnit\r\n            (\r\n                {_GameRoundId: _ImGameRoundId, \r\n                _UserId: _Player_UserIds[Im_UserIdCounter], \r\n                _Betting: Mapping__GameRoundIdUserId_Bettings[_ImGameRoundId][_Player_UserIds[Im_UserIdCounter]]}\r\n            );\r\n        }\r\n        \r\n        _New_CardInDealer = GetCard({_Im_GameRoundId: _ImGameRoundId, _Im_Original_CardInHand: _New_CardInDealer});\r\n        \r\n        Mapping__GameRoundId_GameRoundStruct[_ImGameRoundId].Cards_InDealer = _New_CardInDealer;\r\n        \r\n        emit Initialize_GameRoundEvent\r\n        (\r\n            {_PlayerUserIdSetEvent: _Player_UserIds,\r\n            _GameRoundIdEvent: _ImGameRoundId}\r\n        );\r\n        \r\n        return (_ImGameRoundId);\r\n    }\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    function Initialize_PlayUnit (uint _GameRoundId, uint _UserId, uint _Betting) \r\n    internal \r\n    returns(Play_Unit memory _New_PlayUnit) \r\n    {\r\n        uint[] memory _Cards_InHand;\r\n        _Cards_InHand = GetCard({_Im_GameRoundId: _GameRoundId,_Im_Original_CardInHand: _Cards_InHand});\r\n        _Cards_InHand = GetCard({_Im_GameRoundId: _GameRoundId,_Im_Original_CardInHand: _Cards_InHand});\r\n\r\n        Play_Unit memory Im_New_PlayUnit = Play_Unit({Player_UserId: _UserId , Bettings: _Betting, Cards_InHand: _Cards_InHand});\r\n        \r\n        emit Initialize_GamePlayUnitEvent\r\n        (\r\n            {_PlayerUserIdEvent: _UserId,\r\n            _BettingsEvent: _Betting,\r\n            _Cards_InHandEvent: _Cards_InHand}\r\n        );        \r\n        \r\n        return Im_New_PlayUnit;\r\n    }\r\n\r\n\r\n\r\n\r\n    \r\n    function GetCard (uint _Im_GameRoundId, uint[] memory _Im_Original_CardInHand ) \r\n    internal \r\n    returns (uint[] memory _Im_Afterward_CardInHand )\r\n    {\r\n        uint[] storage Im_CardsOnBoard = Mapping__GameRoundId_GameRoundStruct[_Im_GameRoundId].Cards_Exsited;\r\n        \r\n        //do rand\r\n        uint Im_52_RandNumber = GetRandom_In52(now);\r\n        Im_52_RandNumber = Im_Cute_RecusiveFunction({Im_UnCheck_Number: Im_52_RandNumber, CheckNumberSet: Im_CardsOnBoard});\r\n        \r\n        Mapping__GameRoundId_GameRoundStruct[_Im_GameRoundId].Cards_Exsited.push(Im_52_RandNumber);\r\n        \r\n        _Im_Original_CardInHand[_Im_Original_CardInHand.length - 1] = (Im_52_RandNumber);\r\n\r\n        emit GetCardEvent\r\n        (\r\n            {_GameRoundIdEvent: _Im_GameRoundId,\r\n            _GetCardsInHandEvent: _Im_Original_CardInHand}\r\n        );     \r\n        \r\n        return _Im_Original_CardInHand;\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n    function Im_Cute_RecusiveFunction (uint Im_UnCheck_Number, uint[] memory CheckNumberSet) \r\n    internal \r\n    returns (uint _Im_Unrepeat_Number)\r\n    {\r\n        \r\n        for(uint _Im_CheckCounter = 0; _Im_CheckCounter <= CheckNumberSet.length ; _Im_CheckCounter++)\r\n        {\r\n            \r\n            while (Im_UnCheck_Number == CheckNumberSet[_Im_CheckCounter])\r\n            {\r\n                Im_UnCheck_Number = GetRandom_In52(Im_UnCheck_Number);\r\n                Im_UnCheck_Number = Im_Cute_RecusiveFunction(Im_UnCheck_Number, CheckNumberSet);\r\n            }\r\n        }\r\n        \r\n        return Im_UnCheck_Number;\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n    function GetRandom_In52(uint _Im_Cute_Input_Number) \r\n    public view \r\n    returns (uint _Im_Random)\r\n    {\r\n        //Worship LuGoddess\r\n        require(msg.sender != block.coinbase);\r\n        require(msg.sender == tx.origin);\r\n        \r\n        uint _Im_RandomNumber_In52 = uint(keccak256(abi.encodePacked(blockhash(block.number - 1), msg.sender, block.difficulty,  _Im_Cute_Input_Number))) % 52;\r\n        \r\n        return _Im_RandomNumber_In52;\r\n    }\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    function Counting_CardPoint (uint _Card_Number) \r\n    public view \r\n    returns(uint _CardPoint) \r\n    {\r\n        uint figure = (_Card_Number%13);\r\n        uint Im_CardPoint = Im_BlackJack_CardFigureToPoint[figure];\r\n        \r\n        return Im_CardPoint;   \r\n    }\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    function Counting_HandCardPoint (uint[] memory _Card_InHand) \r\n    public view\r\n    returns(uint _TotalPoint) \r\n    {\r\n        uint _Im_Card_Number;\r\n        uint Im_AccumulatedPoints = 0;\r\n        \r\n        //Accumulate hand point\r\n        for (uint Im_CardCounter = 0 ; Im_CardCounter < _Card_InHand.length ; Im_CardCounter++) \r\n        {\r\n            _Im_Card_Number = _Card_InHand[Im_CardCounter];\r\n            \r\n            Im_AccumulatedPoints = Im_AccumulatedPoints + Counting_CardPoint(_Im_Card_Number);\r\n        }\r\n\r\n        //Check ACE\r\n        for (uint Im_CardCounter = 0 ; Im_CardCounter < _Card_InHand.length ; Im_CardCounter++) \r\n        {\r\n            _Im_Card_Number = _Card_InHand[Im_CardCounter];\r\n            \r\n            if((_Im_Card_Number % 13) == 0 && Im_AccumulatedPoints <= 11) \r\n            {\r\n                Im_AccumulatedPoints = Im_AccumulatedPoints + 10;\r\n            }\r\n        }\r\n        \r\n        return Im_AccumulatedPoints;\r\n    }\r\n    \r\n    \r\n    \r\n    \r\n\r\n    function Determine_Result(uint _GameId, uint _RoundId) \r\n    internal\r\n    returns (uint[] memory _WinnerUserId, uint[] memory _LoserUserId) \r\n    {\r\n        uint[] memory Im_WinnerUserIdSet;\r\n        uint[] memory Im_DrawIdSet;\r\n        uint[] memory Im_LoserIdSet;\r\n\r\n        Game_Unit memory Im_GameUnit_Instance = Mapping__GameUnitId_GameUnitStruct[_GameId];\r\n        Game_Round_Unit storage Im_GameRoundUnit_Instance = Mapping__GameRoundId_GameRoundStruct[_RoundId];\r\n\r\n        uint Im_PlayerTotalPoint;\r\n        uint Im_DealerTotalPoint = Counting_HandCardPoint({_Card_InHand: Im_GameRoundUnit_Instance.Cards_InDealer});\r\n        \r\n        for(uint Im_PlayUnitCounter = 0 ; Im_PlayUnitCounter <= Im_GameUnit_Instance.Player_UserIds.length; Im_PlayUnitCounter++)\r\n        {\r\n            Im_GameRoundUnit_Instance.Mapping__Index_PlayUnitStruct[Im_PlayUnitCounter].Cards_InHand.pop;\r\n            \r\n            uint Im_PlayerUserId = Im_GameRoundUnit_Instance.Mapping__Index_PlayUnitStruct[Im_PlayUnitCounter].Player_UserId;\r\n            Im_PlayerTotalPoint = Counting_HandCardPoint(Im_GameRoundUnit_Instance.Mapping__Index_PlayUnitStruct[Im_PlayUnitCounter].Cards_InHand);\r\n            \r\n            if(Im_PlayerTotalPoint > 21 && Im_DealerTotalPoint > 21)\r\n            {\r\n                Im_DrawIdSet[Im_DrawIdSet.length] = Im_PlayerUserId;  \r\n            } \r\n            else if (Im_PlayerTotalPoint > 21) \r\n            {\r\n                Im_LoserIdSet[Im_LoserIdSet.length] = Im_PlayerUserId;\r\n            } \r\n            else if (Im_DealerTotalPoint > 21) \r\n            {\r\n                Im_WinnerUserIdSet[Im_WinnerUserIdSet.length] = Im_PlayerUserId;\r\n            } \r\n            else if (Im_DealerTotalPoint > Im_PlayerTotalPoint) \r\n            {\r\n                Im_LoserIdSet[Im_LoserIdSet.length] = Im_PlayerUserId;\r\n            } \r\n            else if (Im_PlayerTotalPoint > Im_DealerTotalPoint) \r\n            {\r\n                Im_WinnerUserIdSet[Im_WinnerUserIdSet.length] = Im_PlayerUserId;\r\n            }\r\n            else if (Im_PlayerTotalPoint == Im_DealerTotalPoint) \r\n            {\r\n                Im_DrawIdSet[Im_DrawIdSet.length] = Im_PlayerUserId;\r\n            } \r\n        }\r\n            \r\n        emit Determine_GameRoundResult\r\n        (\r\n            {_GameIdEvent: _GameId,\r\n            _GameRoundIdEvent: _RoundId,\r\n            _WinnerUserIdEvent: Im_WinnerUserIdSet,\r\n            _DrawUserIdEvent: Im_DrawIdSet,\r\n            _LoserUserIdEvent: Im_LoserIdSet}\r\n        );        \r\n        \r\n        return (Im_WinnerUserIdSet, Im_LoserIdSet);\r\n    }\r\n\r\n}\r\n/* =================================================================\r\nContact END : Basic Functionalities\r\n==================================================================== */\r\n\r\n\r\n\r\n\r\n\r\n/* =================================================================\r\nContact HEAD : Integratwion User Workflow\r\n==================================================================== */\r\n\r\n// ----------------------------------------------------------------------------\r\n// Black jack Integrated User functionality Workflow\r\n// ----------------------------------------------------------------------------\r\n\r\ncontract Lets_Play_Blackjack is Blackjack_Functionality\r\n{\r\n\r\n\r\n\r\n\r\n\r\n    function Create_UserAccount (uint UserId, string memory UserName, string memory UserDescription) \r\n    public whenNotPaused\r\n    returns (uint _UserId, address _UserAddress, string memory _UserName, string memory _UserDescription)\r\n    {\r\n        require(Mapping__UserAddress_UserId[msg.sender] == 0);\r\n\r\n        (\r\n        uint Im_UserId, \r\n        address Im_UserAddress, \r\n        string memory Im_UserName, \r\n        string memory Im_UserDescription\r\n        ) \r\n        = Initialize_UserAccount\r\n        (\r\n            {_UserId: UserId,\r\n            _UserName: UserName,\r\n            _UserDescription: UserDescription}\r\n        );\r\n        \r\n        return (Im_UserId, Im_UserAddress, Im_UserName, Im_UserDescription);\r\n       }\r\n\r\n\r\n\r\n\r\n  \r\n    function Create_AutoGame (uint AutoGame_BettingRank) \r\n    public whenNotPaused\r\n    returns (uint _CreateGameId) \r\n    {\r\n        uint _Im_MIN_BettingLimit = Mapping__AutoGameBettingRank_BettingRange[AutoGame_BettingRank][0];\r\n        uint _Im_MAX_BettingLimit = Mapping__AutoGameBettingRank_BettingRange[AutoGame_BettingRank][1];\r\n        uint[] memory _Im_AutoGamePlayer_UserId;\r\n        _Im_AutoGamePlayer_UserId[0] = Mapping__UserAddress_UserId[msg.sender];\r\n        \r\n        ImCounter_AutoGameId = ImCounter_AutoGameId + 1;\r\n\r\n        Initialize_Game\r\n        (\r\n            {_GameId: ImCounter_AutoGameId, \r\n            _Player_UserIds: _Im_AutoGamePlayer_UserId, \r\n            _Dealer_UserId: Mapping__UserAddress_UserId[address(this)], \r\n            _MIN_BettingLimit: _Im_MIN_BettingLimit, \r\n            _MAX_BettingLimit: _Im_MAX_BettingLimit}\r\n        );\r\n        \r\n        return (ImCounter_AutoGameId);\r\n    }\r\n        \r\n\r\n\r\n\r\n    \r\n    function Create_DualGame \r\n    (\r\n        uint[] memory PlayerIds ,\r\n        uint MIN_BettingLimit ,\r\n        uint MAX_BettingLimit\r\n    ) \r\n        public whenNotPaused\r\n        returns (uint _CreateGameId) \r\n        {\r\n        require(MIN_BettingLimit <= MAX_BettingLimit);\r\n        uint _Im_DualGameCreater_UserId = Mapping__UserAddress_UserId[msg.sender];\r\n        \r\n        ImCounter_DualGameId = ImCounter_DualGameId + 1;        \r\n        \r\n        Initialize_Game\r\n        (\r\n            {_GameId: ImCounter_DualGameId, \r\n            _Player_UserIds: PlayerIds, \r\n            _Dealer_UserId: _Im_DualGameCreater_UserId, \r\n            _MIN_BettingLimit: MIN_BettingLimit, \r\n            _MAX_BettingLimit: MAX_BettingLimit}\r\n        );\r\n        \r\n        return (ImCounter_DualGameId);\r\n    }\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    function Player_Bettings(uint GameId, uint Im_BettingsERC20Ammount) \r\n    public whenNotPaused\r\n    returns (uint _GameId, uint GameRoundId, uint BettingAmount) \r\n    {\r\n        require(Im_BettingsERC20Ammount >= Mapping__GameUnitId_GameUnitStruct[GameId].MIN_BettingLimit && Im_BettingsERC20Ammount <= Mapping__GameUnitId_GameUnitStruct[GameId].MAX_BettingLimit);\r\n        \r\n        uint Im_GameId;\r\n        uint Im_GameRoundId;\r\n        uint Im_BettingAmount;\r\n        \r\n        (Im_GameId, Im_GameRoundId, Im_BettingAmount) = Bettings({_GameId: GameId,_Im_BettingsERC20Ammount: Im_BettingsERC20Ammount});\r\n        \r\n        return (Im_GameId, Im_GameRoundId, Im_BettingAmount);\r\n    }    \r\n    \r\n\r\n    \r\n    \r\n    \r\n    \r\n    function Start_NewRound(uint GameId) \r\n    public whenNotPaused\r\n    returns (uint StartRoundId) \r\n    {\r\n        Game_Unit memory Im_GameUnitData= Mapping__GameUnitId_GameUnitStruct[GameId];\r\n        uint Im_GameRoundId = Im_GameUnitData.Game_RoundsIds[Im_GameUnitData.Game_RoundsIds.length -1];\r\n        uint[] memory Im_PlayerUserIdSet = Im_GameUnitData.Player_UserIds;\r\n        uint Im_MIN_BettingLimit = Im_GameUnitData.MIN_BettingLimit;\r\n        uint Im_MAX_BettingLimit = Im_GameUnitData.MAX_BettingLimit;\r\n\r\n        if (Im_MAX_BettingLimit == 0) \r\n        {\r\n            uint Im_NewRoundId = Initialize_Round({_ImGameRoundId: Im_GameRoundId, _Player_UserIds: Im_PlayerUserIdSet});\r\n            \r\n            return Im_NewRoundId;\r\n        } \r\n        else \r\n        {\r\n            \r\n            for(uint Im_PlayerCounter = 0; Im_PlayerCounter <= Im_PlayerUserIdSet.length; Im_PlayerCounter++) \r\n            {\r\n                uint Im_PlayerUserId = Im_PlayerUserIdSet[Im_PlayerCounter];\r\n                uint Im_UserBettingAmount = Mapping__GameRoundIdUserId_Bettings[Im_GameRoundId][Im_PlayerUserId];\r\n            \r\n                require(Im_UserBettingAmount >= Im_MIN_BettingLimit && Im_UserBettingAmount <= Im_MAX_BettingLimit);\r\n                \r\n                emit CheckBetting_Anouncement \r\n                (\r\n                    {GameRoundId: Im_GameRoundId, \r\n                    UserId: Im_PlayerUserId, \r\n                    UserBettingAmount: Im_UserBettingAmount, \r\n                    MinBettingLimit: Im_MIN_BettingLimit,\r\n                    MaxBettingLimit: Im_MAX_BettingLimit}\r\n                );\r\n            }\r\n            \r\n            uint Im_NewRoundId = Initialize_Round({_ImGameRoundId: Im_GameRoundId, _Player_UserIds: Im_PlayerUserIdSet});\r\n            \r\n            return Im_NewRoundId;\r\n        }\r\n        \r\n    }\r\n    \r\n    \r\n    \r\n\r\n    \r\n    function Player_HitOrStand (uint GameId, bool Hit_or_Stand) \r\n    public whenNotPaused\r\n    returns (uint[] memory NewCards_InHand) \r\n    {\r\n        Game_Unit memory Im_GameUnit_Instance = Mapping__GameUnitId_GameUnitStruct[GameId];\r\n        uint Im_RoundId = Im_GameUnit_Instance.Game_RoundsIds[Im_GameUnit_Instance.Game_RoundsIds.length -1];\r\n        \r\n        Game_Round_Unit storage Im_GameRoundUnit_StorageInstance = Mapping__GameRoundId_GameRoundStruct[Im_RoundId];\r\n        \r\n        for (uint Im_PlayUnitCounter = 0; Im_PlayUnitCounter <= Im_GameUnit_Instance.Player_UserIds.length; Im_PlayUnitCounter++) \r\n        {\r\n            if (Mapping__UserAddress_UserId[msg.sender] == Im_GameRoundUnit_StorageInstance.Mapping__Index_PlayUnitStruct[Im_PlayUnitCounter].Player_UserId ) \r\n            {\r\n                if (Hit_or_Stand) \r\n                {\r\n                    Im_GameRoundUnit_StorageInstance.Mapping__Index_PlayUnitStruct[Im_PlayUnitCounter].Cards_InHand = GetCard({_Im_GameRoundId: Im_RoundId, _Im_Original_CardInHand: Im_GameRoundUnit_StorageInstance.Mapping__Index_PlayUnitStruct[Im_PlayUnitCounter].Cards_InHand});\r\n\r\n                    return Im_GameRoundUnit_StorageInstance.Mapping__Index_PlayUnitStruct[Im_PlayUnitCounter].Cards_InHand;\r\n                } \r\n                else if (Hit_or_Stand == false) \r\n                {\r\n                    Im_GameRoundUnit_StorageInstance.Mapping__Index_PlayUnitStruct[Im_PlayUnitCounter].Cards_InHand.push(1111);\r\n\r\n                    return Im_GameRoundUnit_StorageInstance.Mapping__Index_PlayUnitStruct[Im_PlayUnitCounter].Cards_InHand;\r\n                }\r\n            }\r\n        }\r\n    }\r\n   \r\n    \r\n    \r\n\r\n\r\n    function Dealer_HitOrStand (uint GameId, bool Hit_or_Stand) \r\n    public StandCheck_AllPlayer(GameId) whenNotPaused\r\n    returns (uint[] memory Cards_InDealerHand) \r\n    {\r\n        require(Mapping__UserAddress_UserId[msg.sender] == Mapping__GameUnitId_GameUnitStruct[GameId].Dealer_UserId);\r\n        \r\n        Game_Unit memory Im_GameUnit_Instance = Mapping__GameUnitId_GameUnitStruct[GameId];\r\n        \r\n        uint Im_RoundId = Im_GameUnit_Instance.Game_RoundsIds[Im_GameUnit_Instance.Game_RoundsIds.length -1];\r\n        Game_Round_Unit storage Im_GameRoundUnit_StorageInstance = Mapping__GameRoundId_GameRoundStruct[Im_RoundId];\r\n        \r\n        \r\n        uint Im_DealerUserId = Im_GameUnit_Instance.Dealer_UserId;\r\n        uint[] memory WeR_WinnerId;\r\n        uint[] memory WeR_LoserId;\r\n        \r\n        if (Hit_or_Stand) \r\n        {\r\n            Im_GameRoundUnit_StorageInstance.Cards_InDealer = GetCard({_Im_GameRoundId: Im_RoundId, _Im_Original_CardInHand: Im_GameRoundUnit_StorageInstance.Cards_InDealer});\r\n            \r\n            return Im_GameRoundUnit_StorageInstance.Cards_InDealer;\r\n        } \r\n        else if (Hit_or_Stand == false) \r\n        {\r\n            //Get winner and loser\r\n            (WeR_WinnerId, WeR_LoserId) = Determine_Result({_GameId: GameId,_RoundId: Im_RoundId});\r\n            \r\n            //Transfer moneymoney to winners\r\n            for(uint Im_WinnerCounter = 0; Im_WinnerCounter <= WeR_WinnerId.length ; Im_WinnerCounter++) \r\n            {\r\n                uint Im_WinnerUserId = WeR_WinnerId[Im_WinnerCounter];\r\n                uint Im_WinnerBettingAmount = Mapping__GameRoundIdUserId_Bettings[Im_RoundId][Im_WinnerUserId];\r\n\r\n                Mapping__OwnerUserId_ERC20Amount[Im_DealerUserId] - Im_WinnerBettingAmount;\r\n                Mapping__OwnerUserId_ERC20Amount[Im_WinnerUserId] + Im_WinnerBettingAmount;\r\n            }\r\n\r\n            //Transfer moneymoney from losers          \r\n            for(uint Im_LoserCounter = 0; Im_LoserCounter <= WeR_LoserId.length ; Im_LoserCounter++) \r\n            {\r\n                uint Im_LoserUserId = WeR_WinnerId[Im_LoserCounter];\r\n                uint Im_LoserBettingAmount = Mapping__GameRoundIdUserId_Bettings[Im_RoundId][Im_LoserUserId];\r\n\r\n                Mapping__OwnerUserId_ERC20Amount[Im_DealerUserId] + Im_LoserBettingAmount;\r\n                Mapping__OwnerUserId_ERC20Amount[Im_LoserUserId] - Im_LoserBettingAmount;\r\n            }\r\n\r\n            //Create New Round ID\r\n            ImCounter_GameRoundId = ImCounter_GameRoundId + 1;\r\n            Mapping__GameUnitId_GameUnitStruct[GameId].Game_RoundsIds.push(ImCounter_GameRoundId);\r\n\r\n            return Im_GameRoundUnit_StorageInstance.Cards_InDealer;\r\n        }\r\n    }\r\n\r\n}\r\n/* =================================================================\r\nContact HEAD : Integration User Workflow\r\n==================================================================== */\r\n//Ver1.0 - Worship Lu Goddess Forever\r\n//Created by meowent@gmail.com","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_Code\",\"type\":\"uint256\"},{\"name\":\"_Value\",\"type\":\"uint256\"}],\"name\":\"Set_EmergencyCode\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"cfoAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"GameId\",\"type\":\"uint256\"}],\"name\":\"Start_NewRound\",\"outputs\":[{\"name\":\"StartRoundId\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TotalERC20Amount_LuToken\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ceoAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"GameId\",\"type\":\"uint256\"},{\"name\":\"Hit_or_Stand\",\"type\":\"bool\"}],\"name\":\"Dealer_HitOrStand\",\"outputs\":[{\"name\":\"Cards_InDealerHand\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_Address\",\"type\":\"address\"},{\"name\":\"_Data\",\"type\":\"bytes\"}],\"name\":\"Im_CommandShell\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ImCounter_GameRoundId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"PlayerIds\",\"type\":\"uint256[]\"},{\"name\":\"MIN_BettingLimit\",\"type\":\"uint256\"},{\"name\":\"MAX_BettingLimit\",\"type\":\"uint256\"}],\"name\":\"Create_DualGame\",\"outputs\":[{\"name\":\"_CreateGameId\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newCMO\",\"type\":\"address\"}],\"name\":\"setCMO\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"Mapping__OwnerUserId_ERC20Amount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"LuGoddess\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ImCounter_AutoGameId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"GameId\",\"type\":\"uint256\"},{\"name\":\"Im_BettingsERC20Ammount\",\"type\":\"uint256\"}],\"name\":\"Player_Bettings\",\"outputs\":[{\"name\":\"_GameId\",\"type\":\"uint256\"},{\"name\":\"GameRoundId\",\"type\":\"uint256\"},{\"name\":\"BettingAmount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newCEO\",\"type\":\"address\"}],\"name\":\"setCEO\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newCOO\",\"type\":\"address\"}],\"name\":\"setCOO\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"Donate_LuGoddess\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ImCounter_DualGameId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"C_Meow_O_Address\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"AutoGame_BettingRank\",\"type\":\"uint256\"}],\"name\":\"Create_AutoGame\",\"outputs\":[{\"name\":\"_CreateGameId\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newCFO\",\"type\":\"address\"}],\"name\":\"setCFO\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"Mapping__GameRoundIdUserId_Bettings\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_UserId\",\"type\":\"uint256\"}],\"name\":\"Exchange_ETH2LuToken\",\"outputs\":[{\"name\":\"UserId\",\"type\":\"uint256\"},{\"name\":\"GetLuTokenAmount\",\"type\":\"uint256\"},{\"name\":\"AccountRemainLuToken\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_Card_InHand\",\"type\":\"uint256[]\"}],\"name\":\"Counting_HandCardPoint\",\"outputs\":[{\"name\":\"_TotalPoint\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"code\",\"type\":\"uint256\"}],\"name\":\"Use_EmergencyCode\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_Amount\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_RankNumber\",\"type\":\"uint256\"},{\"name\":\"_MinimunBetting\",\"type\":\"uint256\"},{\"name\":\"_MaximunBetting\",\"type\":\"uint256\"}],\"name\":\"SettingAutoGame_BettingRankRange\",\"outputs\":[{\"name\":\"RankNumber\",\"type\":\"uint256\"},{\"name\":\"MinimunBetting\",\"type\":\"uint256\"},{\"name\":\"MaximunBetting\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenOwner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_GetPayAddress\",\"type\":\"address\"},{\"name\":\"LuTokenAmount\",\"type\":\"uint256\"}],\"name\":\"Exchange_LuToken2ETH\",\"outputs\":[{\"name\":\"SuccessMessage\",\"type\":\"bool\"},{\"name\":\"PayerUserId\",\"type\":\"uint256\"},{\"name\":\"GetPayAddress\",\"type\":\"address\"},{\"name\":\"PayETH_Amount\",\"type\":\"uint256\"},{\"name\":\"AccountRemainLuToken\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"Mapping__AutoGameBettingRank_BettingRange\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"Mapping__GameRoundId_GameRoundStruct\",\"outputs\":[{\"name\":\"GameRoundId\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_Im_Cute_Input_Number\",\"type\":\"uint256\"}],\"name\":\"GetRandom_In52\",\"outputs\":[{\"name\":\"_Im_Random\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"cooAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"Im_BlackJack_CardFigureToPoint\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"Mapping__UserId_UserAccountStruct\",\"outputs\":[{\"name\":\"UserId\",\"type\":\"uint256\"},{\"name\":\"UserAddress\",\"type\":\"address\"},{\"name\":\"UserName\",\"type\":\"string\"},{\"name\":\"UserDescription\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_Card_Number\",\"type\":\"uint256\"}],\"name\":\"Counting_CardPoint\",\"outputs\":[{\"name\":\"_CardPoint\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"UserId\",\"type\":\"uint256\"},{\"name\":\"UserName\",\"type\":\"string\"},{\"name\":\"UserDescription\",\"type\":\"string\"}],\"name\":\"Create_UserAccount\",\"outputs\":[{\"name\":\"_UserId\",\"type\":\"uint256\"},{\"name\":\"_UserAddress\",\"type\":\"address\"},{\"name\":\"_UserName\",\"type\":\"string\"},{\"name\":\"_UserDescription\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"GameId\",\"type\":\"uint256\"},{\"name\":\"Hit_or_Stand\",\"type\":\"bool\"}],\"name\":\"Player_HitOrStand\",\"outputs\":[{\"name\":\"NewCards_InHand\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"Mapping__OwnerUserIdAlloweUserId_ERC20Amount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenOwner\",\"type\":\"address\"},{\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"Deposit\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_Address\",\"type\":\"address\"}],\"name\":\"Worship_LuGoddess\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"Mapping__GameUnitId_GameUnitStruct\",\"outputs\":[{\"name\":\"Game_UnitId\",\"type\":\"uint256\"},{\"name\":\"Dealer_UserId\",\"type\":\"uint256\"},{\"name\":\"MIN_BettingLimit\",\"type\":\"uint256\"},{\"name\":\"MAX_BettingLimit\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"From\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"Amount\",\"type\":\"uint256\"}],\"name\":\"BankDeposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"From\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"Amount\",\"type\":\"uint256\"}],\"name\":\"BankWithdrawal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_UserIdEvent\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_UserAddressEvent\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_UserNameEvent\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"_UserDescriptionEvent\",\"type\":\"string\"}],\"name\":\"Create_UserAccountEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_GameIdEvent\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_Player_UserIdsEvent\",\"type\":\"uint256[]\"},{\"indexed\":false,\"name\":\"_Dealer_UserIdEvent\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_MIN_BettingLimitEvent\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_MAX_BettingLimitEvent\",\"type\":\"uint256\"}],\"name\":\"Initialize_GameEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_GameIdEvent\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_GameRoundIdEvent\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_UserIdEvent\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_BettingAmountEvent\",\"type\":\"uint256\"}],\"name\":\"BettingsEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_PlayerUserIdSetEvent\",\"type\":\"uint256[]\"},{\"indexed\":false,\"name\":\"_GameRoundIdEvent\",\"type\":\"uint256\"}],\"name\":\"Initialize_GameRoundEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_PlayerUserIdEvent\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_BettingsEvent\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_Cards_InHandEvent\",\"type\":\"uint256[]\"}],\"name\":\"Initialize_GamePlayUnitEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_GameRoundIdEvent\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_GetCardsInHandEvent\",\"type\":\"uint256[]\"}],\"name\":\"GetCardEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_GameIdEvent\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_GameRoundIdEvent\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_WinnerUserIdEvent\",\"type\":\"uint256[]\"},{\"indexed\":false,\"name\":\"_DrawUserIdEvent\",\"type\":\"uint256[]\"},{\"indexed\":false,\"name\":\"_LoserUserIdEvent\",\"type\":\"uint256[]\"}],\"name\":\"Determine_GameRoundResult\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_ETH_AddressEvent\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_ETH_ExchangeAmountEvent\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_LuToken_UserIdEvnet\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_LuToken_ExchangeAmountEvnet\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_LuToken_RemainAmountEvent\",\"type\":\"uint256\"}],\"name\":\"ExchangeLuTokenEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"GameRoundId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"UserId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"UserBettingAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"MinBettingLimit\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"MaxBettingLimit\",\"type\":\"uint256\"}],\"name\":\"CheckBetting_Anouncement\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"tokenOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"Lets_Play_Blackjack","CompilerVersion":"v0.5.3+commit.10d17f24","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://a40991c65cdfa0b45440df7952dcf41c5ea98f64f264e5f4cf744fff5f6c9ab6"}]}