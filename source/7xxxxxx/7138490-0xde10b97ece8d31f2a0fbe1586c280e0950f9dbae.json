{"status":"1","message":"OK","result":[{"SourceCode":"// Verified using https://dapp.tools\n\n// hevm: flattened sources of src/EscrowData.sol\npragma solidity ^0.4.24;\n\n////// lib/ds-auth/src/auth.sol\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n/* pragma solidity >=0.4.23; */\n\ncontract DSAuthority {\n    function canCall(\n        address src, address dst, bytes4 sig\n    ) public view returns (bool);\n}\n\ncontract DSAuthEvents {\n    event LogSetAuthority (address indexed authority);\n    event LogSetOwner     (address indexed owner);\n}\n\ncontract DSAuth is DSAuthEvents {\n    DSAuthority  public  authority;\n    address      public  owner;\n\n    constructor() public {\n        owner = msg.sender;\n        emit LogSetOwner(msg.sender);\n    }\n\n    function setOwner(address owner_)\n        public\n        auth\n    {\n        owner = owner_;\n        emit LogSetOwner(owner);\n    }\n\n    function setAuthority(DSAuthority authority_)\n        public\n        auth\n    {\n        authority = authority_;\n        emit LogSetAuthority(address(authority));\n    }\n\n    modifier auth {\n        require(isAuthorized(msg.sender, msg.sig), \"ds-auth-unauthorized\");\n        _;\n    }\n\n    function isAuthorized(address src, bytes4 sig) internal view returns (bool) {\n        if (src == address(this)) {\n            return true;\n        } else if (src == owner) {\n            return true;\n        } else if (authority == DSAuthority(0)) {\n            return false;\n        } else {\n            return authority.canCall(src, address(this), sig);\n        }\n    }\n}\n\n////// lib/ds-math/src/math.sol\n/// math.sol -- mixin for inline numerical wizardry\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n/* pragma solidity >0.4.13; */\n\ncontract DSMath {\n    function add(uint x, uint y) internal pure returns (uint z) {\n        require((z = x + y) >= x, \"ds-math-add-overflow\");\n    }\n    function sub(uint x, uint y) internal pure returns (uint z) {\n        require((z = x - y) <= x, \"ds-math-sub-underflow\");\n    }\n    function mul(uint x, uint y) internal pure returns (uint z) {\n        require(y == 0 || (z = x * y) / y == x, \"ds-math-mul-overflow\");\n    }\n\n    function min(uint x, uint y) internal pure returns (uint z) {\n        return x <= y ? x : y;\n    }\n    function max(uint x, uint y) internal pure returns (uint z) {\n        return x >= y ? x : y;\n    }\n    function imin(int x, int y) internal pure returns (int z) {\n        return x <= y ? x : y;\n    }\n    function imax(int x, int y) internal pure returns (int z) {\n        return x >= y ? x : y;\n    }\n\n    uint constant WAD = 10 ** 18;\n    uint constant RAY = 10 ** 27;\n\n    function wmul(uint x, uint y) internal pure returns (uint z) {\n        z = add(mul(x, y), WAD / 2) / WAD;\n    }\n    function rmul(uint x, uint y) internal pure returns (uint z) {\n        z = add(mul(x, y), RAY / 2) / RAY;\n    }\n    function wdiv(uint x, uint y) internal pure returns (uint z) {\n        z = add(mul(x, WAD), y / 2) / y;\n    }\n    function rdiv(uint x, uint y) internal pure returns (uint z) {\n        z = add(mul(x, RAY), y / 2) / y;\n    }\n\n    // This famous algorithm is called \"exponentiation by squaring\"\n    // and calculates x^n with x as fixed-point and n as regular unsigned.\n    //\n    // It's O(log n), instead of O(n) for naive repeated multiplication.\n    //\n    // These facts are why it works:\n    //\n    //  If n is even, then x^n = (x^2)^(n/2).\n    //  If n is odd,  then x^n = x * x^(n-1),\n    //   and applying the equation for even x gives\n    //    x^n = x * (x^2)^((n-1) / 2).\n    //\n    //  Also, EVM division is flooring and\n    //    floor[(n-1) / 2] = floor[n / 2].\n    //\n    function rpow(uint x, uint n) internal pure returns (uint z) {\n        z = n % 2 != 0 ? x : RAY;\n\n        for (n /= 2; n != 0; n /= 2) {\n            x = rmul(x, x);\n\n            if (n % 2 != 0) {\n                z = rmul(z, x);\n            }\n        }\n    }\n}\n\n////// lib/ds-token/lib/ds-stop/lib/ds-note/src/note.sol\n/// note.sol -- the `note' modifier, for logging calls as events\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n/* pragma solidity >=0.4.23; */\n\ncontract DSNote {\n    event LogNote(\n        bytes4   indexed  sig,\n        address  indexed  guy,\n        bytes32  indexed  foo,\n        bytes32  indexed  bar,\n        uint256           wad,\n        bytes             fax\n    ) anonymous;\n\n    modifier note {\n        bytes32 foo;\n        bytes32 bar;\n        uint256 wad;\n\n        assembly {\n            foo := calldataload(4)\n            bar := calldataload(36)\n            wad := callvalue\n        }\n\n        emit LogNote(msg.sig, msg.sender, foo, bar, wad, msg.data);\n\n        _;\n    }\n}\n\n////// lib/ds-token/lib/ds-stop/src/stop.sol\n/// stop.sol -- mixin for enable/disable functionality\n\n// Copyright (C) 2017  DappHub, LLC\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n/* pragma solidity >=0.4.23; */\n\n/* import \"ds-auth/auth.sol\"; */\n/* import \"ds-note/note.sol\"; */\n\ncontract DSStop is DSNote, DSAuth {\n    bool public stopped;\n\n    modifier stoppable {\n        require(!stopped, \"ds-stop-is-stopped\");\n        _;\n    }\n    function stop() public auth note {\n        stopped = true;\n    }\n    function start() public auth note {\n        stopped = false;\n    }\n\n}\n\n////// lib/ds-token/lib/erc20/src/erc20.sol\n/// erc20.sol -- API for the ERC20 token standard\n\n// See <https://github.com/ethereum/EIPs/issues/20>.\n\n// This file likely does not meet the threshold of originality\n// required for copyright to apply.  As a result, this is free and\n// unencumbered software belonging to the public domain.\n\n/* pragma solidity >0.4.20; */\n\ncontract ERC20Events {\n    event Approval(address indexed src, address indexed guy, uint wad);\n    event Transfer(address indexed src, address indexed dst, uint wad);\n}\n\ncontract ERC20 is ERC20Events {\n    function totalSupply() public view returns (uint);\n    function balanceOf(address guy) public view returns (uint);\n    function allowance(address src, address guy) public view returns (uint);\n\n    function approve(address guy, uint wad) public returns (bool);\n    function transfer(address dst, uint wad) public returns (bool);\n    function transferFrom(\n        address src, address dst, uint wad\n    ) public returns (bool);\n}\n\n////// lib/ds-token/src/base.sol\n/// base.sol -- basic ERC20 implementation\n\n// Copyright (C) 2015, 2016, 2017  DappHub, LLC\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n/* pragma solidity >=0.4.23; */\n\n/* import \"erc20/erc20.sol\"; */\n/* import \"ds-math/math.sol\"; */\n\ncontract DSTokenBase is ERC20, DSMath {\n    uint256                                            _supply;\n    mapping (address => uint256)                       _balances;\n    mapping (address => mapping (address => uint256))  _approvals;\n\n    constructor(uint supply) public {\n        _balances[msg.sender] = supply;\n        _supply = supply;\n    }\n\n    function totalSupply() public view returns (uint) {\n        return _supply;\n    }\n    function balanceOf(address src) public view returns (uint) {\n        return _balances[src];\n    }\n    function allowance(address src, address guy) public view returns (uint) {\n        return _approvals[src][guy];\n    }\n\n    function transfer(address dst, uint wad) public returns (bool) {\n        return transferFrom(msg.sender, dst, wad);\n    }\n\n    function transferFrom(address src, address dst, uint wad)\n        public\n        returns (bool)\n    {\n        if (src != msg.sender) {\n            require(_approvals[src][msg.sender] >= wad, \"ds-token-insufficient-approval\");\n            _approvals[src][msg.sender] = sub(_approvals[src][msg.sender], wad);\n        }\n\n        require(_balances[src] >= wad, \"ds-token-insufficient-balance\");\n        _balances[src] = sub(_balances[src], wad);\n        _balances[dst] = add(_balances[dst], wad);\n\n        emit Transfer(src, dst, wad);\n\n        return true;\n    }\n\n    function approve(address guy, uint wad) public returns (bool) {\n        _approvals[msg.sender][guy] = wad;\n\n        emit Approval(msg.sender, guy, wad);\n\n        return true;\n    }\n}\n\n////// lib/ds-token/src/token.sol\n/// token.sol -- ERC20 implementation with minting and burning\n\n// Copyright (C) 2015, 2016, 2017  DappHub, LLC\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n/* pragma solidity >=0.4.23; */\n\n/* import \"ds-stop/stop.sol\"; */\n\n/* import \"./base.sol\"; */\n\ncontract DSToken is DSTokenBase(0), DSStop {\n\n    bytes32  public  symbol;\n    uint256  public  decimals = 18; // standard token precision. override to customize\n\n    constructor(bytes32 symbol_) public {\n        symbol = symbol_;\n    }\n\n    event Mint(address indexed guy, uint wad);\n    event Burn(address indexed guy, uint wad);\n\n    function approve(address guy) public stoppable returns (bool) {\n        return super.approve(guy, uint(-1));\n    }\n\n    function approve(address guy, uint wad) public stoppable returns (bool) {\n        return super.approve(guy, wad);\n    }\n\n    function transferFrom(address src, address dst, uint wad)\n        public\n        stoppable\n        returns (bool)\n    {\n        if (src != msg.sender && _approvals[src][msg.sender] != uint(-1)) {\n            require(_approvals[src][msg.sender] >= wad, \"ds-token-insufficient-approval\");\n            _approvals[src][msg.sender] = sub(_approvals[src][msg.sender], wad);\n        }\n\n        require(_balances[src] >= wad, \"ds-token-insufficient-balance\");\n        _balances[src] = sub(_balances[src], wad);\n        _balances[dst] = add(_balances[dst], wad);\n\n        emit Transfer(src, dst, wad);\n\n        return true;\n    }\n\n    function push(address dst, uint wad) public {\n        transferFrom(msg.sender, dst, wad);\n    }\n    function pull(address src, uint wad) public {\n        transferFrom(src, msg.sender, wad);\n    }\n    function move(address src, address dst, uint wad) public {\n        transferFrom(src, dst, wad);\n    }\n\n    function mint(uint wad) public {\n        mint(msg.sender, wad);\n    }\n    function burn(uint wad) public {\n        burn(msg.sender, wad);\n    }\n    function mint(address guy, uint wad) public auth stoppable {\n        _balances[guy] = add(_balances[guy], wad);\n        _supply = add(_supply, wad);\n        emit Mint(guy, wad);\n    }\n    function burn(address guy, uint wad) public auth stoppable {\n        if (guy != msg.sender && _approvals[guy][msg.sender] != uint(-1)) {\n            require(_approvals[guy][msg.sender] >= wad, \"ds-token-insufficient-approval\");\n            _approvals[guy][msg.sender] = sub(_approvals[guy][msg.sender], wad);\n        }\n\n        require(_balances[guy] >= wad, \"ds-token-insufficient-balance\");\n        _balances[guy] = sub(_balances[guy], wad);\n        _supply = sub(_supply, wad);\n        emit Burn(guy, wad);\n    }\n\n    // Optional token name\n    bytes32   public  name = \"\";\n\n    function setName(bytes32 name_) public auth {\n        name = name_;\n    }\n}\n\n////// src/EscrowDataInterface.sol\n/* pragma solidity ^0.4.24; */\n\n/* import \"ds-token/token.sol\"; */\n\ninterface EscrowDataInterface\n{\n    ///@notice Create and fund a new escrow.\n    function createEscrow(\n        bytes32 _tradeId, \n        DSToken _token, \n        address _buyer, \n        address _seller, \n        uint256 _value, \n        uint16 _fee,\n        uint32 _paymentWindowInSeconds\n    ) external returns(bool);\n\n    function getEscrow(\n        bytes32 _tradeHash\n    ) external returns(bool, uint32, uint128);\n\n    function removeEscrow(\n        bytes32 _tradeHash\n    ) external returns(bool);\n\n    function updateSellerCanCancelAfter(\n        bytes32 _tradeHash,\n        uint32 _paymentWindowInSeconds\n    ) external returns(bool);\n\n    function increaseTotalGasFeesSpentByRelayer(\n        bytes32 _tradeHash,\n        uint128 _increaseGasFees\n    ) external returns(bool);\n}\n////// src/EscrowData.sol\n/* pragma solidity ^0.4.24; */\n\n/* import \"ds-auth/auth.sol\"; */\n/* import \"ds-token/token.sol\"; */\n/* import \"./EscrowDataInterface.sol\"; */\n\n// contract EscrowData is EscrowDataInterface, DSAuth\ncontract EscrowData is DSAuth, EscrowDataInterface\n{\n    address public dexc2c;\n\n    event SetDexC2C(address caller, address dexc2c);\n    event Created(bytes32 _tradeHash);\n    event Removed(bytes32 _tradeHash);\n    event Updated(bytes32 _tradeHash, uint32 _sellerCanCancelAfter);\n\n    mapping (bytes32 => Escrow) public escrows;\n    struct Escrow\n    {\n        bool exists;\n        // This is the timestamp in which the seller can cancel the escrow after\n        uint32 sellerCanCancelAfter;\n        uint128 totalGasFeesSpentByRelayer;\n    }\n\n    function setDexC2C(address _dexc2c)public auth returns(bool){\n        require(_dexc2c != address(0x00), \"DEXC2C address error\");\n        dexc2c = _dexc2c;\n        emit SetDexC2C(msg.sender, _dexc2c);\n        return true;\n    }\n\n    modifier onlyDexc2c(){\n        require(msg.sender == dexc2c, \"Must be dexc2c\");\n        _;\n    }\n\n    function createEscrow(\n        bytes32 _tradeId,\n        DSToken _tradeToken,\n        address _buyer,\n        address _seller,\n        uint256 _value,\n        uint16 _fee,\n        uint32 _paymentWindowInSeconds\n    ) public onlyDexc2c returns(bool){\n        bytes32 _tradeHash = keccak256(abi.encodePacked(_tradeId, _tradeToken, _buyer, _seller, _value, _fee));\n        require(!escrows[_tradeHash].exists, \"Trade already exists\");\n        uint32 _sellerCanCancelAfter = uint32(block.timestamp) + _paymentWindowInSeconds;\n    \n        escrows[_tradeHash] = Escrow(true, _sellerCanCancelAfter, 0);\n        emit Created(_tradeHash);\n        return true;\n    }\n\n    function getEscrow(\n        bytes32 _tradeHash\n    ) public view returns (bool, uint32, uint128){\n        Escrow memory escrow = escrows[_tradeHash];\n        if(escrow.exists){\n            return (escrow.exists, escrow.sellerCanCancelAfter, escrow.totalGasFeesSpentByRelayer);\n        }\n        return (false, 0, 0);\n    }\n\n    function exists(\n        bytes32 _tradeHash\n    ) public view returns(bool){\n        return escrows[_tradeHash].exists;\n    }\n\n    function removeEscrow(\n        bytes32 _tradeHash\n    ) public onlyDexc2c returns(bool){\n        require(escrows[_tradeHash].exists, \"Escrow not exists\");\n        delete escrows[_tradeHash];\n        emit Removed(_tradeHash);\n        return true;\n    }\n\n    function updateSellerCanCancelAfter(\n        bytes32 _tradeHash,\n        uint32 _paymentWindowInSeconds\n    ) public onlyDexc2c returns(bool){\n        require(escrows[_tradeHash].exists, \"Escrow not exists\");\n        uint32 _sellerCanCancelAfter = uint32(block.timestamp) + _paymentWindowInSeconds;\n        escrows[_tradeHash].sellerCanCancelAfter = _sellerCanCancelAfter;\n        emit Updated(_tradeHash, _sellerCanCancelAfter);\n        return true;\n    }\n\n    function increaseTotalGasFeesSpentByRelayer(\n        bytes32 _tradeHash,\n        uint128 _increaseGasFees\n    ) public onlyDexc2c returns(bool){\n        require(escrows[_tradeHash].exists, \"Escrow not exists\");\n        escrows[_tradeHash].totalGasFeesSpentByRelayer += _increaseGasFees;\n        return true;\n    }\n\n}\n","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"owner_\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tradeHash\",\"type\":\"bytes32\"},{\"name\":\"_increaseGasFees\",\"type\":\"uint128\"}],\"name\":\"increaseTotalGasFeesSpentByRelayer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"escrows\",\"outputs\":[{\"name\":\"exists\",\"type\":\"bool\"},{\"name\":\"sellerCanCancelAfter\",\"type\":\"uint32\"},{\"name\":\"totalGasFeesSpentByRelayer\",\"type\":\"uint128\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tradeId\",\"type\":\"bytes32\"},{\"name\":\"_tradeToken\",\"type\":\"address\"},{\"name\":\"_buyer\",\"type\":\"address\"},{\"name\":\"_seller\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_fee\",\"type\":\"uint16\"},{\"name\":\"_paymentWindowInSeconds\",\"type\":\"uint32\"}],\"name\":\"createEscrow\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tradeHash\",\"type\":\"bytes32\"}],\"name\":\"exists\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"authority_\",\"type\":\"address\"}],\"name\":\"setAuthority\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"dexc2c\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tradeHash\",\"type\":\"bytes32\"}],\"name\":\"removeEscrow\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"authority\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_dexc2c\",\"type\":\"address\"}],\"name\":\"setDexC2C\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tradeHash\",\"type\":\"bytes32\"},{\"name\":\"_paymentWindowInSeconds\",\"type\":\"uint32\"}],\"name\":\"updateSellerCanCancelAfter\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tradeHash\",\"type\":\"bytes32\"}],\"name\":\"getEscrow\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"},{\"name\":\"\",\"type\":\"uint32\"},{\"name\":\"\",\"type\":\"uint128\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"dexc2c\",\"type\":\"address\"}],\"name\":\"SetDexC2C\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_tradeHash\",\"type\":\"bytes32\"}],\"name\":\"Created\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_tradeHash\",\"type\":\"bytes32\"}],\"name\":\"Removed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_tradeHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"_sellerCanCancelAfter\",\"type\":\"uint32\"}],\"name\":\"Updated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"authority\",\"type\":\"address\"}],\"name\":\"LogSetAuthority\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"LogSetOwner\",\"type\":\"event\"}]","ContractName":"EscrowData","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://7383f5082b88969a951548477a8e4e0a437562c99957c01e1dd3a89674ce0796"}]}