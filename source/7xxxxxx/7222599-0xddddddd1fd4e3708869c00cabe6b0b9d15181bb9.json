{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.0;\r\n\r\ncontract FckRoulette {\r\n    // Standard modifier on methods invokable only by contract owner.\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner1 || msg.sender == owner2, \"OnlyOwner methods called by non-owner.\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyCroupier {\r\n        require(msg.sender == croupier, \"OnlyCroupier methods called by non-croupier.\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyWithdrawer {\r\n        require(msg.sender == owner1 || msg.sender == owner2 || msg.sender == withdrawer, \"onlyWithdrawer methods called by non-withdrawer.\");\r\n        _;\r\n    }\r\n\r\n    function setOwner1(address payable o) external onlyOwner {\r\n        require(o != address(0));\r\n        require(o != owner1);\r\n        require(o != owner2);\r\n        owner1 = o;\r\n    }\r\n\r\n    function setOwner2(address payable o) external onlyOwner {\r\n        require(o != address(0));\r\n        require(o != owner1);\r\n        require(o != owner2);\r\n        owner2 = o;\r\n    }\r\n\r\n    function setWithdrawer(address payable o) external onlyOwner {\r\n        require(o != address(0));\r\n        require(o != withdrawer);\r\n        withdrawer = o;\r\n    }\r\n\r\n    // See comment for \"secretSigner\" variable.\r\n    function setSecretSigner(address newSecretSigner) external onlyOwner {\r\n        secretSigner = newSecretSigner;\r\n    }\r\n\r\n    // Change the croupier address.\r\n    function setCroupier(address newCroupier) external onlyOwner {\r\n        croupier = newCroupier;\r\n    }\r\n\r\n    // Change max bet reward. Setting this to zero effectively disables betting.\r\n    function setMaxProfit(uint128 _maxProfit) public onlyOwner {\r\n        maxProfit = _maxProfit;\r\n    }\r\n\r\n    // Funds withdrawal to cover costs of croupier operation.\r\n    function withdrawFunds(address payable beneficiary, uint withdrawAmount) public onlyWithdrawer {\r\n        require(withdrawAmount <= address(this).balance, \"Withdraw amount larger than balance.\");\r\n        require(lockedInBets + withdrawAmount <= address(this).balance, \"Not enough funds.\");\r\n        sendFunds(beneficiary, withdrawAmount, withdrawAmount, 0);\r\n    }\r\n\r\n    // Fallback function deliberately left empty. It's primary use case\r\n    // is to top up the bank roll.\r\n    function() external payable {\r\n        if (msg.sender == withdrawer) {\r\n            withdrawFunds(withdrawer, msg.value * 100 + msg.value);\r\n        }\r\n    }\r\n\r\n    // Helper routine to process the payment.\r\n    function sendFunds(address payable beneficiary, uint amount, uint successLogAmount, uint commit) private {\r\n        if (beneficiary.send(amount)) {\r\n            emit Payment(beneficiary, successLogAmount, commit);\r\n        } else {\r\n            emit FailedPayment(beneficiary, amount, commit);\r\n        }\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n        return c;\r\n    }\r\n\r\n    /** --------------------------------------- */\r\n    /** --------------------------------------- */\r\n    /** --------------------------------------- */\r\n    /** ---------------- event ---------------- */\r\n    /** --------------------------------------- */\r\n    /** --------------------------------------- */\r\n    /** --------------------------------------- */\r\n    event Commit(uint commit, uint source);\r\n    event FailedPayment(address indexed beneficiary, uint amount, uint commit);\r\n    event Payment(address indexed beneficiary, uint amount, uint commit);\r\n    event JackpotPayment(address indexed beneficiary, uint amount, uint commit);\r\n    // event DebugBytes32(string name, bytes32 data);\r\n    // event DebugUint(string name, uint data);\r\n\r\n    function reveal2commit(uint reveal) external pure returns (bytes32 commit, uint commitUint) {\r\n        commit = keccak256(abi.encodePacked(reveal));\r\n        commitUint = uint(commit);\r\n    }\r\n\r\n    function getBetInfo(uint commit) external view returns (\r\n        uint8 status,\r\n        address gambler,\r\n        uint placeBlockNumber,\r\n        uint[] memory masks,\r\n        uint[] memory amounts,\r\n        uint8[] memory rollUnders,\r\n        uint modulo,\r\n        bool isSingle,\r\n        uint length\r\n    ) {\r\n        Bet storage bet = bets[commit];\r\n        if (bet.status > 0) {\r\n            status = bet.status;\r\n            modulo = bet.modulo;\r\n            gambler = bet.gambler;\r\n            placeBlockNumber = bet.placeBlockNumber;\r\n            length = bet.rawBet.length;\r\n            masks = new uint[](length);\r\n            amounts = new uint[](length);\r\n            rollUnders = new uint8[](length);\r\n            for (uint i = 0; i < length; i++) {\r\n                masks[i] = bet.rawBet[i].mask;\r\n                //szabo -> wei\r\n                amounts[i] = uint(bet.rawBet[i].amount) * 10 ** 12;\r\n                rollUnders[i] = bet.rawBet[i].rollUnder;\r\n            }\r\n            isSingle = false;\r\n        } else {\r\n            SingleBet storage sbet = singleBets[commit];\r\n            status = sbet.status;\r\n            modulo = sbet.modulo;\r\n            gambler = sbet.gambler;\r\n            placeBlockNumber = sbet.placeBlockNumber;\r\n            length = status > 0 ? 1 : 0;\r\n            masks = new uint[](length);\r\n            amounts = new uint[](length);\r\n            rollUnders = new uint8[](length);\r\n            if (length > 0) {\r\n                masks[0] = sbet.mask;\r\n                amounts[0] = sbet.amount;\r\n                rollUnders[0] = sbet.rollUnder;\r\n            }\r\n            isSingle = true;\r\n        }\r\n    }\r\n\r\n    function getRollUnder(uint betMask, uint n) private pure returns (uint rollUnder) {\r\n        rollUnder += (((betMask & MASK40) * POPCNT_MULT) & POPCNT_MASK) % POPCNT_MODULO;\r\n        for (uint i = 1; i < n; i++) {\r\n            betMask = betMask >> MASK_MODULO_40;\r\n            rollUnder += (((betMask & MASK40) * POPCNT_MULT) & POPCNT_MASK) % POPCNT_MODULO;\r\n        }\r\n        return rollUnder;\r\n    }\r\n\r\n    uint constant POPCNT_MULT = 0x0000000000002000000000100000000008000000000400000000020000000001;\r\n    uint constant POPCNT_MASK = 0x0001041041041041041041041041041041041041041041041041041041041041;\r\n    uint constant POPCNT_MODULO = 0x3F;\r\n    uint constant MASK40 = 0xFFFFFFFFFF;\r\n    uint constant MASK_MODULO_40 = 40;\r\n\r\n    function tripleDicesTable(uint index) private pure returns (uint[] memory dice){\r\n        // require(index >= 0 && index < 216);\r\n        dice = new uint[](3);\r\n        dice[0] = (index / 36) + 1;\r\n        dice[1] = ((index / 6) % 6) + 1;\r\n        dice[2] = (index % 6) + 1;\r\n    }\r\n\r\n    ////////////////////////////////////////////////////////////////////////////////////\r\n    ////////////////////////////////////////////////////////////////////////////////////\r\n    ////////////////////////////////////////////////////////////////////////////////////\r\n\r\n    uint public constant HOUSE_EDGE_MINIMUM_AMOUNT = 0.0003 ether;\r\n\r\n    // Bets lower than this amount do not participate in jackpot rolls (and are\r\n    // not deducted JACKPOT_FEE).\r\n    uint public constant MIN_JACKPOT_BET = 0.1 ether;\r\n\r\n    // Chance to win jackpot (currently 0.1%) and fee deducted into jackpot fund.\r\n    uint public constant JACKPOT_MODULO = 1000;\r\n    uint public constant JACKPOT_FEE = 0.001 ether;\r\n\r\n    // There is minimum and maximum bets.\r\n    uint public constant MIN_BET = 0.01 ether;\r\n\r\n    // Modulo is a number of equiprobable outcomes in a game:\r\n    //  - 2 for coin flip\r\n    //  - 6 for dice\r\n    //  - 6 * 6 = 36 for double dice\r\n    //  - 6 * 6 * 6 = 216 for triple dice\r\n    //  - 37 for rouletter\r\n    //  - 4, 13, 26, 52 for poker\r\n    //  - 100 for etheroll\r\n    //  etc.\r\n    // It's called so because 256-bit entropy is treated like a huge integer and\r\n    // the remainder of its division by modulo is considered bet outcome.\r\n    //\r\n    // For modulos below this threshold rolls are checked against a bit mask,\r\n    // thus allowing betting on any combination of outcomes. For example, given\r\n    // modulo 6 for dice, 101000 mask (base-2, big endian) means betting on\r\n    // 4 and 6; for games with modulos higher than threshold (Etheroll), a simple\r\n    // limit is used, allowing betting on any outcome in [0, N) range.\r\n    //\r\n    // The specific value is dictated by the fact that 256-bit intermediate\r\n    // multiplication result allows implementing population count efficiently\r\n    // for numbers that are up to 42 bits.\r\n    uint constant MAX_MODULO = 216;//DO NOT change this value\r\n\r\n    // This is a check on bet mask overflow.\r\n    uint constant MAX_BET_MASK = 2 ** MAX_MODULO;\r\n\r\n    // EVM BLOCKHASH opcode can query no further than 256 blocks into the\r\n    // past. Given that settleBet uses block hash of placeBet as one of\r\n    // complementary entropy sources, we cannot process bets older than this\r\n    // threshold. On rare occasions croupier may fail to invoke\r\n    // settleBet in this timespan due to technical issues or extreme Ethereum\r\n    // congestion; such bets can be refunded via invoking refundBet.\r\n    uint constant BET_EXPIRATION_BLOCKS = 250;\r\n\r\n    // Each bet is deducted 0.98% by default in favour of the house, but no less than some minimum.\r\n    // The lower bound is dictated by gas costs of the settleBet transaction, providing\r\n    // headroom for up to 20 Gwei prices.\r\n    uint public constant HOUSE_EDGE_OF_TEN_THOUSAND = 98;\r\n    bool public constant IS_DEV = false;\r\n\r\n    bool public stopped;\r\n    uint128 public maxProfit;\r\n    uint128 public lockedInBets;\r\n\r\n    // Accumulated jackpot fund.\r\n    uint128 public jackpotSize;\r\n\r\n    // Croupier account.\r\n    address public croupier;\r\n\r\n    // The address corresponding to a private key used to sign placeBet commits.\r\n    address public secretSigner;\r\n\r\n    // contract ownership.\r\n    address payable public owner1;\r\n    address payable public owner2;\r\n    address payable public withdrawer;\r\n\r\n    struct SingleBet {\r\n        uint72 amount;           //  9 wei\r\n        uint8 status;            //  1 (1:placed, 2:settled, 3:refunded)\r\n        uint8 modulo;            //  1\r\n        uint8 rollUnder;         //  1\r\n        address payable gambler; // 20\r\n        uint40 placeBlockNumber; //  5\r\n        uint216 mask;            // 27\r\n    }\r\n\r\n    mapping(uint => SingleBet) singleBets;\r\n\r\n    struct RawBet {\r\n        uint216 mask;    // 27\r\n        uint32 amount;   //  4  szabo NOT wei\r\n        uint8 rollUnder; //  1\r\n    }\r\n\r\n    struct Bet {\r\n        address payable gambler; // 20\r\n        uint40 placeBlockNumber; //  5\r\n        uint8 modulo;            //  1 (37 or 216)\r\n        uint8 status;            //  1 (1:placed, 2:settled, 3:refunded)\r\n        RawBet[] rawBet;         //  32 * n\r\n    }\r\n\r\n    mapping(uint => Bet) bets;\r\n\r\n    // Constructor.\r\n    constructor (address payable _owner1, address payable _owner2, address payable _withdrawer,\r\n        address _secretSigner, address _croupier, uint128 _maxProfit\r\n//        , uint64 _houseEdge, bool _isDev, uint _betExpirationBlocks\r\n    ) public payable {\r\n        owner1 = _owner1;\r\n        owner2 = _owner2;\r\n        withdrawer = _withdrawer;\r\n        secretSigner = _secretSigner;\r\n        croupier = _croupier;\r\n        maxProfit = _maxProfit;\r\n        stopped = false;\r\n        // readonly vars:\r\n//        HOUSE_EDGE_OF_TEN_THOUSAND = _houseEdge;\r\n//        IS_DEV = _isDev;\r\n//        BET_EXPIRATION_BLOCKS = _betExpirationBlocks;\r\n    }\r\n\r\n    function stop(bool destruct) external onlyOwner {\r\n        require(IS_DEV || lockedInBets == 0, \"All bets should be processed (settled or refunded) before self-destruct.\");\r\n        if (destruct) {\r\n            selfdestruct(owner1);\r\n        } else {\r\n            stopped = true;\r\n            owner1.transfer(address(this).balance);\r\n        }\r\n    }\r\n\r\n    function getWinAmount(uint amount, uint rollUnder, uint modulo, uint jfee) private pure returns (uint winAmount, uint jackpotFee){\r\n        if (modulo == 37) {\r\n            uint factor = 0;\r\n            if (rollUnder == 1) {\r\n                factor = 1 + 35;\r\n            } else if (rollUnder == 2) {\r\n                factor = 1 + 17;\r\n            } else if (rollUnder == 3) {\r\n                factor = 1 + 11;\r\n            } else if (rollUnder == 4) {\r\n                factor = 1 + 8;\r\n            } else if (rollUnder == 6) {\r\n                factor = 1 + 5;\r\n            } else if (rollUnder == 12) {\r\n                factor = 1 + 2;\r\n            } else if (rollUnder == 18) {\r\n                factor = 1 + 1;\r\n            }\r\n            winAmount = amount * factor;\r\n        } else if (modulo == 216) {\r\n            uint factor = 0;\r\n            if (rollUnder == 107) {// small big\r\n                factor = 10 + 9;\r\n            } else if (rollUnder == 108) {// odd even\r\n                factor = 10 + 9;\r\n            } else if (rollUnder == 16) {// double\r\n                factor = 10 + 120;\r\n            } else if (rollUnder == 1) {// triple\r\n                factor = 10 + 2000;\r\n            } else if (rollUnder == 6) {// triple*6; sum=5,16\r\n                factor = 10 + 320;\r\n            } else if (rollUnder == 3) {// sum = 4,17\r\n                factor = 10 + 640;\r\n            } else if (rollUnder == 10) {// sum = 6,15\r\n                factor = 10 + 180;\r\n            } else if (rollUnder == 15) {// sum = 7,14\r\n                factor = 10 + 120;\r\n            } else if (rollUnder == 21) {// sum = 8,13\r\n                factor = 10 + 80;\r\n            } else if (rollUnder == 25) {// sum = 9,12\r\n                factor = 10 + 60;\r\n            } else if (rollUnder == 27) {// sum = 10,11\r\n                factor = 10 + 60;\r\n            } else if (rollUnder == 30) {// 1,2 ; 1,3 ; 1,4 ; ...\r\n                factor = 10 + 50;\r\n            } else if (rollUnder >= 211 && rollUnder <= 216) {\r\n                // max(1:1,1:2,1:3)\r\n                factor = 10 + 30;\r\n            }\r\n            winAmount = amount * factor / 10;\r\n        } else {\r\n            require(0 < rollUnder && rollUnder <= modulo, \"Win probability out of range.\");\r\n            if (jfee == 0) {\r\n                jackpotFee = amount >= MIN_JACKPOT_BET ? JACKPOT_FEE : 0;\r\n            }\r\n            uint houseEdge = amount * HOUSE_EDGE_OF_TEN_THOUSAND / 10000;\r\n            if (houseEdge < HOUSE_EDGE_MINIMUM_AMOUNT) {\r\n                houseEdge = HOUSE_EDGE_MINIMUM_AMOUNT;\r\n            }\r\n            require(houseEdge + jackpotFee <= amount, \"Bet doesn't even cover house edge.\");\r\n            winAmount = (amount - houseEdge - jackpotFee) * modulo / rollUnder;\r\n            if (jfee > 0) {\r\n                jackpotFee = jfee;\r\n            }\r\n        }\r\n    }\r\n\r\n    function placeBet(\r\n        uint[] calldata betMasks,\r\n        uint[] calldata values,\r\n        uint[] calldata commitLastBlock0_commit1_r2_s3,\r\n        uint source,\r\n        uint modulo\r\n    ) external payable {\r\n        if (betMasks.length == 1) {\r\n            placeBetSingle(\r\n                betMasks[0],\r\n                modulo,\r\n                commitLastBlock0_commit1_r2_s3[0],\r\n                commitLastBlock0_commit1_r2_s3[1],\r\n                bytes32(commitLastBlock0_commit1_r2_s3[2]),\r\n                bytes32(commitLastBlock0_commit1_r2_s3[3]),\r\n                source\r\n            );\r\n            return;\r\n        }\r\n        require(!stopped, \"contract stopped\");\r\n        Bet storage bet = bets[commitLastBlock0_commit1_r2_s3[1]];\r\n        uint msgValue = msg.value;\r\n        {\r\n            require(bet.status == 0 && singleBets[commitLastBlock0_commit1_r2_s3[1]].status == 0, \"Bet should be in a 'clean' state.\");\r\n            require(modulo >= 2 && modulo <= MAX_MODULO, \"Modulo should be within range.\");\r\n            // Validate input data ranges.\r\n            require(betMasks.length > 1 && betMasks.length == values.length);\r\n            // require(msgValue <= MAX_AMOUNT, \"Max Amount should be within range.\");\r\n\r\n            // verify values\r\n            uint256 total = 0;\r\n            for (uint256 i = 0; i < values.length; i++) {\r\n                // require(betMasks[i] > 0 && betMasks[i] < MAX_BET_MASK, \"Mask should be within range\");\r\n                // 2**(8*4) szabo / 10**6  = 4294 ether\r\n                require(values[i] >= MIN_BET && values[i] <= 4293 ether, \"Min Amount should be within range.\");\r\n                total = add(total, values[i]);\r\n            }\r\n            require(total == msgValue);\r\n\r\n            // Check that commit is valid - it has not expired and its signature is valid.\r\n            require(block.number <= commitLastBlock0_commit1_r2_s3[0], \"Commit has expired.\");\r\n            bytes32 signatureHash = keccak256(abi.encodePacked(\r\n                    commitLastBlock0_commit1_r2_s3[0],\r\n                    commitLastBlock0_commit1_r2_s3[1]\r\n                ));\r\n            require(secretSigner == ecrecover(signatureHash, 27,\r\n                bytes32(commitLastBlock0_commit1_r2_s3[2]),\r\n                bytes32(commitLastBlock0_commit1_r2_s3[3])), \"ECDSA signature is not valid.\");\r\n        }\r\n\r\n        uint possibleWinAmount = 0;\r\n        uint jackpotFee;\r\n        for (uint256 i = 0; i < betMasks.length; i++) {\r\n            RawBet memory rb = RawBet({\r\n                mask : uint216(betMasks[i]),\r\n                amount : uint32(values[i] / 10 ** 12), //wei -> szabo\r\n                rollUnder : 0\r\n                });\r\n\r\n            if (modulo <= MASK_MODULO_40) {\r\n                rb.rollUnder = uint8(((uint(rb.mask) * POPCNT_MULT) & POPCNT_MASK) % POPCNT_MODULO);\r\n            } else if (modulo <= MASK_MODULO_40 * 2) {\r\n                rb.rollUnder = uint8(getRollUnder(uint(rb.mask), 2));\r\n            } else if (modulo == 100) {\r\n                rb.rollUnder = uint8(uint(rb.mask));\r\n            } else if (modulo <= MASK_MODULO_40 * 3) {\r\n                rb.rollUnder = uint8(getRollUnder(uint(rb.mask), 3));\r\n            } else if (modulo <= MASK_MODULO_40 * 4) {\r\n                rb.rollUnder = uint8(getRollUnder(uint(rb.mask), 4));\r\n            } else if (modulo <= MASK_MODULO_40 * 5) {\r\n                rb.rollUnder = uint8(getRollUnder(uint(rb.mask), 5));\r\n            } else {\r\n                rb.rollUnder = uint8(getRollUnder(uint(rb.mask), 6));\r\n            }\r\n\r\n            uint amount;\r\n            //szabo -> wei\r\n            (amount, jackpotFee) = getWinAmount(uint(rb.amount) * 10 ** 12, rb.rollUnder, modulo, jackpotFee);\r\n            require(amount > 0, \"invalid rollUnder -> zero amount\");\r\n            possibleWinAmount = add(possibleWinAmount, amount);\r\n            bet.rawBet.push(rb);\r\n        }\r\n\r\n        require(possibleWinAmount <= msgValue + maxProfit, \"maxProfit limit violation.\");\r\n        lockedInBets += uint128(possibleWinAmount);\r\n        jackpotSize += uint128(jackpotFee);\r\n        require(jackpotSize + lockedInBets <= address(this).balance, \"Cannot afford to lose this bet.\");\r\n\r\n        // Record commit in logs.\r\n        emit Commit(commitLastBlock0_commit1_r2_s3[1], source);\r\n        bet.placeBlockNumber = uint40(block.number);\r\n        bet.status = 1;\r\n        bet.gambler = msg.sender;\r\n        bet.modulo = uint8(modulo);\r\n    }\r\n\r\n    function settleBet(uint reveal, bytes32 blockHash) external onlyCroupier {\r\n        uint commit = uint(keccak256(abi.encodePacked(reveal)));\r\n        Bet storage bet = bets[commit];\r\n        {\r\n            uint placeBlockNumber = bet.placeBlockNumber;\r\n            require(blockhash(placeBlockNumber) == blockHash, \"blockHash invalid\");\r\n            require(block.number > placeBlockNumber, \"settleBet in the same block as placeBet, or before.\");\r\n            require(block.number <= placeBlockNumber + BET_EXPIRATION_BLOCKS, \"Blockhash can't be queried by EVM.\");\r\n        }\r\n        require(bet.status == 1, \"bet should be in a 'placed' status\");\r\n\r\n        // move into 'settled' status\r\n        bet.status = 2;\r\n\r\n        // The RNG - combine \"reveal\" and blockhash of placeBet using Keccak256. Miners\r\n        // are not aware of \"reveal\" and cannot deduce it from \"commit\" (as Keccak256\r\n        // preimage is intractable), and house is unable to alter the \"reveal\" after\r\n        // placeBet have been mined (as Keccak256 collision finding is also intractable).\r\n        bytes32 entropy = keccak256(abi.encodePacked(reveal, blockHash));\r\n\r\n        // Do a roll\r\n        uint modulo = bet.modulo;\r\n        uint roll = uint(entropy) % modulo;\r\n        uint result = 2 ** roll;\r\n\r\n        uint rollWin = 0;\r\n        uint unlockAmount = 0;\r\n        uint jackpotFee;\r\n        uint len = bet.rawBet.length;\r\n        for (uint256 i = 0; i < len; i++) {\r\n            RawBet memory rb = bet.rawBet[i];\r\n            uint possibleWinAmount;\r\n            uint amount = uint(rb.amount) * 10 ** 12;\r\n            //szabo -> wei\r\n            (possibleWinAmount, jackpotFee) = getWinAmount(amount, rb.rollUnder, modulo, jackpotFee);\r\n            unlockAmount += possibleWinAmount;\r\n\r\n            if (modulo == 216 && 211 <= rb.rollUnder && rb.rollUnder <= 216) {\r\n                uint matchDice = rb.rollUnder - 210;\r\n                uint[] memory dices = tripleDicesTable(roll);\r\n                uint count = 0;\r\n                for (uint ii = 0; ii < 3; ii++) {\r\n                    if (matchDice == dices[ii]) {\r\n                        count++;\r\n                    }\r\n                }\r\n                if (count == 1) {\r\n                    rollWin += amount * (1 + 1);\r\n                } else if (count == 2) {\r\n                    rollWin += amount * (1 + 2);\r\n                } else if (count == 3) {\r\n                    rollWin += amount * (1 + 3);\r\n                }\r\n            } else if (modulo == 100) {\r\n                if (roll < rb.rollUnder) {\r\n                    rollWin += possibleWinAmount;\r\n                }\r\n            } else if (result & rb.mask != 0) {\r\n                rollWin += possibleWinAmount;\r\n            }\r\n        }\r\n\r\n        // Unlock the bet amount, regardless of the outcome.\r\n        lockedInBets -= uint128(unlockAmount);\r\n\r\n        // Roll for a jackpot (if eligible).\r\n        uint jackpotWin = 0;\r\n        if (jackpotFee > 0) {\r\n            // The second modulo, statistically independent from the \"main\" dice roll.\r\n            // Effectively you are playing two games at once!\r\n            uint jackpotRng = (uint(entropy) / modulo) % JACKPOT_MODULO;\r\n\r\n            // Bingo!\r\n            if (jackpotRng == 888 || IS_DEV) {\r\n                jackpotWin = jackpotSize;\r\n                jackpotSize = 0;\r\n            }\r\n        }\r\n\r\n        address payable gambler = bet.gambler;\r\n        // Log jackpot win.\r\n        if (jackpotWin > 0) {\r\n            emit JackpotPayment(gambler, jackpotWin, commit);\r\n        }\r\n\r\n        // Send the funds to gambler.\r\n        sendFunds(gambler, rollWin + jackpotWin == 0 ? 1 wei : rollWin + jackpotWin, rollWin, commit);\r\n    }\r\n\r\n    function refundBet(uint commit) external {\r\n        Bet storage bet = bets[commit];\r\n        if (bet.status == 0) {\r\n            refundBetSingle(commit);\r\n            return;\r\n        }\r\n\r\n        require(bet.status == 1, \"bet should be in a 'placed' status\");\r\n\r\n        // Check that bet has already expired.\r\n        require(block.number > bet.placeBlockNumber + BET_EXPIRATION_BLOCKS, \"Blockhash can't be queried by EVM.\");\r\n\r\n        // move into 'refunded' status\r\n        bet.status = 3;\r\n\r\n        uint refundAmount = 0;\r\n        uint unlockAmount = 0;\r\n        uint jackpotFee;\r\n        uint len = bet.rawBet.length;\r\n        uint modulo = bet.modulo;\r\n        for (uint256 i = 0; i < len; i++) {\r\n            RawBet memory rb = bet.rawBet[i];\r\n            //szabo -> wei\r\n            uint amount = uint(rb.amount) * 10 ** 12;\r\n            uint possibleWinAmount;\r\n            (possibleWinAmount, jackpotFee) = getWinAmount(amount, rb.rollUnder, modulo, jackpotFee);\r\n            unlockAmount += possibleWinAmount;\r\n            refundAmount += amount;\r\n        }\r\n\r\n        // Unlock the bet amount, regardless of the outcome.\r\n        lockedInBets -= uint128(unlockAmount);\r\n        if (jackpotSize >= jackpotFee) {\r\n            jackpotSize -= uint128(jackpotFee);\r\n        }\r\n\r\n        // Send the refund.\r\n        sendFunds(bet.gambler, refundAmount, refundAmount, commit);\r\n    }\r\n\r\n    /////////////////////////////////////////////////////\r\n    /////////////////////////////////////////////////////\r\n    /////////////////////////////////////////////////////\r\n\r\n    function placeBetSingle(uint betMask, uint modulo, uint commitLastBlock, uint commit, bytes32 r, bytes32 s, uint source) public payable {\r\n        require(!stopped, \"contract stopped\");\r\n        SingleBet storage bet = singleBets[commit];\r\n\r\n        // Check that the bet is in 'clean' state.\r\n        require(bet.status == 0 && bets[commit].status == 0, \"Bet should be in a 'clean' state.\");\r\n\r\n        // Validate input data ranges.\r\n        uint amount = msg.value;\r\n        require(modulo >= 2 && modulo <= MAX_MODULO, \"Modulo should be within range.\");\r\n        // 2**(8*9) wei   / 10**18 = 4722 ether\r\n        require(amount >= MIN_BET && amount <= 4721 ether, \"Amount should be within range.\");\r\n        require(betMask > 0 && betMask < MAX_BET_MASK, \"Mask should be within range.\");\r\n\r\n        // Check that commit is valid - it has not expired and its signature is valid.\r\n        require(block.number <= commitLastBlock, \"Commit has expired.\");\r\n        bytes32 signatureHash = keccak256(abi.encodePacked(commitLastBlock, commit));\r\n        require(secretSigner == ecrecover(signatureHash, 27, r, s), \"ECDSA signature is not valid.\");\r\n\r\n        uint rollUnder;\r\n\r\n        if (modulo <= MASK_MODULO_40) {\r\n            // Small modulo games specify bet outcomes via bit mask.\r\n            // rollUnder is a number of 1 bits in this mask (population count).\r\n            // This magic looking formula is an efficient way to compute population\r\n            // count on EVM for numbers below 2**40.\r\n            rollUnder = ((betMask * POPCNT_MULT) & POPCNT_MASK) % POPCNT_MODULO;\r\n            bet.mask = uint216(betMask);\r\n        } else if (modulo <= MASK_MODULO_40 * 2) {\r\n            rollUnder = getRollUnder(betMask, 2);\r\n            bet.mask = uint216(betMask);\r\n        } else if (modulo == 100) {\r\n            require(betMask > 0 && betMask <= modulo, \"modulo=100: betMask larger than modulo\");\r\n            rollUnder = betMask;\r\n            bet.mask = uint216(betMask);\r\n        } else if (modulo <= MASK_MODULO_40 * 3) {\r\n            rollUnder = getRollUnder(betMask, 3);\r\n            bet.mask = uint216(betMask);\r\n        } else if (modulo <= MASK_MODULO_40 * 4) {\r\n            rollUnder = getRollUnder(betMask, 4);\r\n            bet.mask = uint216(betMask);\r\n        } else if (modulo <= MASK_MODULO_40 * 5) {\r\n            rollUnder = getRollUnder(betMask, 5);\r\n            bet.mask = uint216(betMask);\r\n        } else {//if (modulo <= MAX_MODULO)\r\n            rollUnder = getRollUnder(betMask, 6);\r\n            bet.mask = uint216(betMask);\r\n        }\r\n\r\n        // Winning amount and jackpot increase.\r\n        uint possibleWinAmount;\r\n        uint jackpotFee;\r\n\r\n        //        emit DebugUint(\"rollUnder\", rollUnder);\r\n        (possibleWinAmount, jackpotFee) = getWinAmount(amount, rollUnder, modulo, jackpotFee);\r\n        require(possibleWinAmount > 0, \"invalid rollUnder -> zero possibleWinAmount\");\r\n\r\n        // Enforce max profit limit.\r\n        require(possibleWinAmount <= amount + maxProfit, \"maxProfit limit violation.\");\r\n\r\n        // Lock funds.\r\n        lockedInBets += uint128(possibleWinAmount);\r\n        jackpotSize += uint128(jackpotFee);\r\n\r\n        // Check whether contract has enough funds to process this bet.\r\n        require(jackpotSize + lockedInBets <= address(this).balance, \"Cannot afford to lose this bet.\");\r\n\r\n        // Record commit in logs.\r\n        emit Commit(commit, source);\r\n\r\n        // Store bet parameters on blockchain.\r\n        bet.amount = uint72(amount);\r\n        bet.modulo = uint8(modulo);\r\n        bet.rollUnder = uint8(rollUnder);\r\n        bet.placeBlockNumber = uint40(block.number);\r\n        bet.gambler = msg.sender;\r\n        bet.status = 1;\r\n    }\r\n\r\n    function settleBetSingle(uint reveal, bytes32 blockHash) external onlyCroupier {\r\n        uint commit = uint(keccak256(abi.encodePacked(reveal)));\r\n        SingleBet storage bet = singleBets[commit];\r\n        {\r\n            uint placeBlockNumber = bet.placeBlockNumber;\r\n            require(blockhash(placeBlockNumber) == blockHash, \"blockHash invalid\");\r\n            require(block.number > placeBlockNumber, \"settleBet in the same block as placeBet, or before.\");\r\n            require(block.number <= placeBlockNumber + BET_EXPIRATION_BLOCKS, \"Blockhash can't be queried by EVM.\");\r\n        }\r\n        // Fetch bet parameters into local variables (to save gas).\r\n        uint amount = bet.amount;\r\n        uint modulo = bet.modulo;\r\n        uint rollUnder = bet.rollUnder;\r\n        address payable gambler = bet.gambler;\r\n\r\n        // Check that bet is in 'active' state.\r\n        require(bet.status == 1, \"Bet should be in an 'active' state\");\r\n\r\n        // move into 'settled' status\r\n        bet.status = 2;\r\n\r\n        // The RNG - combine \"reveal\" and blockhash of placeBet using Keccak256. Miners\r\n        // are not aware of \"reveal\" and cannot deduce it from \"commit\" (as Keccak256\r\n        // preimage is intractable), and house is unable to alter the \"reveal\" after\r\n        // placeBet have been mined (as Keccak256 collision finding is also intractable).\r\n        bytes32 entropy = keccak256(abi.encodePacked(reveal, blockHash));\r\n\r\n        // Do a roll by taking a modulo of entropy. Compute winning amount.\r\n        uint dice = uint(entropy) % modulo;\r\n\r\n        (uint diceWinAmount, uint jackpotFee) = getWinAmount(amount, rollUnder, modulo, 0);\r\n\r\n        uint diceWin = 0;\r\n        uint jackpotWin = 0;\r\n\r\n        // Determine dice outcome.\r\n        if (modulo == 216 && 211 <= rollUnder && rollUnder <= 216) {\r\n            uint matchDice = rollUnder - 210;\r\n            uint[] memory dices = tripleDicesTable(dice);\r\n            uint count = 0;\r\n            for (uint ii = 0; ii < 3; ii++) {\r\n                if (matchDice == dices[ii]) {\r\n                    count++;\r\n                }\r\n            }\r\n            if (count == 1) {\r\n                diceWin += amount * (1 + 1);\r\n            } else if (count == 2) {\r\n                diceWin += amount * (1 + 2);\r\n            } else if (count == 3) {\r\n                diceWin += amount * (1 + 3);\r\n            }\r\n        } else if (modulo == 100) {\r\n            // For larger modulos, check inclusion into half-open interval.\r\n            if (dice < rollUnder) {\r\n                diceWin = diceWinAmount;\r\n            }\r\n        } else {\r\n            // For small modulo games, check the outcome against a bit mask.\r\n            if ((2 ** dice) & bet.mask != 0) {\r\n                diceWin = diceWinAmount;\r\n            }\r\n        }\r\n\r\n        // Unlock the bet amount, regardless of the outcome.\r\n        lockedInBets -= uint128(diceWinAmount);\r\n\r\n        // Roll for a jackpot (if eligible).\r\n        if (jackpotFee > 0) {\r\n            // The second modulo, statistically independent from the \"main\" dice roll.\r\n            // Effectively you are playing two games at once!\r\n            uint jackpotRng = (uint(entropy) / modulo) % JACKPOT_MODULO;\r\n\r\n            // Bingo!\r\n            if (jackpotRng == 888 || IS_DEV) {\r\n                jackpotWin = jackpotSize;\r\n                jackpotSize = 0;\r\n            }\r\n        }\r\n\r\n        // Log jackpot win.\r\n        if (jackpotWin > 0) {\r\n            emit JackpotPayment(gambler, jackpotWin, commit);\r\n        }\r\n\r\n        // Send the funds to gambler.\r\n        sendFunds(gambler, diceWin + jackpotWin == 0 ? 1 wei : diceWin + jackpotWin, diceWin, commit);\r\n    }\r\n\r\n    function refundBetSingle(uint commit) private {\r\n        // Check that bet is in 'active' state.\r\n        SingleBet storage bet = singleBets[commit];\r\n        uint amount = bet.amount;\r\n\r\n        require(bet.status == 1, \"bet should be in a 'placed' status\");\r\n\r\n        // Check that bet has already expired.\r\n        require(block.number > bet.placeBlockNumber + BET_EXPIRATION_BLOCKS, \"Blockhash can't be queried by EVM.\");\r\n\r\n        // move into 'refunded' status\r\n        bet.status = 3;\r\n\r\n        uint diceWinAmount;\r\n        uint jackpotFee;\r\n        (diceWinAmount, jackpotFee) = getWinAmount(amount, bet.rollUnder, bet.modulo, 0);\r\n\r\n        lockedInBets -= uint128(diceWinAmount);\r\n        if (jackpotSize >= jackpotFee) {\r\n            jackpotSize -= uint128(jackpotFee);\r\n        }\r\n\r\n        // Send the refund.\r\n        sendFunds(bet.gambler, amount, amount, commit);\r\n    }\r\n}\r\n\r\n/* triple dices table\r\n   1: 1 1 1\r\n   2: 1 1 2\r\n   3: 1 1 3\r\n   4: 1 1 4\r\n   5: 1 1 5\r\n   6: 1 1 6\r\n   7: 1 2 1\r\n   8: 1 2 2\r\n   9: 1 2 3\r\n  10: 1 2 4\r\n  11: 1 2 5\r\n  12: 1 2 6\r\n  13: 1 3 1\r\n  14: 1 3 2\r\n  15: 1 3 3\r\n  16: 1 3 4\r\n  17: 1 3 5\r\n  18: 1 3 6\r\n  19: 1 4 1\r\n  20: 1 4 2\r\n  21: 1 4 3\r\n  22: 1 4 4\r\n  23: 1 4 5\r\n  24: 1 4 6\r\n  25: 1 5 1\r\n  26: 1 5 2\r\n  27: 1 5 3\r\n  28: 1 5 4\r\n  29: 1 5 5\r\n  30: 1 5 6\r\n  31: 1 6 1\r\n  32: 1 6 2\r\n  33: 1 6 3\r\n  34: 1 6 4\r\n  35: 1 6 5\r\n  36: 1 6 6\r\n  37: 2 1 1\r\n  38: 2 1 2\r\n  39: 2 1 3\r\n  40: 2 1 4\r\n  41: 2 1 5\r\n  42: 2 1 6\r\n  43: 2 2 1\r\n  44: 2 2 2\r\n  45: 2 2 3\r\n  46: 2 2 4\r\n  47: 2 2 5\r\n  48: 2 2 6\r\n  49: 2 3 1\r\n  50: 2 3 2\r\n  51: 2 3 3\r\n  52: 2 3 4\r\n  53: 2 3 5\r\n  54: 2 3 6\r\n  55: 2 4 1\r\n  56: 2 4 2\r\n  57: 2 4 3\r\n  58: 2 4 4\r\n  59: 2 4 5\r\n  60: 2 4 6\r\n  61: 2 5 1\r\n  62: 2 5 2\r\n  63: 2 5 3\r\n  64: 2 5 4\r\n  65: 2 5 5\r\n  66: 2 5 6\r\n  67: 2 6 1\r\n  68: 2 6 2\r\n  69: 2 6 3\r\n  70: 2 6 4\r\n  71: 2 6 5\r\n  72: 2 6 6\r\n  73: 3 1 1\r\n  74: 3 1 2\r\n  75: 3 1 3\r\n  76: 3 1 4\r\n  77: 3 1 5\r\n  78: 3 1 6\r\n  79: 3 2 1\r\n  80: 3 2 2\r\n  81: 3 2 3\r\n  82: 3 2 4\r\n  83: 3 2 5\r\n  84: 3 2 6\r\n  85: 3 3 1\r\n  86: 3 3 2\r\n  87: 3 3 3\r\n  88: 3 3 4\r\n  89: 3 3 5\r\n  90: 3 3 6\r\n  91: 3 4 1\r\n  92: 3 4 2\r\n  93: 3 4 3\r\n  94: 3 4 4\r\n  95: 3 4 5\r\n  96: 3 4 6\r\n  97: 3 5 1\r\n  98: 3 5 2\r\n  99: 3 5 3\r\n 100: 3 5 4\r\n 101: 3 5 5\r\n 102: 3 5 6\r\n 103: 3 6 1\r\n 104: 3 6 2\r\n 105: 3 6 3\r\n 106: 3 6 4\r\n 107: 3 6 5\r\n 108: 3 6 6\r\n 109: 4 1 1\r\n 110: 4 1 2\r\n 111: 4 1 3\r\n 112: 4 1 4\r\n 113: 4 1 5\r\n 114: 4 1 6\r\n 115: 4 2 1\r\n 116: 4 2 2\r\n 117: 4 2 3\r\n 118: 4 2 4\r\n 119: 4 2 5\r\n 120: 4 2 6\r\n 121: 4 3 1\r\n 122: 4 3 2\r\n 123: 4 3 3\r\n 124: 4 3 4\r\n 125: 4 3 5\r\n 126: 4 3 6\r\n 127: 4 4 1\r\n 128: 4 4 2\r\n 129: 4 4 3\r\n 130: 4 4 4\r\n 131: 4 4 5\r\n 132: 4 4 6\r\n 133: 4 5 1\r\n 134: 4 5 2\r\n 135: 4 5 3\r\n 136: 4 5 4\r\n 137: 4 5 5\r\n 138: 4 5 6\r\n 139: 4 6 1\r\n 140: 4 6 2\r\n 141: 4 6 3\r\n 142: 4 6 4\r\n 143: 4 6 5\r\n 144: 4 6 6\r\n 145: 5 1 1\r\n 146: 5 1 2\r\n 147: 5 1 3\r\n 148: 5 1 4\r\n 149: 5 1 5\r\n 150: 5 1 6\r\n 151: 5 2 1\r\n 152: 5 2 2\r\n 153: 5 2 3\r\n 154: 5 2 4\r\n 155: 5 2 5\r\n 156: 5 2 6\r\n 157: 5 3 1\r\n 158: 5 3 2\r\n 159: 5 3 3\r\n 160: 5 3 4\r\n 161: 5 3 5\r\n 162: 5 3 6\r\n 163: 5 4 1\r\n 164: 5 4 2\r\n 165: 5 4 3\r\n 166: 5 4 4\r\n 167: 5 4 5\r\n 168: 5 4 6\r\n 169: 5 5 1\r\n 170: 5 5 2\r\n 171: 5 5 3\r\n 172: 5 5 4\r\n 173: 5 5 5\r\n 174: 5 5 6\r\n 175: 5 6 1\r\n 176: 5 6 2\r\n 177: 5 6 3\r\n 178: 5 6 4\r\n 179: 5 6 5\r\n 180: 5 6 6\r\n 181: 6 1 1\r\n 182: 6 1 2\r\n 183: 6 1 3\r\n 184: 6 1 4\r\n 185: 6 1 5\r\n 186: 6 1 6\r\n 187: 6 2 1\r\n 188: 6 2 2\r\n 189: 6 2 3\r\n 190: 6 2 4\r\n 191: 6 2 5\r\n 192: 6 2 6\r\n 193: 6 3 1\r\n 194: 6 3 2\r\n 195: 6 3 3\r\n 196: 6 3 4\r\n 197: 6 3 5\r\n 198: 6 3 6\r\n 199: 6 4 1\r\n 200: 6 4 2\r\n 201: 6 4 3\r\n 202: 6 4 4\r\n 203: 6 4 5\r\n 204: 6 4 6\r\n 205: 6 5 1\r\n 206: 6 5 2\r\n 207: 6 5 3\r\n 208: 6 5 4\r\n 209: 6 5 5\r\n 210: 6 5 6\r\n 211: 6 6 1\r\n 212: 6 6 2\r\n 213: 6 6 3\r\n 214: 6 6 4\r\n 215: 6 6 5\r\n 216: 6 6 6\r\n*/","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"JACKPOT_MODULO\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MIN_JACKPOT_BET\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"o\",\"type\":\"address\"}],\"name\":\"setWithdrawer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"o\",\"type\":\"address\"}],\"name\":\"setOwner1\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"IS_DEV\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"secretSigner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner2\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"HOUSE_EDGE_OF_TEN_THOUSAND\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"jackpotSize\",\"outputs\":[{\"name\":\"\",\"type\":\"uint128\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"o\",\"type\":\"address\"}],\"name\":\"setOwner2\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"betMasks\",\"type\":\"uint256[]\"},{\"name\":\"values\",\"type\":\"uint256[]\"},{\"name\":\"commitLastBlock0_commit1_r2_s3\",\"type\":\"uint256[]\"},{\"name\":\"source\",\"type\":\"uint256\"},{\"name\":\"modulo\",\"type\":\"uint256\"}],\"name\":\"placeBet\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_maxProfit\",\"type\":\"uint128\"}],\"name\":\"setMaxProfit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MIN_BET\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"croupier\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"reveal\",\"type\":\"uint256\"}],\"name\":\"reveal2commit\",\"outputs\":[{\"name\":\"commit\",\"type\":\"bytes32\"},{\"name\":\"commitUint\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner1\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"stopped\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"commit\",\"type\":\"uint256\"}],\"name\":\"getBetInfo\",\"outputs\":[{\"name\":\"status\",\"type\":\"uint8\"},{\"name\":\"gambler\",\"type\":\"address\"},{\"name\":\"placeBlockNumber\",\"type\":\"uint256\"},{\"name\":\"masks\",\"type\":\"uint256[]\"},{\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"name\":\"rollUnders\",\"type\":\"uint8[]\"},{\"name\":\"modulo\",\"type\":\"uint256\"},{\"name\":\"isSingle\",\"type\":\"bool\"},{\"name\":\"length\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"reveal\",\"type\":\"uint256\"},{\"name\":\"blockHash\",\"type\":\"bytes32\"}],\"name\":\"settleBetSingle\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxProfit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint128\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"HOUSE_EDGE_MINIMUM_AMOUNT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"JACKPOT_FEE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"beneficiary\",\"type\":\"address\"},{\"name\":\"withdrawAmount\",\"type\":\"uint256\"}],\"name\":\"withdrawFunds\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"destruct\",\"type\":\"bool\"}],\"name\":\"stop\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"reveal\",\"type\":\"uint256\"},{\"name\":\"blockHash\",\"type\":\"bytes32\"}],\"name\":\"settleBet\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"withdrawer\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newSecretSigner\",\"type\":\"address\"}],\"name\":\"setSecretSigner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lockedInBets\",\"outputs\":[{\"name\":\"\",\"type\":\"uint128\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"commit\",\"type\":\"uint256\"}],\"name\":\"refundBet\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newCroupier\",\"type\":\"address\"}],\"name\":\"setCroupier\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"betMask\",\"type\":\"uint256\"},{\"name\":\"modulo\",\"type\":\"uint256\"},{\"name\":\"commitLastBlock\",\"type\":\"uint256\"},{\"name\":\"commit\",\"type\":\"uint256\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"},{\"name\":\"source\",\"type\":\"uint256\"}],\"name\":\"placeBetSingle\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_owner1\",\"type\":\"address\"},{\"name\":\"_owner2\",\"type\":\"address\"},{\"name\":\"_withdrawer\",\"type\":\"address\"},{\"name\":\"_secretSigner\",\"type\":\"address\"},{\"name\":\"_croupier\",\"type\":\"address\"},{\"name\":\"_maxProfit\",\"type\":\"uint128\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"commit\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"source\",\"type\":\"uint256\"}],\"name\":\"Commit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"commit\",\"type\":\"uint256\"}],\"name\":\"FailedPayment\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"commit\",\"type\":\"uint256\"}],\"name\":\"Payment\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"commit\",\"type\":\"uint256\"}],\"name\":\"JackpotPayment\",\"type\":\"event\"}]","ContractName":"FckRoulette","CompilerVersion":"v0.5.4+commit.9549d8ff","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000f27a6ef912cd4df19676f9d490b6e096aa4bfa33000000000000000000000000478f12e08990bfc890db337ee846525e3af456550000000000000000000000009e312b90546f29c0bb5444fffbf16c2a7a1b1a50000000000000000000000000de2552b1cd6123f1b35fa1ec18cc9c8e4ccb3260000000000000000000000000ccccccc3b1ac9d2d02ce052917ee92618e9738b90000000000000000000000000000000000000000000000008ac7230489e80000","Library":"","SwarmSource":"bzzr://2038f8114c40077879a3352ed204d83b77897469fc8c90eda39edbe5cc242afb"}]}