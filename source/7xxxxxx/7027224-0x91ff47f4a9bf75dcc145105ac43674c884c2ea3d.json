{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity > 0.4.99 <0.6.0;\r\n\r\ninterface IPayeeShare {\r\n    function payeePartsToSell() external view returns (uint256);\r\n    function payeePricePerPart() external view returns (uint256);\r\n}\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\ncontract AssetSplitContracts {\r\n    \r\n     struct Contract {\r\n        address payable contractAddress;\r\n        address payable creatorAddress;\r\n        uint256 contractType;\r\n        uint256 a_uint256;\r\n        string a_string;\r\n        uint256 b_uint256;\r\n        string b_string;\r\n        uint256 c_uint256;\r\n        string c_string;\r\n        bool active;\r\n    }\r\n    \r\n    Contract[] public contracts;\r\n\r\n    struct SaleContract {\r\n        address payable saleContractAddress;\r\n    }\r\n    \r\n    SaleContract[] public saleContracts;\r\n    \r\n    mapping (address => uint) public saleContractCount;\r\n    \r\n    string public constant createdBy = \"AssetSplit.org - the guys who cut the pizza\";\r\n    \r\n    event AddedContract(address contractAddress, address contractCreator, uint256 contractType);\r\n    \r\n    bytes32 password = 0x75673d0f21e100acda4f6dc8b3ac99a142af1d843cb1936898d854e930409f10;\r\n\r\n    using SafeMath for uint256;\r\n    \r\n    function addSaleContract(address payable _contractAddress, string memory _password, bytes32 _newPassword) public {\r\n        bytes32 pw = keccak256(bytes(_password));\r\n        require(password == pw);\r\n        require(password != _newPassword);\r\n        password = _newPassword;\r\n        saleContracts.push(SaleContract(_contractAddress)).sub(1);\r\n        saleContractCount[_contractAddress] = saleContractCount[_contractAddress].add(1);\r\n    }\r\n    \r\n    function editSaleContract(uint _id, address payable _newContractAddress, string memory _password, bytes32 _newPassword) public {\r\n        bytes32 pw = keccak256(bytes(_password));\r\n        require(password == pw);\r\n        require(_newPassword != \"\");\r\n        password = _newPassword;\r\n        SaleContract storage myContract = saleContracts[_id];\r\n        myContract.saleContractAddress = _newContractAddress;\r\n        saleContractCount[_newContractAddress] = saleContractCount[_newContractAddress].add(1);\r\n    }\r\n    \r\n    function addContract(address payable _contractAddress, address payable _creatorAddress, uint256 _contractType) public returns (bool success) {\r\n        require (saleContractCount[msg.sender] > 0);\r\n        removeOldFirst(_contractAddress);\r\n        contracts.push(Contract(_contractAddress, _creatorAddress, _contractType, 0, \"\", 0, \"\", 0, \"\", true));\r\n        emit AddedContract(_contractAddress, _creatorAddress, _contractType);\r\n        return true;\r\n    }\r\n\r\n    function editContract (uint _id, uint256 _a_uint256, string memory _a_string, uint256 _b_uint256, string memory _b_string, uint256 _c_uint256, string memory _c_string) public returns (bool success) {\r\n        require (saleContractCount[msg.sender] > 0);\r\n        Contract storage myContract = contracts[_id];\r\n        myContract.a_uint256 = _a_uint256;\r\n        myContract.a_string = _a_string;\r\n        myContract.b_uint256 = _b_uint256;\r\n        myContract.b_string = _b_string;\r\n        myContract.c_uint256 = _c_uint256;\r\n        myContract.c_string = _c_string;\r\n        return true;\r\n    }\r\n    \r\n    function removeOldFirst(address _contractAddress) internal {\r\n        for (uint i = 0; i < contracts.length; i++) {    \r\n            Contract storage myContracts = contracts[i];\r\n            if (myContracts.contractAddress == _contractAddress) {\r\n                myContracts.active = false;\r\n            }\r\n        }\r\n    }\r\n    \r\n    function countActiveType(uint256 _type) internal view returns (uint256) {\r\n        uint256 counter = 0;\r\n        for (uint i = 0; i < contracts.length; i++) {\r\n            Contract memory myContracts = contracts[i];\r\n        if (myContracts.contractType == _type && myContracts.active == true) {\r\n            counter++;\r\n          }\r\n        }\r\n        return counter;\r\n    }\r\n    \r\n   function getContractsByType(uint256 _type) public view returns (uint[] memory) {\r\n        uint[] memory result = new uint[](countActiveType(_type));\r\n        uint counter = 0;\r\n        for (uint i = 0; i < contracts.length; i++) {\r\n            Contract memory myContracts = contracts[i];\r\n          if (myContracts.contractType == _type && myContracts.active == true) {\r\n            result[counter] = i;\r\n            counter++;\r\n          }\r\n        }\r\n        return result;\r\n    }\r\n  \r\n     function getMyContractsByType(uint256 _type) public view returns (uint[] memory) {\r\n        uint[] memory result = new uint[](countActiveType(_type));\r\n        uint counter = 0;\r\n        for (uint i = 0; i < contracts.length; i++) {\r\n        Contract memory myContracts = contracts[i];\r\n          if (myContracts.contractType == _type && myContracts.creatorAddress == msg.sender && myContracts.active == true) {\r\n            result[counter] = i;\r\n            counter++;\r\n          }\r\n        }\r\n        return result;\r\n    }\r\n    \r\n    function cleanSellShareOutput() public {\r\n        for (uint i = 0; i < contracts.length; i++) {    \r\n            Contract storage myContracts = contracts[i];\r\n            IPayeeShare shareContract;\r\n            shareContract = IPayeeShare(myContracts.contractAddress);\r\n            if (shareContract.payeePartsToSell() < 1 || shareContract.payeePricePerPart() == 0) {\r\n                myContracts.active = false;\r\n            }\r\n        }\r\n    }\r\n    \r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"createdBy\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"contracts\",\"outputs\":[{\"name\":\"contractAddress\",\"type\":\"address\"},{\"name\":\"creatorAddress\",\"type\":\"address\"},{\"name\":\"contractType\",\"type\":\"uint256\"},{\"name\":\"a_uint256\",\"type\":\"uint256\"},{\"name\":\"a_string\",\"type\":\"string\"},{\"name\":\"b_uint256\",\"type\":\"uint256\"},{\"name\":\"b_string\",\"type\":\"string\"},{\"name\":\"c_uint256\",\"type\":\"uint256\"},{\"name\":\"c_string\",\"type\":\"string\"},{\"name\":\"active\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_contractAddress\",\"type\":\"address\"},{\"name\":\"_password\",\"type\":\"string\"},{\"name\":\"_newPassword\",\"type\":\"bytes32\"}],\"name\":\"addSaleContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_type\",\"type\":\"uint256\"}],\"name\":\"getMyContractsByType\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"cleanSellShareOutput\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_type\",\"type\":\"uint256\"}],\"name\":\"getContractsByType\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"saleContracts\",\"outputs\":[{\"name\":\"saleContractAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_contractAddress\",\"type\":\"address\"},{\"name\":\"_creatorAddress\",\"type\":\"address\"},{\"name\":\"_contractType\",\"type\":\"uint256\"}],\"name\":\"addContract\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_id\",\"type\":\"uint256\"},{\"name\":\"_newContractAddress\",\"type\":\"address\"},{\"name\":\"_password\",\"type\":\"string\"},{\"name\":\"_newPassword\",\"type\":\"bytes32\"}],\"name\":\"editSaleContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"saleContractCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_id\",\"type\":\"uint256\"},{\"name\":\"_a_uint256\",\"type\":\"uint256\"},{\"name\":\"_a_string\",\"type\":\"string\"},{\"name\":\"_b_uint256\",\"type\":\"uint256\"},{\"name\":\"_b_string\",\"type\":\"string\"},{\"name\":\"_c_uint256\",\"type\":\"uint256\"},{\"name\":\"_c_string\",\"type\":\"string\"}],\"name\":\"editContract\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"contractAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"contractCreator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"contractType\",\"type\":\"uint256\"}],\"name\":\"AddedContract\",\"type\":\"event\"}]","ContractName":"AssetSplitContracts","CompilerVersion":"v0.5.2+commit.1df8f40c","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://6f8ce34e03aaf996367d1379d98677658fc1bcc98a9692c7a00cb7b5db70cf52"}]}