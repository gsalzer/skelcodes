{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.0;\r\n\r\ncontract CryptoTycoonsVIPLib{\r\n    \r\n    address payable public owner;\r\n    \r\n    // Accumulated jackpot fund.\r\n    uint128 public jackpotSize;\r\n    uint128 public rankingRewardSize;\r\n    \r\n    mapping (address => uint) userExpPool;\r\n    mapping (address => bool) public callerMap;\r\n\r\n    event RankingRewardPayment(address indexed beneficiary, uint amount);\r\n\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner, \"OnlyOwner methods called by non-owner.\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyCaller {\r\n        bool isCaller = callerMap[msg.sender];\r\n        require(isCaller, \"onlyCaller methods called by non-caller.\");\r\n        _;\r\n    }\r\n\r\n    constructor() public{\r\n        owner = msg.sender;\r\n        callerMap[owner] = true;\r\n    }\r\n\r\n    // Fallback function deliberately left empty. It's primary use case\r\n    // is to top up the bank roll.\r\n    function () external payable {\r\n    }\r\n\r\n    function kill() external onlyOwner {\r\n        selfdestruct(owner);\r\n    }\r\n\r\n    function addCaller(address caller) public onlyOwner{\r\n        bool isCaller = callerMap[caller];\r\n        if (isCaller == false){\r\n            callerMap[caller] = true;\r\n        }\r\n    }\r\n\r\n    function deleteCaller(address caller) external onlyOwner {\r\n        bool isCaller = callerMap[caller];\r\n        if (isCaller == true) {\r\n            callerMap[caller] = false;\r\n        }\r\n    }\r\n\r\n    function addUserExp(address addr, uint256 amount) public onlyCaller{\r\n        uint exp = userExpPool[addr];\r\n        exp = exp + amount;\r\n        userExpPool[addr] = exp;\r\n    }\r\n\r\n    function getUserExp(address addr) public view returns(uint256 exp){\r\n        return userExpPool[addr];\r\n    }\r\n\r\n    function getVIPLevel(address user) public view returns (uint256 level) {\r\n        uint exp = userExpPool[user];\r\n\r\n        if(exp >= 25 ether && exp < 125 ether){\r\n            level = 1;\r\n        } else if(exp >= 125 ether && exp < 250 ether){\r\n            level = 2;\r\n        } else if(exp >= 250 ether && exp < 1250 ether){\r\n            level = 3;\r\n        } else if(exp >= 1250 ether && exp < 2500 ether){\r\n            level = 4;\r\n        } else if(exp >= 2500 ether && exp < 12500 ether){\r\n            level = 5;\r\n        } else if(exp >= 12500 ether && exp < 25000 ether){\r\n            level = 6;\r\n        } else if(exp >= 25000 ether && exp < 125000 ether){\r\n            level = 7;\r\n        } else if(exp >= 125000 ether && exp < 250000 ether){\r\n            level = 8;\r\n        } else if(exp >= 250000 ether && exp < 1250000 ether){\r\n            level = 9;\r\n        } else if(exp >= 1250000 ether){\r\n            level = 10;\r\n        } else{\r\n            level = 0;\r\n        }\r\n\r\n        return level;\r\n    }\r\n\r\n    function getVIPBounusRate(address user) public view returns (uint256 rate){\r\n        uint level = getVIPLevel(user);\r\n        return level;\r\n    }\r\n\r\n    // This function is used to bump up the jackpot fund. Cannot be used to lower it.\r\n    function increaseJackpot(uint increaseAmount) external onlyCaller {\r\n        require (increaseAmount <= address(this).balance, \"Increase amount larger than balance.\");\r\n        require (jackpotSize + increaseAmount <= address(this).balance, \"Not enough funds.\");\r\n        jackpotSize += uint128(increaseAmount);\r\n    }\r\n\r\n    function payJackpotReward(address payable to) external onlyCaller{\r\n        to.transfer(jackpotSize);\r\n        jackpotSize = 0;\r\n    }\r\n\r\n    function getJackpotSize() external view returns (uint256){\r\n        return jackpotSize;\r\n    }\r\n\r\n    function increaseRankingReward(uint amount) public onlyCaller{\r\n        require (amount <= address(this).balance, \"Increase amount larger than balance.\");\r\n        require (rankingRewardSize + amount <= address(this).balance, \"Not enough funds.\");\r\n        rankingRewardSize += uint128(amount);\r\n    }\r\n\r\n    function payRankingReward(address payable to) external onlyCaller {\r\n        uint128 prize = rankingRewardSize / 2;\r\n        rankingRewardSize = rankingRewardSize - prize;\r\n        if(to.send(prize)){\r\n            emit RankingRewardPayment(to, prize);\r\n        }\r\n    }\r\n\r\n    function getRankingRewardSize() external view returns (uint128){\r\n        return rankingRewardSize;\r\n    }\r\n}\r\ncontract CryptoTycoonsConstants{\r\n    /// *** Constants section\r\n\r\n    // Each bet is deducted 1% in favour of the house, but no less than some minimum.\r\n    // The lower bound is dictated by gas costs of the settleBet transaction, providing\r\n    // headroom for up to 10 Gwei prices.\r\n    uint constant HOUSE_EDGE_PERCENT = 1;\r\n    uint constant RANK_FUNDS_PERCENT = 7;\r\n    uint constant INVITER_BENEFIT_PERCENT = 7;\r\n    uint constant HOUSE_EDGE_MINIMUM_AMOUNT = 0.0004 ether;\r\n\r\n    // Bets lower than this amount do not participate in jackpot rolls (and are\r\n    // not deducted JACKPOT_FEE).\r\n    uint constant MIN_JACKPOT_BET = 0.1 ether;\r\n\r\n    // Chance to win jackpot (currently 0.1%) and fee deducted into jackpot fund.\r\n    uint constant JACKPOT_MODULO = 1000;\r\n    uint constant JACKPOT_FEE = 0.001 ether;\r\n\r\n    // There is minimum and maximum bets.\r\n    uint constant MIN_BET = 0.01 ether;\r\n    uint constant MAX_AMOUNT = 10 ether;\r\n\r\n    // Standard contract ownership transfer.\r\n    address payable public owner;\r\n    address payable private nextOwner;\r\n\r\n    // Croupier account.\r\n    mapping (address => bool ) croupierMap;\r\n\r\n    // Adjustable max bet profit. Used to cap bets against dynamic odds.\r\n    uint public maxProfit;\r\n\r\n    address payable public VIPLibraryAddress;\r\n\r\n    // The address corresponding to a private key used to sign placeBet commits.\r\n    address public secretSigner;\r\n\r\n    // Events that are issued to make statistic recovery easier.\r\n    event FailedPayment(address indexed beneficiary, uint amount);\r\n    event VIPPayback(address indexed beneficiary, uint amount);\r\n    event WithdrawFunds(address indexed beneficiary, uint amount);\r\n\r\n    constructor (uint _maxProfit) public {\r\n        owner = msg.sender;\r\n        secretSigner = owner;\r\n        maxProfit = _maxProfit;\r\n        croupierMap[owner] = true;\r\n    }\r\n\r\n    // Standard modifier on methods invokable only by contract owner.\r\n    modifier onlyOwner {\r\n        require (msg.sender == owner, \"OnlyOwner methods called by non-owner.\");\r\n        _;\r\n    }\r\n\r\n    // Standard modifier on methods invokable only by contract owner.\r\n    modifier onlyCroupier {\r\n        bool isCroupier = croupierMap[msg.sender];\r\n        require(isCroupier, \"OnlyCroupier methods called by non-croupier.\");\r\n        _;\r\n    }\r\n\r\n\r\n    // Fallback function deliberately left empty. It's primary use case\r\n    // is to top up the bank roll.\r\n    function () external payable {\r\n\r\n    }\r\n\r\n    // Standard contract ownership transfer implementation,\r\n    function approveNextOwner(address payable _nextOwner) external onlyOwner {\r\n        require (_nextOwner != owner, \"Cannot approve current owner.\");\r\n        nextOwner = _nextOwner;\r\n    }\r\n\r\n    function acceptNextOwner() external {\r\n        require (msg.sender == nextOwner, \"Can only accept preapproved new owner.\");\r\n        owner = nextOwner;\r\n    }\r\n\r\n    // See comment for \"secretSigner\" variable.\r\n    function setSecretSigner(address newSecretSigner) external onlyOwner {\r\n        secretSigner = newSecretSigner;\r\n    }\r\n\r\n    function getSecretSigner() external onlyOwner view returns(address){\r\n        return secretSigner;\r\n    }\r\n\r\n    function addCroupier(address newCroupier) external onlyOwner {\r\n        bool isCroupier = croupierMap[newCroupier];\r\n        if (isCroupier == false) {\r\n            croupierMap[newCroupier] = true;\r\n        }\r\n    }\r\n    \r\n    function deleteCroupier(address newCroupier) external onlyOwner {\r\n        bool isCroupier = croupierMap[newCroupier];\r\n        if (isCroupier == true) {\r\n            croupierMap[newCroupier] = false;\r\n        }\r\n    }\r\n\r\n    function setVIPLibraryAddress(address payable addr) external onlyOwner{\r\n        VIPLibraryAddress = addr;\r\n    }\r\n\r\n    // Change max bet reward. Setting this to zero effectively disables betting.\r\n    function setMaxProfit(uint _maxProfit) public onlyOwner {\r\n        require (_maxProfit < MAX_AMOUNT, \"maxProfit should be a sane number.\");\r\n        maxProfit = _maxProfit;\r\n    }\r\n    \r\n    // Funds withdrawal to cover costs of AceDice operation.\r\n    function withdrawFunds(address payable beneficiary, uint withdrawAmount) external onlyOwner {\r\n        require (withdrawAmount <= address(this).balance, \"Increase amount larger than balance.\");\r\n        if (beneficiary.send(withdrawAmount)){\r\n            emit WithdrawFunds(beneficiary, withdrawAmount);\r\n        }\r\n    }\r\n\r\n    function kill() external onlyOwner {\r\n        // require (lockedInBets == 0, \"All bets should be processed (settled or refunded) before self-destruct.\");\r\n        selfdestruct(owner);\r\n    }\r\n\r\n    function thisBalance() public view returns(uint) {\r\n        return address(this).balance;\r\n    }\r\n\r\n    function payTodayReward(address payable to) external onlyOwner {\r\n        CryptoTycoonsVIPLib vipLib = CryptoTycoonsVIPLib(VIPLibraryAddress);\r\n        vipLib.payRankingReward(to);\r\n    }\r\n\r\n    function getRankingRewardSize() external view returns (uint128) {\r\n        CryptoTycoonsVIPLib vipLib = CryptoTycoonsVIPLib(VIPLibraryAddress);\r\n        return vipLib.getRankingRewardSize();\r\n    }\r\n        \r\n    function handleVIPPaybackAndExp(CryptoTycoonsVIPLib vipLib, address payable gambler, uint amount) internal returns(uint vipPayback) {\r\n        // CryptoTycoonsVIPLib vipLib = CryptoTycoonsVIPLib(VIPLibraryAddress);\r\n        vipLib.addUserExp(gambler, amount);\r\n\r\n        uint rate = vipLib.getVIPBounusRate(gambler);\r\n\r\n        if (rate <= 0)\r\n            return 0;\r\n\r\n        vipPayback = amount * rate / 10000;\r\n        if(vipPayback > 0){\r\n            emit VIPPayback(gambler, vipPayback);\r\n        }\r\n    }\r\n\r\n    function increaseRankingFund(CryptoTycoonsVIPLib vipLib, uint amount) internal{\r\n        uint rankingFunds = uint128(amount * HOUSE_EDGE_PERCENT / 100 * RANK_FUNDS_PERCENT /100);\r\n        // uint128 rankingRewardFee = uint128(amount * HOUSE_EDGE_PERCENT / 100 * 9 /100);\r\n        VIPLibraryAddress.transfer(rankingFunds);\r\n        vipLib.increaseRankingReward(rankingFunds);\r\n    }\r\n\r\n    function getMyAccuAmount() external view returns (uint){\r\n        CryptoTycoonsVIPLib vipLib = CryptoTycoonsVIPLib(VIPLibraryAddress);\r\n        return vipLib.getUserExp(msg.sender);\r\n    }\r\n\r\n    function getJackpotSize() external view returns (uint){\r\n        CryptoTycoonsVIPLib vipLib = CryptoTycoonsVIPLib(VIPLibraryAddress);\r\n        return vipLib.getJackpotSize();\r\n    }\r\n   \r\n    function verifyCommit(uint commit, uint8 v, bytes32 r, bytes32 s) internal view {\r\n        // Check that commit is valid - it has not expired and its signature is valid.\r\n        // require (block.number <= commitLastBlock, \"Commit has expired.\");\r\n        //bytes32 signatureHash = keccak256(abi.encodePacked(commitLastBlock, commit));\r\n        bytes memory prefix = \"\\x19Ethereum Signed Message:\\n32\";\r\n        bytes memory message = abi.encodePacked(commit);\r\n        bytes32 messageHash = keccak256(abi.encodePacked(prefix, keccak256(message)));\r\n        require (secretSigner == ecrecover(messageHash, v, r, s), \"ECDSA signature is not valid.\");\r\n    }\r\n\r\n    function calcHouseEdge(uint amount) public pure returns (uint houseEdge) {\r\n        // 0.02\r\n        houseEdge = amount * HOUSE_EDGE_PERCENT / 100;\r\n        if (houseEdge < HOUSE_EDGE_MINIMUM_AMOUNT) {\r\n            houseEdge = HOUSE_EDGE_MINIMUM_AMOUNT;\r\n        }\r\n    }\r\n\r\n    function calcJackpotFee(uint amount) internal pure returns (uint jackpotFee) {\r\n        // 0.001\r\n        if (amount >= MIN_JACKPOT_BET) {\r\n            jackpotFee = JACKPOT_FEE;\r\n        }\r\n    }\r\n\r\n    function calcRankFundsFee(uint amount) internal pure returns (uint rankFundsFee) {\r\n        // 0.01 * 0.07\r\n        rankFundsFee = amount * RANK_FUNDS_PERCENT / 10000;\r\n    }\r\n\r\n    function calcInviterBenefit(uint amount) internal pure returns (uint invitationFee) {\r\n        // 0.01 * 0.07\r\n        invitationFee = amount * INVITER_BENEFIT_PERCENT / 10000;\r\n    }\r\n\r\n    function processBet(\r\n        uint betMask, uint reveal, \r\n        uint8 v, bytes32 r, bytes32 s, address payable inviter) \r\n    external payable;\r\n}\r\ncontract CardRPS is CryptoTycoonsConstants(10 ether)  {\r\n\r\n    event FailedPayment(address indexed beneficiary, uint amount);\r\n    event Payment(address indexed beneficiary, uint amount, uint playerNum1, uint playerNum2, uint npcNum1, uint npcNum2, uint betAmount, uint rouletteIndex);\r\n    event JackpotPayment(address indexed beneficiary, uint amount, uint playerNum1, uint playerNum2, uint npcNum1, uint npcNum2, uint betAmount);\r\n    \r\n    struct RandomNumber{\r\n        uint8 playerNum1;\r\n        uint8 playerNum2;\r\n        uint8 npcNum1;\r\n        uint8 npcNum2;\r\n        uint8 rouletteIndex;\r\n    }\r\n\r\n    function processBet(\r\n        uint betMask, uint reveal, \r\n        uint8 v, bytes32 r, bytes32 s, address payable inviter) \r\n        external payable {\r\n\r\n        address payable gambler = msg.sender;\r\n\r\n        // Validate input data ranges.\r\n        uint amount = msg.value;\r\n        // require (modulo > 1 && modulo <= MAX_MODULO, \"Modulo should be within range.\");\r\n        require (amount >= MIN_BET && amount <= MAX_AMOUNT, \"Amount should be within range.\");\r\n\r\n        if (inviter != address(0)){\r\n            require(gambler != inviter, \"cannot invite myself\");\r\n        }\r\n        uint commit = uint(keccak256(abi.encodePacked(reveal)));\r\n        verifyCommit(commit, v, r, s);\r\n\r\n\r\n        bytes32 entropy = keccak256(abi.encodePacked(reveal, blockhash(block.number)));\r\n\r\n        processReward(gambler, amount, entropy, inviter);\r\n    }\r\n\r\n    function processReward(\r\n        address payable gambler, uint amount, \r\n        bytes32 entropy, address payable inviter) internal{\r\n\r\n        CryptoTycoonsVIPLib vipLib = CryptoTycoonsVIPLib(VIPLibraryAddress);\r\n        // 1. increate vip exp\r\n        uint _vipPayback = handleVIPPaybackAndExp(vipLib, msg.sender, amount);\r\n\r\n        // The RNG - combine \"reveal\" and blockhash of placeBet using Keccak256. Miners\r\n        // are not aware of \"reveal\" and cannot deduce it from \"commit\" (as Keccak256\r\n        // preimage is intractable), and house is unable to alter the \"reveal\" after\r\n        // placeBet have been mined (as Keccak256 collision finding is also intractable).\r\n        uint seed = uint(entropy);\r\n        // Do a roll by taking a modulo of entropy. Compute winning amount.\r\n\r\n        RandomNumber memory randomNumber = RandomNumber(0, 0, 0, 0, 0);\r\n        // uint mask = 2 ** 8;\r\n        randomNumber.playerNum1 = uint8(seed % 3);\r\n        seed = seed / 2 ** 8;\r\n        \r\n        randomNumber.playerNum2 = uint8(seed % 3);        \r\n        seed = seed / 2 ** 8;\r\n\r\n        randomNumber.npcNum1 = uint8(seed % 3);\r\n        seed = seed / 2 ** 8;\r\n\r\n        randomNumber.npcNum2 = uint8(seed % 3);\r\n        seed = seed / 2 ** 8;\r\n\r\n        randomNumber.rouletteIndex = uint8(seed % 12);\r\n        seed = seed / 2 ** 8;\r\n\r\n        uint jackpotFee = amount >= MIN_JACKPOT_BET ? JACKPOT_FEE : 0;\r\n\r\n        uint houseEdge = amount * HOUSE_EDGE_PERCENT / 100;\r\n\r\n        if (houseEdge < HOUSE_EDGE_MINIMUM_AMOUNT) {\r\n            houseEdge = HOUSE_EDGE_MINIMUM_AMOUNT;\r\n        }\r\n\r\n        handleJackpotReward(vipLib, randomNumber, entropy, gambler, jackpotFee, amount);\r\n\r\n        if(inviter != address(0)){\r\n            // pay 10% of house edge to inviter\r\n            inviter.transfer(amount * HOUSE_EDGE_PERCENT / 100 * 7 /100);\r\n        }\r\n\r\n        \r\n        payBettingReward(gambler, randomNumber, amount, houseEdge, jackpotFee, _vipPayback);\r\n\r\n\r\n        increaseRankingFund(vipLib, amount);\r\n    }\r\n\r\n    function handleJackpotReward(\r\n        CryptoTycoonsVIPLib vipLib, \r\n        RandomNumber memory randomNumber, \r\n        bytes32 entropy,\r\n        address payable gambler, uint jackpotFee, uint amount) private {\r\n\r\n        uint jackpotWin = 0;\r\n        // Roll for a jackpot (if eligible).\r\n        if (amount >= MIN_JACKPOT_BET) {\r\n                        \r\n            VIPLibraryAddress.transfer(jackpotFee);\r\n            vipLib.increaseJackpot(jackpotFee);\r\n\r\n            // The second modulo, statistically independent from the \"main\" dice roll.\r\n            // Effectively you are playing two games at once!\r\n            // uint jackpotRng = (uint(entropy) / modulo) % JACKPOT_MODULO;\r\n\r\n            // Bingo!\r\n            if ((uint(entropy) / 100) % JACKPOT_MODULO == 0) {\r\n                jackpotWin = vipLib.getJackpotSize();\r\n                vipLib.payJackpotReward(gambler);\r\n            }\r\n        }\r\n        \r\n        // Log jackpot win.\r\n        if (jackpotWin > 0) {\r\n            emit JackpotPayment(gambler, \r\n                    jackpotWin, \r\n                    randomNumber.playerNum1, \r\n                    randomNumber.playerNum2, \r\n                    randomNumber.npcNum1, \r\n                    randomNumber.npcNum2, \r\n                    amount);\r\n        }\r\n    }\r\n\r\n    function payBettingReward(\r\n        address payable gambler, \r\n        RandomNumber memory randomNumber, \r\n        uint amount, uint houseEdge, uint jackpotFee,\r\n        uint vipPayback) private {\r\n        uint8 winValue = calculateWinValue(randomNumber); // 0 -> draw, 1 -> user win, 2 -> npc win\r\n\r\n        uint winAmount = 0;\r\n\r\n        if (winValue == 0) {\r\n            // draw\r\n            winAmount = amount - houseEdge - jackpotFee;\r\n        } else if (winValue == 1) {\r\n            // user win\r\n            winAmount = (amount - houseEdge - jackpotFee) \r\n                            * getRouletteRate(randomNumber.rouletteIndex) / 10;\r\n        } else {\r\n\r\n        }\r\n\r\n        winAmount += vipPayback;\r\n        if(winAmount > 0){\r\n            if (gambler.send(winAmount)) {\r\n                emit Payment(gambler, winAmount, \r\n                    randomNumber.playerNum1, \r\n                    randomNumber.playerNum2, \r\n                    randomNumber.npcNum1, \r\n                    randomNumber.npcNum2,\r\n                    amount, randomNumber.rouletteIndex);\r\n            } else {\r\n                emit FailedPayment(gambler, amount);\r\n            }\r\n        }else{\r\n            emit Payment(gambler, winAmount, \r\n                randomNumber.playerNum1, \r\n                randomNumber.playerNum2, \r\n                randomNumber.npcNum1, \r\n                randomNumber.npcNum2,\r\n                amount, randomNumber.rouletteIndex);\r\n        }\r\n        \r\n        // Send the funds to gambler.\r\n        // sendFunds(gambler, winAmount == 0 ? 1 wei : winAmount, winAmount, \r\n        //             randomNumber.playerNum1, \r\n        //             randomNumber.playerNum2, \r\n        //             randomNumber.npcNum1, \r\n        //             randomNumber.npcNum2, \r\n        //             amount,\r\n        //             randomNumber.rouletteIndex);\r\n    }\r\n\r\n    function calculateWinValue(RandomNumber memory randomNumber) private pure returns (uint8){\r\n        uint8 playerNum1 = randomNumber.playerNum1;\r\n        uint8 playerNum2 = randomNumber.playerNum2;\r\n        uint8 npcNum1 = randomNumber.npcNum1;\r\n        uint8 npcNum2 = randomNumber.npcNum2;\r\n\r\n        uint8 winValue = 0;\r\n        if (playerNum1 == npcNum1){ // num 0 -> scissors, 1 -> rock, 2 -> papper\r\n            if (playerNum2 == npcNum2){\r\n                winValue = 0;\r\n            } else if(playerNum2 == 0 && npcNum2 == 2){\r\n                winValue = 1; // user win\r\n            } else if(playerNum2 == 1 && npcNum2 == 0){\r\n                winValue = 1; // user win\r\n            } else if(playerNum2 == 2 && npcNum2 == 1){\r\n                winValue = 1; // user win\r\n            } else{\r\n                winValue = 2; // npc win\r\n            }\r\n        } else if(playerNum1 == 0 && npcNum1 == 2){\r\n            winValue = 1; // user win\r\n        } else if(playerNum1 == 1 && npcNum1 == 0){\r\n            winValue = 1; // user win\r\n        } else if(playerNum1 == 2 && npcNum1 == 1){\r\n            winValue = 1; // user win\r\n        } else{\r\n            winValue = 2; // npc win\r\n        } \r\n        return winValue;\r\n    }\r\n\r\n    function getRouletteRate(uint index) private pure returns (uint8){\r\n        uint8 rate = 11;\r\n        if (index == 0){\r\n            rate = 50;\r\n        } else if(index== 1){\r\n            rate = 11;\r\n        } else if(index== 2){\r\n            rate = 20;\r\n        } else if(index== 3){\r\n            rate = 15;\r\n        } else if(index== 4){\r\n            rate = 20;\r\n        } else if(index== 5){\r\n            rate = 11;\r\n        } else if(index== 6){\r\n            rate = 20;\r\n        } else if(index== 7){\r\n            rate = 15;\r\n        } else if(index== 8){\r\n            rate = 20;\r\n        } else if(index== 9){\r\n            rate = 11;\r\n        } else if(index== 10){\r\n            rate = 20;\r\n        } else if(index== 11){\r\n            rate = 15;\r\n        }\r\n        return rate;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"thisBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"}],\"name\":\"payTodayReward\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"setVIPLibraryAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"kill\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newCroupier\",\"type\":\"address\"}],\"name\":\"addCroupier\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"calcHouseEdge\",\"outputs\":[{\"name\":\"houseEdge\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"secretSigner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getRankingRewardSize\",\"outputs\":[{\"name\":\"\",\"type\":\"uint128\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getMyAccuAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getSecretSigner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"VIPLibraryAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxProfit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"beneficiary\",\"type\":\"address\"},{\"name\":\"withdrawAmount\",\"type\":\"uint256\"}],\"name\":\"withdrawFunds\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"betMask\",\"type\":\"uint256\"},{\"name\":\"reveal\",\"type\":\"uint256\"},{\"name\":\"v\",\"type\":\"uint8\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"},{\"name\":\"inviter\",\"type\":\"address\"}],\"name\":\"processBet\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptNextOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newCroupier\",\"type\":\"address\"}],\"name\":\"deleteCroupier\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_nextOwner\",\"type\":\"address\"}],\"name\":\"approveNextOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newSecretSigner\",\"type\":\"address\"}],\"name\":\"setSecretSigner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getJackpotSize\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_maxProfit\",\"type\":\"uint256\"}],\"name\":\"setMaxProfit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"FailedPayment\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"playerNum1\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"playerNum2\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"npcNum1\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"npcNum2\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"betAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"rouletteIndex\",\"type\":\"uint256\"}],\"name\":\"Payment\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"playerNum1\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"playerNum2\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"npcNum1\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"npcNum2\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"betAmount\",\"type\":\"uint256\"}],\"name\":\"JackpotPayment\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"VIPPayback\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"WithdrawFunds\",\"type\":\"event\"}]","ContractName":"CardRPS","CompilerVersion":"v0.5.2+commit.1df8f40c","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://073d99bf44a04442e22a4d301d5d4253d6d15ced98380bd868c3f7fd0ac65854"}]}