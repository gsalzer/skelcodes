{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.24;\r\n\r\n// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipRenounced(address indexed previousOwner);\r\n  event OwnershipTransferred(\r\n    address indexed previousOwner,\r\n    address indexed newOwner\r\n  );\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  constructor() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to relinquish control of the contract.\r\n   * @notice Renouncing to ownership will leave the contract without an owner.\r\n   * It will not be possible to call the functions with the `onlyOwner`\r\n   * modifier anymore.\r\n   */\r\n  function renounceOwnership() public onlyOwner {\r\n    emit OwnershipRenounced(owner);\r\n    owner = address(0);\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address _newOwner) public onlyOwner {\r\n    _transferOwnership(_newOwner);\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function _transferOwnership(address _newOwner) internal {\r\n    require(_newOwner != address(0));\r\n    emit OwnershipTransferred(owner, _newOwner);\r\n    owner = _newOwner;\r\n  }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/math/SafeMath.sol\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return a / b;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n// File: contracts/interfaces/IRegistry.sol\r\n\r\n// limited ContractRegistry definition\r\ninterface IRegistry {\r\n  function owner()\r\n    external\r\n    returns (address);\r\n\r\n  function updateContractAddress(\r\n    string _name,\r\n    address _address\r\n  )\r\n    external\r\n    returns (address);\r\n\r\n  function getContractAddress(\r\n    string _name\r\n  )\r\n    external\r\n    view\r\n    returns (address);\r\n}\r\n\r\n// File: contracts/interfaces/IPoaToken.sol\r\n\r\ninterface IPoaToken {\r\n  function initializeToken\r\n  (\r\n    bytes32 _name32, // bytes32 of name string\r\n    bytes32 _symbol32, // bytes32 of symbol string\r\n    address _issuer,\r\n    address _custodian,\r\n    address _registry,\r\n    uint256 _totalSupply // token total supply\r\n  )\r\n    external\r\n    returns (bool);\r\n\r\n  function issuer()\r\n    external\r\n    view\r\n    returns (address);\r\n\r\n  function startPreFunding()\r\n    external\r\n    returns (bool);\r\n\r\n  function pause()\r\n    external;\r\n\r\n  function unpause()\r\n    external;\r\n\r\n  function terminate()\r\n    external\r\n    returns (bool);\r\n\r\n  function proofOfCustody()\r\n    external\r\n    view\r\n    returns (string);\r\n}\r\n\r\n// File: contracts/interfaces/IPoaCrowdsale.sol\r\n\r\ninterface IPoaCrowdsale {\r\n  function initializeCrowdsale(\r\n    bytes32 _fiatCurrency32,                // fiat currency string, e.g. 'EUR'\r\n    uint256 _startTimeForFundingPeriod,     // future UNIX timestamp\r\n    uint256 _durationForFiatFundingPeriod,  // duration of fiat funding period in seconds\r\n    uint256 _durationForEthFundingPeriod,   // duration of ETH funding period in seconds\r\n    uint256 _durationForActivationPeriod,   // duration of activation period in seconds\r\n    uint256 _fundingGoalInCents             // funding goal in fiat cents\r\n  )\r\n    external\r\n    returns (bool);\r\n}\r\n\r\n// File: contracts/PoaProxyCommon.sol\r\n\r\n/**\r\n  @title PoaProxyCommon acts as a convention between:\r\n  - PoaCommon (and its inheritants: PoaToken & PoaCrowdsale)\r\n  - PoaProxy\r\n\r\n  It dictates where to read and write storage\r\n*/\r\ncontract PoaProxyCommon {\r\n  /*****************************\r\n  * Start Proxy Common Storage *\r\n  *****************************/\r\n\r\n  // PoaTokenMaster logic contract used by proxies\r\n  address public poaTokenMaster;\r\n\r\n  // PoaCrowdsaleMaster logic contract used by proxies\r\n  address public poaCrowdsaleMaster;\r\n\r\n  // Registry used for getting other contract addresses\r\n  address public registry;\r\n\r\n  /***************************\r\n  * End Proxy Common Storage *\r\n  ***************************/\r\n\r\n\r\n  /*********************************\r\n  * Start Common Utility Functions *\r\n  *********************************/\r\n\r\n  /// @notice Gets a given contract address by bytes32 in order to save gas\r\n  function getContractAddress(string _name)\r\n    public\r\n    view\r\n    returns (address _contractAddress)\r\n  {\r\n    bytes4 _signature = bytes4(keccak256(\"getContractAddress32(bytes32)\"));\r\n    bytes32 _name32 = keccak256(abi.encodePacked(_name));\r\n\r\n    assembly {\r\n      let _registry := sload(registry_slot) // load registry address from storage\r\n      let _pointer := mload(0x40)          // Set _pointer to free memory pointer\r\n      mstore(_pointer, _signature)         // Store _signature at _pointer\r\n      mstore(add(_pointer, 0x04), _name32) // Store _name32 at _pointer offset by 4 bytes for pre-existing _signature\r\n\r\n      // staticcall(g, a, in, insize, out, outsize) => returns 0 on error, 1 on success\r\n      let result := staticcall(\r\n        gas,       // g = gas: whatever was passed already\r\n        _registry, // a = address: address in storage\r\n        _pointer,  // in = mem in  mem[in..(in+insize): set to free memory pointer\r\n        0x24,      // insize = mem insize  mem[in..(in+insize): size of signature (bytes4) + bytes32 = 0x24\r\n        _pointer,  // out = mem out  mem[out..(out+outsize): output assigned to this storage address\r\n        0x20       // outsize = mem outsize  mem[out..(out+outsize): output should be 32byte slot (address size = 0x14 <  slot size 0x20)\r\n      )\r\n\r\n      // revert if not successful\r\n      if iszero(result) {\r\n        revert(0, 0)\r\n      }\r\n\r\n      _contractAddress := mload(_pointer) // Assign result to return value\r\n      mstore(0x40, add(_pointer, 0x24))   // Advance free memory pointer by largest _pointer size\r\n    }\r\n  }\r\n\r\n  /*******************************\r\n  * End Common Utility Functions *\r\n  *******************************/\r\n}\r\n\r\n// File: contracts/PoaProxy.sol\r\n\r\n/**\r\n  @title This contract manages the storage of:\r\n  - PoaProxy\r\n  - PoaToken\r\n  - PoaCrowdsale\r\n\r\n  @notice PoaProxy uses chained \"delegatecall()\"s to call functions on\r\n  PoaToken and PoaCrowdsale and sets the resulting storage\r\n  here on PoaProxy.\r\n\r\n  @dev `getContractAddress(\"PoaLogger\").call()` does not use the return value\r\n  because we would rather contract functions to continue even if the event\r\n  did not successfully trigger on the logger contract.\r\n*/\r\ncontract PoaProxy is PoaProxyCommon {\r\n  uint8 public constant version = 1;\r\n\r\n  event ProxyUpgraded(address upgradedFrom, address upgradedTo);\r\n\r\n  /**\r\n    @notice Stores addresses of our contract registry\r\n    as well as the PoaToken and PoaCrowdsale master\r\n    contracts to forward calls to.\r\n  */\r\n  constructor(\r\n    address _poaTokenMaster,\r\n    address _poaCrowdsaleMaster,\r\n    address _registry\r\n  )\r\n    public\r\n  {\r\n    // Ensure that none of the given addresses are empty\r\n    require(_poaTokenMaster != address(0));\r\n    require(_poaCrowdsaleMaster != address(0));\r\n    require(_registry != address(0));\r\n\r\n    // Set addresses in common storage using deterministic storage slots\r\n    poaTokenMaster = _poaTokenMaster;\r\n    poaCrowdsaleMaster = _poaCrowdsaleMaster;\r\n    registry = _registry;\r\n  }\r\n\r\n  /*****************************\r\n   * Start Proxy State Helpers *\r\n   *****************************/\r\n\r\n  /**\r\n    @notice Ensures that a given address is a contract by\r\n    making sure it has code. Used during upgrading to make\r\n    sure the new addresses to upgrade to are smart contracts.\r\n   */\r\n  function isContract(address _address)\r\n    private\r\n    view\r\n    returns (bool)\r\n  {\r\n    uint256 _size;\r\n    assembly { _size := extcodesize(_address) }\r\n\r\n    return _size > 0;\r\n  }\r\n\r\n  /***************************\r\n   * End Proxy State Helpers *\r\n   ***************************/\r\n\r\n\r\n  /*****************************\r\n   * Start Proxy State Setters *\r\n   *****************************/\r\n\r\n  /// @notice Update the stored \"poaTokenMaster\" address to upgrade the PoaToken master contract\r\n  function proxyChangeTokenMaster(address _newMaster)\r\n    public\r\n    returns (bool)\r\n  {\r\n    require(msg.sender == getContractAddress(\"PoaManager\"));\r\n    require(_newMaster != address(0));\r\n    require(poaTokenMaster != _newMaster);\r\n    require(isContract(_newMaster));\r\n    address _oldMaster = poaTokenMaster;\r\n    poaTokenMaster = _newMaster;\r\n\r\n    emit ProxyUpgraded(_oldMaster, _newMaster);\r\n    getContractAddress(\"PoaLogger\").call(\r\n      abi.encodeWithSignature(\r\n        \"logProxyUpgraded(address,address)\",\r\n        _oldMaster,\r\n        _newMaster\r\n      )\r\n    );\r\n\r\n    return true;\r\n  }\r\n\r\n  /// @notice Update the stored `poaCrowdsaleMaster` address to upgrade the PoaCrowdsale master contract\r\n  function proxyChangeCrowdsaleMaster(address _newMaster)\r\n    public\r\n    returns (bool)\r\n  {\r\n    require(msg.sender == getContractAddress(\"PoaManager\"));\r\n    require(_newMaster != address(0));\r\n    require(poaCrowdsaleMaster != _newMaster);\r\n    require(isContract(_newMaster));\r\n    address _oldMaster = poaCrowdsaleMaster;\r\n    poaCrowdsaleMaster = _newMaster;\r\n\r\n    emit ProxyUpgraded(_oldMaster, _newMaster);\r\n    getContractAddress(\"PoaLogger\").call(\r\n      abi.encodeWithSignature(\r\n        \"logProxyUpgraded(address,address)\",\r\n        _oldMaster,\r\n        _newMaster\r\n      )\r\n    );\r\n\r\n    return true;\r\n  }\r\n\r\n  /***************************\r\n   * End Proxy State Setters *\r\n   ***************************/\r\n\r\n  /**\r\n    @notice Fallback function for all proxied functions using \"delegatecall()\".\r\n    It will first forward all functions to the \"poaTokenMaster\" address. If the\r\n    called function isn't found there, then \"poaTokenMaster\"'s fallback function\r\n    will forward the call to \"poaCrowdsale\". If the called function also isn't\r\n    found there, it will fail at last.\r\n  */\r\n  function()\r\n    external\r\n    payable\r\n  {\r\n    assembly {\r\n      // Load PoaToken master address from first storage pointer\r\n      let _poaTokenMaster := sload(poaTokenMaster_slot)\r\n\r\n      // calldatacopy(t, f, s)\r\n      calldatacopy(\r\n        0x0, // t = mem position to\r\n        0x0, // f = mem position from\r\n        calldatasize // s = size bytes\r\n      )\r\n\r\n      // delegatecall(g, a, in, insize, out, outsize) => returns \"0\" on error, or \"1\" on success\r\n      let result := delegatecall(\r\n        gas, // g = gas\r\n        _poaTokenMaster, // a = address\r\n        0x0, // in = mem in  mem[in..(in+insize)\r\n        calldatasize, // insize = mem insize  mem[in..(in+insize)\r\n        0x0, // out = mem out  mem[out..(out+outsize)\r\n        0 // outsize = mem outsize  mem[out..(out+outsize)\r\n      )\r\n\r\n      // Check if the call was successful\r\n      if iszero(result) {\r\n        // Revert if call failed\r\n        revert(0, 0)\r\n      }\r\n\r\n      // returndatacopy(t, f, s)\r\n      returndatacopy(\r\n        0x0, // t = mem position to\r\n        0x0,  // f = mem position from\r\n        returndatasize // s = size bytes\r\n      )\r\n      // Return if call succeeded\r\n      return(\r\n        0x0,\r\n        returndatasize\r\n      )\r\n    }\r\n  }\r\n}\r\n\r\n// File: contracts/PoaManager.sol\r\n\r\ncontract PoaManager is Ownable {\r\n  using SafeMath for uint256;\r\n\r\n  uint256 constant version = 1;\r\n\r\n  IRegistry public registry;\r\n\r\n  struct EntityState {\r\n    uint256 index;\r\n    bool active;\r\n  }\r\n\r\n  // Keeping a list for addresses we track for easy access\r\n  address[] private issuerAddressList;\r\n  address[] private tokenAddressList;\r\n\r\n  // A mapping for each address we track\r\n  mapping (address => EntityState) private tokenMap;\r\n  mapping (address => EntityState) private issuerMap;\r\n\r\n  event IssuerAdded(address indexed issuer);\r\n  event IssuerRemoved(address indexed issuer);\r\n  event IssuerStatusChanged(address indexed issuer, bool active);\r\n\r\n  event TokenAdded(address indexed token);\r\n  event TokenRemoved(address indexed token);\r\n  event TokenStatusChanged(address indexed token, bool active);\r\n\r\n  modifier isNewIssuer(address _issuerAddress) {\r\n    require(_issuerAddress != address(0));\r\n    require(issuerMap[_issuerAddress].index == 0);\r\n    _;\r\n  }\r\n\r\n  modifier onlyActiveIssuer() {\r\n    EntityState memory entity = issuerMap[msg.sender];\r\n    require(entity.active);\r\n    _;\r\n  }\r\n\r\n  constructor(address _registryAddress)\r\n    public\r\n  {\r\n    require(_registryAddress != address(0));\r\n    registry = IRegistry(_registryAddress);\r\n  }\r\n\r\n  //\r\n  // Entity functions\r\n  //\r\n\r\n  function doesEntityExist(\r\n    address _entityAddress,\r\n    EntityState entity\r\n  )\r\n    private\r\n    pure\r\n    returns (bool)\r\n  {\r\n    return (_entityAddress != address(0) && entity.index != 0);\r\n  }\r\n\r\n  function addEntity(\r\n    address _entityAddress,\r\n    address[] storage entityList,\r\n    bool _active\r\n  )\r\n    private\r\n    returns (EntityState)\r\n  {\r\n    entityList.push(_entityAddress);\r\n    // we do not offset by `-1` so that we never have `entity.index = 0` as this is what is\r\n    // used to check for existence in modifier [doesEntityExist]\r\n    uint256 index = entityList.length;\r\n    EntityState memory entity = EntityState(index, _active);\r\n\r\n    return entity;\r\n  }\r\n\r\n  function removeEntity(\r\n    EntityState _entityToRemove,\r\n    address[] storage _entityList\r\n  )\r\n    private\r\n    returns (address, uint256)\r\n  {\r\n    // we offset by -1 here to account for how `addEntity` marks the `entity.index` value\r\n    uint256 index = _entityToRemove.index.sub(1);\r\n\r\n    // swap the entity to be removed with the last element in the list\r\n    _entityList[index] = _entityList[_entityList.length - 1];\r\n\r\n    // because we wanted seperate mappings for token and issuer, and we cannot pass a storage mapping\r\n    // as a function argument, this abstraction is leaky; we return the address and index so the\r\n    // caller can update the mapping\r\n    address entityToSwapAddress = _entityList[index];\r\n\r\n    // we do not need to delete the element, the compiler should clean up for us\r\n    _entityList.length--;\r\n\r\n    return (entityToSwapAddress, _entityToRemove.index);\r\n  }\r\n\r\n  function setEntityActiveValue(\r\n    EntityState storage entity,\r\n    bool _active\r\n  )\r\n    private\r\n  {\r\n    require(entity.active != _active);\r\n    entity.active = _active;\r\n  }\r\n\r\n  //\r\n  // Issuer functions\r\n  //\r\n\r\n  // Return all tracked issuer addresses\r\n  function getIssuerAddressList()\r\n    public\r\n    view\r\n    returns (address[])\r\n  {\r\n    return issuerAddressList;\r\n  }\r\n\r\n  // Add an issuer and set active value to true\r\n  function addIssuer(address _issuerAddress)\r\n    public\r\n    onlyOwner\r\n    isNewIssuer(_issuerAddress)\r\n  {\r\n    issuerMap[_issuerAddress] = addEntity(\r\n      _issuerAddress,\r\n      issuerAddressList,\r\n      true\r\n    );\r\n\r\n    emit IssuerAdded(_issuerAddress);\r\n  }\r\n\r\n  // Remove an issuer\r\n  function removeIssuer(address _issuerAddress)\r\n    public\r\n    onlyOwner\r\n  {\r\n    require(doesEntityExist(_issuerAddress, issuerMap[_issuerAddress]));\r\n\r\n    address addressToUpdate;\r\n    uint256 indexUpdate;\r\n    (addressToUpdate, indexUpdate) = removeEntity(issuerMap[_issuerAddress], issuerAddressList);\r\n    issuerMap[addressToUpdate].index = indexUpdate;\r\n    delete issuerMap[_issuerAddress];\r\n\r\n    emit IssuerRemoved(_issuerAddress);\r\n  }\r\n\r\n  // Set previously delisted issuer to listed\r\n  function listIssuer(address _issuerAddress)\r\n    public\r\n    onlyOwner\r\n  {\r\n    require(doesEntityExist(_issuerAddress, issuerMap[_issuerAddress]));\r\n\r\n    setEntityActiveValue(issuerMap[_issuerAddress], true);\r\n    emit IssuerStatusChanged(_issuerAddress, true);\r\n  }\r\n\r\n  // Set previously listed issuer to delisted\r\n  function delistIssuer(address _issuerAddress)\r\n    public\r\n    onlyOwner\r\n  {\r\n    require(doesEntityExist(_issuerAddress, issuerMap[_issuerAddress]));\r\n\r\n    setEntityActiveValue(issuerMap[_issuerAddress], false);\r\n    emit IssuerStatusChanged(_issuerAddress, false);\r\n  }\r\n\r\n  function isActiveIssuer(address _issuerAddress)\r\n    public\r\n    view\r\n    returns (bool)\r\n  {\r\n    require(doesEntityExist(_issuerAddress, issuerMap[_issuerAddress]));\r\n\r\n    return issuerMap[_issuerAddress].active;\r\n  }\r\n\r\n  function isRegisteredIssuer(address _issuerAddress)\r\n    external\r\n    view\r\n    returns (bool)\r\n  {\r\n    return doesEntityExist(_issuerAddress, issuerMap[_issuerAddress]);\r\n  }\r\n\r\n  //\r\n  // Token functions\r\n  //\r\n\r\n  // Return all tracked token addresses\r\n  function getTokenAddressList()\r\n    public\r\n    view\r\n    returns (address[])\r\n  {\r\n    return tokenAddressList;\r\n  }\r\n\r\n  function createPoaTokenProxy()\r\n    private\r\n    returns (address _proxyContract)\r\n  {\r\n    address _poaTokenMaster = registry.getContractAddress(\"PoaTokenMaster\");\r\n    address _poaCrowdsaleMaster = registry.getContractAddress(\"PoaCrowdsaleMaster\");\r\n    _proxyContract = new PoaProxy(_poaTokenMaster, _poaCrowdsaleMaster, address(registry));\r\n  }\r\n\r\n  /**\r\n    @notice Creates a PoaToken contract with given parameters, and set active value to false\r\n    @param _fiatCurrency32 Fiat symbol used in ExchangeRates\r\n    @param _startTimeForFundingPeriod Given as unix time in seconds since 01.01.1970\r\n    @param _durationForFiatFundingPeriod How long fiat funding can last, given in seconds\r\n    @param _durationForEthFundingPeriod How long eth funding can last, given in seconds\r\n    @param _durationForActivationPeriod How long a custodian has to activate token, given in seconds\r\n    @param _fundingGoalInCents Given as fiat cents\r\n   */\r\n  function addNewToken(\r\n    bytes32 _name32,\r\n    bytes32 _symbol32,\r\n    bytes32 _fiatCurrency32,\r\n    address _custodian,\r\n    uint256 _totalSupply,\r\n    uint256 _startTimeForFundingPeriod,\r\n    uint256 _durationForFiatFundingPeriod,\r\n    uint256 _durationForEthFundingPeriod,\r\n    uint256 _durationForActivationPeriod,\r\n    uint256 _fundingGoalInCents\r\n  )\r\n    public\r\n    onlyActiveIssuer\r\n    returns (address)\r\n  {\r\n    address _tokenAddress = createPoaTokenProxy();\r\n\r\n    IPoaToken(_tokenAddress).initializeToken(\r\n      _name32,\r\n      _symbol32,\r\n      msg.sender,\r\n      _custodian,\r\n      registry,\r\n      _totalSupply\r\n    );\r\n\r\n    IPoaCrowdsale(_tokenAddress).initializeCrowdsale(\r\n      _fiatCurrency32,\r\n      _startTimeForFundingPeriod,\r\n      _durationForFiatFundingPeriod,\r\n      _durationForEthFundingPeriod,\r\n      _durationForActivationPeriod,\r\n      _fundingGoalInCents\r\n    );\r\n\r\n    tokenMap[_tokenAddress] = addEntity(\r\n      _tokenAddress,\r\n      tokenAddressList,\r\n      false\r\n    );\r\n\r\n    emit TokenAdded(_tokenAddress);\r\n\r\n    return _tokenAddress;\r\n  }\r\n\r\n  /**\r\n    @notice Add existing `PoaProxy` contracts when `PoaManager` has been upgraded\r\n    @param _tokenAddress the `PoaProxy` address to address\r\n    @param _isListed if `PoaProxy` should be added as active or inactive\r\n    @dev `PoaProxy` contracts can only be added when the POA's issuer is already listed.\r\n         Furthermore, we use `issuer()` as check if `_tokenAddress` represents a `PoaProxy`.\r\n   */\r\n  function addExistingToken(address _tokenAddress, bool _isListed)\r\n    external\r\n    onlyOwner\r\n  {\r\n    require(!doesEntityExist(_tokenAddress, tokenMap[_tokenAddress]));\r\n    // Issuer address of `_tokenAddress` must be an active Issuer.\r\n    // If `_tokenAddress` is not an instance of PoaProxy, this will fail as desired.\r\n    require(isActiveIssuer(IPoaToken(_tokenAddress).issuer()));\r\n\r\n    tokenMap[_tokenAddress] = addEntity(\r\n      _tokenAddress,\r\n      tokenAddressList,\r\n      _isListed\r\n    );\r\n  }\r\n\r\n  // Remove a token\r\n  function removeToken(address _tokenAddress)\r\n    public\r\n    onlyOwner\r\n  {\r\n    require(doesEntityExist(_tokenAddress, tokenMap[_tokenAddress]));\r\n\r\n    address addressToUpdate;\r\n    uint256 indexUpdate;\r\n    (addressToUpdate, indexUpdate) = removeEntity(tokenMap[_tokenAddress], tokenAddressList);\r\n    tokenMap[addressToUpdate].index = indexUpdate;\r\n    delete tokenMap[_tokenAddress];\r\n\r\n    emit TokenRemoved(_tokenAddress);\r\n  }\r\n\r\n  // Set previously delisted token to listed\r\n  function listToken(address _tokenAddress)\r\n    public\r\n    onlyOwner\r\n  {\r\n    require(doesEntityExist(_tokenAddress, tokenMap[_tokenAddress]));\r\n\r\n    setEntityActiveValue(tokenMap[_tokenAddress], true);\r\n    emit TokenStatusChanged(_tokenAddress, true);\r\n  }\r\n\r\n  // Set previously listed token to delisted\r\n  function delistToken(address _tokenAddress)\r\n    public\r\n    onlyOwner\r\n  {\r\n    require(doesEntityExist(_tokenAddress, tokenMap[_tokenAddress]));\r\n\r\n    setEntityActiveValue(tokenMap[_tokenAddress], false);\r\n    emit TokenStatusChanged(_tokenAddress, false);\r\n  }\r\n\r\n  function isActiveToken(address _tokenAddress)\r\n    public\r\n    view\r\n    returns (bool)\r\n  {\r\n    require(doesEntityExist(_tokenAddress, tokenMap[_tokenAddress]));\r\n\r\n    return tokenMap[_tokenAddress].active;\r\n  }\r\n\r\n  function isRegisteredToken(address _tokenAddress)\r\n    external\r\n    view\r\n    returns (bool)\r\n  {\r\n    return doesEntityExist(_tokenAddress, tokenMap[_tokenAddress]);\r\n  }\r\n\r\n  //\r\n  // Token onlyOwner functions as PoaManger is `owner` of all PoaToken\r\n  //\r\n\r\n  // Allow unpausing a listed PoaToken\r\n  function pauseToken(address _tokenAddress)\r\n    public\r\n    onlyOwner\r\n  {\r\n    IPoaToken(_tokenAddress).pause();\r\n  }\r\n\r\n  // Allow unpausing a listed PoaToken\r\n  function unpauseToken(IPoaToken _tokenAddress)\r\n    public\r\n    onlyOwner\r\n  {\r\n    _tokenAddress.unpause();\r\n  }\r\n\r\n  // Allow terminating a listed PoaToken\r\n  function terminateToken(IPoaToken _tokenAddress)\r\n    public\r\n    onlyOwner\r\n  {\r\n    _tokenAddress.terminate();\r\n  }\r\n\r\n  // upgrade an existing PoaToken proxy to what is stored in ContractRegistry\r\n  function upgradeToken(PoaProxy _proxyToken)\r\n    external\r\n    onlyOwner\r\n    returns (bool)\r\n  {\r\n    _proxyToken.proxyChangeTokenMaster(\r\n      registry.getContractAddress(\"PoaTokenMaster\")\r\n    );\r\n\r\n    return true;\r\n  }\r\n\r\n  // upgrade an existing PoaCrowdsale proxy to what is stored in ContractRegistry\r\n  function upgradeCrowdsale(PoaProxy _proxyToken)\r\n    external\r\n    onlyOwner\r\n    returns (bool)\r\n  {\r\n    _proxyToken.proxyChangeCrowdsaleMaster(\r\n      registry.getContractAddress(\"PoaCrowdsaleMaster\")\r\n    );\r\n\r\n    return true;\r\n  }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_name32\",\"type\":\"bytes32\"},{\"name\":\"_symbol32\",\"type\":\"bytes32\"},{\"name\":\"_fiatCurrency32\",\"type\":\"bytes32\"},{\"name\":\"_custodian\",\"type\":\"address\"},{\"name\":\"_totalSupply\",\"type\":\"uint256\"},{\"name\":\"_startTimeForFundingPeriod\",\"type\":\"uint256\"},{\"name\":\"_durationForFiatFundingPeriod\",\"type\":\"uint256\"},{\"name\":\"_durationForEthFundingPeriod\",\"type\":\"uint256\"},{\"name\":\"_durationForActivationPeriod\",\"type\":\"uint256\"},{\"name\":\"_fundingGoalInCents\",\"type\":\"uint256\"}],\"name\":\"addNewToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenAddress\",\"type\":\"address\"}],\"name\":\"listToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_issuerAddress\",\"type\":\"address\"}],\"name\":\"addIssuer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_issuerAddress\",\"type\":\"address\"}],\"name\":\"isRegisteredIssuer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenAddress\",\"type\":\"address\"}],\"name\":\"unpauseToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"name\":\"_isListed\",\"type\":\"bool\"}],\"name\":\"addExistingToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_issuerAddress\",\"type\":\"address\"}],\"name\":\"removeIssuer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenAddress\",\"type\":\"address\"}],\"name\":\"isActiveToken\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenAddress\",\"type\":\"address\"}],\"name\":\"removeToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_proxyToken\",\"type\":\"address\"}],\"name\":\"upgradeToken\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_issuerAddress\",\"type\":\"address\"}],\"name\":\"delistIssuer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTokenAddressList\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenAddress\",\"type\":\"address\"}],\"name\":\"isRegisteredToken\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"registry\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenAddress\",\"type\":\"address\"}],\"name\":\"pauseToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getIssuerAddressList\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenAddress\",\"type\":\"address\"}],\"name\":\"delistToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenAddress\",\"type\":\"address\"}],\"name\":\"terminateToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_issuerAddress\",\"type\":\"address\"}],\"name\":\"isActiveIssuer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_issuerAddress\",\"type\":\"address\"}],\"name\":\"listIssuer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_proxyToken\",\"type\":\"address\"}],\"name\":\"upgradeCrowdsale\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_registryAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"issuer\",\"type\":\"address\"}],\"name\":\"IssuerAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"issuer\",\"type\":\"address\"}],\"name\":\"IssuerRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"issuer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"active\",\"type\":\"bool\"}],\"name\":\"IssuerStatusChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"token\",\"type\":\"address\"}],\"name\":\"TokenAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"token\",\"type\":\"address\"}],\"name\":\"TokenRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"active\",\"type\":\"bool\"}],\"name\":\"TokenStatusChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"}],\"name\":\"OwnershipRenounced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"PoaManager","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"0000000000000000000000005973376b603268fe4251d13040226078257014f8","Library":"","SwarmSource":"bzzr://68fb153aab6ea446eb7f0a299aec399928ed8d899dc798bc3cd6c9d99c5193e3"}]}