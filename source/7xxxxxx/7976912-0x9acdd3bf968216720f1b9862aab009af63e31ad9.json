{"status":"1","message":"OK","result":[{"SourceCode":"// File: contracts/lib/ownership/Ownable.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\ncontract Ownable {\r\n    address public owner;\r\n    event OwnershipTransferred(address indexed previousOwner,address indexed newOwner);\r\n\r\n    /// @dev The Ownable constructor sets the original `owner` of the contract to the sender account.\r\n    constructor() public { owner = msg.sender; }\r\n\r\n    /// @dev Throws if called by any contract other than latest designated caller\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    /// @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n    /// @param newOwner The address to transfer ownership to.\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        require(newOwner != address(0));\r\n        emit OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n}\r\n\r\n// File: contracts/lib/token/FactoryTokenInterface.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\ncontract FactoryTokenInterface is Ownable {\r\n    function balanceOf(address _owner) public view returns (uint256);\r\n    function transfer(address _to, uint256 _value) public returns (bool);\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool);\r\n    function approve(address _spender, uint256 _value) public returns (bool);\r\n    function allowance(address _owner, address _spender) public view returns (uint256);\r\n    function mint(address _to, uint256 _amount) public returns (bool);\r\n    function burnFrom(address _from, uint256 _value) public;\r\n}\r\n\r\n// File: contracts/lib/token/TokenFactoryInterface.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\ncontract TokenFactoryInterface {\r\n    function create(string _name, string _symbol) public returns (FactoryTokenInterface);\r\n}\r\n\r\n// File: contracts/lib/ownership/ZapCoordinatorInterface.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\ncontract ZapCoordinatorInterface is Ownable {\r\n    function addImmutableContract(string contractName, address newAddress) external;\r\n    function updateContract(string contractName, address newAddress) external;\r\n    function getContractName(uint index) public view returns (string);\r\n    function getContract(string contractName) public view returns (address);\r\n    function updateAllDependencies() external;\r\n}\r\n\r\n// File: contracts/platform/bondage/BondageInterface.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\ncontract BondageInterface {\r\n    function bond(address, bytes32, uint256) external returns(uint256);\r\n    function unbond(address, bytes32, uint256) external returns (uint256);\r\n    function delegateBond(address, address, bytes32, uint256) external returns(uint256);\r\n    function escrowDots(address, address, bytes32, uint256) external returns (bool);\r\n    function releaseDots(address, address, bytes32, uint256) external returns (bool);\r\n    function returnDots(address, address, bytes32, uint256) external returns (bool success);\r\n    function calcZapForDots(address, bytes32, uint256) external view returns (uint256);\r\n    function currentCostOfDot(address, bytes32, uint256) public view returns (uint256);\r\n    function getDotsIssued(address, bytes32) public view returns (uint256);\r\n    function getBoundDots(address, address, bytes32) public view returns (uint256);\r\n    function getZapBound(address, bytes32) public view returns (uint256);\r\n    function dotLimit( address, bytes32) public view returns (uint256);\r\n}\r\n\r\n// File: contracts/platform/bondage/currentCost/CurrentCostInterface.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\ncontract CurrentCostInterface {\r\n    function _currentCostOfDot(address, bytes32, uint256) public view returns (uint256);\r\n    function _dotLimit(address, bytes32) public view returns (uint256);\r\n    function _costOfNDots(address, bytes32, uint256, uint256) public view returns (uint256);\r\n}\r\n\r\n// File: contracts/platform/registry/RegistryInterface.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\ncontract RegistryInterface {\r\n    function initiateProvider(uint256, bytes32) public returns (bool);\r\n    function initiateProviderCurve(bytes32, int256[], address) public returns (bool);\r\n    function setEndpointParams(bytes32, bytes32[]) public;\r\n    function getEndpointParams(address, bytes32) public view returns (bytes32[]);\r\n    function getProviderPublicKey(address) public view returns (uint256);\r\n    function getProviderTitle(address) public view returns (bytes32);\r\n    function setProviderParameter(bytes32, bytes) public;\r\n    function setProviderTitle(bytes32) public;\r\n    function clearEndpoint(bytes32) public;\r\n    function getProviderParameter(address, bytes32) public view returns (bytes);\r\n    function getAllProviderParams(address) public view returns (bytes32[]);\r\n    function getProviderCurveLength(address, bytes32) public view returns (uint256);\r\n    function getProviderCurve(address, bytes32) public view returns (int[]);\r\n    function isProviderInitiated(address) public view returns (bool);\r\n    function getAllOracles() external view returns (address[]);\r\n    function getProviderEndpoints(address) public view returns (bytes32[]);\r\n    function getEndpointBroker(address, bytes32) public view returns (address);\r\n}\r\n\r\n// File: contracts/lib/platform/SampleContest.sol\r\n\r\n/*\r\nContest where users can bond to contestant curves which mint tokens( unbondabe*),\r\nwinner decided by oracle\r\ncontract unbonds from loser curves\r\nholders of winning token allowed to take share of reserve token(zap) which was unbonded from loser curves\r\n\r\nStarting Contest:\r\n\r\n    deploys with contest uninitialized: status = Uninitialized\r\n\r\n    anyone can initialize new token:backed curve\r\n\r\n    owner initializes contest with oracle: status = Initialized\r\n\r\nEnding Contest:\r\n\r\n    owner calls close: status = ReadyToSettle\r\n\r\n    oracle calls judge to set winning curve: status = Judged\r\n\r\n    anyone calls settle, contest unbonds from losing curves: status = Settled\r\n\r\n    holders of winnning token call redeem to retrieve their share of reserve token\r\n    based on their holding of winning token\r\n\r\n    *holders of winning token can optionally unbond\r\n*/\r\n\r\ncontract SampleContest is Ownable {\r\n\r\n    CurrentCostInterface currentCost;\r\n    FactoryTokenInterface public reserveToken;\r\n    ZapCoordinatorInterface public coord;\r\n    TokenFactoryInterface public tokenFactory;\r\n    BondageInterface bondage;\r\n\r\n    enum ContestStatus {\r\n        Uninitialized,    //\r\n        Initialized,      // ready for buys\r\n        // ReadyToSettle,    // ready for judgement\r\n        Judged,           // winner determined\r\n        Settled,           // value of winning tokens determined\r\n        Canceled          // oracle did not respond in time\r\n    }\r\n\r\n    address public oracle;    // address of oracle who will choose the winner\r\n    uint256 public ttl;    // time allowed before, close and judge. if time expired, allow unbond from all curves\r\n    // uint256 public expired = 2**256 -1;    // time allowed before, close and judge. if time expired, allow unbond from all curves\r\n    bytes32 public winner;    // curve identifier of the winner\r\n    uint256 public winValue;  // final value of the winning token\r\n    ContestStatus public status; //state of contest\r\n\r\n    mapping(bytes32 => address) public curves; // map of endpoint specifier to token-backed dotaddress\r\n    bytes32[] public curves_list; // array of endpoint specifiers\r\n\r\n    mapping(address => uint8) public redeemed; // map of address redemption state\r\n    address[] public redeemed_list;\r\n\r\n    event DotTokenCreated(address tokenAddress);\r\n    event Bonded(bytes32 indexed endpoint, uint256 indexed numDots, address indexed sender);\r\n    event Unbonded(bytes32 indexed endpoint,uint256 indexed amount, address indexed sender);\r\n\r\n    event Initialized(address indexed oracle);\r\n    event Closed();\r\n    event Judged(bytes32 winner);\r\n    event Settled(uint256 winValue, uint256 winTokens);\r\n    event Reset();\r\n\r\n    constructor(\r\n        address coordinator,\r\n        address factory,\r\n        uint256 providerPubKey,\r\n        bytes32 providerTitle\r\n    ){\r\n        coord = ZapCoordinatorInterface(coordinator);\r\n        reserveToken = FactoryTokenInterface(coord.getContract(\"ZAP_TOKEN\"));\r\n        //always allow bondage to transfer from wallet\r\n        reserveToken.approve(coord.getContract(\"BONDAGE\"), ~uint256(0));\r\n        tokenFactory = TokenFactoryInterface(factory);\r\n\r\n        RegistryInterface registry = RegistryInterface(coord.getContract(\"REGISTRY\"));\r\n        registry.initiateProvider(providerPubKey, providerTitle);\r\n        status = ContestStatus.Uninitialized;\r\n    }\r\n\r\n// contest lifecycle\r\n\r\n    function initializeContest(\r\n        address oracleAddress,\r\n        uint256 _ttl\r\n    ) onlyOwner public {\r\n        require( status == ContestStatus.Uninitialized, \"Contest already initialized\");\r\n        oracle = oracleAddress;\r\n        ttl = _ttl + block.number;\r\n        status = ContestStatus.Initialized;\r\n        emit Initialized(oracle);\r\n    }\r\n\r\n    // function close() onlyOwner {\r\n    //     status = ContestStatus.ReadyToSettle;\r\n    //     expired = block.number + ttl;\r\n    //     emit Closed();\r\n    // }\r\n\r\n    function judge(bytes32 endpoint) {\r\n        require( status == ContestStatus.Initialized, \"Contest not initialized\" );\r\n        require( msg.sender == oracle, \"Only designated Oracle can judge\");\r\n        require(block.number < ttl, \"Contest expired, refund in process\");\r\n        winner = endpoint;\r\n        status = ContestStatus.Judged;\r\n        emit Judged(winner);\r\n    }\r\n\r\n    function settle() public {\r\n        require( status == ContestStatus.Judged, \"winner not determined\");\r\n\r\n        bondage = BondageInterface(coord.getContract(\"BONDAGE\"));\r\n        // how many winning dots\r\n        uint256 numWin =  bondage.getDotsIssued(address(this), winner);\r\n        // redeemable value of each dot token\r\n        uint256 dots;\r\n        for( uint256 i = 0; i < curves_list.length; i++) {\r\n          if(curves_list[i]!=winner){\r\n            dots =  bondage.getDotsIssued(address(this), curves_list[i]);\r\n            if( dots > 0) {\r\n                bondage.unbond(address(this), curves_list[i], dots);\r\n            }\r\n          }\r\n        }\r\n        winValue = reserveToken.balanceOf(address(this)) / numWin;\r\n\r\n        status = ContestStatus.Settled;\r\n        emit Settled(winValue, numWin);\r\n    }\r\n\r\n\r\n    //TODO ensure all has been redeemed or enough time has elasped\r\n    function reset() public {\r\n        require(msg.sender == oracle);\r\n        require(status == ContestStatus.Settled || status == ContestStatus.Canceled, \"contest not settled\");\r\n        if( status == ContestStatus.Canceled ) {\r\n            require(reserveToken.balanceOf(address(this)) == 0, \"funds remain\");\r\n        }\r\n\r\n        delete redeemed_list;\r\n        delete curves_list;\r\n        status = ContestStatus.Initialized;\r\n        emit Reset();\r\n    }\r\n\r\n/// TokenDotFactory methods\r\n\r\n    function initializeCurve(\r\n        bytes32 endpoint,\r\n        bytes32 symbol,\r\n        int256[] curve\r\n    ) public returns(address) {\r\n        // require(status==ContestStatus.Initialized,\"Contest is not initalized\")\r\n        require(curves[endpoint] == 0, \"Curve endpoint already exists or used in the past. Please choose a new endpoint\");\r\n\r\n        RegistryInterface registry = RegistryInterface(coord.getContract(\"REGISTRY\"));\r\n        registry.initiateProviderCurve(endpoint, curve, address(this));\r\n\r\n        curves[endpoint] = newToken(bytes32ToString(endpoint), bytes32ToString(symbol));\r\n        curves_list.push(endpoint);\r\n        registry.setProviderParameter(endpoint, toBytes(curves[endpoint]));\r\n\r\n        DotTokenCreated(curves[endpoint]);\r\n        return curves[endpoint];\r\n    }\r\n\r\n    //whether this contract holds tokens or coming from msg.sender,etc\r\n    function bond(bytes32 endpoint, uint numDots) public  {\r\n        require( status == ContestStatus.Initialized, \" contest is not initiated\");\r\n\r\n        bondage = BondageInterface(coord.getContract(\"BONDAGE\"));\r\n        uint256 issued = bondage.getDotsIssued(address(this), endpoint);\r\n\r\n        CurrentCostInterface cost = CurrentCostInterface(coord.getContract(\"CURRENT_COST\"));\r\n        uint256 numReserve = cost._costOfNDots(address(this), endpoint, issued + 1, numDots - 1);\r\n\r\n        require(\r\n            reserveToken.transferFrom(msg.sender, address(this), numReserve),\r\n            \"insufficient accepted token numDots approved for transfer\"\r\n        );\r\n\r\n        reserveToken.approve(address(bondage), numReserve);\r\n        bondage.bond(address(this), endpoint, numDots);\r\n        FactoryTokenInterface(curves[endpoint]).mint(msg.sender, numDots);\r\n        emit Bonded(endpoint, numDots, msg.sender);\r\n    }\r\n\r\n    //whether this contract holds tokens or coming from msg.sender,etc\r\n    function unbond(bytes32 endpoint, uint numDots) public returns(uint256) {\r\n\r\n        require(status == ContestStatus.Settled, \"not ready\");\r\n\r\n        bondage = BondageInterface(coord.getContract(\"BONDAGE\"));\r\n        uint issued = bondage.getDotsIssued(address(this), endpoint);\r\n\r\n        //unbond dots\r\n        bondage.unbond(address(this), winner, numDots);\r\n\r\n        currentCost = CurrentCostInterface(coord.getContract(\"CURRENT_COST\"));\r\n        //get reserve value to send\r\n        uint reserveCost = currentCost._costOfNDots(address(this), endpoint, issued + 1 - numDots, numDots - 1);\r\n\r\n        FactoryTokenInterface curveToken = FactoryTokenInterface(curves[endpoint]);\r\n\r\n        if( status == ContestStatus.Initialized || status == ContestStatus.Canceled) {\r\n            //oracle has taken too long to judge winner so unbonds will be allowed for all\r\n            require(block.number > ttl, \"oracle query not expired.\");\r\n            // require(status == ContestStatus.Settled, \"contest not settled\");\r\n            status = ContestStatus.Canceled;\r\n\r\n            //unbond dots\r\n            //TODO get bound dot then unbond the correct amount ? or unbond all in 1 call\r\n            // bondage.unbond(address(this), endpoint, numDots);\r\n\r\n            //burn dot backed token\r\n            //FIXME only burn the bound tokens ?\r\n            curveToken.burnFrom(msg.sender, numDots);\r\n\r\n            require(reserveToken.transfer(msg.sender, reserveCost), \"transfer failed\");\r\n            emit Unbonded(endpoint, reserveCost, msg.sender);\r\n            return reserveCost;\r\n        }\r\n\r\n        else {\r\n\r\n            require( status == ContestStatus.Settled, \" contest not settled\");\r\n            require(redeemed[msg.sender] == 0, \"already redeeemed\");\r\n            require(winner==endpoint, \"only winners can unbond for rewards\");\r\n\r\n            //reward user's winning tokens unbond value + share of losing curves reserve token proportional to winning token holdings\r\n            uint reward = ( winValue * FactoryTokenInterface(getTokenAddress(winner)).balanceOf(msg.sender) ) + reserveCost;\r\n\r\n            //burn user's unbonded tokens\r\n            // curveToken.approve(address(this),numDots);\r\n            curveToken.burnFrom(msg.sender, numDots);\r\n\r\n            reserveToken.transfer(msg.sender, reward);\r\n            redeemed[msg.sender] = 1;\r\n\r\n            // emit Unbonded(winner, reward, msg.sender);\r\n            return reward;\r\n        }\r\n    }\r\n\r\n    function newToken(\r\n        string name,\r\n        string symbol\r\n    )\r\n        internal\r\n        returns (address tokenAddress)\r\n    {\r\n        FactoryTokenInterface token = tokenFactory.create(name, symbol);\r\n        tokenAddress = address(token);\r\n        return tokenAddress;\r\n    }\r\n\r\n    function getTokenAddress(bytes32 endpoint) public view returns(address) {\r\n        RegistryInterface registry = RegistryInterface(coord.getContract(\"REGISTRY\"));\r\n        return bytesToAddr(registry.getProviderParameter(address(this), endpoint));\r\n    }\r\n\r\n    function getEndpoints() public view returns(bytes32[]){\r\n      return curves_list;\r\n    }\r\n\r\n    function getStatus() public view returns(uint256){\r\n      return uint(status);\r\n    }\r\n\r\n    function isEndpointValid(bytes32 _endpoint) public view returns(bool){\r\n      for(uint256 i=0; i<curves_list.length;i++){\r\n        if(_endpoint == curves_list[i]){\r\n          return true;\r\n        }\r\n      }\r\n      return false;\r\n    }\r\n\r\n    // https://ethereum.stackexchange.com/questions/884/how-to-convert-an-address-to-bytes-in-solidity\r\n    function toBytes(address x) public pure returns (bytes b) {\r\n        b = new bytes(20);\r\n        for (uint i = 0; i < 20; i++)\r\n            b[i] = byte(uint8(uint(x) / (2**(8*(19 - i)))));\r\n    }\r\n\r\n    //https://ethereum.stackexchange.com/questions/2519/how-to-convert-a-bytes32-to-string\r\n    function bytes32ToString(bytes32 x) public pure returns (string) {\r\n        bytes memory bytesString = new bytes(32);\r\n        bytesString = abi.encodePacked(x);\r\n        return string(bytesString);\r\n    }\r\n\r\n    //https://ethereum.stackexchange.com/questions/15350/how-to-convert-an-bytes-to-address-in-solidity\r\n    function bytesToAddr (bytes b) public pure returns (address) {\r\n        uint result = 0;\r\n        for (uint i = b.length-1; i+1 > 0; i--) {\r\n            uint c = uint(b[i]);\r\n            uint to_inc = c * ( 16 ** ((b.length - i-1) * 2));\r\n            result += to_inc;\r\n        }\r\n        return address(result);\r\n    }\r\n}\r\n\r\n// File: contracts/platform/dispatch/DispatchInterface.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\ninterface DispatchInterface {\r\n    function query(address, string, bytes32, bytes32[]) external returns (uint256);\r\n    function respond1(uint256, string) external returns (bool);\r\n    function respond2(uint256, string, string) external returns (bool);\r\n    function respond3(uint256, string, string, string) external returns (bool);\r\n    function respond4(uint256, string, string, string, string) external returns (bool);\r\n    function respondBytes32Array(uint256, bytes32[]) external returns (bool);\r\n    function respondIntArray(uint256,int[] ) external returns (bool);\r\n    function cancelQuery(uint256) external;\r\n    function getProvider(uint256 id) public view returns (address);\r\n    function getSubscriber(uint256 id) public view returns (address);\r\n    function getEndpoint(uint256 id) public view returns (bytes32);\r\n    function getStatus(uint256 id) public view returns (uint256);\r\n    function getCancel(uint256 id) public view returns (uint256);\r\n    function getUserQuery(uint256 id) public view returns (string);\r\n    function getSubscriberOnchain(uint256 id) public view returns (bool);\r\n}\r\n\r\n// File: contracts/lib/platform/Client.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\ncontract Client1 {\r\n    /// @dev callback that provider will call after Dispatch.query() call\r\n    /// @param id request id\r\n    /// @param response1 first provider-specified param\r\n    function callback(uint256 id, string response1) external;\r\n}\r\ncontract Client2 {\r\n    /// @dev callback that provider will call after Dispatch.query() call\r\n    /// @param id request id\r\n    /// @param response1 first provider-specified param\r\n    /// @param response2 second provider-specified param\r\n    function callback(uint256 id, string response1, string response2) external;\r\n}\r\ncontract Client3 {\r\n    /// @dev callback that provider will call after Dispatch.query() call\r\n    /// @param id request id\r\n    /// @param response1 first provider-specified param\r\n    /// @param response2 second provider-specified param\r\n    /// @param response3 third provider-specified param\r\n    function callback(uint256 id, string response1, string response2, string response3) external;\r\n}\r\ncontract Client4 {\r\n    /// @dev callback that provider will call after Dispatch.query() call\r\n    /// @param id request id\r\n    /// @param response1 first provider-specified param\r\n    /// @param response2 second provider-specified param\r\n    /// @param response3 third provider-specified param\r\n    /// @param response4 fourth provider-specified param\r\n    function callback(uint256 id, string response1, string response2, string response3, string response4) external;\r\n}\r\n\r\ncontract ClientBytes32Array {\r\n    /// @dev callback that provider will call after Dispatch.query() call\r\n    /// @param id request id\r\n    /// @param response bytes32 array\r\n    function callback(uint256 id, bytes32[] response) external;\r\n}\r\n\r\ncontract ClientIntArray{\r\n    /// @dev callback that provider will call after Dispatch.query() call\r\n    /// @param id request id\r\n    /// @param response int array\r\n    function callback(uint256 id, int[] response) external;\r\n}\r\n\r\n// File: contracts/lib/platform/BTCcontest.sol\r\n\r\npragma solidity ^0.4.25;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract BTCcontest is Ownable, ClientIntArray {\r\n  SampleContest public contest;\r\n  ZapCoordinatorInterface public coordinator;\r\n  address public oracle;\r\n  uint256 public query_id;\r\n  uint256 public startPrice;\r\n  bytes32 public upEndpoint;\r\n  bytes32 public downEndpoint;\r\n\r\n  constructor(\r\n    address _cord,\r\n    address _contest,\r\n    uint256 _startPrice,\r\n    bytes32 _upEndpoint,\r\n    bytes32 _downEndpoint\r\n  ){\r\n    oracle = msg.sender;\r\n    contest = SampleContest(_contest);\r\n    startPrice = _startPrice;\r\n    coordinator = ZapCoordinatorInterface(_cord);\r\n    require(contest.isEndpointValid(_upEndpoint) && contest.isEndpointValid(_downEndpoint),\"Endpoints are not valid\");\r\n    upEndpoint = _upEndpoint;\r\n    downEndpoint = _downEndpoint;\r\n    address bondageAddress = coordinator.getContract(\"BONDAGE\");\r\n    BondageInterface bondage = BondageInterface(bondageAddress);\r\n    FactoryTokenInterface reserveToken = FactoryTokenInterface(coordinator.getContract(\"ZAP_TOKEN\"));\r\n    //get reserve value to send\r\n    reserveToken.approve(address(bondageAddress),~uint256(0));\r\n\r\n  }\r\n\r\n  function bondToCoincap(address _coincap,bytes32 _endpoint,uint256 _numDots)public returns (bool){\r\n    address bondageAddress = coordinator.getContract(\"BONDAGE\");\r\n    BondageInterface bondage = BondageInterface(bondageAddress);\r\n    FactoryTokenInterface reserveToken = FactoryTokenInterface(coordinator.getContract(\"ZAP_TOKEN\"));\r\n    //get reserve value to send\r\n    bondage.bond(_coincap,_endpoint,_numDots);\r\n    return true;\r\n\r\n  }\r\n  function queryToSettle(address _coincap,bytes32 _endpoint) public returns(uint256){\r\n    require(msg.sender == oracle, \"Only Oracle owner can call query to settle\");\r\n    address dispatchAddress = coordinator.getContract(\"DISPATCH\");\r\n    DispatchInterface dispatch = DispatchInterface(dispatchAddress);\r\n    bytes32[] memory params = new bytes32[](0);\r\n    return dispatch.query(_coincap,\"BTC\",_endpoint,params);\r\n  }\r\n\r\n  function callback(uint256 _id, int[] responses) external {\r\n    address dispatchAddress = coordinator.getContract(\"DISPATCH\");\r\n    require(address(msg.sender)==address(dispatchAddress),\"Only accept response from dispatch\");\r\n    require(contest.getStatus()==1,\"Contest is not in initialized state\"); //2 is the ReadyToSettle enum value\r\n    uint256 price = uint256(responses[0]);\r\n    bytes32[] memory endpoints = contest.getEndpoints();\r\n    for(uint256 i=0;i<endpoints.length;i++){\r\n      if(endpoints[i]==upEndpoint && price > startPrice){\r\n        return contest.judge(endpoints[i]);\r\n      }\r\n      if(endpoints[i]==downEndpoint && price<startPrice){\r\n        return contest.judge(endpoints[i]);\r\n      }\r\n    }\r\n  }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"coordinator\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"downEndpoint\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_coincap\",\"type\":\"address\"},{\"name\":\"_endpoint\",\"type\":\"bytes32\"},{\"name\":\"_numDots\",\"type\":\"uint256\"}],\"name\":\"bondToCoincap\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"oracle\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_id\",\"type\":\"uint256\"},{\"name\":\"responses\",\"type\":\"int256[]\"}],\"name\":\"callback\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"upEndpoint\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_coincap\",\"type\":\"address\"},{\"name\":\"_endpoint\",\"type\":\"bytes32\"}],\"name\":\"queryToSettle\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"contest\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"query_id\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_cord\",\"type\":\"address\"},{\"name\":\"_contest\",\"type\":\"address\"},{\"name\":\"_startPrice\",\"type\":\"uint256\"},{\"name\":\"_upEndpoint\",\"type\":\"bytes32\"},{\"name\":\"_downEndpoint\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"BTCcontest","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000b007eca49763f31edff95623ed6c23c8c1924a1600000000000000000000000064a0fbf12ad9644db64d159a64a0e9a883517d86000000000000000000000000000000000000000000000000000000000000204d6274635f757000000000000000000000000000000000000000000000000000006274635f646f776e000000000000000000000000000000000000000000000000","Library":"","SwarmSource":"bzzr://898ad913aa1b8b0253916f2ec442d9c051d625291fb9841223feac9234d48c32"}]}