{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity >= 0.5.0;\r\n\r\ncontract WinyDice {\r\n    address payable private OWNER;\r\n\r\n    // Each bet is deducted 0.98% in favour of the house, but no less than some minimum.\r\n    // The lower bound is dictated by gas costs of the settleBet transaction, providing\r\n    // headroom for up to 20 Gwei prices.\r\n    uint public constant HOUSE_EDGE_OF_TEN_THOUSAND = 98;\r\n    uint public constant HOUSE_EDGE_MINIMUM_AMOUNT = 0.0003 ether;\r\n\r\n    // Modulo is a number of equiprobable outcomes in a game:\r\n    //  - 2 for coin flip\r\n    //  - 6 for dice\r\n    //  - 6 * 6 = 36 for double dice\r\n    //  - 6 * 6 * 6 = 216 for triple dice\r\n    //  - 37 for rouletter\r\n    //  - 4, 13, 26, 52 for poker\r\n    //  - 100 for etheroll\r\n    //  etc.\r\n    // It's called so because 256-bit entropy is treated like a huge integer and\r\n    // the remainder of its division by modulo is considered bet outcome.\r\n    uint constant MAX_MODULO = 216;\r\n\r\n    // For modulos below this threshold rolls are checked against a bit mask,\r\n    // thus allowing betting on any combination of outcomes. For example, given\r\n    // modulo 6 for dice, 101000 mask (base-2, big endian) means betting on\r\n    // 4 and 6; for games with modulos higher than threshold (Etheroll), a simple\r\n    // limit is used, allowing betting on any outcome in [0, N) range.\r\n    //\r\n    // The specific value is dictated by the fact that 256-bit intermediate\r\n    // multiplication result allows implementing population count efficiently\r\n    // for numbers that are up to 42 bits.\r\n    uint constant MAX_MASK_MODULO = 216;\r\n\r\n    // This is a check on bet mask overflow.\r\n    uint constant MAX_BET_MASK = 2 ** MAX_MASK_MODULO;\r\n\r\n    // Adjustable max bet profit. Used to cap bets against dynamic odds.\r\n    uint public MAX_PROFIT;\r\n    uint public MAX_PROFIT_PERCENT = 10;\r\n    bool public KILLED;\r\n\r\n    // Funds that are locked in potentially winning bets. Prevents contract from\r\n    // committing to bets it cannot pay out.\r\n    uint128 public LOCKED_IN_BETS;\r\n\r\n    uint256 public JACKPOT_BALANCE = 0;\r\n\r\n    bool public PAYOUT_PAUSED; \r\n    bool public GAME_PAUSED;\r\n\r\n    //Minimum amount that can have a chance to win jackpot\r\n    uint256 public constant MIN_JACKPOT_BET = 0.1 ether;\r\n    uint256 public JACKPOT_CHANCE = 1000;   //0.1%\r\n    uint256 public constant JACKPOT_FEE = 0.001 ether;\r\n\r\n    uint constant MIN_BET = 0.01 ether;\r\n    uint constant MAX_BET = 300000 ether;\r\n\r\n     // This are some constants making O(1) population count in placeBet possible.\r\n    // See whitepaper for intuition and proofs behind it.\r\n    uint constant POPCNT_MULT = 0x0000000000002000000000100000000008000000000400000000020000000001;\r\n    uint constant POPCNT_MASK = 0x0001041041041041041041041041041041041041041041041041041041041041;\r\n    uint constant POPCNT_MODULO = 0x3F;\r\n    uint constant MASK40 = 0xFFFFFFFFFF;\r\n    uint constant MASK_MODULO_40 = 40;\r\n\r\n    // A structure representing a single bet.\r\n    struct Bet {\r\n        // Wager amount in wei.\r\n        uint80 Amount;//10\r\n        // Modulo of a game.\r\n        uint8 Modulo;//1\r\n        // Number of winning outcomes, used to compute winning payment (* modulo/rollUnder),\r\n        // and used instead of mask for games with modulo > MAX_MASK_MODULO.\r\n        uint8 RollUnder;//1\r\n        // Address of a player, used to pay out winning bets.\r\n        address payable Player;//20\r\n        // Bit mask representing winning bet outcomes (see MAX_MASK_MODULO comment).\r\n        uint216 Mask;//27\r\n        uint40 PlaceBlockNumber;\r\n    }\r\n\r\n    // Mapping from commits to all currently active & processed bets.\r\n    mapping(uint => Bet) bets;\r\n    // Croupier account.\r\n    address private CROUPIER;\r\n\r\n    // Events that are issued to make statistic recovery easier.\r\n    event FailedPayment(address indexed playerAddress,uint indexed betId, uint amount,uint dice);\r\n    event Payment(address indexed playerAddress,uint indexed betId, uint amount,uint dice);\r\n    event JackpotPayment(address indexed playerAddress,uint indexed betId, uint amount);    \r\n    // This event is emitted in placeBet to record commit in the logs.\r\n    event BetPlaced(uint indexed betId, uint source);\r\n    event LogTransferEther(address indexed SentToAddress, uint256 AmountTransferred);\r\n\r\n    constructor (address payable _owner,address _croupier) public payable {\r\n        OWNER = _owner;                \r\n        CROUPIER = _croupier;\r\n        KILLED = false;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == OWNER,\"only owner can call this function.\");\r\n        _;\r\n    }\r\n\r\n    // Standard modifier on methods invokable only by Croupier.\r\n    modifier onlyCroupier {\r\n        require(msg.sender == CROUPIER, \"OnlyCroupier methods called by non-croupier.\");\r\n        _;\r\n    }\r\n\r\n    modifier payoutsAreActive {\r\n        if(PAYOUT_PAUSED == true) revert(\"payouts are currently paused.\");\r\n        _;\r\n    } \r\n\r\n    modifier gameIsActive {\r\n        if(GAME_PAUSED == true) revert(\"game is not active right now.\");\r\n        _;\r\n    } \r\n\r\n\r\n    function GetChoiceCountForLargeModulo(uint inputMask, uint n) private pure returns (uint choiceCount) {\r\n        choiceCount += (((inputMask & MASK40) * POPCNT_MULT) & POPCNT_MASK) % POPCNT_MODULO;\r\n        for (uint i = 1; i < n; i++) {\r\n            inputMask = inputMask >> MASK_MODULO_40;\r\n            choiceCount += (((inputMask & MASK40) * POPCNT_MULT) & POPCNT_MASK) % POPCNT_MODULO;\r\n        }\r\n        return choiceCount;\r\n    }\r\n\r\n    function GetChoiceCount(uint inputMask ,uint modulo) private pure returns (uint choiceCount,uint mask) {\r\n\r\n        if (modulo <= MASK_MODULO_40) {\r\n            // Small modulo games specify bet outcomes via bit mask.\r\n            // rollUnder is a number of 1 bits in this mask (population count).\r\n            // This magic looking formula is an efficient way to compute population\r\n            // count on EVM for numbers below 2**40.\r\n            choiceCount = ((inputMask * POPCNT_MULT) & POPCNT_MASK) % POPCNT_MODULO;\r\n            mask = inputMask;\r\n        } else if (modulo <= MASK_MODULO_40 * 2) {\r\n            choiceCount = GetChoiceCountForLargeModulo(inputMask, 2);\r\n            mask = inputMask;\r\n        } else if (modulo == 100) {\r\n            require(inputMask > 0 && inputMask <= modulo, \"High modulo range, betMask larger than modulo.\");\r\n            choiceCount = inputMask;\r\n        } else if (modulo <= MASK_MODULO_40 * 3) {\r\n            choiceCount = GetChoiceCountForLargeModulo(inputMask, 3);\r\n            mask = inputMask;\r\n        } else if (modulo <= MASK_MODULO_40 * 4) {\r\n            choiceCount = GetChoiceCountForLargeModulo(inputMask, 4);\r\n            mask = inputMask;\r\n        } else if (modulo <= MASK_MODULO_40 * 5) {\r\n            choiceCount = GetChoiceCountForLargeModulo(inputMask, 5);\r\n            mask = inputMask;\r\n        } else if (modulo <= MAX_MASK_MODULO) {\r\n            choiceCount = GetChoiceCountForLargeModulo(inputMask, 6);\r\n            mask = inputMask;\r\n        } else {\r\n            // Larger modulos specify the right edge of half-open interval of\r\n            // winning bet outcomes.\r\n            require(inputMask > 0 && inputMask <= modulo, \"High modulo range, betMask larger than modulo.\");\r\n            choiceCount = inputMask;\r\n        }        \r\n    }\r\n\r\n    // Get the expected win amount after house edge is subtracted.\r\n    function GetDiceWinAmount(uint amount, uint modulo, uint choiceCount) private pure returns (uint winAmount, uint jackpotFee) {\r\n        require(0 < choiceCount && choiceCount <= modulo, \"Win probability out of range.\");\r\n\r\n        jackpotFee = amount >= MIN_JACKPOT_BET ? JACKPOT_FEE : 0;\r\n\r\n        uint houseEdge = amount * HOUSE_EDGE_OF_TEN_THOUSAND / 10000;\r\n\r\n        if (houseEdge < HOUSE_EDGE_MINIMUM_AMOUNT) {\r\n            houseEdge = HOUSE_EDGE_MINIMUM_AMOUNT;\r\n        }\r\n\r\n        require(houseEdge + jackpotFee <= amount, \"Bet doesn't even cover house edge.\");\r\n\r\n        winAmount = (amount - houseEdge - jackpotFee) * modulo / choiceCount;\r\n    }    \r\n\r\n    /// *** Betting logic\r\n\r\n    // Bet states:\r\n    //  amount == 0 && player == 0 - 'clean' (can place a bet)\r\n    //  amount != 0 && player != 0 - 'active' (can be settled or refunded)\r\n    //  amount == 0 && player != 0 - 'processed' (can clean storage)\r\n    \r\n    function PlaceBet(uint mask, uint modulo, uint betId , uint source) public payable gameIsActive {        \r\n        if(KILLED == true) revert (\"Contract Killed\");\r\n        // Check that the bet is in 'clean' state.\r\n        MAX_PROFIT = (address(this).balance + msg.value - LOCKED_IN_BETS - JACKPOT_BALANCE) * MAX_PROFIT_PERCENT / 100;\r\n        Bet storage bet = bets[betId];\r\n        if(bet.Player != address(0)) revert(\"Bet should be in a 'clean' state.\");\r\n\r\n        // Validate input data ranges.\r\n        if(modulo < 2 && modulo > MAX_MODULO) revert(\"Modulo should be within range.\");\r\n        if(msg.value < MIN_BET && msg.value > MAX_BET) revert(\"Amount should be within range.\");\r\n        if(mask < 0 && mask > MAX_BET_MASK) revert(\"Mask should be within range.\");\r\n\r\n        uint choiceCount;\r\n        uint finalMask;\r\n        (choiceCount,finalMask) = GetChoiceCount(mask,modulo);        \r\n\r\n        // Winning amount and jackpot increase.\r\n        uint possibleWinAmount;\r\n        uint jackpotFee;\r\n\r\n        (possibleWinAmount, jackpotFee) = GetDiceWinAmount(msg.value, modulo, choiceCount);\r\n\r\n        // Enforce max profit limit.\r\n        if(possibleWinAmount > MAX_PROFIT) revert(\"maxProfit limit violation.\");\r\n\r\n        // Lock funds.\r\n        LOCKED_IN_BETS += uint128(possibleWinAmount);\r\n        JACKPOT_BALANCE += uint128(jackpotFee);\r\n\r\n        // Check whether contract has enough funds to process this bet.\r\n        if((JACKPOT_BALANCE + LOCKED_IN_BETS) > address(this).balance) revert( \"Cannot afford to lose this bet.\");        \r\n\r\n        // Record commit in logs.\r\n        emit BetPlaced(betId, source);\r\n\r\n        // Store bet parameters on blockchain.\r\n        bet.Amount = uint80(msg.value);\r\n        bet.Modulo = uint8(modulo);\r\n        bet.RollUnder = uint8(choiceCount);\r\n        bet.Mask = uint216(mask);\r\n        bet.Player = msg.sender;\r\n        bet.PlaceBlockNumber = uint40(block.number);\r\n    }\r\n\r\n    // Helper routine to process the payment.\r\n    function SendFunds(address payable beneficiary, uint amount, uint successLogAmount, uint betId,uint dice) private {\r\n        if (beneficiary.send(amount)) {\r\n            emit Payment(beneficiary,betId, successLogAmount,dice);\r\n            MAX_PROFIT = (address(this).balance - amount - JACKPOT_BALANCE - LOCKED_IN_BETS) * MAX_PROFIT_PERCENT / 100;\r\n        } else {\r\n            emit FailedPayment(beneficiary,betId,amount,dice);\r\n        }\r\n        \r\n    }\r\n\r\n    // Refund transaction - return the bet amount of a roll that was not processed in a\r\n    // due timeframe. \r\n    // in a situation like this, just contact us, however nothing\r\n    // precludes you from invoking this method yourself.\r\n    function RefundBet(uint betId) external onlyOwner {\r\n        // Check that bet is in 'active' state.\r\n        Bet storage bet = bets[betId];\r\n        uint amount = bet.Amount;\r\n\r\n        if(amount == 0) revert(\"Bet should be in an 'active' state\");\r\n\r\n        // Move bet into 'processed' state, release funds.\r\n        bet.Amount = 0;\r\n\r\n        uint diceWinAmount;\r\n        uint jackpotFee;\r\n        (diceWinAmount, jackpotFee) = GetDiceWinAmount(amount, bet.Modulo, bet.RollUnder);\r\n\r\n        LOCKED_IN_BETS -= uint128(diceWinAmount);\r\n        if (JACKPOT_BALANCE >= jackpotFee) {\r\n            JACKPOT_BALANCE -= uint128(jackpotFee);\r\n        }       \r\n\r\n        // Send the refund.\r\n        SendFunds(bet.Player, amount, amount, betId,0);\r\n        MAX_PROFIT = (address(this).balance - LOCKED_IN_BETS - JACKPOT_BALANCE - diceWinAmount) * MAX_PROFIT_PERCENT / 100;\r\n        delete bets[betId];\r\n    }\r\n\r\n     // This is the method used to settle bets. \r\n    function SettleBet(string memory betString,bytes32 blockHash) public onlyCroupier {\r\n        uint betId = uint(keccak256(abi.encodePacked(betString)));\r\n\r\n        Bet storage bet = bets[betId];\r\n\r\n         uint placeBlockNumber = bet.PlaceBlockNumber;\r\n\r\n        if(block.number <= placeBlockNumber) revert(\"settleBet in the same block as placeBet, or before.\");\r\n        if(blockhash(placeBlockNumber) != blockHash) revert(\"Invalid BlockHash\");        \r\n        \r\n        SettleBetCommon(bet,betId,blockHash);\r\n    }\r\n\r\n    // Common settlement code for settleBet.\r\n    function SettleBetCommon(Bet storage bet, uint betId,bytes32 blockHash) private {\r\n        uint amount = bet.Amount;\r\n        uint modulo = bet.Modulo;\r\n        uint rollUnder = bet.RollUnder;\r\n        address payable player = bet.Player;\r\n\r\n        // Check that bet is in 'active' state.        \r\n        if(amount == 0) revert(\"Bet should be in an 'active' state\");\r\n\r\n        // Move bet into 'processed' state already.\r\n        bet.Amount = 0;\r\n\r\n        // The RNG - combine \"betId\" and blockHash of placeBet using Keccak256.\r\n        bytes32 entropy = keccak256(abi.encodePacked(betId, blockHash));\r\n        \r\n        // Do a roll by taking a modulo of entropy. Compute winning amount.\r\n        uint dice = uint(entropy) % modulo;\r\n\r\n        uint diceWinAmount;\r\n        uint _jackpotFee;\r\n        (diceWinAmount, _jackpotFee) = GetDiceWinAmount(amount, modulo, rollUnder);\r\n\r\n        uint diceWin = 0;\r\n        uint jackpotWin = 0;\r\n\r\n        // Determine dice outcome.\r\n        if ((modulo != 100) && (modulo <= MAX_MASK_MODULO)) {\r\n            // For small modulo games, check the outcome against a bit mask.\r\n            if ((2 ** dice) & bet.Mask != 0) {\r\n                diceWin = diceWinAmount;\r\n            }\r\n        } else {\r\n            // For larger modulos, check inclusion into half-open interval.\r\n            if (dice < rollUnder) {\r\n                diceWin = diceWinAmount;\r\n            }\r\n        }\r\n\r\n        // Unlock the bet amount, regardless of the outcome.\r\n        LOCKED_IN_BETS -= uint128(diceWinAmount);\r\n\r\n        // Roll for a jackpot (if eligible).\r\n        if (amount >= MIN_JACKPOT_BET) {\r\n            // The second modulo, statistically independent from the \"main\" dice roll.\r\n            // Effectively you are playing two games at once!\r\n            uint jackpotRng = (uint(entropy) / modulo) % JACKPOT_CHANCE;\r\n\r\n            // Bingo!\r\n            if (jackpotRng == 0) {\r\n                jackpotWin = JACKPOT_BALANCE;\r\n                JACKPOT_BALANCE = 0;\r\n            }\r\n        }\r\n\r\n        // Log jackpot win.\r\n        if (jackpotWin > 0) {\r\n            emit JackpotPayment(player,betId,jackpotWin);\r\n        }        \r\n\r\n        // Send the funds to player.\r\n        SendFunds(player, diceWin + jackpotWin == 0 ? 1 wei : diceWin + jackpotWin, diceWin, betId,dice);\r\n        MAX_PROFIT = (address(this).balance - LOCKED_IN_BETS - JACKPOT_BALANCE - diceWin) * MAX_PROFIT_PERCENT / 100;\r\n        delete bets[betId];\r\n    }\r\n\r\n    function GetBetInfoByBetString(string memory betString) public view onlyOwner returns (uint _betId, uint amount, uint8 modulo, uint8 rollUnder, uint betId, uint mask, address player) {\r\n        _betId = uint(keccak256(abi.encodePacked(betString)));\r\n        (amount, modulo, rollUnder, betId, mask, player) = GetBetInfo(_betId);\r\n    }\r\n\r\n    function GetBetInfo(uint _betId) public view returns (uint amount, uint8 modulo, uint8 rollUnder, uint betId, uint mask, address player) {\r\n        Bet storage bet = bets[_betId];\r\n        amount = bet.Amount;\r\n        modulo = bet.Modulo;\r\n        rollUnder = bet.RollUnder;\r\n        betId = _betId;\r\n        mask = bet.Mask;\r\n        player = bet.Player;\r\n    }\r\n\r\n    /* only owner address can set emergency pause #1 */\r\n    function ownerPauseGame(bool newStatus) public onlyOwner {\r\n        GAME_PAUSED = newStatus;\r\n    }\r\n\r\n    /* only owner address can set emergency pause #2 */\r\n    function ownerPausePayouts(bool newPayoutStatus) public onlyOwner {\r\n        PAYOUT_PAUSED = newPayoutStatus;\r\n    }   \r\n\r\n    /* only owner address can set emergency pause #2 */\r\n    function ownerSetMaxProfit(uint _maxProfit) public onlyOwner {\r\n        MAX_PROFIT = _maxProfit;\r\n        MAX_PROFIT = (address(this).balance - LOCKED_IN_BETS - JACKPOT_BALANCE) * MAX_PROFIT_PERCENT / 100;\r\n    }\r\n\r\n     /* only owner address can set emergency pause #2 */\r\n    function ownerSetMaxProfitPercent(uint _maxProfitPercent) public onlyOwner {\r\n        MAX_PROFIT_PERCENT = _maxProfitPercent;\r\n        MAX_PROFIT = (address(this).balance - LOCKED_IN_BETS - JACKPOT_BALANCE) * MAX_PROFIT_PERCENT / 100;\r\n    }    \r\n\r\n    /* only owner address can transfer ether */\r\n    function TransferEther(address payable sendTo, uint amount) public onlyOwner {        \r\n        /* safely update contract balance when sending out funds*/              \r\n        if(!sendTo.send(amount)) \r\n            revert(\"owner transfer ether failed.\");\r\n        if(KILLED == false)\r\n        {\r\n            MAX_PROFIT = (address(this).balance - LOCKED_IN_BETS - JACKPOT_BALANCE) * MAX_PROFIT_PERCENT / 100;            \r\n        }\r\n        emit LogTransferEther(sendTo, amount); \r\n    }\r\n\r\n    //Add ether to contract by owner\r\n    function ChargeContract () external payable onlyOwner {\r\n        /* safely update contract balance */ \r\n        MAX_PROFIT = (address(this).balance - LOCKED_IN_BETS - JACKPOT_BALANCE) * MAX_PROFIT_PERCENT / 100;       \r\n    }\r\n\r\n    // Contract may be destroyed only when there are no ongoing bets,\r\n    // either settled or refunded. All funds are transferred to contract owner.\r\n    function kill() external onlyOwner {\r\n        require(LOCKED_IN_BETS == 0, \"All bets should be processed (settled or refunded) before self-destruct.\");\r\n        KILLED = true;\r\n        JACKPOT_BALANCE = 0;        \r\n    }\r\n\r\n     function ownerSetNewOwner(address payable newOwner) external onlyOwner {\r\n        OWNER = newOwner;       \r\n    }\r\n\r\n    function ownerSetNewCroupier(address newCroupier) external onlyOwner {\r\n        CROUPIER =  newCroupier  ; \r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"MIN_JACKPOT_BET\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"betString\",\"type\":\"string\"}],\"name\":\"GetBetInfoByBetString\",\"outputs\":[{\"name\":\"_betId\",\"type\":\"uint256\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"modulo\",\"type\":\"uint8\"},{\"name\":\"rollUnder\",\"type\":\"uint8\"},{\"name\":\"betId\",\"type\":\"uint256\"},{\"name\":\"mask\",\"type\":\"uint256\"},{\"name\":\"player\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"mask\",\"type\":\"uint256\"},{\"name\":\"modulo\",\"type\":\"uint256\"},{\"name\":\"betId\",\"type\":\"uint256\"},{\"name\":\"source\",\"type\":\"uint256\"}],\"name\":\"PlaceBet\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"kill\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newPayoutStatus\",\"type\":\"bool\"}],\"name\":\"ownerPausePayouts\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"LOCKED_IN_BETS\",\"outputs\":[{\"name\":\"\",\"type\":\"uint128\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"HOUSE_EDGE_OF_TEN_THOUSAND\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_maxProfitPercent\",\"type\":\"uint256\"}],\"name\":\"ownerSetMaxProfitPercent\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_betId\",\"type\":\"uint256\"}],\"name\":\"GetBetInfo\",\"outputs\":[{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"modulo\",\"type\":\"uint8\"},{\"name\":\"rollUnder\",\"type\":\"uint8\"},{\"name\":\"betId\",\"type\":\"uint256\"},{\"name\":\"mask\",\"type\":\"uint256\"},{\"name\":\"player\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"betString\",\"type\":\"string\"},{\"name\":\"blockHash\",\"type\":\"bytes32\"}],\"name\":\"SettleBet\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"KILLED\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_PROFIT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newStatus\",\"type\":\"bool\"}],\"name\":\"ownerPauseGame\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"PAYOUT_PAUSED\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"betId\",\"type\":\"uint256\"}],\"name\":\"RefundBet\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"ownerSetNewOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"JACKPOT_CHANCE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"ChargeContract\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"sendTo\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TransferEther\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"HOUSE_EDGE_MINIMUM_AMOUNT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_PROFIT_PERCENT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"JACKPOT_FEE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"JACKPOT_BALANCE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newCroupier\",\"type\":\"address\"}],\"name\":\"ownerSetNewCroupier\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_maxProfit\",\"type\":\"uint256\"}],\"name\":\"ownerSetMaxProfit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"GAME_PAUSED\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_croupier\",\"type\":\"address\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"playerAddress\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"betId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"dice\",\"type\":\"uint256\"}],\"name\":\"FailedPayment\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"playerAddress\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"betId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"dice\",\"type\":\"uint256\"}],\"name\":\"Payment\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"playerAddress\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"betId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"JackpotPayment\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"betId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"source\",\"type\":\"uint256\"}],\"name\":\"BetPlaced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"SentToAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"AmountTransferred\",\"type\":\"uint256\"}],\"name\":\"LogTransferEther\",\"type\":\"event\"}]","ContractName":"WinyDice","CompilerVersion":"v0.5.5+commit.47a71e8f","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000e62c4b299c3818f700f8c27112f100411ee76c92000000000000000000000000e62c4b299c3818f700f8c27112f100411ee76c92","Library":"","SwarmSource":"bzzr://825dd1917f379403dbb06d9dd954b328fa4d8474b1195475a8267e16bee0b369"}]}