{"status":"1","message":"OK","result":[{"SourceCode":"/**\r\n * Source Code first verified at https://etherscan.io on Wednesday, April 24, 2019\r\n (UTC) */\r\n\r\npragma solidity ^0.4.25;\r\n\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address who) external view returns (uint256);\r\n\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n\r\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\r\n\r\n    event Transfer(\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256 value\r\n    );\r\n\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 value\r\n    );\r\n}\r\n\r\n/**\r\n * @title math operations that returns specific size reults (32, 64 and 256\r\n *        bits)\r\n */\r\nlibrary SafeMath {\r\n\r\n    /**\r\n     * @dev Multiplies two numbers and returns a uint64\r\n     * @param a A number\r\n     * @param b A number\r\n     * @return a * b as a uint64\r\n     */\r\n    function mul64(uint256 a, uint256 b) internal pure returns (uint64) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n        require(c < 2**64);\r\n        return uint64(c);\r\n    }\r\n\r\n    /**\r\n     * @dev Divides two numbers and returns a uint64\r\n     * @param a A number\r\n     * @param b A number\r\n     * @return a / b as a uint64\r\n     */\r\n    function div64(uint256 a, uint256 b) internal pure returns (uint64) {\r\n        uint256 c = a / b;\r\n        require(c < 2**64);\r\n        /* solcov ignore next */\r\n        return uint64(c);\r\n    }\r\n\r\n    /**\r\n     * @dev Substracts two numbers and returns a uint64\r\n     * @param a A number\r\n     * @param b A number\r\n     * @return a - b as a uint64\r\n     */\r\n    function sub64(uint256 a, uint256 b) internal pure returns (uint64) {\r\n        require(b <= a);\r\n        uint256 c = a - b;\r\n        require(c < 2**64);\r\n        /* solcov ignore next */\r\n        return uint64(c);\r\n    }\r\n\r\n    /**\r\n     * @dev Adds two numbers and returns a uint64\r\n     * @param a A number\r\n     * @param b A number\r\n     * @return a + b as a uint64\r\n     */\r\n    function add64(uint256 a, uint256 b) internal pure returns (uint64) {\r\n        uint256 c = a + b;\r\n        require(c >= a && c < 2**64);\r\n        /* solcov ignore next */\r\n        return uint64(c);\r\n    }\r\n\r\n    /**\r\n     * @dev Multiplies two numbers and returns a uint32\r\n     * @param a A number\r\n     * @param b A number\r\n     * @return a * b as a uint32\r\n     */\r\n    function mul32(uint256 a, uint256 b) internal pure returns (uint32) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n        require(c < 2**32);\r\n        /* solcov ignore next */\r\n        return uint32(c);\r\n    }\r\n\r\n    /**\r\n     * @dev Divides two numbers and returns a uint32\r\n     * @param a A number\r\n     * @param b A number\r\n     * @return a / b as a uint32\r\n     */\r\n    function div32(uint256 a, uint256 b) internal pure returns (uint32) {\r\n        uint256 c = a / b;\r\n        require(c < 2**32);\r\n        /* solcov ignore next */\r\n        return uint32(c);\r\n    }\r\n\r\n    /**\r\n     * @dev Substracts two numbers and returns a uint32\r\n     * @param a A number\r\n     * @param b A number\r\n     * @return a - b as a uint32\r\n     */\r\n    function sub32(uint256 a, uint256 b) internal pure returns (uint32) {\r\n        require(b <= a);\r\n        uint256 c = a - b;\r\n        require(c < 2**32);\r\n        /* solcov ignore next */\r\n        return uint32(c);\r\n    }\r\n\r\n    /**\r\n     * @dev Adds two numbers and returns a uint32\r\n     * @param a A number\r\n     * @param b A number\r\n     * @return a + b as a uint32\r\n     */\r\n    function add32(uint256 a, uint256 b) internal pure returns (uint32) {\r\n        uint256 c = a + b;\r\n        require(c >= a && c < 2**32);\r\n        return uint32(c);\r\n    }\r\n\r\n    /**\r\n     * @dev Multiplies two numbers and returns a uint256\r\n     * @param a A number\r\n     * @param b A number\r\n     * @return a * b as a uint256\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n        /* solcov ignore next */\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Divides two numbers and returns a uint256\r\n     * @param a A number\r\n     * @param b A number\r\n     * @return a / b as a uint256\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a / b;\r\n        /* solcov ignore next */\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Substracts two numbers and returns a uint256\r\n     * @param a A number\r\n     * @param b A number\r\n     * @return a - b as a uint256\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n     * @dev Adds two numbers and returns a uint256\r\n     * @param a A number\r\n     * @param b A number\r\n     * @return a + b as a uint256\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n        return c;\r\n    }\r\n}\r\n\r\n\r\n\r\n/**\r\n * @title Merkle Tree's proof helper contract\r\n */\r\nlibrary Merkle {\r\n\r\n    /**\r\n     * @dev calculates the hash of two child nodes on the merkle tree.\r\n     * @param a Hash of the left child node.\r\n     * @param b Hash of the right child node.\r\n     * @return sha3 hash of the resulting node.\r\n     */\r\n    function combinedHash(bytes32 a, bytes32 b) public pure returns(bytes32) {\r\n        return keccak256(abi.encodePacked(a, b));\r\n    }\r\n\r\n    /**\r\n     * @dev calculates a root hash associated with a Merkle proof\r\n     * @param proof array of proof hashes\r\n     * @param key index of the leaf element list.\r\n     *        this key indicates the specific position of the leaf\r\n     *        in the merkle tree. It will be used to know if the\r\n     *        node that will be hashed along with the proof node\r\n     *        is placed on the right or the left of the current\r\n     *        tree level. That is achieved by doing the modulo of\r\n     *        the current key/position. A new level of nodes will\r\n     *        be evaluated after that, and the new left or right\r\n     *        position is obtained by doing the same operation, \r\n     *        after dividing the key/position by two.\r\n     * @param leaf the leaf element to verify on the set.\r\n     * @return the hash of the Merkle proof. Should match the Merkle root\r\n     *         if the proof is valid\r\n     */\r\n    function getProofRootHash(bytes32[] memory proof, uint256 key, bytes32 leaf) public pure returns(bytes32) {\r\n        bytes32 hash = keccak256(abi.encodePacked(leaf));\r\n        uint256 k = key;\r\n        for(uint i = 0; i<proof.length; i++) {\r\n            uint256 bit = k % 2;\r\n            k = k / 2;\r\n\r\n            if (bit == 0)\r\n                hash = combinedHash(hash, proof[i]);\r\n            else\r\n                hash = combinedHash(proof[i], hash);\r\n        }\r\n        return hash;\r\n    }\r\n}\r\n\r\n/**\r\n * @title Data Structures for BatPay: Accounts, Payments & Challenge\r\n */\r\ncontract Data {\r\n    struct Account {\r\n        address owner;\r\n        uint64  balance;\r\n        uint32  lastCollectedPaymentId;\r\n    }\r\n\r\n    struct BulkRegistration {\r\n        bytes32 rootHash;\r\n        uint32  recordCount;\r\n        uint32  smallestRecordId;\r\n    }\r\n\r\n    struct Payment {\r\n        uint32  fromAccountId;\r\n        uint64  amount;\r\n        uint64  fee;\r\n        uint32  smallestAccountId;\r\n        uint32  greatestAccountId;\r\n        uint32  totalNumberOfPayees;\r\n        uint64  lockTimeoutBlockNumber;\r\n        bytes32 paymentDataHash;\r\n        bytes32 lockingKeyHash;\r\n        bytes32 metadata;\r\n    }\r\n\r\n    struct CollectSlot {\r\n        uint32  minPayIndex;\r\n        uint32  maxPayIndex;\r\n        uint64  amount;\r\n        uint64  delegateAmount;\r\n        uint32  to;\r\n        uint64  block;\r\n        uint32  delegate;\r\n        uint32  challenger;\r\n        uint32  index;\r\n        uint64  challengeAmount;\r\n        uint8   status;\r\n        address addr;\r\n        bytes32 data;\r\n    }\r\n\r\n    struct Config {\r\n        uint32 maxBulk;\r\n        uint32 maxTransfer;\r\n        uint32 challengeBlocks;\r\n        uint32 challengeStepBlocks;\r\n        uint64 collectStake;\r\n        uint64 challengeStake;\r\n        uint32 unlockBlocks;\r\n        uint32 massExitIdBlocks;\r\n        uint32 massExitIdStepBlocks;\r\n        uint32 massExitBalanceBlocks;\r\n        uint32 massExitBalanceStepBlocks;\r\n        uint64 massExitStake;\r\n        uint64 massExitChallengeStake;\r\n        uint64 maxCollectAmount;\r\n    }\r\n\r\n    Config public params;\r\n    address public owner;\r\n\r\n    uint public constant MAX_ACCOUNT_ID = 2**32-1;    // Maximum account id (32-bits)\r\n    uint public constant NEW_ACCOUNT_FLAG = 2**256-1; // Request registration of new account\r\n    uint public constant INSTANT_SLOT = 32768;\r\n\r\n}\r\n\r\n\r\n/**\r\n  * @title Accounts, methods to manage accounts and balances\r\n  */\r\n\r\ncontract Accounts is Data {\r\n    event BulkRegister(uint bulkSize, uint smallestAccountId, uint bulkId );\r\n    event AccountRegistered(uint accountId, address accountAddress);\r\n\r\n    IERC20 public token;\r\n    Account[] public accounts;\r\n    BulkRegistration[] public bulkRegistrations;\r\n\r\n    /**\r\n      * @dev determines whether accountId is valid\r\n      * @param accountId an account id\r\n      * @return boolean\r\n      */\r\n    function isValidId(uint accountId) public view returns (bool) {\r\n        return (accountId < accounts.length);\r\n    }\r\n\r\n    /**\r\n      * @dev determines whether accountId is the owner of the account\r\n      * @param accountId an account id\r\n      * @return boolean\r\n      */\r\n    function isAccountOwner(uint accountId) public view returns (bool) {\r\n        return isValidId(accountId) && msg.sender == accounts[accountId].owner;\r\n    }\r\n\r\n    /**\r\n      * @dev modifier to restrict that accountId is valid\r\n      * @param accountId an account id\r\n      */\r\n    modifier validId(uint accountId) {\r\n        require(isValidId(accountId), \"accountId is not valid\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n      * @dev modifier to restrict that accountId is owner\r\n      * @param accountId an account ID\r\n      */\r\n    modifier onlyAccountOwner(uint accountId) {\r\n        require(isAccountOwner(accountId), \"Only account owner can invoke this method\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n      * @dev Reserve accounts but delay assigning addresses.\r\n      *      Accounts will be claimed later using MerkleTree's rootHash.\r\n      * @param bulkSize Number of accounts to reserve.\r\n      * @param rootHash Hash of the root node of the Merkle Tree referencing the list of addresses.\r\n      */\r\n    function bulkRegister(uint256 bulkSize, bytes32 rootHash) public {\r\n        require(bulkSize > 0, \"Bulk size can't be zero\");\r\n        require(bulkSize < params.maxBulk, \"Cannot register this number of ids simultaneously\");\r\n        require(SafeMath.add(accounts.length, bulkSize) <= MAX_ACCOUNT_ID, \"Cannot register: ran out of ids\");\r\n        require(rootHash > 0, \"Root hash can't be zero\");\r\n\r\n        emit BulkRegister(bulkSize, accounts.length, bulkRegistrations.length);\r\n        bulkRegistrations.push(BulkRegistration(rootHash, uint32(bulkSize), uint32(accounts.length)));\r\n        accounts.length = SafeMath.add(accounts.length, bulkSize);\r\n    }\r\n\r\n    /** @dev Complete registration for a reserved account by showing the\r\n      *     bulkRegistration-id and Merkle proof associated with this address\r\n      * @param addr Address claiming this account\r\n      * @param proof Merkle proof for address and id\r\n      * @param accountId Id of the account to be registered.\r\n      * @param bulkId BulkRegistration id for the transaction reserving this account\r\n      */\r\n    function claimBulkRegistrationId(address addr, bytes32[] memory proof, uint accountId, uint bulkId) public {\r\n        require(bulkId < bulkRegistrations.length, \"the bulkId referenced is invalid\");\r\n        uint smallestAccountId = bulkRegistrations[bulkId].smallestRecordId;\r\n        uint n = bulkRegistrations[bulkId].recordCount;\r\n        bytes32 rootHash = bulkRegistrations[bulkId].rootHash;\r\n        bytes32 hash = Merkle.getProofRootHash(proof, SafeMath.sub(accountId, smallestAccountId), bytes32(addr));\r\n\r\n        require(accountId >= smallestAccountId && accountId < smallestAccountId + n,\r\n            \"the accountId specified is not part of that bulk registration slot\");\r\n        require(hash == rootHash, \"invalid Merkle proof\");\r\n        emit AccountRegistered(accountId, addr);\r\n\r\n        accounts[accountId].owner = addr;\r\n    }\r\n\r\n    /**\r\n      * @dev Register a new account\r\n      * @return the id of the new account\r\n      */\r\n    function register() public returns (uint32 ret) {\r\n        require(accounts.length < MAX_ACCOUNT_ID, \"no more accounts left\");\r\n        ret = (uint32)(accounts.length);\r\n        accounts.push(Account(msg.sender, 0, 0));\r\n        emit AccountRegistered(ret, msg.sender);\r\n        return ret;\r\n    }\r\n\r\n    /**\r\n     * @dev withdraw tokens from the BatchPayment contract into the original address.\r\n     * @param amount Amount of tokens to withdraw.\r\n     * @param accountId Id of the user requesting the withdraw.\r\n     */\r\n    function withdraw(uint64 amount, uint256 accountId)\r\n        external\r\n        onlyAccountOwner(accountId)\r\n    {\r\n        uint64 balance = accounts[accountId].balance;\r\n\r\n        require(balance >= amount, \"insufficient funds\");\r\n        require(amount > 0, \"amount should be nonzero\");\r\n\r\n        balanceSub(accountId, amount);\r\n\r\n        require(token.transfer(msg.sender, amount), \"transfer failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Deposit tokens into the BatchPayment contract to enable scalable payments\r\n     * @param amount Amount of tokens to deposit on `accountId`. User should have\r\n     *        enough balance and issue an `approve()` method prior to calling this.\r\n     * @param accountId The id of the user account. In case `NEW_ACCOUNT_FLAG` is used,\r\n     *        a new account will be registered and the requested amount will be\r\n     *        deposited in a single operation.\r\n     */\r\n    function deposit(uint64 amount, uint256 accountId) external {\r\n        require(accountId < accounts.length || accountId == NEW_ACCOUNT_FLAG, \"invalid accountId\");\r\n        require(amount > 0, \"amount should be positive\");\r\n\r\n        if (accountId == NEW_ACCOUNT_FLAG) {\r\n            // new account\r\n            uint newId = register();\r\n            accounts[newId].balance = amount;\r\n        } else {\r\n            // existing account\r\n            balanceAdd(accountId, amount);\r\n        }\r\n\r\n        require(token.transferFrom(msg.sender, address(this), amount), \"transfer failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Increase the specified account balance by `amount` tokens.\r\n     * @param accountId An account id\r\n     * @param amount number of tokens\r\n     */\r\n    function balanceAdd(uint accountId, uint64 amount)\r\n    internal\r\n    validId(accountId)\r\n    {\r\n        accounts[accountId].balance = SafeMath.add64(accounts[accountId].balance, amount);\r\n    }\r\n\r\n    /**\r\n     *  @dev Substract `amount` tokens from the specified account's balance\r\n     *  @param accountId An account id\r\n     *  @param amount number of tokens\r\n     */\r\n    function balanceSub(uint accountId, uint64 amount)\r\n    internal\r\n    validId(accountId)\r\n    {\r\n        uint64 balance = accounts[accountId].balance;\r\n        require(balance >= amount, \"not enough funds\");\r\n        accounts[accountId].balance = SafeMath.sub64(balance, amount);\r\n    }\r\n\r\n    /**\r\n     *  @dev returns the balance associated with the account in tokens\r\n     *  @param accountId account requested.\r\n     */\r\n    function balanceOf(uint accountId)\r\n        external\r\n        view\r\n        validId(accountId)\r\n        returns (uint64)\r\n    {\r\n        return accounts[accountId].balance;\r\n    }\r\n\r\n    /**\r\n      * @dev gets number of accounts registered and reserved.\r\n      * @return returns the size of the accounts array.\r\n      */\r\n    function getAccountsLength() external view returns (uint) {\r\n        return accounts.length;\r\n    }\r\n\r\n    /**\r\n      * @dev gets the number of bulk registrations performed\r\n      * @return the size of the bulkRegistrations array.\r\n      */\r\n    function getBulkLength() external view returns (uint) {\r\n        return bulkRegistrations.length;\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @title Challenge helper library\r\n */\r\nlibrary Challenge {\r\n\r\n    uint8 public constant PAY_DATA_HEADER_MARKER = 0xff; // marker in payData header\r\n\r\n    /**\r\n     * @dev Reverts if challenge period has expired or Collect Slot status is\r\n     *      not a valid one.\r\n     */\r\n    modifier onlyValidCollectSlot(Data.CollectSlot storage collectSlot, uint8 validStatus) {\r\n        require(!challengeHasExpired(collectSlot), \"Challenge has expired\");\r\n        require(isSlotStatusValid(collectSlot, validStatus), \"Wrong Collect Slot status\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @return true if the current block number is greater or equal than the\r\n     *         allowed block for this challenge.\r\n     */\r\n    function challengeHasExpired(Data.CollectSlot storage collectSlot) public view returns (bool) {\r\n        return collectSlot.block <= block.number;\r\n    }\r\n\r\n    /**\r\n     * @return true if the Slot status is valid.\r\n     */\r\n    function isSlotStatusValid(Data.CollectSlot storage collectSlot, uint8 validStatus) public view returns (bool) {\r\n        return collectSlot.status == validStatus;\r\n    }\r\n\r\n    /** @dev calculates new block numbers based on the current block and a\r\n     *      delta constant specified by the protocol policy.\r\n     * @param delta number of blocks into the future to calculate.\r\n     * @return future block number.\r\n     */\r\n    function getFutureBlock(uint delta) public view returns(uint64) {\r\n        return SafeMath.add64(block.number, delta);\r\n    }\r\n\r\n    /**\r\n     * @dev Inspects the compact payment list provided and calculates the sum\r\n     *      of the amounts referenced\r\n     * @param data binary array, with 12 bytes per item. 8-bytes amount,\r\n     *        4-bytes payment index.\r\n     * @return the sum of the amounts referenced on the array.\r\n     */\r\n    function getDataSum(bytes memory data) public pure returns (uint sum) {\r\n        require(data.length > 0, \"no data provided\");\r\n        require(data.length % 12 == 0, \"wrong data format, data length should be multiple of 12\");\r\n\r\n        uint n = SafeMath.div(data.length, 12);\r\n        uint modulus = 2**64;\r\n\r\n        sum = 0;\r\n\r\n        // Get the sum of the stated amounts in data\r\n        // Each entry in data is [8-bytes amount][4-bytes payIndex]\r\n\r\n        for (uint i = 0; i < n; i++) {\r\n            // solium-disable-next-line security/no-inline-assembly\r\n            assembly {\r\n                let amount := mod(mload(add(data, add(8, mul(i, 12)))), modulus)\r\n                let result := add(sum, amount)\r\n                switch or(gt(result, modulus), eq(result, modulus))\r\n                case 1 { revert (0, 0) }\r\n                default { sum := result }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Helper function that obtains the amount/payIndex pair located at\r\n     *      position `index`.\r\n     * @param data binary array, with 12 bytes per item. 8-bytes amount,\r\n     *        4-bytes payment index.\r\n     * @param index Array item requested.\r\n     * @return amount and payIndex requested.\r\n     */\r\n    function getDataAtIndex(bytes memory data, uint index) public pure returns (uint64 amount, uint32 payIndex) {\r\n        require(data.length > 0, \"no data provided\");\r\n        require(data.length % 12 == 0, \"wrong data format, data length should be multiple of 12\");\r\n\r\n        uint mod1 = 2**64;\r\n        uint mod2 = 2**32;\r\n        uint i = SafeMath.mul(index, 12);\r\n\r\n        require(i <= SafeMath.sub(data.length, 12), \"index * 12 must be less or equal than (data.length - 12)\");\r\n\r\n        // solium-disable-next-line security/no-inline-assembly\r\n        assembly {\r\n            amount := mod( mload(add(data, add(8, i))), mod1 )\r\n\r\n            payIndex := mod( mload(add(data, add(12, i))), mod2 )\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev obtains the number of bytes per id in `payData`\r\n     * @param payData efficient binary representation of a list of accountIds\r\n     * @return bytes per id in `payData`\r\n     */\r\n    function getBytesPerId(bytes payData) internal pure returns (uint) {\r\n        // payData includes a 2 byte header and a list of ids\r\n        // [0xff][bytesPerId]\r\n\r\n        uint len = payData.length;\r\n        require(len >= 2, \"payData length should be >= 2\");\r\n        require(uint8(payData[0]) == PAY_DATA_HEADER_MARKER, \"payData header missing\");\r\n        uint bytesPerId = uint(payData[1]);\r\n        require(bytesPerId > 0 && bytesPerId < 32, \"second byte of payData should be positive and less than 32\");\r\n\r\n        // remaining bytes should be a multiple of bytesPerId\r\n        require((len - 2) % bytesPerId == 0,\r\n        \"payData length is invalid, all payees must have same amount of bytes (payData[1])\");\r\n\r\n        return bytesPerId;\r\n    }\r\n\r\n    /**\r\n     * @dev Process payData, inspecting the list of ids, accumulating the amount for\r\n     *    each entry of `id`.\r\n     *   `payData` includes 2 header bytes, followed by n bytesPerId-bytes entries.\r\n     *   `payData` format: [byte 0xff][byte bytesPerId][delta 0][delta 1]..[delta n-1]\r\n     * @param payData List of payees of a specific Payment, with the above format.\r\n     * @param id ID to look for in `payData`\r\n     * @param amount amount per occurrence of `id` in `payData`\r\n     * @return the amount sum for all occurrences of `id` in `payData`\r\n     */\r\n    function getPayDataSum(bytes memory payData, uint id, uint amount) public pure returns (uint sum) {\r\n        uint bytesPerId = getBytesPerId(payData);\r\n        uint modulus = 1 << SafeMath.mul(bytesPerId, 8);\r\n        uint currentId = 0;\r\n\r\n        sum = 0;\r\n\r\n        for (uint i = 2; i < payData.length; i += bytesPerId) {\r\n            // Get next id delta from paydata\r\n            // currentId += payData[2+i*bytesPerId]\r\n\r\n            // solium-disable-next-line security/no-inline-assembly\r\n            assembly {\r\n                currentId := add(\r\n                    currentId,\r\n                    mod(\r\n                        mload(add(payData, add(i, bytesPerId))),\r\n                        modulus))\r\n\r\n                switch eq(currentId, id)\r\n                case 1 { sum := add(sum, amount) }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev calculates the number of accounts included in payData\r\n     * @param payData efficient binary representation of a list of accountIds\r\n     * @return number of accounts present\r\n     */\r\n    function getPayDataCount(bytes payData) public pure returns (uint) {\r\n        uint bytesPerId = getBytesPerId(payData);\r\n\r\n        // calculate number of records\r\n        return SafeMath.div(payData.length - 2, bytesPerId);\r\n    }\r\n\r\n    /**\r\n     * @dev function. Phase I of the challenging game\r\n     * @param collectSlot Collect slot\r\n     * @param config Various parameters\r\n     * @param accounts a reference to the main accounts array\r\n     * @param challenger id of the challenger user\r\n     */\r\n    function challenge_1(\r\n        Data.CollectSlot storage collectSlot,\r\n        Data.Config storage config,\r\n        Data.Account[] storage accounts,\r\n        uint32 challenger\r\n    )\r\n        public\r\n        onlyValidCollectSlot(collectSlot, 1)\r\n    {\r\n        require(accounts[challenger].balance >= config.challengeStake, \"not enough balance\");\r\n\r\n        collectSlot.status = 2;\r\n        collectSlot.challenger = challenger;\r\n        collectSlot.block = getFutureBlock(config.challengeStepBlocks);\r\n\r\n        accounts[challenger].balance -= config.challengeStake;\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function. Phase II of the challenging game\r\n     * @param collectSlot Collect slot\r\n     * @param config Various parameters\r\n     * @param data Binary array listing the payments in which the user was referenced.\r\n     */\r\n    function challenge_2(\r\n        Data.CollectSlot storage collectSlot,\r\n        Data.Config storage config,\r\n        bytes memory data\r\n    )\r\n        public\r\n        onlyValidCollectSlot(collectSlot, 2)\r\n    {\r\n        require(getDataSum(data) == collectSlot.amount, \"data doesn't represent collected amount\");\r\n\r\n        collectSlot.data = keccak256(data);\r\n        collectSlot.status = 3;\r\n        collectSlot.block = getFutureBlock(config.challengeStepBlocks);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function. Phase III of the challenging game\r\n     * @param collectSlot Collect slot\r\n     * @param config Various parameters\r\n     * @param data Binary array listing the payments in which the user was referenced.\r\n     * @param disputedPaymentIndex index selecting the disputed payment\r\n     */\r\n    function challenge_3(\r\n        Data.CollectSlot storage collectSlot,\r\n        Data.Config storage config,\r\n        bytes memory data,\r\n        uint32 disputedPaymentIndex\r\n    )\r\n        public\r\n        onlyValidCollectSlot(collectSlot, 3)\r\n    {\r\n        require(collectSlot.data == keccak256(data),\r\n        \"data mismatch, collected data hash doesn't match provided data hash\");\r\n        (collectSlot.challengeAmount, collectSlot.index) = getDataAtIndex(data, disputedPaymentIndex);\r\n        collectSlot.status = 4;\r\n        collectSlot.block = getFutureBlock(config.challengeStepBlocks);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function. Phase IV of the challenging game\r\n     * @param collectSlot Collect slot\r\n     * @param payments a reference to the BatPay payments array\r\n     * @param payData binary data describing the list of account receiving\r\n     *        tokens on the selected transfer\r\n     */\r\n    function challenge_4(\r\n        Data.CollectSlot storage collectSlot,\r\n        Data.Payment[] storage payments,\r\n        bytes memory payData\r\n    )\r\n        public\r\n        onlyValidCollectSlot(collectSlot, 4)\r\n    {\r\n        require(collectSlot.index >= collectSlot.minPayIndex && collectSlot.index < collectSlot.maxPayIndex,\r\n            \"payment referenced is out of range\");\r\n        Data.Payment memory p = payments[collectSlot.index];\r\n        require(keccak256(payData) == p.paymentDataHash,\r\n        \"payData mismatch, payment's data hash doesn't match provided payData hash\");\r\n        require(p.lockingKeyHash == 0, \"payment is locked\");\r\n\r\n        uint collected = getPayDataSum(payData, collectSlot.to, p.amount);\r\n\r\n        // Check if id is included in bulkRegistration within payment\r\n        if (collectSlot.to >= p.smallestAccountId && collectSlot.to < p.greatestAccountId) {\r\n            collected = SafeMath.add(collected, p.amount);\r\n        }\r\n\r\n        require(collected == collectSlot.challengeAmount,\r\n        \"amount mismatch, provided payData sum doesn't match collected challenge amount\");\r\n\r\n        collectSlot.status = 5;\r\n    }\r\n\r\n    /**\r\n     * @dev the challenge was completed successfully, or the delegate failed to respond on time.\r\n     *      The challenger will collect the stake.\r\n     * @param collectSlot Collect slot\r\n     * @param config Various parameters\r\n     * @param accounts a reference to the main accounts array\r\n     */\r\n    function challenge_success(\r\n        Data.CollectSlot storage collectSlot,\r\n        Data.Config storage config,\r\n        Data.Account[] storage accounts\r\n    )\r\n        public\r\n    {\r\n        require((collectSlot.status == 2 || collectSlot.status == 4),\r\n            \"Wrong Collect Slot status\");\r\n        require(challengeHasExpired(collectSlot),\r\n            \"Challenge not yet finished\");\r\n\r\n        accounts[collectSlot.challenger].balance = SafeMath.add64(\r\n            accounts[collectSlot.challenger].balance,\r\n            SafeMath.add64(config.collectStake, config.challengeStake));\r\n\r\n        collectSlot.status = 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function. The delegate proved the challenger wrong, or\r\n     *      the challenger failed to respond on time. The delegae collects the stake.\r\n     * @param collectSlot Collect slot\r\n     * @param config Various parameters\r\n     * @param accounts a reference to the main accounts array\r\n     */\r\n    function challenge_failed(\r\n        Data.CollectSlot storage collectSlot,\r\n        Data.Config storage config,\r\n        Data.Account[] storage accounts\r\n    )\r\n        public\r\n    {\r\n        require(collectSlot.status == 5 || (collectSlot.status == 3 && block.number >= collectSlot.block),\r\n            \"challenge not completed\");\r\n\r\n        // Challenge failed\r\n        // delegate wins Stake\r\n        accounts[collectSlot.delegate].balance = SafeMath.add64(\r\n            accounts[collectSlot.delegate].balance,\r\n            config.challengeStake);\r\n\r\n        // reset slot to status=1, waiting for challenges\r\n        collectSlot.challenger = 0;\r\n        collectSlot.status = 1;\r\n        collectSlot.block = getFutureBlock(config.challengeBlocks);\r\n    }\r\n\r\n    /**\r\n     * @dev Helps verify a ECDSA signature, while recovering the signing address.\r\n     * @param hash Hash of the signed message\r\n     * @param sig binary representation of the r, s & v parameters.\r\n     * @return address of the signer if data provided is valid, zero otherwise.\r\n     */\r\n    function recoverHelper(bytes32 hash, bytes sig) public pure returns (address) {\r\n        bytes memory prefix = \"\\x19Ethereum Signed Message:\\n32\";\r\n        bytes32 prefixedHash = keccak256(abi.encodePacked(prefix, hash));\r\n\r\n        bytes32 r;\r\n        bytes32 s;\r\n        uint8 v;\r\n\r\n        // Check the signature length\r\n        if (sig.length != 65) {\r\n            return (address(0));\r\n        }\r\n\r\n        // Divide the signature in r, s and v variables\r\n        // ecrecover takes the signature parameters, and the only way to get them\r\n        // currently is to use assembly.\r\n        // solium-disable-next-line security/no-inline-assembly\r\n        assembly {\r\n            r := mload(add(sig, 32))\r\n            s := mload(add(sig, 64))\r\n            v := byte(0, mload(add(sig, 96)))\r\n        }\r\n\r\n        // Version of signature should be 27 or 28, but 0 and 1 are also possible versions\r\n        if (v < 27) {\r\n            v += 27;\r\n        }\r\n\r\n        // If the version is correct return the signer address\r\n        if (v != 27 && v != 28) {\r\n            return address(0);\r\n        }\r\n\r\n        return ecrecover(prefixedHash, v, r, s);\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @title Payments and Challenge game - Performs the operations associated with\r\n *        transfer and the different steps of the collect challenge game.\r\n */\r\ncontract Payments is Accounts {\r\n    event PaymentRegistered(\r\n        uint32 indexed payIndex,\r\n        uint indexed from,\r\n        uint totalNumberOfPayees,\r\n        uint amount\r\n    );\r\n\r\n    event PaymentUnlocked(uint32 indexed payIndex, bytes key);\r\n    event PaymentRefunded(uint32 beneficiaryAccountId, uint64 amountRefunded);\r\n\r\n    /**\r\n     * Event for collection logging. Off-chain monitoring services may listen\r\n     * to this event to trigger challenges.\r\n     */\r\n    event Collect(\r\n        uint indexed delegate,\r\n        uint indexed slot,\r\n        uint indexed to,\r\n        uint32 fromPayindex,\r\n        uint32 toPayIndex,\r\n        uint amount\r\n    );\r\n\r\n    event Challenge1(uint indexed delegate, uint indexed slot, uint challenger);\r\n    event Challenge2(uint indexed delegate, uint indexed slot);\r\n    event Challenge3(uint indexed delegate, uint indexed slot, uint index);\r\n    event Challenge4(uint indexed delegate, uint indexed slot);\r\n    event ChallengeSuccess(uint indexed delegate, uint indexed slot);\r\n    event ChallengeFailed(uint indexed delegate, uint indexed slot);\r\n\r\n    Payment[] public payments;\r\n    mapping (uint32 => mapping (uint32 => CollectSlot)) public collects;\r\n\r\n    /**\r\n     * @dev Register token payment to multiple recipients\r\n     * @param fromId Account id for the originator of the transaction\r\n     * @param amount Amount of tokens to pay each destination.\r\n     * @param fee Fee in tokens to be payed to the party providing the unlocking service\r\n     * @param payData Efficient representation of the destination account list\r\n     * @param newCount Number of new destination accounts that will be reserved during the registerPayment transaction\r\n     * @param rootHash Hash of the root hash of the Merkle tree listing the addresses reserved.\r\n     * @param lockingKeyHash hash resulting of calculating the keccak256 of\r\n     *        of the key locking this payment to help in atomic data swaps.\r\n     *        This hash will later be used by the `unlock` function to unlock the payment we are registering.\r\n     *         The `lockingKeyHash` must be equal to the keccak256 of the packed\r\n     *         encoding of the unlockerAccountId and the key used by the unlocker to encrypt the traded data:\r\n     *             `keccak256(abi.encodePacked(unlockerAccountId, key))`\r\n     *         DO NOT use previously used locking keys, since an attacker could realize that by comparing key hashes\r\n     * @param metadata Application specific data to be stored associated with the payment\r\n     */\r\n    function registerPayment(\r\n        uint32 fromId,\r\n        uint64 amount,\r\n        uint64 fee,\r\n        bytes payData,\r\n        uint newCount,\r\n        bytes32 rootHash,\r\n        bytes32 lockingKeyHash,\r\n        bytes32 metadata\r\n    )\r\n        external\r\n    {\r\n        require(payments.length < 2**32, \"Cannot add more payments\");\r\n        require(isAccountOwner(fromId), \"Invalid fromId\");\r\n        require(amount > 0, \"Invalid amount\");\r\n        require(newCount == 0 || rootHash > 0, \"Invalid root hash\"); // although bulkRegister checks this, we anticipate\r\n        require(fee == 0 || lockingKeyHash > 0, \"Invalid lock hash\");\r\n\r\n        Payment memory p;\r\n\r\n        // Prepare a Payment struct\r\n        p.totalNumberOfPayees = SafeMath.add32(Challenge.getPayDataCount(payData), newCount);\r\n        require(p.totalNumberOfPayees > 0, \"Invalid number of payees, should at least be 1 payee\");\r\n        require(p.totalNumberOfPayees < params.maxTransfer,\r\n        \"Too many payees, it should be less than config maxTransfer\");\r\n\r\n        p.fromAccountId = fromId;\r\n        p.amount = amount;\r\n        p.fee = fee;\r\n        p.lockingKeyHash = lockingKeyHash;\r\n        p.metadata = metadata;\r\n        p.smallestAccountId = uint32(accounts.length);\r\n        p.greatestAccountId = SafeMath.add32(p.smallestAccountId, newCount);\r\n        p.lockTimeoutBlockNumber = SafeMath.add64(block.number, params.unlockBlocks);\r\n        p.paymentDataHash = keccak256(abi.encodePacked(payData));\r\n\r\n        // calculate total cost of payment\r\n        uint64 totalCost = SafeMath.mul64(amount, p.totalNumberOfPayees);\r\n        totalCost = SafeMath.add64(totalCost, fee);\r\n\r\n        // Check that fromId has enough balance and substract totalCost\r\n        balanceSub(fromId, totalCost);\r\n\r\n        // If this operation includes new accounts, do a bulkRegister\r\n        if (newCount > 0) {\r\n            bulkRegister(newCount, rootHash);\r\n        }\r\n\r\n        // Save the new Payment\r\n        payments.push(p);\r\n\r\n        emit PaymentRegistered(SafeMath.sub32(payments.length, 1), p.fromAccountId, p.totalNumberOfPayees, p.amount);\r\n    }\r\n\r\n    /**\r\n     * @dev provide the required key, releasing the payment and enabling the buyer decryption the digital content.\r\n     * @param payIndex payment Index associated with the registerPayment operation.\r\n     * @param unlockerAccountId id of the party providing the unlocking service. Fees wil be payed to this id.\r\n     * @param key Cryptographic key used to encrypt traded data.\r\n     */\r\n    function unlock(uint32 payIndex, uint32 unlockerAccountId, bytes memory key) public returns(bool) {\r\n        require(payIndex < payments.length, \"invalid payIndex, payments is not that long yet\");\r\n        require(isValidId(unlockerAccountId), \"Invalid unlockerAccountId\");\r\n        require(block.number < payments[payIndex].lockTimeoutBlockNumber, \"Hash lock expired\");\r\n        bytes32 h = keccak256(abi.encodePacked(unlockerAccountId, key));\r\n        require(h == payments[payIndex].lockingKeyHash, \"Invalid key\");\r\n\r\n        payments[payIndex].lockingKeyHash = bytes32(0);\r\n        balanceAdd(unlockerAccountId, payments[payIndex].fee);\r\n\r\n        emit PaymentUnlocked(payIndex, key);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Enables the buyer to recover funds associated with a `registerPayment()`\r\n     *      operation for which decryption keys were not provided.\r\n     * @param payIndex Index of the payment transaction associated with this request.\r\n     * @return true if the operation succeded.\r\n     */\r\n    function refundLockedPayment(uint32 payIndex) external returns (bool) {\r\n        require(payIndex < payments.length, \"invalid payIndex, payments is not that long yet\");\r\n        require(payments[payIndex].lockingKeyHash != 0, \"payment is already unlocked\");\r\n        require(block.number >= payments[payIndex].lockTimeoutBlockNumber, \"Hash lock has not expired yet\");\r\n        Payment memory payment = payments[payIndex];\r\n        require(payment.totalNumberOfPayees > 0, \"payment already refunded\");\r\n\r\n        uint64 total = SafeMath.add64(\r\n            SafeMath.mul64(payment.totalNumberOfPayees, payment.amount),\r\n            payment.fee\r\n        );\r\n\r\n        payment.totalNumberOfPayees = 0;\r\n        payment.fee = 0;\r\n        payment.amount = 0;\r\n        payments[payIndex] = payment;\r\n\r\n        // Complete refund\r\n        balanceAdd(payment.fromAccountId, total);\r\n        emit PaymentRefunded(payment.fromAccountId, total);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev let users claim pending balance associated with prior transactions\r\n            Users ask a delegate to complete the transaction on their behalf,\r\n            the delegate calculates the apropiate amount (declaredAmount) and\r\n            waits for a possible challenger.\r\n            If this is an instant collect, tokens are transfered immediatly.\r\n     * @param delegate id of the delegate account performing the operation on the name of the user.\r\n     * @param slotId Individual slot used for the challenge game.\r\n     * @param toAccountId Destination of the collect operation.\r\n     * @param maxPayIndex payIndex of the first payment index not covered by this application.\r\n     * @param declaredAmount amount of tokens owed to this user account\r\n     * @param fee fee in tokens to be paid for the end user help.\r\n     * @param destination Address to withdraw the full account balance.\r\n     * @param signature An R,S,V ECDS signature provided by a user.\r\n     */\r\n    function collect(\r\n        uint32 delegate,\r\n        uint32 slotId,\r\n        uint32 toAccountId,\r\n        uint32 maxPayIndex,\r\n        uint64 declaredAmount,\r\n        uint64 fee,\r\n        address destination,\r\n        bytes memory signature\r\n    )\r\n    public\r\n    {\r\n        // Check delegate and toAccountId are valid\r\n        require(isAccountOwner(delegate), \"invalid delegate\");\r\n        require(isValidId(toAccountId), \"toAccountId must be a valid account id\");\r\n\r\n        // make sure the game slot is empty (release it if necessary)\r\n        freeSlot(delegate, slotId);\r\n\r\n        Account memory tacc = accounts[toAccountId];\r\n        require(tacc.owner != 0, \"account registration has to be completed\");\r\n\r\n        if (delegate != toAccountId) {\r\n            // If \"toAccountId\" != delegate, check who signed this transaction\r\n            bytes32 hash =\r\n            keccak256(\r\n            abi.encodePacked(\r\n                address(this), delegate, toAccountId, tacc.lastCollectedPaymentId,\r\n                maxPayIndex, declaredAmount, fee, destination\r\n            ));\r\n            require(Challenge.recoverHelper(hash, signature) == tacc.owner, \"Bad user signature\");\r\n        }\r\n\r\n        // Check maxPayIndex is valid\r\n        require(maxPayIndex > 0 && maxPayIndex <= payments.length,\r\n        \"invalid maxPayIndex, payments is not that long yet\");\r\n        require(maxPayIndex > tacc.lastCollectedPaymentId, \"account already collected payments up to maxPayIndex\");\r\n        require(payments[maxPayIndex - 1].lockTimeoutBlockNumber < block.number,\r\n            \"cannot collect payments that can be unlocked\");\r\n\r\n        // Check if declaredAmount and fee are valid\r\n        require(declaredAmount <= params.maxCollectAmount, \"declaredAmount is too big\");\r\n        require(fee <= declaredAmount, \"fee is too big, should be smaller than declaredAmount\");\r\n\r\n        // Prepare the challenge slot\r\n        CollectSlot storage sl = collects[delegate][slotId];\r\n        sl.delegate = delegate;\r\n        sl.minPayIndex = tacc.lastCollectedPaymentId;\r\n        sl.maxPayIndex = maxPayIndex;\r\n        sl.amount = declaredAmount;\r\n        sl.to = toAccountId;\r\n        sl.block = Challenge.getFutureBlock(params.challengeBlocks);\r\n        sl.status = 1;\r\n\r\n        // Calculate how many tokens needs the delegate, and setup delegateAmount and addr\r\n        uint64 needed = params.collectStake;\r\n\r\n        // check if this is an instant collect\r\n        if (slotId >= INSTANT_SLOT) {\r\n            uint64 declaredAmountLessFee = SafeMath.sub64(declaredAmount, fee);\r\n            sl.delegateAmount = declaredAmount;\r\n            needed = SafeMath.add64(needed, declaredAmountLessFee);\r\n            sl.addr = address(0);\r\n\r\n            // Instant-collect, toAccount gets the declaredAmount now\r\n            balanceAdd(toAccountId, declaredAmountLessFee);\r\n        } else\r\n        {   // not instant-collect\r\n            sl.delegateAmount = fee;\r\n            sl.addr = destination;\r\n        }\r\n\r\n        // Check delegate has enough funds\r\n        require(accounts[delegate].balance >= needed, \"not enough funds\");\r\n\r\n        // Update the lastCollectPaymentId for the toAccount\r\n        accounts[toAccountId].lastCollectedPaymentId = uint32(maxPayIndex);\r\n\r\n        // Now the delegate Pays\r\n        balanceSub(delegate, needed);\r\n\r\n        // Proceed if the user is withdrawing its balance\r\n        if (destination != address(0) && slotId >= INSTANT_SLOT) {\r\n            uint64 toWithdraw = accounts[toAccountId].balance;\r\n            accounts[toAccountId].balance = 0;\r\n            require(token.transfer(destination, toWithdraw), \"transfer failed\");\r\n        }\r\n\r\n        emit Collect(delegate, slotId, toAccountId, tacc.lastCollectedPaymentId, maxPayIndex, declaredAmount);\r\n    }\r\n\r\n    /**\r\n     * @dev gets the number of payments issued\r\n     * @return returns the size of the payments array.\r\n     */\r\n    function getPaymentsLength() external view returns (uint) {\r\n        return payments.length;\r\n    }\r\n\r\n    /**\r\n     * @dev initiate a challenge game\r\n     * @param delegate id of the delegate that performed the collect operation\r\n     *        in the name of the end-user.\r\n     * @param slot slot used for the challenge game. Every user has a sperate\r\n     *        set of slots\r\n     * @param challenger id of the user account challenging the delegate.\r\n     */\r\n    function challenge_1(\r\n        uint32 delegate,\r\n        uint32 slot,\r\n        uint32 challenger\r\n    )\r\n        public\r\n        validId(delegate)\r\n        onlyAccountOwner(challenger)\r\n    {\r\n        Challenge.challenge_1(collects[delegate][slot], params, accounts, challenger);\r\n        emit Challenge1(delegate, slot, challenger);\r\n    }\r\n\r\n    /**\r\n     * @dev The delegate provides the list of payments that mentions the enduser\r\n     * @param delegate id of the delegate performing the collect operation\r\n     * @param slot slot used for the operation\r\n     * @param data binary list of payment indexes associated with this collect operation.\r\n     */\r\n    function challenge_2(\r\n        uint32 delegate,\r\n        uint32 slot,\r\n        bytes memory data\r\n    )\r\n        public\r\n        onlyAccountOwner(delegate)\r\n    {\r\n        Challenge.challenge_2(collects[delegate][slot], params, data);\r\n        emit Challenge2(delegate, slot);\r\n    }\r\n\r\n    /**\r\n     * @dev the Challenger chooses a single index into the delegate provided data list\r\n     * @param delegate id of the delegate performing the collect operation\r\n     * @param slot slot used for the operation\r\n     * @param data binary list of payment indexes associated with this collect operation.\r\n     * @param index index into the data array for the payment id selected by the challenger\r\n     */\r\n    function challenge_3(\r\n        uint32 delegate,\r\n        uint32 slot,\r\n        bytes memory data,\r\n        uint32 index\r\n    )\r\n        public\r\n        validId(delegate)\r\n    {\r\n        require(isAccountOwner(collects[delegate][slot].challenger), \"only challenger can call challenge_2\");\r\n\r\n        Challenge.challenge_3(collects[delegate][slot], params, data, index);\r\n        emit Challenge3(delegate, slot, index);\r\n    }\r\n\r\n    /**\r\n     * @dev the delegate provides proof that the destination account was\r\n     *      included on that payment, winning the game\r\n     * @param delegate id of the delegate performing the collect operation\r\n     * @param slot slot used for the operation\r\n     */\r\n    function challenge_4(\r\n        uint32 delegate,\r\n        uint32 slot,\r\n        bytes memory payData\r\n    )\r\n        public\r\n        onlyAccountOwner(delegate)\r\n    {\r\n        Challenge.challenge_4(\r\n            collects[delegate][slot],\r\n            payments,\r\n            payData\r\n            );\r\n        emit Challenge4(delegate, slot);\r\n    }\r\n\r\n    /**\r\n     * @dev the challenge was completed successfully. The delegate stake is slashed.\r\n     * @param delegate id of the delegate performing the collect operation\r\n     * @param slot slot used for the operation\r\n     */\r\n    function challenge_success(\r\n        uint32 delegate,\r\n        uint32 slot\r\n    )\r\n        public\r\n        validId(delegate)\r\n    {\r\n        Challenge.challenge_success(collects[delegate][slot], params, accounts);\r\n        emit ChallengeSuccess(delegate, slot);\r\n    }\r\n\r\n    /**\r\n     * @dev The delegate won the challenge game. He gets the challenge stake.\r\n     * @param delegate id of the delegate performing the collect operation\r\n     * @param slot slot used for the operation\r\n     */\r\n    function challenge_failed(\r\n        uint32 delegate,\r\n        uint32 slot\r\n    )\r\n        public\r\n        onlyAccountOwner(delegate)\r\n    {\r\n        Challenge.challenge_failed(collects[delegate][slot], params, accounts);\r\n        emit ChallengeFailed(delegate, slot);\r\n    }\r\n\r\n    /**\r\n     * @dev Releases a slot used by the collect channel game, only when the game is finished.\r\n     *      This does three things:\r\n     *        1. Empty the slot\r\n     *        2. Pay the delegate\r\n     *        3. Pay the destinationAccount\r\n     *      Also, if a token.transfer was requested, transfer the outstanding balance to the specified address.\r\n     * @param delegate id of the account requesting the release operation\r\n     * @param slot id of the slot requested for the duration of the challenge game\r\n     */\r\n    function freeSlot(uint32 delegate, uint32 slot) public {\r\n        CollectSlot memory s = collects[delegate][slot];\r\n\r\n        // If this is slot is empty, nothing else to do here.\r\n        if (s.status == 0) return;\r\n\r\n        // Make sure this slot is ready to be freed.\r\n        // It should be in the waiting state(1) and with challenge time ran-out\r\n        require(s.status == 1, \"slot not available\");\r\n        require(block.number >= s.block, \"slot not available\");\r\n\r\n        // 1. Put the slot in the empty state\r\n        collects[delegate][slot].status = 0;\r\n\r\n        // 2. Pay the delegate\r\n        // This includes the stake as well as fees and other tokens reserved during collect()\r\n        // [delegateAmount + stake] => delegate\r\n        balanceAdd(delegate, SafeMath.add64(s.delegateAmount, params.collectStake));\r\n\r\n        // 3. Pay the destination account\r\n        // [amount - delegateAmount] => to\r\n        uint64 balance = SafeMath.sub64(s.amount, s.delegateAmount);\r\n\r\n        // was a transfer requested?\r\n        if (s.addr != address(0))\r\n        {\r\n            // empty the account balance\r\n            balance = SafeMath.add64(balance, accounts[s.to].balance);\r\n            accounts[s.to].balance = 0;\r\n            if (balance != 0)\r\n                require(token.transfer(s.addr, balance), \"transfer failed\");\r\n        } else\r\n        {\r\n            balanceAdd(s.to, balance);\r\n        }\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @title BatchPayment processing\r\n * @notice This contract allows to scale ERC-20 token transfer for fees or\r\n *         micropayments on the few-buyers / many-sellers setting.\r\n */\r\ncontract BatPay is Payments {\r\n\r\n    /**\r\n     * @dev Contract constructor, sets ERC20 token this contract will use for payments\r\n     * @param token_ ERC20 contract address\r\n     * @param maxBulk Maximum number of users to register in a single bulkRegister\r\n     * @param maxTransfer Maximum number of destinations on a single payment\r\n     * @param challengeBlocks number of blocks to wait for a challenge\r\n     * @param challengeStepBlocks number of blocks to wait for a single step on\r\n     *        the challenge game\r\n     * @param collectStake stake in tokens for a collect operation\r\n     * @param challengeStake stake in tokens for the challenger of a collect operation\r\n     * @param unlockBlocks number of blocks to wait after registering payment\r\n     *        for an unlock operation\r\n     * @param maxCollectAmount Maximum amount of tokens to be collected in a\r\n     *        single transaction\r\n     */\r\n    constructor(\r\n        IERC20 token_,\r\n        uint32 maxBulk,\r\n        uint32 maxTransfer,\r\n        uint32 challengeBlocks,\r\n        uint32 challengeStepBlocks,\r\n        uint64 collectStake,\r\n        uint64 challengeStake,\r\n        uint32 unlockBlocks,\r\n        uint64 maxCollectAmount\r\n    )\r\n        public\r\n    {\r\n        require(token_ != address(0), \"Token address can't be zero\");\r\n        require(maxBulk > 0, \"Parameter maxBulk can't be zero\");\r\n        require(maxTransfer > 0, \"Parameter maxTransfer can't be zero\");\r\n        require(challengeBlocks > 0, \"Parameter challengeBlocks can't be zero\");\r\n        require(challengeStepBlocks > 0, \"Parameter challengeStepBlocks can't be zero\");\r\n        require(collectStake > 0, \"Parameter collectStake can't be zero\");\r\n        require(challengeStake > 0, \"Parameter challengeStake can't be zero\");\r\n        require(unlockBlocks > 0, \"Parameter unlockBlocks can't be zero\");\r\n        require(maxCollectAmount > 0, \"Parameter maxCollectAmount can't be zero\");\r\n\r\n        owner = msg.sender;\r\n        token = IERC20(token_);\r\n        params.maxBulk = maxBulk;\r\n        params.maxTransfer = maxTransfer;\r\n        params.challengeBlocks = challengeBlocks;\r\n        params.challengeStepBlocks = challengeStepBlocks;\r\n        params.collectStake = collectStake;\r\n        params.challengeStake = challengeStake;\r\n        params.unlockBlocks = unlockBlocks;\r\n        params.maxCollectAmount = maxCollectAmount;\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"fromId\",\"type\":\"uint32\"},{\"name\":\"amount\",\"type\":\"uint64\"},{\"name\":\"fee\",\"type\":\"uint64\"},{\"name\":\"payData\",\"type\":\"bytes\"},{\"name\":\"newCount\",\"type\":\"uint256\"},{\"name\":\"rootHash\",\"type\":\"bytes32\"},{\"name\":\"lockingKeyHash\",\"type\":\"bytes32\"},{\"name\":\"metadata\",\"type\":\"bytes32\"}],\"name\":\"registerPayment\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"delegate\",\"type\":\"uint32\"},{\"name\":\"slotId\",\"type\":\"uint32\"},{\"name\":\"toAccountId\",\"type\":\"uint32\"},{\"name\":\"maxPayIndex\",\"type\":\"uint32\"},{\"name\":\"declaredAmount\",\"type\":\"uint64\"},{\"name\":\"fee\",\"type\":\"uint64\"},{\"name\":\"destination\",\"type\":\"address\"},{\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"collect\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAccountsLength\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"bulkRegistrations\",\"outputs\":[{\"name\":\"rootHash\",\"type\":\"bytes32\"},{\"name\":\"recordCount\",\"type\":\"uint32\"},{\"name\":\"smallestRecordId\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"accountId\",\"type\":\"uint256\"}],\"name\":\"isValidId\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"register\",\"outputs\":[{\"name\":\"ret\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"INSTANT_SLOT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"proof\",\"type\":\"bytes32[]\"},{\"name\":\"accountId\",\"type\":\"uint256\"},{\"name\":\"bulkId\",\"type\":\"uint256\"}],\"name\":\"claimBulkRegistrationId\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"NEW_ACCOUNT_FLAG\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"payIndex\",\"type\":\"uint32\"},{\"name\":\"unlockerAccountId\",\"type\":\"uint32\"},{\"name\":\"key\",\"type\":\"bytes\"}],\"name\":\"unlock\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint64\"},{\"name\":\"accountId\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"delegate\",\"type\":\"uint32\"},{\"name\":\"slot\",\"type\":\"uint32\"},{\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"challenge_2\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"delegate\",\"type\":\"uint32\"},{\"name\":\"slot\",\"type\":\"uint32\"}],\"name\":\"challenge_success\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"accountId\",\"type\":\"uint256\"}],\"name\":\"isAccountOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint64\"},{\"name\":\"accountId\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"delegate\",\"type\":\"uint32\"},{\"name\":\"slot\",\"type\":\"uint32\"},{\"name\":\"payData\",\"type\":\"bytes\"}],\"name\":\"challenge_4\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint32\"},{\"name\":\"\",\"type\":\"uint32\"}],\"name\":\"collects\",\"outputs\":[{\"name\":\"minPayIndex\",\"type\":\"uint32\"},{\"name\":\"maxPayIndex\",\"type\":\"uint32\"},{\"name\":\"amount\",\"type\":\"uint64\"},{\"name\":\"delegateAmount\",\"type\":\"uint64\"},{\"name\":\"to\",\"type\":\"uint32\"},{\"name\":\"block\",\"type\":\"uint64\"},{\"name\":\"delegate\",\"type\":\"uint32\"},{\"name\":\"challenger\",\"type\":\"uint32\"},{\"name\":\"index\",\"type\":\"uint32\"},{\"name\":\"challengeAmount\",\"type\":\"uint64\"},{\"name\":\"status\",\"type\":\"uint8\"},{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"data\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_ACCOUNT_ID\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"payments\",\"outputs\":[{\"name\":\"fromAccountId\",\"type\":\"uint32\"},{\"name\":\"amount\",\"type\":\"uint64\"},{\"name\":\"fee\",\"type\":\"uint64\"},{\"name\":\"smallestAccountId\",\"type\":\"uint32\"},{\"name\":\"greatestAccountId\",\"type\":\"uint32\"},{\"name\":\"totalNumberOfPayees\",\"type\":\"uint32\"},{\"name\":\"lockTimeoutBlockNumber\",\"type\":\"uint64\"},{\"name\":\"paymentDataHash\",\"type\":\"bytes32\"},{\"name\":\"lockingKeyHash\",\"type\":\"bytes32\"},{\"name\":\"metadata\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"delegate\",\"type\":\"uint32\"},{\"name\":\"slot\",\"type\":\"uint32\"}],\"name\":\"challenge_failed\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"delegate\",\"type\":\"uint32\"},{\"name\":\"slot\",\"type\":\"uint32\"},{\"name\":\"challenger\",\"type\":\"uint32\"}],\"name\":\"challenge_1\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"accountId\",\"type\":\"uint256\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint64\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getPaymentsLength\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getBulkLength\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"delegate\",\"type\":\"uint32\"},{\"name\":\"slot\",\"type\":\"uint32\"}],\"name\":\"freeSlot\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"params\",\"outputs\":[{\"name\":\"maxBulk\",\"type\":\"uint32\"},{\"name\":\"maxTransfer\",\"type\":\"uint32\"},{\"name\":\"challengeBlocks\",\"type\":\"uint32\"},{\"name\":\"challengeStepBlocks\",\"type\":\"uint32\"},{\"name\":\"collectStake\",\"type\":\"uint64\"},{\"name\":\"challengeStake\",\"type\":\"uint64\"},{\"name\":\"unlockBlocks\",\"type\":\"uint32\"},{\"name\":\"massExitIdBlocks\",\"type\":\"uint32\"},{\"name\":\"massExitIdStepBlocks\",\"type\":\"uint32\"},{\"name\":\"massExitBalanceBlocks\",\"type\":\"uint32\"},{\"name\":\"massExitBalanceStepBlocks\",\"type\":\"uint32\"},{\"name\":\"massExitStake\",\"type\":\"uint64\"},{\"name\":\"massExitChallengeStake\",\"type\":\"uint64\"},{\"name\":\"maxCollectAmount\",\"type\":\"uint64\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"payIndex\",\"type\":\"uint32\"}],\"name\":\"refundLockedPayment\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"bulkSize\",\"type\":\"uint256\"},{\"name\":\"rootHash\",\"type\":\"bytes32\"}],\"name\":\"bulkRegister\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"accounts\",\"outputs\":[{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"balance\",\"type\":\"uint64\"},{\"name\":\"lastCollectedPaymentId\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"delegate\",\"type\":\"uint32\"},{\"name\":\"slot\",\"type\":\"uint32\"},{\"name\":\"data\",\"type\":\"bytes\"},{\"name\":\"index\",\"type\":\"uint32\"}],\"name\":\"challenge_3\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"token_\",\"type\":\"address\"},{\"name\":\"maxBulk\",\"type\":\"uint32\"},{\"name\":\"maxTransfer\",\"type\":\"uint32\"},{\"name\":\"challengeBlocks\",\"type\":\"uint32\"},{\"name\":\"challengeStepBlocks\",\"type\":\"uint32\"},{\"name\":\"collectStake\",\"type\":\"uint64\"},{\"name\":\"challengeStake\",\"type\":\"uint64\"},{\"name\":\"unlockBlocks\",\"type\":\"uint32\"},{\"name\":\"maxCollectAmount\",\"type\":\"uint64\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"payIndex\",\"type\":\"uint32\"},{\"indexed\":true,\"name\":\"from\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"totalNumberOfPayees\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"PaymentRegistered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"payIndex\",\"type\":\"uint32\"},{\"indexed\":false,\"name\":\"key\",\"type\":\"bytes\"}],\"name\":\"PaymentUnlocked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"beneficiaryAccountId\",\"type\":\"uint32\"},{\"indexed\":false,\"name\":\"amountRefunded\",\"type\":\"uint64\"}],\"name\":\"PaymentRefunded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"delegate\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"slot\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"fromPayindex\",\"type\":\"uint32\"},{\"indexed\":false,\"name\":\"toPayIndex\",\"type\":\"uint32\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Collect\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"delegate\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"slot\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"challenger\",\"type\":\"uint256\"}],\"name\":\"Challenge1\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"delegate\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"slot\",\"type\":\"uint256\"}],\"name\":\"Challenge2\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"delegate\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"slot\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"Challenge3\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"delegate\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"slot\",\"type\":\"uint256\"}],\"name\":\"Challenge4\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"delegate\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"slot\",\"type\":\"uint256\"}],\"name\":\"ChallengeSuccess\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"delegate\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"slot\",\"type\":\"uint256\"}],\"name\":\"ChallengeFailed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"bulkSize\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"smallestAccountId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"bulkId\",\"type\":\"uint256\"}],\"name\":\"BulkRegister\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"accountId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"accountAddress\",\"type\":\"address\"}],\"name\":\"AccountRegistered\",\"type\":\"event\"}]","ContractName":"BatPay","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"1","ConstructorArguments":"000000000000000000000000281d477239f0ac790270bda6800bc912d1a3532a000000000000000000000000000000000000000000000000000000000000c351000000000000000000000000000000000000000000000000000000000000c3510000000000000000000000000000000000000000000000000000000000001a5e0000000000000000000000000000000000000000000000000000000000006978000000000000000000000000000000000000000000000000000000e8d4a510000000000000000000000000000000000000000000000000000000048c27395000000000000000000000000000000000000000000000000000000000000000011800000000000000000000000000000000000000000000000000002d79883d2000","Library":"Merkle:d0e9271cad86f87c5a538628c22e13fbbb774c87;Challenge:202fe4bf42b8338171b9b8802261623af5322171","SwarmSource":"bzzr://c8b41a20e302e1e133ee787e77412c6511b2240ab8ef30200bb7751a524443b6"}]}