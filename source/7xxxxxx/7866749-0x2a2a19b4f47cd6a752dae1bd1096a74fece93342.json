{"status":"1","message":"OK","result":[{"SourceCode":"{\"Address.sol\":{\"content\":\"pragma solidity ^0.5.0;\\n\\n/**\\n * Utility library of inline functions on addresses\\n */\\nlibrary Address {\\n    /**\\n     * Returns whether the target address is a contract\\n     * @dev This function will return false if invoked during the constructor of a contract,\\n     * as the code is not actually created until after the constructor finishes.\\n     * @param account address of the account to check\\n     * @return whether the target address is a contract\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        uint256 size;\\n        // XXX Currently there is no better way to check if there is a contract in an address\\n        // than to check the size of the code at that address.\\n        // See https://ethereum.stackexchange.com/a/14016/36603\\n        // for more details about how this works.\\n        // TODO Check this again before the Serenity release, because all addresses will be\\n        // contracts then.\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { size := extcodesize(account) }\\n        return size \\u003e 0;\\n    }\\n}\\n\"},\"Controllable.sol\":{\"content\":\"pragma solidity ^0.5.0;\\n\\nimport \\\"./Ownable.sol\\\";\\n\\ncontract Controllable is Ownable {\\n    mapping(address=\\u003ebool) public controllers;\\n\\n    modifier onlyController {\\n        require(controllers[msg.sender]);\\n        _;\\n    }\\n\\n    function setController(address controller, bool enabled) public onlyOwner {\\n        controllers[controller] = enabled;\\n    }\\n}\\n\"},\"Deed.sol\":{\"content\":\"pragma solidity \\u003e=0.4.24;\\n\\ninterface Deed {\\n\\n    function setOwner(address payable newOwner) external;\\n    function setRegistrar(address newRegistrar) external;\\n    function setBalance(uint newValue, bool throwOnFailure) external;\\n    function closeDeed(uint refundRatio) external;\\n    function destroyDeed() external;\\n\\n    function owner() external view returns (address);\\n    function previousOwner() external view returns (address);\\n    function value() external view returns (uint);\\n    function creationDate() external view returns (uint);\\n\\n}\\n\"},\"DeedImplementation.sol\":{\"content\":\"pragma solidity ^0.5.0;\\n\\nimport \\\"./Deed.sol\\\";\\n\\n/**\\n * @title Deed to hold ether in exchange for ownership of a node\\n * @dev The deed can be controlled only by the registrar and can only send ether back to the owner.\\n */\\ncontract DeedImplementation is Deed {\\n\\n    address payable constant burn = address(0xdead);\\n\\n    address payable private _owner;\\n    address private _previousOwner;\\n    address private _registrar;\\n\\n    uint private _creationDate;\\n    uint private _value;\\n\\n    bool active;\\n\\n    event OwnerChanged(address newOwner);\\n    event DeedClosed();\\n\\n    modifier onlyRegistrar {\\n        require(msg.sender == _registrar);\\n        _;\\n    }\\n\\n    modifier onlyActive {\\n        require(active);\\n        _;\\n    }\\n\\n    constructor(address payable initialOwner) public payable {\\n        _owner = initialOwner;\\n        _registrar = msg.sender;\\n        _creationDate = now;\\n        active = true;\\n        _value = msg.value;\\n    }\\n\\n    function setOwner(address payable newOwner) external onlyRegistrar {\\n        require(newOwner != address(0x0));\\n        _previousOwner = _owner;  // This allows contracts to check who sent them the ownership\\n        _owner = newOwner;\\n        emit OwnerChanged(newOwner);\\n    }\\n\\n    function setRegistrar(address newRegistrar) external onlyRegistrar {\\n        _registrar = newRegistrar;\\n    }\\n\\n    function setBalance(uint newValue, bool throwOnFailure) external onlyRegistrar onlyActive {\\n        // Check if it has enough balance to set the value\\n        require(_value \\u003e= newValue);\\n        _value = newValue;\\n        // Send the difference to the owner\\n        require(_owner.send(address(this).balance - newValue) || !throwOnFailure);\\n    }\\n\\n    /**\\n     * @dev Close a deed and refund a specified fraction of the bid value\\n     *\\n     * @param refundRatio The amount*1/1000 to refund\\n     */\\n    function closeDeed(uint refundRatio) external onlyRegistrar onlyActive {\\n        active = false;\\n        require(burn.send(((1000 - refundRatio) * address(this).balance)/1000));\\n        emit DeedClosed();\\n        _destroyDeed();\\n    }\\n\\n    /**\\n     * @dev Close a deed and refund a specified fraction of the bid value\\n     */\\n    function destroyDeed() external {\\n        _destroyDeed();\\n    }\\n\\n    function owner() external view returns (address) {\\n        return _owner;\\n    }\\n\\n    function previousOwner() external view returns (address) {\\n        return _previousOwner;\\n    }\\n\\n    function value() external view returns (uint) {\\n        return _value;\\n    }\\n\\n    function creationDate() external view returns (uint) {\\n        _creationDate;\\n    }\\n\\n    function _destroyDeed() internal {\\n        require(!active);\\n\\n        // Instead of selfdestruct(owner), invoke owner fallback function to allow\\n        // owner to log an event if desired; but owner should also be aware that\\n        // its fallback function can also be invoked by setBalance\\n        if (_owner.send(address(this).balance)) {\\n            selfdestruct(burn);\\n        }\\n    }\\n}\\n\"},\"ENS.sol\":{\"content\":\"pragma solidity \\u003e=0.4.24;\\n\\ninterface ENS {\\n\\n    // Logged when the owner of a node assigns a new owner to a subnode.\\n    event NewOwner(bytes32 indexed node, bytes32 indexed label, address owner);\\n\\n    // Logged when the owner of a node transfers ownership to a new account.\\n    event Transfer(bytes32 indexed node, address owner);\\n\\n    // Logged when the resolver for a node changes.\\n    event NewResolver(bytes32 indexed node, address resolver);\\n\\n    // Logged when the TTL of a node changes\\n    event NewTTL(bytes32 indexed node, uint64 ttl);\\n\\n\\n    function setSubnodeOwner(bytes32 node, bytes32 label, address owner) external;\\n    function setResolver(bytes32 node, address resolver) external;\\n    function setOwner(bytes32 node, address owner) external;\\n    function setTTL(bytes32 node, uint64 ttl) external;\\n    function owner(bytes32 node) external view returns (address);\\n    function resolver(bytes32 node) external view returns (address);\\n    function ttl(bytes32 node) external view returns (uint64);\\n\\n}\\n\"},\"HashRegistrar.sol\":{\"content\":\"pragma solidity ^0.5.0;\\n\\n\\n/*\\n\\nTemporary Hash Registrar\\n========================\\n\\nThis is a simplified version of a hash registrar. It is purporsefully limited:\\nnames cannot be six letters or shorter, new auctions will stop after 4 years.\\n\\nThe plan is to test the basic features and then move to a new contract in at most\\n2 years, when some sort of renewal mechanism will be enabled.\\n*/\\n\\n\\nimport \\\"./ENS.sol\\\";\\nimport \\\"./DeedImplementation.sol\\\";\\nimport \\\"./Registrar.sol\\\";\\n\\n/**\\n * @title Registrar\\n * @dev The registrar handles the auction process for each subnode of the node it owns.\\n */\\ncontract HashRegistrar is Registrar {\\n    ENS public ens;\\n    bytes32 public rootNode;\\n\\n    mapping (bytes32 =\\u003e Entry) _entries;\\n    mapping (address =\\u003e mapping (bytes32 =\\u003e Deed)) public sealedBids;\\n\\n    uint32 constant totalAuctionLength = 5 days;\\n    uint32 constant revealPeriod = 48 hours;\\n    uint32 public constant launchLength = 8 weeks;\\n\\n    uint constant minPrice = 0.01 ether;\\n    uint public registryStarted;\\n\\n    struct Entry {\\n        Deed deed;\\n        uint registrationDate;\\n        uint value;\\n        uint highestBid;\\n    }\\n\\n    modifier inState(bytes32 _hash, Mode _state) {\\n        require(state(_hash) == _state);\\n        _;\\n    }\\n\\n    modifier onlyOwner(bytes32 _hash) {\\n        require(state(_hash) == Mode.Owned \\u0026\\u0026 msg.sender == _entries[_hash].deed.owner());\\n        _;\\n    }\\n\\n    modifier registryOpen() {\\n        require(now \\u003e= registryStarted \\u0026\\u0026 now \\u003c= registryStarted + (365 * 4) * 1 days \\u0026\\u0026 ens.owner(rootNode) == address(this));\\n        _;\\n    }\\n\\n    /**\\n     * @dev Constructs a new Registrar, with the provided address as the owner of the root node.\\n     *\\n     * @param _ens The address of the ENS\\n     * @param _rootNode The hash of the rootnode.\\n     */\\n    constructor(ENS _ens, bytes32 _rootNode, uint _startDate) public {\\n        ens = _ens;\\n        rootNode = _rootNode;\\n        registryStarted = _startDate \\u003e 0 ? _startDate : now;\\n    }\\n\\n    /**\\n     * @dev Start an auction for an available hash\\n     *\\n     * @param _hash The hash to start an auction on\\n     */\\n    function startAuction(bytes32 _hash) external {\\n        _startAuction(_hash);\\n    }\\n\\n    /**\\n     * @dev Start multiple auctions for better anonymity\\n     *\\n     * Anyone can start an auction by sending an array of hashes that they want to bid for.\\n     * Arrays are sent so that someone can open up an auction for X dummy hashes when they\\n     * are only really interested in bidding for one. This will increase the cost for an\\n     * attacker to simply bid blindly on all new auctions. Dummy auctions that are\\n     * open but not bid on are closed after a week.\\n     *\\n     * @param _hashes An array of hashes, at least one of which you presumably want to bid on\\n     */\\n    function startAuctions(bytes32[] calldata _hashes) external {\\n        _startAuctions(_hashes);\\n    }\\n\\n    /**\\n     * @dev Submit a new sealed bid on a desired hash in a blind auction\\n     *\\n     * Bids are sent by sending a message to the main contract with a hash and an amount. The hash\\n     * contains information about the bid, including the bidded hash, the bid amount, and a random\\n     * salt. Bids are not tied to any one auction until they are revealed. The value of the bid\\n     * itself can be masqueraded by sending more than the value of your actual bid. This is\\n     * followed by a 48h reveal period. Bids revealed after this period will be burned and the ether unrecoverable.\\n     * Since this is an auction, it is expected that most public hashes, like known domains and common dictionary\\n     * words, will have multiple bidders pushing the price up.\\n     *\\n     * @param sealedBid A sealedBid, created by the shaBid function\\n     */\\n    function newBid(bytes32 sealedBid) external payable {\\n        _newBid(sealedBid);\\n    }\\n\\n    /**\\n     * @dev Start a set of auctions and bid on one of them\\n     *\\n     * This method functions identically to calling `startAuctions` followed by `newBid`,\\n     * but all in one transaction.\\n     *\\n     * @param hashes A list of hashes to start auctions on.\\n     * @param sealedBid A sealed bid for one of the auctions.\\n     */\\n    function startAuctionsAndBid(bytes32[] calldata hashes, bytes32 sealedBid) external payable {\\n        _startAuctions(hashes);\\n        _newBid(sealedBid);\\n    }\\n\\n    /**\\n     * @dev Submit the properties of a bid to reveal them\\n     *\\n     * @param _hash The node in the sealedBid\\n     * @param _value The bid amount in the sealedBid\\n     * @param _salt The sale in the sealedBid\\n     */\\n    function unsealBid(bytes32 _hash, uint _value, bytes32 _salt) external {\\n        bytes32 seal = shaBid(_hash, msg.sender, _value, _salt);\\n        Deed bid = sealedBids[msg.sender][seal];\\n        require(address(bid) != address(0x0));\\n\\n        sealedBids[msg.sender][seal] = Deed(address(0x0));\\n        Entry storage h = _entries[_hash];\\n        uint value = min(_value, bid.value());\\n        bid.setBalance(value, true);\\n\\n        Mode auctionState = state(_hash);\\n        if (auctionState == Mode.Owned) {\\n            // Too late! Bidder loses their bid. Gets 0.5% back.\\n            bid.closeDeed(5);\\n            emit BidRevealed(_hash, msg.sender, value, 1);\\n        } else if (auctionState != Mode.Reveal) {\\n            // Invalid phase\\n            revert();\\n        } else if (value \\u003c minPrice || bid.creationDate() \\u003e h.registrationDate - revealPeriod) {\\n            // Bid too low or too late, refund 99.5%\\n            bid.closeDeed(995);\\n            emit BidRevealed(_hash, msg.sender, value, 0);\\n        } else if (value \\u003e h.highestBid) {\\n            // New winner\\n            // Cancel the other bid, refund 99.5%\\n            if (address(h.deed) != address(0x0)) {\\n                Deed previousWinner = h.deed;\\n                previousWinner.closeDeed(995);\\n            }\\n\\n            // Set new winner\\n            // Per the rules of a vickery auction, the value becomes the previous highestBid\\n            h.value = h.highestBid;  // will be zero if there\\u0027s only 1 bidder\\n            h.highestBid = value;\\n            h.deed = bid;\\n            emit BidRevealed(_hash, msg.sender, value, 2);\\n        } else if (value \\u003e h.value) {\\n            // Not winner, but affects second place\\n            h.value = value;\\n            bid.closeDeed(995);\\n            emit BidRevealed(_hash, msg.sender, value, 3);\\n        } else {\\n            // Bid doesn\\u0027t affect auction\\n            bid.closeDeed(995);\\n            emit BidRevealed(_hash, msg.sender, value, 4);\\n        }\\n    }\\n\\n    /**\\n     * @dev Cancel a bid\\n     *\\n     * @param seal The value returned by the shaBid function\\n     */\\n    function cancelBid(address bidder, bytes32 seal) external {\\n        Deed bid = sealedBids[bidder][seal];\\n        \\n        // If a sole bidder does not `unsealBid` in time, they have a few more days\\n        // where they can call `startAuction` (again) and then `unsealBid` during\\n        // the revealPeriod to get back their bid value.\\n        // For simplicity, they should call `startAuction` within\\n        // 9 days (2 weeks - totalAuctionLength), otherwise their bid will be\\n        // cancellable by anyone.\\n        require(address(bid) != address(0x0) \\u0026\\u0026 now \\u003e= bid.creationDate() + totalAuctionLength + 2 weeks);\\n\\n        // Send the canceller 0.5% of the bid, and burn the rest.\\n        bid.setOwner(msg.sender);\\n        bid.closeDeed(5);\\n        sealedBids[bidder][seal] = Deed(0);\\n        emit BidRevealed(seal, bidder, 0, 5);\\n    }\\n\\n    /**\\n     * @dev Finalize an auction after the registration date has passed\\n     *\\n     * @param _hash The hash of the name the auction is for\\n     */\\n    function finalizeAuction(bytes32 _hash) external onlyOwner(_hash) {\\n        Entry storage h = _entries[_hash];\\n        \\n        // Handles the case when there\\u0027s only a single bidder (h.value is zero)\\n        h.value = max(h.value, minPrice);\\n        h.deed.setBalance(h.value, true);\\n\\n        trySetSubnodeOwner(_hash, h.deed.owner());\\n        emit HashRegistered(_hash, h.deed.owner(), h.value, h.registrationDate);\\n    }\\n\\n    /**\\n     * @dev The owner of a domain may transfer it to someone else at any time.\\n     *\\n     * @param _hash The node to transfer\\n     * @param newOwner The address to transfer ownership to\\n     */\\n    function transfer(bytes32 _hash, address payable newOwner) external onlyOwner(_hash) {\\n        require(newOwner != address(0x0));\\n\\n        Entry storage h = _entries[_hash];\\n        h.deed.setOwner(newOwner);\\n        trySetSubnodeOwner(_hash, newOwner);\\n    }\\n\\n    /**\\n     * @dev After some time, or if we\\u0027re no longer the registrar, the owner can release\\n     *      the name and get their ether back.\\n     *\\n     * @param _hash The node to release\\n     */\\n    function releaseDeed(bytes32 _hash) external onlyOwner(_hash) {\\n        Entry storage h = _entries[_hash];\\n        Deed deedContract = h.deed;\\n\\n        require(now \\u003e= h.registrationDate + 365 days || ens.owner(rootNode) != address(this));\\n\\n        h.value = 0;\\n        h.highestBid = 0;\\n        h.deed = Deed(0);\\n\\n        _tryEraseSingleNode(_hash);\\n        deedContract.closeDeed(1000);\\n        emit HashReleased(_hash, h.value);        \\n    }\\n\\n    /**\\n     * @dev Submit a name 6 characters long or less. If it has been registered,\\n     *      the submitter will earn 50% of the deed value. \\n     * \\n     * We are purposefully handicapping the simplified registrar as a way \\n     * to force it into being restructured in a few years.\\n     *\\n     * @param unhashedName An invalid name to search for in the registry.\\n     */\\n    function invalidateName(string calldata unhashedName)\\n        external\\n        inState(keccak256(abi.encode(unhashedName)), Mode.Owned)\\n    {\\n        require(strlen(unhashedName) \\u003c= 6);\\n        bytes32 hash = keccak256(abi.encode(unhashedName));\\n\\n        Entry storage h = _entries[hash];\\n\\n        _tryEraseSingleNode(hash);\\n\\n        if (address(h.deed) != address(0x0)) {\\n            // Reward the discoverer with 50% of the deed\\n            // The previous owner gets 50%\\n            h.value = max(h.value, minPrice);\\n            h.deed.setBalance(h.value/2, false);\\n            h.deed.setOwner(msg.sender);\\n            h.deed.closeDeed(1000);\\n        }\\n\\n        emit HashInvalidated(hash, unhashedName, h.value, h.registrationDate);\\n\\n        h.value = 0;\\n        h.highestBid = 0;\\n        h.deed = Deed(0);\\n    }\\n\\n    /**\\n     * @dev Allows anyone to delete the owner and resolver records for a (subdomain of) a\\n     *      name that is not currently owned in the registrar. If passing, eg, \\u0027foo.bar.eth\\u0027,\\n     *      the owner and resolver fields on \\u0027foo.bar.eth\\u0027 and \\u0027bar.eth\\u0027 will all be cleared.\\n     *\\n     * @param labels A series of label hashes identifying the name to zero out, rooted at the\\n     *        registrar\\u0027s root. Must contain at least one element. For instance, to zero \\n     *        \\u0027foo.bar.eth\\u0027 on a registrar that owns \\u0027.eth\\u0027, pass an array containing\\n     *        [keccak256(\\u0027foo\\u0027), keccak256(\\u0027bar\\u0027)].\\n     */\\n    function eraseNode(bytes32[] calldata labels) external {\\n        require(labels.length != 0);\\n        require(state(labels[labels.length - 1]) != Mode.Owned);\\n\\n        _eraseNodeHierarchy(labels.length - 1, labels, rootNode);\\n    }\\n\\n    /**\\n     * @dev Transfers the deed to the current registrar, if different from this one.\\n     *\\n     * Used during the upgrade process to a permanent registrar.\\n     *\\n     * @param _hash The name hash to transfer.\\n     */\\n    function transferRegistrars(bytes32 _hash) external onlyOwner(_hash) {\\n        address registrar = ens.owner(rootNode);\\n        require(registrar != address(this));\\n\\n        // Migrate the deed\\n        Entry storage h = _entries[_hash];\\n        h.deed.setRegistrar(registrar);\\n\\n        // Call the new registrar to accept the transfer\\n        Registrar(registrar).acceptRegistrarTransfer(_hash, h.deed, h.registrationDate);\\n\\n        // Zero out the Entry\\n        h.deed = Deed(0);\\n        h.registrationDate = 0;\\n        h.value = 0;\\n        h.highestBid = 0;\\n    }\\n\\n    /**\\n     * @dev Accepts a transfer from a previous registrar; stubbed out here since there\\n     *      is no previous registrar implementing this interface.\\n     *\\n     * @param hash The sha3 hash of the label to transfer.\\n     * @param deed The Deed object for the name being transferred in.\\n     * @param registrationDate The date at which the name was originally registered.\\n     */\\n    function acceptRegistrarTransfer(bytes32 hash, Deed deed, uint registrationDate) external {\\n        hash; deed; registrationDate; // Don\\u0027t warn about unused variables\\n    }\\n\\n    function entries(bytes32 _hash) external view returns (Mode, address, uint, uint, uint) {\\n        Entry storage h = _entries[_hash];\\n        return (state(_hash), address(h.deed), h.registrationDate, h.value, h.highestBid);\\n    }\\n\\n    // State transitions for names:\\n    //   Open -\\u003e Auction (startAuction)\\n    //   Auction -\\u003e Reveal\\n    //   Reveal -\\u003e Owned\\n    //   Reveal -\\u003e Open (if nobody bid)\\n    //   Owned -\\u003e Open (releaseDeed or invalidateName)\\n    function state(bytes32 _hash) public view returns (Mode) {\\n        Entry storage entry = _entries[_hash];\\n\\n        if (!isAllowed(_hash, now)) {\\n            return Mode.NotYetAvailable;\\n        } else if (now \\u003c entry.registrationDate) {\\n            if (now \\u003c entry.registrationDate - revealPeriod) {\\n                return Mode.Auction;\\n            } else {\\n                return Mode.Reveal;\\n            }\\n        } else {\\n            if (entry.highestBid == 0) {\\n                return Mode.Open;\\n            } else {\\n                return Mode.Owned;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Determines if a name is available for registration yet\\n     *\\n     * Each name will be assigned a random date in which its auction\\n     * can be started, from 0 to 8 weeks\\n     *\\n     * @param _hash The hash to start an auction on\\n     * @param _timestamp The timestamp to query about\\n     */\\n    function isAllowed(bytes32 _hash, uint _timestamp) public view returns (bool allowed) {\\n        return _timestamp \\u003e getAllowedTime(_hash);\\n    }\\n\\n    /**\\n     * @dev Returns available date for hash\\n     *\\n     * The available time from the `registryStarted` for a hash is proportional\\n     * to its numeric value.\\n     *\\n     * @param _hash The hash to start an auction on\\n     */\\n    function getAllowedTime(bytes32 _hash) public view returns (uint) {\\n        return registryStarted + ((launchLength * (uint(_hash) \\u003e\\u003e 128)) \\u003e\\u003e 128);\\n        // Right shift operator: a \\u003e\\u003e b == a / 2**b\\n    }\\n\\n    /**\\n     * @dev Hash the values required for a secret bid\\n     *\\n     * @param hash The node corresponding to the desired namehash\\n     * @param value The bid amount\\n     * @param salt A random value to ensure secrecy of the bid\\n     * @return The hash of the bid values\\n     */\\n    function shaBid(bytes32 hash, address owner, uint value, bytes32 salt) public pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(hash, owner, value, salt));\\n    }\\n\\n    function _tryEraseSingleNode(bytes32 label) internal {\\n        if (ens.owner(rootNode) == address(this)) {\\n            ens.setSubnodeOwner(rootNode, label, address(this));\\n            bytes32 node = keccak256(abi.encodePacked(rootNode, label));\\n            ens.setResolver(node, address(0x0));\\n            ens.setOwner(node, address(0x0));\\n        }\\n    }\\n\\n    function _startAuction(bytes32 _hash) internal registryOpen() {\\n        Mode mode = state(_hash);\\n        if (mode == Mode.Auction) return;\\n        require(mode == Mode.Open);\\n\\n        Entry storage newAuction = _entries[_hash];\\n        newAuction.registrationDate = now + totalAuctionLength;\\n        newAuction.value = 0;\\n        newAuction.highestBid = 0;\\n        emit AuctionStarted(_hash, newAuction.registrationDate);\\n    }\\n\\n    function _startAuctions(bytes32[] memory _hashes) internal {\\n        for (uint i = 0; i \\u003c _hashes.length; i ++) {\\n            _startAuction(_hashes[i]);\\n        }\\n    }\\n\\n    function _newBid(bytes32 sealedBid) internal {\\n        require(address(sealedBids[msg.sender][sealedBid]) == address(0x0));\\n        require(msg.value \\u003e= minPrice);\\n\\n        // Creates a new hash contract with the owner\\n        Deed bid = (new DeedImplementation).value(msg.value)(msg.sender);\\n        sealedBids[msg.sender][sealedBid] = bid;\\n        emit NewBid(sealedBid, msg.sender, msg.value);\\n    }\\n\\n    function _eraseNodeHierarchy(uint idx, bytes32[] memory labels, bytes32 node) internal {\\n        // Take ownership of the node\\n        ens.setSubnodeOwner(node, labels[idx], address(this));\\n        node = keccak256(abi.encodePacked(node, labels[idx]));\\n\\n        // Recurse if there are more labels\\n        if (idx \\u003e 0) {\\n            _eraseNodeHierarchy(idx - 1, labels, node);\\n        }\\n\\n        // Erase the resolver and owner records\\n        ens.setResolver(node, address(0x0));\\n        ens.setOwner(node, address(0x0));\\n    }\\n\\n    /**\\n     * @dev Assign the owner in ENS, if we\\u0027re still the registrar\\n     *\\n     * @param _hash hash to change owner\\n     * @param _newOwner new owner to transfer to\\n     */\\n    function trySetSubnodeOwner(bytes32 _hash, address _newOwner) internal {\\n        if (ens.owner(rootNode) == address(this))\\n            ens.setSubnodeOwner(rootNode, _hash, _newOwner);\\n    }\\n\\n    /**\\n     * @dev Returns the maximum of two unsigned integers\\n     *\\n     * @param a A number to compare\\n     * @param b A number to compare\\n     * @return The maximum of two unsigned integers\\n     */\\n    function max(uint a, uint b) internal pure returns (uint) {\\n        if (a \\u003e b)\\n            return a;\\n        else\\n            return b;\\n    }\\n\\n    /**\\n     * @dev Returns the minimum of two unsigned integers\\n     *\\n     * @param a A number to compare\\n     * @param b A number to compare\\n     * @return The minimum of two unsigned integers\\n     */\\n    function min(uint a, uint b) internal pure returns (uint) {\\n        if (a \\u003c b)\\n            return a;\\n        else\\n            return b;\\n    }\\n\\n    /**\\n     * @dev Returns the length of a given string\\n     *\\n     * @param s The string to measure the length of\\n     * @return The length of the input string\\n     */\\n    function strlen(string memory s) internal pure returns (uint) {\\n        s; // Don\\u0027t warn about unused variables\\n        // Starting here means the LSB will be the byte we care about\\n        uint ptr;\\n        uint end;\\n        assembly {\\n            ptr := add(s, 1)\\n            end := add(mload(s), ptr)\\n        }\\n        uint len = 0;\\n        for (len; ptr \\u003c end; len++) {\\n            uint8 b;\\n            assembly { b := and(mload(ptr), 0xFF) }\\n            if (b \\u003c 0x80) {\\n                ptr += 1;\\n            } else if (b \\u003c 0xE0) {\\n                ptr += 2;\\n            } else if (b \\u003c 0xF0) {\\n                ptr += 3;\\n            } else if (b \\u003c 0xF8) {\\n                ptr += 4;\\n            } else if (b \\u003c 0xFC) {\\n                ptr += 5;\\n            } else {\\n                ptr += 6;\\n            }\\n        }\\n        return len;\\n    }\\n\\n}\\n\"},\"MultiSigWallet.sol\":{\"content\":\"/**\\n * Source Code first verified at https://etherscan.io on Friday, March 3, 2017\\n (UTC) */\\n\\npragma solidity ^0.5.0;\\n\\n\\n/// @title Multisignature wallet - Allows multiple parties to agree on transactions before execution.\\n/// @author Stefan George - \\u003cstefan.george@consensys.net\\u003e\\ncontract MultiSigWallet {\\n\\n  uint constant public MAX_OWNER_COUNT = 50;\\n\\n  event Confirmation(address indexed sender, uint indexed transactionId);\\n  event Revocation(address indexed sender, uint indexed transactionId);\\n  event Submission(uint indexed transactionId);\\n  event Execution(uint indexed transactionId, bytes data);\\n  event ExecutionFailure(uint indexed transactionId);\\n  event Deposit(address indexed sender, uint value);\\n  event OwnerAddition(address indexed owner);\\n  event OwnerRemoval(address indexed owner);\\n  event RequirementChange(uint required);\\n\\n  mapping (uint =\\u003e Transaction) public transactions;\\n  mapping (uint =\\u003e mapping (address =\\u003e bool)) public confirmations;\\n  mapping (address =\\u003e bool) public isOwner;\\n  address[] public owners;\\n  uint public required;\\n  uint public transactionCount;\\n\\n  struct Transaction {\\n    address destination;\\n    uint value;\\n    bytes data;\\n    bool executed;\\n  }\\n\\n  modifier onlyWallet() {\\n    if (msg.sender != address(this))\\n      revert();\\n    _;\\n  }\\n\\n  modifier ownerDoesNotExist(address owner) {\\n    if (isOwner[owner])\\n      revert();\\n    _;\\n  }\\n\\n  modifier ownerExists(address owner) {\\n    if (!isOwner[owner])\\n      revert();\\n    _;\\n  }\\n\\n  modifier transactionExists(uint transactionId) {\\n    if (transactions[transactionId].destination == address(0))\\n      revert();\\n    _;\\n  }\\n\\n  modifier confirmed(uint transactionId, address owner) {\\n    if (!confirmations[transactionId][owner])\\n      revert();\\n    _;\\n  }\\n\\n  modifier notConfirmed(uint transactionId, address owner) {\\n    if (confirmations[transactionId][owner])\\n      revert();\\n    _;\\n  }\\n\\n  modifier notExecuted(uint transactionId) {\\n    if (transactions[transactionId].executed)\\n      revert();\\n    _;\\n  }\\n\\n  modifier notNull(address _address) {\\n    if (_address == address(0))\\n      revert();\\n    _;\\n  }\\n\\n  modifier validRequirement(uint ownerCount, uint _required) {\\n    if (   ownerCount \\u003e MAX_OWNER_COUNT\\n    || _required \\u003e ownerCount\\n    || _required == 0\\n    || ownerCount == 0)\\n      revert();\\n    _;\\n  }\\n\\n  /*\\n   * Public functions\\n   */\\n  /// @dev Contract constructor sets initial owners and required number of confirmations.\\n  /// @param _owners List of initial owners.\\n  /// @param _required Number of required confirmations.\\n  constructor(address[] memory _owners, uint _required)\\n  public\\n  validRequirement(_owners.length, _required)\\n  {\\n    for (uint i=0; i\\u003c_owners.length; i++) {\\n      if (isOwner[_owners[i]] || _owners[i] == address(0))\\n        revert();\\n      isOwner[_owners[i]] = true;\\n    }\\n    owners = _owners;\\n    required = _required;\\n  }\\n\\n  /// @dev Allows to add a new owner. Transaction has to be sent by wallet.\\n  /// @param owner Address of new owner.\\n  function addOwner(address owner)\\n  public\\n  onlyWallet\\n  ownerDoesNotExist(owner)\\n  notNull(owner)\\n  validRequirement(owners.length + 1, required)\\n  {\\n    isOwner[owner] = true;\\n    owners.push(owner);\\n    emit OwnerAddition(owner);\\n  }\\n\\n  /// @dev Allows to remove an owner. Transaction has to be sent by wallet.\\n  /// @param owner Address of owner.\\n  function removeOwner(address owner)\\n  public\\n  onlyWallet\\n  ownerExists(owner)\\n  {\\n    isOwner[owner] = false;\\n    for (uint i=0; i\\u003cowners.length - 1; i++)\\n      if (owners[i] == owner) {\\n        owners[i] = owners[owners.length - 1];\\n        break;\\n      }\\n    owners.length -= 1;\\n    if (required \\u003e owners.length)\\n      changeRequirement(owners.length);\\n    emit OwnerRemoval(owner);\\n  }\\n\\n  /// @dev Allows to replace an owner with a new owner. Transaction has to be sent by wallet.\\n  /// @param owner Address of owner to be replaced.\\n  /// @param owner Address of new owner.\\n  function replaceOwner(address owner, address newOwner)\\n  public\\n  onlyWallet\\n  ownerExists(owner)\\n  ownerDoesNotExist(newOwner)\\n  {\\n    for (uint i=0; i\\u003cowners.length; i++)\\n      if (owners[i] == owner) {\\n        owners[i] = newOwner;\\n        break;\\n      }\\n    isOwner[owner] = false;\\n    isOwner[newOwner] = true;\\n    emit OwnerRemoval(owner);\\n    emit OwnerAddition(newOwner);\\n  }\\n\\n  /// @dev Allows to change the number of required confirmations. Transaction has to be sent by wallet.\\n  /// @param _required Number of required confirmations.\\n  function changeRequirement(uint _required)\\n  public\\n  onlyWallet\\n  validRequirement(owners.length, _required)\\n  {\\n    required = _required;\\n    emit RequirementChange(_required);\\n  }\\n\\n  /// @dev Allows an owner to submit and confirm a transaction.\\n  /// @param destination Transaction target address.\\n  /// @param value Transaction ether value.\\n  /// @param data Transaction data payload.\\n  /// @return Returns transaction ID.\\n  function submitTransaction(address destination, uint value, bytes memory data)\\n  public\\n  returns (uint transactionId)\\n  {\\n    transactionId = addTransaction(destination, value, data);\\n    confirmTransaction(transactionId);\\n  }\\n\\n  /// @dev Allows an owner to confirm a transaction.\\n  /// @param transactionId Transaction ID.\\n  function confirmTransaction(uint transactionId)\\n  public\\n  ownerExists(msg.sender)\\n  transactionExists(transactionId)\\n  notConfirmed(transactionId, msg.sender)\\n  {\\n    confirmations[transactionId][msg.sender] = true;\\n    emit Confirmation(msg.sender, transactionId);\\n    executeTransaction(transactionId);\\n  }\\n\\n  /// @dev Allows an owner to revoke a confirmation for a transaction.\\n  /// @param transactionId Transaction ID.\\n  function revokeConfirmation(uint transactionId)\\n  public\\n  ownerExists(msg.sender)\\n  confirmed(transactionId, msg.sender)\\n  notExecuted(transactionId)\\n  {\\n    confirmations[transactionId][msg.sender] = false;\\n    emit Revocation(msg.sender, transactionId);\\n  }\\n\\n  /// @dev Allows anyone to execute a confirmed transaction.\\n  /// @param transactionId Transaction ID.\\n  function executeTransaction(uint transactionId)\\n  public\\n  notExecuted(transactionId)\\n  {\\n    if (isConfirmed(transactionId)) {\\n      Transaction storage tx = transactions[transactionId];\\n      tx.executed = true;\\n      bool success;\\n      (success,) = tx.destination.call.value(tx.value)(tx.data);\\n      if (success)\\n        emit Execution(transactionId, tx.data);\\n      else {\\n        emit ExecutionFailure(transactionId);\\n        tx.executed = false;\\n      }\\n    }\\n  }\\n\\n  /// @dev Returns the confirmation status of a transaction.\\n  /// @param transactionId Transaction ID.\\n  /// @return Confirmation status.\\n  function isConfirmed(uint transactionId)\\n  public\\n  view\\n  returns (bool)\\n  {\\n    uint count = 0;\\n    for (uint i=0; i\\u003cowners.length; i++) {\\n      if (confirmations[transactionId][owners[i]])\\n        count += 1;\\n      if (count == required)\\n        return true;\\n    }\\n  }\\n\\n  /*\\n   * Internal functions\\n   */\\n  /// @dev Adds a new transaction to the transaction mapping, if transaction does not exist yet.\\n  /// @param destination Transaction target address.\\n  /// @param value Transaction ether value.\\n  /// @param data Transaction data payload.\\n  /// @return Returns transaction ID.\\n  function addTransaction(address destination, uint value, bytes memory data)\\n  internal\\n  notNull(destination)\\n  returns (uint transactionId)\\n  {\\n    transactionId = transactionCount;\\n    transactions[transactionId] = Transaction({\\n      destination: destination,\\n      value: value,\\n      data: data,\\n      executed: false\\n      });\\n    transactionCount += 1;\\n    emit Submission(transactionId);\\n  }\\n\\n  /*\\n   * Web3 call functions\\n   */\\n  /// @dev Returns number of confirmations of a transaction.\\n  /// @param transactionId Transaction ID.\\n  /// @return Number of confirmations.\\n  function getConfirmationCount(uint transactionId)\\n  public\\n  view\\n  returns (uint count)\\n  {\\n    for (uint i=0; i\\u003cowners.length; i++)\\n      if (confirmations[transactionId][owners[i]])\\n        count += 1;\\n  }\\n\\n  /// @dev Returns total number of transactions after filers are applied.\\n  /// @param pending Include pending transactions.\\n  /// @param executed Include executed transactions.\\n  /// @return Total number of transactions after filters are applied.\\n  function getTransactionCount(bool pending, bool executed)\\n  public\\n  view\\n  returns (uint count)\\n  {\\n    for (uint i=0; i\\u003ctransactionCount; i++)\\n      if (   pending \\u0026\\u0026 !transactions[i].executed\\n      || executed \\u0026\\u0026 transactions[i].executed)\\n        count += 1;\\n  }\\n\\n  /// @dev Returns list of owners.\\n  /// @return List of owner addresses.\\n  function getOwners()\\n  public\\n  view\\n  returns (address[] memory)\\n  {\\n    return owners;\\n  }\\n\\n  /// @dev Returns array with owner addresses, which confirmed transaction.\\n  /// @param transactionId Transaction ID.\\n  /// @return Returns array of owner addresses.\\n  function getConfirmations(uint transactionId)\\n  public\\n  view\\n  returns (address[] memory _confirmations)\\n  {\\n    address[] memory confirmationsTemp = new address[](owners.length);\\n    uint count = 0;\\n    uint i;\\n    for (i=0; i\\u003cowners.length; i++)\\n      if (confirmations[transactionId][owners[i]]) {\\n        confirmationsTemp[count] = owners[i];\\n        count += 1;\\n      }\\n    _confirmations = new address[](count);\\n    for (i=0; i\\u003ccount; i++)\\n      _confirmations[i] = confirmationsTemp[i];\\n  }\\n\\n  /// @dev Returns list of transaction IDs in defined range.\\n  /// @param from Index start position of transaction array.\\n  /// @param to Index end position of transaction array.\\n  /// @param pending Include pending transactions.\\n  /// @param executed Include executed transactions.\\n  /// @return Returns array of transaction IDs.\\n  function getTransactionIds(uint from, uint to, bool pending, bool executed)\\n  public\\n  view\\n  returns (uint[] memory _transactionIds)\\n  {\\n    uint[] memory transactionIdsTemp = new uint[](transactionCount);\\n    uint count = 0;\\n    uint i;\\n    for (i=0; i\\u003ctransactionCount; i++)\\n      if (   pending \\u0026\\u0026 !transactions[i].executed\\n      || executed \\u0026\\u0026 transactions[i].executed)\\n      {\\n        transactionIdsTemp[count] = i;\\n        count += 1;\\n      }\\n    _transactionIds = new uint[](to - from);\\n    for (i=from; i\\u003cto; i++)\\n      _transactionIds[i - from] = transactionIdsTemp[i];\\n  }\\n}\"},\"NameBazaarRescue.sol\":{\"content\":\"pragma solidity ^0.5.0;\\n\\nimport \\\"./Root.sol\\\";\\n\\nimport \\\"./Offering.sol\\\";\\nimport \\\"./OfferingRegistry.sol\\\";\\nimport \\\"./MultiSigWallet.sol\\\";\\n\\ncontract NameBazaarRescue is Ownable {\\n  bytes32 constant public ETH_NODE = 0x93cdeb708b7545dc668eb9280176169d1c33cfd8ed6f04690a0bcc88a93fc4ae;\\n  bytes32 constant public ETH_LABEL = 0x4f5b812789fc606be1b3b16908db13fc7a9adf7ca72641f84d75b47069d3d7f0;\\n\\n  Root public root;\\n  OfferingRegistry public offeringRegistry;\\n  address public previousRegistrar;\\n\\n  event ReclaimSuccess(address offering, uint transactionId);\\n\\n  constructor(address _root, address _offeringRegistry, address _previousRegistrar) public {\\n    require(_root != address(0));\\n    require(_offeringRegistry != address(0));\\n    require(_previousRegistrar != address(0));\\n\\n    root = Root(_root);\\n    offeringRegistry = OfferingRegistry(_offeringRegistry);\\n    previousRegistrar = _previousRegistrar;\\n  }\\n\\n  function reclaimOwnerships(address[] memory offerings) public onlyOwner {\\n    address originalNodeOwner = root.ens().owner(ETH_NODE);\\n    MultiSigWallet emergencyMultisig = MultiSigWallet(offeringRegistry.emergencyMultisig());\\n\\n    root.setSubnodeOwner(ETH_LABEL, previousRegistrar);\\n\\n    for (uint i = 0; i \\u003c offerings.length; i++) {\\n      require(offeringRegistry.isOffering(offerings[i]));\\n      bool executed = false;\\n      uint txId = emergencyMultisig.submitTransaction(offerings[i], 0, abi.encodeWithSignature(\\\"reclaimOwnership()\\\"));\\n      (,,,executed) = emergencyMultisig.transactions(txId);\\n\\n      if (executed) {\\n        emit ReclaimSuccess(offerings[i], txId);\\n      } else {\\n        revert(\\\"reclaimOwnership transaction couldn\\u0027t be executed\\\");\\n      }\\n    }\\n\\n    root.setSubnodeOwner(ETH_LABEL, originalNodeOwner);\\n  }\\n\\n}\\n\"},\"Offering.sol\":{\"content\":\"pragma solidity ^0.5.0;\\n\\n/**\\n * @title Offering\\n * @dev Contains base logic for an offering and is meant to be extended.\\n */\\n\\nimport \\\"./ENS.sol\\\";\\nimport \\\"./HashRegistrar.sol\\\";\\nimport \\\"./OfferingRegistry.sol\\\";\\nimport \\\"./Address.sol\\\";\\n\\ncontract Offering {\\n\\n    struct Offering {\\n        // Order here is important for gas optimisations. Must be fitting into uint265 slots.\\n        bytes32 node;                       // ENS node\\n        // WARNING: The contract DOES NOT perform ENS name normalisation, which is up to responsibility of each offchain UI!\\n        string name;                        // full ENS name\\n        bytes32 labelHash;                  // hash of ENS label\\n        address originalOwner;              // owner of ENS name, creator of offering\\n        address newOwner;                   // Address of a new owner of ENS name, buyer\\n        uint price;                         // Price of the offering, or the highest bid in auction\\n        uint128 version;                    // version of offering contract\\n        uint64 createdOn;                   // Time when offering was created\\n        uint64 finalizedOn;                 // Time when ENS name was transferred to a new owner\\n    }\\n\\n    Offering public offering;\\n\\n    // Hardcoded ENS address. For development will be replaced after compilation. This way we save gas to users deploying offering contracts.\\n    ENS public ens = ENS(0x314159265dD8dbb310642f98f50C066173C1259b);\\n\\n    // Hardcoded namehash of \\\"eth\\\"\\n    bytes32 public constant rootNode = 0x93cdeb708b7545dc668eb9280176169d1c33cfd8ed6f04690a0bcc88a93fc4ae;\\n\\n    // Placeholder to be replaced after compilation. This way we save gas to users deploying offering contracts.\\n    OfferingRegistry public offeringRegistry = OfferingRegistry(0xfEEDFEEDfeEDFEedFEEdFEEDFeEdfEEdFeEdFEEd);\\n\\n    // Placeholder to be replaced after compilation. This way we save gas to users deploying offering contracts.\\n    address public emergencyMultisig = 0xDeEDdeeDDEeDDEEdDEedDEEdDEeDdEeDDEEDDeed;\\n\\n    constructor(ENS _ens, OfferingRegistry _offeringRegistry, address _emergencyMultisig) public {\\n        ens = _ens;\\n        offeringRegistry = _offeringRegistry;\\n        emergencyMultisig = _emergencyMultisig;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only for offering creator\\n     */\\n    modifier onlyOriginalOwner() {\\n        require(isSenderOriginalOwner());\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only for Namebazaar\\u0027s Emergency Multisig wallet\\n     */\\n    modifier onlyEmergencyMultisig() {\\n        require(isSenderEmergencyMultisig());\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only is called by Namebazaar\\u0027s Emergency Multisig wallet\\n     */\\n    modifier onlyWithoutNewOwner() {\\n        require(offering.newOwner == address(0));\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when offering contract has name ownership\\n     */\\n    modifier onlyWhenContractIsNodeOwner() {\\n        require(isContractNodeOwner());\\n        _;\\n    }\\n\\n\\n    /**\\n     * @dev Modifier to make a function callable only when there\\u0027s not emergency pause\\n     */\\n    modifier onlyWhenNotEmergencyPaused() {\\n        require(!offeringRegistry.isEmergencyPaused());\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when offering contract doesn\\u0027t have name ownership\\n     */\\n    modifier onlyWhenContractIsNotNodeOwner() {\\n        require(!isContractNodeOwner());\\n        _;\\n    }\\n\\n    /**\\n     * @dev Constructor of offering\\n     * Should be callable just once, by factory\\n     */\\n    function construct(\\n        bytes32 _node,\\n        string memory _name,\\n        bytes32 _labelHash,\\n        address _originalOwner,\\n        uint128 _version,\\n        uint _price\\n    )\\n    public\\n    onlyWhenNotEmergencyPaused\\n    {\\n        require(offering.createdOn == 0);               // Prevent constructing multiple times\\n        offering.node = _node;\\n        offering.name = _name;\\n        offering.labelHash = _labelHash;\\n        offering.originalOwner = _originalOwner;\\n        offering.version = _version;\\n        offering.createdOn = uint64(now);\\n        offering.price = _price;\\n    }\\n\\n    /**\\n     * @dev Unregisters offering for not displaying it in UI\\n     * Cannot be run if contract has ownership or it was already transferred to new owner\\n     */\\n    function unregister()\\n    public\\n    onlyOriginalOwner\\n    onlyWithoutNewOwner\\n    onlyWhenContractIsNotNodeOwner\\n    {\\n        // New owner is not really this address, but it\\u0027s the way to recogize if offering\\n        // was unregistered without having separate var for it, which is costly\\n        offering.newOwner = address(0xdeaddead);\\n        fireOnChanged(\\\"unregister\\\");\\n    }\\n\\n    /**\\n    * @dev Transfers ENS name ownership back to original owner\\n    * Can be run only by original owner or emergency multisig\\n    * Sets newOwner to special address 0xdead\\n    */\\n    function reclaimOwnership()\\n    public\\n    onlyWithoutNewOwner\\n    {\\n        bool isEmergency = isSenderEmergencyMultisig();\\n        require(isEmergency || isSenderOriginalOwner());\\n\\n        if (isContractNodeOwner()) {\\n            doTransferOwnership(offering.originalOwner);\\n        }\\n        if (isEmergency) {\\n            // New owner is not really this address, but it\\u0027s the way to recogize if\\n            // was disabled in emergency without having separate var for it, which is costly\\n            offering.newOwner = address(0xdead);\\n        }\\n        fireOnChanged(\\\"reclaimOwnership\\\");\\n    }\\n\\n    /**\\n    * @dev Transfers name ownership in context of offering contract\\n    * Cannot be run if ownership was already transferred to new owner\\n    * @param _newOwner address New owner of ENS name\\n    */\\n    function transferOwnership(address _newOwner)\\n    internal\\n    onlyWhenNotEmergencyPaused\\n    onlyWithoutNewOwner\\n    {\\n        offering.newOwner = _newOwner;\\n        offering.finalizedOn = uint64(now);\\n        doTransferOwnership(_newOwner);\\n        fireOnChanged(\\\"finalize\\\");\\n    }\\n\\n    /**\\n    * @dev Function to actually do ENS transfer\\n    * Top level names should be transferred via registrar, so deed is transferred too\\n    * @param _newOwner address New owner of ENS name\\n    */\\n    function doTransferOwnership(address _newOwner)\\n    private\\n    {\\n        address payable newOwner = address(uint160(_newOwner));\\n        if (isNodeTLDOfRegistrar()) {\\n            HashRegistrar(ens.owner(rootNode)).transfer(offering.labelHash, newOwner);\\n        } else {\\n            ens.setOwner(offering.node, newOwner);\\n        }\\n    }\\n\\n    function doSetSettings(uint _price)\\n    internal\\n    {\\n        offering.price = _price;\\n    }\\n\\n    function fireOnChanged(bytes32 eventType, uint[] memory extraData)\\n    internal\\n    {\\n        offeringRegistry.fireOnOfferingChanged(offering.version, eventType, extraData);\\n    }\\n\\n    function fireOnChanged(bytes32 eventType) internal {\\n        fireOnChanged(eventType, new uint[](0));\\n    }\\n\\n    /**\\n    * @dev Returns whether offering contract is owner of ENS name\\n    * For top level names, offering contract must be also owner of registrar deed\\n    * @return bool true if contract is ENS node owner\\n    */\\n    function isContractNodeOwner() public view returns(bool) {\\n        if (isNodeTLDOfRegistrar()) {\\n            address deed;\\n            (,deed,,,) = HashRegistrar(ens.owner(rootNode)).entries(offering.labelHash);\\n            return ens.owner(offering.node) == address(this) \\u0026\\u0026\\n            Deed(deed).owner() == address(this);\\n        } else {\\n            return ens.owner(offering.node) == address(this);\\n        }\\n    }\\n\\n    /**\\n    * @dev Exchanges funds of new owner for ownership of ENS name owner\\n    * msg.value must exactly equal to offering price\\n    */\\n    function buy()\\n    public\\n    payable\\n    {\\n        require(msg.value == offering.price);\\n        address payable origOwner = address(uint160(offering.originalOwner));\\n        origOwner.transfer(offering.price);\\n        transferOwnership(msg.sender);\\n    }\\n\\n    /**\\n    * @dev Returns whether offering node is top level name of registrar or subname\\n    * @return bool true if offering node is top level name of registrar\\n    */\\n    function isNodeTLDOfRegistrar() public view returns (bool) {\\n        return offering.node == keccak256(abi.encodePacked(rootNode, offering.labelHash));\\n    }\\n\\n    /**\\n    * @dev Returns whether msg.sender is original owner of ENS name, offering creator\\n    * @return bool true if msg.sender is original owner\\n    */\\n    function isSenderOriginalOwner() public view returns(bool) {\\n        return msg.sender == offering.originalOwner;\\n    }\\n\\n    /**\\n    * @dev Returns whether msg.sender is emergency multisig address\\n    * @return bool true if msg.sender is emergency multisig\\n    */\\n    function isSenderEmergencyMultisig() public view returns(bool) {\\n        return msg.sender == emergencyMultisig;\\n    }\\n\\n    /**\\n    * @dev Returns whether offerring was cancelled in emergency, by emergency multisig\\n    * @return bool true if offering was cancelled in emergency\\n    */\\n    function wasEmergencyCancelled() public view returns(bool) {\\n        return offering.newOwner == address(0xdead);\\n    }\\n}\\n\"},\"OfferingFactory.sol\":{\"content\":\"pragma solidity ^0.5.0;\\n\\nimport \\\"./OfferingRegistry.sol\\\";\\nimport \\\"./Offering.sol\\\";\\nimport \\\"./ENS.sol\\\";\\nimport \\\"./HashRegistrar.sol\\\";\\n\\n/**\\n * @title OfferingFactory\\n * @dev Base contract factory for creating new offerings\\n */\\n\\ncontract OfferingFactory {\\n\\n    ENS public ens;\\n    OfferingRegistry public offeringRegistry;\\n\\n    // Hardcoded namehash of \\\"eth\\\"\\n    bytes32 public constant rootNode = 0x93cdeb708b7545dc668eb9280176169d1c33cfd8ed6f04690a0bcc88a93fc4ae;\\n\\n    constructor (\\n        ENS _ens,\\n        OfferingRegistry _offeringRegistry\\n    ) public {\\n        ens = _ens;\\n        offeringRegistry = _offeringRegistry;\\n    }\\n\\n    /**\\n    * @dev Deploys new BuyNow offering and registers it to OfferingRegistry\\n    * @param name string Plaintext ENS name\\n    * @param price uint The price of the offering\\n    */\\n    function createOffering(\\n        bytes32 node,\\n        string memory name,\\n        bytes32 labelHash,\\n        uint price\\n    ) public {\\n        Offering newOffering = new Offering(ens, offeringRegistry, offeringRegistry.emergencyMultisig());\\n        uint8 version = 1;\\n\\n        newOffering.construct(\\n            node,\\n            name,\\n            labelHash,\\n            msg.sender,\\n            version,\\n            price\\n        );\\n\\n        registerOffering(node, labelHash, address(newOffering), version);\\n    }\\n\\n    /**\\n    * @dev Registers new offering to OfferingRegistry, clears offering requests for this ENS node\\n    * Must check if creator of offering is actual owner of ENS name and for top level names also deed owner\\n    * @param node bytes32 ENS node\\n    * @param labelHash bytes32 ENS labelhash\\n    * @param newOffering address The address of new offering\\n    * @param version uint The version of offering contract\\n    */\\n    function registerOffering(bytes32 node, bytes32 labelHash, address newOffering, uint version)\\n        internal\\n    {\\n        require(ens.owner(node) == msg.sender);\\n        if (node == keccak256(abi.encodePacked(rootNode, labelHash))) {\\n            address deed;\\n            (,deed,,,) = HashRegistrar(ens.owner(rootNode)).entries(labelHash);\\n            require(Deed(deed).owner() == msg.sender);\\n        }\\n\\n        offeringRegistry.addOffering(newOffering, node, msg.sender, version);\\n    }\\n}\"},\"OfferingRegistry.sol\":{\"content\":\"pragma solidity ^0.5.0;\\n\\n\\nimport \\\"./UsedByFactories.sol\\\";\\n\\n\\n/**\\n * @title OfferingRegistry\\n * @dev Offering registry is responsible to firing event each time offering is created or changed\\n * This is mostly for offchain search DB to keep easily in sync\\n */\\n\\ncontract OfferingRegistry is UsedByFactories {\\n\\n  event onOfferingAdded(address indexed offering, bytes32 indexed node, address indexed owner, uint version);\\n  event onOfferingChanged(address indexed offering, uint version, bytes32 indexed eventType, uint[] extraData);\\n\\n  address public emergencyMultisig;                           // Emergency Multisig wallet of Namebazaar\\n  bool public isEmergencyPaused = false;                      // Variable to pause buying activity on all offerings\\n  mapping (address =\\u003e bool) public isOffering;                // Stores whether given address of namebazaar offering\\n\\n\\n  /**\\n   * @dev Modifier to make a function callable only by Namebazaar Multisig wallet\\n   */\\n  modifier onlyEmergencyMultisig() {\\n    require(msg.sender == emergencyMultisig);\\n    _;\\n  }\\n\\n  constructor(address _emergencyMultisig) public {\\n    emergencyMultisig = _emergencyMultisig;\\n  }\\n\\n  /**\\n   * @dev Serves as central point for firing event when new offering is created\\n   * Only offering factory can run this function\\n   * @param offering address Address of newly created offering\\n   * @param node bytes32 ENS node associated with new offering\\n   * @param owner address Owner of the ENS name and creator of the offering\\n   * @param version uint Version of offering contract\\n   */\\n  function addOffering(address offering, bytes32 node, address owner, uint version)\\n  public\\n  onlyFactory\\n  {\\n    isOffering[offering] = true;\\n    emit onOfferingAdded(offering, node, owner, version);\\n  }\\n\\n\\n  /**\\n   * @dev Serves as central point for firing event when offering state has been changed in any way\\n   * Only offering contract can run this function\\n   * @param version uint Version of offering contract\\n   * @param eventType base32 Short string identifying offering change\\n   * @param extraData uint[] Arbitrary data associated with event\\n   */\\n  function fireOnOfferingChanged(uint version, bytes32 eventType, uint[] memory extraData) public {\\n    require(isOffering[msg.sender]);\\n    emit onOfferingChanged(msg.sender, version, eventType, extraData);\\n  }\\n\\n  /**\\n   * @dev Function to activate emergency pause. This should stop buying activity on all offerings\\n   * Only Emergency Multisig wallet should be able to call this\\n   */\\n  function emergencyPause() onlyEmergencyMultisig public {\\n    isEmergencyPaused = true;\\n  }\\n\\n  /**\\n   * @dev Function to deactivate emergency pause. This should allow buying activity on all offerings again\\n   * Only Emergency Multisig wallet should be able to call this\\n   */\\n  function emergencyRelease() onlyEmergencyMultisig public {\\n    isEmergencyPaused = false;\\n  }\\n}\"},\"Ownable.sol\":{\"content\":\"pragma solidity ^0.5.0;\\n\\ncontract Ownable {\\n\\n    address public owner;\\n\\n    modifier onlyOwner {\\n        require(isOwner(msg.sender));\\n        _;\\n    }\\n\\n    constructor() public {\\n        owner = msg.sender;\\n    }\\n\\n    function transferOwnership(address newOwner) public onlyOwner {\\n        owner = newOwner;\\n    }\\n\\n    function isOwner(address addr) public view returns (bool) {\\n        return owner == addr;\\n    }\\n}\\n\"},\"Registrar.sol\":{\"content\":\"pragma solidity \\u003e=0.4.24;\\n\\nimport \\\"./Deed.sol\\\";\\n\\ninterface Registrar {\\n\\n    enum Mode { Open, Auction, Owned, Forbidden, Reveal, NotYetAvailable }\\n\\n    event AuctionStarted(bytes32 indexed hash, uint registrationDate);\\n    event NewBid(bytes32 indexed hash, address indexed bidder, uint deposit);\\n    event BidRevealed(bytes32 indexed hash, address indexed owner, uint value, uint8 status);\\n    event HashRegistered(bytes32 indexed hash, address indexed owner, uint value, uint registrationDate);\\n    event HashReleased(bytes32 indexed hash, uint value);\\n    event HashInvalidated(bytes32 indexed hash, string indexed name, uint value, uint registrationDate);\\n\\n    function startAuction(bytes32 _hash) external;\\n    function startAuctions(bytes32[] calldata _hashes) external;\\n    function newBid(bytes32 sealedBid) external payable;\\n    function startAuctionsAndBid(bytes32[] calldata hashes, bytes32 sealedBid) external payable;\\n    function unsealBid(bytes32 _hash, uint _value, bytes32 _salt) external;\\n    function cancelBid(address bidder, bytes32 seal) external;\\n    function finalizeAuction(bytes32 _hash) external;\\n    function transfer(bytes32 _hash, address payable newOwner) external;\\n    function releaseDeed(bytes32 _hash) external;\\n    function invalidateName(string calldata unhashedName) external;\\n    function eraseNode(bytes32[] calldata labels) external;\\n    function transferRegistrars(bytes32 _hash) external;\\n    function acceptRegistrarTransfer(bytes32 hash, Deed deed, uint registrationDate) external;\\n    function entries(bytes32 _hash) external view returns (Mode, address, uint, uint, uint);\\n}\\n\"},\"Root.sol\":{\"content\":\"pragma solidity ^0.5.0;\\n\\nimport \\\"./ENS.sol\\\";\\nimport \\\"./Ownable.sol\\\";\\nimport \\\"./Controllable.sol\\\";\\n\\ncontract Root is Ownable, Controllable {\\n    bytes32 constant private ROOT_NODE = bytes32(0);\\n\\n    bytes4 constant private INTERFACE_META_ID = bytes4(keccak256(\\\"supportsInterface(bytes4)\\\"));\\n\\n    event TLDLocked(bytes32 indexed label);\\n\\n    ENS public ens;\\n    mapping(bytes32=\\u003ebool) public locked;\\n\\n    constructor(ENS _ens) public {\\n        ens = _ens;\\n    }\\n\\n    function setSubnodeOwner(bytes32 label, address owner) external onlyController {\\n        require(!locked[label]);\\n        ens.setSubnodeOwner(ROOT_NODE, label, owner);\\n    }\\n\\n    function setResolver(address resolver) external onlyOwner {\\n        ens.setResolver(ROOT_NODE, resolver);\\n    }\\n\\n    function lock(bytes32 label) external onlyOwner {\\n        emit TLDLocked(label);\\n        locked[label] = true;\\n    }\\n\\n    function supportsInterface(bytes4 interfaceID) external pure returns (bool) {\\n        return interfaceID == INTERFACE_META_ID;\\n    }\\n}\\n\"},\"UsedByFactories.sol\":{\"content\":\"pragma solidity ^0.5.0;\\n\\nimport \\\"./Ownable.sol\\\";\\n\\n/**\\n * @title UsedByFactories\\n * @dev Provides modifiers to allow only offering factory contracts to execute method\\n */\\n\\ncontract UsedByFactories is Ownable {\\n\\n    mapping(address =\\u003e bool) public isFactory;\\n\\n    modifier onlyFactory() {\\n        require(isFactory[msg.sender]);\\n        _;\\n    }\\n\\n    function setFactories(address[] memory factories, bool _isFactory)\\n    public\\n    onlyOwner\\n    {\\n        for(uint i = 0; i \\u003c factories.length; i++) {\\n            isFactory[factories[i]] = _isFactory;\\n        }\\n    }\\n}\"}}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ETH_LABEL\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"previousRegistrar\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"offerings\",\"type\":\"address[]\"}],\"name\":\"reclaimOwnerships\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"offeringRegistry\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ETH_NODE\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"root\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_root\",\"type\":\"address\"},{\"name\":\"_offeringRegistry\",\"type\":\"address\"},{\"name\":\"_previousRegistrar\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"offering\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"transactionId\",\"type\":\"uint256\"}],\"name\":\"ReclaimSuccess\",\"type\":\"event\"}]","ContractName":"NameBazaarRescue","CompilerVersion":"v0.5.0+commit.1d4f565a","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000285088c75a8508664ad77df63e2d60a408e5284a00000000000000000000000034e400a8b4da8a23b5eaf81b46d3a887669a45b90000000000000000000000006090a6e47849629b7245dfa1ca21d94cd15878ef","Library":"","SwarmSource":"bzzr://5deff5a6b1ab08af17fb5f8c7fbc5be8d349de590475e9e96f7bb563420e0074"}]}