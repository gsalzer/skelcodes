{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.5.0;\r\n\r\n// File: openzeppelin-solidity/contracts/access/Roles.sol\r\n\r\n/**\r\n * @title Roles\r\n * @dev Library for managing addresses assigned to a Role.\r\n */\r\nlibrary Roles {\r\n    struct Role {\r\n        mapping (address => bool) bearer;\r\n    }\r\n\r\n    /**\r\n     * @dev give an account access to this role\r\n     */\r\n    function add(Role storage role, address account) internal {\r\n        require(account != address(0));\r\n        require(!has(role, account));\r\n\r\n        role.bearer[account] = true;\r\n    }\r\n\r\n    /**\r\n     * @dev remove an account's access to this role\r\n     */\r\n    function remove(Role storage role, address account) internal {\r\n        require(account != address(0));\r\n        require(has(role, account));\r\n\r\n        role.bearer[account] = false;\r\n    }\r\n\r\n    /**\r\n     * @dev check if an account has this role\r\n     * @return bool\r\n     */\r\n    function has(Role storage role, address account) internal view returns (bool) {\r\n        require(account != address(0));\r\n        return role.bearer[account];\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/access/roles/PauserRole.sol\r\n\r\ncontract PauserRole {\r\n    using Roles for Roles.Role;\r\n\r\n    event PauserAdded(address indexed account);\r\n    event PauserRemoved(address indexed account);\r\n\r\n    Roles.Role private _pausers;\r\n\r\n    constructor () internal {\r\n        _addPauser(msg.sender);\r\n    }\r\n\r\n    modifier onlyPauser() {\r\n        require(isPauser(msg.sender));\r\n        _;\r\n    }\r\n\r\n    function isPauser(address account) public view returns (bool) {\r\n        return _pausers.has(account);\r\n    }\r\n\r\n    function addPauser(address account) public onlyPauser {\r\n        _addPauser(account);\r\n    }\r\n\r\n    function renouncePauser() public {\r\n        _removePauser(msg.sender);\r\n    }\r\n\r\n    function _addPauser(address account) internal {\r\n        _pausers.add(account);\r\n        emit PauserAdded(account);\r\n    }\r\n\r\n    function _removePauser(address account) internal {\r\n        _pausers.remove(account);\r\n        emit PauserRemoved(account);\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/lifecycle/Pausable.sol\r\n\r\n/**\r\n * @title Pausable\r\n * @dev Base contract which allows children to implement an emergency stop mechanism.\r\n */\r\ncontract Pausable is PauserRole {\r\n    event Paused(address account);\r\n    event Unpaused(address account);\r\n\r\n    bool private _paused;\r\n\r\n    constructor () internal {\r\n        _paused = false;\r\n    }\r\n\r\n    /**\r\n     * @return true if the contract is paused, false otherwise.\r\n     */\r\n    function paused() public view returns (bool) {\r\n        return _paused;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to make a function callable only when the contract is not paused.\r\n     */\r\n    modifier whenNotPaused() {\r\n        require(!_paused);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to make a function callable only when the contract is paused.\r\n     */\r\n    modifier whenPaused() {\r\n        require(_paused);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev called by the owner to pause, triggers stopped state\r\n     */\r\n    function pause() public onlyPauser whenNotPaused {\r\n        _paused = true;\r\n        emit Paused(msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @dev called by the owner to unpause, returns to normal state\r\n     */\r\n    function unpause() public onlyPauser whenPaused {\r\n        _paused = false;\r\n        emit Unpaused(msg.sender);\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC20/IERC20.sol\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ninterface IERC20 {\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n\r\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address who) external view returns (uint256);\r\n\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: lib/ds-math/src/math.sol\r\n\r\n/// math.sol -- mixin for inline numerical wizardry\r\n\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\npragma solidity >0.4.13;\r\n\r\ncontract DSMath {\r\n    function add(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x + y) >= x, \"ds-math-add-overflow\");\r\n    }\r\n    function sub(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x - y) <= x, \"ds-math-sub-underflow\");\r\n    }\r\n    function mul(uint x, uint y) internal pure returns (uint z) {\r\n        require(y == 0 || (z = x * y) / y == x, \"ds-math-mul-overflow\");\r\n    }\r\n\r\n    function min(uint x, uint y) internal pure returns (uint z) {\r\n        return x <= y ? x : y;\r\n    }\r\n    function max(uint x, uint y) internal pure returns (uint z) {\r\n        return x >= y ? x : y;\r\n    }\r\n    function imin(int x, int y) internal pure returns (int z) {\r\n        return x <= y ? x : y;\r\n    }\r\n    function imax(int x, int y) internal pure returns (int z) {\r\n        return x >= y ? x : y;\r\n    }\r\n\r\n    uint constant WAD = 10 ** 18;\r\n    uint constant RAY = 10 ** 27;\r\n\r\n    function wmul(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, y), WAD / 2) / WAD;\r\n    }\r\n    function rmul(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, y), RAY / 2) / RAY;\r\n    }\r\n    function wdiv(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, WAD), y / 2) / y;\r\n    }\r\n    function rdiv(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, RAY), y / 2) / y;\r\n    }\r\n\r\n    // This famous algorithm is called \"exponentiation by squaring\"\r\n    // and calculates x^n with x as fixed-point and n as regular unsigned.\r\n    //\r\n    // It's O(log n), instead of O(n) for naive repeated multiplication.\r\n    //\r\n    // These facts are why it works:\r\n    //\r\n    //  If n is even, then x^n = (x^2)^(n/2).\r\n    //  If n is odd,  then x^n = x * x^(n-1),\r\n    //   and applying the equation for even x gives\r\n    //    x^n = x * (x^2)^((n-1) / 2).\r\n    //\r\n    //  Also, EVM division is flooring and\r\n    //    floor[(n-1) / 2] = floor[n / 2].\r\n    //\r\n    function rpow(uint x, uint n) internal pure returns (uint z) {\r\n        z = n % 2 != 0 ? x : RAY;\r\n\r\n        for (n /= 2; n != 0; n /= 2) {\r\n            x = rmul(x, x);\r\n\r\n            if (n % 2 != 0) {\r\n                z = rmul(z, x);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/interfaces/IWrappedEther.sol\r\n\r\ncontract IWrappedEther is IERC20 {\r\n    function deposit() external payable;\r\n    function withdraw(uint amount) external;\r\n}\r\n\r\n// File: contracts/interfaces/ISaiTub.sol\r\n\r\ninterface DSValue {\r\n    function peek() external view returns (bytes32, bool);\r\n}\r\n\r\ninterface ISaiTub {\r\n    function sai() external view returns (IERC20);  // Stablecoin\r\n    function sin() external view returns (IERC20);  // Debt (negative sai)\r\n    function skr() external view returns (IERC20);  // Abstracted collateral\r\n    function gem() external view returns (IWrappedEther);  // Underlying collateral\r\n    function gov() external view returns (IERC20);  // Governance token\r\n\r\n    function open() external returns (bytes32 cup);\r\n    function join(uint wad) external;\r\n    function exit(uint wad) external;\r\n    function give(bytes32 cup, address guy) external;\r\n    function lock(bytes32 cup, uint wad) external;\r\n    function free(bytes32 cup, uint wad) external;\r\n    function draw(bytes32 cup, uint wad) external;\r\n    function wipe(bytes32 cup, uint wad) external;\r\n    function shut(bytes32 cup) external;\r\n    function per() external view returns (uint ray);\r\n    function lad(bytes32 cup) external view returns (address);\r\n    \r\n    function tab(bytes32 cup) external returns (uint);\r\n    function rap(bytes32 cup) external returns (uint);\r\n    function ink(bytes32 cup) external view returns (uint);\r\n    function mat() external view returns (uint);    // Liquidation ratio\r\n    function fee() external view returns (uint);    // Governance fee\r\n    function pep() external view returns (DSValue); // Governance price feed\r\n    function cap() external view returns (uint); // Debt ceiling\r\n    \r\n\r\n    function cups(bytes32) external view returns (address, uint, uint, uint);\r\n}\r\n\r\n// File: contracts/interfaces/IDex.sol\r\n\r\ninterface IDex {\r\n    function getPayAmount(IERC20 pay_gem, IERC20 buy_gem, uint buy_amt) external view returns (uint);\r\n    function buyAllAmount(IERC20 buy_gem, uint buy_amt, IERC20 pay_gem, uint max_fill_amount) external returns (uint);\r\n    function offer(\r\n        uint pay_amt,    //maker (ask) sell how much\r\n        IERC20 pay_gem,   //maker (ask) sell which token\r\n        uint buy_amt,    //maker (ask) buy how much\r\n        IERC20 buy_gem,   //maker (ask) buy which token\r\n        uint pos         //position to insert offer, 0 should be used if unknown\r\n    )\r\n    external\r\n    returns (uint);\r\n}\r\n\r\n// File: contracts/ArrayUtils.sol\r\n\r\nlibrary ArrayUtils {\r\n    function removeElement(bytes32[] storage array, uint index) internal {\r\n        if (index >= array.length) return;\r\n\r\n        for (uint i = index; i < array.length - 1; i++) {\r\n            array[i] = array[i + 1];\r\n        }\r\n        delete array[array.length - 1];\r\n        array.length--;\r\n    }\r\n\r\n    function findElement(bytes32[] storage array, bytes32 element) internal view returns (uint index, bool ok) {\r\n        for (uint i = 0; i < array.length; i++) {\r\n            if (array[i] == element) {\r\n                return (i, true);\r\n            }\r\n        }\r\n\r\n        return (0, false);\r\n    }\r\n}\r\n\r\n// File: contracts/MakerDaoGateway.sol\r\n\r\ncontract MakerDaoGateway is Pausable, DSMath {\r\n    using ArrayUtils for bytes32[];\r\n\r\n    ISaiTub public saiTub;\r\n    IDex public dex;\r\n    IWrappedEther public weth;\r\n    IERC20 public peth;\r\n    IERC20 public dai;\r\n    IERC20 public mkr;\r\n\r\n    mapping(bytes32 => address) public cdpOwner;\r\n    mapping(address => bytes32[]) public cdpsByOwner;\r\n\r\n    event CdpOpened(address indexed owner, bytes32 cdpId);\r\n    event CdpClosed(address indexed owner, bytes32 cdpId);\r\n    event CollateralSupplied(address indexed owner, bytes32 cdpId, uint wethAmount, uint pethAmount);\r\n    event DaiBorrowed(address indexed owner, bytes32 cdpId, uint amount);\r\n    event DaiRepaid(address indexed owner, bytes32 cdpId, uint amount);\r\n    event CollateralReturned(address indexed owner, bytes32 cdpId, uint wethAmount, uint pethAmount);\r\n    event CdpTransferred(address indexed oldOwner, address indexed newOwner, bytes32 cdpId);\r\n    event CdpEjected(address indexed newOwner, bytes32 cdpId);\r\n    event CdpRegistered(address indexed newOwner, bytes32 cdpId);\r\n\r\n    modifier isCdpOwner(bytes32 cdpId) {\r\n        require(cdpOwner[cdpId] == msg.sender || cdpId == 0, \"CDP belongs to a different address\");\r\n        _;\r\n    }\r\n\r\n    constructor(ISaiTub _saiTub, IDex _dex) public {\r\n        saiTub = _saiTub;\r\n        dex = _dex;\r\n        weth = saiTub.gem();\r\n        peth = saiTub.skr();\r\n        dai = saiTub.sai();\r\n        mkr = saiTub.gov();\r\n    }\r\n\r\n    function cdpsByOwnerLength(address _owner) external view returns (uint) {\r\n        return cdpsByOwner[_owner].length;\r\n    }\r\n\r\n    function systemParameters() external view returns (uint liquidationRatio, uint annualStabilityFee, uint daiAvailable) {\r\n        liquidationRatio = saiTub.mat();\r\n        annualStabilityFee = rpow(saiTub.fee(), 365 days);\r\n        daiAvailable = sub(saiTub.cap(), dai.totalSupply());\r\n    }\r\n    \r\n    function cdpInfo(bytes32 cdpId) external returns (uint borrowedDai, uint outstandingDai, uint suppliedPeth) {\r\n        (, uint ink, uint art, ) = saiTub.cups(cdpId);\r\n        borrowedDai = art;\r\n        suppliedPeth = ink;\r\n        outstandingDai = add(saiTub.rap(cdpId), saiTub.tab(cdpId));\r\n    }\r\n    \r\n    function pethForWeth(uint wethAmount) public view returns (uint) {\r\n        return rdiv(wethAmount, saiTub.per());\r\n    }\r\n\r\n    function wethForPeth(uint pethAmount) public view returns (uint) {\r\n        return rmul(pethAmount, saiTub.per());\r\n    }\r\n\r\n    function() external payable {\r\n        // For unwrapping WETH\r\n    }\r\n\r\n    // SUPPLY AND BORROW\r\n\r\n    // specify cdpId if you want to use existing CDP, or pass 0 if you need to create a new one \r\n    function supplyEthAndBorrowDai(bytes32 cdpId, uint daiAmount) whenNotPaused isCdpOwner(cdpId) external payable {\r\n        bytes32 id = supplyEth(cdpId);\r\n        borrowDai(id, daiAmount);\r\n    }\r\n\r\n    // specify cdpId if you want to use existing CDP, or pass 0 if you need to create a new one \r\n    function supplyWethAndBorrowDai(bytes32 cdpId, uint wethAmount, uint daiAmount) whenNotPaused isCdpOwner(cdpId) external {\r\n        bytes32 id = supplyWeth(cdpId, wethAmount);\r\n        borrowDai(id, daiAmount);\r\n    }\r\n\r\n    // ETH amount should be > 0.005 for new CDPs\r\n    // returns id of actual CDP (existing or a new one)\r\n    function supplyEth(bytes32 cdpId) isCdpOwner(cdpId) whenNotPaused isCdpOwner(cdpId) public payable returns (bytes32 _cdpId) {\r\n        if (msg.value > 0) {\r\n            weth.deposit.value(msg.value)();\r\n            return _supply(cdpId, msg.value);\r\n        }\r\n\r\n        return cdpId;\r\n    }\r\n\r\n    // WETH amount should be > 0.005 for new CDPs\r\n    // don't forget to approve WETH before supplying\r\n    // returns id of actual CDP (existing or a new one)\r\n    function supplyWeth(bytes32 cdpId, uint wethAmount) whenNotPaused isCdpOwner(cdpId) public returns (bytes32 _cdpId) {\r\n        if (wethAmount > 0) {\r\n            require(weth.transferFrom(msg.sender, address(this), wethAmount));\r\n            return _supply(cdpId, wethAmount);\r\n        }\r\n\r\n        return cdpId;\r\n    }\r\n\r\n    function borrowDai(bytes32 cdpId, uint daiAmount) whenNotPaused isCdpOwner(cdpId) public {\r\n        if (daiAmount > 0) {\r\n            saiTub.draw(cdpId, daiAmount);\r\n\r\n            require(dai.transfer(msg.sender, daiAmount));\r\n\r\n            emit DaiBorrowed(msg.sender, cdpId, daiAmount);\r\n        }\r\n    }\r\n\r\n    // REPAY AND RETURN\r\n\r\n    // don't forget to approve DAI before repaying\r\n    function repayDaiAndReturnEth(bytes32 cdpId, uint daiAmount, uint ethAmount, bool payFeeInDai) whenNotPaused isCdpOwner(cdpId) external {\r\n        repayDai(cdpId, daiAmount, payFeeInDai);\r\n        returnEth(cdpId, ethAmount);\r\n    }\r\n\r\n    // don't forget to approve DAI before repaying\r\n    // pass -1 to daiAmount to repay all outstanding debt\r\n    // pass -1 to wethAmount to return all collateral\r\n    function repayDaiAndReturnWeth(bytes32 cdpId, uint daiAmount, uint wethAmount, bool payFeeInDai) whenNotPaused isCdpOwner(cdpId) public {\r\n        repayDai(cdpId, daiAmount, payFeeInDai);\r\n        returnWeth(cdpId, wethAmount);\r\n    }\r\n\r\n    // don't forget to approve DAI before repaying\r\n    // pass -1 to daiAmount to repay all outstanding debt\r\n    function repayDai(bytes32 cdpId, uint daiAmount, bool payFeeInDai) whenNotPaused isCdpOwner(cdpId) public {\r\n        if (daiAmount > 0) {\r\n            uint _daiAmount = daiAmount;\r\n            if (_daiAmount == uint(- 1)) {\r\n                // repay all outstanding debt\r\n                _daiAmount = saiTub.tab(cdpId);\r\n            }\r\n\r\n            _ensureApproval(dai, address(saiTub));\r\n            _ensureApproval(mkr, address(saiTub));\r\n\r\n            uint govFeeAmount = _calcGovernanceFee(cdpId, _daiAmount);\r\n            _handleGovFee(govFeeAmount, payFeeInDai);\r\n\r\n            require(dai.transferFrom(msg.sender, address(this), _daiAmount));\r\n\r\n            saiTub.wipe(cdpId, _daiAmount);\r\n\r\n            emit DaiRepaid(msg.sender, cdpId, _daiAmount);\r\n        }\r\n    }\r\n\r\n    function returnEth(bytes32 cdpId, uint ethAmount) whenNotPaused isCdpOwner(cdpId) public {\r\n        if (ethAmount > 0) {\r\n            uint effectiveWethAmount = _return(cdpId, ethAmount);\r\n            weth.withdraw(effectiveWethAmount);\r\n            msg.sender.transfer(effectiveWethAmount);\r\n        }\r\n    }\r\n\r\n    function returnWeth(bytes32 cdpId, uint wethAmount) whenNotPaused isCdpOwner(cdpId) public {\r\n        if (wethAmount > 0) {\r\n            uint effectiveWethAmount = _return(cdpId, wethAmount);\r\n            require(weth.transfer(msg.sender, effectiveWethAmount));\r\n        }\r\n    }\r\n\r\n    function closeCdp(bytes32 cdpId, bool payFeeInDai) whenNotPaused isCdpOwner(cdpId) external {\r\n        repayDaiAndReturnWeth(cdpId, uint(-1), uint(-1), payFeeInDai);\r\n        _removeCdp(cdpId, msg.sender);\r\n        saiTub.shut(cdpId);\r\n        \r\n        emit CdpClosed(msg.sender, cdpId);\r\n    }\r\n\r\n    // TRANSFER AND ADOPT\r\n\r\n    // You can migrate your CDP from MakerDaoGateway contract to another owner\r\n    function transferCdp(bytes32 cdpId, address nextOwner) isCdpOwner(cdpId) external {\r\n        address _owner = nextOwner;\r\n        if (_owner == address(0x0)) {\r\n            _owner = msg.sender;\r\n        }\r\n        \r\n        saiTub.give(cdpId, _owner);\r\n\r\n        _removeCdp(cdpId, msg.sender);\r\n\r\n        emit CdpTransferred(msg.sender, _owner, cdpId);\r\n    }\r\n    \r\n    function ejectCdp(bytes32 cdpId) onlyPauser external {\r\n        address owner = cdpOwner[cdpId];\r\n        saiTub.give(cdpId, owner);\r\n\r\n        _removeCdp(cdpId, owner);\r\n\r\n        emit CdpEjected(owner, cdpId);\r\n    }\r\n    \r\n    // ONLY FOR TEST VERSION. WILL BE REMOVED IN TO OFFICIAL RELEASE VERSION\r\n    function destroy() onlyPauser external {\r\n        selfdestruct(msg.sender);\r\n    }\r\n\r\n    // If you want to migrate existing CDP to MakerDaoGateway contract,\r\n    // you need to register your cdp first with this function, and then execute `give` operation,\r\n    // transferring CDP to the MakerDaoGateway contract\r\n    function registerCdp(bytes32 cdpId, address owner) whenNotPaused external {\r\n        require(saiTub.lad(cdpId) == msg.sender, \"Can't register other's CDP\");\r\n        require(cdpOwner[cdpId] == address(0x0), \"Can't register CDP twice\");\r\n\r\n        address _owner = owner;\r\n        if (_owner == address(0x0)) {\r\n            _owner = msg.sender;\r\n        }\r\n\r\n        cdpOwner[cdpId] = _owner;\r\n        cdpsByOwner[_owner].push(cdpId);\r\n\r\n        emit CdpRegistered(_owner, cdpId);\r\n    }\r\n\r\n    // INTERNAL FUNCTIONS\r\n\r\n    function _supply(bytes32 cdpId, uint wethAmount) internal returns (bytes32 _cdpId) {\r\n        _cdpId = cdpId;\r\n        if (_cdpId == 0) {\r\n            _cdpId = _createCdp();\r\n        }\r\n\r\n        _ensureApproval(weth, address(saiTub));\r\n\r\n        uint pethAmount = pethForWeth(wethAmount);\r\n\r\n        saiTub.join(pethAmount);\r\n\r\n        _ensureApproval(peth, address(saiTub));\r\n\r\n        saiTub.lock(_cdpId, pethAmount);\r\n        emit CollateralSupplied(msg.sender, _cdpId, wethAmount, pethAmount);\r\n    }\r\n\r\n    function _return(bytes32 cdpId, uint wethAmount) internal returns (uint _wethAmount) {\r\n        uint pethAmount;\r\n\r\n        if (wethAmount == uint(- 1)) {\r\n            // return all collateral\r\n            pethAmount = saiTub.ink(cdpId);\r\n        } else {\r\n            pethAmount = pethForWeth(wethAmount);\r\n        }\r\n\r\n        saiTub.free(cdpId, pethAmount);\r\n\r\n        _ensureApproval(peth, address(saiTub));\r\n\r\n        saiTub.exit(pethAmount);\r\n\r\n        _wethAmount = wethForPeth(pethAmount);\r\n\r\n        emit CollateralReturned(msg.sender, cdpId, _wethAmount, pethAmount);\r\n    }\r\n\r\n    function _calcGovernanceFee(bytes32 cdpId, uint daiAmount) internal returns (uint mkrFeeAmount) {\r\n        uint daiFeeAmount = rmul(daiAmount, rdiv(saiTub.rap(cdpId), saiTub.tab(cdpId)));\r\n        (bytes32 val, bool ok) = saiTub.pep().peek();\r\n        require(ok && val != 0, 'Unable to get mkr rate');\r\n\r\n        return wdiv(daiFeeAmount, uint(val));\r\n    }\r\n\r\n    function _handleGovFee(uint mkrGovAmount, bool payWithDai) internal {\r\n        if (mkrGovAmount > 0) {\r\n            if (payWithDai) {\r\n                uint daiAmount = dex.getPayAmount(dai, mkr, mkrGovAmount);\r\n\r\n                _ensureApproval(dai, address(dex));\r\n\r\n                require(dai.transferFrom(msg.sender, address(this), daiAmount));\r\n                dex.buyAllAmount(mkr, mkrGovAmount, dai, daiAmount);\r\n            } else {\r\n                require(mkr.transferFrom(msg.sender, address(this), mkrGovAmount));\r\n            }\r\n        }\r\n    }\r\n\r\n    function _ensureApproval(IERC20 token, address spender) internal {\r\n        if (token.allowance(address(this), spender) != uint(- 1)) {\r\n            require(token.approve(spender, uint(- 1)));\r\n        }\r\n    }\r\n\r\n    function _createCdp() internal returns (bytes32 cdpId) {\r\n        cdpId = saiTub.open();\r\n\r\n        cdpOwner[cdpId] = msg.sender;\r\n        cdpsByOwner[msg.sender].push(cdpId);\r\n\r\n        emit CdpOpened(msg.sender, cdpId);\r\n    }\r\n    \r\n    function _removeCdp(bytes32 cdpId, address owner) internal {\r\n        (uint i, bool ok) = cdpsByOwner[owner].findElement(cdpId);\r\n        require(ok, \"Can't find cdp in owner's list\");\r\n        \r\n        cdpsByOwner[owner].removeElement(i);\r\n        delete cdpOwner[cdpId];\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"cdpId\",\"type\":\"bytes32\"}],\"name\":\"cdpInfo\",\"outputs\":[{\"name\":\"borrowedDai\",\"type\":\"uint256\"},{\"name\":\"outstandingDai\",\"type\":\"uint256\"},{\"name\":\"suppliedPeth\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"pethAmount\",\"type\":\"uint256\"}],\"name\":\"wethForPeth\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"cdpsByOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"cdpId\",\"type\":\"bytes32\"},{\"name\":\"daiAmount\",\"type\":\"uint256\"},{\"name\":\"ethAmount\",\"type\":\"uint256\"},{\"name\":\"payFeeInDai\",\"type\":\"bool\"}],\"name\":\"repayDaiAndReturnEth\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"cdpId\",\"type\":\"bytes32\"},{\"name\":\"nextOwner\",\"type\":\"address\"}],\"name\":\"transferCdp\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"cdpId\",\"type\":\"bytes32\"},{\"name\":\"wethAmount\",\"type\":\"uint256\"},{\"name\":\"daiAmount\",\"type\":\"uint256\"}],\"name\":\"supplyWethAndBorrowDai\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"weth\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"cdpId\",\"type\":\"bytes32\"}],\"name\":\"supplyEth\",\"outputs\":[{\"name\":\"_cdpId\",\"type\":\"bytes32\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isPauser\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"cdpsByOwnerLength\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"cdpId\",\"type\":\"bytes32\"},{\"name\":\"ethAmount\",\"type\":\"uint256\"}],\"name\":\"returnEth\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"cdpId\",\"type\":\"bytes32\"},{\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"registerCdp\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"cdpId\",\"type\":\"bytes32\"},{\"name\":\"daiAmount\",\"type\":\"uint256\"}],\"name\":\"supplyEthAndBorrowDai\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"dex\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renouncePauser\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"cdpId\",\"type\":\"bytes32\"},{\"name\":\"daiAmount\",\"type\":\"uint256\"}],\"name\":\"borrowDai\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"peth\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"systemParameters\",\"outputs\":[{\"name\":\"liquidationRatio\",\"type\":\"uint256\"},{\"name\":\"annualStabilityFee\",\"type\":\"uint256\"},{\"name\":\"daiAvailable\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"mkr\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"addPauser\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"destroy\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"cdpId\",\"type\":\"bytes32\"},{\"name\":\"daiAmount\",\"type\":\"uint256\"},{\"name\":\"payFeeInDai\",\"type\":\"bool\"}],\"name\":\"repayDai\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"saiTub\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"cdpOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"cdpId\",\"type\":\"bytes32\"},{\"name\":\"wethAmount\",\"type\":\"uint256\"}],\"name\":\"supplyWeth\",\"outputs\":[{\"name\":\"_cdpId\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"cdpId\",\"type\":\"bytes32\"},{\"name\":\"wethAmount\",\"type\":\"uint256\"}],\"name\":\"returnWeth\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"cdpId\",\"type\":\"bytes32\"},{\"name\":\"daiAmount\",\"type\":\"uint256\"},{\"name\":\"wethAmount\",\"type\":\"uint256\"},{\"name\":\"payFeeInDai\",\"type\":\"bool\"}],\"name\":\"repayDaiAndReturnWeth\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"cdpId\",\"type\":\"bytes32\"},{\"name\":\"payFeeInDai\",\"type\":\"bool\"}],\"name\":\"closeCdp\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"wethAmount\",\"type\":\"uint256\"}],\"name\":\"pethForWeth\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"cdpId\",\"type\":\"bytes32\"}],\"name\":\"ejectCdp\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"dai\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_saiTub\",\"type\":\"address\"},{\"name\":\"_dex\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"cdpId\",\"type\":\"bytes32\"}],\"name\":\"CdpOpened\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"cdpId\",\"type\":\"bytes32\"}],\"name\":\"CdpClosed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"cdpId\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"wethAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"pethAmount\",\"type\":\"uint256\"}],\"name\":\"CollateralSupplied\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"cdpId\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"DaiBorrowed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"cdpId\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"DaiRepaid\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"cdpId\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"wethAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"pethAmount\",\"type\":\"uint256\"}],\"name\":\"CollateralReturned\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"cdpId\",\"type\":\"bytes32\"}],\"name\":\"CdpTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"cdpId\",\"type\":\"bytes32\"}],\"name\":\"CdpEjected\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"cdpId\",\"type\":\"bytes32\"}],\"name\":\"CdpRegistered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"PauserAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"PauserRemoved\",\"type\":\"event\"}]","ContractName":"MakerDaoGateway","CompilerVersion":"v0.5.0+commit.1d4f565a","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000448a5065aebb8e423f0896e6c5d525c040f59af3000000000000000000000000b7ac09c2c0217b07d7c103029b4918a2c401eecb","Library":"","SwarmSource":"bzzr://77b1e3203a35bd6e4c9d5ce06a7bb9fb40c5d6f3a0d5ba6649b44c324a1a9d30"}]}