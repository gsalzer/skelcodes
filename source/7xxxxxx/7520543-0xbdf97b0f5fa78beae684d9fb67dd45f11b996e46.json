{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.6;\r\n\r\nlibrary SafeMath {\r\n\r\n    function mul(uint a, uint b) internal pure returns (uint) {\r\n        uint c = a * b;\r\n        require(a == 0 || c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint a, uint b) internal pure returns (uint) {\r\n        require(b > 0);\r\n        uint c = a / b;\r\n        require(a == b * c + a % b);\r\n        return c;\r\n    }\r\n\r\n    function sub(uint a, uint b) internal pure returns (uint) {\r\n        require(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint a, uint b) internal pure returns (uint) {\r\n        uint c = a + b;\r\n        require(c >= a);\r\n        return c;\r\n    }\r\n\r\n    function max64(uint64 a, uint64 b) internal pure returns (uint64) {\r\n        return a >= b ? a : b;\r\n    }\r\n\r\n    function min64(uint64 a, uint64 b) internal pure returns (uint64) {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n    function max256(uint a, uint b) internal pure returns (uint) {\r\n        return a >= b ? a : b;\r\n    }\r\n\r\n    function min256(uint a, uint b) internal pure returns (uint) {\r\n        return a < b ? a : b;\r\n    }\r\n}\r\n\r\ninterface GeneralERC20 {\r\n\tfunction transfer(address to, uint256 value) external;\r\n\tfunction transferFrom(address from, address to, uint256 value) external;\r\n\tfunction approve(address spender, uint256 value) external;\r\n\tfunction balanceOf(address spender) external view returns (uint);\r\n}\r\n\r\nlibrary SafeERC20 {\r\n\tfunction checkSuccess()\r\n\t\tprivate\r\n\t\tpure\r\n\t\treturns (bool)\r\n\t{\r\n\t\tuint256 returnValue = 0;\r\n\r\n\t\tassembly {\r\n\t\t\t// check number of bytes returned from last function call\r\n\t\t\tswitch returndatasize\r\n\r\n\t\t\t// no bytes returned: assume success\r\n\t\t\tcase 0x0 {\r\n\t\t\t\treturnValue := 1\r\n\t\t\t}\r\n\r\n\t\t\t// 32 bytes returned: check if non-zero\r\n\t\t\tcase 0x20 {\r\n\t\t\t\t// copy 32 bytes into scratch space\r\n\t\t\t\treturndatacopy(0x0, 0x0, 0x20)\r\n\r\n\t\t\t\t// load those bytes into returnValue\r\n\t\t\t\treturnValue := mload(0x0)\r\n\t\t\t}\r\n\r\n\t\t\t// not sure what was returned: don't mark as success\r\n\t\t\tdefault { }\r\n\t\t}\r\n\r\n\t\treturn returnValue != 0;\r\n\t}\r\n\r\n\tfunction transfer(address token, address to, uint256 amount) internal {\r\n\t\tGeneralERC20(token).transfer(to, amount);\r\n\t\trequire(checkSuccess());\r\n\t}\r\n\r\n\tfunction transferFrom(address token, address from, address to, uint256 amount) internal {\r\n\t\tGeneralERC20(token).transferFrom(from, to, amount);\r\n\t\trequire(checkSuccess());\r\n\t}\r\n\r\n\tfunction approve(address token, address spender, uint256 amount) internal {\r\n\t\tGeneralERC20(token).approve(spender, amount);\r\n\t\trequire(checkSuccess());\r\n\t}\r\n}\r\n\r\nlibrary SignatureValidator {\r\n\tenum SignatureMode {\r\n\t\tNO_SIG,\r\n\t\tEIP712,\r\n\t\tGETH,\r\n\t\tTREZOR,\r\n\t\tADEX\r\n\t}\r\n\r\n\tfunction recoverAddr(bytes32 hash, bytes32[3] memory signature) internal pure returns (address) {\r\n\t\tSignatureMode mode = SignatureMode(uint8(signature[0][0]));\r\n\r\n\t\tif (mode == SignatureMode.NO_SIG) {\r\n\t\t\treturn address(0x0);\r\n\t\t}\r\n\r\n\t\tuint8 v = uint8(signature[0][1]);\r\n\r\n\t\tif (mode == SignatureMode.GETH) {\r\n\t\t\thash = keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\r\n\t\t} else if (mode == SignatureMode.TREZOR) {\r\n\t\t\thash = keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n\\x20\", hash));\r\n\t\t} else if (mode == SignatureMode.ADEX) {\r\n\t\t\thash = keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n108By signing this message, you acknowledge signing an AdEx bid with the hash:\\n\", hash));\r\n\t\t}\r\n\r\n\t\treturn ecrecover(hash, v, signature[1], signature[2]);\r\n\t}\r\n\r\n\t/// @dev Validates that a hash was signed by a specified signer.\r\n\t/// @param hash Hash which was signed.\r\n\t/// @param signer Address of the signer.\r\n\t/// @param signature ECDSA signature along with the mode [{mode}{v}, {r}, {s}]\r\n\t/// @return Returns whether signature is from a specified user.\r\n\tfunction isValidSignature(bytes32 hash, address signer, bytes32[3] memory signature) internal pure returns (bool) {\r\n\t\treturn recoverAddr(hash, signature) == signer;\r\n\t}\r\n}\r\n\r\n\r\nlibrary ChannelLibrary {\r\n\tuint constant MAX_VALIDITY = 365 days;\r\n\r\n\t// Both numbers are inclusive\r\n\tuint constant MIN_VALIDATOR_COUNT = 2;\r\n\t// This is an arbitrary number, but we impose this limit to restrict on-chain load; also to ensure the *3 operation is safe\r\n\tuint constant MAX_VALIDATOR_COUNT = 25;\r\n\r\n\tenum State {\r\n\t\tUnknown,\r\n\t\tActive,\r\n\t\tExpired\r\n\t}\r\n\r\n\tstruct Channel {\r\n\t\taddress creator;\r\n\r\n\t\taddress tokenAddr;\r\n\t\tuint tokenAmount;\r\n\r\n\t\tuint validUntil;\r\n\r\n\t\taddress[] validators;\r\n\r\n\t\t// finally, arbitrary bytes32 that allows to... @TODO document that this acts as a nonce\r\n\t\tbytes32 spec;\r\n\t}\r\n\r\n\tfunction hash(Channel memory channel)\r\n\t\tinternal\r\n\t\tview\r\n\t\treturns (bytes32)\r\n\t{\r\n\t\t// In this version of solidity, we can no longer keccak256() directly\r\n\t\treturn keccak256(abi.encode(\r\n\t\t\taddress(this),\r\n\t\t\tchannel.creator,\r\n\t\t\tchannel.tokenAddr,\r\n\t\t\tchannel.tokenAmount,\r\n\t\t\tchannel.validUntil,\r\n\t\t\tchannel.validators,\r\n\t\t\tchannel.spec\r\n\t\t));\r\n\t}\r\n\r\n\tfunction isValid(Channel memory channel, uint currentTime)\r\n\t\tinternal\r\n\t\tpure\r\n\t\treturns (bool)\r\n\t{\r\n\t\t// NOTE: validators[] can be sybil'd by passing the same addr a few times\r\n\t\t// this does not matter since you can sybil validators[] anyway, and that is mitigated off-chain\r\n\t\tif (channel.validators.length < MIN_VALIDATOR_COUNT) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tif (channel.validators.length > MAX_VALIDATOR_COUNT) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tif (channel.validUntil < currentTime) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tif (channel.validUntil > (currentTime + MAX_VALIDITY)) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction isSignedBySupermajority(Channel memory channel, bytes32 toSign, bytes32[3][] memory signatures) \r\n\t\tinternal\r\n\t\tpure\r\n\t\treturns (bool)\r\n\t{\r\n\t\t// NOTE: each element of signatures[] must signed by the elem with the same index in validators[]\r\n\t\t// In case someone didn't sign, pass SignatureMode.NO_SIG\r\n\t\tif (signatures.length != channel.validators.length) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\tuint signs = 0;\r\n\t\tuint sigLen = signatures.length;\r\n\t\tfor (uint i=0; i<sigLen; i++) {\r\n\t\t\t// NOTE: if a validator has not signed, you can just use SignatureMode.NO_SIG\r\n\t\t\tif (SignatureValidator.isValidSignature(toSign, channel.validators[i], signatures[i])) {\r\n\t\t\t\tsigns++;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn signs*3 >= channel.validators.length*2;\r\n\t}\r\n}\r\npragma experimental ABIEncoderV2;\r\n\r\n\r\ncontract ValidatorRegistry {\r\n\t// The contract will probably just use a mapping, but this is a generic interface\r\n\tfunction whitelisted(address) view external returns (bool);\r\n}\r\n\r\ncontract Identity {\r\n\tusing SafeMath for uint;\r\n\r\n\t// Storage\r\n\t// WARNING: be careful when modifying this\r\n\t// privileges and routineAuthorizations must always be 0th and 1th thing in storage\r\n\tmapping (address => uint8) public privileges;\r\n\t// Routine authorizations\r\n\tmapping (bytes32 => bool) public routineAuthorizations;\r\n\t// The next allowed nonce\r\n\tuint public nonce = 0;\r\n\t// Routine operations are authorized at once for a period, fee is paid once\r\n\tmapping (bytes32 => uint256) public routinePaidFees;\r\n\r\n\t// Constants\r\n\tbytes4 private constant CHANNEL_WITHDRAW_SELECTOR = bytes4(keccak256('channelWithdraw((address,address,uint256,uint256,address[],bytes32),bytes32,bytes32[3][],bytes32[],uint256)'));\r\n\tbytes4 private constant CHANNEL_WITHDRAW_EXPIRED_SELECTOR = bytes4(keccak256('channelWithdrawExpired((address,address,uint256,uint256,address[],bytes32))'));\r\n\tbytes4 private constant CHANNEL_OPEN_SELECTOR = bytes4(keccak256('channelOpen((address,address,uint256,uint256,address[],bytes32))'));\r\n\tuint256 private constant CHANNEL_MAX_VALIDITY = 90 days;\r\n\r\n\tenum PrivilegeLevel {\r\n\t\tNone,\r\n\t\tRoutines,\r\n\t\tTransactions,\r\n\t\tWithdrawTo\r\n\t}\r\n\tenum RoutineOp {\r\n\t\tChannelWithdraw,\r\n\t\tChannelWithdrawExpired,\r\n\t\tChannelOpen,\r\n\t\tWithdraw\r\n\t}\r\n\r\n\t// Events\r\n\tevent LogPrivilegeChanged(address indexed addr, uint8 privLevel);\r\n\tevent LogRoutineAuth(bytes32 hash, bool authorized);\r\n\r\n\t// Transaction structure\r\n\t// Those can be executed by keys with >= PrivilegeLevel.Transactions\r\n\t// Even though the contract cannot receive ETH, we are able to send ETH (.value), cause ETH might've been sent to the contract address before it's deployed\r\n\tstruct Transaction {\r\n\t\t// replay protection\r\n\t\taddress identityContract;\r\n\t\tuint nonce;\r\n\t\t// tx fee, in tokens\r\n\t\taddress feeTokenAddr;\r\n\t\tuint feeAmount;\r\n\t\t// all the regular txn data\r\n\t\taddress to;\r\n\t\tuint value;\r\n\t\tbytes data;\r\n\t}\r\n\r\n\t// RoutineAuthorizations allow the user to authorize (via keys >= PrivilegeLevel.Routines) a particular relayer to do any number of routines\r\n\t// those routines are safe: e.g. withdrawing channels to the identity, or from the identity to the pre-approved withdraw (>= PrivilegeLevel.Withdraw) address\r\n\t// while the fee will be paid only ONCE per auth, the authorization can be used until validUntil\r\n\t// while the routines are safe, there is some level of implied trust as the relayer may run executeRoutines without any routines to claim the fee\r\n\tstruct RoutineAuthorization {\r\n\t\taddress relayer;\r\n\t\taddress outpace;\r\n\t\taddress registry;\r\n\t\tuint validUntil;\r\n\t\taddress feeTokenAddr;\r\n\t\tuint weeklyFeeAmount;\r\n\t}\r\n\tstruct RoutineOperation {\r\n\t\tRoutineOp mode;\r\n\t\tbytes data;\r\n\t}\r\n\r\n\tconstructor(address[] memory addrs, uint8[] memory privLevels)\r\n\t\tpublic\r\n\t{\r\n\t\tuint len = privLevels.length;\r\n\t\tfor (uint i=0; i<len; i++) {\r\n\t\t\tprivileges[addrs[i]] = privLevels[i];\r\n\t\t\temit LogPrivilegeChanged(addrs[i], privLevels[i]);\r\n\t\t}\r\n\t}\r\n\r\n\tfunction setAddrPrivilege(address addr, uint8 privLevel)\r\n\t\texternal\r\n\t{\r\n\t\trequire(msg.sender == address(this), 'ONLY_IDENTITY_CAN_CALL');\r\n\t\tprivileges[addr] = privLevel;\r\n\t\temit LogPrivilegeChanged(addr, privLevel);\r\n\t}\r\n\r\n\tfunction setRoutineAuth(bytes32 hash, bool authorized)\r\n\t\texternal\r\n\t{\r\n\t\trequire(msg.sender == address(this), 'ONLY_IDENTITY_CAN_CALL');\r\n\t\troutineAuthorizations[hash] = authorized;\r\n\t\temit LogRoutineAuth(hash, authorized);\r\n\t}\r\n\r\n\tfunction execute(Transaction[] memory txns, bytes32[3][] memory signatures)\r\n\t\tpublic\r\n\t{\r\n\t\taddress feeTokenAddr = txns[0].feeTokenAddr;\r\n\t\tuint feeAmount = 0;\r\n\t\tuint len = txns.length;\r\n\t\tfor (uint i=0; i<len; i++) {\r\n\t\t\tTransaction memory txn = txns[i];\r\n\t\t\trequire(txn.identityContract == address(this), 'TRANSACTION_NOT_FOR_CONTRACT');\r\n\t\t\trequire(txn.feeTokenAddr == feeTokenAddr, 'EXECUTE_NEEDS_SINGLE_TOKEN');\r\n\t\t\trequire(txn.nonce == nonce, 'WRONG_NONCE');\r\n\r\n\t\t\t// If we use the naive abi.encode(txn) and have a field of type `bytes`,\r\n\t\t\t// there is a discrepancy between ethereumjs-abi and solidity\r\n\t\t\t// if we enter every field individually, in order, there is no discrepancy\r\n\t\t\t//bytes32 hash = keccak256(abi.encode(txn));\r\n\t\t\tbytes32 hash = keccak256(abi.encode(txn.identityContract, txn.nonce, txn.feeTokenAddr, txn.feeAmount, txn.to, txn.value, txn.data));\r\n\t\t\taddress signer = SignatureValidator.recoverAddr(hash, signatures[i]);\r\n\r\n\t\t\trequire(privileges[signer] >= uint8(PrivilegeLevel.Transactions), 'INSUFFICIENT_PRIVILEGE_TRANSACTION');\r\n\r\n\t\t\tnonce = nonce.add(1);\r\n\t\t\tfeeAmount = feeAmount.add(txn.feeAmount);\r\n\r\n\t\t\texecuteCall(txn.to, txn.value, txn.data);\r\n\t\t\t// The actual anti-bricking mechanism - do not allow a signer to drop his own priviledges\r\n\t\t\trequire(privileges[signer] >= uint8(PrivilegeLevel.Transactions), 'PRIVILEGE_NOT_DOWNGRADED');\r\n\t\t}\r\n\t\tif (feeAmount > 0) {\r\n\t\t\tSafeERC20.transfer(feeTokenAddr, msg.sender, feeAmount);\r\n\t\t}\r\n\t}\r\n\r\n\tfunction executeBySender(Transaction[] memory txns)\r\n\t\tpublic\r\n\t{\r\n\t\trequire(privileges[msg.sender] >= uint8(PrivilegeLevel.Transactions), 'INSUFFICIENT_PRIVILEGE_SENDER');\r\n\t\tuint len = txns.length;\r\n\t\tfor (uint i=0; i<len; i++) {\r\n\t\t\tTransaction memory txn = txns[i];\r\n\t\t\trequire(txn.nonce == nonce, 'WRONG_NONCE');\r\n\r\n\t\t\tnonce = nonce.add(1);\r\n\r\n\t\t\texecuteCall(txn.to, txn.value, txn.data);\r\n\t\t}\r\n\t\t// The actual anti-bricking mechanism - do not allow the sender to drop his own priviledges\r\n\t\trequire(privileges[msg.sender] >= uint8(PrivilegeLevel.Transactions), 'PRIVILEGE_NOT_DOWNGRADED');\r\n\t}\r\n\r\n\tfunction executeRoutines(RoutineAuthorization memory auth, RoutineOperation[] memory operations)\r\n\t\tpublic\r\n\t{\r\n\t\trequire(auth.relayer == msg.sender, 'ONLY_RELAYER_CAN_CALL');\r\n\t\trequire(auth.validUntil >= now, 'AUTHORIZATION_EXPIRED');\r\n\t\tbytes32 hash = keccak256(abi.encode(auth));\r\n\t\trequire(routineAuthorizations[hash], 'NOT_AUTHORIZED');\r\n\t\tuint len = operations.length;\r\n\t\tfor (uint i=0; i<len; i++) {\r\n\t\t\tRoutineOperation memory op = operations[i];\r\n\t\t\tif (op.mode == RoutineOp.ChannelWithdraw) {\r\n\t\t\t\t// Channel: Withdraw\r\n\t\t\t\texecuteCall(auth.outpace, 0, abi.encodePacked(CHANNEL_WITHDRAW_SELECTOR, op.data));\r\n\t\t\t} else if (op.mode == RoutineOp.ChannelWithdrawExpired) {\r\n\t\t\t\t// Channel: Withdraw Expired\r\n\t\t\t\texecuteCall(auth.outpace, 0, abi.encodePacked(CHANNEL_WITHDRAW_EXPIRED_SELECTOR, op.data));\r\n\t\t\t} else if (op.mode == RoutineOp.ChannelOpen) {\r\n\t\t\t\t// Channel: open\r\n\t\t\t\t(ChannelLibrary.Channel memory channel) = abi.decode(op.data, (ChannelLibrary.Channel));\r\n\t\t\t\t// Ensure validity is sane\r\n\t\t\t\trequire(channel.validUntil <= (now + CHANNEL_MAX_VALIDITY), 'CHANNEL_EXCEEDED_MAX_VALID');\r\n\t\t\t\t// Ensure all validators are whitelisted\r\n\t\t\t\tuint validatorsLen = channel.validators.length;\r\n\t\t\t\tfor (uint j=0; j<validatorsLen; j++) {\r\n\t\t\t\t\trequire(\r\n\t\t\t\t\t\tValidatorRegistry(auth.registry).whitelisted(channel.validators[j]),\r\n\t\t\t\t\t\t\"VALIDATOR_NOT_WHITELISTED\"\r\n\t\t\t\t\t);\r\n\t\t\t\t}\r\n\t\t\t\tSafeERC20.approve(channel.tokenAddr, auth.outpace, 0);\r\n\t\t\t\tSafeERC20.approve(channel.tokenAddr, auth.outpace, channel.tokenAmount);\r\n\t\t\t\texecuteCall(auth.outpace, 0, abi.encodePacked(CHANNEL_OPEN_SELECTOR, op.data));\r\n\t\t\t} else if (op.mode == RoutineOp.Withdraw) {\r\n\t\t\t\t// Withdraw from identity\r\n\t\t\t\t(address tokenAddr, address to, uint amount) = abi.decode(op.data, (address, address, uint));\r\n\t\t\t\trequire(privileges[to] >= uint8(PrivilegeLevel.WithdrawTo), 'INSUFFICIENT_PRIVILEGE_WITHDRAW');\r\n\t\t\t\tSafeERC20.transfer(tokenAddr, to, amount);\r\n\t\t\t} else {\r\n\t\t\t\trevert('INVALID_MODE');\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (auth.weeklyFeeAmount > 0 && (now - routinePaidFees[hash]) >= 7 days) {\r\n\t\t\troutinePaidFees[hash] = now;\r\n\t\t\tSafeERC20.transfer(auth.feeTokenAddr, msg.sender, auth.weeklyFeeAmount);\r\n\t\t}\r\n\t}\r\n\r\n\t// we shouldn't use address.call(), cause: https://github.com/ethereum/solidity/issues/2884\r\n\t// copied from https://github.com/uport-project/uport-identity/blob/develop/contracts/Proxy.sol\r\n\t// there's also\r\n\t// https://github.com/gnosis/MultiSigWallet/commit/e1b25e8632ca28e9e9e09c81bd20bf33fdb405ce\r\n\t// https://github.com/austintgriffith/bouncer-proxy/blob/master/BouncerProxy/BouncerProxy.sol\r\n\t// https://github.com/gnosis/safe-contracts/blob/7e2eeb3328bb2ae85c36bc11ea6afc14baeb663c/contracts/base/Executor.sol\r\n\tfunction executeCall(address to, uint256 value, bytes memory data)\r\n\t\tinternal\r\n\t{\r\n\t\tassembly {\r\n\t\t\tlet result := call(gas, to, value, add(data, 0x20), mload(data), 0, 0)\r\n\r\n\t\t\tswitch result case 0 {\r\n\t\t\t\tlet size := returndatasize\r\n\t\t\t\tlet ptr := mload(0x40)\r\n\t\t\t\treturndatacopy(ptr, 0, size)\r\n\t\t\t\trevert(ptr, size)\r\n\t\t\t}\r\n\t\t\tdefault {}\r\n\t\t}\r\n\t}\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"components\":[{\"name\":\"relayer\",\"type\":\"address\"},{\"name\":\"outpace\",\"type\":\"address\"},{\"name\":\"registry\",\"type\":\"address\"},{\"name\":\"validUntil\",\"type\":\"uint256\"},{\"name\":\"feeTokenAddr\",\"type\":\"address\"},{\"name\":\"weeklyFeeAmount\",\"type\":\"uint256\"}],\"name\":\"auth\",\"type\":\"tuple\"},{\"components\":[{\"name\":\"mode\",\"type\":\"uint8\"},{\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"operations\",\"type\":\"tuple[]\"}],\"name\":\"executeRoutines\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"privLevel\",\"type\":\"uint8\"}],\"name\":\"setAddrPrivilege\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"components\":[{\"name\":\"identityContract\",\"type\":\"address\"},{\"name\":\"nonce\",\"type\":\"uint256\"},{\"name\":\"feeTokenAddr\",\"type\":\"address\"},{\"name\":\"feeAmount\",\"type\":\"uint256\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"txns\",\"type\":\"tuple[]\"},{\"name\":\"signatures\",\"type\":\"bytes32[3][]\"}],\"name\":\"execute\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"components\":[{\"name\":\"identityContract\",\"type\":\"address\"},{\"name\":\"nonce\",\"type\":\"uint256\"},{\"name\":\"feeTokenAddr\",\"type\":\"address\"},{\"name\":\"feeAmount\",\"type\":\"uint256\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"txns\",\"type\":\"tuple[]\"}],\"name\":\"executeBySender\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"routinePaidFees\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nonce\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"hash\",\"type\":\"bytes32\"},{\"name\":\"authorized\",\"type\":\"bool\"}],\"name\":\"setRoutineAuth\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"privileges\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"routineAuthorizations\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"addrs\",\"type\":\"address[]\"},{\"name\":\"privLevels\",\"type\":\"uint8[]\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"privLevel\",\"type\":\"uint8\"}],\"name\":\"LogPrivilegeChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"hash\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"authorized\",\"type\":\"bool\"}],\"name\":\"LogRoutineAuth\",\"type\":\"event\"}]","ContractName":"Identity","CompilerVersion":"v0.5.6+commit.b259423e","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"0000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000","Library":"","SwarmSource":"bzzr://eafd1115ef2e313f1326ee058efe806f8e32388ce616c0e80b8fb661edc69f6d"}]}