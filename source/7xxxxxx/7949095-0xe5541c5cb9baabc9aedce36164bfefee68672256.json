{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n \r\n\r\n//\r\n//                       .#########'\r\n//                    .###############+\r\n//                  ,####################\r\n//                `#######################+\r\n//               ;##########################\r\n//              #############################.\r\n//             ###############################,\r\n//           +##################,    ###########`\r\n//          .###################     .###########\r\n//         ##############,          .###########+\r\n//         #############`            .############`\r\n//         ###########+                ############\r\n//        ###########;                  ###########\r\n//        ##########'                    ###########\r\n//       '##########    '#.        `,     ##########\r\n//       ##########    ####'      ####.   :#########;\r\n//      `#########'   :#####;    ######    ##########\r\n//      :#########    #######:  #######    :#########\r\n//      +#########    :#######.########     #########`\r\n//      #########;     ###############'     #########:\r\n//      #########       #############+      '########'\r\n//      #########        ############       :#########\r\n//      #########         ##########        ,#########\r\n//      #########         :########         ,#########\r\n//      #########        ,##########        ,#########\r\n//      #########       ,############       :########+\r\n//      #########      .#############+      '########'\r\n//      #########:    `###############'     #########,\r\n//      +########+    ;#######`;#######     #########\r\n//      ,#########    '######`  '######    :#########\r\n//       #########;   .#####`    '#####    ##########\r\n//       ##########    '###`      +###    :#########:\r\n//       ;#########+     `                ##########\r\n//        ##########,                    ###########\r\n//         ###########;                ############\r\n//         +############             .############`\r\n//          ###########+           ,#############;\r\n//          `###########     ;++#################\r\n//           :##########,    ###################\r\n//            '###########.'###################\r\n//             +##############################\r\n//              '############################`\r\n//               .##########################\r\n//                 #######################:\r\n//                   ###################+\r\n//                     +##############:\r\n//                        :#######+`\r\n//\r\n//\r\n//\r\n// Play0x.com (The ONLY gaming platform for all ERC20 Tokens)\r\n// -------------------------------------------------------------------------------------------------------\r\n// * Multiple types of game platforms\r\n// * Build your own game zone - Not only playing games, but also allowing other players to join your game.\r\n// * Support all ERC20 tokens.\r\n//\r\n//\r\n//\r\n// 0xC Token (Contract address : 0x60d8234a662651e586173c17eb45ca9833a7aa6c)\r\n// -------------------------------------------------------------------------------------------------------\r\n// * 0xC Token is an ERC20 Token specifically for digital entertainment.\r\n// * No ICO and private sales,fair access.\r\n// * There will be hundreds of games using 0xC as a game token.\r\n// * Token holders can permanently get ETH's profit sharing.\r\n//\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, reverts on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    uint256 c = a * b;\r\n    require(c / a == b);\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b > 0); // Solidity only automatically asserts when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b <= a);\r\n    uint256 c = a - b;\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, reverts on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    require(c >= a);\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\r\n  * reverts when dividing by zero.\r\n  */\r\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b != 0);\r\n    return a % b;\r\n  }\r\n}\r\n\r\n/**\r\n* @title ERC20 interface\r\n* @dev see https://github.com/ethereum/EIPs/issues/20\r\n*/\r\ncontract ERC20 {\r\n    function approve(address _spender, uint256 _value) public returns (bool success);\r\n    function allowance(address owner, address spender) public constant returns (uint256);\r\n    function balanceOf(address who) public constant returns  (uint256);\r\n    function transferFrom(address from, address to, uint256 value) public returns (bool);\r\n    function transfer(address _to, uint256 _value) public;\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}\r\n\r\ncontract Play0x_LottoBall {\r\n\r\n    using SafeMath for uint256;\r\n    using SafeMath for uint128;\r\n    using SafeMath for uint40;\r\n    using SafeMath for uint8;\r\n\r\n    uint public jackpotSize;\r\n\r\n    uint public MIN_BET;\r\n    uint public MAX_BET;\r\n    uint public MAX_AMOUNT;\r\n    uint constant MAX_MODULO = 15;\r\n\r\n    //Adjustable max bet profit.\r\n    uint public maxProfit; \r\n\r\n    //Fee percentage\r\n    uint8 public platformFeePercentage = 15;\r\n    uint8 public jackpotFeePercentage = 5;\r\n    uint8 public ERC20rewardMultiple = 5;\r\n    \r\n    //0:ether 1:token\r\n    uint8 public currencyType = 0;\r\n\r\n    //Bets can be refunded via invoking refundBet.\r\n    uint constant BetExpirationBlocks = 250;\r\n\r\n    //Funds that are locked in potentially winning bets.\r\n    uint public lockedInBets; \r\n\r\n    //Standard contract ownership transfer.\r\n    address public owner;\r\n    address private nextOwner; \r\n    address public secretSigner;\r\n    address public refunder; \r\n\r\n    //The address corresponding to a private key used to sign placeBet commits. \r\n    address public ERC20ContractAddres;\r\n    \r\n    address constant DUMMY_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\r\n\r\n    //Single bet.\r\n    struct Bet {\r\n        //Amount in wei.\r\n        uint amount;\r\n        //place tx Block number.\r\n        uint40 placeBlockNumber;\r\n        // Address of a gambler.\r\n        address gambler;  \r\n        // Game mode.\r\n        uint8 machineMode; \r\n        // Number of draws\r\n        uint8 rotateTime;\r\n    }\r\n\r\n    //Mapping from commits\r\n    mapping (uint => Bet) public bets;\r\n\r\n    //Mapping from signer\r\n    mapping(address => bool) public signerList;\r\n    \r\n    //Mapping from withdrawal\r\n    mapping(uint8 => uint32) public withdrawalMode;\r\n     \r\n    //Admin Payment\r\n    event ToManagerPayment(address indexed beneficiary, uint amount);\r\n    event ToManagerFailedPayment(address indexed beneficiary, uint amount);\r\n    event ToOwnerPayment(address indexed beneficiary, uint amount);\r\n    event ToOwnerFailedPayment(address indexed beneficiary, uint amount);\r\n\r\n    //Bet Payment\r\n    event Payment(address indexed beneficiary, uint amount);\r\n    event AllFundsPayment(address indexed beneficiary, uint amount);\r\n    event AllTokenPayment(address indexed beneficiary, uint amount);\r\n    event FailedPayment(address indexed beneficiary, uint amount);\r\n    event TokenPayment(address indexed beneficiary, uint amount);\r\n\r\n    //JACKPOT\r\n    event JackpotBouns(address indexed beneficiary, uint amount);\r\n\r\n    // Events that are issued to make statistic recovery easier.\r\n    event PlaceBetLog(address indexed player, uint amount,uint8 rotateTime,uint commit);\r\n\r\n    //Play0x_LottoBall_Event\r\n    event BetRelatedData(\r\n        address indexed player,\r\n        uint playerBetAmount,\r\n        uint playerGetAmount,\r\n        bytes32 entropy, \r\n        uint8 rotateTime\r\n    );\r\n    \r\n    //Refund_Event\r\n    event RefundLog(address indexed player, uint commit, uint amount);\r\n \r\n    // Constructor. Deliberately does not take any parameters.\r\n    constructor () public {\r\n        owner = msg.sender;\r\n        secretSigner = DUMMY_ADDRESS; \r\n        ERC20ContractAddres = DUMMY_ADDRESS; \r\n        refunder = DUMMY_ADDRESS; \r\n    }\r\n\r\n    // Standard modifier on methods invokable only by contract owner.\r\n    modifier onlyOwner {\r\n        require (msg.sender == owner);\r\n        _;\r\n    }\r\n    \r\n    modifier onlyRefunder {\r\n        require (msg.sender == refunder);\r\n        _;\r\n    } \r\n    \r\n    modifier onlySigner {\r\n        require (signerList[msg.sender] == true); \r\n        _;\r\n    }\r\n    \r\n    //Init Parameter.\r\n    function initialParameter(\r\n        // address _manager,\r\n        address _secretSigner,\r\n        address _erc20tokenAddress ,\r\n        address _refunder,\r\n        \r\n        uint _MIN_BET,\r\n        uint _MAX_BET,\r\n        uint _maxProfit, \r\n        uint _MAX_AMOUNT, \r\n        \r\n        uint8 _platformFeePercentage,\r\n        uint8 _jackpotFeePercentage,\r\n        uint8 _ERC20rewardMultiple,\r\n        uint8 _currencyType,\r\n        \r\n        address[] _signerList,\r\n        uint32[] _withdrawalMode)public onlyOwner{\r\n            \r\n        secretSigner = _secretSigner;\r\n        ERC20ContractAddres = _erc20tokenAddress;\r\n        refunder = _refunder; \r\n        \r\n        MIN_BET = _MIN_BET;\r\n        MAX_BET = _MAX_BET;\r\n        maxProfit = _maxProfit; \r\n        MAX_AMOUNT = _MAX_AMOUNT;\r\n        \r\n        platformFeePercentage = _platformFeePercentage;\r\n        jackpotFeePercentage = _jackpotFeePercentage;\r\n        ERC20rewardMultiple = _ERC20rewardMultiple;\r\n        currencyType = _currencyType;\r\n        \r\n        createSignerList(_signerList);\r\n        createWithdrawalMode(_withdrawalMode); \r\n    }\r\n \r\n    // Standard contract ownership transfer implementation,\r\n    function approveNextOwner(address _nextOwner) public onlyOwner {\r\n        require (_nextOwner != owner);\r\n        nextOwner = _nextOwner;\r\n    }\r\n\r\n    function acceptNextOwner() public {\r\n        require (msg.sender == nextOwner);\r\n        owner = nextOwner;\r\n    }\r\n\r\n    // Fallback function deliberately left empty.\r\n    function () public payable {\r\n    }\r\n   \r\n    //Creat SignerList.\r\n    function createSignerList(address[] _signerList)private onlyOwner  {\r\n        for (uint i=0; i<_signerList.length; i++) {\r\n            address newSigner = _signerList[i];\r\n            signerList[newSigner] = true; \r\n        } \r\n    }\r\n     \r\n    //Creat WithdrawalMode.\r\n    function createWithdrawalMode(uint32[] _withdrawalMode)private onlyOwner {\r\n        for (uint8 i=0; i<_withdrawalMode.length; i++) {\r\n            uint32 newWithdrawalMode = _withdrawalMode[i];\r\n            uint8 mode = i + 1;\r\n            withdrawalMode[mode] = newWithdrawalMode;\r\n        } \r\n    }\r\n     \r\n    //Set SecretSigner.\r\n    function setSecretSigner(address _secretSigner) external onlyOwner {\r\n        secretSigner = _secretSigner;\r\n    } \r\n    \r\n    //Set settle signer.\r\n    function setSigner(address signer,bool isActive )external onlyOwner{\r\n        signerList[signer] = isActive; \r\n    } \r\n    \r\n    //Set Refunder.\r\n    function setRefunder(address _refunder) external onlyOwner {\r\n        refunder = _refunder;\r\n    } \r\n     \r\n    //Set tokenAddress.\r\n    function setTokenAddress(address _tokenAddress) external onlyOwner {\r\n        ERC20ContractAddres = _tokenAddress;\r\n    }\r\n \r\n    // Change max bet reward. Setting this to zero effectively disables betting.\r\n    function setMaxProfit(uint _maxProfit) external onlyOwner {\r\n        require (_maxProfit < MAX_AMOUNT && _maxProfit > 0);\r\n        maxProfit = _maxProfit;\r\n    }\r\n\r\n    // Funds withdrawal.\r\n    function withdrawFunds(address beneficiary, uint withdrawAmount) external onlyOwner {\r\n        require (withdrawAmount <= address(this).balance && withdrawAmount > 0);\r\n\r\n        uint safetyAmount = jackpotSize.add(lockedInBets).add(withdrawAmount);\r\n        safetyAmount = safetyAmount.add(withdrawAmount);\r\n\r\n        require (safetyAmount <= address(this).balance);\r\n        sendFunds(beneficiary, withdrawAmount );\r\n    }\r\n\r\n    // Token withdrawal.\r\n    function withdrawToken(address beneficiary, uint withdrawAmount) external onlyOwner {\r\n        require (withdrawAmount <= ERC20(ERC20ContractAddres).balanceOf(address(this)));\r\n\r\n        uint safetyAmount = jackpotSize.add(lockedInBets);\r\n        safetyAmount = safetyAmount.add(withdrawAmount);\r\n        require (safetyAmount <= ERC20(ERC20ContractAddres).balanceOf(address(this)));\r\n\r\n         ERC20(ERC20ContractAddres).transfer(beneficiary, withdrawAmount);\r\n         emit TokenPayment(beneficiary, withdrawAmount);\r\n    }\r\n\r\n    //Recovery of funds\r\n    function withdrawAllFunds(address beneficiary) external onlyOwner {\r\n        if (beneficiary.send(address(this).balance)) {\r\n            lockedInBets = 0;\r\n            jackpotSize = 0;\r\n            emit AllFundsPayment(beneficiary, address(this).balance);\r\n        } else {\r\n            emit FailedPayment(beneficiary, address(this).balance);\r\n        }\r\n    }\r\n\r\n    //Recovery of Token funds\r\n    function withdrawAlltokenFunds(address beneficiary) external onlyOwner {\r\n        ERC20(ERC20ContractAddres).transfer(beneficiary, ERC20(ERC20ContractAddres).balanceOf(address(this)));\r\n        lockedInBets = 0;\r\n        jackpotSize = 0;\r\n        emit AllTokenPayment(beneficiary, ERC20(ERC20ContractAddres).balanceOf(address(this)));\r\n    }\r\n\r\n    // Contract may be destroyed only when there are no ongoing bets,\r\n    // either settled or refunded. All funds are transferred to contract owner.\r\n    function kill() external onlyOwner {\r\n        require (lockedInBets == 0); \r\n        selfdestruct(owner);\r\n    }\r\n\r\n    function getContractInformation()public view returns(\r\n        uint _jackpotSize, \r\n        uint _MIN_BET,\r\n        uint _MAX_BET,\r\n        uint _MAX_AMOUNT,\r\n        uint8 _platformFeePercentage,\r\n        uint8 _jackpotFeePercentage,\r\n        uint _maxProfit, \r\n        uint _lockedInBets){\r\n\r\n        _jackpotSize = jackpotSize; \r\n        _MIN_BET = MIN_BET;\r\n        _MAX_BET = MAX_BET;\r\n        _MAX_AMOUNT = MAX_AMOUNT;\r\n        _platformFeePercentage = platformFeePercentage;\r\n        _jackpotFeePercentage = jackpotFeePercentage;\r\n        _maxProfit = maxProfit; \r\n        _lockedInBets = lockedInBets;  \r\n    }\r\n\r\n    function getContractAddress()public view returns(\r\n        address _owner, \r\n        address _ERC20ContractAddres,\r\n        address _secretSigner,\r\n        address _refunder ){\r\n\r\n        _owner = owner; \r\n        _ERC20ContractAddres = ERC20ContractAddres;\r\n        _secretSigner = secretSigner;  \r\n        _refunder = refunder; \r\n    } \r\n \r\n    //Bet by ether: Commits are signed with a block limit to ensure that they are used at most once.\r\n    function placeBet(uint8 _rotateTime , uint8 _machineMode , uint _commitLastBlock, uint _commit, bytes32 r, bytes32 s ) external payable {\r\n         \r\n        // Check that the bet is in 'clean' state.\r\n        Bet storage bet = bets[_commit];\r\n        require (bet.gambler == address(0));\r\n        \r\n        //Check SecretSigner.\r\n        bytes32 signatureHash = keccak256(abi.encodePacked(_commitLastBlock, _commit));\r\n        require (secretSigner == ecrecover(signatureHash, 27, r, s));\r\n        \r\n        //Check rotateTime ,machineMode and commitLastBlock.\r\n        require (_rotateTime > 0 && _rotateTime <= 20); \r\n        \r\n        //_machineMode: 1~15\r\n        require (_machineMode > 0 && _machineMode <= MAX_MODULO);\r\n        \r\n        require (block.number < _commitLastBlock );\r\n         \r\n        lockedInBets = lockedInBets.add( getPossibleWinPrize(withdrawalMode[_machineMode],msg.value) );\r\n        \r\n        //Check the highest profit\r\n        require (getPossibleWinPrize(withdrawalMode[_machineMode],msg.value) <= maxProfit && getPossibleWinPrize(withdrawalMode[_machineMode],msg.value) > 0);\r\n        require (lockedInBets.add(jackpotSize) <= address(this).balance);\r\n \r\n        //Amount should be within range\r\n        require (msg.value >= MIN_BET && msg.value <= MAX_BET);\r\n        \r\n        emit PlaceBetLog(msg.sender, msg.value,_rotateTime,_commit);\r\n          \r\n        // Store bet parameters on blockchain.\r\n        bet.amount = msg.value;\r\n        bet.placeBlockNumber = uint40(block.number);\r\n        bet.gambler = msg.sender;  \r\n        bet.machineMode = uint8(_machineMode);  \r\n        bet.rotateTime = uint8(_rotateTime);  \r\n    }\r\n\r\n    function placeTokenBet(uint8 _rotateTime , uint8 _machineMode , uint _commitLastBlock, uint _commit, bytes32 r, bytes32 s, uint _amount, address _playerAddress) external onlySigner {\r\n        \r\n        // Check that the bet is in 'clean' state.\r\n        Bet storage bet = bets[_commit];\r\n        require (bet.gambler == address(0));\r\n        \r\n        //Check SecretSigner.\r\n        bytes32 signatureHash = keccak256(abi.encodePacked(_commitLastBlock, _commit));\r\n        require (secretSigner == ecrecover(signatureHash, 27, r, s));\r\n        \r\n        //Check rotateTime ,machineMode and commitLastBlock.\r\n        require (_rotateTime > 0 && _rotateTime <= 20); \r\n         \r\n        //_machineMode: 1~15\r\n        require (_machineMode > 0 && _machineMode <= MAX_MODULO); \r\n        \r\n        require (block.number < _commitLastBlock ); \r\n        \r\n        //Token lockedInBets \r\n        lockedInBets = lockedInBets.add(getPossibleWinPrize(withdrawalMode[_machineMode],_amount));\r\n        \r\n        //Check the highest profit\r\n        require (getPossibleWinPrize(withdrawalMode[_machineMode],_amount) <= maxProfit && getPossibleWinPrize(withdrawalMode[_machineMode],_amount) > 0);\r\n        require (lockedInBets.add(jackpotSize) <= ERC20(ERC20ContractAddres).balanceOf(address(this)));\r\n  \r\n        //Amount should be within range\r\n        require (_amount >= MIN_BET && _amount <= MAX_BET);\r\n        \r\n        emit PlaceBetLog(_playerAddress, _amount, _rotateTime,_commit);\r\n        \r\n        // Store bet parameters on blockchain.\r\n        bet.amount = _amount;\r\n        bet.placeBlockNumber = uint40(block.number);\r\n        bet.gambler = _playerAddress;  \r\n        bet.machineMode = _machineMode;\r\n        bet.rotateTime = _rotateTime;\r\n    }\r\n \r\n    function settleBet(bytes32 luckySeed,uint reveal, bytes32 blockHash ) external onlySigner{ \r\n          \r\n        // \"commit\" for bet settlement can only be obtained by hashing a \"reveal\".\r\n        uint commit = uint(keccak256(abi.encodePacked(reveal)));\r\n\r\n        // Fetch bet parameters into local variables (to save gas).\r\n        Bet storage bet = bets[commit];\r\n        \r\n        // Check that bet is in 'active' state and check that bet has not expired yet.\r\n        require (bet.amount != 0); \r\n        require (bet.rotateTime > 0 && bet.rotateTime <= 20); \r\n        require (bet.machineMode > 0 && bet.machineMode <= MAX_MODULO); \r\n        require (block.number > bet.placeBlockNumber);\r\n        require (block.number <= bet.placeBlockNumber.add(BetExpirationBlocks));\r\n        require (blockhash(bet.placeBlockNumber) == blockHash);\r\n \r\n        //check possibleWinAmount   \r\n        require (getPossibleWinPrize(withdrawalMode[bet.machineMode],bet.amount) < maxProfit); \r\n         \r\n        require (luckySeed > 0); \r\n\r\n        //The RNG - combine \"reveal\" and blockhash of LuckySeed using Keccak256.\r\n        bytes32 _entropy = keccak256(\r\n            abi.encodePacked(\r\n                uint(\r\n                    keccak256(\r\n                        abi.encodePacked(\r\n                            reveal,\r\n                            luckySeed\r\n                        )\r\n                    )\r\n                ),\r\n                blockHash\r\n            )\r\n        );\r\n        \r\n        //Player profit\r\n        uint totalAmount = 0;\r\n        \r\n        //Player Token profit\r\n        uint totalTokenAmount = 0;\r\n        \r\n        //Jackpot check default value\r\n        bool isGetJackpot = false; \r\n        \r\n        //Settlement record\r\n        bytes32 tmp_entropy = _entropy; \r\n        \r\n        //Billing mode\r\n        uint8 machineMode = bet.machineMode; \r\n        \r\n        for (uint8 i = 0; i < bet.rotateTime; i++) {\r\n            \r\n            //every round result\r\n            bool isWinThisRound = false;\r\n            \r\n            //Random number of must be less than the machineMode\r\n            assembly {   \r\n                switch gt(machineMode,and(tmp_entropy, 0xf))\r\n                case 1 {\r\n                    isWinThisRound := 1\r\n                }\r\n            }\r\n\r\n            if (isWinThisRound == true ){\r\n                //bet win, get single round bonus\r\n                totalAmount = totalAmount.add(getPossibleWinPrize(withdrawalMode[bet.machineMode],bet.amount).div(bet.rotateTime));\r\n\r\n                //Platform fee determination:Ether Game Winning players must pay platform fees \r\n                totalAmount = totalAmount.sub( \r\n                        (\r\n                            (\r\n                                bet.amount.div(bet.rotateTime)\r\n                            ).mul(platformFeePercentage)\r\n                        ).div(1000) \r\n                    );\r\n            }else if ( isWinThisRound == false && currencyType == 0 && ERC20(ERC20ContractAddres).balanceOf(address(this)) > 0){\r\n                //Ether game lose, get token reward \r\n                 totalTokenAmount = totalTokenAmount.add(bet.amount.div(bet.rotateTime).mul(ERC20rewardMultiple));\r\n            }\r\n\r\n            //Get jackpotWin Result, only one chance to win Jackpot in each game.\r\n            if (isGetJackpot == false){ \r\n                //getJackpotWinBonus\r\n                assembly { \r\n                    let buf := and(tmp_entropy, 0xffff)  \r\n                    switch buf\r\n                    case 0xffff {\r\n                        isGetJackpot := 1\r\n                    }\r\n                }\r\n            }\r\n            \r\n            //This round is settled, shift settlement record.\r\n            tmp_entropy = tmp_entropy >> 4;\r\n        } \r\n         \r\n        //Player get Jackpot \r\n        if (isGetJackpot == true ) { \r\n            emit JackpotBouns(bet.gambler,jackpotSize);\r\n            \r\n            totalAmount = totalAmount.add(jackpotSize);\r\n            jackpotSize = 0; \r\n        } \r\n \r\n        if (currencyType == 0) {\r\n            //Ether game\r\n            if (totalAmount != 0 && totalAmount < maxProfit){\r\n                sendFunds(bet.gambler, totalAmount );\r\n            }\r\n\r\n            //Send ERC20 Token\r\n            if (totalTokenAmount != 0){ \r\n                \r\n                if(ERC20(ERC20ContractAddres).balanceOf(address(this)) > 0){\r\n                    ERC20(ERC20ContractAddres).transfer(bet.gambler, totalTokenAmount);\r\n                    emit TokenPayment(bet.gambler, totalTokenAmount);\r\n                }\r\n            }\r\n        }else if(currencyType == 1){\r\n            //ERC20 game\r\n\r\n            //Send ERC20 Token\r\n            if (totalAmount != 0 && totalAmount < maxProfit){\r\n                if(ERC20(ERC20ContractAddres).balanceOf(address(this)) > 0){\r\n                    ERC20(ERC20ContractAddres).transfer(bet.gambler, totalAmount);\r\n                    emit TokenPayment(bet.gambler, totalAmount);\r\n                }\r\n            }\r\n        }\r\n\r\n        //Unlock the bet amount, regardless of the outcome.\r\n        lockedInBets = lockedInBets.sub(getPossibleWinPrize(withdrawalMode[bet.machineMode],bet.amount));\r\n\r\n  \r\n        //Save jackpotSize\r\n        jackpotSize = jackpotSize.add(bet.amount.mul(jackpotFeePercentage).div(1000));\r\n         \r\n        emit BetRelatedData(\r\n            bet.gambler,\r\n            bet.amount,\r\n            totalAmount,\r\n            _entropy, \r\n            bet.rotateTime\r\n        );\r\n        \r\n        //Move bet into 'processed' state already.\r\n        bet.amount = 0;\r\n    }\r\n\r\n    function runRotateTime (Bet storage bet, bytes32 _entropy )private view returns(uint totalAmount, uint totalTokenAmount, bool isGetJackpot ) {\r\n           \r\n        bytes32 tmp_entropy = _entropy; \r\n \r\n        isGetJackpot = false;\r\n        \r\n        uint8 machineMode = bet.machineMode;\r\n        \r\n        for (uint8 i = 0; i < bet.rotateTime; i++) {\r\n            \r\n            //every round result\r\n            bool isWinThisRound = false;\r\n            \r\n            //Random number of must be less than the machineMode\r\n            assembly {   \r\n                switch gt(machineMode,and(tmp_entropy, 0xf))\r\n                case 1 {\r\n                    isWinThisRound := 1\r\n                }\r\n            }\r\n\r\n            if (isWinThisRound == true ){\r\n                //bet win, get single round bonus\r\n                totalAmount = totalAmount.add(getPossibleWinPrize(withdrawalMode[bet.machineMode],bet.amount).div(bet.rotateTime));\r\n\r\n                //Platform fee determination:Ether Game Winning players must pay platform fees \r\n                totalAmount = totalAmount.sub( \r\n                        (\r\n                            (\r\n                                bet.amount.div(bet.rotateTime)\r\n                            ).mul(platformFeePercentage)\r\n                        ).div(1000) \r\n                    );\r\n            }else if ( isWinThisRound == false && currencyType == 0 && ERC20(ERC20ContractAddres).balanceOf(address(this)) > 0){\r\n                //Ether game lose, get token reward \r\n                 totalTokenAmount = totalTokenAmount.add(bet.amount.div(bet.rotateTime).mul(ERC20rewardMultiple));\r\n            }\r\n\r\n            //Get jackpotWin Result, only one chance to win Jackpot in each game.\r\n            if (isGetJackpot == false){ \r\n                //getJackpotWinBonus\r\n                assembly { \r\n                    let buf := and(tmp_entropy, 0xffff)  \r\n                    switch buf\r\n                    case 0xffff {\r\n                        isGetJackpot := 1\r\n                    }\r\n                }\r\n            } \r\n            //This round is settled, shift settlement record.\r\n            tmp_entropy = tmp_entropy >> 4;\r\n        } \r\n\r\n        if (isGetJackpot == true ) { \r\n            //gambler get jackpot. \r\n            totalAmount = totalAmount.add(jackpotSize); \r\n        }\r\n    }\r\n \r\n    //Get deductedBalance\r\n    function getPossibleWinPrize(uint bonusPercentage,uint senderValue)public pure returns (uint possibleWinAmount) { \r\n        //Win Amount  \r\n        possibleWinAmount = ((senderValue.mul(bonusPercentage))).div(10000);\r\n    }\r\n    \r\n    //Get deductedBalance\r\n    function getPossibleWinAmount(uint bonusPercentage,uint senderValue)public view returns (uint platformFee,uint jackpotFee,uint possibleWinAmount) {\r\n\r\n        //Platform Fee\r\n        uint prePlatformFee = (senderValue).mul(platformFeePercentage);\r\n        platformFee = (prePlatformFee).div(1000);\r\n\r\n        //Get jackpotFee\r\n        uint preJackpotFee = (senderValue).mul(jackpotFeePercentage);\r\n        jackpotFee = (preJackpotFee).div(1000);\r\n\r\n        //Win Amount\r\n        uint preUserGetAmount = senderValue.mul(bonusPercentage);\r\n        possibleWinAmount = preUserGetAmount.div(10000);\r\n    }\r\n\r\n    function settleBetVerifi(bytes32 luckySeed,uint reveal,bytes32 blockHash  )external view onlySigner returns(uint totalAmount,uint totalTokenAmount,bytes32 _entropy,bool isGetJackpot ) {\r\n        \r\n        // \"commit\" for bet settlement can only be obtained by hashing a \"reveal\".\r\n        uint commit = uint(keccak256(abi.encodePacked(reveal)));\r\n\r\n        // Fetch bet parameters into local variables (to save gas).\r\n        Bet storage bet = bets[commit];\r\n         \r\n        //The RNG - combine \"reveal\" and blockhash of LuckySeed using Keccak256.\r\n        _entropy = keccak256(\r\n            abi.encodePacked(\r\n                uint(\r\n                    keccak256(\r\n                        abi.encodePacked(\r\n                                reveal,\r\n                                luckySeed\r\n                            )\r\n                        )\r\n                    ),\r\n                blockHash\r\n            )\r\n        );\r\n        \r\n        isGetJackpot = false;\r\n        (totalAmount,totalTokenAmount,isGetJackpot) = runRotateTime( \r\n            bet,\r\n            _entropy \r\n        ); \r\n    }\r\n\r\n    // Refund transaction\r\n    function refundBet(uint commit) external onlyRefunder{\r\n        // Check that bet is in 'active' state.\r\n        Bet storage bet = bets[commit];\r\n        uint amount = bet.amount; \r\n        uint8 machineMode = bet.machineMode; \r\n        \r\n        require (amount != 0, \"Bet should be in an 'active' state\");\r\n\r\n        // Check that bet has already expired.\r\n        require (block.number > bet.placeBlockNumber.add(BetExpirationBlocks));\r\n  \r\n        //Amount unlock\r\n        lockedInBets = lockedInBets.sub(getPossibleWinPrize(withdrawalMode[machineMode],bet.amount));\r\n \r\n        //Refund\r\n        emit RefundLog(bet.gambler,commit, amount); \r\n        sendFunds(bet.gambler, amount );\r\n        \r\n        // Move bet into 'processed' state, release funds.\r\n        bet.amount = 0;\r\n    }\r\n\r\n    function refundTokenBet(uint commit) external onlyRefunder{\r\n        // Check that bet is in 'active' state.\r\n        Bet storage bet = bets[commit];\r\n        uint amount = bet.amount;\r\n        uint8 machineMode = bet.machineMode; \r\n\r\n        require (amount != 0, \"Bet should be in an 'active' state\");\r\n\r\n        // Check that bet has already expired.\r\n        require (block.number > bet.placeBlockNumber.add(BetExpirationBlocks));\r\n \r\n        //Amount unlock\r\n        lockedInBets = lockedInBets.sub(getPossibleWinPrize(withdrawalMode[machineMode],bet.amount));\r\n\r\n        emit RefundLog(bet.gambler,commit, amount); \r\n         \r\n        //Refund\r\n        emit TokenPayment(bet.gambler, amount);\r\n        ERC20(ERC20ContractAddres).transfer(bet.gambler, amount);\r\n         \r\n        // Move bet into 'processed' state, release funds.\r\n        bet.amount = 0;\r\n    }\r\n\r\n    // A helper routine to bulk clean the storage.\r\n    function clearStorage(uint[] cleanCommits) external onlyRefunder {\r\n        uint length = cleanCommits.length;\r\n\r\n        for (uint i = 0; i < length; i++) {\r\n            clearProcessedBet(cleanCommits[i]);\r\n        }\r\n    }\r\n\r\n    // Helper routine to move 'processed' bets into 'clean' state.\r\n    function clearProcessedBet(uint commit) private {\r\n        Bet storage bet = bets[commit];\r\n\r\n        // Do not overwrite active bets with zeros\r\n        if (bet.amount != 0 || block.number <= bet.placeBlockNumber + BetExpirationBlocks) {\r\n            return;\r\n        }\r\n\r\n        // Zero out the remaining storage\r\n        bet.placeBlockNumber = 0;\r\n        bet.gambler = address(0);\r\n        bet.machineMode = 0;\r\n        bet.rotateTime = 0; \r\n    }\r\n\r\n    // Helper routine to process the payment.\r\n    function sendFunds(address receiver, uint amount ) private {\r\n        if (receiver.send(amount)) {\r\n            emit Payment(receiver, amount);\r\n        } else {\r\n            emit FailedPayment(receiver, amount);\r\n        }\r\n    } \r\n    \r\n    function sendFundsToOwner(address beneficiary, uint amount) external onlyOwner {\r\n        if (beneficiary.send(amount)) {\r\n            emit ToOwnerPayment(beneficiary, amount);\r\n        } else {\r\n            emit ToOwnerFailedPayment(beneficiary, amount);\r\n        }\r\n    }\r\n\r\n    //Update\r\n    function updateMIN_BET(uint _uintNumber)external onlyOwner {\r\n         MIN_BET = _uintNumber;\r\n    }\r\n\r\n    function updateMAX_BET(uint _uintNumber)external onlyOwner {\r\n         MAX_BET = _uintNumber;\r\n    }\r\n\r\n    function updateMAX_AMOUNT(uint _uintNumber)external onlyOwner {\r\n         MAX_AMOUNT = _uintNumber;\r\n    } \r\n    \r\n    function updateWithdrawalMode(uint8 _mode, uint32 _modeValue) external onlyOwner{\r\n       withdrawalMode[_mode]  = _modeValue;\r\n    } \r\n\r\n    function updatePlatformFeePercentage(uint8 _platformFeePercentage ) external onlyOwner{\r\n       platformFeePercentage = _platformFeePercentage;\r\n    }\r\n\r\n    function updateJackpotFeePercentage(uint8 _jackpotFeePercentage ) external onlyOwner{\r\n       jackpotFeePercentage = _jackpotFeePercentage;\r\n    }\r\n\r\n    function updateERC20rewardMultiple(uint8 _ERC20rewardMultiple ) external onlyOwner{\r\n       ERC20rewardMultiple = _ERC20rewardMultiple;\r\n    }\r\n    \r\n    function updateCurrencyType(uint8 _currencyType ) external onlyOwner{\r\n       currencyType = _currencyType;\r\n    }\r\n    \r\n    function updateJackpot(uint newSize) external onlyOwner {\r\n        require (newSize < address(this).balance && newSize > 0); \r\n        jackpotSize = newSize;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"name\":\"withdrawalMode\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_mode\",\"type\":\"uint8\"},{\"name\":\"_modeValue\",\"type\":\"uint32\"}],\"name\":\"updateWithdrawalMode\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_currencyType\",\"type\":\"uint8\"}],\"name\":\"updateCurrencyType\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"bets\",\"outputs\":[{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"placeBlockNumber\",\"type\":\"uint40\"},{\"name\":\"gambler\",\"type\":\"address\"},{\"name\":\"machineMode\",\"type\":\"uint8\"},{\"name\":\"rotateTime\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenAddress\",\"type\":\"address\"}],\"name\":\"setTokenAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"bonusPercentage\",\"type\":\"uint256\"},{\"name\":\"senderValue\",\"type\":\"uint256\"}],\"name\":\"getPossibleWinAmount\",\"outputs\":[{\"name\":\"platformFee\",\"type\":\"uint256\"},{\"name\":\"jackpotFee\",\"type\":\"uint256\"},{\"name\":\"possibleWinAmount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"signer\",\"type\":\"address\"},{\"name\":\"isActive\",\"type\":\"bool\"}],\"name\":\"setSigner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getContractAddress\",\"outputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_ERC20ContractAddres\",\"type\":\"address\"},{\"name\":\"_secretSigner\",\"type\":\"address\"},{\"name\":\"_refunder\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"beneficiary\",\"type\":\"address\"}],\"name\":\"withdrawAllFunds\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_secretSigner\",\"type\":\"address\"},{\"name\":\"_erc20tokenAddress\",\"type\":\"address\"},{\"name\":\"_refunder\",\"type\":\"address\"},{\"name\":\"_MIN_BET\",\"type\":\"uint256\"},{\"name\":\"_MAX_BET\",\"type\":\"uint256\"},{\"name\":\"_maxProfit\",\"type\":\"uint256\"},{\"name\":\"_MAX_AMOUNT\",\"type\":\"uint256\"},{\"name\":\"_platformFeePercentage\",\"type\":\"uint8\"},{\"name\":\"_jackpotFeePercentage\",\"type\":\"uint8\"},{\"name\":\"_ERC20rewardMultiple\",\"type\":\"uint8\"},{\"name\":\"_currencyType\",\"type\":\"uint8\"},{\"name\":\"_signerList\",\"type\":\"address[]\"},{\"name\":\"_withdrawalMode\",\"type\":\"uint32[]\"}],\"name\":\"initialParameter\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"kill\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ERC20ContractAddres\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"signerList\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"secretSigner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_rotateTime\",\"type\":\"uint8\"},{\"name\":\"_machineMode\",\"type\":\"uint8\"},{\"name\":\"_commitLastBlock\",\"type\":\"uint256\"},{\"name\":\"_commit\",\"type\":\"uint256\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"placeBet\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"jackpotSize\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"luckySeed\",\"type\":\"bytes32\"},{\"name\":\"reveal\",\"type\":\"uint256\"},{\"name\":\"blockHash\",\"type\":\"bytes32\"}],\"name\":\"settleBetVerifi\",\"outputs\":[{\"name\":\"totalAmount\",\"type\":\"uint256\"},{\"name\":\"totalTokenAmount\",\"type\":\"uint256\"},{\"name\":\"_entropy\",\"type\":\"bytes32\"},{\"name\":\"isGetJackpot\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MIN_BET\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ERC20rewardMultiple\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_ERC20rewardMultiple\",\"type\":\"uint8\"}],\"name\":\"updateERC20rewardMultiple\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"beneficiary\",\"type\":\"address\"}],\"name\":\"withdrawAlltokenFunds\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_BET\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"jackpotFeePercentage\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"luckySeed\",\"type\":\"bytes32\"},{\"name\":\"reveal\",\"type\":\"uint256\"},{\"name\":\"blockHash\",\"type\":\"bytes32\"}],\"name\":\"settleBet\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"beneficiary\",\"type\":\"address\"},{\"name\":\"withdrawAmount\",\"type\":\"uint256\"}],\"name\":\"withdrawToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_platformFeePercentage\",\"type\":\"uint8\"}],\"name\":\"updatePlatformFeePercentage\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_jackpotFeePercentage\",\"type\":\"uint8\"}],\"name\":\"updateJackpotFeePercentage\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_uintNumber\",\"type\":\"uint256\"}],\"name\":\"updateMAX_AMOUNT\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxProfit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_uintNumber\",\"type\":\"uint256\"}],\"name\":\"updateMAX_BET\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_uintNumber\",\"type\":\"uint256\"}],\"name\":\"updateMIN_BET\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"beneficiary\",\"type\":\"address\"},{\"name\":\"withdrawAmount\",\"type\":\"uint256\"}],\"name\":\"withdrawFunds\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"platformFeePercentage\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"bonusPercentage\",\"type\":\"uint256\"},{\"name\":\"senderValue\",\"type\":\"uint256\"}],\"name\":\"getPossibleWinPrize\",\"outputs\":[{\"name\":\"possibleWinAmount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptNextOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_rotateTime\",\"type\":\"uint8\"},{\"name\":\"_machineMode\",\"type\":\"uint8\"},{\"name\":\"_commitLastBlock\",\"type\":\"uint256\"},{\"name\":\"_commit\",\"type\":\"uint256\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_playerAddress\",\"type\":\"address\"}],\"name\":\"placeTokenBet\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_AMOUNT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_nextOwner\",\"type\":\"address\"}],\"name\":\"approveNextOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_secretSigner\",\"type\":\"address\"}],\"name\":\"setSecretSigner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_refunder\",\"type\":\"address\"}],\"name\":\"setRefunder\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"commit\",\"type\":\"uint256\"}],\"name\":\"refundTokenBet\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"refunder\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lockedInBets\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"commit\",\"type\":\"uint256\"}],\"name\":\"refundBet\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"beneficiary\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"sendFundsToOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currencyType\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"cleanCommits\",\"type\":\"uint256[]\"}],\"name\":\"clearStorage\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getContractInformation\",\"outputs\":[{\"name\":\"_jackpotSize\",\"type\":\"uint256\"},{\"name\":\"_MIN_BET\",\"type\":\"uint256\"},{\"name\":\"_MAX_BET\",\"type\":\"uint256\"},{\"name\":\"_MAX_AMOUNT\",\"type\":\"uint256\"},{\"name\":\"_platformFeePercentage\",\"type\":\"uint8\"},{\"name\":\"_jackpotFeePercentage\",\"type\":\"uint8\"},{\"name\":\"_maxProfit\",\"type\":\"uint256\"},{\"name\":\"_lockedInBets\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newSize\",\"type\":\"uint256\"}],\"name\":\"updateJackpot\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_maxProfit\",\"type\":\"uint256\"}],\"name\":\"setMaxProfit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ToManagerPayment\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ToManagerFailedPayment\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ToOwnerPayment\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ToOwnerFailedPayment\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Payment\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"AllFundsPayment\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"AllTokenPayment\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"FailedPayment\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TokenPayment\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"JackpotBouns\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"player\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"rotateTime\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"commit\",\"type\":\"uint256\"}],\"name\":\"PlaceBetLog\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"player\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"playerBetAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"playerGetAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"entropy\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"rotateTime\",\"type\":\"uint8\"}],\"name\":\"BetRelatedData\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"player\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"commit\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"RefundLog\",\"type\":\"event\"}]","ContractName":"Play0x_LottoBall","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://b654f22f57aa857a1fab23118d87f2f9641b8a0d78456353eeb05e0ca95fb071"}]}