{"status":"1","message":"OK","result":[{"SourceCode":"// Verified using https://dapp.tools\n\n// hevm: flattened sources of src/Leverager.sol\npragma solidity >0.4.13 >=0.5.0 <0.6.0;\n\n////// lib/ds-math/src/math.sol\n/// math.sol -- mixin for inline numerical wizardry\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n/* pragma solidity >0.4.13; */\n\ncontract DSMath {\n    function add(uint x, uint y) internal pure returns (uint z) {\n        require((z = x + y) >= x, \"ds-math-add-overflow\");\n    }\n    function sub(uint x, uint y) internal pure returns (uint z) {\n        require((z = x - y) <= x, \"ds-math-sub-underflow\");\n    }\n    function mul(uint x, uint y) internal pure returns (uint z) {\n        require(y == 0 || (z = x * y) / y == x, \"ds-math-mul-overflow\");\n    }\n\n    function min(uint x, uint y) internal pure returns (uint z) {\n        return x <= y ? x : y;\n    }\n    function max(uint x, uint y) internal pure returns (uint z) {\n        return x >= y ? x : y;\n    }\n    function imin(int x, int y) internal pure returns (int z) {\n        return x <= y ? x : y;\n    }\n    function imax(int x, int y) internal pure returns (int z) {\n        return x >= y ? x : y;\n    }\n\n    uint constant WAD = 10 ** 18;\n    uint constant RAY = 10 ** 27;\n\n    function wmul(uint x, uint y) internal pure returns (uint z) {\n        z = add(mul(x, y), WAD / 2) / WAD;\n    }\n    function rmul(uint x, uint y) internal pure returns (uint z) {\n        z = add(mul(x, y), RAY / 2) / RAY;\n    }\n    function wdiv(uint x, uint y) internal pure returns (uint z) {\n        z = add(mul(x, WAD), y / 2) / y;\n    }\n    function rdiv(uint x, uint y) internal pure returns (uint z) {\n        z = add(mul(x, RAY), y / 2) / y;\n    }\n\n    // This famous algorithm is called \"exponentiation by squaring\"\n    // and calculates x^n with x as fixed-point and n as regular unsigned.\n    //\n    // It's O(log n), instead of O(n) for naive repeated multiplication.\n    //\n    // These facts are why it works:\n    //\n    //  If n is even, then x^n = (x^2)^(n/2).\n    //  If n is odd,  then x^n = x * x^(n-1),\n    //   and applying the equation for even x gives\n    //    x^n = x * (x^2)^((n-1) / 2).\n    //\n    //  Also, EVM division is flooring and\n    //    floor[(n-1) / 2] = floor[n / 2].\n    //\n    function rpow(uint x, uint n) internal pure returns (uint z) {\n        z = n % 2 != 0 ? x : RAY;\n\n        for (n /= 2; n != 0; n /= 2) {\n            x = rmul(x, x);\n\n            if (n % 2 != 0) {\n                z = rmul(z, x);\n            }\n        }\n    }\n}\n\n////// src/interfaces/IERC20.sol\n/* pragma solidity >=0.5.0 <0.6.0; */\n\ninterface IERC20 {\n    function transfer(address to, uint256 value) external returns (bool);\n    function approve(address spender, uint256 value) external returns (bool);\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address who) external view returns (uint256);\n    function allowance(address owner, address spender) external view returns (uint256);\n}\n////// src/interfaces/IExchange.sol\n/* pragma solidity >=0.5.0 <0.6.0; */\n\n/* import \"./IERC20.sol\"; */\n\ninterface IExchange {\n    // specify either srcAmount = 0 or dstAmount = 0\n    // actual amount - actual srcAmount if srcAmount is zero or actual dstAmount if dstAmount is zero\n    function swap(IERC20 srcToken, uint srcAmount, IERC20 dstToken, uint dstAmount) external returns (uint actualAmount);\n}\n\n////// src/interfaces/ILender.sol\n/* pragma solidity >=0.5.0 <0.6.0; */\n\n/* import \"./IERC20.sol\"; */\n\ninterface ILender {\n    function supplyAndBorrow(\n        bytes32 agreementId,\n        IERC20 principalToken,\n        uint principalAmount,\n        IERC20 collateralToken,\n        uint collateralAmount) external returns (bytes32 _agreementId);\n\n    function repayAndReturn(\n        bytes32 agreementId,\n        IERC20 principalToken,\n        uint repaymentAmount,\n        IERC20 collateralToken,\n        uint withdrawAmount) external;\n\n    function getOwedAmount(bytes32 agreementId, IERC20 principalToken) external returns (uint);\n}\n\n////// src/interfaces/IPriceFeed.sol\n/* pragma solidity >=0.5.0 <0.6.0; */\n\n/* import \"./IERC20.sol\"; */\n\ninterface IPriceFeed {\n    function convertAmountToETH(IERC20 srcToken, uint srcAmount) external view returns (uint ethAmount);\n    function convertAmountFromETH(IERC20 dstToken, uint ethAmount) external view returns (uint dstAmount);\n}\n\n////// src/Leverager.sol\n/* pragma solidity >=0.5.0 <0.6.0; */\n\n/* import \"ds-math/math.sol\"; */\n/* import \"./interfaces/IERC20.sol\"; */\n/* import \"./interfaces/IExchange.sol\"; */\n/* import \"./interfaces/IPriceFeed.sol\"; */\n/* import \"./interfaces/ILender.sol\"; */\n\ncontract Leverager is DSMath {\n\n    struct Position {\n        bytes32 agreementId;\n        address owner;\n        address heldToken;\n        uint heldAmount;\n        address principalToken;\n    }\n\n    uint public positionsCount;\n    mapping (uint => Position) public positions;\n\n    event PositionOpened(\n        address indexed owner,\n        uint positionId,\n        // IExchange exchange,\n        // ILender lender,\n        // IPriceFeed priceFeed,\n        address heldToken, \n        uint heldAmount, \n        address principalToken,\n        uint wadMaxBaseRatio\n    );\n\n    event Iteration(uint num, uint recievedEthAmount);\n\n    event PositionClosed(\n        address indexed owner\n    );\n\n    // deposit token is a held token\n    // FOR DELEGATECALL ONLY!\n    // addresses[0] = lender\n    // addresses[1] = exchange\n    // addresses[2] = priceFeed\n    // addresses[3] = heldToken\n    // addresses[4] = principalToken\n    // uints[0] =     initialDepositAmount\n    // uints[1] =     wadMaxBaseRatio\n    // uints[2] =     maxIterations\n    // uints[3] =     minCollateralEthAmount\n    // \n    // arrays in params used to evade \"stack too deep\" during compilation\n    function openShortPosition (\n        address[5] calldata addresses,\n        uint[4] calldata uints\n    ) external {\n        positionsCount = add(positionsCount, 1);\n        uint positionId = positionsCount;\n        uint recievedAmount = uints[0];\n        uint recievedEthAmount;\n        uint heldAmount = uints[0];\n        bytes32 agreementId;\n\n        IERC20(addresses[3]).transferFrom(msg.sender, address(this), uints[0]);\n\n        for (uint i = 0; i < uints[2]; i++) {\n            uint principalAmount = calcPrincipal(IERC20(addresses[3]), recievedAmount, IERC20(addresses[4]), uints[1], IPriceFeed(addresses[2]));\n\n            bool ok;\n            bytes memory result;\n            (ok, result) = addresses[0].delegatecall(\n                abi.encodeWithSignature(\n                    \"supplyAndBorrow(bytes32,address,uint256,address,uint256)\",\n                    agreementId, addresses[4], principalAmount, addresses[3], recievedAmount\n                )\n            );\n            require(ok, \"supplyAndBorrow failed\");\n            agreementId = _bytesToBytes32(result);\n            \n            (ok, result) = addresses[1].delegatecall(\n                abi.encodeWithSignature(\n                    \"swap(address,uint256,address,uint256)\",\n                    addresses[4], principalAmount, addresses[3], 0\n                )\n            );\n            require(ok, \"swap failed\");\n            recievedAmount = uint(_bytesToBytes32(result));\n            recievedEthAmount = IPriceFeed(addresses[2]).convertAmountToETH(IERC20(addresses[3]), recievedAmount);\n            heldAmount += recievedAmount;\n\n            emit Iteration(i, recievedEthAmount);\n\n            if(recievedEthAmount < uints[3])\n                break;\n        }\n\n        positions[positionId] = Position({\n            agreementId: agreementId,\n            owner: msg.sender,\n            heldToken: addresses[3],\n            heldAmount: heldAmount,\n            principalToken: addresses[4]\n        });\n\n        emit PositionOpened(msg.sender, positionId, addresses[3], heldAmount, addresses[4], uints[1]);\n    }\n    \n    // FOR DELEGATECALL ONLY!\n    // function closeShortPosition(\n    //     bytes32 positionId,\n    //     address exchange,\n    //     address lender,\n    //     uint maxIterations\n    // ) external {\n    //     Position storage position = positions[positionId];\n\n    //     for (var i = 0; i < maxIterations; i++) {\n    //         uint owedAmount = lender.getOwedAmount(position.agreementId, position.principalToken);\n\n    //         bool ok;\n    //         bytes memory result;\n    //         (ok, result) = exchange.delegatecall(\n    //             abi.encodeWithSignature(\n    //                 \"swap(address,uint256,address,uint256)\",\n    //                 position.heldToken, 0, position.principalToken, owedAmount\n    //             )\n    //         );\n    //         require(ok, \"swap failed\");\n    //         recievedAmount = uint(_bytesToBytes32(result));\n\n    //         (ok, result) = lender.delegatecall(\n    //             abi.encodeWithSignature(\n    //                 \"repayAndReturn(bytes32,address,uint256,address,uint256)\",\n    //                 position.agreementId, position.principalToken, uint(-1), position.heldToken, uint(-1)\n    //             )\n    //         );\n    //         require(ok, \"supplyAndBorrow failed\");\n    //     }\n\n    //     delete positions[positionId];\n        \n    //     emit PositionClosed(msg.sender);\n    // }\n\n    // determines how much we can borrow from a lender in order to maintain provided collateral ratio\n    function calcPrincipal(\n        IERC20 heldToken,\n        uint depositAmount,\n        IERC20 principalToken,\n        uint wadMaxBaseRatio,\n        IPriceFeed priceFeed\n    ) public view returns (uint principalAmount){\n        uint collateralETH = priceFeed.convertAmountToETH(heldToken, depositAmount);\n        uint principalETH = wdiv(collateralETH, wadMaxBaseRatio);\n        principalAmount = priceFeed.convertAmountFromETH(principalToken, principalETH);\n    }\n\n    function _bytesToBytes32(bytes memory source) internal pure returns (bytes32 result) {\n        if (source.length == 0)\n            return 0x0;\n\n        assembly {\n            result := mload(add(source, 32))\n        }\n    }\n}\n","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"addresses\",\"type\":\"address[5]\"},{\"name\":\"uints\",\"type\":\"uint256[4]\"}],\"name\":\"openShortPosition\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"positions\",\"outputs\":[{\"name\":\"agreementId\",\"type\":\"bytes32\"},{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"heldToken\",\"type\":\"address\"},{\"name\":\"heldAmount\",\"type\":\"uint256\"},{\"name\":\"principalToken\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"positionsCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"heldToken\",\"type\":\"address\"},{\"name\":\"depositAmount\",\"type\":\"uint256\"},{\"name\":\"principalToken\",\"type\":\"address\"},{\"name\":\"wadMaxBaseRatio\",\"type\":\"uint256\"},{\"name\":\"priceFeed\",\"type\":\"address\"}],\"name\":\"calcPrincipal\",\"outputs\":[{\"name\":\"principalAmount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"positionId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"heldToken\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"heldAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"principalToken\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"wadMaxBaseRatio\",\"type\":\"uint256\"}],\"name\":\"PositionOpened\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"num\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"recievedEthAmount\",\"type\":\"uint256\"}],\"name\":\"Iteration\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"PositionClosed\",\"type\":\"event\"}]","ContractName":"Leverager","CompilerVersion":"v0.5.4+commit.9549d8ff","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://2c19ff5f7ced63c0912fb24f30c9a626ed57ff2167c8625a84f08ed2c8519c97"}]}