{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.5.3;\r\n\r\n// ---------------------------------------------------------------------------\r\n// RICO\r\n// ---------------------------------------------------------------------------\r\n\r\n// File: contracts/interfaces/IERC20.sol\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ninterface IERC20 {\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n\r\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function name() external pure returns (string memory);\r\n\r\n    function symbol() external pure returns (string memory);\r\n\r\n    function decimals() external pure returns (uint256);\r\n\r\n    function balanceOf(address who) external view returns (uint256);\r\n\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: contracts/helpers/SafeMath.sol\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Unsigned math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n    * @dev Multiplies two unsigned integers, reverts on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two unsigned integers, reverts on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n\r\n        return c;\r\n    }\r\n}\r\n\r\n// File: contracts/helpers/ReentrancyGuard.sol\r\n\r\n/**\r\n * @title Helps contracts guard against reentrancy attacks.\r\n * @author Remco Bloemen <remco@2Ï€.com>, Eenae <alexey@mixbytes.io>\r\n * @dev If you mark a function `nonReentrant`, you should also\r\n * mark it `external`.\r\n */\r\ncontract ReentrancyGuard {\r\n    /// @dev counter to allow mutex lock with only one SSTORE operation\r\n    uint256 private _guardCounter;\r\n\r\n    constructor () internal {\r\n        // The counter starts at one to prevent changing it from zero to a non-zero\r\n        // value, which is a more expensive operation.\r\n        _guardCounter = 1;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and make it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        _guardCounter += 1;\r\n        uint256 localCounter = _guardCounter;\r\n        _;\r\n        require(localCounter == _guardCounter);\r\n    }\r\n}\r\n\r\n// File: contracts/ownerships/ClusterRole.sol\r\n\r\ncontract ClusterRole {\r\n    address payable private _cluster;\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the cluster.\r\n     */\r\n    modifier onlyCluster() {\r\n        require(isCluster(), \"onlyCluster: only cluster can call this method.\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev The Cluster Role sets the original `cluster` of the contract to the sender\r\n     * account.\r\n     */\r\n    constructor () internal {\r\n        _cluster = msg.sender;\r\n    }\r\n\r\n    /**\r\n     * @return the address of the cluster contract.\r\n     */\r\n    function cluster() public view returns (address payable) {\r\n        return _cluster;\r\n    }\r\n\r\n    /**\r\n     * @return true if `msg.sender` is the owner of the contract.\r\n     */\r\n    function isCluster() public view returns (bool) {\r\n        return msg.sender == _cluster;\r\n    }\r\n}\r\n\r\n// File: contracts/ownerships/Ownable.sol\r\n\r\ncontract OperatorRole {\r\n    address payable private _operator;\r\n\r\n    event OwnershipTransferred(address indexed previousOperator, address indexed newOperator);\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the operator.\r\n     */\r\n    modifier onlyOperator() {\r\n        require(isOperator(), \"onlyOperator: only the operator can call this method.\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev The OperatorRole constructor sets the original `operator` of the contract to the sender\r\n     * account.\r\n     */\r\n    constructor (address payable operator) internal {\r\n        _operator = operator;\r\n        emit OwnershipTransferred(address(0), operator);\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current operator to transfer control of the contract to a newOperator.\r\n     * @param newOperator The address to transfer ownership to.\r\n     */\r\n    function transferOwnership(address payable newOperator) external onlyOperator {\r\n        _transferOwnership(newOperator);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers control of the contract to a newOperator.\r\n     * @param newOperator The address to transfer ownership to.\r\n     */\r\n    function _transferOwnership(address payable newOperator) private {\r\n        require(newOperator != address(0), \"_transferOwnership: the address of new operator is not valid.\");\r\n        emit OwnershipTransferred(_operator, newOperator);\r\n        _operator = newOperator;\r\n    }\r\n\r\n    /**\r\n     * @return the address of the operator.\r\n     */\r\n    function operator() public view returns (address payable) {\r\n        return _operator;\r\n    }\r\n\r\n    /**\r\n     * @return true if `msg.sender` is the operator of the contract.\r\n     */\r\n    function isOperator() public view returns (bool) {\r\n        return msg.sender == _operator;\r\n    }\r\n}\r\n\r\n// File: contracts/Crowdsale.sol\r\n\r\n/**\r\n * @title Crowdsale\r\n * @dev Crowdsale is a base contract for managing a token crowdsale,\r\n * allowing investors to purchase tokens with ether. This contract implements\r\n * such functionality in its most fundamental form and can be extended to provide additional\r\n * functionality and/or custom behavior.\r\n * The external interface represents the basic interface for purchasing tokens, and conform\r\n * the base architecture for crowdsales. They are *not* intended to be modified / overridden.\r\n * The internal interface conforms the extensible and modifiable surface of crowdsales. Override\r\n * the methods to add functionality. Consider using 'super' where appropriate to concatenate\r\n * behavior.\r\n */\r\ncontract Crowdsale is ReentrancyGuard, ClusterRole, OperatorRole {\r\n    using SafeMath for uint256;\r\n\r\n    IERC20 internal _token;\r\n\r\n    // Crowdsale constant details\r\n    uint256 private _fee;\r\n    uint256 private _rate;\r\n    uint256 private _minInvestmentAmount;\r\n\r\n    // Crowdsale purchase state\r\n    uint256 internal _weiRaised;\r\n    uint256 internal _tokensSold;\r\n\r\n    // Emergency transfer variables\r\n    address private _newContract;\r\n    bool private _emergencyExitCalled;\r\n\r\n    address[] private _investors;\r\n\r\n    // Get Investor token/eth balances by address\r\n    struct Investor {\r\n        uint256 eth;\r\n        uint256 tokens;\r\n        uint256 withdrawnEth;\r\n        uint256 withdrawnTokens;\r\n        bool refunded;\r\n    }\r\n\r\n    mapping (address => Investor) internal _balances;\r\n\r\n    // Bonuses state\r\n    struct Bonus {\r\n        uint256 amount;\r\n        uint256 finishTimestamp;\r\n    }\r\n\r\n    Bonus[] private _bonuses;\r\n\r\n    event Deposited(address indexed beneficiary, uint256 indexed weiAmount, uint256 indexed tokensAmount, uint256 fee);\r\n    event EthTransfered(address indexed beneficiary,uint256 weiAmount);\r\n    event TokensTransfered(address indexed beneficiary, uint256 tokensAmount);\r\n    event Refunded(address indexed beneficiary, uint256 indexed weiAmount);\r\n    event EmergencyExitCalled(address indexed newContract, uint256 indexed tokensAmount, uint256 indexed weiAmount);\r\n\r\n    /**\r\n     * @dev The rate is the conversion between wei and the smallest and indivisible\r\n     * token unit. So, if you are using a rate of 1 with a ERC20Detailed token\r\n     * with 3 decimals called TOK, 1 wei will give you 1 unit, or 0.001 TOK.\r\n     * @param token Address of the token being sold\r\n     */\r\n    constructor (\r\n        uint256 rate,\r\n        address token,\r\n        address payable operator,\r\n        uint256[] memory bonusFinishTimestamp,\r\n        uint256[] memory bonuses,\r\n        uint256 minInvestmentAmount,\r\n        uint256 fee\r\n        ) internal OperatorRole(operator) {\r\n        if (bonuses.length > 0) {\r\n            for (uint256 i = 0; i < bonuses.length; i++) {\r\n                if (i != 0) {\r\n                    require(bonusFinishTimestamp[i] > bonusFinishTimestamp[i - 1], \"Crowdsale: invalid bonus finish timestamp.\");\r\n                }\r\n\r\n                Bonus memory bonus = Bonus(bonuses[i], bonusFinishTimestamp[i]);\r\n                _bonuses.push(bonus);\r\n            }\r\n        }\r\n\r\n        _rate = rate;\r\n        _token = IERC20(token);\r\n        _minInvestmentAmount = minInvestmentAmount;\r\n        _fee = fee;\r\n    }\r\n\r\n    // -----------------------------------------\r\n    // EXTERNAL\r\n    // -----------------------------------------\r\n\r\n    /**\r\n     * @dev fallback function ***DO NOT OVERRIDE***\r\n     * Note that other contracts will transfer fund with a base gas stipend\r\n     * of 2300, which is not enough to call buyTokens. Consider calling\r\n     * buyTokens directly when purchasing tokens from a contract.\r\n     */\r\n    function () external payable {\r\n        buyTokens(msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @dev low level token purchase ***DO NOT OVERRIDE***\r\n     * This function has a non-reentrancy guard, so it shouldn't be called by\r\n     * another `nonReentrant` function.\r\n     * @param beneficiary Recipient of the token purchase\r\n     */\r\n    function buyTokens(address beneficiary) public nonReentrant payable {\r\n        uint256 weiAmount = msg.value;\r\n\r\n        _preValidatePurchase(beneficiary, weiAmount);\r\n\r\n        // calculating the fee from weiAmount\r\n        uint256 fee = _calculatePercent(weiAmount, _fee);\r\n\r\n        // calculate token amount to be created\r\n        uint256 tokensAmount = _calculateTokensAmount(weiAmount);\r\n\r\n        // removing the fee amount from main value\r\n        weiAmount = weiAmount.sub(fee);\r\n\r\n        _processPurchase(beneficiary, weiAmount, tokensAmount);\r\n\r\n        // transfer the fee to cluster contract\r\n        cluster().transfer(fee);\r\n\r\n        emit Deposited(beneficiary, weiAmount, tokensAmount, fee);\r\n    }\r\n\r\n    /**\r\n     * @dev transfer all funds (ETH/Tokens) to another contract, if this crowdsale has some issues\r\n     * @param newContract address of receiver contract\r\n     */\r\n    function emergencyExit(address payable newContract) public {\r\n        require(newContract != address(0), \"emergencyExit: invalid new contract address.\");\r\n        require(isCluster() || isOperator(), \"emergencyExit: only operator or cluster can call this method.\");\r\n\r\n        if (isCluster()) {\r\n            _emergencyExitCalled = true;\r\n            _newContract = newContract;\r\n        } else if (isOperator()) {\r\n            require(_emergencyExitCalled == true, \"emergencyExit: the cluster need to call this method first.\");\r\n            require(_newContract == newContract, \"emergencyExit: the newContract address is not the same address with clusters newContract.\");\r\n\r\n            uint256 allLockedTokens = _token.balanceOf(address(this));\r\n            _withdrawTokens(newContract, allLockedTokens);\r\n\r\n            uint256 allLocketETH = address(this).balance;\r\n            _withdrawEther(newContract, allLocketETH);\r\n\r\n            emit EmergencyExitCalled(newContract, allLockedTokens, allLocketETH);\r\n        }\r\n    }\r\n\r\n    // -----------------------------------------\r\n    // INTERNAL\r\n    // -----------------------------------------\r\n\r\n    /**\r\n     * @dev Validation of an incoming purchase. Use require statements to revert state when conditions are not met.\r\n     * @param beneficiary Address performing the token purchase\r\n     * @param weiAmount Value in wei involved in the purchase\r\n     */\r\n    function _preValidatePurchase(address beneficiary, uint256 weiAmount) internal view {\r\n        require(weiAmount >= _minInvestmentAmount, \"_preValidatePurchase: msg.amount should be bigger then _minInvestmentAmount.\");\r\n        require(beneficiary != address(0), \"_preValidatePurchase: invalid beneficiary address.\");\r\n        require(_emergencyExitCalled == false, \"_preValidatePurchase: the crowdsale contract address was transfered.\");\r\n    }\r\n\r\n    /**\r\n     * @dev Calculate the fee amount from msg.value\r\n     */\r\n    function _calculatePercent(uint256 amount, uint256 percent) internal pure returns (uint256) {\r\n        return amount.mul(percent).div(100);\r\n    }\r\n\r\n    /**\r\n     * @dev Override to extend the way in which ether is converted to tokens.\r\n     * @param weiAmount Value in wei to be converted into tokens\r\n     * @return Number of tokens that can be purchased with the specified _weiAmount\r\n     */\r\n    function _calculateTokensAmount(uint256 weiAmount) internal view returns (uint256) {\r\n        uint256 tokensAmount = weiAmount.mul(_rate);\r\n\r\n        for (uint256 i = 0; i < _bonuses.length; i++) {\r\n\t\t\tif (block.timestamp <= _bonuses[i].finishTimestamp) {\r\n\t\t\t    uint256 bonusAmount = _calculatePercent(tokensAmount, _bonuses[i].amount);\r\n\t\t\t    tokensAmount = tokensAmount.add(bonusAmount);\r\n\t\t\t    break;\r\n\t\t\t}\r\n\t\t}\r\n\r\n        return tokensAmount;\r\n    }\r\n\r\n    /**\r\n     * @dev Executed when a purchase has been validated and is ready to be executed. Doesn't necessarily emit/send tokens.\r\n     * @param beneficiary Address receiving the tokens\r\n     * @param tokenAmount Number of tokens to be purchased\r\n     */\r\n    function _processPurchase(address beneficiary, uint256 weiAmount, uint256 tokenAmount) internal {\r\n        // updating the purchase state\r\n        _weiRaised = _weiRaised.add(weiAmount);\r\n        _tokensSold = _tokensSold.add(tokenAmount);\r\n\r\n        // if investor is new pushing his/her address to investors list\r\n        if (_balances[beneficiary].eth == 0 && _balances[beneficiary].refunded == false) {\r\n            _investors.push(beneficiary);\r\n        }\r\n\r\n        _balances[beneficiary].eth = _balances[beneficiary].eth.add(weiAmount);\r\n        _balances[beneficiary].tokens = _balances[beneficiary].tokens.add(tokenAmount);\r\n    }\r\n\r\n    // -----------------------------------------\r\n    // FUNDS INTERNAL\r\n    // -----------------------------------------\r\n\r\n    function _withdrawTokens(address beneficiary, uint256 amount) internal {\r\n        _token.transfer(beneficiary, amount);\r\n        emit TokensTransfered(beneficiary, amount);\r\n    }\r\n\r\n    function _withdrawEther(address payable beneficiary, uint256 amount) internal {\r\n        beneficiary.transfer(amount);\r\n        emit EthTransfered(beneficiary, amount);\r\n    }\r\n\r\n    // -----------------------------------------\r\n    // GETTERS\r\n    // -----------------------------------------\r\n\r\n    /**\r\n     * @return the details of this crowdsale\r\n     */\r\n    function getCrowdsaleDetails() public view returns (uint256, address, uint256, uint256, uint256[] memory finishTimestamps, uint256[] memory bonuses) {\r\n        finishTimestamps = new uint256[](_bonuses.length);\r\n        bonuses = new uint256[](_bonuses.length);\r\n\r\n        for (uint256 i = 0; i < _bonuses.length; i++) {\r\n            finishTimestamps[i] = _bonuses[i].finishTimestamp;\r\n            bonuses[i] = _bonuses[i].amount;\r\n        }\r\n\r\n        return (\r\n            _rate,\r\n            address(_token),\r\n            _minInvestmentAmount,\r\n            _fee,\r\n            finishTimestamps,\r\n            bonuses\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev getInvestorBalances returns the eth/tokens balances of investor also withdrawn history of eth/tokens\r\n     */\r\n    function getInvestorBalances(address investor) public view returns (uint256, uint256, uint256, uint256, bool) {\r\n        return (\r\n            _balances[investor].eth,\r\n            _balances[investor].tokens,\r\n            _balances[investor].withdrawnEth,\r\n            _balances[investor].withdrawnTokens,\r\n            _balances[investor].refunded\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev getInvestorsArray returns the array of addresses of investors\r\n     */\r\n    function getInvestorsArray() public view returns (address[] memory investors) {\r\n        uint256 investorsAmount = _investors.length;\r\n        investors = new address[](investorsAmount);\r\n\r\n        for (uint256 i = 0; i < investorsAmount; i++) {\r\n            investors[i] = _investors[i];\r\n        }\r\n\r\n        return investors;\r\n    }\r\n\r\n    /**\r\n     * @return the amount of wei raised.\r\n     */\r\n    function getRaisedWei() public view returns (uint256) {\r\n        return _weiRaised;\r\n    }\r\n\r\n    /**\r\n     * @return the amount of tokens sold.\r\n     */\r\n    function getSoldTokens() public view returns (uint256) {\r\n        return _tokensSold;\r\n    }\r\n\r\n    /**\r\n     * @dev isInvestor check if the address is investor or not\r\n     */\r\n    function isInvestor(address sender) public view returns (bool) {\r\n        return _balances[sender].eth != 0 && _balances[sender].tokens != 0;\r\n    }\r\n}\r\n\r\n// File: contracts/TimedCrowdsale.sol\r\n\r\n/**\r\n * @title TimedCrowdsale\r\n * @dev Crowdsale accepting contributions only within a time frame.\r\n */\r\ncontract TimedCrowdsale is Crowdsale {\r\n    uint256 private _openingTime;\r\n    uint256 private _closingTime;\r\n\r\n    /**\r\n     * @dev Reverts if not in crowdsale time range.\r\n     */\r\n    modifier onlyWhileOpen() {\r\n        require(isOpen(), \"onlyWhileOpen: investor can call this method only when crowdsale is open.\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Constructor, takes crowdsale opening and closing times.\r\n     * @param openingTime Crowdsale opening time\r\n     * @param closingTime Crowdsale closing time\r\n     */\r\n    constructor (\r\n        uint256 rate,\r\n        address token,\r\n        uint256 openingTime,\r\n        uint256 closingTime,\r\n        address payable operator,\r\n        uint256[] memory bonusFinishTimestamp,\r\n        uint256[] memory bonuses,\r\n        uint256 minInvestmentAmount,\r\n        uint256 fee\r\n        ) internal Crowdsale(rate, token, operator, bonusFinishTimestamp, bonuses, minInvestmentAmount, fee) {\r\n        if (bonusFinishTimestamp.length > 0) {\r\n            require(bonusFinishTimestamp[0] >= openingTime, \"TimedCrowdsale: the opening time is smaller then the first bonus timestamp.\");\r\n            require(bonusFinishTimestamp[bonusFinishTimestamp.length - 1] <= closingTime, \"TimedCrowdsale: the closing time is smaller then the last bonus timestamp.\");\r\n        }\r\n\r\n        _openingTime = openingTime;\r\n        _closingTime = closingTime;\r\n    }\r\n\r\n    // -----------------------------------------\r\n    // INTERNAL\r\n    // -----------------------------------------\r\n\r\n    /**\r\n     * @dev Extend parent behavior requiring to be within contributing period\r\n     * @param beneficiary Token purchaser\r\n     * @param weiAmount Amount of wei contributed\r\n     */\r\n    function _preValidatePurchase(address beneficiary, uint256 weiAmount) internal onlyWhileOpen view {\r\n        super._preValidatePurchase(beneficiary, weiAmount);\r\n    }\r\n\r\n    // -----------------------------------------\r\n    // EXTERNAL\r\n    // -----------------------------------------\r\n\r\n    /**\r\n     * @dev refund the investments to investor while crowdsale is open\r\n     */\r\n    function refundETH() external onlyWhileOpen {\r\n        require(isInvestor(msg.sender), \"refundETH: only the active investors can call this method.\");\r\n\r\n        uint256 weiAmount = _balances[msg.sender].eth;\r\n        uint256 tokensAmount = _balances[msg.sender].tokens;\r\n\r\n        _balances[msg.sender].eth = 0;\r\n        _balances[msg.sender].tokens = 0;\r\n\r\n        if (_balances[msg.sender].refunded == false) {\r\n            _balances[msg.sender].refunded = true;\r\n        }\r\n\r\n        _weiRaised = _weiRaised.sub(weiAmount);\r\n        _tokensSold = _tokensSold.sub(tokensAmount);\r\n\r\n        msg.sender.transfer(weiAmount);\r\n\r\n        emit Refunded(msg.sender, weiAmount);\r\n    }\r\n\r\n    // -----------------------------------------\r\n    // GETTERS\r\n    // -----------------------------------------\r\n\r\n    /**\r\n     * @return the crowdsale opening time.\r\n     */\r\n    function getOpeningTime() public view returns (uint256) {\r\n        return _openingTime;\r\n    }\r\n\r\n    /**\r\n     * @return the crowdsale closing time.\r\n     */\r\n    function getClosingTime() public view returns (uint256) {\r\n        return _closingTime;\r\n    }\r\n\r\n    /**\r\n     * @return true if the crowdsale is open, false otherwise.\r\n     */\r\n    function isOpen() public view returns (bool) {\r\n        return block.timestamp >= _openingTime && block.timestamp <= _closingTime;\r\n    }\r\n\r\n    /**\r\n     * @dev Checks whether the period in which the crowdsale is open has already elapsed.\r\n     * @return Whether crowdsale period has elapsed\r\n     */\r\n    function hasClosed() public view returns (bool) {\r\n        return block.timestamp > _closingTime;\r\n    }\r\n}\r\n\r\n// File: contracts/ResponsibleCrowdsale.sol\r\n\r\n/**\r\n * @title ResponsibleCrowdsale\r\n * @dev Main crowdsale contract\r\n */\r\ncontract ResponsibleCrowdsale is TimedCrowdsale {\r\n    uint256 private _cycleId;\r\n    uint256 private _milestoneId;\r\n    uint256 private constant _timeForDisputs = 3 days;\r\n\r\n    uint256 private _allCyclesTokensPercent;\r\n    uint256 private _allCyclesEthPercent;\r\n\r\n    bool private _operatorTransferedTokens;\r\n\r\n    enum MilestoneStatus { PENDING, DISPUTS_PERIOD, APPROVED }\r\n    enum InvestorDisputeState { NO_DISPUTES, SUBMITTED, CLOSED, WINNED }\r\n\r\n    struct Cycle {\r\n        uint256 tokenPercent;\r\n        uint256 ethPercent;\r\n        bytes32[] milestones;\r\n    }\r\n\r\n    struct Dispute {\r\n        uint256 activeDisputes;\r\n        address[] winnedAddressList;\r\n        mapping (address => InvestorDisputeState) investorDispute;\r\n    }\r\n\r\n    struct Milestone {\r\n        bytes32 name;\r\n        uint256 startTimestamp;\r\n        uint256 disputesOpeningTimestamp;\r\n        uint256 cycleId;\r\n        uint256 tokenPercent;\r\n        uint256 ethPercent;\r\n        Dispute disputes;\r\n        bool operatorWasWithdrawn;\r\n        bool validHash;\r\n        mapping (address => bool) userWasWithdrawn;\r\n    }\r\n\r\n    // Mapping of circes by id\r\n    mapping (uint256 => Cycle) private _cycles;\r\n\r\n    // Mapping of milestones with order\r\n    mapping (uint256 => bytes32) private _milestones;\r\n\r\n    // Get detail of each milestone by Hash\r\n    mapping (bytes32 => Milestone) private _milestoneDetails;\r\n\r\n    event MilestoneInvestmentsWithdrawn(bytes32 indexed milestoneHash, uint256 weiAmount, uint256 tokensAmount);\r\n    event MilestoneResultWithdrawn(bytes32 indexed milestoneHash, address indexed investor, uint256 weiAmount, uint256 tokensAmount);\r\n\r\n    constructor (\r\n        uint256 rate,\r\n        address token,\r\n        uint256 openingTime,\r\n        uint256 closingTime,\r\n        address payable operator,\r\n        uint256[] memory bonusFinishTimestamp,\r\n        uint256[] memory bonuses,\r\n        uint256 minInvestmentAmount,\r\n        uint256 fee\r\n    )\r\n        public TimedCrowdsale(rate, token, openingTime, closingTime, operator, bonusFinishTimestamp, bonuses, minInvestmentAmount, fee)\r\n    {}\r\n\r\n    // -----------------------------------------\r\n    // OPERATOR FEATURES\r\n    // -----------------------------------------\r\n\r\n    function addCycle(\r\n        uint256 tokenPercent,\r\n        uint256 ethPercent,\r\n        bytes32[] memory milestonesNames,\r\n        uint256[] memory milestonesTokenPercent,\r\n        uint256[] memory milestonesEthPercent,\r\n        uint256[] memory milestonesStartTimestamps\r\n    )\r\n        public onlyOperator returns (bool)\r\n    {\r\n        // Checking incoming values\r\n        require(tokenPercent > 0 && tokenPercent <= 100, \"addCycle: the Token percent of the cycle should be bigger then 0 and smaller then 100.\");\r\n        require(ethPercent > 0 && ethPercent <= 100, \"addCycle: the ETH percent of the cycle should be bigger then 0 and smaller then 100.\");\r\n        require(milestonesNames.length > 0, \"addCycle: the milestones length should be bigger than 0.\");\r\n        require(milestonesTokenPercent.length == milestonesNames.length, \"addCycle: the milestonesTokenPercent length should be equal to milestonesNames length.\");\r\n        require(milestonesEthPercent.length == milestonesTokenPercent.length, \"addCycle: the milestonesEthPercent length should be equal to milestonesTokenPercent length.\");\r\n        require(milestonesStartTimestamps.length == milestonesEthPercent.length, \"addCycle: the milestonesFinishTimestamps length should be equal to milestonesEthPercent length.\");\r\n\r\n        // Checking the calculated amount of percentages of all cycles\r\n        require(_allCyclesTokensPercent + tokenPercent <= 100, \"addCycle: the calculated amount of token percents is bigger then 100.\");\r\n        require(_allCyclesEthPercent + ethPercent <= 100, \"addCycle: the calculated amount of eth percents is bigger then 100.\");\r\n\r\n        _cycles[_cycleId] = Cycle(\r\n            tokenPercent,\r\n            ethPercent,\r\n            new bytes32[](0)\r\n        );\r\n\r\n        uint256 allMilestonesTokensPercent;\r\n        uint256 allMilestonesEthPercent;\r\n\r\n        for (uint256 i = 0; i < milestonesNames.length; i++) {\r\n            // checking if the percentages (token/eth) in this milestones is bigger then 0 and smaller/equal to 100\r\n            require(milestonesTokenPercent[i] > 0 && milestonesTokenPercent[i] <= 100, \"addCycle: the token percent of milestone should be bigger then 0 and smaller from 100.\");\r\n            require(milestonesEthPercent[i] > 0 && milestonesEthPercent[i] <= 100, \"addCycle: the ETH percent of milestone should be bigger then 0 and smaller from 100.\");\r\n\r\n            if (i == 0 && _milestoneId == 0) {\r\n                // checking the first milestone of the first cycle\r\n                require(milestonesStartTimestamps[i] > getClosingTime(), \"addCycle: the first milestone timestamp should be bigger then crowdsale closing time.\");\r\n                require(milestonesTokenPercent[i] <= 25 && milestonesEthPercent[i] <= 25, \"addCycle: for security reasons for the first milestone the operator can withdraw only less than 25 percent of investments.\");\r\n            } else if (i == 0 && _milestoneId > 0) {\r\n                // checking if the first milestone starts after the last milestone of the previous cycle\r\n                uint256 previousCycleLastMilestoneStartTimestamp =  _milestoneDetails[_milestones[_milestoneId - 1]].startTimestamp;\r\n                require(milestonesStartTimestamps[i] > previousCycleLastMilestoneStartTimestamp, \"addCycle: the first timestamp of this milestone should be bigger then his previus milestons last timestamp.\");\r\n                require(milestonesStartTimestamps[i] >= block.timestamp + _timeForDisputs, \"addCycle: the second cycle should be start a minimum 3 days after this transaction.\");\r\n            } else if (i != 0) {\r\n                // checking if the each next milestone finish timestamp is bigger than his previous one finish timestamp\r\n                require(milestonesStartTimestamps[i] > milestonesStartTimestamps[i - 1], \"addCycle: each timestamp should be bigger then his previus one.\");\r\n            }\r\n\r\n            // generating the unique hash for each milestone\r\n            bytes32 hash = _generateHash(\r\n                milestonesNames[i],\r\n                milestonesStartTimestamps[i]\r\n            );\r\n\r\n            // before starting the next milestone investors can open disputes within 3 days\r\n            uint256 disputesOpeningTimestamp = milestonesStartTimestamps[i] - _timeForDisputs;\r\n\r\n            // The first milestone of the first cycle can not have disputes\r\n            if (i == 0 && _milestoneId == 0) {\r\n                disputesOpeningTimestamp = milestonesStartTimestamps[i];\r\n            }\r\n\r\n            // updating the state\r\n            _cycles[_cycleId].milestones.push(hash);\r\n            _milestones[i + _milestoneId] = hash;\r\n            _milestoneDetails[hash] = Milestone(\r\n                milestonesNames[i],                 // Milestone name\r\n                milestonesStartTimestamps[i],       // Milestone finish timestamp\r\n                disputesOpeningTimestamp,           // Miliestone submit timestamp (it will be updated once when operator calls the submit milestone method)\r\n                _cycleId,                           // cycle Id for detecting token and eth percent for this cycle\r\n                milestonesTokenPercent[i],          // Token percent of this milestone\r\n                milestonesEthPercent[i],            // ETH percent of this milestone\r\n                Dispute(0, new address[](0)),       // Disputs state initialization\r\n                false,                              // Operator does not withdrawn this milestone investments yet\r\n                true                                // Milestone hash is valid\r\n            );\r\n\r\n            allMilestonesTokensPercent += milestonesTokenPercent[i];\r\n            allMilestonesEthPercent += milestonesEthPercent[i];\r\n        }\r\n\r\n        // checking if the calculated amount of all percentages (token/eth) in this milestones equal to 100\r\n        require(allMilestonesTokensPercent == 100, \"addCycle: the calculated amount of Token percent should be equal to 100.\");\r\n        require(allMilestonesEthPercent == 100, \"addCycle: the calculated amount of ETH percent should be equal to 100.\");\r\n\r\n        _allCyclesTokensPercent += tokenPercent;\r\n        _allCyclesEthPercent += ethPercent;\r\n\r\n        _cycleId++;\r\n        _milestoneId += milestonesNames.length;\r\n\r\n        return true;\r\n    }\r\n\r\n    function collectMilestoneInvestment(bytes32 hash) public onlyOperator {\r\n        require(_milestoneDetails[hash].validHash, \"collectMilestoneInvestment: the milestone hash is not valid.\");\r\n        require(_milestoneDetails[hash].operatorWasWithdrawn == false, \"collectMilestoneInvestment: the operator already withdrawn his funds.\");\r\n        require(getMilestoneStatus(hash) == MilestoneStatus.APPROVED, \"collectMilestoneInvestment: the time for collecting funds is not started yet.\");\r\n        require(isMilestoneHasActiveDisputes(hash) == false, \"collectMilestoneInvestment: the milestone has unsolved disputes.\");\r\n        require(_hadOperatorTransferredTokens(), \"collectMilestoneInvestment: the operator need to transfer sold tokens to this contract for receiving investments.\");\r\n\r\n        _milestoneDetails[hash].operatorWasWithdrawn = true;\r\n\r\n        uint256 milestoneRefundedTokens;\r\n        uint256 milestoneInvestmentWei = _calculateEthAmountByMilestone(getRaisedWei(), hash);\r\n        uint256 winnedDisputesAmount = _milestoneDetails[hash].disputes.winnedAddressList.length;\r\n\r\n        if (winnedDisputesAmount > 0) {\r\n            for (uint256 i = 0; i < winnedDisputesAmount; i++) {\r\n                address winnedInvestor = _milestoneDetails[hash].disputes.winnedAddressList[i];\r\n\r\n                uint256 investorWeiForMilestone = _calculateEthAmountByMilestone(_balances[winnedInvestor].eth, hash);\r\n                uint256 investorTokensForMilestone = _calculateTokensAmountByMilestone(_balances[winnedInvestor].tokens, hash);\r\n\r\n                milestoneInvestmentWei = milestoneInvestmentWei.sub(investorWeiForMilestone);\r\n                milestoneRefundedTokens = milestoneRefundedTokens.add(investorTokensForMilestone);\r\n            }\r\n        }\r\n\r\n        _withdrawEther(operator(), milestoneInvestmentWei);\r\n\r\n        if (milestoneRefundedTokens != 0) {\r\n            _withdrawTokens(operator(), milestoneRefundedTokens);\r\n        }\r\n\r\n        emit MilestoneInvestmentsWithdrawn(hash, milestoneInvestmentWei, milestoneRefundedTokens);\r\n    }\r\n\r\n    // -----------------------------------------\r\n    // DISPUTS FEATURES\r\n    // -----------------------------------------\r\n\r\n    function openDispute(bytes32 hash, address investor) external onlyCluster returns (bool) {\r\n        _milestoneDetails[hash].disputes.investorDispute[investor] = InvestorDisputeState.SUBMITTED;\r\n        _milestoneDetails[hash].disputes.activeDisputes++;\r\n        return true;\r\n    }\r\n\r\n    function solveDispute(bytes32 hash, address investor, bool investorWins) external onlyCluster {\r\n        require(isMilestoneHasActiveDisputes(hash) == true, \"solveDispute: no active disputs available.\");\r\n\r\n        if (investorWins == true) {\r\n            _milestoneDetails[hash].disputes.investorDispute[investor] = InvestorDisputeState.WINNED;\r\n            _milestoneDetails[hash].disputes.winnedAddressList.push(investor);\r\n        } else {\r\n            _milestoneDetails[hash].disputes.investorDispute[investor] = InvestorDisputeState.CLOSED;\r\n        }\r\n\r\n        _milestoneDetails[hash].disputes.activeDisputes--;\r\n    }\r\n\r\n    // -----------------------------------------\r\n    // INVESTOR FEATURES\r\n    // -----------------------------------------\r\n\r\n    function collectMilestoneResult(bytes32 hash) public {\r\n        require(isInvestor(msg.sender), \"collectMilestoneResult: only the active investors can call this method.\");\r\n        require(_milestoneDetails[hash].validHash, \"collectMilestoneResult: the milestone hash is not valid.\");\r\n        require(getMilestoneStatus(hash) == MilestoneStatus.APPROVED, \"collectMilestoneResult: the time for collecting funds is not started yet.\");\r\n        require(didInvestorWithdraw(hash, msg.sender) == false, \"collectMilestoneResult: the investor already withdrawn his tokens.\");\r\n        require(_milestoneDetails[hash].disputes.investorDispute[msg.sender] != InvestorDisputeState.SUBMITTED, \"collectMilestoneResult: the investor has unsolved disputes.\");\r\n        require(_hadOperatorTransferredTokens(), \"collectMilestoneInvestment: the operator need to transfer sold tokens to this contract for receiving investments.\");\r\n\r\n        _milestoneDetails[hash].userWasWithdrawn[msg.sender] = true;\r\n\r\n        uint256 investorBalance;\r\n        uint256 tokensToSend;\r\n        uint256 winnedWeis;\r\n\r\n        if (_milestoneDetails[hash].disputes.investorDispute[msg.sender] != InvestorDisputeState.WINNED) {\r\n            investorBalance = _balances[msg.sender].tokens;\r\n            tokensToSend = _calculateTokensAmountByMilestone(investorBalance, hash);\r\n\r\n            // transfering tokens to investor\r\n            _withdrawTokens(msg.sender, tokensToSend);\r\n            _balances[msg.sender].withdrawnTokens += tokensToSend;\r\n        } else {\r\n            investorBalance = _balances[msg.sender].eth;\r\n            winnedWeis = _calculateEthAmountByMilestone(investorBalance, hash);\r\n\r\n            // transfering disputs ETH investor\r\n            _withdrawEther(msg.sender, winnedWeis);\r\n            _balances[msg.sender].withdrawnEth += winnedWeis;\r\n        }\r\n\r\n        emit MilestoneResultWithdrawn(hash, msg.sender, winnedWeis, tokensToSend);\r\n    }\r\n\r\n    // -----------------------------------------\r\n    // INTERNAL\r\n    // -----------------------------------------\r\n\r\n    function _preValidatePurchase(address beneficiary, uint256 weiAmount) internal view {\r\n        require(_cycleId > 0, \"_preValidatePurchase: the cycles/milestones is not setted.\");\r\n        super._preValidatePurchase(beneficiary, weiAmount);\r\n    }\r\n\r\n    function _generateHash(bytes32 name, uint256 timestamp) private view returns (bytes32) {\r\n        // generating the unique hash for milestone using the name, start timestamp and the address of this crowdsale\r\n        return keccak256(abi.encodePacked(name, timestamp, address(this)));\r\n    }\r\n\r\n    function _calculateEthAmountByMilestone(uint256 weiAmount, bytes32 milestone) private view returns (uint256) {\r\n        uint256 cycleId = _milestoneDetails[milestone].cycleId;\r\n        uint256 cyclePercent = _cycles[cycleId].ethPercent;\r\n        uint256 milestonePercent = _milestoneDetails[milestone].ethPercent;\r\n\r\n        uint256 amount = _calculatePercent(milestonePercent, _calculatePercent(weiAmount, cyclePercent));\r\n        return amount;\r\n    }\r\n\r\n    function _calculateTokensAmountByMilestone(uint256 tokens, bytes32 milestone) private view returns (uint256) {\r\n        uint256 cycleId = _milestoneDetails[milestone].cycleId;\r\n        uint256 cyclePercent = _cycles[cycleId].tokenPercent;\r\n        uint256 milestonePercent = _milestoneDetails[milestone].tokenPercent;\r\n\r\n        uint256 amount = _calculatePercent(milestonePercent, _calculatePercent(tokens, cyclePercent));\r\n        return amount;\r\n    }\r\n\r\n    function _hadOperatorTransferredTokens() private returns (bool) {\r\n        // the first time when the investor/operator want to withdraw the funds\r\n        if (_token.balanceOf(address(this)) == getSoldTokens()) {\r\n            _operatorTransferedTokens = true;\r\n            return true;\r\n        } else if (_operatorTransferedTokens == true) {\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    // -----------------------------------------\r\n    // GETTERS\r\n    // -----------------------------------------\r\n\r\n    function getCyclesAmount() external view returns (uint256) {\r\n        return _cycleId;\r\n    }\r\n\r\n    function getCycleDetails(uint256 cycleId) external view returns (uint256, uint256, bytes32[] memory) {\r\n        return (\r\n            _cycles[cycleId].tokenPercent,\r\n            _cycles[cycleId].ethPercent,\r\n            _cycles[cycleId].milestones\r\n        );\r\n    }\r\n\r\n    function getMilestonesHashes() external view returns (bytes32[] memory milestonesHashArray) {\r\n        milestonesHashArray = new bytes32[](_milestoneId);\r\n\r\n        for (uint256 i = 0; i < _milestoneId; i++) {\r\n            milestonesHashArray[i] = _milestones[i];\r\n        }\r\n\r\n        return milestonesHashArray;\r\n    }\r\n\r\n    function getMilestoneDetails(bytes32 hash) external view returns (bytes32, uint256, uint256, uint256, uint256, uint256, uint256, MilestoneStatus status) {\r\n        Milestone memory mil = _milestoneDetails[hash];\r\n        status = getMilestoneStatus(hash);\r\n        return (\r\n            mil.name,\r\n            mil.startTimestamp,\r\n            mil.disputesOpeningTimestamp,\r\n            mil.cycleId,\r\n            mil.tokenPercent,\r\n            mil.ethPercent,\r\n            mil.disputes.activeDisputes,\r\n            status\r\n        );\r\n    }\r\n\r\n    function getMilestoneStatus(bytes32 hash) public view returns (MilestoneStatus status) {\r\n        // checking if the time for collecting milestone funds was comes\r\n        if (block.timestamp >= _milestoneDetails[hash].startTimestamp) {\r\n            return MilestoneStatus.APPROVED;\r\n        } else if (block.timestamp > _milestoneDetails[hash].disputesOpeningTimestamp) {\r\n                return MilestoneStatus.DISPUTS_PERIOD;\r\n        } else {\r\n            return MilestoneStatus.PENDING;\r\n        }\r\n    }\r\n\r\n    function getCycleTotalPercents() external view returns (uint256, uint256) {\r\n        return (\r\n            _allCyclesTokensPercent,\r\n            _allCyclesEthPercent\r\n        );\r\n    }\r\n\r\n    function canInvestorOpenNewDispute(bytes32 hash, address investor) public view returns (bool) {\r\n        InvestorDisputeState state = _milestoneDetails[hash].disputes.investorDispute[investor];\r\n        return state == InvestorDisputeState.NO_DISPUTES || state == InvestorDisputeState.CLOSED;\r\n    }\r\n\r\n    function isMilestoneHasActiveDisputes(bytes32 hash) public view returns (bool) {\r\n        return _milestoneDetails[hash].disputes.activeDisputes > 0;\r\n    }\r\n\r\n    function didInvestorOpenedDisputeBefore(bytes32 hash, address investor) public view returns (bool) {\r\n        return _milestoneDetails[hash].disputes.investorDispute[investor] != InvestorDisputeState.NO_DISPUTES;\r\n    }\r\n\r\n    function didInvestorWithdraw(bytes32 hash, address investor) public view returns (bool) {\r\n        return _milestoneDetails[hash].userWasWithdrawn[investor];\r\n    }\r\n}\r\n\r\n// File: contracts/deployers/CrowdsaleDeployer.sol\r\n\r\nlibrary CrowdsaleDeployer {\r\n    function addCrowdsale(\r\n        uint256 rate,\r\n        address token,\r\n        uint256 openingTime,\r\n        uint256 closingTime,\r\n        address payable operator,\r\n        uint256[] calldata bonusFinishTimestamp,\r\n        uint256[] calldata bonuses,\r\n        uint256 minInvestmentAmount,\r\n        uint256 fee\r\n        ) external returns (address) {\r\n         return address(new ResponsibleCrowdsale(rate, token, openingTime, closingTime, operator, bonusFinishTimestamp, bonuses, minInvestmentAmount, fee));\r\n    }\r\n}\r\n\r\n// ---------------------------------------------------------------------------\r\n// ARBITERS POOL\r\n// ---------------------------------------------------------------------------\r\n\r\n// File: contracts/ownerships/Roles.sol\r\n\r\nlibrary Roles {\r\n    struct Role {\r\n        mapping (address => bool) bearer;\r\n    }\r\n\r\n    /**\r\n     * @dev give an account access to this role\r\n     */\r\n    function add(Role storage role, address account) internal {\r\n        require(account != address(0));\r\n        require(!has(role, account));\r\n\r\n        role.bearer[account] = true;\r\n    }\r\n\r\n    /**\r\n     * @dev remove an account's access to this role\r\n     */\r\n    function remove(Role storage role, address account) internal {\r\n        require(account != address(0));\r\n        require(has(role, account));\r\n\r\n        role.bearer[account] = false;\r\n    }\r\n\r\n    /**\r\n     * @dev check if an account has this role\r\n     * @return bool\r\n     */\r\n    function has(Role storage role, address account) internal view returns (bool) {\r\n        require(account != address(0));\r\n        return role.bearer[account];\r\n    }\r\n}\r\n\r\n// File: contracts/ownerships/ArbiterRole.sol\r\n\r\ncontract ArbiterRole is ClusterRole {\r\n    using Roles for Roles.Role;\r\n\r\n    uint256 private _arbitersAmount;\r\n\r\n    event ArbiterAdded(address indexed arbiter);\r\n    event ArbiterRemoved(address indexed arbiter);\r\n\r\n    Roles.Role private _arbiters;\r\n\r\n    modifier onlyArbiter() {\r\n        require(isArbiter(msg.sender), \"onlyArbiter: only arbiter can call this method.\");\r\n        _;\r\n    }\r\n\r\n    // -----------------------------------------\r\n    // EXTERNAL\r\n    // -----------------------------------------\r\n\r\n    function addArbiter(address arbiter) public onlyCluster {\r\n        _addArbiter(arbiter);\r\n        _arbitersAmount++;\r\n    }\r\n\r\n    function removeArbiter(address arbiter) public onlyCluster {\r\n        _removeArbiter(arbiter);\r\n        _arbitersAmount--;\r\n    }\r\n\r\n    // -----------------------------------------\r\n    // INTERNAL\r\n    // -----------------------------------------\r\n\r\n    function _addArbiter(address arbiter) private {\r\n        _arbiters.add(arbiter);\r\n        emit ArbiterAdded(arbiter);\r\n    }\r\n\r\n    function _removeArbiter(address arbiter) private {\r\n        _arbiters.remove(arbiter);\r\n        emit ArbiterRemoved(arbiter);\r\n    }\r\n\r\n    // -----------------------------------------\r\n    // GETTERS\r\n    // -----------------------------------------\r\n\r\n    function isArbiter(address account) public view returns (bool) {\r\n        return _arbiters.has(account);\r\n    }\r\n\r\n    function getArbitersAmount() external view returns (uint256) {\r\n        return _arbitersAmount;\r\n    }\r\n}\r\n\r\n// File: contracts/interfaces/ICluster.sol\r\n\r\ninterface ICluster {\r\n    function withdrawEth() external;\r\n\r\n    function addArbiter(address newArbiter) external;\r\n\r\n    function removeArbiter(address arbiter) external;\r\n\r\n    function addCrowdsale(\r\n        uint256 rate,\r\n        address token,\r\n        uint256 openingTime,\r\n        uint256 closingTime,\r\n        address payable operator,\r\n        uint256[] calldata bonusFinishTimestamp,\r\n        uint256[] calldata bonuses,\r\n        uint256 minInvestmentAmount,\r\n        uint256 fee\r\n    ) external returns (address);\r\n\r\n    function emergencyExit(address crowdsale, address payable newContract) external;\r\n\r\n    function openDispute(address crowdsale, bytes32 hash, string calldata reason) external payable returns (uint256);\r\n\r\n    function solveDispute(address crowdsale, bytes32 hash, address investor, bool investorWins) external;\r\n\r\n    function getArbitersPoolAddress() external view returns (address);\r\n\r\n    function getAllCrowdsalesAddresses() external view returns (address[] memory crowdsales);\r\n\r\n    function getCrowdsaleMilestones(address crowdsale) external view returns(bytes32[] memory milestonesHashArray);\r\n\r\n    function getOperatorCrowdsaleAddresses(address operator) external view returns (address[] memory crowdsales);\r\n\r\n    function owner() external view returns (address payable);\r\n\r\n    function isOwner() external view returns (bool);\r\n\r\n    function transferOwnership(address payable newOwner) external;\r\n\r\n    function isBackEnd(address account) external view returns (bool);\r\n\r\n    function addBackEnd(address account) external;\r\n\r\n    function removeBackEnd(address account) external;\r\n}\r\n\r\n// File: contracts/ArbitersPool.sol\r\n\r\ncontract ArbitersPool is ArbiterRole {\r\n    uint256 private _disputsAmount;\r\n    uint256 private constant _necessaryVoices = 3;\r\n\r\n    enum DisputeStatus { WAITING, SOLVED }\r\n    enum Choice { OPERATOR_WINS, INVESTOR_WINS }\r\n\r\n    ICluster private _clusterInterface;\r\n\r\n    struct Vote {\r\n        address arbiter;\r\n        Choice choice;\r\n    }\r\n\r\n    struct Dispute {\r\n        address investor;\r\n        address crowdsale;\r\n        bytes32 milestoneHash;\r\n        string reason;\r\n        uint256 votesAmount;\r\n        DisputeStatus status;\r\n        mapping (address => bool) hasVoted;\r\n        mapping (uint256 => Vote) choices;\r\n    }\r\n\r\n    mapping (uint256 => Dispute) private _disputesById;\r\n    mapping (address => uint256[]) private _disputesByInvestor;\r\n    mapping (bytes32 => uint256[]) private _disputesByMilestone;\r\n\r\n    event Voted(uint256 indexed disputeId, address indexed arbiter, Choice choice);\r\n    event NewDisputeCreated(uint256 disputeId, address indexed crowdsale, bytes32 indexed hash, address indexed investor);\r\n    event DisputeSolved(uint256 disputeId, Choice choice, address indexed crowdsale, bytes32 indexed hash, address indexed investor);\r\n\r\n    constructor () public {\r\n        _clusterInterface = ICluster(msg.sender);\r\n    }\r\n\r\n    function createDispute(bytes32 milestoneHash, address crowdsale, address investor, string calldata reason) external onlyCluster returns (uint256) {\r\n        Dispute memory dispute = Dispute(\r\n            investor,\r\n            crowdsale,\r\n            milestoneHash,\r\n            reason,\r\n            0,\r\n            DisputeStatus.WAITING\r\n        );\r\n\r\n        uint256 thisDisputeId = _disputsAmount;\r\n        _disputsAmount++;\r\n\r\n        _disputesById[thisDisputeId] = dispute;\r\n        _disputesByMilestone[milestoneHash].push(thisDisputeId);\r\n        _disputesByInvestor[investor].push(thisDisputeId);\r\n\r\n        emit NewDisputeCreated(thisDisputeId, crowdsale, milestoneHash, investor);\r\n\r\n        return thisDisputeId;\r\n    }\r\n\r\n    function voteDispute(uint256 id, Choice choice) public onlyArbiter {\r\n        require(_disputsAmount > id, \"voteDispute: invalid number of dispute.\");\r\n        require(_disputesById[id].hasVoted[msg.sender] == false, \"voteDispute: arbiter was already voted.\");\r\n        require(_disputesById[id].status == DisputeStatus.WAITING, \"voteDispute: dispute was already closed.\");\r\n        require(_disputesById[id].votesAmount < _necessaryVoices, \"voteDispute: dispute was already voted and finished.\");\r\n\r\n        _disputesById[id].hasVoted[msg.sender] = true;\r\n\r\n        // updating the votes amount\r\n        _disputesById[id].votesAmount++;\r\n\r\n        // storing info about this vote\r\n        uint256 votesAmount = _disputesById[id].votesAmount;\r\n        _disputesById[id].choices[votesAmount] = Vote(msg.sender, choice);\r\n\r\n        // checking, if the second arbiter voted the same result with the 1st voted arbiter, then dispute will be solved without 3rd vote\r\n        if (_disputesById[id].votesAmount == 2 && _disputesById[id].choices[0].choice == choice) {\r\n            _executeDispute(id, choice);\r\n        } else if (_disputesById[id].votesAmount == _necessaryVoices) {\r\n            Choice winner = _calculateWinner(id);\r\n            _executeDispute(id, winner);\r\n        }\r\n\r\n        emit Voted(id, msg.sender, choice);\r\n    }\r\n\r\n    // -----------------------------------------\r\n    // INTERNAL\r\n    // -----------------------------------------\r\n\r\n    function _calculateWinner(uint256 id) private view returns (Choice choice) {\r\n        uint256 votesForInvestor = 0;\r\n        for (uint256 i = 0; i < _necessaryVoices; i++) {\r\n            if (_disputesById[id].choices[i].choice == Choice.INVESTOR_WINS) {\r\n                votesForInvestor++;\r\n            }\r\n        }\r\n\r\n        return votesForInvestor >= 2 ? Choice.INVESTOR_WINS : Choice.OPERATOR_WINS;\r\n    }\r\n\r\n    function _executeDispute(uint256 id, Choice choice) private {\r\n        _disputesById[id].status = DisputeStatus.SOLVED;\r\n        _clusterInterface.solveDispute(\r\n            _disputesById[id].crowdsale,\r\n            _disputesById[id].milestoneHash,\r\n            _disputesById[id].investor,\r\n            choice == Choice.INVESTOR_WINS\r\n        );\r\n\r\n        emit DisputeSolved(\r\n            id,\r\n            choice,\r\n            _disputesById[id].crowdsale,\r\n            _disputesById[id].milestoneHash,\r\n            _disputesById[id].investor\r\n        );\r\n    }\r\n\r\n    // -----------------------------------------\r\n    // GETTERS\r\n    // -----------------------------------------\r\n\r\n    function getDisputesAmount() external view returns (uint256) {\r\n        return _disputsAmount;\r\n    }\r\n\r\n    function getDisputeDetails(uint256 id) external view returns (bytes32, address, address, string memory, uint256, DisputeStatus status) {\r\n        Dispute memory dispute = _disputesById[id];\r\n        return (\r\n            dispute.milestoneHash,\r\n            dispute.crowdsale,\r\n            dispute.investor,\r\n            dispute.reason,\r\n            dispute.votesAmount,\r\n            dispute.status\r\n        );\r\n    }\r\n\r\n    function getMilestoneDisputes(bytes32 hash) external view returns (uint256[] memory disputesIDs) {\r\n        uint256 disputesLength = _disputesByMilestone[hash].length;\r\n        disputesIDs = new uint256[](disputesLength);\r\n\r\n        for (uint256 i = 0; i < disputesLength; i++) {\r\n            disputesIDs[i] = _disputesByMilestone[hash][i];\r\n        }\r\n\r\n        return disputesIDs;\r\n    }\r\n\r\n    function getInvestorDisputes(address investor) external view returns (uint256[] memory disputesIDs) {\r\n        uint256 disputesLength = _disputesByInvestor[investor].length;\r\n        disputesIDs = new uint256[](disputesLength);\r\n\r\n        for (uint256 i = 0; i < disputesLength; i++) {\r\n            disputesIDs[i] = _disputesByInvestor[investor][i];\r\n        }\r\n\r\n        return disputesIDs;\r\n    }\r\n\r\n    function getDisputeVotes(uint256 id) external view returns(address[] memory arbiters, Choice[] memory choices) {\r\n        uint256 votedArbitersAmount = _disputesById[id].votesAmount;\r\n        arbiters = new address[](votedArbitersAmount);\r\n        choices = new Choice[](votedArbitersAmount);\r\n\r\n        for (uint256 i = 0; i < votedArbitersAmount; i++) {\r\n            arbiters[i] = _disputesById[id].choices[i].arbiter;\r\n            choices[i] = _disputesById[id].choices[i].choice;\r\n        }\r\n\r\n        return (\r\n            arbiters,\r\n            choices\r\n        );\r\n    }\r\n\r\n    function hasDisputeSolved(uint256 id) external view returns (bool) {\r\n        return _disputesById[id].status == DisputeStatus.SOLVED;\r\n    }\r\n\r\n    function hasArbiterVoted(uint256 id, address arbiter) external view returns (bool) {\r\n        return _disputesById[id].hasVoted[arbiter];\r\n    }\r\n}\r\n\r\n// ---------------------------------------------------------------------------\r\n// CLUSTER CONTRACT\r\n// ---------------------------------------------------------------------------\r\n\r\n// File: contracts/interfaces/IArbitersPool.sol\r\n\r\ninterface IArbitersPool {\r\n    enum DisputeStatus { WAITING, SOLVED }\r\n    enum Choice { OPERATOR_WINS, INVESTOR_WINS }\r\n\r\n    function createDispute(bytes32 milestoneHash, address crowdsale, address investor, string calldata reason) external returns (uint256);\r\n\r\n    function voteDispute(uint256 id, Choice choice) external;\r\n\r\n    function addArbiter(address newArbiter) external;\r\n\r\n    function renounceArbiter(address arbiter) external;\r\n\r\n    function getDisputesAmount() external view returns (uint256);\r\n\r\n    function getDisputeDetails(uint256 id) external view returns (bytes32, address, address, string memory, uint256, DisputeStatus status);\r\n\r\n    function getMilestoneDisputes(bytes32 hash) external view returns (uint256[] memory disputesIDs);\r\n\r\n    function getInvestorDisputes(address investor) external view returns (uint256[] memory disputesIDs);\r\n\r\n    function getDisputeVotes(uint256 id) external view returns(address[] memory arbiters, Choice[] memory choices);\r\n\r\n    function getArbitersAmount() external view returns (uint256);\r\n\r\n    function isArbiter(address account) external view returns (bool);\r\n\r\n    function hasDisputeSolved(uint256 id) external view returns (bool);\r\n\r\n    function hasArbiterVoted(uint256 id, address arbiter) external view returns (bool);\r\n\r\n    function cluster() external view returns (address payable);\r\n\r\n    function isCluster() external view returns (bool);\r\n}\r\n\r\n// File: contracts/interfaces/IRICO.sol\r\n\r\ninterface IRICO {\r\n    enum MilestoneStatus { PENDING, DISPUTS_PERIOD, APPROVED }\r\n\r\n    function addCycle(\r\n        uint256 tokenPercent,\r\n        uint256 ethPercent,\r\n        bytes32[] calldata milestonesNames,\r\n        uint256[] calldata milestonesTokenPercent,\r\n        uint256[] calldata milestonesEthPercent,\r\n        uint256[] calldata milestonesStartTimestamps\r\n    ) external returns (bool);\r\n\r\n    function collectMilestoneInvestment(bytes32 hash) external;\r\n\r\n    function collectMilestoneResult(bytes32 hash) external;\r\n\r\n    function getCyclesAmount() external view returns (uint256);\r\n\r\n    function getCycleDetails(uint256 cycleId) external view returns (uint256, uint256, bytes32[] memory);\r\n\r\n    function getMilestonesHashes() external view returns (bytes32[] memory milestonesHashArray);\r\n\r\n    function getMilestoneDetails(bytes32 hash) external view returns (bytes32, uint256, uint256, uint256, uint256, uint256, uint256, MilestoneStatus status);\r\n\r\n    function getMilestoneStatus(bytes32 hash) external view returns (MilestoneStatus status);\r\n\r\n    function getCycleTotalPercents() external view returns (uint256, uint256);\r\n\r\n    function canInvestorOpenNewDispute(bytes32 hash, address investor) external view returns (bool);\r\n\r\n    function isMilestoneHasActiveDisputes(bytes32 hash) external view returns (bool);\r\n\r\n    function didInvestorOpenedDisputeBefore(bytes32 hash, address investor) external view returns (bool);\r\n\r\n    function didInvestorWithdraw(bytes32 hash, address investor) external view returns (bool);\r\n\r\n    function buyTokens(address beneficiary) external payable;\r\n\r\n    function isInvestor(address sender) external view returns (bool);\r\n\r\n    function openDispute(bytes32 hash, address investor) external returns (bool);\r\n\r\n    function solveDispute(bytes32 hash, address investor, bool investorWins) external;\r\n\r\n    function emergencyExit(address payable newContract) external;\r\n\r\n    function getCrowdsaleDetails() external view returns (uint256, address, uint256, uint256, uint256[] memory finishTimestamps, uint256[] memory bonuses);\r\n\r\n    function getInvestorBalances(address investor) external view returns (uint256, uint256, uint256, uint256, bool);\r\n\r\n    function getInvestorsArray() external view returns (address[] memory investors);\r\n\r\n    function getRaisedWei() external view returns (uint256);\r\n\r\n    function getSoldTokens() external view returns (uint256);\r\n\r\n    function refundETH() external;\r\n\r\n    function getOpeningTime() external view returns (uint256);\r\n\r\n    function getClosingTime() external view returns (uint256);\r\n\r\n    function isOpen() external view returns (bool);\r\n\r\n    function hasClosed() external view returns (bool);\r\n\r\n    function cluster() external view returns (address payable);\r\n\r\n    function isCluster() external view returns (bool);\r\n\r\n    function operator() external view returns (address payable);\r\n\r\n    function isOperator() external view returns (bool);\r\n}\r\n\r\n// File: contracts/ownerships/Ownable.sol\r\n\r\ncontract Ownable {\r\n    address payable private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n     * account.\r\n     */\r\n    constructor () internal {\r\n        _owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), _owner);\r\n    }\r\n\r\n    /**\r\n     * @return the address of the owner.\r\n     */\r\n    function owner() public view returns (address payable) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner(), \"onlyOwner: only the owner can call this method.\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @return true if `msg.sender` is the owner of the contract.\r\n     */\r\n    function isOwner() public view returns (bool) {\r\n        return msg.sender == _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function transferOwnership(address payable newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function _transferOwnership(address payable newOwner) private {\r\n        require(newOwner != address(0), \"_transferOwnership: the address of new operator is not valid.\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\n// File: contracts/ownerships/BackEndRole.sol\r\n\r\ncontract BackEndRole is Ownable {\r\n    using Roles for Roles.Role;\r\n\r\n    event BackEndAdded(address indexed account);\r\n    event BackEndRemoved(address indexed account);\r\n\r\n    Roles.Role private _backEnds;\r\n\r\n    modifier onlyBackEnd() {\r\n        require(isBackEnd(msg.sender), \"onlyBackEnd: only back end address can call this method.\");\r\n        _;\r\n    }\r\n\r\n    function isBackEnd(address account) public view returns (bool) {\r\n        return _backEnds.has(account);\r\n    }\r\n\r\n    function addBackEnd(address account) public onlyOwner {\r\n        _addBackEnd(account);\r\n    }\r\n\r\n    function removeBackEnd(address account) public onlyOwner {\r\n        _removeBackEnd(account);\r\n    }\r\n\r\n    function _addBackEnd(address account) private {\r\n        _backEnds.add(account);\r\n        emit BackEndAdded(account);\r\n    }\r\n\r\n    function _removeBackEnd(address account) private {\r\n        _backEnds.remove(account);\r\n        emit BackEndRemoved(account);\r\n    }\r\n}\r\n\r\n// File: contracts/Cluster.sol\r\n\r\ncontract Cluster is BackEndRole {\r\n    uint256 private constant _feeForMoreDisputes = 1 ether;\r\n\r\n    address private _arbitersPoolAddress;\r\n    address[] private _crowdsales;\r\n\r\n    mapping (address => address[]) private _operatorsContracts;\r\n\r\n    IArbitersPool private _arbitersPool;\r\n\r\n    event WeiFunded(address indexed sender, uint256 indexed amount);\r\n    event CrowdsaleCreated(\r\n        address crowdsale,\r\n        uint256 rate,\r\n        address token,\r\n        uint256 openingTime,\r\n        uint256 closingTime,\r\n        address operator,\r\n        uint256[] bonusFinishTimestamp,\r\n        uint256[] bonuses,\r\n        uint256 minInvestmentAmount,\r\n        uint256 fee\r\n    );\r\n\r\n    // -----------------------------------------\r\n    // CONSTRUCTOR\r\n    // -----------------------------------------\r\n\r\n    constructor () public {\r\n        _arbitersPoolAddress = address(new ArbitersPool());\r\n        _arbitersPool = IArbitersPool(_arbitersPoolAddress);\r\n    }\r\n\r\n    function() external payable {\r\n        emit WeiFunded(msg.sender, msg.value);\r\n    }\r\n\r\n    // -----------------------------------------\r\n    // OWNER FEATURES\r\n    // -----------------------------------------\r\n\r\n    function withdrawEth() external onlyOwner {\r\n        owner().transfer(address(this).balance);\r\n    }\r\n\r\n    function addArbiter(address newArbiter) external onlyBackEnd {\r\n        require(newArbiter != address(0), \"addArbiter: invalid type of address.\");\r\n\r\n        _arbitersPool.addArbiter(newArbiter);\r\n    }\r\n\r\n    function removeArbiter(address arbiter) external onlyBackEnd {\r\n        require(arbiter != address(0), \"removeArbiter: invalid type of address.\");\r\n\r\n        _arbitersPool.renounceArbiter(arbiter);\r\n    }\r\n\r\n    function addCrowdsale(\r\n        uint256 rate,\r\n        address token,\r\n        uint256 openingTime,\r\n        uint256 closingTime,\r\n        address payable operator,\r\n        uint256[] calldata bonusFinishTimestamp,\r\n        uint256[] calldata bonuses,\r\n        uint256 minInvestmentAmount,\r\n        uint256 fee\r\n        ) external onlyBackEnd returns (address) {\r\n        require(rate != 0, \"addCrowdsale: the rate should be bigger then 0.\");\r\n        require(token != address(0), \"addCrowdsale: invalid token address.\");\r\n        require(openingTime >= block.timestamp, \"addCrowdsale: invalid opening time.\");\r\n        require(closingTime > openingTime, \"addCrowdsale: invalid closing time.\");\r\n        require(operator != address(0), \"addCrowdsale: the address of operator is not valid.\");\r\n        require(bonusFinishTimestamp.length == bonuses.length, \"addCrowdsale: the length of bonusFinishTimestamp and bonuses is not equal.\");\r\n\r\n        address crowdsale = CrowdsaleDeployer.addCrowdsale(\r\n            rate,\r\n            token,\r\n            openingTime,\r\n            closingTime,\r\n            operator,\r\n            bonusFinishTimestamp,\r\n            bonuses,\r\n            minInvestmentAmount,\r\n            fee\r\n        );\r\n\r\n        // Updating the state\r\n        _crowdsales.push(crowdsale);\r\n        _operatorsContracts[operator].push(crowdsale);\r\n\r\n        emit CrowdsaleCreated(\r\n            crowdsale,\r\n            rate,\r\n            token,\r\n            openingTime,\r\n            closingTime,\r\n            operator,\r\n            bonusFinishTimestamp,\r\n            bonuses,\r\n            minInvestmentAmount,\r\n            fee\r\n        );\r\n        return crowdsale;\r\n    }\r\n\r\n    // -----------------------------------------\r\n    // OPERATOR FEATURES\r\n    // -----------------------------------------\r\n\r\n    function emergencyExit(address crowdsale, address payable newContract) external onlyOwner {\r\n        IRICO(crowdsale).emergencyExit(newContract);\r\n    }\r\n\r\n    // -----------------------------------------\r\n    // INVESTOR FEATURES\r\n    // -----------------------------------------\r\n\r\n    function openDispute(address crowdsale, bytes32 hash, string calldata reason) external payable returns (uint256) {\r\n        require(IRICO(crowdsale).isInvestor(msg.sender) == true, \"openDispute: sender is not an investor.\");\r\n        require(IRICO(crowdsale).canInvestorOpenNewDispute(hash, msg.sender) == true, \"openDispute: investor cannot open a new dispute.\");\r\n        require(IRICO(crowdsale).getMilestoneStatus(hash) == IRICO.MilestoneStatus.DISPUTS_PERIOD, \"openDispute: the period for opening new disputes was finished.\");\r\n\r\n        if (IRICO(crowdsale).didInvestorOpenedDisputeBefore(hash, msg.sender) == true) {\r\n            require(msg.value == _feeForMoreDisputes, \"openDispute: for the second and other disputes investor need to pay 1 ETH fee.\");\r\n        }\r\n\r\n        IRICO(crowdsale).openDispute(hash, msg.sender);\r\n        uint256 disputeID = _arbitersPool.createDispute(hash, crowdsale, msg.sender, reason);\r\n\r\n        return disputeID;\r\n    }\r\n\r\n    // -----------------------------------------\r\n    // ARBITERSPOOL FEATURES\r\n    // -----------------------------------------\r\n\r\n    function solveDispute(address crowdsale, bytes32 hash, address investor, bool investorWins) external {\r\n        require(msg.sender == _arbitersPoolAddress, \"solveDispute: the sender is not arbiters pool contract.\");\r\n\r\n        IRICO(crowdsale).solveDispute(hash, investor, investorWins);\r\n    }\r\n\r\n    // -----------------------------------------\r\n    // GETTERS\r\n    // -----------------------------------------\r\n\r\n    function getArbitersPoolAddress() external view returns (address) {\r\n        return _arbitersPoolAddress;\r\n    }\r\n\r\n    function getAllCrowdsalesAddresses() external view returns (address[] memory crowdsales) {\r\n        crowdsales = new address[](_crowdsales.length);\r\n        for (uint256 i = 0; i < _crowdsales.length; i++) {\r\n            crowdsales[i] = _crowdsales[i];\r\n        }\r\n        return crowdsales;\r\n    }\r\n\r\n    function getCrowdsaleMilestones(address crowdsale) external view returns(bytes32[] memory milestonesHashArray) {\r\n        return IRICO(crowdsale).getMilestonesHashes();\r\n    }\r\n\r\n    function getOperatorCrowdsaleAddresses(address operator) external view returns (address[] memory crowdsales) {\r\n        crowdsales = new address[](_operatorsContracts[operator].length);\r\n        for (uint256 i = 0; i < _operatorsContracts[operator].length; i++) {\r\n            crowdsales[i] = _operatorsContracts[operator][i];\r\n        }\r\n        return crowdsales;\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"arbiter\",\"type\":\"address\"}],\"name\":\"removeArbiter\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"crowdsale\",\"type\":\"address\"},{\"name\":\"hash\",\"type\":\"bytes32\"},{\"name\":\"investor\",\"type\":\"address\"},{\"name\":\"investorWins\",\"type\":\"bool\"}],\"name\":\"solveDispute\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"crowdsale\",\"type\":\"address\"},{\"name\":\"hash\",\"type\":\"bytes32\"},{\"name\":\"reason\",\"type\":\"string\"}],\"name\":\"openDispute\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"rate\",\"type\":\"uint256\"},{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"openingTime\",\"type\":\"uint256\"},{\"name\":\"closingTime\",\"type\":\"uint256\"},{\"name\":\"operator\",\"type\":\"address\"},{\"name\":\"bonusFinishTimestamp\",\"type\":\"uint256[]\"},{\"name\":\"bonuses\",\"type\":\"uint256[]\"},{\"name\":\"minInvestmentAmount\",\"type\":\"uint256\"},{\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"addCrowdsale\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"crowdsale\",\"type\":\"address\"},{\"name\":\"newContract\",\"type\":\"address\"}],\"name\":\"emergencyExit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isBackEnd\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getArbitersPoolAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"getOperatorCrowdsaleAddresses\",\"outputs\":[{\"name\":\"crowdsales\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawEth\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newArbiter\",\"type\":\"address\"}],\"name\":\"addArbiter\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"addBackEnd\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"removeBackEnd\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAllCrowdsalesAddresses\",\"outputs\":[{\"name\":\"crowdsales\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"crowdsale\",\"type\":\"address\"}],\"name\":\"getCrowdsaleMilestones\",\"outputs\":[{\"name\":\"milestonesHashArray\",\"type\":\"bytes32[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"WeiFunded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"crowdsale\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"rate\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"openingTime\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"closingTime\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"bonusFinishTimestamp\",\"type\":\"uint256[]\"},{\"indexed\":false,\"name\":\"bonuses\",\"type\":\"uint256[]\"},{\"indexed\":false,\"name\":\"minInvestmentAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"CrowdsaleCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"BackEndAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"BackEndRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"Cluster","CompilerVersion":"v0.5.3+commit.10d17f24","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"CrowdsaleDeployer:0B586AC698c6924021DC7ad3faB0C38B6192F8C3","SwarmSource":"bzzr://66c0641395d531498f791c465ecd9c40cbb051eca45c3f6b5c16d95ea116c1b1"}]}