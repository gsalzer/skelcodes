{"status":"1","message":"OK","result":[{"SourceCode":"/**\r\n * Copyright 2017â€“2018, bZeroX, LLC. All Rights Reserved.\r\n * Licensed under the Apache License, Version 2.0.\r\n */\r\n \r\npragma solidity 0.5.3;\r\npragma experimental ABIEncoderV2;\r\n\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * See https://github.com/ethereum/EIPs/issues/179\r\n */\r\ncontract ERC20Basic {\r\n  function totalSupply() public view returns (uint256);\r\n  function balanceOf(address _who) public view returns (uint256);\r\n  function transfer(address _to, uint256 _value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address _owner, address _spender)\r\n    public view returns (uint256);\r\n\r\n  function transferFrom(address _from, address _to, uint256 _value)\r\n    public returns (bool);\r\n\r\n  function approve(address _spender, uint256 _value) public returns (bool);\r\n  event Approval(\r\n    address indexed owner,\r\n    address indexed spender,\r\n    uint256 value\r\n  );\r\n}\r\n\r\ncontract EIP20 is ERC20 {\r\n    string public name;\r\n    uint8 public decimals;\r\n    string public symbol;\r\n}\r\n\r\ninterface NonCompliantEIP20 {\r\n    function transfer(address _to, uint256 _value) external;\r\n    function transferFrom(address _from, address _to, uint256 _value) external;\r\n    function approve(address _spender, uint256 _value) external;\r\n}\r\n\r\ncontract EIP20Wrapper {\r\n\r\n    function eip20Transfer(\r\n        address token,\r\n        address to,\r\n        uint256 value)\r\n        internal\r\n        returns (bool result) {\r\n\r\n        NonCompliantEIP20(token).transfer(to, value);\r\n\r\n        assembly {\r\n            switch returndatasize()   \r\n            case 0 {                        // non compliant ERC20\r\n                result := not(0)            // result is true\r\n            }\r\n            case 32 {                       // compliant ERC20\r\n                returndatacopy(0, 0, 32) \r\n                result := mload(0)          // result == returndata of external call\r\n            }\r\n            default {                       // not an not an ERC20 token\r\n                revert(0, 0) \r\n            }\r\n        }\r\n\r\n        require(result, \"eip20Transfer failed\");\r\n    }\r\n\r\n    function eip20TransferFrom(\r\n        address token,\r\n        address from,\r\n        address to,\r\n        uint256 value)\r\n        internal\r\n        returns (bool result) {\r\n\r\n        NonCompliantEIP20(token).transferFrom(from, to, value);\r\n\r\n        assembly {\r\n            switch returndatasize()   \r\n            case 0 {                        // non compliant ERC20\r\n                result := not(0)            // result is true\r\n            }\r\n            case 32 {                       // compliant ERC20\r\n                returndatacopy(0, 0, 32) \r\n                result := mload(0)          // result == returndata of external call\r\n            }\r\n            default {                       // not an not an ERC20 token\r\n                revert(0, 0) \r\n            }\r\n        }\r\n\r\n        require(result, \"eip20TransferFrom failed\");\r\n    }\r\n\r\n    function eip20Approve(\r\n        address token,\r\n        address spender,\r\n        uint256 value)\r\n        internal\r\n        returns (bool result) {\r\n\r\n        NonCompliantEIP20(token).approve(spender, value);\r\n\r\n        assembly {\r\n            switch returndatasize()   \r\n            case 0 {                        // non compliant ERC20\r\n                result := not(0)            // result is true\r\n            }\r\n            case 32 {                       // compliant ERC20\r\n                returndatacopy(0, 0, 32) \r\n                result := mload(0)          // result == returndata of external call\r\n            }\r\n            default {                       // not an not an ERC20 token\r\n                revert(0, 0) \r\n            }\r\n        }\r\n\r\n        require(result, \"eip20Approve failed\");\r\n    }\r\n}\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\r\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (_a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    c = _a * _b;\r\n    assert(c / _a == _b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    // assert(_b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = _a / _b;\r\n    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\r\n    return _a / _b;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, rounding up and truncating the quotient\r\n  */\r\n  function divCeil(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    if (_a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    return ((_a - 1) / _b) + 1;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    assert(_b <= _a);\r\n    return _a - _b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\r\n    c = _a + _b;\r\n    assert(c >= _a);\r\n    return c;\r\n  }\r\n}\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n  event OwnershipTransferred(\r\n    address indexed previousOwner,\r\n    address indexed newOwner\r\n  );\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  constructor() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address _newOwner) public onlyOwner {\r\n    _transferOwnership(_newOwner);\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function _transferOwnership(address _newOwner) internal {\r\n    require(_newOwner != address(0));\r\n    emit OwnershipTransferred(owner, _newOwner);\r\n    owner = _newOwner;\r\n  }\r\n}\r\n\r\ncontract BZxOwnable is Ownable {\r\n\r\n    address public bZxContractAddress;\r\n\r\n    event BZxOwnershipTransferred(address indexed previousBZxContract, address indexed newBZxContract);\r\n\r\n    // modifier reverts if bZxContractAddress isn't set\r\n    modifier onlyBZx() {\r\n        require(msg.sender == bZxContractAddress, \"only bZx contracts can call this function\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev Allows the current owner to transfer the bZx contract owner to a new contract address\r\n    * @param newBZxContractAddress The bZx contract address to transfer ownership to.\r\n    */\r\n    function transferBZxOwnership(address newBZxContractAddress) public onlyOwner {\r\n        require(newBZxContractAddress != address(0) && newBZxContractAddress != owner, \"transferBZxOwnership::unauthorized\");\r\n        emit BZxOwnershipTransferred(bZxContractAddress, newBZxContractAddress);\r\n        bZxContractAddress = newBZxContractAddress;\r\n    }\r\n\r\n    /**\r\n    * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n    * @param newOwner The address to transfer ownership to.\r\n    * This overrides transferOwnership in Ownable to prevent setting the new owner the same as the bZxContract\r\n    */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        require(newOwner != address(0) && newOwner != bZxContractAddress, \"transferOwnership::unauthorized\");\r\n        emit OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n}\r\n\r\ncontract ExchangeV2Interface {\r\n\r\n    struct OrderV2 {\r\n        address makerAddress;           // Address that created the order.\r\n        address takerAddress;           // Address that is allowed to fill the order. If set to 0, any address is allowed to fill the order.\r\n        address feeRecipientAddress;    // Address that will recieve fees when order is filled.\r\n        address senderAddress;          // Address that is allowed to call Exchange contract methods that affect this order. If set to 0, any address is allowed to call these methods.\r\n        uint256 makerAssetAmount;       // Amount of makerAsset being offered by maker. Must be greater than 0.\r\n        uint256 takerAssetAmount;       // Amount of takerAsset being bid on by maker. Must be greater than 0.\r\n        uint256 makerFee;               // Amount of ZRX paid to feeRecipient by maker when order is filled. If set to 0, no transfer of ZRX from maker to feeRecipient will be attempted.\r\n        uint256 takerFee;               // Amount of ZRX paid to feeRecipient by taker when order is filled. If set to 0, no transfer of ZRX from taker to feeRecipient will be attempted.\r\n        uint256 expirationTimeSeconds;  // Timestamp in seconds at which order expires.\r\n        uint256 salt;                   // Arbitrary number to facilitate uniqueness of the order's hash.\r\n        bytes makerAssetData;           // Encoded data that can be decoded by a specified proxy contract when transferring makerAsset. The last byte references the id of this proxy.\r\n        bytes takerAssetData;           // Encoded data that can be decoded by a specified proxy contract when transferring takerAsset. The last byte references the id of this proxy.\r\n    }\r\n\r\n    struct FillResults {\r\n        uint256 makerAssetFilledAmount;  // Total amount of makerAsset(s) filled.\r\n        uint256 takerAssetFilledAmount;  // Total amount of takerAsset(s) filled.\r\n        uint256 makerFeePaid;            // Total amount of ZRX paid by maker(s) to feeRecipient(s).\r\n        uint256 takerFeePaid;            // Total amount of ZRX paid by taker to feeRecipients(s).\r\n    }\r\n\r\n    /// @dev Fills the input order.\r\n    ///      Returns false if the transaction would otherwise revert.\r\n    /// @param order Order struct containing order specifications.\r\n    /// @param takerAssetFillAmount Desired amount of takerAsset to sell.\r\n    /// @param signature Proof that order has been created by maker.\r\n    /// @return Amounts filled and fees paid by maker and taker.\r\n    function fillOrderNoThrow(\r\n        OrderV2 memory order,\r\n        uint256 takerAssetFillAmount,\r\n        bytes memory signature)\r\n        public\r\n        returns (FillResults memory fillResults);\r\n\r\n    /// @dev Synchronously executes multiple calls of fillOrder until total amount of takerAsset is sold by taker.\r\n    ///      Returns false if the transaction would otherwise revert.\r\n    /// @param orders Array of order specifications.\r\n    /// @param takerAssetFillAmount Desired amount of takerAsset to sell.\r\n    /// @param signatures Proofs that orders have been signed by makers.\r\n    /// @return Amounts filled and fees paid by makers and taker.\r\n    function marketSellOrdersNoThrow(\r\n        OrderV2[] memory orders,\r\n        uint256 takerAssetFillAmount,\r\n        bytes[] memory signatures)\r\n        public\r\n        returns (FillResults memory totalFillResults);\r\n\r\n\r\n    /// @dev Verifies that a signature is valid.\r\n    /// @param hash Message hash that is signed.\r\n    /// @param signerAddress Address that should have signed the given hash.\r\n    /// @param signature Proof of signing.\r\n    /// @return Validity of order signature.\r\n    function isValidSignature(\r\n        bytes32 hash,\r\n        address signerAddress,\r\n        bytes calldata signature)\r\n        external\r\n        view\r\n        returns (bool isValid);\r\n}\r\n\r\ncontract BZxTo0xShared {\r\n    using SafeMath for uint256;\r\n\r\n    /// @dev Calculates partial value given a numerator and denominator rounded down.\r\n    ///      Reverts if rounding error is >= 0.1%\r\n    /// @param numerator Numerator.\r\n    /// @param denominator Denominator.\r\n    /// @param target Value to calculate partial of.\r\n    /// @return Partial value of target rounded down.\r\n    function _safeGetPartialAmountFloor(\r\n        uint256 numerator,\r\n        uint256 denominator,\r\n        uint256 target\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256 partialAmount)\r\n    {\r\n        require(\r\n            denominator > 0,\r\n            \"DIVISION_BY_ZERO\"\r\n        );\r\n\r\n        require(\r\n            !_isRoundingErrorFloor(\r\n                numerator,\r\n                denominator,\r\n                target\r\n            ),\r\n            \"ROUNDING_ERROR\"\r\n        );\r\n        \r\n        partialAmount = SafeMath.div(\r\n            SafeMath.mul(numerator, target),\r\n            denominator\r\n        );\r\n        return partialAmount;\r\n    }\r\n\r\n    /// @dev Checks if rounding error >= 0.1% when rounding down.\r\n    /// @param numerator Numerator.\r\n    /// @param denominator Denominator.\r\n    /// @param target Value to multiply with numerator/denominator.\r\n    /// @return Rounding error is present.\r\n    function _isRoundingErrorFloor(\r\n        uint256 numerator,\r\n        uint256 denominator,\r\n        uint256 target\r\n    )\r\n        internal\r\n        pure\r\n        returns (bool isError)\r\n    {\r\n        require(\r\n            denominator > 0,\r\n            \"DIVISION_BY_ZERO\"\r\n        );\r\n        \r\n        // The absolute rounding error is the difference between the rounded\r\n        // value and the ideal value. The relative rounding error is the\r\n        // absolute rounding error divided by the absolute value of the\r\n        // ideal value. This is undefined when the ideal value is zero.\r\n        //\r\n        // The ideal value is `numerator * target / denominator`.\r\n        // Let's call `numerator * target % denominator` the remainder.\r\n        // The absolute error is `remainder / denominator`.\r\n        //\r\n        // When the ideal value is zero, we require the absolute error to\r\n        // be zero. Fortunately, this is always the case. The ideal value is\r\n        // zero iff `numerator == 0` and/or `target == 0`. In this case the\r\n        // remainder and absolute error are also zero. \r\n        if (target == 0 || numerator == 0) {\r\n            return false;\r\n        }\r\n        \r\n        // Otherwise, we want the relative rounding error to be strictly\r\n        // less than 0.1%.\r\n        // The relative error is `remainder / (numerator * target)`.\r\n        // We want the relative error less than 1 / 1000:\r\n        //        remainder / (numerator * denominator)  <  1 / 1000\r\n        // or equivalently:\r\n        //        1000 * remainder  <  numerator * target\r\n        // so we have a rounding error iff:\r\n        //        1000 * remainder  >=  numerator * target\r\n        uint256 remainder = mulmod(\r\n            target,\r\n            numerator,\r\n            denominator\r\n        );\r\n        isError = SafeMath.mul(1000, remainder) >= SafeMath.mul(numerator, target);\r\n        return isError;\r\n    }\r\n}\r\n\r\ncontract BZxTo0xV2 is BZxTo0xShared, EIP20Wrapper, BZxOwnable {\r\n    using SafeMath for uint256;\r\n\r\n    event LogFillResults(\r\n        uint256 makerAssetFilledAmount,\r\n        uint256 takerAssetFilledAmount,\r\n        uint256 makerFeePaid,\r\n        uint256 takerFeePaid\r\n    );\r\n\r\n    bool public DEBUG = false;\r\n\r\n    address public exchangeV2Contract;\r\n    address public zrxTokenContract;\r\n    address public erc20ProxyContract;\r\n\r\n    constructor(\r\n        address _exchangeV2,\r\n        address _zrxToken,\r\n        address _proxy)\r\n        public\r\n    {\r\n        exchangeV2Contract = _exchangeV2;\r\n        zrxTokenContract = _zrxToken;\r\n        erc20ProxyContract = _proxy;\r\n    }\r\n\r\n    function()\r\n        external {\r\n        revert();\r\n    }\r\n\r\n    // 0xc78429c4 == \"take0xV2Trade(address,address,uint256,(address,address,address,address,uint256,uint256,uint256,uint256,uint256,uint256,bytes,bytes)[],bytes[])\"\r\n    function take0xV2Trade(\r\n        address trader,\r\n        address vaultAddress,\r\n        uint256 sourceTokenAmountToUse,\r\n        ExchangeV2Interface.OrderV2[] memory orders0x, // Array of 0x V2 order structs\r\n        bytes[] memory signatures0x) // Array of signatures for each of the V2 orders\r\n        public\r\n        onlyBZx\r\n        returns (\r\n            address destTokenAddress,\r\n            uint256 destTokenAmount,\r\n            uint256 sourceTokenUsedAmount)\r\n    {\r\n        address sourceTokenAddress;\r\n\r\n        //destTokenAddress==makerToken, sourceTokenAddress==takerToken\r\n        (destTokenAddress, sourceTokenAddress) = getV2Tokens(orders0x[0]);\r\n\r\n        (sourceTokenUsedAmount, destTokenAmount) = _take0xV2Trade(\r\n            trader,\r\n            sourceTokenAddress,\r\n            sourceTokenAmountToUse,\r\n            orders0x,\r\n            signatures0x);\r\n\r\n        if (sourceTokenUsedAmount < sourceTokenAmountToUse) {\r\n            // all sourceToken has to be traded\r\n            revert(\"BZxTo0xV2::take0xTrade: sourceTokenUsedAmount < sourceTokenAmountToUse\");\r\n        }\r\n\r\n        // transfer the destToken to the vault\r\n        eip20Transfer(\r\n            destTokenAddress,\r\n            vaultAddress,\r\n            destTokenAmount);\r\n    }\r\n\r\n    /// @dev Calculates partial value given a numerator and denominator.\r\n    /// @param numerator Numerator.\r\n    /// @param denominator Denominator.\r\n    /// @param target Value to calculate partial of.\r\n    /// @return Partial value of target.\r\n    function getPartialAmount(uint256 numerator, uint256 denominator, uint256 target)\r\n        public\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return SafeMath.div(SafeMath.mul(numerator, target), denominator);\r\n    }\r\n\r\n    /// @dev Extracts the maker and taker token addresses from the 0x V2 order object.\r\n    /// @param order 0x V2 order object.\r\n    /// @return makerTokenAddress and takerTokenAddress.\r\n    function getV2Tokens(\r\n        ExchangeV2Interface.OrderV2 memory order)\r\n        public\r\n        pure\r\n        returns (\r\n            address makerTokenAddress,\r\n            address takerTokenAddress)\r\n    {\r\n        bytes memory makerAssetData = order.makerAssetData;\r\n        bytes memory takerAssetData = order.takerAssetData;\r\n        bytes4 makerProxyID;\r\n        bytes4 takerProxyID;\r\n\r\n        // example data: 0xf47261b00000000000000000000000001dc4c1cefef38a777b15aa20260a54e584b16c48\r\n        assembly {\r\n            makerProxyID := mload(add(makerAssetData, 32))\r\n            takerProxyID := mload(add(takerAssetData, 32))\r\n\r\n            makerTokenAddress := mload(add(makerAssetData, 36))\r\n            takerTokenAddress := mload(add(takerAssetData, 36))\r\n        }\r\n\r\n        // ERC20 Proxy ID -> bytes4(keccak256(\"ERC20Token(address)\")) = 0xf47261b0\r\n        require(makerProxyID == 0xf47261b0 && takerProxyID == 0xf47261b0, \"BZxTo0xV2::getV2Tokens: 0x V2 orders must use ERC20 tokens\");\r\n    }\r\n\r\n    function set0xV2Exchange (\r\n        address _exchange)\r\n        public\r\n        onlyOwner\r\n    {\r\n        exchangeV2Contract = _exchange;\r\n    }\r\n\r\n    function setZRXToken (\r\n        address _zrxToken)\r\n        public\r\n        onlyOwner\r\n    {\r\n        zrxTokenContract = _zrxToken;\r\n    }\r\n\r\n    function set0xTokenProxy (\r\n        address _proxy)\r\n        public\r\n        onlyOwner\r\n    {\r\n        erc20ProxyContract = _proxy;\r\n    }\r\n\r\n    function approveFor (\r\n        address token,\r\n        address spender,\r\n        uint256 value)\r\n        public\r\n        onlyOwner\r\n        returns (bool)\r\n    {\r\n        eip20Approve(\r\n            token,\r\n            spender,\r\n            value);\r\n\r\n        return true;\r\n    }\r\n\r\n    function toggleDebug (\r\n        bool isDebug)\r\n        public\r\n        onlyOwner\r\n    {\r\n        DEBUG = isDebug;\r\n    }\r\n\r\n    function _take0xV2Trade(\r\n        address trader,\r\n        address sourceTokenAddress,\r\n        uint256 sourceTokenAmountToUse,\r\n        ExchangeV2Interface.OrderV2[] memory orders0x, // Array of 0x V2 order structs\r\n        bytes[] memory signatures0x)\r\n        internal\r\n        returns (uint256 sourceTokenUsedAmount, uint256 destTokenAmount)\r\n    {\r\n        uint256 zrxTokenAmount = 0;\r\n        uint256 takerAssetRemaining = sourceTokenAmountToUse;\r\n        for (uint256 i = 0; i < orders0x.length; i++) {\r\n            // Note: takerAssetData (sourceToken) is confirmed to be the same in 0x for batch orders\r\n            // To confirm makerAssetData is the same for each order, rather than doing a more expensive per order bytes\r\n            // comparison, we will simply set makerAssetData the same in each order to the first value observed. The 0x\r\n            // trade will fail for invalid orders.\r\n            if (i > 0)\r\n                orders0x[i].makerAssetData = orders0x[0].makerAssetData;\r\n\r\n            // calculate required takerFee\r\n            if (takerAssetRemaining > 0 && orders0x[i].takerFee > 0) { // takerFee\r\n                if (takerAssetRemaining >= orders0x[i].takerAssetAmount) {\r\n                    zrxTokenAmount = zrxTokenAmount.add(orders0x[i].takerFee);\r\n                    takerAssetRemaining = takerAssetRemaining.sub(orders0x[i].takerAssetAmount);\r\n                } else {\r\n                    zrxTokenAmount = zrxTokenAmount.add(_safeGetPartialAmountFloor(\r\n                        takerAssetRemaining,\r\n                        orders0x[i].takerAssetAmount,\r\n                        orders0x[i].takerFee\r\n                    ));\r\n                    takerAssetRemaining = 0;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (zrxTokenAmount > 0) {\r\n            // The 0x erc20ProxyContract already has unlimited transfer allowance for ZRX from this contract (set during deployment of this contract)\r\n            eip20TransferFrom(\r\n                zrxTokenContract,\r\n                trader,\r\n                address(this),\r\n                zrxTokenAmount);\r\n        }\r\n\r\n        // Make sure there is enough allowance for 0x Exchange Proxy to transfer the sourceToken needed for the 0x trade\r\n        uint256 tempAllowance = EIP20(sourceTokenAddress).allowance(address(this), erc20ProxyContract);\r\n        if (tempAllowance < sourceTokenAmountToUse) {\r\n            if (tempAllowance > 0) {\r\n                // reset approval to 0\r\n                eip20Approve(\r\n                    sourceTokenAddress,\r\n                    erc20ProxyContract,\r\n                    0);\r\n            }\r\n\r\n            eip20Approve(\r\n                sourceTokenAddress,\r\n                erc20ProxyContract,\r\n                sourceTokenAmountToUse);\r\n        }\r\n\r\n        ExchangeV2Interface.FillResults memory fillResults;\r\n        if (orders0x.length > 1) {\r\n            fillResults = ExchangeV2Interface(exchangeV2Contract).marketSellOrdersNoThrow(\r\n                orders0x,\r\n                sourceTokenAmountToUse,\r\n                signatures0x);\r\n        } else {\r\n            fillResults = ExchangeV2Interface(exchangeV2Contract).fillOrderNoThrow(\r\n                orders0x[0],\r\n                sourceTokenAmountToUse,\r\n                signatures0x[0]);\r\n        }\r\n\r\n        if (zrxTokenAmount > 0 && fillResults.takerFeePaid < zrxTokenAmount) {\r\n            // refund unused ZRX token (if any)\r\n            eip20Transfer(\r\n                zrxTokenContract,\r\n                trader,\r\n                zrxTokenAmount.sub(fillResults.takerFeePaid));\r\n        }\r\n\r\n        if (DEBUG) {\r\n            emit LogFillResults(\r\n                fillResults.makerAssetFilledAmount,\r\n                fillResults.takerAssetFilledAmount,\r\n                fillResults.makerFeePaid,\r\n                fillResults.takerFeePaid\r\n            );\r\n        }\r\n\r\n        sourceTokenUsedAmount = fillResults.takerAssetFilledAmount;\r\n        destTokenAmount = fillResults.makerAssetFilledAmount;\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_exchange\",\"type\":\"address\"}],\"name\":\"set0xV2Exchange\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"DEBUG\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"approveFor\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_zrxToken\",\"type\":\"address\"}],\"name\":\"setZRXToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"isDebug\",\"type\":\"bool\"}],\"name\":\"toggleDebug\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"erc20ProxyContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newBZxContractAddress\",\"type\":\"address\"}],\"name\":\"transferBZxOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"exchangeV2Contract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"numerator\",\"type\":\"uint256\"},{\"name\":\"denominator\",\"type\":\"uint256\"},{\"name\":\"target\",\"type\":\"uint256\"}],\"name\":\"getPartialAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"components\":[{\"name\":\"makerAddress\",\"type\":\"address\"},{\"name\":\"takerAddress\",\"type\":\"address\"},{\"name\":\"feeRecipientAddress\",\"type\":\"address\"},{\"name\":\"senderAddress\",\"type\":\"address\"},{\"name\":\"makerAssetAmount\",\"type\":\"uint256\"},{\"name\":\"takerAssetAmount\",\"type\":\"uint256\"},{\"name\":\"makerFee\",\"type\":\"uint256\"},{\"name\":\"takerFee\",\"type\":\"uint256\"},{\"name\":\"expirationTimeSeconds\",\"type\":\"uint256\"},{\"name\":\"salt\",\"type\":\"uint256\"},{\"name\":\"makerAssetData\",\"type\":\"bytes\"},{\"name\":\"takerAssetData\",\"type\":\"bytes\"}],\"name\":\"order\",\"type\":\"tuple\"}],\"name\":\"getV2Tokens\",\"outputs\":[{\"name\":\"makerTokenAddress\",\"type\":\"address\"},{\"name\":\"takerTokenAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"trader\",\"type\":\"address\"},{\"name\":\"vaultAddress\",\"type\":\"address\"},{\"name\":\"sourceTokenAmountToUse\",\"type\":\"uint256\"},{\"components\":[{\"name\":\"makerAddress\",\"type\":\"address\"},{\"name\":\"takerAddress\",\"type\":\"address\"},{\"name\":\"feeRecipientAddress\",\"type\":\"address\"},{\"name\":\"senderAddress\",\"type\":\"address\"},{\"name\":\"makerAssetAmount\",\"type\":\"uint256\"},{\"name\":\"takerAssetAmount\",\"type\":\"uint256\"},{\"name\":\"makerFee\",\"type\":\"uint256\"},{\"name\":\"takerFee\",\"type\":\"uint256\"},{\"name\":\"expirationTimeSeconds\",\"type\":\"uint256\"},{\"name\":\"salt\",\"type\":\"uint256\"},{\"name\":\"makerAssetData\",\"type\":\"bytes\"},{\"name\":\"takerAssetData\",\"type\":\"bytes\"}],\"name\":\"orders0x\",\"type\":\"tuple[]\"},{\"name\":\"signatures0x\",\"type\":\"bytes[]\"}],\"name\":\"take0xV2Trade\",\"outputs\":[{\"name\":\"destTokenAddress\",\"type\":\"address\"},{\"name\":\"destTokenAmount\",\"type\":\"uint256\"},{\"name\":\"sourceTokenUsedAmount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"zrxTokenContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bZxContractAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_proxy\",\"type\":\"address\"}],\"name\":\"set0xTokenProxy\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_exchangeV2\",\"type\":\"address\"},{\"name\":\"_zrxToken\",\"type\":\"address\"},{\"name\":\"_proxy\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"makerAssetFilledAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"takerAssetFilledAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"makerFeePaid\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"takerFeePaid\",\"type\":\"uint256\"}],\"name\":\"LogFillResults\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousBZxContract\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newBZxContract\",\"type\":\"address\"}],\"name\":\"BZxOwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"BZxTo0xV2","CompilerVersion":"v0.5.3+commit.10d17f24","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000004f833a24e1f95d70f028921e27040ca56e09ab0b000000000000000000000000e41d2489571d322189246dafa5ebde1f4699f4980000000000000000000000002240dab907db71e64d3e0dba4800c83b5c502d4e","Library":"","SwarmSource":"bzzr://f7b6535f4094349b987030e529ce2c09f021372cf4c6934aa343f9b169589014"}]}