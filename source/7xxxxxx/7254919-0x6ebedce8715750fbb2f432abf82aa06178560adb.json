{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.24;\r\n\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n    address public owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n    * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n    * account.\r\n    */\r\n    constructor(address _owner) public {\r\n        owner = _owner;\r\n    }\r\n\r\n    /**\r\n    * @dev Throws if called by any account other than the owner.\r\n    */\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n    * @param newOwner The address to transfer ownership to.\r\n    */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        require(newOwner != address(0));\r\n        emit OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n\r\n}\r\n\r\n\r\n\r\n/**\r\n * @title Validator\r\n * @dev The Validator contract has a validator address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Validator {\r\n    address public validator;\r\n\r\n    event NewValidatorSet(address indexed previousOwner, address indexed newValidator);\r\n\r\n    /**\r\n    * @dev The Validator constructor sets the original `validator` of the contract to the sender\r\n    * account.\r\n    */\r\n    constructor() public {\r\n        validator = msg.sender;\r\n    }\r\n\r\n    /**\r\n    * @dev Throws if called by any account other than the validator.\r\n    */\r\n    modifier onlyValidator() {\r\n        require(msg.sender == validator);\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev Allows the current validator to transfer control of the contract to a newValidator.\r\n    * @param newValidator The address to become next validator.\r\n    */\r\n    function setNewValidator(address newValidator) public onlyValidator {\r\n        require(newValidator != address(0));\r\n        emit NewValidatorSet(validator, newValidator);\r\n        validator = newValidator;\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n\r\n\r\ncontract TokenInterface {\r\n    function mint(address _to, uint256 _amount) public returns (bool);\r\n    function finishMinting() public returns (bool);\r\n    function transferOwnership(address newOwner) public;\r\n}\r\n\r\n\r\n/**\r\n * @title Crowdsale\r\n * @dev Crowdsale is a base contract for managing a token crowdsale.\r\n * Crowdsales have a start and end timestamps, where investors can make\r\n * token purchases and the crowdsale will assign them tokens based\r\n * on a token per ETH rate. Funds collected are forwarded to a wallet\r\n * as they arrive. The contract requires a MintableToken that will be\r\n * minted as contributions arrive, note that the crowdsale contract\r\n * must be owner of the token in order to be able to mint it.\r\n */\r\ncontract Crowdsale {\r\n    using SafeMath for uint256;\r\n\r\n    // The token being sold\r\n    address public token;\r\n\r\n    // start and end timestamps where investments are allowed (both inclusive)\r\n    uint256 public startTime;\r\n    uint256 public endTime;\r\n\r\n    // address where funds are collected\r\n    address public wallet;\r\n\r\n    // how many token units a buyer gets per ether\r\n    uint256 public rate;\r\n\r\n    // amount of raised money in wei\r\n    uint256 public weiRaised;\r\n\r\n    // maximum amount of wei that can be raised\r\n    uint256 public hardCap;\r\n\r\n    /**\r\n    * event for token purchase logging\r\n    * @param purchaser who paid for the tokens\r\n    * @param beneficiary who got the tokens\r\n    * @param value weis paid for purchase\r\n    * @param amount amount of tokens purchased\r\n    */\r\n    event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);\r\n\r\n    constructor(uint256 _startTime, uint256 _endTime, uint256 _hardCap, uint256 _rate, address _wallet, address _token) public {\r\n        require(_startTime >= now);\r\n        require(_endTime >= _startTime);\r\n        require(_rate > 0);\r\n        require(_wallet != address(0));\r\n        require(_token != address(0));\r\n\r\n        startTime = _startTime;\r\n        endTime = _endTime;\r\n        hardCap = _hardCap;\r\n        rate = _rate;\r\n        wallet = _wallet;\r\n        token = _token;\r\n    }\r\n\r\n    // fallback function can be used to buy tokens\r\n    function () external payable {\r\n        buyTokens(msg.sender);\r\n    }\r\n\r\n    // low level token purchase function\r\n    function buyTokens(address beneficiary) public payable {\r\n        require(beneficiary != address(0));\r\n        require(validPurchase());\r\n\r\n        uint256 weiAmount = msg.value;\r\n\r\n        // calculate token amount to be created\r\n        uint256 tokens = getTokenAmount(weiAmount);\r\n\r\n        // update state\r\n        weiRaised = weiRaised.add(weiAmount);\r\n\r\n        TokenInterface(token).mint(beneficiary, tokens);\r\n        emit TokenPurchase(msg.sender, beneficiary, weiAmount, tokens);\r\n\r\n        forwardFunds();\r\n    }\r\n\r\n    // @return true if crowdsale event has ended\r\n    function hasEnded() public view returns (bool) {\r\n        return now > endTime;\r\n    }\r\n\r\n    // Override this method to have a way to add business logic to your crowdsale when buying\r\n    function getTokenAmount(uint256 weiAmount) internal view returns(uint256) {\r\n        return weiAmount.mul(rate);\r\n    }\r\n\r\n    // send ether to the fund collection wallet\r\n    // override to create custom fund forwarding mechanisms\r\n    function forwardFunds() internal {\r\n        wallet.transfer(msg.value);\r\n    }\r\n\r\n    // @return true if the transaction can buy tokens\r\n    function validPurchase() internal view returns (bool) {\r\n        require(weiRaised.add(msg.value) <= hardCap);\r\n        bool withinPeriod = now >= startTime && now <= endTime;\r\n        bool nonZeroPurchase = msg.value != 0;\r\n        return withinPeriod && nonZeroPurchase;\r\n    }\r\n\r\n}\r\n\r\n\r\n\r\n/**\r\n * @title FinalizableCrowdsale\r\n * @dev Extension of Crowdsale where an owner can do extra work\r\n * after finishing.\r\n */\r\ncontract FinalizableCrowdsale is Crowdsale, Ownable {\r\n    using SafeMath for uint256;\r\n\r\n    bool public isFinalized = false;\r\n\r\n    event Finalized();\r\n \r\n    constructor(address _owner) public Ownable(_owner) {}\r\n\r\n    /**\r\n    * @dev Must be called after crowdsale ends, to do some extra finalization\r\n    * work. Calls the contract's finalization function.\r\n    */\r\n    function finalize() onlyOwner public {\r\n        require(!isFinalized);\r\n        require(hasEnded());\r\n\r\n        finalization();\r\n        emit Finalized();\r\n\r\n        isFinalized = true;\r\n    }\r\n\r\n    /**\r\n    * @dev Can be overridden to add finalization logic. The overriding function\r\n    * should call super.finalization() to ensure the chain of finalization is\r\n    * executed entirely.\r\n    */\r\n    function finalization() internal {}\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract Whitelist is Ownable {\r\n    mapping(address => bool) internal investorMap;\r\n\r\n    /**\r\n    * event for investor approval logging\r\n    * @param investor approved investor\r\n    */\r\n    event Approved(address indexed investor);\r\n\r\n    /**\r\n    * event for investor disapproval logging\r\n    * @param investor disapproved investor\r\n    */\r\n    event Disapproved(address indexed investor);\r\n\r\n    constructor(address _owner) \r\n        public \r\n        Ownable(_owner) \r\n    {\r\n        \r\n    }\r\n\r\n    /** @param _investor the address of investor to be checked\r\n      * @return true if investor is approved\r\n      */\r\n    function isInvestorApproved(address _investor) external view returns (bool) {\r\n        require(_investor != address(0));\r\n        return investorMap[_investor];\r\n    }\r\n\r\n    /** @dev approve an investor\r\n      * @param toApprove investor to be approved\r\n      */\r\n    function approveInvestor(address toApprove) external onlyOwner {\r\n        investorMap[toApprove] = true;\r\n        emit Approved(toApprove);\r\n    }\r\n\r\n    /** @dev approve investors in bulk\r\n      * @param toApprove array of investors to be approved\r\n      */\r\n    function approveInvestorsInBulk(address[] toApprove) external onlyOwner {\r\n        for (uint i = 0; i < toApprove.length; i++) {\r\n            investorMap[toApprove[i]] = true;\r\n            emit Approved(toApprove[i]);\r\n        }\r\n    }\r\n\r\n    /** @dev disapprove an investor\r\n      * @param toDisapprove investor to be disapproved\r\n      */\r\n    function disapproveInvestor(address toDisapprove) external onlyOwner {\r\n        delete investorMap[toDisapprove];\r\n        emit Disapproved(toDisapprove);\r\n    }\r\n\r\n    /** @dev disapprove investors in bulk\r\n      * @param toDisapprove array of investors to be disapproved\r\n      */\r\n    function disapproveInvestorsInBulk(address[] toDisapprove) external onlyOwner {\r\n        for (uint i = 0; i < toDisapprove.length; i++) {\r\n            delete investorMap[toDisapprove[i]];\r\n            emit Disapproved(toDisapprove[i]);\r\n        }\r\n    }\r\n}\r\n\r\n\r\n\r\n/** @title Compliant Crowdsale */\r\ncontract CompliantCrowdsaleHardcap is Validator, FinalizableCrowdsale {\r\n    Whitelist public whiteListingContract;\r\n\r\n    struct MintStruct {\r\n        address to;\r\n        uint256 tokens;\r\n        uint256 weiAmount;\r\n    }\r\n\r\n    mapping (uint => MintStruct) public pendingMints;\r\n    uint256 public currentMintNonce;\r\n    mapping (address => uint) public rejectedMintBalance;\r\n\r\n    modifier checkIsInvestorApproved(address _account) {\r\n        require(whiteListingContract.isInvestorApproved(_account));\r\n        _;\r\n    }\r\n\r\n    modifier checkIsAddressValid(address _account) {\r\n        require(_account != address(0));\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * event for rejected mint logging\r\n    * @param to address for which buy tokens got rejected\r\n    * @param value number of tokens\r\n    * @param amount number of ethers invested\r\n    * @param nonce request recorded at this particular nonce\r\n    * @param reason reason for rejection\r\n    */\r\n    event MintRejected(\r\n        address indexed to,\r\n        uint256 value,\r\n        uint256 amount,\r\n        uint256 indexed nonce,\r\n        uint256 reason\r\n    );\r\n\r\n    /**\r\n    * event for buy tokens request logging\r\n    * @param beneficiary address for which buy tokens is requested\r\n    * @param tokens number of tokens\r\n    * @param weiAmount number of ethers invested\r\n    * @param nonce request recorded at this particular nonce\r\n    */\r\n    event ContributionRegistered(\r\n        address beneficiary,\r\n        uint256 tokens,\r\n        uint256 weiAmount,\r\n        uint256 nonce\r\n    );\r\n\r\n    /**\r\n    * event for rate update logging\r\n    * @param rate new rate\r\n    */\r\n    event RateUpdated(uint256 rate);\r\n\r\n    /**\r\n    * event for whitelist contract update logging\r\n    * @param _whiteListingContract address of the new whitelist contract\r\n    */\r\n    event WhiteListingContractSet(address indexed _whiteListingContract);\r\n\r\n    /**\r\n    * event for claimed ether logging\r\n    * @param account user claiming the ether\r\n    * @param amount ether claimed\r\n    */\r\n    event Claimed(address indexed account, uint256 amount);\r\n\r\n    /** @dev Constructor\r\n      * @param whitelistAddress Ethereum address of the whitelist contract\r\n      * @param _startTime crowdsale start time\r\n      * @param _endTime crowdsale end time\r\n      * @param _hardcap maximum ether(in weis) this crowdsale can raise\r\n      * @param _rate number of tokens to be sold per ether\r\n      * @param _wallet Ethereum address of the wallet\r\n      * @param _token Ethereum address of the token contract\r\n      * @param _owner Ethereum address of the owner\r\n      */\r\n    constructor(\r\n        address whitelistAddress,\r\n        uint256 _startTime,\r\n        uint256 _endTime,\r\n        uint256 _hardcap,\r\n        uint256 _rate,\r\n        address _wallet,\r\n        address _token,\r\n        address _owner\r\n    )\r\n        public\r\n        FinalizableCrowdsale(_owner)\r\n        Crowdsale(_startTime, _endTime, _hardcap, _rate, _wallet, _token)\r\n    {\r\n        setWhitelistContract(whitelistAddress);\r\n    }\r\n\r\n    /** @dev Updates whitelist contract address\r\n      * @param whitelistAddress address of the new whitelist contract \r\n      */\r\n    function setWhitelistContract(address whitelistAddress)\r\n        public \r\n        onlyValidator \r\n        checkIsAddressValid(whitelistAddress)\r\n    {\r\n        whiteListingContract = Whitelist(whitelistAddress);\r\n        emit WhiteListingContractSet(whiteListingContract);\r\n    }\r\n\r\n    /** @dev buy tokens request\r\n      * @param beneficiary the address to which the tokens have to be minted\r\n      */\r\n    function buyTokens(address beneficiary)\r\n        public \r\n        payable\r\n        checkIsInvestorApproved(beneficiary)\r\n    {\r\n        require(validPurchase());\r\n\r\n        uint256 weiAmount = msg.value;\r\n\r\n        // calculate token amount to be created\r\n        uint256 tokens = weiAmount.mul(rate);\r\n\r\n        pendingMints[currentMintNonce] = MintStruct(beneficiary, tokens, weiAmount);\r\n        emit ContributionRegistered(beneficiary, tokens, weiAmount, currentMintNonce);\r\n\r\n        currentMintNonce++;\r\n    }\r\n\r\n    /** @dev Updates token rate \r\n    * @param _rate New token rate \r\n    */ \r\n    function updateRate(uint256 _rate) public onlyOwner { \r\n        require(_rate > 0);\r\n        rate = _rate;\r\n        emit RateUpdated(rate);\r\n    }\r\n\r\n    /** @dev approve buy tokens request\r\n      * @param nonce request recorded at this particular nonce\r\n      */\r\n    function approveMint(uint256 nonce)\r\n        external \r\n        onlyValidator\r\n    {\r\n        require(_approveMint(nonce));\r\n    }\r\n\r\n    /** @dev reject buy tokens request\r\n      * @param nonce request recorded at this particular nonce\r\n      * @param reason reason for rejection\r\n      */\r\n    function rejectMint(uint256 nonce, uint256 reason)\r\n        external \r\n        onlyValidator\r\n    {\r\n        _rejectMint(nonce, reason);\r\n    }\r\n\r\n    /** @dev approve buy tokens requests in bulk\r\n      * @param nonces request recorded at these nonces\r\n      */\r\n    function bulkApproveMints(uint256[] nonces)\r\n        external \r\n        onlyValidator\r\n    {\r\n        for (uint i = 0; i < nonces.length; i++) {\r\n            require(_approveMint(nonces[i]));\r\n        }        \r\n    }\r\n    \r\n    /** @dev reject buy tokens requests\r\n      * @param nonces request recorded at these nonces\r\n      * @param reasons reasons for rejection\r\n      */\r\n    function bulkRejectMints(uint256[] nonces, uint256[] reasons)\r\n        external \r\n        onlyValidator\r\n    {\r\n        require(nonces.length == reasons.length);\r\n        for (uint i = 0; i < nonces.length; i++) {\r\n            _rejectMint(nonces[i], reasons[i]);\r\n        }\r\n    }\r\n\r\n    /** @dev approve buy tokens request called internally in the approveMint and bulkApproveMints functions\r\n      * @param nonce request recorded at this particular nonce\r\n      */\r\n    function _approveMint(uint256 nonce)\r\n        private\r\n        checkIsInvestorApproved(pendingMints[nonce].to)\r\n        returns (bool)\r\n    {\r\n        // update state\r\n        weiRaised = weiRaised.add(pendingMints[nonce].weiAmount);\r\n\r\n        //No need to use mint-approval on token side, since the minting is already approved in the crowdsale side\r\n        TokenInterface(token).mint(pendingMints[nonce].to, pendingMints[nonce].tokens);\r\n        \r\n        emit TokenPurchase(\r\n            msg.sender,\r\n            pendingMints[nonce].to,\r\n            pendingMints[nonce].weiAmount,\r\n            pendingMints[nonce].tokens\r\n        );\r\n\r\n        forwardFunds(pendingMints[nonce].weiAmount);\r\n        delete pendingMints[nonce];\r\n\r\n        return true;\r\n    }\r\n\r\n    /** @dev reject buy tokens request called internally in the rejectMint and bulkRejectMints functions\r\n      * @param nonce request recorded at this particular nonce\r\n      * @param reason reason for rejection\r\n      */\r\n    function _rejectMint(uint256 nonce, uint256 reason)\r\n        private\r\n        checkIsAddressValid(pendingMints[nonce].to)\r\n    {\r\n        rejectedMintBalance[pendingMints[nonce].to] = rejectedMintBalance[pendingMints[nonce].to].add(pendingMints[nonce].weiAmount);\r\n        \r\n        emit MintRejected(\r\n            pendingMints[nonce].to,\r\n            pendingMints[nonce].tokens,\r\n            pendingMints[nonce].weiAmount,\r\n            nonce,\r\n            reason\r\n        );\r\n        \r\n        delete pendingMints[nonce];\r\n    }\r\n\r\n    /** @dev claim back ether if buy tokens request is rejected */\r\n    function claim() external {\r\n        require(rejectedMintBalance[msg.sender] > 0);\r\n        uint256 value = rejectedMintBalance[msg.sender];\r\n        rejectedMintBalance[msg.sender] = 0;\r\n\r\n        msg.sender.transfer(value);\r\n\r\n        emit Claimed(msg.sender, value);\r\n    }\r\n\r\n    function finalization() internal {\r\n        TokenInterface(token).finishMinting();\r\n        transferTokenOwnership(owner);\r\n        super.finalization();\r\n    }\r\n\r\n    /** @dev Updates token contract address\r\n      * @param newToken New token contract address\r\n      */\r\n    function setTokenContract(address newToken)\r\n        external \r\n        onlyOwner\r\n        checkIsAddressValid(newToken)\r\n    {\r\n        token = newToken;\r\n    }\r\n\r\n    /** @dev transfers ownership of the token contract\r\n      * @param newOwner New owner of the token contract\r\n      */\r\n    function transferTokenOwnership(address newOwner)\r\n        public \r\n        onlyOwner\r\n        checkIsAddressValid(newOwner)\r\n    {\r\n        TokenInterface(token).transferOwnership(newOwner);\r\n    }\r\n\r\n    function forwardFunds(uint256 amount) internal {\r\n        wallet.transfer(amount);\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"toDisapprove\",\"type\":\"address\"}],\"name\":\"disapproveInvestor\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"toDisapprove\",\"type\":\"address[]\"}],\"name\":\"disapproveInvestorsInBulk\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"toApprove\",\"type\":\"address\"}],\"name\":\"approveInvestor\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_investor\",\"type\":\"address\"}],\"name\":\"isInvestorApproved\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"toApprove\",\"type\":\"address[]\"}],\"name\":\"approveInvestorsInBulk\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"investor\",\"type\":\"address\"}],\"name\":\"Approved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"investor\",\"type\":\"address\"}],\"name\":\"Disapproved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"Whitelist","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"0000000000000000000000004bde96bb3f307f050779a8a6771e89cc7b4ac078","Library":"","SwarmSource":"bzzr://3d5ebe1517fb072afe58f46e112a4cd5bc516cb93ace96348b3769b33fbfcafb"}]}