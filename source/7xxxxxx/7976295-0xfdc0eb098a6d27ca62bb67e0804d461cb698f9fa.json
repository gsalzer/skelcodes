{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.0;\r\n\r\n\r\nlibrary Pairing {\r\n    struct G1Point {\r\n        uint X;\r\n        uint Y;\r\n    }\r\n\r\n    // Encoding of field elements is: X[0] * z + X[1]\r\n    struct G2Point {\r\n        uint[2] X;\r\n        uint[2] Y;\r\n    }\r\n\r\n    /// @return the generator of G1\r\n    function P1()\r\n        internal pure returns (G1Point memory)\r\n    {\r\n        return G1Point(1, 2);\r\n    }\r\n\r\n    /// @return the generator of G2\r\n    function P2() internal pure returns (G2Point memory) {\r\n        return G2Point(\r\n            [11559732032986387107991004021392285783925812861821192530917403151452391805634,\r\n             10857046999023057135944570762232829481370756359578518086990519993285655852781],\r\n            [4082367875863433681332203403145435568316851327593401208105741076214120093531,\r\n             8495653923123431417604973247489272438418190587263600148770280649306958101930]\r\n        );\r\n    }\r\n\r\n    /// @return the negation of p, i.e. p.add(p.negate()) should be zero.\r\n    function negate(G1Point memory p) internal pure returns (G1Point memory) {\r\n        // The prime q in the base field F_q for G1\r\n        uint q = 21888242871839275222246405745257275088696311157297823662689037894645226208583;\r\n        if (p.X == 0 && p.Y == 0)\r\n            return G1Point(0, 0);\r\n        return G1Point(p.X, q - (p.Y % q));\r\n    }\r\n\r\n    /// @return the sum of two points of G1\r\n    function pointAdd(G1Point memory p1, G1Point memory p2)\r\n        internal view returns (G1Point memory r)\r\n    {\r\n        uint[4] memory input;\r\n        input[0] = p1.X;\r\n        input[1] = p1.Y;\r\n        input[2] = p2.X;\r\n        input[3] = p2.Y;\r\n        bool success;\r\n        assembly {\r\n            success := staticcall(sub(gas, 2000), 6, input, 0xc0, r, 0x60)\r\n        }\r\n        require(success);\r\n    }\r\n\r\n    /// @return the product of a point on G1 and a scalar, i.e.\r\n    /// p == p.mul(1) and p.add(p) == p.mul(2) for all points p.\r\n    function pointMul(G1Point memory p, uint s)\r\n        internal view returns (G1Point memory r)\r\n    {\r\n        uint[3] memory input;\r\n        input[0] = p.X;\r\n        input[1] = p.Y;\r\n        input[2] = s;\r\n        bool success;\r\n        assembly {\r\n            success := staticcall(sub(gas, 2000), 7, input, 0x80, r, 0x60)\r\n        }\r\n        require (success);\r\n    }\r\n\r\n    /// @return the result of computing the pairing check\r\n    /// e(p1[0], p2[0]) *  .... * e(p1[n], p2[n]) == 1\r\n    /// For example pairing([P1(), P1().negate()], [P2(), P2()]) should\r\n    /// return true.\r\n    function pairing(G1Point[] memory p1, G2Point[] memory p2)\r\n        internal view returns (bool)\r\n    {\r\n        require(p1.length == p2.length);\r\n        uint elements = p1.length;\r\n        uint inputSize = elements * 6;\r\n        uint[] memory input = new uint[](inputSize);\r\n        for (uint i = 0; i < elements; i++)\r\n        {\r\n            input[i * 6 + 0] = p1[i].X;\r\n            input[i * 6 + 1] = p1[i].Y;\r\n            input[i * 6 + 2] = p2[i].X[0];\r\n            input[i * 6 + 3] = p2[i].X[1];\r\n            input[i * 6 + 4] = p2[i].Y[0];\r\n            input[i * 6 + 5] = p2[i].Y[1];\r\n        }\r\n        uint[1] memory out;\r\n        bool success;\r\n        assembly {\r\n            success := staticcall(sub(gas, 2000), 8, add(input, 0x20), mul(inputSize, 0x20), out, 0x20)\r\n        }\r\n        require(success);\r\n        return out[0] != 0;\r\n    }\r\n\r\n    /// Convenience method for a pairing check for two pairs.\r\n    function pairingProd2(G1Point memory a1, G2Point memory a2, G1Point memory b1, G2Point memory b2)\r\n        internal view returns (bool)\r\n    {\r\n        G1Point[] memory p1 = new G1Point[](2);\r\n        G2Point[] memory p2 = new G2Point[](2);\r\n        p1[0] = a1;\r\n        p1[1] = b1;\r\n        p2[0] = a2;\r\n        p2[1] = b2;\r\n        return pairing(p1, p2);\r\n    }\r\n    /// Convenience method for a pairing check for three pairs.\r\n    function pairingProd3(\r\n            G1Point memory a1, G2Point memory a2,\r\n            G1Point memory b1, G2Point memory b2,\r\n            G1Point memory c1, G2Point memory c2\r\n    )\r\n        internal view returns (bool)\r\n    {\r\n        G1Point[] memory p1 = new G1Point[](3);\r\n        G2Point[] memory p2 = new G2Point[](3);\r\n        p1[0] = a1;\r\n        p1[1] = b1;\r\n        p1[2] = c1;\r\n        p2[0] = a2;\r\n        p2[1] = b2;\r\n        p2[2] = c2;\r\n        return pairing(p1, p2);\r\n    }\r\n\r\n    /// Convenience method for a pairing check for four pairs.\r\n    function pairingProd4(\r\n            G1Point memory a1, G2Point memory a2,\r\n            G1Point memory b1, G2Point memory b2,\r\n            G1Point memory c1, G2Point memory c2,\r\n            G1Point memory d1, G2Point memory d2\r\n    )\r\n        internal view returns (bool)\r\n    {\r\n        G1Point[] memory p1 = new G1Point[](4);\r\n        G2Point[] memory p2 = new G2Point[](4);\r\n        p1[0] = a1;\r\n        p1[1] = b1;\r\n        p1[2] = c1;\r\n        p1[3] = d1;\r\n        p2[0] = a2;\r\n        p2[1] = b2;\r\n        p2[2] = c2;\r\n        p2[3] = d2;\r\n        return pairing(p1, p2);\r\n    }\r\n}\r\n\r\n\r\nlibrary Verifier\r\n{\r\n    using Pairing for Pairing.G1Point;\r\n    using Pairing for Pairing.G2Point;\r\n\r\n    function scalarField ()\r\n        internal pure returns (uint256)\r\n    {\r\n        return 21888242871839275222246405745257275088548364400416034343698204186575808495617;\r\n    }\r\n\r\n    struct VerifyingKey\r\n    {\r\n        Pairing.G1Point alpha;\r\n        Pairing.G2Point beta;\r\n        Pairing.G2Point gamma;\r\n        Pairing.G2Point delta;\r\n        Pairing.G1Point[] gammaABC;\r\n    }\r\n\r\n    struct Proof\r\n    {\r\n        Pairing.G1Point A;\r\n        Pairing.G2Point B;\r\n        Pairing.G1Point C;\r\n    }\r\n\r\n    struct ProofWithInput\r\n    {\r\n        Proof proof;\r\n        uint256[] input;\r\n    }\r\n\r\n\r\n    function negateY( uint256 Y )\r\n        internal \r\n        pure \r\n        returns (uint256)\r\n    {\r\n        uint q = 21888242871839275222246405745257275088696311157297823662689037894645226208583;\r\n        return q - (Y % q);\r\n    }\r\n\r\n\r\n    /*\r\n    * This implements the Solidity equivalent of the following Python code:\r\n\r\n        from py_ecc.bn128 import *\r\n\r\n        data = # ... arguments to function [in_vk, vk_gammaABC, in_proof, proof_inputs]\r\n\r\n        vk = [int(_, 16) for _ in data[0]]\r\n        ic = [FQ(int(_, 16)) for _ in data[1]]\r\n        proof = [int(_, 16) for _ in data[2]]\r\n        inputs = [int(_, 16) for _ in data[3]]\r\n\r\n        it = iter(ic)\r\n        ic = [(_, next(it)) for _ in it]\r\n        vk_alpha = [FQ(_) for _ in vk[:2]]\r\n        vk_beta = (FQ2(vk[2:4][::-1]), FQ2(vk[4:6][::-1]))\r\n        vk_gamma = (FQ2(vk[6:8][::-1]), FQ2(vk[8:10][::-1]))\r\n        vk_delta = (FQ2(vk[10:12][::-1]), FQ2(vk[12:14][::-1]))\r\n\r\n        assert is_on_curve(vk_alpha, b)\r\n        assert is_on_curve(vk_beta, b2)\r\n        assert is_on_curve(vk_gamma, b2)\r\n        assert is_on_curve(vk_delta, b2)\r\n\r\n        proof_A = [FQ(_) for _ in proof[:2]]\r\n        proof_B = (FQ2(proof[2:4][::-1]), FQ2(proof[4:-2][::-1]))\r\n        proof_C = [FQ(_) for _ in proof[-2:]]\r\n\r\n        assert is_on_curve(proof_A, b)\r\n        assert is_on_curve(proof_B, b2)\r\n        assert is_on_curve(proof_C, b)\r\n\r\n        vk_x = ic[0]\r\n        for i, s in enumerate(inputs):\r\n            vk_x = add(vk_x, multiply(ic[i + 1], s))\r\n\r\n        check_1 = pairing(proof_B, proof_A)\r\n        check_2 = pairing(vk_beta, neg(vk_alpha))\r\n        check_3 = pairing(vk_gamma, neg(vk_x))\r\n        check_4 = pairing(vk_delta, neg(proof_C))\r\n\r\n        ok = check_1 * check_2 * check_3 * check_4\r\n        assert ok == FQ12.one()\r\n    */\r\n    function verify (uint256[14] memory in_vk, uint256[] memory vk_gammaABC, uint256[8] memory in_proof, uint256[] memory proof_inputs)\r\n        internal \r\n        view \r\n        returns (bool)\r\n    {\r\n        require( ((vk_gammaABC.length / 2) - 1) == proof_inputs.length );\r\n        \r\n        // Compute the linear combination vk_x\r\n        uint256[3] memory mul_input;\r\n        uint256[4] memory add_input;\r\n        bool success;\r\n        uint m = 2;\r\n\r\n        // First two fields are used as the sum\r\n        add_input[0] = vk_gammaABC[0];\r\n        add_input[1] = vk_gammaABC[1];\r\n\r\n        // Performs a sum of gammaABC[0] + sum[ gammaABC[i+1]^proof_inputs[i] ]\r\n        for (uint i = 0; i < proof_inputs.length; i++) {\r\n            mul_input[0] = vk_gammaABC[m++];\r\n            mul_input[1] = vk_gammaABC[m++];\r\n            mul_input[2] = proof_inputs[i];\r\n\r\n            assembly {\r\n                // ECMUL, output to last 2 elements of `add_input`\r\n                success := staticcall(sub(gas, 2000), 7, mul_input, 0x80, add(add_input, 0x40), 0x60)\r\n            }\r\n            require(success);\r\n            \r\n            assembly {\r\n                // ECADD\r\n                success := staticcall(sub(gas, 2000), 6, add_input, 0xc0, add_input, 0x60)\r\n            }\r\n            require(success);\r\n        }\r\n        \r\n        uint[24] memory input = [\r\n            // (proof.A, proof.B)\r\n            in_proof[0], in_proof[1],                           // proof.A   (G1)\r\n            in_proof[2], in_proof[3], in_proof[4], in_proof[5], // proof.B   (G2)\r\n\r\n            // (-vk.alpha, vk.beta)\r\n            in_vk[0], negateY(in_vk[1]),                        // -vk.alpha (G1)\r\n            in_vk[2], in_vk[3], in_vk[4], in_vk[5],             // vk.beta   (G2)\r\n\r\n            // (-vk_x, vk.gamma)\r\n            add_input[0], negateY(add_input[1]),                // -vk_x     (G1)\r\n            in_vk[6], in_vk[7], in_vk[8], in_vk[9],             // vk.gamma  (G2)\r\n\r\n            // (-proof.C, vk.delta)\r\n            in_proof[6], negateY(in_proof[7]),                  // -proof.C  (G1)\r\n            in_vk[10], in_vk[11], in_vk[12], in_vk[13]          // vk.delta  (G2)\r\n        ];\r\n\r\n        uint[1] memory out;\r\n        assembly {\r\n            success := staticcall(sub(gas, 2000), 8, input, 768, out, 0x20)\r\n        }\r\n        require(success);\r\n        return out[0] != 0;\r\n    }\r\n\r\n\r\n    function verify(VerifyingKey memory vk, ProofWithInput memory pwi)\r\n        internal \r\n        view \r\n        returns (bool)\r\n    {\r\n        return verify(vk, pwi.proof, pwi.input);\r\n    }\r\n\r\n\r\n    function verify(VerifyingKey memory vk, Proof memory proof, uint256[] memory input)\r\n        internal \r\n        view \r\n        returns (bool)\r\n    {\r\n        require(input.length + 1 == vk.gammaABC.length);\r\n\r\n        // Compute the linear combination vk_x\r\n        Pairing.G1Point memory vk_x = vk.gammaABC[0];\r\n        for (uint i = 0; i < input.length; i++)\r\n            vk_x = Pairing.pointAdd(vk_x, Pairing.pointMul(vk.gammaABC[i + 1], input[i]));\r\n\r\n        // Verify proof\r\n        return Pairing.pairingProd4(\r\n            proof.A, proof.B,\r\n            vk_x.negate(), vk.gamma,\r\n            proof.C.negate(), vk.delta,\r\n            vk.alpha.negate(), vk.beta);\r\n    }\r\n}\r\n\r\nlibrary MiMC\r\n{\r\n    function getScalarField ()\r\n        internal pure returns (uint256)\r\n    {\r\n        return 0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f0000001;\r\n    }\r\n\r\n    /**\r\n    * MiMC-p/p with exponent of 7\r\n    * \r\n    * Recommended at least 46 rounds, for a polynomial degree of 2^126\r\n    */\r\n    function MiMCpe7( uint256 in_x, uint256 in_k, uint256 in_seed, uint256 round_count )\r\n        internal pure returns(uint256 out_x)\r\n    {\r\n        assembly {\r\n            if lt(round_count, 1) { revert(0, 0) }\r\n\r\n            // Initialise round constants, k will be hashed\r\n            let c := mload(0x40)\r\n            mstore(0x40, add(c, 32))\r\n            mstore(c, in_seed)\r\n\r\n            let localQ := 0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f0000001\r\n            let t\r\n            let a\r\n\r\n            // Further n-2 subsequent rounds include a round constant\r\n            for { let i := round_count } gt(i, 0) { i := sub(i, 1) } {\r\n                // c = H(c)\r\n                mstore(c, keccak256(c, 32))\r\n\r\n                // x = pow(x + c_i, 7, p) + k\r\n                t := addmod(addmod(in_x, mload(c), localQ), in_k, localQ)              // t = x + c_i + k\r\n                a := mulmod(t, t, localQ)                                              // t^2\r\n                in_x := mulmod(mulmod(a, mulmod(a, a, localQ), localQ), t, localQ)     // t^7\r\n            }\r\n\r\n            // Result adds key again as blinding factor\r\n            out_x := addmod(in_x, in_k, localQ)\r\n        }\r\n    }\r\n       \r\n    function MiMCpe7_mp( uint256[] memory in_x, uint256 in_k, uint256 in_seed, uint256 round_count )\r\n        internal pure returns (uint256)\r\n    {\r\n        uint256 r = in_k;\r\n        uint256 localQ = 0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f0000001;\r\n\r\n        for( uint256 i = 0; i < in_x.length; i++ )\r\n        {\r\n            r = (r + in_x[i] + MiMCpe7(in_x[i], r, in_seed, round_count)) % localQ;\r\n        }\r\n\r\n        // uint256 x0 = in_x[0];\r\n        // uint256 x1 = in_x[1];\r\n        // uint256 m0 = MiMCpe7(x0, r, in_seed, round_count);\r\n        // assembly {\r\n        //     r := addmod(addmod(r, x0, localQ), m0, localQ)\r\n        // }\r\n        // uint256 m1 = MiMCpe7(x1, r, in_seed, round_count);\r\n        // assembly {\r\n        //     r := addmod(addmod(r, x1, localQ), m1, localQ)\r\n        // }\r\n        \r\n        return r;\r\n    }\r\n\r\n    function Hash( uint256[] memory in_msgs, uint256 in_key )\r\n        internal pure returns (uint256)\r\n    {\r\n        return MiMCpe7_mp(in_msgs, in_key, uint256(keccak256(\"mimc\")), 91);\r\n    }\r\n\r\n    function Hash( uint256[] memory in_msgs )\r\n        internal pure returns (uint256)\r\n    {\r\n        return Hash(in_msgs, 0);\r\n    }\r\n}\r\n\r\nlibrary MerkleTree\r\n{\r\n    // ceil(log2(1<<15))\r\n    uint constant internal TREE_DEPTH = 15;\r\n\r\n\r\n    // 1<<15 leaves\r\n    uint constant internal MAX_LEAF_COUNT = 32768;\r\n\r\n\r\n    struct Data\r\n    {\r\n        uint cur;\r\n        uint256[32768][16] nodes; // first column = leaves, second column = leaves' parents, etc\r\n    }\r\n\r\n    function treeDepth() internal pure returns (uint256) {\r\n        return TREE_DEPTH;\r\n    }\r\n\r\n\r\n    function fillLevelIVs (uint256[15] memory IVs)\r\n        internal\r\n        pure\r\n    {\r\n        IVs[0] = 149674538925118052205057075966660054952481571156186698930522557832224430770;\r\n        IVs[1] = 9670701465464311903249220692483401938888498641874948577387207195814981706974;\r\n        IVs[2] = 18318710344500308168304415114839554107298291987930233567781901093928276468271;\r\n        IVs[3] = 6597209388525824933845812104623007130464197923269180086306970975123437805179;\r\n        IVs[4] = 21720956803147356712695575768577036859892220417043839172295094119877855004262;\r\n        IVs[5] = 10330261616520855230513677034606076056972336573153777401182178891807369896722;\r\n        IVs[6] = 17466547730316258748333298168566143799241073466140136663575045164199607937939;\r\n        IVs[7] = 18881017304615283094648494495339883533502299318365959655029893746755475886610;\r\n        IVs[8] = 21580915712563378725413940003372103925756594604076607277692074507345076595494;\r\n        IVs[9] = 12316305934357579015754723412431647910012873427291630993042374701002287130550;\r\n        IVs[10] = 18905410889238873726515380969411495891004493295170115920825550288019118582494;\r\n        IVs[11] = 12819107342879320352602391015489840916114959026915005817918724958237245903353;\r\n        IVs[12] = 8245796392944118634696709403074300923517437202166861682117022548371601758802;\r\n        IVs[13] = 16953062784314687781686527153155644849196472783922227794465158787843281909585;\r\n        IVs[14] = 19346880451250915556764413197424554385509847473349107460608536657852472800734;\r\n    }\r\n\r\n\r\n    function hashImpl (uint256 left, uint256 right, uint256 IV)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        uint256[] memory x = new uint256[](2);\r\n        x[0] = left;\r\n        x[1] = right;\r\n\r\n        return MiMC.Hash(x, IV);\r\n    }\r\n\r\n\r\n    function insert(Data storage self, uint256 leaf)\r\n        internal\r\n        returns (uint256 new_root, uint256 offset)\r\n    {\r\n        require(leaf != 0);\r\n\r\n\r\n        uint256[15] memory IVs;\r\n        fillLevelIVs(IVs);\r\n\r\n        offset = self.cur;\r\n\r\n        require(offset != MAX_LEAF_COUNT - 1);\r\n\r\n        self.nodes[0][offset] = leaf;\r\n\r\n        new_root = updateTree(self, IVs);\r\n\r\n        self.cur = offset + 1;\r\n    }\r\n\r\n\r\n    /**\r\n    * Returns calculated merkle root\r\n    */\r\n    function verifyPath(uint256 leaf, uint256[15] memory in_path, bool[15] memory address_bits)\r\n        internal \r\n        pure \r\n        returns (uint256 merkleRoot)\r\n    {\r\n        uint256[15] memory IVs;\r\n        fillLevelIVs(IVs);\r\n\r\n        merkleRoot = leaf;\r\n\r\n        for (uint depth = 0; depth < TREE_DEPTH; depth++) {\r\n            if (address_bits[depth]) {\r\n                merkleRoot = hashImpl(in_path[depth], merkleRoot, IVs[depth]);\r\n            } else {\r\n                merkleRoot = hashImpl(merkleRoot, in_path[depth], IVs[depth]);\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    function verifyPath(Data storage self, uint256 leaf, uint256[15] memory in_path, bool[15] memory address_bits)\r\n        internal \r\n        view \r\n        returns (bool)\r\n    {\r\n        return verifyPath(leaf, in_path, address_bits) == getRoot(self);\r\n    }\r\n\r\n\r\n    function getLeaf(Data storage self, uint depth, uint offset)\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return getUniqueLeaf(depth, offset, self.nodes[depth][offset]);\r\n    }\r\n\r\n\r\n    function getMerkleProof(Data storage self, uint index)\r\n        internal\r\n        view\r\n        returns (uint256[15] memory proof_path)\r\n    {\r\n        for (uint depth = 0; depth < TREE_DEPTH; depth++)\r\n        {\r\n            if (index % 2 == 0) {\r\n                proof_path[depth] = getLeaf(self, depth, index + 1);\r\n            } else {\r\n                proof_path[depth] = getLeaf(self, depth, index - 1);\r\n            }\r\n            index = uint(index / 2);\r\n        }\r\n    }\r\n\r\n\r\n    function getUniqueLeaf(uint256 depth, uint256 offset, uint256 leaf)\r\n        internal pure returns (uint256)\r\n    {\r\n        if (leaf == 0x0)\r\n        {\r\n            leaf = uint256(\r\n                sha256(\r\n                    abi.encodePacked(\r\n                        uint16(depth),\r\n                        uint240(offset)))) % MiMC.getScalarField();\r\n        }\r\n\r\n        return leaf;\r\n    }\r\n\r\n\r\n    function updateTree(Data storage self, uint256[15] memory IVs)\r\n        internal returns(uint256 root)\r\n    {\r\n        uint currentIndex = self.cur;\r\n        uint256 leaf1;\r\n        uint256 leaf2;\r\n\r\n        for (uint depth = 0; depth < TREE_DEPTH; depth++)\r\n        {\r\n\r\n            if (currentIndex%2 == 0)\r\n            {\r\n                leaf1 = self.nodes[depth][currentIndex];\r\n\r\n                leaf2 = getUniqueLeaf(depth, currentIndex + 1, self.nodes[depth][currentIndex + 1]);\r\n            } else\r\n            {\r\n                leaf1 = getUniqueLeaf(depth, currentIndex - 1, self.nodes[depth][currentIndex - 1]);\r\n\r\n                leaf2 = self.nodes[depth][currentIndex];\r\n            }\r\n\r\n            uint nextIndex = uint(currentIndex/2);\r\n\r\n            self.nodes[depth+1][nextIndex] = hashImpl(leaf1, leaf2, IVs[depth]);\r\n\r\n            currentIndex = nextIndex;\r\n        }\r\n\r\n        return self.nodes[TREE_DEPTH][0];\r\n    }\r\n\r\n\r\n    function getRoot (Data storage self)\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return self.nodes[TREE_DEPTH][0];\r\n    }\r\n\r\n    function getNextLeafIndex (Data storage self)\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return self.cur;\r\n    }\r\n}\r\n\r\n\r\ncontract Mixer\r\n{\r\n    using MerkleTree for MerkleTree.Data;\r\n\r\n    uint constant public AMOUNT = 1 ether;\r\n\r\n    uint256[14] vk;\r\n    uint256[] gammaABC;\r\n\r\n    mapping (uint256 => bool) public nullifiers;\r\n    mapping (address => uint256[]) public pendingDeposits;\r\n\r\n    MerkleTree.Data internal tree;\r\n\r\n    event CommitmentAdded(address indexed _fundingWallet, uint256 _leaf);\r\n    event LeafAdded(uint256 _leaf, uint256 _leafIndex);\r\n    event DepositWithdrawn(uint256 _nullifier);\r\n\r\n    constructor(uint256[14] memory in_vk, uint256[] memory in_gammaABC)\r\n        public\r\n    {\r\n        vk = in_vk;\r\n        gammaABC = in_gammaABC;\r\n    }\r\n\r\n    function getRoot()\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return tree.getRoot();\r\n    }\r\n\r\n    /**\r\n    * Save a commitment (leaf) that needs to be funded later on\r\n    */\r\n    function commit(uint256 leaf, address fundingWallet)\r\n        public\r\n        payable\r\n    {\r\n        require(leaf > 0, \"null leaf\");\r\n        pendingDeposits[fundingWallet].push(leaf);\r\n        emit CommitmentAdded(fundingWallet, leaf);\r\n        if (msg.value > 0) fundCommitment();\r\n    }\r\n\r\n    function fundCommitment() private {\r\n        require(msg.value == AMOUNT, \"wrong value\");\r\n        uint256[] storage leaves = pendingDeposits[msg.sender];\r\n        require(leaves.length > 0, \"commitment must be sent first\");\r\n        uint256 leaf = leaves[leaves.length - 1];\r\n        leaves.length--;\r\n        (, uint256 leafIndex) = tree.insert(leaf);\r\n        emit LeafAdded(leaf, leafIndex);\r\n    }\r\n\r\n    /*\r\n    * Used by the funding wallet to fund a previously saved commitment\r\n    */\r\n    function () external payable {\r\n        fundCommitment();\r\n    }\r\n\r\n    // should not be used in production otherwise nullifier_secret would be shared with node!\r\n    function makeLeafHash(uint256 nullifier_secret, address wallet_address)\r\n        external\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        // return MiMC.Hash([nullifier_secret, uint256(wallet_address)], 0);\r\n        bytes32 digest = sha256(abi.encodePacked(nullifier_secret, uint256(wallet_address)));\r\n        uint256 mask = uint256(-1) >> 4; // clear the first 4 bits to make sure we stay within the prime field\r\n        return uint256(digest) & mask;\r\n    }\r\n\r\n    // should not be used in production otherwise nullifier_secret would be shared with node!\r\n    function makeNullifierHash(uint256 nullifier_secret)\r\n        external\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        uint256[] memory vals = new uint256[](2);\r\n        vals[0] = nullifier_secret;\r\n        vals[1] = nullifier_secret;\r\n        return MiMC.Hash(vals, 0);\r\n    }\r\n\r\n    function getMerklePath(uint256 leafIndex)\r\n        external\r\n        view\r\n        returns (uint256[15] memory out_path)\r\n    {\r\n        out_path = tree.getMerkleProof(leafIndex);\r\n    }\r\n\r\n    function isSpent(uint256 nullifier)\r\n        public\r\n        view\r\n        returns (bool)\r\n    {\r\n        return nullifiers[nullifier];\r\n    }\r\n\r\n    function verifyProof(uint256 in_root, address in_wallet_address, uint256 in_nullifier, uint256[8] memory proof)\r\n        public\r\n        view\r\n        returns (bool)\r\n    {\r\n        uint256[] memory snark_input = new uint256[](3);\r\n        snark_input[0] = in_root;\r\n        snark_input[1] = uint256(in_wallet_address);\r\n        snark_input[2] = in_nullifier;\r\n\r\n        return Verifier.verify(vk, gammaABC, proof, snark_input);\r\n    }\r\n\r\n    function withdraw(\r\n        address payable in_withdraw_address,\r\n        uint256 in_nullifier,\r\n        uint256[8] memory proof\r\n    )\r\n        public\r\n    {\r\n        uint startGas = gasleft();\r\n        require(!nullifiers[in_nullifier], \"Nullifier used\");\r\n        require(verifyProof(getRoot(), in_withdraw_address, in_nullifier, proof), \"Proof verification failed\");\r\n\r\n        nullifiers[in_nullifier] = true;\r\n        emit DepositWithdrawn(in_nullifier);\r\n\r\n        uint gasUsed = startGas - gasleft() + 57700;\r\n        uint relayerRefund = gasUsed * tx.gasprice;\r\n        if(relayerRefund > AMOUNT/20) relayerRefund = AMOUNT/20;\r\n        in_withdraw_address.transfer(AMOUNT - relayerRefund); // leaf withdrawal\r\n        msg.sender.transfer(relayerRefund); // relayer refund\r\n    }\r\n\r\n    function treeDepth() external pure returns (uint256) {\r\n        return MerkleTree.treeDepth();\r\n    }\r\n\r\n    function getNextLeafIndex() external view returns (uint256) {\r\n        return tree.getNextLeafIndex();\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"nullifier_secret\",\"type\":\"uint256\"},{\"name\":\"wallet_address\",\"type\":\"address\"}],\"name\":\"makeLeafHash\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"leaf\",\"type\":\"uint256\"},{\"name\":\"fundingWallet\",\"type\":\"address\"}],\"name\":\"commit\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"treeDepth\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"in_withdraw_address\",\"type\":\"address\"},{\"name\":\"in_nullifier\",\"type\":\"uint256\"},{\"name\":\"proof\",\"type\":\"uint256[8]\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getNextLeafIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"nullifier\",\"type\":\"uint256\"}],\"name\":\"isSpent\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getRoot\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"leafIndex\",\"type\":\"uint256\"}],\"name\":\"getMerklePath\",\"outputs\":[{\"name\":\"out_path\",\"type\":\"uint256[15]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"in_root\",\"type\":\"uint256\"},{\"name\":\"in_wallet_address\",\"type\":\"address\"},{\"name\":\"in_nullifier\",\"type\":\"uint256\"},{\"name\":\"proof\",\"type\":\"uint256[8]\"}],\"name\":\"verifyProof\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"pendingDeposits\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"nullifier_secret\",\"type\":\"uint256\"}],\"name\":\"makeNullifierHash\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"AMOUNT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"nullifiers\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"in_vk\",\"type\":\"uint256[14]\"},{\"name\":\"in_gammaABC\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_fundingWallet\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_leaf\",\"type\":\"uint256\"}],\"name\":\"CommitmentAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_leaf\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_leafIndex\",\"type\":\"uint256\"}],\"name\":\"LeafAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_nullifier\",\"type\":\"uint256\"}],\"name\":\"DepositWithdrawn\",\"type\":\"event\"}]","ContractName":"Mixer","CompilerVersion":"v0.5.0+commit.1d4f565a","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"159f09e91e1ef10716da832c2d1244a6472e5da5a16ad386894dbe2bf5e66fec24fe496b77d02691c6e9592295c8aca481ba65b4f3061e767c254fe48e0951f82927d9177c5f20b43a72cf824b712bb3ee9f43c1f9815d31ec280e6cc95b3bca1dab0af360ff7414d757502c970fb70953057101d88828dc64e98b0998dcc660259411351840195377656f5392809d61b2e5318c636009ea530a2598bab898880b20a00eadfd12032c1af8ea43ea6593f2dfd2a509fdd3bc8a983eda2fec83022aa8e49aa482324da11609f2fa212d616a80ce2c8af22e87cb4fb9b0d331a7e004e3850e0ecaeec849ebc3f5499d6cd171299699df65b8bbc4bdd2045186d150239dfeed57a34365a80027c6ba1eb42743e450da6b4bc31d7e879beed4c949ed0f00ea653b521ae74f70d846040edb377d291685031fa205c51aedc8e193f3501924cd68d520558ba67cf9b86b2d4a5b21e6c892eaa59998a15d00b52c78984f02db76679bb73ed126873b7a7e739cd73aeb8970748d78f26a5b516c23e5b75121ab18375d80412a2ff151c8be043b3af5f4fd159fae0d23bf0c07ed3e0e9abf2793ccd39e182a4ceee75740532176ccd7c364325d53f3c14122da61f8aabb8300000000000000000000000000000000000000000000000000000000000001e000000000000000000000000000000000000000000000000000000000000000082c749d9058c25a81e28ce047d579fc9e004d6415e40c0f5207fcb9de38f95caa2b62e5faefb05eb9564cd1c2ddf7306941ba819b5716fc5d05665797d45b5ad4023631e41379aaf53c3df142b6630c2f9fdc01dc9bd8546bc887f3bc20cbc57f112bbdb56a948879015e519acc228435bf1bbc4da3c0ac7510daa75ea0ee402d1f62aa8d372dfd8e9e885c4cea65b01a5ca32c64c8ae4f4494c75dc35dc3780d0415d651a0b5ed8d1ed04e98c4c79635ed9ea843ce9e125a48ddb52542bb51281a022ccc8171193602067a83d0724e6a155a75a7767be2015199894c3fa4a62c0f76799f652b8c82725f6cb989d6e04eb01b2ca175770fbaa233744e7c8e8e66","Library":"","SwarmSource":"bzzr://4f2a38374263fce14b7ad46814cad390067baeff247c4532a66f2d95b0f5c9f1"}]}