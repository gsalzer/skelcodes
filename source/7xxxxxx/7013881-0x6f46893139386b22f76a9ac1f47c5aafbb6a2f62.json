{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\n// File: contracts\\utils\\SafeMath.sol\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return a / b;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n  /**\r\n  * @dev gives square root of given x.\r\n  */\r\n  function sqrt(uint256 x)\r\n    internal\r\n    pure\r\n    returns (uint256 y)\r\n  {\r\n    uint256 z = ((add(x,1)) / 2);\r\n    y = x;\r\n    while (z < y)\r\n    {\r\n        y = z;\r\n        z = ((add((x / z),z)) / 2);\r\n    }\r\n  }\r\n\r\n  /**\r\n  * @dev gives square. multiplies x by x\r\n  */\r\n  function sq(uint256 x)\r\n    internal\r\n    pure\r\n    returns (uint256)\r\n  {\r\n    return (mul(x,x));\r\n  }\r\n\r\n  /**\r\n  * @dev x to the power of y\r\n  */\r\n  function pwr(uint256 x, uint256 y)\r\n    internal\r\n    pure\r\n    returns (uint256)\r\n  {\r\n    if (x==0)\r\n        return (0);\r\n    else if (y==0)\r\n        return (1);\r\n    else\r\n    {\r\n        uint256 z = x;\r\n        for (uint256 i=1; i < y; i++)\r\n            z = mul(z,x);\r\n        return (z);\r\n    }\r\n  }\r\n}\r\n\r\n// File: contracts\\CKingCal.sol\r\n\r\nlibrary CKingCal {\r\n\r\n  using SafeMath for *;\r\n  /**\r\n  * @dev calculates number of keys received given X eth\r\n  * @param _curEth current amount of eth in contract\r\n  * @param _newEth eth being spent\r\n  * @return amount of ticket purchased\r\n  */\r\n  function keysRec(uint256 _curEth, uint256 _newEth)\r\n    internal\r\n    pure\r\n    returns (uint256)\r\n  {\r\n    return(keys((_curEth).add(_newEth)).sub(keys(_curEth)));\r\n  }\r\n\r\n  /**\r\n  * @dev calculates amount of eth received if you sold X keys\r\n  * @param _curKeys current amount of keys that exist\r\n  * @param _sellKeys amount of keys you wish to sell\r\n  * @return amount of eth received\r\n  */\r\n  function ethRec(uint256 _curKeys, uint256 _sellKeys)\r\n    internal\r\n    pure\r\n    returns (uint256)\r\n  {\r\n    return((eth(_curKeys)).sub(eth(_curKeys.sub(_sellKeys))));\r\n  }\r\n\r\n  /**\r\n  * @dev calculates how many keys would exist with given an amount of eth\r\n  * @param _eth total ether received.\r\n  * @return number of keys that would exist\r\n  */\r\n  function keys(uint256 _eth)\r\n    internal\r\n    pure\r\n    returns(uint256)\r\n  {\r\n      // sqrt((eth*1 eth* 312500000000000000000000000)+5624988281256103515625000000000000000000000000000000000000000000) - 74999921875000000000000000000000) / 15625000\r\n      return ((((((_eth).mul(1000000000000000000)).mul(31250000000000000000000000)).add(56249882812561035156250000000000000000000000000000000000000000)).sqrt()).sub(7499992187500000000000000000000)) / (15625000);\r\n  }  \r\n\r\n  /**\r\n  * @dev calculates how much eth would be in contract given a number of keys\r\n  * @param _keys number of keys \"in contract\"\r\n  * @return eth that would exists\r\n  */\r\n  function eth(uint256 _keys)\r\n    internal\r\n    pure\r\n    returns(uint256)\r\n  {\r\n    // (149999843750000*keys*1 eth) + 78125000 * keys * keys) /2 /(sq(1 ether))\r\n    return ((7812500).mul(_keys.sq()).add(((14999984375000).mul(_keys.mul(1000000000000000000))) / (2))) / ((1000000000000000000).sq());\r\n  }\r\n}\r\n\r\n// File: contracts\\utils\\Ownable.sol\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  constructor() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    require(newOwner != address(0));\r\n    emit OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n\r\n}\r\n\r\n// File: contracts\\TowerCKing.sol\r\n\r\ncontract CKing is Ownable {\r\n  using SafeMath for *;\r\n  using CKingCal for uint256;\r\n\r\n\r\n  string constant public name = \"Cryptower\";\r\n  string constant public symbol = \"CT\";\r\n\r\n  // time constants;\r\n  uint256 constant private timeInit = 1 weeks; // 600; //1 week \r\n  uint256 constant private timeInc = 30 seconds; //60 ///////\r\n  uint256 constant private timeMax = 30 minutes; // 300\r\n\r\n  // profit distribution parameters\r\n  uint256 constant private fixRet = 46;\r\n  uint256 constant private extraRet = 10;\r\n  uint256 constant private affRet = 10;\r\n  uint256 constant private gamePrize = 12;\r\n  uint256 constant private groupPrize = 12;\r\n  uint256 constant private devTeam = 10;\r\n\r\n  // player data\r\n  struct Player {\r\n    address addr; // player address\r\n    string name; // playerName\r\n    uint256 aff;  // affliliate vault\r\n    uint256 affId; // affiliate id, who referered u\r\n    uint256 hretKeys; // number of high return keys\r\n    uint256 mretKeys; // number of medium return keys\r\n    uint256 lretKeys; // number of low return keys\r\n    uint256 eth;      // total eth spend for the keys\r\n    uint256 ethWithdraw; // earning withdrawed by user\r\n  }\r\n\r\n  mapping(uint256 => Player) public players; // player data\r\n  mapping(address => uint) public addrXpId; // player address => pId\r\n  uint public playerNum = 0;\r\n\r\n  // game info\r\n  uint256 public totalEther;     // total key sale revenue\r\n  uint256 public totalKeys;      // total number of keys.\r\n  uint256 private constant minPay = 1000000000; // minimum pay to buy keys or deposit in game;\r\n  uint256 public totalCommPot;   // total ether going to be distributed\r\n  uint256 private keysForGame;    // keys belongs to the game for profit distribution\r\n  uint256 private gamePot;        // ether need to be distributed based on the side chain game\r\n  uint256 public teamWithdrawed; // eth withdrawed by dev team. \r\n  uint256 public gameWithdrawed; // ether already been withdrawn from game pot \r\n  uint256 public endTime;        // main game end time\r\n  address public CFO;\r\n  address public COO; \r\n  address public fundCenter; \r\n  address public playerBook; \r\n\r\n\r\n\r\n  uint private stageId = 1;   // stageId start 1\r\n  uint private constant groupPrizeStartAt = 2000000000000000000000000; // 1000000000000000000000;\r\n  uint private constant groupPrizeStageGap = 100000000000000000000000; // 100000000000000000000\r\n  mapping(uint => mapping(uint => uint)) public stageInfo; // stageId => pID => keys purchased in this stage\r\n\r\n  // admin params\r\n  uint256 public startTime;  // admin set start\r\n  uint256 constant private coolDownTime = 2 days; // team is able to withdraw fund 2 days after game end.\r\n\r\n  modifier isGameActive() {\r\n    uint _now = now;\r\n    require(_now > startTime && _now < endTime);\r\n    _;\r\n  }\r\n  \r\n  modifier onlyCOO() {\r\n    require(COO == msg.sender, \"Only COO can operate.\");\r\n    _; \r\n  }\r\n\r\n  // events\r\n  event BuyKey(uint indexed _pID, uint _affId, uint _keyType, uint _keyAmount);\r\n  event EarningWithdraw(uint indexed _pID, address _addr, uint _amount);\r\n\r\n\r\n  constructor(address _CFO, address _COO, address _fundCenter, address _playerBook) public {\r\n    CFO = _CFO;\r\n    COO = _COO; \r\n    fundCenter = _fundCenter; \r\n    playerBook = _playerBook; \r\n  }\r\n    \r\n  function setCFO(address _CFO) onlyOwner public {\r\n    CFO = _CFO; \r\n  }  \r\n  \r\n  function setCOO(address _COO) onlyOwner public {\r\n    COO = _COO; \r\n  }  \r\n  \r\n  function setContractAddress(address _fundCenter, address _playerBook) onlyCOO public {\r\n    fundCenter = _fundCenter; \r\n    playerBook = _playerBook; \r\n  }\r\n\r\n  function startGame(uint _startTime) onlyCOO public {\r\n    require(_startTime > now);\r\n    startTime = _startTime;\r\n    endTime = startTime.add(timeInit);\r\n  }\r\n  \r\n  function gameWithdraw(uint _amount) onlyCOO public {\r\n    // users may choose to withdraw eth from cryptower game, allow dev team to withdraw eth from this contract to fund center. \r\n    uint _total = getTotalGamePot(); \r\n    uint _remainingBalance = _total.sub(gameWithdrawed); \r\n    \r\n    if(_amount > 0) {\r\n      require(_amount <= _remainingBalance);\r\n    } else{\r\n      _amount = _remainingBalance;\r\n    }\r\n    \r\n    fundCenter.transfer(_amount); \r\n    gameWithdrawed = gameWithdrawed.add(_amount); \r\n  }\r\n\r\n\r\n  function teamWithdraw(uint _amount) onlyCOO public {\r\n    uint256 _now = now;\r\n    if(_now > endTime.add(coolDownTime)) {\r\n      // dev team have rights to withdraw all remaining balance 2 days after game end. \r\n      // if users does not claim their ETH within coolDown period, the team may withdraw their remaining balance. Users can go to crytower game to get their ETH back.\r\n      CFO.transfer(_amount);\r\n      teamWithdrawed = teamWithdrawed.add(_amount); \r\n    } else {\r\n        uint _total = totalEther.mul(devTeam).div(100); \r\n        uint _remainingBalance = _total.sub(teamWithdrawed); \r\n        \r\n        if(_amount > 0) {\r\n            require(_amount <= _remainingBalance);\r\n        } else{\r\n            _amount = _remainingBalance;\r\n        }\r\n        CFO.transfer(_amount);\r\n        teamWithdrawed = teamWithdrawed.add(_amount); \r\n    }\r\n  }\r\n  \r\n\r\n  function updateTimer(uint256 _keys) private {\r\n    uint256 _now = now;\r\n    uint256 _newTime;\r\n\r\n    if(endTime.sub(_now) < timeMax) {\r\n        _newTime = ((_keys) / (1000000000000000000)).mul(timeInc).add(endTime);\r\n        if(_newTime.sub(_now) > timeMax) {\r\n            _newTime = _now.add(timeMax);\r\n        }\r\n        endTime = _newTime;\r\n    }\r\n  }\r\n  \r\n  function receivePlayerInfo(address _addr, string _name) external {\r\n    require(msg.sender == playerBook, \"must be from playerbook address\"); \r\n    uint _pID = addrXpId[_addr];\r\n    if(_pID == 0) { // player not exist yet. create one \r\n        playerNum = playerNum + 1;\r\n        Player memory p; \r\n        p.addr = _addr;\r\n        p.name = _name; \r\n        players[playerNum] = p; \r\n        _pID = playerNum; \r\n        addrXpId[_addr] = _pID;\r\n    } else {\r\n        players[_pID].name = _name; \r\n    }\r\n  }\r\n\r\n  function buyByAddress(uint256 _affId, uint _keyType) payable isGameActive public {\r\n    uint _pID = addrXpId[msg.sender];\r\n    if(_pID == 0) { // player not exist yet. create one\r\n      playerNum = playerNum + 1;\r\n      Player memory p;\r\n      p.addr = msg.sender;\r\n      p.affId = _affId;\r\n      players[playerNum] = p;\r\n      _pID = playerNum;\r\n      addrXpId[msg.sender] = _pID;\r\n    }\r\n    buy(_pID, msg.value, _affId, _keyType);\r\n  }\r\n\r\n  function buyFromVault(uint _amount, uint256 _affId, uint _keyType) public isGameActive  {\r\n    uint _pID = addrXpId[msg.sender];\r\n    uint _earning = getPlayerEarning(_pID);\r\n    uint _newEthWithdraw = _amount.add(players[_pID].ethWithdraw);\r\n    require(_newEthWithdraw < _earning); // withdraw amount cannot bigger than earning\r\n    players[_pID].ethWithdraw = _newEthWithdraw; // update player withdraw\r\n    buy(_pID, _amount, _affId, _keyType);\r\n  }\r\n\r\n  function getKeyPrice(uint _keyAmount) public view returns(uint256) {\r\n    if(now > startTime) {\r\n      return totalKeys.add(_keyAmount).ethRec(_keyAmount);\r\n    } else { // copy fomo init price\r\n      return (7500000000000);\r\n    }\r\n  }\r\n\r\n  function buy(uint256 _pID, uint256 _eth, uint256 _affId, uint _keyType) private {\r\n\r\n    if (_eth > minPay) { // bigger than minimum pay\r\n      players[_pID].eth = _eth.add(players[_pID].eth);\r\n      uint _keys = totalEther.keysRec(_eth);\r\n      //bought at least 1 whole key\r\n      if(_keys >= 1000000000000000000) {\r\n        updateTimer(_keys);\r\n      }\r\n\r\n      //update total ether and total keys\r\n      totalEther = totalEther.add(_eth);\r\n      totalKeys = totalKeys.add(_keys);\r\n      // update game portion\r\n      uint256 _game = _eth.mul(gamePrize).div(100);\r\n      gamePot = _game.add(gamePot);\r\n\r\n\r\n      // update player keys and keysForGame\r\n      if(_keyType == 1) { // high return key\r\n        players[_pID].hretKeys  = _keys.add(players[_pID].hretKeys);\r\n      } else if (_keyType == 2) {\r\n        players[_pID].mretKeys = _keys.add(players[_pID].mretKeys);\r\n        keysForGame = keysForGame.add(_keys.mul(extraRet).div(fixRet+extraRet));\r\n      } else if (_keyType == 3) {\r\n        players[_pID].lretKeys = _keys.add(players[_pID].lretKeys);\r\n        keysForGame = keysForGame.add(_keys);\r\n      } else { // keytype unknown.\r\n        revert();\r\n      }\r\n      //update affliliate gain\r\n      if(_affId != 0 && _affId != _pID && _affId <= playerNum) { // udate players\r\n          uint256 _aff = _eth.mul(affRet).div(100);\r\n          players[_affId].aff = _aff.add(players[_affId].aff);\r\n          totalCommPot = (_eth.mul(fixRet+extraRet).div(100)).add(totalCommPot);\r\n      } else { // addId == 0 or _affId is self, put the fund into earnings per key\r\n          totalCommPot = (_eth.mul(fixRet+extraRet+affRet).div(100)).add(totalCommPot);\r\n      }\r\n      // update stage info\r\n      if(totalKeys > groupPrizeStartAt) {\r\n        updateStageInfo(_pID, _keys);\r\n      }\r\n      emit BuyKey(_pID, _affId, _keyType, _keys);\r\n    } else { // if contribute less than the minimum conntribution return to player aff vault\r\n      players[_pID].aff = _eth.add(players[_pID].aff);\r\n    }\r\n  }\r\n\r\n  function updateStageInfo(uint _pID, uint _keyAmount) private {\r\n    uint _stageL = groupPrizeStartAt.add(groupPrizeStageGap.mul(stageId - 1));\r\n    uint _stageH = groupPrizeStartAt.add(groupPrizeStageGap.mul(stageId));\r\n    if(totalKeys > _stageH) { // game has been pushed to next stage\r\n      stageId = (totalKeys.sub(groupPrizeStartAt)).div(groupPrizeStageGap) + 1;\r\n      _keyAmount = (totalKeys.sub(groupPrizeStartAt)) % groupPrizeStageGap;\r\n      stageInfo[stageId][_pID] = stageInfo[stageId][_pID].add(_keyAmount);\r\n    } else {\r\n      if(_keyAmount < totalKeys.sub(_stageL)) {\r\n        stageInfo[stageId][_pID] = stageInfo[stageId][_pID].add(_keyAmount);\r\n      } else {\r\n        _keyAmount = totalKeys.sub(_stageL);\r\n        stageInfo[stageId][_pID] = stageInfo[stageId][_pID].add(_keyAmount);\r\n      }\r\n    }\r\n  }\r\n\r\n  function withdrawEarning(uint256 _amount) public {\r\n    address _addr = msg.sender;\r\n    uint256 _pID = addrXpId[_addr];\r\n    require(_pID != 0);  // player must exist\r\n\r\n    uint _earning = getPlayerEarning(_pID);\r\n    uint _remainingBalance = _earning.sub(players[_pID].ethWithdraw);\r\n    if(_amount > 0) {\r\n      require(_amount <= _remainingBalance);\r\n    }else{\r\n      _amount = _remainingBalance;\r\n    }\r\n\r\n\r\n    _addr.transfer(_amount);  // transfer remaining balance to\r\n    players[_pID].ethWithdraw = players[_pID].ethWithdraw.add(_amount);\r\n  }\r\n\r\n  function getPlayerEarning(uint256 _pID) view public returns (uint256) {\r\n    Player memory p = players[_pID];\r\n    uint _gain = totalCommPot.mul(p.hretKeys.add(p.mretKeys.mul(fixRet).div(fixRet+extraRet))).div(totalKeys);\r\n    uint _total = _gain.add(p.aff);\r\n    _total = getWinnerPrize(_pID).add(_total);\r\n    return _total;\r\n  }\r\n\r\n  function getPlayerWithdrawEarning(uint _pid) public view returns(uint){\r\n    uint _earning = getPlayerEarning(_pid);\r\n    return _earning.sub(players[_pid].ethWithdraw);\r\n  }\r\n\r\n  function getWinnerPrize(uint256 _pID) view public returns (uint256) {\r\n    uint _keys;\r\n    uint _pKeys;\r\n    if(now < endTime) {\r\n      return 0;\r\n    } else if(totalKeys > groupPrizeStartAt) { // keys in the winner stage share the group prize\r\n      _keys = totalKeys.sub(groupPrizeStartAt.add(groupPrizeStageGap.mul(stageId - 1)));\r\n      _pKeys = stageInfo[stageId][_pID];\r\n      return totalEther.mul(groupPrize).div(100).mul(_pKeys).div(_keys);\r\n    } else { // totalkeys does not meet the minimum group prize criteria, all keys share the group prize\r\n      Player memory p = players[_pID];\r\n      _pKeys = p.hretKeys.add(p.mretKeys).add(p.lretKeys);\r\n      return totalEther.mul(groupPrize).div(100).mul(_pKeys).div(totalKeys);\r\n    }\r\n  }\r\n\r\n  function getWinningStageInfo() view public returns (uint256 _stageId, uint256 _keys, uint256 _amount) {\r\n    _amount = totalEther.mul(groupPrize).div(100);\r\n    if(totalKeys < groupPrizeStartAt) { // group prize is not activate yet\r\n      return (0, totalKeys, _amount);\r\n    } else {\r\n      _stageId = stageId;\r\n      _keys = totalKeys.sub(groupPrizeStartAt.add(groupPrizeStageGap.mul(stageId - 1)));\r\n      return (_stageId, _keys, _amount);\r\n    }\r\n  }\r\n\r\n  function getPlayerStageKeys() view public returns (uint256 _stageId, uint _keys, uint _pKeys) {\r\n    uint _pID = addrXpId[msg.sender];\r\n    if(totalKeys < groupPrizeStartAt) {\r\n      Player memory p = players[_pID];\r\n      _pKeys = p.hretKeys.add(p.mretKeys).add(p.lretKeys);\r\n      return (0, totalKeys, _pKeys);\r\n    } else {\r\n      _stageId = stageId;\r\n      _keys = totalKeys.sub(groupPrizeStartAt.add(groupPrizeStageGap.mul(stageId - 1)));\r\n      _pKeys = stageInfo[_stageId][_pID];\r\n      return (_stageId, _keys, _pKeys);\r\n    }\r\n\r\n  }\r\n\r\n  function getTotalGamePot() view public returns (uint256) {\r\n    uint _gain = totalCommPot.mul(keysForGame).div(totalKeys);\r\n    uint _total = _gain.add(gamePot);\r\n    return _total;\r\n  }\r\n  \r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"getTotalGamePot\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"playerNum\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"stageInfo\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_fundCenter\",\"type\":\"address\"},{\"name\":\"_playerBook\",\"type\":\"address\"}],\"name\":\"setContractAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_COO\",\"type\":\"address\"}],\"name\":\"setCOO\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"playerBook\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CFO\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"endTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalKeys\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getWinningStageInfo\",\"outputs\":[{\"name\":\"_stageId\",\"type\":\"uint256\"},{\"name\":\"_keys\",\"type\":\"uint256\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_CFO\",\"type\":\"address\"}],\"name\":\"setCFO\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"addrXpId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"gameWithdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getPlayerStageKeys\",\"outputs\":[{\"name\":\"_stageId\",\"type\":\"uint256\"},{\"name\":\"_keys\",\"type\":\"uint256\"},{\"name\":\"_pKeys\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_affId\",\"type\":\"uint256\"},{\"name\":\"_keyType\",\"type\":\"uint256\"}],\"name\":\"buyByAddress\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_keyAmount\",\"type\":\"uint256\"}],\"name\":\"getKeyPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"teamWithdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalEther\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_pID\",\"type\":\"uint256\"}],\"name\":\"getPlayerEarning\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"},{\"name\":\"_name\",\"type\":\"string\"}],\"name\":\"receivePlayerInfo\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"gameWithdrawed\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_pid\",\"type\":\"uint256\"}],\"name\":\"getPlayerWithdrawEarning\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdrawEarning\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_pID\",\"type\":\"uint256\"}],\"name\":\"getWinnerPrize\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"COO\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_startTime\",\"type\":\"uint256\"}],\"name\":\"startGame\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_affId\",\"type\":\"uint256\"},{\"name\":\"_keyType\",\"type\":\"uint256\"}],\"name\":\"buyFromVault\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"teamWithdrawed\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalCommPot\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"players\",\"outputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"name\",\"type\":\"string\"},{\"name\":\"aff\",\"type\":\"uint256\"},{\"name\":\"affId\",\"type\":\"uint256\"},{\"name\":\"hretKeys\",\"type\":\"uint256\"},{\"name\":\"mretKeys\",\"type\":\"uint256\"},{\"name\":\"lretKeys\",\"type\":\"uint256\"},{\"name\":\"eth\",\"type\":\"uint256\"},{\"name\":\"ethWithdraw\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"fundCenter\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_CFO\",\"type\":\"address\"},{\"name\":\"_COO\",\"type\":\"address\"},{\"name\":\"_fundCenter\",\"type\":\"address\"},{\"name\":\"_playerBook\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_pID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_affId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_keyType\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_keyAmount\",\"type\":\"uint256\"}],\"name\":\"BuyKey\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_pID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"EarningWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"CKing","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"0000000000000000000000002250f5ce3d49caab3476e9e1811942fdc67f88e50000000000000000000000002250f5ce3d49caab3476e9e1811942fdc67f88e5000000000000000000000000366c513514176bc0edc1e17c290f54f308e43ac30000000000000000000000006fd749dc814754106bf097a2d1a7f089a8ff6cda","Library":"","SwarmSource":"bzzr://98ba3454c3e8460366530db0fb6107b1984a9baaf2264ad5d11cac942a2993e4"}]}