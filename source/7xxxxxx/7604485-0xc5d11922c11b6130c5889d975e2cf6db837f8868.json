{"status":"1","message":"OK","result":[{"SourceCode":"// File: contracts/exchange/ownable.sol\r\n\r\npragma solidity 0.5.6;\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n     * account.\r\n     */\r\n    constructor () internal {\r\n        _owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), _owner);\r\n    }\r\n\r\n    /**\r\n     * @return the address of the owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner());\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @return true if `msg.sender` is the owner of the contract.\r\n     */\r\n    function isOwner() public view returns (bool) {\r\n        return msg.sender == _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to relinquish control of the contract.\r\n     * It will not be possible to call the functions with the `onlyOwner`\r\n     * modifier anymore.\r\n     * @notice Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0));\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\n// File: contracts/exchange/safe-math.sol\r\n\r\npragma solidity 0.5.6;\r\n\r\n/**\r\n * @dev Math operations with safety checks that throw on error. This contract is based on the \r\n * source code at: \r\n * https://github.com/OpenZeppelin/openzeppelin-solidity/blob/master/contracts/math/SafeMath.sol.\r\n */\r\nlibrary SafeMath\r\n{\r\n\r\n  /**\r\n   * @dev Multiplies two numbers, reverts on overflow.\r\n   * @param _factor1 Factor number.\r\n   * @param _factor2 Factor number.\r\n   * @return The product of the two factors.\r\n   */\r\n  function mul(\r\n    uint256 _factor1,\r\n    uint256 _factor2\r\n  )\r\n    internal\r\n    pure\r\n    returns (uint256 product)\r\n  {\r\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (_factor1 == 0)\r\n    {\r\n      return 0;\r\n    }\r\n\r\n    product = _factor1 * _factor2;\r\n    require(product / _factor1 == _factor2);\r\n  }\r\n\r\n  /**\r\n   * @dev Integer division of two numbers, truncating the quotient, reverts on division by zero.\r\n   * @param _dividend Dividend number.\r\n   * @param _divisor Divisor number.\r\n   * @return The quotient.\r\n   */\r\n  function div(\r\n    uint256 _dividend,\r\n    uint256 _divisor\r\n  )\r\n    internal\r\n    pure\r\n    returns (uint256 quotient)\r\n  {\r\n    // Solidity automatically asserts when dividing by 0, using all gas.\r\n    require(_divisor > 0);\r\n    quotient = _dividend / _divisor;\r\n    // assert(_dividend == _divisor * quotient + _dividend % _divisor); // There is no case in which this doesn't hold.\r\n  }\r\n\r\n  /**\r\n   * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n   * @param _minuend Minuend number.\r\n   * @param _subtrahend Subtrahend number.\r\n   * @return Difference.\r\n   */\r\n  function sub(\r\n    uint256 _minuend,\r\n    uint256 _subtrahend\r\n  )\r\n    internal\r\n    pure\r\n    returns (uint256 difference)\r\n  {\r\n    require(_subtrahend <= _minuend);\r\n    difference = _minuend - _subtrahend;\r\n  }\r\n\r\n  /**\r\n   * @dev Adds two numbers, reverts on overflow.\r\n   * @param _addend1 Number.\r\n   * @param _addend2 Number.\r\n   * @return Sum.\r\n   */\r\n  function add(\r\n    uint256 _addend1,\r\n    uint256 _addend2\r\n  )\r\n    internal\r\n    pure\r\n    returns (uint256 sum)\r\n  {\r\n    sum = _addend1 + _addend2;\r\n    require(sum >= _addend1);\r\n  }\r\n\r\n  /**\r\n    * @dev Divides two numbers and returns the remainder (unsigned integer modulo), reverts when\r\n    * dividing by zero.\r\n    * @param _dividend Number.\r\n    * @param _divisor Number.\r\n    * @return Remainder.\r\n    */\r\n  function mod(\r\n    uint256 _dividend,\r\n    uint256 _divisor\r\n  )\r\n    internal\r\n    pure\r\n    returns (uint256 remainder) \r\n  {\r\n    require(_divisor != 0);\r\n    remainder = _dividend % _divisor;\r\n  }\r\n\r\n}\r\n\r\n// File: contracts/exchange/erc721-token-receiver.sol\r\n\r\npragma solidity 0.5.6;\r\n\r\n/**\r\n * @dev ERC-721 interface for accepting safe transfers. \r\n * See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md.\r\n */\r\ninterface ERC721TokenReceiver\r\n{\r\n\r\n  /**\r\n   * @dev Handle the receipt of a NFT. The ERC721 smart contract calls this function on the\r\n   * recipient after a `transfer`. This function MAY throw to revert and reject the transfer. Return\r\n   * of other than the magic value MUST result in the transaction being reverted.\r\n   * Returns `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))` unless throwing.\r\n   * @notice The contract address is always the message sender. A wallet/broker/auction application\r\n   * MUST implement the wallet interface if it will accept safe transfers.\r\n   * @param _operator The address which called `safeTransferFrom` function.\r\n   * @param _from The address which previously owned the token.\r\n   * @param _tokenId The NFT identifier which is being transferred.\r\n   * @param _data Additional data with no specified format.\r\n   * @return Returns `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`.\r\n   */\r\n  function onERC721Received(\r\n    address _operator,\r\n    address _from,\r\n    uint256 _tokenId,\r\n    bytes calldata _data\r\n  )\r\n    external\r\n    returns(bytes4);\r\n\r\n\tfunction onERC721Received(\r\n    address _from, \r\n    uint256 _tokenId, \r\n    bytes calldata _data\r\n  ) \r\n  external \r\n  returns \r\n  (bytes4);\r\n\r\n}\r\n\r\n// File: contracts/exchange/ERC165Checker.sol\r\n\r\npragma solidity ^0.5.6;\r\n\r\n/**\r\n * @title ERC165Checker\r\n * @dev Use `using ERC165Checker for address`; to include this library\r\n * https://eips.ethereum.org/EIPS/eip-165\r\n */\r\nlibrary ERC165Checker {\r\n    // As per the EIP-165 spec, no interface should ever match 0xffffffff\r\n    bytes4 private constant _INTERFACE_ID_INVALID = 0xffffffff;\r\n\r\n    bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;\r\n    /*\r\n     * 0x01ffc9a7 ===\r\n     *     bytes4(keccak256('supportsInterface(bytes4)'))\r\n     */\r\n\r\n    /**\r\n     * @notice Query if a contract supports ERC165\r\n     * @param account The address of the contract to query for support of ERC165\r\n     * @return true if the contract at account implements ERC165\r\n     */\r\n    function _supportsERC165(address account) internal view returns (bool) {\r\n        // Any contract that implements ERC165 must explicitly indicate support of\r\n        // InterfaceId_ERC165 and explicitly indicate non-support of InterfaceId_Invalid\r\n        return _supportsERC165Interface(account, _INTERFACE_ID_ERC165) &&\r\n            !_supportsERC165Interface(account, _INTERFACE_ID_INVALID);\r\n    }\r\n\r\n    /**\r\n     * @notice Query if a contract implements an interface, also checks support of ERC165\r\n     * @param account The address of the contract to query for support of an interface\r\n     * @param interfaceId The interface identifier, as specified in ERC-165\r\n     * @return true if the contract at account indicates support of the interface with\r\n     * identifier interfaceId, false otherwise\r\n     * @dev Interface identification is specified in ERC-165.\r\n     */\r\n    function _supportsInterface(address account, bytes4 interfaceId) internal view returns (bool) {\r\n        // query support of both ERC165 as per the spec and support of _interfaceId\r\n        return _supportsERC165(account) &&\r\n            _supportsERC165Interface(account, interfaceId);\r\n    }\r\n\r\n    /**\r\n     * @notice Query if a contract implements interfaces, also checks support of ERC165\r\n     * @param account The address of the contract to query for support of an interface\r\n     * @param interfaceIds A list of interface identifiers, as specified in ERC-165\r\n     * @return true if the contract at account indicates support all interfaces in the\r\n     * interfaceIds list, false otherwise\r\n     * @dev Interface identification is specified in ERC-165.\r\n     */\r\n    function _supportsAllInterfaces(address account, bytes4[] memory interfaceIds) internal view returns (bool) {\r\n        // query support of ERC165 itself\r\n        if (!_supportsERC165(account)) {\r\n            return false;\r\n        }\r\n\r\n        // query support of each interface in _interfaceIds\r\n        for (uint256 i = 0; i < interfaceIds.length; i++) {\r\n            if (!_supportsERC165Interface(account, interfaceIds[i])) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        // all interfaces supported\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @notice Query if a contract implements an interface, does not check ERC165 support\r\n     * @param account The address of the contract to query for support of an interface\r\n     * @param interfaceId The interface identifier, as specified in ERC-165\r\n     * @return true if the contract at account indicates support of the interface with\r\n     * identifier interfaceId, false otherwise\r\n     * @dev Assumes that account contains a contract that supports ERC165, otherwise\r\n     * the behavior of this method is undefined. This precondition can be checked\r\n     * with the `supportsERC165` method in this library.\r\n     * Interface identification is specified in ERC-165.\r\n     */\r\n    function _supportsERC165Interface(address account, bytes4 interfaceId) private view returns (bool) {\r\n        // success determines whether the staticcall succeeded and result determines\r\n        // whether the contract at account indicates support of _interfaceId\r\n        (bool success, bool result) = _callERC165SupportsInterface(account, interfaceId);\r\n\r\n        return (success && result);\r\n    }\r\n\r\n    /**\r\n     * @notice Calls the function with selector 0x01ffc9a7 (ERC165) and suppresses throw\r\n     * @param account The address of the contract to query for support of an interface\r\n     * @param interfaceId The interface identifier, as specified in ERC-165\r\n     * @return success true if the STATICCALL succeeded, false otherwise\r\n     * @return result true if the STATICCALL succeeded and the contract at account\r\n     * indicates support of the interface with identifier interfaceId, false otherwise\r\n     */\r\n    function _callERC165SupportsInterface(address account, bytes4 interfaceId)\r\n        private\r\n        view\r\n        returns (bool success, bool result)\r\n    {\r\n        bytes memory encodedParams = abi.encodeWithSelector(_INTERFACE_ID_ERC165, interfaceId);\r\n\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n            let encodedParams_data := add(0x20, encodedParams)\r\n            let encodedParams_size := mload(encodedParams)\r\n\r\n            let output := mload(0x40)    // Find empty storage location using \"free memory pointer\"\r\n            mstore(output, 0x0)\r\n\r\n            success := staticcall(\r\n                30000,                   // 30k gas\r\n                account,                 // To addr\r\n                encodedParams_data,\r\n                encodedParams_size,\r\n                output,\r\n                0x20                     // Outputs are 32 bytes long\r\n            )\r\n\r\n            result := mload(output)      // Load the result\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/exchange/exchange.sol\r\n\r\npragma solidity 0.5.6;\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @dev Interface to Interative with ERC-721 Contract.\r\n */\r\ncontract Erc721Interface {\r\n    function transferFrom(address _from, address _to, uint256 _tokenId) external;\r\n    function isApprovedForAll(address _owner, address _operator) external view returns (bool);\r\n    function ownerOf(uint256 _tokenId) external view returns (address _owner);\r\n}\r\n\r\n/**\r\n * @dev Interface to Interative with CryptoKitties Contract.\r\n */\r\ncontract KittyInterface {\r\n    mapping (uint256 => address) public kittyIndexToApproved;\r\n    function transfer(address _to, uint256 _tokenId) external;\r\n    function transferFrom(address _from, address _to, uint256 _tokenId) external;\r\n    function ownerOf(uint256 _tokenId) external view returns (address _owner);\r\n}\r\n\r\n\r\ncontract Exchange is Ownable, ERC721TokenReceiver {\r\n\r\n    using SafeMath for uint256;\r\n    using SafeMath for uint;\r\n    using ERC165Checker for address;\r\n\r\n    /**\r\n     * @dev CryptoKitties KittyCore Contract address.\r\n     */\r\n    address constant internal  CryptoKittiesAddress = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d;\r\n    \r\n    /**\r\n     * @dev Magic value of a smart contract that can recieve NFT.\r\n     * Equal to: bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\")).\r\n     */\r\n    bytes4 internal constant ERC721_RECEIVED_THREE_INPUT = 0xf0b9e5ba;\r\n\r\n    /**\r\n    * @dev Magic value of a smart contract that can recieve NFT.\r\n    * Equal to: bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\")).\r\n    */\r\n    bytes4 internal constant ERC721_RECEIVED_FOUR_INPUT = 0x150b7a02;\r\n\r\n    /**\r\n    * @dev A mapping from NFT ID to the owner address.\r\n    */\r\n    mapping (address => mapping (uint256 => address)) internal TokenToOwner;\r\n\r\n    /**\r\n    * @dev A mapping from owner address to specific contract address's all NFT IDs \r\n    */\r\n    mapping (address => mapping (address => uint256[])) internal OwnerToTokens;\r\n\r\n    /**\r\n    * @dev A mapping from specific contract address's NFT ID to its index in owner tokens array \r\n    */\r\n    mapping (address => mapping(uint256 => uint256)) internal TokenToIndex;\r\n\r\n    /**\r\n    * @dev A mapping from the address to all order it owns\r\n    */\r\n    mapping (address => bytes32[]) internal OwnerToOrders;\r\n\r\n    /**\r\n    * @dev A mapping from order to owner address\r\n    */\r\n    mapping (bytes32 => address) internal OrderToOwner;\r\n\r\n    /**\r\n    * @dev A mapping from order to its index in owner order array.\r\n    */\r\n    mapping (bytes32 => uint) internal OrderToIndex;\r\n\r\n    /**\r\n    * @dev A mapping from matchorder to owner address\r\n    */\r\n    mapping (bytes32 => address) internal MatchOrderToOwner;\r\n   \r\n    /**\r\n    * @dev A mapping from order to all matchorder it owns\r\n    */\r\n    mapping (bytes32 => bytes32[]) internal OrderToMatchOrders;\r\n\r\n    /**\r\n    * @dev A mapping from matchorder to its index in order's matchorder array\r\n    */\r\n    mapping (bytes32 => mapping(bytes32 => uint)) internal OrderToMatchOrderIndex;\r\n\r\n    /**\r\n    * @dev A mapping from order to confirm it exist or not\r\n    */\r\n    mapping (bytes32 => bool) internal OrderToExist;\r\n\r\n\r\n    /**\r\n    * @dev An array which contains all support NFT interface in Exchange\r\n    */\r\n    bytes4[] internal SupportNFTInterface;\r\n\r\n    /**\r\n    * @dev order and matchorder is equal to keccak256(contractAddress, tokenId, owner),\r\n    * because order is just a hash, so OrderObj is use to record details.\r\n    */\r\n    struct OrderObj {\r\n        // NFT's owner\r\n        address owner;\r\n\r\n        // NFT's contract address\r\n        address contractAddress;\r\n        \r\n        // NFT's id\r\n        uint256 tokenId;\r\n    }\r\n\r\n    /**\r\n    * @dev An mapping from order or matchorder's hash to it order obj\r\n    */\r\n    mapping (bytes32 => OrderObj) internal HashToOrderObj;\r\n\r\n    /**\r\n    * @dev This emits when someone called receiveErc721Token and success transfer NFT to \r\n    * exchange contract.\r\n    * @param _from Owner of NFT  \r\n    * @param _contractAddress NFT's contract address\r\n    * @param _tokenId NFT's id\r\n    */\r\n    event ReceiveToken(\r\n        address indexed _from, \r\n        address _contractAddress, \r\n        uint256 _tokenId\r\n    );\r\n\r\n\r\n    /**\r\n    * @dev This emits when someone called SendBackToken and transfer NFT from\r\n    * exchange contract to it owner\r\n    * @param _owner Owner of NFT  \r\n    * @param _contractAddress NFT's contract address\r\n    * @param _tokenId NFT's id\r\n    */\r\n    event SendBackToken(\r\n        address indexed _owner, \r\n        address _contractAddress, \r\n        uint256 _tokenId\r\n    );\r\n\r\n    /**\r\n    * @dev This emits when send NFT happened from exchange contract to other address\r\n    * @param _to exchange contract send address\r\n    * @param _contractAddress NFT's contract address\r\n    * @param _tokenId NFT's id\r\n    */\r\n    event SendToken(\r\n        address indexed _to, \r\n        address _contractAddress, \r\n        uint256 _tokenId\r\n    );\r\n\r\n    /**\r\n    * @dev This emits when an OrderObj be created \r\n    * @param _hash order's hash\r\n    * @param _owner Owner of NFT  \r\n    * @param _contractAddress NFT's contract address\r\n    * @param _tokenId NFT's id\r\n    */\r\n    event CreateOrderObj(\r\n        bytes32 indexed _hash,\r\n        address _owner,\r\n        address _contractAddress,\r\n        uint256 _tokenId   \r\n    );\r\n\r\n    /**\r\n    * @dev This emits when an order be created \r\n    * @param _from this order's owner\r\n    * @param _orderHash this order's hash\r\n    * @param _contractAddress NFT's contract address\r\n    * @param _tokenId NFT's id\r\n    */\r\n    event CreateOrder(\r\n        address indexed _from,\r\n        bytes32 indexed _orderHash,\r\n        address _contractAddress,\r\n        uint256 _tokenId\r\n    );\r\n\r\n    /**\r\n    * @dev This emits when an matchorder be created \r\n    * @param _from this order's owner\r\n    * @param _orderHash order's hash which matchorder pairing\r\n    * @param _matchOrderHash this matchorder's hash\r\n    * @param _contractAddress NFT's contract address\r\n    * @param _tokenId NFT's id\r\n    */\r\n    event CreateMatchOrder(\r\n        address indexed _from,\r\n        bytes32 indexed _orderHash,\r\n        bytes32 indexed _matchOrderHash,\r\n        address _contractAddress,\r\n        uint256 _tokenId\r\n    );\r\n\r\n    /**\r\n    * @dev This emits when an order be deleted \r\n    * @param _from this order's owner\r\n    * @param _orderHash this order's hash\r\n    */\r\n    event DeleteOrder(\r\n        address indexed _from,\r\n        bytes32 indexed _orderHash\r\n    );\r\n\r\n    /**\r\n    * @dev This emits when an matchorder be deleted \r\n    * @param _from this matchorder's owner\r\n    * @param _orderHash order which matchorder pairing\r\n    * @param _matchOrderHash this matchorder\r\n    */\r\n    event DeleteMatchOrder(\r\n        address indexed _from,\r\n        bytes32 indexed _orderHash,\r\n        bytes32 indexed _matchOrderHash\r\n    );\r\n\r\n\r\n    /**\r\n    * @dev Function only be executed when massage sender is NFT's owner\r\n    * @param contractAddress NFT's contract address\r\n    * @param tokenId NFT's id\r\n    */\r\n    modifier onlySenderIsOriginalOwner(\r\n        address contractAddress, \r\n        uint256 tokenId\r\n    ) \r\n    {\r\n        require(TokenToOwner[contractAddress][tokenId] == msg.sender, \"original owner should be message sender\");\r\n        _;\r\n    }\r\n\r\n    constructor () public {\r\n        //nf-token\r\n        SupportNFTInterface.push(0x80ac58cd);\r\n\r\n        //nf-token-metadata\r\n        SupportNFTInterface.push(0x780e9d63);\r\n\r\n        //nf-token-enumerable\r\n        SupportNFTInterface.push(0x5b5e139f);\r\n    }\r\n\r\n   /**\r\n   * @dev Add support NFT interface in Exchange\r\n   * @notice Only Exchange owner can do tihs\r\n   * @param interface_id Support NFT interface's interface_id\r\n   */\r\n    function addSupportNFTInterface(\r\n        bytes4 interface_id\r\n    )\r\n    external\r\n    onlyOwner()\r\n    {\r\n        SupportNFTInterface.push(interface_id);\r\n    }\r\n\r\n   /**\r\n   * @dev NFT contract will call when it use safeTransferFrom method\r\n   */\r\n    function onERC721Received(\r\n        address _from, \r\n        uint256 _tokenId, \r\n        bytes calldata _data\r\n    ) \r\n    external \r\n    returns (bytes4)\r\n    {\r\n        return ERC721_RECEIVED_THREE_INPUT;\r\n    }\r\n\r\n   /**\r\n   * @dev NFT contract will call when it use safeTransferFrom method\r\n   */\r\n    function onERC721Received(\r\n        address _operator,\r\n        address _from,\r\n        uint256 _tokenId,\r\n        bytes calldata data\r\n    )\r\n    external\r\n    returns(bytes4)\r\n    {\r\n        return ERC721_RECEIVED_FOUR_INPUT;\r\n    }\r\n\r\n   /**\r\n   * @dev Create an order for your NFT and other people can pairing their NFT to exchange\r\n   * @notice You must call receiveErc721Token method first to send your NFT to exchange contract,\r\n   * if your NFT have matchorder pair with other order, then they will become Invalid until you\r\n   * delete this order.\r\n   * @param contractAddress NFT's contract address\r\n   * @param tokenId NFT's id\r\n   */\r\n    function createOrder(\r\n        address contractAddress, \r\n        uint256 tokenId\r\n    ) \r\n    external \r\n    onlySenderIsOriginalOwner(\r\n        contractAddress, \r\n        tokenId\r\n    ) \r\n    {\r\n        bytes32 orderHash = keccak256(abi.encodePacked(contractAddress, tokenId, msg.sender));\r\n        require(OrderToOwner[orderHash] != msg.sender, \"Order already exist\");\r\n        _addOrder(msg.sender, orderHash);\r\n        emit CreateOrder(msg.sender, orderHash, contractAddress, tokenId);\r\n    }\r\n\r\n   /**\r\n   * @dev write order information to exchange contract.\r\n   * @param sender order's owner\r\n   * @param orderHash order's hash\r\n   */\r\n    function _addOrder(\r\n        address sender, \r\n        bytes32 orderHash\r\n    ) \r\n    internal \r\n    {\r\n        uint index = OwnerToOrders[sender].push(orderHash).sub(1);\r\n        OrderToOwner[orderHash] = sender;\r\n        OrderToIndex[orderHash] = index;\r\n        OrderToExist[orderHash] = true;\r\n    }\r\n\r\n   /**\r\n   * @dev Delete an order if you don't want exchange NFT to anyone, or you want get your NFT back.\r\n   * @param orderHash order's hash\r\n   */\r\n    function deleteOrder(\r\n        bytes32 orderHash\r\n    )\r\n    external\r\n    {\r\n        require(OrderToOwner[orderHash] == msg.sender, \"this order hash not belongs to this address\");\r\n        _removeOrder(msg.sender, orderHash);\r\n        emit DeleteOrder(msg.sender, orderHash);\r\n    }\r\n\r\n   /**\r\n   * @dev Remove order information on exchange contract \r\n   * @param sender order's owner\r\n   * @param orderHash order's hash\r\n   */\r\n    function _removeOrder(\r\n        address sender,\r\n        bytes32 orderHash\r\n    )\r\n    internal\r\n    {\r\n        OrderToExist[orderHash] = false;\r\n        delete OrderToOwner[orderHash];\r\n        uint256 orderIndex = OrderToIndex[orderHash];\r\n        uint256 lastOrderIndex = OwnerToOrders[sender].length.sub(1);\r\n        if (lastOrderIndex != orderIndex){\r\n            bytes32 lastOwnerOrder = OwnerToOrders[sender][lastOrderIndex];\r\n            OwnerToOrders[sender][orderIndex] = lastOwnerOrder;\r\n            OrderToIndex[lastOwnerOrder] = orderIndex;\r\n        }\r\n        OwnerToOrders[sender].length--;\r\n    }\r\n\r\n   /**\r\n   * @dev If your are interested in specfic order's NFT, create a matchorder and pair with it so order's owner\r\n   * can know and choose to exchange with you\r\n   * @notice You must call receiveErc721Token method first to send your NFT to exchange contract,\r\n   * if your NFT already create order, then you will be prohibit create matchorder until you delete this NFT's \r\n   * order.\r\n   * @param contractAddress NFT's contract address\r\n   * @param tokenId NFT's id\r\n   * @param orderHash order's hash which matchorder want to pair with \r\n   */\r\n    function createMatchOrder(\r\n        address contractAddress,\r\n        uint256 tokenId, \r\n        bytes32 orderHash\r\n    ) \r\n    external \r\n    onlySenderIsOriginalOwner(\r\n        contractAddress, \r\n        tokenId\r\n    ) \r\n    {\r\n        bytes32 matchOrderHash = keccak256(abi.encodePacked(contractAddress, tokenId, msg.sender));\r\n        require(OrderToOwner[matchOrderHash] != msg.sender, \"Order already exist\");\r\n        _addMatchOrder(matchOrderHash, orderHash);\r\n        emit CreateMatchOrder(msg.sender, orderHash, matchOrderHash, contractAddress, tokenId);\r\n    }\r\n\r\n   /**\r\n   * @dev add matchorder information on exchange contract \r\n   * @param matchOrderHash matchorder's hash\r\n   * @param orderHash order's hash which matchorder pair with \r\n   */\r\n    function _addMatchOrder(\r\n        bytes32 matchOrderHash, \r\n        bytes32 orderHash\r\n    ) \r\n    internal \r\n    {\r\n        uint inOrderIndex = OrderToMatchOrders[orderHash].push(matchOrderHash).sub(1);\r\n        OrderToMatchOrderIndex[orderHash][matchOrderHash] = inOrderIndex;\r\n    }\r\n\r\n   /**\r\n   * @dev delete matchorder information on exchange contract \r\n   * @param matchOrderHash matchorder's hash\r\n   * @param orderHash order's hash which matchorder pair with \r\n   */\r\n    function deleteMatchOrder(\r\n        bytes32 matchOrderHash,\r\n        bytes32 orderHash\r\n    )\r\n    external\r\n    {\r\n        require(MatchOrderToOwner[matchOrderHash] == msg.sender, \"match order doens't belong to this address\" );\r\n        require(OrderToExist[orderHash] == true, \"this order is not exist\");\r\n        _removeMatchOrder(orderHash, matchOrderHash);\r\n        emit DeleteMatchOrder(msg.sender, orderHash, matchOrderHash);\r\n    }\r\n\r\n  /**\r\n   * @dev delete matchorder information on exchange contract \r\n   * @param orderHash order's hash which matchorder pair with \r\n   * @param matchOrderHash matchorder's hash\r\n   */\r\n    function _removeMatchOrder(\r\n        bytes32 orderHash,\r\n        bytes32 matchOrderHash\r\n    )\r\n    internal\r\n    {\r\n        uint256 matchOrderIndex = OrderToMatchOrderIndex[orderHash][matchOrderHash];\r\n        uint256 lastMatchOrderIndex = OrderToMatchOrders[orderHash].length.sub(1);\r\n        if (lastMatchOrderIndex != matchOrderIndex){\r\n            bytes32 lastMatchOrder = OrderToMatchOrders[orderHash][lastMatchOrderIndex];\r\n            OrderToMatchOrders[orderHash][matchOrderIndex] = lastMatchOrder;\r\n            OrderToMatchOrderIndex[orderHash][lastMatchOrder] = matchOrderIndex;\r\n        }\r\n        OrderToMatchOrders[orderHash].length--;\r\n    }\r\n\r\n    /**\r\n    * @dev order's owner can choose NFT to exchange from it's match order array, when function \r\n    * execute, order will be deleted, both NFT will be exchanged and send to corresponding address.\r\n    * @param order order's hash which matchorder pair with \r\n    * @param matchOrder matchorder's hash\r\n    */\r\n    function exchangeToken(\r\n        bytes32 order,\r\n        bytes32 matchOrder\r\n    ) \r\n    external \r\n    {\r\n        require(OrderToOwner[order] == msg.sender, \"this order doesn't belongs to this address\");\r\n        OrderObj memory orderObj = HashToOrderObj[order];\r\n        uint index = OrderToMatchOrderIndex[order][matchOrder];\r\n        require(OrderToMatchOrders[order][index] == matchOrder, \"match order is not in this order\");\r\n        require(OrderToExist[matchOrder] != true, \"this match order's token have open order\");\r\n        OrderObj memory matchOrderObj = HashToOrderObj[matchOrder];\r\n        _sendToken(matchOrderObj.owner, orderObj.contractAddress, orderObj.tokenId);\r\n        _sendToken(orderObj.owner, matchOrderObj.contractAddress, matchOrderObj.tokenId);\r\n        _removeMatchOrder(order, matchOrder);\r\n        _removeOrder(msg.sender, order);\r\n    }\r\n\r\n    /**\r\n    * @dev if you want to create order and matchorder on exchange contract, you must call this function\r\n    * to send your NFT to exchange contract, if your NFT is followed erc165 and erc721 standard, exchange\r\n    * contract will checked and execute sucessfully, then contract will record your information so you \r\n    * don't need worried about NFT lost.\r\n    * @notice because contract can't directly transfer your NFT, so you should call setApprovalForAll \r\n    * on NFT contract first, so this function can execute successfully.\r\n    * @param contractAddress NFT's Contract address\r\n    * @param tokenId NFT's id \r\n    */\r\n    function receiveErc721Token(\r\n        address contractAddress, \r\n        uint256 tokenId\r\n    ) \r\n    external  \r\n    {\r\n        bool checkSupportErc165Interface = false;\r\n        if(contractAddress != CryptoKittiesAddress){\r\n            for(uint i = 0; i < SupportNFTInterface.length; i++){\r\n                if(contractAddress._supportsInterface(SupportNFTInterface[i]) == true){\r\n                    checkSupportErc165Interface = true;\r\n                }\r\n            }\r\n            require(checkSupportErc165Interface == true, \"not supported Erc165 Interface\");\r\n            Erc721Interface erc721Contract = Erc721Interface(contractAddress);\r\n            require(erc721Contract.isApprovedForAll(msg.sender,address(this)) == true, \"contract doesn't have power to control this token id\");\r\n            erc721Contract.transferFrom(msg.sender, address(this), tokenId);\r\n        }else {\r\n            KittyInterface kittyContract = KittyInterface(contractAddress);\r\n            require(kittyContract.kittyIndexToApproved(tokenId) == address(this), \"contract doesn't have power to control this cryptoKitties's id\");\r\n            kittyContract.transferFrom(msg.sender, address(this), tokenId);\r\n        }\r\n        _addToken(msg.sender, contractAddress, tokenId);\r\n        emit ReceiveToken(msg.sender, contractAddress, tokenId);\r\n\r\n    }\r\n\r\n    /**\r\n    * @dev add token and OrderObj information on exchange contract, because order hash and matchorder\r\n    * hash are same, so one NFT have mapping to one OrderObj\r\n    * @param sender NFT's owner\r\n    * @param contractAddress NFT's contract address\r\n    * @param tokenId NFT's id\r\n    */\r\n    function _addToken(\r\n        address sender, \r\n        address contractAddress, \r\n        uint256 tokenId\r\n    ) \r\n    internal \r\n    {   \r\n        bytes32 matchOrderHash = keccak256(abi.encodePacked(contractAddress, tokenId, sender));\r\n        MatchOrderToOwner[matchOrderHash] = sender;\r\n        HashToOrderObj[matchOrderHash] = OrderObj(sender,contractAddress,tokenId);\r\n        TokenToOwner[contractAddress][tokenId] = sender;\r\n        uint index = OwnerToTokens[sender][contractAddress].push(tokenId).sub(1);\r\n        TokenToIndex[contractAddress][tokenId] = index;\r\n        emit CreateOrderObj(matchOrderHash, sender, contractAddress, tokenId);\r\n    }\r\n\r\n\r\n    /**\r\n    * @dev send your NFT back to address which you send token in, if your NFT still have open order,\r\n    * then order will be deleted\r\n    * @notice matchorder will not be deleted because cost too high, but they will be useless and other\r\n    * people can't choose your match order to exchange\r\n    * @param contractAddress NFT's Contract address\r\n    * @param tokenId NFT's id \r\n    */\r\n    function sendBackToken(\r\n        address contractAddress, \r\n        uint256 tokenId\r\n    ) \r\n    external \r\n    onlySenderIsOriginalOwner(\r\n        contractAddress, \r\n        tokenId\r\n    ) \r\n    {\r\n        bytes32 orderHash = keccak256(abi.encodePacked(contractAddress, tokenId, msg.sender));\r\n        if(OrderToExist[orderHash] == true) {\r\n            _removeOrder(msg.sender, orderHash);\r\n        }\r\n        _sendToken(msg.sender, contractAddress, tokenId);\r\n        emit SendBackToken(msg.sender, contractAddress, tokenId);\r\n    }  \r\n\r\n\r\n    /**\r\n    * @dev Drive NFT contract to send NFT to corresponding address\r\n    * @notice because cryptokittes contract method are not the same as general NFT contract, so \r\n    * need treat it individually\r\n    * @param sendAddress NFT's owner\r\n    * @param contractAddress NFT's contract address\r\n    * @param tokenId NFT's id\r\n    */\r\n    function _sendToken(\r\n        address sendAddress,\r\n        address contractAddress, \r\n        uint256 tokenId\r\n    )\r\n    internal\r\n    {   \r\n        if(contractAddress != CryptoKittiesAddress){\r\n            Erc721Interface erc721Contract = Erc721Interface(contractAddress);\r\n            require(erc721Contract.ownerOf(tokenId) == address(this), \"exchange contract should have this token\");\r\n            erc721Contract.transferFrom(address(this), sendAddress, tokenId);\r\n        }else{\r\n            KittyInterface kittyContract = KittyInterface(contractAddress);\r\n            require(kittyContract.ownerOf(tokenId) == address(this), \"exchange contract should have this token\");\r\n            kittyContract.transfer(sendAddress, tokenId);\r\n        }\r\n        _removeToken(contractAddress, tokenId);\r\n        emit SendToken(sendAddress, contractAddress, tokenId);\r\n    }\r\n\r\n    /**\r\n    * @dev remove token and OrderObj information on exchange contract\r\n    * @param contractAddress NFT's contract address\r\n    * @param tokenId NFT's id\r\n    */\r\n    function _removeToken(\r\n        address contractAddress, \r\n        uint256 tokenId\r\n    ) \r\n    internal \r\n    {\r\n        address owner = TokenToOwner[contractAddress][tokenId];\r\n        bytes32 orderHash = keccak256(abi.encodePacked(contractAddress, tokenId, owner));\r\n        delete HashToOrderObj[orderHash];\r\n        delete MatchOrderToOwner[orderHash];\r\n        delete TokenToOwner[contractAddress][tokenId];\r\n        uint256 tokenIndex = TokenToIndex[contractAddress][tokenId];\r\n        uint256 lastOwnerTokenIndex = OwnerToTokens[owner][contractAddress].length.sub(1);\r\n        if (lastOwnerTokenIndex != tokenIndex){\r\n            uint256 lastOwnerToken = OwnerToTokens[owner][contractAddress][lastOwnerTokenIndex];\r\n            OwnerToTokens[owner][contractAddress][tokenIndex] = lastOwnerToken;\r\n            TokenToIndex[contractAddress][lastOwnerToken] = tokenIndex;\r\n        }\r\n        OwnerToTokens[owner][contractAddress].length--;\r\n    }\r\n\r\n    /**\r\n    * @dev get NFT owner address\r\n    * @param contractAddress NFT's contract address\r\n    * @param tokenId NFT's id\r\n    * @return NFT owner address\r\n    */\r\n    function getTokenOwner(\r\n        address contractAddress, \r\n        uint256 tokenId\r\n    ) \r\n    external \r\n    view \r\n    returns (address)\r\n    {\r\n        return TokenToOwner[contractAddress][tokenId];\r\n    }\r\n    \r\n    /**\r\n    * @dev get owner's specfic contract address's all NFT array \r\n    * @param ownerAddress owner address\r\n    * @param contractAddress  NFT's contract address\r\n    * @return NFT's array\r\n    */\r\n    function getOwnerTokens(\r\n        address ownerAddress, \r\n        address contractAddress\r\n    ) \r\n    external \r\n    view \r\n    returns (uint256[] memory)\r\n    {\r\n        return OwnerToTokens[ownerAddress][contractAddress];\r\n    }\r\n\r\n    /**\r\n    * @dev get NFT's index in owner NFT's array \r\n    * @param contractAddress NFT's contract address\r\n    * @param tokenId NFT's id\r\n    * @return NFT's index\r\n    */\r\n    function getTokenIndex(\r\n        address contractAddress, \r\n        uint256 tokenId\r\n    ) \r\n    external \r\n    view\r\n    returns (uint256)\r\n    {\r\n        return TokenToIndex[contractAddress][tokenId];\r\n    }\r\n\r\n    /**\r\n    * @dev get owner address's all orders\r\n    * @param ownerAddress owner address\r\n    * @return orders array\r\n    */\r\n    function getOwnerOrders(\r\n        address ownerAddress\r\n    ) \r\n    external \r\n    view \r\n    returns (bytes32[] memory){\r\n        return OwnerToOrders[ownerAddress];\r\n    }\r\n\r\n    /**\r\n    * @dev get specfit order's owner address\r\n    * @param order order's hash\r\n    * @return order's owner address\r\n    */\r\n    function getOrderOwner(\r\n        bytes32 order\r\n    ) \r\n    external \r\n    view \r\n    returns (address)\r\n    {\r\n        return OrderToOwner[order];\r\n    }\r\n\r\n    /**\r\n    * @dev get order's index in owner orders array\r\n    * @param order order's hash\r\n    * @return order's index\r\n    */\r\n    function getOrderIndex(\r\n        bytes32 order\r\n    ) \r\n    external \r\n    view \r\n    returns (uint)\r\n    {\r\n        return OrderToIndex[order];\r\n    }\r\n\r\n    /**\r\n    * @dev get order exist or not in exchange contract\r\n    * @param order order's hash\r\n    * @return boolean to express order exist \r\n    */\r\n    function getOrderExist(\r\n        bytes32 order\r\n    )\r\n    external\r\n    view\r\n    returns (bool){\r\n        return OrderToExist[order];\r\n    }\r\n\r\n    /**\r\n    * @dev get specfit matchorder's owner address\r\n    * @param matchOrder matchorder's hash\r\n    * @return matchorder's owner address\r\n    */\r\n    function getMatchOrderOwner(\r\n        bytes32 matchOrder\r\n    ) \r\n    external \r\n    view \r\n    returns (address)\r\n    {\r\n        return MatchOrderToOwner[matchOrder];\r\n    }\r\n\r\n    /**\r\n    * @dev get matchorder's index in NFT order's matchorders array\r\n    * @param order matchorder's hash\r\n    * @return matchorder's index\r\n    */\r\n    function getOrderMatchOrderIndex(\r\n        bytes32 order,\r\n        bytes32 matchOrder\r\n    ) \r\n    external \r\n    view \r\n    returns (uint)\r\n    {\r\n        return OrderToMatchOrderIndex[order][matchOrder];\r\n    }\r\n\r\n    /**\r\n    * @dev get order's matchorder array\r\n    * @param order order's hash\r\n    * @return matchorder array\r\n    */\r\n    function getOrderMatchOrders(\r\n        bytes32 order\r\n    ) \r\n    external \r\n    view \r\n    returns (bytes32[] memory)\r\n    {\r\n        return OrderToMatchOrders[order];\r\n    }\r\n\r\n    /**\r\n    * @dev get mapping from order or matchorder's hash to OrderObj\r\n    * @param hashOrder order or matchorder's hash\r\n    * @return OrderObj\r\n    */\r\n    function getHashOrderObj(\r\n        bytes32 hashOrder\r\n    )\r\n    external\r\n    view\r\n    returns(\r\n        address, \r\n        address, \r\n        uint256\r\n    )\r\n    {\r\n        OrderObj memory orderObj = HashToOrderObj[hashOrder];\r\n        return(\r\n            orderObj.owner,\r\n            orderObj.contractAddress,\r\n            orderObj.tokenId\r\n        );\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"ownerAddress\",\"type\":\"address\"},{\"name\":\"contractAddress\",\"type\":\"address\"}],\"name\":\"getOwnerTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"order\",\"type\":\"bytes32\"}],\"name\":\"getOrderIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"contractAddress\",\"type\":\"address\"},{\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getTokenIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_operator\",\"type\":\"address\"},{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"onERC721Received\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes4\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"contractAddress\",\"type\":\"address\"},{\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getTokenOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"order\",\"type\":\"bytes32\"}],\"name\":\"getOrderOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"contractAddress\",\"type\":\"address\"},{\"name\":\"tokenId\",\"type\":\"uint256\"},{\"name\":\"orderHash\",\"type\":\"bytes32\"}],\"name\":\"createMatchOrder\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"order\",\"type\":\"bytes32\"}],\"name\":\"getOrderMatchOrders\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"order\",\"type\":\"bytes32\"}],\"name\":\"getOrderExist\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"contractAddress\",\"type\":\"address\"},{\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"createOrder\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"hashOrder\",\"type\":\"bytes32\"}],\"name\":\"getHashOrderObj\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"order\",\"type\":\"bytes32\"},{\"name\":\"matchOrder\",\"type\":\"bytes32\"}],\"name\":\"exchangeToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"orderHash\",\"type\":\"bytes32\"}],\"name\":\"deleteOrder\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"ownerAddress\",\"type\":\"address\"}],\"name\":\"getOwnerOrders\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"order\",\"type\":\"bytes32\"},{\"name\":\"matchOrder\",\"type\":\"bytes32\"}],\"name\":\"getOrderMatchOrderIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"interface_id\",\"type\":\"bytes4\"}],\"name\":\"addSupportNFTInterface\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"contractAddress\",\"type\":\"address\"},{\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"sendBackToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"contractAddress\",\"type\":\"address\"},{\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"receiveErc721Token\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"matchOrder\",\"type\":\"bytes32\"}],\"name\":\"getMatchOrderOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"onERC721Received\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes4\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"matchOrderHash\",\"type\":\"bytes32\"},{\"name\":\"orderHash\",\"type\":\"bytes32\"}],\"name\":\"deleteMatchOrder\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_contractAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"ReceiveToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_contractAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"SendBackToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_contractAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"SendToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_hash\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_contractAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"CreateOrderObj\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_orderHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"_contractAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"CreateOrder\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_orderHash\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"_matchOrderHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"_contractAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"CreateMatchOrder\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_orderHash\",\"type\":\"bytes32\"}],\"name\":\"DeleteOrder\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_orderHash\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"_matchOrderHash\",\"type\":\"bytes32\"}],\"name\":\"DeleteMatchOrder\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"Exchange","CompilerVersion":"v0.5.6+commit.b259423e","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://56c55b1cb1847a9b0a33c97a9490d26b2332edaeee7e4d8013fbcfd3b5092579"}]}