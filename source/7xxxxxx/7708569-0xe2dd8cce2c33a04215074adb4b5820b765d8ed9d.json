{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\ninterface IArbitrable {\r\n\r\n    event MetaEvidence(uint indexed _metaEvidenceID, string _evidence);\r\n\r\n    event Dispute(Arbitrator indexed _arbitrator, uint indexed _disputeID, uint _metaEvidenceID, uint _evidenceGroupID);\r\n\r\n    event Evidence(Arbitrator indexed _arbitrator, uint indexed _evidenceGroupID, address indexed _party, string _evidence);\r\n\r\n    event Ruling(Arbitrator indexed _arbitrator, uint indexed _disputeID, uint _ruling);\r\n\r\n    function rule(uint _disputeID, uint _ruling) external;\r\n}\r\n\r\ncontract Arbitrable is IArbitrable {\r\n    Arbitrator public arbitrator;\r\n    bytes public arbitratorExtraData;\r\n\r\n    modifier onlyArbitrator {require(msg.sender == address(arbitrator), \"Can only be called by the arbitrator.\"); _;}\r\n\r\n    constructor(Arbitrator _arbitrator, bytes memory _arbitratorExtraData) public {\r\n        arbitrator = _arbitrator;\r\n        arbitratorExtraData = _arbitratorExtraData;\r\n    }\r\n\r\n    function rule(uint _disputeID, uint _ruling) public onlyArbitrator {\r\n        emit Ruling(Arbitrator(msg.sender),_disputeID,_ruling);\r\n\r\n        executeRuling(_disputeID,_ruling);\r\n    }\r\n\r\n    function executeRuling(uint _disputeID, uint _ruling) internal;\r\n}\r\n\r\ncontract Arbitrator {\r\n\r\n    enum DisputeStatus {Waiting, Appealable, Solved}\r\n\r\n    modifier requireArbitrationFee(bytes memory _extraData) {\r\n        require(msg.value >= arbitrationCost(_extraData), \"Not enough ETH to cover arbitration costs.\");\r\n        _;\r\n    }\r\n    modifier requireAppealFee(uint _disputeID, bytes memory _extraData) {\r\n        require(msg.value >= appealCost(_disputeID, _extraData), \"Not enough ETH to cover appeal costs.\");\r\n        _;\r\n    }\r\n\r\n    event DisputeCreation(uint indexed _disputeID, Arbitrable indexed _arbitrable);\r\n\r\n    event AppealPossible(uint indexed _disputeID, Arbitrable indexed _arbitrable);\r\n\r\n    event AppealDecision(uint indexed _disputeID, Arbitrable indexed _arbitrable);\r\n\r\n    function createDispute(uint _choices, bytes memory _extraData) public requireArbitrationFee(_extraData) payable returns(uint disputeID) {}\r\n\r\n    function arbitrationCost(bytes memory _extraData) public view returns(uint fee);\r\n\r\n    function appeal(uint _disputeID, bytes memory _extraData) public requireAppealFee(_disputeID,_extraData) payable {\r\n        emit AppealDecision(_disputeID, Arbitrable(msg.sender));\r\n    }\r\n\r\n    function appealCost(uint _disputeID, bytes memory _extraData) public view returns(uint fee);\r\n\r\n    function appealPeriod(uint _disputeID) public view returns(uint start, uint end) {}\r\n\r\n    function disputeStatus(uint _disputeID) public view returns(DisputeStatus status);\r\n\r\n    function currentRuling(uint _disputeID) public view returns(uint ruling);\r\n}\r\n\r\n/**\r\n *  @authors: [@clesaege, @n1c01a5, @epiqueras, @ferittuncer]\r\n *  @reviewers: [@clesaege*, @unknownunknown1*]\r\n *  @auditors: []\r\n *  @bounties: []\r\n *  @deployments: []\r\n */\r\n\r\n\r\n/** @title Centralized Arbitrator\r\n *  @dev This is a centralized arbitrator deciding alone on the result of disputes. No appeals are possible.\r\n */\r\ncontract CentralizedArbitrator is Arbitrator {\r\n\r\n    address public owner = msg.sender;\r\n    uint arbitrationPrice; // Not public because arbitrationCost already acts as an accessor.\r\n    uint constant NOT_PAYABLE_VALUE = (2**256-2)/2; // High value to be sure that the appeal is too expensive.\r\n\r\n    struct DisputeStruct {\r\n        Arbitrable arbitrated;\r\n        uint choices;\r\n        uint fee;\r\n        uint ruling;\r\n        DisputeStatus status;\r\n    }\r\n\r\n    modifier onlyOwner {require(msg.sender==owner, \"Can only be called by the owner.\"); _;}\r\n\r\n    DisputeStruct[] public disputes;\r\n\r\n    /** @dev Constructor. Set the initial arbitration price.\r\n     *  @param _arbitrationPrice Amount to be paid for arbitration.\r\n     */\r\n    constructor(uint _arbitrationPrice) public {\r\n        arbitrationPrice = _arbitrationPrice;\r\n    }\r\n\r\n    /** @dev Set the arbitration price. Only callable by the owner.\r\n     *  @param _arbitrationPrice Amount to be paid for arbitration.\r\n     */\r\n    function setArbitrationPrice(uint _arbitrationPrice) public onlyOwner {\r\n        arbitrationPrice = _arbitrationPrice;\r\n    }\r\n\r\n    /** @dev Cost of arbitration. Accessor to arbitrationPrice.\r\n     *  @param _extraData Not used by this contract.\r\n     *  @return fee Amount to be paid.\r\n     */\r\n    function arbitrationCost(bytes _extraData) public view returns(uint fee) {\r\n        return arbitrationPrice;\r\n    }\r\n\r\n    /** @dev Cost of appeal. Since it is not possible, it's a high value which can never be paid.\r\n     *  @param _disputeID ID of the dispute to be appealed. Not used by this contract.\r\n     *  @param _extraData Not used by this contract.\r\n     *  @return fee Amount to be paid.\r\n     */\r\n    function appealCost(uint _disputeID, bytes _extraData) public view returns(uint fee) {\r\n        return NOT_PAYABLE_VALUE;\r\n    }\r\n\r\n    /** @dev Create a dispute. Must be called by the arbitrable contract.\r\n     *  Must be paid at least arbitrationCost().\r\n     *  @param _choices Amount of choices the arbitrator can make in this dispute. When ruling ruling<=choices.\r\n     *  @param _extraData Can be used to give additional info on the dispute to be created.\r\n     *  @return disputeID ID of the dispute created.\r\n     */\r\n    function createDispute(uint _choices, bytes _extraData) public payable returns(uint disputeID)  {\r\n        super.createDispute(_choices, _extraData);\r\n        disputeID = disputes.push(DisputeStruct({\r\n            arbitrated: Arbitrable(msg.sender),\r\n            choices: _choices,\r\n            fee: msg.value,\r\n            ruling: 0,\r\n            status: DisputeStatus.Waiting\r\n            })) - 1; // Create the dispute and return its number.\r\n        emit DisputeCreation(disputeID, Arbitrable(msg.sender));\r\n    }\r\n\r\n    /** @dev Give a ruling. UNTRUSTED.\r\n     *  @param _disputeID ID of the dispute to rule.\r\n     *  @param _ruling Ruling given by the arbitrator. Note that 0 means \"Not able/wanting to make a decision\".\r\n     */\r\n    function _giveRuling(uint _disputeID, uint _ruling) internal {\r\n        DisputeStruct storage dispute = disputes[_disputeID];\r\n        require(_ruling <= dispute.choices, \"Invalid ruling.\");\r\n        require(dispute.status != DisputeStatus.Solved, \"The dispute must not be solved already.\");\r\n\r\n        dispute.ruling = _ruling;\r\n        dispute.status = DisputeStatus.Solved;\r\n\r\n        msg.sender.send(dispute.fee); // Avoid blocking.\r\n        dispute.arbitrated.rule(_disputeID,_ruling);\r\n    }\r\n\r\n    /** @dev Give a ruling. UNTRUSTED.\r\n     *  @param _disputeID ID of the dispute to rule.\r\n     *  @param _ruling Ruling given by the arbitrator. Note that 0 means \"Not able/wanting to make a decision\".\r\n     */\r\n    function giveRuling(uint _disputeID, uint _ruling) public onlyOwner {\r\n        return _giveRuling(_disputeID, _ruling);\r\n    }\r\n\r\n    /** @dev Return the status of a dispute.\r\n     *  @param _disputeID ID of the dispute to rule.\r\n     *  @return status The status of the dispute.\r\n     */\r\n    function disputeStatus(uint _disputeID) public view returns(DisputeStatus status) {\r\n        return disputes[_disputeID].status;\r\n    }\r\n\r\n    /** @dev Return the ruling of a dispute.\r\n     *  @param _disputeID ID of the dispute to rule.\r\n     *  @return ruling The ruling which would or has been given.\r\n     */\r\n    function currentRuling(uint _disputeID) public view returns(uint ruling) {\r\n        return disputes[_disputeID].ruling;\r\n    }\r\n}\r\n\r\n\r\n/**\r\n *  @title AppealableArbitrator\r\n *  @author Enrique Piqueras - <epiquerass@gmail.com>\r\n *  @dev A centralized arbitrator that can be appealed.\r\n */\r\ncontract AppealableArbitrator is CentralizedArbitrator, Arbitrable {\r\n    /* Structs */\r\n\r\n    struct AppealDispute {\r\n        uint rulingTime;\r\n        Arbitrator arbitrator;\r\n        uint appealDisputeID;\r\n    }\r\n\r\n    /* Storage */\r\n\r\n    uint public timeOut;\r\n    mapping(uint => AppealDispute) public appealDisputes;\r\n    mapping(uint => uint) public appealDisputeIDsToDisputeIDs;\r\n\r\n    /* Constructor */\r\n\r\n    /** @dev Constructs the `AppealableArbitrator` contract.\r\n     *  @param _arbitrationPrice The amount to be paid for arbitration.\r\n     *  @param _arbitrator The back up arbitrator.\r\n     *  @param _arbitratorExtraData Not used by this contract.\r\n     *  @param _timeOut The time out for the appeal period.\r\n     */\r\n    constructor(\r\n        uint _arbitrationPrice,\r\n        Arbitrator _arbitrator,\r\n        bytes _arbitratorExtraData,\r\n        uint _timeOut\r\n    ) public CentralizedArbitrator(_arbitrationPrice) Arbitrable(_arbitrator, _arbitratorExtraData) {\r\n        timeOut = _timeOut;\r\n    }\r\n\r\n    /* External */\r\n\r\n    /** @dev Changes the back up arbitrator.\r\n     *  @param _arbitrator The new back up arbitrator.\r\n     */\r\n    function changeArbitrator(Arbitrator _arbitrator) external onlyOwner {\r\n        arbitrator = _arbitrator;\r\n    }\r\n\r\n    /** @dev Changes the time out.\r\n     *  @param _timeOut The new time out.\r\n     */\r\n    function changeTimeOut(uint _timeOut) external onlyOwner {\r\n        timeOut = _timeOut;\r\n    }\r\n\r\n    /* External Views */\r\n\r\n    /** @dev Gets the specified dispute's latest appeal ID.\r\n     *  @param _disputeID The ID of the dispute.\r\n     */\r\n    function getAppealDisputeID(uint _disputeID) external view returns(uint disputeID) {\r\n        if (appealDisputes[_disputeID].arbitrator != Arbitrator(address(0)))\r\n            disputeID = AppealableArbitrator(appealDisputes[_disputeID].arbitrator).getAppealDisputeID(appealDisputes[_disputeID].appealDisputeID);\r\n        else disputeID = _disputeID;\r\n    }\r\n\r\n    /* Public */\r\n\r\n    /** @dev Appeals a ruling.\r\n     *  @param _disputeID The ID of the dispute.\r\n     *  @param _extraData Additional info about the appeal.\r\n     */\r\n    function appeal(uint _disputeID, bytes _extraData) public payable requireAppealFee(_disputeID, _extraData) {\r\n        super.appeal(_disputeID, _extraData);\r\n        if (appealDisputes[_disputeID].arbitrator != Arbitrator(address(0)))\r\n            appealDisputes[_disputeID].arbitrator.appeal.value(msg.value)(appealDisputes[_disputeID].appealDisputeID, _extraData);\r\n        else {\r\n            appealDisputes[_disputeID].arbitrator = arbitrator;\r\n            appealDisputes[_disputeID].appealDisputeID = arbitrator.createDispute.value(msg.value)(disputes[_disputeID].choices, _extraData);\r\n            appealDisputeIDsToDisputeIDs[appealDisputes[_disputeID].appealDisputeID] = _disputeID;\r\n        }\r\n    }\r\n\r\n    /** @dev Gives a ruling.\r\n     *  @param _disputeID The ID of the dispute.\r\n     *  @param _ruling The ruling.\r\n     */\r\n    function giveRuling(uint _disputeID, uint _ruling) public {\r\n        require(disputes[_disputeID].status != DisputeStatus.Solved, \"The specified dispute is already resolved.\");\r\n        if (appealDisputes[_disputeID].arbitrator != Arbitrator(address(0))) {\r\n            require(Arbitrator(msg.sender) == appealDisputes[_disputeID].arbitrator, \"Appealed disputes must be ruled by their back up arbitrator.\");\r\n            super._giveRuling(_disputeID, _ruling);\r\n        } else {\r\n            require(msg.sender == owner, \"Not appealed disputes must be ruled by the owner.\");\r\n            if (disputes[_disputeID].status == DisputeStatus.Appealable) {\r\n                if (now - appealDisputes[_disputeID].rulingTime > timeOut)\r\n                    super._giveRuling(_disputeID, disputes[_disputeID].ruling);\r\n                else revert(\"Time out time has not passed yet.\");\r\n            } else {\r\n                disputes[_disputeID].ruling = _ruling;\r\n                disputes[_disputeID].status = DisputeStatus.Appealable;\r\n                appealDisputes[_disputeID].rulingTime = now;\r\n                emit AppealPossible(_disputeID, disputes[_disputeID].arbitrated);\r\n            }\r\n        }\r\n    }\r\n\r\n    /* Public Views */\r\n\r\n    /** @dev Gets the cost of appeal for the specified dispute.\r\n     *  @param _disputeID The ID of the dispute.\r\n     *  @param _extraData Additional info about the appeal.\r\n     *  @return The cost of the appeal.\r\n     */\r\n    function appealCost(uint _disputeID, bytes _extraData) public view returns(uint cost) {\r\n        if (appealDisputes[_disputeID].arbitrator != Arbitrator(address(0)))\r\n            cost = appealDisputes[_disputeID].arbitrator.appealCost(appealDisputes[_disputeID].appealDisputeID, _extraData);\r\n        else if (disputes[_disputeID].status == DisputeStatus.Appealable) cost = arbitrator.arbitrationCost(_extraData);\r\n        else cost = NOT_PAYABLE_VALUE;\r\n    }\r\n\r\n    /** @dev Gets the status of the specified dispute.\r\n     *  @param _disputeID The ID of the dispute.\r\n     *  @return The status.\r\n     */\r\n    function disputeStatus(uint _disputeID) public view returns(DisputeStatus status) {\r\n        if (appealDisputes[_disputeID].arbitrator != Arbitrator(address(0)))\r\n            status = appealDisputes[_disputeID].arbitrator.disputeStatus(appealDisputes[_disputeID].appealDisputeID);\r\n        else status = disputes[_disputeID].status;\r\n    }\r\n\r\n    /* Internal */\r\n\r\n    /** @dev Executes the ruling of the specified dispute.\r\n     *  @param _disputeID The ID of the dispute.\r\n     *  @param _ruling The ruling.\r\n     */\r\n    function executeRuling(uint _disputeID, uint _ruling) internal {\r\n        require(\r\n            appealDisputes[appealDisputeIDsToDisputeIDs[_disputeID]].arbitrator != Arbitrator(address(0)),\r\n            \"The dispute must have been appealed.\"\r\n        );\r\n        giveRuling(appealDisputeIDsToDisputeIDs[_disputeID], _ruling);\r\n    }\r\n}\r\n\r\n\r\ncontract MultipleArbitrableTransaction is IArbitrable {\r\n\r\n    // **************************** //\r\n    // *    Contract variables    * //\r\n    // **************************** //\r\n\r\n    uint8 constant AMOUNT_OF_CHOICES = 2;\r\n    uint8 constant SENDER_WINS = 1;\r\n    uint8 constant RECEIVER_WINS = 2;\r\n\r\n    enum Party {Sender, Receiver}\r\n    enum Status {NoDispute, WaitingSender, WaitingReceiver, DisputeCreated, Resolved}\r\n\r\n    struct Transaction {\r\n        address sender;\r\n        address receiver;\r\n        uint amount;\r\n        uint timeoutPayment; // Time in seconds after which the transaction can be automatically executed if not disputed.\r\n        uint disputeId; // If dispute exists, the ID of the dispute.\r\n        uint senderFee; // Total fees paid by the sender.\r\n        uint receiverFee; // Total fees paid by the receiver.\r\n        uint lastInteraction; // Last interaction for the dispute procedure.\r\n        Status status;\r\n    }\r\n\r\n    Transaction[] public transactions;\r\n    bytes public arbitratorExtraData; // Extra data to set up the arbitration.\r\n    Arbitrator public arbitrator; // Address of the arbitrator contract.\r\n    uint public feeTimeout; // Time in seconds a party can take to pay arbitration fees before being considered unresponding and lose the dispute.\r\n\r\n\r\n    mapping (uint => uint) public disputeIDtoTransactionID; // One-to-one relationship between the dispute and the transaction.\r\n\r\n    // **************************** //\r\n    // *          Events          * //\r\n    // **************************** //\r\n\r\n    /** @dev To be emitted when meta-evidence is submitted.\r\n     *  @param _metaEvidenceID Unique identifier of meta-evidence. Should be the `transactionID`.\r\n     *  @param _evidence A link to the meta-evidence JSON that follows the ERC 1497 Evidence standard (https://github.com/ethereum/EIPs/issues/1497).\r\n     */\r\n    event MetaEvidence(uint indexed _metaEvidenceID, string _evidence);\r\n\r\n    /** @dev To be emitted when a party pays or reimburses the other.\r\n     *  @param _transactionID The index of the transaction.\r\n     *  @param _amount The amount paid.\r\n     *  @param _party The party that paid.\r\n     */\r\n    event Payment(uint indexed _transactionID, uint _amount, address _party);\r\n\r\n    /** @dev Indicate that a party has to pay a fee or would otherwise be considered as losing.\r\n     *  @param _transactionID The index of the transaction.\r\n     *  @param _party The party who has to pay.\r\n     */\r\n    event HasToPayFee(uint indexed _transactionID, Party _party);\r\n\r\n    /** @dev To be raised when evidence is submitted. Should point to the resource (evidences are not to be stored on chain due to gas considerations).\r\n     *  @param _arbitrator The arbitrator of the contract.\r\n     *  @param _evidenceGroupID Unique identifier of the evidence group the evidence belongs to.\r\n     *  @param _party The address of the party submitting the evidence. Note that 0 is kept for evidences not submitted by any party.\r\n     *  @param _evidence A link to an evidence JSON that follows the ERC 1497 Evidence standard (https://github.com/ethereum/EIPs/issues/1497).\r\n     */\r\n    event Evidence(Arbitrator indexed _arbitrator, uint indexed _evidenceGroupID, address indexed _party, string _evidence);\r\n\r\n    /** @dev To be emitted when a dispute is created to link the correct meta-evidence to the disputeID.\r\n     *  @param _arbitrator The arbitrator of the contract.\r\n     *  @param _disputeID ID of the dispute in the Arbitrator contract.\r\n     *  @param _metaEvidenceID Unique identifier of meta-evidence. Should be the transactionID.\r\n     *  @param _evidenceGroupID Unique identifier of the evidence group that is linked to this dispute.\r\n     */\r\n    event Dispute(Arbitrator indexed _arbitrator, uint indexed _disputeID, uint _metaEvidenceID, uint _evidenceGroupID);\r\n\r\n    /** @dev To be raised when a ruling is given.\r\n     *  @param _arbitrator The arbitrator giving the ruling.\r\n     *  @param _disputeID ID of the dispute in the Arbitrator contract.\r\n     *  @param _ruling The ruling which was given.\r\n     */\r\n    event Ruling(Arbitrator indexed _arbitrator, uint indexed _disputeID, uint _ruling);\r\n\r\n    // **************************** //\r\n    // *    Arbitrable functions  * //\r\n    // *    Modifying the state   * //\r\n    // **************************** //\r\n\r\n    /** @dev Constructor.\r\n     *  @param _arbitrator The arbitrator of the contract.\r\n     *  @param _arbitratorExtraData Extra data for the arbitrator.\r\n     *  @param _feeTimeout Arbitration fee timeout for the parties.\r\n     */\r\n    constructor (\r\n        Arbitrator _arbitrator,\r\n        bytes _arbitratorExtraData,\r\n        uint _feeTimeout\r\n    ) public {\r\n        arbitrator = _arbitrator;\r\n        arbitratorExtraData = _arbitratorExtraData;\r\n        feeTimeout = _feeTimeout;\r\n    }\r\n\r\n    /** @dev Create a transaction.\r\n     *  @param _timeoutPayment Time after which a party can automatically execute the arbitrable transaction.\r\n     *  @param _receiver The recipient of the transaction.\r\n     *  @param _metaEvidence Link to the meta-evidence.\r\n     *  @return transactionID The index of the transaction.\r\n     */\r\n    function createTransaction(\r\n        uint _timeoutPayment,\r\n        address _receiver,\r\n        string _metaEvidence\r\n    ) public payable returns (uint transactionID) {\r\n        transactions.push(Transaction({\r\n            sender: msg.sender,\r\n            receiver: _receiver,\r\n            amount: msg.value,\r\n            timeoutPayment: _timeoutPayment,\r\n            disputeId: 0,\r\n            senderFee: 0,\r\n            receiverFee: 0,\r\n            lastInteraction: now,\r\n            status: Status.NoDispute\r\n        }));\r\n        emit MetaEvidence(transactions.length - 1, _metaEvidence);\r\n\r\n        return transactions.length - 1;\r\n    }\r\n\r\n    /** @dev Pay receiver. To be called if the good or service is provided.\r\n     *  @param _transactionID The index of the transaction.\r\n     *  @param _amount Amount to pay in wei.\r\n     */\r\n    function pay(uint _transactionID, uint _amount) public {\r\n        Transaction storage transaction = transactions[_transactionID];\r\n        require(transaction.sender == msg.sender, \"The caller must be the sender.\");\r\n        require(transaction.status == Status.NoDispute, \"The transaction shouldn't be disputed.\");\r\n        require(_amount <= transaction.amount, \"The amount paid has to be less than or equal to the transaction.\");\r\n\r\n        transaction.receiver.transfer(_amount);\r\n        transaction.amount -= _amount;\r\n        emit Payment(_transactionID, _amount, msg.sender);\r\n    }\r\n\r\n    /** @dev Reimburse sender. To be called if the good or service can't be fully provided.\r\n     *  @param _transactionID The index of the transaction.\r\n     *  @param _amountReimbursed Amount to reimburse in wei.\r\n     */\r\n    function reimburse(uint _transactionID, uint _amountReimbursed) public {\r\n        Transaction storage transaction = transactions[_transactionID];\r\n        require(transaction.receiver == msg.sender, \"The caller must be the receiver.\");\r\n        require(transaction.status == Status.NoDispute, \"The transaction shouldn't be disputed.\");\r\n        require(_amountReimbursed <= transaction.amount, \"The amount reimbursed has to be less or equal than the transaction.\");\r\n\r\n        transaction.sender.transfer(_amountReimbursed);\r\n        transaction.amount -= _amountReimbursed;\r\n        emit Payment(_transactionID, _amountReimbursed, msg.sender);\r\n    }\r\n\r\n    /** @dev Transfer the transaction's amount to the receiver if the timeout has passed.\r\n     *  @param _transactionID The index of the transaction.\r\n     */\r\n    function executeTransaction(uint _transactionID) public {\r\n        Transaction storage transaction = transactions[_transactionID];\r\n        require(now - transaction.lastInteraction >= transaction.timeoutPayment, \"The timeout has not passed yet.\");\r\n        require(transaction.status == Status.NoDispute, \"The transaction shouldn't be disputed.\");\r\n\r\n        transaction.receiver.transfer(transaction.amount);\r\n        transaction.amount = 0;\r\n\r\n        transaction.status = Status.Resolved;\r\n    }\r\n\r\n    /** @dev Reimburse sender if receiver fails to pay the fee.\r\n     *  @param _transactionID The index of the transaction.\r\n     */\r\n    function timeOutBySender(uint _transactionID) public {\r\n        Transaction storage transaction = transactions[_transactionID];\r\n\r\n        require(transaction.status == Status.WaitingReceiver, \"The transaction is not waiting on the receiver.\");\r\n        require(now - transaction.lastInteraction >= feeTimeout, \"Timeout time has not passed yet.\");\r\n\r\n        executeRuling(_transactionID, SENDER_WINS);\r\n    }\r\n\r\n    /** @dev Pay receiver if sender fails to pay the fee.\r\n     *  @param _transactionID The index of the transaction.\r\n     */\r\n    function timeOutByReceiver(uint _transactionID) public {\r\n        Transaction storage transaction = transactions[_transactionID];\r\n\r\n        require(transaction.status == Status.WaitingSender, \"The transaction is not waiting on the sender.\");\r\n        require(now - transaction.lastInteraction >= feeTimeout, \"Timeout time has not passed yet.\");\r\n\r\n        executeRuling(_transactionID, RECEIVER_WINS);\r\n    }\r\n\r\n    /** @dev Pay the arbitration fee to raise a dispute. To be called by the sender. UNTRUSTED.\r\n     *  Note that the arbitrator can have createDispute throw, which will make this function throw and therefore lead to a party being timed-out.\r\n     *  This is not a vulnerability as the arbitrator can rule in favor of one party anyway.\r\n     *  @param _transactionID The index of the transaction.\r\n     */\r\n    function payArbitrationFeeBySender(uint _transactionID) public payable {\r\n        Transaction storage transaction = transactions[_transactionID];\r\n        uint arbitrationCost = arbitrator.arbitrationCost(arbitratorExtraData);\r\n\r\n        require(transaction.status < Status.DisputeCreated, \"Dispute has already been created or because the transaction has been executed.\");\r\n        require(msg.sender == transaction.sender, \"The caller must be the sender.\");\r\n\r\n        transaction.senderFee += msg.value;\r\n        // Require that the total pay at least the arbitration cost.\r\n        require(transaction.senderFee >= arbitrationCost, \"The sender fee must cover arbitration costs.\");\r\n\r\n        transaction.lastInteraction = now;\r\n\r\n        // The receiver still has to pay. This can also happen if he has paid, but arbitrationCost has increased.\r\n        if (transaction.receiverFee < arbitrationCost) {\r\n            transaction.status = Status.WaitingReceiver;\r\n            emit HasToPayFee(_transactionID, Party.Receiver);\r\n        } else { // The receiver has also paid the fee. We create the dispute.\r\n            raiseDispute(_transactionID, arbitrationCost);\r\n        }\r\n    }\r\n\r\n    /** @dev Pay the arbitration fee to raise a dispute. To be called by the receiver. UNTRUSTED.\r\n     *  Note that this function mirrors payArbitrationFeeBySender.\r\n     *  @param _transactionID The index of the transaction.\r\n     */\r\n    function payArbitrationFeeByReceiver(uint _transactionID) public payable {\r\n        Transaction storage transaction = transactions[_transactionID];\r\n        uint arbitrationCost = arbitrator.arbitrationCost(arbitratorExtraData);\r\n\r\n        require(transaction.status < Status.DisputeCreated, \"Dispute has already been created or because the transaction has been executed.\");\r\n        require(msg.sender == transaction.receiver, \"The caller must be the receiver.\");\r\n\r\n        transaction.receiverFee += msg.value;\r\n        // Require that the total paid to be at least the arbitration cost.\r\n        require(transaction.receiverFee >= arbitrationCost, \"The receiver fee must cover arbitration costs.\");\r\n\r\n        transaction.lastInteraction = now;\r\n        // The sender still has to pay. This can also happen if he has paid, but arbitrationCost has increased.\r\n        if (transaction.senderFee < arbitrationCost) {\r\n            transaction.status = Status.WaitingSender;\r\n            emit HasToPayFee(_transactionID, Party.Sender);\r\n        } else { // The sender has also paid the fee. We create the dispute.\r\n            raiseDispute(_transactionID, arbitrationCost);\r\n        }\r\n    }\r\n\r\n    /** @dev Create a dispute. UNTRUSTED.\r\n     *  @param _transactionID The index of the transaction.\r\n     *  @param _arbitrationCost Amount to pay the arbitrator.\r\n     */\r\n    function raiseDispute(uint _transactionID, uint _arbitrationCost) internal {\r\n        Transaction storage transaction = transactions[_transactionID];\r\n        transaction.status = Status.DisputeCreated;\r\n        transaction.disputeId = arbitrator.createDispute.value(_arbitrationCost)(AMOUNT_OF_CHOICES, arbitratorExtraData);\r\n        disputeIDtoTransactionID[transaction.disputeId] = _transactionID;\r\n        emit Dispute(arbitrator, transaction.disputeId, _transactionID, _transactionID);\r\n\r\n        // Refund sender if it overpaid.\r\n        if (transaction.senderFee > _arbitrationCost) {\r\n            uint extraFeeSender = transaction.senderFee - _arbitrationCost;\r\n            transaction.senderFee = _arbitrationCost;\r\n            transaction.sender.send(extraFeeSender);\r\n        }\r\n\r\n        // Refund receiver if it overpaid.\r\n        if (transaction.receiverFee > _arbitrationCost) {\r\n            uint extraFeeReceiver = transaction.receiverFee - _arbitrationCost;\r\n            transaction.receiverFee = _arbitrationCost;\r\n            transaction.receiver.send(extraFeeReceiver);\r\n        }\r\n    }\r\n\r\n    /** @dev Submit a reference to evidence. EVENT.\r\n     *  @param _transactionID The index of the transaction.\r\n     *  @param _evidence A link to an evidence using its URI.\r\n     */\r\n    function submitEvidence(uint _transactionID, string _evidence) public {\r\n        Transaction storage transaction = transactions[_transactionID];\r\n        require(\r\n            msg.sender == transaction.sender || msg.sender == transaction.receiver,\r\n            \"The caller must be the sender or the receiver.\"\r\n        );\r\n        require(\r\n            transaction.status < Status.Resolved,\r\n            \"Must not send evidence if the dispute is resolved.\"\r\n        );\r\n\r\n        emit Evidence(arbitrator, _transactionID, msg.sender, _evidence);\r\n    }\r\n\r\n    /** @dev Appeal an appealable ruling.\r\n     *  Transfer the funds to the arbitrator.\r\n     *  Note that no checks are required as the checks are done by the arbitrator.\r\n     *  @param _transactionID The index of the transaction.\r\n     */\r\n    function appeal(uint _transactionID) public payable {\r\n        Transaction storage transaction = transactions[_transactionID];\r\n\r\n        arbitrator.appeal.value(msg.value)(transaction.disputeId, arbitratorExtraData);\r\n    }\r\n\r\n    /** @dev Give a ruling for a dispute. Must be called by the arbitrator.\r\n     *  The purpose of this function is to ensure that the address calling it has the right to rule on the contract.\r\n     *  @param _disputeID ID of the dispute in the Arbitrator contract.\r\n     *  @param _ruling Ruling given by the arbitrator. Note that 0 is reserved for \"Not able/wanting to make a decision\".\r\n     */\r\n    function rule(uint _disputeID, uint _ruling) public {\r\n        uint transactionID = disputeIDtoTransactionID[_disputeID];\r\n        Transaction storage transaction = transactions[transactionID];\r\n        require(msg.sender == address(arbitrator), \"The caller must be the arbitrator.\");\r\n        require(transaction.status == Status.DisputeCreated, \"The dispute has already been resolved.\");\r\n\r\n        emit Ruling(Arbitrator(msg.sender), _disputeID, _ruling);\r\n\r\n        executeRuling(transactionID, _ruling);\r\n    }\r\n\r\n    /** @dev Execute a ruling of a dispute. It reimburses the fee to the winning party.\r\n     *  @param _transactionID The index of the transaction.\r\n     *  @param _ruling Ruling given by the arbitrator. 1 : Reimburse the receiver. 2 : Pay the sender.\r\n     */\r\n    function executeRuling(uint _transactionID, uint _ruling) internal {\r\n        Transaction storage transaction = transactions[_transactionID];\r\n        require(_ruling <= AMOUNT_OF_CHOICES, \"Invalid ruling.\");\r\n\r\n        // Give the arbitration fee back.\r\n        // Note that we use send to prevent a party from blocking the execution.\r\n        if (_ruling == SENDER_WINS) {\r\n            transaction.sender.send(transaction.senderFee + transaction.amount);\r\n        } else if (_ruling == RECEIVER_WINS) {\r\n            transaction.receiver.send(transaction.receiverFee + transaction.amount);\r\n        } else {\r\n            uint split_amount = (transaction.senderFee + transaction.amount) / 2;\r\n            transaction.sender.send(split_amount);\r\n            transaction.receiver.send(split_amount);\r\n        }\r\n\r\n        transaction.amount = 0;\r\n        transaction.senderFee = 0;\r\n        transaction.receiverFee = 0;\r\n        transaction.status = Status.Resolved;\r\n    }\r\n\r\n    // **************************** //\r\n    // *     Constant getters     * //\r\n    // **************************** //\r\n\r\n    /** @dev Getter to know the count of transactions.\r\n     *  @return countTransactions The count of transactions.\r\n     */\r\n    function getCountTransactions() public view returns (uint countTransactions) {\r\n        return transactions.length;\r\n    }\r\n\r\n    /** @dev Get IDs for transactions where the specified address is the receiver and/or the sender.\r\n     *  This function must be used by the UI and not by other smart contracts.\r\n     *  Note that the complexity is O(t), where t is amount of arbitrable transactions.\r\n     *  @param _address The specified address.\r\n     *  @return transactionIDs The transaction IDs.\r\n     */\r\n    function getTransactionIDsByAddress(address _address) public view returns (uint[] transactionIDs) {\r\n        uint count = 0;\r\n        for (uint i = 0; i < transactions.length; i++) {\r\n            if (transactions[i].sender == _address || transactions[i].receiver == _address)\r\n                count++;\r\n        }\r\n\r\n        transactionIDs = new uint[](count);\r\n\r\n        count = 0;\r\n\r\n        for (uint j = 0; j < transactions.length; j++) {\r\n            if (transactions[j].sender == _address || transactions[j].receiver == _address)\r\n                transactionIDs[count++] = j;\r\n        }\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"arbitratorExtraData\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"disputeIDtoTransactionID\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_disputeID\",\"type\":\"uint256\"},{\"name\":\"_ruling\",\"type\":\"uint256\"}],\"name\":\"rule\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_transactionID\",\"type\":\"uint256\"}],\"name\":\"timeOutByReceiver\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"arbitrator\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_transactionID\",\"type\":\"uint256\"}],\"name\":\"payArbitrationFeeByReceiver\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_transactionID\",\"type\":\"uint256\"}],\"name\":\"payArbitrationFeeBySender\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_transactionID\",\"type\":\"uint256\"}],\"name\":\"appeal\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"transactions\",\"outputs\":[{\"name\":\"sender\",\"type\":\"address\"},{\"name\":\"receiver\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"timeoutPayment\",\"type\":\"uint256\"},{\"name\":\"disputeId\",\"type\":\"uint256\"},{\"name\":\"senderFee\",\"type\":\"uint256\"},{\"name\":\"receiverFee\",\"type\":\"uint256\"},{\"name\":\"lastInteraction\",\"type\":\"uint256\"},{\"name\":\"status\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCountTransactions\",\"outputs\":[{\"name\":\"countTransactions\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_transactionID\",\"type\":\"uint256\"},{\"name\":\"_evidence\",\"type\":\"string\"}],\"name\":\"submitEvidence\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"feeTimeout\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_timeoutPayment\",\"type\":\"uint256\"},{\"name\":\"_receiver\",\"type\":\"address\"},{\"name\":\"_metaEvidence\",\"type\":\"string\"}],\"name\":\"createTransaction\",\"outputs\":[{\"name\":\"transactionID\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_transactionID\",\"type\":\"uint256\"}],\"name\":\"executeTransaction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_transactionID\",\"type\":\"uint256\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"pay\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_transactionID\",\"type\":\"uint256\"}],\"name\":\"timeOutBySender\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getTransactionIDsByAddress\",\"outputs\":[{\"name\":\"transactionIDs\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_transactionID\",\"type\":\"uint256\"},{\"name\":\"_amountReimbursed\",\"type\":\"uint256\"}],\"name\":\"reimburse\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_arbitrator\",\"type\":\"address\"},{\"name\":\"_arbitratorExtraData\",\"type\":\"bytes\"},{\"name\":\"_feeTimeout\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_metaEvidenceID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_evidence\",\"type\":\"string\"}],\"name\":\"MetaEvidence\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_transactionID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_party\",\"type\":\"address\"}],\"name\":\"Payment\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_transactionID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_party\",\"type\":\"uint8\"}],\"name\":\"HasToPayFee\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_arbitrator\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_evidenceGroupID\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"_party\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_evidence\",\"type\":\"string\"}],\"name\":\"Evidence\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_arbitrator\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_disputeID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_metaEvidenceID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_evidenceGroupID\",\"type\":\"uint256\"}],\"name\":\"Dispute\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_arbitrator\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_disputeID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_ruling\",\"type\":\"uint256\"}],\"name\":\"Ruling\",\"type\":\"event\"}]","ContractName":"MultipleArbitrableTransaction","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000988b3a538b618c7a603e1c11ab82cd16dbe2806900000000000000000000000000000000000000000000000000000000000000600000000000000000000000000000000000000000000000000000000000049d40000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000","Library":"","SwarmSource":"bzzr://ca37fdd5fb21d4c20ca48a483e19d2b34ed077560ff160aa03b5cbf41bb9a170"}]}