{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.25;\r\n\r\n// File: contracts/LinkedListLib.sol\r\n\r\n/**\r\n * @title LinkedListLib\r\n * @author Darryl Morris (o0ragman0o) and Modular.network\r\n *\r\n * This utility library was forked from https://github.com/o0ragman0o/LibCLL\r\n * into the Modular-Network ethereum-libraries repo at https://github.com/Modular-Network/ethereum-libraries\r\n * It has been updated to add additional functionality and be more compatible with solidity 0.4.18\r\n * coding patterns.\r\n *\r\n * version 1.1.1\r\n * Copyright (c) 2017 Modular Inc.\r\n * The MIT License (MIT)\r\n * https://github.com/Modular-network/ethereum-libraries/blob/master/LICENSE\r\n *\r\n * The LinkedListLib provides functionality for implementing data indexing using\r\n * a circlular linked list\r\n *\r\n * Modular provides smart contract services and security reviews for contract\r\n * deployments in addition to working on open source projects in the Ethereum\r\n * community. Our purpose is to test, document, and deploy reusable code onto the\r\n * blockchain and improve both security and usability. We also educate non-profits,\r\n * schools, and other community members about the application of blockchain\r\n * technology. For further information: modular.network\r\n *\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\r\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\r\n * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\r\n * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\r\n * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\r\n * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n*/\r\n\r\n\r\nlibrary LinkedListLib {\r\n\r\n    uint256 constant NULL = 0;\r\n    uint256 constant HEAD = 0;\r\n    bool constant PREV = false;\r\n    bool constant NEXT = true;\r\n\r\n    struct LinkedList{\r\n        mapping (uint256 => mapping (bool => uint256)) list;\r\n    }\r\n\r\n    /// @dev returns true if the list exists\r\n    /// @param self stored linked list from contract\r\n    function listExists(LinkedList storage self)\r\n        public\r\n        view returns (bool)\r\n    {\r\n        // if the head nodes previous or next pointers both point to itself, then there are no items in the list\r\n        if (self.list[HEAD][PREV] != HEAD || self.list[HEAD][NEXT] != HEAD) {\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /// @dev returns true if the node exists\r\n    /// @param self stored linked list from contract\r\n    /// @param _node a node to search for\r\n    function nodeExists(LinkedList storage self, uint256 _node)\r\n        public\r\n        view returns (bool)\r\n    {\r\n        if (self.list[_node][PREV] == HEAD && self.list[_node][NEXT] == HEAD) {\r\n            if (self.list[HEAD][NEXT] == _node) {\r\n                return true;\r\n            } else {\r\n                return false;\r\n            }\r\n        } else {\r\n            return true;\r\n        }\r\n    }\r\n\r\n    /// @dev Returns the number of elements in the list\r\n    /// @param self stored linked list from contract\r\n    function sizeOf(LinkedList storage self) public view returns (uint256 numElements) {\r\n        bool exists;\r\n        uint256 i;\r\n        (exists,i) = getAdjacent(self, HEAD, NEXT);\r\n        while (i != HEAD) {\r\n            (exists,i) = getAdjacent(self, i, NEXT);\r\n            numElements++;\r\n        }\r\n        return;\r\n    }\r\n\r\n    /// @dev Returns the links of a node as a tuple\r\n    /// @param self stored linked list from contract\r\n    /// @param _node id of the node to get\r\n    function getNode(LinkedList storage self, uint256 _node)\r\n        public view returns (bool,uint256,uint256)\r\n    {\r\n        if (!nodeExists(self,_node)) {\r\n            return (false,0,0);\r\n        } else {\r\n            return (true,self.list[_node][PREV], self.list[_node][NEXT]);\r\n        }\r\n    }\r\n\r\n    /// @dev Returns the link of a node `_node` in direction `_direction`.\r\n    /// @param self stored linked list from contract\r\n    /// @param _node id of the node to step from\r\n    /// @param _direction direction to step in\r\n    function getAdjacent(LinkedList storage self, uint256 _node, bool _direction)\r\n        public view returns (bool,uint256)\r\n    {\r\n        if (!nodeExists(self,_node)) {\r\n            return (false,0);\r\n        } else {\r\n            return (true,self.list[_node][_direction]);\r\n        }\r\n    }\r\n\r\n    /// @dev Can be used before `insert` to build an ordered list\r\n    /// @param self stored linked list from contract\r\n    /// @param _node an existing node to search from, e.g. HEAD.\r\n    /// @param _value value to seek\r\n    /// @param _direction direction to seek in\r\n    //  @return next first node beyond '_node' in direction `_direction`\r\n    function getSortedSpot(LinkedList storage self, uint256 _node, uint256 _value, bool _direction)\r\n        public view returns (uint256)\r\n    {\r\n        if (sizeOf(self) == 0) { return 0; }\r\n        require((_node == 0) || nodeExists(self,_node));\r\n        bool exists;\r\n        uint256 next;\r\n        (exists,next) = getAdjacent(self, _node, _direction);\r\n        while  ((next != 0) && (_value != next) && ((_value < next) != _direction)) next = self.list[next][_direction];\r\n        return next;\r\n    }\r\n\r\n    /// @dev Creates a bidirectional link between two nodes on direction `_direction`\r\n    /// @param self stored linked list from contract\r\n    /// @param _node first node for linking\r\n    /// @param _link  node to link to in the _direction\r\n    function createLink(LinkedList storage self, uint256 _node, uint256 _link, bool _direction) private  {\r\n        self.list[_link][!_direction] = _node;\r\n        self.list[_node][_direction] = _link;\r\n    }\r\n\r\n    /// @dev Insert node `_new` beside existing node `_node` in direction `_direction`.\r\n    /// @param self stored linked list from contract\r\n    /// @param _node existing node\r\n    /// @param _new  new node to insert\r\n    /// @param _direction direction to insert node in\r\n    function insert(LinkedList storage self, uint256 _node, uint256 _new, bool _direction) internal returns (bool) {\r\n        if(!nodeExists(self,_new) && nodeExists(self,_node)) {\r\n            uint256 c = self.list[_node][_direction];\r\n            createLink(self, _node, _new, _direction);\r\n            createLink(self, _new, c, _direction);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /// @dev removes an entry from the linked list\r\n    /// @param self stored linked list from contract\r\n    /// @param _node node to remove from the list\r\n    function remove(LinkedList storage self, uint256 _node) internal returns (uint256) {\r\n        if ((_node == NULL) || (!nodeExists(self,_node))) { return 0; }\r\n        createLink(self, self.list[_node][PREV], self.list[_node][NEXT], NEXT);\r\n        delete self.list[_node][PREV];\r\n        delete self.list[_node][NEXT];\r\n        return _node;\r\n    }\r\n\r\n    /// @dev pushes an enrty to the head of the linked list\r\n    /// @param self stored linked list from contract\r\n    /// @param _node new entry to push to the head\r\n    /// @param _direction push to the head (NEXT) or tail (PREV)\r\n    function push(LinkedList storage self, uint256 _node, bool _direction) internal  {\r\n        insert(self, HEAD, _node, _direction);\r\n    }\r\n\r\n    /// @dev pops the first entry from the linked list\r\n    /// @param self stored linked list from contract\r\n    /// @param _direction pop from the head (NEXT) or the tail (PREV)\r\n    function pop(LinkedList storage self, bool _direction) internal returns (uint256) {\r\n        bool exists;\r\n        uint256 adj;\r\n\r\n        (exists,adj) = getAdjacent(self, HEAD, _direction);\r\n\r\n        return remove(self, adj);\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipRenounced(address indexed previousOwner);\r\n  event OwnershipTransferred(\r\n    address indexed previousOwner,\r\n    address indexed newOwner\r\n  );\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  constructor() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to relinquish control of the contract.\r\n   */\r\n  function renounceOwnership() public onlyOwner {\r\n    emit OwnershipRenounced(owner);\r\n    owner = address(0);\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address _newOwner) public onlyOwner {\r\n    _transferOwnership(_newOwner);\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function _transferOwnership(address _newOwner) internal {\r\n    require(_newOwner != address(0));\r\n    emit OwnershipTransferred(owner, _newOwner);\r\n    owner = _newOwner;\r\n  }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/ownership/rbac/Roles.sol\r\n\r\n/**\r\n * @title Roles\r\n * @author Francisco Giordano (@frangio)\r\n * @dev Library for managing addresses assigned to a Role.\r\n *      See RBAC.sol for example usage.\r\n */\r\nlibrary Roles {\r\n  struct Role {\r\n    mapping (address => bool) bearer;\r\n  }\r\n\r\n  /**\r\n   * @dev give an address access to this role\r\n   */\r\n  function add(Role storage role, address addr)\r\n    internal\r\n  {\r\n    role.bearer[addr] = true;\r\n  }\r\n\r\n  /**\r\n   * @dev remove an address' access to this role\r\n   */\r\n  function remove(Role storage role, address addr)\r\n    internal\r\n  {\r\n    role.bearer[addr] = false;\r\n  }\r\n\r\n  /**\r\n   * @dev check if an address has this role\r\n   * // reverts\r\n   */\r\n  function check(Role storage role, address addr)\r\n    view\r\n    internal\r\n  {\r\n    require(has(role, addr));\r\n  }\r\n\r\n  /**\r\n   * @dev check if an address has this role\r\n   * @return bool\r\n   */\r\n  function has(Role storage role, address addr)\r\n    view\r\n    internal\r\n    returns (bool)\r\n  {\r\n    return role.bearer[addr];\r\n  }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/ownership/rbac/RBAC.sol\r\n\r\n/**\r\n * @title RBAC (Role-Based Access Control)\r\n * @author Matt Condon (@Shrugs)\r\n * @dev Stores and provides setters and getters for roles and addresses.\r\n * @dev Supports unlimited numbers of roles and addresses.\r\n * @dev See //contracts/mocks/RBACMock.sol for an example of usage.\r\n * This RBAC method uses strings to key roles. It may be beneficial\r\n *  for you to write your own implementation of this interface using Enums or similar.\r\n * It's also recommended that you define constants in the contract, like ROLE_ADMIN below,\r\n *  to avoid typos.\r\n */\r\ncontract RBAC {\r\n  using Roles for Roles.Role;\r\n\r\n  mapping (string => Roles.Role) private roles;\r\n\r\n  event RoleAdded(address addr, string roleName);\r\n  event RoleRemoved(address addr, string roleName);\r\n\r\n  /**\r\n   * @dev reverts if addr does not have role\r\n   * @param addr address\r\n   * @param roleName the name of the role\r\n   * // reverts\r\n   */\r\n  function checkRole(address addr, string roleName)\r\n    view\r\n    public\r\n  {\r\n    roles[roleName].check(addr);\r\n  }\r\n\r\n  /**\r\n   * @dev determine if addr has role\r\n   * @param addr address\r\n   * @param roleName the name of the role\r\n   * @return bool\r\n   */\r\n  function hasRole(address addr, string roleName)\r\n    view\r\n    public\r\n    returns (bool)\r\n  {\r\n    return roles[roleName].has(addr);\r\n  }\r\n\r\n  /**\r\n   * @dev add a role to an address\r\n   * @param addr address\r\n   * @param roleName the name of the role\r\n   */\r\n  function addRole(address addr, string roleName)\r\n    internal\r\n  {\r\n    roles[roleName].add(addr);\r\n    emit RoleAdded(addr, roleName);\r\n  }\r\n\r\n  /**\r\n   * @dev remove a role from an address\r\n   * @param addr address\r\n   * @param roleName the name of the role\r\n   */\r\n  function removeRole(address addr, string roleName)\r\n    internal\r\n  {\r\n    roles[roleName].remove(addr);\r\n    emit RoleRemoved(addr, roleName);\r\n  }\r\n\r\n  /**\r\n   * @dev modifier to scope access to a single role (uses msg.sender as addr)\r\n   * @param roleName the name of the role\r\n   * // reverts\r\n   */\r\n  modifier onlyRole(string roleName)\r\n  {\r\n    checkRole(msg.sender, roleName);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev modifier to scope access to a set of roles (uses msg.sender as addr)\r\n   * @param roleNames the names of the roles to scope access to\r\n   * // reverts\r\n   *\r\n   * @TODO - when solidity supports dynamic arrays as arguments to modifiers, provide this\r\n   *  see: https://github.com/ethereum/solidity/issues/2467\r\n   */\r\n  // modifier onlyRoles(string[] roleNames) {\r\n  //     bool hasAnyRole = false;\r\n  //     for (uint8 i = 0; i < roleNames.length; i++) {\r\n  //         if (hasRole(msg.sender, roleNames[i])) {\r\n  //             hasAnyRole = true;\r\n  //             break;\r\n  //         }\r\n  //     }\r\n\r\n  //     require(hasAnyRole);\r\n\r\n  //     _;\r\n  // }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/ownership/Whitelist.sol\r\n\r\n/**\r\n * @title Whitelist\r\n * @dev The Whitelist contract has a whitelist of addresses, and provides basic authorization control functions.\r\n * @dev This simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Whitelist is Ownable, RBAC {\r\n  event WhitelistedAddressAdded(address addr);\r\n  event WhitelistedAddressRemoved(address addr);\r\n\r\n  string public constant ROLE_WHITELISTED = \"whitelist\";\r\n\r\n  /**\r\n   * @dev Throws if called by any account that's not whitelisted.\r\n   */\r\n  modifier onlyWhitelisted() {\r\n    checkRole(msg.sender, ROLE_WHITELISTED);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev add an address to the whitelist\r\n   * @param addr address\r\n   * @return true if the address was added to the whitelist, false if the address was already in the whitelist\r\n   */\r\n  function addAddressToWhitelist(address addr)\r\n    onlyOwner\r\n    public\r\n  {\r\n    addRole(addr, ROLE_WHITELISTED);\r\n    emit WhitelistedAddressAdded(addr);\r\n  }\r\n\r\n  /**\r\n   * @dev getter to determine if address is in whitelist\r\n   */\r\n  function whitelist(address addr)\r\n    public\r\n    view\r\n    returns (bool)\r\n  {\r\n    return hasRole(addr, ROLE_WHITELISTED);\r\n  }\r\n\r\n  /**\r\n   * @dev add addresses to the whitelist\r\n   * @param addrs addresses\r\n   * @return true if at least one address was added to the whitelist,\r\n   * false if all addresses were already in the whitelist\r\n   */\r\n  function addAddressesToWhitelist(address[] addrs)\r\n    onlyOwner\r\n    public\r\n  {\r\n    for (uint256 i = 0; i < addrs.length; i++) {\r\n      addAddressToWhitelist(addrs[i]);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev remove an address from the whitelist\r\n   * @param addr address\r\n   * @return true if the address was removed from the whitelist,\r\n   * false if the address wasn't in the whitelist in the first place\r\n   */\r\n  function removeAddressFromWhitelist(address addr)\r\n    onlyOwner\r\n    public\r\n  {\r\n    removeRole(addr, ROLE_WHITELISTED);\r\n    emit WhitelistedAddressRemoved(addr);\r\n  }\r\n\r\n  /**\r\n   * @dev remove addresses from the whitelist\r\n   * @param addrs addresses\r\n   * @return true if at least one address was removed from the whitelist,\r\n   * false if all addresses weren't in the whitelist in the first place\r\n   */\r\n  function removeAddressesFromWhitelist(address[] addrs)\r\n    onlyOwner\r\n    public\r\n  {\r\n    for (uint256 i = 0; i < addrs.length; i++) {\r\n      removeAddressFromWhitelist(addrs[i]);\r\n    }\r\n  }\r\n\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/math/SafeMath.sol\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return a / b;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC20/ERC20Basic.sol\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/179\r\n */\r\ncontract ERC20Basic {\r\n  function totalSupply() public view returns (uint256);\r\n  function balanceOf(address who) public view returns (uint256);\r\n  function transfer(address to, uint256 value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC20/BasicToken.sol\r\n\r\n/**\r\n * @title Basic token\r\n * @dev Basic version of StandardToken, with no allowances.\r\n */\r\ncontract BasicToken is ERC20Basic {\r\n  using SafeMath for uint256;\r\n\r\n  mapping(address => uint256) balances;\r\n\r\n  uint256 totalSupply_;\r\n\r\n  /**\r\n  * @dev total number of tokens in existence\r\n  */\r\n  function totalSupply() public view returns (uint256) {\r\n    return totalSupply_;\r\n  }\r\n\r\n  /**\r\n  * @dev transfer token for a specified address\r\n  * @param _to The address to transfer to.\r\n  * @param _value The amount to be transferred.\r\n  */\r\n  function transfer(address _to, uint256 _value) public returns (bool) {\r\n    require(_to != address(0));\r\n    require(_value <= balances[msg.sender]);\r\n\r\n    balances[msg.sender] = balances[msg.sender].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    emit Transfer(msg.sender, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n  * @dev Gets the balance of the specified address.\r\n  * @param _owner The address to query the the balance of.\r\n  * @return An uint256 representing the amount owned by the passed address.\r\n  */\r\n  function balanceOf(address _owner) public view returns (uint256) {\r\n    return balances[_owner];\r\n  }\r\n\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC20/ERC20.sol\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address owner, address spender)\r\n    public view returns (uint256);\r\n\r\n  function transferFrom(address from, address to, uint256 value)\r\n    public returns (bool);\r\n\r\n  function approve(address spender, uint256 value) public returns (bool);\r\n  event Approval(\r\n    address indexed owner,\r\n    address indexed spender,\r\n    uint256 value\r\n  );\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC20/StandardToken.sol\r\n\r\n/**\r\n * @title Standard ERC20 token\r\n *\r\n * @dev Implementation of the basic standard token.\r\n * @dev https://github.com/ethereum/EIPs/issues/20\r\n * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\r\n */\r\ncontract StandardToken is ERC20, BasicToken {\r\n\r\n  mapping (address => mapping (address => uint256)) internal allowed;\r\n\r\n\r\n  /**\r\n   * @dev Transfer tokens from one address to another\r\n   * @param _from address The address which you want to send tokens from\r\n   * @param _to address The address which you want to transfer to\r\n   * @param _value uint256 the amount of tokens to be transferred\r\n   */\r\n  function transferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _value\r\n  )\r\n    public\r\n    returns (bool)\r\n  {\r\n    require(_to != address(0));\r\n    require(_value <= balances[_from]);\r\n    require(_value <= allowed[_from][msg.sender]);\r\n\r\n    balances[_from] = balances[_from].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n    emit Transfer(_from, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n   *\r\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\r\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\r\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\r\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _value The amount of tokens to be spent.\r\n   */\r\n  function approve(address _spender, uint256 _value) public returns (bool) {\r\n    allowed[msg.sender][_spender] = _value;\r\n    emit Approval(msg.sender, _spender, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n   * @param _owner address The address which owns the funds.\r\n   * @param _spender address The address which will spend the funds.\r\n   * @return A uint256 specifying the amount of tokens still available for the spender.\r\n   */\r\n  function allowance(\r\n    address _owner,\r\n    address _spender\r\n   )\r\n    public\r\n    view\r\n    returns (uint256)\r\n  {\r\n    return allowed[_owner][_spender];\r\n  }\r\n\r\n  /**\r\n   * @dev Increase the amount of tokens that an owner allowed to a spender.\r\n   *\r\n   * approve should be called when allowed[_spender] == 0. To increment\r\n   * allowed value is better to use this function to avoid 2 calls (and wait until\r\n   * the first transaction is mined)\r\n   * From MonolithDAO Token.sol\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _addedValue The amount of tokens to increase the allowance by.\r\n   */\r\n  function increaseApproval(\r\n    address _spender,\r\n    uint _addedValue\r\n  )\r\n    public\r\n    returns (bool)\r\n  {\r\n    allowed[msg.sender][_spender] = (\r\n      allowed[msg.sender][_spender].add(_addedValue));\r\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Decrease the amount of tokens that an owner allowed to a spender.\r\n   *\r\n   * approve should be called when allowed[_spender] == 0. To decrement\r\n   * allowed value is better to use this function to avoid 2 calls (and wait until\r\n   * the first transaction is mined)\r\n   * From MonolithDAO Token.sol\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _subtractedValue The amount of tokens to decrease the allowance by.\r\n   */\r\n  function decreaseApproval(\r\n    address _spender,\r\n    uint _subtractedValue\r\n  )\r\n    public\r\n    returns (bool)\r\n  {\r\n    uint oldValue = allowed[msg.sender][_spender];\r\n    if (_subtractedValue > oldValue) {\r\n      allowed[msg.sender][_spender] = 0;\r\n    } else {\r\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\r\n    }\r\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n    return true;\r\n  }\r\n\r\n}\r\n\r\n// File: contracts/QuantstampAuditData.sol\r\n\r\ncontract QuantstampAuditData is Whitelist {\r\n  // state of audit requests submitted to the contract\r\n  enum AuditState {\r\n    None,\r\n    Queued,\r\n    Assigned,\r\n    Refunded,\r\n    Completed,  // automated audit finished successfully and the report is available\r\n    Error,      // automated audit failed to finish; the report contains detailed information about the error\r\n    Expired,\r\n    Resolved\r\n  }\r\n\r\n  // structure representing an audit\r\n  struct Audit {\r\n    address requestor;\r\n    string contractUri;\r\n    uint256 price;\r\n    uint256 requestBlockNumber; // block number that audit was requested\r\n    QuantstampAuditData.AuditState state;\r\n    address auditor;       // the address of the node assigned to the audit\r\n    uint256 assignBlockNumber;  // block number that audit was assigned\r\n    string reportHash;     // stores the hash of audit report\r\n    uint256 reportBlockNumber;  // block number that the payment and the audit report were submitted\r\n    address registrar;  // address of the contract which registers this request\r\n  }\r\n\r\n  // map audits (requestId, Audit)\r\n  mapping(uint256 => Audit) public audits;\r\n\r\n  // token used to pay for audits. This contract assumes that the owner of the contract trusts token's code and\r\n  // that transfer function (such as transferFrom, transfer) do the right thing\r\n  StandardToken public token;\r\n\r\n  // Once an audit node gets an audit request, they must submit a report within this many blocks.\r\n  // After that, the report is verified by the police.\r\n  uint256 public auditTimeoutInBlocks = 50;\r\n\r\n  // maximum number of assigned audits per each audit node\r\n  uint256 public maxAssignedRequests = 10;\r\n\r\n  // map audit nodes to their minimum prices. Defaults to zero: the node accepts all requests.\r\n  mapping(address => uint256) public minAuditPrice;\r\n\r\n  // For generating requestIds starting from 1\r\n  uint256 private requestCounter;\r\n\r\n  /**\r\n   * @dev The constructor creates an audit contract.\r\n   * @param tokenAddress The address of a StandardToken that will be used to pay audit nodes.\r\n   */\r\n  constructor (address tokenAddress) public {\r\n    require(tokenAddress != address(0));\r\n    token = StandardToken(tokenAddress);\r\n  }\r\n\r\n  function addAuditRequest (address requestor, string contractUri, uint256 price) public onlyWhitelisted returns(uint256) {\r\n    // assign the next request ID\r\n    uint256 requestId = ++requestCounter;\r\n    // store the audit\r\n    audits[requestId] = Audit(requestor, contractUri, price, block.number, AuditState.Queued, address(0), 0, \"\", 0, msg.sender);  // solhint-disable-line not-rely-on-time\r\n    return requestId;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows a whitelisted logic contract (QuantstampAudit) to spend stored tokens.\r\n   * @param amount The number of wei-QSP that will be approved.\r\n   */\r\n  function approveWhitelisted(uint256 amount) public onlyWhitelisted {\r\n    token.approve(msg.sender, amount);\r\n  }\r\n\r\n  function getAuditContractUri(uint256 requestId) public view returns(string) {\r\n    return audits[requestId].contractUri;\r\n  }\r\n\r\n  function getAuditRequestor(uint256 requestId) public view returns(address) {\r\n    return audits[requestId].requestor;\r\n  }\r\n\r\n  function getAuditPrice (uint256 requestId) public view returns(uint256) {\r\n    return audits[requestId].price;\r\n  }\r\n\r\n  function getAuditState (uint256 requestId) public view returns(AuditState) {\r\n    return audits[requestId].state;\r\n  }\r\n\r\n  function getAuditRequestBlockNumber (uint256 requestId) public view returns(uint) {\r\n    return audits[requestId].requestBlockNumber;\r\n  }\r\n\r\n  function setAuditState (uint256 requestId, AuditState state) public onlyWhitelisted {\r\n    audits[requestId].state = state;\r\n  }\r\n\r\n  function getAuditAuditor (uint256 requestId) public view returns(address) {\r\n    return audits[requestId].auditor;\r\n  }\r\n\r\n  function getAuditRegistrar (uint256 requestId) public view returns(address) {\r\n    return audits[requestId].registrar;\r\n  }\r\n\r\n  function setAuditAuditor (uint256 requestId, address auditor) public onlyWhitelisted {\r\n    audits[requestId].auditor = auditor;\r\n  }\r\n\r\n  function getAuditAssignBlockNumber (uint256 requestId) public view returns(uint256) {\r\n    return audits[requestId].assignBlockNumber;\r\n  }\r\n\r\n  function getAuditReportBlockNumber (uint256 requestId) public view returns (uint256) {\r\n    return audits[requestId].reportBlockNumber;\r\n  }\r\n\r\n  function setAuditAssignBlockNumber (uint256 requestId, uint256 assignBlockNumber) public onlyWhitelisted {\r\n    audits[requestId].assignBlockNumber = assignBlockNumber;\r\n  }\r\n\r\n  function setAuditReportHash (uint256 requestId, string reportHash) public onlyWhitelisted {\r\n    audits[requestId].reportHash = reportHash;\r\n  }\r\n\r\n  function setAuditReportBlockNumber (uint256 requestId, uint256 reportBlockNumber) public onlyWhitelisted {\r\n    audits[requestId].reportBlockNumber = reportBlockNumber;\r\n  }\r\n\r\n  function setAuditRegistrar (uint256 requestId, address registrar) public onlyWhitelisted {\r\n    audits[requestId].registrar = registrar;\r\n  }\r\n\r\n  function setAuditTimeout (uint256 timeoutInBlocks) public onlyOwner {\r\n    auditTimeoutInBlocks = timeoutInBlocks;\r\n  }\r\n\r\n  /**\r\n   * @dev Set the maximum number of audits any audit node can handle at any time.\r\n   * @param maxAssignments Maximum number of audit requests for each audit node.\r\n   */\r\n  function setMaxAssignedRequests (uint256 maxAssignments) public onlyOwner {\r\n    maxAssignedRequests = maxAssignments;\r\n  }\r\n\r\n  function getMinAuditPrice (address auditor) public view returns(uint256) {\r\n    return minAuditPrice[auditor];\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the audit node to set its minimum price per audit in wei-QSP.\r\n   * @param price The minimum price.\r\n   */\r\n  function setMinAuditPrice(address auditor, uint256 price) public onlyWhitelisted {\r\n    minAuditPrice[auditor] = price;\r\n  }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC20/SafeERC20.sol\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure.\r\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n  function safeTransfer(ERC20Basic token, address to, uint256 value) internal {\r\n    require(token.transfer(to, value));\r\n  }\r\n\r\n  function safeTransferFrom(\r\n    ERC20 token,\r\n    address from,\r\n    address to,\r\n    uint256 value\r\n  )\r\n    internal\r\n  {\r\n    require(token.transferFrom(from, to, value));\r\n  }\r\n\r\n  function safeApprove(ERC20 token, address spender, uint256 value) internal {\r\n    require(token.approve(spender, value));\r\n  }\r\n}\r\n\r\n// File: contracts/token_escrow/TokenEscrow.sol\r\n\r\n/**\r\n * NOTE: All contracts in this directory were taken from a non-master branch of openzeppelin-solidity.\r\n * This contract was modified to be a whitelist.\r\n * Commit: ed451a8688d1fa7c927b27cec299a9726667d9b1\r\n */\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title TokenEscrow\r\n * @dev Holds tokens destinated to a payee until they withdraw them.\r\n * The contract that uses the TokenEscrow as its payment method\r\n * should be its owner, and provide public methods redirecting\r\n * to the TokenEscrow's deposit and withdraw.\r\n * Moreover, the TokenEscrow should also be allowed to transfer\r\n * tokens from the payer to itself.\r\n */\r\ncontract TokenEscrow is Ownable, Whitelist {\r\n  using SafeMath for uint256;\r\n  using SafeERC20 for ERC20;\r\n\r\n  event Deposited(address indexed payee, uint256 tokenAmount);\r\n  event Withdrawn(address indexed payee, uint256 tokenAmount);\r\n\r\n  mapping(address => uint256) public deposits;\r\n\r\n  ERC20 public token;\r\n\r\n  constructor (ERC20 _token) public {\r\n    require(_token != address(0));\r\n    token = _token;\r\n  }\r\n\r\n  function depositsOf(address _payee) public view returns (uint256) {\r\n    return deposits[_payee];\r\n  }\r\n\r\n  /**\r\n  * @dev Puts in escrow a certain amount of tokens as credit to be withdrawn.\r\n  * @param _payee The destination address of the tokens.\r\n  * @param _amount The amount of tokens to deposit in escrow.\r\n  */\r\n  function deposit(address _payee, uint256 _amount) public onlyWhitelisted {\r\n    deposits[_payee] = deposits[_payee].add(_amount);\r\n\r\n    token.safeTransferFrom(msg.sender, address(this), _amount);\r\n\r\n    emit Deposited(_payee, _amount);\r\n  }\r\n\r\n  /**\r\n  * @dev Withdraw accumulated tokens for a payee.\r\n  * @param _payee The address whose tokens will be withdrawn and transferred to.\r\n  */\r\n  function withdraw(address _payee) public onlyWhitelisted {\r\n    uint256 payment = deposits[_payee];\r\n    assert(token.balanceOf(address(this)) >= payment);\r\n\r\n    deposits[_payee] = 0;\r\n\r\n    token.safeTransfer(_payee, payment);\r\n\r\n    emit Withdrawn(_payee, payment);\r\n  }\r\n}\r\n\r\n// File: contracts/token_escrow/ConditionalTokenEscrow.sol\r\n\r\n/**\r\n * NOTE: All contracts in this directory were taken from a non-master branch of openzeppelin-solidity.\r\n * Commit: ed451a8688d1fa7c927b27cec299a9726667d9b1\r\n */\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\n\r\n/**\r\n * @title ConditionalTokenEscrow\r\n * @dev Base abstract escrow to only allow withdrawal of tokens\r\n * if a condition is met.\r\n */\r\ncontract ConditionalTokenEscrow is TokenEscrow {\r\n  /**\r\n  * @dev Returns whether an address is allowed to withdraw their tokens.\r\n  * To be implemented by derived contracts.\r\n  * @param _payee The destination address of the tokens.\r\n  */\r\n  function withdrawalAllowed(address _payee) public view returns (bool);\r\n\r\n  function withdraw(address _payee) public {\r\n    require(withdrawalAllowed(_payee));\r\n    super.withdraw(_payee);\r\n  }\r\n}\r\n\r\n// File: contracts/QuantstampAuditTokenEscrow.sol\r\n\r\ncontract QuantstampAuditTokenEscrow is ConditionalTokenEscrow {\r\n\r\n  // the escrow maintains the list of staked addresses\r\n  using LinkedListLib for LinkedListLib.LinkedList;\r\n\r\n  // constants used by LinkedListLib\r\n  uint256 constant internal NULL = 0;\r\n  uint256 constant internal HEAD = 0;\r\n  bool constant internal PREV = false;\r\n  bool constant internal NEXT = true;\r\n\r\n  // maintain the number of staked nodes\r\n  // saves gas cost over needing to call stakedNodesList.sizeOf()\r\n  uint256 public stakedNodesCount = 0;\r\n\r\n  // the minimum amount of wei-QSP that must be staked in order to be a node\r\n  uint256 public minAuditStake = 10000 * (10 ** 18);\r\n\r\n  // if true, the payee cannot currently withdraw their funds\r\n  mapping(address => bool) public lockedFunds;\r\n\r\n  // if funds are locked, they may be retrieved after this block\r\n  // if funds are unlocked, the number should be ignored\r\n  mapping(address => uint256) public unlockBlockNumber;\r\n\r\n  // staked audit nodes -- needed to inquire about audit node statistics, such as min price\r\n  // this list contains all nodes that have *ANY* stake, however when getNextStakedNode is called,\r\n  // it skips nodes that do not meet the minimum stake.\r\n  // the reason for this approach is that if the owner lowers the minAuditStake,\r\n  // we must be aware of any node with a stake.\r\n  LinkedListLib.LinkedList internal stakedNodesList;\r\n\r\n  event Slashed(address addr, uint256 amount);\r\n  event StakedNodeAdded(address addr);\r\n  event StakedNodeRemoved(address addr);\r\n\r\n  // the constructor of TokenEscrow requires an ERC20, not an address\r\n  constructor(address tokenAddress) public TokenEscrow(ERC20(tokenAddress)) {} // solhint-disable no-empty-blocks\r\n\r\n  /**\r\n  * @dev Puts in escrow a certain amount of tokens as credit to be withdrawn.\r\n  *      Overrides the function in TokenEscrow.sol to add the payee to the staked list.\r\n  * @param _payee The destination address of the tokens.\r\n  * @param _amount The amount of tokens to deposit in escrow.\r\n  */\r\n  function deposit(address _payee, uint256 _amount) public onlyWhitelisted {\r\n    super.deposit(_payee, _amount);\r\n    if (_amount > 0) {\r\n      // fails gracefully if the node already exists\r\n      addNodeToStakedList(_payee);\r\n    }\r\n  }\r\n\r\n /**\r\n  * @dev Withdraw accumulated tokens for a payee.\r\n  *      Overrides the function in TokenEscrow.sol to remove the payee from the staked list.\r\n  * @param _payee The address whose tokens will be withdrawn and transferred to.\r\n  */\r\n  function withdraw(address _payee) public onlyWhitelisted {\r\n    super.withdraw(_payee);\r\n    removeNodeFromStakedList(_payee);\r\n  }\r\n\r\n  /**\r\n   * @dev Sets the minimum stake to a new value.\r\n   * @param _value The new value. _value must be greater than zero in order for the linked list to be maintained correctly.\r\n   */\r\n  function setMinAuditStake(uint256 _value) public onlyOwner {\r\n    require(_value > 0);\r\n    minAuditStake = _value;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns true if the sender staked enough.\r\n   * @param addr The address to check.\r\n   */\r\n  function hasEnoughStake(address addr) public view returns(bool) {\r\n    return depositsOf(addr) >= minAuditStake;\r\n  }\r\n\r\n  /**\r\n   * @dev Overrides ConditionalTokenEscrow function. If true, funds may be withdrawn.\r\n   * @param _payee The address that wants to withdraw funds.\r\n   */\r\n  function withdrawalAllowed(address _payee) public view returns (bool) {\r\n    return !lockedFunds[_payee] || unlockBlockNumber[_payee] < block.number;\r\n  }\r\n\r\n  /**\r\n   * @dev Prevents the payee from withdrawing funds.\r\n   * @param _payee The address that will be locked.\r\n   */\r\n  function lockFunds(address _payee, uint256 _unlockBlockNumber) public onlyWhitelisted returns (bool) {\r\n    lockedFunds[_payee] = true;\r\n    unlockBlockNumber[_payee] = _unlockBlockNumber;\r\n    return true;\r\n  }\r\n\r\n    /**\r\n   * @dev Slash a percentage of the stake of an address.\r\n   *      The percentage is taken from the minAuditStake, not the total stake of the address.\r\n   *      The caller of this function receives the slashed QSP.\r\n   *      If the current stake does not cover the slash amount, the full stake is taken.\r\n   *\r\n   * @param addr The address that will be slashed.\r\n   * @param percentage The percent of the minAuditStake that should be slashed.\r\n   */\r\n  function slash(address addr, uint256 percentage) public onlyWhitelisted returns (uint256) {\r\n    require(0 <= percentage && percentage <= 100);\r\n\r\n    uint256 slashAmount = getSlashAmount(percentage);\r\n    uint256 balance = depositsOf(addr);\r\n    if (balance < slashAmount) {\r\n      slashAmount = balance;\r\n    }\r\n\r\n    // subtract from the deposits amount of the addr\r\n    deposits[addr] = deposits[addr].sub(slashAmount);\r\n\r\n    emit Slashed(addr, slashAmount);\r\n\r\n    // if the deposits of the address are now zero, remove from the list\r\n    if (depositsOf(addr) == 0) {\r\n      removeNodeFromStakedList(addr);\r\n    }\r\n\r\n    // transfer the slashAmount to the police contract\r\n    token.safeTransfer(msg.sender, slashAmount);\r\n\r\n    return slashAmount;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the slash amount for a given percentage.\r\n   * @param percentage The percent of the minAuditStake that should be slashed.\r\n   */\r\n  function getSlashAmount(uint256 percentage) public view returns (uint256) {\r\n    return (minAuditStake.mul(percentage)).div(100);\r\n  }\r\n\r\n  /**\r\n   * @dev Given a staked address, returns the next address from the list that meets the minAuditStake.\r\n   * @param addr The staked address.\r\n   * @return The next address in the list.\r\n   */\r\n  function getNextStakedNode(address addr) public view returns(address) {\r\n    bool exists;\r\n    uint256 next;\r\n    (exists, next) = stakedNodesList.getAdjacent(uint256(addr), NEXT);\r\n    // only return addresses that meet the minAuditStake\r\n    while (exists && next != HEAD && !hasEnoughStake(address(next))) {\r\n      (exists, next) = stakedNodesList.getAdjacent(next, NEXT);\r\n    }\r\n    return address(next);\r\n  }\r\n\r\n  /**\r\n   * @dev Adds an address to the stakedNodesList.\r\n   * @param addr The address to be added to the list.\r\n   * @return true if the address was added to the list.\r\n   */\r\n  function addNodeToStakedList(address addr) internal returns(bool success) {\r\n    if (stakedNodesList.insert(HEAD, uint256(addr), PREV)) {\r\n      stakedNodesCount++;\r\n      emit StakedNodeAdded(addr);\r\n      success = true;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Removes an address from the stakedNodesList.\r\n   * @param addr The address to be removed from the list.\r\n   * @return true if the address was removed from the list.\r\n   */\r\n  function removeNodeFromStakedList(address addr) internal returns(bool success) {\r\n    if (stakedNodesList.remove(uint256(addr)) != 0) {\r\n      stakedNodesCount--;\r\n      emit StakedNodeRemoved(addr);\r\n      success = true;\r\n    }\r\n  }\r\n}\r\n\r\n// File: contracts/QuantstampAuditPolice.sol\r\n\r\n// TODO (QSP-833): salary and taxing\r\n// TODO transfer existing salary if removing police\r\ncontract QuantstampAuditPolice is Whitelist {   // solhint-disable max-states-count\r\n\r\n  using SafeMath for uint256;\r\n  using LinkedListLib for LinkedListLib.LinkedList;\r\n\r\n  // constants used by LinkedListLib\r\n  uint256 constant internal NULL = 0;\r\n  uint256 constant internal HEAD = 0;\r\n  bool constant internal PREV = false;\r\n  bool constant internal NEXT = true;\r\n\r\n  enum PoliceReportState {\r\n    UNVERIFIED,\r\n    INVALID,\r\n    VALID,\r\n    EXPIRED\r\n  }\r\n\r\n  // whitelisted police nodes\r\n  LinkedListLib.LinkedList internal policeList;\r\n\r\n  // the total number of police nodes\r\n  uint256 public numPoliceNodes = 0;\r\n\r\n  // the number of police nodes assigned to each report\r\n  uint256 public policeNodesPerReport = 3;\r\n\r\n  // the number of blocks the police have to verify a report\r\n  uint256 public policeTimeoutInBlocks = 100;\r\n\r\n  // number from [0-100] that indicates the percentage of the minAuditStake that should be slashed\r\n  uint256 public slashPercentage = 20;\r\n\r\n    // this is only deducted once per report, regardless of the number of police nodes assigned to it\r\n  uint256 public reportProcessingFeePercentage = 5;\r\n\r\n  event PoliceNodeAdded(address addr);\r\n  event PoliceNodeRemoved(address addr);\r\n  // TODO: we may want these parameters indexed\r\n  event PoliceNodeAssignedToReport(address policeNode, uint256 requestId);\r\n  event PoliceSubmissionPeriodExceeded(uint256 requestId, uint256 timeoutBlock, uint256 currentBlock);\r\n  event PoliceSlash(uint256 requestId, address policeNode, address auditNode, uint256 amount);\r\n  event PoliceFeesClaimed(address policeNode, uint256 fee);\r\n  event PoliceFeesCollected(uint256 requestId, uint256 fee);\r\n  event PoliceAssignmentExpiredAndCleared(uint256 requestId);\r\n\r\n  // pointer to the police node that was last assigned to a report\r\n  address private lastAssignedPoliceNode = address(HEAD);\r\n\r\n  // maps each police node to the IDs of reports it should check\r\n  mapping(address => LinkedListLib.LinkedList) internal assignedReports;\r\n\r\n  // maps request IDs to the police nodes that are expected to check the report\r\n  mapping(uint256 => LinkedListLib.LinkedList) internal assignedPolice;\r\n\r\n  // maps each audit node to the IDs of reports that are pending police approval for payment\r\n  mapping(address => LinkedListLib.LinkedList) internal pendingPayments;\r\n\r\n  // maps request IDs to police timeouts\r\n  mapping(uint256 => uint256) public policeTimeouts;\r\n\r\n  // maps request IDs to reports submitted by police nodes\r\n  mapping(uint256 => mapping(address => bytes)) public policeReports;\r\n\r\n  // maps request IDs to the result reported by each police node\r\n  mapping(uint256 => mapping(address => PoliceReportState)) public policeReportResults;\r\n\r\n  // maps request IDs to whether they have been verified by the police\r\n  mapping(uint256 => PoliceReportState) public verifiedReports;\r\n\r\n  // maps request IDs to whether their reward has been claimed by the submitter\r\n  mapping(uint256 => bool) public rewardHasBeenClaimed;\r\n\r\n  // tracks the total number of reports ever assigned to a police node\r\n  mapping(address => uint256) public totalReportsAssigned;\r\n\r\n  // tracks the total number of reports ever checked by a police node\r\n  mapping(address => uint256) public totalReportsChecked;\r\n\r\n  // the collected fees for each report\r\n  mapping(uint256 => uint256) public collectedFees;\r\n\r\n  // contract that stores audit data (separate from the auditing logic)\r\n  QuantstampAuditData public auditData;\r\n\r\n  // contract that stores token escrows of nodes on the network\r\n  QuantstampAuditTokenEscrow public tokenEscrow;\r\n\r\n  /**\r\n   * @dev The constructor creates a police contract.\r\n   * @param auditDataAddress The address of an AuditData that stores data used for performing audits.\r\n   * @param escrowAddress The address of a QuantstampTokenEscrow contract that holds staked deposits of nodes.\r\n   */\r\n  constructor (address auditDataAddress, address escrowAddress) public {\r\n    require(auditDataAddress != address(0));\r\n    require(escrowAddress != address(0));\r\n    auditData = QuantstampAuditData(auditDataAddress);\r\n    tokenEscrow = QuantstampAuditTokenEscrow(escrowAddress);\r\n  }\r\n\r\n  /**\r\n   * @dev Assigns police nodes to a submitted report\r\n   * @param requestId The ID of the audit request.\r\n   */\r\n  function assignPoliceToReport(uint256 requestId) public onlyWhitelisted {\r\n    // ensure that the requestId has not already been assigned to police already\r\n    require(policeTimeouts[requestId] == 0);\r\n    // set the timeout for police reports\r\n    policeTimeouts[requestId] = block.number + policeTimeoutInBlocks;\r\n    // if there are not enough police nodes, this avoids assigning the same node twice\r\n    uint256 numToAssign = policeNodesPerReport;\r\n    if (numPoliceNodes < numToAssign) {\r\n      numToAssign = numPoliceNodes;\r\n    }\r\n    while (numToAssign > 0) {\r\n      lastAssignedPoliceNode = getNextPoliceNode(lastAssignedPoliceNode);\r\n      if (lastAssignedPoliceNode != address(0)) {\r\n        // push the request ID to the tail of the assignment list for the police node\r\n        assignedReports[lastAssignedPoliceNode].push(requestId, PREV);\r\n        // push the police node to the list of nodes assigned to check the report\r\n        assignedPolice[requestId].push(uint256(lastAssignedPoliceNode), PREV);\r\n        emit PoliceNodeAssignedToReport(lastAssignedPoliceNode, requestId);\r\n        totalReportsAssigned[lastAssignedPoliceNode] = totalReportsAssigned[lastAssignedPoliceNode].add(1);\r\n        numToAssign = numToAssign.sub(1);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Cleans the list of assignments to police node (msg.sender), but checks only up to a limit\r\n   * of assignments. If the limit is 0, attempts to clean the entire list.\r\n   * @param policeNode The node whose assignments should be cleared.\r\n   * @param limit The number of assigments to check.\r\n   */\r\n  function clearExpiredAssignments (address policeNode, uint256 limit) public {\r\n    removeExpiredAssignments(policeNode, 0, limit);\r\n  }\r\n\r\n  /**\r\n   * @dev Collects the police fee for checking a report.\r\n   *      NOTE: this function assumes that the fee will be transferred by the calling contract.\r\n   * @param requestId The ID of the audit request.\r\n   * @return The amount collected.\r\n   */\r\n  function collectFee(uint256 requestId) public onlyWhitelisted returns (uint256) {\r\n    uint256 policeFee = getPoliceFee(auditData.getAuditPrice(requestId));\r\n    // the collected fee needs to be stored in a map since the owner could change the fee percentage\r\n    collectedFees[requestId] = policeFee;\r\n    emit PoliceFeesCollected(requestId, policeFee);\r\n    return policeFee;\r\n  }\r\n\r\n  /**\r\n   * @dev Split a payment, which may be for report checking or from slashing, amongst all police nodes\r\n   * @param amount The amount to be split, which should have been transferred to this contract earlier.\r\n   */\r\n  function splitPayment(uint256 amount) public onlyWhitelisted {\r\n    require(numPoliceNodes != 0);\r\n    address policeNode = getNextPoliceNode(address(HEAD));\r\n    uint256 amountPerNode = amount.div(numPoliceNodes);\r\n    // TODO: upgrade our openzeppelin version to use mod\r\n    uint256 largerAmount = amountPerNode.add(amount % numPoliceNodes);\r\n    bool largerAmountClaimed = false;\r\n    while (policeNode != address(HEAD)) {\r\n      // give the largerAmount to the current lastAssignedPoliceNode if it is not equal to HEAD\r\n      // this approach is only truly fair if numPoliceNodes and policeNodesPerReport are relatively prime\r\n      // but the remainder should be extremely small in any case\r\n      // the last conditional handles the edge case where all police nodes were removed and then re-added\r\n      if (!largerAmountClaimed && (policeNode == lastAssignedPoliceNode || lastAssignedPoliceNode == address(HEAD))) {\r\n        require(auditData.token().transfer(policeNode, largerAmount));\r\n        emit PoliceFeesClaimed(policeNode, largerAmount);\r\n        largerAmountClaimed = true;\r\n      } else {\r\n        require(auditData.token().transfer(policeNode, amountPerNode));\r\n        emit PoliceFeesClaimed(policeNode, amountPerNode);\r\n      }\r\n      policeNode = getNextPoliceNode(address(policeNode));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Associates a pending payment with an auditor that can be claimed after the policing period.\r\n   * @param auditor The audit node that submitted the report.\r\n   * @param requestId The ID of the audit request.\r\n   */\r\n  function addPendingPayment(address auditor, uint256 requestId) public onlyWhitelisted {\r\n    pendingPayments[auditor].push(requestId, PREV);\r\n  }\r\n\r\n  /**\r\n   * @dev Submits verification of a report by a police node.\r\n   * @param policeNode The address of the police node.\r\n   * @param auditNode The address of the audit node.\r\n   * @param requestId The ID of the audit request.\r\n   * @param report The compressed bytecode representation of the report.\r\n   * @param isVerified Whether the police node's report matches the submitted report.\r\n   *                   If not, the audit node is slashed.\r\n   * @return two bools and a uint256: (true if the report was successfully submitted, true if a slash occurred, the slash amount).\r\n   */\r\n  function submitPoliceReport(\r\n    address policeNode,\r\n    address auditNode,\r\n    uint256 requestId,\r\n    bytes report,\r\n    bool isVerified) public onlyWhitelisted returns (bool, bool, uint256) {\r\n    // remove expired assignments\r\n    bool hasRemovedCurrentId = removeExpiredAssignments(policeNode, requestId, 0);\r\n    // if the current request has timed out, return\r\n    if (hasRemovedCurrentId) {\r\n      emit PoliceSubmissionPeriodExceeded(requestId, policeTimeouts[requestId], block.number);\r\n      return (false, false, 0);\r\n    }\r\n    // the police node is assigned to the report\r\n    require(isAssigned(requestId, policeNode));\r\n\r\n    // remove the report from the assignments to the node\r\n    assignedReports[policeNode].remove(requestId);\r\n    // increment the number of reports checked by the police node\r\n    totalReportsChecked[policeNode] = totalReportsChecked[policeNode] + 1;\r\n    // store the report\r\n    policeReports[requestId][policeNode] = report;\r\n    // emit an event\r\n    PoliceReportState state;\r\n    if (isVerified) {\r\n      state = PoliceReportState.VALID;\r\n    } else {\r\n      state = PoliceReportState.INVALID;\r\n    }\r\n    policeReportResults[requestId][policeNode] = state;\r\n\r\n    // the report was already marked invalid by a different police node\r\n    if (verifiedReports[requestId] == PoliceReportState.INVALID) {\r\n      return (true, false, 0);\r\n    } else {\r\n      verifiedReports[requestId] = state;\r\n    }\r\n    bool slashOccurred;\r\n    uint256 slashAmount;\r\n    if (!isVerified) {\r\n      pendingPayments[auditNode].remove(requestId);\r\n      // an audit node can only be slashed once for each report,\r\n      // even if multiple police mark the report as invalid\r\n      slashAmount = tokenEscrow.slash(auditNode, slashPercentage);\r\n      slashOccurred = true;\r\n      emit PoliceSlash(requestId, policeNode, auditNode, slashAmount);\r\n    }\r\n    return (true, slashOccurred, slashAmount);\r\n  }\r\n\r\n  /**\r\n   * @dev Determines whether an audit node is allowed by the police to claim an audit.\r\n   * @param auditNode The address of the audit node.\r\n   * @param requestId The ID of the requested audit.\r\n   */\r\n  function canClaimAuditReward (address auditNode, uint256 requestId) public view returns (bool) {\r\n    // NOTE: can't use requires here, as claimNextReward needs to iterate the full list\r\n    return\r\n      // the report is in the pending payments list for the audit node\r\n      pendingPayments[auditNode].nodeExists(requestId) &&\r\n      // the policing period has ended for the report\r\n      policeTimeouts[requestId] < block.number &&\r\n      // the police did not invalidate the report\r\n      verifiedReports[requestId] != PoliceReportState.INVALID &&\r\n      // the reward has not already been claimed\r\n      !rewardHasBeenClaimed[requestId] &&\r\n      // the requestId is non-zero\r\n      requestId > 0;\r\n  }\r\n\r\n  /**\r\n   * @dev Given a requestId, returns the next pending available reward for the audit node.\r\n   * @param auditNode The address of the audit node.\r\n   * @param requestId The ID of the current linked list node\r\n   * @return true if the next reward exists, and the corresponding requestId in the linked list\r\n   */\r\n  function getNextAvailableReward (address auditNode, uint256 requestId) public view returns (bool, uint256) {\r\n    bool exists;\r\n    (exists, requestId) = pendingPayments[auditNode].getAdjacent(requestId, NEXT);\r\n    // NOTE: Do NOT short circuit this list based on timeouts.\r\n    // The ordering may be broken if the owner changes the timeouts.\r\n    while (exists && requestId != HEAD) {\r\n      if (canClaimAuditReward(auditNode, requestId)) {\r\n        return (true, requestId);\r\n      }\r\n      (exists, requestId) = pendingPayments[auditNode].getAdjacent(requestId, NEXT);\r\n    }\r\n    return (false, 0);\r\n  }\r\n\r\n  /**\r\n   * @dev Sets the reward as claimed after checking that it can be claimed.\r\n   *      This function also ensures double payment does not occur.\r\n   * @param auditNode The address of the audit node.\r\n   * @param requestId The ID of the requested audit.\r\n   */\r\n  function setRewardClaimed (address auditNode, uint256 requestId) public onlyWhitelisted returns (bool) {\r\n    // set the reward to claimed, to avoid double payment\r\n    rewardHasBeenClaimed[requestId] = true;\r\n    pendingPayments[auditNode].remove(requestId);\r\n    // if it is possible to claim yet the state is UNVERIFIED, mark EXPIRED\r\n    if (verifiedReports[requestId] == PoliceReportState.UNVERIFIED) {\r\n      verifiedReports[requestId] = PoliceReportState.EXPIRED;\r\n    }\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Selects the next ID to be rewarded.\r\n   * @param auditNode The address of the audit node.\r\n   * @param requestId The previous claimed requestId (initially set to HEAD).\r\n   * @return True if another reward exists, and the request ID.\r\n   */\r\n  function claimNextReward (address auditNode, uint256 requestId) public onlyWhitelisted returns (bool, uint256) {\r\n    bool exists;\r\n    (exists, requestId) = pendingPayments[auditNode].getAdjacent(requestId, NEXT);\r\n    // NOTE: Do NOT short circuit this list based on timeouts.\r\n    // The ordering may be broken if the owner changes the timeouts.\r\n    while (exists && requestId != HEAD) {\r\n      if (canClaimAuditReward(auditNode, requestId)) {\r\n        setRewardClaimed(auditNode, requestId);\r\n        return (true, requestId);\r\n      }\r\n      (exists, requestId) = pendingPayments[auditNode].getAdjacent(requestId, NEXT);\r\n    }\r\n    return (false, 0);\r\n  }\r\n\r\n  /**\r\n   * @dev Gets the next assigned report to the police node.\r\n   * @param policeNode The address of the police node.\r\n   * @return true if the list is non-empty, requestId, auditPrice, uri, and policeAssignmentBlockNumber.\r\n   */\r\n  function getNextPoliceAssignment(address policeNode) public view returns (bool, uint256, uint256, string, uint256) {\r\n    bool exists;\r\n    uint256 requestId;\r\n    (exists, requestId) = assignedReports[policeNode].getAdjacent(HEAD, NEXT);\r\n    // if the head of the list is an expired assignment, try to find a current one\r\n    while (exists && requestId != HEAD) {\r\n      if (policeTimeouts[requestId] < block.number) {\r\n        (exists, requestId) = assignedReports[policeNode].getAdjacent(requestId, NEXT);\r\n      } else {\r\n        uint256 price = auditData.getAuditPrice(requestId);\r\n        string memory uri = auditData.getAuditContractUri(requestId);\r\n        uint256 policeAssignmentBlockNumber = auditData.getAuditReportBlockNumber(requestId);\r\n        return (exists, requestId, price, uri, policeAssignmentBlockNumber);\r\n      }\r\n    }\r\n    return (false, 0, 0, \"\", 0);\r\n  }\r\n\r\n  /**\r\n   * @dev Gets the next assigned police node to an audit request.\r\n   * @param requestId The ID of the audit request.\r\n   * @param policeNode The previous claimed requestId (initially set to HEAD).\r\n   * @return true if the next police node exists, and the address of the police node.\r\n   */\r\n  function getNextAssignedPolice(uint256 requestId, address policeNode) public view returns (bool, address) {\r\n    bool exists;\r\n    uint256 nextPoliceNode;\r\n    (exists, nextPoliceNode) = assignedPolice[requestId].getAdjacent(uint256(policeNode), NEXT);\r\n    if (nextPoliceNode == HEAD) {\r\n      return (false, address(0));\r\n    }\r\n    return (exists, address(nextPoliceNode));\r\n  }\r\n\r\n  /**\r\n   * @dev Sets the number of police nodes that should check each report.\r\n   * @param numPolice The number of police.\r\n   */\r\n  function setPoliceNodesPerReport(uint256 numPolice) public onlyOwner {\r\n    policeNodesPerReport = numPolice;\r\n  }\r\n\r\n  /**\r\n   * @dev Sets the police timeout.\r\n   * @param numBlocks The number of blocks for the timeout.\r\n   */\r\n  function setPoliceTimeoutInBlocks(uint256 numBlocks) public onlyOwner {\r\n    policeTimeoutInBlocks = numBlocks;\r\n  }\r\n\r\n  /**\r\n   * @dev Sets the slash percentage.\r\n   * @param percentage The percentage as an integer from [0-100].\r\n   */\r\n  function setSlashPercentage(uint256 percentage) public onlyOwner {\r\n    require(0 <= percentage && percentage <= 100);\r\n    slashPercentage = percentage;\r\n  }\r\n\r\n  /**\r\n   * @dev Sets the report processing fee percentage.\r\n   * @param percentage The percentage in the range of [0-100].\r\n   */\r\n  function setReportProcessingFeePercentage(uint256 percentage) public onlyOwner {\r\n    require(percentage <= 100);\r\n    reportProcessingFeePercentage = percentage;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns true if a node is whitelisted.\r\n   * @param node The node to check.\r\n   */\r\n  function isPoliceNode(address node) public view returns (bool) {\r\n    return policeList.nodeExists(uint256(node));\r\n  }\r\n\r\n  /**\r\n   * @dev Adds an address to the police.\r\n   * @param addr The address to be added.\r\n   * @return true if the address was added to the whitelist.\r\n   */\r\n  function addPoliceNode(address addr) public onlyOwner returns (bool success) {\r\n    if (policeList.insert(HEAD, uint256(addr), PREV)) {\r\n      numPoliceNodes = numPoliceNodes.add(1);\r\n      emit PoliceNodeAdded(addr);\r\n      success = true;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Removes an address from the whitelist linked-list.\r\n   * @param addr The address to be removed.\r\n   * @return true if the address was removed from the whitelist.\r\n   */\r\n  function removePoliceNode(address addr) public onlyOwner returns (bool success) {\r\n    // if lastAssignedPoliceNode is addr, need to move the pointer\r\n    bool exists;\r\n    uint256 next;\r\n    if (lastAssignedPoliceNode == addr) {\r\n      (exists, next) = policeList.getAdjacent(uint256(addr), NEXT);\r\n      lastAssignedPoliceNode = address(next);\r\n    }\r\n\r\n    if (policeList.remove(uint256(addr)) != NULL) {\r\n      numPoliceNodes = numPoliceNodes.sub(1);\r\n      emit PoliceNodeRemoved(addr);\r\n      success = true;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Given a whitelisted address, returns the next address from the whitelist.\r\n   * @param addr The address in the whitelist.\r\n   * @return The next address in the whitelist.\r\n   */\r\n  function getNextPoliceNode(address addr) public view returns (address) {\r\n    bool exists;\r\n    uint256 next;\r\n    (exists, next) = policeList.getAdjacent(uint256(addr), NEXT);\r\n    return address(next);\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the resulting state of a police report for a given audit request.\r\n   * @param requestId The ID of the audit request.\r\n   * @param policeAddr The address of the police node.\r\n   * @return the PoliceReportState of the (requestId, policeNode) pair.\r\n   */\r\n  function getPoliceReportResult(uint256 requestId, address policeAddr) public view returns (PoliceReportState) {\r\n    return policeReportResults[requestId][policeAddr];\r\n  }\r\n\r\n  function getPoliceReport(uint256 requestId, address policeAddr) public view returns (bytes) {\r\n    return policeReports[requestId][policeAddr];\r\n  }\r\n\r\n  function getPoliceFee(uint256 auditPrice) public view returns (uint256) {\r\n    return auditPrice.mul(reportProcessingFeePercentage).div(100);\r\n  }\r\n\r\n  function isAssigned(uint256 requestId, address policeAddr) public view returns (bool) {\r\n    return assignedReports[policeAddr].nodeExists(requestId);\r\n  }\r\n\r\n  /**\r\n   * Cleans the list of assignments to a given police node.\r\n   * @param policeNode The address of the police node.\r\n   * @param requestId The ID of the audit request.\r\n   * @param limit The number of assigments to check. Use 0 if the entire list should be checked.\r\n   * @return true if the current request ID gets removed during cleanup.\r\n   */\r\n  function removeExpiredAssignments (address policeNode, uint256 requestId, uint256 limit) internal returns (bool) {\r\n    bool hasRemovedCurrentId = false;\r\n    bool exists;\r\n    uint256 potentialExpiredRequestId;\r\n    uint256 nextExpiredRequestId;\r\n    uint256 iterationsLeft = limit;\r\n    (exists, nextExpiredRequestId) = assignedReports[policeNode].getAdjacent(HEAD, NEXT);\r\n    // NOTE: Short circuiting this list may cause expired assignments to exist later in the list.\r\n    //       The may occur if the owner changes the global police timeout.\r\n    //       These expired assignments will be removed in subsequent calls.\r\n    while (exists && nextExpiredRequestId != HEAD && (limit == 0 || iterationsLeft > 0)) {\r\n      potentialExpiredRequestId = nextExpiredRequestId;\r\n      (exists, nextExpiredRequestId) = assignedReports[policeNode].getAdjacent(nextExpiredRequestId, NEXT);\r\n      if (policeTimeouts[potentialExpiredRequestId] < block.number) {\r\n        assignedReports[policeNode].remove(potentialExpiredRequestId);\r\n        emit PoliceAssignmentExpiredAndCleared(potentialExpiredRequestId);\r\n        if (potentialExpiredRequestId == requestId) {\r\n          hasRemovedCurrentId = true;\r\n        }\r\n      } else {\r\n        break;\r\n      }\r\n      iterationsLeft -= 1;\r\n    }\r\n    return hasRemovedCurrentId;\r\n  }\r\n}\r\n\r\n// File: contracts/QuantstampAuditReportData.sol\r\n\r\ncontract QuantstampAuditReportData is Whitelist {\r\n\r\n  // mapping from requestId to a report\r\n  mapping(uint256 => bytes) public reports;\r\n\r\n  function setReport(uint256 requestId, bytes report) external onlyWhitelisted {\r\n    reports[requestId] = report;\r\n  }\r\n\r\n  function getReport(uint256 requestId) external view returns(bytes) {\r\n    return reports[requestId];\r\n  }\r\n\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/lifecycle/Pausable.sol\r\n\r\n/**\r\n * @title Pausable\r\n * @dev Base contract which allows children to implement an emergency stop mechanism.\r\n */\r\ncontract Pausable is Ownable {\r\n  event Pause();\r\n  event Unpause();\r\n\r\n  bool public paused = false;\r\n\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is not paused.\r\n   */\r\n  modifier whenNotPaused() {\r\n    require(!paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is paused.\r\n   */\r\n  modifier whenPaused() {\r\n    require(paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to pause, triggers stopped state\r\n   */\r\n  function pause() onlyOwner whenNotPaused public {\r\n    paused = true;\r\n    emit Pause();\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to unpause, returns to normal state\r\n   */\r\n  function unpause() onlyOwner whenPaused public {\r\n    paused = false;\r\n    emit Unpause();\r\n  }\r\n}\r\n\r\n// File: contracts/QuantstampAudit.sol\r\n\r\ncontract QuantstampAudit is Pausable {\r\n  using SafeMath for uint256;\r\n  using LinkedListLib for LinkedListLib.LinkedList;\r\n\r\n  // constants used by LinkedListLib\r\n  uint256 constant internal NULL = 0;\r\n  uint256 constant internal HEAD = 0;\r\n  bool constant internal PREV = false;\r\n  bool constant internal NEXT = true;\r\n\r\n  // mapping from an audit node address to the number of requests that it currently processes\r\n  mapping(address => uint256) public assignedRequestCount;\r\n\r\n  // increasingly sorted linked list of prices\r\n  LinkedListLib.LinkedList internal priceList;\r\n  // map from price to a list of request IDs\r\n  mapping(uint256 => LinkedListLib.LinkedList) internal auditsByPrice;\r\n\r\n  // list of request IDs of assigned audits (the list preserves temporal order of assignments)\r\n  LinkedListLib.LinkedList internal assignedAudits;\r\n\r\n  // stores request ids of the most recently assigned audits for each audit node\r\n  mapping(address => uint256) public mostRecentAssignedRequestIdsPerAuditor;\r\n\r\n  // contract that stores audit data (separate from the auditing logic)\r\n  QuantstampAuditData public auditData;\r\n\r\n  // contract that stores audit reports on-chain\r\n  QuantstampAuditReportData public reportData;\r\n\r\n  // contract that handles policing\r\n  QuantstampAuditPolice public police;\r\n\r\n  // contract that stores token escrows of nodes on the network\r\n  QuantstampAuditTokenEscrow public tokenEscrow;\r\n\r\n  event LogAuditFinished(\r\n    uint256 requestId,\r\n    address auditor,\r\n    QuantstampAuditData.AuditState auditResult,\r\n    bytes report\r\n  );\r\n\r\n  event LogPoliceAuditFinished(\r\n    uint256 requestId,\r\n    address policeNode,\r\n    bytes report,\r\n    bool isVerified\r\n  );\r\n\r\n  event LogAuditRequested(uint256 requestId,\r\n    address requestor,\r\n    string uri,\r\n    uint256 price\r\n  );\r\n\r\n  event LogAuditAssigned(uint256 requestId,\r\n    address auditor,\r\n    address requestor,\r\n    string uri,\r\n    uint256 price,\r\n    uint256 requestBlockNumber);\r\n\r\n  /* solhint-disable event-name-camelcase */\r\n  event LogReportSubmissionError_InvalidAuditor(uint256 requestId, address auditor);\r\n  event LogReportSubmissionError_InvalidState(uint256 requestId, address auditor, QuantstampAuditData.AuditState state);\r\n  event LogReportSubmissionError_InvalidResult(uint256 requestId, address auditor, QuantstampAuditData.AuditState state);\r\n  event LogReportSubmissionError_ExpiredAudit(uint256 requestId, address auditor, uint256 allowanceBlockNumber);\r\n  event LogAuditAssignmentError_ExceededMaxAssignedRequests(address auditor);\r\n  event LogAuditAssignmentError_Understaked(address auditor, uint256 stake);\r\n  event LogAuditAssignmentUpdate_Expired(uint256 requestId, uint256 allowanceBlockNumber);\r\n  event LogClaimRewardsReachedGasLimit(address auditor);\r\n\r\n  /* solhint-enable event-name-camelcase */\r\n\r\n  event LogAuditQueueIsEmpty();\r\n\r\n  event LogPayAuditor(uint256 requestId, address auditor, uint256 amount);\r\n  event LogAuditNodePriceChanged(address auditor, uint256 amount);\r\n\r\n  event LogRefund(uint256 requestId, address requestor, uint256 amount);\r\n  event LogRefundInvalidRequestor(uint256 requestId, address requestor);\r\n  event LogRefundInvalidState(uint256 requestId, QuantstampAuditData.AuditState state);\r\n  event LogRefundInvalidFundsLocked(uint256 requestId, uint256 currentBlock, uint256 fundLockEndBlock);\r\n\r\n  // the audit queue has elements, but none satisfy the minPrice of the audit node\r\n  // amount corresponds to the current minPrice of the audit node\r\n  event LogAuditNodePriceHigherThanRequests(address auditor, uint256 amount);\r\n\r\n  enum AuditAvailabilityState {\r\n    Error,\r\n    Ready,      // an audit is available to be picked up\r\n    Empty,      // there is no audit request in the queue\r\n    Exceeded,   // number of incomplete audit requests is reached the cap\r\n    Underpriced, // all queued audit requests are less than the expected price\r\n    Understaked // the audit node's stake is not large enough to request its min price\r\n  }\r\n\r\n  /**\r\n   * @dev The constructor creates an audit contract.\r\n   * @param auditDataAddress The address of an AuditData that stores data used for performing audits.\r\n   * @param reportDataAddress The address of a ReportData that stores audit reports.\r\n   * @param escrowAddress The address of a QuantstampTokenEscrow contract that holds staked deposits of nodes.\r\n   * @param policeAddress The address of a QuantstampAuditPolice that performs report checking.\r\n   */\r\n  constructor (address auditDataAddress, address reportDataAddress, address escrowAddress, address policeAddress) public {\r\n    require(auditDataAddress != address(0));\r\n    require(reportDataAddress != address(0));\r\n    require(escrowAddress != address(0));\r\n    require(policeAddress != address(0));\r\n    auditData = QuantstampAuditData(auditDataAddress);\r\n    reportData = QuantstampAuditReportData(reportDataAddress);\r\n    tokenEscrow = QuantstampAuditTokenEscrow(escrowAddress);\r\n    police = QuantstampAuditPolice(policeAddress);\r\n  }\r\n\r\n  /**\r\n   * @dev Allows nodes to stake a deposit. The audit node must approve QuantstampAudit before invoking.\r\n   * @param amount The amount of wei-QSP to deposit.\r\n   */\r\n  function stake(uint256 amount) external returns(bool) {\r\n    // first acquire the tokens approved by the audit node\r\n    require(auditData.token().transferFrom(msg.sender, address(this), amount));\r\n    // use those tokens to approve a transfer in the escrow\r\n    auditData.token().approve(address(tokenEscrow), amount);\r\n    // a \"Deposited\" event is emitted in TokenEscrow\r\n    tokenEscrow.deposit(msg.sender, amount);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows audit nodes to retrieve a deposit.\r\n   */\r\n  function unstake() external returns(bool) {\r\n    // the escrow contract ensures that the deposit is not currently locked\r\n    tokenEscrow.withdraw(msg.sender);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns funds to the requestor.\r\n   * @param requestId Unique ID of the audit request.\r\n   */\r\n  function refund(uint256 requestId) external returns(bool) {\r\n    QuantstampAuditData.AuditState state = auditData.getAuditState(requestId);\r\n    // check that the audit exists and is in a valid state\r\n    if (state != QuantstampAuditData.AuditState.Queued &&\r\n          state != QuantstampAuditData.AuditState.Assigned &&\r\n            state != QuantstampAuditData.AuditState.Expired) {\r\n      emit LogRefundInvalidState(requestId, state);\r\n      return false;\r\n    }\r\n    address requestor = auditData.getAuditRequestor(requestId);\r\n    if (requestor != msg.sender) {\r\n      emit LogRefundInvalidRequestor(requestId, msg.sender);\r\n      return;\r\n    }\r\n    uint256 refundBlockNumber = auditData.getAuditAssignBlockNumber(requestId).add(auditData.auditTimeoutInBlocks());\r\n    // check that the audit node has not recently started the audit (locking the funds)\r\n    if (state == QuantstampAuditData.AuditState.Assigned) {\r\n      if (block.number <= refundBlockNumber) {\r\n        emit LogRefundInvalidFundsLocked(requestId, block.number, refundBlockNumber);\r\n        return false;\r\n      }\r\n      // the request is expired but not detected by getNextAuditRequest\r\n      updateAssignedAudits(requestId);\r\n    } else if (state == QuantstampAuditData.AuditState.Queued) {\r\n      // remove the request from the queue\r\n      // note that if an audit node is currently assigned the request, it is already removed from the queue\r\n      removeQueueElement(requestId);\r\n    }\r\n\r\n    // set the audit state to refunded\r\n    auditData.setAuditState(requestId, QuantstampAuditData.AuditState.Refunded);\r\n\r\n    // return the funds to the requestor\r\n    uint256 price = auditData.getAuditPrice(requestId);\r\n    emit LogRefund(requestId, requestor, price);\r\n    safeTransferFromDataContract(requestor, price);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Submits audit request.\r\n   * @param contractUri Identifier of the resource to audit.\r\n   * @param price The total amount of tokens that will be paid for the audit.\r\n   */\r\n  function requestAudit(string contractUri, uint256 price) public returns(uint256) {\r\n    // it passes HEAD as the existing price, therefore may result in extra gas needed for list iteration\r\n    return requestAuditWithPriceHint(contractUri, price, HEAD);\r\n  }\r\n\r\n  /**\r\n   * @dev Submits audit request.\r\n   * @param contractUri Identifier of the resource to audit.\r\n   * @param price The total amount of tokens that will be paid for the audit.\r\n   * @param existingPrice Existing price in the list (price hint allows for optimization that can make insertion O(1)).\r\n   */\r\n  function requestAuditWithPriceHint(string contractUri, uint256 price, uint256 existingPrice) public whenNotPaused returns(uint256) {\r\n    require(price > 0);\r\n    // transfer tokens to the data contract\r\n    require(auditData.token().transferFrom(msg.sender, address(auditData), price));\r\n    // store the audit\r\n    uint256 requestId = auditData.addAuditRequest(msg.sender, contractUri, price);\r\n\r\n    queueAuditRequest(requestId, existingPrice);\r\n\r\n    emit LogAuditRequested(requestId, msg.sender, contractUri, price); // solhint-disable-line not-rely-on-time\r\n\r\n    return requestId;\r\n  }\r\n\r\n  /**\r\n   * @dev Submits the report and pays the audit node for their work if the audit is completed.\r\n   * @param requestId Unique identifier of the audit request.\r\n   * @param auditResult Result of an audit.\r\n   * @param report a compressed report. TODO, let's document the report format.\r\n   */\r\n  function submitReport(uint256 requestId, QuantstampAuditData.AuditState auditResult, bytes report) public { // solhint-disable-line function-max-lines\r\n    if (QuantstampAuditData.AuditState.Completed != auditResult && QuantstampAuditData.AuditState.Error != auditResult) {\r\n      emit LogReportSubmissionError_InvalidResult(requestId, msg.sender, auditResult);\r\n      return;\r\n    }\r\n\r\n    QuantstampAuditData.AuditState auditState = auditData.getAuditState(requestId);\r\n    if (auditState != QuantstampAuditData.AuditState.Assigned) {\r\n      emit LogReportSubmissionError_InvalidState(requestId, msg.sender, auditState);\r\n      return;\r\n    }\r\n\r\n    // the sender must be the audit node\r\n    if (msg.sender != auditData.getAuditAuditor(requestId)) {\r\n      emit LogReportSubmissionError_InvalidAuditor(requestId, msg.sender);\r\n      return;\r\n    }\r\n\r\n    // remove the requestId from assigned queue\r\n    updateAssignedAudits(requestId);\r\n\r\n    // the audit node should not send a report after its allowed period\r\n    uint256 allowanceBlockNumber = auditData.getAuditAssignBlockNumber(requestId) + auditData.auditTimeoutInBlocks();\r\n    if (allowanceBlockNumber < block.number) {\r\n      // update assigned to expired state\r\n      auditData.setAuditState(requestId, QuantstampAuditData.AuditState.Expired);\r\n      emit LogReportSubmissionError_ExpiredAudit(requestId, msg.sender, allowanceBlockNumber);\r\n      return;\r\n    }\r\n\r\n    // update the audit information held in this contract\r\n    auditData.setAuditState(requestId, auditResult);\r\n    auditData.setAuditReportBlockNumber(requestId, block.number); // solhint-disable-line not-rely-on-time\r\n\r\n    // validate the audit state\r\n    require(isAuditFinished(requestId));\r\n\r\n    // store reports on-chain\r\n    reportData.setReport(requestId, report);\r\n\r\n    emit LogAuditFinished(requestId, msg.sender, auditResult, report);\r\n\r\n    // alert the police to verify the report\r\n    police.assignPoliceToReport(requestId);\r\n    // add the requestId to the pending payments that should be paid to the audit node after policing\r\n    police.addPendingPayment(msg.sender, requestId);\r\n    // pay fee to the police\r\n    if (police.reportProcessingFeePercentage() > 0 && police.numPoliceNodes() > 0) {\r\n      uint256 policeFee = police.collectFee(requestId);\r\n      safeTransferFromDataContract(address(police), policeFee);\r\n      police.splitPayment(policeFee);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the compressed report submitted by the audit node.\r\n   * @param requestId The ID of the audit request.\r\n   */\r\n  function getReport(uint256 requestId) public view returns (bytes) {\r\n    return reportData.getReport(requestId);\r\n  }\r\n\r\n  /**\r\n   * @dev Checks whether a given node is a police.\r\n   * @param node The address of the node to be checked.\r\n   * @return true if the target address is a police node.\r\n   */\r\n  function isPoliceNode(address node) public view returns(bool) {\r\n    return police.isPoliceNode(node);\r\n  }\r\n\r\n  /**\r\n   * @dev Submits verification of a report by a police node.\r\n   * @param requestId The ID of the audit request.\r\n   * @param report The compressed bytecode representation of the report.\r\n   * @param isVerified Whether the police node's report matches the submitted report.\r\n   *                   If not, the audit node is slashed.\r\n   * @return true if the report was submitted successfully.\r\n   */\r\n  function submitPoliceReport(\r\n    uint256 requestId,\r\n    bytes report,\r\n    bool isVerified) public returns (bool) {\r\n    require(police.isPoliceNode(msg.sender));\r\n    // get the address of the audit node\r\n    address auditNode = auditData.getAuditAuditor(requestId);\r\n    bool hasBeenSubmitted;\r\n    bool slashOccurred;\r\n    uint256 slashAmount;\r\n    // hasBeenSubmitted may be false if the police submission period has ended\r\n    (hasBeenSubmitted, slashOccurred, slashAmount) = police.submitPoliceReport(msg.sender, auditNode, requestId, report, isVerified);\r\n    if (hasBeenSubmitted) {\r\n      emit LogPoliceAuditFinished(requestId, msg.sender, report, isVerified);\r\n    }\r\n    if (slashOccurred) {\r\n      // transfer the audit request price to the police\r\n      uint256 auditPoliceFee = police.collectedFees(requestId);\r\n      uint256 adjustedPrice = auditData.getAuditPrice(requestId).sub(auditPoliceFee);\r\n      safeTransferFromDataContract(address(police), adjustedPrice);\r\n\r\n      // divide the adjusted price + slash among police assigned to report\r\n      police.splitPayment(adjustedPrice.add(slashAmount));\r\n    }\r\n    return hasBeenSubmitted;\r\n  }\r\n\r\n  /**\r\n   * @dev Determines whether the address (of an audit node) can claim any audit rewards.\r\n   */\r\n  function hasAvailableRewards () public view returns (bool) {\r\n    bool exists;\r\n    uint256 next;\r\n    (exists, next) = police.getNextAvailableReward(msg.sender, HEAD);\r\n    return exists;\r\n  }\r\n\r\n  /**\r\n   * @dev Given a requestId, returns the next pending available reward for the audit node.\r\n   *      This can be used in conjunction with claimReward() if claimRewards fails due to gas limits.\r\n   * @param requestId The ID of the current linked list node\r\n   * @return true if the next reward exists, and the corresponding requestId in the linked list\r\n   */\r\n  function getNextAvailableReward (uint256 requestId) public view returns(bool, uint256) {\r\n    return police.getNextAvailableReward(msg.sender, requestId);\r\n  }\r\n\r\n  /**\r\n   * @dev If the policing period has ended without the report being marked invalid,\r\n   *      allow the audit node to claim the audit's reward.\r\n   * @param requestId The ID of the audit request.\r\n   * NOTE: We need this function if claimRewards always fails due to gas limits.\r\n   *       I think this can only happen if the audit node receives many (i.e., hundreds) of audits,\r\n   *       and never calls claimRewards() until much later.\r\n   */\r\n  function claimReward (uint256 requestId) public returns (bool) {\r\n    require(police.canClaimAuditReward(msg.sender, requestId));\r\n    police.setRewardClaimed(msg.sender, requestId);\r\n    transferReward(requestId);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Claim all pending rewards for the audit node.\r\n   * @return Returns true if the operation ran to completion, or false if the loop exits due to gas limits.\r\n   */\r\n  function claimRewards () public returns (bool) {\r\n    // Yet another list iteration. Could ignore this check, but makes testing painful.\r\n    require(hasAvailableRewards());\r\n    bool exists;\r\n    uint256 requestId = HEAD;\r\n    uint256 remainingGasBeforeCall;\r\n    uint256 remainingGasAfterCall;\r\n    bool loopExitedDueToGasLimit;\r\n    // This loop occurs here (not in QuantstampAuditPolice) due to requiring the audit price,\r\n    // as otherwise we require more dependencies/mappings in QuantstampAuditPolice.\r\n    while (true) {\r\n      remainingGasBeforeCall = gasleft();\r\n      (exists, requestId) = police.claimNextReward(msg.sender, HEAD);\r\n      if (!exists) {\r\n        break;\r\n      }\r\n      transferReward(requestId);\r\n      remainingGasAfterCall = gasleft();\r\n      // multiplying by 2 to leave a bit of extra leeway, particularly due to the while-loop in claimNextReward\r\n      if (remainingGasAfterCall < remainingGasBeforeCall.sub(remainingGasAfterCall).mul(2)) {\r\n        loopExitedDueToGasLimit = true;\r\n        emit LogClaimRewardsReachedGasLimit(msg.sender);\r\n        break;\r\n      }\r\n    }\r\n    return loopExitedDueToGasLimit;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the total stake deposited by an address.\r\n   * @param addr The address to check.\r\n   */\r\n  function totalStakedFor(address addr) public view returns(uint256) {\r\n    return tokenEscrow.depositsOf(addr);\r\n  }\r\n\r\n  /**\r\n   * @dev Returns true if the sender staked enough.\r\n   * @param addr The address to check.\r\n   */\r\n  function hasEnoughStake(address addr) public view returns(bool) {\r\n    return tokenEscrow.hasEnoughStake(addr);\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the minimum stake required to be an audit node.\r\n   */\r\n  function getMinAuditStake() public view returns(uint256) {\r\n    return tokenEscrow.minAuditStake();\r\n  }\r\n\r\n  /**\r\n   *  @dev Returns the timeout time (in blocks) for any given audit.\r\n   */\r\n  function getAuditTimeoutInBlocks() public view returns(uint256) {\r\n    return auditData.auditTimeoutInBlocks();\r\n  }\r\n\r\n  /**\r\n   *  @dev Returns the minimum price for a specific audit node.\r\n   */\r\n  function getMinAuditPrice (address auditor) public view returns(uint256) {\r\n    return auditData.getMinAuditPrice(auditor);\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the maximum number of assigned audits for any given audit node.\r\n   */\r\n  function getMaxAssignedRequests() public view returns(uint256) {\r\n    return auditData.maxAssignedRequests();\r\n  }\r\n\r\n  /**\r\n   * @dev Determines if there is an audit request available to be picked up by the caller.\r\n   */\r\n  function anyRequestAvailable() public view returns(AuditAvailabilityState) {\r\n    uint256 requestId;\r\n\r\n    // check that the audit node's stake is large enough\r\n    if (!hasEnoughStake(msg.sender)) {\r\n      return AuditAvailabilityState.Understaked;\r\n    }\r\n\r\n    // there are no audits in the queue\r\n    if (!auditQueueExists()) {\r\n      return AuditAvailabilityState.Empty;\r\n    }\r\n\r\n    // check if the audit node's assignment count is not exceeded\r\n    if (assignedRequestCount[msg.sender] >= auditData.maxAssignedRequests()) {\r\n      return AuditAvailabilityState.Exceeded;\r\n    }\r\n\r\n    requestId = anyAuditRequestMatchesPrice(auditData.getMinAuditPrice(msg.sender));\r\n    if (requestId == 0) {\r\n      return AuditAvailabilityState.Underpriced;\r\n    }\r\n    return AuditAvailabilityState.Ready;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the next assigned report in a police node's assignment queue.\r\n   * @return true if the list is non-empty, requestId, auditPrice, uri, and policeAssignmentBlockNumber.\r\n   */\r\n  function getNextPoliceAssignment() public view returns (bool, uint256, uint256, string, uint256) {\r\n    return police.getNextPoliceAssignment(msg.sender);\r\n  }\r\n\r\n  /**\r\n   * @dev Finds a list of most expensive audits and assigns the oldest one to the audit node.\r\n   */\r\n  /* solhint-disable function-max-lines */\r\n  function getNextAuditRequest() public {\r\n    // remove an expired audit request\r\n    if (assignedAudits.listExists()) {\r\n      bool exists;\r\n      uint256 potentialExpiredRequestId;\r\n      (exists, potentialExpiredRequestId) = assignedAudits.getAdjacent(HEAD, NEXT);\r\n      uint256 allowanceBlockNumber = auditData.getAuditAssignBlockNumber(potentialExpiredRequestId) + auditData.auditTimeoutInBlocks();\r\n      if (allowanceBlockNumber < block.number) {\r\n        updateAssignedAudits(potentialExpiredRequestId);\r\n        auditData.setAuditState(potentialExpiredRequestId, QuantstampAuditData.AuditState.Expired);\r\n        emit LogAuditAssignmentUpdate_Expired(potentialExpiredRequestId, allowanceBlockNumber);\r\n      }\r\n    }\r\n\r\n    AuditAvailabilityState isRequestAvailable = anyRequestAvailable();\r\n    // there are no audits in the queue\r\n    if (isRequestAvailable == AuditAvailabilityState.Empty) {\r\n      emit LogAuditQueueIsEmpty();\r\n      return;\r\n    }\r\n\r\n    // check if the audit node's assignment is not exceeded\r\n    if (isRequestAvailable == AuditAvailabilityState.Exceeded) {\r\n      emit LogAuditAssignmentError_ExceededMaxAssignedRequests(msg.sender);\r\n      return;\r\n    }\r\n\r\n    uint256 minPrice = auditData.getMinAuditPrice(msg.sender);\r\n\r\n    // check that the audit node has staked enough QSP\r\n    if (isRequestAvailable == AuditAvailabilityState.Understaked) {\r\n      emit LogAuditAssignmentError_Understaked(msg.sender, totalStakedFor(msg.sender));\r\n      return;\r\n    }\r\n\r\n    // there are no audits in the queue with a price high enough for the audit node\r\n    uint256 requestId = dequeueAuditRequest(minPrice);\r\n    if (requestId == 0) {\r\n      emit LogAuditNodePriceHigherThanRequests(msg.sender, minPrice);\r\n      return;\r\n    }\r\n\r\n    auditData.setAuditState(requestId, QuantstampAuditData.AuditState.Assigned);\r\n    auditData.setAuditAuditor(requestId, msg.sender);\r\n    auditData.setAuditAssignBlockNumber(requestId, block.number);\r\n    assignedRequestCount[msg.sender]++;\r\n    // push to the tail\r\n    assignedAudits.push(requestId, PREV);\r\n\r\n    // lock stake when assigned\r\n    tokenEscrow.lockFunds(msg.sender, block.number.add(auditData.auditTimeoutInBlocks()).add(police.policeTimeoutInBlocks()));\r\n\r\n    mostRecentAssignedRequestIdsPerAuditor[msg.sender] = requestId;\r\n    emit LogAuditAssigned(requestId,\r\n      auditData.getAuditAuditor(requestId),\r\n      auditData.getAuditRequestor(requestId),\r\n      auditData.getAuditContractUri(requestId),\r\n      auditData.getAuditPrice(requestId),\r\n      auditData.getAuditRequestBlockNumber(requestId));\r\n  }\r\n  /* solhint-enable function-max-lines */\r\n\r\n  /**\r\n   * @dev Allows the audit node to set its minimum price per audit in wei-QSP.\r\n   * @param price The minimum price.\r\n   */\r\n  function setAuditNodePrice(uint256 price) public {\r\n    require(price <= auditData.token().totalSupply());\r\n    auditData.setMinAuditPrice(msg.sender, price);\r\n    emit LogAuditNodePriceChanged(msg.sender, price);\r\n  }\r\n\r\n  /**\r\n   * @dev Checks if an audit is finished. It is considered finished when the audit is either completed or failed.\r\n   * @param requestId Unique ID of the audit request.\r\n   */\r\n  function isAuditFinished(uint256 requestId) public view returns(bool) {\r\n    QuantstampAuditData.AuditState state = auditData.getAuditState(requestId);\r\n    return state == QuantstampAuditData.AuditState.Completed || state == QuantstampAuditData.AuditState.Error;\r\n  }\r\n\r\n  /**\r\n   * @dev Given a price, returns the next price from the priceList.\r\n   * @param price A price indicated by a node in priceList.\r\n   * @return The next price in the linked list.\r\n   */\r\n  function getNextPrice(uint256 price) public view returns(uint256) {\r\n    bool exists;\r\n    uint256 next;\r\n    (exists, next) = priceList.getAdjacent(price, NEXT);\r\n    return next;\r\n  }\r\n\r\n  /**\r\n   * @dev Given a requestId, returns the next one from assignedAudits.\r\n   * @param requestId The ID of the current linked list node\r\n   * @return next requestId in the linked list\r\n   */\r\n  function getNextAssignedRequest(uint256 requestId) public view returns(uint256) {\r\n    bool exists;\r\n    uint256 next;\r\n    (exists, next) = assignedAudits.getAdjacent(requestId, NEXT);\r\n    return next;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the audit request most recently assigned to msg.sender.\r\n   * @return A tuple (requestId, audit_uri, audit_price, request_block_number).\r\n   */\r\n  function myMostRecentAssignedAudit() public view returns(\r\n    uint256, // requestId\r\n    address, // requestor\r\n    string,  // contract uri\r\n    uint256, // price\r\n    uint256  // request block number\r\n  ) {\r\n    uint256 requestId = mostRecentAssignedRequestIdsPerAuditor[msg.sender];\r\n    return (\r\n      requestId,\r\n      auditData.getAuditRequestor(requestId),\r\n      auditData.getAuditContractUri(requestId),\r\n      auditData.getAuditPrice(requestId),\r\n      auditData.getAuditRequestBlockNumber(requestId)\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @dev Given a price and a requestId, the function returns the next requestId with the same price.\r\n   * Return 0, provided the given price does not exist in auditsByPrice.\r\n   * @param price The price value of the current bucket.\r\n   * @param requestId Unique Id of a requested audit.\r\n   * @return The next requestId with the same price.\r\n   */\r\n  function getNextAuditByPrice(uint256 price, uint256 requestId) public view returns(uint256) {\r\n    bool exists;\r\n    uint256 next;\r\n    (exists, next) = auditsByPrice[price].getAdjacent(requestId, NEXT);\r\n    return next;\r\n  }\r\n\r\n  /**\r\n   * @dev Given a price finds where it should be placed to build a sorted list.\r\n   * @return next First existing price higher than the passed price.\r\n   */\r\n  function findPrecedingPrice(uint256 price) public view returns(uint256) {\r\n    return priceList.getSortedSpot(HEAD, price, NEXT);\r\n  }\r\n\r\n  /**\r\n   * @dev Given a requestId, the function removes it from the list of audits and decreases the number of assigned\r\n   * audits of the associated audit node.\r\n   * @param requestId Unique ID of a requested audit.\r\n   */\r\n  function updateAssignedAudits(uint256 requestId) internal {\r\n    assignedAudits.remove(requestId);\r\n    assignedRequestCount[auditData.getAuditAuditor(requestId)] =\r\n      assignedRequestCount[auditData.getAuditAuditor(requestId)].sub(1);\r\n  }\r\n\r\n  /**\r\n   * @dev Checks if the list of audits has any elements.\r\n   */\r\n  function auditQueueExists() internal view returns(bool) {\r\n    return priceList.listExists();\r\n  }\r\n\r\n  /**\r\n   * @dev Adds an audit request to the queue.\r\n   * @param requestId Request ID.\r\n   * @param existingPrice The price of an existing audit in the queue (makes insertion O(1)).\r\n   */\r\n  function queueAuditRequest(uint256 requestId, uint256 existingPrice) internal {\r\n    uint256 price = auditData.getAuditPrice(requestId);\r\n    if (!priceList.nodeExists(price)) {\r\n      uint256 priceHint = priceList.nodeExists(existingPrice) ? existingPrice : HEAD;\r\n      // if a price bucket doesn't exist, create it next to an existing one\r\n      priceList.insert(priceList.getSortedSpot(priceHint, price, NEXT), price, PREV);\r\n    }\r\n    // push to the tail\r\n    auditsByPrice[price].push(requestId, PREV);\r\n  }\r\n\r\n  /**\r\n   * @dev Evaluates if there is an audit price >= minPrice.\r\n   * Note that there should not be any audit with price as 0.\r\n   * @param minPrice The minimum audit price.\r\n   * @return The requestId of an audit adhering to the minPrice, or 0 if no such audit exists.\r\n   */\r\n  function anyAuditRequestMatchesPrice(uint256 minPrice) internal view returns(uint256) {\r\n    bool priceExists;\r\n    uint256 price;\r\n    uint256 requestId;\r\n\r\n    // picks the tail of price buckets\r\n    (priceExists, price) = priceList.getAdjacent(HEAD, PREV);\r\n    if (price < minPrice) {\r\n      return 0;\r\n    }\r\n    requestId = getNextAuditByPrice(price, HEAD);\r\n    return requestId;\r\n  }\r\n\r\n  /**\r\n   * @dev Finds a list of most expensive audits and returns the oldest one that has a price >= minPrice.\r\n   * @param minPrice The minimum audit price.\r\n   */\r\n  function dequeueAuditRequest(uint256 minPrice) internal returns(uint256) {\r\n\r\n    uint256 requestId;\r\n    uint256 price;\r\n\r\n    // picks the tail of price buckets\r\n    // TODO seems the following statement is redundantly called from getNextAuditRequest. If this is the only place\r\n    // to call dequeueAuditRequest, then removing the following line saves gas, but leaves dequeueAuditRequest\r\n    // unsafe for further extension.\r\n    requestId = anyAuditRequestMatchesPrice(minPrice);\r\n\r\n    if (requestId > 0) {\r\n      price = auditData.getAuditPrice(requestId);\r\n      auditsByPrice[price].remove(requestId);\r\n      // removes the price bucket if it contains no requests\r\n      if (!auditsByPrice[price].listExists()) {\r\n        priceList.remove(price);\r\n      }\r\n      return requestId;\r\n    }\r\n    return 0;\r\n  }\r\n\r\n  /**\r\n   * @dev Removes an element from the list.\r\n   * @param requestId The Id of the request to be removed.\r\n   */\r\n  function removeQueueElement(uint256 requestId) internal {\r\n    uint256 price = auditData.getAuditPrice(requestId);\r\n\r\n    // the node must exist in the list\r\n    require(priceList.nodeExists(price));\r\n    require(auditsByPrice[price].nodeExists(requestId));\r\n\r\n    auditsByPrice[price].remove(requestId);\r\n    if (!auditsByPrice[price].listExists()) {\r\n      priceList.remove(price);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Internal helper function to perform the transfer of rewards.\r\n   * @param requestId The ID of the audit request.\r\n   */\r\n  function transferReward (uint256 requestId) internal {\r\n    uint256 auditPoliceFee = police.collectedFees(requestId);\r\n    uint256 auditorPayment = auditData.getAuditPrice(requestId).sub(auditPoliceFee);\r\n    safeTransferFromDataContract(msg.sender, auditorPayment);\r\n    emit LogPayAuditor(requestId, msg.sender, auditorPayment);\r\n  }\r\n\r\n  /**\r\n   * @dev Used to transfer funds stored in the data contract to a given address.\r\n   * @param _to The address to transfer funds.\r\n   * @param amount The number of wei-QSP to be transferred.\r\n   */\r\n  function safeTransferFromDataContract(address _to, uint256 amount) internal {\r\n    auditData.approveWhitelisted(amount);\r\n    require(auditData.token().transferFrom(address(auditData), _to, amount));\r\n  }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"reportData\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"requestId\",\"type\":\"uint256\"}],\"name\":\"isAuditFinished\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"setAuditNodePrice\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"contractUri\",\"type\":\"string\"},{\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"requestAudit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"requestId\",\"type\":\"uint256\"}],\"name\":\"refund\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"price\",\"type\":\"uint256\"},{\"name\":\"requestId\",\"type\":\"uint256\"}],\"name\":\"getNextAuditByPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unstake\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"myMostRecentAssignedAudit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"string\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"mostRecentAssignedRequestIdsPerAuditor\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"requestId\",\"type\":\"uint256\"},{\"name\":\"report\",\"type\":\"bytes\"},{\"name\":\"isVerified\",\"type\":\"bool\"}],\"name\":\"submitPoliceReport\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claimRewards\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"contractUri\",\"type\":\"string\"},{\"name\":\"price\",\"type\":\"uint256\"},{\"name\":\"existingPrice\",\"type\":\"uint256\"}],\"name\":\"requestAuditWithPriceHint\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"totalStakedFor\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"requestId\",\"type\":\"uint256\"}],\"name\":\"getReport\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"requestId\",\"type\":\"uint256\"}],\"name\":\"getNextAvailableReward\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"requestId\",\"type\":\"uint256\"}],\"name\":\"getNextAssignedRequest\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"auditData\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"anyRequestAvailable\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"hasEnoughStake\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getMaxAssignedRequests\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAuditTimeoutInBlocks\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"getNextPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getMinAuditStake\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"hasAvailableRewards\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"stake\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenEscrow\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"requestId\",\"type\":\"uint256\"}],\"name\":\"claimReward\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"getNextAuditRequest\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"police\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"assignedRequestCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"requestId\",\"type\":\"uint256\"},{\"name\":\"auditResult\",\"type\":\"uint8\"},{\"name\":\"report\",\"type\":\"bytes\"}],\"name\":\"submitReport\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"findPrecedingPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"node\",\"type\":\"address\"}],\"name\":\"isPoliceNode\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getNextPoliceAssignment\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"string\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"auditor\",\"type\":\"address\"}],\"name\":\"getMinAuditPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"auditDataAddress\",\"type\":\"address\"},{\"name\":\"reportDataAddress\",\"type\":\"address\"},{\"name\":\"escrowAddress\",\"type\":\"address\"},{\"name\":\"policeAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"requestId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"auditor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"auditResult\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"report\",\"type\":\"bytes\"}],\"name\":\"LogAuditFinished\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"requestId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"policeNode\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"report\",\"type\":\"bytes\"},{\"indexed\":false,\"name\":\"isVerified\",\"type\":\"bool\"}],\"name\":\"LogPoliceAuditFinished\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"requestId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"requestor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"uri\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"LogAuditRequested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"requestId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"auditor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"requestor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"uri\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"price\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"requestBlockNumber\",\"type\":\"uint256\"}],\"name\":\"LogAuditAssigned\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"requestId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"auditor\",\"type\":\"address\"}],\"name\":\"LogReportSubmissionError_InvalidAuditor\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"requestId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"auditor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"state\",\"type\":\"uint8\"}],\"name\":\"LogReportSubmissionError_InvalidState\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"requestId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"auditor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"state\",\"type\":\"uint8\"}],\"name\":\"LogReportSubmissionError_InvalidResult\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"requestId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"auditor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"allowanceBlockNumber\",\"type\":\"uint256\"}],\"name\":\"LogReportSubmissionError_ExpiredAudit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"auditor\",\"type\":\"address\"}],\"name\":\"LogAuditAssignmentError_ExceededMaxAssignedRequests\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"auditor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"stake\",\"type\":\"uint256\"}],\"name\":\"LogAuditAssignmentError_Understaked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"requestId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"allowanceBlockNumber\",\"type\":\"uint256\"}],\"name\":\"LogAuditAssignmentUpdate_Expired\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"auditor\",\"type\":\"address\"}],\"name\":\"LogClaimRewardsReachedGasLimit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"LogAuditQueueIsEmpty\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"requestId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"auditor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"LogPayAuditor\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"auditor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"LogAuditNodePriceChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"requestId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"requestor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"LogRefund\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"requestId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"requestor\",\"type\":\"address\"}],\"name\":\"LogRefundInvalidRequestor\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"requestId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"state\",\"type\":\"uint8\"}],\"name\":\"LogRefundInvalidState\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"requestId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"currentBlock\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"fundLockEndBlock\",\"type\":\"uint256\"}],\"name\":\"LogRefundInvalidFundsLocked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"auditor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"LogAuditNodePriceHigherThanRequests\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"}],\"name\":\"OwnershipRenounced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"QuantstampAudit","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000fcbc318314aae617cf58c2d13a9ee48be0e4c3700000000000000000000000005d7213b2fd42d5cc86a4d3a180a8f8f600ac95c800000000000000000000000051397c286a6399b4dd1fb8c221be94562d6951cb00000000000000000000000059523b19e6614f9e6acede42100619458ee01eab","Library":"LinkedListLib:697E2033BA28C1cC9E28d94ca910cA53a978aaD0","SwarmSource":"bzzr://e04c5101bb8651b78edd64806e80f884b6bf54fb4d04f5e0c2847266e42e9b36"}]}