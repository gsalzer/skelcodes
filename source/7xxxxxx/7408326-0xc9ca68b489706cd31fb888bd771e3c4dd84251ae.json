{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.2;\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n     * account.\r\n     */\r\n    constructor () internal {\r\n        _owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), _owner);\r\n    }\r\n\r\n    /**\r\n     * @return the address of the owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner());\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @return true if `msg.sender` is the owner of the contract.\r\n     */\r\n    function isOwner() public view returns (bool) {\r\n        return msg.sender == _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to relinquish control of the contract.\r\n     * It will not be possible to call the functions with the `onlyOwner`\r\n     * modifier anymore.\r\n     * @notice Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0));\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\n/**\r\n * @title Roles\r\n * @dev Library for managing addresses assigned to a Role.\r\n */\r\nlibrary Roles {\r\n    struct Role {\r\n        mapping (address => bool) bearer;\r\n    }\r\n\r\n    /**\r\n     * @dev give an account access to this role\r\n     */\r\n    function add(Role storage role, address account) internal {\r\n        require(account != address(0));\r\n        require(!has(role, account));\r\n\r\n        role.bearer[account] = true;\r\n    }\r\n\r\n    /**\r\n     * @dev remove an account's access to this role\r\n     */\r\n    function remove(Role storage role, address account) internal {\r\n        require(account != address(0));\r\n        require(has(role, account));\r\n\r\n        role.bearer[account] = false;\r\n    }\r\n\r\n    /**\r\n     * @dev check if an account has this role\r\n     * @return bool\r\n     */\r\n    function has(Role storage role, address account) internal view returns (bool) {\r\n        require(account != address(0));\r\n        return role.bearer[account];\r\n    }\r\n}\r\n\r\ncontract PauserRole {\r\n    using Roles for Roles.Role;\r\n\r\n    event PauserAdded(address indexed account);\r\n    event PauserRemoved(address indexed account);\r\n\r\n    Roles.Role private _pausers;\r\n\r\n    constructor () internal {\r\n        _addPauser(msg.sender);\r\n    }\r\n\r\n    modifier onlyPauser() {\r\n        require(isPauser(msg.sender));\r\n        _;\r\n    }\r\n\r\n    function isPauser(address account) public view returns (bool) {\r\n        return _pausers.has(account);\r\n    }\r\n\r\n    function addPauser(address account) public onlyPauser {\r\n        _addPauser(account);\r\n    }\r\n\r\n    function renouncePauser() public {\r\n        _removePauser(msg.sender);\r\n    }\r\n\r\n    function _addPauser(address account) internal {\r\n        _pausers.add(account);\r\n        emit PauserAdded(account);\r\n    }\r\n\r\n    function _removePauser(address account) internal {\r\n        _pausers.remove(account);\r\n        emit PauserRemoved(account);\r\n    }\r\n}\r\n\r\n/**\r\n * @title Pausable\r\n * @dev Base contract which allows children to implement an emergency stop mechanism.\r\n */\r\ncontract Pausable is PauserRole {\r\n    event Paused(address account);\r\n    event Unpaused(address account);\r\n\r\n    bool private _paused;\r\n\r\n    constructor () internal {\r\n        _paused = false;\r\n    }\r\n\r\n    /**\r\n     * @return true if the contract is paused, false otherwise.\r\n     */\r\n    function paused() public view returns (bool) {\r\n        return _paused;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to make a function callable only when the contract is not paused.\r\n     */\r\n    modifier whenNotPaused() {\r\n        require(!_paused);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to make a function callable only when the contract is paused.\r\n     */\r\n    modifier whenPaused() {\r\n        require(_paused);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev called by the owner to pause, triggers stopped state\r\n     */\r\n    function pause() public onlyPauser whenNotPaused {\r\n        _paused = true;\r\n        emit Paused(msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @dev called by the owner to unpause, returns to normal state\r\n     */\r\n    function unpause() public onlyPauser whenPaused {\r\n        _paused = false;\r\n        emit Unpaused(msg.sender);\r\n    }\r\n}\r\n\r\n/** @title ProofBox. */\r\ncontract ProofBox is Ownable, Pausable {\r\n\r\n    struct Device {\r\n      uint index;\r\n      address deviceOwner;\r\n      address txOriginator;\r\n\r\n    }\r\n\r\n    mapping (bytes32 => Device) private deviceMap;\r\n    mapping (address => bool) public authorized;\r\n    bytes32[] public deviceIds;\r\n\r\n\r\n\r\n    event deviceCreated(bytes32 indexed deviceId, address indexed deviceOwner);\r\n    event txnCreated(bytes32 indexed deviceId, address indexed txnOriginator);\r\n    event deviceProof(bytes32 indexed deviceId, address indexed deviceOwner);\r\n    event deviceTransfer(bytes32 indexed deviceId, address indexed fromOwner, address indexed toOwner);\r\n    event deviceMessage(bytes32 indexed deviceId, address indexed deviceOwner, address indexed txnOriginator, string messageToWrite);\r\n    event deviceDestruct(bytes32 indexed deviceId, address indexed deviceOwner);\r\n    event ipfsHashtoAddress(bytes32 indexed deviceId, address indexed ownerAddress, string ipfskey);\r\n\r\n\r\n\r\n    /** @dev Checks to see if device exist\r\n      * @param _deviceId ID of the device.\r\n      * @return isIndeed True if the device ID exists.\r\n      */\r\n    function isDeviceId(bytes32 _deviceId)\r\n       public\r\n       view\r\n       returns(bool isIndeed)\r\n     {\r\n       if(deviceIds.length == 0) return false;\r\n       return (deviceIds[deviceMap[_deviceId].index] == _deviceId);\r\n     }\r\n\r\n    /** @dev returns the index of stored deviceID\r\n      * @param _deviceId ID of the device.\r\n      * @return _index index of the device.\r\n      */\r\n    function getDeviceId(bytes32 _deviceId)\r\n       public\r\n       view\r\n       deviceIdExist(_deviceId)\r\n       returns(uint _index)\r\n     {\r\n       return deviceMap[_deviceId].index;\r\n     }\r\n\r\n     /** @dev returns address of device owner\r\n       * @param _deviceId ID of the device.\r\n       * @return deviceOwner device owner's address\r\n       */\r\n      function getOwnerByDevice(bytes32 _deviceId)\r\n           public\r\n           view\r\n           returns (address deviceOwner){\r\n\r\n               return deviceMap[_deviceId].deviceOwner;\r\n\r\n      }\r\n\r\n      /** @dev returns up to 10 devices for the device owner\r\n        * @return _deviceIds device ID's of the owner\r\n        */\r\n      function getDevicesByOwner(bytes32 _message, uint8 _v, bytes32 _r, bytes32 _s)\r\n              public\r\n              view\r\n              returns(bytes32[10] memory _deviceIds) {\r\n\r\n          address signer = ecrecover(_message, _v, _r, _s);\r\n          uint numDevices;\r\n          bytes32[10] memory devicesByOwner;\r\n\r\n          for(uint i = 0; i < deviceIds.length; i++) {\r\n\r\n              if(addressEqual(deviceMap[deviceIds[i]].deviceOwner,signer)) {\r\n\r\n                  devicesByOwner[numDevices] = deviceIds[i];\r\n                  if (numDevices == 10) {\r\n                    break;\r\n                  }\r\n                  numDevices++;\r\n\r\n              }\r\n\r\n          }\r\n\r\n          return devicesByOwner;\r\n      }\r\n\r\n      /** @dev returns up to 10 transactions of device owner\r\n        * @return _deviceIds device ID's of the msg.sender transactions\r\n        */\r\n      function getDevicesByTxn(bytes32 _message, uint8 _v, bytes32 _r, bytes32 _s)\r\n              public\r\n              view\r\n              returns(bytes32[10] memory _deviceIds) {\r\n\r\n          address signer = ecrecover(_message, _v, _r, _s);\r\n          uint numDevices;\r\n          bytes32[10] memory devicesByTxOriginator;\r\n\r\n          for(uint i = 0; i < deviceIds.length; i++) {\r\n\r\n              if(addressEqual(deviceMap[deviceIds[i]].txOriginator,signer)) {\r\n\r\n                  devicesByTxOriginator[numDevices] = deviceIds[i];\r\n                  if (numDevices == 10) {\r\n                    break;\r\n                  }\r\n                  numDevices++;\r\n\r\n              }\r\n\r\n          }\r\n\r\n          return devicesByTxOriginator;\r\n      }\r\n\r\n\r\n      modifier deviceIdExist(bytes32 _deviceId){\r\n          require(isDeviceId(_deviceId));\r\n          _;\r\n      }\r\n\r\n      modifier deviceIdNotExist(bytes32 _deviceId){\r\n          require(!isDeviceId(_deviceId));\r\n          _;\r\n      }\r\n\r\n      modifier authorizedUser() {\r\n          require(authorized[msg.sender] == true);\r\n          _;\r\n      }\r\n\r\n      constructor() public {\r\n\r\n          authorized[msg.sender]=true;\r\n      }\r\n\r\n\r\n    /** @dev when a new device ID is registered by a proxy owner by sending device owner signature\r\n      * @param _deviceId ID of the device.\r\n      * @return index of stored device\r\n      */\r\n    function registerProof (bytes32 _deviceId, bytes32 _message, uint8 _v, bytes32 _r, bytes32 _s)\r\n         public\r\n         whenNotPaused()\r\n         authorizedUser()\r\n         deviceIdNotExist(_deviceId)\r\n         returns(uint index) {\r\n\r\n            address signer = ecrecover(_message, _v, _r, _s);\r\n\r\n            deviceMap[_deviceId].deviceOwner = signer;\r\n            deviceMap[_deviceId].txOriginator = signer;\r\n            deviceMap[_deviceId].index = deviceIds.push(_deviceId)-1;\r\n\r\n            emit deviceCreated(_deviceId, signer);\r\n\r\n            return deviceIds.length-1;\r\n\r\n    }\r\n\r\n    /** @dev returns true if delete is successful\r\n      * @param _deviceId ID of the device.\r\n      * @return bool delete\r\n      */\r\n    function destructProof(bytes32 _deviceId, bytes32 _message, uint8 _v, bytes32 _r, bytes32 _s)\r\n            public\r\n            whenNotPaused()\r\n            authorizedUser()\r\n            deviceIdExist(_deviceId)\r\n            returns(bool success) {\r\n\r\n                address signer = ecrecover(_message, _v, _r, _s);\r\n\r\n                require(deviceMap[_deviceId].deviceOwner == signer);\r\n\r\n                uint rowToDelete = deviceMap[_deviceId].index;\r\n                bytes32 keyToMove = deviceIds[deviceIds.length-1];\r\n                deviceIds[rowToDelete] = keyToMove;\r\n                deviceMap[keyToMove].index = rowToDelete;\r\n                deviceIds.length--;\r\n\r\n                emit deviceDestruct(_deviceId, signer);\r\n                return true;\r\n\r\n    }\r\n\r\n    /** @dev returns request transfer of device\r\n      * @param _deviceId ID of the device.\r\n      * @return index of stored device\r\n      */\r\n    function requestTransfer(bytes32 _deviceId, bytes32 _message, uint8 _v, bytes32 _r, bytes32 _s)\r\n          public\r\n          whenNotPaused()\r\n          deviceIdExist(_deviceId)\r\n          authorizedUser()\r\n          returns(uint index) {\r\n\r\n            address signer = ecrecover(_message, _v, _r, _s);\r\n\r\n            deviceMap[_deviceId].txOriginator=signer;\r\n\r\n            emit txnCreated(_deviceId, signer);\r\n\r\n            return deviceMap[_deviceId].index;\r\n\r\n    }\r\n\r\n    /** @dev returns approve transfer of device\r\n      * @param _deviceId ID of the device.\r\n      * @return bool approval\r\n      */\r\n    function approveTransfer (bytes32 _deviceId, address newOwner, bytes32 _message, uint8 _v, bytes32 _r, bytes32 _s)\r\n            public\r\n            whenNotPaused()\r\n            deviceIdExist(_deviceId)\r\n            authorizedUser()\r\n            returns(bool) {\r\n\r\n                address signer = ecrecover(_message, _v, _r, _s);\r\n\r\n                require(deviceMap[_deviceId].deviceOwner == signer);\r\n                require(deviceMap[_deviceId].txOriginator == newOwner);\r\n\r\n                deviceMap[_deviceId].deviceOwner=newOwner;\r\n\r\n                emit deviceTransfer(_deviceId, signer, deviceMap[_deviceId].deviceOwner);\r\n\r\n                return true;\r\n\r\n    }\r\n\r\n    /** @dev returns write message success\r\n      * @param _deviceId ID of the device.\r\n      * @return bool true when write message is successful\r\n      */\r\n    function writeMessage (bytes32 _deviceId, string memory messageToWrite, bytes32 _message, uint8 _v, bytes32 _r, bytes32 _s)\r\n            public\r\n            whenNotPaused()\r\n            deviceIdExist(_deviceId)\r\n            authorizedUser()\r\n            returns(bool) {\r\n                address signer = ecrecover(_message, _v, _r, _s);\r\n                require(deviceMap[_deviceId].deviceOwner == signer);\r\n                emit deviceMessage(_deviceId, deviceMap[_deviceId].deviceOwner, signer, messageToWrite);\r\n\r\n                return true;\r\n\r\n    }\r\n\r\n    /** @dev returns request proof of device\r\n      * @param _deviceId ID of the device.\r\n      * @return _index info of that device\r\n      */\r\n     function requestProof(bytes32 _deviceId, bytes32 _message, uint8 _v, bytes32 _r, bytes32 _s)\r\n         public\r\n         whenNotPaused()\r\n         deviceIdExist(_deviceId)\r\n         authorizedUser()\r\n         returns(uint _index) {\r\n\r\n             address signer = ecrecover(_message, _v, _r, _s);\r\n\r\n             deviceMap[_deviceId].txOriginator=signer;\r\n\r\n             emit txnCreated(_deviceId, signer);\r\n\r\n             return deviceMap[_deviceId].index;\r\n     }\r\n\r\n\r\n     /** @dev returns approve proof of device\r\n       * @param _deviceId ID of the device.\r\n       * @return bool  - approval\r\n       */\r\n     function approveProof(bytes32 _deviceId, bytes32 _message, uint8 _v, bytes32 _r, bytes32 _s)\r\n             public\r\n             whenNotPaused()\r\n             deviceIdExist(_deviceId)\r\n             authorizedUser()\r\n             returns(bool) {\r\n\r\n                  address signer = ecrecover(_message, _v, _r, _s);\r\n                  deviceMap[_deviceId].txOriginator=signer;\r\n                  require(deviceMap[_deviceId].deviceOwner == signer);\r\n\r\n                  emit deviceProof(_deviceId, signer);\r\n                  return true;\r\n     }\r\n\r\n     /** @dev updates IPFS hash into device owner public address\r\n       * @param ipfskey -  ipfs hash for attachment.\r\n       */\r\n     function emitipfskey(bytes32 _deviceId, address ownerAddress, string memory ipfskey)\r\n              public\r\n              whenNotPaused()\r\n              deviceIdExist(_deviceId)\r\n              authorizedUser() {\r\n        emit ipfsHashtoAddress(_deviceId, ownerAddress, ipfskey);\r\n    }\r\n\r\n    /** @dev Updates Authorization status of an address for executing functions\r\n    * on this contract\r\n    * @param target Address that will be authorized or not authorized\r\n    * @param isAuthorized New authorization status of address\r\n    */\r\n    function changeAuthStatus(address target, bool isAuthorized)\r\n            public\r\n            whenNotPaused()\r\n            onlyOwner() {\r\n\r\n              authorized[target] = isAuthorized;\r\n    }\r\n\r\n    /** @dev Updates Authorization status of an address for executing functions\r\n    * on this contract\r\n    * @param targets Address that will be authorized or not authorized in bulk\r\n    * @param isAuthorized New registration status of address\r\n    */\r\n    function changeAuthStatuses(address[] memory targets, bool isAuthorized)\r\n            public\r\n            whenNotPaused()\r\n            onlyOwner() {\r\n              for (uint i = 0; i < targets.length; i++) {\r\n                changeAuthStatus(targets[i], isAuthorized);\r\n              }\r\n    }\r\n\r\n    /*\r\n        NOTE: We explicitly do not define a fallback function, because there are\r\n        no ethers received by any funtion on this contract\r\n\r\n    */\r\n\r\n    //Helper Functions\r\n\r\n    /** @dev compares two String equal or not\r\n      * @param a first string, b second string.\r\n      * @return bool true if match\r\n      */\r\n    function bytesEqual(bytes32 a, bytes32 b) private pure returns (bool) {\r\n       return keccak256(abi.encodePacked(a)) == keccak256(abi.encodePacked(b));\r\n     }\r\n\r\n   /** @dev compares two address equal or not\r\n     * @param a first address, b second address.\r\n     * @return bool true if match\r\n     */\r\n   function addressEqual(address a, address b) private pure returns (bool) {\r\n      return keccak256(abi.encodePacked(a)) == keccak256(abi.encodePacked(b));\r\n    }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"_deviceId\",\"type\":\"bytes32\"}],\"name\":\"getDeviceId\",\"outputs\":[{\"name\":\"_index\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isPauser\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"targets\",\"type\":\"address[]\"},{\"name\":\"isAuthorized\",\"type\":\"bool\"}],\"name\":\"changeAuthStatuses\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"target\",\"type\":\"address\"},{\"name\":\"isAuthorized\",\"type\":\"bool\"}],\"name\":\"changeAuthStatus\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renouncePauser\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_deviceId\",\"type\":\"bytes32\"},{\"name\":\"ownerAddress\",\"type\":\"address\"},{\"name\":\"ipfskey\",\"type\":\"string\"}],\"name\":\"emitipfskey\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"addPauser\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_deviceId\",\"type\":\"bytes32\"}],\"name\":\"isDeviceId\",\"outputs\":[{\"name\":\"isIndeed\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_deviceId\",\"type\":\"bytes32\"},{\"name\":\"_message\",\"type\":\"bytes32\"},{\"name\":\"_v\",\"type\":\"uint8\"},{\"name\":\"_r\",\"type\":\"bytes32\"},{\"name\":\"_s\",\"type\":\"bytes32\"}],\"name\":\"approveProof\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_deviceId\",\"type\":\"bytes32\"}],\"name\":\"getOwnerByDevice\",\"outputs\":[{\"name\":\"deviceOwner\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_message\",\"type\":\"bytes32\"},{\"name\":\"_v\",\"type\":\"uint8\"},{\"name\":\"_r\",\"type\":\"bytes32\"},{\"name\":\"_s\",\"type\":\"bytes32\"}],\"name\":\"getDevicesByOwner\",\"outputs\":[{\"name\":\"_deviceIds\",\"type\":\"bytes32[10]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_deviceId\",\"type\":\"bytes32\"},{\"name\":\"_message\",\"type\":\"bytes32\"},{\"name\":\"_v\",\"type\":\"uint8\"},{\"name\":\"_r\",\"type\":\"bytes32\"},{\"name\":\"_s\",\"type\":\"bytes32\"}],\"name\":\"requestTransfer\",\"outputs\":[{\"name\":\"index\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"authorized\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_message\",\"type\":\"bytes32\"},{\"name\":\"_v\",\"type\":\"uint8\"},{\"name\":\"_r\",\"type\":\"bytes32\"},{\"name\":\"_s\",\"type\":\"bytes32\"}],\"name\":\"getDevicesByTxn\",\"outputs\":[{\"name\":\"_deviceIds\",\"type\":\"bytes32[10]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_deviceId\",\"type\":\"bytes32\"},{\"name\":\"messageToWrite\",\"type\":\"string\"},{\"name\":\"_message\",\"type\":\"bytes32\"},{\"name\":\"_v\",\"type\":\"uint8\"},{\"name\":\"_r\",\"type\":\"bytes32\"},{\"name\":\"_s\",\"type\":\"bytes32\"}],\"name\":\"writeMessage\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_deviceId\",\"type\":\"bytes32\"},{\"name\":\"_message\",\"type\":\"bytes32\"},{\"name\":\"_v\",\"type\":\"uint8\"},{\"name\":\"_r\",\"type\":\"bytes32\"},{\"name\":\"_s\",\"type\":\"bytes32\"}],\"name\":\"requestProof\",\"outputs\":[{\"name\":\"_index\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"deviceIds\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_deviceId\",\"type\":\"bytes32\"},{\"name\":\"newOwner\",\"type\":\"address\"},{\"name\":\"_message\",\"type\":\"bytes32\"},{\"name\":\"_v\",\"type\":\"uint8\"},{\"name\":\"_r\",\"type\":\"bytes32\"},{\"name\":\"_s\",\"type\":\"bytes32\"}],\"name\":\"approveTransfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_deviceId\",\"type\":\"bytes32\"},{\"name\":\"_message\",\"type\":\"bytes32\"},{\"name\":\"_v\",\"type\":\"uint8\"},{\"name\":\"_r\",\"type\":\"bytes32\"},{\"name\":\"_s\",\"type\":\"bytes32\"}],\"name\":\"registerProof\",\"outputs\":[{\"name\":\"index\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_deviceId\",\"type\":\"bytes32\"},{\"name\":\"_message\",\"type\":\"bytes32\"},{\"name\":\"_v\",\"type\":\"uint8\"},{\"name\":\"_r\",\"type\":\"bytes32\"},{\"name\":\"_s\",\"type\":\"bytes32\"}],\"name\":\"destructProof\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"deviceId\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"deviceOwner\",\"type\":\"address\"}],\"name\":\"deviceCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"deviceId\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"txnOriginator\",\"type\":\"address\"}],\"name\":\"txnCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"deviceId\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"deviceOwner\",\"type\":\"address\"}],\"name\":\"deviceProof\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"deviceId\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"fromOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"toOwner\",\"type\":\"address\"}],\"name\":\"deviceTransfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"deviceId\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"deviceOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"txnOriginator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"messageToWrite\",\"type\":\"string\"}],\"name\":\"deviceMessage\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"deviceId\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"deviceOwner\",\"type\":\"address\"}],\"name\":\"deviceDestruct\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"deviceId\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"ownerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"ipfskey\",\"type\":\"string\"}],\"name\":\"ipfsHashtoAddress\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"PauserAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"PauserRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"ProofBox","CompilerVersion":"v0.5.2+commit.1df8f40c","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://3ce487d1fd3cb9a0486af6808f689c5baf6c742d940e6cfcc5be00df74516a63"}]}