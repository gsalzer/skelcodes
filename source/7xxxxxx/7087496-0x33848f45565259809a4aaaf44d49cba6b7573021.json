{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address private _owner;\r\n\r\n  event OwnershipTransferred(\r\n    address indexed previousOwner,\r\n    address indexed newOwner\r\n  );\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  constructor(address custom_owner) public {\r\n    if (custom_owner != address (0))\r\n      _owner = custom_owner;\r\n    else\r\n      _owner = msg.sender;\r\n    emit OwnershipTransferred(address(0), _owner);\r\n  }\r\n\r\n  /**\r\n   * @return the address of the owner.\r\n   */\r\n  function owner() public view returns(address) {\r\n    return _owner;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(isOwner());\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @return true if `msg.sender` is the owner of the contract.\r\n   */\r\n  function isOwner() public view returns(bool) {\r\n    return msg.sender == _owner;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to relinquish control of the contract.\r\n   * @notice Renouncing to ownership will leave the contract without an owner.\r\n   * It will not be possible to call the functions with the `onlyOwner`\r\n   * modifier anymore.\r\n   */\r\n  function renounceOwnership() public onlyOwner {\r\n    emit OwnershipTransferred(_owner, address(0));\r\n    _owner = address(0);\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    _transferOwnership(newOwner);\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function _transferOwnership(address newOwner) internal {\r\n    require(newOwner != address(0));\r\n    emit OwnershipTransferred(_owner, newOwner);\r\n    _owner = newOwner;\r\n  }\r\n}\r\n\r\n\r\ncontract Authorizable is Ownable {\r\n    mapping (address => bool) addressesAllowed;\r\n\r\n    constructor () Ownable(address(0)) public {\r\n        addressesAllowed[owner()] = true;\r\n    }\r\n\r\n    function addAuthorization (address authAddress) public onlyOwner {\r\n        addressesAllowed[authAddress] = true;\r\n    }\r\n\r\n    function removeAuthorization (address authAddress) public onlyOwner {\r\n        delete(addressesAllowed[authAddress]);\r\n    }\r\n\r\n    function isAuthorized () public view returns(bool) {\r\n        return addressesAllowed[msg.sender];\r\n    }\r\n\r\n    modifier authorized() {\r\n        require(isAuthorized());\r\n        _;\r\n    }\r\n}\r\n\r\ncontract NotesharesCatalog is Authorizable {\r\n    address[] public tokens;\r\n    mapping (address => bool) public banned; // 1 - banned, 0 - allowed\r\n\r\n    event tokenAdded (address tokenAddress);\r\n    event permissionChanged (address tokenAddress, bool permission);\r\n\r\n    function getTokens () public view returns(address[]) {\r\n        return tokens;\r\n    }\r\n\r\n    function getTokensCount () public view returns(uint256) {\r\n        return tokens.length;\r\n    }\r\n\r\n    function isBanned (address tokenAddress) public view returns(bool) {\r\n        return banned[tokenAddress];\r\n    }\r\n\r\n    function setPermission (address tokenAddress, bool permission) public onlyOwner {\r\n        if (permission)\r\n            banned[tokenAddress] = permission;\r\n        else\r\n            delete(banned[tokenAddress]);\r\n\r\n        emit permissionChanged(tokenAddress, permission);\r\n    }\r\n\r\n    function addExistingToken (address token) public authorized {\r\n        require(token != address (0));\r\n        tokens.push(token);\r\n        emit tokenAdded (token);\r\n    }\r\n\r\n    function destruct () public onlyOwner {\r\n        selfdestruct(owner());\r\n    }\r\n}\r\n\r\n/*\r\n    Based on https://etherscan.io/address/0x6dee36e9f915cab558437f97746998048dcaa700#code\r\n    by https://blog.pennyether.com/posts/realtime-dividend-token.html\r\n*/\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, reverts on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    uint256 c = a * b;\r\n    require(c / a == b);\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b > 0); // Solidity only automatically asserts when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b <= a);\r\n    uint256 c = a - b;\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, reverts on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    require(c >= a);\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\r\n  * reverts when dividing by zero.\r\n  */\r\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b != 0);\r\n    return a % b;\r\n  }\r\n}\r\n\r\n\r\ncontract ERC20 {\r\n    using SafeMath for uint256;\r\n\r\n    string public name;\r\n    string public symbol;\r\n    uint8 public decimals = 18;\r\n    uint public totalSupply;\r\n    mapping (address => uint) public balanceOf;\r\n    mapping (address => mapping (address => uint)) public allowance;\r\n\r\n    event Created(uint time);\r\n    event Transfer(address indexed from, address indexed to, uint amount);\r\n    event Approval(address indexed owner, address indexed spender, uint amount);\r\n    event AllowanceUsed(address indexed owner, address indexed spender, uint amount);\r\n\r\n    constructor(string _name, string _symbol)\r\n    public\r\n    {\r\n        name = _name;\r\n        symbol = _symbol;\r\n        emit Created(now);\r\n    }\r\n\r\n    function transfer(address _to, uint _value)\r\n    public\r\n    returns (bool success)\r\n    {\r\n        return _transfer(msg.sender, _to, _value);\r\n    }\r\n\r\n    function approve(address _spender, uint _value)\r\n    public\r\n    returns (bool success)\r\n    {\r\n        allowance[msg.sender][_spender] = _value;\r\n        emit Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    // Attempts to transfer `_value` from `_from` to `_to`\r\n    //  if `_from` has sufficient allowance for `msg.sender`.\r\n    function transferFrom(address _from, address _to, uint256 _value)\r\n    public\r\n    returns (bool success)\r\n    {\r\n        address _spender = msg.sender;\r\n        require(allowance[_from][_spender] >= _value);\r\n        allowance[_from][_spender] = allowance[_from][_spender].sub(_value);\r\n        emit AllowanceUsed(_from, _spender, _value);\r\n        return _transfer(_from, _to, _value);\r\n    }\r\n\r\n    // Transfers balance from `_from` to `_to` if `_to` has sufficient balance.\r\n    // Called from transfer() and transferFrom().\r\n    function _transfer(address _from, address _to, uint _value)\r\n    private\r\n    returns (bool success)\r\n    {\r\n        require(balanceOf[_from] >= _value);\r\n        require(balanceOf[_to].add(_value) > balanceOf[_to]);\r\n        balanceOf[_from] = balanceOf[_from].sub(_value);\r\n        balanceOf[_to] = balanceOf[_to].add(_value);\r\n        emit Transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n}\r\n\r\ninterface HasTokenFallback {\r\n    function tokenFallback(address _from, uint256 _amount, bytes _data)\r\n    external\r\n    returns (bool success);\r\n}\r\n\r\ncontract ERC667 is ERC20 {\r\n    constructor(string _name, string _symbol)\r\n    public\r\n    ERC20(_name, _symbol)\r\n    {}\r\n\r\n    function transferAndCall(address _to, uint _value, bytes _data)\r\n    public\r\n    returns (bool success)\r\n    {\r\n        require(super.transfer(_to, _value));\r\n        require(HasTokenFallback(_to).tokenFallback(msg.sender, _value, _data));\r\n        return true;\r\n    }\r\n}\r\n\r\n/*********************************************************\r\n******************* DIVIDEND TOKEN ***********************\r\n**********************************************************\r\n\r\nUI: https://www.pennyether.com/status/tokens\r\n\r\nAn ERC20 token that can accept Ether and distribute it\r\nperfectly to all Token Holders relative to each account's\r\nbalance at the time the dividend is received.\r\n\r\nThe Token is owned by the creator, and can be frozen,\r\nminted, and burned by the owner.\r\n\r\nNotes:\r\n    - Accounts can view or receive dividends owed at any time\r\n    - Dividends received are immediately credited to all\r\n      current Token Holders and can be redeemed at any time.\r\n    - Per above, upon transfers, dividends are not\r\n      transferred. They are kept by the original sender, and\r\n      not credited to the receiver.\r\n    - Uses \"pull\" instead of \"push\". Token holders must pull\r\n      their own dividends.\r\n\r\n*/\r\ncontract DividendTokenERC667 is ERC667, Ownable\r\n{\r\n    using SafeMath for uint256;\r\n\r\n    // How dividends work:\r\n    //\r\n    // - A \"point\" is a fraction of a Wei (1e-32), it's used to reduce rounding errors.\r\n    //\r\n    // - totalPointsPerToken represents how many points each token is entitled to\r\n    //   from all the dividends ever received. Each time a new deposit is made, it\r\n    //   is incremented by the points oweable per token at the time of deposit:\r\n    //     (depositAmtInWei * POINTS_PER_WEI) / totalSupply\r\n    //\r\n    // - Each account has a `creditedPoints` and `lastPointsPerToken`\r\n    //   - lastPointsPerToken:\r\n    //       The value of totalPointsPerToken the last time `creditedPoints` was changed.\r\n    //   - creditedPoints:\r\n    //       How many points have been credited to the user. This is incremented by:\r\n    //         (`totalPointsPerToken` - `lastPointsPerToken` * balance) via\r\n    //         `.updateCreditedPoints(account)`. This occurs anytime the balance changes\r\n    //         (transfer, mint, burn).\r\n    //\r\n    // - .collectOwedDividends() calls .updateCreditedPoints(account), converts points\r\n    //   to wei and pays account, then resets creditedPoints[account] to 0.\r\n    //\r\n    // - \"Credit\" goes to Nick Johnson for the concept.\r\n    //\r\n    uint constant POINTS_PER_WEI = 1e32;\r\n    uint public dividendsTotal;\r\n    uint public dividendsCollected;\r\n    uint public totalPointsPerToken;\r\n    mapping (address => uint) public creditedPoints;\r\n    mapping (address => uint) public lastPointsPerToken;\r\n\r\n    // Events\r\n    event CollectedDividends(uint time, address indexed account, uint amount);\r\n    event DividendReceived(uint time, address indexed sender, uint amount);\r\n\r\n    constructor(uint256 _totalSupply, address _custom_owner)\r\n    public\r\n    ERC667(\"Noteshares Token\", \"NST\")\r\n    Ownable(_custom_owner)\r\n    {\r\n        totalSupply = _totalSupply;\r\n    }\r\n\r\n    // Upon receiving payment, increment lastPointsPerToken.\r\n    function receivePayment()\r\n    internal\r\n    {\r\n        if (msg.value == 0) return;\r\n        // POINTS_PER_WEI is 1e32.\r\n        // So, no multiplication overflow unless msg.value > 1e45 wei (1e27 ETH)\r\n        totalPointsPerToken = totalPointsPerToken.add((msg.value.mul(POINTS_PER_WEI)).div(totalSupply));\r\n        dividendsTotal = dividendsTotal.add(msg.value);\r\n        emit DividendReceived(now, msg.sender, msg.value);\r\n    }\r\n    /*************************************************************/\r\n    /********** PUBLIC FUNCTIONS *********************************/\r\n    /*************************************************************/\r\n\r\n    // Normal ERC20 transfer, except before transferring\r\n    //  it credits points for both the sender and receiver.\r\n    function transfer(address _to, uint _value)\r\n    public\r\n    returns (bool success)\r\n    {\r\n        // ensure tokens are not frozen.\r\n        _updateCreditedPoints(msg.sender);\r\n        _updateCreditedPoints(_to);\r\n        return ERC20.transfer(_to, _value);\r\n    }\r\n\r\n    // Normal ERC20 transferFrom, except before transferring\r\n    //  it credits points for both the sender and receiver.\r\n    function transferFrom(address _from, address _to, uint256 _value)\r\n    public\r\n    returns (bool success)\r\n    {\r\n        _updateCreditedPoints(_from);\r\n        _updateCreditedPoints(_to);\r\n        return ERC20.transferFrom(_from, _to, _value);\r\n    }\r\n\r\n    // Normal ERC667 transferAndCall, except before transferring\r\n    //  it credits points for both the sender and receiver.\r\n    function transferAndCall(address _to, uint _value, bytes _data)\r\n    public\r\n    returns (bool success)\r\n    {\r\n        _updateCreditedPoints(msg.sender);\r\n        _updateCreditedPoints(_to);\r\n        return ERC667.transferAndCall(_to, _value, _data);\r\n    }\r\n\r\n    // Updates creditedPoints, sends all wei to the owner\r\n    function collectOwedDividends()\r\n    internal\r\n    returns (uint _amount)\r\n    {\r\n        // update creditedPoints, store amount, and zero it.\r\n        _updateCreditedPoints(msg.sender);\r\n        _amount = creditedPoints[msg.sender].div(POINTS_PER_WEI);\r\n        creditedPoints[msg.sender] = 0;\r\n        dividendsCollected = dividendsCollected.add(_amount);\r\n        emit CollectedDividends(now, msg.sender, _amount);\r\n        require(msg.sender.call.value(_amount)());\r\n    }\r\n\r\n\r\n    /*************************************************************/\r\n    /********** PRIVATE METHODS / VIEWS **************************/\r\n    /*************************************************************/\r\n    // Credits _account with whatever dividend points they haven't yet been credited.\r\n    //  This needs to be called before any user's balance changes to ensure their\r\n    //  \"lastPointsPerToken\" credits their current balance, and not an altered one.\r\n    function _updateCreditedPoints(address _account)\r\n    private\r\n    {\r\n        creditedPoints[_account] = creditedPoints[_account].add(_getUncreditedPoints(_account));\r\n        lastPointsPerToken[_account] = totalPointsPerToken;\r\n    }\r\n\r\n    // For a given account, returns how many Wei they haven't yet been credited.\r\n    function _getUncreditedPoints(address _account)\r\n    private\r\n    view\r\n    returns (uint _amount)\r\n    {\r\n        uint _pointsPerToken = totalPointsPerToken.sub(lastPointsPerToken[_account]);\r\n        // The upper bound on this number is:\r\n        //   ((1e32 * TOTAL_DIVIDEND_AMT) / totalSupply) * balances[_account]\r\n        // Since totalSupply >= balances[_account], this will overflow only if\r\n        //   TOTAL_DIVIDEND_AMT is around 1e45 wei. Not ever going to happen.\r\n        return _pointsPerToken.mul(balanceOf[_account]);\r\n    }\r\n\r\n\r\n    /*************************************************************/\r\n    /********* CONSTANTS *****************************************/\r\n    /*************************************************************/\r\n    // Returns how many wei a call to .collectOwedDividends() would transfer.\r\n    function getOwedDividends(address _account)\r\n    public\r\n    constant\r\n    returns (uint _amount)\r\n    {\r\n        return (_getUncreditedPoints(_account).add(creditedPoints[_account])).div(POINTS_PER_WEI);\r\n    }\r\n}\r\n\r\ncontract NSERC667 is DividendTokenERC667 {\r\n    using SafeMath for uint256;\r\n\r\n    uint256 private TOTAL_SUPPLY =  100 * (10 ** uint256(decimals)); //always a 100 tokens representing 100% of ownership\r\n\r\n    constructor (address ecosystemFeeAccount, uint256 ecosystemShare, address _custom_owner)\r\n    public\r\n    DividendTokenERC667(TOTAL_SUPPLY, _custom_owner)\r\n    {\r\n        uint256 ownerSupply = totalSupply.sub(ecosystemShare);\r\n        balanceOf[owner()] = ownerSupply;\r\n        balanceOf[ecosystemFeeAccount] = ecosystemShare;\r\n    }\r\n}\r\n\r\ncontract NotesharesToken is NSERC667 {\r\n    using SafeMath for uint256;\r\n\r\n    uint8 public state; //0 - canceled, 1 - active, 2 - failed, 3 - complete\r\n\r\n    string private contentLink;\r\n    string private folderLink;\r\n    bool public hidden = false;\r\n\r\n    constructor (string _contentLink, string _folderLink, address _ecosystemFeeAccount, uint256 ecosystemShare, address _custom_owner)\r\n    public\r\n    NSERC667(_ecosystemFeeAccount, ecosystemShare, _custom_owner) {\r\n        state = 3;\r\n        contentLink = _contentLink;\r\n        folderLink = _folderLink;\r\n    }\r\n\r\n    //payables\r\n    /**\r\n     * Main donation function\r\n     */\r\n    function () public payable {\r\n        require(state == 3); //donations only acceptable if contract is complete\r\n        receivePayment();\r\n    }\r\n\r\n    function getContentLink () public view returns (string) {\r\n        require(hidden == false);\r\n        return contentLink;\r\n    }\r\n\r\n    function getFolderLink() public view returns (string) {\r\n        require(hidden == false);\r\n        return folderLink;\r\n    }\r\n    //Contract control\r\n    /**\r\n     * Transfers dividend in ETH if contract is complete or remaining funds to investors if contract is failed\r\n     */\r\n\r\n    function setCancelled () public onlyOwner {\r\n        state = 0;\r\n    }\r\n\r\n    function setHidden (bool _hidden) public onlyOwner {\r\n        hidden = _hidden;\r\n    }\r\n\r\n    function claimDividend () public {\r\n        require(state > 1);\r\n        collectOwedDividends();\r\n    }\r\n\r\n    //destruction is possible if there is only one owner\r\n    function destruct () public onlyOwner {\r\n        require(state == 2 || state == 3);\r\n        require(balanceOf[owner()] == totalSupply);\r\n        selfdestruct(owner());\r\n    }\r\n\r\n    //to claim ownership you should have 100% of tokens\r\n    function claimOwnership () public {\r\n        //require(state == 2);\r\n        require(balanceOf[msg.sender] == totalSupply);\r\n        _transferOwnership(msg.sender);\r\n    }\r\n}\r\n\r\ncontract NotesharesTokenFactory is Ownable (address(0)) {\r\n    address public catalogAddress;\r\n    address public ecosystemFeeAccount;\r\n\r\n    event tokenCreated (address tokenAddress);\r\n\r\n    constructor (address _catalogAddress, address _ecosystemFeeAccount) public {\r\n        catalogAddress = _catalogAddress;\r\n        ecosystemFeeAccount = _ecosystemFeeAccount;\r\n    }\r\n\r\n    function setEcosystemFeeAccount (address _ecosystemFeeAccount) public onlyOwner {\r\n        ecosystemFeeAccount = _ecosystemFeeAccount;\r\n    }\r\n\r\n    function setCatalogAddress (address _catalogAddress) public onlyOwner {\r\n        catalogAddress = _catalogAddress;\r\n    }\r\n\r\n    function addTokenToCatalog (address token) internal {\r\n        NotesharesCatalog NSC = NotesharesCatalog(catalogAddress);\r\n        NSC.addExistingToken(address(token));\r\n    }\r\n\r\n    function createToken (string _contentLink, string _folderLink, uint256 ecosystemShare) public returns (address){\r\n        NotesharesToken NST = new NotesharesToken(_contentLink, _folderLink, ecosystemFeeAccount, ecosystemShare, msg.sender);\r\n        emit tokenCreated(address(NST));\r\n        addTokenToCatalog(address(NST));\r\n    }\r\n\r\n    function destruct () public onlyOwner {\r\n        selfdestruct(owner());\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"ecosystemFeeAccount\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"destruct\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"catalogAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_contentLink\",\"type\":\"string\"},{\"name\":\"_folderLink\",\"type\":\"string\"},{\"name\":\"ecosystemShare\",\"type\":\"uint256\"}],\"name\":\"createToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_catalogAddress\",\"type\":\"address\"}],\"name\":\"setCatalogAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_ecosystemFeeAccount\",\"type\":\"address\"}],\"name\":\"setEcosystemFeeAccount\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_catalogAddress\",\"type\":\"address\"},{\"name\":\"_ecosystemFeeAccount\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"tokenAddress\",\"type\":\"address\"}],\"name\":\"tokenCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"NotesharesTokenFactory","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000005102b7ea9aeca5895d918acd0caea56e7fdee1300000000000000000000000001eda62c925cd5d60f64044829993b5108b97c010","Library":"","SwarmSource":"bzzr://13bc3f4b7aff623f2f90aec290972aab022267dff4de298f1b23c02b59862d47"}]}