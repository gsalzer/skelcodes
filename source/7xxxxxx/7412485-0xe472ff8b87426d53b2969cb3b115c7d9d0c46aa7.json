{"status":"1","message":"OK","result":[{"SourceCode":"// File: contracts/upgradeability/EternalStorage.sol\r\n\r\npragma solidity 0.4.19;\r\n\r\n\r\n/**\r\n * @title EternalStorage\r\n * @dev This contract holds all the necessary state variables to carry out the storage of any contract.\r\n */\r\ncontract EternalStorage {\r\n\r\n    mapping(bytes32 => uint256) internal uintStorage;\r\n    mapping(bytes32 => string) internal stringStorage;\r\n    mapping(bytes32 => address) internal addressStorage;\r\n    mapping(bytes32 => bytes) internal bytesStorage;\r\n    mapping(bytes32 => bool) internal boolStorage;\r\n    mapping(bytes32 => int256) internal intStorage;\r\n\r\n}\r\n\r\n// File: contracts/libraries/SafeMath.sol\r\n\r\npragma solidity 0.4.19;\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n// File: contracts/IRewardableValidators.sol\r\n\r\npragma solidity 0.4.19;\r\n\r\n\r\ninterface IRewardableValidators {\r\n    function isValidator(address _validator) public view returns(bool);\r\n    function requiredSignatures() public view returns(uint256);\r\n    function owner() public view returns(address);\r\n    function validatorList() public view returns (address[]);\r\n    function getValidatorRewardAddress(address _validator) public view returns(address);\r\n    function validatorCount() public view returns (uint256);\r\n    function getNextValidator(address _address) public view returns (address);\r\n}\r\n\r\n// File: contracts/upgradeable_contracts/FeeTypes.sol\r\n\r\npragma solidity 0.4.19;\r\n\r\n\r\ncontract FeeTypes {\r\n    bytes32 internal constant HOME_FEE = keccak256(\"home-fee\");\r\n    bytes32 internal constant FOREIGN_FEE = keccak256(\"foreign-fee\");\r\n}\r\n\r\n// File: contracts/upgradeable_contracts/BaseFeeManager.sol\r\n\r\npragma solidity 0.4.19;\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract BaseFeeManager is EternalStorage, FeeTypes {\r\n    using SafeMath for uint256;\r\n\r\n    bytes32 public constant REWARD_FOR_TRANSFERRING_FROM_HOME = keccak256(\"reward-transferring-from-home\");\r\n\r\n    bytes32 public constant REWARD_FOR_TRANSFERRING_FROM_FOREIGN = keccak256(\"reward-transferring-from-foreign\");\r\n\r\n    event HomeFeeUpdated(uint256 fee);\r\n    event ForeignFeeUpdated(uint256 fee);\r\n\r\n    function calculateFee(uint256 _value, bool _recover, bytes32 _feeType) external view returns(uint256) {\r\n        uint256 fee = _feeType == HOME_FEE ? getHomeFee() : getForeignFee();\r\n        uint256 eth = 1 ether;\r\n        if (!_recover) {\r\n            return _value.mul(fee).div(eth);\r\n        }\r\n        return _value.mul(fee).div(eth.sub(fee));\r\n    }\r\n\r\n    function setHomeFee(uint256 _fee) external {\r\n        uintStorage[keccak256(\"homeFee\")] = _fee;\r\n        HomeFeeUpdated(_fee);\r\n    }\r\n\r\n    function getHomeFee() public view returns(uint256) {\r\n        return uintStorage[keccak256(\"homeFee\")];\r\n    }\r\n\r\n    function setForeignFee(uint256 _fee) external {\r\n        uintStorage[keccak256(\"foreignFee\")] = _fee;\r\n        ForeignFeeUpdated(_fee);\r\n    }\r\n\r\n    function getForeignFee() public view returns(uint256) {\r\n        return uintStorage[keccak256(\"foreignFee\")];\r\n    }\r\n\r\n    function distributeFeeFromAffirmation(uint256 _fee) external {\r\n        distributeFeeProportionally(_fee, REWARD_FOR_TRANSFERRING_FROM_FOREIGN);\r\n    }\r\n\r\n    function distributeFeeFromSignatures(uint256 _fee) external {\r\n        distributeFeeProportionally(_fee, REWARD_FOR_TRANSFERRING_FROM_HOME);\r\n    }\r\n\r\n    function getFeeManagerMode() public pure returns(bytes4);\r\n\r\n    function random(uint256 _count) public view returns(uint256) {\r\n        return uint256(block.blockhash(block.number.sub(1))) % _count;\r\n    }\r\n\r\n    function distributeFeeProportionally(uint256 _fee, bytes32 _direction) internal {\r\n        IRewardableValidators validators = rewardableValidatorContract();\r\n        address F_ADDR = 0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF;\r\n        uint256 numOfValidators = validators.validatorCount();\r\n\r\n        uint256 feePerValidator = _fee.div(numOfValidators);\r\n\r\n        uint256 randomValidatorIndex;\r\n        uint256 diff = _fee.sub(feePerValidator.mul(numOfValidators));\r\n        if (diff > 0) {\r\n            randomValidatorIndex = random(numOfValidators);\r\n        }\r\n\r\n        address nextValidator = validators.getNextValidator(F_ADDR);\r\n        require((nextValidator != F_ADDR) && (nextValidator != address(0)));\r\n\r\n        uint256 i = 0;\r\n        while (nextValidator != F_ADDR) {\r\n            uint256 feeToDistribute = feePerValidator;\r\n            if (diff > 0 && randomValidatorIndex == i) {\r\n                feeToDistribute = feeToDistribute.add(diff);\r\n            }\r\n\r\n            address rewardAddress = validators.getValidatorRewardAddress(nextValidator);\r\n            onFeeDistribution(rewardAddress, feeToDistribute, _direction);\r\n\r\n            nextValidator = validators.getNextValidator(nextValidator);\r\n            require(nextValidator != address(0));\r\n            i = i + 1;\r\n        }\r\n    }\r\n\r\n    function onFeeDistribution(address _rewardAddress, uint256 _fee, bytes32 _direction) internal {\r\n        if (_direction == REWARD_FOR_TRANSFERRING_FROM_FOREIGN) {\r\n            onAffirmationFeeDistribution(_rewardAddress, _fee);\r\n        } else {\r\n            onSignatureFeeDistribution(_rewardAddress, _fee);\r\n        }\r\n    }\r\n\r\n    function onAffirmationFeeDistribution(address _rewardAddress, uint256 _fee) internal;\r\n\r\n    function onSignatureFeeDistribution(address _rewardAddress, uint256 _fee) internal;\r\n\r\n    function rewardableValidatorContract() public view returns(IRewardableValidators) {\r\n        return IRewardableValidators(addressStorage[keccak256(\"validatorContract\")]);\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC20/ERC20Basic.sol\r\n\r\npragma solidity ^0.4.18;\r\n\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/179\r\n */\r\ncontract ERC20Basic {\r\n  function totalSupply() public view returns (uint256);\r\n  function balanceOf(address who) public view returns (uint256);\r\n  function transfer(address to, uint256 value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC20/ERC20.sol\r\n\r\npragma solidity ^0.4.18;\r\n\r\n\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address owner, address spender) public view returns (uint256);\r\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\r\n  function approve(address spender, uint256 value) public returns (bool);\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: contracts/ERC677.sol\r\n\r\npragma solidity 0.4.19;\r\n\r\n\r\n\r\ncontract ERC677 is ERC20 {\r\n    event Transfer(address indexed from, address indexed to, uint value, bytes data);\r\n\r\n    function transferAndCall(address, uint, bytes) external returns (bool);\r\n\r\n}\r\n\r\n// File: contracts/IBurnableMintableERC677Token.sol\r\n\r\npragma solidity 0.4.19;\r\n\r\n\r\n\r\ncontract IBurnableMintableERC677Token is ERC677 {\r\n    function mint(address, uint256) public returns (bool);\r\n    function burn(uint256 _value) public;\r\n    function claimTokens(address _token, address _to) public;\r\n}\r\n\r\n// File: contracts/upgradeable_contracts/Sacrifice.sol\r\n\r\npragma solidity 0.4.19;\r\n\r\n\r\ncontract Sacrifice {\r\n    function Sacrifice(address _recipient) public payable {\r\n        selfdestruct(_recipient);\r\n    }\r\n}\r\n\r\n// File: contracts/upgradeable_contracts/native_to_erc20/FeeManagerNativeToErc.sol\r\n\r\npragma solidity 0.4.19;\r\n\r\n\r\n\r\n\r\n\r\ncontract FeeManagerNativeToErc is BaseFeeManager {\r\n\r\n    function getFeeManagerMode() public pure returns(bytes4) {\r\n        return bytes4(keccak256(\"manages-one-direction\"));\r\n    }\r\n\r\n    function erc677token() public view returns(IBurnableMintableERC677Token) {\r\n        return IBurnableMintableERC677Token(addressStorage[keccak256(\"erc677token\")]);\r\n    }\r\n\r\n    function onAffirmationFeeDistribution(address _rewardAddress, uint256 _fee) internal {\r\n        if (!_rewardAddress.send(_fee)) {\r\n            (new Sacrifice).value(_fee)(_rewardAddress);\r\n        }\r\n    }\r\n\r\n    function onSignatureFeeDistribution(address _rewardAddress, uint256 _fee) internal {\r\n        erc677token().mint(_rewardAddress, _fee);\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_fee\",\"type\":\"uint256\"}],\"name\":\"distributeFeeFromAffirmation\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"erc677token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_fee\",\"type\":\"uint256\"}],\"name\":\"setForeignFee\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_fee\",\"type\":\"uint256\"}],\"name\":\"setHomeFee\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_fee\",\"type\":\"uint256\"}],\"name\":\"distributeFeeFromSignatures\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"REWARD_FOR_TRANSFERRING_FROM_FOREIGN\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"REWARD_FOR_TRANSFERRING_FROM_HOME\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getHomeFee\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_recover\",\"type\":\"bool\"},{\"name\":\"_feeType\",\"type\":\"bytes32\"}],\"name\":\"calculateFee\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rewardableValidatorContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_count\",\"type\":\"uint256\"}],\"name\":\"random\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getFeeManagerMode\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes4\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getForeignFee\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"HomeFeeUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"ForeignFeeUpdated\",\"type\":\"event\"}]","ContractName":"FeeManagerNativeToErc","CompilerVersion":"v0.4.19+commit.c4cbbb05","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://ec6e3a680f324557a468dbd9551a921f8bb26047f45cdc3f2e200882d8b48332"}]}